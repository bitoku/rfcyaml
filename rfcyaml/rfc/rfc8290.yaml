- title: __initial_text__
  contents:
  - "               The Flow Queue CoDel Packet Scheduler and\n                  \
    \ Active Queue Management Algorithm\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo presents the FQ-CoDel hybrid packet scheduler and Active\n\
    \   Queue Management (AQM) algorithm, a powerful tool for fighting\n   bufferbloat\
    \ and reducing latency.\n   FQ-CoDel mixes packets from multiple flows and reduces\
    \ the impact of\n   head-of-line blocking from bursty traffic.  It provides isolation\
    \ for\n   low-rate traffic such as DNS, web, and videoconferencing traffic.  It\n\
    \   improves utilisation across the networking fabric, especially for\n   bidirectional\
    \ traffic, by keeping queue lengths short, and it can be\n   implemented in a\
    \ memory- and CPU-efficient fashion across a wide\n   range of hardware.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This document is a product of the Internet Engineering\n   Task Force (IETF).\
    \  It represents the consensus of the IETF\n   community.  It has received public\
    \ review and has been approved for\n   publication by the Internet Engineering\
    \ Steering Group (IESG).  Not\n   all documents approved by the IESG are a candidate\
    \ for any level of\n   Internet Standard; see Section 2 of RFC 7841.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8290.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2018 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   4\n     1.1.  Conventions Used in This Document . . . . . . . .\
    \ . . . .   4\n     1.2.  Terminology and Concepts  . . . . . . . . . . . . .\
    \ . . .   5\n     1.3.  Informal Summary of FQ-CoDel  . . . . . . . . . . . .\
    \ . .   5\n   2.  CoDel . . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ .   7\n   3.  Flow Queueing . . . . . . . . . . . . . . . . . . . . . . . .\
    \   7\n   4.  The FQ-CoDel Scheduler  . . . . . . . . . . . . . . . . . . .  \
    \ 8\n     4.1.  Enqueue . . . . . . . . . . . . . . . . . . . . . . . . .   8\n\
    \       4.1.1.  Alternative Classification Schemes  . . . . . . . . .   9\n  \
    \   4.2.  Dequeue . . . . . . . . . . . . . . . . . . . . . . . . .  10\n   5.\
    \  Implementation Considerations . . . . . . . . . . . . . . . .  11\n     5.1.\
    \  Data Structures . . . . . . . . . . . . . . . . . . . . .  11\n     5.2.  Parameters\
    \  . . . . . . . . . . . . . . . . . . . . . . .  12\n       5.2.1.  Interval\
    \  . . . . . . . . . . . . . . . . . . . . . .  12\n       5.2.2.  Target  . .\
    \ . . . . . . . . . . . . . . . . . . . . .  12\n       5.2.3.  Packet Limit \
    \ . . . . . . . . . . . . . . . . . . . .  13\n       5.2.4.  Quantum . . . .\
    \ . . . . . . . . . . . . . . . . . . .  13\n       5.2.5.  Flows . . . . . .\
    \ . . . . . . . . . . . . . . . . . .  13\n       5.2.6.  Explicit Congestion\
    \ Notification (ECN)  . . . . . . .  14\n       5.2.7.  CE Threshold  . . . .\
    \ . . . . . . . . . . . . . . . .  14\n     5.3.  Probability of Hash Collisions\
    \  . . . . . . . . . . . . .  14\n     5.4.  Memory Overhead . . . . . . . . .\
    \ . . . . . . . . . . . .  15\n     5.5.  Per-Packet Timestamping . . . . . .\
    \ . . . . . . . . . . .  16\n     5.6.  Limiting Queueing in Lower Layers . .\
    \ . . . . . . . . . .  16\n     5.7.  Other Forms of Fair Queueing  . . . . .\
    \ . . . . . . . . .  17\n     5.8.  Differences between CoDel and FQ-CoDel Behaviour\
    \  . . . .  17\n   6.  Limitations of Flow Queueing  . . . . . . . . . . . . .\
    \ . . .  18\n     6.1.  Fairness between Things Other Than Flows  . . . . . .\
    \ . .  18\n     6.2.  Flow Bunching by Opaque Encapsulation . . . . . . . . .\
    \ .  18\n     6.3.  Low-Priority Congestion Control Algorithms  . . . . . . .\
    \  19\n   7.  Deployment Status and Future Work . . . . . . . . . . . . . .  19\n\
    \   8.  Security Considerations . . . . . . . . . . . . . . . . . . .  20\n  \
    \ 9.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  21\n   10.\
    \ References  . . . . . . . . . . . . . . . . . . . . . . . . .  21\n     10.1.\
    \  Normative References . . . . . . . . . . . . . . . . . .  21\n     10.2.  Informative\
    \ References . . . . . . . . . . . . . . . . .  21\n   Acknowledgements  . . .\
    \ . . . . . . . . . . . . . . . . . . . . .  24\n   Authors' Addresses  . . .\
    \ . . . . . . . . . . . . . . . . . . . .  25\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The Flow Queue CoDel (FQ-CoDel) algorithm is a combined\
    \ packet\n   scheduler and Active Queue Management (AQM) [RFC3168] algorithm\n\
    \   developed as part of the bufferbloat-fighting community effort\n   [BLOATWEB].\
    \  It is based on a modified Deficit Round Robin (DRR)\n   queue scheduler [DRR]\
    \ [DRRPP] with the CoDel AQM [RFC8289] algorithm\n   operating on each queue.\
    \  This document describes the combined\n   algorithm; reference implementations\
    \ are available for the ns-2 [NS2]\n   and ns-3 [NS3] network simulators, and\
    \ the algorithm is included in\n   the mainline Linux kernel as the fq_codel queueing\
    \ discipline\n   [LINUXSRC].\n   FQ-CoDel is a general, efficient, nearly parameterless\
    \ queue\n   management approach combining flow queueing with CoDel.  It is a\n\
    \   powerful tool for solving bufferbloat [BLOAT] and has already been\n   turned\
    \ on by default in a number of Linux distributions.  In this\n   document, we\
    \ describe the Linux implementation in sufficient detail\n   for others to independently\
    \ implement the algorithm for deployment\n   outside the Linux ecosystem.\n  \
    \ Since the FQ-CoDel algorithm was originally developed in the Linux\n   kernel,\
    \ that implementation is still considered canonical.  This\n   document describes\
    \ the algorithm in the abstract in Sections 1-4 and\n   separates out most implementation\
    \ details in subsequent sections;\n   however, the Linux implementation is used\
    \ as a reference for default\n   behaviour in the abstract algorithm description.\n\
    \   This document is structured as follows.  This section gives some\n   concepts\
    \ and terminology used in the rest of the document and gives a\n   short informal\
    \ summary of the FQ-CoDel algorithm.  Section 2 gives an\n   overview of the CoDel\
    \ algorithm.  Section 3 covers the flow hashing\n   and DRR portion.  Section\
    \ 4 then describes the working of the\n   algorithm in detail, while Section 5\
    \ describes implementation details\n   and considerations.  Section 6 lists some\
    \ of the limitations of using\n   flow queueing.  Section 7 outlines the current\
    \ status of FQ-CoDel\n   deployment and lists some possible future areas of inquiry.\
    \  Finally,\n   Section 8 reiterates some important security points that must\
    \ be\n   observed in the implementation.\n"
- title: 1.1.  Conventions Used in This Document
  contents:
  - "1.1.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be\
    \ interpreted as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when,\
    \ they appear in all\n   capitals, as shown here.\n"
- title: 1.2.  Terminology and Concepts
  contents:
  - "1.2.  Terminology and Concepts\n   Flow:  A flow is typically identified by a\
    \ 5-tuple of source IP\n      address, destination IP address, source port number,\
    \ destination\n      port number, and protocol number.  It can also be identified\
    \ by a\n      superset or subset of those parameters, by Media Access Control\n\
    \      (MAC) address, or by other means.  FQ-CoDel hashes flows into a\n     \
    \ configurable number of buckets to assign packets to internal\n      queues.\n\
    \   Queue:  A queue of packets represented internally in FQ-CoDel.  In\n     \
    \ most instances, each flow gets its own queue; however, because of\n      the\
    \ possibility of hash collisions, this is not always the case.\n      In an attempt\
    \ to avoid confusion, the word \"queue\" is used to\n      refer to the internal\
    \ data structure, and \"flow\" is used to refer\n      to the actual stream of\
    \ packets being delivered to the FQ-CoDel\n      algorithm.\n   Scheduler:  A\
    \ mechanism to select which queue a packet is dequeued\n      from.\n   CoDel\
    \ AQM:  The Active Queue Management algorithm employed by\n      FQ-CoDel as described\
    \ in [RFC8289].\n   DRR:  Deficit Round Robin scheduling [DRR].\n   Quantum: \
    \ The maximum amount of bytes to be dequeued from a queue at\n      once.\n  \
    \ Interval:  Characteristic time period used by the control loop of\n      CoDel\
    \ to detect when a persistent queue is developing (see\n      Section 4.2 of [RFC8289]).\n\
    \   Target:  Setpoint value of the minimum sojourn time of packets in a\n    \
    \  queue used as the target of the control loop in CoDel (see\n      Section 4.3\
    \ of [RFC8289]).\n"
- title: 1.3.  Informal Summary of FQ-CoDel
  contents:
  - "1.3.  Informal Summary of FQ-CoDel\n   FQ-CoDel is a hybrid of DRR [DRR] and\
    \ CoDel [RFC8289], with an\n   optimisation for sparse flows similar to Shortest\
    \ Queue First (SQF)\n   [SQF] and DRR++ [DRRPP].  We call this \"flow queueing\"\
    \ rather than\n   \"fair queueing\", as flows that build a queue are treated differently\n\
    \   from flows that do not.\n   By default, FQ-CoDel stochastically classifies\
    \ incoming packets into\n   different queues by hashing the 5-tuple of protocol\
    \ number, source\n   and destination IP addresses, and source and destination\
    \ port\n   numbers, perturbed with a random number selected at initiation time\n\
    \   (although other flow classification schemes can optionally be\n   configured\
    \ instead; see Section 4.1.1).  Each queue is managed by the\n   CoDel AQM algorithm\
    \ [CODEL] [RFC8289].  Packet ordering within a\n   queue is preserved, since queues\
    \ have FIFO ordering.\n   The FQ-CoDel algorithm consists of two logical parts:\
    \ (1) the\n   scheduler, which selects which queue to dequeue a packet from, and\n\
    \   (2) the CoDel AQM, which works on each of the queues.  The subtleties\n  \
    \ of FQ-CoDel are mostly in the scheduling part, whereas the\n   interaction between\
    \ the scheduler and the CoDel algorithm are fairly\n   straightforward.\n   At\
    \ initialisation, each queue is set up to have a separate set of\n   CoDel state\
    \ variables.  By default, 1024 queues are created.  The\n   Linux implementation\
    \ at the time of writing supports anywhere from\n   one to 65535 separate queues,\
    \ and each queue maintains the state\n   variables throughout its lifetime, and\
    \ so acts the same as the non-FQ\n   variant of CoDel would.  This means that\
    \ with only one queue,\n   FQ-CoDel behaves essentially the same as CoDel by itself.\n\
    \   On dequeue, FQ-CoDel selects a queue from which to dequeue by a two-\n   tier,\
    \ round-robin scheme, in which each queue is allowed to dequeue\n   up to a configurable\
    \ quantum of bytes for each iteration.  Deviations\n   from this quantum are maintained\
    \ as byte credits for the queue, which\n   serves to make the fairness scheme\
    \ byte-based rather than packet-\n   based.  The two-tier, round-robin mechanism\
    \ distinguishes between\n   \"new\" queues (which don't build up a standing queue)\
    \ and \"old\" queues\n   (which have queued enough data to be active for more\
    \ than one\n   iteration of the round-robin scheduler).\n   This new/old queue\
    \ distinction has a particular consequence for\n   queues that don't build up\
    \ more than a quantum of bytes before being\n   visited by the scheduler: such\
    \ a queue will be removed from the list\n   after it empties and then re-added\
    \ as a new queue the next time a\n   packet arrives for it.  This means it will\
    \ effectively get priority\n   over queues that do not empty out each round (a\
    \ minor caveat is\n   required here to protect against starvation, see below).\
    \  Exactly how\n   little data a flow has to send to keep its queue in this state\
    \ is\n   somewhat difficult to reason about, because it depends on both the\n\
    \   egress link speed and the number of concurrent flows.  However, in\n   practice,\
    \ many things that are beneficial to have prioritised for\n   typical internet\
    \ use (ACKs, DNS lookups, interactive Secure Shell\n   (SSH), HTTP requests, Voice\
    \ over IP (VoIP)) _tend_ to fall in this\n   category, which is why FQ-CoDel performs\
    \ so well for many practical\n   applications.  However, the implicitness of the\
    \ prioritisation means\n   that for applications that require guaranteed priority\
    \ (for instance,\n   multiplexing the network control plane over the network itself),\n\
    \   explicit classification is still needed.\n   This scheduling scheme has some\
    \ subtlety to it, which is explained in\n   detail in the remainder of this document.\n"
- title: 2.  CoDel
  contents:
  - "2.  CoDel\n   CoDel is described in the Communications of the ACM paper [CODEL]\
    \ and\n   the IETF document [RFC8289].  The basic idea is to control queue\n \
    \  length, maintaining sufficient queueing to keep the outgoing link\n   busy\
    \ but avoiding building up the queue beyond that point.  This is\n   done by preferentially\
    \ dropping packets that remain in the queue for\n   \"too long\".  Packets are\
    \ dropped by head drop, which lowers the time\n   for the drop signal to propagate\
    \ back to the sender by the length of\n   the queue and helps trigger TCP fast\
    \ retransmit sooner.\n   The CoDel algorithm itself will not be described here;\
    \ instead, we\n   refer the reader to the CoDel document [RFC8289].\n"
- title: 3.  Flow Queueing
  contents:
  - "3.  Flow Queueing\n   The intention of FQ-CoDel's scheduler is to give each flow\
    \ its own\n   queue, hence the term \"flow queueing\".  Rather than a perfect\n\
    \   realisation of this, a hashing-based scheme is used, where flows are\n   hashed\
    \ into a number of buckets, each of which has its own queue.\n   The number of\
    \ buckets is configurable and presently defaults to 1024\n   in the Linux implementation.\
    \  This is enough to avoid hash collisions\n   on a moderate number of flows as\
    \ seen, for instance, in a home\n   gateway.  Depending on the characteristics\
    \ of the link, this can be\n   tuned to trade off memory for a lower probability\
    \ of hash collisions.\n   See Sections 5.3 and 5.4 for a more in-depth discussion\
    \ of this.\n   By default, the flow hashing is performed on the 5-tuple of source\n\
    \   and destination IP addresses, source and destination port numbers,\n   and\
    \ protocol number.  While the hashing can be customised to match on\n   arbitrary\
    \ packet bytes, care should be taken when doing so; much of\n   the benefit of\
    \ the FQ-CoDel scheduler comes from this per-flow\n   distinction.  However, the\
    \ default hashing does have some\n   limitations, as discussed in Section 6.\n\
    \   FQ-CoDel's DRR scheduler is byte-based, employing a deficit round-\n   robin\
    \ mechanism between queues.  This works by keeping track of the\n   current number\
    \ of \"byte credits\" of each queue.  This number is\n   initialised to the configurable\
    \ quantum; each time a queue gets a\n   dequeue opportunity, it gets to dequeue\
    \ packets, thus decreasing the\n   number of credits by the packet size for each\
    \ packet.  This continues\n   until the value of the byte credits counter becomes\
    \ zero or less, at\n   which point the counter is increased by one quantum, and\
    \ the dequeue\n   opportunity ends.\n   This means that if one queue contains\
    \ packets of, for instance, size\n   quantum/3, and another contains quantum-sized\
    \ packets, the first\n   queue will dequeue three packets each time it gets a\
    \ turn, whereas\n   the second only dequeues one.  This means that flows that\
    \ send small\n   packets are not penalised by the difference in packet sizes;\
    \ rather,\n   the DRR scheme approximates a byte-based fairness queueing scheme.\n\
    \   The size of the quantum determines the scheduling granularity, with\n   the\
    \ trade-off from too small a quantum being scheduling overhead.\n   For small\
    \ bandwidths, lowering the quantum from the default MTU size\n   can be advantageous.\n\
    \   Unlike plain DRR, there are two sets of flows: a \"new\" list for flows\n\
    \   that have not built a queue recently and an \"old\" list for queues\n   that\
    \ build a backlog.  This distinction is an integral part of the\n   FQ-CoDel scheduler\
    \ and is described in more detail in Section 4.\n"
- title: 4.  The FQ-CoDel Scheduler
  contents:
  - "4.  The FQ-CoDel Scheduler\n   To make its scheduling decisions, FQ-CoDel maintains\
    \ two ordered\n   lists of active queues: new and old queues.  When a packet is\
    \ added\n   to a queue that is not currently active, that queue becomes active\
    \ by\n   being added to the list of new queues.  Later on, it is moved to the\n\
    \   list of old queues, from which it is removed when it is no longer\n   active.\
    \  This behaviour is the source of some subtlety in the packet\n   scheduling\
    \ at dequeue time, as explained below.\n"
- title: 4.1.  Enqueue
  contents:
  - "4.1.  Enqueue\n   The packet enqueue mechanism consists of three stages: classifying\n\
    \   into a queue, timestamping and bookkeeping, and optionally dropping a\n  \
    \ packet when the total number of enqueued packets goes over the\n   maximum.\n\
    \   When a packet is enqueued, it is first classified into the\n   appropriate\
    \ queue.  By default, this is done by hashing (using a\n   Jenkins hash function\
    \ [JENKINS]) on the 5-tuple of IP protocol,\n   source and destination IP addresses,\
    \ and source and destination port\n   numbers (if they exist) and then taking\
    \ the hash value modulo the\n   number of queues.  The hash is salted by modulo\
    \ addition of a random\n   value selected at initialisation time to prevent possible\
    \ DoS attacks\n   if the hash is predictable ahead of time (see Section 8).  The\
    \ Linux\n   kernel implements the Jenkins hash function by mixing three 32-bit\n\
    \   values into a single 32-bit output value.  Inputs larger than 96 bits\n  \
    \ are reduced by additional mixing steps, 96 bits at a time.\n   Once the packet\
    \ has been successfully classified into a queue, it is\n   handed over to the\
    \ CoDel algorithm for timestamping.  It is then\n   added to the tail of the selected\
    \ queue, and the queue's byte count\n   is updated by the packet size.  Then,\
    \ if the queue is not currently\n   active (i.e., if it is not in either the list\
    \ of new queues or the\n   list of old queues), it is added to the end of the\
    \ list of new\n   queues, and its number of credits is initiated to the configured\n\
    \   quantum.  Otherwise, the queue is left in its current queue list.\n   Finally,\
    \ to protect against overload, the total number of enqueued\n   packets is compared\
    \ with the configured limit.  If the limit is\n   exceeded (which can happen since\
    \ a packet was just enqueued), the\n   queue with the largest current byte count\
    \ is selected and half the\n   number of packets from this queue (up to a maximum\
    \ of 64 packets) are\n   dropped from the head of that queue.  Dropping several\
    \ packets at\n   once helps amortise the cost of finding the longest queue,\n\
    \   significantly lowering CPU usage in an overload situation.\n"
- title: 4.1.1.  Alternative Classification Schemes
  contents:
  - "4.1.1.  Alternative Classification Schemes\n   As mentioned previously, it is\
    \ possible to modify the classification\n   scheme to provide a different notion\
    \ of a flow.  The Linux\n   implementation provides this option in the form of\
    \ the \"tc filter\"\n   command.  While this can add capabilities (for instance,\
    \ matching on\n   other possible parameters such as MAC address, Diffserv code\
    \ point\n   values, firewall rules, flow-specific markings, IPv6 flow label,\n\
    \   etc.), care should be taken to preserve the notion of flow because\n   much\
    \ of the benefit of the FQ-CoDel scheduler comes from keeping\n   flows in separate\
    \ queues.\n   For protocols that do not contain a port number (such as ICMP),\
    \ the\n   Linux implementation simply sets the port numbers to zero and\n   performs\
    \ the hashing as usual.  In practice, this results in such\n   protocols each\
    \ getting their own queue (except in the case of hash\n   collisions).  An implementation\
    \ can perform other classifications for\n   protocols that have their own notion\
    \ of a flow but SHOULD fall back\n   to simply hashing on source and destination\
    \ IP address and protocol\n   number in the absence of other information.\n  \
    \ The default classification scheme can additionally be improved by\n   performing\
    \ decapsulation of tunnelled packets prior to hashing on the\n   5-tuple in the\
    \ encapsulated payload.  The Linux implementation does\n   this for common encapsulations\
    \ known to the kernel, such as 6in4\n   [RFC4213], IP-in-IP [RFC2003], and Generic\
    \ Routing Encapsulation\n   (GRE) [RFC2890].  This helps to distinguish between\
    \ flows that share\n   the same (outer) 5-tuple but, of course, is limited to\
    \ unencrypted\n   tunnels (see Section 6.2 for a discussion of encrypted tunnels).\n"
- title: 4.2.  Dequeue
  contents:
  - "4.2.  Dequeue\n   Most of FQ-CoDel's work is done at packet dequeue time.  It\
    \ consists\n   of three parts: selecting a queue from which to dequeue a packet,\n\
    \   actually dequeueing it (employing the CoDel algorithm in the\n   process),\
    \ and some final bookkeeping.\n   For the first part, the scheduler first looks\
    \ at the list of new\n   queues; for the queue at the head of that list, if that\
    \ queue has a\n   negative number of credits (i.e., it has already dequeued at\
    \ least a\n   quantum of bytes), it is given an additional quantum of credits,\
    \ the\n   queue is put onto _the end of_ the list of old queues, and the\n   routine\
    \ selects the next queue and starts again.\n   Otherwise, that queue is selected\
    \ for dequeue.  If the list of new\n   queues is empty, the scheduler proceeds\
    \ down the list of old queues\n   in the same fashion (checking the credits and\
    \ either selecting the\n   queue for dequeueing or adding credits and putting\
    \ the queue back at\n   the end of the list).\n   After having selected a queue\
    \ from which to dequeue a packet, the\n   CoDel algorithm is invoked on that queue.\
    \  This applies the CoDel\n   control law, which is the mechanism CoDel uses to\
    \ determine when to\n   drop packets (see [RFC8289]).  As a result of this, one\
    \ or more\n   packets may be discarded from the head of the selected queue before\n\
    \   the packet that should be dequeued is returned (or nothing is\n   returned\
    \ if the queue is or becomes empty while being handled by the\n   CoDel algorithm).\n\
    \   Finally, if the CoDel algorithm does not return a packet, then the\n   queue\
    \ must be empty, and the scheduler does one of two things.  If\n   the queue selected\
    \ for dequeue came from the list of new queues, it\n   is moved to _the end of_\
    \ the list of old queues.  If instead it came\n   from the list of old queues,\
    \ that queue is removed from the list, to\n   be added back (as a new queue) the\
    \ next time a packet arrives that\n   hashes to that queue.  Then (since no packet\
    \ was available for\n   dequeue), the whole dequeue process is restarted from\
    \ the beginning.\n   If, instead, the scheduler _did_ get a packet back from the\
    \ CoDel\n   algorithm, it subtracts the size of the packet from the byte credits\n\
    \   for the selected queue and returns the packet as the result of the\n   dequeue\
    \ operation.\n   The step that moves an empty queue from the list of new queues\
    \ to the\n   end of the list of old queues before it is removed is crucial to\n\
    \   prevent starvation.  Otherwise, the queue could reappear (the next\n   time\
    \ a packet arrives for it) before the list of old queues is\n   visited; this\
    \ can go on indefinitely, even with a small number of\n   active flows, if the\
    \ flow providing packets to the queue in question\n   transmits at just the right\
    \ rate.  This is prevented by first moving\n   the queue to the end of the list\
    \ of old queues, forcing the scheduler\n   to service all old queues before the\
    \ empty queue is removed and thus\n   preventing starvation.\n   The resulting\
    \ migration of queues between the different states is\n   summarised in the state\
    \ diagram shown in Figure 1.  Note that both\n   the new and old queue states\
    \ can additionally have arrival and\n   dequeue events that do not change the\
    \ state; these are omitted in the\n   figure.\n   +-----------------+        \
    \        +------------------+\n   |                 |     Empty      |       \
    \           |\n   |     Empty       |<---------------+       Old        +----+\n\
    \   |                 |                |                  |    |\n   +-------+---------+\
    \                +------------------+    |\n           |                     \
    \        ^            ^       |Credits\n           |Arrival                  \
    \    |            |       |Exhausted\n           v                           \
    \  |            |       |\n   +-----------------+                   |        \
    \    |       |\n   |                 |      Empty or     |            |      \
    \ |\n   |      New        +-------------------+            +-------+\n   |   \
    \              | Credits Exhausted\n   +-----------------+\n   Figure 1: Partial\
    \ State Diagram for Queues between Different States\n"
- title: 5.  Implementation Considerations
  contents:
  - "5.  Implementation Considerations\n   This section contains implementation details\
    \ for the FQ-CoDel\n   algorithm.  This includes the data structures and parameters\
    \ used in\n   the Linux implementation, as well as discussion of some required\n\
    \   features of the target platform and other considerations.\n"
- title: 5.1.  Data Structures
  contents:
  - "5.1.  Data Structures\n   The main data structure of FQ-CoDel is the array of\
    \ queues, which is\n   instantiated with the number of queues specified by the\
    \ \"flows\"\n   parameter at instantiation time.  Each queue consists simply of\
    \ an\n   ordered list of packets with FIFO semantics, two state variables\n  \
    \ tracking the queue credits and total number of bytes enqueued, and\n   the set\
    \ of CoDel state variables.  Other state variables to track\n   queue statistics\
    \ can also be included; for instance, the Linux\n   implementation keeps a count\
    \ of dropped packets.\n   In addition to the queue structures themselves, FQ-CoDel\
    \ maintains\n   two ordered lists containing references to the subset of queues\
    \ that\n   are currently active.  These are the lists of new and old queues, as\n\
    \   explained in Section 4 above.\n   In the Linux implementation, queue space\
    \ is shared: there's a global\n   limit on the number of packets the queues can\
    \ hold, but not a limit\n   for each queue.\n"
- title: 5.2.  Parameters
  contents:
  - "5.2.  Parameters\n   The following are the user configuration parameters exposed\
    \ by the\n   Linux implementation of FQ-CoDel.\n"
- title: 5.2.1.  Interval
  contents:
  - "5.2.1.  Interval\n   The \"interval\" parameter has the same semantics as CoDel\
    \ and is used\n   to ensure that the minimum sojourn time of packets in a queue\
    \ used as\n   an estimator by the CoDel control algorithm is a relatively up-to-\n\
    \   date value.  That is, CoDel only reacts to delay experienced in the\n   last\
    \ epoch of length interval.  It SHOULD be set to be on the order\n   of the worst-case\
    \ RTT through the bottleneck to give end points\n   sufficient time to react.\n\
    \   The default interval value is 100 ms.\n"
- title: 5.2.2.  Target
  contents:
  - "5.2.2.  Target\n   The \"target\" parameter has the same semantics as CoDel.\
    \  It is the\n   acceptable minimum standing/persistent queue delay for each FQ-CoDel\n\
    \   queue.  This minimum delay is identified by tracking the local\n   minimum\
    \ queue delay that packets experience.\n   The default target value is 5 ms, but\
    \ this value should be tuned to\n   be at least the transmission time of a single\
    \ MTU-sized packet at the\n   prevalent egress link speed (which, for example,\
    \ is ~15 ms for 1 Mbps\n   and MTU 1500).  This prevents CoDel from being too\
    \ aggressive at low\n   bandwidths.  It should otherwise be set to 5-10% of the\
    \ configured\n   interval.\n"
- title: 5.2.3.  Packet Limit
  contents:
  - "5.2.3.  Packet Limit\n   Routers do not have infinite memory, so some packet\
    \ limit MUST be\n   enforced.\n   The \"limit\" parameter is the hard limit on\
    \ the real queue size,\n   measured in number of packets.  This limit is a global\
    \ limit on the\n   number of packets in all queues; each individual queue does\
    \ not have\n   an upper limit.  When the limit is reached and a new packet arrives\n\
    \   for enqueue, packets are dropped from the head of the largest queue\n   (measured\
    \ in bytes) to make room for the new packet.\n   In Linux, the default packet\
    \ limit is 10240 packets, which is\n   suitable for up to 10-Gigabit Ethernet\
    \ speeds.  In practice, the hard\n   limit is rarely (if ever) hit, as drops are\
    \ performed by the CoDel\n   algorithm long before the limit is hit.  For platforms\
    \ that are\n   severely memory constrained, a lower limit can be used.\n"
- title: 5.2.4.  Quantum
  contents:
  - "5.2.4.  Quantum\n   The \"quantum\" parameter is the number of bytes each queue\
    \ gets to\n   dequeue on each round of the scheduling algorithm.  The default\
    \ is\n   set to 1514 bytes, which corresponds to the Ethernet MTU plus the\n \
    \  hardware header length of 14 bytes.\n   In systems employing TCP Segmentation\
    \ Offload (TSO), where a \"packet\"\n   consists of an offloaded packet train,\
    \ it can presently be as large\n   as 64 kilobytes.  In systems using Generic\
    \ Receive Offload (GRO),\n   they can be up to 17 times the TCP max segment size\
    \ (or 25\n   kilobytes).  These mega-packets severely impact FQ-CoDel's ability\
    \ to\n   schedule traffic, and they hurt latency needlessly.  There is ongoing\n\
    \   work in Linux to make smarter use of offload engines.\n"
- title: 5.2.5.  Flows
  contents:
  - "5.2.5.  Flows\n   The \"flows\" parameter sets the number of queues into which\
    \ the\n   incoming packets are classified.  Due to the stochastic nature of\n\
    \   hashing, multiple flows may end up being hashed into the same slot.\n   This\
    \ parameter can be set only at initialisation time in the current\n   implementation,\
    \ since memory has to be allocated for the hash table.\n   The default value is\
    \ 1024 in the current Linux implementation.\n"
- title: 5.2.6.  Explicit Congestion Notification (ECN)
  contents:
  - "5.2.6.  Explicit Congestion Notification (ECN)\n   ECN [RFC3168] is enabled by\
    \ default.  Rather than do anything special\n   with misbehaved ECN flows, FQ-CoDel\
    \ relies on the packet scheduling\n   system to minimise their impact; thus, the\
    \ number of unresponsive\n   packets in a flow being marked with ECN can grow\
    \ to the overall\n   packet limit but will not otherwise affect the performance\
    \ of the\n   system.\n   ECN can be disabled by specifying the \"noecn\" parameter.\n"
- title: 5.2.7.  CE Threshold
  contents:
  - "5.2.7.  CE Threshold\n   This parameter enables DCTCP-like processing resulting\
    \ in Congestion\n   Encountered (CE) marking on ECN-Capable Transport (ECT) packets\n\
    \   [RFC3168] starting at a lower sojourn delay setpoint than the default\n  \
    \ CoDel target.  Details of Data Center TCP (DCTCP) can be found in\n   [RFC8257].\n\
    \   The \"ce_threshold\" parameter is disabled by default; it can be\n   enabled\
    \ by setting it to a number of microseconds.\n"
- title: 5.3.  Probability of Hash Collisions
  contents:
  - "5.3.  Probability of Hash Collisions\n   Since the Linux FQ-CoDel implementation\
    \ by default uses 1024 hash\n   buckets, the probability that (say) 100 flows\
    \ will all hash to the\n   same bucket is something like ten to the power of minus\
    \ 300.  Thus,\n   at least one of the flows will almost certainly hash to some\
    \ other\n   queue.\n   Expanding on this, based on analytical equations for hash\
    \ collision\n   probabilities, for 100 flows, the probability of no collision\
    \ is\n   90.78%; the probability that no more than two of the 100 flows will\n\
    \   be involved in any given collision is 99.57%; and the probability\n   that\
    \ no more than three of the 100 flows will be involved in any\n   given collision\
    \ is 99.99%.  These probabilities assume a hypothetical\n   perfect hashing function,\
    \ so in practice, they may be a bit lower.\n   We have not found this difference\
    \ to matter in practice.\n   These probabilities can be improved upon by using\
    \ set-associative\n   hashing, a technique used in the Cake algorithm currently\
    \ being\n   developed as a further refinement of the FQ-CoDel principles [CAKE].\n\
    \   For a 4-way associative hash with the same number of total queues,\n   the\
    \ probability of no collisions for 100 flows is 99.93%, while for\n   an 8-way\
    \ associative hash, it is ~100%.\n"
- title: 5.4.  Memory Overhead
  contents:
  - "5.4.  Memory Overhead\n   FQ-CoDel can be implemented with a low memory footprint\
    \ (less than 64\n   bytes per queue on 64-bit systems).  These are the data structures\n\
    \   used in the Linux implementation:\n   <CODE BEGINS>\n   struct codel_vars\
    \ {\n      u32             count;             /* number of dropped packets */\n\
    \      u32             lastcount;     /* count entry to dropping state */\n  \
    \    bool            dropping;                /* currently dropping? */\n    \
    \  u16             rec_inv_sqrt;    /* reciprocal sqrt computation */\n      codel_time_t\
    \    first_above_time;    /* when delay above target */\n      codel_time_t  \
    \  drop_next;                 /* next time to drop */\n      codel_time_t    ldelay;\
    \ /* sojourn time of last dequeued packet */\n   };\n   struct fq_codel_flow {\n\
    \      struct sk_buff    *head;\n      struct sk_buff    *tail;\n      struct\
    \ list_head  flowchain;\n      int               credits;   /* current number\
    \ of queue credits */\n      u32               dropped; /* # of drops (or ECN\
    \ marks) on flow */\n      struct codel_vars cvars;\n   };\n   <CODE ENDS>\n \
    \  The master table managing all queues looks like this:\n   <CODE BEGINS>\n \
    \  struct fq_codel_sched_data {\n      struct tcf_proto *filter_list;  /* optional\
    \ external classifier */\n      struct fq_codel_flow *flows;    /* Flows table\
    \ [flows_cnt] */\n      u32             *backlogs;      /* backlog table [flows_cnt]\
    \ */\n      u32             flows_cnt;      /* number of flows */\n      u32 \
    \            perturbation;   /* hash perturbation */\n      u32             quantum;\
    \        /* psched_mtu(qdisc_dev(sch)); */\n      struct codel_params cparams;\n\
    \      struct codel_stats cstats;\n      u32             drop_overlimit;\n   \
    \   u32             new_flow_count;\n      struct list_head new_flows;     /*\
    \ list of new flows */\n      struct list_head old_flows;     /* list of old flows\
    \ */\n   };\n   <CODE ENDS>\n"
- title: 5.5.  Per-Packet Timestamping
  contents:
  - "5.5.  Per-Packet Timestamping\n   The CoDel portion of the algorithm requires\
    \ per-packet timestamps be\n   stored along with the packet.  While this approach\
    \ works well for\n   software-based routers, it may be impossible to retrofit\
    \ devices that\n   do most of their processing in silicon and lack the space or\n\
    \   mechanism for timestamping.\n   Also, while perfect resolution is not needed,\
    \ timestamp resolution\n   finer than the CoDel target setting is necessary. \
    \ Furthermore,\n   timestamping functions in the core OS need to be efficient,\
    \ as they\n   are called at least once on each packet enqueue and dequeue.\n"
- title: 5.6.  Limiting Queueing in Lower Layers
  contents:
  - "5.6.  Limiting Queueing in Lower Layers\n   When deploying a queue management\
    \ algorithm such as FQ-CoDel, it is\n   important to ensure that the algorithm\
    \ actually runs in the right\n   place to control the queue.  In particular, lower\
    \ layers of the\n   operating system networking stack can have queues of their\
    \ own, as\n   can device drivers and hardware.  Thus, it is desirable that the\n\
    \   queue management algorithm runs as close to the hardware as possible.\n  \
    \ However, scheduling such complexity at interrupt time is difficult,\n   so a\
    \ small standing queue between the algorithm and the wire is often\n   needed\
    \ at higher transmit rates.\n   In Linux, the mechanism to ensure these different\
    \ needs are balanced\n   is called \"Byte Queue Limits\" [BQL]; it controls the\
    \ device driver\n   ring buffer (for physical line rates).  For cases where this\n\
    \   functionality is not available, the queue can be controlled by means\n   of\
    \ a software rate limiter such as Hierarchical Token Bucket [HTB] or\n   Hierarchical\
    \ Fair-Service Curve [HFSC].  The Cake algorithm [CAKE]\n   integrates a software\
    \ rate limiter for this purpose.\n   Other issues with queues at lower layers\
    \ are described in [CODEL].\n"
- title: 5.7.  Other Forms of Fair Queueing
  contents:
  - "5.7.  Other Forms of Fair Queueing\n   Much of the scheduling portion of FQ-CoDel\
    \ is derived from DRR and is\n   substantially similar to DRR++.  Versions based\
    \ on Stochastic Fair\n   Queueing [SFQ] have also been produced and tested in\
    \ ns2.  Other\n   forms of fair queueing, such as Weighted Fair Queueing [WFQ]\
    \ or Quick\n   Fair Queueing [QFQ], have not been thoroughly explored, but there's\n\
    \   no a priori reason why the round-robin scheduling of FQ-CoDel\n   couldn't\
    \ be replaced with something else.\n   For a comprehensive discussion of fairness\
    \ queueing algorithms and\n   their combination with AQM, see [RFC7806].\n"
- title: 5.8.  Differences between CoDel and FQ-CoDel Behaviour
  contents:
  - "5.8.  Differences between CoDel and FQ-CoDel Behaviour\n   CoDel can be applied\
    \ to a single queue system as a straight AQM,\n   where it converges towards an\
    \ \"ideal\" drop rate (i.e., one that\n   minimises delay while keeping a high\
    \ link utilisation) and then\n   optimises around that control point.\n   The\
    \ scheduling of FQ-CoDel mixes packets of competing flows, which\n   acts to pace\
    \ bursty flows to better fill the pipe.  Additionally, a\n   new flow gets substantial\
    \ leeway over other flows until CoDel finds\n   an ideal drop rate for it.  However,\
    \ for a new flow that exceeds the\n   configured quantum, more time passes before\
    \ all of its data is\n   delivered (as packets from it, too, are mixed across\
    \ the other\n   existing queue-building flows).  Thus, FQ-CoDel takes longer (as\n\
    \   measured in time) to converge towards an ideal drop rate for a given\n   new\
    \ flow but does so within fewer delivered _packets_ from that flow.\n   Finally,\
    \ the flow isolation provided by FQ-CoDel means that the CoDel\n   drop mechanism\
    \ operates on the flows actually building queues; this\n   results in packets\
    \ being dropped more accurately from the largest\n   flows than when only CoDel\
    \ is used.  Additionally, flow isolation\n   radically improves the transient\
    \ behaviour of the network when\n   traffic or link characteristics change (e.g.,\
    \ when new flows start up\n   or the link bandwidth changes); while CoDel itself\
    \ can take a while\n   to respond, FQ-CoDel reacts almost immediately.\n"
- title: 6.  Limitations of Flow Queueing
  contents:
  - "6.  Limitations of Flow Queueing\n   While FQ-CoDel has been shown in many scenarios\
    \ to offer significant\n   performance gains compared to alternative queue management\n\
    \   strategies, there are some scenarios where the scheduling algorithm\n   in\
    \ particular is not a good fit.  This section documents some of the\n   known\
    \ cases in which either the default behaviour may require\n   tweaking or alternatives\
    \ to flow queueing should be considered.\n"
- title: 6.1.  Fairness between Things Other Than Flows
  contents:
  - "6.1.  Fairness between Things Other Than Flows\n   In some parts of the network,\
    \ enforcing flow-level fairness may not\n   be desirable, or some other form of\
    \ fairness may be more important.\n   Some examples of this include an ISP that\
    \ may be more interested in\n   ensuring fairness between customers than between\
    \ flows or a hosting\n   or transit provider that wishes to ensure fairness between\
    \ connecting\n   Autonomous Systems or networks.  Another issue can be that the\
    \ number\n   of simultaneous flows experienced at a particular link can be too\n\
    \   high for flow-based fairness queueing to be effective.\n   Whatever the reason,\
    \ in a scenario where fairness between flows is\n   not desirable, reconfiguring\
    \ FQ-CoDel to match on a different\n   characteristic can be a way forward.  The\
    \ implementation in Linux can\n   leverage the packet matching mechanism of the\
    \ \"tc\" subsystem to use\n   any available packet field to partition packets\
    \ into virtual queues,\n   for instance, to match on address or subnet source/destination\
    \ pairs,\n   application-layer characteristics, etc.\n   Furthermore, as commonly\
    \ deployed today, FQ-CoDel is used with three\n   or more tiers of service classification,\
    \ based on Diffserv markings:\n   priority, best effort, and background.  Some\
    \ products do more\n   detailed classification, including deep packet inspection\
    \ and\n   destination-specific filters to achieve their desired result.\n"
- title: 6.2.  Flow Bunching by Opaque Encapsulation
  contents:
  - "6.2.  Flow Bunching by Opaque Encapsulation\n   Where possible, FQ-CoDel will\
    \ attempt to decapsulate packets before\n   matching on the header fields for\
    \ the flow hashing.  However, for\n   some encapsulation techniques, most notably\
    \ encrypted VPNs, this is\n   not possible.  If several flows are bunched into\
    \ one such\n   encapsulated tunnel, they will be seen as one flow by the FQ-CoDel\n\
    \   algorithm.  This means that they will share a queue and drop\n   behaviour,\
    \ so flows inside the encapsulation will not benefit from\n   the implicit prioritisation\
    \ of FQ-CoDel but will continue to benefit\n   from the reduced overall queue\
    \ length from the CoDel algorithm\n   operating on the queue.  In addition, when\
    \ such an encapsulated bunch\n   competes against other flows, it will count as\
    \ one flow and not\n   assigned a share of the bandwidth based on how many flows\
    \ are inside\n   the encapsulation.\n   Depending on the application, this may\
    \ or may not be desirable\n   behaviour.  In cases where it is not, changing FQ-CoDel's\
    \ matching to\n   not be flow-based (as detailed in the previous subsection above)\
    \ can\n   be a mitigation.  Going forward, having some mechanism for opaque\n\
    \   encapsulations to express to the outer layer which flow a packet\n   belongs\
    \ to could be a way to mitigate this.  Naturally, care needs to\n   be taken when\
    \ designing such a mechanism to ensure no new privacy and\n   security issues\
    \ are raised by exposing information from inside the\n   encapsulation to the\
    \ outside world.  Keeping the extra information\n   out of band and dropping it\
    \ before it hits the network could be one\n   way to achieve this.\n"
- title: 6.3.  Low-Priority Congestion Control Algorithms
  contents:
  - "6.3.  Low-Priority Congestion Control Algorithms\n   In the presence of queue\
    \ management schemes that limit latency under\n   load, low-priority congestion\
    \ control algorithms such as Low Extra\n   Delay Background Transport (LEDBAT)\
    \ [RFC6817] (or, in general,\n   algorithms that try to voluntarily use up less\
    \ than their fair share\n   of bandwidth) experience little added latency when\
    \ the link is\n   congested.  Thus, they lack the signal to back off that added\
    \ latency\n   previously afforded them.  This effect is seen with FQ-CoDel as\
    \ well\n   as with any effective AQM [GONG2014].\n   As such, these delay-based\
    \ algorithms tend to revert to loss-based\n   congestion control and will consume\
    \ the fair share of bandwidth\n   afforded to them by the FQ-CoDel scheduler.\
    \  However, low-priority\n   congestion control mechanisms may be able to take\
    \ steps to continue\n   to be low priority, for instance, by taking into account\
    \ the vastly\n   reduced level of delay afforded by an AQM or by using a coupled\n\
    \   approach to observing the behaviour of multiple flows.\n"
- title: 7.  Deployment Status and Future Work
  contents:
  - "7.  Deployment Status and Future Work\n   The FQ-CoDel algorithm as described\
    \ in this document has been shipped\n   as part of the Linux kernel since version\
    \ 3.5 (released on the 21st\n   of July, 2012), with the ce_threshold being added\
    \ in version 4.2.\n   The algorithm has seen widespread testing in a variety of\
    \ contexts\n   and is configured as the default queueing discipline in a number\
    \ of\n   mainline Linux distributions (as of this writing, at least OpenWRT,\n\
    \   Arch Linux, and Fedora).  In addition, a BSD implementation is\n   available.\
    \  All data resulting from these trials have shown FQ-CoDel\n   to be a massive\
    \ improvement over the previous default FIFO queue, and\n   people are encouraged\
    \ to turn it on.\n   Of course, there is always room for improvement, and this\
    \ document\n   has listed some of the known limitations of the algorithm.  As\
    \ such,\n   we encourage further research into algorithm refinements and\n   addressing\
    \ of limitations.  One such effort has been undertaken by\n   the bufferbloat\
    \ community in the form of the Cake queue management\n   scheme [CAKE].  In addition\
    \ to this, we believe the following\n   (non-exhaustive) list of issues to be\
    \ worthy of further enquiry:\n   o  Variations on the flow classification mechanism\
    \ to fit different\n      notions of flows.  For instance, an ISP might want to\
    \ deploy per-\n      subscriber scheduling, while in other cases, several flows\
    \ can\n      share a 5-tuple, as exemplified by the RTCWEB QoS recommendations\n\
    \      [WEBRTC-QOS].\n   o  Interactions between flow queueing and delay-based\
    \ congestion\n      control algorithms and scavenger protocols.\n   o  Other scheduling\
    \ mechanisms to replace the DRR portion of the\n      algorithm, e.g., QFQ or\
    \ WFQ.\n   o  Sensitivity of parameters, most notably, the number of queues and\n\
    \      the CoDel parameters.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   There are no specific security exposures associated\
    \ with FQ-CoDel\n   that are not also present in current FIFO systems.  On the\
    \ contrary,\n   some vulnerabilities of FIFO systems are reduced with FQ-CoDel\
    \ (e.g.,\n   simple minded packet floods).  However, some care is needed in the\n\
    \   implementation to ensure this is the case.  These are included in the\n  \
    \ description above, but we reiterate them here:\n   o  To prevent packets in\
    \ the new queues from starving old queues, it\n      is important that when a\
    \ queue on the list of new queues empties,\n      it is moved to _the end of_\
    \ the list of old queues.  This is\n      described at the end of Section 4.2.\n\
    \   o  To prevent an attacker targeting a specific flow for a denial-of-\n   \
    \   service attack, the hash that maps packets to queues should not be\n     \
    \ predictable.  To achieve this, FQ-CoDel salts the hash, as\n      described\
    \ in the beginning of Section 4.1.  The size of the salt\n      and the strength\
    \ of the hash function is obviously a trade-off\n      between performance and\
    \ security.  The Linux implementation uses a\n      32-bit random value as the\
    \ salt and a Jenkins hash function.  This\n      makes it possible to achieve\
    \ high throughput, and we consider it\n      sufficient to ward off the most obvious\
    \ attacks.\n   o  Packet fragments without a Layer 4 header can be hashed into\n\
    \      different bins than the first fragment with the header intact.\n      This\
    \ can cause reordering and/or adversely affect the performance\n      of the flow.\
    \  Keeping state to match the fragments to the\n      beginning of the packet\
    \ or simply putting all packet fragments\n      (including the first fragment\
    \ of each fragmented packet) into the\n      same queue are two ways to alleviate\
    \ this.\n"
- title: 9.  IANA Considerations
  contents:
  - "9.  IANA Considerations\n   This document does not require any IANA actions.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n  \
    \            DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC7806]  Baker, F. and R. Pan, \"On Queuing, Marking, and Dropping\",\n\
    \              RFC 7806, DOI 10.17487/RFC7806, April 2016,\n              <https://www.rfc-editor.org/info/rfc7806>.\n\
    \   [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n     \
    \         2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n        \
    \      May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8289]  Nichols,\
    \ K., Jacobson, V., McGregor, A., Ed., and J.\n              Iyengar, Ed., \"\
    Controlled Delay Active Queue Management\",\n              RFC 8289, DOI 10.17487/RFC8289,\
    \ January 2018,\n              <https://www.rfc-editor.org/info/rfc8289>.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [BLOAT]    Gettys, J. and K. Nichols, \"Bufferbloat:\
    \ Dark Buffers in\n              the Internet\", Communications of the ACM, Volume\
    \ 55, Issue\n              1, DOI 10.1145/2063176.2063196, January 2012.\n   [BLOATWEB]\
    \ \"Bufferbloat\", <https://www.bufferbloat.net>.\n   [BQL]      Herbert, T.,\
    \ \"bql: Byte Queue Limits\", August 2011,\n              <https://lwn.net/Articles/454378/>.\n\
    \   [CAKE]     \"Cake - Common Applications Kept Enhanced\",\n              <http://www.bufferbloat.net/projects/codel/wiki/Cake>.\n\
    \   [CODEL]    Nichols, K. and V. Jacobson, \"Controlling Queue Delay\",\n   \
    \           ACM Queue, Volume 10, Issue 5,\n              DOI 10.1145/2208917.2209336,\
    \ May 2012,\n              <http://queue.acm.org/detail.cfm?id=2209336>.\n   [DRR]\
    \      Shreedhar, M. and G. Varghese, \"Efficient Fair Queueing\n            \
    \  Using Deficit Round Robin\", IEEE/ACM Transactions on\n              Networking,\
    \ Volume 4, Issue 3, DOI 10.1109/90.502236, June\n              1996.\n   [DRRPP]\
    \    MacGregor, M. and W. Shi, \"Deficits for Bursty Latency-\n              Critical\
    \ Flows: DRR++\", Proceedings of the IEEE\n              International Conference\
    \ on Networks 2000 (ICON 2000),\n              DOI 10.1109/ICON.2000.875803, September\
    \ 2000,\n              <http://ieeexplore.ieee.org/xpls/\n              abs_all.jsp?arnumber=875803>.\n\
    \   [GONG2014] Gong, Y., Rossi, D., Testa, C., Valenti, S., and D. Taht,\n   \
    \           \"Fighting the bufferbloat: On the coexistence of AQM and\n      \
    \        low priority congestion control\", Elsevier Computer\n              Networks,\
    \ Volume 65, DOI 10.1016/j.bjp.2014.01.009, June\n              2014, <https://www.sciencedirect.com/science/article/pii/\n\
    \              S1389128614000188>.\n   [HFSC]     Stoica, I., Zhang, H., and T.\
    \ Eugene Ng, \"A Hierarchical\n              Fair Service Curve Algorithm for\
    \ Link-Sharing, Real-Time\n              and Priority Services\", Proceedings\
    \ of ACM SIGCOMM,\n              DOI 10.1145/263105.263175, September 1997,\n\
    \              <http://conferences.sigcomm.org/sigcomm/1997/papers/\n        \
    \      p011.pdf>.\n   [HTB]      Wikipedia, \"Token Bucket: Variations\", October\
    \ 2017,\n              <https://en.wikipedia.org/w/\n              index.php?title=Token_bucket&oldid=803574657>.\n\
    \   [JENKINS]  Jenkins, B., \"A Hash Function for Hash Table Lookup\",\n     \
    \         <http://www.burtleburtle.net/bob/hash/doobs.html>.\n   [LINUXSRC] \"\
    Linux Kernel Source Tree\", <https://git.kernel.org/cgit/l\n              inux/kernel/git/torvalds/linux.git/tree/net/sched/\n\
    \              sch_fq_codel.c>.\n   [NS2]      \"ns-2\", December 2014, <http://nsnam.sourceforge.net/wiki/\n\
    \              index.php?title=Main_Page&oldid=8076>.\n   [NS3]      \"ns-3\"\
    , February 2016, <https://www.nsnam.org/mediawiki/\n              index.php?title=Main_Page&oldid=9883>.\n\
    \   [QFQ]      Checconi, F., Rizzo, L., and P. Valente, \"QFQ: Efficient\n   \
    \           Packet Scheduling with Tight Guarantees\", IEEE/ACM\n            \
    \  Transactions on Networking (TON), Volume 21, Issue 3, pp.\n              802-816,\
    \ DOI 10.1109/TNET.2012.2215881, June 2013,\n              <http://dl.acm.org/citation.cfm?id=2525552>.\n\
    \   [RFC2003]  Perkins, C., \"IP Encapsulation within IP\", RFC 2003,\n      \
    \        DOI 10.17487/RFC2003, October 1996,\n              <https://www.rfc-editor.org/info/rfc2003>.\n\
    \   [RFC2890]  Dommety, G., \"Key and Sequence Number Extensions to GRE\",\n \
    \             RFC 2890, DOI 10.17487/RFC2890, September 2000,\n              <https://www.rfc-editor.org/info/rfc2890>.\n\
    \   [RFC3168]  Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition\n   \
    \           of Explicit Congestion Notification (ECN) to IP\",\n             \
    \ RFC 3168, DOI 10.17487/RFC3168, September 2001,\n              <https://www.rfc-editor.org/info/rfc3168>.\n\
    \   [RFC4213]  Nordmark, E. and R. Gilligan, \"Basic Transition Mechanisms\n \
    \             for IPv6 Hosts and Routers\", RFC 4213,\n              DOI 10.17487/RFC4213,\
    \ October 2005,\n              <https://www.rfc-editor.org/info/rfc4213>.\n  \
    \ [RFC6817]  Shalunov, S., Hazel, G., Iyengar, J., and M. Kuehlewind,\n      \
    \        \"Low Extra Delay Background Transport (LEDBAT)\", RFC 6817,\n      \
    \        DOI 10.17487/RFC6817, December 2012,\n              <https://www.rfc-editor.org/info/rfc6817>.\n\
    \   [RFC8257]  Bensley, S., Thaler, D., Balasubramanian, P., Eggert, L.,\n   \
    \           and G. Judd, \"Data Center TCP (DCTCP): TCP Congestion\n         \
    \     Control for Data Centers\", RFC 8257, DOI 10.17487/RFC8257,\n          \
    \    October 2017, <https://www.rfc-editor.org/info/rfc8257>.\n   [SFQ]      McKenney,\
    \ P., \"Stochastic Fairness Queueing\", Proceedings\n              of IEEE INFOCOM,\
    \ DOI 10.1109/INFCOM.1990.91316, June 1990,\n              <http://perso.telecom-\n\
    \              paristech.fr/~bonald/Publications_files/BMO2011.pdf>.\n   [SQF]\
    \      Carofiglio, G. and L. Muscariello, \"On the Impact of TCP\n           \
    \   and Per-Flow Scheduling on Internet Performance\", IEEE/ACM\n            \
    \  Transactions on Networking, Volume 20, Issue 2,\n              DOI 10.1109/TNET.2011.2164553,\
    \ August 2011.\n   [WEBRTC-QOS]\n              Jones, P., Dhesikan, S., Jennings,\
    \ C., and D. Druta, \"DSCP\n              Packet Markings for WebRTC QoS\", Work\
    \ in Progress,\n              draft-ietf-tsvwg-rtcweb-qos-18, August 2016.\n \
    \  [WFQ]      Demers, A., Keshav, S., and S. Shenker, \"Analysis and\n       \
    \       Simulation of a Fair Queueing Algorithm\", ACM SIGCOMM\n             \
    \ Computer Communication Review, Volume 19, Issue 4, pp.\n              1-12,\
    \ DOI 10.1145/75247.75248, September 1989,\n              <http://doi.acm.org/10.1145/75247.75248>.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   Our deepest thanks to Kathie Nichols, Van Jacobson, and\
    \ all the\n   members of the bufferbloat.net effort for all the help on developing\n\
    \   and testing the algorithm.  In addition, our thanks to Anil Agarwal\n   for\
    \ his help with getting the hash collision probabilities in this\n   document\
    \ right.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Toke Hoeiland-Joergensen\n   Karlstad University\n   Dept.\
    \ of Computer Science\n   Karlstad  65188\n   Sweden\n   Email: toke@toke.dk\n\
    \   Paul McKenney\n   IBM Linux Technology Center\n   1385 NW Amberglen Parkway\n\
    \   Hillsboro, OR  97006\n   United States of America\n   Email: paulmck@linux.vnet.ibm.com\n\
    \   URI:   http://www2.rdrop.com/~paulmck/\n   Dave Taht\n   Teklibre\n   2104\
    \ W First street\n   Apt 2002\n   FT Myers, FL  33901\n   United States of America\n\
    \   Email: dave.taht@gmail.com\n   URI:   http://www.teklibre.com/\n   Jim Gettys\n\
    \   21 Oak Knoll Road\n   Carlisle, MA  993\n   United States of America\n   Email:\
    \ jg@freedesktop.org\n   URI:   https://en.wikipedia.org/wiki/Jim_Gettys\n   Eric\
    \ Dumazet\n   Google, Inc.\n   1600 Amphitheatre Pkwy\n   Mountain View, CA  94043\n\
    \   United States of America\n   Email: edumazet@gmail.com\n"
