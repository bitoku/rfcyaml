- title: __initial_text__
  contents:
  - '               Extending TCP for Transactions -- Concepts

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard.  Distribution of this memo is\n\
    \   unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo discusses extension of TCP to provide transaction-oriented\n\
    \   service, without altering its virtual-circuit operation.  This\n   extension\
    \ would fill the large gap between connection-oriented TCP\n   and datagram-based\
    \ UDP, allowing TCP to efficiently perform many\n   applications for which UDP\
    \ is currently used.  A separate memo\n   contains a detailed functional specification\
    \ for this proposed\n   extension.\n   This work was supported in part by the\
    \ National Science Foundation\n   under Grant Number NCR-8922231.\n"
- title: TABLE OF CONTENTS
  contents:
  - "TABLE OF CONTENTS\n   1. INTRODUCTION ..................................................\
    \  2\n   2. TRANSACTIONS USING STANDARD TCP ...............................  3\n\
    \   3. BYPASSING THE 3-WAY HANDSHAKE .................................  6\n  \
    \    3.1  Concept of TAO ...........................................  6\n    \
    \  3.2  Cache Initialization ..................................... 10\n      3.3\
    \  Accepting <SYN,ACK> Segments ............................. 11\n   4. SHORTENING\
    \ TIME-WAIT STATE .................................... 13\n   5. CHOOSING A MONOTONIC\
    \ SEQUENCE ................................. 15\n      5.1  Cached Timestamps\
    \ ........................................ 16\n      5.2  Current TCP Sequence\
    \ Numbers ............................. 18\n      5.3  64-bit Sequence Numbers\
    \ .................................. 20\n      5.4  Connection Counts ........................................\
    \ 20\n      5.5  Conclusions .............................................. 21\n\
    \   6. CONNECTION STATES ............................................. 24\n  \
    \ 7. CONCLUSIONS AND ACKNOWLEDGMENTS ............................... 32\n   APPENDIX\
    \ A: TIME-WAIT STATE AND THE 2-PACKET EXCHANGE ............ 34\n   REFERENCES\
    \ ....................................................... 37\n   Security Considerations\
    \ .......................................... 38\n   Author's Address .................................................\
    \ 38\n"
- title: 1. INTRODUCTION
  contents:
  - "1. INTRODUCTION\n   The TCP protocol [STD-007] implements a virtual-circuit transport\n\
    \   service that provides reliable and ordered data delivery over a\n   full-duplex\
    \ connection.  Under the virtual circuit model, the life of\n   a connection is\
    \ divided into three distinct phases: (1) opening the\n   connection to create\
    \ a full-duplex byte stream; (2) transferring data\n   in one or both directions\
    \ over this stream; and (3) closing the\n   connection.  Remote login and file\
    \ transfer are examples of\n   applications that are well suited to virtual-circuit\
    \ service.\n   Distributed applications, which are becoming increasingly numerous\n\
    \   and sophisticated in the Internet, tend to use a transaction-oriented\n  \
    \ rather than a virtual circuit style of communication.  Currently, a\n   transaction-oriented\
    \ Internet application must choose to suffer the\n   overhead of opening and closing\
    \ TCP connections or else build an\n   application-specific transport mechanism\
    \ on top of the connectionless\n   transport protocol UDP.  Greater convenience,\
    \ uniformity, and\n   efficiency would result from widely-available kernel implementations\n\
    \   of a transport protocol supporting a transaction service model [RFC-\n   955].\n\
    \   The transaction service model has the following features:\n   *    The fundamental\
    \ interaction is a request followed by a response.\n   *    An explicit open or\
    \ close phase would impose excessive overhead.\n   *    At-most-once semantics\
    \ is required; that is, a transaction must\n        not be \"replayed\" by a duplicate\
    \ request packet.\n   *    In favorable circumstances, a reliable request/response\n\
    \        handshake can be performed with exactly one packet in each\n        direction.\n\
    \   *    The minimum transaction latency for a client is RTT + SPT, where\n  \
    \      RTT is the round-trip time and SPT is the server processing\n        time.\n\
    \   We use the term \"transaction transport protocol\" for a transport-\n   layer\
    \ protocol that follows this model [RFC-955].\n   The Internet architecture allows\
    \ an arbitrary collection of transport\n   protocols to be defined on top of the\
    \ minimal end-to-end datagram\n   service provided by IP [Clark88].  In practice,\
    \ however, production\n   systems implement only TCP and UDP at the transport\
    \ layer.  It has\n   proven difficult to leverage a new transport protocol into\
    \ place, to\n   be widely enough available to be useful for application builders.\n\
    \   This memo explores an alternative approach to providing a transaction\n  \
    \ transport protocol: extending TCP to implement the transaction\n   service model,\
    \ while continuing to support the virtual circuit model.\n   Each transaction\
    \ will then be a single instance of a TCP connection.\n   The proposed transaction\
    \ extension is effectively implementable\n   within current TCPs and operating\
    \ systems, and it should also scale\n   to the much faster networks, interfaces,\
    \ and CPUs of the future.\n   The present memo explains the theory behind the\
    \ extension, in\n   somewhat exquisite detail.  Despite the length and complexity\
    \ of this\n   memo, the TCP extensions required for transactions are in fact quite\n\
    \   limited and simple.  Another memo [TTCP-FS] provides a self-contained\n  \
    \ functional specification of the extensions.\n   Section 2 of this memo describes\
    \ the limitations of standard TCP for\n   transaction processing, to motivate\
    \ the extensions.  Sections 3, 4,\n   and 5 explore the fundamental extensions\
    \ that are required for\n   transactions.  Section 6 discusses the changes required\
    \ in the TCP\n   connection state diagram.  Finally, Section 7 presents conclusions\n\
    \   and acknowledgments.  Familiarity with the standard TCP protocol\n   [STD-007]\
    \ is assumed.\n"
- title: 2.  TRANSACTIONS USING STANDARD TCP
  contents:
  - "2.  TRANSACTIONS USING STANDARD TCP\n   Reliable transfer of data depends upon\
    \ sequence numbers.  Before data\n   transfer can begin, both parties must \"\
    synchronize\" the connection,\n   i.e, agree on common sequence numbers.  The\
    \ synchronization procedure\n   must preserve at-most-once semantics, i.e., be\
    \ free from replay\n   hazards due to duplicate packets.  The TCP developers adopted\
    \ a\n   synchronization mechanism known as the 3-way handshake.\n   Consider a\
    \ simple transaction in which client host A sends a single-\n   segment request\
    \ to server host B, and B returns a single-segment\n   response.  Many current\
    \ TCP implementations use at least ten segments\n   (i.e., packets) for this sequence:\
    \ three for the 3-way handshake\n   opening the connection, four to send and acknowledge\
    \ the request and\n   response data, and three for TCP's full-duplex data-conserving\
    \ close\n   sequence.  These ten segments represent a high relative overhead for\n\
    \   two data-bearing segments.  However, a more important consideration\n   is\
    \ the transaction latency seen by the client:  2*RTT + SPT, larger\n   than the\
    \ minimum by one RTT.  As CPU and network speeds increase, the\n   relative significance\
    \ of this extra transaction latency also\n   increases.\n   Proposed transaction\
    \ transport protocols have typically used a\n   \"timer-based\" approach to connection\
    \ synchronization [Birrell84].  In\n   this approach, once end-to-end connection\
    \ state is established in the\n   client and server hosts, a subset of this state\
    \ is maintained for\n   some period of time.  A new request before the expiration\
    \ of this\n   timeout period can then reestablish the full state without an\n\
    \   explicit handshake.  Watson pointed out that the timer-based approach\n  \
    \ of his Delta-T protocol [Watson81] would encompass both virtual\n   circuits\
    \ and transactions.  However, the TCP group adopted the 3-way\n   handshake (because\
    \ of uncertainty about the robustness of enforcing\n   the packet lifetime bounds\
    \ required by Delta-T, within a general\n   Internet environment).  More recently,\
    \ Liskov, Shrira, and Wroclawski\n   [Liskov90] have proposed a different timer-based\
    \ approach to\n   connection synchronization, requiring loosely-synchronized clocks\
    \ in\n   the hosts.\n   The technique proposed in this memo, suggested by Clark\
    \ [Clark89],\n   depends upon cacheing of connection state but not upon clocks\
    \ or\n   timers; it is described in Section 3 below.  Garlick, Rom, and Postel\n\
    \   also proposed a connection synchronization mechanism using cached\n   state\
    \ [Garlick77].  Their scheme required each host to maintain\n   connection records\
    \ containing the highest sequence number on each\n   connection.  The technique\
    \ suggested here retains only per-host\n   state, not per-connection state.\n\
    \   During TCP development, it was suggested that TCP could support\n   transactions\
    \ with data segments containing both SYN and FIN bits.\n   (These \"Kamikaze\"\
    \ segments were not supported as a service; they were\n   used mainly to crash\
    \ other experimental TCPs!)  To illustrate this\n   idea, Figure 1 shows a plausible\
    \ application of the current TCP rules\n   to create a minimal transaction.  (In\
    \ fact, some minor adjustments in\n   the standard TCP spec would be required\
    \ to make Figure 1 fully legal\n   [STD-007]).\n   Figure 1, like many of the\
    \ examples shown in this memo, uses an\n   abbreviated form to illustrate segment\
    \ sequences.  For clarity and\n   brevity, it omits explicit sequence and acknowledgment\
    \ numbers,\n   assuming that these will follow the well-known TCP rules.  The\n\
    \   notation \"ACK(x)\" implies a cumulative acknowledgment for the control\n\
    \   bit or data \"x\" and everything preceding \"x\" in the sequence space.\n\
    \   The referent of \"x\" should be clear from the context.  Also, host A\n  \
    \ will always be the client and host B will be the server in these\n   diagrams.\n\
    \   The first three segments in Figure 1 implement the standard TCP\n   three-way\
    \ handshake.  If segment #1 had been an old duplicate, the\n   client side would\
    \ have sent an RST (Reset) bit in segment #3,\n   terminating the sequence.  The\
    \ request data included on the initial\n   SYN segment cannot be delivered to\
    \ user B until segment #3 completes\n   the 3-way handshake.  Loading control\
    \ bits onto the segments has\n   reduced the total number of segments to 5, but\
    \ the client still\n   observes a transaction latency of 2*RTT + SPT.  The 3-way\
    \ handshake\n   thus precludes high-performance transaction processing.\n    \
    \   TCP A  (Client)                                 TCP B (Server)\n       _______________\
    \                                 ______________\n       CLOSED              \
    \                                 LISTEN\n   (Client sends request)\n    1. SYN-SENT\
    \             --> <SYN,data1,FIN> -->       SYN-RCVD\n                       \
    \                                (data1 queued)\n    2. ESTABLISHED  <-- <SYN,ACK(SYN)>\
    \ <--                SYN-RCVD\n    3. FIN-WAIT-1            --> <ACK(SYN),FIN>\
    \ -->     CLOSE-WAIT\n                                                    (data1\
    \ to server)\n                                                 (Server sends reply)\n\
    \    4. TIME-WAIT    <-- <ACK(FIN),data2,FIN> <--          LAST-ACK\n    (data2\
    \ to client)\n    5. TIME-WAIT                 --> <ACK(FIN)> -->         CLOSED\n\
    \       (timeout)\n       CLOSED\n               Figure 1: Transaction Sequence:\
    \ RFC-793 TCP\n   The TCP close sequence also poses a performance problem for\n\
    \   transactions: one or both end(s) of a closed connection must remain\n   in\
    \ \"TIME-WAIT\" state until a 4 minute timeout has expired [STD-007].\n   The\
    \ same connection (defined by the host and port numbers at both\n   ends) cannot\
    \ be reopened until this delay has expired.  Because of\n   TIME-WAIT state, a\
    \ client program should choose a new local port\n   number (i.e., a different\
    \ connection) for each successive\n   transaction.  However, the TCP port field\
    \ of 16 bits (less the\n   \"well-known\" port space) provides only 64512 available\
    \ user ports.\n   This limits the total rate of transactions between any pair\
    \ of hosts\n   to a maximum of 64512/240 = 268 per second.  This is much too low\
    \ a\n   rate for low-delay paths, e.g., high-speed LANs.  A high rate of\n   short\
    \ connections (i.e., transactions) could also lead to excessive\n   consumption\
    \ of kernel memory by connection control blocks in TIME-\n   WAIT state.\n   In\
    \ summary, to perform efficient transaction processing in TCP, we\n   need to\
    \ suppress the 3-way handshake and to shorten TIME-WAIT state.\n   Protocol mechanisms\
    \ to accomplish these two goals are discussed in\n   Sections 3 and 4, respectively.\
    \  Both require the choice of a\n   monotonic sequence-like space; Section 5 analyzes\
    \ the choices and\n   makes a selection for this space.  Finally, the TCP connection\
    \ state\n   machine must be extended as described in Section 6.\n   Transaction\
    \ processing in TCP raises some other protocol issues,\n   which are discussed\
    \ in the functional specification memo [TTCP-FS].\n   These include:\n   (1) \
    \ augmenting the user interface for transactions,\n   (2)  delaying acknowledgment\
    \ segments to allow maximum piggy-backing\n        of control bits with data,\n\
    \   (3)  measuring the retransmission timeout time (RTO) on very short\n     \
    \   connections, and\n   (4)  providing an initial server window.\n   A recently\
    \ proposed set of enhancements [RFC-1323] defines a TCP\n   Timestamps option\
    \ that carries two 32-bit timestamp values.  The\n   Timestamps option is used\
    \ to accurately measure round-trip time\n   (RTT).  The same option is also used\
    \ in a procedure known as \"PAWS\"\n   (Protect Againsts Wrapped Sequence) to\
    \ prevent erroneous data\n   delivery due to a combination of old duplicate segments\
    \ and sequence\n   number reuse at very high bandwidths.  The particular approach\
    \ to\n   transactions chosen in this memo does not require the RFC-1323\n   enhancements;\
    \ however, they are important and should be implemented\n   in every TCP, with\
    \ or without the transaction extensions described\n   here.\n"
- title: 3.  BYPASSING THE 3-WAY HANDSHAKE
  contents:
  - "3.  BYPASSING THE 3-WAY HANDSHAKE\n   To avoid 3-way handshakes for transactions,\
    \ we introduce a new\n   mechanism for validating initial SYN segments, i.e.,\
    \ for enforcing\n   at-most-once semantics without a 3-way handshake.  We refer\
    \ to this\n   as the TCP Accelerated Open, or TAO, mechanism.\n   3.1 Concept\
    \ of TAO\n      The basis of TAO is this: a TCP uses cached per-host information\n\
    \      to immediately validate new SYNs [Clark89].  If this validation\n     \
    \ fails, e.g., because there is no current cached state or the\n      segment\
    \ is an old duplicate, the procedure falls back to a normal\n      3-way handshake\
    \ to validate the SYN.  Thus, bypassing a 3-way\n      handshake is considered\
    \ to be an optional optimization.\n      The proposed TAO mechanism uses a finite\
    \ sequence-like space of\n      values that increase monotonically with successive\
    \ transactions\n      (connections) between a given (client, server) host pair.\
    \  Call\n      this monotonic space M, and let each initial SYN segment carry\
    \ an\n      M value SEG.M.  If M is not the existing sequence (SEG.SEQ) field,\n\
    \      SEG.M may be carried in a TCP option.\n      When host B receives from\
    \ host A an initial SYN segment containing\n      a new value SEG.M, host B compares\
    \ this against cache.M[A], the\n      latest M value that B has cached for host\
    \ A.  This comparison is\n      the \"TAO test\".  Because the M values are monotonically\n\
    \      increasing, SEG.M > cache.M[A] implies that the SYN must be new\n     \
    \ and can be accepted immediately.  If not, a normal 3-way handshake\n      is\
    \ performed to validate the initial SYN segment.  Figure 2\n      illustrates\
    \ the TAO mechanism; cached M values are shown enclosed\n      in square brackets.\
    \  The M values generated by host A satisfy\n      x0 < x1, and the M values generated\
    \ by host B satisfy y0 < y1.\n      An appropriate choice for the M value space\
    \ is discussed in\n      Section 5.  M values are drawn from a finite number space,\
    \ so\n      inequalities must be defined in the usual way for sequence numbers\n\
    \      [STD-007].  The M space must not wrap so quickly that an old\n      duplicate\
    \ SYN will be erroneously accepted.  We assume that some\n      maximum segment\
    \ lifetime (MSL) is enforced by the IP layer.\n        ____\bT_\bC_\bP__\bA_____\
    \                                ____\bT_\bC_\bP__\bB_____\n            cache.M[B]\
    \                                  cache.M[A]\n               V              \
    \                              V\n            [ y0 ]                         \
    \              [ x0 ]\n      1.             -->  <SYN,data1,M=x1> -->       (\
    \ (x1 > x0) =>\n                                                      data1 ->\
    \ user_B;\n                                                      cache.M[A]= x1)\n\
    \            [ y0 ]                                       [ x1 ]\n      2.   \
    \         <-- <SYN,ACK(data1),data2,M=y1> <--\n         (data2 -> user_A,\n  \
    \        cache.M[B]= y1)\n            [ y1 ]                                 \
    \      [ x1 ]\n                              ... (etc.) ...\n                \
    \   Figure 2. TAO: Three-Way Handshake is Bypassed\n      Figure 2 shows the simplest\
    \ case: each side has cached the latest\n      M value of the other, and the SEG.M\
    \ value in the client's SYN\n      segment is greater than the value in the cache\
    \ at the server host.\n      As a result, B can accept the client A's request\
    \ data1 immediately\n      and pass it to the server application.  B's reply data2\
    \ is shown\n      piggybacked on the <SYN,ACK> segment.  As a result of this 2-way\n\
    \      exchange, the cached M values are updated at both sites; the\n      client\
    \ side becomes relevant only if the client/server roles\n      reverse.  Validation\
    \ of the <SYN,ACK> segment at host A is\n      discussed later.\n      Figure\
    \ 3 shows the TAO test failing but the consequent 3-way\n      handshake succeeding.\
    \  B updates its cache with the value x2 >= x1\n      when the initial SYN is\
    \ known to be valid.\n           _\bT_\bC_\bP__\bA                           \
    \          _\bT_\bC_\bP__\bB\n            cache.M[B]                         \
    \         cache.M[A]\n               V                                       \
    \    V\n            [ y0 ]                                       [ x0 ]\n    \
    \  1.                 --> <SYN,data1,M=x1> -->   ( (x1 <= x0) =>\n           \
    \                                         data1 queued;\n                    \
    \                                3-way handshake)\n            [ y0 ]        \
    \                               [ x0 ]\n      2.                <-- <SYN,ACK(SYN),M=y1>\
    \ <--\n         (cache.M[B]= y1)\n            [ y1 ]                         \
    \              [ x0 ]\n      3.                  --> <ACK(SYN),M=x2> -->  (Handshake\
    \ OK =>\n                                                   data1->user_B,\n \
    \                                                  cache.M[A]= x2)\n         \
    \   [ y1 ]                                       [ x2 ]\n                    \
    \        ...  (etc.)  ...\n          Figure 3. TAO Test Fails but 3-Way Handshake\
    \ Succeeds.\n      There are several possible causes for a TAO test failure on\
    \ a\n      legitimate new SYN segment (not an old duplicate).\n      (1)  There\
    \ may be no cached M value for this particular client\n           host.\n    \
    \  (2)  The SYN may be the one of a set of nearly-simultaneous SYNs\n        \
    \   for different connections but from the same host, which\n           arrived\
    \ out of order.\n      (3)  The finite M space may have wrapped around between\
    \ successive\n           transactions from the same client.\n      (4)  The M\
    \ values may advance too slowly for closely-spaced\n           transactions.\n\
    \      None of these TAO failures will cause a lockout, because the\n      resulting\
    \ 3-way handshake will succeed.  Note that the first\n      transaction between\
    \ a given host pair will always require a 3-way\n      handshake; subsequent transactions\
    \ can take advantage of TAO.\n      The per-host cache required by TAO is highly\
    \ desirable for other\n      reasons, e.g., to retain the measured round trip\
    \ time and MTU for\n      a given remote host.  Furthermore, a host should already\
    \ have a\n      per-host routing cache [HR-COMM] that should be easily extensible\n\
    \      for this purpose.\n      Figure 4 illustrates a complete TCP transaction\
    \ sequence using the\n      TAO mechanism.  Bypassing the 3-way handshake leads\
    \ to new\n      connection states; Figure 4 shows three of them, \"SYN-SENT*\"\
    ,\n      \"CLOSE-WAIT*\", and \"LAST-ACK*\".  Explanation of these states is\n\
    \      deferred to Section 6.\n          TCP A  (Client)                     \
    \            TCP B (Server)\n          _______________                       \
    \          ______________\n          CLOSED                                  \
    \                LISTEN\n      1.  SYN-SENT*    --> <SYN,data1,FIN,M=x1> --> \
    \         CLOSE-WAIT*\n                                                      \
    \   (TAO test OK=>\n                                                         \
    \ data1->user_B)\n                   <-- <SYN,ACK(FIN),data2,FIN,M=y1> <--   \
    \    LAST-ACK*\n      2.  TIME-WAIT\n       (data2->user_A)\n      3.  TIME-WAIT\
    \          --> <ACK(FIN),M=x2> -->              CLOSED\n          (timeout)\n\
    \            CLOSED\n               Figure 4: Minimal Transaction Sequence Using\
    \ TAO\n   3.2 Cache Initialization\n      The first connection between hosts A\
    \ and B will find no cached\n      state at one or both ends, so both M caches\
    \ must be initialized.\n      This requires that the first transaction carry a\
    \ specially marked\n      SEG.M value, which we call SEG.M.NEW.  Receiving a SEG.M.NEW\
    \ value\n      in an initial SYN segment, B will cache this value and send its\n\
    \      own M back to initialize A's cache.  When a host crashes and\n      restarts,\
    \ all its cached M values cache.M[*] must be invalidated\n      in order to force\
    \ a re-synchronization of the caches at both ends.\n      This cache synchronization\
    \ procedure is illustrated in Figure 5,\n      where client host A has crashed\
    \ and restarted with its cache\n      entries undefined, as indicated by \"??\"\
    .  Since cache.TS[B] is\n      undefined, A sends a SEG.M.NEW value instead of\
    \ SEG.M in the <SYN>\n      segment of its first transaction request to B.  Receiving\
    \ this\n      SEG.M.NEW, the server host B invalidates cache.TS[A] and performs\n\
    \      a 3-way handshake.  SEG.M in segment #2 updates A's cache, and\n      when\
    \ the handshake completes successfully, B updates its cached M\n      value to\
    \ x2 >= x1.\n           _\bT_\bC_\bP__\bA                                    \
    \ _\bT_\bC_\bP__\bB\n            cache.M[B]                                  cache.M[A]\n\
    \               V                                           V\n            [ ??\
    \ ]                                       [ x0 ]\n      1.           --> <SYN,data1,M.NEW=x1>\
    \ -->   (invalidate cache;\n                                                 \
    \       queue data1;\n            [ ?? ]                                  3-way\
    \ handshake)\n                                                         [ ?? ]\n\
    \      2.              <-- <SYN,ACK(SYN),M=y1> <--\n         (cache.M[B]= y1)\n\
    \            [ y1 ]                                       [ ?? ]\n      3.   \
    \               --> <ACK(SYN),M=x2> -->  data1->user_B,\n                    \
    \                               cache.M[A]= x2)\n            [ y1 ]          \
    \                             [ x2 ]\n                            ...  (etc.)\
    \  ...\n                  Figure 5.  Client Host Crashed\n      Suppose that the\
    \ 3-way handshake failed, presumably because\n      segment #1 was an old duplicate.\
    \  Then segment #3 from host A\n      would be an RST segment, with the result\
    \ that both side's caches\n      would be left undefined.\n      Figure 6 shows\
    \ the procedure when the server crashes and restarts.\n      Upon receiving a\
    \ <SYN> segment from a host for which it has no\n      cached M value, B initiates\
    \ a 3-way handshake to validate the\n      request and sends its own M value to\
    \ A.  Again the result is to\n      update cached M values on both sides.\n  \
    \            _\bT_\bC_\bP__\bA                                     _\bT_\bC_\b\
    P__\bB\n               cache.M[B]                                  cache.M[A]\n\
    \                  V                                           V\n           \
    \    [ y0 ]                                       [ ?? ]\n         1.        \
    \       --> <SYN,data1,M=x1> -->      (data1 queued;\n                       \
    \                                3-way handshake)\n               [ y0 ]     \
    \                                  [ ?? ]\n         2.              <-- <SYN,ACK(SYN),M=y1>\
    \ <--\n            (cache.M[B]= y1)\n               [ y1 ]                   \
    \                    [ ?? ]\n         3.                --> <ACK(SYN),M=x2> -->\
    \   (data1->user_B,\n                                                      cache.M[A]=\
    \ x2)\n               [ y1 ]                                       [ x2 ]\n  \
    \                             ...  (etc.)  ...\n                        Figure\
    \ 6. Server Host Crashed\n   3.3  Accepting <SYN,ACK> Segments\n      Transactions\
    \ introduce a new hazard of erroneously accepting an\n      old duplicate <SYN,ACK>\
    \ segment.  To be acceptable, a <SYN,ACK>\n      segment must arrive in SYN-SENT\
    \ state, and its ACK field must\n      acknowledge something that was sent.  In\
    \ current TCPs the\n      effective send window in SYN-SENT state is exactly one\
    \ octet, and\n      an acceptable <SYN,ACK> must exactly ACK this one octet. \
    \ The\n      clock-driven selection of Initial Sequence Number (ISN) makes an\n\
    \      erroneous acceptance exceedingly unlikely.  An old duplicate SYN\n    \
    \  could be accepted erroneously only if successive connection\n      attempts\
    \ occurred more often than once every 4 microseconds, or if\n      the segment\
    \ lifetime exceeded the 4 hour wraparound time for ISN\n      selection.\n   \
    \   However, when TCP is used for transactions, data sent with the\n      initial\
    \ SYN increases the range of sequence numbers that have been\n      sent.  This\
    \ increases the danger of accepting an old duplicate\n      <SYN,ACK> segment,\
    \ and the consequences are more serious.  In the\n      example in Figure 7, segments\
    \ 1-3 form a normal transaction\n      sequence, and segment 4 begins a new transaction\
    \ (incarnation) for\n      the same connection.  Segment #5 is a duplicate of\
    \ segment #2 from\n      the preceding transaction.  Although the new transaction\
    \ has a\n      larger ISN, the previous ACK value 402 falls into the new range\n\
    \      [200,700) of sequence numbers that have been sent, so segment #5\n    \
    \  could be erroneously accepted and passed to the client as the\n      response\
    \ to the new request.\n           _\bT_\bC_\bP__\bA                          \
    \             _\bT_\bC_\bP__\bB\n         CLOSED                             \
    \                      LISTEN\n      1.           --> <seq=100,SYN,data=300,FIN,M=x1>\
    \ --> (TAO test OK)\n      2.         <-- <seq=800,ack=402,SYN,data=350,FIN,M=y1>\
    \ <--\n      3. TIME-WAIT                      --> <ACK(FIN)> -->       CLOSED\n\
    \         (short timeout)\n         CLOSED\n         (New Request)\n      4. \
    \          --> <seq=200,SYN,data=500,FIN,M=x2> --> ...\n                     \
    \                       (Duplicate of segment #2)\n      5.         <-- <seq=800,ack=402,SYN,data=300,FIN,M=y1>\
    \ <--...\n         (Acceptable!!)\n               Figure 7: Old Duplicate <SYN,ACK>\
    \ Causing Error\n      Unfortunately, we cannot simply use TAO on the client side\
    \ to\n      detect and reject old duplicate <SYN,ACK> segments.  A TAO test at\n\
    \      the client might fail for a valid <SYN,ACK> segment, due to out-\n    \
    \  of-order delivery, and this could result in permanent non-delivery\n      of\
    \ a valid transaction reply.\n      Instead, we include a second M value, an echo\
    \ of the client's M\n      value from the initial <SYN> segment, in the <SYN,ACK>\
    \ segment.  A\n      specially-marked M value, SEG.M.ECHO, is used for this purpose.\n\
    \      The client knows the value it sent in the initial <SYN> and can\n     \
    \ therefore positively validate the <SYN,ACK> using the echoed\n      value. \
    \ This is illustrated in Figure 12, which is the same as\n      Figure 4 with\
    \ the addition of the echoed value on the <SYN,ACK>\n      segment #2.\n     \
    \ It should be noted that TCP allows a simultaneous open sequence in\n      which\
    \ both sides send and receive an initial <SYN> (see Figure 8\n      of [STD-007].\
    \  In this case, the TAO test must be performed on\n      both sides to preserve\
    \ the symmetry.  See [TTCP-FS] for an\n      example.\n"
- title: 4.  SHORTENING TIME-WAIT STATE
  contents:
  - "4.  SHORTENING TIME-WAIT STATE\n   Once a transaction has been initiated for\
    \ a particular connection\n   (pair of ports) between a given host pair, a new\
    \ transaction for the\n   same connection cannot take place for a time that is\
    \ at least:\n       RTT + SPT + TIME-WAIT_delay\n   Since the client host can\
    \ cycle among the 64512 available port\n   numbers, an upper bound on the transaction\
    \ rate between a particular\n   host pair is:\n   [1]    TRmax = 64512 /(RTT +\
    \ TIME-WAIT_Delay)\n   in transactions per second (Tps), where we assumed SPT\
    \ is negligible.\n   We must reduce TIME-WAIT_Delay to support high-rate TCP transaction\n\
    \   processing.\n   TIME-WAIT state performs two functions: (1) supporting the\
    \ full-\n   duplex reliable close of TCP, and (2) allowing old duplicate segments\n\
    \   from an earlier connection incarnation to expire before they can\n   cause\
    \ an error (see Appendix to [RFC-1185]).  The first function\n   impacts the application\
    \ model of a TCP connection, which we would not\n   want to change.  The second\
    \ is part of the fundamental machinery of\n   TCP reliable delivery; to safely\
    \ truncate TIME-WAIT state, we must\n   provide another means to exclude duplicate\
    \ packets from earlier\n   incarnations of the connection.\n   To minimize the\
    \ delay in TIME-WAIT state while performing both\n   functions, we propose to\
    \ set the TIME-WAIT delay to:\n   [2]    TIME-WAIT_Delay = max( K*RTO, U )\n \
    \  where U and K are constants and RTO is the dynamically-determined\n   retransmission\
    \ timeout, the measured RTT plus an allowance for the\n   RTT variance [Jacobson88].\
    \  We choose K large enough so that there is\n   high probability of the close\
    \ completing successfully if at all\n   possible; K = 8 seems reasonable.  This\
    \ takes care of the first\n   function of TIME-WAIT state.\n   In a real implementation,\
    \ there may be a minimum RTO value Tr,\n   corresponding to the precision of RTO\
    \ calculation.  For example, in\n   the popular BSD implementation of TCP, the\
    \ minimum RTO is Tr = 0.5\n   second.  Assuming K = 8 and U = 0, Eqns [1] and\
    \ [2] impose an upper\n   limit of TRmax = 16K Tps on the transaction rate of\
    \ these\n   implementations.\n   It is possible to have many short connections\
    \ only if RTO is very\n   small, in which case the TIME-WAIT delay [2] reduces\
    \ to U.  To\n   accelerate the close sequence, we need to reduce U below the MSL\n\
    \   enforced by the IP layer, without introducing a hazard from old\n   duplicate\
    \ segments.  For this purpose, we introduce another monotonic\n   number sequence;\
    \ call it X.  X values are required to be monotonic\n   between successive connection\
    \ incarnations; depending upon the choice\n   of the X space (see Section 5),\
    \ X values may also increase during a\n   connection.  A value from the X space\
    \ is to be carried in every\n   segment, and a segment is rejected if it is received\
    \ with an X value\n   smaller than the largest X value received.  This mechanism\
    \ does not\n   use a cache; the largest X value is maintained in the TCP connection\n\
    \   control block (TCB) for each connection.\n   The value of U depends upon the\
    \ choice for the X space, discussed in\n   the next section.  If X is time-like,\
    \ U can be set to twice the time\n   granularity (i.e, twice the minimum \"tick\"\
    \ time) of X.  The TIME-WAIT\n   delay will then ensure that current X values\
    \ do not overlap the X\n   values of earlier incarnations of the same connection.\
    \  Another\n   consequence of time-like X values is the possibility that an open\
    \ but\n   idle connection might allow the X value to wrap its sign bit,\n   resulting\
    \ in a lockup of the connection.  To prevent this, a 24-day\n   idle timer on\
    \ each open connection could bypass the X check on the\n   first segment following\
    \ the idle period, for example.  In practice,\n   many implementations have keep-alive\
    \ mechanisms that prevent such\n   long idle periods [RFC-1323].\n   Referring\
    \ back to Figure 4, our proposed transaction extension\n   results in a minimum\
    \ exchange of 3 packets.  Segment #3, the final\n   ACK segment, does not increase\
    \ transaction latency, but in\n   combination with the TIME-WAIT delay of K*RTO\
    \ it ensures that the\n   server side of the connection will be closed before\
    \ a new transaction\n   is issued for this same pair of ports.  It also provides\
    \ an RTT\n   measurement for the server.\n   We may ask whether it would be possible\
    \ to further reduce the TIME-\n   WAIT delay.  We might set K to zero; alternatively,\
    \ we might allow\n   the client TCP to start a new transaction request while the\n\
    \   connection was still in TIME-WAIT state, with the new initial SYN\n   acting\
    \ as an implied acknowledgment of the previous FIN.  Appendix A\n   summarizes\
    \ the issues raised by these alternatives, which we call\n   \"truncating\" TIME-WAIT\
    \ state, and suggests some possible solutions.\n   Further study would be required,\
    \ but these solutions appear to bend\n   the theory and/or implementations of\
    \ the TCP protocol farther than we\n   wish to bend them.\n   We therefore propose\
    \ using formula [2] with K=8 and retaining the\n   final ACK(FIN) transmission.\
    \  To raise the transaction rate,\n   therefore, we require small values of RTO\
    \ and U.\n"
- title: 5.  CHOOSING A MONOTONIC SEQUENCE
  contents:
  - "5.  CHOOSING A MONOTONIC SEQUENCE\n   For simplicity, we want the monotonic sequence\
    \ X used for shortening\n   TIME-WAIT state to be identical to the monotonic sequence\
    \ M for\n   bypassing the 3-way handshake.  Calling the common space M, we will\n\
    \   send an M value SEG.M in each TCP segment.  Upon receipt of an\n   initial\
    \ SYN segment, SEG.M will be compared with a per-host cached\n   value to authenticate\
    \ the SYN without a 3-way handshake; this is the\n   TAO mechanism.  Upon receipt\
    \ of a non-SYN segment, SEG.M will be\n   compared with the current value in the\
    \ connection control block and\n   used to discard old duplicates.\n   Note that\
    \ the situation with TIME-WAIT state differs from that of\n   bypassing 3-way\
    \ handshakes in two ways: (a) TIME-WAIT requires\n   duplicate detection on every\
    \ segment vs. only on SYN segments, and\n   (b) TIME-WAIT applies to a single\
    \ connection vs. being global across\n   all connections.  This section discusses\
    \ possible choices for the\n   common monotonic sequence.\n   The SEG.M values\
    \ must satisfy the following requirements.\n   *    The values must be monotonic;\
    \ this requirement is defined more\n        precisely below.\n   *    Their granularity\
    \ must be fine-grained enough to support a high\n        rate of transaction processing;\
    \ the M clock must \"tick\" at least\n        once between successive transactions.\n\
    \   *    Their range (wrap-around time) must be great enough to allow a\n    \
    \    realistic MSL to be enforced by the network.\n   The TCP spec calls for an\
    \ MSL of 120 secs.  Since much of the\n   Internet does not carefully enforce\
    \ this limit, it would be safer to\n   have an MSL at least an order of magnitude\
    \ larger.  We set as an\n   objective an MSL of at least 2000 seconds.  If there\
    \ were no TIME-\n   WAIT delay, the ultimate limit on transaction rate would be\
    \ set by\n   speed-of-light delays in the network and by the latency of host\n\
    \   operating systems.  As the bottleneck problems with interfacing CPUs\n   to\
    \ gigabit LANs are solved, we can imagine transaction durations as\n   short as\
    \ 1 microsecond.  Therefore, we set an ultimate performance\n   goal of TRmax\
    \ at least 10**6 Tps.\n   A particular connection between hosts A and B is identified\
    \ by the\n   local and remote TCP \"sockets\", i.e., by the quadruplet: {A, B,\n\
    \   Port.A, Port.B}.  Imagine that each host keeps a count CC of the\n   number\
    \ of TCP connections it has initiated.  We can use this CC\n   number to distinguish\
    \ different incarnations of the same connection.\n   Then a particular SEG.M value\
    \ may be labeled implicitly by 6\n   quantities: {A, B, Port.A, Port.B, CC, n},\
    \ where n is the byte offset\n   of that segment within the connection incarnation.\n\
    \   To bypass the 3-way handshake, we require thgt SEG.M values on\n   successive\
    \ SYN segments from a host A to a host B be monotone\n   increasing.  If CC' >\
    \ CC, then we require that:\n       SEG.M(A,B,Port.A,Port.B,CC',0) >  SEG.M(A,B,Port.A,Port.B,CC,0)\n\
    \   for any legal values of Port.A and Port.B.\n   To delete old duplicates (allowing\
    \ TIME-WAIT state to be shortened),\n   we require that SEG.M values be disjoint\
    \ across different\n   incarnations of the same connection.   If CC' > CC then\n\
    \       SEG.M(A,B,Port.A,Port.B,CC',n') > SEG.M(A,B,Port.A,Port.B,CC,n),\n   for\
    \ any non-negative integers n and n'.\n   We now consider four different choices\
    \ for the common monotonic\n   space: RFC-1323 timestamps, TCP sequence numbers,\
    \ the connection\n   count, and 64-bit TCP sequence numbers.  The results are\
    \ summarized\n   in Table I.\n   5.1 Cached Timestamps\n      The PAWS mechanism\
    \ [RFC-1323] uses TCP \"timestamps\" as\n      monotonically increasing integers\
    \ in order to throw out old\n      duplicate segments within the same incarnation.\
    \  Jacobson\n      suggested the cacheing of these timestamps for bypassing 3-way\n\
    \      handshakes [Jacobson90], i.e., that TCP timestamps be used for our\n  \
    \    common monotonic space M.  This idea is attractive since it would\n     \
    \ allow the same timestamp options to be used for RTTM, PAWS, and\n      transactions.\n\
    \      To obtain at-most-once service, the criterion for immediate\n      acceptance\
    \ of a SYN must be that SEG.M is strictly greater than\n      the cached M value.\
    \  That is, to be useful for bypassing 3-way\n      handshakes, the timestamp\
    \ clock must tick at least once between\n      any two successive transactions\
    \ between the same pair of hosts\n      (even if different ports are used).  Hence,\
    \ the timestamp clock\n      rate would determine TRmax, the maximum possible\
    \ transaction rate.\n      Unfortunately, the timestamp clock frequency called\
    \ for by RFC-\n      1323, in the range 1 sec to 1 ms, is much too slow for\n\
    \      transactions.  The TCP timestamp period was chosen to be\n      comparable\
    \ to the fundamental interval for computing and\n      scheduling retransmission\
    \ timeouts; this is generally in the range\n      of 1 sec. to 1 ms., and in many\
    \ operating systems, much closer to\n      1 second.  Although it would be possible\
    \ to increase the timestamp\n      clock frequency by several orders of magnitude,\
    \ to do so would\n      make implementation more difficult, and on some systems\n\
    \      excessively expensive.\n      The wraparound time for TCP timestamps, at\
    \ least 24 days, causes\n      no problem for transactions.\n      The PAWS mechanism\
    \ uses TCP timestamps to protect against old\n      duplicate non-SYN segments\
    \ from the same incarnation [RFC-1323].\n      It can also be used to protect\
    \ against old duplicate data segments\n      from earlier incarnations (and therefore\
    \ allow shortening of\n      TIME-WAIT state) if we can ensure that the timestamp\
    \ clock ticks\n      at least once between the end of one incarnation and the\
    \ beginning\n      of the next.  This can be achieved by setting U = 2 seconds,\
    \ i.e.,\n      to twice the maximum timestamp clock period.  This value in\n \
    \     formula [2] leads to an upper bound TRmax = 32K Tps between a host\n   \
    \   pair.  However, as pointed out above, old duplicate SYN detection\n      using\
    \ timestamps leads to a smaller transaction rate bound, 1 Tps,\n      which is\
    \ unacceptable.  In addition, the timestamp approach is\n      imperfect; it allows\
    \ old ACK segments to enter the new connection\n      where they can cause a disconnect.\
    \  This happens because old\n      duplicate ACKs that arrive during TIME-WAIT\
    \ state generate new\n      ACKs with the current timestamp [RFC-1337].\n    \
    \  We therefore conclude that timestamps are not adequate as the\n      monotonic\
    \ space M; see Table I.  However, they may still be useful\n      to effectively\
    \ extend some other monotonic number space, just as\n      they are used in PAWS\
    \ to extend the TCP sequence number space.\n      This is discussed below.\n \
    \  5.2 Current TCP Sequence Numbers\n      It is useful to understand why the\
    \ existing 32-bit TCP sequence\n      numbers do not form an appropriate monotonic\
    \ space for\n      transactions.\n      The sequence number sent in an initial\
    \ SYN is called the Initial\n      Sequence Number or ISN.  According to the TCP\
    \ specification, an\n      ISN is to be selected using:\n      [3]      ISN =\
    \ (R*T) mod 2**32\n      where T is the real time in seconds (from an arbitrary\
    \ origin,\n      fixed when the system is started) and R is a constant, currently\n\
    \      250 KBps.  These ISN values form a monotonic time sequence that\n     \
    \ wraps in 4.55 hours = 16380 seconds and has a granularity of 4\n      usecs.\
    \  For transaction rates up to roughly 250K Tps, the ISN\n      value calculated\
    \ by formula [3] will be monotonic and could be\n      used for bypassing the\
    \ 3-way handshake.\n      However, TCP sequence numbers (alone) could not be used\
    \ to shorten\n      TIME-WAIT state, because there are several ways that overlap\
    \ of\n      the sequence space of successive incarnations can occur (as\n    \
    \  described in Appendix to [RFC-1185]).  One way is a \"fast\n      connection\"\
    , with a transfer rate greater than R; another is a\n      \"long\" connection,\
    \ with a duration of approximately 4.55 hours.\n      TIME-WAIT delay is necessary\
    \ to protect against these cases.  With\n      the official delay of 240 seconds,\
    \ formula [1] implies a upper\n      bound (as RTT -> 0) of TRmax = 268 Tps; with\
    \ our target MSL of\n      2000 sec, TRmax = 32 Tps.  These values are unacceptably\
    \ low.\n      To improve this transaction rate, we could use TCP timestamps to\n\
    \      effectively extend the range of the TCP sequence numbers.\n      Timestamps\
    \ would guard against sequence number wrap-around and\n      thereby allow us\
    \ to increase R in [3] to exceed the maximum\n      possible transfer rate.  Then\
    \ sequence numbers for successive\n      incarnations could not overlap.  Timestamps\
    \ would also provide\n      safety with an MSL as large as 24 days.  We could\
    \ then set U = 0\n      in the TIME-WAIT delay calculation [2].  For example,\
    \ R = 10**9\n      Bps leads to TRmax <= 10**9 Tps. See 2(b) in Table I.  These\n\
    \      values would more than satisfy our objectives.\n      We should make clear\
    \ how this proposal, sequence numbers plus\n      timestamps, differs from the\
    \ timestamps alone discussed (and\n      rejected) in the previous section.  The\
    \ difference lies in what is\n      cached and tested for TAO; the proposal here\
    \ is to cache and test\n      BOTH the latest TCP sequence number and the latest\
    \ TCP timestamp.\n      In effect, we are proposing to use timestamps to logically\
    \ extend\n      the sequence space to 64 bits.  Another alternative, presented\
    \ in\n      the next section, is to directly expand the TCP sequence space to\n\
    \      64 bits.\n      Unfortunately, the proposed solution (TCP sequence numbers\
    \ plus\n      timestamps) based on equation [3] would be difficult or impossible\n\
    \      to implement on many systems, which base their TCP implementation\n   \
    \   upon a very low granularity software clock, typically O(1 sec).\n      To\
    \ adapt the procedure to a system with a low granularity software\n      clock,\
    \ suppose that we calculate the ISN as:\n      [4]      ISN = ( R*Ts*floor(T/Ts)\
    \ + q*CC) mod 2**32\n      where Ts is the time per tick of the software clock,\
    \ CC is the\n      connection count, and q is a constant.  That is, the ISN is\n\
    \      incremented by the constant R*Ts once every clock tick and by the\n   \
    \   constant q for every new connection.  We need to choose q to\n      obtain\
    \ the required monotonicity.\n      For monotonicity of the ISN's themselves,\
    \ q=1 suffices.  However,\n      monotonicity during the entire connection requires\
    \ q = R*Ts.  This\n      value of q can be deduced as follows.  Let S(T, CC, n)\
    \ be the\n      sequence number for byte offset n in a connection with number\
    \ CC\n      at time T:\n          S(T, CC, n) = (R*Ts*floor(T/Ts) + q*CC + n)\
    \ mod 2**32.\n      For any T1 > T2, we require that: S(T2, CC+1, 0) - S(T1, CC,\
    \ n) >\n      0 for all n.  Since R is assumed to be an upper bound on the\n \
    \     transfer rate, we can write down:\n          R > n/(T2 - T1),  or  T2/Ts\
    \ - T1/Ts > n/(R*Ts)\n      Using the relationship:  floor(x)-floor(y) > x-y-1\
    \ and a little\n      algebra leads to the conclusion that using q = R*Ts creates\
    \ the\n      required monotonic number sequence.  Therefore, we consider:\n  \
    \    [5]      ISN = R*Ts*(floor(T/Ts) + CC) mod 2**32\n      (which is the algorithm\
    \ used for ISN selection by BSD TCP).\n      For error-free operation, the sequence\
    \ numbers generated by [5]\n      must not wrap the sign bit in less than MSL\
    \ seconds.  Since CC\n      cannot increase faster than TRmax, the safe condition\
    \ is:\n            R* (1 + Ts*TRmax) * MSL < 2**31.\n      We are interested in\
    \ the case: Ts*TRmax >> 1, so this relationship\n      reduces to:\n      [6]\
    \     R * Ts * TRmax * MSL < 2**31.\n      This shows a direct trade-off among\
    \ the maximum effective\n      bandwidth R, the maximum transaction rate TRmax,\
    \ and the maximum\n      segment lifetime MSL.  For reasonable limiting values\
    \ of R, Ts,\n      and MSL, formula [6] leads to a very low value of TRmax.  For\n\
    \      example, with MSL= 2000 secs, R=10**9 Bps, and Ts = 0.5 sec, TRmax\n  \
    \    < 2*10**-3 Tps.\n      To ease the situation, we could supplement sequence\
    \ numbers with\n      timestamps.  This would allow an effective MSL of 2 seconds\
    \ in\n      [6], since longer times would be protected by differing\n      timestamps.\
    \  Then TRmax < 2**30/(R*Ts).  The actual enforced MSL\n      would be increased\
    \ to 24 days.  Unfortunately, TRmax would still\n      be too small, since we\
    \ want to support transfer rates up to R ~\n      10**9 Bps.  Ts = 0.5 sec would\
    \ imply TRmax ~ 2 Tps.  On many\n      systems, it appears infeasible to decrease\
    \ Ts enough to obtain an\n      acceptable TRmax using this approach.\n   5.3\
    \ 64-bit TCP Sequence Numbers\n      Another possibility would be to simply increase\
    \ the TCP sequence\n      space to 64 bits as suggested in [RFC-1263].  We would\
    \ also\n      increase the R value for clock-driven ISN selection, beyond the\n\
    \      fastest transfer rate of which the host is capable.  A reasonable\n   \
    \   upper limit might be R = 10**9 Bps.  As noted above, in a\n      practical\
    \ implementation we would use:\n            ISN = R*Ts*( floor(T/Ts) + CC) mod\
    \ 2**64\n      leading to:\n            R*(1 +  Ts * TRmax) * MSL < 2**63\n  \
    \    For example, suppose that R = 10**9 Bps, Ts = 0.5, and MSL = 16K\n      secs\
    \ (4.4 hrs); then this result implies that TRmax < 10**6 Tps.\n      We see that\
    \ adding 32 bits to the sequence space has provided\n      feasible values for\
    \ transaction processing.\n   5.4 Connection Counts\n      The Connection Count\
    \ CC is well suited to be the monotonic\n      sequence M, since it \"ticks\"\
    \ exactly once for each new connection\n      incarnation and is constant within\
    \ a single incarnation.  Thus, it\n      perfectly separates segments from different\
    \ incarnations of the\n      same connection and would allow U = 0 in the TIME-WAIT\
    \ state delay\n      formula [2].  (Strictly, U cannot be reduced below 1/R =\
    \ 4 usec,\n      as noted in Section 4.  However, this is of little practical\n\
    \      consequence until the ultimate limits on TRmax are approached).\n     \
    \ Assume that CC is a 32-bit number.  To prevent wrap-around in the\n      sign\
    \ bit of CC in less than MSL seconds requires that:\n           TRmax * MSL <\
    \ 2**31\n      For example, if MSL =  2000 seconds then TRmax < 10**6 Tp.  These\n\
    \      are acceptable limits for transaction processing.  However, if\n      they\
    \ are not, we could augment CC with TCP timestamps to obtain\n      very far-out\
    \ limits, as discussed below.\n      It would be an implementation choice at the\
    \ client whether CC is\n      global for all destinations or private to each destination\
    \ host\n      (and maintained in the per-host cache).  In the latter case, the\n\
    \      last CC value assigned for each remote host could also be\n      maintained\
    \ in the per-host cache.  Since there is not typically a\n      large amount of\
    \ parallelism in the network connection of a host,\n      there should be little\
    \ difference in the performance of these two\n      different approaches, and\
    \ the single global CC value is certainly\n      simpler.\n      To augment CC\
    \ with TCP timestamps, we would bypass a 3-way\n      handshake if both SEG.CC\
    \ > cache.CC[A] and SEG.TSval >=\n      cache.TS[A].  The timestamp check would\
    \ detect a SYN older than 2\n      seconds, so that the effective wrap-around\
    \ requirement would be:\n           TRmax * 2 < 2**31\n      i.e., TRmax < 10**9\
    \ Tps.  The required MSL would be raised to 24\n      days.  Using timestamps\
    \ in this way, we could reduce the size of\n      CC.  For example, suppose CC\
    \ were 16 bits.  Then the wrap-around\n      condition TRmax * 2 < 2**15 implies\
    \ that TRmax is 16K.\n      Finally, note that using CC to delete old duplicates\
    \ from earlier\n      incarnations would not obviate the need for the time-stamp-based\n\
    \      PAWS mechanism to prevent errors within a single incarnation due\n    \
    \  to wrapping the 32-bit TCP sequence space at very high transfer\n      rates.\n\
    \   5.5  Conclusions\n      The alternatives for monotonic sequence are summarized\
    \ in Table I.\n      We see that there are two feasible choices for the monotonic\n\
    \      space: the connection count and 64-bit sequence numbers.  Of these\n  \
    \    two, we believe that the simpler is the connection count.\n      Implementation\
    \ of 64-bit sequence numbers would require\n      negotiation of a new header\
    \ format and expansion of all variables\n      and calculations on the sequence\
    \ space.  CC can be carried in an\n      option and need be examined only once\
    \ per packet.\n      We propose to use a simple 32-bit connection count CC, without\n\
    \      augmentation with timestamps, for the transaction extension.  This\n  \
    \    choice has the advantages of simplicity and directness.  Its\n      drawback\
    \ is that it adds a third sequence-like space (in addition\n      to the TCP sequence\
    \ number and the TCP timestamp) to each TCP\n      header and to the main line\
    \ of packet processing.  However, the\n      additional code is in fact very modest.\n\
    \   We now have a general outline of the proposed TCP extensions for\n   transactions.\n\
    \   o    A host maintains a 32-bit global connection counter variable CC.\n  \
    \ o    The sender's current CC value is carried in an option in every\n      \
    \  TCP segment.\n   o    CC values are cached per host, and the TAO mechanism\
    \ is used to\n        bypass the 3-way handshake when possible.\n   o    In non-SYN\
    \ segments, the CC value is used to reject duplicates\n        from earlier incarnations.\
    \  This allows TIME-WAIT state delay to\n        be reduced to K*RTO (i.e., U=0\
    \ in Eq. [2]).\n                TABLE I: Summary of Monotonic Sequences\n    \
    \  APPROACH              TRmax (Tps)    Required MSL      COMMENTS\n   __________________________________________________________________\n\
    \   1. Timestamp & PAWS        1              24 days         TRmax is\n     \
    \                                                       too small\n   __________________________________________________________________\n\
    \   2. Current TCP Sequence Numbers\n     (a) clock-driven\n       ISN: eq. [3]\
    \           268           240 secs      TRmax & MSL\n                        \
    \                                    too small\n     (b) Timestamps& clock-\n\
    \         driven ISN [3] &     10**9         24 days           Hard to\n     \
    \    R=10**9                                            implement\n     (c) Timestamps\
    \ & c-dr\n         ISN: eq. [4]        2**30/(R*Ts)   24 days         TRmax too\n\
    \                                                               small.\n   __________________________________________________________________\n\
    \   3. 64-bit TCP Sequence Numbers\n                          2**63/(MSL*R*Ts)\
    \      MSL        Significant\n                                              \
    \            TCP change\n                           e.g., R=10**9 Bps,\n     \
    \                          MSL = 4.4 hrs,\n                               Ts =\
    \ 0.5 sec=>\n                               TRmax = 10**6\n   __________________________________________________________________\n\
    \   4. Connection Counts\n     (a) no timestamps       2**31/MSL        MSL  \
    \      3rd sequence\n                        e.g., MSL=2000 sec              \
    \        space\n                             TRmax = 10**6\n     (b) with timestamps\
    \     2**30           24 days     (ditto)\n                 and PAWS\n   __________________________________________________________________\n"
- title: 6.  CONNECTION STATES
  contents:
  - "6.  CONNECTION STATES\n   TCP has always allowed a connection to be half-closed.\
    \  TAO makes a\n   significant addition to TCP semantics by allowing a connection\
    \ to be\n   half-synchronized, i.e., to be open for data transfer in one\n   direction\
    \ before the other direction has been opened.  Thus, the\n   passive end of a\
    \ connection (which receives an initial SYN) can\n   accept data and even a FIN\
    \ bit before its own SYN has been\n   acknowledged.  This SYN, data, and FIN may\
    \ arrive on a single segment\n   (as in Figure 4), or on multiple segments; packetization\
    \ makes no\n   difference to the logic of the finite-state machine (FSM) defining\n\
    \   transitions among connection states.\n   Half-synchronized connections have\
    \ several consequences.\n   (a)  The passive end must provide an implied initial\
    \ data window in\n        order to accept data.  The minimum size of this implied\
    \ window\n        is a parameter in the specification; we suggest 4K bytes.\n\
    \   (b)  New connection states and transitions are introduced into the\n     \
    \   TCP FSM at both ends of the connection.  At the active end, new\n        states\
    \ are required to piggy-back the FIN on the initial SYN\n        segment.  At\
    \ the passive end, new states are required for a\n        half-synchronized connection.\n\
    \   This section develops the resulting FSM description of a TCP\n   connection\
    \ as a conventional state/transition diagram.  To develop a\n   complete FSM,\
    \ we take a constructive approach, as follows: (1) write\n   down all possible\
    \ events; (2) write down the precedence rules that\n   govern the order in which\
    \ events may occur; (3) construct the\n   resulting FSM; and (4) augment it to\
    \ support TAO.  In principle, we\n   do this separately for the active and passive\
    \ ends; however, the\n   symmetry of TCP results in the two FSMs being almost\
    \ entirely\n   coincident.\n   Figure 8 lists all possible state transitions for\
    \ a TCP connection in\n   the absence of TAO, as elementary events and corresponding\
    \ actions.\n   Each transition is labeled with a letter.  Transitions a-g are\
    \ used\n   by the active side, and c-i are used by the passive side.  Without\n\
    \   TAO, transition \"c\" (event \"rcv ACK(SYN)\") synchronizes the\n   connection,\
    \ allowing data to be accepted for the user.\n   By definition, the first transition\
    \ for an active (or passive) side\n   must be \"a\" (or \"i\", respectively).\
    \  During a single instance of a\n   connection, the active side will progress\
    \ through some permutation of\n   the complete sequence of transitions {a b c\
    \ d e f } or the sequence\n   {a b c d e f g}.  The set of possible permutations\
    \ is determined by\n   precedence rules governing the order in which transitions\
    \ can occur.\n          Label              Event / Action\n          _____   \
    \           ________________________\n            a                OPEN / snd\
    \ SYN\n            b                rcv SYN [No TAO]/ snd ACK(SYN)\n         \
    \   c                rcv ACK(SYN) /\n            d                CLOSE / snd\
    \ FIN\n            e                rcv FIN / snd ACK(FIN)\n            f    \
    \            rcv ACK(FIN) /\n            g                timeout=2MSL / delete\
    \ TCB\n        ___________________________________________________\n         \
    \   h                passive OPEN / create TCB\n            i                rcv\
    \ SYN [No TAO]/ snd SYN, ACK(SYN)\n        ___________________________________________________\n\
    \           Figure 8.  Basic TCP Connection Transitions\n   Using the notation\
    \ \"<.\" to mean \"must precede\", the precedence rules\n   are:\n   (1)  Logical\
    \ ordering: must open connection before closing it:\n        b <. e\n   (2)  Causality\
    \ -- cannot receive ACK(x) before x has been sent:\n        a <. c and i <. c\
    \ and d <. f\n   (3)  Acknowledgments are cumulative\n        c <. f\n   (4) \
    \ First packet in each direction must contain a SYN.\n        b <. c and b <.\
    \ f\n   (5)  TIME-WAIT state\n        Whenever d precedes e in the sequence, g\
    \ must be the last\n        transition.\n   Applying these rules, we can enumerate\
    \ all possible permutations of\n   the events and summarize them in a state transition\
    \ diagram.  Figure\n   9 shows the result, with boxes representing the states\
    \ and directed\n   arcs representing the transitions.\n          ________    \
    \        ________\n         |        |    h     |        |\n         | CLOSED\
    \ |--------->| LISTEN |\n         |________|          |________|\n           \
    \   |                   |\n              | a                 | i\n          ____V____\
    \           ____V___                 ________\n         |        |    b     |\
    \        |      e        |        |\n         |        |--------->|        |-------------->|\
    \        |\n         |________|          |________|               |________|\n\
    \            /                    /   |                /       |\n           /\
    \                    /    | c           d /        | c\n          /          \
    \          /   __V_____          |    ____V___\n         /                   \
    \ /   |        | e       |   |        |\n      d  |                d  /    | \
    \       |------------>|        |\n         |                   |    |________|\
    \         |   |________|\n         |                   |       |             \
    \  |         |\n         |                   |       |            ___V____   \
    \  |\n         |                   |       |           |        |    |\n     \
    \    |                   |       |           |        |    |\n         |     \
    \              |       |           |________|    |\n         |               \
    \    |       |                   |     |\n     ____V___          ______V_    \
    \  |     ________      |     |\n    |        |    b   |        | e   |    |  \
    \      |     |     |\n    |        |------->|        |--------->|        |   \
    \  |     |\n    |________|        |________|     |    |________|     |     |\n\
    \                              |      /          |        |     |\n          \
    \                  c |     / d       c |      c |   d |\n                    \
    \          |    /            |        |     |\n                             _V___V__\
    \       ____V___     V_____V_\n                            |        |  e  |  \
    \      |   |        |\n                            |        |---->|        | \
    \  |        |\n                            |________|     |________|   |________|\n\
    \                                 |              |           |\n             \
    \                    | f            | f         | f\n                        \
    \     ____V___       ____V___     ___V____\n                            |    \
    \    |  e  | TIME-  | g |        |\n                            |        |---->|\
    \   WAIT |-->| CLOSED |\n                            |________|     |________|\
    \   |________|\n               Figure 9: Basic State Diagram\n   Although Figure\
    \ 9 gives a correct representation of the possible\n   event sequences, it is\
    \ not quite correct for the actions, which do\n   not compose as shown.   In particular,\
    \ once a control bit X has been\n   sent, it must continue to be sent until ACK(X)\
    \ is received.  This\n   requires new transitions with modified actions, shown\
    \ in the\n   following list.  We use the labeling convention that transitions\
    \ with\n   the same event part all have the same letter, with different numbers\n\
    \   of primes to indicate different actions.\n          Label              Event\
    \ / Action\n          _____              _______________________________________\n\
    \            b' (=i)          rcv SYN [No TAO] / snd SYN,ACK(SYN)\n          \
    \  b''              rcv SYN [No TAO] / snd SYN,FIN,ACK(SYN)\n            d'  \
    \             CLOSE / snd SYN,FIN\n            e'               rcv FIN / snd\
    \ FIN,ACK(FIN)\n            e''              rcv FIN / snd SYN,FIN,ACK(FIN)\n\
    \   Figure 10 shows the state diagram of Figure 9, with the modified\n   transitions\
    \ and with the states used by standard TCP [STD-007]\n   identified. Those states\
    \ that do not occur in standard TCP are\n   numbered 1-5.\n   Standard TCP has\
    \ another implied restriction: a FIN bit cannot be\n   recognized before the connection\
    \ has been synchronized, i.e., c <. e.\n   This eliminates from standard TCP the\
    \ states 1, 2, and 5 shown in\n   Figure 10.  States 3 and 4 are needed if a FIN\
    \ is to be piggy-backed\n   on a SYN segment (note that the states shown in Figure\
    \ 1 are actually\n   wrong; the states shown as SYN-SENT and ESTABLISHED are really\
    \ states\n   3 and 4).  In the absence of piggybacking the FIN bit, Figure 10\n\
    \   reduces to the standard TCP state diagram [STD-007].\n   The FSM described\
    \ in Figure 10 is intended to be applied\n   cumulatively; that is, parsing a\
    \ single packet header may lead to\n   more than one transition.  For example,\
    \ the standard TCP state\n   diagram includes a direct transition from SYN-SENT\
    \ to ESTABLISHED:\n       rcv SYN,ACK(SYN) / snd ACK(SYN).\n   This is transition\
    \ b followed immediately by c.\n          ________            ________\n     \
    \    |        |     h    |        |\n         | CLOSED |--------->| LISTEN |\n\
    \         |________|          |________|\n              |                   |\n\
    \              | a                 | i\n          ____V____           ____V___\
    \                 ________\n         | SYN-   |     b'   |  SYN-  |     e'   \
    \     |        |\n         |   SENT |--------->|RECEIVED|-------------->|   1\
    \    |\n         |________|          |________|               |________|\n   \
    \         /                    /   |                  |     |\n         d'/  \
    \                d'/    | c             d' |   c |\n          /              \
    \      /   __V_____             |    _V______\n         /                    /\
    \   |ESTAB-  | e          |   | CLOSE- |\n         |                   /    |\
    \  LISHED|------------|-->|   WAIT |\n         |                   |    |________|\
    \            |   |________|\n         |                   |       |          \
    \        |      |\n         |                   |       |             _____V__\
    \    |\n         |                   |       |            |        |   |\n   \
    \      |                   |       |            |   2    |   |\n         |   \
    \                |       |            |________|   |\n         |             \
    \      |       |                   |     |\n     ____V___          ______V_  \
    \    |     ________      |     |\n    |        |  b''   |        |e''' |    |\
    \        |     |     |\n    |    3   |------->|    4   |--------->|    5   | \
    \    |     |\n    |________|        |________|     |    |________|     |     |\n\
    \                              |      /          |        |     |\n          \
    \                  c |     / d       c |      c |   d |\n                    \
    \          |    /            |        |     |\n                             _V___V__\
    \       ____V___     V_____V_\n                            | FIN-   | e'' |  \
    \      |   | LAST-  |\n                            |  WAIT-1|---->|CLOSING | \
    \  |   ACK  |\n                            |________|     |________|   |________|\n\
    \                                 |              |           |\n             \
    \                    | f            | f         | f\n                        \
    \     ____V___       ____V___     ___V____\n                            | FIN-\
    \   |  e  | TIME-  | g |        |\n                            |  WAIT-2|---->|\
    \   WAIT |-->| CLOSED |\n                            |________|     |________|\
    \   |________|\n        Figure 10: Basic State Diagram -- Correct Actions\n  \
    \ Next we introduce TAO.  If the TAO test succeeds, the connection\n   becomes\
    \ half-synchronized.  This requires a new set of states,\n   mirroring the states\
    \ of Figure 10, beginning with acceptance of a SYN\n   (transition \"b\" or \"\
    i\"), and ending when ACK(SYN) arrives (transition\n   \"c\").  Figure 11 shows\
    \ the result of augmenting Figure 10 with the\n   additional states for TAO. \
    \ The transitions are defined in the\n   following table:\n           Key for\
    \ Figure 11: Complete State Diagram with TAO\n                Label          \
    \  Event / Action\n                _____            ________________________\n\
    \                  a              OPEN / create TCB, snd SYN\n               \
    \   b'             rcv SYN [no TAO]/ snd SYN,ACK(SYN)\n                  b'' \
    \           rcv SYN [no TAO]/ snd SYN,FIN,ACK(SYN)\n                  c      \
    \        rcv ACK(SYN) /\n                  d              CLOSE / snd FIN\n  \
    \                d'             CLOSE / snd SYN,FIN\n                  e     \
    \         rcv FIN / snd ACK(FIN)\n                  e'             rcv FIN / snd\
    \ SYN,ACK(FIN)\n                  e''            rcv FIN / snd FIN,ACK(FIN)\n\
    \                  e'''           rcv FIN / snd SYN,FIN,ACK(FIN)\n           \
    \       f              rcv ACK(FIN) /\n                  g              timeout=2MSL\
    \ / delete TCB\n                  h              passive OPEN / create TCB\n \
    \                 i (= b')       rcv SYN [no TAO]/ snd SYN,ACK(SYN)\n        \
    \          j              rcv SYN [TAO OK] / snd SYN,ACK(SYN)\n              \
    \    k              rcv SYN [TAO OK] / snd SYN,FIN,ACK(SYN)\n   Each new state\
    \ in Figure 11 bears a very simple relationship to a\n   standard TCP state. \
    \ We indicate this by naming the new state with\n   the standard state name followed\
    \ by a star.  States SYN-SENT* and\n   SYN-RECEIVED* differ from the corresponding\
    \ unstarred states in\n   recording the fact that a FIN has been sent.  The other\
    \ new states\n   with starred names differ from the corresponding unstarred states\
    \ in\n   being half-synchronized (hence, a SYN bit needs to be transmitted).\n\
    \   The state diagram of Figure 11 is more general than required for\n   transaction\
    \ processing.  In particular, it handles simultaneous\n   connection synchronization\
    \ from both sides, allowing one or both\n   sides to bypass the 3-way handshake.\
    \  It includes other transitions\n   that are unlikely in normal transaction processing,\
    \ for example, the\n   server sending a FIN before it receives a FIN from the\
    \ client\n   (ESTABLISHED* -> FIN-WAIT-1* in Figure 11).\n   ________        \
    \          ________\n  |        |      h         |        |\n  | CLOSED |--------------->|\
    \ LISTEN |\n  |________|                |________|\n       |                 \
    \    /     |\n      a|                    / i    | j\n       |               \
    \    /       |\n       |                  /       _V______               ________\n\
    \       |           j      |      |ESTAB-  |       e'    | CLOSE- |\n       |\
    \        /---------|----->| LISHED*|------------>|   WAIT*|\n       |       /\
    \          |      |________|             |________|\n       |      /         \
    \  |       |     |                 |    |\n       |     /            |       |d'\
    \   | c            d' |    | c\n   ____V___ /       ______V_      |    _V______\
    \           |   _V______\n  | SYN-   |   b'  |  SYN-  | c   |   |ESTAB-  |  e\
    \       |  | CLOSE- |\n  |   SENT |------>|RECEIVED|-----|-->|  LISHED|----------|->|\
    \   WAIT |\n  |________|       |________|     |   |________|          |  |________|\n\
    \       |               |          |     |                 |       |\n       |\
    \               |          |     |              ___V____   |\n       |       \
    \        |          |     |             | LAST-  |  |\n       | d'           \
    \ | d'       | d'  | d           |  ACK*  |  |\n       |               |     \
    \     |     |             |________|  |\n       |               |          | \
    \    |                    |    |\n       |               |    ______V_    |  \
    \      ________    |c   |d\n       |          k    |   |  FIN-  |   |  e''' |\
    \        |   |    |\n       |        /------|-->| WAIT-1*|---|------>|CLOSING*|\
    \   |    |\n       |       /       |   |________|   |       |________|   |   \
    \ |\n       |      /        |          |     |            |       |    |\n   \
    \    |     /         |          | c   |            | c     |    |\n   ____V___\
    \ /      ____V___       V_____V_       ____V___    V____V__\n  | SYN-   |  b''\
    \ |  SYN-  |  c  |  FIN-  | e'' |        |  | LAST-  |\n  |  SENT* |----->|RECEIVD*|---->|\
    \ WAIT-1 |---->|CLOSING |  |   ACK  |\n  |________|      |________|     |________|\
    \     |________|  |________|\n                                     |         \
    \      |           |\n                                     | f             | f\
    \         | f\n                                  ___V____       ____V___     ___V____\n\
    \                                 |  FIN-  | e   |TIME-   | g |        |\n   \
    \                              | WAIT-2 |---->|   WAIT |-->| CLOSED |\n      \
    \                           |________|     |________|   |________|\n       Figure\
    \ 11: Complete State Diagram with TAO\n   The relationship between starred and\
    \ unstarred states is very\n   regular.  As a result, the state extensions can\
    \ be implemented very\n   simply using the standard TCP FSM with the addition\
    \ of two \"hidden\"\n   boolean flags, as described in the functional specification\
    \ memo\n   [TTCP-FS].\n   As an example of the application of Figure 11, consider\
    \ the minimal\n   transaction shown in Figure 12.\n       TCP A  (Client)    \
    \                             TCP B (Server)\n       _______________         \
    \                        ______________\n       CLOSED                       \
    \                           LISTEN\n   1.  SYN-SENT*    --> <SYN,data1,FIN,CC=x1>\
    \ -->     CLOSE-WAIT*\n                                                      (TAO\
    \ test OK=>\n                                                       data1->user_B)\n\
    \                                                             LAST-ACK*\n    \
    \          <-- <SYN,ACK(FIN),data2,FIN,CC=y1,CC.ECHO=x1> <--\n   2.  TIME-WAIT\n\
    \    (TAO test OK,\n     data2->user_A)\n   3.  TIME-WAIT          --> <ACK(FIN),CC=x2>\
    \ -->              CLOSED\n       (timeout)\n         CLOSED\n             Figure\
    \ 12: Minimal Transaction Sequence\n   Sending segment #1 leaves the client end\
    \ in SYN-SENT* state, which\n   differs from SYN-SENT state in recording the fact\
    \ that a FIN has been\n   sent.  At the server end, passing the TAO test enters\
    \ ESTABLISHED*\n   state, which passes the data to the user as in ESTABLISHED\
    \ state and\n   also records the fact that the connection is half synchronized.\
    \  Then\n   the server processes the FIN bit of segment #1, moving to CLOSE-WAIT*\n\
    \   state.\n   Moving to CLOSE-WAIT* state should cause the server to send a segment\n\
    \   containing SYN and ACK(FIN).  However, transmission of this segment\n   is\
    \ deferred so the server can piggyback the response data and FIN on\n   the same\
    \ segment, unless a timeout occurs first.  When the server\n   does send segment\
    \ #2 containing the response data2 and a FIN, the\n   connection advances from\
    \ CLOSE-WAIT* to LAST-ACK* state; the\n   connection is still half-synchronized\
    \ from B's viewpoint.\n   Processing segment #2 at the client again results in\
    \ multiple\n   transitions:\n       SYN-SENT* -> FIN-WAIT-1* -> CLOSING* -> CLOSING\
    \ -> TIME-WAIT\n   These correspond respectively to receiving a SYN, a FIN, an\
    \ ACK for\n   A's SYN, and an ACK for A's FIN.\n   Figure 13 shows a slightly\
    \ more complex example, a transaction\n   sequence in which request and response\
    \ data each require two\n   segments.  This figure assumes that both client and\
    \ server TCP are\n   well-behaved, so that e.g., the client sends the single segment\
    \ #5 to\n   acknowledge both data segments #3 and #4.  SEG.CC values are omitted\n\
    \   for clarity.\n        _\bT_\bC_\bP__\bA                                  \
    \          _\bT_\bC_\bP__\bB\n    1.  SYN-SENT*      --> <SYN,data1>   -->   \
    \      ESTABLISHED*\n                                                    (TAO\
    \ OK,\n                                                     data1-> user)\n  \
    \  2.  SYN-SENT*      --> <data2,FIN>   -->          CLOSE-WAIT*\n           \
    \                                         (data2-> user)\n    3.  FIN-WAIT-2 \
    \    <-- <SYN,ACK(FIN),data3> <--   CLOSE-WAIT*\n         (data3->user)\n    4.\
    \  TIME_WAIT      <-- <ACK(FIN),data4,FIN> <--     LAST-ACK*\n         (data4->user)\n\
    \    5.  TIME-WAIT      --> <ACK(FIN)> -->                  CLOSED\n         Figure\
    \ 13. Multi-Packet Request/Response Transaction\n"
- title: 7.  CONCLUSIONS AND ACKNOWLEDGMENTS
  contents:
  - "7.  CONCLUSIONS AND ACKNOWLEDGMENTS\n   TCP was designed to be a highly symmetric\
    \ protocol.  This symmetry is\n   evident in the piggy-backing of acknowledgments\
    \ on data and in the\n   common header format for data segments and acknowledgments.\
    \  On the\n   other hand, the examples and discussion in this memo are in general\n\
    \   highly unsymmetrical; the actions of a \"client\" are clearly\n   distinguished\
    \ from those of a \"server\".  To explain this apparent\n   discrepancy, we note\
    \ the following.  Even when TCP is used for\n   virtual circuit service, the data\
    \ transfer phase is symmetrical but\n   the open and close phases are not.  A\
    \ minimal transaction, consisting\n   of one segment in each direction, compresses\
    \ the open, data transfer,\n   and close phases together, and making the asymmetry\
    \ of the open and\n   close phases dominant.  As request and response messages\
    \ increase in\n   size, the virtual circuit model becomes increasingly relevant,\
    \ and\n   symmetry again dominates.\n   TCP's 3-way handshake precludes any performance\
    \ gain from including\n   data on a SYN segment, while TCP's full-duplex data-conserving\
    \ close\n   sequence ties up communication resources to the detriment of high-\n\
    \   speed transactions.  Merely loading more control bits onto TCP data\n   segments\
    \ does not provide efficient transaction service.  To use TCP\n   as an effective\
    \ transaction transport protocol requires bypassing the\n   3-way handshake and\
    \ shortening the TIME-WAIT delay.  This memo has\n   proposed a backwards-compatible\
    \ TCP extension to accomplish both\n   goals.  It is our hope that by building\
    \ upon the current version of\n   TCP, we can give a boost to community acceptance\
    \ of the new\n   facilities.  Furthermore, the resulting protocol implementations\
    \ will\n   retain the algorithms that have been developed for flow and\n   congestion\
    \ control in TCP [Jacobson88].\n   O'Malley and Peterson have recently recommended\
    \ against backwards-\n   compatible extensions to TCP, and suggested instead a\
    \ mechanism to\n   allow easy installation of alternative versions of a protocol\
    \ [RFC-\n   1263].  While this is an interesting long-term approach, in the\n\
    \   shorter term we suggest that incremental extension of the current TCP\n  \
    \ may be a more effective route.\n   Besides the backward-compatible extension\
    \ proposed here, there are\n   two other possible approaches to making efficient\
    \ transaction\n   processing widely available in the Internet: (1) a new version\
    \ of TCP\n   or (2) a new protocol specifically adapted to transactions.  Since\n\
    \   current TCP \"almost\" supports transactions, we favor (1) over (2).  A\n\
    \   new version of TCP that retained the semantics of STD-007 but used 64\n  \
    \ bit sequence numbers with the procedures and states described in\n   Sections\
    \ 3, 4, and 6 of this memo would support transactions as well\n   as virtual circuits\
    \ in a clean, coherent manner.\n   A potential application of transaction-mode\
    \ TCP might be SMTP.  If\n   commands and responses are batched, in favorable\
    \ cases complete SMTP\n   delivery operations on short messages could be performed\
    \ with a\n   single minimal transaction; on the other hand, the body of a message\n\
    \   may be arbitrarily large.  Using a TCP extended as in this memo could\n  \
    \ significantly reduce the load on large mail hosts.\n   This work began as an\
    \ elaboration of the concept of TAO, due to Dave\n   Clark.  I am grateful to\
    \ him and to Van Jacobson, John Wroclawski,\n   Dave Borman, and other members\
    \ of the End-to-End Research group for\n   helpful ideas and critiques during\
    \ the long development of this work.\n   I also thank Liming Wei, who tested the\
    \ initial implementation in Sun\n   OS.\n"
- title: APPENDIX A -- TIME-WAIT STATE AND THE 2-PACKET EXCHANGE
  contents:
  - "APPENDIX A -- TIME-WAIT STATE AND THE 2-PACKET EXCHANGE\n   This appendix considers\
    \ the implications of reducing TIME-WAIT state\n   delay below that given in formula\
    \ [2].\n   An immediate consequence of this would be the requirement for the\n\
    \   server host to accept an initial SYN for a connection in LAST-ACK\n   state.\
    \  Without the transaction extensions, the arrival of a new\n   <SYN> in LAST-ACK\
    \ state looks to TCP like a half-open connection, and\n   TCP's rules are designed\
    \ to restore correspondence by destroying the\n   state (through sending a RST\
    \ segment) at one end or the other.  We\n   would need to thwart this action in\
    \ the case of transactions.\n   There are two different possible ways to further\
    \ reduce TIME-WAIT\n   delay.\n   (1)  Explicit Truncation of TIME-WAIT state\n\
    \        TIME-WAIT state could be explicitly truncated by accepting a new\n  \
    \      sendto() request for a connection in TIME-WAIT state.\n        This would\
    \ allow the ACK(FIN) segment to be delayed and sent\n        only if a timeout\
    \ occurs before a new request arrives.  This\n        allows an ideal 2-segment\
    \ exchange for closely-spaced\n        transactions, which would restore some\
    \ symmetry to the\n        transaction exchange.  However, explicit truncation\
    \ would\n        represent a significant change in many implementations.\n   \
    \     It might be supposed that even greater symmetry would result if\n      \
    \  the new request segment were a <SYN,ACK> that explicitly\n        acknowledges\
    \ the previous reply, rather than a <SYN> that is\n        only an implicit acknowledgment.\
    \  However, the new request\n        segment might arrive at B to find the server\
    \ side in either\n        LAST-ACK or CLOSED state, depending upon whether the\
    \ ACK(FIN)\n        had arrived.  In CLOSED state, a <SYN,ACK> would not be\n\
    \        acceptable.  Hence, if the client sent an initial <SYN,ACK>\n       \
    \ instead of a <SYN> segment, there would be a race condition at\n        the\
    \ server.\n   (2)  No TIME-WAIT delay\n        TIME-WAIT delay could be removed\
    \ entirely.  This would imply\n        that the ACK(FIN) would always be sent\
    \ (which does not of course\n        guarantee that it will be received).  As\
    \ a result, the arrival\n        of a new SYN in LAST-ACK state would be rare.\n\
    \        This choice is much simpler to implement.  Its drawback is that\n   \
    \     the server will get a false failure report if the ACK(FIN) is\n        lost.\
    \  This may not matter in practice, but it does represent a\n        significant\
    \ change of TCP semantics.  It should be noted that\n        reliable delivery\
    \ of the reply is not an issue.  The client\n        enter TIME-WAIT state only\
    \ after the entire reply, including the\n        FIN bit, has been received successfully.\n\
    \   The server host B must be certain that a new request received in\n   LAST-ACK\
    \ state is indeed a new SYN and not an old duplicate;\n   otherwise, B could falsely\
    \ acknowledge a previous response that has\n   not in fact been delivered to A.\
    \  If the TAO comparison succeeds, the\n   SYN must be new; however, the server\
    \ has a dilemma if the TAO test\n   fails.\n   In Figure A.1, for example, the\
    \ reply segment from the first\n   transaction has been lost; since it has not\
    \ been acknowledged, it is\n   still in B's retransmission queue.  An old duplicate\
    \ request, segment\n   #3, arrives at B and its TAO test fails.  B is in the position\
    \ of\n   having old state it cannot discard (the retransmission queue) and\n \
    \  needing to build new state to pursue a 3-way handshake to validate\n   the\
    \ new SYN.  If the 3-way handshake failed, it would need to restore\n   the earlier\
    \ LAST-ACK* state.  (Compare with Figure 15 \"Old Duplicate\n   SYN Initiates\
    \ a Reset on Two Passive Sockets\" in STD-007).  This\n   would be complex and\
    \ difficult to accomplish in many implementations.\n       TCP A  (Client)   \
    \                            TCP B (Server)\n       _______________          \
    \                     ______________\n         CLOSED                        \
    \                  LISTEN\n   1.    SYN-SENT*       --> <SYN,data1,FIN> -->  \
    \  CLOSE-WAIT*\n                                                     (TAO test\
    \ OK;\n                                                      data1->server)\n\
    \   2.        (lost) X<-- <SYN,ACK(FIN),data2,FIN> <-- LAST-ACK*\n           \
    \        (old duplicate)\n   3.                     ... <SYN,data3,FIN> -->  \
    \   LAST-ACK*\n                                                  (TAO test fail;\n\
    \                                                   3-way handshake?)\n      \
    \           Figure A.1: The Server's Dilemma\n   The only practical action A can\
    \ taken when the TAO test fails on a\n   new SYN received in LAST-ACK state is\
    \ to ignore the SYN, assuming it\n   is really an old duplicate.  We must pursue\
    \ the possible consequences\n   of this action.\n   Section 3.1 listed four possible\
    \ reasons for failure of the TAO test\n   on a legitimate SYN segment: (1) no\
    \ cached state, (2) out-of-order\n   delivery of SYNs, (3) wraparound of CCgen\
    \ relative to the cached\n   value, or (4) the M values advance too slowly.  \
    \ We are assuming that\n   there is a cached CC value at B (otherwise, the SYN\
    \ cannot be\n   acceptable in LAST-ACK state).  Wrapping the CC space is very\n\
    \   unlikely and probably impossible; it is difficult to imagine\n   circumstances\
    \ which would allow the new SYN to be delivered but not\n   the ACK(FIN), especially\
    \ given the long wraparound time of CCgen.\n   This leaves the problem of out-of-order\
    \ delivery of two nearly-\n   concurrent SYNs for different ports.  The second\
    \ to be delivered may\n   have a lower CC option and thus be locked out.  This\
    \ can be solved by\n   using a new CCgen value for every retransmission of an\
    \ initial SYN.\n   Truncation of TIME-WAIT state and acceptance of a SYN in LAST-ACK\n\
    \   state should take place only if there is a cached CC value for the\n   remote\
    \ host.  Otherwise, a SYN arriving in LAST-ACK state is to be\n   processed by\
    \ normal TCP rules, which will result in a RST segment\n   from either A or B.\n\
    \   This discussion leads to a paradigm for rejecting old duplicate\n   segments\
    \ that is different from TAO.  This alternative scheme is\n   based upon the following:\n\
    \   (a)  Each retransmission of an initial SYN will have a new value of\n    \
    \    CC, as described above.\n        This provision takes care of reordered SYNs.\n\
    \   (b)  A host maintains a distinct CCgen value for each remote host.\n     \
    \   This value could easily be maintained in the same cache used for\n       \
    \ the received CC values, e.g., as cache.CCgen[].\n        Once the caches are\
    \ primed, it should always be true that\n        cache.CCgen[B] on host A is equal\
    \ to cache.CC[A] on host B, and\n        the next transaction from A will carry\
    \ a CC value exactly 1\n        greater.  Thus, there is no problem of wraparound\
    \ of the CC\n        value.\n   (c)  A new SYN is acceptable if its SEG.CC > cache.CC[client],\n\
    \        otherwise the SYN is ignored as an old duplicate.\n   This alternative\
    \ paradigm was not adopted because it would be a\n   somewhat greater perturbation\
    \ of TCP rules, because it may not have\n   the robustness of TAO, and because\
    \ all of its consequences may not be\n   understood.\n"
- title: REFERENCES
  contents:
  - "REFERENCES\n    [Birrell84]  Birrell, A. and B. Nelson, \"Implementing Remote\n\
    \      Procedure Calls\", ACM TOCS, Vo. 2, No. 1, February 1984.\n    [Clark88]\
    \  Clark, D., \"The Design Philosophy of the Internet\n      Protocols\", ACM\
    \ SIGCOMM '88, Stanford, CA, August 1988.\n    [Clark89]  Clark, D., Private communication,\
    \ 1989.\n    [Garlick77]  Garlick, L., R. Rom, and J. Postel, \"Issues in Reliable\n\
    \      Host-to-Host Protocols\", Proc. Second Berkeley Workshop on\n      Distributed\
    \ Data Management and Computer Networks, May 1977.\n    [HR-COMM]  Braden, R.,\
    \ Ed., \"Requirements for Internet Hosts --\n      Communication Layers\", STD-003,\
    \ RFC-1122, October 1989.\n    [Jacobson88] Jacobson, V., \"Congestion Avoidance\
    \ and Control\",\n      SIGCOMM '88, Stanford, CA., August 1988.\n    [Jacobson90]\
    \ Jacobson, V., private communication, 1990.\n    [Liskov90]  Liskov, B., Shrira,\
    \ L., and J. Wroclawski, \"Efficient\n      At-Most-Once Messages Based on Synchronized\
    \ Clocks\", ACM SIGCOMM\n      '90, Philadelphia, PA, September 1990.\n    [RFC-955]\
    \  Braden, R., \"Towards a Transport Service Transaction\n      Protocol\", RFC-955,\
    \ September 1985.\n    [RFC-1185]  Jacobson, V., Braden, R., and Zhang, L., \"\
    TCP Extension\n      for High-Speed Paths\", RFC-1185, October 1990.\n    [RFC-1263]\
    \  O'Malley, S. and L. Peterson, \"TCP Extensions Considered\n      Harmful\"\
    , RFC-1263, University of Arizona, October 1991.\n    [RFC-1323]  Jacobson, V.,\
    \ Braden, R., and Borman, D., \"TCP\n      Extensions for High Performance, RFC-1323,\
    \ February 1991.\n    [RFC-1337]  Braden, R., \"TIME-WAIT Assassination Hazards\
    \ in TCP\",\n      RFC-1337, May 1992.\n    [STD-007]  Postel, J., \"Transmission\
    \ Control Protocol - DARPA\n      Internet Program Protocol Specification\", STD-007,\
    \ RFC-793,\n      September 1981.\n    [TTCP-FS]  Braden, R., \"Transaction TCP\
    \ -- Functional\n      Specification\", Work in Progress, September 1992.\n  \
    \  [Watson81]  Watson, R., \"Timer-based Mechanisms in Reliable\n      Transport\
    \ Protocol Connection Management\", Computer Networks, Vol.\n      5, 1981.\n"
- title: Security Considerations
  contents:
  - "Security Considerations\n   Security issues are not discussed in this memo.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Bob Braden\n   University of Southern California\n   Information\
    \ Sciences Institute\n   4676 Admiralty Way\n   Marina del Rey, CA 90292\n   Phone:\
    \ (310) 822-1511\n   EMail: Braden@ISI.EDU\n"
