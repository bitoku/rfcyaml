- contents:
  - '                        DNS Stateful Operations

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document defines a new DNS OPCODE for DNS Stateful Operations\n
    \  (DSO).  DSO messages communicate operations within persistent\n   stateful
    sessions using Type Length Value (TLV) syntax.  Three TLVs\n   are defined that
    manage session timeouts, termination, and encryption\n   padding, and a framework
    is defined for extensions to enable new\n   stateful operations.  This document
    updates RFC 1035 by adding a new\n   DNS header OPCODE that has both different
    message semantics and a new\n   result code.  This document updates RFC 7766 by
    redefining a session,\n   providing new guidance on connection reuse, and providing
    a new\n   mechanism for handling session idle timeouts.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8490.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2019 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (https://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   4\n   2.  Requirements Language . . . . . . . . . . . . . . . . .
    . . .   6\n   3.  Terminology . . . . . . . . . . . . . . . . . . . . . . . .
    .   6\n   4.  Applicability . . . . . . . . . . . . . . . . . . . . . . . .   9\n
    \    4.1.  Use Cases . . . . . . . . . . . . . . . . . . . . . . . .   9\n       4.1.1.
    \ Session Management  . . . . . . . . . . . . . . . . .   9\n       4.1.2.  Long-Lived
    Subscriptions  . . . . . . . . . . . . . .   9\n     4.2.  Applicable Transports
    . . . . . . . . . . . . . . . . . .  10\n   5.  Protocol Details  . . . . . .
    . . . . . . . . . . . . . . . .  11\n     5.1.  DSO Session Establishment . .
    . . . . . . . . . . . . . .  12\n       5.1.1.  DSO Session Establishment Failure
    . . . . . . . . . .  13\n       5.1.2.  DSO Session Establishment Success . .
    . . . . . . . .  14\n     5.2.  Operations after DSO Session Establishment  .
    . . . . . .  14\n     5.3.  DSO Session Termination . . . . . . . . . . . . .
    . . . .  15\n       5.3.1.  Handling Protocol Errors  . . . . . . . . . . . .
    . .  15\n     5.4.  Message Format  . . . . . . . . . . . . . . . . . . . . .
    \ 16\n       5.4.1.  DNS Header Fields in DSO Messages . . . . . . . . . .  17\n
    \      5.4.2.  DSO Data  . . . . . . . . . . . . . . . . . . . . . .  18\n       5.4.3.
    \ DSO Unidirectional Messages . . . . . . . . . . . . .  20\n       5.4.4.  TLV
    Syntax  . . . . . . . . . . . . . . . . . . . . .  21\n       5.4.5.  Unrecognized
    TLVs . . . . . . . . . . . . . . . . . .  22\n       5.4.6.  EDNS(0) and TSIG
    \ . . . . . . . . . . . . . . . . . .  23\n     5.5.  Message Handling  . . .
    . . . . . . . . . . . . . . . . .  24\n       5.5.1.  Delayed Acknowledgement
    Management  . . . . . . . . .  25\n       5.5.2.  MESSAGE ID Namespaces . . .
    . . . . . . . . . . . . .  26\n       5.5.3.  Error Responses . . . . . . . .
    . . . . . . . . . . .  27\n     5.6.  Responder-Initiated Operation Cancellation
    \ . . . . . . .  28\n   6.  DSO Session Lifecycle and Timers  . . . . . . . .
    . . . . . .  29\n     6.1.  DSO Session Initiation  . . . . . . . . . . . . .
    . . . .  29\n     6.2.  DSO Session Timeouts  . . . . . . . . . . . . . . . .
    . .  30\n     6.3.  Inactive DSO Sessions . . . . . . . . . . . . . . . . . .
    \ 31\n     6.4.  The Inactivity Timeout  . . . . . . . . . . . . . . . . .  32\n
    \      6.4.1.  Closing Inactive DSO Sessions . . . . . . . . . . . .  32\n       6.4.2.
    \ Values for the Inactivity Timeout . . . . . . . . . .  33\n     6.5.  The Keepalive
    Interval  . . . . . . . . . . . . . . . . .  34\n       6.5.1.  Keepalive Interval
    Expiry . . . . . . . . . . . . . .  34\n       6.5.2.  Values for the Keepalive
    Interval . . . . . . . . . .  34\n     6.6.  Server-Initiated DSO Session Termination
    \ . . . . . . . .  36\n       6.6.1.  Server-Initiated Retry Delay Message  .
    . . . . . . .  37\n       6.6.2.  Misbehaving Clients . . . . . . . . . . . .
    . . . . .  38\n       6.6.3.  Client Reconnection . . . . . . . . . . . . . .
    . . .  38\n   7.  Base TLVs for DNS Stateful Operations . . . . . . . . . . .
    .  40\n     7.1.  Keepalive TLV . . . . . . . . . . . . . . . . . . . . . .  40\n
    \      7.1.1.  Client Handling of Received Session Timeout Values  .  42\n       7.1.2.
    \ Relationship to edns-tcp-keepalive EDNS(0) Option . .  43\n     7.2.  Retry
    Delay TLV . . . . . . . . . . . . . . . . . . . . .  44\n       7.2.1.  Retry
    Delay TLV Used as a Primary TLV . . . . . . . .  44\n       7.2.2.  Retry Delay
    TLV Used as a Response Additional TLV . .  46\n     7.3.  Encryption Padding TLV
    \ . . . . . . . . . . . . . . . . .  46\n   8.  Summary Highlights  . . . . .
    . . . . . . . . . . . . . . . .  47\n     8.1.  QR Bit and MESSAGE ID . . . .
    . . . . . . . . . . . . . .  47\n     8.2.  TLV Usage . . . . . . . . . . . .
    . . . . . . . . . . . .  48\n   9.  Additional Considerations . . . . . . . .
    . . . . . . . . . .  50\n     9.1.  Service Instances . . . . . . . . . . . .
    . . . . . . . .  50\n     9.2.  Anycast Considerations  . . . . . . . . . . .
    . . . . . .  51\n     9.3.  Connection Sharing  . . . . . . . . . . . . . . .
    . . . .  52\n     9.4.  Operational Considerations for Middleboxes  . . . . .
    . .  53\n     9.5.  TCP Delayed Acknowledgement Considerations  . . . . . . .
    \ 54\n   10. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  57\n
    \    10.1.  DSO OPCODE Registration  . . . . . . . . . . . . . . . .  57\n     10.2.
    \ DSO RCODE Registration . . . . . . . . . . . . . . . . .  57\n     10.3.  DSO
    Type Code Registry . . . . . . . . . . . . . . . . .  57\n   11. Security Considerations
    . . . . . . . . . . . . . . . . . . .  59\n     11.1.  TLS Zero Round-Trip Considerations
    . . . . . . . . . . .  59\n   12. References  . . . . . . . . . . . . . . . .
    . . . . . . . . .  60\n     12.1.  Normative References . . . . . . . . . . .
    . . . . . . .  60\n     12.2.  Informative References . . . . . . . . . . . .
    . . . . .  61\n   Acknowledgements  . . . . . . . . . . . . . . . . . . . . .
    . . .  63\n   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . .
    .  63\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This document specifies a mechanism for managing stateful
    DNS\n   connections.  DNS most commonly operates over a UDP transport, but it\n
    \  can also operate over streaming transports; the original DNS RFC\n   specifies
    DNS-over-TCP [RFC1035], and a profile for DNS-over-TLS\n   [RFC7858] has been
    specified.  These transports can offer persistent\n   long-lived sessions and
    therefore, when using them for transporting\n   DNS messages, it is of benefit
    to have a mechanism that can establish\n   parameters associated with those sessions,
    such as timeouts.  In such\n   situations, it is also advantageous to support
    server-initiated\n   messages (such as DNS Push Notifications [Push]).\n   The
    existing Extension Mechanism for DNS (EDNS(0)) [RFC6891] is\n   explicitly defined
    to only have \"per-message\" semantics.  While\n   EDNS(0) has been used to signal
    at least one session-related\n   parameter (edns-tcp-keepalive EDNS(0) Option
    [RFC7828]), the result\n   is less than optimal due to the restrictions imposed
    by the EDNS(0)\n   semantics and the lack of server-initiated signaling.  For
    example, a\n   server cannot arbitrarily instruct a client to close a connection\n
    \  because the server can only send EDNS(0) options in responses to\n   queries
    that contained EDNS(0) options.\n   This document defines a new DNS OPCODE for
    DNS Stateful Operations\n   (DSO) with a value of 6.  DSO messages are used to
    communicate\n   operations within persistent stateful sessions, expressed using
    Type\n   Length Value (TLV) syntax.  This document defines an initial set of\n
    \  three TLVs used to manage session timeouts, termination, and\n   encryption
    padding.\n   All three TLVs defined here are mandatory for all implementations
    of\n   DSO.  Further TLVs may be defined in additional specifications.\n   DSO
    messages may or may not be acknowledged.  Whether a DSO message\n   is to be acknowledged
    (a DSO request message) or is not to be\n   acknowledged (a DSO unidirectional
    message) is specified in the\n   definition of that particular DSO message type.
    \ The MESSAGE ID is\n   nonzero for DSO request messages, and zero for DSO unidirectional\n
    \  messages.  Messages are pipelined and responses may appear out of\n   order
    when multiple requests are being processed concurrently.\n   The format for DSO
    messages (Section 5.4) differs somewhat from the\n   traditional DNS message format
    used for standard queries and\n   responses.  The standard twelve-byte header
    is used, but the four\n   count fields (QDCOUNT, ANCOUNT, NSCOUNT, ARCOUNT) are
    set to zero,\n   and accordingly their corresponding sections are not present.\n
    \  The actual data pertaining to DNS Stateful Operations (expressed in\n   TLV
    syntax) is appended to the end of the DNS message header.  Just\n   as in traditional
    DNS-over-TCP [RFC1035] [RFC7766], the stream\n   protocol carrying DSO messages
    (which are just another kind of DNS\n   message) frames them by putting a 16-bit
    message length at the start.\n   The length of the DSO message is therefore determined
    from that\n   length rather than from any of the DNS header counts.\n   When displayed
    using packet analyzer tools that have not been updated\n   to recognize the DSO
    format, this will result in the DSO data being\n   displayed as unknown extra
    data after the end of the DNS message.\n   This new format has distinct advantages
    over an RR-based format\n   because it is more explicit and more compact.  Each
    TLV definition is\n   specific to its use case and, as a result, contains no redundant
    or\n   overloaded fields.  Importantly, it completely avoids conflating DNS\n
    \  Stateful Operations in any way with normal DNS operations or with\n   existing
    EDNS(0)-based functionality.  A goal of this approach is to\n   avoid the operational
    issues that have befallen EDNS(0), particularly\n   relating to middlebox behavior
    (see sections discussing EDNS(0), and\n   problems caused by firewalls and load
    balancers, in the recent work\n   describing causes of DNS failures [Fail]).\n
    \  With EDNS(0), multiple options may be packed into a single OPT\n   pseudo-RR,
    and there is no generalized mechanism for a client to be\n   able to tell whether
    a server has processed or otherwise acted upon\n   each individual option within
    the combined OPT pseudo-RR.  The\n   specifications for each individual option
    need to define how each\n   different option is to be acknowledged, if necessary.\n
    \  In contrast to EDNS(0), with DSO there is no compelling motivation to\n   pack
    multiple operations into a single message for efficiency\n   reasons, because
    DSO always operates using a connection-oriented\n   transport protocol.  Each
    DSO operation is communicated in its own\n   separate DNS message, and the transport
    protocol can take care of\n   packing several DNS messages into a single IP packet
    if appropriate.\n   For example, TCP can pack multiple small DNS messages into
    a single\n   TCP segment.  This simplification allows for clearer semantics.  Each\n
    \  DSO request message communicates just one primary operation, and the\n   RCODE
    in the corresponding response message indicates the success or\n   failure of
    that operation.\n"
  title: 1.  Introduction
- contents:
  - "2.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
    \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT
    RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted
    as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear
    in all\n   capitals, as shown here.\n"
  title: 2.  Requirements Language
- contents:
  - "3.  Terminology\n   DSO:  DNS Stateful Operations.\n   connection:  a bidirectional
    byte (or message) stream, where the\n      bytes (or messages) are delivered reliably
    and in order, such as\n      provided by using DNS-over-TCP [RFC1035] [RFC7766]
    or DNS-over-TLS\n      [RFC7858].\n   session:  the unqualified term \"session\"
    in the context of this\n      document refers to a persistent network connection
    between two\n      endpoints that allows for the exchange of DNS messages over
    a\n      connection where either end of the connection can send messages to\n
    \     the other end.  (The term has no relationship to the \"session\n      layer\"
    of the OSI \"seven-layer model\".)\n   DSO Session:  a session established between
    two endpoints that\n      acknowledge persistent DNS state via the exchange of
    DSO messages\n      over the connection.  This is distinct from a DNS-over-TCP
    session\n      as described in the previous specification for DNS-over-TCP\n      [RFC7766].\n
    \  close gracefully:  a normal session shutdown where the client closes\n      the
    TCP connection to the server using a graceful close such that\n      no data is
    lost (e.g., using TCP FIN; see Section 5.3).\n   forcibly abort:  a session shutdown
    as a result of a fatal error\n      where the TCP connection is unilaterally aborted
    without regard\n      for data loss (e.g., using TCP RST; see Section 5.3).\n
    \  server:  the software with a listening socket, awaiting incoming\n      connection
    requests, in the usual DNS sense.\n   client:  the software that initiates a connection
    to the server's\n      listening socket, in the usual DNS sense.\n   initiator:
    \ the software that sends a DSO request message or a DSO\n      unidirectional
    message during a DSO Session.  Either a client or\n      server can be an initiator.\n
    \  responder:  the software that receives a DSO request message or a DSO\n      unidirectional
    message during a DSO Session.  Either a client or a\n      server can be a responder.\n
    \  sender:  the software that is sending a DNS message, a DSO message, a\n      DNS
    response, or a DSO response.\n   receiver:  the software that is receiving a DNS
    message, a DSO\n      message, a DNS response, or a DSO response.\n   service
    instance:  a specific instance of server software running on\n      a specific
    host (Section 9.1).\n   long-lived operation:  an outstanding operation on a DSO
    Session\n      where either the client or server, acting as initiator, has\n      requested
    that the responder send new information regarding the\n      request, as it becomes
    available.\n   early data:  a TLS 1.3 handshake containing data on the first flight\n
    \     that begins a DSO Session (Section 2.3 of the TLS 1.3\n      specification
    [RFC8446]).  TCP Fast Open [RFC7413] is only\n      permitted when using TLS.\n
    \  DNS message:  any DNS message, including DNS queries, responses,\n      updates,
    DSO messages, etc.\n   DNS request message:  any DNS message where the QR bit
    is 0.\n   DNS response message:  any DNS message where the QR bit is 1.\n   DSO
    message:  a DSO request message, DSO unidirectional message, or\n      DSO response
    to a DSO request message.  If the QR bit is 1 in a\n      DSO message, it is a
    DSO response message.  If the QR bit is 0 in\n      a DSO message, it is a DSO
    request message or DSO unidirectional\n      message, as determined by the specification
    of its Primary TLV.\n   DSO response message:  a response to a DSO request message.\n
    \  DSO request message:  a DSO message that requires a response.\n   DSO unidirectional
    message:  a DSO message that does not require and\n      cannot induce a response.\n
    \  Primary TLV:  the first TLV in a DSO request message or DSO\n      unidirectional
    message; this determines the nature of the\n      operation being performed.\n
    \  Additional TLV:  any TLVs that follow the Primary TLV in a DSO\n      request
    message or DSO unidirectional message.\n   Response Primary TLV:  in a DSO response,
    any TLVs with the same DSO-\n      TYPE as the Primary TLV from the corresponding
    DSO request\n      message.  If present, any Response Primary TLV(s) MUST appear\n
    \     first in the DSO response message, before any Response Additional\n      TLVs.\n
    \  Response Additional TLV:  any TLVs in a DSO response that follow the\n      (optional)
    Response Primary TLV(s).\n   inactivity timer:  the time since the most recent
    non-keepalive DNS\n      message was sent or received (see Section 6.4).\n   keepalive
    timer:  the time since the most recent DNS message was sent\n      or received
    (see Section 6.5).\n   session timeouts:  the inactivity timer and the keepalive
    timer.\n   inactivity timeout:  the maximum value that the inactivity timer can\n
    \     have before the connection is gracefully closed.\n   keepalive interval:
    \ the maximum value that the keepalive timer can\n      have before the client
    is required to send a keepalive (see\n      Section 7.1).\n   resetting a timer:
    \ setting the timer value to zero and restarting\n      the timer.\n   clearing
    a timer:  setting the timer value to zero but not restarting\n      the timer.\n"
  title: 3.  Terminology
- contents:
  - "4.  Applicability\n   DNS Stateful Operations are applicable to several known
    use cases and\n   are only applicable on transports that are capable of supporting
    a\n   DSO Session.\n"
  - contents:
    - "4.1.  Use Cases\n   Several use cases for DNS Stateful Operations are described
      below.\n"
    - contents:
      - "4.1.1.  Session Management\n   In one use case, establishing session parameters
        such as server-\n   defined timeouts is of great use in the general management
        of\n   persistent connections.  For example, using DSO Sessions for stub-to-\n
        \  recursive DNS-over-TLS [RFC7858] is more flexible for both the client\n
        \  and the server than attempting to manage sessions using just the\n   edns-tcp-keepalive
        EDNS(0) Option [RFC7828].  The simple set of TLVs\n   defined in this document
        is sufficient to greatly enhance connection\n   management for this use case.\n"
      title: 4.1.1.  Session Management
    - contents:
      - "4.1.2.  Long-Lived Subscriptions\n   In another use case, DNS-based Service
        Discovery (DNS-SD) [RFC6763]\n   has evolved into a naturally session-based
        mechanism where, for\n   example, long-lived subscriptions lend themselves
        to 'push'\n   mechanisms as opposed to polling.  Long-lived stateful connections\n
        \  and server-initiated messages align with this use case [Push].\n   A general
        use case is that DNS traffic is often bursty, but session\n   establishment
        can be expensive.  One challenge with long-lived\n   connections is sustaining
        sufficient traffic to maintain NAT and\n   firewall state.  To mitigate this
        issue, this document introduces a\n   new concept for the DNS -- DSO \"keepalive
        traffic\".  This traffic\n   carries no DNS data and is not considered 'activity'
        in the classic\n   DNS sense, but it serves to maintain state in middleboxes
        and to\n   assure the client and server that they still have connectivity
        to\n   each other.\n"
      title: 4.1.2.  Long-Lived Subscriptions
    title: 4.1.  Use Cases
  - contents:
    - "4.2.  Applicable Transports\n   DNS Stateful Operations are applicable in cases
      where it is useful to\n   maintain an open session between a DNS client and
      server, where the\n   transport allows such a session to be maintained, and
      where the\n   transport guarantees in-order delivery of messages on which DSO\n
      \  depends.  Two specific transports that meet the requirements to\n   support
      DNS Stateful Operations are DNS-over-TCP [RFC1035] [RFC7766]\n   and DNS-over-TLS
      [RFC7858].\n   Note that in the case of DNS-over-TLS, there is no mechanism
      for\n   upgrading from DNS-over-TCP to DNS-over-TLS mid-connection (see\n   Section
      7 of the DNS-over-TLS specification [RFC7858]).  A connection\n   is either
      DNS-over-TCP from the start, or DNS-over-TLS from the\n   start.\n   DNS Stateful
      Operations are not applicable for transports that cannot\n   support clean session
      semantics or that do not guarantee in-order\n   delivery.  While in principle
      such a transport could be constructed\n   over UDP, the current specification
      of DNS-over-UDP [RFC1035] does\n   not provide in-order delivery or session
      semantics and hence cannot\n   be used.  Similarly, DNS-over-HTTP [RFC8484]
      cannot be used because\n   HTTP has its own mechanism for managing sessions,
      which is\n   incompatible with the mechanism specified here.\n   Only DNS-over-TCP
      and DNS-over-TLS are currently defined for use with\n   DNS Stateful Operations.
      \ Other transports may be added in the future\n   if they meet the requirements
      set out in the first paragraph of this\n   section.\n"
    title: 4.2.  Applicable Transports
  title: 4.  Applicability
- contents:
  - "5.  Protocol Details\n   The overall flow of DNS Stateful Operations goes through
    a series of\n   phases:\n   Connection Establishment:  A client establishes a
    connection to a\n      server (Section 4.2).\n   Connected but Sessionless:  A
    connection exists, but a DSO Session\n      has not been established.  DNS messages
    can be sent from the\n      client to server, and DNS responses can be sent from
    the server to\n      the client.  In this state, a client that wishes to use DSO
    can\n      attempt to establish a DSO Session (Section 5.1).  Standard DNS-\n
    \     over-TCP inactivity timeout handling is in effect [RFC7766] (see\n      Section
    7.1.2 of this document).\n   DSO Session Establishment in Progress:  A client
    has sent a DSO\n      request within the last 30 seconds, but has not yet received
    a DSO\n      response for that request.  In this phase, the client may send\n
    \     more DSO requests and more DNS requests, but MUST NOT send DSO\n      unidirectional
    messages (Section 5.1).\n   DSO Session Establishment Timeout:  A client has sent
    a DSO request,\n      and after 30 seconds has still received no DSO response
    for that\n      request.  This means that the server is now in an indeterminate\n
    \     state.  The client forcibly aborts the connection.  The client MAY\n      reconnect
    without using DSO, if appropriate.\n   DSO Session Establishment Failed:  A client
    has sent a DSO request,\n      and received a corresponding DSO response with
    a nonzero RCODE.\n      This means that the attempt to establish the DSO Session
    did not\n      succeed.  At this point, the client is permitted to continue\n
    \     operating without a DSO Session (Connected but Sessionless) but\n      does
    not send further DSO messages (Section 5.1).\n   DSO Session Established:  A client
    has sent a DSO request, and\n      received a corresponding DSO response with
    RCODE set to NOERROR\n      (0).  A DSO Session has now been successfully established.
    \ Both\n      client and server may send DSO messages and DNS messages; both may\n
    \     send replies in response to messages they receive (Section 5.2).\n      The
    inactivity timer (Section 6.4) is active; the keepalive timer\n      (Section
    6.5) is active.  Standard DNS-over-TCP inactivity timeout\n      handling is no
    longer in effect [RFC7766] (see Section 7.1.2 of\n      this document).\n   Server
    Shutdown:  The server has decided to gracefully terminate the\n      session and
    has sent the client a Retry Delay message\n      (Section 6.6.1).  There may still
    be unprocessed messages from the\n      client; the server will ignore these.
    \ The server will not send\n      any further messages to the client (Section
    6.6.1.1).\n   Client Shutdown:  The client has decided to disconnect, either\n
    \     because it no longer needs service, the connection is inactive\n      (Section
    6.4.1), or because the server sent it a Retry Delay\n      message (Section 6.6.1).
    \ The client closes the connection\n      gracefully (Section 5.3).\n   Reconnect:
    \ The client disconnected as a result of a server shutdown.\n      The client
    either waits for the server-specified Retry Delay to\n      expire (Section 6.6.3)
    or else contacts a different server\n      instance.  If the client no longer
    needs service, it does not\n      reconnect.\n   Forcibly Abort:  The client or
    server detected a protocol error, and\n      further communication would have
    undefined behavior.  The client\n      or server forcibly aborts the connection
    (Section 5.3).\n   Abort Reconnect Wait:  The client has forcibly aborted the
    connection\n      but still needs service.  Or, the server forcibly aborted the\n
    \     connection, but the client still needs service.  The client either\n      connects
    to a different service instance (Section 9.1) or waits to\n      reconnect (Section
    6.6.3.1).\n"
  - contents:
    - "5.1.  DSO Session Establishment\n   In order for a session to be established
      between a client and a\n   server, the client must first establish a connection
      to the server\n   using an applicable transport (see Section 4.2).\n   In some
      environments, it may be known in advance by external means\n   that both client
      and server support DSO, and in these cases either\n   client or server may initiate
      DSO messages at any time.  In this\n   case, the session is established as soon
      as the connection is\n   established; this is referred to as implicit DSO Session\n
      \  establishment.\n   However, in the typical case a server will not know in
      advance\n   whether a client supports DSO, so in general, unless it is known
      in\n   advance by other means that a client does support DSO, a server MUST\n
      \  NOT initiate DSO request messages or DSO unidirectional messages\n   until
      a DSO Session has been mutually established by at least one\n   successful DSO
      request/response exchange initiated by the client, as\n   described below.  This
      is referred to as explicit DSO Session\n   establishment.\n   Until a DSO Session
      has been implicitly or explicitly established, a\n   client MUST NOT initiate
      DSO unidirectional messages.\n   A DSO Session is established over a connection
      by the client sending\n   a DSO request message, such as a DSO Keepalive request
      message\n   (Section 7.1), and receiving a response with a matching MESSAGE
      ID,\n   and RCODE set to NOERROR (0), indicating that the DSO request was\n
      \  successful.\n   Some DSO messages are permitted as early data (Section 11.1).
      \ Others\n   are not.  Unidirectional messages are never permitted as early
      data,\n   unless an implicit DSO Session exists.\n   If a server receives a
      DSO message in early data whose Primary TLV is\n   not permitted to appear in
      early data, the server MUST forcibly abort\n   the connection.  If a client
      receives a DSO message in early data,\n   and there is no implicit DSO Session,
      the client MUST forcibly abort\n   the connection.  This can only be enforced
      on TLS connections;\n   therefore, servers MUST NOT enable TCP Fast Open (TFO)
      when listening\n   for a connection that does not require TLS.\n"
    - contents:
      - "5.1.1.  DSO Session Establishment Failure\n   If the response RCODE is set
        to NOTIMP (4), or in practice any value\n   other than NOERROR (0) or DSOTYPENI
        (defined below), then the client\n   MUST assume that the server does not
        implement DSO at all.  In this\n   case, the client is permitted to continue
        sending DNS messages on\n   that connection but MUST NOT issue further DSO
        messages on that\n   connection.\n   If the RCODE in the response is set to
        DSOTYPENI (\"DSO-TYPE Not\n   Implemented\"; RCODE 11), this indicates that
        the server does support\n   DSO but does not implement the DSO-TYPE of the
        Primary TLV in this\n   DSO request message.  A server implementing DSO MUST
        NOT return\n   DSOTYPENI for a DSO Keepalive request message because the Keepalive\n
        \  TLV is mandatory to implement.  But in the future, if a client\n   attempts
        to establish a DSO Session using a response-requiring DSO\n   request message
        using some newly-defined DSO-TYPE that the server\n   does not understand,
        that would result in a DSOTYPENI response.  If\n   the server returns DSOTYPENI,
        then a DSO Session is not considered\n   established.  The client is, however,
        permitted to continue sending\n   DNS messages on the connection, including
        other DSO messages such as\n   the DSO Keepalive, which may result in a successful
        NOERROR response,\n   yielding the establishment of a DSO Session.\n   When
        a DSO message is received by an existing DNS server that doesn't\n   recognize
        the DSO OPCODE, two other possible outcomes exist: the\n   server might send
        no response to the DSO message, or the server might\n   drop the connection.\n
        \  If the server sends no response to the DSO message, the client SHOULD\n
        \  wait 30 seconds, after which time the server will be assumed not to\n   support
        DSO.  If the server doesn't respond within 30 seconds, it can\n   be assumed
        that it is not going to respond; this leaves it in an\n   unspecified state:
        there is no specification requiring that a\n   response be sent to an unknown
        message, but there is also no\n   specification stating what state the server
        is in if no response is\n   sent.  Therefore the client MUST forcibly abort
        the connection to the\n   server.  The client MAY reconnect, but not use DSO,
        if appropriate\n   (Section 6.6.3.1).  By disconnecting and reconnecting,
        the client\n   ensures that the server is in a known state before sending
        any\n   subsequent requests.\n   If the server drops the connection the client
        SHOULD mark that\n   service instance as not supporting DSO, and not attempt
        a DSO\n   connection for some period of time (at least an hour) after the\n
        \  failed attempt.  The client MAY reconnect but not use DSO, if\n   appropriate
        (Section 6.6.3.2).\n"
      title: 5.1.1.  DSO Session Establishment Failure
    - contents:
      - "5.1.2.  DSO Session Establishment Success\n   When the server receives a
        DSO request message from a client, and\n   transmits a successful NOERROR
        response to that request, the server\n   considers the DSO Session established.\n
        \  When the client receives the server's NOERROR response to its DSO\n   request
        message, the client considers the DSO Session established.\n   Once a DSO
        Session has been established, either end may unilaterally\n   send appropriate
        DSO messages at any time, and therefore either\n   client or server may be
        the initiator of a message.\n"
      title: 5.1.2.  DSO Session Establishment Success
    title: 5.1.  DSO Session Establishment
  - contents:
    - "5.2.  Operations after DSO Session Establishment\n   Once a DSO Session has
      been established, clients and servers should\n   behave as described in this
      specification with regard to inactivity\n   timeouts and session termination,
      not as previously prescribed in the\n   earlier specification for DNS-over-TCP
      [RFC7766].\n   Because a server that supports DNS Stateful Operations MUST return
      an\n   RCODE of \"NOERROR\" when it receives a Keepalive TLV DSO request\n   message,
      the Keepalive TLV is an ideal candidate for use in\n   establishing a DSO Session.
      \ Any other option that can only succeed\n   when sent to a server of the desired
      kind is also a good candidate\n   for use in establishing a DSO Session.  For
      clients that implement\n   only the DSO-TYPEs defined in this base specification,
      sending a\n   Keepalive TLV is the only DSO request message they have available
      to\n   initiate a DSO Session.  Even for clients that do implement other\n   future
      DSO-TYPEs, for simplicity they MAY elect to always send an\n   initial DSO Keepalive
      request message as their way of initiating a\n   DSO Session.  A future definition
      of a new response-requiring DSO-\n   TYPE gives implementers the option of using
      that new DSO-TYPE if they\n   wish, but does not change the fact that sending
      a Keepalive TLV\n   remains a valid way of initiating a DSO Session.\n"
    title: 5.2.  Operations after DSO Session Establishment
  - contents:
    - "5.3.  DSO Session Termination\n   A DSO Session is terminated when the underlying
      connection is closed.\n   DSO Sessions are \"closed gracefully\" as a result
      of the server\n   closing a DSO Session because it is overloaded, because of
      the client\n   closing the DSO Session because it is done, or because of the
      client\n   closing the DSO Session because it is inactive.  DSO Sessions are\n
      \  \"forcibly aborted\" when either the client or server closes the\n   connection
      because of a protocol error.\n   o  Where this specification says \"close gracefully\",
      it means sending\n      a TLS close_notify (if TLS is in use) followed by a
      TCP FIN, or\n      the equivalent for other protocols.  Where this specification\n
      \     requires a connection to be closed gracefully, the requirement to\n      initiate
      that graceful close is placed on the client in order to\n      place the burden
      of TCP's TIME-WAIT state on the client rather\n      than the server.\n   o
      \ Where this specification says \"forcibly abort\", it means sending a\n      TCP
      RST or the equivalent for other protocols.  In the BSD Sockets\n      API, this
      is achieved by setting the SO_LINGER option to zero\n      before closing the
      socket.\n"
    - contents:
      - "5.3.1.  Handling Protocol Errors\n   In protocol implementation, there are
        generally two kinds of errors\n   that software writers have to deal with.
        \ The first is situations\n   that arise due to factors in the environment,
        such as temporary loss\n   of connectivity.  While undesirable, these situations
        do not indicate\n   a flaw in the software and are situations that software
        should\n   generally be able to recover from.\n   The second is situations
        that should never happen when communicating\n   with a compliant DSO implementation.
        \ If they do happen, they\n   indicate a serious flaw in the protocol implementation
        beyond what is\n   reasonable to expect software to recover from.  This document\n
        \  describes this latter form of error condition as a \"fatal error\" and\n
        \  specifies that an implementation encountering a fatal error condition\n
        \  \"MUST forcibly abort the connection immediately\".\n"
      title: 5.3.1.  Handling Protocol Errors
    title: 5.3.  DSO Session Termination
  - contents:
    - "5.4.  Message Format\n   A DSO message begins with the standard twelve-byte
      DNS message header\n   [RFC1035] with the OPCODE field set to the DSO OPCODE
      (6).  However,\n   unlike standard DNS messages, the question section, answer
      section,\n   authority records section, and additional records sections are
      not\n   present.  The corresponding count fields (QDCOUNT, ANCOUNT, NSCOUNT,\n
      \  ARCOUNT) MUST be set to zero on transmission.\n   If a DSO message is received
      where any of the count fields are not\n   zero, then a FORMERR MUST be returned.\n
      \                                               1   1   1   1   1   1\n        0
      \  1   2   3   4   5   6   7   8   9   0   1   2   3   4   5\n      +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n
      \     |                          MESSAGE ID                           |\n      +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n
      \     |QR |  OPCODE (6)   |            Z              |     RCODE     |\n      +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n
      \     |                     QDCOUNT (MUST be zero)                    |\n      +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n
      \     |                     ANCOUNT (MUST be zero)                    |\n      +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n
      \     |                     NSCOUNT (MUST be zero)                    |\n      +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n
      \     |                     ARCOUNT (MUST be zero)                    |\n      +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n
      \     |                                                               |\n      /
      \                          DSO Data                            /\n      /                                                               /\n
      \     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n"
    - contents:
      - "5.4.1.  DNS Header Fields in DSO Messages\n   In a DSO unidirectional message,
        the MESSAGE ID field MUST be set to\n   zero.  In a DSO request message, the
        MESSAGE ID field MUST be set to\n   a unique nonzero value that the initiator
        is not currently using for\n   any other active operation on this connection.
        \ For the purposes\n   here, a MESSAGE ID is in use in this DSO Session if
        the initiator has\n   used it in a DSO request message for which it is still
        awaiting a\n   response, or if the client has used it to set up a long-lived\n
        \  operation that has not yet been canceled.  For example, a long-lived\n
        \  operation could be a Push Notification subscription [Push] or a\n   Discovery
        Relay interface subscription [Relay].\n   Whether a message is a DSO request
        message or a DSO unidirectional\n   message is determined only by the specification
        for the Primary TLV.\n   An acknowledgment cannot be requested by including
        a nonzero MESSAGE\n   ID in a message that is required according to its Primary
        TLV to be\n   unidirectional.  Nor can an acknowledgment be prevented by sending
        a\n   MESSAGE ID of zero in a message that is required to be a DSO request\n
        \  message according to its Primary TLV.  A responder that receives\n   either
        such malformed message MUST treat it as a fatal error and\n   forcibly abort
        the connection immediately.\n   In a DSO request message or DSO unidirectional
        message, the DNS\n   Header Query/Response (QR) bit MUST be zero (QR=0).  If
        the QR bit is\n   not zero, the message is not a DSO request or DSO unidirectional\n
        \  message.\n   In a DSO response message, the DNS Header QR bit MUST be one
        (QR=1).\n   If the QR bit is not one, the message is not a DSO response message.\n
        \  In a DSO response message (QR=1), the MESSAGE ID field MUST NOT be\n   zero,
        and MUST contain a copy of the value of the (nonzero) MESSAGE\n   ID field
        in the DSO request message being responded to.  If a DSO\n   response message
        (QR=1) is received where the MESSAGE ID is zero,\n   this is a fatal error
        and the recipient MUST forcibly abort the\n   connection immediately.\n   The
        DNS Header OPCODE field holds the DSO OPCODE value (6).\n   The Z bits are
        currently unused in DSO messages; in both DSO request\n   messages and DSO
        responses, the Z bits MUST be set to zero (0) on\n   transmission and MUST
        be ignored on reception.\n   In a DSO request message (QR=0), the RCODE is
        set according to the\n   definition of the request.  For example, in a Retry
        Delay message\n   (Section 6.6.1), the RCODE indicates the reason for termination.\n
        \  However, in most DSO request messages (QR=0), except where clearly\n   specified
        otherwise, the RCODE is set to zero on transmission, and\n   silently ignored
        on reception.\n   The RCODE value in a response message (QR=1) may be one
        of the\n   following values:\n   +------+-----------+------------------------------------------------+\n
        \  | Code | Mnemonic  | Description                                    |\n
        \  +------+-----------+------------------------------------------------+\n
        \  |    0 | NOERROR   | Operation processed successfully               |\n
        \  |      |           |                                                |\n
        \  |    1 | FORMERR   | Format error                                   |\n
        \  |      |           |                                                |\n
        \  |    2 | SERVFAIL  | Server failed to process DSO request message   |\n
        \  |      |           | due to a problem with the server               |\n
        \  |      |           |                                                |\n
        \  |    4 | NOTIMP    | DSO not supported                              |\n
        \  |      |           |                                                |\n
        \  |    5 | REFUSED   | Operation declined for policy reasons          |\n
        \  |      |           |                                                |\n
        \  |   11 | DSOTYPENI | Primary TLV's DSO-Type is not implemented      |\n
        \  +------+-----------+------------------------------------------------+\n
        \  Use of the above RCODEs is likely to be common in DSO but does not\n   preclude
        the definition and use of other codes in future documents\n   that make use
        of DSO.\n   If a document defining a new DSO-TYPE makes use of response codes
        not\n   defined here, then that document MUST specify the specific\n   interpretation
        of those RCODE values in the context of that new DSO\n   TLV.\n   The RCODE
        field is followed by the four zero-valued count fields,\n   followed by the
        DSO Data.\n"
      title: 5.4.1.  DNS Header Fields in DSO Messages
    - contents:
      - "5.4.2.  DSO Data\n   The standard twelve-byte DNS message header with its
        zero-valued\n   count fields is followed by the DSO Data, expressed using
        TLV syntax,\n   as described in Section 5.4.4.\n   A DSO request message or
        DSO unidirectional message MUST contain at\n   least one TLV.  The first TLV
        in a DSO request message or DSO\n   unidirectional message is referred to
        as the \"Primary TLV\" and\n   determines the nature of the operation being
        performed, including\n   whether it is a DSO request or a DSO unidirectional
        operation.  In\n   some cases, it may be appropriate to include other TLVs
        in a DSO\n   request message or DSO unidirectional message, such as the DSO\n
        \  Encryption Padding TLV (Section 7.3).  Additional TLVs follow the\n   Primary
        TLV.  Additional TLVs are not limited to what is defined in\n   this document.
        \ New Additional TLVs may be defined in the future.\n   Their definitions
        will describe when their use is appropriate.\n   An unrecognized Primary TLV
        results in a DSOTYPENI error response.\n   Unrecognized Additional TLVs are
        silently ignored, as described in\n   Sections 5.4.5 and 8.2.\n   A DSO response
        message may contain no TLVs, or may contain one or\n   more TLVs, appropriate
        to the information being communicated.\n   Any TLVs with the same DSO-TYPE
        as the Primary TLV from the\n   corresponding DSO request message are Response
        Primary TLV(s) and\n   MUST appear first in a DSO response message.  A DSO
        response message\n   may contain multiple Response Primary TLVs, or a single
        Response\n   Primary TLV, or in some cases, no Response Primary TLV.  A Response\n
        \  Primary TLV is not required; for most DSO operations the MESSAGE ID\n   field
        in the DNS message header is sufficient to identify the DSO\n   request message
        to which a particular response message relates.\n   Any other TLVs in a DSO
        response message are Response Additional\n   TLVs, such as the DSO Encryption
        Padding TLV (Section 7.3).  Response\n   Additional TLVs follow the Response
        Primary TLV(s), if present.\n   Response Additional TLVs are not limited to
        what is defined in this\n   document.  New Response Additional TLVs may be
        defined in the future.\n   Their definitions will describe when their use
        is appropriate.\n   Unrecognized Response Additional TLVs are silently ignored,
        as\n   described in Sections 5.4.5 and 8.2.\n   The specification for each
        DSO TLV determines what TLVs are required\n   in a response to a DSO request
        message using that TLV.  If a DSO\n   response is received for an operation
        where the specification\n   requires that the response carry a particular
        TLV or TLVs, and the\n   required TLV(s) are not present, then this is a fatal
        error and the\n   recipient of the defective response message MUST forcibly
        abort the\n   connection immediately.  Similarly, if more than the specified
        number\n   of instances of a given TLV are present, this is a fatal error
        and\n   the recipient of the defective response message MUST forcibly abort\n
        \  the connection immediately.\n"
      title: 5.4.2.  DSO Data
    - contents:
      - "5.4.3.  DSO Unidirectional Messages\n   It is anticipated that most DSO operations
        will be specified to use\n   DSO request messages, which generate corresponding
        DSO responses.  In\n   some specialized high-traffic use cases, it may be
        appropriate to\n   specify DSO unidirectional messages.  DSO unidirectional
        messages can\n   be more efficient on the network because they don't generate
        a stream\n   of corresponding reply messages.  Using DSO unidirectional messages\n
        \  can also simplify software in some cases by removing the need for an\n
        \  initiator to maintain state while it waits to receive replies it\n   doesn't
        care about.  When the specification for a particular TLV used\n   as a Primary
        TLV (i.e., first) in an outgoing DSO request message\n   (i.e., QR=0) states
        that a message is to be unidirectional, the\n   MESSAGE ID field MUST be set
        to zero and the receiver MUST NOT\n   generate any response message corresponding
        to that DSO\n   unidirectional message.\n   The previous point, that the receiver
        MUST NOT generate responses to\n   DSO unidirectional messages, applies even
        in the case of errors.\n   When a DSO message is received where both the QR
        bit and the MESSAGE\n   ID field are zero, the receiver MUST NOT generate
        any response.  For\n   example, if the DSO-TYPE in the Primary TLV is unrecognized,
        then a\n   DSOTYPENI error MUST NOT be returned; instead, the receiver MUST\n
        \  forcibly abort the connection immediately.\n   DSO unidirectional messages
        MUST NOT be used \"speculatively\" in cases\n   where the sender doesn't know
        if the receiver supports the Primary\n   TLV in the message because there
        is no way to receive any response to\n   indicate success or failure.  DSO
        unidirectional messages are only\n   appropriate in cases where the sender
        already knows that the receiver\n   supports and wishes to receive these messages.\n
        \  For example, after a client has subscribed for Push Notifications\n   [Push],
        the subsequent event notifications are then sent as DSO\n   unidirectional
        messages.  This is appropriate because the client\n   initiated the message
        stream by virtue of its Push Notification\n   subscription, thereby indicating
        its support of Push Notifications\n   and its desire to receive those notifications.\n
        \  Similarly, after a Discovery Relay client has subscribed to receive\n   inbound
        multicast DNS (mDNS) [RFC6762] traffic from a Discovery\n   Relay, the subsequent
        stream of received packets is then sent using\n   DSO unidirectional messages.
        \ This is appropriate because the client\n   initiated the message stream
        by virtue of its Discovery Relay link\n   subscription, thereby indicating
        its support of Discovery Relay and\n   its desire to receive inbound mDNS
        packets over that DSO Session\n   [Relay].\n"
      title: 5.4.3.  DSO Unidirectional Messages
    - contents:
      - "5.4.4.  TLV Syntax\n   All TLVs, whether used as \"Primary\", \"Additional\",
        \"Response\n   Primary\", or \"Response Additional\", use the same encoding
        syntax.\n   A specification that defines a new TLV must specify whether the
        DSO-\n   TYPE can be used as a Primary TLV, and whether the DSO-TYPE can be\n
        \  used as an Additional TLV.  Some DSO-TYPEs are dual-purpose and can\n   be
        used as Primary TLVs in some messages, and in other messages as\n   Additional
        TLVs.  The specification for a DSO-TYPE must also state\n   whether, when
        used as the Primary (i.e., first) TLV in a DSO message\n   (i.e., QR=0), that
        DSO message is unidirectional, or is a DSO request\n   message that requires
        a response.\n   If a DSO request message requires a response, the specification
        must\n   also state which TLVs, if any, are to be included in the response
        and\n   how many instances of each of the TLVs are allowed.  The Primary TLV\n
        \  may or may not be contained in the response depending on what is\n   specified
        for that TLV.  If multiple instances of the Primary TLV are\n   allowed the
        specification should clearly describe how they should be\n   processed.\n
        \                                               1   1   1   1   1   1\n        0
        \  1   2   3   4   5   6   7   8   9   0   1   2   3   4   5\n      +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n
        \     |                           DSO-TYPE                            |\n
        \     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n
        \     |                          DSO-LENGTH                           |\n
        \     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n
        \     |                                                               |\n
        \     /                           DSO-DATA                            /\n
        \     /                                                               /\n
        \     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n
        \  DSO-TYPE:  A 16-bit unsigned integer, in network (big endian) byte\n      order,
        giving the DSO-TYPE of the current DSO TLV per the IANA\n      \"DSO Type
        Codes\" registry.\n   DSO-LENGTH:  A 16-bit unsigned integer, in network (big
        endian) byte\n      order, giving the size in bytes of the DSO-DATA.\n   DSO-DATA:
        \ Type-code specific format.  The generic DSO machinery\n      treats the
        DSO-DATA as an opaque \"blob\" without attempting to\n      interpret it.
        \ Interpretation of the meaning of the DSO-DATA for a\n      particular DSO-TYPE
        is the responsibility of the software that\n      implements that DSO-TYPE.\n"
      title: 5.4.4.  TLV Syntax
    - contents:
      - "5.4.5.  Unrecognized TLVs\n   If a DSO request message is received containing
        an unrecognized\n   Primary TLV, with a nonzero MESSAGE ID (indicating that
        a response is\n   expected), then the receiver MUST send an error response
        with a\n   matching MESSAGE ID, and RCODE DSOTYPENI.  The error response MUST\n
        \  NOT contain a copy of the unrecognized Primary TLV.\n   If a DSO unidirectional
        message is received containing both an\n   unrecognized Primary TLV and a
        zero MESSAGE ID (indicating that no\n   response is expected), then this is
        a fatal error and the recipient\n   MUST forcibly abort the connection immediately.\n
        \  If a DSO request message or DSO unidirectional message is received\n   where
        the Primary TLV is recognized, containing one or more\n   unrecognized Additional
        TLVs, the unrecognized Additional TLVs MUST\n   be silently ignored, and the
        remainder of the message is interpreted\n   and handled as if the unrecognized
        parts were not present.\n   Similarly, if a DSO response message is received
        containing one or\n   more unrecognized TLVs, the unrecognized TLVs MUST be
        silently\n   ignored and the remainder of the message is interpreted and handled\n
        \  as if the unrecognized parts are not present.\n"
      title: 5.4.5.  Unrecognized TLVs
    - contents:
      - "5.4.6.  EDNS(0) and TSIG\n   Since the ARCOUNT field MUST be zero, a DSO
        message cannot contain a\n   valid EDNS(0) option in the additional records
        section.  If\n   functionality provided by current or future EDNS(0) options
        is\n   desired for DSO messages, one or more new DSO TLVs need to be defined\n
        \  to carry the necessary information.\n   For example, the EDNS(0) Padding
        Option [RFC7830] used for security\n   purposes is not permitted in a DSO
        message, so if message padding is\n   desired for DSO messages, then the DSO
        Encryption Padding TLV\n   described in Section 7.3 MUST be used.\n   A DSO
        message can't contain a TSIG record because a TSIG record is\n   included
        in the additional section of the message, which would mean\n   that ARCOUNT
        would be greater than zero.  DSO messages are required\n   to have an ARCOUNT
        of zero.  Therefore, if use of signatures with DSO\n   messages becomes necessary
        in the future, a new DSO TLV would have to\n   be defined to perform this
        function.\n   Note, however, that while DSO *messages* cannot include EDNS(0)
        or\n   TSIG records, a DSO *session* is typically used to carry a whole\n
        \  series of DNS messages of different kinds, including DSO messages and\n
        \  other DNS message types like Query [RFC1034] [RFC1035] and Update\n   [RFC2136].
        \ These messages can carry EDNS(0) and TSIG records.\n   Although messages
        may contain other EDNS(0) options as appropriate,\n   this specification explicitly
        prohibits use of the edns-tcp-keepalive\n   EDNS(0) Option [RFC7828] in *any*
        messages sent on a DSO Session\n   (because it is obsoleted by the functionality
        provided by the DSO\n   Keepalive operation).  If any message sent on a DSO
        Session contains\n   an edns-tcp-keepalive EDNS(0) Option, this is a fatal
        error and the\n   recipient of the defective message MUST forcibly abort the
        connection\n   immediately.\n"
      title: 5.4.6.  EDNS(0) and TSIG
    title: 5.4.  Message Format
  - contents:
    - "5.5.  Message Handling\n   As described in Section 5.4.1, whether an outgoing
      DSO message with\n   the QR bit in the DNS header set to zero is a DSO request
      or a DSO\n   unidirectional message is determined by the specification for the\n
      \  Primary TLV, which in turn determines whether the MESSAGE ID field in\n   that
      outgoing message will be zero or nonzero.\n   Every DSO message with the QR
      bit in the DNS header set to zero and a\n   nonzero MESSAGE ID field is a DSO
      request message, and MUST elicit a\n   corresponding response, with the QR bit
      in the DNS header set to one\n   and the MESSAGE ID field set to the value given
      in the corresponding\n   DSO request message.\n   Valid DSO request messages
      sent by the client with a nonzero MESSAGE\n   ID field elicit a response from
      the server, and valid DSO request\n   messages sent by the server with a nonzero
      MESSAGE ID field elicit a\n   response from the client.\n   Every DSO message
      with both the QR bit in the DNS header and the\n   MESSAGE ID field set to zero
      is a DSO unidirectional message and MUST\n   NOT elicit a response.\n"
    - contents:
      - "5.5.1.  Delayed Acknowledgement Management\n   Generally, most good TCP implementations
        employ a delayed\n   acknowledgement timer to provide more efficient use of
        the network\n   and better performance.\n   With a bidirectional exchange
        over TCP, such as with a DSO request\n   message, the operating system TCP
        implementation waits for the\n   application-layer client software to generate
        the corresponding DSO\n   response message.  The TCP implementation can then
        send a single\n   combined packet containing the TCP acknowledgement, the
        TCP window\n   update, and the application-generated DSO response message.
        \ This is\n   more efficient than sending three separate packets, as would
        occur if\n   the TCP packet containing the DSO request were acknowledged\n
        \  immediately.\n   With a DSO unidirectional message or DSO response message,
        there is\n   no corresponding application-generated DSO response message,
        and\n   consequently, no hint to the transport protocol about when it should\n
        \  send its acknowledgement and window update.\n   Some networking APIs provide
        a mechanism that allows the application-\n   layer client software to signal
        to the transport protocol that no\n   response will be forthcoming (in effect
        it can be thought of as a\n   zero-length \"empty\" write).  Where available
        in the networking API\n   being used, the recipient of a DSO unidirectional
        message or DSO\n   response message, having parsed and interpreted the message,
        SHOULD\n   then use this mechanism provided by the networking API to signal
        that\n   no response for this message will be forthcoming.  The TCP\n   implementation
        can then go ahead and send its acknowledgement and\n   window update without
        further delay.  See Section 9.5 for further\n   discussion of why this is
        important.\n"
      title: 5.5.1.  Delayed Acknowledgement Management
    - contents:
      - "5.5.2.  MESSAGE ID Namespaces\n   The namespaces of 16-bit MESSAGE IDs are
        independent in each\n   direction.  This means it is *not* an error for both
        client and\n   server to send DSO request messages at the same time as each
        other,\n   using the same MESSAGE ID, in different directions.  This\n   simplification
        is necessary in order for the protocol to be\n   implementable.  It would
        be infeasible to require the client and\n   server to coordinate with each
        other regarding allocation of new\n   unique MESSAGE IDs.  It is also not
        necessary to require the client\n   and server to coordinate with each other
        regarding allocation of new\n   unique MESSAGE IDs.  The value of the 16-bit
        MESSAGE ID combined with\n   the identity of the initiator (client or server)
        is sufficient to\n   unambiguously identify the operation in question.  This
        can be\n   thought of as a 17-bit message identifier space using message\n
        \  identifiers 0x00001-0x0FFFF for client-to-server DSO request\n   messages,
        and 0x10001-0x1FFFF for server-to-client DSO request\n   messages.  The least-significant
        16 bits are stored explicitly in the\n   MESSAGE ID field of the DSO message,
        and the most-significant bit is\n   implicit from the direction of the message.\n
        \  As described in Section 5.4.1, an initiator MUST NOT reuse a MESSAGE\n
        \  ID that it already has in use for an outstanding DSO request message\n
        \  (unless specified otherwise by the relevant specification for the\n   DSO-TYPE
        in question).  At the very least, this means that a MESSAGE\n   ID can't be
        reused in a particular direction on a particular DSO\n   Session while the
        initiator is waiting for a response to a previous\n   DSO request message
        using that MESSAGE ID on that DSO Session (unless\n   specified otherwise
        by the relevant specification for the DSO-TYPE in\n   question), and for a
        long-lived operation, the MESSAGE ID for the\n   operation can't be reused
        while that operation remains active.\n   If a client or server receives a
        response (QR=1) where the MESSAGE ID\n   is zero, or is any other value that
        does not match the MESSAGE ID of\n   any of its outstanding operations, this
        is a fatal error and the\n   recipient MUST forcibly abort the connection
        immediately.\n   If a responder receives a DSO request message (QR=0) where
        the\n   MESSAGE ID is not zero, the responder tracks request MESSAGE IDs,
        and\n   the MESSAGE ID matches the MESSAGE ID of a DSO request message it\n
        \  received for which a response has not yet been sent, it MUST forcibly\n
        \  abort the connection immediately.  This behavior is required to\n   prevent
        a hypothetical attack that takes advantage of undefined\n   behavior in this
        case.  However, if the responder does not track\n   MESSAGE IDs in this way,
        no such risk exists.  Therefore, tracking\n   MESSAGE IDs just to implement
        this sanity check is not required.\n"
      title: 5.5.2.  MESSAGE ID Namespaces
    - contents:
      - "5.5.3.  Error Responses\n   When a DSO request message is unsuccessful for
        some reason, the\n   responder returns an error code to the initiator.\n   In
        the case of a server returning an error code to a client in\n   response to
        an unsuccessful DSO request message, the server MAY\n   choose to end the
        DSO Session or MAY choose to allow the DSO Session\n   to remain open.  For
        error conditions that only affect the single\n   operation in question, the
        server SHOULD return an error response to\n   the client and leave the DSO
        Session open for further operations.\n   For error conditions that are likely
        to make all operations\n   unsuccessful in the immediate future, the server
        SHOULD return an\n   error response to the client and then end the DSO Session
        by sending\n   a Retry Delay message as described in Section 6.6.1.\n   Upon
        receiving an error response from the server, a client SHOULD NOT\n   automatically
        close the DSO Session.  An error relating to one\n   particular operation
        on a DSO Session does not necessarily imply that\n   all other operations
        on that DSO Session have also failed or that\n   future operations will fail.
        \ The client should assume that the\n   server will make its own decision
        about whether or not to end the DSO\n   Session based on the server's determination
        of whether the error\n   condition pertains to this particular operation or
        to any subsequent\n   operations.  If the server does not end the DSO Session
        by sending\n   the client a Retry Delay message (Section 6.6.1), then the
        client\n   SHOULD continue to use that DSO Session for subsequent operations.\n
        \  When a DSO unidirectional message type is received (MESSAGE ID field\n
        \  is zero), the receiver should already be expecting this DSO message\n   type.
        \ Section 5.4.5 describes the handling of unknown DSO message\n   types.  When
        a DSO unidirectional message of an unexpected type is\n   received, the receiver
        SHOULD forcibly abort the connection.  Whether\n   the connection should be
        forcibly aborted for other internal errors\n   processing the DSO unidirectional
        message is implementation dependent\n   according to the severity of the error.\n"
      title: 5.5.3.  Error Responses
    title: 5.5.  Message Handling
  - contents:
    - "5.6.  Responder-Initiated Operation Cancellation\n   This document, the base
      specification for DNS Stateful Operations,\n   does not itself define any long-lived
      operations, but it defines a\n   framework for supporting long-lived operations
      such as Push\n   Notification subscriptions [Push] and Discovery Relay interface\n
      \  subscriptions [Relay].\n   Long-lived operations, if successful, will remain
      active until the\n   initiator terminates the operation.\n   However, it is
      possible that a long-lived operation may be valid at\n   the time it was initiated,
      but then a later change of circumstances\n   may render that operation invalid.
      \ For example, a long-lived client\n   operation may pertain to a name that
      the server is authoritative for,\n   but then the server configuration is changed
      such that it is no\n   longer authoritative for that name.\n   In such cases,
      instead of terminating the entire session, it may be\n   desirable for the responder
      to be able to cancel selectively only\n   those operations that have become
      invalid.\n   The responder performs this selective cancellation by sending a
      new\n   DSO response message with the MESSAGE ID field containing the MESSAGE\n
      \  ID of the long-lived operation that is to be terminated (that it had\n   previously
      acknowledged with a NOERROR RCODE) and the RCODE field of\n   the new DSO response
      message giving the reason for cancellation.\n   After a DSO response message
      with nonzero RCODE has been sent, that\n   operation has been terminated from
      the responder's point of view, and\n   the responder sends no more messages
      relating to that operation.\n   After a DSO response message with nonzero RCODE
      has been received by\n   the initiator, that operation has been terminated from
      the\n   initiator's point of view, and the canceled operation's MESSAGE ID is\n
      \  now free for reuse.\n"
    title: 5.6.  Responder-Initiated Operation Cancellation
  title: 5.  Protocol Details
- contents:
  - '6.  DSO Session Lifecycle and Timers

    '
  - contents:
    - "6.1.  DSO Session Initiation\n   A DSO Session begins as described in Section
      5.1.\n   Once a DSO Session has been created, client or server may initiate
      as\n   many DNS operations as they wish using the DSO Session.\n   When an initiator
      has multiple messages to send, it SHOULD NOT wait\n   for each response before
      sending the next message.\n   A responder MUST act on messages in the order
      they are received, and\n   SHOULD return responses to request messages as they
      become available.\n   A responder SHOULD NOT delay sending responses for the
      purpose of\n   delivering responses in the same order that the corresponding\n
      \  requests were received.\n   Section 6.2.1.1 of the DNS-over-TCP specification
      [RFC7766] specifies\n   this in more detail.\n"
    title: 6.1.  DSO Session Initiation
  - contents:
    - "6.2.  DSO Session Timeouts\n   Two timeout values are associated with a DSO
      Session: the inactivity\n   timeout and the keepalive interval.  Both values
      are communicated in\n   the same TLV, the Keepalive TLV (Section 7.1).\n   The
      first timeout value, the inactivity timeout, is the maximum time\n   for which
      a client may speculatively keep an inactive DSO Session\n   open in the expectation
      that it may have future requests to send to\n   that server.\n   The second
      timeout value, the keepalive interval, is the maximum\n   permitted interval
      between messages if the client wishes to keep the\n   DSO Session alive.\n   The
      two timeout values are independent.  The inactivity timeout may\n   be shorter,
      the same, or longer than the keepalive interval, though\n   in most cases the
      inactivity timeout is expected to be shorter than\n   the keepalive interval.\n
      \  A shorter inactivity timeout with a longer keepalive interval signals\n   to
      the client that it should not speculatively keep an inactive DSO\n   Session
      open for very long without reason, but when it does have an\n   active reason
      to keep a DSO Session open, it doesn't need to be\n   sending an aggressive
      level of DSO keepalive traffic to maintain that\n   session.  An example of
      this would be a client that has subscribed to\n   DNS Push notifications.  In
      this case, the client is not sending any\n   traffic to the server, but the
      session is not inactive because there\n   is an active request to the server
      to receive push notifications.\n   A longer inactivity timeout with a shorter
      keepalive interval signals\n   to the client that it may speculatively keep
      an inactive DSO Session\n   open for a long time, but to maintain that inactive
      DSO Session it\n   should be sending a lot of DSO keepalive traffic.  This configuration\n
      \  is expected to be less common.\n   In the usual case where the inactivity
      timeout is shorter than the\n   keepalive interval, it is only when a client
      has a long-lived, low-\n   traffic operation that the keepalive interval comes
      into play in\n   order to ensure that a sufficient residual amount of traffic
      is\n   generated to maintain NAT and firewall state, and to assure the\n   client
      and server that they still have connectivity to each other.\n   On a new DSO
      Session, if no explicit DSO Keepalive message exchange\n   has taken place,
      the default value for both timeouts is 15 seconds.\n   For both timeouts, lower
      values of the timeout result in higher\n   network traffic and a higher CPU
      load on the server.\n"
    title: 6.2.  DSO Session Timeouts
  - contents:
    - "6.3.  Inactive DSO Sessions\n   At both servers and clients, the generation
      or reception of any\n   complete DNS message (including DNS requests, responses,
      updates, DSO\n   messages, etc.) resets both timers for that DSO Session, with
      the one\n   exception being that a DSO Keepalive message resets only the\n   keepalive
      timer, not the inactivity timeout timer.\n   In addition, for as long as the
      client has an outstanding operation\n   in progress, the inactivity timer remains
      cleared and an inactivity\n   timeout cannot occur.\n   For short-lived DNS
      operations like traditional queries and updates,\n   an operation is considered
      \"in progress\" for the time between request\n   and response, typically a period
      of a few hundred milliseconds at\n   most.  At the client, the inactivity timer
      is cleared upon\n   transmission of a request and remains cleared until reception
      of the\n   corresponding response.  At the server, the inactivity timer is\n
      \  cleared upon reception of a request and remains cleared until\n   transmission
      of the corresponding response.\n   For long-lived DNS Stateful Operations (such
      as a Push Notification\n   subscription [Push] or a Discovery Relay interface
      subscription\n   [Relay]), an operation is considered \"in progress\" for as
      long as the\n   operation is active, i.e., until it is canceled.  This means
      that a\n   DSO Session can exist with active operations, with no messages\n
      \  flowing in either direction, for far longer than the inactivity\n   timeout.
      \ This is not an error.  This is why there are two separate\n   timers: the
      inactivity timeout and the keepalive interval.  Just\n   because a DSO Session
      has no traffic for an extended period of time,\n   it does not automatically
      make that DSO Session \"inactive\", if it has\n   an active operation that is
      awaiting events.\n"
    title: 6.3.  Inactive DSO Sessions
  - contents:
    - "6.4.  The Inactivity Timeout\n   The purpose of the inactivity timeout is for
      the server to balance\n   the trade-off between the costs of setting up new
      DSO Sessions and\n   the costs of maintaining inactive DSO Sessions.  A server
      with\n   abundant DSO Session capacity can offer a high inactivity timeout to\n
      \  permit clients to keep a speculative DSO Session open for a long time\n   and
      to save the cost of establishing a new DSO Session for future\n   communications
      with that server.  A server with scarce memory\n   resources can offer a low
      inactivity timeout to cause clients to\n   promptly close DSO Sessions whenever
      they have no outstanding\n   operations with that server and then create a new
      DSO Session later\n   when needed.\n"
    - contents:
      - "6.4.1.  Closing Inactive DSO Sessions\n   When a connection's inactivity
        timeout is reached, the client MUST\n   begin closing the idle connection,
        but a client is not required to\n   keep an idle connection open until the
        inactivity timeout is reached.\n   A client MAY close a DSO Session at any
        time, at the client's\n   discretion.  If a client determines that it has
        no current or\n   reasonably anticipated future need for a currently inactive
        DSO\n   Session, then the client SHOULD gracefully close that connection.\n
        \  If, at any time during the life of the DSO Session, the inactivity\n   timeout
        value (i.e., 15 seconds by default) elapses without there\n   being any operation
        active on the DSO Session, the client MUST close\n   the connection gracefully.\n
        \  If, at any time during the life of the DSO Session, too much time\n   elapses
        without there being any operation active on the DSO Session,\n   then the
        server MUST consider the client delinquent and MUST forcibly\n   abort the
        DSO Session.  What is considered \"too much time\" in this\n   context is
        five seconds or twice the current inactivity timeout\n   value, whichever
        is greater.  If the inactivity timeout has its\n   default value of 15 seconds,
        this means that a client will be\n   considered delinquent and disconnected
        if it has not closed its\n   connection after 30 seconds of inactivity.\n
        \  In this context, an operation being active on a DSO Session includes\n
        \  a query waiting for a response, an update waiting for a response, or\n
        \  an active long-lived operation, but not a DSO Keepalive message\n   exchange
        itself.  A DSO Keepalive message exchange resets only the\n   keepalive interval
        timer, not the inactivity timeout timer.\n   If the client wishes to keep
        an inactive DSO Session open for longer\n   than the default duration, then
        it uses the DSO Keepalive message to\n   request longer timeout values as
        described in Section 7.1.\n"
      title: 6.4.1.  Closing Inactive DSO Sessions
    - contents:
      - "6.4.2.  Values for the Inactivity Timeout\n   For the inactivity timeout
        value, lower values result in more\n   frequent DSO Session teardowns and
        re-establishments.  Higher values\n   result in lower traffic and a lower
        CPU load on the server, but a\n   higher memory burden to maintain state for
        inactive DSO Sessions.\n   A server may dictate any value it chooses for the
        inactivity timeout\n   (either in a response to a client-initiated request
        or in a server-\n   initiated message) including values under one second,
        or even zero.\n   An inactivity timeout of zero informs the client that it
        should not\n   speculatively maintain idle connections at all, and as soon
        as the\n   client has completed the operation or operations relating to this\n
        \  server, the client should immediately begin closing this session.\n   A
        server will forcibly abort an idle client session after five\n   seconds or
        twice the inactivity timeout value, whichever is greater.\n   In the case
        of a zero inactivity timeout value, this means that if a\n   client fails
        to close an idle client session, then the server will\n   forcibly abort the
        idle session after five seconds.\n   An inactivity timeout of 0xFFFFFFFF represents
        \"infinity\" and informs\n   the client that it may keep an idle connection
        open as long as it\n   wishes.  Note that after granting an unlimited inactivity
        timeout in\n   this way, at any point the server may revise that inactivity
        timeout\n   by sending a new DSO Keepalive message dictating new Session Timeout\n
        \  values to the client.\n   The largest *finite* inactivity timeout supported
        by the current\n   Keepalive TLV is 0xFFFFFFFE (2^32-2 milliseconds, approximately
        49.7\n   days).\n"
      title: 6.4.2.  Values for the Inactivity Timeout
    title: 6.4.  The Inactivity Timeout
  - contents:
    - "6.5.  The Keepalive Interval\n   The purpose of the keepalive interval is to
      manage the generation of\n   sufficient messages to maintain state in middleboxes
      (such at NAT\n   gateways or firewalls) and for the client and server to periodically\n
      \  verify that they still have connectivity to each other.  This allows\n   them
      to clean up state when connectivity is lost and to establish a\n   new session
      if appropriate.\n"
    - contents:
      - "6.5.1.  Keepalive Interval Expiry\n   If, at any time during the life of
        the DSO Session, the keepalive\n   interval value (i.e., 15 seconds by default)
        elapses without any DNS\n   messages being sent or received on a DSO Session,
        the client MUST\n   take action to keep the DSO Session alive by sending a
        DSO Keepalive\n   message (Section 7.1).  A DSO Keepalive message exchange
        resets only\n   the keepalive timer, not the inactivity timer.\n   If a client
        disconnects from the network abruptly, without cleanly\n   closing its DSO
        Session, perhaps leaving a long-lived operation\n   uncanceled, the server
        learns of this after failing to receive the\n   required DSO keepalive traffic
        from that client.  If, at any time\n   during the life of the DSO Session,
        twice the keepalive interval\n   value (i.e., 30 seconds by default) elapses
        without any DNS messages\n   being sent or received on a DSO Session, the
        server SHOULD consider\n   the client delinquent and SHOULD forcibly abort
        the DSO Session.\n"
      title: 6.5.1.  Keepalive Interval Expiry
    - contents:
      - "6.5.2.  Values for the Keepalive Interval\n   For the keepalive interval
        value, lower values result in a higher\n   volume of DSO keepalive traffic.
        \ Higher values of the keepalive\n   interval reduce traffic and the CPU load,
        but have minimal effect on\n   the memory burden at the server because clients
        keep a DSO Session\n   open for the same length of time (determined by the
        inactivity\n   timeout) regardless of the level of DSO keepalive traffic required.\n
        \  It may be appropriate for clients and servers to select different\n   keepalive
        intervals depending on the type of network they are on.\n   A corporate DNS
        server that knows it is serving only clients on the\n   internal network,
        with no intervening NAT gateways or firewalls, can\n   impose a longer keepalive
        interval because frequent DSO keepalive\n   traffic is not required.\n   A
        public DNS server that is serving primarily residential consumer\n   clients,
        where it is likely there will be a NAT gateway on the path,\n   may impose
        a shorter keepalive interval to generate more frequent DSO\n   keepalive traffic.\n
        \  A smart client may be adaptive to its environment.  A client using a\n
        \  private IPv4 address [RFC1918] to communicate with a DNS server at an\n
        \  address outside that IPv4 private address block may conclude that\n   there
        is likely to be a NAT gateway on the path, and accordingly\n   request a shorter
        keepalive interval.\n   By default, it is RECOMMENDED that clients request,
        and servers\n   grant, a keepalive interval of 60 minutes.  This keepalive
        interval\n   provides for reasonably timely detection if a client abruptly\n
        \  disconnects without cleanly closing the session.  Also, it is\n   sufficient
        to maintain state in firewalls and NAT gateways that\n   follow the IETF recommended
        Best Current Practice that the\n   \"established connection idle-timeout\"
        used by middleboxes be at least\n   2 hours and 4 minutes [RFC5382] [RFC7857].\n
        \  Note that the shorter the keepalive interval value, the higher the\n   load
        on client and server.  Moreover, for a keepalive value that is\n   shorter
        than the time needed for the transport to retransmit, the\n   loss of a single
        packet would cause a server to overzealously abort\n   the connection.  For
        example, a (hypothetical and unrealistic)\n   keepalive interval value of
        100 ms would result in a continuous\n   stream of ten messages per second
        or more (if allowed by the current\n   congestion control window) in both
        directions to keep the DSO Session\n   alive.  And, in this extreme example,
        a single retransmission over a\n   path with, as an example, 100 ms RTT would
        introduce a momentary\n   pause in the stream of messages long enough to cause
        the server to\n   abort the connection.\n   Because of this concern, the server
        MUST NOT send a DSO Keepalive\n   message (either a DSO response to a client-initiated
        DSO request or a\n   server-initiated DSO message) with a keepalive interval
        value less\n   than ten seconds.  If a client receives a DSO Keepalive message\n
        \  specifying a keepalive interval value less than ten seconds, this is\n
        \  a fatal error and the client MUST forcibly abort the connection\n   immediately.\n
        \  A keepalive interval value of 0xFFFFFFFF represents \"infinity\" and\n
        \  informs the client that it should generate no DSO keepalive traffic.\n
        \  Note that after signaling that the client should generate no DSO\n   keepalive
        traffic in this way, the server may at any point revise\n   that DSO keepalive
        traffic requirement by sending a new DSO Keepalive\n   message dictating new
        Session Timeout values to the client.\n   The largest *finite* keepalive interval
        supported by the current\n   Keepalive TLV is 0xFFFFFFFE (2^32-2 milliseconds,
        approximately 49.7\n   days).\n"
      title: 6.5.2.  Values for the Keepalive Interval
    title: 6.5.  The Keepalive Interval
  - contents:
    - "6.6.  Server-Initiated DSO Session Termination\n   In addition to canceling
      individual long-lived operations selectively\n   (Section 5.6), there are also
      occasions where a server may need to\n   terminate one or more entire DSO sessions.
      \ An entire DSO session may\n   need to be terminated if the client is defective
      in some way or\n   departs from the network without closing its DSO session.
      \ DSO\n   Sessions may also need to be terminated if the server becomes\n   overloaded
      or is reconfigured and lacks the ability to be selective\n   about which operations
      need to be canceled.\n   This section discusses various reasons a DSO session
      may be\n   terminated and the mechanisms for doing so.\n   In normal operation,
      closing a DSO Session is the client's\n   responsibility.  The client makes
      the determination of when to close\n   a DSO Session based on an evaluation
      of both its own needs and the\n   inactivity timeout value dictated by the server.
      \ A server only\n   causes a DSO Session to be ended in the exceptional circumstances\n
      \  outlined below.  Some of the exceptional situations in which a server\n   may
      terminate a DSO Session include:\n   o  The server application software or underlying
      operating system is\n      shutting down or restarting.\n   o  The server application
      software terminates unexpectedly (perhaps\n      due to a bug that makes it
      crash, causing the underlying operating\n      system to send a TCP RST).\n
      \  o  The server is undergoing a reconfiguration or maintenance\n      procedure
      that, due to the way the server software is implemented,\n      requires clients
      to be disconnected.  For example, some software\n      is implemented such that
      it reads a configuration file at startup,\n      and changing the server's configuration
      entails modifying the\n      configuration file and then killing and restarting
      the server\n      software, which generally entails a loss of network connections.\n
      \  o  The client fails to meet its obligation to generate the required\n      DSO
      keepalive traffic or to close an inactive session by the\n      prescribed time
      (five seconds or twice the time interval dictated\n      by the server, whichever
      is greater, as described in Section 6.2).\n   o  The client sends a grossly
      invalid or malformed request that is\n      indicative of a seriously defective
      client implementation.\n   o  The server is over capacity and needs to shed
      some load.\n"
    - contents:
      - "6.6.1.  Server-Initiated Retry Delay Message\n   In the cases described above
        where a server elects to terminate a DSO\n   Session, it could do so simply
        by forcibly aborting the connection.\n   However, if it did this, the likely
        behavior of the client might be\n   simply to treat this as a network failure
        and reconnect immediately,\n   putting more burden on the server.\n   Therefore,
        to avoid this reconnection implosion, a server SHOULD\n   instead choose to
        shed client load by sending a Retry Delay message\n   with an appropriate
        RCODE value informing the client of the reason\n   the DSO Session needs to
        be terminated.  The format of the DSO Retry\n   Delay TLV and the interpretations
        of the various RCODE values are\n   described in Section 7.2.  After sending
        a DSO Retry Delay message,\n   the server MUST NOT send any further messages
        on that DSO Session.\n   The server MAY randomize retry delays in situations
        where many retry\n   delays are sent in quick succession so as to avoid all
        the clients\n   attempting to reconnect at once.  In general, implementations
        should\n   avoid using the DSO Retry Delay message in a way that would result
        in\n   many clients reconnecting at the same time if every client attempts\n
        \  to reconnect at the exact time specified.\n   Upon receipt of a DSO Retry
        Delay message from the server, the client\n   MUST make note of the reconnect
        delay for this server and then\n   immediately close the connection gracefully.\n
        \  After sending a DSO Retry Delay message, the server SHOULD allow the\n
        \  client five seconds to close the connection, and if the client has\n   not
        closed the connection after five seconds, then the server SHOULD\n   forcibly
        abort the connection.\n   A DSO Retry Delay message MUST NOT be initiated
        by a client.  If a\n   server receives a DSO Retry Delay message, this is
        a fatal error and\n   the server MUST forcibly abort the connection immediately.\n"
      - contents:
        - "6.6.1.1.  Outstanding Operations\n   At the instant a server chooses to
          initiate a DSO Retry Delay\n   message, there may be DNS requests already
          in flight from client to\n   server on this DSO Session, which will arrive
          at the server after its\n   DSO Retry Delay message has been sent.  The
          server MUST silently\n   ignore such incoming requests and MUST NOT generate
          any response\n   messages for them.  When the DSO Retry Delay message from
          the server\n   arrives at the client, the client will determine that any
          DNS\n   requests it previously sent on this DSO Session that have not yet\n
          \  received a response will now certainly not be receiving any response.\n
          \  Such requests should be considered failed and should be retried at a\n
          \  later time, as appropriate.\n   In the case where some, but not all,
          of the existing operations on a\n   DSO Session have become invalid (perhaps
          because the server has been\n   reconfigured and is no longer authoritative
          for some of the names),\n   but the server is terminating all affected DSO
          Sessions en masse by\n   sending them all a DSO Retry Delay message, the
          reconnect delay MAY\n   be zero, indicating that the clients SHOULD immediately
          attempt to\n   re-establish operations.\n   It is likely that some of the
          attempts will be successful and some\n   will not, depending on the nature
          of the reconfiguration.\n   In the case where a server is terminating a
          large number of DSO\n   Sessions at once (e.g., if the system is restarting)
          and the server\n   doesn't want to be inundated with a flood of simultaneous
          retries, it\n   SHOULD send different reconnect delay values to each client.
          \ These\n   adjustments MAY be selected randomly, pseudorandomly, or\n   deterministically
          (e.g., incrementing the time value by one tenth of\n   a second for each
          successive client, yielding a post-restart\n   reconnection rate of ten
          clients per second).\n"
        title: 6.6.1.1.  Outstanding Operations
      title: 6.6.1.  Server-Initiated Retry Delay Message
    - contents:
      - "6.6.2.  Misbehaving Clients\n   A server may determine that a client is not
        following the protocol\n   correctly.  There may be no way for the server
        to recover the DSO\n   session, in which case the server forcibly terminates
        the connection.\n   Since the client doesn't know why the connection dropped,
        it may\n   reconnect immediately.  If the server has determined that a client
        is\n   not following the protocol correctly, it MAY terminate the DSO\n   Session
        as soon as it is established, specifying a long retry-delay\n   to prevent
        the client from immediately reconnecting.\n"
      title: 6.6.2.  Misbehaving Clients
    - contents:
      - "6.6.3.  Client Reconnection\n   After a DSO Session is ended by the server
        (either by sending the\n   client a DSO Retry Delay message or by forcibly
        aborting the\n   underlying transport connection), the client SHOULD try to
        reconnect\n   to that service instance or to another suitable service instance
        if\n   more than one is available.  If reconnecting to the same service\n
        \  instance, the client MUST respect the indicated delay, if available,\n
        \  before attempting to reconnect.  Clients SHOULD NOT attempt to\n   randomize
        the delay; the server will randomly jitter the retry delay\n   values it sends
        to each client if this behavior is desired.\n   If a particular service instance
        will only be out of service for a\n   short maintenance period, it should
        indicate a retry delay value that\n   is a little longer than the expected
        maintenance window.  It should\n   not default to a very large delay value,
        or clients may not attempt\n   to reconnect promptly after it resumes service.\n
        \  If a service instance does not want a client to reconnect ever\n   (perhaps
        the service instance is being decommissioned), it SHOULD set\n   the retry
        delay to the maximum value 0xFFFFFFFF (2^32-1 milliseconds,\n   approximately
        49.7 days).  It is not possible to instruct a client to\n   stay away for
        longer than 49.7 days.  If, after 49.7 days, the DNS or\n   other configuration
        information still indicates that this is the\n   valid service instance for
        a particular service, then clients MAY\n   attempt to reconnect.  In reality,
        if a client is rebooted or\n   otherwise loses state, it may well attempt
        to reconnect before 49.7\n   days elapse, for as long as the DNS or other
        configuration\n   information continues to indicate that this is the service
        instance\n   the client should use.\n"
      - contents:
        - "6.6.3.1.  Reconnecting after a Forcible Abort\n   If a connection was forcibly
          aborted by the client due to\n   noncompliant behavior by the server, the
          client SHOULD mark that\n   service instance as not supporting DSO.  The
          client MAY reconnect but\n   not attempt to use DSO, or it may connect to
          a different service\n   instance if applicable.\n"
        title: 6.6.3.1.  Reconnecting after a Forcible Abort
      - contents:
        - "6.6.3.2.  Reconnecting after an Unexplained Connection Drop\n   It is also
          possible for a server to forcibly terminate the\n   connection; in this
          case, the client doesn't know whether the\n   termination was the result
          of a protocol error or a network outage.\n   When the client notices that
          the connection has been dropped, it can\n   attempt to reconnect immediately.
          \ However, if the connection is\n   dropped again without the client being
          able to successfully do\n   whatever it is trying to do, it should mark
          the server as not\n   supporting DSO.\n"
        title: 6.6.3.2.  Reconnecting after an Unexplained Connection Drop
      - contents:
        - "6.6.3.3.  Probing for Working DSO Support\n   Once a server has been marked
          by the client as not supporting DSO,\n   the client SHOULD NOT attempt DSO
          operations on that server until\n   some time has elapsed.  A reasonable
          minimum would be an hour.  Since\n   forcibly aborted connections are the
          result of a software failure,\n   it's not likely that the problem will
          be solved in the first hour\n   after it's first encountered.  However,
          by restricting the retry\n   interval to an hour, the client will be able
          to notice when the\n   problem has been fixed without placing an undue burden
          on the server.\n"
        title: 6.6.3.3.  Probing for Working DSO Support
      title: 6.6.3.  Client Reconnection
    title: 6.6.  Server-Initiated DSO Session Termination
  title: 6.  DSO Session Lifecycle and Timers
- contents:
  - "7.  Base TLVs for DNS Stateful Operations\n   This section describes the three
    base TLVs for DNS Stateful\n   Operations: Keepalive, Retry Delay, and Encryption
    Padding.\n"
  - contents:
    - "7.1.  Keepalive TLV\n   The Keepalive TLV (DSO-TYPE=1) performs two functions.
      \ Primarily, it\n   establishes the values for the Session Timeouts.  Incidentally,
      it\n   also resets the keepalive timer for the DSO Session, meaning that it\n
      \  can be used as a kind of \"no-op\" message for the purpose of keeping a\n
      \  session alive.  The client will request the desired Session Timeout\n   values
      and the server will acknowledge with the response values that\n   it requires
      the client to use.\n   DSO messages with the Keepalive TLV as the Primary TLV
      may appear in\n   early data.\n   The DSO-DATA for the Keepalive TLV is as follows:\n
      \                          1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 3 3\n       0
      1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |                 INACTIVITY TIMEOUT (32 bits)                  |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |                 KEEPALIVE INTERVAL (32 bits)                  |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  INACTIVITY TIMEOUT:  The inactivity timeout for the current DSO\n      Session,
      specified as a 32-bit unsigned integer, in network (big\n      endian) byte
      order in units of milliseconds.  This is the timeout\n      at which the client
      MUST begin closing an inactive DSO Session.\n      The inactivity timeout can
      be any value of the server's choosing.\n      If the client does not gracefully
      close an inactive DSO Session,\n      then after five seconds or twice this
      interval, whichever is\n      greater, the server will forcibly abort the connection.\n
      \  KEEPALIVE INTERVAL:  The keepalive interval for the current DSO\n      Session,
      specified as a 32-bit unsigned integer, in network (big\n      endian) byte
      order in units of milliseconds.  This is the interval\n      at which a client
      MUST generate DSO keepalive traffic to maintain\n      connection state.  The
      keepalive interval MUST NOT be less than\n      ten seconds.  If the client
      does not generate the mandated DSO\n      keepalive traffic, then after twice
      this interval the server will\n      forcibly abort the connection.  Since the
      minimum allowed\n      keepalive interval is ten seconds, the minimum time at
      which a\n      server will forcibly disconnect a client for failing to generate\n
      \     the mandated DSO keepalive traffic is twenty seconds.\n   The transmission
      or reception of DSO Keepalive messages (i.e.,\n   messages where the Keepalive
      TLV is the first TLV) reset only the\n   keepalive timer, not the inactivity
      timer.  The reason for this is\n   that periodic DSO Keepalive messages are
      sent for the sole purpose of\n   keeping a DSO Session alive when that DSO Session
      has current or\n   recent non-maintenance activity that warrants keeping that
      DSO\n   Session alive.  Sending DSO keepalive traffic itself is not\n   considered
      a client activity; it is considered a maintenance activity\n   that is performed
      in service of other client activities.  If DSO\n   keepalive traffic itself
      were to reset the inactivity timer, then\n   that would create a circular livelock
      where keepalive traffic would\n   be sent indefinitely to keep a DSO Session
      alive.  In this scenario,\n   the only activity on that DSO Session would be
      the keepalive traffic\n   keeping the DSO Session alive so that further keepalive
      traffic can\n   be sent.  For a DSO Session to be considered active, it must
      be\n   carrying something more than just keepalive traffic.  This is why\n   merely
      sending or receiving a DSO Keepalive message does not reset\n   the inactivity
      timer.\n   When sent by a client, the DSO Keepalive request message MUST be
      sent\n   as a DSO request message with a nonzero MESSAGE ID.  If a server\n
      \  receives a DSO Keepalive message with a zero MESSAGE ID, then this is\n   a
      fatal error and the server MUST forcibly abort the connection\n   immediately.
      \ The DSO Keepalive request message resets a DSO\n   Session's keepalive timer
      and, at the same time, communicates to the\n   server the client's requested
      Session Timeout values.  In a server\n   response to a client-initiated DSO
      Keepalive request message, the\n   Session Timeouts contain the server's chosen
      values from this point\n   forward in the DSO Session, which the client MUST
      respect.  This is\n   modeled after the DHCP protocol, where the client requests
      a certain\n   lease lifetime using DHCP option 51 [RFC2132], but the server
      is the\n   ultimate authority for deciding what lease lifetime is actually\n
      \  granted.\n   When a client is sending its second and subsequent DSO Keepalive\n
      \  request messages to the server, the client SHOULD continue to request\n   its
      preferred values each time.  This allows flexibility so that if\n   conditions
      change during the lifetime of a DSO Session, the server\n   can adapt its responses
      to better fit the client's needs.\n   Once a DSO Session is in progress (Section
      5.1), a DSO Keepalive\n   message MAY be initiated by a server.  When sent by
      a server, the DSO\n   Keepalive message MUST be sent as a DSO unidirectional
      message with\n   the MESSAGE ID set to zero.  The client MUST NOT generate a
      response\n   to a server-initiated DSO Keepalive message.  If a client receives
      a\n   DSO Keepalive request message with a nonzero MESSAGE ID, then this is\n
      \  a fatal error and the client MUST forcibly abort the connection\n   immediately.
      \ The DSO Keepalive unidirectional message from the\n   server resets a DSO
      Session's keepalive timer and, at the same time,\n   unilaterally informs the
      client of the new Session Timeout values to\n   use from this point forward
      in this DSO Session.  No client DSO\n   response to this unilateral declaration
      is required or allowed.\n   In DSO Keepalive response messages, exactly one
      instance of the\n   Keepalive TLV MUST be present and is used only as a Response
      Primary\n   TLV sent as a reply to a DSO Keepalive request message from the\n
      \  client.  A Keepalive TLV MUST NOT be added to other responses as a\n   Response
      Additional TLV.  If the server wishes to update a client's\n   Session Timeout
      values other than in response to a DSO Keepalive\n   request message from the
      client, then it does so by sending a DSO\n   Keepalive unidirectional message
      of its own, as described above.\n   It is not required that the Keepalive TLV
      be used in every DSO\n   Session.  While many DSO operations will be used in
      conjunction with\n   a long-lived session state, not all DSO operations require
      a long-\n   lived session state, and in some cases the default 15-second value\n
      \  for both the inactivity timeout and keepalive interval may be\n   perfectly
      appropriate.  However, note that for clients that implement\n   only the DSO-TYPEs
      defined in this document, a DSO Keepalive request\n   message is the only way
      for a client to initiate a DSO Session.\n"
    - contents:
      - "7.1.1.  Client Handling of Received Session Timeout Values\n   When a client
        receives a response to its client-initiated DSO\n   Keepalive request message,
        or receives a server-initiated DSO\n   Keepalive unidirectional message, the
        client has then received\n   Session Timeout values dictated by the server.
        \ The two timeout\n   values contained in the Keepalive TLV from the server
        may each be\n   higher, lower, or the same as the respective Session Timeout
        values\n   the client previously had for this DSO Session.\n   In the case
        of the keepalive timer, the handling of the received\n   value is straightforward.
        \ The act of receiving the message\n   containing the DSO Keepalive TLV itself
        resets the keepalive timer\n   and updates the keepalive interval for the
        DSO Session.  The new\n   keepalive interval indicates the maximum time that
        may elapse before\n   another message must be sent or received on this DSO
        Session, if the\n   DSO Session is to remain alive.\n   In the case of the
        inactivity timeout, the handling of the received\n   value is a little more
        subtle, though the meaning of the inactivity\n   timeout remains as specified;
        it still indicates the maximum\n   permissible time allowed without useful
        activity on a DSO Session.\n   The act of receiving the message containing
        the Keepalive TLV does\n   not itself reset the inactivity timer.  The time
        elapsed since the\n   last useful activity on this DSO Session is unaffected
        by exchange of\n   DSO Keepalive messages.  The new inactivity timeout value
        in the\n   Keepalive TLV in the received message does update the timeout\n
        \  associated with the running inactivity timer; that becomes the new\n   maximum
        permissible time without activity on a DSO Session.\n   o  If the current
        inactivity timer value is less than the new\n      inactivity timeout, then
        the DSO Session may remain open for now.\n      When the inactivity timer
        value reaches the new inactivity\n      timeout, the client MUST then begin
        closing the DSO Session as\n      described above.\n   o  If the current inactivity
        timer value is equal to the new\n      inactivity timeout, then this DSO Session
        has been inactive for\n      exactly as long as the server will permit, and
        now the client MUST\n      immediately begin closing this DSO Session.\n   o
        \ If the current inactivity timer value is already greater than the\n      new
        inactivity timeout, then this DSO Session has already been\n      inactive
        for longer than the server permits, and the client MUST\n      immediately
        begin closing this DSO Session.\n   o  If the current inactivity timer value
        is already more than twice\n      the new inactivity timeout, then the client
        is immediately\n      considered delinquent (this DSO Session is immediately
        eligible to\n      be forcibly terminated by the server) and the client MUST\n
        \     immediately begin closing this DSO Session.  However, if a server\n
        \     abruptly reduces the inactivity timeout in this way, then, to give\n
        \     the client time to close the connection gracefully before the\n      server
        resorts to forcibly aborting it, the server SHOULD give the\n      client
        an additional grace period of either five seconds or one\n      quarter of
        the new inactivity timeout, whichever is greater.\n"
      title: 7.1.1.  Client Handling of Received Session Timeout Values
    - contents:
      - "7.1.2.  Relationship to edns-tcp-keepalive EDNS(0) Option\n   The inactivity
        timeout value in the Keepalive TLV (DSO-TYPE=1) has\n   similar intent to
        the edns-tcp-keepalive EDNS(0) Option [RFC7828].  A\n   client/server pair
        that supports DSO MUST NOT use the edns-tcp-\n   keepalive EDNS(0) Option
        within any message after a DSO Session has\n   been established.  A client
        that has sent a DSO message to establish\n   a session MUST NOT send an edns-tcp-keepalive
        EDNS(0) Option from\n   this point on.  Once a DSO Session has been established,
        if either\n   client or server receives a DNS message over the DSO Session
        that\n   contains an edns-tcp-keepalive EDNS(0) Option, this is a fatal error\n
        \  and the receiver of the edns-tcp-keepalive EDNS(0) Option MUST\n   forcibly
        abort the connection immediately.\n"
      title: 7.1.2.  Relationship to edns-tcp-keepalive EDNS(0) Option
    title: 7.1.  Keepalive TLV
  - contents:
    - "7.2.  Retry Delay TLV\n   The Retry Delay TLV (DSO-TYPE=2) can be used as a
      Primary TLV\n   (unidirectional) in a server-to-client message, or as a Response\n
      \  Additional TLV in either direction.  DSO messages with a Relay Delay\n   TLV
      as their Primary TLV are not permitted in early data.\n   The DSO-DATA for the
      Retry Delay TLV is as follows:\n                           1 1 1 1 1 1 1 1 1
      1 2 2 2 2 2 2 2 2 2 2 3 3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0
      1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |                     RETRY DELAY (32 bits)                     |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  RETRY DELAY:  A time value, specified as a 32-bit unsigned integer in\n      network
      (big endian) byte order, in units of milliseconds, within\n      which the initiator
      MUST NOT retry this operation or retry\n      connecting to this server.  Recommendations
      for the RETRY DELAY\n      value are given in Section 6.6.1.\n"
    - contents:
      - "7.2.1.  Retry Delay TLV Used as a Primary TLV\n   When used as the Primary
        TLV in a DSO unidirectional message, the\n   Retry Delay TLV is sent from
        server to client.  It is used by a\n   server to instruct a client to close
        the DSO Session and underlying\n   connection, and not to reconnect for the
        indicated time interval.\n   In this case, it applies to the DSO Session as
        a whole, and the\n   client MUST begin closing the DSO Session as described
        in\n   Section 6.6.1.  The RCODE in the message header SHOULD indicate the\n
        \  principal reason for the termination:\n   o  NOERROR indicates a routine
        shutdown or restart.\n   o  FORMERR indicates that a client DSO request was
        too badly\n      malformed for the session to continue.\n   o  SERVFAIL indicates
        that the server is overloaded due to resource\n      exhaustion and needs
        to shed load.\n   o  REFUSED indicates that the server has been reconfigured,
        and at\n      this time it is now unable to perform one or more of the long-\n
        \     lived client operations that were previously being performed on\n      this
        DSO Session.\n   o  NOTAUTH indicates that the server has been reconfigured
        and at\n      this time it is now unable to perform one or more of the long-\n
        \     lived client operations that were previously being performed on\n      this
        DSO Session because it does not have authority over the names\n      in question
        (for example, a DNS Push Notification server could be\n      reconfigured
        such that it is no longer accepting DNS Push\n      Notification requests
        for one or more of the currently subscribed\n      names).\n   This document
        specifies only these RCODE values for the DSO Retry\n   Delay message.  Servers
        sending DSO Retry Delay messages SHOULD use\n   one of these values.  However,
        future circumstances may create\n   situations where other RCODE values are
        appropriate in DSO Retry\n   Delay messages, so clients MUST be prepared to
        accept DSO Retry Delay\n   messages with any RCODE value.\n   In some cases,
        when a server sends a DSO Retry Delay unidirectional\n   message to a client,
        there may be more than one reason for the server\n   wanting to end the session.
        \ Possibly, the configuration could have\n   been changed such that some long-lived
        client operations can no\n   longer be continued due to policy (REFUSED),
        and other long-lived\n   client operations can no longer be performed due
        to the server no\n   longer being authoritative for those names (NOTAUTH).
        \ In such cases,\n   the server MAY use any of the applicable RCODE values,
        or\n   RCODE=NOERROR (routine shutdown or restart).\n   Note that the selection
        of RCODE value in a DSO Retry Delay message\n   is not critical since the
        RCODE value is generally used only for\n   information purposes such as writing
        to a log file for future human\n   analysis regarding the nature of the disconnection.
        \ Generally,\n   clients do not modify their behavior depending on the RCODE
        value.\n   The RETRY DELAY in the message tells the client how long it should\n
        \  wait before attempting a new connection to this service instance.\n   For
        clients that do in some way modify their behavior depending on\n   the RCODE
        value, they should treat unknown RCODE values the same as\n   RCODE=NOERROR
        (routine shutdown or restart).\n   A DSO Retry Delay message (DSO message
        where the Primary TLV is Retry\n   Delay) from server to client is a DSO unidirectional
        message; the\n   MESSAGE ID MUST be set to zero in the outgoing message and
        the client\n   MUST NOT send a response.\n   A client MUST NOT send a DSO
        Retry Delay message to a server.  If a\n   server receives a DSO message where
        the Primary TLV is the Retry\n   Delay TLV, this is a fatal error and the
        server MUST forcibly abort\n   the connection immediately.\n"
      title: 7.2.1.  Retry Delay TLV Used as a Primary TLV
    - contents:
      - "7.2.2.  Retry Delay TLV Used as a Response Additional TLV\n   In the case
        of a DSO request message that results in a nonzero RCODE\n   value, the responder
        MAY append a Retry Delay TLV to the response,\n   indicating the time interval
        during which the initiator SHOULD NOT\n   attempt this operation again.\n
        \  The indicated time interval during which the initiator SHOULD NOT\n   retry
        applies only to the failed operation, not to the DSO Session as\n   a whole.\n
        \  Either a client or a server, whichever is acting in the role of the\n   responder
        for a particular DSO request message, MAY append a Retry\n   Delay TLV to
        an error response that it sends.\n"
      title: 7.2.2.  Retry Delay TLV Used as a Response Additional TLV
    title: 7.2.  Retry Delay TLV
  - contents:
    - "7.3.  Encryption Padding TLV\n   The Encryption Padding TLV (DSO-TYPE=3) can
      only be used as an\n   Additional or Response Additional TLV.  It is only applicable
      when\n   the DSO Transport layer uses encryption such as TLS.\n   The DSO-DATA
      for the Padding TLV is optional and is a variable length\n   field containing
      non-specified values.  A DSO-LENGTH of 0 essentially\n   provides for 4 bytes
      of padding (the minimum amount).\n                                                1
      \  1   1   1   1   1\n        0   1   2   3   4   5   6   7   8   9   0   1
      \  2   3   4   5\n      +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n
      \     /                                                               /\n      /
      \             PADDING -- VARIABLE NUMBER OF BYTES              /\n      /                                                               /\n
      \     +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n   As
      specified for the EDNS(0) Padding Option [RFC7830], the PADDING\n   bytes SHOULD
      be set to 0x00.  Other values MAY be used, for example,\n   in cases where there
      is a concern that the padded message could be\n   subject to compression before
      encryption.  PADDING bytes of any value\n   MUST be accepted in the messages
      received.\n   The Encryption Padding TLV may be included in either a DSO request\n
      \  message, response, or both.  As specified for the EDNS(0) Padding\n   Option
      [RFC7830], if a DSO request message is received with an\n   Encryption Padding
      TLV, then the DSO response MUST also include an\n   Encryption Padding TLV.\n
      \  The length of padding is intentionally not specified in this document\n   and
      is a function of current best practices with respect to the type\n   and length
      of data in the preceding TLVs [RFC8467].\n"
    title: 7.3.  Encryption Padding TLV
  title: 7.  Base TLVs for DNS Stateful Operations
- contents:
  - "8.  Summary Highlights\n   This section summarizes some noteworthy highlights
    about various\n   aspects of the DSO protocol.\n"
  - contents:
    - "8.1.  QR Bit and MESSAGE ID\n   In DSO request messages, the QR bit is 0 and
      the MESSAGE ID is\n   nonzero.\n   In DSO response messages, the QR bit is 1
      and the MESSAGE ID is\n   nonzero.\n   In DSO unidirectional messages, the QR
      bit is 0 and the MESSAGE ID is\n   zero.\n   The table below illustrates which
      combinations are legal and how they\n   are interpreted:\n               +------------------------------+------------------------+\n
      \              |       MESSAGE ID zero        |   MESSAGE ID nonzero   |\n      +--------+------------------------------+------------------------+\n
      \     |  QR=0  |  DSO unidirectional message  |  DSO request message   |\n      +--------+------------------------------+------------------------+\n
      \     |  QR=1  |    Invalid - Fatal Error     |  DSO response message  |\n      +--------+------------------------------+------------------------+\n"
    title: 8.1.  QR Bit and MESSAGE ID
  - contents:
    - "8.2.  TLV Usage\n   The table below indicates, for each of the three TLVs defined
      in this\n   document, whether they are valid in each of ten different contexts.\n
      \  The first five contexts are DSO requests or DSO unidirectional\n   messages
      from client to server, and the corresponding responses from\n   server back
      to client:\n   o  C-P - Primary TLV, sent in DSO request message, from client
      to\n      server, with nonzero MESSAGE ID indicating that this request MUST\n
      \     generate response message.\n   o  C-U - Primary TLV, sent in DSO unidirectional
      message, from client\n      to server, with zero MESSAGE ID indicating that
      this request MUST\n      NOT generate response message.\n   o  C-A - Additional
      TLV, optionally added to a DSO request message or\n      DSO unidirectional
      message from client to server.\n   o  CRP - Response Primary TLV, included in
      response message sent back\n      to the client (in response to a client \"C-P\"
      request with nonzero\n      MESSAGE ID indicating that a response is required)
      where the DSO-\n      TYPE of the Response TLV matches the DSO-TYPE of the Primary
      TLV\n      in the request.\n   o  CRA - Response Additional TLV, included in
      response message sent\n      back to the client (in response to a client \"C-P\"
      request with\n      nonzero MESSAGE ID indicating that a response is required)
      where\n      the DSO-TYPE of the Response TLV does not match the DSO-TYPE of\n
      \     the Primary TLV in the request.\n   The second five contexts are their
      counterparts in the opposite\n   direction: DSO requests or DSO unidirectional
      messages from server to\n   client, and the corresponding responses from client
      back to server.\n   o  S-P - Primary TLV, sent in DSO request message, from
      server to\n      client, with nonzero MESSAGE ID indicating that this request
      MUST\n      generate response message.\n   o  S-U - Primary TLV, sent in DSO
      unidirectional message, from server\n      to client, with zero MESSAGE ID indicating
      that this request MUST\n      NOT generate response message.\n   o  S-A - Additional
      TLV, optionally added to a DSO request message or\n      DSO unidirectional
      message from server to client.\n   o  SRP - Response Primary TLV, included in
      response message sent back\n      to the server (in response to a server \"S-P\"
      request with nonzero\n      MESSAGE ID indicating that a response is required)
      where the DSO-\n      TYPE of the Response TLV matches the DSO-TYPE of the Primary
      TLV\n      in the request.\n   o  SRA - Response Additional TLV, included in
      response message sent\n      back to the server (in response to a server \"S-P\"
      request with\n      nonzero MESSAGE ID indicating that a response is required)
      where\n      the DSO-TYPE of the Response TLV does not match the DSO-TYPE of\n
      \     the Primary TLV in the request.\n                +-------------------------+-------------------------+\n
      \               | C-P  C-U  C-A  CRP  CRA | S-P  S-U  S-A  SRP  SRA |\n   +------------+-------------------------+-------------------------+\n
      \  | KeepAlive  |  X              X       |       X                 |\n   +------------+-------------------------+-------------------------+\n
      \  | RetryDelay |                      X  |       X              X  |\n   +------------+-------------------------+-------------------------+\n
      \  | Padding    |            X         X  |            X         X  |\n   +------------+-------------------------+-------------------------+\n
      \  Note that some of the columns in this table are currently empty.  The\n   table
      provides a template for future TLV definitions to follow.  It\n   is recommended
      that definitions of future TLVs include a similar\n   table summarizing the
      contexts where the new TLV is valid.\n"
    title: 8.2.  TLV Usage
  title: 8.  Summary Highlights
- contents:
  - '9.  Additional Considerations

    '
  - contents:
    - "9.1.  Service Instances\n   We use the term \"service instance\" to refer to
      software running on a\n   host that can receive connections on some set of {
      IP address, port }\n   tuples.  What makes the software an instance is that
      regardless of\n   which of these tuples the client uses to connect to it, the
      client is\n   connected to the same software, running on the same logical node
      (see\n   Section 9.2), and will receive the same answers and the same keying\n
      \  information.\n   Service instances are identified from the perspective of
      the client.\n   If the client is configured with { IP address, port } tuples,
      it has\n   no way to tell if the service offered at one tuple is the same server\n
      \  that is listening on a different tuple.  So in this case, the client\n   treats
      each different tuple as if it references a different service\n   instance.\n
      \  In some cases, a client is configured with a hostname and a port\n   number.
      \ The port number may be given explicitly, along with the\n   hostname.  The
      port number may be omitted, and assumed to have some\n   default value.  The
      hostname and a port number may be learned from\n   the network, as in the case
      of DNS SRV records.  In these cases, the\n   { hostname, port } tuple uniquely
      identifies the service instance,\n   subject to the usual case-insensitive DNS
      comparison of names\n   [RFC1034].\n   It is possible that two hostnames might
      point to some common IP\n   addresses; this is a configuration anomaly that
      the client is not\n   obliged to detect.  The effect of this could be that after
      being told\n   to disconnect, the client might reconnect to the same server
      because\n   it is represented as a different service instance.\n   Implementations
      SHOULD NOT resolve hostnames and then perform the\n   process of matching IP
      address(es) in order to evaluate whether two\n   entities should be determined
      to be the \"same service instance\".\n"
    title: 9.1.  Service Instances
  - contents:
    - "9.2.  Anycast Considerations\n   When an anycast service is configured on a
      particular IP address and\n   port, it must be the case that although there
      is more than one\n   physical server responding on that IP address, each such
      server can\n   be treated as equivalent.  What we mean by \"equivalent\" here
      is that\n   both servers can provide the same service and, where appropriate,
      the\n   same authentication information, such as PKI certificates, when\n   establishing
      connections.\n   If a change in network topology causes packets in a particular
      TCP\n   connection to be sent to an anycast server instance that does not\n
      \  know about the connection, the new server will automatically\n   terminate
      the connection with a TCP reset, since it will have no\n   record of the connection,
      and then the client can reconnect or stop\n   using the connection as appropriate.\n
      \  If, after the connection is re-established, the client's assumption\n   that
      it is connected to the same instance is violated in some way,\n   that would
      be considered an incorrect behavior in this context.  It\n   is, however, out
      of the possible scope for this specification to make\n   specific recommendations
      in this regard; that would be up to follow-\n   on documents that describe specific
      uses of DNS Stateful Operations.\n"
    title: 9.2.  Anycast Considerations
  - contents:
    - "9.3.  Connection Sharing\n   As previously specified for DNS-over-TCP [RFC7766]:\n
      \     To mitigate the risk of unintentional server overload, DNS\n      clients
      MUST take care to minimize the number of concurrent\n      TCP connections made
      to any individual server.  It is RECOMMENDED\n      that for any given client/server
      interaction there SHOULD be\n      no more than one connection for regular queries,
      one for zone\n      transfers, and one for each protocol that is being used
      on top\n      of TCP (for example, if the resolver was using TLS).  However,\n
      \     it is noted that certain primary/secondary configurations\n      with
      many busy zones might need to use more than one TCP\n      connection for zone
      transfers for operational reasons (for\n      example, to support concurrent
      transfers of multiple zones).\n   A single server may support multiple services,
      including DNS Updates\n   [RFC2136], DNS Push Notifications [Push], and other
      services, for one\n   or more DNS zones.  When a client discovers that the target
      server\n   for several different operations is the same service instance (see\n
      \  Section 9.1), the client SHOULD use a single shared DSO Session for\n   all
      those operations.\n   This requirement has two benefits.  First, it reduces
      unnecessary\n   connection load on the DNS server.  Second, it avoids the connection\n
      \  startup time that would be spent establishing each new additional\n   connection
      to the same DNS server.\n   However, server implementers and operators should
      be aware that\n   connection sharing may not be possible in all cases.  A single
      host\n   device may be home to multiple independent client software instances\n
      \  that don't coordinate with each other.  Similarly, multiple\n   independent
      client devices behind the same NAT gateway will also\n   typically appear to
      the DNS server as different source ports on the\n   same client IP address.
      \ Because of these constraints, a DNS server\n   MUST be prepared to accept
      multiple connections from different source\n   ports on the same client IP address.\n"
    title: 9.3.  Connection Sharing
  - contents:
    - "9.4.  Operational Considerations for Middleboxes\n   Where an application-layer
      middlebox (e.g., a DNS proxy, forwarder,\n   or session multiplexer) is in the
      path, care must be taken to avoid a\n   configuration in which DSO traffic is
      mishandled.  The simplest way\n   to avoid such problems is to avoid using middleboxes.
      \ When this is\n   not possible, middleboxes should be evaluated to make sure
      that they\n   behave correctly.\n   Correct behavior for middleboxes consists
      of one of the following:\n   o  The middlebox does not forward DSO messages
      and responds to DSO\n      messages with a response code other than NOERROR
      or DSOTYPENI.\n   o  The middlebox acts as a DSO server and follows this specification\n
      \     in establishing connections.\n   o  There is a 1:1 correspondence between
      incoming and outgoing\n      connections such that when a connection is established
      to the\n      middlebox, it is guaranteed that exactly one corresponding\n      connection
      will be established from the middlebox to some DNS\n      resolver, and all
      incoming messages will be forwarded without\n      modification or reordering.
      \ An example of this would be a NAT\n      forwarder or TCP connection optimizer
      (e.g., for a high-latency\n      connection such as a geosynchronous satellite
      link).\n   Middleboxes that do not meet one of the above criteria are very\n
      \  likely to fail in unexpected and difficult-to-diagnose ways.  For\n   example,
      a DNS load balancer might unbundle DNS messages from the\n   incoming TCP stream
      and forward each message from the stream to a\n   different DNS server.  If
      such a load balancer is in use, and the DNS\n   servers it points to implement
      DSO and are configured to enable DSO,\n   DSO Session establishment will succeed,
      but no coherent session will\n   exist between the client and the server.  If
      such a load balancer is\n   pointed at a DNS server that does not implement
      DSO or is configured\n   not to allow DSO, no such problem will exist, but such
      a\n   configuration risks unexpected failure if new server software is\n   installed
      that does implement DSO.\n   It is of course possible to implement a middlebox
      that properly\n   supports DSO.  It is even possible to implement one that implements\n
      \  DSO with long-lived operations.  This can be done either by\n   maintaining
      a 1:1 correspondence between incoming and outgoing\n   connections, as mentioned
      above, or by terminating incoming sessions\n   at the middlebox but maintaining
      state in the middlebox about any\n   long-lived operations that are requested.
      \ Specifying this in detail\n   is beyond the scope of this document.\n"
    title: 9.4.  Operational Considerations for Middleboxes
  - contents:
    - "9.5.  TCP Delayed Acknowledgement Considerations\n   Most modern implementations
      of the Transmission Control Protocol\n   (TCP) include a feature called \"Delayed
      Acknowledgement\" [RFC1122].\n   Without this feature, TCP can be very wasteful
      on the network.  For\n   illustration, consider a simple example like remote
      login using a\n   very simple TCP implementation that lacks delayed acks.  When
      the\n   user types a keystroke, a data packet is sent.  When the data packet\n
      \  arrives at the server, the simple TCP implementation sends an\n   immediate
      acknowledgement.  Mere milliseconds later, the server\n   process reads the
      one byte of keystroke data, and consequently the\n   simple TCP implementation
      sends an immediate window update.  Mere\n   milliseconds later, the server process
      generates the character echo\n   and sends this data back in reply.  The simple
      TCP implementation\n   then sends this data packet immediately too.  In this
      case, this\n   simple TCP implementation sends a burst of three packets almost\n
      \  instantaneously (ack, window update, data).\n   Clearly it would be more
      efficient if the TCP implementation were to\n   combine the three separate packets
      into one, and this is what the\n   delayed ack feature enables.\n   With delayed
      ack, the TCP implementation waits after receiving a data\n   packet, typically
      for 200 ms, and then sends its ack if (a) more data\n   packet(s) arrive, (b)
      the receiving process generates some reply\n   data, or (c) 200 ms elapse without
      either of the above occurring.\n   With delayed ack, remote login becomes much
      more efficient,\n   generating just one packet instead of three for each character
      echo.\n   The logic of delayed ack is that the 200 ms delay cannot do any\n
      \  significant harm.  If something at the other end were waiting for\n   something,
      then the receiving process should generate the reply that\n   the thing at the
      other end is waiting for, and TCP will then\n   immediately send that reply
      (combined with the ack and window\n   update).  And if the receiving process
      does not in fact generate any\n   reply for this particular message, then by
      definition the thing at\n   the other end cannot be waiting for anything.  Therefore,
      the 200 ms\n   delay is harmless.\n   This assumption may be true unless the
      sender is using Nagle's\n   algorithm, a similar efficiency feature, created
      to protect the\n   network from poorly written client software that performs
      many rapid\n   small writes in succession.  Nagle's algorithm allows these small\n
      \  writes to be coalesced into larger, less wasteful packets.\n   Unfortunately,
      Nagle's algorithm and delayed ack, two valuable\n   efficiency features, can
      interact badly with each other when used\n   together [NagleDA].\n   DSO request
      messages elicit responses; DSO unidirectional messages\n   and DSO response
      messages do not.\n   For DSO request messages, which do elicit responses, Nagle's\n
      \  algorithm and delayed ack work as intended.\n   For DSO messages that do
      not elicit responses, the delayed ack\n   mechanism causes the ack to be delayed
      by 200 ms.  The 200 ms delay\n   on the ack can in turn cause Nagle's algorithm
      to prevent the sender\n   from sending any more data for 200 ms until the awaited
      ack arrives.\n   On an enterprise Gigabit Ethernet (GigE) backbone with sub-\n
      \  millisecond round-trip times, a 200 ms delay is enormous in\n   comparison.\n
      \  When this issues is raised, there are two solutions that are often\n   offered,
      neither of them ideal:\n   1.  Disable delayed ack.  For DSO messages that elicit
      no response,\n       removing delayed ack avoids the needless 200 ms delay and
      sends\n       back an immediate ack that tells Nagle's algorithm that it should\n
      \      immediately grant the sender permission to send its next packet.\n       Unfortunately,
      for DSO messages that *do* elicit a response,\n       removing delayed ack removes
      the efficiency gains of combining\n       acks with data, and the responder
      will now send two or three\n       packets instead of one.\n   2.  Disable Nagle's
      algorithm.  When acks are delayed by the delayed\n       ack algorithm, removing
      Nagle's algorithm prevents the sender\n       from being blocked from sending
      its next small packet\n       immediately.  Unfortunately, on a network with
      a higher round-\n       trip time, removing Nagle's algorithm removes the efficiency\n
      \      gains of combining multiple small packets into fewer larger ones,\n       with
      the goal of limiting the number of small packets in flight\n       at any one
      time.\n   The problem here is that with DSO messages that elicit no response,\n
      \  the TCP implementation is stuck waiting, unsure if a response is\n   about
      to be generated or whether the TCP implementation should go\n   ahead and send
      an ack and window update.\n   The solution is networking APIs that allow the
      receiver to inform the\n   TCP implementation that a received message has been
      read, processed,\n   and no response for this message will be generated.  TCP
      can then\n   stop waiting for a response that will never come, and immediately
      go\n   ahead and send an ack and window update.\n   For implementations of DSO,
      disabling delayed ack is NOT RECOMMENDED\n   because of the harm this can do
      to the network.\n   For implementations of DSO, disabling Nagle's algorithm
      is NOT\n   RECOMMENDED because of the harm this can do to the network.\n   At
      the time that this document is being prepared for publication, it\n   is known
      that at least one TCP implementation provides the ability\n   for the recipient
      of a TCP message to signal that it is not going to\n   send a response, and
      hence the delayed ack mechanism can stop\n   waiting.  Implementations on operating
      systems where this feature is\n   available SHOULD make use of it.\n"
    title: 9.5.  TCP Delayed Acknowledgement Considerations
  title: 9.  Additional Considerations
- contents:
  - '10.  IANA Considerations

    '
  - contents:
    - "10.1.  DSO OPCODE Registration\n   The IANA has assigned the value 6 for DNS
      Stateful Operations (DSO)\n   in the \"DNS OpCodes\" registry.\n"
    title: 10.1.  DSO OPCODE Registration
  - contents:
    - "10.2.  DSO RCODE Registration\n   IANA has assigned the value 11 for the DSOTYPENI
      error code in the\n   \"DNS RCODEs\" registry.  The DSOTYPENI error code (\"DSO-TYPE
      Not\n   Implemented\") indicates that the receiver does implement DNS Stateful\n
      \  Operations, but does not implement the specific DSO-TYPE of the\n   Primary
      TLV in the DSO request message.\n"
    title: 10.2.  DSO RCODE Registration
  - contents:
    - "10.3.  DSO Type Code Registry\n   The IANA has created the 16-bit \"DSO Type
      Codes\" registry, with\n   initial (hexadecimal) values as shown below:\n   +-----------+-----------------------+-------+-----------+-----------+\n
      \  | Type      | Name                  | Early | Status    | Reference |\n   |
      \          |                       | Data  |           |           |\n   +-----------+-----------------------+-------+-----------+-----------+\n
      \  | 0000      | Reserved              | NO    | Standards | RFC 8490  |\n   |
      \          |                       |       | Track     |           |\n   |           |
      \                      |       |           |           |\n   | 0001      | KeepAlive
      \            | OK    | Standards | RFC 8490  |\n   |           |                       |
      \      | Track     |           |\n   |           |                       |       |
      \          |           |\n   | 0002      | RetryDelay            | NO    | Standards
      | RFC 8490  |\n   |           |                       |       | Track     |
      \          |\n   |           |                       |       |           |           |\n
      \  | 0003      | EncryptionPadding     | NA    | Standards | RFC 8490  |\n   |
      \          |                       |       | Track     |           |\n   |           |
      \                      |       |           |           |\n   | 0004-003F | Unassigned,
      reserved  | NO    |           |           |\n   |           | for DSO session-
      \     |       |           |           |\n   |           | management TLVs       |
      \      |           |           |\n   |           |                       |       |
      \          |           |\n   | 0040-F7FF | Unassigned            | NO    |           |
      \          |\n   |           |                       |       |           |           |\n
      \  | F800-FBFF | Experimental/local    | NO    |           |           |\n   |
      \          | use                   |       |           |           |\n   |           |
      \                      |       |           |           |\n   | FC00-FFFF | Reserved
      for future   | NO    |           |           |\n   |           | expansion             |
      \      |           |           |\n   +-----------+-----------------------+-------+-----------+-----------+\n
      \  The meanings of the fields are as follows:\n   Type:  The 16-bit DSO type
      code.\n   Name:  The human-readable name of the TLV.\n   Early Data:  If OK,
      this TLV may be sent as early data in a TLS zero\n      round-trip (Section
      2.3 of the TLS 1.3 specification [RFC8446])\n      initial handshake.  If NA,
      the TLV may appear as an Additional TLV\n      in a DSO message that is sent
      as early data.\n   Status:  RFC status (e.g., \"Standards Track\") or \"External\"
      if not\n      documented in an RFC.\n   Reference:  A stable reference to the
      document in which this TLV is\n      defined.\n   Note: DSO Type Code zero is
      reserved and is not currently intended\n   for allocation.\n   Registrations
      of new DSO Type Codes in the \"Reserved for DSO session-\n   management\" range
      0004-003F and the \"Reserved for future expansion\"\n   range FC00-FFFF require
      publication of an IETF Standards Action\n   document [RFC8126].\n   Requests
      to register additional new DSO Type Codes in the\n   \"Unassigned\" range 0040-F7FF
      are to be recorded by IANA after Expert\n   Review [RFC8126].  The expert review
      should validate that the\n   requested type code is specified in a way that
      conforms to this\n   specification, and that the intended use for the code would
      not be\n   addressed with an experimental/local assignment.\n   DSO Type Codes
      in the \"experimental/local\" range F800-FBFF may be\n   used as Experimental
      Use or Private Use values [RFC8126] and may be\n   used freely for development
      purposes or for other purposes within a\n   single site.  No attempt is made
      to prevent multiple sites from using\n   the same value in different (and incompatible)
      ways.  There is no\n   need for IANA to review such assignments (since IANA
      does not record\n   them) and assignments are not generally useful for broad\n
      \  interoperability.  It is the responsibility of the sites making use\n   of
      \"experimental/local\" values to ensure that no conflicts occur\n   within the
      intended scope of use.\n   Any document defining a new TLV that lists a value
      of \"OK\" in the\n   Early Data column must include a threat analysis for the
      use of the\n   TLV in the case of TLS zero round-trip.  See Section 11.1 for\n
      \  details.\n"
    title: 10.3.  DSO Type Code Registry
  title: 10.  IANA Considerations
- contents:
  - "11.  Security Considerations\n   If this mechanism is to be used with DNS-over-TLS,
    then these\n   messages are subject to the same constraints as any other DNS-over-\n
    \  TLS messages and MUST NOT be sent in the clear before the TLS session\n   is
    established.\n   The data field of the \"Encryption Padding\" TLV could be used
    as a\n   covert channel.\n   When designing new DSO TLVs, the potential for data
    in the TLV to be\n   used as a tracking identifier should be taken into consideration
    and\n   should be avoided when not required.\n   When used without TLS or similar
    cryptographic protection, a\n   malicious entity may be able to inject a malicious
    unidirectional DSO\n   Retry Delay message into the data stream, specifying an
    unreasonably\n   large RETRY DELAY, causing a denial-of-service attack against
    the\n   client.\n   The establishment of DSO Sessions has an impact on the number
    of open\n   TCP connections on a DNS server.  Additional resources may be used
    on\n   the server as a result.  However, because the server can limit the\n   number
    of DSO Sessions established and can also close existing DSO\n   Sessions as needed,
    denial of service or resource exhaustion should\n   not be a concern.\n"
  - contents:
    - "11.1.  TLS Zero Round-Trip Considerations\n   DSO permits zero round-trip operation
      using TCP Fast Open with\n   TLS 1.3 [RFC8446] early data to reduce or eliminate
      round trips in\n   session establishment.  TCP Fast Open is only permitted in\n
      \  combination with TLS 1.3 early data.  In the rest of this section, we\n   refer
      to TLS 1.3 early data in a TLS zero round-trip initial\n   handshake message,
      regardless of whether or not it is included in a\n   TCP SYN packet with early
      data using the TCP Fast Open option, as\n   \"early data.\"\n   A DSO message
      may or may not be permitted to be sent as early data.\n   The definition for
      each TLV that can be used as a Primary TLV is\n   required to state whether
      or not that TLV is permitted as early data.\n   Only response-requiring messages
      are ever permitted as early data,\n   and only clients are permitted to send
      a DSO message as early data\n   unless there is an implicit DSO session (see
      Section 5.1).\n   For DSO messages that are permitted as early data, a client
      MAY\n   include one or more such messages as early data without having to\n
      \  wait for a DSO response to the first DSO request message to confirm\n   successful
      establishment of a DSO Session.\n   However, unless there is an implicit DSO
      session, a client MUST NOT\n   send DSO unidirectional messages until after
      a DSO Session has been\n   mutually established.\n   Similarly, unless there
      is an implicit DSO session, a server MUST NOT\n   send DSO request messages
      until it has received a response-requiring\n   DSO request message from a client
      and transmitted a successful\n   NOERROR response for that request.\n   Caution
      must be taken to ensure that DSO messages sent as early data\n   are idempotent
      or are otherwise immune to any problems that could\n   result from the inadvertent
      replay that can occur with zero round-\n   trip operation.\n   It would be possible
      to add a TLV that requires the server to do some\n   significant work and send
      that to the server as initial data in a TCP\n   SYN packet.  A flood of such
      packets could be used as a DoS attack on\n   the server.  None of the TLVs defined
      here have this property.\n   If a new TLV is specified that does have this property,
      that TLV must\n   be specified as not permitted in zero round-trip messages.
      \ This\n   prevents work from being done until a round-trip has occurred from\n
      \  the server to the client to verify that the source address of the\n   packet
      is reachable.\n   Documents that define new TLVs must state whether each new
      TLV may be\n   sent as early data.  Such documents must include a threat analysis
      in\n   the security considerations section for each TLV defined in the\n   document
      that may be sent as early data.  This threat analysis should\n   be done based
      on the advice given in Sections 2.3, 8, and\n   Appendix E.5 of the TLS 1.3
      specification [RFC8446].\n"
    title: 11.1.  TLS Zero Round-Trip Considerations
  title: 11.  Security Considerations
- contents:
  - '12.  References

    '
  - contents:
    - "12.1.  Normative References\n   [RFC1034]  Mockapetris, P., \"Domain names
      - concepts and facilities\",\n              STD 13, RFC 1034, DOI 10.17487/RFC1034,
      November 1987,\n              <https://www.rfc-editor.org/info/rfc1034>.\n   [RFC1035]
      \ Mockapetris, P., \"Domain names - implementation and\n              specification\",
      STD 13, RFC 1035, DOI 10.17487/RFC1035,\n              November 1987, <https://www.rfc-editor.org/info/rfc1035>.\n
      \  [RFC1918]  Rekhter, Y., Moskowitz, B., Karrenberg, D., de Groot, G.,\n              and
      E. Lear, \"Address Allocation for Private Internets\",\n              BCP 5,
      RFC 1918, DOI 10.17487/RFC1918, February 1996,\n              <https://www.rfc-editor.org/info/rfc1918>.\n
      \  [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n              Requirement
      Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n
      \             <https://www.rfc-editor.org/info/rfc2119>.\n   [RFC2136]  Vixie,
      P., Ed., Thomson, S., Rekhter, Y., and J. Bound,\n              \"Dynamic Updates
      in the Domain Name System (DNS UPDATE)\",\n              RFC 2136, DOI 10.17487/RFC2136,
      April 1997,\n              <https://www.rfc-editor.org/info/rfc2136>.\n   [RFC6891]
      \ Damas, J., Graff, M., and P. Vixie, \"Extension Mechanisms\n              for
      DNS (EDNS(0))\", STD 75, RFC 6891,\n              DOI 10.17487/RFC6891, April
      2013,\n              <https://www.rfc-editor.org/info/rfc6891>.\n   [RFC7766]
      \ Dickinson, J., Dickinson, S., Bellis, R., Mankin, A., and\n              D.
      Wessels, \"DNS Transport over TCP - Implementation\n              Requirements\",
      RFC 7766, DOI 10.17487/RFC7766, March 2016,\n              <https://www.rfc-editor.org/info/rfc7766>.\n
      \  [RFC7830]  Mayrhofer, A., \"The EDNS(0) Padding Option\", RFC 7830,\n              DOI
      10.17487/RFC7830, May 2016,\n              <https://www.rfc-editor.org/info/rfc7830>.\n
      \  [RFC8126]  Cotton, M., Leiba, B., and T. Narten, \"Guidelines for\n              Writing
      an IANA Considerations Section in RFCs\", BCP 26,\n              RFC 8126, DOI
      10.17487/RFC8126, June 2017,\n              <https://www.rfc-editor.org/info/rfc8126>.\n
      \  [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119
      Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017,
      <https://www.rfc-editor.org/info/rfc8174>.\n"
    title: 12.1.  Normative References
  - contents:
    - "12.2.  Informative References\n   [Fail]     Andrews, M. and R. Bellis, \"A
      Common Operational Problem\n              in DNS Servers - Failure To Communicate\",
      Work in\n              Progress, draft-ietf-dnsop-no-response-issue-13, February\n
      \             2019.\n   [NagleDA]  Cheshire, S., \"TCP Performance problems
      caused by\n              interaction between Nagle's Algorithm and Delayed ACK\",\n
      \             May 2005,\n              <http://www.stuartcheshire.org/papers/nagledelayedack/>.\n
      \  [Push]     Pusateri, T. and S. Cheshire, \"DNS Push Notifications\",\n              Work
      in Progress, draft-ietf-dnssd-push-18, March 2019.\n   [Relay]    Lemon, T.
      and S. Cheshire, \"Multicast DNS Discovery\n              Relay\", Work in Progress,
      draft-ietf-dnssd-mdns-relay-02,\n              March 2019.\n   [RFC1122]  Braden,
      R., Ed., \"Requirements for Internet Hosts -\n              Communication Layers\",
      STD 3, RFC 1122,\n              DOI 10.17487/RFC1122, October 1989,\n              <https://www.rfc-editor.org/info/rfc1122>.\n
      \  [RFC2132]  Alexander, S. and R. Droms, \"DHCP Options and BOOTP Vendor\n
      \             Extensions\", RFC 2132, DOI 10.17487/RFC2132, March 1997,\n              <https://www.rfc-editor.org/info/rfc2132>.\n
      \  [RFC5382]  Guha, S., Ed., Biswas, K., Ford, B., Sivakumar, S., and P.\n              Srisuresh,
      \"NAT Behavioral Requirements for TCP\", BCP 142,\n              RFC 5382, DOI
      10.17487/RFC5382, October 2008,\n              <https://www.rfc-editor.org/info/rfc5382>.\n
      \  [RFC6762]  Cheshire, S. and M. Krochmal, \"Multicast DNS\", RFC 6762,\n              DOI
      10.17487/RFC6762, February 2013,\n              <https://www.rfc-editor.org/info/rfc6762>.\n
      \  [RFC6763]  Cheshire, S. and M. Krochmal, \"DNS-Based Service\n              Discovery\",
      RFC 6763, DOI 10.17487/RFC6763, February 2013,\n              <https://www.rfc-editor.org/info/rfc6763>.\n
      \  [RFC7413]  Cheng, Y., Chu, J., Radhakrishnan, S., and A. Jain, \"TCP\n              Fast
      Open\", RFC 7413, DOI 10.17487/RFC7413, December 2014,\n              <https://www.rfc-editor.org/info/rfc7413>.\n
      \  [RFC7828]  Wouters, P., Abley, J., Dickinson, S., and R. Bellis, \"The\n
      \             edns-tcp-keepalive EDNS0 Option\", RFC 7828,\n              DOI
      10.17487/RFC7828, April 2016,\n              <https://www.rfc-editor.org/info/rfc7828>.\n
      \  [RFC7857]  Penno, R., Perreault, S., Boucadair, M., Ed., Sivakumar,\n              S.,
      and K. Naito, \"Updates to Network Address Translation\n              (NAT)
      Behavioral Requirements\", BCP 127, RFC 7857,\n              DOI 10.17487/RFC7857,
      April 2016,\n              <https://www.rfc-editor.org/info/rfc7857>.\n   [RFC7858]
      \ Hu, Z., Zhu, L., Heidemann, J., Mankin, A., Wessels, D.,\n              and
      P. Hoffman, \"Specification for DNS over Transport\n              Layer Security
      (TLS)\", RFC 7858, DOI 10.17487/RFC7858, May\n              2016, <https://www.rfc-editor.org/info/rfc7858>.\n
      \  [RFC8446]  Rescorla, E., \"The Transport Layer Security (TLS) Protocol\n
      \             Version 1.3\", RFC 8446, DOI 10.17487/RFC8446, August 2018,\n
      \             <https://www.rfc-editor.org/info/rfc8446>.\n   [RFC8467]  Mayrhofer,
      A., \"Padding Policies for Extension Mechanisms\n              for DNS (EDNS(0))\",
      RFC 8467, DOI 10.17487/RFC8467,\n              October 2018, <https://www.rfc-editor.org/info/rfc8467>.\n
      \  [RFC8484]  Hoffman, P. and P. McManus, \"DNS Queries over HTTPS\n              (DoH)\",
      RFC 8484, DOI 10.17487/RFC8484, October 2018,\n              <https://www.rfc-editor.org/info/rfc8484>.\n"
    title: 12.2.  Informative References
  title: 12.  References
- contents:
  - "Acknowledgements\n   Thanks to Stephane Bortzmeyer, Tim Chown, Ralph Droms, Paul
    Hoffman,\n   Jan Komissar, Edward Lewis, Allison Mankin, Rui Paulo, David\n   Schinazi,
    Manju Shankar Rao, Bernie Volz, and Bob Harold for their\n   helpful contributions
    to this document.\n"
  title: Acknowledgements
- contents:
  - "Authors' Addresses\n   Ray Bellis\n   Internet Systems Consortium, Inc.\n   950
    Charter Street\n   Redwood City, CA  94063\n   United States of America\n   Phone:
    +1 (650) 423-1200\n   Email: ray@isc.org\n   Stuart Cheshire\n   Apple Inc.\n
    \  One Apple Park Way\n   Cupertino, CA  95014\n   United States of America\n
    \  Phone: +1 (408) 996-1010\n   Email: cheshire@apple.com\n   John Dickinson\n
    \  Sinodun Internet Technologies\n   Magadalen Centre\n   Oxford Science Park\n
    \  Oxford  OX4 4GA\n   United Kingdom\n   Email: jad@sinodun.com\n   Sara Dickinson\n
    \  Sinodun Internet Technologies\n   Magadalen Centre\n   Oxford Science Park\n
    \  Oxford  OX4 4GA\n   United Kingdom\n   Email: sara@sinodun.com\n   Ted Lemon\n
    \  Nibbhaya Consulting\n   P.O. Box 958\n   Brattleboro, VT  05302-0958\n   United
    States of America\n   Email: mellon@fugue.com\n   Tom Pusateri\n   Unaffiliated\n
    \  Raleigh, NC  27608\n   United States of America\n   Phone: +1 (919) 867-1330\n
    \  Email: pusateri@bangj.com\n"
  title: Authors' Addresses
