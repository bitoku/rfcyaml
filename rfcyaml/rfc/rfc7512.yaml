- contents:
  - '                        The PKCS #11 URI Scheme

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This memo specifies a PKCS #11 Uniform Resource Identifier (URI)\n
    \  Scheme for identifying PKCS #11 objects stored in PKCS #11 tokens and\n   also
    for identifying PKCS #11 tokens, slots, or libraries.  The URI\n   scheme is based
    on how PKCS #11 objects, tokens, slots, and libraries\n   are identified in \"PKCS
    #11 v2.20: Cryptographic Token Interface\n   Standard\".\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7512.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2015 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................2\n
    \  2. PKCS #11 URI Scheme Definition ..................................4\n      2.1.
    PKCS #11 URI Scheme Name ...................................4\n      2.2. PKCS
    #11 URI Scheme Status .................................4\n      2.3. PKCS #11
    URI Scheme Syntax .................................4\n      2.4. PKCS #11 URI
    Scheme Query Attribute Semantics ..............9\n      2.5. PKCS #11 URI Matching
    Guidelines ..........................11\n      2.6. PKCS #11 URI Comparison ...................................12\n
    \     2.7. Generating PKCS #11 URIs ..................................14\n   3.
    Examples of PKCS #11 URIs ......................................14\n   4. IANA
    Considerations ............................................17\n      4.1. URI
    Scheme Registration ...................................17\n   5. Internationalization
    Considerations ............................18\n   6. Security Considerations ........................................18\n
    \  7. References .....................................................19\n      7.1.
    Normative References ......................................19\n      7.2. Informative
    References ....................................19\n   Contributors ......................................................20\n
    \  Authors' Addresses ................................................20\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   \"PKCS #11 v2.20: Cryptographic Token Interface Standard\"
    [PKCS11]\n   specifies an API, called Cryptoki, for devices that hold\n   cryptographic
    information and perform cryptographic functions.\n   Cryptoki (pronounced \"crypto-key\"
    and short for \"cryptographic token\n   interface\") follows a simple object-based
    approach, addressing the\n   goals of technology independence (any kind of device
    may be used) and\n   resource sharing (multiple applications may access multiple
    devices),\n   presenting applications with a common, logical view of the device
    --\n   a cryptographic token.\n   It is desirable for applications or libraries
    that work with PKCS #11\n   tokens to accept a common identifier that consumers
    could use to\n   identify an existing PKCS #11 storage object in a PKCS #11 token,
    an\n   existing token itself, a slot, or an existing Cryptoki library (also\n
    \  called a producer, module, or provider).  The set of storage object\n   types
    that can be stored in a PKCS #11 token includes a certificate;\n   a data object;
    and a public, private, or secret key.  These objects\n   can be uniquely identifiable
    via the PKCS #11 URI scheme defined in\n   this document.  The set of attributes
    describing a storage object can\n   contain an object label, its type, and its
    ID.  The set of attributes\n   that identifies a PKCS #11 token can contain a
    token label,\n   manufacturer name, serial number, and token model.  Attributes
    that\n   can identify a slot are a slot ID, description, and manufacturer.\n   Attributes
    that can identify a Cryptoki library are a library\n   manufacturer, description,
    and version.  Library attributes may be\n   necessary to use if more than one
    Cryptoki library provides a token\n   and/or PKCS #11 objects of the same name.
    \ A set of query attributes\n   is provided as well.\n   A PKCS #11 URI cannot
    identify other objects defined in the\n   specification [PKCS11] aside from storage
    objects.  For example,\n   objects not identifiable by a PKCS #11 URI include
    a hardware feature\n   and mechanism.  Note that a Cryptoki library does not have
    to provide\n   for storage objects at all.  The URI can still be used to identify
    a\n   specific PKCS #11 token, slot, or an API producer in such a case.\n   A
    subset of existing PKCS #11 structure members and object attributes\n   was chosen
    to uniquely identify a PKCS #11 storage object, token,\n   slot, or library in
    a configuration file, on a command line, or in a\n   configuration property of
    something else.  Should there be a need for\n   a more complex information exchange
    on PKCS #11 entities, a different\n   means of data marshalling should be chosen
    accordingly.\n   A PKCS #11 URI is not intended to be used to create new PKCS
    #11\n   objects in tokens or to create PKCS #11 tokens.  It is solely to be\n
    \  used to identify and work with existing storage objects, tokens, and\n   slots
    through the PKCS #11 API, or to identify Cryptoki libraries\n   themselves.\n
    \  The URI scheme defined in this document is designed specifically with\n   a
    mapping to the PKCS #11 API in mind.  The URI scheme definition\n   uses the scheme,
    path, and query components defined in the \"Uniform\n   Resource Identifier (URI):
    Generic Syntax\" [RFC3986] document.  The\n   URI scheme does not use the hierarchical
    element for a naming\n   authority in the path since the authority part could
    not be mapped to\n   PKCS #11 API elements.  The URI scheme does not use the fragment\n
    \  component.\n   If an application has no access to a producer or producers of
    the\n   PKCS #11 API, the query component module attributes can be used.\n   However,
    the PKCS #11 URI consumer can always decide to provide its\n   own adequate user
    interface to locate and load PKCS #11 API\n   producers.\n   The key words \"MUST\",
    \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD
    NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to
    be interpreted as described in [RFC2119].\n"
  title: 1.  Introduction
- contents:
  - "2.  PKCS #11 URI Scheme Definition\n   In accordance with [RFC4395], this section
    provides the information\n   required to register the PKCS #11 URI scheme.\n"
  - contents:
    - "2.1.  PKCS #11 URI Scheme Name\n   pkcs11\n"
    title: '2.1.  PKCS #11 URI Scheme Name'
  - contents:
    - "2.2.  PKCS #11 URI Scheme Status\n   Permanent\n"
    title: '2.2.  PKCS #11 URI Scheme Status'
  - contents:
    - "2.3.  PKCS #11 URI Scheme Syntax\n   A PKCS #11 URI is a sequence of attribute
      value pairs separated by a\n   semicolon that form a one-level path component,
      optionally followed\n   by a query.  Except for the value of the \"id\" attribute
      defined later\n   in this section, these attribute value pairs and query components
      are\n   composed entirely of textual data and therefore SHOULD all first be\n
      \  encoded as octets according to the UTF-8 character encoding\n   [RFC3629],
      in accordance with Section 2.5 of [RFC3986]; then, only\n   those octets that
      do not correspond to characters in the unreserved\n   set or to permitted characters
      from the reserved set SHOULD be\n   percent-encoded.  Note that the value of
      the \"id\" attribute SHOULD\n   NOT be encoded as UTF-8 because it can contain
      non-textual data,\n   instead it SHOULD be entirely percent-encoded.  See important
      caveats\n   in Sections 2.5 and 5 regarding working with UTF-8 strings containing\n
      \  characters outside the US-ASCII character set.\n   Grammar rules \"unreserved\"
      and \"pct-encoded\" in the PKCS #11 URI\n   scheme definition below are imported
      from [RFC3986].  As a special\n   case, note that according to Appendix A of
      [RFC3986], a space must be\n   percent-encoded.\n   The PKCS #11 specification
      imposes various limitations on the value\n   of attributes, be it a more restrictive
      character set for the\n   \"serial\" attribute or fixed-size buffers for almost
      all the others,\n   including \"token\", \"manufacturer\", and \"model\" attributes.
      \ The\n   syntax of the PKCS #11 URI scheme does not impose such limitations.\n
      \  However, if the consumer of a PKCS #11 URI encounters values that\n   would
      not be accepted by the PKCS #11 specification, it MUST refuse\n   the URI as
      invalid.\n   A PKCS #11 URI takes the following form (for explanation of Augmented\n
      \  BNF, see [RFC5234]):\n pk11-URI             = \"pkcs11:\" pk11-path [ \"?\"
      pk11-query ]\n ; Path component and its attributes.  Path may be empty.\n pk11-path
      \           = [ pk11-pattr *(\";\" pk11-pattr) ]\n pk11-pattr           = pk11-token
      / pk11-manuf / pk11-serial /\n                        pk11-model / pk11-lib-manuf
      /\n                        pk11-lib-ver / pk11-lib-desc /\n                        pk11-object
      / pk11-type / pk11-id /\n                        pk11-slot-desc / pk11-slot-manuf
      /\n                        pk11-slot-id / pk11-v-pattr\n ; Query component and
      its attributes.  Query may be empty.\n pk11-qattr           = pk11-pin-source
      / pk11-pin-value /\n                        pk11-module-name / pk11-module-path
      /\n                        pk11-v-qattr\n pk11-query           = [ pk11-qattr
      *(\"&\" pk11-qattr) ]\n ; Section 2.2 of [RFC3986] mandates all potentially
      reserved characters\n ; that do not conflict with actual delimiters of the URI
      do not have\n ; to be percent-encoded.\n pk11-res-avail       = \":\" / \"[\"
      / \"]\" / \"@\" / \"!\" / \"$\" /\n                        \"'\" / \"(\" / \")\"
      / \"*\" / \"+\" / \",\" / \"=\"\n pk11-path-res-avail  = pk11-res-avail / \"&\"\n
      ; \"/\" and \"?\" in the query component MAY be unencoded but \"&\" MUST\n ;
      be encoded since it functions as a delimiter within the component.\n pk11-query-res-avail
      = pk11-res-avail / \"/\" / \"?\" / \"|\"\n pk11-pchar           = unreserved
      / pk11-path-res-avail / pct-encoded\n pk11-qchar           = unreserved / pk11-query-res-avail
      / pct-encoded\n pk11-token           = \"token\" \"=\" *pk11-pchar\n pk11-manuf
      \          = \"manufacturer\" \"=\" *pk11-pchar\n pk11-serial          = \"serial\"
      \"=\" *pk11-pchar\n pk11-model           = \"model\" \"=\" *pk11-pchar\n pk11-lib-manuf
      \      = \"library-manufacturer\" \"=\" *pk11-pchar\n pk11-lib-desc        =
      \"library-description\" \"=\" *pk11-pchar\n pk11-lib-ver         = \"library-version\"
      \"=\" 1*DIGIT [ \".\" 1*DIGIT ]\n pk11-object          = \"object\" \"=\" *pk11-pchar\n
      pk11-type            = \"type\" \"=\" ( \"public\" / \"private\" / \"cert\"
      /\n                        \"secret-key\" / \"data\" )\n pk11-id              =
      \"id\" \"=\" *pk11-pchar\n pk11-slot-manuf      = \"slot-manufacturer\" \"=\"
      *pk11-pchar\n pk11-slot-desc       = \"slot-description\" \"=\" *pk11-pchar\n
      pk11-slot-id         = \"slot-id\" \"=\" 1*DIGIT\n pk11-pin-source      = \"pin-source\"
      \"=\" *pk11-qchar\n pk11-pin-value       = \"pin-value\" \"=\" *pk11-qchar\n
      pk11-module-name     = \"module-name\" \"=\" *pk11-qchar\n pk11-module-path
      \    = \"module-path\" \"=\" *pk11-qchar\n pk11-v-attr-nm-char  = ALPHA / DIGIT
      / \"-\" / \"_\"\n ; The permitted value of a vendor-specific attribute is based
      on\n ; whether the attribute is used in the path or in the query.\n pk11-v-pattr
      \        = 1*pk11-v-attr-nm-char \"=\" *pk11-pchar\n pk11-v-qattr         =
      1*pk11-v-attr-nm-char \"=\" *pk11-qchar\n   The URI path component contains
      attributes that identify a resource\n   in a one-level hierarchy provided by
      Cryptoki producers.  The query\n   component can contain a few attributes that
      may be needed to retrieve\n   the resource identified by the URI path component.
      \ Attributes in the\n   path component are delimited by the ';' character, attributes
      in the\n   query component use '&' as a delimiter.\n   Both path and query components
      MAY contain vendor-specific\n   attributes.  Such attribute names MUST NOT clash
      with existing\n   attribute names.  Note that in accordance with [BCP178], the\n
      \  previously used convention of starting vendor attributes with an \"x-\"\n
      \  prefix is now deprecated.\n   The general '/' delimiter MUST be percent-encoded
      in the path\n   component so that generic URI parsers never split the path component\n
      \  into multiple segments.  It MAY be unencoded in the query component.\n   The
      delimiter '?'  MUST be percent-encoded in the path component\n   since the PKCS
      #11 URI scheme uses a query component.  The delimiter\n   '#' MUST be always
      percent-encoded so that generic URI parsers do not\n   treat a hash as a beginning
      of a fragment identifier component.  All\n   other generic delimiters MAY be
      used unencoded (':', '[', ']', and\n   '@') in a PKCS #11 URI.\n   The following
      table presents mapping between the PKCS #11 URI path\n   component attributes
      and the PKCS #11 API structure members and\n   object attributes.  Given that
      PKCS #11 URI users may be quite\n   ignorant about the PKCS #11 specification,
      the mapping is a product\n   of a necessary compromise between how precisely
      the URI attribute\n   names are mapped to the names in the specification and
      the ease of\n   use and understanding of the URI scheme.\n   +----------------------+---------------------+----------------------+\n
      \  | URI component path   | Attribute           | PKCS #11             |\n   |
      attribute name       | represents          | specification        |\n   |                      |
      \                    | counterpart          |\n   +----------------------+---------------------+----------------------+\n
      \  | id                   | key identifier for  | \"CKA_ID\" object      |\n
      \  |                      | object              | attribute            |\n   +----------------------+---------------------+----------------------+\n
      \  | library-description  | character-string    | \"libraryDescription\" |\n
      \  |                      | description of the  | member of CK_INFO    |\n   |
      \                     | library             | structure.  It is a  |\n   |                      |
      \                    | UTF-8 string.        |\n   +----------------------+---------------------+----------------------+\n
      \  | library-manufacturer | ID of the Cryptoki  | \"manufacturerID\"     |\n
      \  |                      | library             | member of the        |\n   |
      \                     | manufacturer        | CK_INFO structure.   |\n   |                      |
      \                    | It is a UTF-8        |\n   |                      |                     |
      string.              |\n   +----------------------+---------------------+----------------------+\n
      \  | library-version      | Cryptoki library    | \"libraryVersion\"     |\n
      \  |                      | version number      | member of the        |\n   |
      \                     |                     | CK_INFO structure.   |\n   +----------------------+---------------------+----------------------+\n
      \  | manufacturer         | ID of the token     | \"manufacturerID\"     |\n
      \  |                      | manufacturer        | member of            |\n   |
      \                     |                     | CK_TOKEN_INFO        |\n   |                      |
      \                    | structure.  It is a  |\n   |                      |                     |
      UTF-8 string.        |\n   +----------------------+---------------------+----------------------+\n
      \  | model                | token model         | \"model\" member of    |\n
      \  |                      |                     | CK_TOKEN_INFO        |\n   |
      \                     |                     | structure.  It is a  |\n   |                      |
      \                    | UTF-8 string.        |\n   +----------------------+---------------------+----------------------+\n
      \  | object               | description (name)  | \"CKA_LABEL\" object   |\n
      \  |                      | of the object       | attribute.  It is a  |\n   |
      \                     |                     | UTF-8 string.        |\n   +----------------------+---------------------+----------------------+\n
      \  | serial               | character-string    | \"serialNumber\"       |\n
      \  |                      | serial number of    | member of            |\n   |
      \                     | the token           | CK_TOKEN_INFO        |\n   |                      |
      \                    | structure.           |\n   +----------------------+---------------------+----------------------+\n
      \  | slot-description     | slot description    | \"slotDescription\"    |\n
      \  |                      |                     | member of            |\n   |
      \                     |                     | CK_SLOT_INFO         |\n   |                      |
      \                    | structure.  It is a  |\n   |                      |                     |
      UTF-8 string.        |\n   +----------------------+---------------------+----------------------+\n
      \  | slot-id              | Cryptoki-assigned   | decimal number of    |\n   |
      \                     | value that          | \"CK_SLOT_ID\" type.   |\n   |
      \                     | identifies a slot   |                      |\n   +----------------------+---------------------+----------------------+\n
      \  | slot-manufacturer    | ID of the slot      | \"manufacturerID\"     |\n
      \  |                      | manufacturer        | member of            |\n   |
      \                     |                     | CK_SLOT_INFO         |\n   |                      |
      \                    | structure.  It is a  |\n   |                      |                     |
      UTF-8 string.        |\n   +----------------------+---------------------+----------------------+\n
      \  | token                | application-defined | \"label\" member of    |\n
      \  |                      | label, assigned     | the CK_TOKEN_INFO    |\n   |
      \                     | during token        | structure.  It is a  |\n   |                      |
      initialization      | UTF-8 string.        |\n   +----------------------+---------------------+----------------------+\n
      \  | type                 | object class (type) | \"CKA_CLASS\" object   |\n
      \  |                      |                     | attribute.           |\n   +----------------------+---------------------+----------------------+\n
      \         Table 1: Mapping between URI Path Component Attributes\n                     and
      PKCS #11 Specification Names\n   The following table presents mapping between
      the \"type\" attribute\n   values and corresponding PKCS #11 object classes.\n
      \               +-----------------+-----------------------+\n                |
      Attribute value | PKCS #11 object class |\n                +-----------------+-----------------------+\n
      \               | cert            | CKO_CERTIFICATE       |\n                |
      data            | CKO_DATA              |\n                | private         |
      CKO_PRIVATE_KEY       |\n                | public          | CKO_PUBLIC_KEY
      \       |\n                | secret-key      | CKO_SECRET_KEY        |\n                +-----------------+-----------------------+\n
      \              Table 2: Mapping between the \"type\" Attribute\n                        and
      PKCS #11 Object Classes\n   The query component attribute \"pin-source\" specifies
      where the\n   application or library should find the normal user's token PIN,
      the\n   \"pin-value\" attribute provides the normal user's PIN value directly,\n
      \  if needed, and the \"module-name\" and \"module-path\" attributes modify\n
      \  default settings for accessing PKCS #11 providers.  For the\n   definition
      of a \"normal user\", see [PKCS11].\n   The ABNF rules above are a best-effort
      definition, and this paragraph\n   specifies additional constraints.  A PKCS
      #11 URI MUST NOT contain\n   duplicate attributes of the same name in the URI
      path component.  It\n   means that each attribute may be present at most once
      in the PKCS #11\n   URI path component.  Aside from the query attributes defined
      in this\n   document, duplicate (vendor) attributes MAY be present in the URI\n
      \  query component and it is up to the URI consumer to decide on how to\n   deal
      with such duplicates.\n   As stated earlier in this section, the value of the
      \"id\" attribute\n   can contain non-textual data.  This is because the corresponding
      PKCS\n   #11 \"CKA_ID\" object attribute can contain arbitrary binary data.\n
      \  Therefore, the whole value of the \"id\" attribute SHOULD be percent-\n   encoded.\n
      \  The \"library-version\" attribute represents the major and minor\n   version
      number of the library and its format is \"M.N\".  Both numbers\n   are one byte
      in size; see the \"libraryVersion\" member of the CK_INFO\n   structure in [PKCS11]
      for more information.  Value \"M\" for the\n   attribute MUST be interpreted
      as \"M\" for the major and \"0\" for the\n   minor version of the library.  If
      the attribute is present, the major\n   version number is REQUIRED.  Both \"M\"
      and \"N\" MUST be decimal\n   numbers.\n   Slot ID is a Cryptoki-assigned number
      that is not guaranteed to be\n   stable across PKCS #11 module initializations.
      \ However, there are\n   certain libraries and modules that provide stable slot
      identifiers.\n   For these cases, when the slot description and manufacturer
      ID is not\n   sufficient to uniquely identify a specific reader, the slot ID
      MAY be\n   used to increase the precision of the token identification.  In other\n
      \  scenarios, using the slot IDs is likely to cause usability issues.\n   An
      empty PKCS #11 URI path component attribute that does allow for an\n   empty
      value matches a corresponding structure member or an object\n   attribute with
      an empty value.  Note that according to the PKCS #11\n   specification [PKCS11],
      empty character values in a PKCS #11 API\n   producer must be padded with spaces
      and should not be NULL\n   terminated.\n"
    title: '2.3.  PKCS #11 URI Scheme Syntax'
  - contents:
    - "2.4.  PKCS #11 URI Scheme Query Attribute Semantics\n   An application can
      always ask for a PIN by any means it decides to.\n   What is more, in order
      not to limit PKCS #11 URI portability, the\n   \"pin-source\" attribute value
      format and interpretation is left to be\n   implementation specific.  However,
      the following rules SHOULD be\n   followed in descending order for the value
      of the \"pin-source\"\n   attribute:\n   o  If the value represents a URI, it
      SHOULD be treated as an object\n      containing the PIN.  Such a URI may be
      \"file:\", \"https:\", another\n      PKCS #11 URI, or something else.\n   o
      \ If the value contains \"|<absolute-command-path>\", the\n      implementation
      SHOULD read the PIN from the output of an\n      application specified with
      absolute path \"<absolute-command-\n      path>\".  Note that character \"|\"
      representing a pipe does not have\n      to be percent-encoded in the query
      component of a PKCS #11 URI.\n   o  Interpret the value as needed in an implementation-dependent
      way.\n   If a URI contains both \"pin-source\" and \"pin-value\" query attributes,\n
      \  the URI SHOULD be refused as invalid.\n   Use of the \"pin-value\" attribute
      may have security-related\n   consequences.  Section 6 should be consulted before
      this attribute is\n   ever used.  Standard percent-encoding rules SHOULD be
      followed for\n   the attribute value.\n   A consumer of PKCS #11 URIs MAY accept
      query component attributes\n   \"module-name\" and \"module-path\" in order
      to modify default settings\n   for accessing a PKCS #11 provider or providers.\n
      \  Processing the URI query module attributes SHOULD follow these rules:\n   o
      \ The attribute \"module-name\" SHOULD contain a case-insensitive PKCS\n      #11
      module name (not path nor filename) without system-specific\n      affixes;
      said affix could be a \".so\" or \".DLL\" suffix, or a \"lib\"\n      prefix,
      for example.  Not using system-specific affixes is\n      expected to increase
      portability of PKCS #11 URIs among different\n      systems.  A URI consumer
      searching for PKCS #11 modules SHOULD use\n      a system or application-specific
      locations to find modules based\n      on the name provided in the attribute.\n
      \  o  The attribute \"module-path\" SHOULD contain a system-specific\n      absolute
      path to the PKCS #11 module or a system-specific absolute\n      path to the
      directory of where PKCS #11 modules are located.  For\n      security reasons,
      a URI with a relative path in this attribute\n      SHOULD be rejected.\n   o
      \ The URI consumer MAY refuse to accept either of the attributes, or\n      both.
      \ If use of the attribute present in the URI string is not\n      accepted,
      a warning message SHOULD be presented to the provider of\n      the URI and
      system-specific module locations SHOULD be used.\n   o  If either of the module
      attributes is present, only those modules\n      found matching these query
      attributes SHOULD be used to search for\n      an entity represented by the
      URI.\n   o  The use of the module attributes does not suppress matching of any\n
      \     other URI path component attributes present in a URI.\n   o  The semantics
      of using both attributes in the same URI string is\n      implementation specific
      but such use SHOULD be avoided.  Attribute\n      \"module-name\" is preferred
      to \"module-path\" due to its system-\n      independent nature, but the latter
      may be more suitable for\n      development and debugging.\n   o  A URI MUST
      NOT contain multiple module attributes of the same\n      name.\n   Use of the
      module attributes may have security-related consequences.\n   Section 6 should
      be consulted before these attributes are ever used.\n   A word \"module\" was
      chosen over a word \"library\" in these query\n   attribute names to avoid confusion
      with semantically different\n   library attributes used in the URI path component.\n"
    title: '2.4.  PKCS #11 URI Scheme Query Attribute Semantics'
  - contents:
    - "2.5.  PKCS #11 URI Matching Guidelines\n   A PKCS #11 URI can identify PKCS
      #11 storage objects, tokens, slots,\n   or Cryptoki libraries.  Note that since
      a URI may identify four\n   different types of entities, the context within
      which the URI is used\n   may be needed to determine the type.  For example,
      a URI with only\n   library attributes may either represent all objects in all
      tokens in\n   all Cryptoki libraries identified by the URI, all tokens in those\n
      \  libraries, or just the libraries.\n   The following guidelines can help a
      PKCS #11 URI consumer (e.g., an\n   application accepting PKCS #11 URIs) to
      match the URI with the\n   desired resource.\n   o  The consumer needs to know
      whether the URI is to identify PKCS #11\n      storage object(s), token(s),
      slot(s), or Cryptoki producer(s).\n   o  If the consumer is willing to accept
      query component module\n      attributes, only those PKCS #11 providers matching
      these\n      attributes SHOULD be worked with.  See Section 2.4 for more\n      information.\n
      \  o  An unrecognized attribute in the URI path component, including a\n      vendor-specific
      attribute, SHOULD result in an empty set of\n      matched resources.  The consumer
      can consider whether an error\n      message presented to the user is appropriate
      in such a case.\n   o  An unrecognized attribute in the URI query SHOULD be
      ignored.  The\n      consumer can consider whether a warning message presented
      to the\n      user is appropriate in such a case.\n   o  An attribute not present
      in the URI path component but known to a\n      consumer matches everything.
      \ Each additional attribute present in\n      the URI path component further
      restricts the selection.\n   o  A logical extension of the above is that a URI
      with an empty path\n      component matches everything.  For example, if used
      to identify\n      storage objects, it matches all accessible objects in all
      tokens\n      provided by all relevant PKCS #11 API producers.\n   o  Note that
      use of PIN attributes may change the set of storage\n      objects visible to
      the consumer.\n   o  In addition to query component attributes defined in this\n
      \     document, vendor-specific query attributes may contain further\n      information
      about how to perform the selection or other related\n      information.\n   As
      noted in Section 5, the PKCS #11 specification is not clear about\n   how to
      normalize UTF-8-encoded Unicode characters [RFC3629].  For\n   that reason,
      it is RECOMMENDED not to use characters outside the US-\n   ASCII character
      set for labels and names.  However, those who\n   discover a need to use such
      characters should be cautious,\n   conservative, and expend extra effort to
      be sure they know what they\n   are doing and that failure to do so may create
      both operational and\n   security risks.  It means that when matching UTF-8
      string-based\n   attributes (see Table 1) with characters outside the US-ASCII\n
      \  repertoire, normalizing all UTF-8 strings before string comparison\n   may
      be the only safe approach.  For example, for objects (keys), it\n   means that
      PKCS #11 attribute search template would only contain\n   attributes that are
      not UTF-8 strings and another pass through\n   returned objects is then needed
      for UTF-8 string comparison after the\n   normalization is applied.\n"
    title: '2.5.  PKCS #11 URI Matching Guidelines'
  - contents:
    - "2.6.  PKCS #11 URI Comparison\n   Comparison of two URIs is a way of determining
      whether the URIs are\n   equivalent without comparing the actual resource to
      which the URIs\n   point.  The comparison of URIs aims to minimize false negatives
      while\n   strictly avoiding false positives.  When working with UTF-8 strings\n
      \  with characters outside the US-ASCII character sets, see important\n   caveats
      in Sections 2.5 and 5.\n   Two PKCS #11 URIs are said to be equal if URIs as
      character strings\n   are identical as specified in Section 6.2.1 of [RFC3986],
      or if both\n   of the following rules are fulfilled:\n   o  The set of attributes
      present in the URI is equal.  Note that the\n      ordering of attributes in
      the URI string is not significant for\n      the mechanism of comparison.\n
      \  o  The values of respective attributes are equal based on rules\n      specified
      below\n   The rules for comparing values of respective attributes are:\n   o
      \ The values of path component attributes \"library-description\",\n      \"library-manufacturer\",
      \"manufacturer\", \"model\", \"object\",\n      \"serial\", \"slot-description\",
      \"slot-manufacturer\", \"token\",\n      \"type\", and the query component attribute
      \"module-name\" MUST be\n      compared using a simple string comparison, as
      specified in\n      Section 6.2.1 of [RFC3986], after the case and the percent-\n
      \     encoding normalization were both applied as specified in\n      Section
      6.2.2 of [RFC3986].\n   o  The value of the attribute \"id\" MUST be compared
      using the simple\n      string comparison after all bytes are percent-encoded
      using\n      uppercase letters for digits A-F.\n   o  The value of the attribute
      \"library-version\" MUST be processed as\n      a specific scheme-based normalization
      permitted by Section 6.2.3\n      of [RFC3986].  The value MUST be split into
      a major and minor\n      version with character '.' (dot) serving as a delimiter.
      \ A\n      library-version \"M\" MUST be treated as \"M\" for the major version\n
      \     and \"0\" for the minor version.  Then, resulting minor and major\n      version
      numbers MUST be separately compared numerically.\n   o  The value of the attribute
      \"slot-id\" MUST be processed as a\n      specific scheme-based normalization
      permitted by Section 6.2.3 of\n      [RFC3986] and compared numerically.\n   o
      \ The value of \"pin-source\", if containing a \"file:\" URI or\n      \"|<absolute-command-path>\",
      MUST be compared using the simple\n      string comparison after the full syntax-based
      normalization, as\n      specified in Section 6.2.2 of [RFC3986], is applied.
      \ If the value\n      of the \"pin-source\" attribute is believed to be overloaded,
      the\n      case and percent-encoding normalization SHOULD be applied before\n
      \     the values are compared, but the exact mechanism of comparison is\n      left
      to the application.\n   o  The value of the attribute \"module-path\" MUST be
      compared using\n      the simple string comparison after the full syntax-based\n
      \     normalization, as specified in Section 6.2.2 of [RFC3986], is\n      applied.\n
      \  o  When comparing vendor-specific attributes, the case and percent-\n      encoding
      normalization, as specified in Section 6.2.2 of\n      [RFC3986], SHOULD be
      applied before the values are compared, but\n      the exact mechanism of such
      a comparison is left to the\n      application.\n"
    title: '2.6.  PKCS #11 URI Comparison'
  - contents:
    - "2.7.  Generating PKCS #11 URIs\n   When generating URIs for PKCS #11 resources,
      the exact set of\n   attributes used in a URI is inherently context specific.
      \ A PKCS #11\n   URI template [RFC6570] support MAY be provided by a URI-generating\n
      \  application to list URIs to access the same resource(s) again if the\n   template
      captured the necessary context.\n"
    title: '2.7.  Generating PKCS #11 URIs'
  title: '2.  PKCS #11 URI Scheme Definition'
- contents:
  - "3.  Examples of PKCS #11 URIs\n   This section contains some examples of how
    PKCS #11 token objects,\n   tokens, slots, and libraries can be identified using
    the PKCS #11 URI\n   scheme.  Note that in some of the following examples, line
    breaks and\n   spaces were inserted for better readability.  As specified in\n
    \  Appendix C of [RFC3986], whitespace SHOULD be ignored when extracting\n   the
    URI.  Also note that all spaces that are part of the URIs are\n   percent-encoded,
    as specified in Appendix A of [RFC3986].\n   An empty PKCS #11 URI might be useful
    to PKCS #11 consumers.  See\n   Section 2.5 for more information on semantics
    of such a URI.\n     pkcs11:\n   One of the simplest and most useful forms might
    be a PKCS #11 URI\n   that specifies only an object label and its type.  The default
    token\n   is used so the URI does not specify it.  Note that when specifying\n
    \  public objects, a token PIN may not be required.\n     pkcs11:object=my-pubkey;type=public\n
    \  When a private key is specified, either the \"pin-source\" attribute,\n   \"pin-value\",
    or an application-specific method would be usually used.\n   Note that '/' is
    not percent-encoded in the \"pin-source\" attribute\n   value since this attribute
    is part of the query component, not the\n   path component, and thus is separated
    by '?' from the rest of the\n   URI.\n     pkcs11:object=my-key;type=private?pin-source=file:/etc/token\n
    \  The following example identifies a certificate in the software token.\n   Note
    the use of an empty value for the attribute \"serial\", which\n   matches only
    empty \"serialNumber\" member of the \"CK_TOKEN_INFO\"\n   structure.  Also note
    that the \"id\" attribute value is entirely\n   percent-encoded, as recommended.
    \ While ',' is in the reserved set,\n   it does not have to be percent-encoded
    since it does not conflict\n   with any sub-delimiters used.  The '#' character,
    as in \"The Software\n   PKCS #11 Softtoken\", MUST be percent-encoded.\n     pkcs11:token=The%20Software%20PKCS%2311%20Softtoken;\n
    \           manufacturer=Snake%20Oil,%20Inc.;\n            model=1.0;\n            object=my-certificate;\n
    \           type=cert;\n            id=%69%95%3E%5C%F4%BD%EC%91;\n            serial=\n
    \           ?pin-source=file:/etc/token_pin\n   The next example covers how to
    use the \"module-name\" query attribute.\n   Considering that the module is located
    in the /usr/lib/\n   libmypkcs11.so.1 file, the attribute value is \"mypkcs11\",
    meaning\n   only the module name without the full path and without the platform-\n
    \  specific \"lib\" prefix and \".so.1\" suffix.\n     pkcs11:object=my-sign-key;\n
    \           type=private\n            ?module-name=mypkcs11\n   The following
    example covers how to use the \"module-path\" query\n   attribute.  The attribute
    may be useful if a user needs to provide\n   the key via a PKCS #11 module stored
    on a removable media, for\n   example.  Getting the PIN to access the private
    key here is left to\n   be application specific.\n     pkcs11:object=my-sign-key;\n
    \           type=private\n            ?module-path=/mnt/libmypkcs11.so.1\n   In
    the context of where a token is expected, the token can be\n   identified without
    specifying any PKCS #11 objects.  A PIN might\n   still be needed in the context
    of listing all objects in the token,\n   for example.  Section 6 should be consulted
    before the \"pin-value\"\n   attribute is ever used.\n     pkcs11:token=Software%20PKCS%2311%20softtoken;\n
    \           manufacturer=Snake%20Oil,%20Inc.\n            ?pin-value=the-pin\n
    \  In the context where a slot is expected, the slot can be identified\n   without
    specifying any PKCS #11 objects in any token that may be\n   inserted in the slot.\n
    \    pkcs11:slot-description=Sun%20Metaslot\n   The Cryptoki library alone can
    be also identified without specifying\n   a PKCS #11 token or object.\n     pkcs11:library-manufacturer=Snake%20Oil,%20Inc.;\n
    \           library-description=Soft%20Token%20Library;\n            library-version=1.23\n
    \  The following example shows an attribute value with a semicolon.  In\n   such
    a case, it MUST be percent-encoded.  The token attribute value\n   MUST be read
    as \"My token; created by Joe\".  Lowercase letters MAY be\n   used in percent-encoding,
    as shown below in the \"id\" attribute value,\n   but note that Sections 2.1 and
    6.2.2.1 of [RFC3986] state that all\n   percent-encoded characters SHOULD use
    the uppercase hexadecimal\n   digits.  More specifically, if the URI string were
    to be compared,\n   the algorithm defined in Section 2.6 explicitly requires percent-\n
    \  encoding to use the uppercase digits A-F in the \"id\" attribute\n   values.
    \ And as explained in Section 2.3, library version \"3\" MUST be\n   interpreted
    as \"3\" for the major and \"0\" for the minor version of the\n   library.\n     pkcs11:token=My%20token%25%20created%20by%20Joe;\n
    \           library-version=3;\n            id=%01%02%03%Ba%dd%Ca%fe%04%05%06\n
    \  If there is any need to include a literal \"%;\" substring, for\n   example,
    both characters MUST be escaped.  The token value MUST be\n   read as \"A name
    with a substring %;\".\n     pkcs11:token=A%20name%20with%20a%20substring%20%25%3B;\n
    \           object=my-certificate;\n            type=cert\n   The next example
    includes a small A with acute in the token name.  It\n   MUST be encoded in octets
    according to the UTF-8 character encoding\n   and then percent-encoded.  Given
    that a small A with acute is U+225\n   Unicode code point, the UTF-8 encoding
    is 195 161 in decimal, and\n   that is \"%C3%A1\" in percent-encoding.  See also
    Section 5 on the use\n   of characters outside the US-ASCII character set for
    labels.\n     pkcs11:token=Name%20with%20a%20small%20A%20with%20acute:%20%C3%A1;\n
    \           object=my-certificate;\n            type=cert\n   Both the path and
    query components MAY contain vendor-specific\n   attributes.  Attributes in the
    query component MUST be delimited by\n   '&'.\n     pkcs11:token=my-token;\n            object=my-certificate;\n
    \           type=cert;\n            vendor-aaa=value-a\n            ?pin-source=file:/etc/token_pin\n
    \           &vendor-bbb=value-b\n"
  title: '3.  Examples of PKCS #11 URIs'
- contents:
  - '4.  IANA Considerations

    '
  - contents:
    - "4.1.  URI Scheme Registration\n   This document moves the \"pkcs11\" URI scheme
      from the \"Provisional URI\n   Schemes\" registry to the \"Permanent URI Schemes\"
      registry.  The\n   registration request complies with [RFC4395].\n      URI
      scheme name: pkcs11\n      URI scheme status: permanent\n      URI scheme syntax:
      Defined in Section 2.3 of [RFC7512].\n      URI scheme semantics: Defined in
      Section 1 of [RFC7512].\n      Encoding considerations: See Sections 2.3 and
      5 of [RFC7512].\n      Applications/protocols that use this URI scheme name:
      For general\n      information, see Section 1 of [RFC7512].  A list of known\n
      \     consumers of the PKCS #11 URI include GnuTLS, Gnome, p11-kit,\n      Oracle
      Solaris 11 and higher, OpenSC, OpenConnect, and FreeIPA.\n      Interoperability
      considerations: See Section 5 of [RFC7512].\n      Security considerations:
      See Section 6 of [RFC7512].\n      Contact: Jan Pechanec <Jan.Pechanec@Oracle.com>,
      Darren Moffat\n      <Darren.Moffat@Oracle.com>\n      Author/Change Controller:
      IESG <iesg@ietf.org>\n      References: [RFC7512]\n"
    title: 4.1.  URI Scheme Registration
  title: 4.  IANA Considerations
- contents:
  - "5.  Internationalization Considerations\n   The PKCS #11 specification does not
    specify a canonical form for\n   strings of characters of the CK_UTF8CHAR type.
    \ This presents the\n   usual false negative and false positive (aliasing) concerns
    that\n   arise when dealing with unnormalized strings.  Because all PKCS #11\n
    \  items are local and local security is assumed, these concerns are\n   mainly
    about usability and interoperability.\n   In order to improve the user experience,
    it is RECOMMENDED that\n   applications that create PKCS #11 objects or label
    tokens not use\n   characters outside the US-ASCII character set for the labels.
    \ If\n   that is not possible, labels SHOULD be normalized to Normalization\n
    \  Form C (NFC) [UAX15].  For the same reason, PKCS #11 libraries, slots\n   (token
    readers), and tokens SHOULD use US-ASCII characters only for\n   their names,
    and if that is not possible, they SHOULD normalize their\n   names to NFC.  When
    listing PKCS #11 libraries, slots, tokens, and/or\n   objects, an application
    SHOULD normalize their names to NFC if\n   characters outside of the US-ASCII
    character set are expected.  When\n   matching PKCS #11 URIs to libraries, slots,
    tokens, and/or objects,\n   applications MAY convert names to a chosen normalization
    form before\n   the string comparison for matching, as those might predate these\n
    \  recommendations.  See also Section 2.5.\n"
  title: 5.  Internationalization Considerations
- contents:
  - "6.  Security Considerations\n   There are general security considerations for
    URI schemes discussed\n   in Section 7 of [RFC3986].\n   From those security considerations,
    Section 7.1 of [RFC3986] applies\n   since there is no guarantee that the same
    PKCS #11 URI will always\n   identify the same object, token, slot, or a library
    in the future.\n   Section 7.2 of [RFC3986] applies since by accepting query component\n
    \  attributes \"module-name\" or \"module-path\", the consumer potentially\n   allows
    loading of arbitrary code into a process.\n   Section 7.5 of [RFC3986] applies
    since a PKCS #11 URI may be used in\n   world-readable command-line arguments
    to run applications, stored in\n   public configuration files, or otherwise used
    in clear text.  For\n   that reason, the \"pin-value\" attribute should only be
    used if the URI\n   string itself is protected with the same level of security
    as the\n   token PIN itself otherwise is.\n   The PKCS #11 specification does
    not provide means to authenticate\n   devices to users; it only authenticates
    users to tokens.  Instead,\n   local and physical security are demanded: the user
    must be in\n   possession of their tokens, and the system into whose slots the\n
    \  users' tokens are inserted must be secure.  As a result, the usual\n   security
    considerations regarding normalization do not arise.  For\n   the same reason,
    confusable script issues also do not arise.\n   Nonetheless, if use of characters
    outside the US-ASCII character set\n   is required, it is best to normalize to
    NFC all strings appearing in\n   PKCS #11 API elements.  See also Section 5.\n"
  title: 6.  Security Considerations
- contents:
  - '7.  References

    '
  - contents:
    - "7.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March
      1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n   [RFC3629]
      \ Yergeau, F., \"UTF-8, a transformation format of ISO\n              10646\",
      STD 63, RFC 3629, November 2003,\n              <http://www.rfc-editor.org/info/rfc3629>.\n
      \  [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n              Resource
      Identifier (URI): Generic Syntax\", STD 66, RFC\n              3986, January
      2005,\n              <http://www.rfc-editor.org/info/rfc3986>.\n   [RFC5234]
      \ Crocker, D., Ed. and P. Overell, \"Augmented BNF for Syntax\n              Specifications:
      ABNF\", STD 68, RFC 5234, January 2008,\n              <http://www.rfc-editor.org/info/rfc5234>.\n"
    title: 7.1.  Normative References
  - contents:
    - "7.2.  Informative References\n   [BCP178]   Saint-Andre, P., Crocker, D., and
      M. Nottingham,\n              \"Deprecating the \"X-\" Prefix and Similar Constructs
      in\n              Application Protocols\", RFC 6648, BCP 178, June 2012,\n              <http://www.rfc-editor.org/info/bcp178>.\n
      \  [PKCS11]   RSA Laboratories, \"PKCS #11 v2.20: Cryptographic Token\n              Interface
      Standard\", Public Key Cryptography Standards\n              PKCS#11-v2.20,
      June 2004.\n   [RFC4395]  Hansen, T., Hardie, T., and L. Masinter, \"Guidelines
      and\n              Registration Procedures for New URI Schemes\", BCP 35, RFC\n
      \             4395, February 2006,\n              <http://www.rfc-editor.org/info/rfc4395>.\n
      \  [RFC6570]  Gregorio, J., Fielding, R., Hadley, M., Nottingham, M.,\n              and
      D. Orchard, \"URI Template\", RFC 6570, March 2012,\n              <http://www.rfc-editor.org/info/rfc6570>.\n
      \  [UAX15]    Davis, M., Ed. and K. Whistler, Ed., \"Unicode Standard\n              Annex
      #15: Unicode Normalization Forms\", Version Unicode\n              7.0.0, June
      2014, <http://unicode.org/reports/tr15/>.\n"
    title: 7.2.  Informative References
  title: 7.  References
- contents:
  - "Contributors\n   Stef Walter, Nikos Mavrogiannopoulos, Nico Williams, Dan Winship,\n
    \  Jaroslav Imrich, and Mark Phalan contributed to the development of\n   this
    document.  Shawn Emery shepherded the document.\n"
  title: Contributors
- contents:
  - "Authors' Addresses\n   Jan Pechanec\n   Oracle Corporation\n   4180 Network Circle\n
    \  Santa Clara, CA 95054\n   United States\n   EMail: Jan.Pechanec@Oracle.com\n
    \  URI:   http://www.oracle.com\n   Darren J. Moffat\n   Oracle Corporation\n
    \  Oracle Parkway\n   Thames Valley Park\n   Reading  RG6 1RA\n   United Kingdom\n
    \  EMail: Darren.Moffat@Oracle.com\n   URI:   http://www.oracle.com\n"
  title: Authors' Addresses
