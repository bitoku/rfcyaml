- contents:
  - '          Middlebox Communication (MIDCOM) Protocol Semantics

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Abstract\n   This document specifies semantics for a Middlebox Communication\n
    \  (MIDCOM) protocol to be used by MIDCOM agents for interacting with\n   middleboxes
    such as firewalls and Network Address Translators (NATs).\n   The semantics discussion
    does not include any specification of a\n   concrete syntax or a transport protocol.
    \ However, a concrete\n   protocol is expected to implement the specified semantics
    or, more\n   likely, a superset of it.  The MIDCOM protocol semantics is derived\n
    \  from the MIDCOM requirements, from the MIDCOM framework, and from\n   working
    group decisions.  This document obsoletes RFC 3989.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n
    \     1.1. Terminology ................................................5\n      1.2.
    Transaction Definition Template ............................7\n   2. Semantics
    Specification .........................................8\n      2.1. General Protocol
    Design ....................................8\n           2.1.1. Protocol Transactions
    ...............................8\n           2.1.2. Message Types .......................................9\n
    \          2.1.3. Session, Policy Rule, and Policy Rule Group ........10\n           2.1.4.
    Atomicity ..........................................11\n           2.1.5. Access
    Control .....................................11\n           2.1.6. Middlebox Capabilities
    .............................12\n           2.1.7. Agent and Middlebox Identifiers
    ....................12\n           2.1.8. Conformance ........................................13\n
    \     2.2. Session Control Transactions ..............................13\n           2.2.1.
    Session Establishment (SE) .........................14\n           2.2.2. Session
    Termination (ST) ...........................16\n           2.2.3. Asynchronous
    Session Termination (AST) .............16\n           2.2.4. Session Termination
    by Interruption of Connection ..17\n           2.2.5. Session State Machine ..............................17\n
    \     2.3. Policy Rule Transactions ..................................18\n           2.3.1.
    Configuration Transactions .........................19\n           2.3.2. Establishing
    Policy Rules ..........................19\n           2.3.3. Maintaining Policy
    Rules and Policy Rule Groups ....20\n           2.3.4. Policy Events and Asynchronous
    Notifications .......21\n           2.3.5. Address Tuples .....................................21\n
    \          2.3.6. Address Parameter Constraints ......................23\n           2.3.7.
    Interface-Specific Policy Rules ....................25\n           2.3.8. Policy
    Reserve Rule (PRR) ..........................25\n           2.3.9. Policy Enable
    Rule (PER) ...........................30\n           2.3.10. Policy Rule Lifetime
    Change (RLC) .................36\n           2.3.11. Policy Rule List (PRL) ............................38\n
    \          2.3.12. Policy Rule Status (PRS) ..........................39\n           2.3.13.
    Asynchronous Policy Rule Event (ARE) ..............41\n           2.3.14. Policy
    Rule State Machine .........................42\n      2.4. Policy Rule Group Transactions
    ............................43\n           2.4.1. Overview ...........................................43\n
    \          2.4.2. Group Lifetime Change (GLC) ........................44\n           2.4.3.
    Group List (GL) ....................................46\n           2.4.4. Group
    Status (GS) ..................................47\n   3. Conformance Statements
    .........................................48\n      3.1. General Implementation
    Conformance ........................49\n      3.2. Middlebox Conformance .....................................50\n
    \     3.3. Agent Conformance .........................................50\n   4.
    Transaction Usage Examples .....................................50\n      4.1.
    Exploring Policy Rules and Policy Rule Groups .............50\n      4.2. Enabling
    a SIP-Signaled Call ..............................54\n   5. Compliance with MIDCOM
    Requirements ............................59\n      5.1. Protocol Machinery Requirements
    ...........................59\n           5.1.1. Authorized Association .............................59\n
    \          5.1.2. Agent Connects to Multiple Middleboxes .............60\n           5.1.3.
    Multiple Agents Connect to Same Middlebox ..........60\n           5.1.4. Deterministic
    Behavior .............................60\n           5.1.5. Known and Stable State
    .............................60\n           5.1.6. Status Report ......................................61\n
    \          5.1.7. Unsolicited Messages (Asynchronous Notifications) ..61\n           5.1.8.
    Mutual Authentication ..............................61\n           5.1.9. Session
    Termination by Any Party ...................61\n           5.1.10. Request Result
    ....................................62\n           5.1.11. Version Interworking
    ..............................62\n           5.1.12. Deterministic Handling of
    Overlapping Rules .......62\n      5.2. Protocol Semantics Requirements ...........................62\n
    \          5.2.1. Extensible Syntax and Semantics ....................62\n           5.2.2.
    Policy Rules for Different Types of Middleboxes ....63\n           5.2.3. Ruleset
    Groups .....................................63\n           5.2.4. Policy Rule
    Lifetime Extension .....................63\n           5.2.5. Robust Failure Modes
    ...............................63\n           5.2.6. Failure Reasons ....................................63\n
    \          5.2.7. Multiple Agents Manipulating Same Policy Rule ......63\n           5.2.8.
    Carrying Filtering Rules ...........................64\n           5.2.9. Parity
    of Port Numbers .............................64\n           5.2.10. Consecutive
    Range of Port Numbers .................64\n           5.2.11. Contradicting Overlapping
    Policy Rules ............64\n      5.3. Security Requirements .....................................64\n
    \          5.3.1. Authentication, Confidentiality, Integrity .........64\n           5.3.2.
    Optional Confidentiality of Control Messages .......64\n           5.3.3. Operation
    across Untrusted Domains .................65\n           5.3.4. Mitigate Replay
    Attacks ............................65\n   6. Security Considerations ........................................65\n
    \  7. IAB Considerations on UNSAF ....................................66\n   8.
    Acknowledgements ...............................................66\n   9. References
    .....................................................67\n      9.1. Normative
    References ......................................67\n      9.2. Informative References
    ....................................67\n   Appendix A. Changes from RFC 3989 .................................69\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The MIDCOM working group has defined a framework [MDC-FRM]
    and a list\n   of requirements [MDC-REQ] for middlebox communication.  The next
    step\n   toward a MIDCOM protocol is the specification of protocol semantics\n
    \  that is constrained, but not completely implied, by the documents\n   mentioned
    above.\n   This memo suggests a semantics for the MIDCOM protocol.  It is fully\n
    \  compliant with the requirements listed in [MDC-REQ] and with the\n   working
    group's consensus on semantic issues.  This document\n   obsoletes RFC 3989 [MDC-SEM].\n
    \  In conformance with the working group charter, the semantics\n   description
    is targeted at packet filters and Network Address\n   Translators (NATs), and
    it supports applications that require dynamic\n   configuration of these middleboxes.\n
    \  The semantics is defined in terms of transactions.  Two basic types\n   of
    transactions are used: request transactions and asynchronous\n   transactions.
    \ Further, we distinguish two concrete types of request\n   transactions: configuration
    transactions and monitoring transactions.\n   For each transaction, the semantics
    is specified by describing (1)\n   the parameters of the transaction; (2) the
    processing of request\n   messages at the middlebox; (3) the state transitions
    at the middlebox\n   caused by the request transactions or indicated by the asynchronous\n
    \  transactions, respectively; and (4) the reply and notification\n   messages
    sent from the middlebox to the agent in order to inform the\n   agent about the
    state change.\n   The semantics can be implemented by any protocol that supports
    these\n   two transaction types and that is sufficiently flexible concerning\n
    \  transaction parameters.  Different implementations for different\n   protocols
    might need to extend the semantics described below by\n   adding further transactions
    and/or adding further parameters to\n   transactions and/or splitting single transactions
    into a set of\n   transactions.  Regardless of such extensions, the semantics
    below\n   provides a minimum necessary subset of what must be implemented.\n   The
    remainder of this document is structured as follows.  Section 2\n   describes
    the protocol semantics.  It is structured in four\n   subsections:\n      - General
    Protocol Design (section 2.1)\n      - Session Control (section 2.2)\n      -
    Policy Rules (section 2.3)\n      - Policy Rule Groups (section 2.4)\n   Section
    3 contains conformance statements for MIDCOM protocol\n   definitions and MIDCOM
    protocol implementations with respect to the\n   semantics defined in section
    2.  Section 4 gives two elaborated usage\n   examples.  Finally, section 5 explains
    how the semantics meets the\n   MIDCOM requirements.\n"
  - contents:
    - "1.1.  Terminology\n   The terminology in this memo follows the definitions
      given in the\n   framework [MDC-FRM] and requirements [MDC-REQ] document.\n
      \  In addition, the following terms are used:\n   request transaction        A
      request transaction consists of a\n                              request message
      transfer from the agent to\n                              the middlebox, processing
      of the message\n                              at the middlebox, a reply message
      transfer\n                              from the middlebox to the agent, and
      the\n                              optional transfer of notification messages\n
      \                             from the middlebox to agents other than\n                              the
      one requesting the transaction.  A\n                              request transaction
      might cause a state\n                              transition at the middlebox.\n
      \  configuration transaction  A configuration transaction is a request\n                              transaction
      containing a request for state\n                              change in the
      middlebox.  If accepted, it\n                              causes a state change
      at the middlebox.\n   monitoring transaction     A monitoring transaction is
      a request\n                              transaction containing a request for
      state\n                              information from the middlebox.  It does\n
      \                             not cause a state transition at the\n                              middlebox.\n
      \  asynchronous transaction   An asynchronous transaction is not\n                              triggered
      by an agent.  It may occur\n                              without any agent
      participating in a\n                              session with the middlebox.
      \ Potentially,\n                              an asynchronous transaction includes
      the\n                              transfer of notification messages from the\n
      \                             middlebox to agents that participate in an\n                              open
      session.  A notification message is\n                              sent to each
      agent that needs to be\n                              notified about the asynchronous
      event.\n                              The message indicates the state transition\n
      \                             at the middlebox.\n   agent-unique               An
      agent-unique value is unique in the\n                              context of
      the agent.  This context\n                              includes all MIDCOM
      sessions the agent\n                              participates in.  An agent-unique
      value is\n                              assigned by the agent.\n   middlebox-unique
      \          A middlebox-unique value is unique in the\n                              context
      of the middlebox.  This context\n                              includes all
      MIDCOM sessions the middlebox\n                              participates in.
      \ A middlebox-unique value\n                              is assigned by the
      middlebox.\n   policy rule                In general, a policy rule is \"a basic\n
      \                             building block of a policy-based system.\n                              It
      is the binding of a set of actions to a\n                              set of
      conditions -- where the conditions\n                              are evaluated
      to determine whether the\n                              actions are performed\"
      \ [RFC3198].  In the\n                              MIDCOM context, the condition
      is a\n                              specification of a set of packets to which\n
      \                             rules are applied.  The set of actions\n                              always
      contains just a single element per\n                              rule, either
      action \"reserve\" or action\n                              \"enable\".\n   policy
      reserve rule        A policy rule containing a reserve action.\n                              The
      policy condition of this rule is\n                              always true.
      \ The action is the\n                              reservation of just an IP
      address or a\n                              combination of an IP address and
      a range\n                              of port numbers on neither side, one
      side,\n                              or both sides of the middlebox, depending\n
      \                             on the middlebox configuration.\n   policy enable
      rule         A policy rule containing an enable action.\n                              The
      policy condition consists of a\n                              descriptor of
      one or more unidirectional\n                              or bidirectional packet
      flows, and the\n                              policy action enables packets
      belonging to\n                              this flow to traverse the middlebox.
      \ The\n                              descriptor identifies the protocol, the\n
      \                             flow direction, and the source and\n                              destination
      addresses, optionally with a\n                              range of port numbers.\n
      \  NAT binding                The term NAT binding as used in this\n                              document
      does not necessarily refer to a\n                              NAT bind as defined
      in [NAT-TERM].  A NAT\n                              binding in the MIDCOM semantics
      refers to\n                              an abstraction that enables communication\n
      \                             between two endpoints through the NAT-type\n                              middlebox.
      \ An enable action may result in\n                              a NAT bind or
      a NAT session, depending on\n                              the request and its
      parameters.\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
      \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",  \"MAY\", and
      \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC
      2119 [RFC2119].\n"
    title: 1.1.  Terminology
  - contents:
    - "1.2.  Transaction Definition Template\n   In the following sections, the semantics
      of the MIDCOM protocol is\n   specified per transaction.  A transaction specification
      contains the\n   following entries.  Parameter entries, failure reason, and\n
      \  notification message type are only specified if applicable.\n   transaction-name\n
      \     A description name for this type of transaction.\n   transaction-type\n
      \     The transaction type is either 'configuration', 'monitoring', or\n      'asynchronous'.
      \ See section 1.1 for a description of transaction\n      types.\n   transaction-compliance\n
      \     This entry contains either 'mandatory' or 'optional'.  For\n      details,
      see section 2.1.8.\n   request-parameters\n      This entry lists all parameters
      necessary for this request.  A\n      description for each parameter is given.\n
      \  reply-parameters (success)\n      This entry lists all parameters sent back
      from the middlebox to\n      the agent as positive response to the prior request.
      \ A\n      description for each parameter is given.\n   failure reason\n      All
      negative replies have two parameters: a request identifier\n      identifying
      the request on which the reply is sent and a parameter\n      indicating the
      failure reason.  As these parameters are\n      compulsory, they are not listed
      in the template.  But the template\n      contains a list of potential failure
      reasons that may be indicated\n      by the second parameter.  The list is not
      exhaustive.  A concrete\n      protocol specification may extend the list.\n
      \  notification message type\n      This entry describes the notification message
      type that may be\n      used by this transaction.\n   semantics\n      This
      entry describes the actual semantics of the transaction.\n      Particularly,
      it describes the processing of the request message\n      by the middlebox,
      and middlebox state transitions caused by or\n      causing the transaction,
      respectively.\n"
    title: 1.2.  Transaction Definition Template
  title: 1.  Introduction
- contents:
  - '2.  Semantics Specification

    '
  - contents:
    - "2.1.  General Protocol Design\n   The semantics specification aims at a balance
      between proper support\n   of applications that require dynamic configuration
      of middleboxes and\n   simplicity of specification and implementation of the
      protocol.\n   Protocol interactions are structured into transactions.  The state
      of\n   middleboxes is described by state machines.  The state machines are\n
      \  defined by states and state transitions.  A single transaction may\n   cause
      or be caused by state transitions in more than one state\n   machine, but per
      state machine there is no more than one transition\n   per transaction.\n"
    - contents:
      - "2.1.1.  Protocol Transactions\n   State transitions are initiated either
        by a request message from the\n   agent to the middlebox or by some other
        event at the middlebox.  In\n   the first case, the middlebox informs the
        agent by sending a reply\n   message on the actual state transition; in the
        second, the middlebox\n   sends an unsolicited asynchronous notification message
        to each agent\n   affected by the transaction (if it participates in an open
        session\n   with the middlebox).\n   Request and reply messages contain an
        agent-unique request identifier\n   that allows the agent to determine to
        which sent request a received\n   reply corresponds.\n   An analysis of the
        requirements showed that three kinds of\n   transactions are required:\n      -
        Configuration transactions allowing the agent to request state\n        transitions
        at the middlebox.\n      - Asynchronous transactions allowing the reporting
        of state\n        changes that have not been requested by the agent.\n      -
        Monitoring transactions allowing the agent to request state\n        information
        from the middlebox.\n   Configuration transactions and asynchronous transactions
        provide the\n   basic MIDCOM protocol functionality.  They are related to
        middlebox\n   state transitions, and they concern establishment and termination
        of\n   MIDCOM sessions and of policy rules.\n   Monitoring transactions are
        not related to middlebox state\n   transitions.  They are used by agents to
        explore the number, status,\n   and properties of policy rules established
        at the middlebox.\n   As specified in detail in section 3, configuration transactions
        and\n   asynchronous transactions are mandatory except of the Group Lifetime\n
        \  Change (GLC).  They must be implemented by a compliant middlebox.\n   The
        GLC transaction and some of the monitoring transactions are\n   optional.\n"
      title: 2.1.1.  Protocol Transactions
    - contents:
      - "2.1.2.  Message Types\n   The MIDCOM protocol supports three kinds of messages:
        request\n   messages, reply messages, and notification messages.  For each
        kind,\n   different message types exist.  In this semantics document, message\n
        \  types are only defined by the list of parameters.  The order of the\n   parameters
        and their encoding are left to a concrete protocol\n   definition.  A protocol
        definition may also add further parameters to\n   a message type or combine
        several parameters into one, as long as the\n   information contained in the
        parameters defined in the semantics is\n   still present.\n   For request
        messages and positive reply messages, there exists one\n   message type per
        request transaction.  Each reply transaction defines\n   the parameter list
        of the request message and of the positive\n   (successful) reply message
        by using the transaction definition\n   template defined in section 1.2.\n
        \  In case of a failed request transaction, a negative reply message is\n
        \  sent from the middlebox to the agent.  This message is the same for\n   all
        request transactions; it contains the request identifier\n   identifying the
        request to which the reply is sent and a parameter\n   indicating the failure
        reason.\n   There are three notification message types: the Session Termination\n
        \  Notification (STN), the Policy Rule Event Notification (REN), and the\n
        \  Group Event Notification (GEN).  All of these contain a middlebox-\n   unique
        notification identifier.\n   STN   The Session Termination Notification message
        additionally\n         contains a single parameter indicating the reason for
        session\n         termination by the middlebox.\n   REN   The Policy Rule
        Event Notification message contains the\n         notification identifier,
        a policy rule identifier, and the\n         remaining policy lifetime.\n   GEN
        \  The Group Event Notification message contains the notification\n         identifier,
        a policy rule group identifier, and the remaining\n         policy rule group
        lifetime.\n"
      title: 2.1.2.  Message Types
    - contents:
      - "2.1.3.  Session, Policy Rule, and Policy Rule Group\n   All transactions
        can be further grouped into transactions concerning\n   sessions, transactions
        concerning policy rules, and transactions\n   concerning policy rule groups.
        \ Policy rule groups can be used to\n   indicate relationships between policy
        rules and to simplify\n   transactions on a set of policy rules by using a
        single transaction\n   per group instead of one per policy rule.\n   Sessions
        and policy rules at the middlebox are stateful.  Their\n   states are independent
        of each other, and their state machines (one\n   per session and one per policy
        rule) can be separated.  Policy rule\n   groups are also stateful, but the
        middlebox does not need to maintain\n   state for policy rule groups, because
        the semantics was chosen so\n   that the policy rule group state is implicitly
        defined by the state\n   of all policy rules belonging to the group (see section
        2.4).\n   The separation of session state and policy rule state simplifies
        the\n   specification of the semantics as well as a protocol implementation.\n
        \  Therefore, the semantics specification is structured accordingly and\n
        \  we use two separated state machines to illustrate the semantics.\n   Please
        note that state machines of concrete protocol designs and\n   implementations
        will probably be more complex than the state machines\n   presented here.
        \ However, the protocol state machines are expected to\n   be a superset of
        the semantics state machines in this document.\n"
      title: 2.1.3.  Session, Policy Rule, and Policy Rule Group
    - contents:
      - "2.1.4.  Atomicity\n   All request transactions are atomic with respect to
        each other.  This\n   means that processing of a request at the middlebox
        is never\n   interrupted by another request arriving or already queued.  This\n
        \  particularly applies when the middlebox concurrently receives\n   requests
        originating in different sessions.  However, asynchronous\n   transactions
        may interrupt and/or terminate processing of a request\n   at any time.\n
        \  All request transactions are atomic from the point of view of the\n   agent.
        \ The processing of a request does not start before the\n   complete request
        arrives at the middlebox.  No intermediate state is\n   stable at the middlebox,
        and no intermediate state is reported to any\n   agent.\n   The number of
        transactions specified in this document is rather\n   small.  Again, for simplicity,
        we reduced it to a minimal set that\n   still meets the requirements.  A real
        implementation of the protocol\n   might require splitting some of the transactions
        specified below into\n   two or more transactions of the respective protocol.
        \ Reasons for\n   this might include constraints of the particular protocol
        or the\n   desire for more flexibility.  In general, this should not be a\n
        \  problem.  However, it should be considered that this might change\n   atomicity
        of the affected transactions.\n"
      title: 2.1.4.  Atomicity
    - contents:
      - "2.1.5.  Access Control\n   Ownership determines access to policy rules and
        policy rule groups.\n   When a policy rule is created, a middlebox-unique
        identifier is\n   generated to identify it in further transactions.  Beyond
        the\n   identifier, each policy rule has an owner.  The owner is the\n   authenticated
        agent that established the policy rule.  The middlebox\n   uses the owner
        attribute of a policy rule to control access to it;\n   each time an authenticated
        agent requests to modify an existing\n   policy rule, the middlebox determines
        the owner of the policy rule\n   and checks whether the requesting agent is
        authorized to perform\n   transactions on the owning agent's policy rules.\n
        \  All policy rules belonging to the same policy rule group must have\n   the
        same owner.  Therefore, authenticated agents have access either\n   to all
        members of a policy rule group or to none of them.\n   The middlebox may be
        configured to allow specific authenticated\n   agents to access and modify
        policy rules with certain specific\n   owners.  Certainly, a reasonable default
        configuration would let each\n   agent access its own policy rules.  Also,
        it might be good to\n   configure an agent identity to act as administrator,
        allowing\n   modification of all policy rules owned by any agent.  However,
        the\n   configuration of authorization at the middlebox is out of scope of\n
        \  the MIDCOM semantics and protocol.\n"
      title: 2.1.5.  Access Control
    - contents:
      - "2.1.6.  Middlebox Capabilities\n   For several reasons, it is useful that
        at session establishment the\n   agent learns about particular capabilities
        of the middlebox.\n   Therefore, the session establishment procedure described
        in section\n   2.2.1 includes a transfer of capability information from the\n
        \  middlebox to the agent.  The list of covered middlebox capabilities\n   includes
        the following:\n      - Support of firewall function\n      - List of supported
        NAT functions, perhaps including\n            - address translation\n            -
        port translation\n            - protocol translation\n            - twice-NAT\n
        \     - Internal IP address wildcard support\n      - External IP address
        wildcard support\n      - Port wildcard support\n      - Supported IP version(s)
        for internal network:  IPv4, IPv6, or\n        both\n      - Supported IP
        version(s) for external network:  IPv4, IPv6, or\n        both\n      - List
        of supported optional MIDCOM protocol transactions\n      - Support for interface-specific
        policy rules\n      - Policy rule persistence: persistent or non-persistent
        (a rule is\n        persistent when the middlebox can save the rule to a non-\n
        \       volatile memory, e.g., a hard disk or flash memory)\n      - Maximum
        remaining lifetime of a policy rule or policy rule group\n      - Idle-timeout
        of policy rules in the middlebox (reserved and\n        enabled policy rules
        not used by any data traffic for the time\n        of this idle-timeout are
        deleted automatically by the middlebox;\n        for the deletion of policy
        rules by middleboxes, see section\n        2.3.13, \"Asynchronous Policy Rule
        Event (ARE)\").\n      - Maximum number of simultaneous MIDCOM sessions\n
        \  The list of middlebox capabilities may be extended by a concrete\n   protocol
        specification with further information useful for the agent.\n"
      title: 2.1.6.  Middlebox Capabilities
    - contents:
      - "2.1.7.  Agent and Middlebox Identifiers\n   To allow both agents and middleboxes
        to maintain multiple sessions,\n   each request message contains a parameter
        identifying the requesting\n   agent, and each reply message and each notification
        message contains\n   a parameter identifying the middlebox.  These parameters
        are not\n   explicitly listed in the description of the individual transactions,\n
        \  because they are common to all of them.  They are not further\n   referenced
        in the individual semantics descriptions.  Although they\n   are not necessarily
        passed explicitly as parameters of the MIDCOM\n   protocol, they might be
        provided by the underlying (secure) transport\n   protocol being used.  Agent
        identifiers at the middlebox are\n   middlebox-unique, and middlebox identifiers
        at the agent are agent-\n   unique, respectively.\n"
      title: 2.1.7.  Agent and Middlebox Identifiers
    - contents:
      - "2.1.8.  Conformance\n   The MIDCOM requirements in [MDC-REQ] demand capabilities
        of the\n   MIDCOM protocol that are met by the set of transactions specified\n
        \  below.  However, it is not required that an actual implementation of\n
        \  a middlebox supports all these transactions.  The set of announced\n   supported
        transactions may be different for different authenticated\n   agents.  The
        middlebox informs the authenticated agent with the\n   capability exchange
        at session establishment about the transactions\n   that the agent is authorized
        to perform.  Some transactions need to\n   be offered to every authenticated
        agent.\n   Each transaction definition below has a conformance entry that\n
        \  contains either 'mandatory' or 'optional'.  A mandatory transaction\n   needs
        to be implemented by every middlebox offering MIDCOM service\n   and must
        be must be offered to each of the authenticated agents.  An\n   optional transaction
        does not necessarily need to be implemented by a\n   middlebox; it may offer
        these optional transactions only to certain\n   authenticated agents.  The
        middlebox may offer one, several, all, or\n   no optional transactions to
        the agents.  Whether an agent is allowed\n   to use an optional request transaction
        is determined by the\n   middlebox's authorization procedure, which is not
        further specified\n   by this document.\n"
      title: 2.1.8.  Conformance
    title: 2.1.  General Protocol Design
  - contents:
    - "2.2.  Session Control Transactions\n   Before any transaction on policy rules
      or policy rule groups is\n   possible, a valid MIDCOM session must be established.
      \ A MIDCOM\n   session is an authenticated and authorized association between
      agent\n   and middlebox.  Sessions are initiated by agents and can be\n   terminated
      by either the agent or the middlebox.  Both agent and\n   middlebox may participate
      in several sessions (with different\n   entities) at the same time.  To distinguish
      different sessions, each\n   party uses local session identifiers.\n   All transactions
      are transmitted within this MIDCOM session.\n   Session control is supported
      by three transactions:\n      - Session Establishment (SE)\n      - Session
      Termination (ST)\n      - Asynchronous Session Termination (AST)\n   The first
      two are configuration transactions initiated by the agent,\n   and the last
      one is an asynchronous transaction initiated by the\n   middlebox.\n"
    - contents:
      - "2.2.1.  Session Establishment (SE)\n   transaction-name: session establishment\n
        \  transaction-type: configuration\n   transaction-compliance: mandatory\n
        \  request-parameters:\n      - request identifier: An agent-unique identifier
        for matching\n        corresponding request and reply at the agent.\n      -
        version: The version of the MIDCOM protocol.\n      - middlebox challenge
        (mc): An authentication challenge token for\n        authentication of the
        middlebox.  As seen below, this is present\n        only in the first iteration
        of the request.\n      - agent authentication (aa): An authentication token\n
        \       authenticating the agent to the middlebox.  As seen below, this\n
        \       is updated in the second iteration of the request with material\n
        \       responding to the middlebox challenge.\n   reply-parameters (success):\n
        \     - request identifier: An identifier matching the identifier\n        request.\n
        \     - middlebox authentication (ma): An authentication token\n        authenticating
        the middlebox to the agent.\n      - agent challenge (ac): An authentication
        challenge token for the\n        agent authentication.\n      - middlebox
        capabilities: A list describing the middlebox's\n        capabilities.  See
        section 2.1.6 for the list of middlebox\n        capabilities.\n   failure
        reason:\n      - authentication failed\n      - no authorization\n      -
        protocol version of agent and middlebox do not match\n      - lack of resources\n
        \  semantics:\n      This session establishment transaction is used to establish
        a\n      MIDCOM session.  For mutual authentication of both parties, two\n
        \     subsequent session establishment transactions are required as\n      shown
        in Figure 1.\n             agent                                       middlebox\n
        \              | session establishment request               |\n               |
        \ (with middlebox challenge mc)              | CLOSED\n               |-------------------------------------------->|\n
        \              |                                             |\n               |
        successful reply (with middlebox            |\n               |  authentication
        ma and agent challenge ac)  |\n               |<--------------------------------------------|\n
        \              |                                             | NOAUTH\n               |
        session establishment request               |\n               |  (with agent
        authentication aa)             |\n               |-------------------------------------------->|\n
        \              |                                             |\n               |
        successful reply                            |\n               |<--------------------------------------------|\n
        \              |                                             | OPEN\n               |
        \                                            |\n            Figure 1: Mutual
        Authentication of Agent and Middlebox\n      Session establishment may be
        simplified by using only a single\n      transaction.  In this case, server
        challenge and agent challenge\n      are omitted by the sender or ignored
        by the receiver, and\n      authentication must be provided by other means,
        for example, by\n      Transport Layer Security (TLS) [RFC4346] or IPsec\n
        \     [RFC4302][RFC4303].\n      The middlebox checks with its policy decision
        point whether the\n      requesting agent is authorized to open a MIDCOM session.
        \ If it is\n      not, the middlebox generates a negative reply with 'no\n
        \     authorization' as the failure reason.  If authentication and\n      authorization
        are successful, the session is established, and the\n      agent may start
        with requesting transactions on policy rules and\n      policy rule groups.\n
        \     Part of the successful reply is an indication of the middlebox's\n      capabilities.\n"
      title: 2.2.1.  Session Establishment (SE)
    - contents:
      - "2.2.2.  Session Termination (ST)\n   transaction-name: session termination\n
        \  transaction-type: configuration\n   transaction-compliance: mandatory\n
        \  request-parameters:\n      - request identifier: An agent-unique identifier
        for matching\n        corresponding request and reply at the agent.\n   reply-parameters
        (success only):\n      - request identifier: An identifier matching the identifier
        of the\n        request.\n   semantics:\n      This transaction is used to
        close the MIDCOM session on behalf of\n      the agent.  After session termination,
        the middlebox keeps all\n      established policy rules until their lifetime
        expires or until an\n      event occurs that causes the middlebox to terminate
        them.\n      The middlebox always generates a successful reply.  After sending\n
        \     the reply, the middlebox will not send any further messages to the\n
        \     agent within the current session.  It also will not process any\n      further
        request within this session that it received while\n      processing the session
        termination request or that it receives\n      later.\n"
      title: 2.2.2.  Session Termination (ST)
    - contents:
      - "2.2.3.  Asynchronous Session Termination (AST)\n   transaction-name: asynchronous
        session termination\n   transaction-type: asynchronous\n   transaction-compliance:
        mandatory\n   notification message type: Session Termination Notification
        (STN)\n   reply-parameters (success only):\n      - termination reason: The
        reason why the session is terminated.\n   semantics:\n      The middlebox
        may decide to terminate a MIDCOM session at any\n      time.  Before terminating
        the actual session, the middlebox\n      generates an STN message and sends
        it to the agent.  After sending\n      the notification, the middlebox will
        not process any further\n      request by the agent, even if it is already
        queued at the\n      middlebox.\n      After session termination, the middlebox
        keeps all established\n      policy rules until their lifetime expires or
        until an event occurs\n      for which the middlebox terminates them.\n      Unlike
        in other asynchronous transactions, no more than one\n      notification is
        sent, because there is only one agent affected by\n      the transaction.\n"
      title: 2.2.3.  Asynchronous Session Termination (AST)
    - contents:
      - "2.2.4.  Session Termination by Interruption of Connection\n   If a MIDCOM
        session is based on an underlying network connection, the\n   session can
        also be terminated by an interruption of this connection.\n   If the middlebox
        detects this, it immediately terminates the session.\n   The effect on established
        policy rules is the same as for the\n   Asynchronous Session Termination.\n"
      title: 2.2.4.  Session Termination by Interruption of Connection
    - contents:
      - "2.2.5.  Session State Machine\n   A state machine illustrating the semantics
        of the session\n   transactions is shown in Figure 2.  The transaction abbreviations\n
        \  used can be found in the headings of the particular transaction\n   section.\n
        \  All sessions start in state CLOSED.  If mutual authentication is\n   already
        provided by other means, a successful SE transaction can\n   cause a state
        transition to state OPEN.  Otherwise, it causes a\n   transition to state
        NOAUTH.  From this state, a failed second SE\n   transaction returns to state
        CLOSED.  A successful SE transaction\n   causes a transition to state OPEN.
        \ At any time, an AST transaction\n   or a connection failure may occur, causing
        a transition to state\n   CLOSED.  A successful ST transaction from either
        NOAUTH or OPEN also\n   causes a return to CLOSED.  The parameters of the
        transactions are\n   explained in Figure 2; the value mc=0 represents an empty
        middlebox\n   challenge.\n                                   mc = middlebox
        challenge\n                SE/failure         ma = middlebox authentication\n
        \               +-------+          ac = agent challenge\n                |
        \      v          aa = agent authentication\n               +----------+\n
        \              |  CLOSED  |----------------+\n               +----------+
        \               | SE(mc!=0)/\n                  |   ^  ^                 |
        \ success(ma,ac)\n         SE(mc=0, |   |  | AST             |\n          aa=OK)/
        |   |  | SE/failure      v\n          success |   |  | ST/success +----------+\n
        \                 |   |  +------------|  NOAUTH  |\n                  |   |
        \              +----------+\n                  |   | AST                |
        SE(mc=0,\n                  v   | ST/success         |  aa=OK)/\n               +----------+
        \               |  success\n               |   OPEN   |<---------------+\n
        \              +----------+\n               Figure 2: Session State Machine\n"
      title: 2.2.5.  Session State Machine
    title: 2.2.  Session Control Transactions
  - contents:
    - "2.3.  Policy Rule Transactions\n   This section describes the semantics for
      transactions on policy\n   rules.  The following transactions are specified:\n
      \     - Policy Reserve Rule (PRR)\n      - Policy Enable Rule (PER)\n      -
      Policy Rule Lifetime Change (RLC)\n      - Policy Rule List (PRL)\n      - Policy
      Rule Status (PRS)\n      - Asynchronous Policy Rule Event (ARE)\n   The first
      three transactions (PRR, PER, RLC) are configuration\n   transactions initiated
      by the agent.  The fourth and fifth (PRL, PRS)\n   are monitoring transactions.
      \ The last one (ARE) is an asynchronous\n   transaction.  The PRL and PRS transactions
      do not have any effect on\n   the policy rule state machine.\n   Before any
      transaction can start, a valid MIDCOM session must be\n   established.\n"
    - contents:
      - "2.3.1.  Configuration Transactions\n   Policy rule transactions PER and RLC
        constitute the core of the\n   MIDCOM protocol.  Both are mandatory, and they
        serve for\n      - configuring NAT bindings (PER)\n      - configuring firewall
        pinholes (PER)\n      - extending the lifetime of established policy rules
        (RLC)\n      - deleting policy rules (RLC)\n   Some cases require knowing
        in advance which IP address (and port\n   number) would be chosen by NAT in
        a PER transaction.  This\n   information is required before sufficient information
        for performing\n   a complete PER transaction is available (see example in
        section 4.2).\n   For supporting such cases, the core transactions are extended
        by the\n   Policy Reserve Rule (PRR) transaction serving for\n      - reserving
        addresses and port numbers at NATs (PRR)\n"
      title: 2.3.1.  Configuration Transactions
    - contents:
      - "2.3.2.  Establishing Policy Rules\n   Both PRR and PER establish a policy
        rule.  The action within the rule\n   is 'reserve' if set by PRR and 'enable'
        if set by PER.\n   The Policy Reserve Rule (PRR) transaction is used to establish
        an\n   address reservation on neither side, one side, or both sides of the\n
        \  middlebox, depending on the middlebox configuration.  The transaction\n
        \  returns the reserved IP addresses and the optional ranges of port\n   numbers
        to the agent.  No address binding or pinhole configuration is\n   performed
        at the middlebox.  Packet processing at the middlebox\n   remains unchanged.\n
        \  On pure firewalls, the PRR transaction is successfully processed\n   without
        any reservation, but the state transition of the MIDCOM\n   protocol engine
        is exactly the same as on NATs.\n   On a traditional NAT (see [NAT-TRAD]),
        only an external address is\n   reserved; on a twice-NAT, an internal and
        an external address are\n   reserved.  The reservation at a NAT is for required
        resources, such\n   as IP addresses and port numbers, for future use.  How
        the\n   reservation is exactly done depends on the implementation of the NAT.\n
        \  In both cases, the reservation concerns either an IP address only or\n
        \  a combination of an IP address with a range of port numbers.\n   The Policy
        Enable Rule (PER) transaction is used to establish a\n   policy rule that
        affects packet processing at the middlebox.\n   Depending on its input parameters,
        it may make use of the reservation\n   established by a PRR transaction or
        create a new rule from scratch.\n   On a NAT, the enable action is interpreted
        as a bind action\n   establishing bindings between internal and external addresses.
        \ At a\n   firewall, the enable action is interpreted as one or more allow\n
        \  actions configuring pinholes.  The number of allow actions depends on\n
        \  the parameters of the request and the implementation of the firewall.\n
        \  On a combined NAT/firewall, the enable action is interpreted as a\n   combination
        of bind and allow actions.\n   The PRR transaction and the PER transaction
        are described in more\n   detail in sections 2.3.8 and 2.3.9 below.\n"
      title: 2.3.2.  Establishing Policy Rules
    - contents:
      - "2.3.3.  Maintaining Policy Rules and Policy Rule Groups\n   Each policy rule
        has a middlebox-unique identifier.\n   Each policy rule has an owner.  Access
        control to the policy rule is\n   based on ownership (see section 2.1.5).
        \ Ownership of a policy rule\n   does not change during lifetime of the policy
        rule.\n   Each policy rule has an individual lifetime.  If the policy rule\n
        \  lifetime expires, the policy rule will be terminated at the\n   middlebox.
        \ Typically, the middlebox indicates termination of a\n   policy rule by an
        ARE transaction.  A Policy Rule Lifetime Change\n   (RLC) transaction may
        extend the lifetime of the policy rule up to\n   the limit specified by the
        middlebox at session setup.  Also, an RLC\n   transaction may be used for
        shortening a policy rule's lifetime or\n   deleting a policy rule by requesting
        a lifetime of zero.  (Please\n   note that policy rule lifetimes may also
        be modified by the Group\n   Lifetime Change (GLC) transaction.)\n   Each
        policy rule is a member of exactly one policy rule group.  Group\n   membership
        does not change during the lifetime of a policy rule.\n   Selecting the group
        is part of the transaction establishing the\n   policy rule.  This transaction
        implicitly creates a new group if the\n   agent does not specify one.  The
        new group identifier is chosen by\n   the middlebox.  New members are added
        to an existing group if the\n   agent's request designates one.  A group only
        exists as long as it\n   has member policy rules.  As soon as all policies
        belonging to the\n   group have reached the ends of their lifetimes, the group
        does not\n   exist anymore.\n   Agents can explore the properties and status
        of all policy rules they\n   are allowed to access by using the Policy Rule
        Status (PRS)\n   transaction.\n"
      title: 2.3.3.  Maintaining Policy Rules and Policy Rule Groups
    - contents:
      - "2.3.4.  Policy Events and Asynchronous Notifications\n   If a policy rule
        changes its state or if its remaining lifetime is\n   changed in ways other
        than being decreased by time, then all agents\n   that can access this policy
        rule and that participate in an open\n   session with the middlebox are notified
        by the middlebox.  If the\n   state or lifetime change was requested explicitly
        by a request\n   message, then the middlebox notifies the requesting agent
        by\n   returning the corresponding reply.  All other agents that can access\n
        \  the policy are notified by a Policy Rule Event Notification (REN)\n   message.\n
        \  Note that a middlebox can serve multiple agents at the same time in\n   different
        parallel sessions.  Between these agents, the sets of\n   policy rules that
        can be accessed by them may overlap.  For example,\n   there might be an agent
        that authenticates as administrator and that\n   can access all policies of
        all agents.  Or there could be a backup\n   agent running a session in parallel
        to a main agent and\n   authenticating itself as the same entity as the main
        agent.\n   In case of a PER, PRR, or RLC transaction, the requesting agent\n
        \  receives a PER, PRR, or RLC reply, respectively.  To all other agents\n
        \  that can access the created, modified, or terminated policy rule (and\n
        \  that participate in an open session with the middlebox), the\n   middlebox
        sends a REN message carrying the policy rule identifier\n   (PID) and the
        remaining lifetime of the policy rule.\n   In case of a rule termination by
        lifetime truncation or other events\n   not triggered by an agent, the middlebox
        sends a REN message to each\n   agent that can access the particular policy
        rule and that\n   participates in an open session with the middlebox.  This
        ensures\n   that an agent always knows the most recent state of all policy
        rules\n   it can access.\n"
      title: 2.3.4.  Policy Events and Asynchronous Notifications
    - contents:
      - "2.3.5.  Address Tuples\n   Request and reply messages of the PRR, PER, and
        PRS transactions\n   contain address specifications for IP and transport addresses.
        \ These\n   parameters include\n      - IP version\n      - IP address\n      -
        IP address prefix length\n      - transport protocol\n      - port number\n
        \     - port parity\n      - port range\n   Additionally, the request message
        of PER and the reply message of PRS\n   contain a direction of flow parameter.
        \ This direction of flow\n   parameter indicates for UDP and IP the direction
        of packets\n   traversing the middlebox.  For 'inbound', the UDP packets are\n
        \  traversing from outside to inside; for 'outbound', from inside to\n   outside.
        \ In both cases, the packets can traverse the middlebox only\n   unidirectionally.
        \ A bidirectional flow is enabled through\n   'bidirectional' as direction
        of flow parameter.  For TCP, the packet\n   flow is always bidirectional,
        but the direction of the flow parameter\n   is defined as\n      - inbound:
        bidirectional TCP packet flow.  First packet, with TCP\n        SYN flag set
        and ACK flag not set, must arrive at the middlebox\n        at the outside
        interface.\n      - outbound: bidirectional TCP packet flow.  First packet,
        with TCP\n        SYN flag set and ACK flag not set, must arrive at the middlebox\n
        \       at the inside interface.\n      - bidirectional: bidirectional TCP
        packet flow.  First packet,\n        with TCP SYN flag set and ACK flag not
        set, may arrive at inside\n        or outside interface.\n   We refer to the
        set of these parameters as an address tuple.  An\n   address tuple specifies
        either a communication endpoint at an\n   internal or external device or allocated
        addresses at the middlebox.\n   In this document, we distinguish four kinds
        of address tuples, as\n   shown in Figure 3.\n       +----------+                                 +----------+\n
        \      | internal | A0    A1 +-----------+ A2    A3 | external |\n       |
        endpoint +----------+ middlebox +----------+ endpoint |\n       +----------+
        \         +-----------+          +----------+\n                   Figure 3:
        Address Tuples A0 - A3\n      - A0 - internal endpoint: Address tuple A0 specifies
        a\n        communication endpoint of a device within the internal network,\n
        \       with respect to the middlebox.\n      - A1 - middlebox inside address:
        Address tuple A1 specifies a\n        virtual communication endpoint at the
        middlebox within the\n        internal network.  A1 is the destination address
        for packets\n        passing from the internal endpoint to the middlebox and
        is the\n        source for packets passing from the middlebox to the internal\n
        \       endpoint.\n      - A2 - middlebox outside address: Address tuple A2
        specifies a\n        virtual communication endpoint at the middlebox within
        the\n        external network.  A2 is the destination address for packets\n
        \       passing from the external endpoint to the middlebox and is the\n        source
        for packets passing from the middlebox to the external\n        endpoint.\n
        \     - A3 - external endpoint: Address tuple A3 specifies a\n        communication
        endpoint of a device within the external network,\n        with respect to
        the middlebox.\n   For a firewall, the inside and outside endpoints are identical
        to the\n   corresponding external or internal endpoints, respectively.  In
        this\n   case, the installed policy rule sets the same value in A2 as in A0\n
        \  (A0=A2) and sets the same value in A1 as in A3 (A1=A3).\n   For a traditional
        NAT, A2 is given a value different from that of A0,\n   but the NAT binds
        them.  As for the firewall, it is also as it is at\n   a traditional NAT:
        A1 has the same value as A3.\n   For a twice-NAT, there are two bindings of
        address tuples: A1 and A2\n   are both assigned values by the NAT.  The middlebox
        outside address\n   A2 is bound to the internal endpoint A0, and the middlebox
        inside\n   address A1 is bound to the external endpoint A3.\n"
      title: 2.3.5.  Address Tuples
    - contents:
      - "2.3.6.  Address Parameter Constraints\n   For transaction parameters belonging
        to an address tuple, some\n   constraints exist that are common for all messages
        using them.\n   Therefore, these constraints are summarized in the following
        and are\n   not repeated again when describing the parameters in the transaction\n
        \  descriptions are presented.\n   The MIDCOM semantics defined in this document
        specifies the handling\n   of IPv4 and IPv6 as network protocols, and of TCP
        and UDP (over IPv4\n   and IPv6) as transport protocols.  The handling of
        any other\n   transport protocol, e.g., Stream Control Transmission Protocol\n
        \  (SCTP), is not defined within the semantics but may be supported by\n   concrete
        protocol specifications.\n   The IP version parameter has either the value
        'IPv4' or 'IPv6'.  In a\n   policy rule, the value of the IP version parameter
        must be the same\n   for address tuples A0 and A1, and for A2 and A3.\n   The
        value of the IP address parameter must conform with the specified\n   IP version.\n
        \  The IP address of an address tuple may be wildcarded.  Whether IP\n   address
        wildcarding is allowed or in which range it is allowed\n   depends on the
        local policy of the middlebox; see also section 6,\n   \"Security Considerations\".
        \ Wildcarding is specified by the IP\n   address prefix length parameter of
        an address tuple.  In line with\n   the common use of a prefix length, this
        parameter indicates the\n   number of high significant bits of the IP address
        that are fixed,\n   while the remaining low significant bits of the IP address
        are\n   wildcarded.\n   The value of the transport protocol parameter can
        be either 'TCP',\n   'UDP', or 'ANY'.  If the transport protocol parameter
        has the value\n   'ANY', only IP headers are considered for packet handling
        in the\n   middlebox -- i.e., the transport header is not considered.  The\n
        \  values of the parameters port number, port range, and port parity are\n
        \  irrelevant if the protocol parameter is 'ANY'.  In a policy rule, the\n
        \  value of the transport protocol parameter must be the same for all\n   address
        tuples A0, A1, A2, and A3.\n   The value of the port number parameter is either
        zero or a positive\n   integer.  A positive integer specifies a concrete UDP
        or TCP port\n   number.  The value zero specifies port wildcarding for the
        protocol\n   specified by the transport protocol parameter.  If the port number\n
        \  parameter has the value zero, then the value of the port range\n   parameter
        is irrelevant.  Depending on the value of the transport\n   protocol parameter,
        this parameter may truly refer to ports or may\n   refer to an equivalent
        concept.\n   The port parity parameter is differently used in the context
        of\n   Policy Reserve Rules (PRRs) and Policy Enable Rules (PERs).  In the\n
        \  context of a PRR, the value of the parameter may be 'odd', 'even', or\n
        \  'any'.  It specifies the parity of the first (lowest) reserved port\n   number.\n
        \  In the context of a PER, the port parity parameter indicates to the\n   middlebox
        whether port numbers allocated at the middlebox should have\n   the same parity
        as the corresponding internal or external port\n   numbers, respectively.
        \ In this context, the parameter has the value\n   'same' or 'any'.  If the
        value is 'same', then the parity of the port\n   number of A0 must be the
        same as the parity of the port number of A2,\n   and the parity of the port
        number of A1 must be the same as the\n   parity of the port number of A3.
        \ If the port parity parameter has\n   the value 'any', then there are no
        constraints on the parity of any\n   port number.\n   The port range parameter
        specifies a number of consecutive port\n   numbers.  Its value is a positive
        integer.  Like the port number\n   parameter, this parameter defines a set
        of consecutive port numbers\n   starting with the port number specified by
        the port number parameter\n   as the lowest port number and having as many
        elements as specified by\n   the port range parameter.  A value of 1 specifies
        a single port\n   number.  The port range parameter must have the same value
        for each\n   address tuple A0, A1, A2, and A3.\n   A single policy rule P
        containing a port range value greater than one\n   is equivalent to a set
        of policy rules containing a number n of\n   policies P_1, P_2, ..., P_n where
        n equals the value of the port\n   range parameter.  Each policy rule P_1,
        P_2, ..., P_n has a port\n   range parameter value of 1.  Policy rule P_1
        contains a set of\n   address tuples A0_1, A1_1, A2_1, and A3_1, each of which
        contains the\n   first port number of the respective address tuples in P;
        policy rule\n   P_2 contains a set of address tuples A0_2, A1_2, A2_2, and
        A3_2, each\n   of which contains the second port number of the respective
        address\n   tuples in P; and so on.\n"
      title: 2.3.6.  Address Parameter Constraints
    - contents:
      - "2.3.7.  Interface-Specific Policy Rules\n   Usually, agents request policy
        rules with the knowledge of A0 and A3\n   only, i.e., the address tuples (see
        section 2.3.5).  But in very\n   special cases, agents may need to select
        the interfaces to which the\n   requested policy rule is bound.  Generally,
        the middlebox is careful\n   about choosing the right interfaces when reserving
        or enabling a\n   policy rule, as it has the overall knowledge about its configuration.\n
        \  For agents that want to select the interfaces, optional parameters\n   are
        included in the Policy Reserve Rule (PRR) and Policy Enable Rule\n   (PER)
        transactions.  These parameters are called\n      - inside interface: The
        selected interface at the inside of the\n        middlebox -- i.e., in the
        private or protected address realm.\n      - outside interface: The selected
        interface at the outside of the\n        middlebox -- i.e., in the public
        address realm.\n   The Policy Rule Status (PRS) transactions include these
        optional\n   parameters in their replies when they are supported.\n   Agents
        can learn at session startup whether interface-specific policy\n   rules are
        supported by the middlebox, by checking the middlebox\n   capabilities (see
        section 2.1.6).\n"
      title: 2.3.7.  Interface-Specific Policy Rules
    - contents:
      - "2.3.8.  Policy Reserve Rule (PRR)\n   transaction-name: policy reserve rule\n
        \  transaction-type: configuration\n   transaction-compliance: mandatory\n
        \  request-parameters:\n      - request identifier: An agent-unique identifier
        for matching\n        corresponding request and reply at the agent.\n      -
        group identifier: A reference to the group of which the policy\n        reserve
        rule should be a member.  As indicated in section 2.3.3,\n        if this
        value is not supplied, the middlebox assigns a new group\n        for this
        policy reserve rule.\n      - service: The requested NAT service of the middlebox.
        \ Allowed\n        values are 'traditional' or 'twice'.\n      - internal
        IP version: Requested IP version at the inside of the\n        middlebox;
        see section 2.3.5.\n      - internal IP address: The IP address of the internal\n
        \       communication endpoint (A0 in Figure 3); see section 2.3.5.\n      -
        internal port number: The port number of the internal\n        communication
        endpoint (A0 in Figure 3); see section 2.3.5.\n      - inside interface (optional):
        Interface at the inside of the\n        middlebox; see section 2.3.7.\n      -
        external IP version: Requested IP version at the outside of the\n        middlebox;
        see section 2.3.5.\n      - outside interface (optional): Interface at the
        outside of the\n        middlebox; see section 2.3.7.\n      - transport protocol:
        See section 2.3.5.\n      - port range: The number of consecutive port numbers
        to be\n        reserved; see section 2.3.5.\n      - port parity: The requested
        parity of the first (lowest) port\n        number to be reserved; allowed
        values for this parameter are\n        'odd', 'even', and 'any'.  See also
        section 2.3.5.\n      - policy rule lifetime: A lifetime proposal to the middlebox
        for\n        the requested policy rule.\n   reply-parameters (success):\n
        \     - request identifier: An identifier matching the identifier of the\n
        \       request.\n      - policy rule identifier: A middlebox-unique policy
        rule\n        identifier.  It is assigned by the middlebox and used as policy\n
        \       rule handle in further policy rule transactions, particularly to\n
        \       refer to the policy reserve rule in a subsequent PER\n        transaction.\n
        \     - group identifier: A reference to the group of which the policy\n        reserve
        rule is a member.\n      - reserved inside IP address: The reserved IPv4 or
        IPv6 address on\n        the internal side of the middlebox.  For an outbound
        flow, this\n        will be the destination to which the internal endpoint
        sends its\n        packets (A1 in Figure 3).  For an inbound flow, it will
        be the\n        apparent source address of the packets as forwarded to the\n
        \       internal endpoint (A0 in Figure 3).  The middlebox reserves and\n
        \       reports an internal address only in the case where twice-NAT is\n
        \       in effect.  Otherwise, an empty value for the addresses\n        indicates
        that no internal reservation was made.  See also\n        section 2.3.5.\n
        \     - reserved inside port number: See section 2.3.5.\n      - reserved
        outside IP address: The reserved IPv4 or IPv6 address\n        on the external
        side of the middlebox.  For an inbound flow,\n        this will be the destination
        to which the external endpoint\n        sends its packets (A2 in Figure 3).
        \ For an outbound flow, it\n        will be the apparent source address of
        the packets as forwarded\n        to the external endpoint (A3 in Figure 3).
        \ If the middlebox is\n        configured as a pure firewall, an empty value
        for the addresses\n        indicates that no external reservation was made.
        \ See also\n        section 2.3.5.\n      - reserved outside port number:
        See section 2.3.5.\n      - policy rule lifetime: The policy rule lifetime
        granted by the\n        middlebox, after which the reservation will be revoked
        if it has\n        not been replaced already by a policy enable rule in a
        PER\n        transaction.\n   failure reason:\n      - agent not authorized
        for this transaction\n      - agent not authorized to add members to this
        group\n      - lack of IP addresses\n      - lack of port numbers\n      -
        lack of resources\n      - specified inside/outside interface does not exist\n
        \     - specified inside/outside interface not available for specified\n        service\n
        \  notification message type: Policy Rule Event Notification (REN)\n   semantics:\n
        \     The agent can use this transaction type to reserve an IP address\n      or
        a combination of IP address, transport type, port number, and\n      port
        range at neither side, one side, or both sides of the\n      middlebox as
        required to support the enabling of a flow.\n      Typically, the PRR will
        be used in scenarios where it is required\n      to perform such a reservation
        before sufficient parameters for a\n      complete policy enable rule transaction
        are available.  See\n      section 4.2 for an example.\n      When receiving
        the request, the middlebox determines how many\n      address (and port) reservations
        are required based on its\n      configuration.  If it provides only packet
        filter services, it\n      does not perform any reservation and returns empty
        values for the\n      reserved inside and outside IP addresses and port numbers.
        \ If it\n      is configured for twice-NAT, it reserves both inside and outside\n
        \     IP addresses (and an optional range of port numbers) and returns\n      them.
        \ Otherwise, it reserves and returns an outside IP address\n      (and an
        optional range of port numbers) and returns empty values\n      for the reserved
        inside address and port range.\n      The A0 parameter (inside IP address
        version, inside IP address,\n      and inside port number) can be used by
        the middlebox to determine\n      the correct NAT mapping and thus A2 if necessary.
        \ Once a PRR\n      transaction has reserved an outside address (A2) for an
        internal\n      endpoint (A0) at the middlebox, the middlebox must ensure
        that\n      this reserved A2 is available in any subsequent PER and PRR\n
        \     transactions.\n      For middleboxes supporting interface-specific policy
        rules, as\n      defined in section 2.3.7, the optional inside and outside\n
        \     interface parameters must both be included in the request, or\n      neither
        of them should be included.  In the presence of these\n      parameters, the
        middlebox uses the outside interface parameter to\n      select the interface
        at which the outside address tuple (outside\n      IP address and port number)
        is reserved, and the inside interface\n      parameter to select the interface
        at which the inside address\n      tuple (inside IP address and port number)
        is reserved.  Without\n      the presence of these parameters, the middlebox
        selects the\n      particular interfaces based on its internal configuration.\n
        \     If there is a lack of resources, such as available IP addresses,\n      port
        numbers, or storage for further policy rules, then the\n      reservation
        fails, and an appropriate failure reply is generated.\n      If a non-existing
        policy rule group was specified, or if an\n      existing policy rule group
        was specified that is not owned by the\n      requesting agent, then no new
        policy rule is established, and an\n      appropriate failure reply is generated.\n
        \     In case of success, this transaction creates a new policy reserve\n
        \     rule.  If an already existing policy rule group is specified, then\n
        \     the new policy rule becomes a member of it.  If no policy group is\n
        \     specified, a new group is created with the new policy rule as its\n
        \     only member.  The middlebox generates a middlebox-unique\n      identifier
        for the new policy rule.  The owner of the new policy\n      rule is the authenticated
        agent that sent the request.  The\n      middlebox chooses a lifetime value
        that is greater than zero and\n      less than or equal to the minimum of
        the requested value and the\n      maximum lifetime specified by the middlebox
        at session startup,\n      i.e.,\n         0 <= lt_granted <= MINIMUM(lt_requested,
        lt_maximum)\n      where\n         - lt_granted is the lifetime actually granted
        by the middlebox\n         - lt_requested is the lifetime the agent requested\n
        \        - lt_maximum is the maximum lifetime specified at session\n           setup\n
        \     A middlebox with NAT capability always reserves a middlebox\n      external
        address tuple (A2) in response to a PRR request.  In the\n      special case
        of a combined twice-NAT/NAT middlebox, the agent can\n      request only NAT
        service or twice-NAT service by choosing the\n      service parameter 'traditional'
        or 'twice'.  An agent that does\n      not have any preference chooses 'twice'.
        \ The 'traditional' value\n      should only be used to select traditional
        NAT service at\n      middleboxes offering both traditional NAT and twice-NAT.
        \ In the\n      'twice' case, the combined twice-NAT/NAT middlebox reserves
        A2 and\n      A1; the 'traditional' case results in a reservation of A2 only.\n
        \     An agent must always use the PRR transaction for choosing NAT only\n
        \     or twice-NAT service in the special case of a combined twice-\n      NAT/NAT
        middlebox.  A firewall middlebox ignores this parameter.\n      If the protocol
        identifier is 'ANY', then the middlebox reserves\n      available inside and/or
        outside IP address(es) only.  The reserved\n      address(es) are returned
        to the agent.  In this case, the\n      request-parameters \"port range\"
        and \"port parity\" as well as the\n      reply-parameters \"inside port number\"
        and \"outside port number\"\n      are irrelevant.\n      If the protocol
        identifier is 'UDP' or 'TCP', then a combination\n      of an IP address and
        a consecutive sequence of port numbers,\n      starting with the specified
        parity, is reserved, on neither side,\n      one side, or both sides of the
        middlebox, as appropriate.  The IP\n      address(es) and the first (lowest)
        reserved port number(s) of the\n      consecutive sequence are returned to
        the agent.  (This also\n      applies to other protocols supporting ports
        or the equivalent.)\n      After a new policy reserve rule is successfully
        established and\n      the reply message has been sent to the requesting agent,
        the\n      middlebox checks whether there are other authenticated agents\n
        \     participating in open sessions, which can access the new policy\n      rule.
        \ If the middlebox finds one or more of these agents, then it\n      sends
        a REN message reporting the new policy rule to each of them.\n   MIDCOM agents
        use the policy enable rule (PER) transaction to enable\n   policy reserve
        rules that have been established beforehand by a\n   policy reserve rule (PRR)
        transaction.  See also section 2.3.2.\n"
      title: 2.3.8.  Policy Reserve Rule (PRR)
    - contents:
      - "2.3.9.  Policy Enable Rule (PER)\n   transaction-name: policy enable rule\n
        \  transaction-type: configuration\n   transaction-compliance: mandatory\n
        \  request-parameters:\n      - request identifier: An agent-unique identifier
        for matching\n        corresponding request and reply at the agent.\n      -
        policy reserve rule identifier: A reference to an already\n        existing
        policy reserve rule created by a PRR transaction.  The\n        reference
        may be empty, in which case the middlebox must assign\n        any necessary
        addresses and port numbers within this PER\n        transaction.  If it is
        not empty, then the following request\n        parameters are irrelevant:
        group identifier, transport protocol,\n        port range, port parity, internal
        IP version, external IP\n        version.\n      - group identifier: A reference
        to the group of which the policy\n        enable rule should be a member.
        \ As indicated in section 2.3.3,\n        if this value is not supplied, the
        middlebox assigns a new group\n        for this policy reserve rule.\n      -
        transport protocol: See section 2.3.5.\n      - port range: The number of
        consecutive port numbers to be\n        reserved; see section 2.3.5.\n      -
        port parity: The requested parity of the port number(s) to be\n        mapped.
        \ Allowed values of this parameter are 'same' and 'any'.\n        See also
        section 2.3.5.\n      - direction of flow: This parameter specifies the direction
        of\n        enabled communication, either 'inbound', 'outbound', or\n        'bidirectional'.\n
        \     - internal IP version: Requested IP version at the inside of the\n        middlebox;
        see section 2.3.5.\n      - internal IP address: The IP address of the internal\n
        \       communication endpoint (A0 in Figure 3); see section 2.3.5.\n      -
        internal port number: The port number of the internal\n        communication
        endpoint (A0 in Figure 3); see section 2.3.5.\n      - inside interface (optional):
        Interface at the inside of the\n        middlebox; see section 2.3.7.\n      -
        external IP version: Requested IP version at the outside of the\n        middlebox;
        see section 2.3.5.\n      - external IP address: The IP address of the external\n
        \       communication endpoint (A3 in Figure 3); see section 2.3.5.\n      -
        external port number: The port number of the external\n        communication
        endpoint (A3 in Figure 3), see section 2.3.5.\n      - outside interface (optional):
        Interface at the outside of the\n        middlebox; see section 2.3.7.\n      -
        policy rule lifetime: A lifetime proposal to the middlebox for\n        the
        requested policy rule.\n   reply-parameters (success):\n      - request identifier:
        An identifier matching the identifier of the\n        request.\n      - policy
        rule identifier: A middlebox-unique policy rule\n        identifier.  It is
        assigned by the middlebox and used as policy\n        rule handle in further
        policy rule transactions.  If a policy\n        reserve rule identifier was
        provided in the request, then the\n        returned policy rule identifier
        has the same value.\n      - group identifier: A reference to the group of
        which the policy\n        enable rule is a member.  If a policy reserve rule
        identifier\n        was provided in the request, then this parameter identifies
        the\n        group of which the policy reserve rule was a member.\n      -
        inside IP address: The IP address provided at the inside of the\n        middlebox
        (A1 in Figure 3).  In case of a twice-NAT, this\n        parameter will be
        an internal IP address reserved at the inside\n        of the middlebox.  In
        all other cases, this reply-parameter will\n        be identical with the
        external IP address passed with the\n        request.  If the policy reserve
        rule identifier parameter was\n        supplied in the request and the respective
        PRR transaction\n        reserved an inside IP address, then the inside IP
        address\n        provided in the PER response will be the identical value
        to that\n        returned by the response to the PRR request.  See also section\n
        \       2.3.5.\n      - inside port number: The internal port number provided
        at the\n        inside of the middlebox (A1 in Figure 3);  see also section\n
        \       2.3.5.\n      - outside IP address: The external IP address provided
        at the\n        outside of the middlebox (A2 in Figure 3).  In case of a pure\n
        \       firewall, this parameter will be identical with the internal IP\n
        \       address passed with the request.  In all other cases, this\n        reply-parameter
        will be an external IP address reserved at the\n        outside of the middlebox.
        \ See also section 2.3.5.\n      - outside port number: The external port
        number provided at the\n        outside of the NAT (A2 in Figure 3); see section
        2.3.5..\n      - policy rule lifetime: The policy rule lifetime granted by
        the\n        middlebox.\n   failure reason:\n      - agent not authorized
        for this transaction\n      - agent not authorized to add members to this
        group\n      - no such policy reserve rule\n      - agent not authorized to
        replace this policy reserve rule\n      - conflict with already existing policy
        rule (e.g., the same\n        internal address-port is being mapped to different
        outside\n        address-port pairs)\n      - lack of IP addresses\n      -
        lack of port numbers\n      - lack of resources\n      - no internal IP wildcarding
        allowed\n      - no external IP wildcarding allowed\n      - specified inside/outside
        interface does not exist\n      - specified inside/outside interface not available
        for specified\n        service\n      - reserved A0 to requested A0 mismatch\n
        \  notification message type: Policy Rule Event Notification (REN)\n   semantics:\n
        \     This transaction can be used by an agent to enable communication\n      between
        an internal endpoint and an external endpoint\n      independently of the
        type of middlebox (NAT, NAPT, firewall, NAT-\n      PT, combined devices),
        for unidirectional or bidirectional\n      traffic.\n      The agent sends
        an enable request specifying the endpoints\n      (optionally including wildcards)
        and the direction of\n      communication (inbound, outbound, bidirectional).
        \ The\n      communication endpoints are displayed in Figure 3.  The basic\n
        \     operation of the PER transaction can be described by\n         1. the
        agent sending A0 and A3 to the middlebox,\n         2. the middlebox reserving
        A1 and A2 or using A1 and A2 from a\n            previous PRR transaction,\n
        \        3. the middlebox enabling packet transfer between A0 and A3 by\n
        \           binding A0-A2 and A1-A3 and/or by opening the corresponding\n
        \           pinholes, both according to the specified direction, and\n         4.
        the middlebox returning A1 and A2 to the agent.\n      In case of a pure packet
        filtering firewall, the returned address\n      tuples are the same as those
        in the request: A2=A0 and A1=A3.\n      Each partner uses the other's real
        address.  In case of a\n      traditional NAT, the internal endpoint may use
        the real address of\n      the external endpoint (A1=A3), but the external
        endpoint uses an\n      address tuple provided by the NAT (A2!=A0).  In case
        of a twice-\n      NAT device, both endpoints use address tuples provided
        by the NAT\n      for addressing their communication partner (A3!=A1 and A2!=A0).\n
        \     If a firewall is combined with a NAT or a twice-NAT, the replied\n      address
        tuples will be the same as for pure traditional NAT or\n      twice-NAT, respectively,
        but the middlebox will configure its\n      packet filter in addition to the
        performed NAT bindings.  In case\n      of a firewall combined with a traditional
        NAT, the policy rule may\n      imply more than one enable action for the
        firewall configuration,\n      as incoming and outgoing packets may use different
        source-\n      destination pairs.\n      For middleboxes supporting interface-specific
        policy rules, as\n      defined in section 2.3.7, the optional inside and
        outside\n      interface parameters must both be included in the request,
        or\n      neither of them should be included.  In the presence of these\n
        \     parameters, the middlebox uses the outside interface parameter to\n
        \     select the interface at which the outside address tuple (outside\n      IP
        address and port number) is bound, and the inside interface\n      parameter
        to select the interface at which the inside address\n      tuple (inside IP
        address and port number) is bound.  Without the\n      presence of these parameters,
        the middlebox selects the particular\n      interfaces based on its internal
        configuration.\n      Checking the Policy Reservation Rule Identifier\n         If
        the parameter specifying the policy reservation rule\n         identifier
        is not empty, then the middlebox checks whether the\n         referenced policy
        rule exists, whether the agent is authorized\n         to replace this policy
        rule, and whether this policy rule is a\n         policy reserve rule.\n         In
        case of success, this transaction creates a new policy\n         enable rule.
        \ If a policy reserve rule was referenced, then the\n         policy reserve
        rule is terminated without an explicit\n         notification sent to the
        agent (other than the successful PER\n         reply).\n         The PRR transaction
        sets the internal endpoint A0 during the\n         reservation process.  In
        the process of creating a new policy\n         enable rule, the middlebox
        may check whether the requested A0\n         is equal to the reserved A0.
        \ The middlebox may reject a PER\n         request with a requested A0 not
        equal to the reserved A0 and\n         must then send an appropriate failure
        message.  Alternatively,\n         the middlebox may change A0 due to the
        PER request.\n         The middlebox generates a middlebox-unique identifier
        for the\n         new policy rule.  If a policy reserve rule was referenced,
        then\n         the identifier of the policy reserve rule is reused.\n         The
        owner of the new policy rule is the authenticated agent\n         that sent
        the request.\n      Checking the Policy Rule Group Identifier\n         If
        no policy reserve rule was specified, then the policy rule\n         group
        parameter is checked.  If a non-existing policy rule\n         group is specified,
        or if an existing policy rule group is\n         specified that is not owned
        by the requesting agent, then no\n         new policy rule is established,
        and an appropriate failure\n         reply is generated.\n         If an already
        existing policy rule group is specified, then the\n         new policy rule
        becomes a member.  If no policy group is\n         specified, then a new group
        is created with the new policy rule\n         as its only member.\n      If
        the transport protocol parameter value is 'ANY', then the\n      middlebox
        enables communication between the specified external IP\n      address and
        the specified internal IP address.  The addresses to\n      be used by the
        communication partners to address each other are\n      returned to the agent
        as inside IP address and outside IP address.\n      If the reservation identifier
        is not empty and if the reservation\n      used the same transport protocol
        type, then the reserved IP\n      addresses are used.\n      For the transport
        protocol parameter values 'UDP' and 'TCP', the\n      middlebox acts analogously
        as for 'ANY' but also maps ranges of\n      port numbers, keeping the port
        parity, if requested.\n      The configuration of the middlebox may fail because
        of lack of\n      resources, such as available IP addresses, port numbers,
        or\n      storage for further policy rules.  It may also fail because of a\n
        \     conflict with an established policy rule.  In case of a conflict,\n
        \     the first-come first-served mechanism is applied.  Existing policy\n
        \     rules remain unchanged and arriving new ones are rejected.\n      However,
        in case of a non-conflicting overlap of policy rules\n      (including identical
        policy rules), all policy rules are accepted.\n      The middlebox chooses
        a lifetime value that is greater than zero\n      and less than or equal to
        the minimum of the requested value and\n      the maximum lifetime specified
        by the middlebox at session\n      startup, i.e.,\n         0 <= lt_granted
        <= MINIMUM(lt_requested, lt_maximum)\n      where\n       - lt_granted is
        the lifetime actually granted by the middlebox\n       - lt_requested is the
        lifetime the agent requested\n       - lt_maximum is the maximum lifetime
        specified at session setup\n   In each case of failure, an appropriate failure
        reply is generated.\n   The policy reserve rule that is referenced in the
        PER transaction is\n   not affected in case of a failure within the PER transaction
        -- i.e.,\n   the policy reserve rule remains.\n   After a new policy enable
        rule is successfully established and the\n   reply message has been sent to
        the requesting agent, the middlebox\n   checks whether there are other authenticated
        agents participating in\n   open sessions that can access the new policy rule.
        \ If the middlebox\n   finds one or more of these agents, then it sends a
        REN message\n   reporting the new policy rule to each of them.\n"
      title: 2.3.9.  Policy Enable Rule (PER)
    - contents:
      - "2.3.10.  Policy Rule Lifetime Change (RLC)\n   transaction-name: policy rule
        lifetime change\n   transaction-type: configuration\n   transaction-compliance:
        mandatory\n   request-parameters:\n      - request identifier: An agent-unique
        identifier for matching\n        corresponding request and reply at the agent.\n
        \     - policy rule identifier: Identifying the policy rule for which\n        the
        lifetime is requested to be changed.  This may identify\n        either a
        policy reserve rule or a policy enable rule.\n      - policy rule lifetime:
        The new lifetime proposal for the policy\n        rule.\n   reply-parameters
        (success):\n      - request identifier: An identifier matching the identifier
        of the\n        request.\n      - policy rule lifetime: The remaining policy
        rule lifetime granted\n        by the middlebox.\n   failure reason:\n      -
        agent not authorized for this transaction\n      - agent not authorized to
        change lifetime of this policy rule\n      - no such policy rule\n      -
        lifetime cannot be extended\n   notification message type: Policy Rule Event
        Notification (REN)\n   semantics:\n      The agent can use this transaction
        type to request the extension\n      of an established policy rule's lifetime,
        the shortening of the\n      lifetime, or policy rule termination.  Policy
        rule termination is\n      requested by suggesting a new policy rule lifetime
        of zero.\n      The middlebox first checks whether the specified policy rule\n
        \     exists and whether the agent is authorized to access this policy\n      rule.
        \ If one of the checks fails, an appropriate failure reply is\n      generated.
        \ If the requested lifetime is longer than the current\n      one, the middlebox
        also checks whether the lifetime of the policy\n      rule may be extended
        and generates an appropriate failure message\n      if it may not.\n      A
        failure reply implies that the new lifetime was not accepted,\n      and the
        policy rule remains unchanged.  A success reply is\n      generated by the
        middlebox if the lifetime of the policy rule was\n      changed in any way.\n
        \     The success reply contains the new lifetime of the policy rule.\n      The
        middlebox chooses a lifetime value that is greater than zero\n      and less
        than or equal to the minimum of the requested value and\n      the maximum
        lifetime specified by the middlebox at session\n      startup, i.e.,\n         0
        <= lt_granted <= MINIMUM(lt_requested, lt_maximum)\n      where\n       -
        lt_granted is the lifetime actually granted by the middlebox\n       - lt_requested
        is the lifetime the agent requested\n       - lt_maximum is the maximum lifetime
        specified at session setup\n   After sending a success reply with a lifetime
        of zero, the middlebox\n   will consider the policy rule non-existent.  Any
        further transaction\n   on this policy rule results in a negative reply, indicating
        that this\n   policy rule does not exist anymore.\n   Note that policy rule
        lifetime may also be changed by the Group\n   Lifetime Change (GLC) transaction,
        if applied to the group of which\n   the policy rule is a member.\n   After
        the remaining policy rule lifetime was successfully changed and\n   the reply
        message has been sent to the requesting agent, the\n   middlebox checks whether
        there are other authenticated agents\n   participating in open sessions that
        can access the policy rule.  If\n   the middlebox finds one or more of these
        agents, then it sends a REN\n   message reporting the new remaining policy
        rule lifetime to each of\n   them.\n"
      title: 2.3.10.  Policy Rule Lifetime Change (RLC)
    - contents:
      - "2.3.11.  Policy Rule List (PRL)\n   transaction-name: policy rule list\n
        \  transaction-type: monitoring\n   transaction-compliance: mandatory\n   request-parameters:\n
        \     - request identifier: An agent-unique identifier for matching\n        corresponding
        request and reply at the agent.\n   reply-parameters (success):\n      - request
        identifier: An identifier matching the identifier of the\n        request.\n
        \     - policy list: List of policy rule identifiers of all policy rules\n
        \       that the agent can access.\n   failure reason:\n      - transaction
        not supported\n      - agent not authorized for this transaction\n   semantics:\n
        \     The agent can use this transaction type to list all policies that\n
        \     it can access.  Usually, the agent has this information already,\n      but
        in special cases (for example, after an agent fail-over) or\n      for special
        agents (for example, an administrating agent that can\n      access all policies)
        this transaction can be helpful.\n      The middlebox first checks whether
        the agent is authorized to\n      request this transaction.  If the check
        fails, an appropriate\n      failure reply is generated.  Otherwise, a list
        of all policies the\n      agent can access is returned indicating the identifier
        and the\n      owner of each policy.\n      This transaction does not have
        any effect on the policy rule\n      state.\n"
      title: 2.3.11.  Policy Rule List (PRL)
    - contents:
      - "2.3.12.  Policy Rule Status (PRS)\n   transaction-name: policy rule status\n
        \  transaction-type: monitoring\n   transaction-compliance: mandatory\n   request-parameters:\n
        \     - request identifier: An agent-unique identifier for matching\n        corresponding
        request and reply at the agent.\n      - policy rule identifier: The middlebox-unique
        policy rule\n        identifier.\n   reply-parameters (success):\n      -
        request identifier: An identifier matching the identifier of the\n        request.\n
        \     - policy rule owner: An identifier of the agent owning this policy\n
        \       rule.\n      - group identifier: A reference to the group of which
        the policy\n        rule is a member.\n      - policy rule action: This parameter
        has either the value\n        'reserve' or the value 'enable'.\n      - transport
        protocol: Identifies the protocol for which a\n        reservation is requested;
        see section 2.3.5.\n      - port range: The number of consecutive port numbers;
        see section\n        2.3.5.\n      - direction: The direction of the communication
        enabled by the\n        middlebox.  Applicable only to policy enable rules.\n
        \     - internal IP address version: The version of the internal IP\n        address
        (IP version of A0 in Figure 3).\n      - external IP address version: The
        version of the external IP\n        address (IP version of A3 in Figure 3).\n
        \     - internal IP address: The IP address of the internal\n        communication
        endpoint (A0 in Figure 3); see section 2.3.5.\n      - internal port number:
        The port number of the internal\n        communication endpoint (A0 in Figure
        3); see section 2.3.5.\n      - external IP address: The IP address of the
        external\n        communication endpoint (A3 in Figure 3); see section 2.3.5.\n
        \     - external port number: The port number of the external\n        communication
        endpoint (A3 in Figure 3); see section 2.3.5.\n      - inside interface (optional):
        The inside interface at the\n        middlebox; see section 2.3.7.\n      -
        inside IP address: The internal IP address provided at the\n        inside
        of the NAT (A1 in Figure 3); see section 2.3.5.\n      - inside port number:
        The internal port number provided at the\n        inside of the NAT (A1 in
        Figure 3); see section 2.3.5.\n      - outside interface (optional): The outside
        interface at the\n        middlebox; see section 2.3.7.\n      - outside IP
        address: The external IP address provided at the\n        outside of the NAT
        (A2 in Figure 3); see section 2.3.5.\n      - outside port number: The external
        port number provided at the\n        outside of the NAT (A2 in Figure 3);
        see section 2.3.5.\n      - port parity: The parity of the allocated ports.\n
        \     - service: The selected service in the case of mixed traditional\n        and
        twice-NAT middlebox (see section 2.3.8).\n      - policy rule lifetime: The
        remaining lifetime of the policy rule.\n   failure reason:\n      - transaction
        not supported\n      - agent not authorized for this transaction\n      -
        no such policy rule\n      - agent not authorized to access this policy rule\n
        \  semantics:\n      The agent can use this transaction type to list all properties
        of\n      a policy rule.  Usually, the agent has this information already,\n
        \     but in special cases (for example, after an agent fail-over) or\n      for
        special agents (for example, an administrating agent that can\n      access
        all policy rules) this transaction can be helpful.\n      The middlebox first
        checks whether the specified policy rule\n      exists and whether the agent
        is authorized to access this group.\n      If one of the checks fails, an
        appropriate failure reply is\n      generated.  Otherwise, all properties
        of the policy rule are\n      returned to the agent.  Some of the returned
        parameters may be\n      irrelevant, depending on the policy rule action ('reserve'
        or\n      'enable') and depending on other parameters -- for example, the\n
        \     protocol identifier.\n      This transaction does not have any effect
        on the policy rule\n      state.\n"
      title: 2.3.12.  Policy Rule Status (PRS)
    - contents:
      - "2.3.13.  Asynchronous Policy Rule Event (ARE)\n   transaction-name: asynchronous
        policy rule event\n   transaction-type: asynchronous\n   transaction-compliance:
        mandatory\n   notification message type: Policy Rule Event Notification (REN)\n
        \  semantics:\n      The middlebox may decide at any point in time to terminate
        a\n      policy rule.  This transaction is triggered most frequently by\n
        \     lifetime expiration of the policy rule.  Among other events that\n      may
        cause this transaction are changes in the policy rule decision\n      point.\n
        \     The middlebox sends a REN message to all agents that participate\n      in
        an open session with the middlebox and that are authorized to\n      access
        the policy rule.  The notification is sent to the agents\n      before the
        middlebox changes the policy rule's lifetime.  The\n      change of lifetime
        may be triggered by any other authorized agent\n      and results in shortening
        (lt_new < lt_existing), extending\n      (lt_new > lt_existing), or terminating
        the policy rule\n      (lt_new = 0).\n   The ARE transaction corresponds to
        the REN message handling described\n   in section 2.3.4 for multiple agents.\n"
      title: 2.3.13.  Asynchronous Policy Rule Event (ARE)
    - contents:
      - "2.3.14.  Policy Rule State Machine\n   The state machine for the policy rule
        transactions is shown in Figure\n   4 with all possible state transitions.
        \ The used transaction\n   abbreviations may be found in the headings of the
        particular\n   transaction section.\n                         PRR/success
        \  +---------------+\n                     +-----------------+  PRID UNUSED
        \ |<-+\n           +----+    |                 +---------------+  |\n           |
        \   |    |                   ^   |            |\n           |    v    v                   |
        \  |            |\n           |  +-------------+    ARE     |   | PER/       |
        ARE\n           |  |   RESERVED  +------------+   | success    | RLC(lt=0)/\n
        \          |  +-+----+------+  RLC(lt=0)/    |            |  success\n           |
        \   |    |          success      |            |\n           +----+    |                       v
        \           |\n         RLC(lt>0)/  | PER/success     +---------------+  |\n
        \         success    +---------------->|    ENABLED    +--+\n                                       +-+-------------+\n
        \                                        |           ^\n             lt =
        lifetime               +-----------+\n                                       RLC(lt>0)/success\n
        \                  Figure 4: Policy Rule State Machine\n   This state machine
        exists per policy rule identifier (PRID).\n   Initially, all policy rules
        are in state PRID UNUSED, which means\n   that the policy rule does not exist
        or is not active.  After\n   returning to state PRID UNUSED, the policy rule
        identifier is no\n   longer bound to an existing policy rule and may be reused
        by the\n   middlebox.\n   A successful PRR transaction causes a transition
        from the initial\n   state PRID UNUSED to the state RESERVED, where an address
        reservation\n   is established.  From there, state ENABLED can be entered
        by a PER\n   transaction.  This transaction can also be used for entering
        state\n   ENABLED directly from state PRID UNUSED without a reservation.  In\n
        \  state ENABLED, the requested communication between the internal and\n   the
        external endpoint is enabled.\n   The states RESERVED and ENABLED can be maintained
        by successful RLC\n   transactions with a requested lifetime greater than
        0.  Transitions\n   from both of these states back to state PRID UNUSED can
        be caused by\n   an ARE transaction or by a successful RLC transaction with
        a lifetime\n   parameter of 0.\n   A failed request transaction does not change
        state at the middlebox.\n   Note that transitions initiated by RLC transactions
        may also be\n   initiated by GLC transactions.\n"
      title: 2.3.14.  Policy Rule State Machine
    title: 2.3.  Policy Rule Transactions
  - contents:
    - "2.4.  Policy Rule Group Transactions\n   This section describes the semantics
      for transactions on groups of\n   policy rules.  These transactions are specified
      as follows:\n      - Group Lifetime Change (GLC)\n      - Group List (GL)\n
      \     - Group Status (GS)\n   All are request transactions initiated by the
      agent.  GLC is a\n   configuration transaction.  GL and GS are monitoring transactions\n
      \  that do not have any effect on the group state machine.\n"
    - contents:
      - "2.4.1.  Overview\n   A policy rule group has only one attribute: the list
        of its members.\n   All member policies of a single group must be owned by
        the same\n   authenticated agent.  Therefore, an implicit property of a group
        is\n   its owner, which is the owner of the member policy rules.\n   A group
        is implicitly created when its first member policy rule is\n   established.
        \ A group is implicitly terminated when the last\n   remaining member policy
        rule is terminated.  Consequently, the\n   lifetime of a group is the maximum
        of the lifetimes of all member\n   policy rules.\n   A group has a middlebox-unique
        identifier.\n   Policy rule group transactions are declared as 'optional'
        by their\n   respective compliance entry in section 3.  However, they provide
        some\n   functionalities, such as convenience for the agent in sending only\n
        \  one request instead of several, that is not available if only\n   mandatory
        transactions are available.\n   The Group Lifetime Change (GLC) transaction
        is equivalent to\n   simultaneously performed Policy Rule Lifetime Change
        (RLC)\n   transactions on all members of the group.  The result of a successful\n
        \  GLC transaction is that all member policy rules have the same\n   lifetime.
        \ As with the RLC transaction, the GLC transaction can be\n   used to delete
        all member policy rules by requesting a lifetime of\n   zero.\n   The monitoring
        transactions Group List (GL) and Group Status (GS) can\n   be used by the
        agent to explore the state of the middlebox and to\n   explore its access
        rights.  The GL transaction lists all groups that\n   the agent may access,
        including groups owned by other agents.  The GS\n   transaction reports the
        status on an individual group and lists all\n   policy rules of this group
        by their policy rule identifiers.  The\n   agent can explore the state of
        the individual policy rules by using\n   the policy rule identifiers in a
        policy rule status (PRS) transaction\n   (see section 2.3.12).\n   The GL
        and GS transactions are particularly helpful in case of an\n   agent fail-over.
        \ The agent taking over the role of a failed one can\n   use these transactions
        to retrieve whichever policies have been\n   established by the failed agent.\n
        \  Notifications on group events are generated analogously to policy\n   rule
        events.  To notify agents about group events, the Policy Rule\n   Group Event
        Notification (GEN) message type is used.  GEN messages\n   contain an agent-unique
        notification identifier, the policy rule\n   group identifier, and the remaining
        lifetime of the group.\n"
      title: 2.4.1.  Overview
    - contents:
      - "2.4.2.  Group Lifetime Change (GLC)\n   transaction-name: group lifetime
        change\n   transaction-type: configuration\n   transaction-compliance: optional\n
        \  request-parameters:\n      - request identifier: An agent-unique identifier
        for matching\n        corresponding request and reply at the agent.\n      -
        group identifier: A reference to the group for which the\n        lifetime
        is requested to be changed.\n      - group lifetime: The new lifetime proposal
        for the group.\n   reply-parameters (success):\n      - request identifier:
        An identifier matching the identifier of the\n        request.\n      - group
        lifetime: The group lifetime granted by the middlebox.\n   failure reason:\n
        \     - transaction not supported\n      - agent not authorized for this transaction\n
        \     - agent not authorized to change lifetime of this group\n      - no
        such group\n      - lifetime cannot be extended\n   notification message type:
        Policy Rule Group Event Notification (GEN)\n   semantics:\n      The agent
        can use this transaction type to request an extension of\n      the lifetime
        of all members of a policy rule group, to request\n      shortening the lifetime
        of all members, or to request termination\n      of all member policies (which
        implies termination of the group).\n      Termination is requested by suggesting
        a new group lifetime of\n      zero.\n      The middlebox first checks whether
        the specified group exists and\n      whether the agent is authorized to access
        this group.  If one of\n      the checks fails, an appropriate failure reply
        is generated.  If\n      the requested lifetime is longer than the current
        one, the\n      middlebox also checks whether the lifetime of the group may
        be\n      extended and generates an appropriate failure message if it may\n
        \     not.\n      A failure reply implies that the lifetime of the group remains\n
        \     unchanged.  A success reply is generated by the middlebox if the\n      lifetime
        of the group was changed in any way.\n      The success reply contains the
        new common lifetime of all member\n      policy rules of the group.  The middlebox
        chooses the new lifetime\n      less than or equal to the minimum of the requested
        lifetime and\n      the maximum lifetime that the middlebox specified at session
        setup\n      along with its other capabilities, i.e.,\n         0 <= lt_granted
        <= MINIMUM(lt_requested, lt_maximum)\n      where\n       - lt_granted is
        the lifetime actually granted by the middlebox\n       - lt_requested is the
        lifetime the agent requested\n       - lt_maximum is the maximum lifetime
        specified at session setup\n   After sending a success reply with a lifetime
        of zero, the middlebox\n   will terminate the member policy rules without
        any further\n   notification to the agent, and will consider the group and
        all of its\n   members non-existent.  Any further transaction on this policy
        rule\n   group or on any of its members results in a negative reply,\n   indicating
        that this group or policy rule, respectively, does not\n   exist anymore.\n
        \  After the remaining policy rule group lifetime is successfully\n   changed
        and the reply message has been sent to the requesting agent,\n   the middlebox
        checks whether there are other authenticated agents\n   participating in open
        sessions that can access the policy rule group.\n   If the middlebox finds
        one or more of these agents, it sends a GEN\n   message reporting the new
        remaining policy rule group lifetime to\n   each of them.\n"
      title: 2.4.2.  Group Lifetime Change (GLC)
    - contents:
      - "2.4.3.  Group List (GL)\n   transaction-name: group list\n   transaction-type:
        monitoring\n   transaction-compliance: optional\n   request-parameters:\n
        \     - request identifier: An agent-unique identifier for matching\n        corresponding
        request and reply at the agent.\n   reply-parameters (success):\n      - request
        identifier: An identifier matching the identifier of the\n        request.\n
        \     - group list: List of all groups that the agent can access.  For\n        each
        listed group, the identifier and the owner are indicated.\n   failure reason:\n
        \     - transaction not supported\n      - agent not authorized for this transaction\n
        \  semantics:\n      The agent can use this transaction type to list all groups
        that it\n      can access.  Usually, the agent has this information already,
        but\n      in special cases (for example, after an agent fail-over) or for\n
        \     special agents (for example, an administrating agent that can\n      access
        all groups) this transaction can be helpful.\n      The middlebox first checks
        whether the agent is authorized to\n      request this transaction.  If the
        check fails, an appropriate\n      failure reply is generated.  Otherwise
        a list of all groups the\n      agent can access is returned indicating the
        identifier and the\n      owner of each group.\n      This transaction does
        not have any effect on the group state.\n"
      title: 2.4.3.  Group List (GL)
    - contents:
      - "2.4.4.  Group Status (GS)\n   transaction-name: group status\n   transaction-type:
        monitoring\n   transaction-compliance: optional\n   request-parameters:\n
        \     - request identifier: An agent-unique identifier for matching\n        corresponding
        request and reply at the agent.\n      - group identifier: A reference to
        the group for which status\n        information is requested.\n   reply-parameters
        (success):\n      - request identifier: An identifier matching the identifier
        of the\n        request.\n      - group owner: An identifier of the agent
        owning this policy rule\n        group.\n      - group lifetime: The remaining
        lifetime of the group.  This is\n        the maximum of the remaining lifetimes
        of all members' policy\n        rules.\n      - member list: List of all policy
        rules that are members of the\n        group.  The policy rules are specified
        by their middlebox-unique\n        policy rule identifier.\n   failure reason:\n
        \     - transaction not supported\n      - agent not authorized for this transaction\n
        \     - no such group\n      - agent not authorized to list members of this
        group\n   semantics:\n      The agent can use this transaction type to list
        all member policy\n      rules of a group.  Usually, the agent has this information\n
        \     already, but in special cases (for example, after an agent fail-\n      over)
        or for special agents (for example, an administrating agent\n      that can
        access all groups) this transaction can be helpful.\n      The middlebox first
        checks whether the specified group exists and\n      whether the agent is
        authorized to access this group.  If one of\n      the checks fails, an appropriate
        failure reply is generated.\n      Otherwise, a list of all group members
        is returned indicating the\n      identifier of each group.\n      This transaction
        does not have any effect on the group state.\n"
      title: 2.4.4.  Group Status (GS)
    title: 2.4.  Policy Rule Group Transactions
  title: 2.  Semantics Specification
- contents:
  - "3.  Conformance Statements\n   A protocol definition complies with the semantics
    defined in section\n   2 if the protocol specification includes all specified
    transactions\n   with all their mandatory parameters.  However, it is not required\n
    \  that an actual implementation of a middlebox supports all these\n   transactions.
    \ Which transactions are required for compliance is\n   different for agent and
    middlebox.\n   This section contains conformance statements for MIDCOM protocol\n
    \  implementations related to the semantics.  Conformance is specified\n   differently
    for agents and middleboxes.  These conformance statements\n   will probably be
    extended by a concrete protocol specification.\n   However, such an extension
    is expected to extend the statements below\n   in such a way that all of them
    still hold.\n   The following list shows the transaction-compliance property of
    all\n   transactions as specified in the previous section:\n      - Session Control
    Transactions\n          - Session Establishment (SE)                 mandatory\n
    \         - Session Termination (ST)                   mandatory\n          -
    Asynchronous Session Termination (AST)     mandatory\n      - Policy Rule Transactions\n
    \         - Policy Reserve Rule (PRR)                  mandatory\n          -
    Policy Enable Rule (PER)                   mandatory\n          - Policy Rule
    Lifetime Change (RLC)          mandatory\n          - Policy Rule List  (PRL)
    \                   mandatory\n          - Policy Rule Status (PRS)                   mandatory\n
    \         - Asynchronous Policy Rule Event (ARE)       mandatory\n      - Policy
    Rule Group Transactions\n          - Group Lifetime Change (GLC)                optional\n
    \         - Group List (GL)                            optional\n          - Group
    Status (GS)                          optional\n"
  - contents:
    - "3.1.  General Implementation Conformance\n   A compliant implementation of
      a MIDCOM protocol MUST support all\n   mandatory transactions.\n   A compliant
      implementation of a MIDCOM protocol MAY support none,\n   one, or more of the
      following transactions: GLC, GL, GS.\n   A compliant implementation MAY extend
      the protocol semantics by\n   further transactions.\n   A compliant implementation
      of a MIDCOM protocol MUST support all\n   mandatory parameters of each transaction
      concerning the information\n   contained.  The set of parameters can be redefined
      per transaction as\n   long as the contained information is maintained.\n   A
      compliant implementation of a MIDCOM protocol MAY support the use\n   of interface-specific
      policy rules.  Either both or neither of the\n   optional inside and outside
      interface parameters in PRR, PER, and PRS\n   MUST be included if interface-specific
      policy rules are supported.\n   A compliant implementation MAY extend the list
      of parameters of\n   transactions.\n   A compliant implementation MAY replace
      a single transaction by a set\n   of more fine-grained transactions.  In such
      a case, it MUST be\n   ensured that requirement 2.1.4 (deterministic behavior)
      and\n   requirement 2.1.5 (known and stable state) of [MDC-REQ] are still\n
      \  met.  When a single transaction is replaced by a set of multiple\n   fine-grained
      transactions, this set MUST be equivalent to a single\n   transaction.  Furthermore,
      this set of transactions MUST further meet\n   the atomicity requirement stated
      in section 2.1.4.\n"
    title: 3.1.  General Implementation Conformance
  - contents:
    - "3.2.  Middlebox Conformance\n   A middlebox implementation of a MIDCOM protocol
      supports a request\n   transaction if it is able to receive and process all
      possible correct\n   message instances of the particular request transaction
      and if it\n   generates a correct reply for any correct request it receives.\n
      \  A middlebox implementation of a MIDCOM protocol supports an\n   asynchronous
      transaction if it is able to generate the corresponding\n   notification message
      properly.\n   A compliant middlebox implementation of a MIDCOM protocol must
      inform\n   the agent about the list of supported transactions within the SE\n
      \  transaction.\n"
    title: 3.2.  Middlebox Conformance
  - contents:
    - "3.3.  Agent Conformance\n   An agent implementation of a MIDCOM protocol supports
      a request\n   transaction if it can generate the corresponding request message\n
      \  properly and if it can receive and process all possible correct\n   replies
      to the particular request.\n   An agent implementation of a MIDCOM protocol
      supports an asynchronous\n   transaction if it can receive and process all possible
      correct\n   message instances of the particular transaction.\n   A compliant
      agent implementation of a MIDCOM protocol must not use\n   any optional transaction
      that is not supported by the middlebox.  The\n   middlebox informs the agent
      about the list of supported transactions\n   within the SE transaction.\n"
    title: 3.3.  Agent Conformance
  title: 3.  Conformance Statements
- contents:
  - "4.  Transaction Usage Examples\n   This section gives two usage examples of the
    transactions specified\n   in section 2.  The first shows how an agent can explore
    all policy\n   rules and policy rule groups that it may access at a middlebox.
    \ The\n   second example shows the configuration of a middlebox in combination\n
    \  with the setup of a voice over IP session with the Session Initiation\n   Protocol
    (SIP) [RFC3261].\n"
  - contents:
    - "4.1.  Exploring Policy Rules and Policy Rule Groups\n   This example assumes
      an already established session.  It shows how an\n   agent can find out\n      -
      which groups it may access and who owns these groups,\n      - the status and
      member list of all accessible groups, and\n      - the status and properties
      of all accessible policy rules.\n   If there is just a single session, these
      actions are not needed,\n   because the middlebox informs the agent about each
      state transition\n   of any policy rule or policy rule group.  However, after
      the\n   disruption of a session or after an intentional session termination,\n
      \  the agent might want to re-establish the session and explore which of\n   the
      groups and policy rules it established are still in place.\n   Also, an agent
      system may fail and another one may take over.  Then\n   the new agent system
      needs to find out what has already been\n   configured by the failing system
      and what still needs to be done.\n   A third situation where exploring policy
      rules and groups is useful\n   is the case of an agent with 'administrator'
      authorization.  This\n   agent may access and modify any policy rule or group
      created by any\n   other agent.\n   All agents will probably start their exploration
      with the Group List\n   (GL) transaction, as shown in Figure 5.  On this request,
      the\n   middlebox returns a list of pairs, each containing an agent\n   identifier
      and a group identifier (GID).  The agent is informed which\n   of its own groups
      and which other agents' groups it may access.\n         agent                                     middlebox\n
      \         |                      GL                       |\n          |**********************************************>|\n
      \         |<**********************************************|\n          |   (agent1,GID1)
      (agent1,GID2) (agent2,GID3)   |\n          |                                               |\n
      \         |                   GS GID2                     |\n          |**********************************************>|\n
      \         |<**********************************************|\n          |    agent1
      \ lifetime  PID1  PID2  PID3  PID4   |\n          |                                               |\n
      \           Figure 5: Using the GL and the GS Transactions\n   In Figure 5,
      three groups are accessible to the agent, and the agent\n   retrieves information
      about the second group by using the Group\n   Status (GS) transaction.  It receives
      the owner of the group, the\n   remaining lifetime, and the list of member policy
      rules, in this case\n   containing four policy rule identifiers (PIDs).\n   In
      the following, the agent explores these four policy rules.  The\n   example
      assumes that the middlebox is a traditional NAPT.  Figure 6\n   shows the exploration
      of the first policy rule.  In reply to a Policy\n   Rule Status (PRS) transaction,
      the middlebox always returns the\n   following list of parameters:\n      -
      policy rule owner\n      - group identifier\n      - policy rule action (reserve
      or enable)\n      - protocol type\n      - port range\n      - direction\n      -
      internal IP address\n      - internal port number\n      - external address\n
      \     - external port number\n      - middlebox inside IP address\n      - middlebox
      inside port number\n      - middlebox outside IP address\n      - middlebox
      outside port number\n      - IP address versions (not printed)\n      - middlebox
      service (not printed)\n      - inside and outside interface (optional, not printed)\n
      \        agent                                     middlebox\n          |                   PRS
      PID1                    |\n          |**********************************************>|\n
      \         |<**********************************************|\n          |  agent1
      \   GID2    RESERVE    UDP    1   \"\"   |\n          | ANY         ANY         ANY
      \        ANY       |\n          | ANY         ANY         IPADR_OUT   PORT_OUT1
      |\n          |                                               |\n          Figure
      6: Status Report for an Outside Reservation\n   The 'ANY' parameter printed
      in Figure 6 is used as a placeholder in\n   policy rule status replies for policy
      reserve rules.  The policy rule\n   with PID1 is a policy reserve rule for UDP
      traffic at the outside of\n   the middlebox.  Since this is a reserve rule,
      direction is empty.  As\n   there is no internal or external address involved
      yet, these four\n   fields are wildcarded in the reply.  The same holds for
      the inside\n   middlebox address and port number.  The only address information\n
      \  given by the reply is the reserved outside IP address of the\n   middlebox
      (IPADR_OUT) and the corresponding port number (PORT_OUT1).\n   Note that IPADR_OUT
      and PORT_OUT1 may not be wildcarded, as the\n   reserve action does not support
      this.\n   Applying PRS to PID2 (Figure 7) shows that the second policy rule
      is\n   a policy enable rule for inbound UDP packets.  The internal\n   destination
      is fixed concerning IP address, protocol, and port\n   number, but for the external
      source, the port number is wildcarded.\n   The outside IP address and port number
      of the middlebox are what the\n   external sender needs to use as destination
      in the original packet it\n   sends.  At the middlebox, the destination address
      is replaced with\n   the internal address of the final receiver.  During address\n
      \  translation, the source IP address and the source port numbers of the\n   packets
      remain unchanged.  This is indicated by the inside address,\n   which is identical
      to the external address.\n         agent                                     middlebox\n
      \         |                   PRS PID2                    |\n          |**********************************************>|\n
      \         |<**********************************************|\n          |       agent1
      \ GID2  ENABLE  UDP  1  IN        |\n          | IPADR_INT   PORT_INT1   IPADR_EXT
      \  ANY       |\n          | IPADR_EXT   ANY         IPADR_OUT   PORT_OUT2 |\n
      \         |                                               |\n         Figure
      7: Status Report for Enabled Inbound Packets\n   For traditional NATs, the identity
      of the inside IP address and port\n   number with the external IP address and
      port number always holds\n   (A1=A3 in Figure 3).  For a pure firewall, the
      outside IP address and\n   port number are always identical with the internal
      IP address and\n   port number (A0=A2 in Figure 3).\n         agent                                     middlebox\n
      \         |                   PRS PID3                    |\n          |**********************************************>|\n
      \         |<**********************************************|\n          |       agent1
      \ GID2  ENABLE  UDP  1  OUT       |\n          | IPADR_INT   PORT_INT2   IPADR_EXT
      \  PORT_EXT1 |\n          | IPADR_EXT   PORT_EXT1   IPADR_OUT   PORT_OUT3 |\n
      \         |                                               |\n         Figure
      8: Status Report for Enabled Outbound Packets\n   Figure 8 shows enabled outbound
      UDP communication between the same\n   host.  Here all port numbers are known.
      \ Since again A1=A3, the\n   internal sender uses the external IP address and
      port number as\n   destination in the original packets.  At the firewall, the
      internal\n   source IP address and port number are replaced by the shown outside\n
      \  IP address and port number of the middlebox.\n         agent                                     middlebox\n
      \         |                   PRS PID4                    |\n          |**********************************************>|\n
      \         |<**********************************************|\n          |       agent1
      \ GID2  ENABLE  TCP  1  BI        |\n          |  IPADR_INT   PORT_INT3  IPADR_EXT
      \  PORT_EXT2 |\n          |  IPADR_EXT   PORT_EXT2  IPADR_OUT   PORT_OUT4 |\n
      \         |                                               |\n        Figure
      9: Status Report for Bidirectional TCP Traffic\n   Finally, Figure 9 shows the
      status report for enabled bidirectional\n   TCP traffic.  Note that, still,
      A1=A3.  For outbound packets, only\n   the source IP address and port number
      are replaced at the middlebox,\n   and for inbound packets, only the destination
      IP address and port\n   number are replaced.\n"
    title: 4.1.  Exploring Policy Rules and Policy Rule Groups
  - contents:
    - "4.2.  Enabling a SIP-Signaled Call\n   This elaborated transaction usage example
      shows the interaction\n   between a back-to-back user agent (B2BUA) and a middlebox.
      \ The\n   middlebox itself is a traditional Network Address and Port Translator\n
      \  (NAPT), and two SIP user agents communicate with each other via the\n   B2BUA
      and a NAPT, as shown in Figure 10.  The MIDCOM agent is co-\n   located with
      the B2BUA, and the MIDCOM server is at the middlebox.\n   Thus, the MIDCOM protocol
      runs between the B2BUA and the middlebox.\n               +-------------+\n
      \              | B2BUA       |\n               | for domain  ++++\n               |
      example.com |  +\n               +-------------+  +\n                    ^   ^
      \      +\n        Private     |   |       +     Public Network\n        Network
      \    |   |       +\n      +----------+  |   |  +----+------+         +----------------+\n
      \     | SIP User |<-+   +->| Middlebox |<------->| SIP User Agent |\n      |
      Agent A  |<#######>|   NAPT    |<#######>| B@example.org  |\n      +----------+
      \        +-----------+         +----------------+\n      <--> SIP signaling\n
      \     <##> RTP traffic\n      ++++ MIDCOM protocol\n                   Figure
      10: Example of a SIP Scenario\n   For the sequence charts below, we make these
      assumptions:\n      - The NAPT is statically configured to forward SIP signaling
      from\n        the outside to the B2BUA -- i.e., traffic to the NAPT's external\n
      \       IP address and port 5060 is forwarded to the internal B2BUA.\n      -
      The SIP user agent A, located inside the private network, is\n        registered
      at the B2BUA with its private IP address.\n      - User A knows the general
      SIP URL of user B.  The URL is\n        B@example.org.  However, the concrete
      URL of the SIP user agent\n        B, which user B currently uses, is not known.\n
      \     - The RTP paths are configured, but not the RTP Control Protocol\n        (RTCP)
      paths.\n      - The middlebox and the B2BUA share an established MIDCOM session.\n
      \     - Some parameters are omitted, such as the request identifier\n        (RID).\n
      \  Furthermore, the following abbreviations are used:\n      - IP_AI: Internal
      IP address of user agent A\n      - P_AI: Internal port number of user agent
      A to receive RTP data\n      - P_AE: External mapped port number of user agent
      A\n      - IP_AE: External IP address of the middlebox\n      - IP_B: IP address
      of user agent B\n      - P_B: Port number of user agent B to receive RTP data\n
      \     - GID: Group identifier\n      - PID: Policy rule identifier\n   The abbreviations
      of the MIDCOM transactions can be found in the\n   particular section headings.\n
      \  In our example, user A tries to call user B.  The user agent A sends\n   an
      INVITE SIP message to the B2BUA (see Figure 10).  The SDP part of\n   the particular
      SIP message relevant for the middlebox configuration\n   is shown in the sequence
      chart as follows:\n      SDP: m=..P_AI..\n           c=IP_AI\n   where the m
      tag is the media tag that contains the receiving UDP port\n   number, and the
      c tag contains the IP address of the terminal\n   receiving the media stream.\n
      \  The INVITE message forwarded to user agent B must contain a public IP\n   address
      and a port number to which user agent B can send its RTP\n   media stream.  The
      B2BUA requests a policy enable rule at the\n   middlebox with a PER request
      with the wildcarded IP address and port\n   number of user agent B.  As neither
      the IP address nor port numbers\n   of user agent B are known at this point,
      the address of user agent B\n   must be wildcarded.  The wildcarded IP address
      and port number enable\n   the 'early media' capability but result in some insecurity,
      as any\n   outside host can reach user agent A on the enabled port number\n
      \  through the middlebox.\n   User Agent      B2BUA                       Middlebox
      \  User Agent\n    A                                             NAPT             B\n
      \   |                |                              |              |\n    |
      INVITE         |                              |              |\n    | B@example.org
      \ |                              |              |\n    | SDP:m=..P_AI.. |                              |
      \             |\n    |     c=IP_AI    |                              |              |\n
      \   |--------------->|                              |              |\n    |
      \               |                              |              |\n    |                |
      \ PER PID1 UDP 1 EVEN IN      |              |\n    |                |   IP_AI
      P_AI ANY ANY 300s    |              |\n    |                |*****************************>|
      \             |\n    |                |<*****************************|              |\n
      \   |                |    PER OK GID1 PID1 ANY ANY  |              |\n    |
      \               |       IP_AE P_AE1 300s       |              |\n             Figure
      11: PER with Wildcard Address and Port Number\n   A successful PER reply, as
      shown in Figure 11, results in a NAT\n   binding at the middlebox.  This binding
      enables UDP traffic from any\n   host outside user agent A's private network
      to reach user agent A.\n   So user agent B could start sending traffic immediately
      after\n   receiving the INVITE message, as could any other host -- even hosts\n
      \  that are not intended to participate, such as any malicious host.\n   If
      the middlebox does not support or does not permit IP address\n   wildcarding
      for security reasons, the PER request will be rejected\n   with an appropriate
      failure reason, like 'IP wildcarding not\n   supported'.  Nevertheless, the
      B2BUA needs an outside IP address and\n   port number at the middlebox (the
      NAPT) in order to forward the SIP\n   INVITE message.\n   If the IP address
      of user agent B is still not known (it will be sent\n   by user agent B in the
      SIP reply message) and IP address wildcarding\n   is not permitted, the B2BUA
      uses the PRR transaction.\n   By using the PRR request, the B2BUA requests an
      outside IP address\n   and port number (see Figure 12) without already establishing
      a NAT\n   binding or pin hole.  The PRR request contains the service parameter\n
      \  'tw' -- i.e., the MIDCOM agent chooses the default value.  In this\n   configuration,
      with NAPT and without a twice-NAT, only an outside\n   address is reserved.
      \ In the SDP payload of the INVITE message, the\n   B2BUA replaces the IP address
      and port number of user agent A with\n   the reserved IP address and port from
      the PRR reply (see Figure 12).\n   The SIP INVITE message is forwarded to user
      agent B with a modified\n   SDP body containing the outside address and port
      number, to which\n   user agent B will send its RTP media stream.\n   User Agent
      \     B2BUA                       Middlebox   User Agent\n    A                                             NAPT
      \            B\n    |                |                              |              |\n
      \      ...PER in Figure 11 has failed, continuing with PRR ...\n    |                |
      \                             |              |\n    |                |PRR tw
      v4 v4 A UDP 1 EVEN 300s|              |\n    |                |*****************************>|
      \             |\n    |                |<*****************************|              |\n
      \   |                | PRR OK PID1 GID1 EMPTY       |              |\n    |
      \               |  IP_AE/P_AE 300s             |              |\n    |                |
      \                             |              |\n    |                | INVITE
      B@example.org SDP:m=..P_AE.. c=IP_AE |\n    |                |-------------------------------------------->|\n
      \   |                |<--------------------------------------------|\n    |
      \               |       200 OK  SDP:m=..P_B.. c=IP_B          |\n           Figure
      12: Address Reservation with PRR Transaction\n   This SIP '200 OK' reply contains
      the IP address and port number at\n   which user agent B will receive a media
      stream.  The IP address is\n   assumed to be equal to the IP address from which
      user agent B will\n   send its media stream.\n   Now, the B2BUA has sufficient
      information for establishing the\n   complete NAT binding with a policy enable
      rule (PER) transaction;\n   i.e., the UDP/RTP data of the call can flow from
      user agent B to user\n   agent A.  The PER transaction references the reservation
      by passing\n   the PID of the PRR (PID1).\n   For the opposite direction, UDP/RTP
      data from user agent A to B has\n   to be enabled also.  This is done by a second
      PER transaction with\n   all the necessary parameters (see Figure 13).  The
      request message\n   contains the group identifier (GID1) the middlebox has assigned
      in\n   the first PER transaction.  Therefore, both policy rules have become\n
      \  members of the same group.  After having enabled both UDP/RTP\n   streams,
      the B2BUA can forward the '200 OK' SIP message to user agent\n   A to indicate
      that the telephone call can start.\n   User Agent      B2BUA                       Middlebox
      \  User Agent\n    A                                             NAPT             B\n
      \   |                |                              |              |\n    |
      \               |  PER PID1 UDP 1 SAME IN      |              |\n    |                |
      \  IP_AI P_AI IP_B ANY 300s   |              |\n    |                |*****************************>|
      \             |\n    |                |<*****************************|              |\n
      \   |                |    PER OK GID1 PID1 IP_B ANY |              |\n    |
      \               |       IP_AE P_AE1 300s       |              |\n    |                |
      \                             |              |\n            ...media stream
      from user agent B to A enabled...\n    |                |                              |
      \             |\n    |                |  PER GID1 UDP 1 SAME OUT     |              |\n
      \   |                |    IP_AI ANY IP_B P_B 300s   |              |\n    |
      \               |*****************************>|              |\n    |                |<*****************************|
      \             |\n    |                |   PER OK GID1 PID2 IP_B P_B  |              |\n
      \   |                |       IP_AE P_AE2 300s       |              |\n    |
      \               |                              |              |\n             ...media
      streams from both directions enabled...\n    |                |                              |
      \             |\n    |    200 OK      |                              |              |\n
      \   |<---------------|                              |              |\n    |
      SDP:m=..P_B..  |                              |              |\n    |     c=IP_B
      \    |                              |              |\n          Figure 13: Policy
      Rule Establishment for UDP Flows\n   User agent B decides to terminate the call
      and sends its 'BYE' SIP\n   message to user agent A.  The B2BUA forwards all
      SIP messages and\n   terminates the group afterwards, using a group lifetime
      change (GLC)\n   transaction with a requested remaining lifetime of 0 seconds
      (see\n   Figure 14).  Termination of the group includes terminating all member\n
      \  policy rules.\n   User Agent      B2BUA                       Middlebox   User
      Agent\n    A                                             NAPT             B\n
      \   |                |                              |              |\n    |
      \    BYE        |                     BYE                     |\n    |<---------------|<--------------------------------------------|\n
      \   |                |                              |              |\n    |
      \   200 OK      |                   200 OK                    |\n    |--------------->|-------------------------------------------->|\n
      \   |                |                              |              |\n    |
      \               |         GLC GID1 0s          |              |\n    |                |*****************************>|
      \             |\n    |                |<*****************************|              |\n
      \   |                |         GLC OK 0s            |              |\n    |
      \               |                              |              |\n       ...both
      NAT bindings for the media streams are removed...\n               Figure 14:
      Termination of Policy Rule Groups\n"
    title: 4.2.  Enabling a SIP-Signaled Call
  title: 4.  Transaction Usage Examples
- contents:
  - "5.  Compliance with MIDCOM Requirements\n   This section explains the compliance
    of the specified semantics with\n   the MIDCOM requirements.  It is structured
    according to [MDC-REQ]:\n      - Compliance with Protocol Machinery Requirements
    (section 5.1)\n      - Compliance with Protocol Semantics Requirements (section
    5.2)\n      - Compliance with Security Requirements (section 5.3)\n   The requirements
    are referred to with the number of the section in\n   which they are defined:
    \"requirement x.y.z\" refers to the requirement\n   specified in section x.y.z
    of [MDC-REQ].\n"
  - contents:
    - '5.1.  Protocol Machinery Requirements

      '
    - contents:
      - "5.1.1.  Authorized Association\n   The specified semantics enables a MIDCOM
        agent to establish an\n   authorized association between itself and the middlebox.
        \ The agent\n   identifies itself by the authentication mechanism of the Session\n
        \  Establishment transaction described in section 2.2.1.  Based on this\n
        \  authentication, the middlebox can determine whether or not the agent\n
        \  will be permitted to request a service.  Thus, requirement 2.1.1 is\n   met.\n"
      title: 5.1.1.  Authorized Association
    - contents:
      - "5.1.2.  Agent Connects to Multiple Middleboxes\n   As specified in section
        2.2, the MIDCOM protocol allows the agent to\n   communicate with more than
        one middlebox simultaneously.  The\n   selection of a mechanism for separating
        different sessions is left to\n   the concrete protocol definition.  It must
        provide a clear mapping of\n   protocol messages to open sessions.  Then requirement
        2.1.2 is met.\n"
      title: 5.1.2.  Agent Connects to Multiple Middleboxes
    - contents:
      - "5.1.3.  Multiple Agents Connect to Same Middlebox\n   As specified in section
        2.2, the MIDCOM protocol allows the middlebox\n   to communicate with more
        than one agent simultaneously.  The\n   selection of a mechanism for separating
        different sessions is left to\n   the concrete protocol definition.  It must
        provide a clear mapping of\n   protocol messages to open sessions.  Then requirement
        2.1.3 is met.\n"
      title: 5.1.3.  Multiple Agents Connect to Same Middlebox
    - contents:
      - "5.1.4.  Deterministic Behavior\n   Section 2.1.2 states that the processing
        of a request of an agent may\n   not be interrupted by any request of the
        same or another agent.  This\n   provides atomicity among request transactions
        and avoids race\n   conditions resulting in unpredictable behavior by the
        middlebox.\n   The behavior of the middlebox can only be predictable in the
        view of\n   its administrators.  In the view of an agent, the middlebox behavior\n
        \  is unpredictable, as the administrator can, for example, modify the\n   authorization
        of the agent at any time without the agent being able\n   to observe this
        change.  Consequently, the behavior of the middlebox\n   is not necessarily
        deterministic from the point of view of any agent.\n   As predictability of
        the middlebox behavior is given for its\n   administrator, requirement 2.1.4
        is met.\n"
      title: 5.1.4.  Deterministic Behavior
    - contents:
      - "5.1.5.  Known and Stable State\n   Section 2.1 states that request transactions
        are atomic with respect\n   to each other and from the point of view of an
        agent.  All\n   transactions are clearly defined as state transitions that
        either\n   leave the current stable, well-defined state and enter a new stable,\n
        \  well-defined one or that remain in the current stable, well-defined\n   state.
        \ Section 2.1 clearly demands that intermediate states are not\n   stable
        and are not reported to any agent.\n   Furthermore, for each state transition
        a message is sent to the\n   corresponding agent, either a reply or a notification.
        \ The agent can\n   uniquely map each reply to one of the requests that it
        sent to the\n   middlebox, because agent-unique request identifiers are used
        for this\n   purpose.  Notifications are self-explanatory by their definition.\n
        \  Furthermore, the Group List transaction (section 2.4.3), the Group\n   Status
        transaction (section 2.4.4), the Policy Rule List transaction\n   (section
        2.3.11), and the Policy Rule Status transaction (section\n   2.3.12) allow
        the agent at any time during a session to retrieve\n   information about\n
        \     - all policy rule groups it may access,\n      - the status and member
        policy rules of all accessible groups,\n      - all policy rules it may access,
        and\n      - the status of all accessible policy rules.\n   Therefore, the
        agent is precisely informed about the state of the\n   middlebox (as far as
        the services requested by the agent are\n   affected), and requirement 2.1.5
        is met.\n"
      title: 5.1.5.  Known and Stable State
    - contents:
      - "5.1.6.  Status Report\n   As argued in the previous section, the middlebox
        unambiguously\n   informs the agent about every state transition related to
        any of the\n   services requested by the agent.  Also, at any time the agent
        can\n   retrieve full status information about all accessible policy rules\n
        \  and policy rule groups.  Thus, requirement 2.1.6 is met.\n"
      title: 5.1.6.  Status Report
    - contents:
      - "5.1.7.  Unsolicited Messages (Asynchronous Notifications)\n   The semantics
        includes asynchronous notifications messages from the\n   middlebox to the
        agent, including the Session Termination\n   Notification (STN) message, the
        Policy Rule Event Notification (REN)\n   message, and the Group Event Notification
        (GEN) message (see section\n   2.1.2).  These notifications report every change
        of state of policy\n   rules or policy rule groups that was not explicitly
        requested by the\n   agent.  Thus, requirement 2.1.7 is met by the semantics
        specified\n   above.\n"
      title: 5.1.7.  Unsolicited Messages (Asynchronous Notifications)
    - contents:
      - "5.1.8.  Mutual Authentication\n   As specified in section 2.2.1, the semantics
        requires mutual\n   authentication of agent and middlebox, by using either
        two subsequent\n   Session Establishment transactions or mutual authentication
        provided\n   on a lower protocol layer.  Thus, requirement 2.1.8 is met.\n"
      title: 5.1.8.  Mutual Authentication
    - contents:
      - "5.1.9.  Session Termination by Any Party\n   The semantics specification
        states in section 2.2.2 that the agent\n   may request session termination
        by generating the Session Termination\n   request and that the middlebox may
        not reject this request.  In turn,\n   section 2.2.3 states that the middlebox
        may send the Asynchronous\n   Session Termination notification at any time
        and then terminate the\n   session.  Thus, requirement 2.1.9 is met.\n"
      title: 5.1.9.  Session Termination by Any Party
    - contents:
      - "5.1.10.  Request Result\n   Section 2.1 states that each request of an agent
        is followed by a\n   reply of the middlebox indicating either success or failure.
        \ Thus,\n   requirement 2.2.10 is met.\n"
      title: 5.1.10.  Request Result
    - contents:
      - "5.1.11.  Version Interworking\n   Section 2.2.1 states that the agent needs
        to specify the protocol\n   version number that it will use during the session.
        \ The middlebox\n   may accept this and act according to this protocol version
        or may\n   reject the session if it does not support this version.  If the\n
        \  session setup is rejected, the agent may try again with another\n   version.
        \ Thus, requirement 2.2.11 is met.\n"
      title: 5.1.11.  Version Interworking
    - contents:
      - "5.1.12.  Deterministic Handling of Overlapping Rules\n   The only policy
        rule actions specified are 'reserve' and 'enable'.\n   For firewalls, overlapping
        enable actions or reserve actions do not\n   create any conflict, so a firewall
        will always accept overlapping\n   rules as specified in section 2.3.2 (assuming
        the required\n   authorization is given).\n   For NATs, reserve and enable
        may conflict.  If a conflicting request\n   arrives, it is rejected, as stated
        in section 2.3.2.  If an\n   overlapping request arrives that does not conflict
        with those it\n   overlaps, it is accepted (assuming the required authorization
        is\n   given).\n   Therefore, the behavior of the middlebox in the presence
        of\n   overlapping rules can be predicted deterministically, and requirement\n
        \  2.1.12 is met.\n"
      title: 5.1.12.  Deterministic Handling of Overlapping Rules
    title: 5.1.  Protocol Machinery Requirements
  - contents:
    - '5.2.  Protocol Semantics Requirements

      '
    - contents:
      - "5.2.1.  Extensible Syntax and Semantics\n   Requirement 2.2.1 explicitly
        requests extensibility of protocol\n   syntax.  This needs to be addressed
        by the concrete protocol\n   definition.  The semantics specification is extensible
        anyway,\n   because new transactions may be added.\n"
      title: 5.2.1.  Extensible Syntax and Semantics
    - contents:
      - "5.2.2.  Policy Rules for Different Types of Middleboxes\n   Section 2.3 explains
        that the semantics uses identical transactions\n   for all middlebox types
        and that the same policy rule can be applied\n   to all of them.  Thus, requirement
        2.2.2 is met.\n"
      title: 5.2.2.  Policy Rules for Different Types of Middleboxes
    - contents:
      - "5.2.3.  Ruleset Groups\n   The semantics explicitly supports grouping of
        policy rules and\n   transactions on policy rule groups, as described in section
        2.4.  The\n   group transactions can be used for lifetime extension and termination\n
        \  of all policy rules that are members of the particular group.  Thus,\n
        \  requirement 2.2.3 is met.\n"
      title: 5.2.3.  Ruleset Groups
    - contents:
      - "5.2.4.  Policy Rule Lifetime Extension\n   The semantics includes a transaction
        for explicit lifetime extension\n   of policy rules, as described in section
        2.3.3.  Thus, requirement\n   2.2.4 is met.\n"
      title: 5.2.4.  Policy Rule Lifetime Extension
    - contents:
      - "5.2.5.  Robust Failure Modes\n   The state transitions at the middlebox are
        clearly specified and\n   communicated to the agent.  There is no intermediate
        state reached by\n   a partial processing of a request.  All requests are
        always processed\n   completely, either successfully or unsuccessfully.  All
        request\n   transactions include a list of failure reasons.  These failure\n
        \  reasons cover indication of invalid parameters where applicable.  In\n
        \  case of failure, one of the specified reasons is returned from the\n   middlebox
        to the agent.  Thus, requirement 2.2.5 is met.\n"
      title: 5.2.5.  Robust Failure Modes
    - contents:
      - "5.2.6.  Failure Reasons\n   The semantics includes a failure reason parameter
        in each failure\n   reply.  Thus, requirement 2.2.6 is met.\n"
      title: 5.2.6.  Failure Reasons
    - contents:
      - "5.2.7.  Multiple Agents Manipulating Same Policy Rule\n   As specified in
        sections 2.3 and 2.4, each installed policy rule and\n   policy rule group
        has an owner, which is the authenticated agent that\n   created the policy
        rule or group, respectively.  The authenticated\n   identity is input to authorize
        access to policy rules and groups.\n   If the middlebox is sufficiently configurable,
        its administrator can\n   configure it so that one authenticated agent is
        authorized to access\n   and modify policy rules and groups owned by another
        agent.  Because\n   specified semantics does not preclude this, it meets requirement\n
        \  2.2.7.\n"
      title: 5.2.7.  Multiple Agents Manipulating Same Policy Rule
    - contents:
      - "5.2.8.  Carrying Filtering Rules\n   The Policy Enable Rule transaction specified
        in section 2.3.8 can\n   carry 5-tuple filtering rules.  This meets requirement
        2.2.8.\n"
      title: 5.2.8.  Carrying Filtering Rules
    - contents:
      - "5.2.9.  Parity of Port Numbers\n   As specified in section 2.3.6, the agent
        is able to request keeping\n   the port parity when reserving port numbers
        with the PRR transaction\n   (see section 2.3.8) and when establishing address
        bindings with the\n   PER transaction (see section 2.3.9).  Thus, requirement
        2.2.9 is met.\n"
      title: 5.2.9.  Parity of Port Numbers
    - contents:
      - "5.2.10.  Consecutive Range of Port Numbers\n   As specified in section 2.3.6,
        the agent is able to request a\n   consecutive range of port numbers when
        reserving port numbers with\n   the PRR transaction (see section 2.3.8) and
        when establishing address\n   bindings or pinholes with the PER transaction
        (see section 2.3.9).\n   Thus, requirement 2.2.10 is met.\n"
      title: 5.2.10.  Consecutive Range of Port Numbers
    - contents:
      - "5.2.11.  Contradicting Overlapping Policy Rules\n   Requirement 2.2.11 is
        based on the assumption that contradictory\n   policy rule actions, such as
        'enable'/'allow' and\n   'disable'/'disallow', are supported.  In conformance
        with decisions\n   made by the working group after finalizing the requirements
        document,\n   this requirement is not met by the semantics because no\n   'disable'/'disallow'
        action is supported.\n"
      title: 5.2.11.  Contradicting Overlapping Policy Rules
    title: 5.2.  Protocol Semantics Requirements
  - contents:
    - '5.3.  Security Requirements

      '
    - contents:
      - "5.3.1.  Authentication, Confidentiality, Integrity\n   The semantics definition
        supports mutual authentication of agent and\n   middlebox in the Session Establishment
        transaction (section 2.2.1).\n   The use of an underlying protocol such as
        TLS or IPsec is mandatory.\n   Thus, requirement 2.3.1 is met.\n"
      title: 5.3.1.  Authentication, Confidentiality, Integrity
    - contents:
      - "5.3.2.  Optional Confidentiality of Control Messages\n   The use of IPsec
        or TLS allows agent and middlebox to use an\n   encryption method (including
        no encryption).  Thus, requirement 2.3.2\n   is met.\n"
      title: 5.3.2.  Optional Confidentiality of Control Messages
    - contents:
      - "5.3.3.  Operation across Untrusted Domains\n   Operation across untrusted
        domains is supported by mutual\n   authentication and by the use of TLS or
        IPsec protection.  Thus,\n   requirement 2.3.3 is met.\n"
      title: 5.3.3.  Operation across Untrusted Domains
    - contents:
      - "5.3.4.  Mitigate Replay Attacks\n   The specified semantics mitigates replay
        attacks and meets\n   requirement 2.3.4 by requiring mutual authentication
        of agent and\n   middlebox, and by mandating the use of TLS or IPsec protection.\n
        \  Further mitigation can be provided as part of a concrete MIDCOM\n   protocol
        definition -- for example, by requiring consecutively\n   increasing numbers
        for request identifiers.\n"
      title: 5.3.4.  Mitigate Replay Attacks
    title: 5.3.  Security Requirements
  title: 5.  Compliance with MIDCOM Requirements
- contents:
  - "6.  Security Considerations\n   The interaction between a middlebox and an agent
    (see [MDC-FRM]) is a\n   very sensitive point with respect to security.  The configuration
    of\n   policy rules from a middlebox-external entity appears to contradict\n   the
    nature of a middlebox.  Therefore, effective means have to be\n   used to ensure\n
    \     - mutual authentication between agent and middlebox,\n      - authorization,\n
    \     - message integrity, and\n      - message confidentiality.\n   The semantics
    defines a mechanism to ensure mutual authentication\n   between agent and middlebox
    (see section 2.2.1).  In combination with\n   the authentication, the middlebox
    is able to decide whether an agent\n   is authorized to request an action at the
    middlebox.  The semantics\n   relies on underlying protocols, such as TLS or IPsec,
    to maintain\n   message integrity and confidentiality of the transferred data
    between\n   both entities.\n   For the TLS and IPsec use, both sides must use
    securely configured\n   credentials for authentication and authorization.\n   The
    configuration of policy rules with wildcarded IP addresses and\n   port numbers
    results in certain risks, such as opening overly\n   wildcarded policy rules.
    \ An excessively wildcarded policy rule would\n   be A0 and A3 with IP address
    set to 'any' IP address, for instance.\n   This type of pinhole would render the
    middlebox, in the sense of\n   security, useless, as any packet could traverse
    the middlebox without\n   further checking.  The local policy of the middlebox
    should reject\n   such policy rule enable requests.\n   A reasonable default configuration
    for wildcarding would be that only\n   one port number may be wildcarded and all
    IP addresses must be set\n   without wildcarding.  However, there are some cases
    where security\n   needs to be balanced with functionality.\n   The example described
    in section 4.2 shows how SIP-signaled calls can\n   be served in a secure way
    without wildcarding IP addresses.  But some\n   SIP-signaled applications make
    use of early media (see section 5.5 of\n   [RFC3398]).  To receive early media,
    the middleboxes need to be\n   configured before the second participant in a session
    is known.  As\n   it is not known, the IP address of the second participant needs
    to be\n   wildcarded.\n   In such cases and in several similar ones, there is
    a security policy\n   decision to be made by the middlebox operator.  The operator
    can\n   configure the middlebox so that it supports more functionality, for\n
    \  example, by allowing wildcarded IP addresses, or so that network\n   operation
    is more secure, for example, by disallowing wildcarded IP\n   addresses.\n"
  title: 6.  Security Considerations
- contents:
  - "7.  IAB Considerations on UNSAF\n   UNilateral Self-Address Fixing (UNSAF) is
    described in [RFC3424] as a\n   process at originating endpoints that attempt
    to determine or fix the\n   address (and port) by which they are known to another
    endpoint.\n   UNSAF proposals, such as Simple Traversal of the UDP Protocol through\n
    \  NAT (STUN) [RFC3489], are considered as a general class of\n   workarounds
    for NAT traversal and as solutions for scenarios with no\n   middlebox communication
    (MIDCOM).\n   This document describes the protocol semantics for such a middlebox\n
    \  communication (MIDCOM) solution.  MIDCOM is not intended as a short-\n   term
    workaround, but more as a long-term solution for middlebox\n   communication.
    \ In MIDCOM, endpoints are not involved in allocating,\n   maintaining, and deleting
    addresses and ports at the middlebox.  The\n   full control of addresses and ports
    at the middlebox is located at\n   the MIDCOM server.\n   Therefore, this document
    addresses the UNSAF considerations in\n   [RFC3424] by proposing a long-term alternative
    solution.\n"
  title: 7.  IAB Considerations on UNSAF
- contents:
  - "8.  Acknowledgements\n   We would like to thank all the people contributing to
    the semantics\n   discussion on the mailing list for a lot of valuable comments.\n"
  title: 8.  Acknowledgements
- contents:
  - '9.  References

    '
  - contents:
    - "9.1.  Normative References\n   [RFC2119]   Bradner, S., \"Key words for use
      in RFCs to Indicate\n               Requirement Levels\", BCP 14, RFC 2119,
      March 1997.\n"
    title: 9.1.  Normative References
  - contents:
    - "9.2.  Informative References\n   [MDC-FRM]   Srisuresh, P., Kuthan, J., Rosenberg,
      J., Molitor, A.,\n               and A. Rayhan, \"Middlebox communication architecture
      and\n               framework\", RFC 3303, August 2002.\n   [MDC-REQ]   Swale,
      R., Mart, P., Sijben, P., Brim, S., and M. Shore,\n               \"Middlebox
      Communications (midcom) Protocol\n               Requirements\", RFC 3304, August
      2002.\n   [MDC-SEM]   Stiemerling, M., Quittek, J., and T. Taylor, \"Middlebox\n
      \              Communications (MIDCOM) Protocol Semantics\", RFC 3989,\n               February
      2005.\n   [NAT-TERM]  Srisuresh, P. and M. Holdrege, \"IP Network Address\n
      \              Translator (NAT) Terminology and Considerations\", RFC\n               2663,
      August 1999.\n   [NAT-TRAD]  Srisuresh, P. and K. Egevang, \"Traditional IP
      Network\n               Address Translator (Traditional NAT)\", RFC 3022, January\n
      \              2001.\n   [RFC4346]   Dierks, T. and E. Rescorla, \"The Transport
      Layer Security\n               (TLS) Protocol Version 1.1\", RFC 4346, April
      2006.\n   [RFC4302]   Kent, S., \"IP Authentication Header\", RFC 4302, December\n
      \              2005.\n   [RFC4303]   Kent, S., \"IP Encapsulating Security Payload
      (ESP)\", RFC\n               4303, December 2005.\n   [RFC3198]   Westerinen,
      A., Schnizlein, J., Strassner, J., Scherling,\n               M., Quinn, B.,
      Herzog, S., Huynh, A., Carlson, M., Perry,\n               J., and S. Waldbusser,
      \"Terminology for Policy-Based\n               Management\", RFC 3198, November
      2001.\n   [RFC3261]   Rosenberg, J., Schulzrinne, H., Camarillo, G., Johnston,\n
      \              A., Peterson, J., Sparks, R., Handley, M., and E.\n               Schooler,
      \"SIP:  Session Initiation Protocol\", RFC 3261,\n               June 2002.\n
      \  [RFC3398]   Camarillo, G., Roach, A., Peterson, J., and L. Ong,\n               \"Integrated
      Services Digital Network (ISDN) User Part\n               (ISUP) to Session
      Initiation Protocol (SIP) Mapping\", RFC\n               3398, December 2002.\n
      \  [RFC3424]   Daigle, L. and IAB, \"IAB Considerations for UNilateral\n               Self-Address
      Fixing (UNSAF) Across Network Address\n               Translation\", RFC 3424,
      November 2002.\n   [RFC3489]   Rosenberg, J., Weinberger, J., Huitema, C., and
      R. Mahy,\n               \"STUN - Simple Traversal of User Datagram Protocol
      (UDP)\n               Through Network Address Translators (NATs)\", RFC 3489,\n
      \              March 2003.\n"
    title: 9.2.  Informative References
  title: 9.  References
- contents:
  - "Appendix A.  Changes from RFC 3989\n   1. The example in section 4.2 used a SIP
    proxy server modifying the\n      body of a SIP message.  This was a violation
    of RFC 3261.  This\n      has been fixed by replacing the SIP proxy server with
    a back-to-\n      back user agent.\n   2. Clarifications concerning the used set
    of transaction types have\n      been added.\n   3. Section 3.1, \"General Implementation
    Conformance\", now uses key\n      words from RFC 2119.\n   4. Minor editorial
    changes have been made and references have been\n      updated.\n"
  title: Appendix A.  Changes from RFC 3989
- contents:
  - "Authors' Addresses\n   Martin Stiemerling\n   NEC Europe Ltd.\n   Kurfuersten-Anlage
    36\n   69115 Heidelberg\n   Germany\n   Phone: +49 6221 4342-113\n   EMail: stiemerling@nw.neclab.eu\n
    \  Juergen Quittek\n   NEC Europe Ltd.\n   Kurfuersten-Anlage 36\n   69115 Heidelberg\n
    \  Germany\n   Phone: +49 6221 4342-115\n   EMail: quittek@nw.neclab.eu\n   Tom
    Taylor\n   Nortel\n   1852 Lorraine Ave.\n   Ottawa, Ontario\n   Canada  K1H 6Z8\n
    \  Phone: +1 613 763 1496\n   EMail: tom.taylor@rogers.com\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2008).\n   This document
    is subject to the rights, licenses and restrictions\n   contained in BCP 78, and
    except as set forth therein, the authors\n   retain all their rights.\n   This
    document and the information contained herein are provided on an\n   \"AS IS\"
    basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE INTERNET ENGINEERING
    TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT
    LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION HEREIN WILL NOT INFRINGE
    ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at\n   ietf-ipr@ietf.org.\n"
  title: Intellectual Property
