- title: __initial_text__
  contents:
  - '           Uniform Resource Identifiers (URI): Generic Syntax

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1998).  All Rights Reserved.\n"
- title: IESG Note
  contents:
  - "IESG Note\n   This paper describes a \"superset\" of operations that can be applied\n\
    \   to URI.  It consists of both a grammar and a description of basic\n   functionality\
    \ for URI.  To understand what is a valid URI, both the\n   grammar and the associated\
    \ description have to be studied.  Some of\n   the functionality described is\
    \ not applicable to all URI schemes, and\n   some operations are only possible\
    \ when certain media types are\n   retrieved using the URI, regardless of the\
    \ scheme used.\n"
- title: Abstract
  contents:
  - "Abstract\n   A Uniform Resource Identifier (URI) is a compact string of characters\n\
    \   for identifying an abstract or physical resource.  This document\n   defines\
    \ the generic syntax of URI, including both absolute and\n   relative forms, and\
    \ guidelines for their use; it revises and replaces\n   the generic definitions\
    \ in RFC 1738 and RFC 1808.\n   This document defines a grammar that is a superset\
    \ of all valid URI,\n   such that an implementation can parse the common components\
    \ of a URI\n   reference without knowing the scheme-specific requirements of every\n\
    \   possible identifier type.  This document does not define a generative\n  \
    \ grammar for URI; that task will be performed by the individual\n   specifications\
    \ of each URI scheme.\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   Uniform Resource Identifiers (URI) provide a simple and extensible\n\
    \   means for identifying a resource.  This specification of URI syntax\n   and\
    \ semantics is derived from concepts introduced by the World Wide\n   Web global\
    \ information initiative, whose use of such objects dates\n   from 1990 and is\
    \ described in \"Universal Resource Identifiers in WWW\"\n   [RFC1630].  The specification\
    \ of URI is designed to meet the\n   recommendations laid out in \"Functional\
    \ Recommendations for Internet\n   Resource Locators\" [RFC1736] and \"Functional\
    \ Requirements for Uniform\n   Resource Names\" [RFC1737].\n   This document updates\
    \ and merges \"Uniform Resource Locators\"\n   [RFC1738] and \"Relative Uniform\
    \ Resource Locators\" [RFC1808] in order\n   to define a single, generic syntax\
    \ for all URI.  It excludes those\n   portions of RFC 1738 that defined the specific\
    \ syntax of individual\n   URL schemes; those portions will be updated as separate\
    \ documents, as\n   will the process for registration of new URI schemes.  This\
    \ document\n   does not discuss the issues and recommendation for dealing with\n\
    \   characters outside of the US-ASCII character set [ASCII]; those\n   recommendations\
    \ are discussed in a separate document.\n   All significant changes from the prior\
    \ RFCs are noted in Appendix G.\n"
- title: 1.1 Overview of URI
  contents:
  - "1.1 Overview of URI\n   URI are characterized by the following definitions:\n\
    \      Uniform\n         Uniformity provides several benefits: it allows different\
    \ types\n         of resource identifiers to be used in the same context, even\n\
    \         when the mechanisms used to access those resources may differ;\n   \
    \      it allows uniform semantic interpretation of common syntactic\n       \
    \  conventions across different types of resource identifiers; it\n         allows\
    \ introduction of new types of resource identifiers\n         without interfering\
    \ with the way that existing identifiers are\n         used; and, it allows the\
    \ identifiers to be reused in many\n         different contexts, thus permitting\
    \ new applications or\n         protocols to leverage a pre-existing, large, and\
    \ widely-used\n         set of resource identifiers.\n      Resource\n       \
    \  A resource can be anything that has identity.  Familiar\n         examples\
    \ include an electronic document, an image, a service\n         (e.g., \"today's\
    \ weather report for Los Angeles\"), and a\n         collection of other resources.\
    \  Not all resources are network\n         \"retrievable\"; e.g., human beings,\
    \ corporations, and bound\n         books in a library can also be considered\
    \ resources.\n         The resource is the conceptual mapping to an entity or\
    \ set of\n         entities, not necessarily the entity which corresponds to that\n\
    \         mapping at any particular instance in time.  Thus, a resource\n    \
    \     can remain constant even when its content---the entities to\n         which\
    \ it currently corresponds---changes over time, provided\n         that the conceptual\
    \ mapping is not changed in the process.\n      Identifier\n         An identifier\
    \ is an object that can act as a reference to\n         something that has identity.\
    \  In the case of URI, the object is\n         a sequence of characters with a\
    \ restricted syntax.\n   Having identified a resource, a system may perform a\
    \ variety of\n   operations on the resource, as might be characterized by such\
    \ words\n   as `access', `update', `replace', or `find attributes'.\n"
- title: 1.2. URI, URL, and URN
  contents:
  - "1.2. URI, URL, and URN\n   A URI can be further classified as a locator, a name,\
    \ or both.  The\n   term \"Uniform Resource Locator\" (URL) refers to the subset\
    \ of URI\n   that identify resources via a representation of their primary access\n\
    \   mechanism (e.g., their network \"location\"), rather than identifying\n  \
    \ the resource by name or by some other attribute(s) of that resource.\n   The\
    \ term \"Uniform Resource Name\" (URN) refers to the subset of URI\n   that are\
    \ required to remain globally unique and persistent even when\n   the resource\
    \ ceases to exist or becomes unavailable.\n   The URI scheme (Section 3.1) defines\
    \ the namespace of the URI, and\n   thus may further restrict the syntax and semantics\
    \ of identifiers\n   using that scheme.  This specification defines those elements\
    \ of the\n   URI syntax that are either required of all URI schemes or are common\n\
    \   to many URI schemes.  It thus defines the syntax and semantics that\n   are\
    \ needed to implement a scheme-independent parsing mechanism for\n   URI references,\
    \ such that the scheme-dependent handling of a URI can\n   be postponed until\
    \ the scheme-dependent semantics are needed.  We use\n   the term URL below when\
    \ describing syntax or semantics that only\n   apply to locators.\n   Although\
    \ many URL schemes are named after protocols, this does not\n   imply that the\
    \ only way to access the URL's resource is via the named\n   protocol.  Gateways,\
    \ proxies, caches, and name resolution services\n   might be used to access some\
    \ resources, independent of the protocol\n   of their origin, and the resolution\
    \ of some URL may require the use\n   of more than one protocol (e.g., both DNS\
    \ and HTTP are typically used\n   to access an \"http\" URL's resource when it\
    \ can't be found in a local\n   cache).\n   A URN differs from a URL in that it's\
    \ primary purpose is persistent\n   labeling of a resource with an identifier.\
    \  That identifier is drawn\n   from one of a set of defined namespaces, each\
    \ of which has its own\n   set name structure and assignment procedures.  The\
    \ \"urn\" scheme has\n   been reserved to establish the requirements for a standardized\
    \ URN\n   namespace, as defined in \"URN Syntax\" [RFC2141] and its related\n\
    \   specifications.\n   Most of the examples in this specification demonstrate\
    \ URL, since\n   they allow the most varied use of the syntax and often have a\n\
    \   hierarchical namespace.  A parser of the URI syntax is capable of\n   parsing\
    \ both URL and URN references as a generic URI; once the scheme\n   is determined,\
    \ the scheme-specific parsing can be performed on the\n   generic URI components.\
    \  In other words, the URI syntax is a superset\n   of the syntax of all URI schemes.\n"
- title: 1.3. Example URI
  contents:
  - "1.3. Example URI\n   The following examples illustrate URI that are in common\
    \ use.\n   ftp://ftp.is.co.za/rfc/rfc1808.txt\n      -- ftp scheme for File Transfer\
    \ Protocol services\n   gopher://spinaltap.micro.umn.edu/00/Weather/California/Los%20Angeles\n\
    \      -- gopher scheme for Gopher and Gopher+ Protocol services\n   http://www.math.uio.no/faq/compression-faq/part1.html\n\
    \      -- http scheme for Hypertext Transfer Protocol services\n   mailto:mduerst@ifi.unizh.ch\n\
    \      -- mailto scheme for electronic mail addresses\n   news:comp.infosystems.www.servers.unix\n\
    \      -- news scheme for USENET news groups and articles\n   telnet://melvyl.ucop.edu/\n\
    \      -- telnet scheme for interactive services via the TELNET Protocol\n"
- title: 1.4. Hierarchical URI and Relative Forms
  contents:
  - "1.4. Hierarchical URI and Relative Forms\n   An absolute identifier refers to\
    \ a resource independent of the\n   context in which the identifier is used. \
    \ In contrast, a relative\n   identifier refers to a resource by describing the\
    \ difference within a\n   hierarchical namespace between the current context and\
    \ an absolute\n   identifier of the resource.\n   Some URI schemes support a hierarchical\
    \ naming system, where the\n   hierarchy of the name is denoted by a \"/\" delimiter\
    \ separating the\n   components in the scheme. This document defines a scheme-independent\n\
    \   `relative' form of URI reference that can be used in conjunction with\n  \
    \ a `base' URI (of a hierarchical scheme) to produce another URI. The\n   syntax\
    \ of hierarchical URI is described in Section 3; the relative\n   URI calculation\
    \ is described in Section 5.\n"
- title: 1.5. URI Transcribability
  contents:
  - "1.5. URI Transcribability\n   The URI syntax was designed with global transcribability\
    \ as one of\n   its main concerns. A URI is a sequence of characters from a very\n\
    \   limited set, i.e. the letters of the basic Latin alphabet, digits,\n   and\
    \ a few special characters.  A URI may be represented in a variety\n   of ways:\
    \ e.g., ink on paper, pixels on a screen, or a sequence of\n   octets in a coded\
    \ character set.  The interpretation of a URI depends\n   only on the characters\
    \ used and not how those characters are\n   represented in a network protocol.\n\
    \   The goal of transcribability can be described by a simple scenario.\n   Imagine\
    \ two colleagues, Sam and Kim, sitting in a pub at an\n   international conference\
    \ and exchanging research ideas.  Sam asks Kim\n   for a location to get more\
    \ information, so Kim writes the URI for the\n   research site on a napkin.  Upon\
    \ returning home, Sam takes out the\n   napkin and types the URI into a computer,\
    \ which then retrieves the\n   information to which Kim referred.\n   There are\
    \ several design concerns revealed by the scenario:\n      o  A URI is a sequence\
    \ of characters, which is not always\n         represented as a sequence of octets.\n\
    \      o  A URI may be transcribed from a non-network source, and thus\n     \
    \    should consist of characters that are most likely to be able to\n       \
    \  be typed into a computer, within the constraints imposed by\n         keyboards\
    \ (and related input devices) across languages and\n         locales.\n      o\
    \  A URI often needs to be remembered by people, and it is easier\n         for\
    \ people to remember a URI when it consists of meaningful\n         components.\n\
    \   These design concerns are not always in alignment.  For example, it\n   is\
    \ often the case that the most meaningful name for a URI component\n   would require\
    \ characters that cannot be typed into some systems.  The\n   ability to transcribe\
    \ the resource identifier from one medium to\n   another was considered more important\
    \ than having its URI consist of\n   the most meaningful of components.  In local\
    \ and regional contexts\n   and with improving technology, users might benefit\
    \ from being able to\n   use a wider range of characters; such use is not defined\
    \ in this\n   document.\n"
- title: 1.6. Syntax Notation and Common Elements
  contents:
  - "1.6. Syntax Notation and Common Elements\n   This document uses two conventions\
    \ to describe and define the syntax\n   for URI.  The first, called the layout\
    \ form, is a general description\n   of the order of components and component\
    \ separators, as in\n      <first>/<second>;<third>?<fourth>\n   The component\
    \ names are enclosed in angle-brackets and any characters\n   outside angle-brackets\
    \ are literal separators.  Whitespace should be\n   ignored.  These descriptions\
    \ are used informally and do not define\n   the syntax requirements.\n   The second\
    \ convention is a BNF-like grammar, used to define the\n   formal URI syntax.\
    \  The grammar is that of [RFC822], except that \"|\"\n   is used to designate\
    \ alternatives.  Briefly, rules are separated from\n   definitions by an equal\
    \ \"=\", indentation is used to continue a rule\n   definition over more than\
    \ one line, literals are quoted with \"\",\n   parentheses \"(\" and \")\" are\
    \ used to group elements, optional elements\n   are enclosed in \"[\" and \"]\"\
    \ brackets, and elements may be preceded\n   with <n>* to designate n or more\
    \ repetitions of the following\n   element; n defaults to 0.\n   Unlike many specifications\
    \ that use a BNF-like grammar to define the\n   bytes (octets) allowed by a protocol,\
    \ the URI grammar is defined in\n   terms of characters.  Each literal in the\
    \ grammar corresponds to the\n   character it represents, rather than to the octet\
    \ encoding of that\n   character in any particular coded character set.  How a\
    \ URI is\n   represented in terms of bits and bytes on the wire is dependent upon\n\
    \   the character encoding of the protocol used to transport it, or the\n   charset\
    \ of the document which contains it.\n   The following definitions are common\
    \ to many elements:\n      alpha    = lowalpha | upalpha\n      lowalpha = \"\
    a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"h\" | \"i\" |\n      \
    \           \"j\" | \"k\" | \"l\" | \"m\" | \"n\" | \"o\" | \"p\" | \"q\" | \"\
    r\" |\n                 \"s\" | \"t\" | \"u\" | \"v\" | \"w\" | \"x\" | \"y\"\
    \ | \"z\"\n      upalpha  = \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\" | \"\
    G\" | \"H\" | \"I\" |\n                 \"J\" | \"K\" | \"L\" | \"M\" | \"N\"\
    \ | \"O\" | \"P\" | \"Q\" | \"R\" |\n                 \"S\" | \"T\" | \"U\" |\
    \ \"V\" | \"W\" | \"X\" | \"Y\" | \"Z\"\n      digit    = \"0\" | \"1\" | \"2\"\
    \ | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" |\n                 \"8\" | \"9\"\n\
    \      alphanum = alpha | digit\n   The complete URI syntax is collected in Appendix\
    \ A.\n"
- title: 2. URI Characters and Escape Sequences
  contents:
  - "2. URI Characters and Escape Sequences\n   URI consist of a restricted set of\
    \ characters, primarily chosen to\n   aid transcribability and usability both\
    \ in computer systems and in\n   non-computer communications. Characters used\
    \ conventionally as\n   delimiters around URI were excluded.  The restricted set\
    \ of\n   characters consists of digits, letters, and a few graphic symbols\n \
    \  were chosen from those common to most of the character encodings and\n   input\
    \ facilities available to Internet users.\n      uric          = reserved | unreserved\
    \ | escaped\n   Within a URI, characters are either used as delimiters, or to\n\
    \   represent strings of data (octets) within the delimited portions.\n   Octets\
    \ are either represented directly by a character (using the US-\n   ASCII character\
    \ for that octet [ASCII]) or by an escape encoding.\n   This representation is\
    \ elaborated below.\n"
- title: 2.1 URI and non-ASCII characters
  contents:
  - "2.1 URI and non-ASCII characters\n   The relationship between URI and characters\
    \ has been a source of\n   confusion for characters that are not part of US-ASCII.\
    \ To describe\n   the relationship, it is useful to distinguish between a \"character\"\
    \n   (as a distinguishable semantic entity) and an \"octet\" (an 8-bit\n   byte).\
    \ There are two mappings, one from URI characters to octets, and\n   a second\
    \ from octets to original characters:\n   URI character sequence->octet sequence->original\
    \ character sequence\n   A URI is represented as a sequence of characters, not\
    \ as a sequence\n   of octets. That is because URI might be \"transported\" by\
    \ means that\n   are not through a computer network, e.g., printed on paper, read\
    \ over\n   the radio, etc.\n   A URI scheme may define a mapping from URI characters\
    \ to octets;\n   whether this is done depends on the scheme. Commonly, within\
    \ a\n   delimited component of a URI, a sequence of characters may be used to\n\
    \   represent a sequence of octets. For example, the character \"a\"\n   represents\
    \ the octet 97 (decimal), while the character sequence \"%\",\n   \"0\", \"a\"\
    \ represents the octet 10 (decimal).\n   There is a second translation for some\
    \ resources: the sequence of\n   octets defined by a component of the URI is subsequently\
    \ used to\n   represent a sequence of characters. A 'charset' defines this mapping.\n\
    \   There are many charsets in use in Internet protocols. For example,\n   UTF-8\
    \ [UTF-8] defines a mapping from sequences of octets to sequences\n   of characters\
    \ in the repertoire of ISO 10646.\n   In the simplest case, the original character\
    \ sequence contains only\n   characters that are defined in US-ASCII, and the\
    \ two levels of\n   mapping are simple and easily invertible: each 'original character'\n\
    \   is represented as the octet for the US-ASCII code for it, which is,\n   in\
    \ turn, represented as either the US-ASCII character, or else the\n   \"%\" escape\
    \ sequence for that octet.\n   For original character sequences that contain non-ASCII\
    \ characters,\n   however, the situation is more difficult. Internet protocols\
    \ that\n   transmit octet sequences intended to represent character sequences\n\
    \   are expected to provide some way of identifying the charset used, if\n   there\
    \ might be more than one [RFC2277].  However, there is currently\n   no provision\
    \ within the generic URI syntax to accomplish this\n   identification. An individual\
    \ URI scheme may require a single\n   charset, define a default charset, or provide\
    \ a way to indicate the\n   charset used.\n   It is expected that a systematic\
    \ treatment of character encoding\n   within URI will be developed as a future\
    \ modification of this\n   specification.\n"
- title: 2.2. Reserved Characters
  contents:
  - "2.2. Reserved Characters\n   Many URI include components consisting of or delimited\
    \ by, certain\n   special characters.  These characters are called \"reserved\"\
    , since\n   their usage within the URI component is limited to their reserved\n\
    \   purpose.  If the data for a URI component would conflict with the\n   reserved\
    \ purpose, then the conflicting data must be escaped before\n   forming the URI.\n\
    \      reserved    = \";\" | \"/\" | \"?\" | \":\" | \"@\" | \"&\" | \"=\" | \"\
    +\" |\n                    \"$\" | \",\"\n   The \"reserved\" syntax class above\
    \ refers to those characters that are\n   allowed within a URI, but which may\
    \ not be allowed within a\n   particular component of the generic URI syntax;\
    \ they are used as\n   delimiters of the components described in Section 3.\n\
    \   Characters in the \"reserved\" set are not reserved in all contexts.\n   The\
    \ set of characters actually reserved within any given URI\n   component is defined\
    \ by that component. In general, a character is\n   reserved if the semantics\
    \ of the URI changes if the character is\n   replaced with its escaped US-ASCII\
    \ encoding.\n"
- title: 2.3. Unreserved Characters
  contents:
  - "2.3. Unreserved Characters\n   Data characters that are allowed in a URI but\
    \ do not have a reserved\n   purpose are called unreserved.  These include upper\
    \ and lower case\n   letters, decimal digits, and a limited set of punctuation\
    \ marks and\n   symbols.\n      unreserved  = alphanum | mark\n      mark    \
    \    = \"-\" | \"_\" | \".\" | \"!\" | \"~\" | \"*\" | \"'\" | \"(\" | \")\"\n\
    \   Unreserved characters can be escaped without changing the semantics\n   of\
    \ the URI, but this should not be done unless the URI is being used\n   in a context\
    \ that does not allow the unescaped character to appear.\n"
- title: 2.4. Escape Sequences
  contents:
  - "2.4. Escape Sequences\n   Data must be escaped if it does not have a representation\
    \ using an\n   unreserved character; this includes data that does not correspond\
    \ to\n   a printable character of the US-ASCII coded character set, or that\n\
    \   corresponds to any US-ASCII character that is disallowed, as\n   explained\
    \ below.\n"
- title: 2.4.1. Escaped Encoding
  contents:
  - "2.4.1. Escaped Encoding\n   An escaped octet is encoded as a character triplet,\
    \ consisting of the\n   percent character \"%\" followed by the two hexadecimal\
    \ digits\n   representing the octet code. For example, \"%20\" is the escaped\n\
    \   encoding for the US-ASCII space character.\n      escaped     = \"%\" hex\
    \ hex\n      hex         = digit | \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"\
    F\" |\n                            \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"\
    f\"\n"
- title: 2.4.2. When to Escape and Unescape
  contents:
  - "2.4.2. When to Escape and Unescape\n   A URI is always in an \"escaped\" form,\
    \ since escaping or unescaping a\n   completed URI might change its semantics.\
    \  Normally, the only time\n   escape encodings can safely be made is when the\
    \ URI is being created\n   from its component parts; each component may have its\
    \ own set of\n   characters that are reserved, so only the mechanism responsible\
    \ for\n   generating or interpreting that component can determine whether or\n\
    \   not escaping a character will change its semantics. Likewise, a URI\n   must\
    \ be separated into its components before the escaped characters\n   within those\
    \ components can be safely decoded.\n   In some cases, data that could be represented\
    \ by an unreserved\n   character may appear escaped; for example, some of the\
    \ unreserved\n   \"mark\" characters are automatically escaped by some systems.\
    \  If the\n   given URI scheme defines a canonicalization algorithm, then\n  \
    \ unreserved characters may be unescaped according to that algorithm.\n   For\
    \ example, \"%7e\" is sometimes used instead of \"~\" in an http URL\n   path,\
    \ but the two are equivalent for an http URL.\n   Because the percent \"%\" character\
    \ always has the reserved purpose of\n   being the escape indicator, it must be\
    \ escaped as \"%25\" in order to\n   be used as data within a URI.  Implementers\
    \ should be careful not to\n   escape or unescape the same string more than once,\
    \ since unescaping\n   an already unescaped string might lead to misinterpreting\
    \ a percent\n   data character as another escaped character, or vice versa in\
    \ the\n   case of escaping an already escaped string.\n"
- title: 2.4.3. Excluded US-ASCII Characters
  contents:
  - "2.4.3. Excluded US-ASCII Characters\n   Although they are disallowed within the\
    \ URI syntax, we include here a\n   description of those US-ASCII characters that\
    \ have been excluded and\n   the reasons for their exclusion.\n   The control\
    \ characters in the US-ASCII coded character set are not\n   used within a URI,\
    \ both because they are non-printable and because\n   they are likely to be misinterpreted\
    \ by some control mechanisms.\n   control     = <US-ASCII coded characters 00-1F\
    \ and 7F hexadecimal>\n   The space character is excluded because significant\
    \ spaces may\n   disappear and insignificant spaces may be introduced when URI\
    \ are\n   transcribed or typeset or subjected to the treatment of word-\n   processing\
    \ programs.  Whitespace is also used to delimit URI in many\n   contexts.\n  \
    \ space       = <US-ASCII coded character 20 hexadecimal>\n   The angle-bracket\
    \ \"<\" and \">\" and double-quote (\") characters are\n   excluded because they\
    \ are often used as the delimiters around URI in\n   text documents and protocol\
    \ fields.  The character \"#\" is excluded\n   because it is used to delimit a\
    \ URI from a fragment identifier in URI\n   references (Section 4). The percent\
    \ character \"%\" is excluded because\n   it is used for the encoding of escaped\
    \ characters.\n   delims      = \"<\" | \">\" | \"#\" | \"%\" | <\">\n   Other\
    \ characters are excluded because gateways and other transport\n   agents are\
    \ known to sometimes modify such characters, or they are\n   used as delimiters.\n\
    \   unwise      = \"{\" | \"}\" | \"|\" | \"\\\" | \"^\" | \"[\" | \"]\" | \"\
    `\"\n   Data corresponding to excluded characters must be escaped in order to\n\
    \   be properly represented within a URI.\n"
- title: 3. URI Syntactic Components
  contents:
  - "3. URI Syntactic Components\n   The URI syntax is dependent upon the scheme.\
    \  In general, absolute\n   URI are written as follows:\n      <scheme>:<scheme-specific-part>\n\
    \   An absolute URI contains the name of the scheme being used (<scheme>)\n  \
    \ followed by a colon (\":\") and then a string (the <scheme-specific-\n   part>)\
    \ whose interpretation depends on the scheme.\n   The URI syntax does not require\
    \ that the scheme-specific-part have\n   any general structure or set of semantics\
    \ which is common among all\n   URI.  However, a subset of URI do share a common\
    \ syntax for\n   representing hierarchical relationships within the namespace.\
    \  This\n   \"generic URI\" syntax consists of a sequence of four main components:\n\
    \      <scheme>://<authority><path>?<query>\n   each of which, except <scheme>,\
    \ may be absent from a particular URI.\n   For example, some URI schemes do not\
    \ allow an <authority> component,\n   and others do not use a <query> component.\n\
    \      absoluteURI   = scheme \":\" ( hier_part | opaque_part )\n   URI that are\
    \ hierarchical in nature use the slash \"/\" character for\n   separating hierarchical\
    \ components.  For some file systems, a \"/\"\n   character (used to denote the\
    \ hierarchical structure of a URI) is the\n   delimiter used to construct a file\
    \ name hierarchy, and thus the URI\n   path will look similar to a file pathname.\
    \  This does NOT imply that\n   the resource is a file or that the URI maps to\
    \ an actual filesystem\n   pathname.\n      hier_part     = ( net_path | abs_path\
    \ ) [ \"?\" query ]\n      net_path      = \"//\" authority [ abs_path ]\n   \
    \   abs_path      = \"/\"  path_segments\n   URI that do not make use of the slash\
    \ \"/\" character for separating\n   hierarchical components are considered opaque\
    \ by the generic URI\n   parser.\n      opaque_part   = uric_no_slash *uric\n\
    \      uric_no_slash = unreserved | escaped | \";\" | \"?\" | \":\" | \"@\" |\n\
    \                      \"&\" | \"=\" | \"+\" | \"$\" | \",\"\n   We use the term\
    \ <path> to refer to both the <abs_path> and\n   <opaque_part> constructs, since\
    \ they are mutually exclusive for any\n   given URI and can be parsed as a single\
    \ component.\n"
- title: 3.1. Scheme Component
  contents:
  - "3.1. Scheme Component\n   Just as there are many different methods of access\
    \ to resources,\n   there are a variety of schemes for identifying such resources.\
    \  The\n   URI syntax consists of a sequence of components separated by reserved\n\
    \   characters, with the first component defining the semantics for the\n   remainder\
    \ of the URI string.\n   Scheme names consist of a sequence of characters beginning\
    \ with a\n   lower case letter and followed by any combination of lower case\n\
    \   letters, digits, plus (\"+\"), period (\".\"), or hyphen (\"-\").  For\n \
    \  resiliency, programs interpreting URI should treat upper case letters\n   as\
    \ equivalent to lower case in scheme names (e.g., allow \"HTTP\" as\n   well as\
    \ \"http\").\n      scheme        = alpha *( alpha | digit | \"+\" | \"-\" | \"\
    .\" )\n   Relative URI references are distinguished from absolute URI in that\n\
    \   they do not begin with a scheme name.  Instead, the scheme is\n   inherited\
    \ from the base URI, as described in Section 5.2.\n"
- title: 3.2. Authority Component
  contents:
  - "3.2. Authority Component\n   Many URI schemes include a top hierarchical element\
    \ for a naming\n   authority, such that the namespace defined by the remainder\
    \ of the\n   URI is governed by that authority.  This authority component is\n\
    \   typically defined by an Internet-based server or a scheme-specific\n   registry\
    \ of naming authorities.\n      authority     = server | reg_name\n   The authority\
    \ component is preceded by a double slash \"//\" and is\n   terminated by the\
    \ next slash \"/\", question-mark \"?\", or by the end of\n   the URI.  Within\
    \ the authority component, the characters \";\", \":\",\n   \"@\", \"?\", and\
    \ \"/\" are reserved.\n   An authority component is not required for a URI scheme\
    \ to make use\n   of relative references.  A base URI without an authority component\n\
    \   implies that any relative reference will also be without an authority\n  \
    \ component.\n"
- title: 3.2.1. Registry-based Naming Authority
  contents:
  - "3.2.1. Registry-based Naming Authority\n   The structure of a registry-based\
    \ naming authority is specific to the\n   URI scheme, but constrained to the allowed\
    \ characters for an\n   authority component.\n      reg_name      = 1*( unreserved\
    \ | escaped | \"$\" | \",\" |\n                          \";\" | \":\" | \"@\"\
    \ | \"&\" | \"=\" | \"+\" )\n"
- title: 3.2.2. Server-based Naming Authority
  contents:
  - "3.2.2. Server-based Naming Authority\n   URL schemes that involve the direct\
    \ use of an IP-based protocol to a\n   specified server on the Internet use a\
    \ common syntax for the server\n   component of the URI's scheme-specific data:\n\
    \      <userinfo>@<host>:<port>\n   where <userinfo> may consist of a user name\
    \ and, optionally, scheme-\n   specific information about how to gain authorization\
    \ to access the\n   server.  The parts \"<userinfo>@\" and \":<port>\" may be\
    \ omitted.\n      server        = [ [ userinfo \"@\" ] hostport ]\n   The user\
    \ information, if present, is followed by a commercial at-sign\n   \"@\".\n  \
    \    userinfo      = *( unreserved | escaped |\n                         \";\"\
    \ | \":\" | \"&\" | \"=\" | \"+\" | \"$\" | \",\" )\n   Some URL schemes use the\
    \ format \"user:password\" in the userinfo\n   field. This practice is NOT RECOMMENDED,\
    \ because the passing of\n   authentication information in clear text (such as\
    \ URI) has proven to\n   be a security risk in almost every case where it has\
    \ been used.\n   The host is a domain name of a network host, or its IPv4 address\
    \ as a\n   set of four decimal digit groups separated by \".\".  Literal IPv6\n\
    \   addresses are not supported.\n      hostport      = host [ \":\" port ]\n\
    \      host          = hostname | IPv4address\n      hostname      = *( domainlabel\
    \ \".\" ) toplabel [ \".\" ]\n      domainlabel   = alphanum | alphanum *( alphanum\
    \ | \"-\" ) alphanum\n      toplabel      = alpha | alpha *( alphanum | \"-\"\
    \ ) alphanum\n      IPv4address   = 1*digit \".\" 1*digit \".\" 1*digit \".\"\
    \ 1*digit\n      port          = *digit\n   Hostnames take the form described\
    \ in Section 3 of [RFC1034] and\n   Section 2.1 of [RFC1123]: a sequence of domain\
    \ labels separated by\n   \".\", each domain label starting and ending with an\
    \ alphanumeric\n   character and possibly also containing \"-\" characters.  The\
    \ rightmost\n   domain label of a fully qualified domain name will never start\
    \ with a\n   digit, thus syntactically distinguishing domain names from IPv4\n\
    \   addresses, and may be followed by a single \".\" if it is necessary to\n \
    \  distinguish between the complete domain name and any local domain.\n   To actually\
    \ be \"Uniform\" as a resource locator, a URL hostname should\n   be a fully qualified\
    \ domain name.  In practice, however, the host\n   component may be a local domain\
    \ literal.\n      Note: A suitable representation for including a literal IPv6\n\
    \      address as the host part of a URL is desired, but has not yet been\n  \
    \    determined or implemented in practice.\n   The port is the network port number\
    \ for the server.  Most schemes\n   designate protocols that have a default port\
    \ number.  Another port\n   number may optionally be supplied, in decimal, separated\
    \ from the\n   host by a colon.  If the port is omitted, the default port number\
    \ is\n   assumed.\n"
- title: 3.3. Path Component
  contents:
  - "3.3. Path Component\n   The path component contains data, specific to the authority\
    \ (or the\n   scheme if there is no authority component), identifying the resource\n\
    \   within the scope of that scheme and authority.\n      path          = [ abs_path\
    \ | opaque_part ]\n      path_segments = segment *( \"/\" segment )\n      segment\
    \       = *pchar *( \";\" param )\n      param         = *pchar\n      pchar \
    \        = unreserved | escaped |\n                      \":\" | \"@\" | \"&\"\
    \ | \"=\" | \"+\" | \"$\" | \",\"\n   The path may consist of a sequence of path\
    \ segments separated by a\n   single slash \"/\" character.  Within a path segment,\
    \ the characters\n   \"/\", \";\", \"=\", and \"?\" are reserved.  Each path segment\
    \ may include a\n   sequence of parameters, indicated by the semicolon \";\" character.\n\
    \   The parameters are not significant to the parsing of relative\n   references.\n"
- title: 3.4. Query Component
  contents:
  - "3.4. Query Component\n   The query component is a string of information to be\
    \ interpreted by\n   the resource.\n      query         = *uric\n   Within a query\
    \ component, the characters \";\", \"/\", \"?\", \":\", \"@\",\n   \"&\", \"=\"\
    , \"+\", \",\", and \"$\" are reserved.\n"
- title: 4. URI References
  contents:
  - "4. URI References\n   The term \"URI-reference\" is used here to denote the common\
    \ usage of a\n   resource identifier.  A URI reference may be absolute or relative,\n\
    \   and may have additional information attached in the form of a\n   fragment\
    \ identifier.  However, \"the URI\" that results from such a\n   reference includes\
    \ only the absolute URI after the fragment\n   identifier (if any) is removed\
    \ and after any relative URI is resolved\n   to its absolute form.  Although it\
    \ is possible to limit the\n   discussion of URI syntax and semantics to that\
    \ of the absolute\n   result, most usage of URI is within general URI references,\
    \ and it is\n   impossible to obtain the URI from such a reference without also\n\
    \   parsing the fragment and resolving the relative form.\n      URI-reference\
    \ = [ absoluteURI | relativeURI ] [ \"#\" fragment ]\n   The syntax for relative\
    \ URI is a shortened form of that for absolute\n   URI, where some prefix of the\
    \ URI is missing and certain path\n   components (\".\" and \"..\") have a special\
    \ meaning when, and only when,\n   interpreting a relative path.  The relative\
    \ URI syntax is defined in\n   Section 5.\n"
- title: 4.1. Fragment Identifier
  contents:
  - "4.1. Fragment Identifier\n   When a URI reference is used to perform a retrieval\
    \ action on the\n   identified resource, the optional fragment identifier, separated\
    \ from\n   the URI by a crosshatch (\"#\") character, consists of additional\n\
    \   reference information to be interpreted by the user agent after the\n   retrieval\
    \ action has been successfully completed.  As such, it is not\n   part of a URI,\
    \ but is often used in conjunction with a URI.\n      fragment      = *uric\n\
    \   The semantics of a fragment identifier is a property of the data\n   resulting\
    \ from a retrieval action, regardless of the type of URI used\n   in the reference.\
    \  Therefore, the format and interpretation of\n   fragment identifiers is dependent\
    \ on the media type [RFC2046] of the\n   retrieval result.  The character restrictions\
    \ described in Section 2\n   for URI also apply to the fragment in a URI-reference.\
    \  Individual\n   media types may define additional restrictions or structure\
    \ within\n   the fragment for specifying different types of \"partial views\"\
    \ that\n   can be identified within that media type.\n   A fragment identifier\
    \ is only meaningful when a URI reference is\n   intended for retrieval and the\
    \ result of that retrieval is a document\n   for which the identified fragment\
    \ is consistently defined.\n"
- title: 4.2. Same-document References
  contents:
  - "4.2. Same-document References\n   A URI reference that does not contain a URI\
    \ is a reference to the\n   current document.  In other words, an empty URI reference\
    \ within a\n   document is interpreted as a reference to the start of that document,\n\
    \   and a reference containing only a fragment identifier is a reference\n   to\
    \ the identified fragment of that document.  Traversal of such a\n   reference\
    \ should not result in an additional retrieval action.\n   However, if the URI\
    \ reference occurs in a context that is always\n   intended to result in a new\
    \ request, as in the case of HTML's FORM\n   element, then an empty URI reference\
    \ represents the base URI of the\n   current document and should be replaced by\
    \ that URI when transformed\n   into a request.\n"
- title: 4.3. Parsing a URI Reference
  contents:
  - "4.3. Parsing a URI Reference\n   A URI reference is typically parsed according\
    \ to the four main\n   components and fragment identifier in order to determine\
    \ what\n   components are present and whether the reference is relative or\n \
    \  absolute.  The individual components are then parsed for their\n   subparts\
    \ and, if not opaque, to verify their validity.\n   Although the BNF defines what\
    \ is allowed in each component, it is\n   ambiguous in terms of differentiating\
    \ between an authority component\n   and a path component that begins with two\
    \ slash characters.  The\n   greedy algorithm is used for disambiguation: the\
    \ left-most matching\n   rule soaks up as much of the URI reference string as\
    \ it is capable of\n   matching.  In other words, the authority component wins.\n\
    \   Readers familiar with regular expressions should see Appendix B for a\n  \
    \ concrete parsing example and test oracle.\n"
- title: 5. Relative URI References
  contents:
  - "5. Relative URI References\n   It is often the case that a group or \"tree\"\
    \ of documents has been\n   constructed to serve a common purpose; the vast majority\
    \ of URI in\n   these documents point to resources within the tree rather than\n\
    \   outside of it.  Similarly, documents located at a particular site are\n  \
    \ much more likely to refer to other resources at that site than to\n   resources\
    \ at remote sites.\n   Relative addressing of URI allows document trees to be\
    \ partially\n   independent of their location and access scheme.  For instance,\
    \ it is\n   possible for a single set of hypertext documents to be simultaneously\n\
    \   accessible and traversable via each of the \"file\", \"http\", and \"ftp\"\
    \n   schemes if the documents refer to each other using relative URI.\n   Furthermore,\
    \ such document trees can be moved, as a whole, without\n   changing any of the\
    \ relative references.  Experience within the WWW\n   has demonstrated that the\
    \ ability to perform relative referencing is\n   necessary for the long-term usability\
    \ of embedded URI.\n   The syntax for relative URI takes advantage of the <hier_part>\
    \ syntax\n   of <absoluteURI> (Section 3) in order to express a reference that\
    \ is\n   relative to the namespace of another hierarchical URI.\n      relativeURI\
    \   = ( net_path | abs_path | rel_path ) [ \"?\" query ]\n   A relative reference\
    \ beginning with two slash characters is termed a\n   network-path reference,\
    \ as defined by <net_path> in Section 3.  Such\n   references are rarely used.\n\
    \   A relative reference beginning with a single slash character is\n   termed\
    \ an absolute-path reference, as defined by <abs_path> in\n   Section 3.\n   A\
    \ relative reference that does not begin with a scheme name or a\n   slash character\
    \ is termed a relative-path reference.\n      rel_path      = rel_segment [ abs_path\
    \ ]\n      rel_segment   = 1*( unreserved | escaped |\n                      \
    \    \";\" | \"@\" | \"&\" | \"=\" | \"+\" | \"$\" | \",\" )\n   Within a relative-path\
    \ reference, the complete path segments \".\" and\n   \"..\" have special meanings:\
    \ \"the current hierarchy level\" and \"the\n   level above this hierarchy level\"\
    , respectively.  Although this is\n   very similar to their use within Unix-based\
    \ filesystems to indicate\n   directory levels, these path components are only\
    \ considered special\n   when resolving a relative-path reference to its absolute\
    \ form\n   (Section 5.2).\n   Authors should be aware that a path segment which\
    \ contains a colon\n   character cannot be used as the first segment of a relative\
    \ URI path\n   (e.g., \"this:that\"), because it would be mistaken for a scheme\
    \ name.\n   It is therefore necessary to precede such segments with other\n  \
    \ segments (e.g., \"./this:that\") in order for them to be referenced as\n   a\
    \ relative path.\n   It is not necessary for all URI within a given scheme to\
    \ be\n   restricted to the <hier_part> syntax, since the hierarchical\n   properties\
    \ of that syntax are only necessary when relative URI are\n   used within a particular\
    \ document.  Documents can only make use of\n   relative URI when their base URI\
    \ fits within the <hier_part> syntax.\n   It is assumed that any document which\
    \ contains a relative reference\n   will also have a base URI that obeys the syntax.\
    \  In other words,\n   relative URI cannot be used within a document that has\
    \ an unsuitable\n   base URI.\n   Some URI schemes do not allow a hierarchical\
    \ syntax matching the\n   <hier_part> syntax, and thus cannot use relative references.\n"
- title: 5.1. Establishing a Base URI
  contents:
  - "5.1. Establishing a Base URI\n   The term \"relative URI\" implies that there\
    \ exists some absolute \"base\n   URI\" against which the relative reference is\
    \ applied.  Indeed, the\n   base URI is necessary to define the semantics of any\
    \ relative URI\n   reference; without it, a relative reference is meaningless.\
    \  In order\n   for relative URI to be usable within a document, the base URI\
    \ of that\n   document must be known to the parser.\n   The base URI of a document\
    \ can be established in one of four ways,\n   listed below in order of precedence.\
    \  The order of precedence can be\n   thought of in terms of layers, where the\
    \ innermost defined base URI\n   has the highest precedence.  This can be visualized\
    \ graphically as:\n      .----------------------------------------------------------.\n\
    \      |  .----------------------------------------------------.  |\n      | \
    \ |  .----------------------------------------------.  |  |\n      |  |  |  .----------------------------------------.\
    \  |  |  |\n      |  |  |  |  .----------------------------------.  |  |  |  |\n\
    \      |  |  |  |  |       <relative_reference>       |  |  |  |  |\n      | \
    \ |  |  |  `----------------------------------'  |  |  |  |\n      |  |  |  |\
    \ (5.1.1) Base URI embedded in the       |  |  |  |\n      |  |  |  |        \
    \ document's content             |  |  |  |\n      |  |  |  `----------------------------------------'\
    \  |  |  |\n      |  |  | (5.1.2) Base URI of the encapsulating entity |  |  |\n\
    \      |  |  |         (message, document, or none).        |  |  |\n      | \
    \ |  `----------------------------------------------'  |  |\n      |  | (5.1.3)\
    \ URI used to retrieve the entity            |  |\n      |  `----------------------------------------------------'\
    \  |\n      | (5.1.4) Default Base URI is application-dependent        |\n   \
    \   `----------------------------------------------------------'\n"
- title: 5.1.1. Base URI within Document Content
  contents:
  - "5.1.1. Base URI within Document Content\n   Within certain document media types,\
    \ the base URI of the document can\n   be embedded within the content itself such\
    \ that it can be readily\n   obtained by a parser.  This can be useful for descriptive\
    \ documents,\n   such as tables of content, which may be transmitted to others\
    \ through\n   protocols other than their usual retrieval context (e.g., E-Mail\
    \ or\n   USENET news).\n   It is beyond the scope of this document to specify\
    \ how, for each\n   media type, the base URI can be embedded.  It is assumed that\
    \ user\n   agents manipulating such media types will be able to obtain the\n \
    \  appropriate syntax from that media type's specification.  An example\n   of\
    \ how the base URI can be embedded in the Hypertext Markup Language\n   (HTML)\
    \ [RFC1866] is provided in Appendix D.\n   A mechanism for embedding the base\
    \ URI within MIME container types\n   (e.g., the message and multipart types)\
    \ is defined by MHTML\n   [RFC2110].  Protocols that do not use the MIME message\
    \ header syntax,\n   but which do allow some form of tagged metainformation to\
    \ be included\n   within messages, may define their own syntax for defining the\
    \ base\n   URI as part of a message.\n"
- title: 5.1.2. Base URI from the Encapsulating Entity
  contents:
  - "5.1.2. Base URI from the Encapsulating Entity\n   If no base URI is embedded,\
    \ the base URI of a document is defined by\n   the document's retrieval context.\
    \  For a document that is enclosed\n   within another entity (such as a message\
    \ or another document), the\n   retrieval context is that entity; thus, the default\
    \ base URI of the\n   document is the base URI of the entity in which the document\
    \ is\n   encapsulated.\n"
- title: 5.1.3. Base URI from the Retrieval URI
  contents:
  - "5.1.3. Base URI from the Retrieval URI\n   If no base URI is embedded and the\
    \ document is not encapsulated\n   within some other entity (e.g., the top level\
    \ of a composite entity),\n   then, if a URI was used to retrieve the base document,\
    \ that URI shall\n   be considered the base URI.  Note that if the retrieval was\
    \ the\n   result of a redirected request, the last URI used (i.e., that which\n\
    \   resulted in the actual retrieval of the document) is the base URI.\n"
- title: 5.1.4. Default Base URI
  contents:
  - "5.1.4. Default Base URI\n   If none of the conditions described in Sections 5.1.1--5.1.3\
    \ apply,\n   then the base URI is defined by the context of the application.\n\
    \   Since this definition is necessarily application-dependent, failing\n   to\
    \ define the base URI using one of the other methods may result in\n   the same\
    \ content being interpreted differently by different types of\n   application.\n\
    \   It is the responsibility of the distributor(s) of a document\n   containing\
    \ relative URI to ensure that the base URI for that document\n   can be established.\
    \  It must be emphasized that relative URI cannot\n   be used reliably in situations\
    \ where the document's base URI is not\n   well-defined.\n"
- title: 5.2. Resolving Relative References to Absolute Form
  contents:
  - "5.2. Resolving Relative References to Absolute Form\n   This section describes\
    \ an example algorithm for resolving URI\n   references that might be relative\
    \ to a given base URI.\n   The base URI is established according to the rules\
    \ of Section 5.1 and\n   parsed into the four main components as described in\
    \ Section 3.  Note\n   that only the scheme component is required to be present\
    \ in the base\n   URI; the other components may be empty or undefined.  A component\
    \ is\n   undefined if its preceding separator does not appear in the URI\n   reference;\
    \ the path component is never undefined, though it may be\n   empty.  The base\
    \ URI's query component is not used by the resolution\n   algorithm and may be\
    \ discarded.\n   For each URI reference, the following steps are performed in\
    \ order:\n   1) The URI reference is parsed into the potential four components\
    \ and\n      fragment identifier, as described in Section 4.3.\n   2) If the path\
    \ component is empty and the scheme, authority, and\n      query components are\
    \ undefined, then it is a reference to the\n      current document and we are\
    \ done.  Otherwise, the reference URI's\n      query and fragment components are\
    \ defined as found (or not found)\n      within the URI reference and not inherited\
    \ from the base URI.\n   3) If the scheme component is defined, indicating that\
    \ the reference\n      starts with a scheme name, then the reference is interpreted\
    \ as an\n      absolute URI and we are done.  Otherwise, the reference URI's\n\
    \      scheme is inherited from the base URI's scheme component.\n      Due to\
    \ a loophole in prior specifications [RFC1630], some parsers\n      allow the\
    \ scheme name to be present in a relative URI if it is the\n      same as the\
    \ base URI scheme.  Unfortunately, this can conflict\n      with the correct parsing\
    \ of non-hierarchical URI.  For backwards\n      compatibility, an implementation\
    \ may work around such references\n      by removing the scheme if it matches\
    \ that of the base URI and the\n      scheme is known to always use the <hier_part>\
    \ syntax.  The parser\n      can then continue with the steps below for the remainder\
    \ of the\n      reference components.  Validating parsers should mark such a\n\
    \      misformed relative reference as an error.\n   4) If the authority component\
    \ is defined, then the reference is a\n      network-path and we skip to step\
    \ 7.  Otherwise, the reference\n      URI's authority is inherited from the base\
    \ URI's authority\n      component, which will also be undefined if the URI scheme\
    \ does not\n      use an authority component.\n   5) If the path component begins\
    \ with a slash character (\"/\"), then\n      the reference is an absolute-path\
    \ and we skip to step 7.\n   6) If this step is reached, then we are resolving\
    \ a relative-path\n      reference.  The relative path needs to be merged with\
    \ the base\n      URI's path.  Although there are many ways to do this, we will\n\
    \      describe a simple method using a separate string buffer.\n      a) All\
    \ but the last segment of the base URI's path component is\n         copied to\
    \ the buffer.  In other words, any characters after the\n         last (right-most)\
    \ slash character, if any, are excluded.\n      b) The reference's path component\
    \ is appended to the buffer\n         string.\n      c) All occurrences of \"\
    ./\", where \".\" is a complete path segment,\n         are removed from the buffer\
    \ string.\n      d) If the buffer string ends with \".\" as a complete path segment,\n\
    \         that \".\" is removed.\n      e) All occurrences of \"<segment>/../\"\
    , where <segment> is a\n         complete path segment not equal to \"..\", are\
    \ removed from the\n         buffer string.  Removal of these path segments is\
    \ performed\n         iteratively, removing the leftmost matching pattern on each\n\
    \         iteration, until no matching pattern remains.\n      f) If the buffer\
    \ string ends with \"<segment>/..\", where <segment>\n         is a complete path\
    \ segment not equal to \"..\", that\n         \"<segment>/..\" is removed.\n \
    \     g) If the resulting buffer string still begins with one or more\n      \
    \   complete path segments of \"..\", then the reference is\n         considered\
    \ to be in error.  Implementations may handle this\n         error by retaining\
    \ these components in the resolved path (i.e.,\n         treating them as part\
    \ of the final URI), by removing them from\n         the resolved path (i.e.,\
    \ discarding relative levels above the\n         root), or by avoiding traversal\
    \ of the reference.\n      h) The remaining buffer string is the reference URI's\
    \ new path\n         component.\n   7) The resulting URI components, including\
    \ any inherited from the\n      base URI, are recombined to give the absolute\
    \ form of the URI\n      reference.  Using pseudocode, this would be\n       \
    \  result = \"\"\n         if scheme is defined then\n             append scheme\
    \ to result\n             append \":\" to result\n         if authority is defined\
    \ then\n             append \"//\" to result\n             append authority to\
    \ result\n         append path to result\n         if query is defined then\n\
    \             append \"?\" to result\n             append query to result\n  \
    \       if fragment is defined then\n             append \"#\" to result\n   \
    \          append fragment to result\n         return result\n      Note that\
    \ we must be careful to preserve the distinction between a\n      component that\
    \ is undefined, meaning that its separator was not\n      present in the reference,\
    \ and a component that is empty, meaning\n      that the separator was present\
    \ and was immediately followed by the\n      next component separator or the end\
    \ of the reference.\n   The above algorithm is intended to provide an example\
    \ by which the\n   output of implementations can be tested -- implementation of\
    \ the\n   algorithm itself is not required.  For example, some systems may find\n\
    \   it more efficient to implement step 6 as a pair of segment stacks\n   being\
    \ merged, rather than as a series of string pattern replacements.\n      Note:\
    \ Some WWW client applications will fail to separate the\n      reference's query\
    \ component from its path component before merging\n      the base and reference\
    \ paths in step 6 above.  This may result in\n      a loss of information if the\
    \ query component contains the strings\n      \"/../\" or \"/./\".\n   Resolution\
    \ examples are provided in Appendix C.\n"
- title: 6. URI Normalization and Equivalence
  contents:
  - "6. URI Normalization and Equivalence\n   In many cases, different URI strings\
    \ may actually identify the\n   identical resource. For example, the host names\
    \ used in URL are\n   actually case insensitive, and the URL <http://www.XEROX.com>\
    \ is\n   equivalent to <http://www.xerox.com>. In general, the rules for\n   equivalence\
    \ and definition of a normal form, if any, are scheme\n   dependent. When a scheme\
    \ uses elements of the common syntax, it will\n   also use the common syntax equivalence\
    \ rules, namely that the scheme\n   and hostname are case insensitive and a URL\
    \ with an explicit \":port\",\n   where the port is the default for the scheme,\
    \ is equivalent to one\n   where the port is elided.\n"
- title: 7. Security Considerations
  contents:
  - "7. Security Considerations\n   A URI does not in itself pose a security threat.\
    \  Users should beware\n   that there is no general guarantee that a URL, which\
    \ at one time\n   located a given resource, will continue to do so.  Nor is there\
    \ any\n   guarantee that a URL will not locate a different resource at some\n\
    \   later point in time, due to the lack of any constraint on how a given\n  \
    \ authority apportions its namespace.  Such a guarantee can only be\n   obtained\
    \ from the person(s) controlling that namespace and the\n   resource in question.\
    \  A specific URI scheme may include additional\n   semantics, such as name persistence,\
    \ if those semantics are required\n   of all naming authorities for that scheme.\n\
    \   It is sometimes possible to construct a URL such that an attempt to\n   perform\
    \ a seemingly harmless, idempotent operation, such as the\n   retrieval of an\
    \ entity associated with the resource, will in fact\n   cause a possibly damaging\
    \ remote operation to occur.  The unsafe URL\n   is typically constructed by specifying\
    \ a port number other than that\n   reserved for the network protocol in question.\
    \  The client\n   unwittingly contacts a site that is in fact running a different\n\
    \   protocol.  The content of the URL contains instructions that, when\n   interpreted\
    \ according to this other protocol, cause an unexpected\n   operation.  An example\
    \ has been the use of a gopher URL to cause an\n   unintended or impersonating\
    \ message to be sent via a SMTP server.\n   Caution should be used when using\
    \ any URL that specifies a port\n   number other than the default for the protocol,\
    \ especially when it is\n   a number within the reserved space.\n   Care should\
    \ be taken when a URL contains escaped delimiters for a\n   given protocol (for\
    \ example, CR and LF characters for telnet\n   protocols) that these are not unescaped\
    \ before transmission.  This\n   might violate the protocol, but avoids the potential\
    \ for such\n   characters to be used to simulate an extra operation or parameter\
    \ in\n   that protocol, which might lead to an unexpected and possibly harmful\n\
    \   remote operation to be performed.\n   It is clearly unwise to use a URL that\
    \ contains a password which is\n   intended to be secret. In particular, the use\
    \ of a password within\n   the 'userinfo' component of a URL is strongly disrecommended\
    \ except\n   in those rare cases where the 'password' parameter is intended to\
    \ be\n   public.\n"
- title: 8. Acknowledgements
  contents:
  - "8. Acknowledgements\n   This document was derived from RFC 1738 [RFC1738] and\
    \ RFC 1808\n   [RFC1808]; the acknowledgements in those specifications still apply.\n\
    \   In addition, contributions by Gisle Aas, Martin Beet, Martin Duerst,\n   Jim\
    \ Gettys, Martijn Koster, Dave Kristol, Daniel LaLiberte, Foteos\n   Macrides,\
    \ James Marshall, Ryan Moats, Keith Moore, and Lauren Wood\n   are gratefully\
    \ acknowledged.\n"
- title: 9. References
  contents:
  - "9. References\n   [RFC2277] Alvestrand, H., \"IETF Policy on Character Sets and\n\
    \             Languages\", BCP 18, RFC 2277, January 1998.\n   [RFC1630] Berners-Lee,\
    \ T., \"Universal Resource Identifiers in WWW: A\n             Unifying Syntax\
    \ for the Expression of Names and Addresses\n             of Objects on the Network\
    \ as used in the World-Wide Web\",\n             RFC 1630, June 1994.\n   [RFC1738]\
    \ Berners-Lee, T., Masinter, L., and M. McCahill, Editors,\n             \"Uniform\
    \ Resource Locators (URL)\", RFC 1738, December 1994.\n   [RFC1866] Berners-Lee\
    \ T., and D. Connolly, \"HyperText Markup Language\n             Specification\
    \ -- 2.0\", RFC 1866, November 1995.\n   [RFC1123] Braden, R., Editor, \"Requirements\
    \ for Internet Hosts --\n             Application and Support\", STD 3, RFC 1123,\
    \ October 1989.\n   [RFC822]  Crocker, D., \"Standard for the Format of ARPA Internet\
    \ Text\n             Messages\", STD 11, RFC 822, August 1982.\n   [RFC1808] Fielding,\
    \ R., \"Relative Uniform Resource Locators\", RFC\n             1808, June 1995.\n\
    \   [RFC2046] Freed, N., and N. Borenstein, \"Multipurpose Internet Mail\n   \
    \          Extensions (MIME) Part Two: Media Types\", RFC 2046,\n            \
    \ November 1996.\n   [RFC1736] Kunze, J., \"Functional Recommendations for Internet\n\
    \             Resource Locators\", RFC 1736, February 1995.\n   [RFC2141] Moats,\
    \ R., \"URN Syntax\", RFC 2141, May 1997.\n   [RFC1034] Mockapetris, P., \"Domain\
    \ Names - Concepts and Facilities\",\n             STD 13, RFC 1034, November\
    \ 1987.\n   [RFC2110] Palme, J., and A. Hopmann, \"MIME E-mail Encapsulation of\n\
    \             Aggregate Documents, such as HTML (MHTML)\", RFC 2110, March\n \
    \            1997.\n   [RFC1737] Sollins, K., and L. Masinter, \"Functional Requirements\
    \ for\n             Uniform Resource Names\", RFC 1737, December 1994.\n   [ASCII]\
    \   US-ASCII. \"Coded Character Set -- 7-bit American Standard\n             Code\
    \ for Information Interchange\", ANSI X3.4-1986.\n   [UTF-8]   Yergeau, F., \"\
    UTF-8, a transformation format of ISO 10646\",\n             RFC 2279, January\
    \ 1998.\n"
- title: 10. Authors' Addresses
  contents:
  - "10. Authors' Addresses\n   Tim Berners-Lee\n   World Wide Web Consortium\n  \
    \ MIT Laboratory for Computer Science, NE43-356\n   545 Technology Square\n  \
    \ Cambridge, MA 02139\n   Fax: +1(617)258-8682\n   EMail: timbl@w3.org\n   Roy\
    \ T. Fielding\n   Department of Information and Computer Science\n   University\
    \ of California, Irvine\n   Irvine, CA  92697-3425\n   Fax: +1(949)824-1715\n\
    \   EMail: fielding@ics.uci.edu\n   Larry Masinter\n   Xerox PARC\n   3333 Coyote\
    \ Hill Road\n   Palo Alto, CA 94034\n   Fax: +1(415)812-4333\n   EMail: masinter@parc.xerox.com\n"
- title: A. Collected BNF for URI
  contents:
  - "A. Collected BNF for URI\n      URI-reference = [ absoluteURI | relativeURI ]\
    \ [ \"#\" fragment ]\n      absoluteURI   = scheme \":\" ( hier_part | opaque_part\
    \ )\n      relativeURI   = ( net_path | abs_path | rel_path ) [ \"?\" query ]\n\
    \      hier_part     = ( net_path | abs_path ) [ \"?\" query ]\n      opaque_part\
    \   = uric_no_slash *uric\n      uric_no_slash = unreserved | escaped | \";\"\
    \ | \"?\" | \":\" | \"@\" |\n                      \"&\" | \"=\" | \"+\" | \"\
    $\" | \",\"\n      net_path      = \"//\" authority [ abs_path ]\n      abs_path\
    \      = \"/\"  path_segments\n      rel_path      = rel_segment [ abs_path ]\n\
    \      rel_segment   = 1*( unreserved | escaped |\n                          \"\
    ;\" | \"@\" | \"&\" | \"=\" | \"+\" | \"$\" | \",\" )\n      scheme        = alpha\
    \ *( alpha | digit | \"+\" | \"-\" | \".\" )\n      authority     = server | reg_name\n\
    \      reg_name      = 1*( unreserved | escaped | \"$\" | \",\" |\n          \
    \                \";\" | \":\" | \"@\" | \"&\" | \"=\" | \"+\" )\n      server\
    \        = [ [ userinfo \"@\" ] hostport ]\n      userinfo      = *( unreserved\
    \ | escaped |\n                         \";\" | \":\" | \"&\" | \"=\" | \"+\"\
    \ | \"$\" | \",\" )\n      hostport      = host [ \":\" port ]\n      host   \
    \       = hostname | IPv4address\n      hostname      = *( domainlabel \".\" )\
    \ toplabel [ \".\" ]\n      domainlabel   = alphanum | alphanum *( alphanum |\
    \ \"-\" ) alphanum\n      toplabel      = alpha | alpha *( alphanum | \"-\" )\
    \ alphanum\n      IPv4address   = 1*digit \".\" 1*digit \".\" 1*digit \".\" 1*digit\n\
    \      port          = *digit\n      path          = [ abs_path | opaque_part\
    \ ]\n      path_segments = segment *( \"/\" segment )\n      segment       = *pchar\
    \ *( \";\" param )\n      param         = *pchar\n      pchar         = unreserved\
    \ | escaped |\n                      \":\" | \"@\" | \"&\" | \"=\" | \"+\" | \"\
    $\" | \",\"\n      query         = *uric\n      fragment      = *uric\n      uric\
    \          = reserved | unreserved | escaped\n      reserved      = \";\" | \"\
    /\" | \"?\" | \":\" | \"@\" | \"&\" | \"=\" | \"+\" |\n                      \"\
    $\" | \",\"\n      unreserved    = alphanum | mark\n      mark          = \"-\"\
    \ | \"_\" | \".\" | \"!\" | \"~\" | \"*\" | \"'\" |\n                      \"\
    (\" | \")\"\n      escaped       = \"%\" hex hex\n      hex           = digit\
    \ | \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\" |\n                        \
    \      \"a\" | \"b\" | \"c\" | \"d\" | \"e\" | \"f\"\n      alphanum      = alpha\
    \ | digit\n      alpha         = lowalpha | upalpha\n      lowalpha = \"a\" |\
    \ \"b\" | \"c\" | \"d\" | \"e\" | \"f\" | \"g\" | \"h\" | \"i\" |\n          \
    \       \"j\" | \"k\" | \"l\" | \"m\" | \"n\" | \"o\" | \"p\" | \"q\" | \"r\"\
    \ |\n                 \"s\" | \"t\" | \"u\" | \"v\" | \"w\" | \"x\" | \"y\" |\
    \ \"z\"\n      upalpha  = \"A\" | \"B\" | \"C\" | \"D\" | \"E\" | \"F\" | \"G\"\
    \ | \"H\" | \"I\" |\n                 \"J\" | \"K\" | \"L\" | \"M\" | \"N\" |\
    \ \"O\" | \"P\" | \"Q\" | \"R\" |\n                 \"S\" | \"T\" | \"U\" | \"\
    V\" | \"W\" | \"X\" | \"Y\" | \"Z\"\n      digit    = \"0\" | \"1\" | \"2\" |\
    \ \"3\" | \"4\" | \"5\" | \"6\" | \"7\" |\n                 \"8\" | \"9\"\n"
- title: B. Parsing a URI Reference with a Regular Expression
  contents:
  - "B. Parsing a URI Reference with a Regular Expression\n   As described in Section\
    \ 4.3, the generic URI syntax is not sufficient\n   to disambiguate the components\
    \ of some forms of URI.  Since the\n   \"greedy algorithm\" described in that\
    \ section is identical to the\n   disambiguation method used by POSIX regular\
    \ expressions, it is\n   natural and commonplace to use a regular expression for\
    \ parsing the\n   potential four components and fragment identifier of a URI reference.\n\
    \   The following line is the regular expression for breaking-down a URI\n   reference\
    \ into its components.\n      ^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?\n\
    \       12            3  4          5       6  7        8 9\n   The numbers in\
    \ the second line above are only to assist readability;\n   they indicate the\
    \ reference points for each subexpression (i.e., each\n   paired parenthesis).\
    \  We refer to the value matched for subexpression\n   <n> as $<n>.  For example,\
    \ matching the above expression to\n      http://www.ics.uci.edu/pub/ietf/uri/#Related\n\
    \   results in the following subexpression matches:\n      $1 = http:\n      $2\
    \ = http\n      $3 = //www.ics.uci.edu\n      $4 = www.ics.uci.edu\n      $5 =\
    \ /pub/ietf/uri/\n      $6 = <undefined>\n      $7 = <undefined>\n      $8 = #Related\n\
    \      $9 = Related\n   where <undefined> indicates that the component is not\
    \ present, as is\n   the case for the query component in the above example.  Therefore,\
    \ we\n   can determine the value of the four components and fragment as\n    \
    \  scheme    = $2\n      authority = $4\n      path      = $5\n      query   \
    \  = $7\n      fragment  = $9\n   and, going in the opposite direction, we can\
    \ recreate a URI reference\n   from its components using the algorithm in step\
    \ 7 of Section 5.2.\n"
- title: C. Examples of Resolving Relative URI References
  contents:
  - "C. Examples of Resolving Relative URI References\n   Within an object with a\
    \ well-defined base URI of\n      http://a/b/c/d;p?q\n   the relative URI would\
    \ be resolved as follows:\n"
- title: C.1.  Normal Examples
  contents:
  - "C.1.  Normal Examples\n      g:h           =  g:h\n      g             =  http://a/b/c/g\n\
    \      ./g           =  http://a/b/c/g\n      g/            =  http://a/b/c/g/\n\
    \      /g            =  http://a/g\n      //g           =  http://g\n      ?y\
    \            =  http://a/b/c/?y\n      g?y           =  http://a/b/c/g?y\n   \
    \   #s            =  (current document)#s\n      g#s           =  http://a/b/c/g#s\n\
    \      g?y#s         =  http://a/b/c/g?y#s\n      ;x            =  http://a/b/c/;x\n\
    \      g;x           =  http://a/b/c/g;x\n      g;x?y#s       =  http://a/b/c/g;x?y#s\n\
    \      .             =  http://a/b/c/\n      ./            =  http://a/b/c/\n\
    \      ..            =  http://a/b/\n      ../           =  http://a/b/\n    \
    \  ../g          =  http://a/b/g\n      ../..         =  http://a/\n      ../../\
    \        =  http://a/\n      ../../g       =  http://a/g\n"
- title: C.2.  Abnormal Examples
  contents:
  - "C.2.  Abnormal Examples\n   Although the following abnormal examples are unlikely\
    \ to occur in\n   normal practice, all URI parsers should be capable of resolving\
    \ them\n   consistently.  Each example uses the same base as above.\n   An empty\
    \ reference refers to the start of the current document.\n      <>           \
    \ =  (current document)\n   Parsers must be careful in handling the case where\
    \ there are more\n   relative path \"..\" segments than there are hierarchical\
    \ levels in the\n   base URI's path.  Note that the \"..\" syntax cannot be used\
    \ to change\n   the authority component of a URI.\n      ../../../g    =  http://a/../g\n\
    \      ../../../../g =  http://a/../../g\n   In practice, some implementations\
    \ strip leading relative symbolic\n   elements (\".\", \"..\") after applying\
    \ a relative URI calculation, based\n   on the theory that compensating for obvious\
    \ author errors is better\n   than allowing the request to fail.  Thus, the above\
    \ two references\n   will be interpreted as \"http://a/g\" by some implementations.\n\
    \   Similarly, parsers must avoid treating \".\" and \"..\" as special when\n\
    \   they are not complete components of a relative path.\n      /./g         \
    \ =  http://a/./g\n      /../g         =  http://a/../g\n      g.            =\
    \  http://a/b/c/g.\n      .g            =  http://a/b/c/.g\n      g..        \
    \   =  http://a/b/c/g..\n      ..g           =  http://a/b/c/..g\n   Less likely\
    \ are cases where the relative URI uses unnecessary or\n   nonsensical forms of\
    \ the \".\" and \"..\" complete path segments.\n      ./../g        =  http://a/b/g\n\
    \      ./g/.         =  http://a/b/c/g/\n      g/./h         =  http://a/b/c/g/h\n\
    \      g/../h        =  http://a/b/c/h\n      g;x=1/./y     =  http://a/b/c/g;x=1/y\n\
    \      g;x=1/../y    =  http://a/b/c/y\n   All client applications remove the\
    \ query component from the base URI\n   before resolving relative URI.  However,\
    \ some applications fail to\n   separate the reference's query and/or fragment\
    \ components from a\n   relative path before merging it with the base path.  This\
    \ error is\n   rarely noticed, since typical usage of a fragment never includes\
    \ the\n   hierarchy (\"/\") character, and the query component is not normally\n\
    \   used within relative references.\n      g?y/./x       =  http://a/b/c/g?y/./x\n\
    \      g?y/../x      =  http://a/b/c/g?y/../x\n      g#s/./x       =  http://a/b/c/g#s/./x\n\
    \      g#s/../x      =  http://a/b/c/g#s/../x\n   Some parsers allow the scheme\
    \ name to be present in a relative URI if\n   it is the same as the base URI scheme.\
    \  This is considered to be a\n   loophole in prior specifications of partial\
    \ URI [RFC1630]. Its use\n   should be avoided.\n      http:g        =  http:g\
    \           ; for validating parsers\n                    |  http://a/b/c/g  \
    \ ; for backwards compatibility\n"
- title: D. Embedding the Base URI in HTML documents
  contents:
  - "D. Embedding the Base URI in HTML documents\n   It is useful to consider an example\
    \ of how the base URI of a document\n   can be embedded within the document's\
    \ content.  In this appendix, we\n   describe how documents written in the Hypertext\
    \ Markup Language\n   (HTML) [RFC1866] can include an embedded base URI.  This\
    \ appendix\n   does not form a part of the URI specification and should not be\n\
    \   considered as anything more than a descriptive example.\n   HTML defines a\
    \ special element \"BASE\" which, when present in the\n   \"HEAD\" portion of\
    \ a document, signals that the parser should use the\n   BASE element's \"HREF\"\
    \ attribute as the base URI for resolving any\n   relative URI.  The \"HREF\"\
    \ attribute must be an absolute URI.  Note\n   that, in HTML, element and attribute\
    \ names are case-insensitive.  For\n   example:\n      <!doctype html public \"\
    -//IETF//DTD HTML//EN\">\n      <HTML><HEAD>\n      <TITLE>An example HTML document</TITLE>\n\
    \      <BASE href=\"http://www.ics.uci.edu/Test/a/b/c\">\n      </HEAD><BODY>\n\
    \      ... <A href=\"../x\">a hypertext anchor</A> ...\n      </BODY></HTML>\n\
    \   A parser reading the example document should interpret the given\n   relative\
    \ URI \"../x\" as representing the absolute URI\n      <http://www.ics.uci.edu/Test/a/x>\n\
    \   regardless of the context in which the example document was obtained.\n"
- title: E. Recommendations for Delimiting URI in Context
  contents:
  - "E. Recommendations for Delimiting URI in Context\n   URI are often transmitted\
    \ through formats that do not provide a clear\n   context for their interpretation.\
    \  For example, there are many\n   occasions when URI are included in plain text;\
    \ examples include text\n   sent in electronic mail, USENET news messages, and,\
    \ most importantly,\n   printed on paper.  In such cases, it is important to be\
    \ able to\n   delimit the URI from the rest of the text, and in particular from\n\
    \   punctuation marks that might be mistaken for part of the URI.\n   In practice,\
    \ URI are delimited in a variety of ways, but usually\n   within double-quotes\
    \ \"http://test.com/\", angle brackets\n   <http://test.com/>, or just using whitespace\n\
    \                             http://test.com/\n   These wrappers do not form\
    \ part of the URI.\n   In the case where a fragment identifier is associated with\
    \ a URI\n   reference, the fragment would be placed within the brackets as well\n\
    \   (separated from the URI with a \"#\" character).\n   In some cases, extra\
    \ whitespace (spaces, linebreaks, tabs, etc.) may\n   need to be added to break\
    \ long URI across lines. The whitespace\n   should be ignored when extracting\
    \ the URI.\n   No whitespace should be introduced after a hyphen (\"-\") character.\n\
    \   Because some typesetters and printers may (erroneously) introduce a\n   hyphen\
    \ at the end of line when breaking a line, the interpreter of a\n   URI containing\
    \ a line break immediately after a hyphen should ignore\n   all unescaped whitespace\
    \ around the line break, and should be aware\n   that the hyphen may or may not\
    \ actually be part of the URI.\n   Using <> angle brackets around each URI is\
    \ especially recommended as\n   a delimiting style for URI that contain whitespace.\n\
    \   The prefix \"URL:\" (with or without a trailing space) was recommended\n \
    \  as a way to used to help distinguish a URL from other bracketed\n   designators,\
    \ although this is not common in practice.\n   For robustness, software that accepts\
    \ user-typed URI should attempt\n   to recognize and strip both delimiters and\
    \ embedded whitespace.\n   For example, the text:\n      Yes, Jim, I found it\
    \ under \"http://www.w3.org/Addressing/\",\n      but you can probably pick it\
    \ up from <ftp://ds.internic.\n      net/rfc/>.  Note the warning in <http://www.ics.uci.edu/pub/\n\
    \      ietf/uri/historical.html#WARNING>.\n   contains the URI references\n  \
    \    http://www.w3.org/Addressing/\n      ftp://ds.internic.net/rfc/\n      http://www.ics.uci.edu/pub/ietf/uri/historical.html#WARNING\n"
- title: F. Abbreviated URLs
  contents:
  - "F. Abbreviated URLs\n   The URL syntax was designed for unambiguous reference\
    \ to network\n   resources and extensibility via the URL scheme.  However, as\
    \ URL\n   identification and usage have become commonplace, traditional media\n\
    \   (television, radio, newspapers, billboards, etc.) have increasingly\n   used\
    \ abbreviated URL references.  That is, a reference consisting of\n   only the\
    \ authority and path portions of the identified resource, such\n   as\n      www.w3.org/Addressing/\n\
    \   or simply the DNS hostname on its own.  Such references are primarily\n  \
    \ intended for human interpretation rather than machine, with the\n   assumption\
    \ that context-based heuristics are sufficient to complete\n   the URL (e.g.,\
    \ most hostnames beginning with \"www\" are likely to have\n   a URL prefix of\
    \ \"http://\").  Although there is no standard set of\n   heuristics for disambiguating\
    \ abbreviated URL references, many client\n   implementations allow them to be\
    \ entered by the user and\n   heuristically resolved.  It should be noted that\
    \ such heuristics may\n   change over time, particularly when new URL schemes\
    \ are introduced.\n   Since an abbreviated URL has the same syntax as a relative\
    \ URL path,\n   abbreviated URL references cannot be used in contexts where relative\n\
    \   URLs are expected.  This limits the use of abbreviated URLs to places\n  \
    \ where there is no defined base URL, such as dialog boxes and off-line\n   advertisements.\n"
- title: G. Summary of Non-editorial Changes
  contents:
  - 'G. Summary of Non-editorial Changes

    '
- title: G.1. Additions
  contents:
  - "G.1. Additions\n   Section 4 (URI References) was added to stem the confusion\
    \ regarding\n   \"what is a URI\" and how to describe fragment identifiers given\
    \ that\n   they are not part of the URI, but are part of the URI syntax and\n\
    \   parsing concerns.  In addition, it provides a reference definition\n   for\
    \ use by other IETF specifications (HTML, HTTP, etc.) that have\n   previously\
    \ attempted to redefine the URI syntax in order to account\n   for the presence\
    \ of fragment identifiers in URI references.\n   Section 2.4 was rewritten to\
    \ clarify a number of misinterpretations\n   and to leave room for fully internationalized\
    \ URI.\n   Appendix F on abbreviated URLs was added to describe the shortened\n\
    \   references often seen on television and magazine advertisements and\n   explain\
    \ why they are not used in other contexts.\n"
- title: G.2. Modifications from both RFC 1738 and RFC 1808
  contents:
  - "G.2. Modifications from both RFC 1738 and RFC 1808\n   Changed to URI syntax\
    \ instead of just URL.\n   Confusion regarding the terms \"character encoding\"\
    , the URI\n   \"character set\", and the escaping of characters with %<hex><hex>\n\
    \   equivalents has (hopefully) been reduced.  Many of the BNF rule names\n  \
    \ regarding the character sets have been changed to more accurately\n   describe\
    \ their purpose and to encompass all \"characters\" rather than\n   just US-ASCII\
    \ octets.  Unless otherwise noted here, these\n   modifications do not affect\
    \ the URI syntax.\n   Both RFC 1738 and RFC 1808 refer to the \"reserved\" set\
    \ of characters\n   as if URI-interpreting software were limited to a single set\
    \ of\n   characters with a reserved purpose (i.e., as meaning something other\n\
    \   than the data to which the characters correspond), and that this set\n   was\
    \ fixed by the URI scheme.  However, this has not been true in\n   practice; any\
    \ character that is interpreted differently when it is\n   escaped is, in effect,\
    \ reserved.  Furthermore, the interpreting\n   engine on a HTTP server is often\
    \ dependent on the resource, not just\n   the URI scheme.  The description of\
    \ reserved characters has been\n   changed accordingly.\n   The plus \"+\", dollar\
    \ \"$\", and comma \",\" characters have been added to\n   those in the \"reserved\"\
    \ set, since they are treated as reserved\n   within the query component.\n  \
    \ The tilde \"~\" character was added to those in the \"unreserved\" set,\n  \
    \ since it is extensively used on the Internet in spite of the\n   difficulty\
    \ to transcribe it with some keyboards.\n   The syntax for URI scheme has been\
    \ changed to require that all\n   schemes begin with an alpha character.\n   The\
    \ \"user:password\" form in the previous BNF was changed to a\n   \"userinfo\"\
    \ token, and the possibility that it might be\n   \"user:password\" made scheme\
    \ specific. In particular, the use of\n   passwords in the clear is not even suggested\
    \ by the syntax.\n   The question-mark \"?\" character was removed from the set\
    \ of allowed\n   characters for the userinfo in the authority component, since\
    \ testing\n   showed that many applications treat it as reserved for separating\
    \ the\n   query component from the rest of the URI.\n   The semicolon \";\" character\
    \ was added to those stated as being\n   reserved within the authority component,\
    \ since several new schemes\n   are using it as a separator within userinfo to\
    \ indicate the type of\n   user authentication.\n   RFC 1738 specified that the\
    \ path was separated from the authority\n   portion of a URI by a slash.  RFC\
    \ 1808 followed suit, but with a\n   fudge of carrying around the separator as\
    \ a \"prefix\" in order to\n   describe the parsing algorithm.  RFC 1630 never\
    \ had this problem,\n   since it considered the slash to be part of the path.\
    \  In writing\n   this specification, it was found to be impossible to accurately\n\
    \   describe and retain the difference between the two URI\n      <foo:/bar> \
    \  and   <foo:bar>\n   without either considering the slash to be part of the\
    \ path (as\n   corresponds to actual practice) or creating a separate component\
    \ just\n   to hold that slash.  We chose the former.\n"
- title: G.3. Modifications from RFC 1738
  contents:
  - "G.3. Modifications from RFC 1738\n   The definition of specific URL schemes and\
    \ their scheme-specific\n   syntax and semantics has been moved to separate documents.\n\
    \   The URL host was defined as a fully-qualified domain name.  However,\n   many\
    \ URLs are used without fully-qualified domain names (in contexts\n   for which\
    \ the full qualification is not necessary), without any host\n   (as in some file\
    \ URLs), or with a host of \"localhost\".\n   The URL port is now *digit instead\
    \ of 1*digit, since systems are\n   expected to handle the case where the \":\"\
    \ separator between host and\n   port is supplied without a port.\n   The recommendations\
    \ for delimiting URI in context (Appendix E) have\n   been adjusted to reflect\
    \ current practice.\n"
- title: G.4. Modifications from RFC 1808
  contents:
  - "G.4. Modifications from RFC 1808\n   RFC 1808 (Section 4) defined an empty URL\
    \ reference (a reference\n   containing nothing aside from the fragment identifier)\
    \ as being a\n   reference to the base URL.  Unfortunately, that definition could\
    \ be\n   interpreted, upon selection of such a reference, as a new retrieval\n\
    \   action on that resource.  Since the normal intent of such references\n   is\
    \ for the user agent to change its view of the current document to\n   the beginning\
    \ of the specified fragment within that document, not to\n   make an additional\
    \ request of the resource, a description of how to\n   correctly interpret an\
    \ empty reference has been added in Section 4.\n   The description of the mythical\
    \ Base header field has been replaced\n   with a reference to the Content-Location\
    \ header field defined by\n   MHTML [RFC2110].\n   RFC 1808 described various\
    \ schemes as either having or not having the\n   properties of the generic URI\
    \ syntax.  However, the only requirement\n   is that the particular document containing\
    \ the relative references\n   have a base URI that abides by the generic URI syntax,\
    \ regardless of\n   the URI scheme, so the associated description has been updated\
    \ to\n   reflect that.\n   The BNF term <net_loc> has been replaced with <authority>,\
    \ since the\n   latter more accurately describes its use and purpose.  Likewise,\
    \ the\n   authority is no longer restricted to the IP server syntax.\n   Extensive\
    \ testing of current client applications demonstrated that\n   the majority of\
    \ deployed systems do not use the \";\" character to\n   indicate trailing parameter\
    \ information, and that the presence of a\n   semicolon in a path segment does\
    \ not affect the relative parsing of\n   that segment.  Therefore, parameters\
    \ have been removed as a separate\n   component and may now appear in any path\
    \ segment.  Their influence\n   has been removed from the algorithm for resolving\
    \ a relative URI\n   reference.  The resolution examples in Appendix C have been\
    \ modified\n   to reflect this change.\n   Implementations are now allowed to\
    \ work around misformed relative\n   references that are prefixed by the same\
    \ scheme as the base URI, but\n   only for schemes known to use the <hier_part>\
    \ syntax.\n"
- title: H.  Full Copyright Statement
  contents:
  - "H.  Full Copyright Statement\n   Copyright (C) The Internet Society (1998). \
    \ All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
