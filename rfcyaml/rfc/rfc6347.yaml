- contents:
  - '             Datagram Transport Layer Security Version 1.2

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document specifies version 1.2 of the Datagram Transport Layer\n
    \  Security (DTLS) protocol.  The DTLS protocol provides communications\n   privacy
    for datagram protocols.  The protocol allows client/server\n   applications to
    communicate in a way that is designed to prevent\n   eavesdropping, tampering,
    or message forgery.  The DTLS protocol is\n   based on the Transport Layer Security
    (TLS) protocol and provides\n   equivalent security guarantees.  Datagram semantics
    of the underlying\n   transport are preserved by the DTLS protocol.  This document
    updates\n   DTLS 1.0 to work with TLS version 1.2.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6347.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2012 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n
    \     1.1. Requirements Terminology ...................................5\n   2.
    Usage Model .....................................................5\n   3. Overview
    of DTLS ................................................5\n      3.1. Loss-Insensitive
    Messaging .................................6\n      3.2. Providing Reliability
    for Handshake ........................6\n           3.2.1. Packet Loss .........................................6\n
    \          3.2.2. Reordering ..........................................7\n           3.2.3.
    Message Size ........................................7\n      3.3. Replay Detection
    ...........................................7\n   4. Differences from TLS ............................................7\n
    \     4.1. Record Layer ...............................................8\n           4.1.1.
    Transport Layer Mapping ............................10\n                  4.1.1.1.
    PMTU Issues ...............................10\n           4.1.2. Record Payload
    Protection ..........................12\n                  4.1.2.1. MAC .......................................12\n
    \                 4.1.2.2. Null or Standard Stream Cipher ............13\n                  4.1.2.3.
    Block Cipher ..............................13\n                  4.1.2.4. AEAD
    Ciphers ..............................13\n                  4.1.2.5. New Cipher
    Suites .........................13\n                  4.1.2.6. Anti-Replay ...............................13\n
    \                 4.1.2.7. Handling Invalid Records ..................14\n      4.2.
    The DTLS Handshake Protocol ...............................14\n           4.2.1.
    Denial-of-Service Countermeasures ..................15\n           4.2.2. Handshake
    Message Format ...........................18\n           4.2.3. Handshake Message
    Fragmentation and Reassembly .....19\n           4.2.4. Timeout and Retransmission
    .........................20\n                  4.2.4.1. Timer Values ..............................24\n
    \          4.2.5. ChangeCipherSpec ...................................25\n           4.2.6.
    CertificateVerify and Finished Messages ............25\n           4.2.7. Alert
    Messages .....................................25\n           4.2.8. Establishing
    New Associations with Existing\n                  Parameters .........................................25\n
    \     4.3. Summary of New Syntax .....................................26\n           4.3.1.
    Record Layer .......................................26\n           4.3.2. Handshake
    Protocol .................................27\n   5. Security Considerations ........................................27\n
    \  6. Acknowledgments ................................................28\n   7.
    IANA Considerations ............................................28\n   8. Changes
    since DTLS 1.0 .........................................29\n   9. References .....................................................30\n
    \     9.1. Normative References ......................................30\n      9.2.
    Informative References ....................................31\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   TLS [TLS] is the most widely deployed protocol for securing
    network\n   traffic.  It is widely used for protecting Web traffic and for e-mail\n
    \  protocols such as IMAP [IMAP] and POP [POP].  The primary advantage\n   of
    TLS is that it provides a transparent connection-oriented channel.\n   Thus, it
    is easy to secure an application protocol by inserting TLS\n   between the application
    layer and the transport layer.  However, TLS\n   must run over a reliable transport
    channel -- typically TCP [TCP].\n   Therefore, it cannot be used to secure unreliable
    datagram traffic.\n   An increasing number of application layer protocols have
    been\n   designed that use UDP transport.  In particular, protocols such as\n
    \  the Session Initiation Protocol (SIP) [SIP] and electronic gaming\n   protocols
    are increasingly popular.  (Note that SIP can run over both\n   TCP and UDP, but
    that there are situations in which UDP is\n   preferable.)  Currently, designers
    of these applications are faced\n   with a number of unsatisfactory choices.  First,
    they can use IPsec\n   [RFC4301].  However, for a number of reasons detailed in
    [WHYIPSEC],\n   this is only suitable for some applications.  Second, they can
    design\n   a custom application layer security protocol.  Unfortunately,\n   although
    application layer security protocols generally provide\n   superior security properties
    (e.g., end-to-end security in the case\n   of S/MIME), they typically require
    a large amount of effort to design\n   -- in contrast to the relatively small
    amount of effort required to\n   run the protocol over TLS.\n   In many cases,
    the most desirable way to secure client/server\n   applications would be to use
    TLS; however, the requirement for\n   datagram semantics automatically prohibits
    use of TLS.  This memo\n   describes a protocol for this purpose: Datagram Transport
    Layer\n   Security (DTLS).  DTLS is deliberately designed to be as similar to\n
    \  TLS as possible, both to minimize new security invention and to\n   maximize
    the amount of code and infrastructure reuse.\n   DTLS 1.0 [DTLS1] was originally
    defined as a delta from [TLS11].\n   This document introduces a new version of
    DTLS, DTLS 1.2, which is\n   defined as a series of deltas to TLS 1.2 [TLS12].
    \ There is no DTLS\n   1.1; that version number was skipped in order to harmonize
    version\n   numbers with TLS.  This version also clarifies some confusing points\n
    \  in the DTLS 1.0 specification.\n   Implementations that speak both DTLS 1.2
    and DTLS 1.0 can\n   interoperate with those that speak only DTLS 1.0 (using DTLS
    1.0 of\n   course), just as TLS 1.2 implementations can interoperate with\n   previous
    versions of TLS (see Appendix E.1 of [TLS12] for details),\n   with the exception
    that there is no DTLS version of SSLv2 or SSLv3,\n   so backward compatibility
    issues for those protocols do not apply.\n"
  - contents:
    - "1.1. Requirements Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
      and \"OPTIONAL\" in this\n   document are to be interpreted as described in
      RFC 2119 [REQ].\n"
    title: 1.1. Requirements Terminology
  title: 1.  Introduction
- contents:
  - "2.  Usage Model\n   The DTLS protocol is designed to secure data between communicating\n
    \  applications.  It is designed to run in application space, without\n   requiring
    any kernel modifications.\n   Datagram transport does not require or provide reliable
    or in-order\n   delivery of data.  The DTLS protocol preserves this property for\n
    \  payload data.  Applications such as media streaming, Internet\n   telephony,
    and online gaming use datagram transport for communication\n   due to the delay-sensitive
    nature of transported data.  The behavior\n   of such applications is unchanged
    when the DTLS protocol is used to\n   secure communication, since the DTLS protocol
    does not compensate for\n   lost or re-ordered data traffic.\n"
  title: 2.  Usage Model
- contents:
  - "3.  Overview of DTLS\n   The basic design philosophy of DTLS is to construct
    \"TLS over\n   datagram transport\".  The reason that TLS cannot be used directly
    in\n   datagram environments is simply that packets may be lost or\n   reordered.
    \ TLS has no internal facilities to handle this kind of\n   unreliability; therefore,
    TLS implementations break when rehosted on\n   datagram transport.  The purpose
    of DTLS is to make only the minimal\n   changes to TLS required to fix this problem.
    \ To the greatest extent\n   possible, DTLS is identical to TLS.  Whenever we
    need to invent new\n   mechanisms, we attempt to do so in such a way that preserves
    the\n   style of TLS.\n   Unreliability creates problems for TLS at two levels:\n
    \     1. TLS does not allow independent decryption of individual\n         records.
    \ Because the integrity check depends on the sequence\n         number, if record
    N is not received, then the integrity check\n         on record N+1 will be based
    on the wrong sequence number and\n         thus will fail.  (Note that prior to
    TLS 1.1, there was no\n         explicit IV and so decryption would also fail.)\n
    \     2. The TLS handshake layer assumes that handshake messages are\n         delivered
    reliably and breaks if those messages are lost.\n   The rest of this section describes
    the approach that DTLS uses to\n   solve these problems.\n"
  - contents:
    - "3.1.  Loss-Insensitive Messaging\n   In TLS's traffic encryption layer (called
      the TLS Record Layer),\n   records are not independent.  There are two kinds
      of inter-record\n   dependency:\n      1. Cryptographic context (stream cipher
      key stream) is retained\n         between records.\n      2. Anti-replay and
      message reordering protection are provided by a\n         MAC that includes
      a sequence number, but the sequence numbers\n         are implicit in the records.\n
      \  DTLS solves the first problem by banning stream ciphers.  DTLS solves\n   the
      second problem by adding explicit sequence numbers.\n"
    title: 3.1.  Loss-Insensitive Messaging
  - contents:
    - "3.2.  Providing Reliability for Handshake\n   The TLS handshake is a lockstep
      cryptographic handshake.  Messages\n   must be transmitted and received in a
      defined order; any other order\n   is an error.  Clearly, this is incompatible
      with reordering and\n   message loss.  In addition, TLS handshake messages are
      potentially\n   larger than any given datagram, thus creating the problem of
      IP\n   fragmentation.  DTLS must provide fixes for both of these problems.\n"
    - contents:
      - "3.2.1.  Packet Loss\n   DTLS uses a simple retransmission timer to handle
        packet loss.  The\n   following figure demonstrates the basic concept, using
        the first\n   phase of the DTLS handshake:\n         Client                                   Server\n
        \        ------                                   ------\n         ClientHello
        \          ------>\n                                 X<-- HelloVerifyRequest\n
        \                                                 (lost)\n         [Timer
        Expires]\n         ClientHello           ------>\n         (retransmit)\n
        \  Once the client has transmitted the ClientHello message, it expects\n   to
        see a HelloVerifyRequest from the server.  However, if the\n   server's message
        is lost, the client knows that either the\n   ClientHello or the HelloVerifyRequest
        has been lost and retransmits.\n   When the server receives the retransmission,
        it knows to retransmit.\n   The server also maintains a retransmission timer
        and retransmits when\n   that timer expires.\n   Note that timeout and retransmission
        do not apply to the\n   HelloVerifyRequest, because this would require creating
        state on the\n   server.  The HelloVerifyRequest is designed to be small enough
        that\n   it will not itself be fragmented, thus avoiding concerns about\n
        \  interleaving multiple HelloVerifyRequests.\n"
      title: 3.2.1.  Packet Loss
    - contents:
      - "3.2.2.  Reordering\n   In DTLS, each handshake message is assigned a specific
        sequence\n   number within that handshake.  When a peer receives a handshake\n
        \  message, it can quickly determine whether that message is the next\n   message
        it expects.  If it is, then it processes it.  If not, it\n   queues it for
        future handling once all previous messages have been\n   received.\n"
      title: 3.2.2.  Reordering
    - contents:
      - "3.2.3.  Message Size\n   TLS and DTLS handshake messages can be quite large
        (in theory up to\n   2^24-1 bytes, in practice many kilobytes).  By contrast,
        UDP\n   datagrams are often limited to <1500 bytes if IP fragmentation is
        not\n   desired.  In order to compensate for this limitation, each DTLS\n
        \  handshake message may be fragmented over several DTLS records, each\n   of
        which is intended to fit in a single IP datagram.  Each DTLS\n   handshake
        message contains both a fragment offset and a fragment\n   length.  Thus,
        a recipient in possession of all bytes of a handshake\n   message can reassemble
        the original unfragmented message.\n"
      title: 3.2.3.  Message Size
    title: 3.2.  Providing Reliability for Handshake
  - contents:
    - "3.3.  Replay Detection\n   DTLS optionally supports record replay detection.
      \ The technique used\n   is the same as in IPsec AH/ESP, by maintaining a bitmap
      window of\n   received records.  Records that are too old to fit in the window
      and\n   records that have previously been received are silently discarded.\n
      \  The replay detection feature is optional, since packet duplication is\n   not
      always malicious, but can also occur due to routing errors.\n   Applications
      may conceivably detect duplicate packets and accordingly\n   modify their data
      transmission strategy.\n"
    title: 3.3.  Replay Detection
  title: 3.  Overview of DTLS
- contents:
  - "4.  Differences from TLS\n   As mentioned in Section 3, DTLS is intentionally
    very similar to TLS.\n   Therefore, instead of presenting DTLS as a new protocol,
    we present\n   it as a series of deltas from TLS 1.2 [TLS12].  Where we do not\n
    \  explicitly call out differences, DTLS is the same as in [TLS12].\n"
  - contents:
    - "4.1.  Record Layer\n   The DTLS record layer is extremely similar to that of
      TLS 1.2.  The\n   only change is the inclusion of an explicit sequence number
      in the\n   record.  This sequence number allows the recipient to correctly\n
      \  verify the TLS MAC.  The DTLS record format is shown below:\n      struct
      {\n           ContentType type;\n           ProtocolVersion version;\n           uint16
      epoch;                                    // New field\n           uint48 sequence_number;
      \                         // New field\n           uint16 length;\n           opaque
      fragment[DTLSPlaintext.length];\n         } DTLSPlaintext;\n   type\n      Equivalent
      to the type field in a TLS 1.2 record.\n   version\n      The version of the
      protocol being employed.  This document\n      describes DTLS version 1.2, which
      uses the version { 254, 253 }.\n      The version value of 254.253 is the 1's
      complement of DTLS version\n      1.2.  This maximal spacing between TLS and
      DTLS version numbers\n      ensures that records from the two protocols can
      be easily\n      distinguished.  It should be noted that future on-the-wire
      version\n      numbers of DTLS are decreasing in value (while the true version\n
      \     number is increasing in value.)\n   epoch\n      A counter value that
      is incremented on every cipher state change.\n   sequence_number\n      The
      sequence number for this record.\n   length\n      Identical to the length field
      in a TLS 1.2 record.  As in TLS 1.2,\n      the length should not exceed 2^14.\n
      \  fragment\n      Identical to the fragment field of a TLS 1.2 record.\n   DTLS
      uses an explicit sequence number, rather than an implicit one,\n   carried in
      the sequence_number field of the record.  Sequence numbers\n   are maintained
      separately for each epoch, with each sequence_number\n   initially being 0 for
      each epoch.  For instance, if a handshake\n   message from epoch 0 is retransmitted,
      it might have a sequence\n   number after a message from epoch 1, even if the
      message from epoch 1\n   was transmitted first.  Note that some care needs to
      be taken during\n   the handshake to ensure that retransmitted messages use
      the right\n   epoch and keying material.\n   If several handshakes are performed
      in close succession, there might\n   be multiple records on the wire with the
      same sequence number but\n   from different cipher states.  The epoch field
      allows recipients to\n   distinguish such packets.  The epoch number is initially
      zero and is\n   incremented each time a ChangeCipherSpec message is sent.  In
      order\n   to ensure that any given sequence/epoch pair is unique,\n   implementations
      MUST NOT allow the same epoch value to be reused\n   within two times the TCP
      maximum segment lifetime.  In practice, TLS\n   implementations rarely rehandshake;
      therefore, we do not expect this\n   to be a problem.\n   Note that because
      DTLS records may be reordered, a record from epoch\n   1 may be received after
      epoch 2 has begun.  In general,\n   implementations SHOULD discard packets from
      earlier epochs, but if\n   packet loss causes noticeable problems they MAY choose
      to retain\n   keying material from previous epochs for up to the default MSL\n
      \  specified for TCP [TCP] to allow for packet reordering.  (Note that\n   the
      intention here is that implementors use the current guidance from\n   the IETF
      for MSL, not that they attempt to interrogate the MSL that\n   the system TCP
      stack is using.)  Until the handshake has completed,\n   implementations MUST
      accept packets from the old epoch.\n   Conversely, it is possible for records
      that are protected by the\n   newly negotiated context to be received prior
      to the completion of a\n   handshake.  For instance, the server may send its
      Finished message\n   and then start transmitting data.  Implementations MAY
      either buffer\n   or discard such packets, though when DTLS is used over reliable\n
      \  transports (e.g., SCTP), they SHOULD be buffered and processed once\n   the
      handshake completes.  Note that TLS's restrictions on when\n   packets may be
      sent still apply, and the receiver treats the packets\n   as if they were sent
      in the right order.  In particular, it is still\n   impermissible to send data
      prior to completion of the first\n   handshake.\n   Note that in the special
      case of a rehandshake on an existing\n   association, it is safe to process
      a data packet immediately, even if\n   the ChangeCipherSpec or Finished messages
      have not yet been received\n   provided that either the rehandshake resumes
      the existing session or\n   that it uses exactly the same security parameters
      as the existing\n   association.  In any other case, the implementation MUST
      wait for the\n   receipt of the Finished message to prevent downgrade attack.\n
      \  As in TLS, implementations MUST either abandon an association or\n   rehandshake
      prior to allowing the sequence number to wrap.\n   Similarly, implementations
      MUST NOT allow the epoch to wrap, but\n   instead MUST establish a new association,
      terminating the old\n   association as described in Section 4.2.8.  In practice,\n
      \  implementations rarely rehandshake repeatedly on the same channel, so\n   this
      is not likely to be an issue.\n"
    - contents:
      - "4.1.1.  Transport Layer Mapping\n   Each DTLS record MUST fit within a single
        datagram.  In order to\n   avoid IP fragmentation, clients of the DTLS record
        layer SHOULD\n   attempt to size records so that they fit within any PMTU
        estimates\n   obtained from the record layer.\n   Note that unlike IPsec,
        DTLS records do not contain any association\n   identifiers.  Applications
        must arrange to multiplex between\n   associations.  With UDP, this is presumably
        done with the host/port\n   number.\n   Multiple DTLS records may be placed
        in a single datagram.  They are\n   simply encoded consecutively.  The DTLS
        record framing is sufficient\n   to determine the boundaries.  Note, however,
        that the first byte of\n   the datagram payload must be the beginning of a
        record.  Records may\n   not span datagrams.\n   Some transports, such as
        DCCP [DCCP] provide their own sequence\n   numbers.  When carried over those
        transports, both the DTLS and the\n   transport sequence numbers will be present.
        \ Although this introduces\n   a small amount of inefficiency, the transport
        layer and DTLS sequence\n   numbers serve different purposes; therefore, for
        conceptual\n   simplicity, it is superior to use both sequence numbers.  In
        the\n   future, extensions to DTLS may be specified that allow the use of\n
        \  only one set of sequence numbers for deployment in constrained\n   environments.\n
        \  Some transports, such as DCCP, provide congestion control for traffic\n
        \  carried over them.  If the congestion window is sufficiently narrow,\n
        \  DTLS handshake retransmissions may be held rather than transmitted\n   immediately,
        potentially leading to timeouts and spurious\n   retransmission.  When DTLS
        is used over such transports, care should\n   be taken not to overrun the
        likely congestion window. [DCCPDTLS]\n   defines a mapping of DTLS to DCCP
        that takes these issues into\n   account.\n"
      - contents:
        - "4.1.1.1.  PMTU Issues\n   In general, DTLS's philosophy is to leave PMTU
          discovery to the\n   application.  However, DTLS cannot completely ignore
          PMTU for three\n   reasons:\n   -  The DTLS record framing expands the datagram
          size, thus lowering\n      the effective PMTU from the application's perspective.\n
          \  -  In some implementations, the application may not directly talk to\n
          \     the network, in which case the DTLS stack may absorb ICMP\n      [RFC1191]
          \"Datagram Too Big\" indications or ICMPv6 [RFC4443]\n      \"Packet Too
          Big\" indications.\n   -  The DTLS handshake messages can exceed the PMTU.\n
          \  In order to deal with the first two issues, the DTLS record layer\n   SHOULD
          behave as described below.\n   If PMTU estimates are available from the
          underlying transport\n   protocol, they should be made available to upper
          layer protocols.  In\n   particular:\n   -  For DTLS over UDP, the upper
          layer protocol SHOULD be allowed to\n      obtain the PMTU estimate maintained
          in the IP layer.\n   -  For DTLS over DCCP, the upper layer protocol SHOULD
          be allowed to\n      obtain the current estimate of the PMTU.\n   -  For
          DTLS over TCP or SCTP, which automatically fragment and\n      reassemble
          datagrams, there is no PMTU limitation.  However, the\n      upper layer
          protocol MUST NOT write any record that exceeds the\n      maximum record
          size of 2^14 bytes.\n   The DTLS record layer SHOULD allow the upper layer
          protocol to\n   discover the amount of record expansion expected by the
          DTLS\n   processing.  Note that this number is only an estimate because
          of\n   block padding and the potential use of DTLS compression.\n   If there
          is a transport protocol indication (either via ICMP or via a\n   refusal
          to send the datagram as in Section 14 of [DCCP]), then the\n   DTLS record
          layer MUST inform the upper layer protocol of the error.\n   The DTLS record
          layer SHOULD NOT interfere with upper layer protocols\n   performing PMTU
          discovery, whether via [RFC1191] or [RFC4821]\n   mechanisms.  In particular:\n
          \  -  Where allowed by the underlying transport protocol, the upper\n      layer
          protocol SHOULD be allowed to set the state of the DF bit\n      (in IPv4)
          or prohibit local fragmentation (in IPv6).\n   -  If the underlying transport
          protocol allows the application to\n      request PMTU probing (e.g., DCCP),
          the DTLS record layer should\n      honor this request.\n   The final issue
          is the DTLS handshake protocol.  From the perspective\n   of the DTLS record
          layer, this is merely another upper layer\n   protocol.  However, DTLS handshakes
          occur infrequently and involve\n   only a few round trips; therefore, the
          handshake protocol PMTU\n   handling places a premium on rapid completion
          over accurate PMTU\n   discovery.  In order to allow connections under these
          circumstances,\n   DTLS implementations SHOULD follow the following rules:\n
          \  -  If the DTLS record layer informs the DTLS handshake layer that a\n
          \     message is too big, it SHOULD immediately attempt to fragment it,\n
          \     using any existing information about the PMTU.\n   -  If repeated
          retransmissions do not result in a response, and the\n      PMTU is unknown,
          subsequent retransmissions SHOULD back off to a\n      smaller record size,
          fragmenting the handshake message as\n      appropriate.  This standard
          does not specify an exact number of\n      retransmits to attempt before
          backing off, but 2-3 seems\n      appropriate.\n"
        title: 4.1.1.1.  PMTU Issues
      title: 4.1.1.  Transport Layer Mapping
    - contents:
      - "4.1.2.  Record Payload Protection\n   Like TLS, DTLS transmits data as a
        series of protected records.  The\n   rest of this section describes the details
        of that format.\n"
      - contents:
        - "4.1.2.1.  MAC\n   The DTLS MAC is the same as that of TLS 1.2. However,
          rather than\n   using TLS's implicit sequence number, the sequence number
          used to\n   compute the MAC is the 64-bit value formed by concatenating
          the epoch\n   and the sequence number in the order they appear on the wire.
          \ Note\n   that the DTLS epoch + sequence number is the same length as the
          TLS\n   sequence number.\n   TLS MAC calculation is parameterized on the
          protocol version number,\n   which, in the case of DTLS, is the on-the-wire
          version, i.e., {254,\n   253} for DTLS 1.2.\n   Note that one important
          difference between DTLS and TLS MAC handling\n   is that in TLS, MAC errors
          must result in connection termination.  In\n   DTLS, the receiving implementation
          MAY simply discard the offending\n   record and continue with the connection.
          \ This change is possible\n   because DTLS records are not dependent on
          each other in the way that\n   TLS records are.\n   In general, DTLS implementations
          SHOULD silently discard records with\n   bad MACs or that are otherwise
          invalid.  They MAY log an error.  If a\n   DTLS implementation chooses to
          generate an alert when it receives a\n   message with an invalid MAC, it
          MUST generate a bad_record_mac alert\n   with level fatal and terminate
          its connection state.  Note that\n   because errors do not cause connection
          termination, DTLS stacks are\n   more efficient error type oracles than
          TLS stacks.  Thus, it is\n   especially important that the advice in Section
          6.2.3.2 of [TLS12] be\n   followed.\n"
        title: 4.1.2.1.  MAC
      - contents:
        - "4.1.2.2.  Null or Standard Stream Cipher\n   The DTLS NULL cipher is performed
          exactly as the TLS 1.2 NULL cipher.\n   The only stream cipher described
          in TLS 1.2 is RC4, which cannot be\n   randomly accessed.  RC4 MUST NOT
          be used with DTLS.\n"
        title: 4.1.2.2.  Null or Standard Stream Cipher
      - contents:
        - "4.1.2.3.  Block Cipher\n   DTLS block cipher encryption and decryption
          are performed exactly as\n   with TLS 1.2.\n"
        title: 4.1.2.3.  Block Cipher
      - contents:
        - "4.1.2.4.  AEAD Ciphers\n   TLS 1.2 introduced authenticated encryption
          with additional data\n   (AEAD) cipher suites.  The existing AEAD cipher
          suites, defined in\n   [ECCGCM] and [RSAGCM], can be used with DTLS exactly
          as with TLS 1.2.\n"
        title: 4.1.2.4.  AEAD Ciphers
      - contents:
        - "4.1.2.5.  New Cipher Suites\n   Upon registration, new TLS cipher suites
          MUST indicate whether they\n   are suitable for DTLS usage and what, if
          any, adaptations must be\n   made (see Section 7 for IANA considerations).\n"
        title: 4.1.2.5.  New Cipher Suites
      - contents:
        - "4.1.2.6.  Anti-Replay\n   DTLS records contain a sequence number to provide
          replay protection.\n   Sequence number verification SHOULD be performed
          using the following\n   sliding window procedure, borrowed from Section
          3.4.3 of [ESP].\n   The receiver packet counter for this session MUST be
          initialized to\n   zero when the session is established.  For each received
          record, the\n   receiver MUST verify that the record contains a sequence
          number that\n   does not duplicate the sequence number of any other record
          received\n   during the life of this session.  This SHOULD be the first
          check\n   applied to a packet after it has been matched to a session, to
          speed\n   rejection of duplicate records.\n   Duplicates are rejected through
          the use of a sliding receive window.\n   (How the window is implemented
          is a local matter, but the following\n   text describes the functionality
          that the implementation must\n   exhibit.)  A minimum window size of 32
          MUST be supported, but a\n   window size of 64 is preferred and SHOULD be
          employed as the default.\n   Another window size (larger than the minimum)
          MAY be chosen by the\n   receiver.  (The receiver does not notify the sender
          of the window\n   size.)\n   The \"right\" edge of the window represents
          the highest validated\n   sequence number value received on this session.
          \ Records that contain\n   sequence numbers lower than the \"left\" edge
          of the window are\n   rejected.  Packets falling within the window are checked
          against a\n   list of received packets within the window.  An efficient
          means for\n   performing this check, based on the use of a bit mask, is
          described\n   in Section 3.4.3 of [ESP].\n   If the received record falls
          within the window and is new, or if the\n   packet is to the right of the
          window, then the receiver proceeds to\n   MAC verification.  If the MAC
          validation fails, the receiver MUST\n   discard the received record as invalid.
          \ The receive window is\n   updated only if the MAC verification succeeds.\n"
        title: 4.1.2.6.  Anti-Replay
      - contents:
        - "4.1.2.7.  Handling Invalid Records\n   Unlike TLS, DTLS is resilient in
          the face of invalid records (e.g.,\n   invalid formatting, length, MAC,
          etc.).  In general, invalid records\n   SHOULD be silently discarded, thus
          preserving the association;\n   however, an error MAY be logged for diagnostic
          purposes.\n   Implementations which choose to generate an alert instead,
          MUST\n   generate fatal level alerts to avoid attacks where the attacker\n
          \  repeatedly probes the implementation to see how it responds to\n   various
          types of error.  Note that if DTLS is run over UDP, then any\n   implementation
          which does this will be extremely susceptible to\n   denial-of-service (DoS)
          attacks because UDP forgery is so easy.\n   Thus, this practice is NOT RECOMMENDED
          for such transports.\n   If DTLS is being carried over a transport that
          is resistant to\n   forgery (e.g., SCTP with SCTP-AUTH), then it is safer
          to send alerts\n   because an attacker will have difficulty forging a datagram
          that will\n   not be rejected by the transport layer.\n"
        title: 4.1.2.7.  Handling Invalid Records
      title: 4.1.2.  Record Payload Protection
    title: 4.1.  Record Layer
  - contents:
    - "4.2.  The DTLS Handshake Protocol\n   DTLS uses all of the same handshake messages
      and flows as TLS, with\n   three principal changes:\n      1. A stateless cookie
      exchange has been added to prevent denial-\n         of-service attacks.\n      2.
      Modifications to the handshake header to handle message loss,\n         reordering,
      and DTLS message fragmentation (in order to avoid\n         IP fragmentation).\n
      \     3. Retransmission timers to handle message loss.\n   With these exceptions,
      the DTLS message formats, flows, and logic are\n   the same as those of TLS
      1.2.\n"
    - contents:
      - "4.2.1.  Denial-of-Service Countermeasures\n   Datagram security protocols
        are extremely susceptible to a variety of\n   DoS attacks.  Two attacks are
        of particular concern:\n      1. An attacker can consume excessive resources
        on the server by\n         transmitting a series of handshake initiation requests,
        causing\n         the server to allocate state and potentially to perform\n
        \        expensive cryptographic operations.\n      2. An attacker can use
        the server as an amplifier by sending\n         connection initiation messages
        with a forged source of the\n         victim.  The server then sends its next
        message (in DTLS, a\n         Certificate message, which can be quite large)
        to the victim\n         machine, thus flooding it.\n   In order to counter
        both of these attacks, DTLS borrows the stateless\n   cookie technique used
        by Photuris [PHOTURIS] and IKE [IKEv2].  When\n   the client sends its ClientHello
        message to the server, the server\n   MAY respond with a HelloVerifyRequest
        message.  This message contains\n   a stateless cookie generated using the
        technique of [PHOTURIS].  The\n   client MUST retransmit the ClientHello with
        the cookie added.  The\n   server then verifies the cookie and proceeds with
        the handshake only\n   if it is valid.  This mechanism forces the attacker/client
        to be able\n   to receive the cookie, which makes DoS attacks with spoofed
        IP\n   addresses difficult.  This mechanism does not provide any defense\n
        \  against DoS attacks mounted from valid IP addresses.\n   The exchange is
        shown below:\n      Client                                   Server\n      ------
        \                                  ------\n      ClientHello           ------>\n
        \                           <----- HelloVerifyRequest\n                                   (contains
        cookie)\n      ClientHello           ------>\n      (with cookie)\n      [Rest
        of handshake]\n   DTLS therefore modifies the ClientHello message to add the
        cookie\n   value.\n   struct {\n     ProtocolVersion client_version;\n     Random
        random;\n     SessionID session_id;\n     opaque cookie<0..2^8-1>;                             //
        New field\n     CipherSuite cipher_suites<2..2^16-1>;\n           CompressionMethod
        compression_methods<1..2^8-1>;\n   } ClientHello;\n   When sending the first
        ClientHello, the client does not have a cookie\n   yet; in this case, the
        Cookie field is left empty (zero length).\n   The definition of HelloVerifyRequest
        is as follows:\n   struct {\n     ProtocolVersion server_version;\n     opaque
        cookie<0..2^8-1>;\n   } HelloVerifyRequest;\n   The HelloVerifyRequest message
        type is hello_verify_request(3).\n   The server_version field has the same
        syntax as in TLS.  However, in\n   order to avoid the requirement to do version
        negotiation in the\n   initial handshake, DTLS 1.2 server implementations
        SHOULD use DTLS\n   version 1.0 regardless of the version of TLS that is expected
        to be\n   negotiated.  DTLS 1.2 and 1.0 clients MUST use the version solely
        to\n   indicate packet formatting (which is the same in both DTLS 1.2 and\n
        \  1.0) and not as part of version negotiation.  In particular, DTLS 1.2\n
        \  clients MUST NOT assume that because the server uses version 1.0 in\n   the
        HelloVerifyRequest that the server is not DTLS 1.2 or that it\n   will eventually
        negotiate DTLS 1.0 rather than DTLS 1.2.\n   When responding to a HelloVerifyRequest,
        the client MUST use the same\n   parameter values (version, random, session_id,
        cipher_suites,\n   compression_method) as it did in the original ClientHello.
        \ The\n   server SHOULD use those values to generate its cookie and verify
        that\n   they are correct upon cookie receipt.  The server MUST use the same\n
        \  version number in the HelloVerifyRequest that it would use when\n   sending
        a ServerHello.  Upon receipt of the ServerHello, the client\n   MUST verify
        that the server version values match.  In order to avoid\n   sequence number
        duplication in case of multiple HelloVerifyRequests,\n   the server MUST use
        the record sequence number in the ClientHello as\n   the record sequence number
        in the HelloVerifyRequest.\n   Note: This specification increases the cookie
        size limit to 255 bytes\n   for greater future flexibility.  The limit remains
        32 for previous\n   versions of DTLS.\n   The DTLS server SHOULD generate
        cookies in such a way that they can\n   be verified without retaining any
        per-client state on the server.\n   One technique is to have a randomly generated
        secret and generate\n   cookies as:\n      Cookie = HMAC(Secret, Client-IP,
        Client-Parameters)\n   When the second ClientHello is received, the server
        can verify that\n   the Cookie is valid and that the client can receive packets
        at the\n   given IP address.  In order to avoid sequence number duplication
        in\n   case of multiple cookie exchanges, the server MUST use the record\n
        \  sequence number in the ClientHello as the record sequence number in\n   its
        initial ServerHello.  Subsequent ServerHellos will only be sent\n   after
        the server has created state and MUST increment normally.\n   One potential
        attack on this scheme is for the attacker to collect a\n   number of cookies
        from different addresses and then reuse them to\n   attack the server.  The
        server can defend against this attack by\n   changing the Secret value frequently,
        thus invalidating those\n   cookies.  If the server wishes that legitimate
        clients be able to\n   handshake through the transition (e.g., they received
        a cookie with\n   Secret 1 and then sent the second ClientHello after the
        server has\n   changed to Secret 2), the server can have a limited window
        during\n   which it accepts both secrets.  [IKEv2] suggests adding a version\n
        \  number to cookies to detect this case.  An alternative approach is\n   simply
        to try verifying with both secrets.\n   DTLS servers SHOULD perform a cookie
        exchange whenever a new\n   handshake is being performed.  If the server is
        being operated in an\n   environment where amplification is not a problem,
        the server MAY be\n   configured not to perform a cookie exchange.  The default
        SHOULD be\n   that the exchange is performed, however.  In addition, the server
        MAY\n   choose not to do a cookie exchange when a session is resumed.\n   Clients
        MUST be prepared to do a cookie exchange with every\n   handshake.\n   If
        HelloVerifyRequest is used, the initial ClientHello and\n   HelloVerifyRequest
        are not included in the calculation of the\n   handshake_messages (for the
        CertificateVerify message) and\n   verify_data (for the Finished message).\n
        \  If a server receives a ClientHello with an invalid cookie, it SHOULD\n
        \  treat it the same as a ClientHello with no cookie.  This avoids\n   race/deadlock
        conditions if the client somehow gets a bad cookie\n   (e.g., because the
        server changes its cookie signing key).\n   Note to implementors: This may
        result in clients receiving multiple\n   HelloVerifyRequest messages with
        different cookies.  Clients SHOULD\n   handle this by sending a new ClientHello
        with a cookie in response to\n   the new HelloVerifyRequest.\n"
      title: 4.2.1.  Denial-of-Service Countermeasures
    - contents:
      - "4.2.2.  Handshake Message Format\n   In order to support message loss, reordering,
        and message\n   fragmentation, DTLS modifies the TLS 1.2 handshake header:\n
        \  struct {\n     HandshakeType msg_type;\n     uint24 length;\n     uint16
        message_seq;                               // New field\n     uint24 fragment_offset;
        \                          // New field\n     uint24 fragment_length;                           //
        New field\n     select (HandshakeType) {\n       case hello_request: HelloRequest;\n
        \      case client_hello:  ClientHello;\n       case hello_verify_request:
        HelloVerifyRequest;  // New type\n       case server_hello:  ServerHello;\n
        \      case certificate:Certificate;\n       case server_key_exchange: ServerKeyExchange;\n
        \      case certificate_request: CertificateRequest;\n       case server_hello_done:ServerHelloDone;\n
        \      case certificate_verify:  CertificateVerify;\n       case client_key_exchange:
        ClientKeyExchange;\n       case finished: Finished;\n     } body;\n   } Handshake;\n
        \  The first message each side transmits in each handshake always has\n   message_seq
        = 0.  Whenever each new message is generated, the\n   message_seq value is
        incremented by one.  Note that in the case of a\n   rehandshake, this implies
        that the HelloRequest will have message_seq\n   = 0 and the ServerHello will
        have message_seq = 1.  When a message is\n   retransmitted, the same message_seq
        value is used.  For example:\n         Client                             Server\n
        \        ------                             ------\n         ClientHello (seq=0)
        \ ------>\n                                 X<-- HelloVerifyRequest (seq=0)\n
        \                                                (lost)\n         [Timer Expires]\n
        \        ClientHello (seq=0)  ------>\n         (retransmit)\n                              <------
        HelloVerifyRequest (seq=0)\n         ClientHello (seq=1)  ------>\n         (with
        cookie)\n                              <------        ServerHello (seq=1)\n
        \                             <------        Certificate (seq=2)\n                              <------
        \   ServerHelloDone (seq=3)\n         [Rest of handshake]\n   Note, however,
        that from the perspective of the DTLS record layer,\n   the retransmission
        is a new record.  This record will have a new\n   DTLSPlaintext.sequence_number
        value.\n   DTLS implementations maintain (at least notionally) a\n   next_receive_seq
        counter.  This counter is initially set to zero.\n   When a message is received,
        if its sequence number matches\n   next_receive_seq, next_receive_seq is incremented
        and the message is\n   processed.  If the sequence number is less than next_receive_seq,
        the\n   message MUST be discarded.  If the sequence number is greater than\n
        \  next_receive_seq, the implementation SHOULD queue the message but MAY\n
        \  discard it.  (This is a simple space/bandwidth tradeoff).\n"
      title: 4.2.2.  Handshake Message Format
    - contents:
      - "4.2.3.  Handshake Message Fragmentation and Reassembly\n   As noted in Section
        4.1.1, each DTLS message MUST fit within a single\n   transport layer datagram.
        \ However, handshake messages are\n   potentially bigger than the maximum
        record size.  Therefore, DTLS\n   provides a mechanism for fragmenting a handshake
        message over a\n   number of records, each of which can be transmitted separately,
        thus\n   avoiding IP fragmentation.\n   When transmitting the handshake message,
        the sender divides the\n   message into a series of N contiguous data ranges.
        \ These ranges MUST\n   NOT be larger than the maximum handshake fragment
        size and MUST\n   jointly contain the entire handshake message.  The ranges
        SHOULD NOT\n   overlap.  The sender then creates N handshake messages, all
        with the\n   same message_seq value as the original handshake message.  Each
        new\n   message is labeled with the fragment_offset (the number of bytes\n
        \  contained in previous fragments) and the fragment_length (the length\n
        \  of this fragment).  The length field in all messages is the same as\n   the
        length field of the original message.  An unfragmented message is\n   a degenerate
        case with fragment_offset=0 and fragment_length=length.\n   When a DTLS implementation
        receives a handshake message fragment, it\n   MUST buffer it until it has
        the entire handshake message.  DTLS\n   implementations MUST be able to handle
        overlapping fragment ranges.\n   This allows senders to retransmit handshake
        messages with smaller\n   fragment sizes if the PMTU estimate changes.\n   Note
        that as with TLS, multiple handshake messages may be placed in\n   the same
        DTLS record, provided that there is room and that they are\n   part of the
        same flight.  Thus, there are two acceptable ways to pack\n   two DTLS messages
        into the same datagram: in the same record or in\n   separate records.\n"
      title: 4.2.3.  Handshake Message Fragmentation and Reassembly
    - contents:
      - "4.2.4.  Timeout and Retransmission\n   DTLS messages are grouped into a series
        of message flights, according\n   to the diagrams below.  Although each flight
        of messages may consist\n   of a number of messages, they should be viewed
        as monolithic for the\n   purpose of timeout and retransmission.\n   Client
        \                                         Server\n   ------                                          ------\n
        \  ClientHello             -------->                           Flight 1\n
        \                          <-------    HelloVerifyRequest      Flight 2\n
        \  ClientHello             -------->                           Flight 3\n
        \                                             ServerHello    \\\n                                             Certificate*
        \    \\\n                                       ServerKeyExchange*      Flight
        4\n                                      CertificateRequest*     /\n                           <--------
        \     ServerHelloDone    /\n   Certificate*                                              \\\n
        \  ClientKeyExchange                                          \\\n   CertificateVerify*
        \                                         Flight 5\n   [ChangeCipherSpec]
        \                                        /\n   Finished                -------->
        \                        /\n                                       [ChangeCipherSpec]
        \   \\ Flight 6\n                           <--------             Finished
        \   /\n               Figure 1. Message Flights for Full Handshake\n   Client
        \                                          Server\n   ------                                           ------\n
        \  ClientHello             -------->                          Flight 1\n                                              ServerHello
        \   \\\n                                       [ChangeCipherSpec]     Flight
        2\n                            <--------             Finished    /\n   [ChangeCipherSpec]
        \                                        \\Flight 3\n   Finished                 -------->
        \                        /\n         Figure 2. Message Flights for Session-Resuming
        Handshake\n                           (No Cookie Exchange)\n   DTLS uses a
        simple timeout and retransmission scheme with the\n   following state machine.
        \ Because DTLS clients send the first message\n   (ClientHello), they start
        in the PREPARING state.  DTLS servers start\n   in the WAITING state, but
        with empty buffers and no retransmit timer.\n                      +-----------+\n
        \                     | PREPARING |\n                +---> |           | <--------------------+\n
        \               |     |           |                      |\n                |
        \    +-----------+                      |\n                |           |                            |\n
        \               |           | Buffer next flight         |\n                |
        \          |                            |\n                |          \\|/
        \                          |\n                |     +-----------+                      |\n
        \               |     |           |                      |\n                |
        \    |  SENDING  |<------------------+  |\n                |     |           |
        \                  |  | Send\n                |     +-----------+                   |
        \ | HelloRequest\n        Receive |           |                         |
        \ |\n           next |           | Send flight             |  | or\n         flight
        |  +--------+                         |  |\n                |  |        |
        Set retransmit timer    |  | Receive\n                |  |       \\|/                        |
        \ | HelloRequest\n                |  |  +-----------+                   |
        \ | Send\n                |  |  |           |                   |  | ClientHello\n
        \               +--)--|  WAITING  |-------------------+  |\n                |
        \ |  |           |   Timer expires   |  |\n                |  |  +-----------+
        \                  |  |\n                |  |         |                        |
        \ |\n                |  |         |                        |  |\n                |
        \ |         +------------------------+  |\n                |  |                Read
        retransmit      |\n        Receive |  |                                     |\n
        \          last |  |                                     |\n         flight
        |  |                                     |\n                |  |                                     |\n
        \              \\|/\\|/                                    |\n                                                         |\n
        \           +-----------+                                |\n            |
        \          |                                |\n            | FINISHED  | -------------------------------+\n
        \           |           |\n            +-----------+\n                 |  /|\\\n
        \                |   |\n                 |   |\n                 +---+\n              Read
        retransmit\n           Retransmit last flight\n          Figure 3. DTLS Timeout
        and Retransmission State Machine\n   The state machine has three basic states.\n
        \  In the PREPARING state, the implementation does whatever computations\n
        \  are necessary to prepare the next flight of messages.  It then\n   buffers
        them up for transmission (emptying the buffer first) and\n   enters the SENDING
        state.\n   In the SENDING state, the implementation transmits the buffered\n
        \  flight of messages.  Once the messages have been sent, the\n   implementation
        then enters the FINISHED state if this is the last\n   flight in the handshake.
        \ Or, if the implementation expects to\n   receive more messages, it sets
        a retransmit timer and then enters the\n   WAITING state.\n   There are three
        ways to exit the WAITING state:\n   1. The retransmit timer expires: the implementation
        transitions to\n      the SENDING state, where it retransmits the flight,
        resets the\n      retransmit timer, and returns to the WAITING state.\n   2.
        The implementation reads a retransmitted flight from the peer: the\n      implementation
        transitions to the SENDING state, where it\n      retransmits the flight,
        resets the retransmit timer, and returns\n      to the WAITING state.  The
        rationale here is that the receipt of a\n      duplicate message is the likely
        result of timer expiry on the peer\n      and therefore suggests that part
        of one's previous flight was\n      lost.\n   3. The implementation receives
        the next flight of messages: if this\n      is the final flight of messages,
        the implementation transitions to\n      FINISHED.  If the implementation
        needs to send a new flight, it\n      transitions to the PREPARING state.
        \ Partial reads (whether\n      partial messages or only some of the messages
        in the flight) do\n      not cause state transitions or timer resets.\n   Because
        DTLS clients send the first message (ClientHello), they start\n   in the PREPARING
        state.  DTLS servers start in the WAITING state, but\n   with empty buffers
        and no retransmit timer.\n   When the server desires a rehandshake, it transitions
        from the\n   FINISHED state to the PREPARING state to transmit the HelloRequest.\n
        \  When the client receives a HelloRequest, it transitions from FINISHED\n
        \  to PREPARING to transmit the ClientHello.\n   In addition, for at least
        twice the default MSL defined for [TCP],\n   when in the FINISHED state, the
        node that transmits the last flight\n   (the server in an ordinary handshake
        or the client in a resumed\n   handshake) MUST respond to a retransmit of
        the peer's last flight\n   with a retransmit of the last flight.  This avoids
        deadlock\n   conditions if the last flight gets lost.  This requirement applies
        to\n   DTLS 1.0 as well, and though not explicit in [DTLS1], it was always\n
        \  required for the state machine to function correctly.  To see why\n   this
        is necessary, consider what happens in an ordinary handshake if\n   the server's
        Finished message is lost: the server believes the\n   handshake is complete
        but it actually is not.  As the client is\n   waiting for the Finished message,
        the client's retransmit timer will\n   fire and it will retransmit the client's
        Finished message.  This will\n   cause the server to respond with its own
        Finished message, completing\n   the handshake.  The same logic applies on
        the server side for the\n   resumed handshake.\n   Note that because of packet
        loss, it is possible for one side to be\n   sending application data even
        though the other side has not received\n   the first side's Finished message.
        \ Implementations MUST either\n   discard or buffer all application data packets
        for the new epoch\n   until they have received the Finished message for that
        epoch.\n   Implementations MAY treat receipt of application data with a new\n
        \  epoch prior to receipt of the corresponding Finished message as\n   evidence
        of reordering or packet loss and retransmit their final\n   flight immediately,
        shortcutting the retransmission timer.\n"
      - contents:
        - "4.2.4.1. Timer Values\n   Though timer values are the choice of the implementation,
          mishandling\n   of the timer can lead to serious congestion problems; for
          example, if\n   many instances of a DTLS time out early and retransmit too
          quickly on\n   a congested link.  Implementations SHOULD use an initial
          timer value\n   of 1 second (the minimum defined in RFC 6298 [RFC6298])
          and double\n   the value at each retransmission, up to no less than the
          RFC 6298\n   maximum of 60 seconds.  Note that we recommend a 1-second timer\n
          \  rather than the 3-second RFC 6298 default in order to improve latency\n
          \  for time-sensitive applications.  Because DTLS only uses\n   retransmission
          for handshake and not dataflow, the effect on\n   congestion should be minimal.\n
          \  Implementations SHOULD retain the current timer value until a\n   transmission
          without loss occurs, at which time the value may be\n   reset to the initial
          value.  After a long period of idleness, no less\n   than 10 times the current
          timer value, implementations may reset the\n   timer to the initial value.
          \ One situation where this might occur is\n   when a rehandshake is used
          after substantial data transfer.\n"
        title: 4.2.4.1. Timer Values
      title: 4.2.4.  Timeout and Retransmission
    - contents:
      - "4.2.5.  ChangeCipherSpec\n   As with TLS, the ChangeCipherSpec message is
        not technically a\n   handshake message but MUST be treated as part of the
        same flight as\n   the associated Finished message for the purposes of timeout
        and\n   retransmission.  This creates a potential ambiguity because the order\n
        \  of the ChangeCipherSpec cannot be established unambiguously with\n   respect
        to the handshake messages in case of message loss.\n   This is not a problem
        with any current TLS mode because the expected\n   set of handshake messages
        logically preceeding the ChangeCipherSpec\n   is predictable from the rest
        of the handshake state.  However, future\n   modes MUST take care to avoid
        creating ambiguity.\n"
      title: 4.2.5.  ChangeCipherSpec
    - contents:
      - "4.2.6.  CertificateVerify and Finished Messages\n   CertificateVerify and
        Finished messages have the same format as in\n   TLS.  Hash calculations include
        entire handshake messages, including\n   DTLS-specific fields: message_seq,
        fragment_offset, and\n   fragment_length.  However, in order to remove sensitivity
        to\n   handshake message fragmentation, the Finished MAC MUST be computed
        as\n   if each handshake message had been sent as a single fragment.  Note\n
        \  that in cases where the cookie exchange is used, the initial\n   ClientHello
        and HelloVerifyRequest MUST NOT be included in the\n   CertificateVerify or
        Finished MAC computations.\n"
      title: 4.2.6.  CertificateVerify and Finished Messages
    - contents:
      - "4.2.7.  Alert Messages\n   Note that Alert messages are not retransmitted
        at all, even when they\n   occur in the context of a handshake.  However,
        a DTLS implementation\n   which would ordinarily issue an alert SHOULD generate
        a new alert\n   message if the offending record is received again (e.g., as
        a\n   retransmitted handshake message).  Implementations SHOULD detect when\n
        \  a peer is persistently sending bad messages and terminate the local\n   connection
        state after such misbehavior is detected.\n"
      title: 4.2.7.  Alert Messages
    - contents:
      - "4.2.8.  Establishing New Associations with Existing Parameters\n   If a DTLS
        client-server pair is configured in such a way that\n   repeated connections
        happen on the same host/port quartet, then it is\n   possible that a client
        will silently abandon one connection and then\n   initiate another with the
        same parameters (e.g., after a reboot).\n   This will appear to the server
        as a new handshake with epoch=0.  In\n   cases where a server believes it
        has an existing association on a\n   given host/port quartet and it receives
        an epoch=0 ClientHello, it\n   SHOULD proceed with a new handshake but MUST
        NOT destroy the existing\n   association until the client has demonstrated
        reachability either by\n   completing a cookie exchange or by completing a
        complete handshake\n   including delivering a verifiable Finished message.
        \ After a correct\n   Finished message is received, the server MUST abandon
        the previous\n   association to avoid confusion between two valid associations
        with\n   overlapping epochs.  The reachability requirement prevents\n   off-path/blind
        attackers from destroying associations merely by\n   sending forged ClientHellos.\n"
      title: 4.2.8.  Establishing New Associations with Existing Parameters
    title: 4.2.  The DTLS Handshake Protocol
  - contents:
    - "4.3.  Summary of New Syntax\n   This section includes specifications for the
      data structures that\n   have changed between TLS 1.2 and DTLS 1.2. See [TLS12]
      for the\n   definition of this syntax.\n"
    - contents:
      - "4.3.1.  Record Layer\n   struct {\n        ContentType type;\n        ProtocolVersion
        version;\n        uint16 epoch;                                     // New
        field\n        uint48 sequence_number;                           // New field\n
        \       uint16 length;\n        opaque fragment[DTLSPlaintext.length];\n      }
        DTLSPlaintext;\n      struct {\n        ContentType type;\n        ProtocolVersion
        version;\n        uint16 epoch;                                     // New
        field\n        uint48 sequence_number;                           // New field\n
        \       uint16 length;\n        opaque fragment[DTLSCompressed.length];\n
        \     } DTLSCompressed;\n      struct {\n        ContentType type;\n        ProtocolVersion
        version;\n        uint16 epoch;                                     // New
        field\n        uint48 sequence_number;                           // New field\n
        \       uint16 length;\n        select (CipherSpec.cipher_type) {\n          case
        block:  GenericBlockCipher;\n          case aead:   GenericAEADCipher;                 //
        New field\n        } fragment;\n      } DTLSCiphertext;\n"
      title: 4.3.1.  Record Layer
    - contents:
      - "4.3.2.  Handshake Protocol\n   enum {\n     hello_request(0), client_hello(1),
        server_hello(2),\n     hello_verify_request(3),                          //
        New field\n     certificate(11), server_key_exchange (12),\n     certificate_request(13),
        server_hello_done(14),\n     certificate_verify(15), client_key_exchange(16),\n
        \    finished(20), (255) } HandshakeType;\n   struct {\n     HandshakeType
        msg_type;\n     uint24 length;\n     uint16 message_seq;                               //
        New field\n     uint24 fragment_offset;                           // New field\n
        \    uint24 fragment_length;                           // New field\n     select
        (HandshakeType) {\n       case hello_request: HelloRequest;\n       case client_hello:
        \ ClientHello;\n       case server_hello:  ServerHello;\n       case hello_verify_request:
        HelloVerifyRequest;  // New field\n       case certificate:Certificate;\n
        \      case server_key_exchange: ServerKeyExchange;\n       case certificate_request:
        CertificateRequest;\n       case server_hello_done:ServerHelloDone;\n       case
        certificate_verify:  CertificateVerify;\n       case client_key_exchange:
        ClientKeyExchange;\n       case finished: Finished;\n     } body; } Handshake;\n
        \  struct {\n     ProtocolVersion client_version;\n     Random random;\n     SessionID
        session_id;\n     opaque cookie<0..2^8-1>;                             //
        New field\n     CipherSuite cipher_suites<2..2^16-1>;\n     CompressionMethod
        compression_methods<1..2^8-1>; } ClientHello;\n   struct {\n     ProtocolVersion
        server_version;\n     opaque cookie<0..2^8-1>; } HelloVerifyRequest;\n"
      title: 4.3.2.  Handshake Protocol
    title: 4.3.  Summary of New Syntax
  title: 4.  Differences from TLS
- contents:
  - "5.  Security Considerations\n   This document describes a variant of TLS 1.2;
    therefore, most of the\n   security considerations are the same as those of TLS
    1.2 [TLS12],\n   described in Appendices D, E, and F.\n   The primary additional
    security consideration raised by DTLS is that\n   of denial of service.  DTLS
    includes a cookie exchange designed to\n   protect against denial of service.
    \ However, implementations that do\n   not use this cookie exchange are still
    vulnerable to DoS.  In\n   particular, DTLS servers that do not use the cookie
    exchange may be\n   used as attack amplifiers even if they themselves are not\n
    \  experiencing DoS.  Therefore, DTLS servers SHOULD use the cookie\n   exchange
    unless there is good reason to believe that amplification is\n   not a threat
    in their environment.  Clients MUST be prepared to do a\n   cookie exchange with
    every handshake.\n   Unlike TLS implementations, DTLS implementations SHOULD NOT
    respond\n   to invalid records by terminating the connection.  See Section\n   4.1.2.7
    for details on this.\n"
  title: 5.  Security Considerations
- contents:
  - "6.  Acknowledgments\n   The authors would like to thank Dan Boneh, Eu-Jin Goh,
    Russ Housley,\n   Constantine Sapuntzakis, and Hovav Shacham for discussions and\n
    \  comments on the design of DTLS.  Thanks to the anonymous NDSS\n   reviewers
    of our original NDSS paper on DTLS [DTLS] for their\n   comments.  Also, thanks
    to Steve Kent for feedback that helped\n   clarify many points.  The section on
    PMTU was cribbed from the DCCP\n   specification [DCCP].  Pasi Eronen provided
    a detailed review of this\n   specification.  Peter Saint-Andre provided the list
    of changes in\n   Section 8.  Helpful comments on the document were also received
    from\n   Mark Allman, Jari Arkko, Mohamed Badra, Michael D'Errico, Adrian\n   Farrell,
    Joel Halpern, Ted Hardie, Charlia Kaufman, Pekka Savola,\n   Allison Mankin, Nikos
    Mavrogiannopoulos, Alexey Melnikov, Robin\n   Seggelmann, Michael Tuexen, Juho
    Vaha-Herttua, and Florian Weimer.\n"
  title: 6.  Acknowledgments
- contents:
  - "7.  IANA Considerations\n   This document uses the same identifier space as TLS
    [TLS12], so no\n   new IANA registries are required.  When new identifiers are
    assigned\n   for TLS, authors MUST specify whether they are suitable for DTLS.\n
    \  IANA has modified all TLS parameter registries to add a DTLS-OK flag,\n   indicating
    whether the specification may be used with DTLS.  At the\n   time of publication,
    all of the [TLS12] registrations except the\n   following are suitable for DTLS.
    \ The full table of registrations is\n   available at [IANA].\n   From the TLS
    Cipher Suite Registry:\n      0x00,0x03 TLS_RSA_EXPORT_WITH_RC4_40_MD5        [RFC4346]\n
    \     0x00,0x04 TLS_RSA_WITH_RC4_128_MD5              [RFC5246]\n      0x00,0x05
    TLS_RSA_WITH_RC4_128_SHA              [RFC5246]\n      0x00,0x17 TLS_DH_anon_EXPORT_WITH_RC4_40_MD5
    \   [RFC4346]\n      0x00,0x18 TLS_DH_anon_WITH_RC4_128_MD5          [RFC5246]\n
    \     0x00,0x20 TLS_KRB5_WITH_RC4_128_SHA             [RFC2712]\n      0x00,0x24
    TLS_KRB5_WITH_RC4_128_MD5             [RFC2712]\n      0x00,0x28 TLS_KRB5_EXPORT_WITH_RC4_40_SHA
    \      [RFC2712]\n      0x00,0x2B TLS_KRB5_EXPORT_WITH_RC4_40_MD5       [RFC2712]\n
    \     0x00,0x8A TLS_PSK_WITH_RC4_128_SHA              [RFC4279]\n      0x00,0x8E
    TLS_DHE_PSK_WITH_RC4_128_SHA          [RFC4279]\n      0x00,0x92 TLS_RSA_PSK_WITH_RC4_128_SHA
    \         [RFC4279]\n      0xC0,0x02 TLS_ECDH_ECDSA_WITH_RC4_128_SHA       [RFC4492]\n
    \     0xC0,0x07 TLS_ECDHE_ECDSA_WITH_RC4_128_SHA      [RFC4492]\n      0xC0,0x0C
    TLS_ECDH_RSA_WITH_RC4_128_SHA         [RFC4492]\n      0xC0,0x11 TLS_ECDHE_RSA_WITH_RC4_128_SHA
    \       [RFC4492]\n      0xC0,0x16 TLS_ECDH_anon_WITH_RC4_128_SHA        [RFC4492]\n
    \     0xC0,0x33 TLS_ECDHE_PSK_WITH_RC4_128_SHA        [RFC5489]\n   From the TLS
    Exporter Label Registry:\n      client EAP encryption       [RFC5216]\n      ttls
    \  keying material      [RFC5281]\n      ttls   challenge            [RFC5281]\n
    \  This document defines a new handshake message, hello_verify_request,\n   whose
    value has been allocated from the TLS HandshakeType registry\n   defined in [TLS12].
    \ The value \"3\" has been assigned by the IANA.\n"
  title: 7.  IANA Considerations
- contents:
  - "8.  Changes since DTLS 1.0\n   This document reflects the following changes since
    DTLS 1.0 [DTLS1].\n   -  Updated to match TLS 1.2 [TLS12].\n   -  Addition of
    AEAD Ciphers in Section 4.1.2.3 (tracking changes in\n      TLS 1.2.\n   -  Clarifications
    regarding sequence numbers and epochs in Section\n      4.1 and a clear procedure
    for dealing with state loss in Section\n      4.2.8.\n   -  Clarifications and
    more detailed rules regarding Path MTU issues\n      in Section 4.1.1.1. Clarification
    of the fragmentation text\n      throughout.\n   -  Clarifications regarding handling
    of invalid records in Section\n      4.1.2.7.\n   -  A new paragraph describing
    handling of invalid cookies at the end\n      of Section 4.2.1.\n   -  Some new
    text describing how to avoid handshake deadlock\n      conditions at the end of
    Section 4.2.4.\n   -  Some new text about CertificateVerify messages in Section
    4.2.6.\n   -  A prohibition on epoch wrapping in Section 4.1.\n   -  Clarification
    of the IANA requirements and the explicit\n      requirement for a new IANA registration
    flag for each parameter.\n   -  Added a record sequence number mirroring technique
    for handling\n      repeated ClientHello messages.\n   -  Recommend a fixed version
    number for HelloVerifyRequest.\n   -  Numerous editorial changes.\n"
  title: 8.  Changes since DTLS 1.0
- contents:
  - '9.  References

    '
  - contents:
    - "9.1.  Normative References\n   [REQ]       Bradner, S., \"Key words for use
      in RFCs to Indicate\n               Requirement Levels\", BCP 14, RFC 2119,
      March 1997.\n   [RFC1191]   Mogul, J. and S. Deering, \"Path MTU discovery\",
      RFC 1191,\n               November 1990.\n   [RFC4301]   Kent, S. and K. Seo,
      \"Security Architecture for the\n               Internet Protocol\", RFC 4301,
      December 2005.\n   [RFC4443]   Conta, A., Deering, S., and M. Gupta, Ed., \"Internet\n
      \              Control Message Protocol (ICMPv6) for the Internet\n               Protocol
      Version 6 (IPv6) Specification\", RFC 4443, March\n               2006.\n   [RFC4821]
      \  Mathis, M. and J. Heffner, \"Packetization Layer Path MTU\n               Discovery\",
      RFC 4821, March 2007.\n   [RFC6298]   Paxson, V., Allman, M., Chu, J., and M.
      Sargent,\n               \"Computing TCP's Retransmission Timer\", RFC 6298,
      June\n               2011.\n   [RSAGCM]    Salowey, J., Choudhury, A., and D.
      McGrew, \"AES Galois\n               Counter Mode (GCM) Cipher Suites for TLS\",
      RFC 5288,\n               August 2008.\n   [TCP]       Postel, J., \"Transmission
      Control Protocol\", STD 7, RFC\n               793, September 1981.\n   [TLS12]
      \    Dierks, T. and E. Rescorla, \"The Transport Layer Security\n               (TLS)
      Protocol Version 1.2\", RFC 5246, August 2008.\n"
    title: 9.1.  Normative References
  - contents:
    - "9.2.  Informative References\n   [DCCP]      Kohler, E., Handley, M., and S.
      Floyd, \"Datagram\n               Congestion Control Protocol (DCCP)\", RFC
      4340, March\n               2006.\n   [DCCPDTLS]  Phelan, T., \"Datagram Transport
      Layer Security (DTLS)\n               over the Datagram Congestion Control Protocol
      (DCCP)\",\n               RFC 5238, May 2008.\n   [DTLS]      Modadugu, N. and
      E. Rescorla, \"The Design and\n               Implementation of Datagram TLS\",
      Proceedings of ISOC NDSS\n               2004, February 2004.\n   [DTLS1]     Rescorla,
      E. and N. Modadugu, \"Datagram Transport Layer\n               Security\", RFC
      4347, April 2006.\n   [ECCGCM]    Rescorla, E., \"TLS Elliptic Curve Cipher
      Suites with\n               SHA-256/384 and AES Galois Counter Mode (GCM)\",
      RFC 5289,\n               August 2008.\n   [ESP]       Kent, S., \"IP Encapsulating
      Security Payload (ESP)\", RFC\n               4303, December 2005.\n   [IANA]
      \     IANA, \"Transport Layer Security (TLS) Parameters\",\n               http://www.iana.org/assignments/tls-parameters.\n
      \  [IKEv2]     Kaufman, C., Hoffman, P., Nir, Y., and P. Eronen,\n               \"Internet
      Key Exchange Protocol Version 2 (IKEv2)\", RFC\n               5996, September
      2010.\n   [IMAP]      Crispin, M., \"INTERNET MESSAGE ACCESS PROTOCOL - VERSION\n
      \              4rev1\", RFC 3501, March 2003.\n   [PHOTURIS]  Karn, P. and W.
      Simpson, \"Photuris: Session-Key\n               Management Protocol\", RFC
      2522, March 1999.\n   [POP]       Myers, J. and M. Rose, \"Post Office Protocol
      - Version\n               3\", STD 53, RFC 1939, May 1996.\n   [SIP]       Rosenberg,
      J., Schulzrinne, H., Camarillo, G., Johnston,\n               A., Peterson,
      J., Sparks, R., Handley, M., and E.\n               Schooler, \"SIP: Session
      Initiation Protocol\", RFC 3261,\n               June 2002.\n   [TLS]       Dierks,
      T. and C. Allen, \"The TLS Protocol Version 1.0\",\n               RFC 2246,
      January 1999.\n   [TLS11]     Dierks, T. and E. Rescorla, \"The Transport Layer
      Security\n               (TLS) Protocol Version 1.1\", RFC 4346, April 2006.\n
      \  [WHYIPSEC]  Bellovin, S., \"Guidelines for Specifying the Use of IPsec\n
      \              Version 2\", BCP 146, RFC 5406, February 2009.\n"
    title: 9.2.  Informative References
  title: 9.  References
- contents:
  - "Authors' Addresses\n   Eric Rescorla\n   RTFM, Inc.\n   2064 Edgewood Drive\n
    \  Palo Alto, CA 94303\n   EMail: ekr@rtfm.com\n   Nagendra Modadugu\n   Google,
    Inc.\n   EMail: nagendra@cs.stanford.edu\n"
  title: Authors' Addresses
