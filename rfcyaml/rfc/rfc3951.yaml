- title: __initial_text__
  contents:
  - '                   Internet Low Bit Rate Codec (iLBC)

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard of any kind.\n   Discussion\
    \ and suggestions for improvement are requested.\n   Distribution of this memo\
    \ is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2004).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies a speech codec suitable for robust voice\n\
    \   communication over IP.  The codec is developed by Global IP Sound\n   (GIPS).\
    \  It is designed for narrow band speech and results in a\n   payload bit rate\
    \ of 13.33 kbit/s for 30 ms frames and 15.20 kbit/s\n   for 20 ms frames.  The\
    \ codec enables graceful speech quality\n   degradation in the case of lost frames,\
    \ which occurs in connection\n   with lost or delayed IP packets.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  4\n   2.  Outline of the Codec . . . . . . . . . . . . . . . .\
    \ . . . . .  5\n       2.1.  Encoder. . . . . . . . . . . . . . . . . . . . .\
    \ . . . .  5\n       2.2.  Decoder. . . . . . . . . . . . . . . . . . . . . .\
    \ . . .  7\n   3.  Encoder Principles . . . . . . . . . . . . . . . . . . . .\
    \ . .  7\n       3.1.  Pre-processing . . . . . . . . . . . . . . . . . . . .\
    \ .  9\n       3.2.  LPC Analysis and Quantization. . . . . . . . . . . . . .\
    \  9\n             3.2.1.  Computation of Autocorrelation Coefficients. . . 10\n\
    \             3.2.2.  Computation of LPC Coefficients. . . . . . . . . 11\n  \
    \           3.2.3.  Computation of LSF Coefficients from LPC\n               \
    \      Coefficients . . . . . . . . . . . . . . . . . . 11\n             3.2.4.\
    \  Quantization of LSF Coefficients . . . . . . . . 12\n             3.2.5.  Stability\
    \ Check of LSF Coefficients. . . . . . . 13\n             3.2.6.  Interpolation\
    \ of LSF Coefficients. . . . . . . . 13\n             3.2.7.  LPC Analysis and\
    \ Quantization for 20 ms Frames . 14\n       3.3.  Calculation of the Residual.\
    \ . . . . . . . . . . . . . . 15\n       3.4.  Perceptual Weighting Filter. .\
    \ . . . . . . . . . . . . . 15\n       3.5.  Start State Encoder. . . . . . .\
    \ . . . . . . . . . . . . 15\n             3.5.1.  Start State Estimation . .\
    \ . . . . . . . . . . . 16\n             3.5.2.  All-Pass Filtering and Scale\
    \ Quantization. . . . 17\n             3.5.3.  Scalar Quantization. . . . . .\
    \ . . . . . . . . . 18\n       3.6.  Encoding the Remaining Samples . . . . .\
    \ . . . . . . . . 19\n             3.6.1.  Codebook Memory. . . . . . . . . .\
    \ . . . . . . . 20\n             3.6.2.  Perceptual Weighting of Codebook Memory\n\
    \                     and Target . . . . . . . . . . . . . . . . . . . 22\n  \
    \           3.6.3.  Codebook Creation. . . . . . . . . . . . . . . . 23\n    \
    \                 3.6.3.1. Creation of a Base Codebook . . . . . . 23\n      \
    \               3.6.3.2. Codebook Expansion. . . . . . . . . . . 24\n        \
    \             3.6.3.3. Codebook Augmentation . . . . . . . . . 24\n          \
    \   3.6.4.  Codebook Search. . . . . . . . . . . . . . . . . 26\n            \
    \         3.6.4.1. Codebook Search at Each Stage . . . . . 26\n              \
    \       3.6.4.2. Gain Quantization at Each Stage . . . . 27\n                \
    \     3.6.4.3. Preparation of Target for Next Stage. . 28\n       3.7.  Gain Correction\
    \ Encoding . . . . . . . . . . . . . . . . 28\n       3.8.  Bitstream Definition\
    \ . . . . . . . . . . . . . . . . . . 29\n   4.  Decoder Principles . . . . .\
    \ . . . . . . . . . . . . . . . . . 32\n       4.1.  LPC Filter Reconstruction.\
    \ . . . . . . . . . . . . . . . 33\n       4.2.  Start State Reconstruction .\
    \ . . . . . . . . . . . . . . 33\n       4.3.  Excitation Decoding Loop . . .\
    \ . . . . . . . . . . . . . 34\n       4.4.  Multistage Adaptive Codebook Decoding.\
    \ . . . . . . . . . 35\n             4.4.1.  Construction of the Decoded Excitation\
    \ Signal. . 35\n       4.5.  Packet Loss Concealment. . . . . . . . . . . . .\
    \ . . . . 35\n             4.5.1.  Block Received Correctly and Previous Block\n\
    \                     Also Received. . . . . . . . . . . . . . . . . . 35\n  \
    \           4.5.2.  Block Not Received . . . . . . . . . . . . . . . 36\n    \
    \         4.5.3.  Block Received Correctly When Previous Block\n             \
    \        Not Received . . . . . . . . . . . . . . . . . . 36\n       4.6.  Enhancement.\
    \ . . . . . . . . . . . . . . . . . . . . . . 37\n             4.6.1.  Estimating\
    \ the Pitch . . . . . . . . . . . . . . 39\n             4.6.2.  Determination\
    \ of the Pitch-Synchronous\n                     Sequences. . . . . . . . . .\
    \ . . . . . . . . . . 39\n             4.6.3.  Calculation of the Smoothed Excitation\
    \ . . . . . 41\n             4.6.4.  Enhancer Criterion . . . . . . . . . . .\
    \ . . . . 41\n             4.6.5.  Enhancing the Excitation . . . . . . . . .\
    \ . . . 42\n       4.7.  Synthesis Filtering. . . . . . . . . . . . . . . . .\
    \ . . 43\n       4.8.  Post Filtering . . . . . . . . . . . . . . . . . . . .\
    \ . 43\n   5.  Security Considerations. . . . . . . . . . . . . . . . . . . .\
    \ 43\n   6.  Evaluation of the iLBC Implementations . . . . . . . . . . . . 43\n\
    \   7.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 43\n  \
    \     7.1.  Normative References . . . . . . . . . . . . . . . . . . 43\n    \
    \   7.2.  Informative References . . . . . . . . . . . . . . . . . 44\n   8. \
    \ ACKNOWLEDGEMENTS . . . . . . . . . . . . . . . . . . . . . . . 44\n   APPENDIX\
    \ A: Reference Implementation . . . . . . . . . . . . . . . 45\n       A.1.  iLBC_test.c.\
    \ . . . . . . . . . . . . . . . . . . . . . . 46\n       A.2   iLBC_encode.h.\
    \ . . . . . . . . . . . . . . . . . . . . . 52\n       A.3.  iLBC_encode.c. .\
    \ . . . . . . . . . . . . . . . . . . . . 53\n       A.4.  iLBC_decode.h. . .\
    \ . . . . . . . . . . . . . . . . . . . 63\n       A.5.  iLBC_decode.c. . . .\
    \ . . . . . . . . . . . . . . . . . . 64\n       A.6.  iLBC_define.h. . . . .\
    \ . . . . . . . . . . . . . . . . . 76\n       A.7.  constants.h. . . . . . .\
    \ . . . . . . . . . . . . . . . . 80\n       A.8.  constants.c. . . . . . . .\
    \ . . . . . . . . . . . . . . . 82\n       A.9.  anaFilter.h. . . . . . . . .\
    \ . . . . . . . . . . . . . . 96\n       A.10. anaFilter.c. . . . . . . . . .\
    \ . . . . . . . . . . . . . 97\n       A.11. createCB.h . . . . . . . . . . .\
    \ . . . . . . . . . . . . 98\n       A.12. createCB.c . . . . . . . . . . . .\
    \ . . . . . . . . . . . 99\n       A.13. doCPLC.h . . . . . . . . . . . . . .\
    \ . . . . . . . . . .104\n       A.14. doCPLC.c . . . . . . . . . . . . . . .\
    \ . . . . . . . . .104\n       A.15. enhancer.h . . . . . . . . . . . . . . .\
    \ . . . . . . . .109\n       A.16. enhancer.c . . . . . . . . . . . . . . . .\
    \ . . . . . . .110\n       A.17. filter.h . . . . . . . . . . . . . . . . . .\
    \ . . . . . .123\n       A.18. filter.c . . . . . . . . . . . . . . . . . . .\
    \ . . . . .125\n       A.19. FrameClassify.h. . . . . . . . . . . . . . . . .\
    \ . . . .128\n       A.20. FrameClassify.c. . . . . . . . . . . . . . . . . .\
    \ . . .129\n       A.21. gainquant.h. . . . . . . . . . . . . . . . . . . . .\
    \ . .131\n       A.22. gainquant.c. . . . . . . . . . . . . . . . . . . . . .\
    \ .131\n       A.23. getCBvec.h . . . . . . . . . . . . . . . . . . . . . . .134\n\
    \       A.24. getCBvec.c . . . . . . . . . . . . . . . . . . . . . . .134\n  \
    \     A.25. helpfun.h. . . . . . . . . . . . . . . . . . . . . . . .138\n    \
    \   A.26. helpfun.c. . . . . . . . . . . . . . . . . . . . . . . .140\n      \
    \ A.27. hpInput.h. . . . . . . . . . . . . . . . . . . . . . . .146\n       A.28.\
    \ hpInput.c. . . . . . . . . . . . . . . . . . . . . . . .146\n       A.29. hpOutput.h\
    \ . . . . . . . . . . . . . . . . . . . . . . .148\n       A.30. hpOutput.c .\
    \ . . . . . . . . . . . . . . . . . . . . . .148\n       A.31. iCBConstruct.h\
    \ . . . . . . . . . . . . . . . . . . . . .149\n       A.32. iCBConstruct.c .\
    \ . . . . . . . . . . . . . . . . . . . .150\n       A.33. iCBSearch.h. . . .\
    \ . . . . . . . . . . . . . . . . . . .152\n       A.34. iCBSearch.c. . . . .\
    \ . . . . . . . . . . . . . . . . . .153\n       A.35. LPCdecode.h. . . . . .\
    \ . . . . . . . . . . . . . . . . .163\n       A.36. LPCdecode.c. . . . . . .\
    \ . . . . . . . . . . . . . . . .164\n       A.37. LPCencode.h. . . . . . . .\
    \ . . . . . . . . . . . . . . .167\n       A.38. LPCencode.c. . . . . . . . .\
    \ . . . . . . . . . . . . . .167\n       A.39. lsf.h. . . . . . . . . . . . .\
    \ . . . . . . . . . . . . .172\n       A.40. lsf.c. . . . . . . . . . . . . .\
    \ . . . . . . . . . . . .172\n       A.41. packing.h. . . . . . . . . . . . .\
    \ . . . . . . . . . . .178\n       A.42. packing.c. . . . . . . . . . . . . .\
    \ . . . . . . . . . .179\n       A.43. StateConstructW.h. . . . . . . . . . .\
    \ . . . . . . . . .182\n       A.44. StateConstructW.c. . . . . . . . . . . .\
    \ . . . . . . . .183\n       A.45. StateSearchW.h . . . . . . . . . . . . . .\
    \ . . . . . . .185\n       A.46. StateSearchW.c . . . . . . . . . . . . . . .\
    \ . . . . . .186\n       A.47. syntFilter.h . . . . . . . . . . . . . . . . .\
    \ . . . . .190\n       A.48. syntFilter.c . . . . . . . . . . . . . . . . . .\
    \ . . . .190\n   Authors' Addresses . . . . . . . . . . . . . . . . . . . . .\
    \ . . .192\n   Full Copyright Statement . . . . . . . . . . . . . . . . . . .\
    \ . .194\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document contains the description of an algorithm for\
    \ the coding\n   of speech signals sampled at 8 kHz.  The algorithm, called iLBC,\
    \ uses\n   a block-independent linear-predictive coding (LPC) algorithm and has\n\
    \   support for two basic frame lengths: 20 ms at 15.2 kbit/s and 30 ms\n   at\
    \ 13.33 kbit/s.  When the codec operates at block lengths of 20 ms,\n   it produces\
    \ 304 bits per block, which SHOULD be packetized as in [1].\n   Similarly, for\
    \ block lengths of 30 ms it produces 400 bits per block,\n   which SHOULD be packetized\
    \ as in [1].  The two modes for the\n   different frame sizes operate in a very\
    \ similar way.  When they\n   differ it is explicitly stated in the text, usually\
    \ with the notation\n   x/y, where x refers to the 20 ms mode and y refers to\
    \ the 30 ms mode.\n   The described algorithm results in a speech coding system\
    \ with a\n   controlled response to packet losses similar to what is known from\n\
    \   pulse code modulation (PCM) with packet loss concealment (PLC), such\n   as\
    \ the ITU-T G.711 standard [4], which operates at a fixed bit rate\n   of 64 kbit/s.\
    \  At the same time, the described algorithm enables\n   fixed bit rate coding\
    \ with a quality-versus-bit rate tradeoff close\n   to state-of-the-art.  A suitable\
    \ RTP payload format for the iLBC\n   codec is specified in [1].\n   Some of the\
    \ applications for which this coder is suitable are real\n   time communications\
    \ such as telephony and videoconferencing,\n   streaming audio, archival, and\
    \ messaging.\n   Cable Television Laboratories (CableLabs(R)) has adopted iLBC\
    \ as a\n   mandatory PacketCable(TM) audio codec standard for VoIP over Cable\n\
    \   applications [3].\n   This document is organized as follows.  Section 2 gives\
    \ a brief\n   outline of the codec.  The specific encoder and decoder algorithms\n\
    \   are explained in sections 3 and 4, respectively.  Appendix A provides\n  \
    \ a c-code reference implementation.\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in BCP 14, RFC 2119 [2].\n"
- title: 2.  Outline of the Codec
  contents:
  - "2.  Outline of the Codec\n   The codec consists of an encoder and a decoder as\
    \ described in\n   sections 2.1 and 2.2, respectively.\n   The essence of the\
    \ codec is LPC and block-based coding of the LPC\n   residual signal.  For each\
    \ 160/240 (20 ms/30 ms) sample block, the\n   following major steps are performed:\
    \ A set of LPC filters are\n   computed, and the speech signal is filtered through\
    \ them to produce\n   the residual signal.  The codec uses scalar quantization\
    \ of the\n   dominant part, in terms of energy, of the residual signal for the\n\
    \   block.  The dominant state is of length 57/58 (20 ms/30 ms) samples\n   and\
    \ forms a start state for dynamic codebooks constructed from the\n   already coded\
    \ parts of the residual signal.  These dynamic codebooks\n   are used to code\
    \ the remaining parts of the residual signal.  By this\n   method, coding independence\
    \ between blocks is achieved, resulting in\n   elimination of propagation of perceptual\
    \ degradations due to packet\n   loss.  The method facilitates high-quality packet\
    \ loss concealment\n   (PLC).\n"
- title: 2.1.  Encoder
  contents:
  - "2.1.  Encoder\n   The input to the encoder SHOULD be 16 bit uniform PCM sampled\
    \ at 8\n   kHz.  It SHOULD be partitioned into blocks of BLOCKL=160/240 samples\n\
    \   for the 20/30 ms frame size.  Each block is divided into NSUB=4/6\n   consecutive\
    \ sub-blocks of SUBL=40 samples each.  For 30 ms frame\n   size, the encoder performs\
    \ two LPC_FILTERORDER=10 linear-predictive\n   coding (LPC) analyses.  The first\
    \ analysis applies a smooth window\n   centered over the second sub-block and\
    \ extending to the middle of the\n   fifth sub-block.  The second LPC analysis\
    \ applies a smooth asymmetric\n   window centered over the fifth sub-block and\
    \ extending to the end of\n   the sixth sub-block.  For 20 ms frame size, one\
    \ LPC_FILTERORDER=10\n   linear-predictive coding (LPC) analysis is performed\
    \ with a smooth\n   window centered over the third sub-frame.\n   For each of\
    \ the LPC analyses, a set of line-spectral frequencies\n   (LSFs) are obtained,\
    \ quantized, and interpolated to obtain LSF\n   coefficients for each sub-block.\
    \  Subsequently, the LPC residual is\n   computed by using the quantized and interpolated\
    \ LPC analysis\n   filters.\n   The two consecutive sub-blocks of the residual\
    \ exhibiting the maximal\n   weighted energy are identified.  Within these two\
    \ sub-blocks, the\n   start state (segment) is selected from two choices: the\
    \ first 57/58\n   samples or the last 57/58 samples of the two consecutive sub-blocks.\n\
    \   The selected segment is the one of higher energy.  The start state is\n  \
    \ encoded with scalar quantization.\n   A dynamic codebook encoding procedure\
    \ is used to encode 1) the 23/22\n   (20 ms/30 ms) remaining samples in the two\
    \ sub-blocks containing the\n   start state; 2) the sub-blocks after the start\
    \ state in time; and 3)\n   the sub-blocks before the start state in time.  Thus,\
    \ the encoding\n   target can be either the 23/22 samples remaining of the two\
    \ sub-\n   blocks containing the start state or a 40-sample sub-block.  This\n\
    \   target can consist of samples indexed forward in time or backward in\n   time,\
    \ depending on the location of the start state.\n   The codebook coding is based\
    \ on an adaptive codebook built from a\n   codebook memory that contains decoded\
    \ LPC excitation samples from the\n   already encoded part of the block.  These\
    \ samples are indexed in the\n   same time direction as the target vector, ending\
    \ at the sample\n   instant prior to the first sample instant represented in the\
    \ target\n   vector.  The codebook is used in CB_NSTAGES=3 stages in a successive\n\
    \   refinement approach, and the resulting three code vector gains are\n   encoded\
    \ with 5-, 4-, and 3-bit scalar quantization, respectively.\n   The codebook search\
    \ method employs noise shaping derived from the LPC\n   filters, and the main\
    \ decision criterion is to minimize the squared\n   error between the target vector\
    \ and the code vectors.  Each code\n   vector in this codebook comes from one\
    \ of CB_EXPAND=2 codebook\n   sections.  The first section is filled with delayed,\
    \ already encoded\n   residual vectors.  The code vectors of the second codebook\
    \ section\n   are constructed by predefined linear combinations of vectors in\
    \ the\n   first section of the codebook.\n   As codebook encoding with squared-error\
    \ matching is known to produce\n   a coded signal of less power than does the\
    \ scalar quantized start\n   state signal, a gain re-scaling method is implemented\
    \ by a refined\n   search for a better set of codebook gains in terms of power\
    \ matching\n   after encoding.  This is done by searching for a higher value of\
    \ the\n   gain factor for the first stage codebook, as the subsequent stage\n\
    \   codebook gains are scaled by the first stage gain.\n"
- title: 2.2.  Decoder
  contents:
  - "2.2.  Decoder\n   Typically for packet communications, a jitter buffer placed\
    \ at the\n   receiving end decides whether the packet containing an encoded signal\n\
    \   block has been received or lost.  This logic is not part of the codec\n  \
    \ described here.  For each encoded signal block received the decoder\n   performs\
    \ a decoding.  For each lost signal block, the decoder\n   performs a PLC operation.\n\
    \   The decoding for each block starts by decoding and interpolating the\n   LPC\
    \ coefficients.  Subsequently the start state is decoded.\n   For codebook-encoded\
    \ segments, each segment is decoded by\n   constructing the three code vectors\
    \ given by the received codebook\n   indices in the same way that the code vectors\
    \ were constructed in the\n   encoder.  The three gain factors are also decoded\
    \ and the resulting\n   decoded signal is given by the sum of the three codebook\
    \ vectors\n   scaled with respective gain.\n   An enhancement algorithm is applied\
    \ to the reconstructed excitation\n   signal.  This enhancement augments the periodicity\
    \ of voiced speech\n   regions.  The enhancement is optimized under the constraint\
    \ that the\n   modification signal (defined as the difference between the enhanced\n\
    \   excitation and the excitation signal prior to enhancement) has a\n   short-time\
    \ energy that does not exceed a preset fraction of the\n   short-time energy of\
    \ the excitation signal prior to enhancement.\n   A packet loss concealment (PLC)\
    \ operation is easily embedded in the\n   decoder.  The PLC operation can, e.g.,\
    \ be based on repeating LPC\n   filters and obtaining the LPC residual signal\
    \ by using a long-term\n   prediction estimate from previous residual blocks.\n"
- title: 3.  Encoder Principles
  contents:
  - "3.  Encoder Principles\n   The following block diagram is an overview of all\
    \ the components of\n   the iLBC encoding procedure.  The description of the blocks\
    \ contains\n   references to the section where that particular procedure is further\n\
    \   described.\n             +-----------+    +---------+    +---------+\n   speech\
    \ -> | 1. Pre P  | -> | 2. LPC  | -> | 3. Ana  | ->\n             +-----------+\
    \    +---------+    +---------+\n             +---------------+   +--------------+\n\
    \          -> | 4. Start Sel  | ->| 5. Scalar Qu | ->\n             +---------------+\
    \   +--------------+\n             +--------------+    +---------------+\n   \
    \       -> |6. CB Search  | -> | 7. Packetize  | -> payload\n          |  +--------------+\
    \ |  +---------------+\n          ----<---------<------\n       sub-frame 0..2/4\
    \ (20 ms/30 ms)\n   Figure 3.1. Flow chart of the iLBC encoder\n   1. Pre-process\
    \ speech with a HP filter, if needed (section 3.1).\n   2. Compute LPC parameters,\
    \ quantize, and interpolate (section 3.2).\n   3. Use analysis filters on speech\
    \ to compute residual (section 3.3).\n   4. Select position of 57/58-sample start\
    \ state (section 3.5).\n   5. Quantize the 57/58-sample start state with scalar\
    \ quantization\n      (section 3.5).\n   6. Search the codebook for each sub-frame.\
    \  Start with 23/22 sample\n      block, then encode sub-blocks forward in time,\
    \ and then encode\n      sub-blocks backward in time.  For each block, the steps\
    \ in Figure\n      3.4 are performed (section 3.6).\n   7. Packetize the bits\
    \ into the payload specified in Table 3.2.\n   The input to the encoder SHOULD\
    \ be 16-bit uniform PCM sampled at 8\n   kHz.  Also it SHOULD be partitioned into\
    \ blocks of BLOCKL=160/240\n   samples.  Each block input to the encoder is divided\
    \ into NSUB=4/6\n   consecutive sub-blocks of SUBL=40 samples each.\n        \
    \     0        39        79       119       159\n             +---------------------------------------+\n\
    \             |    1    |    2    |    3    |    4    |\n             +---------------------------------------+\n\
    \                            20 ms frame\n   0        39        79       119 \
    \      159       199       239\n   +-----------------------------------------------------------+\n\
    \   |    1    |    2    |    3    |    4    |    5    |    6    |\n   +-----------------------------------------------------------+\n\
    \                                  30 ms frame\n   Figure 3.2. One input block\
    \ to the encoder for 20 ms (with four sub-\n   frames) and 30 ms (with six sub-frames).\n"
- title: 3.1.  Pre-processing
  contents:
  - "3.1.  Pre-processing\n   In some applications, the recorded speech signal contains\
    \ DC level\n   and/or 50/60 Hz noise.  If these components have not been removed\n\
    \   prior to the encoder call, they should be removed by a high-pass\n   filter.\
    \  A reference implementation of this, using a filter with a\n   cutoff frequency\
    \ of 90 Hz, can be found in Appendix A.28.\n"
- title: 3.2.  LPC Analysis and Quantization
  contents:
  - "3.2.  LPC Analysis and Quantization\n   The input to the LPC analysis module\
    \ is a possibly high-pass filtered\n   speech buffer, speech_hp, that contains\
    \ 240/300 (LPC_LOOKBACK +\n   BLOCKL = 80/60 + 160/240 = 240/300) speech samples,\
    \ where samples 0\n   through 79/59 are from the previous block and samples 80/60\
    \ through\n   239/299 are from the current block.  No look-ahead into the next\n\
    \   block is used.  For the very first block processed, the look-back\n   samples\
    \ are assumed to be zeros.\n   For each input block, the LPC analysis calculates\
    \ one/two set(s) of\n   LPC_FILTERORDER=10 LPC filter coefficients using the autocorrelation\n\
    \   method and the Levinson-Durbin recursion.  These coefficients are\n   converted\
    \ to the Line Spectrum Frequency representation.  In the 20\n   ms case, the single\
    \ lsf set represents the spectral characteristics\n   as measured at the center\
    \ of the third sub-block.  For 30 ms frames,\n   the first set, lsf1, represents\
    \ the spectral properties of the input\n   signal at the center of the second\
    \ sub-block, and the other set,\n   lsf2, represents the spectral characteristics\
    \ as measured at the\n   center of the fifth sub-block.  The details of the computation\
    \ for 30\n   ms frames are described in sections 3.2.1 through 3.2.6.  Section\n\
    \   3.2.7 explains how the LPC Analysis and Quantization differs for 20\n   ms\
    \ frames.\n"
- title: 3.2.1.  Computation of Autocorrelation Coefficients
  contents:
  - "3.2.1.  Computation of Autocorrelation Coefficients\n   The first step in the\
    \ LPC analysis procedure is to calculate\n   autocorrelation coefficients by using\
    \ windowed speech samples.  This\n   windowing is the only difference in the LPC\
    \ analysis procedure for\n   the two sets of coefficients.  For the first set,\
    \ a 240-sample-long\n   standard symmetric Hanning window is applied to samples\
    \ 0 through 239\n   of the input data.  The first window, lpc_winTbl, is defined\
    \ as\n      lpc_winTbl[i]= 0.5 * (1.0 - cos((2*PI*(i+1))/(BLOCKL+1)));\n     \
    \          i=0,...,119\n      lpc_winTbl[i] = winTbl[BLOCKL - i - 1]; i=120,...,239\n\
    \   The windowed speech speech_hp_win1 is then obtained by multiplying\n   the\
    \ first 240 samples of the input speech buffer with the window\n   coefficients:\n\
    \      speech_hp_win1[i] = speech_hp[i] * lpc_winTbl[i];\n               i=0,...,BLOCKL-1\n\
    \   From these 240 windowed speech samples, 11 (LPC_FILTERORDER + 1)\n   autocorrelation\
    \ coefficients, acf1, are calculated:\n      acf1[lag] += speech_hp_win1[n] *\
    \ speech_hp_win1[n + lag];\n               lag=0,...,LPC_FILTERORDER; n=0,...,BLOCKL-lag-1\n\
    \   In order to make the analysis more robust against numerical precision\n  \
    \ problems, a spectral smoothing procedure is applied by windowing the\n   autocorrelation\
    \ coefficients before the LPC coefficients are\n   computed.  Also, a white noise\
    \ floor is added to the autocorrelation\n   function by multiplying coefficient\
    \ zero by 1.0001 (40dB below the\n   energy of the windowed speech signal).  These\
    \ two steps are\n   implemented by multiplying the autocorrelation coefficients\
    \ with the\n   following window:\n      lpc_lagwinTbl[0] = 1.0001;\n      lpc_lagwinTbl[i]\
    \ = exp(-0.5 * ((2 * PI * 60.0 * i) /FS)^2);\n               i=1,...,LPC_FILTERORDER\n\
    \               where FS=8000 is the sampling frequency\n   Then, the windowed\
    \ acf function acf1_win is obtained by\n      acf1_win[i] = acf1[i] * lpc_lagwinTbl[i];\n\
    \               i=0,...,LPC_FILTERORDER\n   The second set of autocorrelation\
    \ coefficients, acf2_win, are\n   obtained in a similar manner.  The window, lpc_asymwinTbl,\
    \ is applied\n   to samples 60 through 299, i.e., the entire current block.  The\n\
    \   window consists of two segments, the first (samples 0 to 219) being\n   half\
    \ a Hanning window with length 440 and the second a quarter of a\n   cycle of\
    \ a cosine wave.  By using this asymmetric window, an LPC\n   analysis centered\
    \ in the fifth sub-block is obtained without the need\n   for any look-ahead,\
    \ which would add delay.  The asymmetric window is\n   defined as\n      lpc_asymwinTbl[i]\
    \ = (sin(PI * (i + 1) / 441))^2; i=0,...,219\n      lpc_asymwinTbl[i] = cos((i\
    \ - 220) * PI / 40); i=220,...,239\n   and the windowed speech is computed by\n\
    \      speech_hp_win2[i] = speech_hp[i + LPC_LOOKBACK] *\n               lpc_asymwinTbl[i];\
    \  i=0,....BLOCKL-1\n   The windowed autocorrelation coefficients are then obtained\
    \ in\n   exactly the same way as for the first analysis instance.\n   The generation\
    \ of the windows lpc_winTbl, lpc_asymwinTbl, and\n   lpc_lagwinTbl are typically\
    \ done in advance, and the arrays are\n   stored in ROM rather than repeating\
    \ the calculation for every block.\n"
- title: 3.2.2.  Computation of LPC Coefficients
  contents:
  - "3.2.2.  Computation of LPC Coefficients\n   From the 2 x 11 smoothed autocorrelation\
    \ coefficients, acf1_win and\n   acf2_win, the 2 x 11 LPC coefficients, lp1 and\
    \ lp2, are calculated\n   in the same way for both analysis locations by using\
    \ the well known\n   Levinson-Durbin recursion.  The first LPC coefficient is\
    \ always 1.0,\n   resulting in ten unique coefficients.\n   After determining\
    \ the LPC coefficients, a bandwidth expansion\n   procedure is applied to smooth\
    \ the spectral peaks in the\n   short-term spectrum.  The bandwidth addition is\
    \ obtained by the\n   following modification of the LPC coefficients:\n      lp1_bw[i]\
    \ = lp1[i] * chirp^i; i=0,...,LPC_FILTERORDER\n      lp2_bw[i] = lp2[i] * chirp^i;\
    \ i=0,...,LPC_FILTERORDER\n   where \"chirp\" is a real number between 0 and 1.\
    \  It is RECOMMENDED to\n   use a value of 0.9.\n"
- title: 3.2.3.  Computation of LSF Coefficients from LPC Coefficients
  contents:
  - "3.2.3.  Computation of LSF Coefficients from LPC Coefficients\n   Thus far, two\
    \ sets of LPC coefficients that represent the short-term\n   spectral characteristics\
    \ of the speech signal for two different time\n   locations within the current\
    \ block have been determined.  These\n   coefficients SHOULD be quantized and\
    \ interpolated.  Before this is\n   done, it is advantageous to convert the LPC\
    \ parameters into another\n   type of representation called Line Spectral Frequencies\
    \ (LSF).  The\n   LSF parameters are used because they are better suited for\n\
    \   quantization and interpolation than the regular LPC coefficients.\n   Many\
    \ computationally efficient methods for calculating the LSFs from\n   the LPC\
    \ coefficients have been proposed in the literature.  The\n   detailed implementation\
    \ of one applicable method can be found in\n   Appendix A.26.  The two arrays\
    \ of LSF coefficients obtained, lsf1 and\n   lsf2, are of dimension 10 (LPC_FILTERORDER).\n"
- title: 3.2.4.  Quantization of LSF Coefficients
  contents:
  - "3.2.4.  Quantization of LSF Coefficients\n   Because the LPC filters defined\
    \ by the two sets of LSFs are also\n   needed in the decoder, the LSF parameters\
    \ need to be quantized and\n   transmitted as side information.  The total number\
    \ of bits required\n   to represent the quantization of the two LSF representations\
    \ for one\n   block of speech is 40, with 20 bits used for each of lsf1 and lsf2.\n\
    \   For computational and storage reasons, the LSF vectors are quantized\n   using\
    \ three-split vector quantization (VQ).  That is, the LSF vectors\n   are split\
    \ into three sub-vectors that are each quantized with a\n   regular VQ.  The quantized\
    \ versions of lsf1 and lsf2, qlsf1 and\n   qlsf2, are obtained by using the same\
    \ memoryless split VQ.  The\n   length of each of these two LSF vectors is 10,\
    \ and they are split\n   into three sub-vectors containing 3, 3, and 4 values,\
    \ respectively.\n   For each of the sub-vectors, a separate codebook of quantized\
    \ values\n   has been designed with a standard VQ training method for a large\n\
    \   database containing speech from a large number of speakers recorded\n   under\
    \ various conditions.  The size of each of the three codebooks\n   associated\
    \ with the split definitions above is\n      int size_lsfCbTbl[LSF_NSPLIT] = {64,128,128};\n\
    \   The actual values of the vector quantization codebook that must be\n   used\
    \ can be found in the reference code of Appendix A.  Both sets of\n   LSF coefficients,\
    \ lsf1 and lsf2, are quantized with a standard\n   memoryless split vector quantization\
    \ (VQ) structure using the squared\n   error criterion in the LSF domain.  The\
    \ split VQ quantization\n   consists of the following steps:\n   1) Quantize the\
    \ first three LSF coefficients (1 - 3) with a VQ\n      codebook of size 64.\n\
    \   2) Quantize the next three LSF coefficients 4 - 6 with VQ a codebook\n   \
    \   of size 128.\n   3) Quantize the last four LSF coefficients (7 - 10) with\
    \ a VQ\n      codebook of size 128.\n   This procedure, repeated for lsf1 and\
    \ lsf2, gives six quantization\n   indices and the quantized sets of LSF coefficients\
    \ qlsf1 and qlsf2.\n   Each set of three indices is encoded with 6 + 7 + 7 = 20\
    \ bits.  The\n   total number of bits used for LSF quantization in a block is\
    \ thus 40\n   bits.\n"
- title: 3.2.5.  Stability Check of LSF Coefficients
  contents:
  - "3.2.5.  Stability Check of LSF Coefficients\n   The LSF representation of the\
    \ LPC filter has the convenient property\n   that the coefficients are ordered\
    \ by increasing value, i.e., lsf(n-1)\n   < lsf(n), 0 < n < 10, if the corresponding\
    \ synthesis filter is\n   stable.  As we are employing a split VQ scheme, it is\
    \ possible that\n   at the split boundaries the LSF coefficients are not ordered\n\
    \   correctly and hence that the corresponding LP filter is unstable.  To\n  \
    \ ensure that the filter used is stable, a stability check is performed\n   for\
    \ the quantized LSF vectors.  If it turns out that the coefficients\n   are not\
    \ ordered appropriately (with a safety margin of 50 Hz to\n   ensure that formant\
    \ peaks are not too narrow), they will be moved\n   apart.  The detailed method\
    \ for this can be found in Appendix A.40.\n   The same procedure is performed\
    \ in the decoder.  This ensures that\n   exactly the same LSF representations\
    \ are used in both encoder and\n   decoder.\n"
- title: 3.2.6.  Interpolation of LSF Coefficients
  contents:
  - "3.2.6.  Interpolation of LSF Coefficients\n   From the two sets of LSF coefficients\
    \ that are computed for each\n   block of speech, different LSFs are obtained\
    \ for each sub-block by\n   means of interpolation.  This procedure is performed\
    \ for the original\n   LSFs (lsf1 and lsf2), as well as the quantized versions\
    \ qlsf1 and\n   qlsf2, as both versions are used in the encoder.  Here follows\
    \ a\n   brief summary of the interpolation scheme; the details are found in\n\
    \   the c-code of Appendix A.  In the first sub-block, the average of the\n  \
    \ second LSF vector from the previous block and the first LSF vector in\n   the\
    \ current block is used.  For sub-blocks two through five, the LSFs\n   used are\
    \ obtained by linear interpolation from lsf1 (and qlsf1) to\n   lsf2 (and qlsf2),\
    \ with lsf1 used in sub-block two and lsf2 in sub-\n   block five.  In the last\
    \ sub-block, lsf2 is used.  For the very first\n   block it is assumed that the\
    \ last LSF vector of the previous block is\n   equal to a predefined vector, lsfmeanTbl,\
    \ obtained by calculating the\n   mean LSF vector of the LSF design database.\n\
    \   lsfmeanTbl[LPC_FILTERORDER] = {0.281738, 0.445801, 0.663330,\n           \
    \       0.962524, 1.251831, 1.533081, 1.850586, 2.137817,\n                  2.481445,\
    \ 2.777344}\n   The interpolation method is standard linear interpolation in the\
    \ LSF\n   domain.  The interpolated LSF values are converted to LPC\n   coefficients\
    \ for each sub-block.  The unquantized and quantized LPC\n   coefficients form\
    \ two sets of filters respectively.  The unquantized\n   analysis filter for sub-block\
    \ k is defined as follows\n                ___\n                \\\n      Ak(z)=\
    \ 1 + > ak(i)*z^(-i)\n                /__\n             i=1...LPC_FILTERORDER\n\
    \   The quantized analysis filter for sub-block k is defined as follows\n    \
    \             ___\n                 \\\n      A~k(z)= 1 + > a~k(i)*z^(-i)\n  \
    \               /__\n             i=1...LPC_FILTERORDER\n   A reference implementation\
    \ of the lsf encoding is given in Appendix\n   A.38.  A reference implementation\
    \ of the corresponding decoding can\n   be found in Appendix A.36.\n"
- title: 3.2.7.  LPC Analysis and Quantization for 20 ms Frames
  contents:
  - "3.2.7.  LPC Analysis and Quantization for 20 ms Frames\n   As previously stated,\
    \ the codec only calculates one set of LPC\n   parameters for the 20 ms frame\
    \ size as opposed to two sets for 30 ms\n   frames.  A single set of autocorrelation\
    \ coefficients is calculated\n   on the LPC_LOOKBACK + BLOCKL = 80 + 160 = 240\
    \ samples.  These samples\n   are windowed with the asymmetric window lpc_asymwinTbl,\
    \ centered over\n   the third sub-frame, to form speech_hp_win.  Autocorrelation\n\
    \   coefficients, acf, are calculated on the 240 samples in speech_hp_win\n  \
    \ and then windowed exactly as in section 3.2.1 (resulting in\n   acf_win).\n\
    \   This single set of windowed autocorrelation coefficients is used to\n   calculate\
    \ LPC coefficients, LSF coefficients, and quantized LSF\n   coefficients in exactly\
    \ the same manner as in sections 3.2.3 through\n   3.2.4.  As for the 30 ms frame\
    \ size, the ten LSF coefficients are\n   divided into three sub-vectors of size\
    \ 3, 3, and 4 and quantized by\n   using the same scheme and codebook as in section\
    \ 3.2.4 to finally get\n   3 quantization indices.  The quantized LSF coefficients\
    \ are\n   stabilized with the algorithm described in section 3.2.5.\n   From the\
    \ set of LSF coefficients computed for this block and those\n   from the previous\
    \ block, different LSFs are obtained for each sub-\n   block by means of interpolation.\
    \  The interpolation is done linearly\n   in the LSF domain over the four sub-blocks,\
    \ so that the n-th sub-\n   frame uses the weight (4-n)/4 for the LSF from old\
    \ frame and the\n   weight n/4 of the LSF from the current frame.  For the very\
    \ first\n   block the mean LSF, lsfmeanTbl, is used as the LSF from the previous\n\
    \   block.  Similarly as seen in section 3.2.6, both unquantized, A(z),\n   and\
    \ quantized, A~(z), analysis filters are calculated for each of the\n   four sub-blocks.\n"
- title: 3.3.  Calculation of the Residual
  contents:
  - "3.3.  Calculation of the Residual\n   The block of speech samples is filtered\
    \ by the quantized and\n   interpolated LPC analysis filters to yield the residual\
    \ signal.  In\n   particular, the corresponding LPC analysis filter for each 40\
    \ sample\n   sub-block is used to filter the speech samples for the same sub-\n\
    \   block.  The filter memory at the end of each sub-block is carried\n   over\
    \ to the LPC filter of the next sub-block.  The signal at the\n   output of each\
    \ LP analysis filter constitutes the residual signal for\n   the corresponding\
    \ sub-block.\n   A reference implementation of the LPC analysis filters is given\
    \ in\n   Appendix A.10.\n"
- title: 3.4.  Perceptual Weighting Filter
  contents:
  - "3.4.  Perceptual Weighting Filter\n   In principle any good design of a perceptual\
    \ weighting filter can be\n   applied in the encoder without compromising this\
    \ codec definition.\n   However, it is RECOMMENDED to use the perceptual weighting\
    \ filter Wk\n   for sub-block k specified below:\n      Wk(z)=1/Ak(z/LPC_CHIRP_WEIGHTDENUM),\
    \ where\n                               LPC_CHIRP_WEIGHTDENUM = 0.4222\n   This\
    \ is a simple design with low complexity that is applied in the\n   LPC residual\
    \ domain.  Here Ak(z) is the filter obtained for sub-block\n   k from unquantized\
    \ but interpolated LSF coefficients.\n"
- title: 3.5.  Start State Encoder
  contents:
  - "3.5.  Start State Encoder\n   The start state is quantized by using a common\
    \ 6-bit scalar quantizer\n   for the block and a 3-bit scalar quantizer operating\
    \ on scaled\n   samples in the weighted speech domain.  In the following we describe\n\
    \   the state encoding in greater detail.\n"
- title: 3.5.1.  Start State Estimation
  contents:
  - "3.5.1.  Start State Estimation\n   The two sub-blocks containing the start state\
    \ are determined by\n   finding the two consecutive sub-blocks in the block having\
    \ the\n   highest power.  Advantageously, down-weighting is used in the\n   beginning\
    \ and end of the sub-frames, i.e., the following measure is\n   computed (NSUB=4/6\
    \ for 20/30 ms frame size):\n      nsub=1,...,NSUB-1\n      ssqn[nsub] = 0.0;\n\
    \      for (i=(nsub-1)*SUBL; i<(nsub-1)*SUBL+5; i++)\n               ssqn[nsub]\
    \ += sampEn_win[i-(nsub-1)*SUBL]*\n                                 residual[i]*residual[i];\n\
    \      for (i=(nsub-1)*SUBL+5; i<(nsub+1)*SUBL-5; i++)\n               ssqn[nsub]\
    \ += residual[i]*residual[i];\n      for (i=(nsub+1)*SUBL-5; i<(nsub+1)*SUBL;\
    \ i++)\n               ssqn[nsub] += sampEn_win[(nsub+1)*SUBL-i-1]*\n        \
    \                         residual[i]*residual[i];\n   where sampEn_win[5]={1/6,\
    \ 2/6, 3/6, 4/6, 5/6}; MAY be used.  The\n   sub-frame number corresponding to\
    \ the maximum value of\n   ssqEn_win[nsub-1]*ssqn[nsub] is selected as the start\
    \ state\n   indicator.  A weighting of ssqEn_win[]={0.8,0.9,1.0,0.9,0.8} for 30\n\
    \   ms frames and ssqEn_win[]={0.9,1.0,0.9} for 20 ms frames; MAY\n   advantageously\
    \ be used to bias the start state towards the middle of\n   the frame.\n   For\
    \ 20 ms frames there are three possible positions for the two-sub-\n   block length\
    \ maximum power segment; the start state position is\n   encoded with 2 bits.\
    \  The start state position, start, MUST be\n   encoded as\n      start=1: start\
    \ state in sub-frame 0 and 1\n      start=2: start state in sub-frame 1 and 2\n\
    \      start=3: start state in sub-frame 2 and 3\n   For 30 ms frames there are\
    \ five possible positions of the two-sub-\n   block length maximum power segment,\
    \ the start state position is\n   encoded with 3 bits.  The start state position,\
    \ start, MUST be\n   encoded as\n      start=1: start state in sub-frame 0 and\
    \ 1\n      start=2: start state in sub-frame 1 and 2\n      start=3: start state\
    \ in sub-frame 2 and 3\n      start=4: start state in sub-frame 3 and 4\n    \
    \  start=5: start state in sub-frame 4 and 5\n   Hence, in both cases, index 0\
    \ is not used.  In order to shorten the\n   start state for bit rate efficiency,\
    \ the start state is brought down\n   to STATE_SHORT_LEN=57 samples for 20 ms\
    \ frames and STATE_SHORT_LEN=58\n   samples for 30 ms frames.  The power of the\
    \ first 23/22 and last\n   23/22 samples of the two sub-frame blocks identified\
    \ above is\n   computed as the sum of the squared signal sample values, and the\n\
    \   23/22-sample segment with the lowest power is excluded from the start\n  \
    \ state.  One bit is transmitted to indicate which of the two possible\n   57/58\
    \ sample segments is used.  The start state position within the\n   two sub-frames\
    \ determined above, state_first, MUST be encoded as\n      state_first=1: start\
    \ state is first STATE_SHORT_LEN samples\n      state_first=0: start state is\
    \ last STATE_SHORT_LEN samples\n"
- title: 3.5.2.  All-Pass Filtering and Scale Quantization
  contents:
  - "3.5.2.  All-Pass Filtering and Scale Quantization\n   The block of residual samples\
    \ in the start state is first filtered by\n   an all-pass filter with the quantized\
    \ LPC coefficients as denominator\n   and reversed quantized LPC coefficients\
    \ as numerator.  The purpose of\n   this phase-dispersion filter is to get a more\
    \ even distribution of\n   the sample values in the residual signal.  The filtering\
    \ is performed\n   by circular convolution, where the initial filter memory is\
    \ set to\n   zero.\n      res(0..(STATE_SHORT_LEN-1))   = uncoded start state\
    \ residual\n      res((STATE_SHORT_LEN)..(2*STATE_SHORT_LEN-1)) = 0\n      Pk(z)\
    \ = A~rk(z)/A~k(z), where\n                                   ___\n          \
    \                         \\\n      A~rk(z)= z^(-LPC_FILTERORDER)+>a~k(i+1)*z^(i-(LPC_FILTERORDER-1))\n\
    \                                   /__\n                               i=0...(LPC_FILTERORDER-1)\n\
    \      and A~k(z) is taken from the block where the start state begins\n     \
    \ res -> Pk(z) -> filtered\n      ccres(k) = filtered(k) + filtered(k+STATE_SHORT_LEN),\n\
    \                                        k=0..(STATE_SHORT_LEN-1)\n   The all-pass\
    \ filtered block is searched for its largest magnitude\n   sample.  The 10-logarithm\
    \ of this magnitude is quantized with a 6-bit\n   quantizer, state_frgqTbl, by\
    \ finding the nearest representation.\n   This results in an index, idxForMax,\
    \ corresponding to a quantized\n   value, qmax.  The all-pass filtered residual\
    \ samples in the block are\n   then multiplied with a scaling factor scal=4.5/(10^qmax)\
    \ to yield\n   normalized samples.\n   state_frgqTbl[64] = {1.000085, 1.071695,\
    \ 1.140395, 1.206868,\n                  1.277188, 1.351503, 1.429380, 1.500727,\
    \ 1.569049,\n                  1.639599, 1.707071, 1.781531, 1.840799, 1.901550,\n\
    \                  1.956695, 2.006750, 2.055474, 2.102787, 2.142819,\n       \
    \           2.183592, 2.217962, 2.257177, 2.295739, 2.332967,\n              \
    \    2.369248, 2.402792, 2.435080, 2.468598, 2.503394,\n                  2.539284,\
    \ 2.572944, 2.605036, 2.636331, 2.668939,\n                  2.698780, 2.729101,\
    \ 2.759786, 2.789834, 2.818679,\n                  2.848074, 2.877470, 2.906899,\
    \ 2.936655, 2.967804,\n                  3.000115, 3.033367, 3.066355, 3.104231,\
    \ 3.141499,\n                  3.183012, 3.222952, 3.265433, 3.308441, 3.350823,\n\
    \                  3.395275, 3.442793, 3.490801, 3.542514, 3.604064,\n       \
    \           3.666050, 3.740994, 3.830749, 3.938770, 4.101764}\n"
- title: 3.5.3.  Scalar Quantization
  contents:
  - "3.5.3.  Scalar Quantization\n   The normalized samples are quantized in the perceptually\
    \ weighted\n   speech domain by a sample-by-sample scalar DPCM quantization as\n\
    \   depicted in Figure 3.3.  Each sample in the block is filtered by a\n   weighting\
    \ filter Wk(z), specified in section 3.4, to form a weighted\n   speech sample\
    \ x[n].  The target sample d[n] is formed by subtracting\n   a predicted sample\
    \ y[n], where the prediction filter is given by\n           Pk(z) = 1 - 1 / Wk(z).\n\
    \               +-------+  x[n] +    d[n] +-----------+ u[n]\n   residual -->|\
    \ Wk(z) |-------->(+)---->| Quantizer |------> quantized\n               +-------+\
    \       - /|\\     +-----------+    |   residual\n                           \
    \       |                      \\|/\n                             y[n] +--------------------->(+)\n\
    \                                  |                       |\n               \
    \                   |        +------+       |\n                              \
    \    +--------| Pk(z)|<------+\n                                           +------+\n\
    \   Figure 3.3.  Quantization of start state samples by DPCM in weighted\n   speech\
    \ domain.\n   The coded state sample u[n] is obtained by quantizing d[n] with\
    \ a 3-\n   bit quantizer with quantization table state_sq3Tbl.\n   state_sq3Tbl[8]\
    \ = {-3.719849, -2.177490, -1.130005, -0.309692,\n                  0.444214,\
    \ 1.329712, 2.436279, 3.983887}\n   The quantized samples are transformed back\
    \ to the residual domain by\n   1) scaling with 1/scal; 2) time-reversing the\
    \ scaled samples; 3)\n   filtering the time-reversed samples by the same all-pass\
    \ filter, as\n   in section 3.5.2, by using circular convolution; and 4) time-\n\
    \   reversing the filtered samples.  (More detail is in section 4.2.)\n   A reference\
    \ implementation of the start-state encoding can be found\n   in Appendix A.46.\n"
- title: 3.6.  Encoding the Remaining Samples
  contents:
  - "3.6.  Encoding the Remaining Samples\n   A dynamic codebook is used to encode\
    \ 1) the 23/22 remaining samples\n   in the two sub-blocks containing the start\
    \ state; 2) the sub-blocks\n   after the start state in time; and 3) the sub-blocks\
    \ before the start\n   state in time.  Thus, the encoding target can be either\
    \ the 23/22\n   samples remaining of the 2 sub-blocks containing the start state,\
    \ or\n   a 40-sample sub-block.  This target can consist of samples that are\n\
    \   indexed forward in time or backward in time, depending on the\n   location\
    \ of the start state.  The length of the target is denoted by\n   lTarget.\n \
    \  The coding is based on an adaptive codebook that is built from a\n   codebook\
    \ memory that contains decoded LPC excitation samples from the\n   already encoded\
    \ part of the block.  These samples are indexed in the\n   same time direction\
    \ as is the target vector and end at the sample\n   instant prior to the first\
    \ sample instant represented in the target\n   vector.  The codebook memory has\
    \ length lMem, which is equal to\n   CB_MEML=147 for the two/four 40-sample sub-blocks\
    \ and 85 for the\n   23/22-sample sub-block.\n   The following figure shows an\
    \ overview of the encoding procedure.\n         +------------+    +---------------+\
    \    +-------------+\n      -> | 1. Decode  | -> | 2. Mem setup  | -> | 3. Perc.\
    \ W. | ->\n         +------------+    +---------------+    +-------------+\n \
    \        +------------+    +-----------------+\n      -> | 4. Search  | -> | 5.\
    \ Upd. Target  | ------------------>\n       | +------------+    +------------------\
    \ |\n       ----<-------------<-----------<----------\n                     stage=0..2\n\
    \         +----------------+\n      -> | 6. Recalc G[0] | ---------------> gains\
    \ and CB indices\n         +----------------+\n   Figure 3.4.  Flow chart of the\
    \ codebook search in the iLBC encoder.\n   1. Decode the part of the residual\
    \ that has been encoded so far,\n      using the codebook without perceptual weighting.\n\
    \   2. Set up the memory by taking data from the decoded residual.  This\n   \
    \   memory is used to construct codebooks.  For blocks preceding the\n      start\
    \ state, both the decoded residual and the target are time\n      reversed (section\
    \ 3.6.1).\n   3. Filter the memory + target with the perceptual weighting filter\n\
    \      (section 3.6.2).\n   4. Search for the best match between the target and\
    \ the codebook\n      vector.  Compute the optimal gain for this match and quantize\
    \ that\n      gain (section 3.6.4).\n   5. Update the perceptually weighted target\
    \ by subtracting the\n      contribution from the selected codebook vector from\
    \ the\n      perceptually weighted memory (quantized gain times selected\n   \
    \   vector).  Repeat 4 and 5 for the two additional stages.\n   6. Calculate the\
    \ energy loss due to encoding of the residual.  If\n      needed, compensate for\
    \ this loss by an upscaling and\n      requantization of the gain for the first\
    \ stage (section 3.7).\n   The following sections provide an in-depth description\
    \ of the\n   different blocks of Figure 3.4.\n"
- title: 3.6.1.  Codebook Memory
  contents:
  - "3.6.1.  Codebook Memory\n   The codebook memory is based on the already encoded\
    \ sub-blocks, so\n   the available data for encoding increases for each new sub-block\
    \ that\n   has been encoded.  Until enough sub-blocks have been encoded to fill\n\
    \   the codebook memory with data, it is padded with zeros.  The\n   following\
    \ figure shows an example of the order in which the sub-\n   blocks are encoded\
    \ for the 30 ms frame size if the start state is\n   located in the last 58 samples\
    \ of sub-block 2 and 3.\n   +-----------------------------------------------------+\n\
    \   |  5     | 1  |///|////////|    2   |    3   |    4   |\n   +-----------------------------------------------------+\n\
    \   Figure 3.5.  The order from 1 to 5 in which the sub-blocks are\n   encoded.\
    \  The slashed area is the start state.\n   The first target sub-block to be encoded\
    \ is number 1, and the\n   corresponding codebook memory is shown in the following\
    \ figure.  As\n   the target vector comes before the start state in time, the\
    \ codebook\n   memory and target vector are time reversed; thus, after the block\
    \ has\n   been time reversed the search algorithm can be reused.  As only the\n\
    \   start state has been encoded so far, the last samples of the codebook\n  \
    \ memory are padded with zeros.\n   +-------------------------\n   |zeros|\\\\\
    \\\\\\\\\\\\|\\\\\\\\|  1 |\n   +-------------------------\n   Figure 3.6.  The\
    \ codebook memory, length lMem=85 samples, and the\n   target vector 1, length\
    \ 22 samples.\n   The next step is to encode sub-block 2 by using the memory that\
    \ now\n   has increased since sub-block 1 has been encoded.  The following\n \
    \  figure shows the codebook memory for encoding of sub-block 2.\n   +-----------------------------------\n\
    \   | zeros | 1  |///|////////|    2   |\n   +-----------------------------------\n\
    \   Figure 3.7.  The codebook memory, length lMem=147 samples, and the\n   target\
    \ vector 2, length 40 samples.\n   The next step is to encode sub-block 3 by using\
    \ the memory which has\n   been increased yet again since sub-blocks 1 and 2 have\
    \ been encoded,\n   but the sub-block still has to be padded with a few zeros.\
    \  The\n   following figure shows the codebook memory for encoding of sub-block\n\
    \   3.\n   +------------------------------------------\n   |zeros| 1  |///|////////|\
    \    2   |   3    |\n   +------------------------------------------\n   Figure\
    \ 3.8.  The codebook memory, length lMem=147 samples, and the\n   target vector\
    \ 3, length 40 samples.\n   The next step is to encode sub-block 4 by using the\
    \ memory which now\n   has increased yet again since sub-blocks 1, 2, and 3 have\
    \ been\n   encoded.  This time, the memory does not have to be padded with\n \
    \  zeros.  The following figure shows the codebook memory for encoding\n   of\
    \ sub-block 4.\n   +------------------------------------------\n   |1|///|////////|\
    \    2   |   3    |   4    |\n   +------------------------------------------\n\
    \   Figure 3.9.  The codebook memory, length lMem=147 samples, and the\n   target\
    \ vector 4, length 40 samples.\n   The final target sub-block to be encoded is\
    \ number 5, and the\n   following figure shows the corresponding codebook memory.\
    \  As the\n   target vector comes before the start state in time, the codebook\n\
    \   memory and target vector are time reversed.\n   +-------------------------------------------\n\
    \   |  3  |   2    |\\\\\\\\\\\\\\\\|\\\\\\\\|  1 |   5    |\n   +-------------------------------------------\n\
    \   Figure 3.10.  The codebook memory, length lMem=147 samples, and the\n   target\
    \ vector 5, length 40 samples.\n   For the case of 20 ms frames, the encoding\
    \ procedure looks almost\n   exactly the same.  The only difference is that the\
    \ size of the start\n   state is 57 samples and that there are only three sub-blocks\
    \ to be\n   encoded.  The encoding order is the same as above, starting with the\n\
    \   23-sample target and then encoding the two remaining 40-sample sub-\n   blocks,\
    \ first going forward in time and then going backward in time\n   relative to\
    \ the start state.\n"
- title: 3.6.2.  Perceptual Weighting of Codebook Memory and Target
  contents:
  - "3.6.2.  Perceptual Weighting of Codebook Memory and Target\n   To provide a perceptual\
    \ weighting of the coding error, a\n   concatenation of the codebook memory and\
    \ the target to be coded is\n   all-pole filtered with the perceptual weighting\
    \ filter specified in\n   section 3.4.  The filter state of the weighting filter\
    \ is set to\n   zero.\n      in(0..(lMem-1))            = unweighted codebook\
    \ memory\n      in(lMem..(lMem+lTarget-1)) = unweighted target signal\n      in\
    \ -> Wk(z) -> filtered,\n          where Wk(z) is taken from the sub-block of\
    \ the target\n      weighted codebook memory = filtered(0..(lMem-1))\n      weighted\
    \ target signal = filtered(lMem..(lMem+lTarget-1))\n   The codebook search is\
    \ done with the weighted codebook memory and the\n   weighted target, whereas\
    \ the decoding and the codebook memory update\n   uses the unweighted codebook\
    \ memory.\n"
- title: 3.6.3.  Codebook Creation
  contents:
  - "3.6.3.  Codebook Creation\n   The codebook for the search is created from the\
    \ perceptually weighted\n   codebook memory.  It consists of two sections, where\
    \ the first is\n   referred to as the base codebook and the second as the expanded\n\
    \   codebook, as it is created by linear combinations of the first.  Each\n  \
    \ of these two sections also has a subsection referred to as the\n   augmented\
    \ codebook.  The augmented codebook is only created and used\n   for the coding\
    \ of the 40-sample sub-blocks and not for the 23/22-\n   sample sub-block case.\
    \  The codebook size used for the different\n   sub-blocks and different stages\
    \ are summarized in the table below.\n                              Stage\n  \
    \                      1               2 & 3\n           --------------------------------------------\n\
    \                22     128  (64+0)*2     128 (64+0)*2\n   Sub-    1:st 40   \
    \  256  (108+20)*2   128 (44+20)*2\n   Blocks  2:nd 40     256  (108+20)*2   256\
    \ (108+20)*2\n           3:rd 40     256  (108+20)*2   256 (108+20)*2\n      \
    \     4:th 40     256  (108+20)*2   256 (108+20)*2\n   Table 3.1.  Codebook sizes\
    \ for the 30 ms mode.\n   Table 3.1 shows the codebook size for the different\
    \ sub-blocks and\n   stages for 30 ms frames.  Inside the parentheses it shows\
    \ how the\n   number of codebook vectors is distributed, within the two sections,\n\
    \   between the base/expanded codebook and the augmented base/expanded\n   codebook.\
    \  It should be interpreted in the following way:\n   (base/expanded cb + augmented\
    \ base/expanded cb).  The total number of\n   codebook vectors for a specific\
    \ sub-block and stage is given by the\n   following formula:\n   Tot. cb vectors\
    \ = base cb + aug. base cb + exp. cb + aug. exp. cb\n   The corresponding values\
    \ to Figure 3.1 for 20 ms frames are only\n   slightly modified.  The short sub-block\
    \ is 23 instead of 22 samples,\n   and the 3:rd and 4:th sub-frame are not present.\n"
- title: 3.6.3.1.  Creation of a Base Codebook
  contents:
  - "3.6.3.1.  Creation of a Base Codebook\n   The base codebook is given by the perceptually\
    \ weighted codebook\n   memory that is mentioned in section 3.5.3.  The different\
    \ codebook\n   vectors are given by sliding a window of length 23/22 or 40, given\
    \ by\n   variable lTarget, over the lMem-long perceptually weighted codebook\n\
    \   memory.  The indices are ordered so that the codebook vector\n   containing\
    \ sample (lMem-lTarget-n) to (lMem-n-1) of the codebook\n   memory vector has\
    \ index n, where n=0..lMem-lTarget.  Thus the total\n   number of base codebook\
    \ vectors is lMem-lTarget+1, and the indices\n   are ordered from sample delay\
    \ lTarget (23/22 or 40) to lMem+1 (86 or\n   148).\n"
- title: 3.6.3.2.  Codebook Expansion
  contents:
  - "3.6.3.2.  Codebook Expansion\n   The base codebook is expanded by a factor of\
    \ 2, creating an\n   additional section in the codebook.  This new section is\
    \ obtained by\n   filtering the base codebook, base_cb, with a FIR filter with\
    \ filter\n   length CB_FILTERLEN=8.  The construction of the expanded codebook\n\
    \   compensates for the delay of four samples introduced by the FIR\n   filter.\n\
    \   cbfiltersTbl[CB_FILTERLEN]={-0.033691, 0.083740, -0.144043,\n            \
    \      0.713379, 0.806152, -0.184326,\n                  0.108887, -0.034180};\n\
    \                   ___\n                   \\\n      exp_cb(k)=  + > cbfiltersTbl(i)*x(k-i+4)\n\
    \                   /__\n             i=0...(LPC_FILTERORDER-1)\n      where x(j)\
    \ = base_cb(j) for j=0..lMem-1 and 0 otherwise\n   The individual codebook vectors\
    \ of the new filtered codebook, exp_cb,\n   and their indices are obtained in\
    \ the same fashion as described above\n   for the base codebook.\n"
- title: 3.6.3.3.  Codebook Augmentation
  contents:
  - "3.6.3.3.  Codebook Augmentation\n   For cases where encoding entire sub-blocks,\
    \ i.e., cbveclen=40, the\n   base and expanded codebooks are augmented to increase\
    \ codebook\n   richness.  The codebooks are augmented by vectors produced by\n\
    \   interpolation of segments.  The base and expanded codebook,\n   constructed\
    \ above, consists of vectors corresponding to sample delays\n   in the range from\
    \ cbveclen to lMem.  The codebook augmentation\n   attempts to augment these codebooks\
    \ with vectors corresponding to\n   sample delays from 20 to 39.  However, not\
    \ all of these samples are\n   present in the base codebook and expanded codebook,\
    \ respectively.\n   Therefore, the augmentation vectors are constructed as linear\n\
    \   combinations between samples corresponding to sample delays in the\n   range\
    \ 20 to 39.  The general idea of this procedure is presented in\n   the following\
    \ figures and text.  The procedure is performed for both\n   the base codebook\
    \ and the expanded codebook.\n       - - ------------------------|\n    codebook\
    \ memory                |\n       - - ------------------------|\n            \
    \      |-5-|---15---|-5-|\n                  pi  pp       po\n               \
    \       |        |                       Codebook vector\n                   \
    \   |---15---|-5-|-----20-----|   <- corresponding to\n                      \
    \    i     ii      iii            sample delay 20\n   Figure 3.11.  Generation\
    \ of the first augmented codebook.\n   Figure 3.11 shows the codebook memory with\
    \ pointers pi, pp, and po,\n   where pi points to sample 25, pp to sample 20,\
    \ and po to sample 5.\n   Below the codebook memory, the augmented codebook vector\n\
    \   corresponding to sample delay 20 is drawn.  Segment i consists of\n   fifteen\
    \ samples from pointer pp and forward in time.  Segment ii\n   consists of five\
    \ interpolated samples from pi and forward and from po\n   and forward.  The samples\
    \ are linearly interpolated with weights\n   [0.0, 0.2, 0.4, 0.6, 0.8] for pi\
    \ and weights [1.0, 0.8, 0.6, 0.4,\n   0.2] for po.  Segment iii consists of twenty\
    \ samples from pp and\n   forward.  The augmented codebook vector corresponding\
    \ to sample delay\n   21 is produced by moving pointers pp and pi one sample backward\
    \ in\n   time.  This gives us the following figure.\n       - - ------------------------|\n\
    \    codebook memory                |\n       - - ------------------------|\n\
    \                  |-5-|---16---|-5-|\n                  pi  pp       po\n   \
    \                   |        |                       Codebook vector\n       \
    \               |---16---|-5-|-----19-----|   <- corresponding to\n          \
    \                i     ii      iii            sample delay 21\n   Figure 3.12.\
    \  Generation of the second augmented codebook.\n   Figure 3.12 shows the codebook\
    \ memory with pointers pi, pp and po\n   where pi points to sample 26, pp to sample\
    \ 21, and po to sample 5.\n   Below the codebook memory, the augmented codebook\
    \ vector\n   corresponding to sample delay 21 is drawn.  Segment i now consists\
    \ of\n   sixteen samples from pp and forward.  Segment ii consists of five\n \
    \  interpolated samples from pi and forward and from po and forward, and\n   the\
    \ interpolation weights are the same throughout the procedure.\n   Segment iii\
    \ consists of nineteen samples from pp and forward.  The\n   same procedure of\
    \ moving the two pointers is continued until the last\n   augmented vector corresponding\
    \ to sample delay 39 has been created.\n   This gives a total of twenty new codebook\
    \ vectors to each of the two\n   sections.  Thus the total number of codebook\
    \ vectors for each of the\n   two sections, when including the augmented codebook,\
    \ becomes lMem-\n   SUBL+1+SUBL/2.  This is provided that augmentation is evoked,\
    \ i.e.,\n   that lTarget=SUBL.\n"
- title: 3.6.4.  Codebook Search
  contents:
  - "3.6.4.  Codebook Search\n   The codebook search uses the codebooks described\
    \ in the sections\n   above to find the best match of the perceptually weighted\
    \ target, see\n   section 3.6.2.  The search method is a multi-stage gain-shape\n\
    \   matching performed as follows.  At each stage the best shape vector\n   is\
    \ identified, then the gain is calculated and quantized, and finally\n   the target\
    \ is updated in preparation for the next codebook search\n   stage.  The number\
    \ of stages is CB_NSTAGES=3.\n   If the target is the 23/22-sample vector the\
    \ codebooks are indexed so\n   that the base codebook is followed by the expanded\
    \ codebook.  If the\n   target is 40 samples the order is as follows: base codebook,\n\
    \   augmented base codebook, expanded codebook, and augmented expanded\n   codebook.\
    \  The size of each codebook section and its corresponding\n   augmented section\
    \ is given by Table 3.1 in section 3.6.3.\n   For example, when the second 40-sample\
    \ sub-block is coded, indices 0\n   - 107 correspond to the base codebook, 108\
    \ - 127 correspond to the\n   augmented base codebook, 128 - 235 correspond to\
    \ the expanded\n   codebook, and indices 236 - 255 correspond to the augmented\
    \ expanded\n   codebook.  The indices are divided in the same fashion for all\
    \ stages\n   in the example.  Only in the case of coding the first 40-sample sub-\n\
    \   block is there a difference between stages (see Table 3.1).\n"
- title: 3.6.4.1.  Codebook Search at Each Stage
  contents:
  - "3.6.4.1.  Codebook Search at Each Stage\n   The codebooks are searched to find\
    \ the best match to the target at\n   each stage.  When the best match is found,\
    \ the target is updated and\n   the next-stage search is started.  The three chosen\
    \ codebook vectors\n   and their corresponding gains constitute the encoded sub-block.\
    \  The\n   best match is decided by the following three criteria:\n   1. Compute\
    \ the measure\n      (target*cbvec)^2 / ||cbvec||^2\n   for all codebook vectors,\
    \ cbvec, and choose the codebook vector\n   maximizing the measure.  The expression\
    \ (target*cbvec) is the dot\n   product between the target vector to be coded\
    \ and the codebook vector\n   for which we compute the measure.  The norm, ||x||,\
    \ is defined as the\n   square root of (x*x).\n   2. The absolute value of the\
    \ gain, corresponding to the chosen\n      codebook vector, cbvec, must be smaller\
    \ than a fixed limit,\n      CB_MAXGAIN=1.3:\n            |gain| < CB_MAXGAIN\n\
    \      where the gain is computed in the following way:\n            gain = (target*cbvec)\
    \ / ||cbvec||^2\n   3. For the first stage, the dot product of the chosen codebook\
    \ vector\n      and target must be positive:\n      target*cbvec > 0\n   In practice\
    \ the above criteria are used in a sequential search\n   through all codebook\
    \ vectors.  The best match is found by registering\n   a new max measure and index\
    \ whenever the previously registered max\n   measure is surpassed and all other\
    \ criteria are fulfilled.  If none\n   of the codebook vectors fulfill (2) and\
    \ (3), the first codebook\n   vector is selected.\n"
- title: 3.6.4.2.  Gain Quantization at Each Stage
  contents:
  - "3.6.4.2.  Gain Quantization at Each Stage\n   The gain follows as a result of\
    \ the computation\n      gain = (target*cbvec) / ||cbvec||^2\n   for the optimal\
    \ codebook vector found by the procedure in section\n   3.6.4.1.\n   The three\
    \ stages quantize the gain, using 5, 4, and 3 bits,\n   respectively.  In the\
    \ first stage, the gain is limited to positive\n   values.  This gain is quantized\
    \ by finding the nearest value in the\n   quantization table gain_sq5Tbl.\n  \
    \ gain_sq5Tbl[32]={0.037476, 0.075012, 0.112488, 0.150024, 0.187500,\n       \
    \           0.224976, 0.262512, 0.299988, 0.337524, 0.375000,\n              \
    \    0.412476, 0.450012, 0.487488, 0.525024, 0.562500,\n                  0.599976,\
    \ 0.637512, 0.674988, 0.712524, 0.750000,\n                  0.787476, 0.825012,\
    \ 0.862488, 0.900024, 0.937500,\n                  0.974976, 1.012512, 1.049988,\
    \ 1.087524, 1.125000,\n                  1.162476, 1.200012}\n   The gains of\
    \ the subsequent two stages can be either positive or\n   negative.  The gains\
    \ are quantized by using a quantization table\n   times a scale factor.  The second\
    \ stage uses the table gain_sq4Tbl,\n   and the third stage uses gain_sq3Tbl.\
    \  The scale factor equates 0.1\n   or the absolute value of the quantized gain\
    \ representation value\n   obtained in the previous stage, whichever is larger.\
    \  Again, the\n   resulting gain index is the index to the nearest value of the\n\
    \   quantization table times the scale factor.\n        gainQ = scaleFact * gain_sqXTbl[index]\n\
    \   gain_sq4Tbl[16]={-1.049988, -0.900024, -0.750000, -0.599976,\n           \
    \       -0.450012, -0.299988, -0.150024, 0.000000, 0.150024,\n               \
    \   0.299988, 0.450012, 0.599976, 0.750000, 0.900024,\n                  1.049988,\
    \ 1.200012}\n   gain_sq3Tbl[8]={-1.000000, -0.659973, -0.330017,0.000000,\n  \
    \                0.250000, 0.500000, 0.750000, 1.00000}\n"
- title: 3.6.4.3.  Preparation of Target for Next Stage
  contents:
  - "3.6.4.3.  Preparation of Target for Next Stage\n   Before performing the search\
    \ for the next stage, the perceptually\n   weighted target vector is updated by\
    \ subtracting from it the selected\n   codebook vector (from the perceptually\
    \ weighted codebook) times the\n   corresponding quantized gain.\n      target[i]\
    \ = target[i] - gainQ * selected_vec[i];\n   A reference implementation of the\
    \ codebook encoding is found in\n   Appendix A.34.\n"
- title: 3.7.  Gain Correction Encoding
  contents:
  - "3.7.  Gain Correction Encoding\n   The start state is quantized in a relatively\
    \ model independent manner\n   using 3 bits per sample.  In contrast, the remaining\
    \ parts of the\n   block are encoded by using an adaptive codebook.  This codebook\
    \ will\n   produce high matching accuracy whenever there is a high correlation\n\
    \   between the target and the best codebook vector.  For unvoiced speech\n  \
    \ segments and background noises, this is not necessarily so, which,\n   due to\
    \ the nature of the squared error criterion, results in a coded\n   signal with\
    \ less power than the target signal.  As the coded start\n   state has good power\
    \ matching to the target, the result is a power\n   fluctuation within the encoded\
    \ frame.  Perceptually, the main problem\n   with this is that the time envelope\
    \ of the signal energy becomes\n   unsteady.  To overcome this problem, the gains\
    \ for the codebooks are\n   re-scaled after the codebook encoding by searching\
    \ for a new gain\n   factor for the first stage codebook that provides better\
    \ power\n   matching.\n   First, the energy for the target signal, tene, is computed\
    \ along with\n   the energy for the coded signal, cene, given by the addition\
    \ of the\n   three gain scaled codebook vectors.  Because the gains of the second\n\
    \   and third stage scale with the gain of the first stage, when the\n   first\
    \ stage gain is changed from gain[0] to gain_sq5Tbl[i] the energy\n   of the coded\
    \ signal changes from cene to\n      cene*(gain_sq5Tbl[i]*gain_sq5Tbl[i])/(gain[0]*gain[0])\n\
    \   where gain[0] is the gain for the first stage found in the original\n   codebook\
    \ search.  A refined search is performed by testing the gain\n   indices i=0 to\
    \ 31, and as long as the new codebook energy as given\n   above is less than tene,\
    \ the gain index for stage 1 is increased.  A\n   restriction is applied so that\
    \ the new gain value for stage 1 cannot\n   be more than two times higher than\
    \ the original value found in the\n   codebook search.  Note that by using this\
    \ method we do not change the\n   shape of the encoded vector, only the gain or\
    \ amplitude.\n"
- title: 3.8.  Bitstream Definition
  contents:
  - "3.8.  Bitstream Definition\n   The total number of bits used to describe one\
    \ frame of 20 ms speech\n   is 304, which fits in 38 bytes and results in a bit\
    \ rate of 15.20\n   kbit/s.  For the case of a frame length of 30 ms speech, the\
    \ total\n   number of bits used is 400, which fits in 50 bytes and results in\
    \ a\n   bit rate of 13.33 kbit/s.  In the bitstream definition, the bits are\n\
    \   distributed into three classes according to their bit error or loss\n   sensitivity.\
    \  The most sensitive bits (class 1) are placed first in\n   the bitstream for\
    \ each frame.  The less sensitive bits (class 2) are\n   placed after the class\
    \ 1 bits.  The least sensitive bits (class 3)\n   are placed at the end of the\
    \ bitstream for each frame.\n   In the 20/30 ms frame length cases for each class,\
    \ the following hold\n   true: The class 1 bits occupy a total of 6/8 bytes (48/64\
    \ bits), the\n   class 2 bits occupy 8/12 bytes (64/96 bits), and the class 3\
    \ bits\n   occupy 24/30 bytes (191/239 bits).  This distribution of the bits\n\
    \   enables the use of uneven level protection (ULP) as is exploited in\n   the\
    \ payload format definition for iLBC [1].  The detailed bit\n   allocation is\
    \ shown in the table below.  When a quantization index is\n   distributed between\
    \ more classes, the more significant bits belong to\n   the lowest class.\n  \
    \ Bitstream structure:\n   ------------------------------------------------------------------+\n\
    \   Parameter                         |       Bits Class <1,2,3>      |\n    \
    \                                 |  20 ms frame  |  30 ms frame  |\n   ----------------------------------+---------------+---------------+\n\
    \                            Split 1  |   6 <6,0,0>   |   6 <6,0,0>   |\n    \
    \               LSF 1    Split 2  |   7 <7,0,0>   |   7 <7,0,0>   |\n   LSF  \
    \                    Split 3  |   7 <7,0,0>   |   7 <7,0,0>   |\n            \
    \       ------------------+---------------+---------------+\n                \
    \            Split 1  | NA (Not Appl.)|   6 <6,0,0>   |\n                   LSF\
    \ 2    Split 2  |      NA       |   7 <7,0,0>   |\n                          \
    \  Split 3  |      NA       |   7 <7,0,0>   |\n                   ------------------+---------------+---------------+\n\
    \                   Sum               |  20 <20,0,0>  |  40 <40,0,0>  |\n   ----------------------------------+---------------+---------------+\n\
    \   Block Class                       |   2 <2,0,0>   |   3 <3,0,0>   |\n   ----------------------------------+---------------+---------------+\n\
    \   Position 22 sample segment        |   1 <1,0,0>   |   1 <1,0,0>   |\n   ----------------------------------+---------------+---------------+\n\
    \   Scale Factor State Coder          |   6 <6,0,0>   |   6 <6,0,0>   |\n   ----------------------------------+---------------+---------------+\n\
    \                   Sample 0          |   3 <0,1,2>   |   3 <0,1,2>   |\n   Quantized\
    \       Sample 1          |   3 <0,1,2>   |   3 <0,1,2>   |\n   Residual     \
    \      :              |   :    :      |   :    :      |\n   State            \
    \  :              |   :    :      |   :    :      |\n   Samples            : \
    \             |   :    :      |   :    :      |\n                   Sample 56\
    \         |   3 <0,1,2>   |   3 <0,1,2>   |\n                   Sample 57    \
    \     |      NA       |   3 <0,1,2>   |\n                   ------------------+---------------+---------------+\n\
    \                   Sum               | 171 <0,57,114>| 174 <0,58,116>|\n   ----------------------------------+---------------+---------------+\n\
    \                            Stage 1  |   7 <6,0,1>   |   7 <4,2,1>   |\n   CB\
    \ for 22/23             Stage 2  |   7 <0,0,7>   |   7 <0,0,7>   |\n   sample\
    \ block             Stage 3  |   7 <0,0,7>   |   7 <0,0,7>   |\n             \
    \      ------------------+---------------+---------------+\n                 \
    \  Sum               |  21 <6,0,15>  |  21 <4,2,15>  |\n   ----------------------------------+---------------+---------------+\n\
    \                            Stage 1  |   5 <2,0,3>   |   5 <1,1,3>   |\n   Gain\
    \ for 22/23           Stage 2  |   4 <1,1,2>   |   4 <1,1,2>   |\n   sample block\
    \             Stage 3  |   3 <0,0,3>   |   3 <0,0,3>   |\n                   ------------------+---------------+---------------+\n\
    \                   Sum               |  12 <3,1,8>   |  12 <2,2,8>   |\n   ----------------------------------+---------------+---------------+\n\
    \                            Stage 1  |   8 <7,0,1>   |   8 <6,1,1>   |\n    \
    \           sub-block 1  Stage 2  |   7 <0,0,7>   |   7 <0,0,7>   |\n        \
    \                    Stage 3  |   7 <0,0,7>   |   7 <0,0,7>   |\n            \
    \       ------------------+---------------+---------------+\n                \
    \            Stage 1  |   8 <0,0,8>   |   8 <0,7,1>   |\n               sub-block\
    \ 2  Stage 2  |   8 <0,0,8>   |   8 <0,0,8>   |\n   Indices                  Stage\
    \ 3  |   8 <0,0,8>   |   8 <0,0,8>   |\n   for CB          ------------------+---------------+---------------+\n\
    \   sub-blocks               Stage 1  |      NA       |   8 <0,7,1>   |\n    \
    \           sub-block 3  Stage 2  |      NA       |   8 <0,0,8>   |\n        \
    \                    Stage 3  |      NA       |   8 <0,0,8>   |\n            \
    \       ------------------+---------------+---------------+\n                \
    \            Stage 1  |      NA       |   8 <0,7,1>   |\n               sub-block\
    \ 4  Stage 2  |      NA       |   8 <0,0,8>   |\n                            Stage\
    \ 3  |      NA       |   8 <0,0,8>   |\n                   ------------------+---------------+---------------+\n\
    \                   Sum               |  46 <7,0,39>  |  94 <6,22,66> |\n   ----------------------------------+---------------+---------------+\n\
    \                            Stage 1  |   5 <1,2,2>   |   5 <1,2,2>   |\n    \
    \           sub-block 1  Stage 2  |   4 <1,1,2>   |   4 <1,2,1>   |\n        \
    \                    Stage 3  |   3 <0,0,3>   |   3 <0,0,3>   |\n            \
    \       ------------------+---------------+---------------+\n                \
    \            Stage 1  |   5 <1,1,3>   |   5 <0,2,3>   |\n               sub-block\
    \ 2  Stage 2  |   4 <0,2,2>   |   4 <0,2,2>   |\n                            Stage\
    \ 3  |   3 <0,0,3>   |   3 <0,0,3>   |\n   Gains for       ------------------+---------------+---------------+\n\
    \   sub-blocks               Stage 1  |      NA       |   5 <0,1,4>   |\n    \
    \           sub-block 3  Stage 2  |      NA       |   4 <0,1,3>   |\n        \
    \                    Stage 3  |      NA       |   3 <0,0,3>   |\n            \
    \       ------------------+---------------+---------------+\n                \
    \            Stage 1  |      NA       |   5 <0,1,4>   |\n               sub-block\
    \ 4  Stage 2  |      NA       |   4 <0,1,3>   |\n                            Stage\
    \ 3  |      NA       |   3 <0,0,3>   |\n                   ------------------+---------------+---------------+\n\
    \                   Sum               |  24 <3,6,15>  |  48 <2,12,34> |\n   ----------------------------------+---------------+---------------+\n\
    \   Empty frame indicator             |   1 <0,0,1>   |   1 <0,0,1>   |\n   -------------------------------------------------------------------\n\
    \   SUM                                 304 <48,64,192> 400 <64,96,240>\n   Table\
    \ 3.2.  The bitstream definition for iLBC for both the 20 ms\n   frame size mode\
    \ and the 30 ms frame size mode.\n   When packetized into the payload, the bits\
    \ MUST be sorted as follows:\n   All the class 1 bits in the order (from top to\
    \ bottom) as specified\n   in the table, all the class 2 bits (from top to bottom),\
    \ and all the\n   class 3 bits in the same sequential order.  The last bit, the\
    \ empty\n   frame indicator, SHOULD be set to zero by the encoder.  If this bit\n\
    \   is set to 1 the decoder SHOULD treat the data as a lost frame.  For\n   example,\
    \ this bit can be set to 1 to indicate lost frame for file\n   storage format,\
    \ as in [1].\n"
- title: 4.  Decoder Principles
  contents:
  - "4.  Decoder Principles\n   This section describes the principles of each component\
    \ of the\n   decoder algorithm.\n              +-------------+    +--------+ \
    \   +---------------+\n   payload -> | 1. Get para | -> | 2. LPC | -> | 3. Sc\
    \ Dequant | ->\n              +-------------+    +--------+    +---------------+\n\
    \              +-------------+    +------------------+\n           -> | 4. Mem\
    \ setup| -> | 5. Construct res |------->\n           |  +-------------+    +-------------------\
    \   |\n           ---------<-----------<-----------<------------\n           \
    \          Sub-frame 0...2/4 (20 ms/30 ms)\n              +----------------+ \
    \   +----------+\n           -> | 6. Enhance res | -> | 7. Synth | ------------>\n\
    \              +----------------+    +----------+\n              +-----------------+\n\
    \           -> | 8. Post Process | ----------------> decoded speech\n        \
    \      +-----------------+\n   Figure 4.1.  Flow chart of the iLBC decoder.  If\
    \ a frame was lost,\n   steps 1 to 5 SHOULD be replaced by a PLC algorithm.\n\
    \   1. Extract the parameters from the bitstream.\n   2. Decode the LPC and interpolate\
    \ (section 4.1).\n   3. Construct the 57/58-sample start state (section 4.2).\n\
    \   4. Set up the memory by using data from the decoded residual.  This\n    \
    \  memory is used for codebook construction.  For blocks preceding\n      the\
    \ start state, both the decoded residual and the target are time\n      reversed.\
    \  Sub-frames are decoded in the same order as they were\n      encoded.\n   5.\
    \ Construct the residuals of this sub-frame (gain[0]*cbvec[0] +\n      gain[1]*cbvec[1]\
    \ + gain[2]*cbvec[2]).  Repeat 4 and 5 until the\n      residual of all sub-blocks\
    \ has been constructed.\n   6. Enhance the residual with the post filter (section\
    \ 4.6).\n   7. Synthesis of the residual (section 4.7).\n   8. Post process with\
    \ HP filter, if desired (section 4.8).\n"
- title: 4.1.  LPC Filter Reconstruction
  contents:
  - "4.1.  LPC Filter Reconstruction\n   The decoding of the LP filter parameters\
    \ is very straightforward.\n   For a set of three/six indices, the corresponding\
    \ LSF vector(s) are\n   found by simple table lookup.  For each of the LSF vectors,\
    \ the three\n   split vectors are concatenated to obtain qlsf1 and qlsf2,\n  \
    \ respectively (in the 20 ms mode only one LSF vector, qlsf, is\n   constructed).\
    \  The next step is the stability check described in\n   section 3.2.5 followed\
    \ by the interpolation scheme described in\n   section 3.2.6 (3.2.7 for 20 ms\
    \ frames).  The only difference is that\n   only the quantized LSFs are known\
    \ at the decoder, and hence the\n   unquantized LSFs are not processed.\n   A\
    \ reference implementation of the LPC filter reconstruction is given\n   in Appendix\
    \ A.36.\n"
- title: 4.2.  Start State Reconstruction
  contents:
  - "4.2.  Start State Reconstruction\n   The scalar encoded STATE_SHORT_LEN=58 (STATE_SHORT_LEN=57\
    \ in the 20\n   ms mode) state samples are reconstructed by 1) forming a set of\n\
    \   samples (by table lookup) from the index stream idxVec[n], 2)\n   multiplying\
    \ the set with 1/scal=(10^qmax)/4.5, 3) time reversing the\n   57/58 samples,\
    \ 4) filtering the time reversed block with the\n   dispersion (all-pass) filter\
    \ used in the encoder (as described in\n   section 3.5.2); this compensates for\
    \ the phase distortion of the\n   earlier filter operation, and 5 reversing the\
    \ 57/58 samples from the\n   previous step.\n   in(0..(STATE_SHORT_LEN-1)) = time\
    \ reversed samples from table\n                                look-up,\n    \
    \                            idxVecDec((STATE_SHORT_LEN-1)..0)\n   in(STATE_SHORT_LEN..(2*STATE_SHORT_LEN-1))\
    \ = 0\n   Pk(z) = A~rk(z)/A~k(z), where\n                                  ___\n\
    \                                  \\\n   A~rk(z)= z^(-LPC_FILTERORDER) + > a~ki*z^(i-(LPC_FILTERORDER-1))\n\
    \                                  /__\n                              i=0...(LPC_FILTERORDER-1)\n\
    \   and A~k(z) is taken from the block where the start state begins\n   in ->\
    \ Pk(z) -> filtered\n   out(k) = filtered(STATE_SHORT_LEN-1-k) +\n           \
    \                filtered(2*STATE_SHORT_LEN-1-k),\n                          \
    \               k=0..(STATE_SHORT_LEN-1)\n   The remaining 23/22 samples in the\
    \ state are reconstructed by the\n   same adaptive codebook technique described\
    \ in section 4.3.  The\n   location bit determines whether these are the first\
    \ or the last 23/22\n   samples of the 80-sample state vector.  If the remaining\
    \ 23/22\n   samples are the first samples, then the scalar encoded\n   STATE_SHORT_LEN\
    \ state samples are time-reversed before initialization\n   of the adaptive codebook\
    \ memory vector.\n   A reference implementation of the start state reconstruction\
    \ is given\n   in Appendix A.44.\n"
- title: 4.3.  Excitation Decoding Loop
  contents:
  - "4.3.  Excitation Decoding Loop\n   The decoding of the LPC excitation vector\
    \ proceeds in the same order\n   in which the residual was encoded at the encoder.\
    \  That is, after the\n   decoding of the entire 80-sample state vector, the forward\
    \ sub-blocks\n   (corresponding to samples occurring after the state vector samples)\n\
    \   are decoded, and then the backward sub-blocks (corresponding to\n   samples\
    \ occurring before the state vector) are decoded, resulting in\n   a fully decoded\
    \ block of excitation signal samples.\n   In particular, each sub-block is decoded\
    \ by using the multistage\n   adaptive codebook decoding module described in section\
    \ 4.4.  This\n   module relies upon an adaptive codebook memory constructed before\n\
    \   each run of the adaptive codebook decoding.  The construction of the\n   adaptive\
    \ codebook memory in the decoder is identical to the method\n   outlined in section\
    \ 3.6.3, except that it is done on the codebook\n   memory without perceptual\
    \ weighting.\n   For the initial forward sub-block, the last STATE_LEN=80 samples\
    \ of\n   the length CB_LMEM=147 adaptive codebook memory are filled with the\n\
    \   samples of the state vector.  For subsequent forward sub-blocks, the\n   first\
    \ SUBL=40 samples of the adaptive codebook memory are discarded,\n   the remaining\
    \ samples are shifted by SUBL samples toward the\n   beginning of the vector,\
    \ and the newly decoded SUBL=40 samples are\n   placed at the end of the adaptive\
    \ codebook memory.  For backward\n   sub-blocks, the construction is similar,\
    \ except that every vector of\n   samples involved is first time reversed.\n \
    \  A reference implementation of the excitation decoding loop is found\n   in\
    \ Appendix A.5.\n"
- title: 4.4.  Multistage Adaptive Codebook Decoding
  contents:
  - "4.4.  Multistage Adaptive Codebook Decoding\n   The Multistage Adaptive Codebook\
    \ Decoding module is used at both the\n   sender (encoder) and the receiver (decoder)\
    \ ends to produce a\n   synthetic signal in the residual domain that is eventually\
    \ used to\n   produce synthetic speech.  The module takes the index values used\
    \ to\n   construct vectors that are scaled and summed together to produce a\n\
    \   synthetic signal that is the output of the module.\n"
- title: 4.4.1.  Construction of the Decoded Excitation Signal
  contents:
  - "4.4.1.  Construction of the Decoded Excitation Signal\n   The unpacked index\
    \ values provided at the input to the module are\n   references to extended codebooks,\
    \ which are constructed as described\n   in section 3.6.3, except that they are\
    \ based on the codebook memory\n   without the perceptual weighting.  The unpacked\
    \ three indices are\n   used to look up three codebook vectors.  The unpacked\
    \ three gain\n   indices are used to decode the corresponding 3 gains.  In this\n\
    \   decoding, the successive rescaling, as described in section 3.6.4.2,\n   is\
    \ applied.\n   A reference implementation of the adaptive codebook decoding is\n\
    \   listed in Appendix A.32.\n"
- title: 4.5.  Packet Loss Concealment
  contents:
  - "4.5.  Packet Loss Concealment\n   If packet loss occurs, the decoder receives\
    \ a signal saying that\n   information regarding a block is lost.  For such blocks\
    \ it is\n   RECOMMENDED to use a Packet Loss Concealment (PLC) unit to create\
    \ a\n   decoded signal that masks the effect of that packet loss.  In the\n  \
    \ following we will describe an example of a PLC unit that can be used\n   with\
    \ the iLBC codec.  As the PLC unit is used only at the decoder,\n   the PLC unit\
    \ does not affect interoperability between\n   implementations.  Other PLC implementations\
    \ MAY therefore be used.\n   The PLC described operates on the LP filters and\
    \ the excitation\n   signals and is based on the following principles:\n"
- title: 4.5.1.  Block Received Correctly and Previous Block Also Received
  contents:
  - "4.5.1.  Block Received Correctly and Previous Block Also Received\n   If the\
    \ block is received correctly, the PLC only records state\n   information of the\
    \ current block that can be used in case the next\n   block is lost.  The LP filter\
    \ coefficients for each sub-block and the\n   entire decoded excitation signal\
    \ are all saved in the decoder state\n   structure.  All of this information will\
    \ be needed if the following\n   block is lost.\n"
- title: 4.5.2.  Block Not Received
  contents:
  - "4.5.2.  Block Not Received\n   If the block is not received, the block substitution\
    \ is based on a\n   pitch-synchronous repetition of the excitation signal, which\
    \ is\n   filtered by the last LP filter of the previous block.  The previous\n\
    \   block's information is stored in the decoder state structure.\n   A correlation\
    \ analysis is performed on the previous block's\n   excitation signal in order\
    \ to detect the amount of pitch periodicity\n   and a pitch value.  The correlation\
    \ measure is also used to decide on\n   the voicing level (the degree to which\
    \ the previous block's\n   excitation was a voiced or roughly periodic signal).\
    \  The excitation\n   in the previous block is used to create an excitation for\
    \ the block\n   to be substituted, such that the pitch of the previous block is\n\
    \   maintained.  Therefore, the new excitation is constructed in a\n   pitch-synchronous\
    \ manner.  In order to avoid a buzzy-sounding\n   substituted block, a random\
    \ excitation is mixed with the new pitch\n   periodic excitation, and the relative\
    \ use of the two components is\n   computed from the correlation measure (voicing\
    \ level).\n   For the block to be substituted, the newly constructed excitation\n\
    \   signal is then passed through the LP filter to produce the speech\n   that\
    \ will be substituted for the lost block.\n   For several consecutive lost blocks,\
    \ the packet loss concealment\n   continues in a similar manner.  The correlation\
    \ measure of the last\n   block received is still used along with the same pitch\
    \ value.  The LP\n   filters of the last block received are also used again. \
    \ The energy\n   of the substituted excitation for consecutive lost blocks is\n\
    \   decreased, leading to a dampened excitation, and therefore to\n   dampened\
    \ speech.\n"
- title: 4.5.3.  Block Received Correctly When Previous Block Not Received
  contents:
  - "4.5.3.  Block Received Correctly When Previous Block Not Received\n   For the\
    \ case in which a block is received correctly when the previous\n   block was\
    \ not, the correctly received block's directly decoded speech\n   (based solely\
    \ on the received block) is not used as the actual\n   output.  The reason for\
    \ this is that the directly decoded speech does\n   not necessarily smoothly merge\
    \ into the synthetic speech generated\n   for the previous lost block.  If the\
    \ two signals are not smoothly\n   merged, an audible discontinuity is accidentally\
    \ produced.\n   Therefore, a correlation analysis between the two blocks of\n\
    \   excitation signal (the excitation of the previous concealed block and\n  \
    \ that of the current received block) is performed to find the best\n   phase\
    \ match.  Then a simple overlap-add procedure is performed to\n   merge the previous\
    \ excitation smoothly into the current block's\n   excitation.\n   The exact implementation\
    \ of the packet loss concealment does not\n   influence interoperability of the\
    \ codec.\n   A reference implementation of the packet loss concealment is\n  \
    \ suggested in Appendix A.14.  Exact compliance with this suggested\n   algorithm\
    \ is not needed for a reference implementation to be fully\n   compatible with\
    \ the overall codec specification.\n"
- title: 4.6.  Enhancement
  contents:
  - "4.6.  Enhancement\n   The decoder contains an enhancement unit that operates\
    \ on the\n   reconstructed excitation signal.  The enhancement unit increases\
    \ the\n   perceptual quality of the reconstructed signal by reducing the\n   speech-correlated\
    \ noise in the voiced speech segments.  Compared to\n   traditional postfilters,\
    \ the enhancer has an advantage in that it can\n   only modify the excitation\
    \ signal slightly.  This means that there is\n   no risk of over enhancement.\
    \  The enhancer works very similarly for\n   both the 20 ms frame size mode and\
    \ the 30 ms frame size mode.\n   For the mode with 20 ms frame size, the enhancer\
    \ uses a memory of six\n   80-sample excitation blocks prior in time plus the\
    \ two new 80-sample\n   excitation blocks.  For each block of 160 new unenhanced\
    \ excitation\n   samples, 160 enhanced excitation samples are produced.  The enhanced\n\
    \   excitation is 40-sample delayed compared to the unenhanced\n   excitation,\
    \ as the enhancer algorithm uses lookahead.\n   For the mode with 30 ms frame\
    \ size, the enhancer uses a memory of\n   five 80-sample excitation blocks prior\
    \ in time plus the three new\n   80-sample excitation blocks.  For each block\
    \ of 240 new unenhanced\n   excitation samples, 240 enhanced excitation samples\
    \ are produced.\n   The enhanced excitation is 80-sample delayed compared to the\n\
    \   unenhanced excitation, as the enhancer algorithm uses lookahead.\n   Outline\
    \ of Enhancer\n   The speech enhancement unit operates on sub-blocks of 80 samples,\n\
    \   which means that there are two/three 80 sample sub-blocks per frame.\n   Each\
    \ of these two/three sub-blocks is enhanced separately, but in an\n   analogous\
    \ manner.\n   unenhanced residual\n           |\n           |   +---------------+\
    \    +--------------+\n           +-> | 1. Pitch Est  | -> | 2. Find PSSQ | -------->\n\
    \               +---------------+  | +--------------+\n                      \
    \            +-----<-------<------<--+\n               +------------+        \
    \ enh block 0..1/2    |\n            -> | 3. Smooth  |                       \
    \      |\n               +------------+                             |\n      \
    \           \\                                        |\n                 /\\\
    \                                       |\n                /  \\   Already   \
    \                         |\n               / 4. \\----------->----------->-----------+\
    \ |\n               \\Crit/ Fulfilled                         | |\n          \
    \      \\? /                                    v |\n                 \\/    \
    \                                 | |\n                  \\  +-----------------+\
    \    +---------+ | |\n              Not +->| 5. Use Constr.  | -> | 6. Mix  |\
    \ ----->\n           Fulfilled +-----------------+    +---------+\n          \
    \  ---------------> enhanced residual\n   Figure 4.2.  Flow chart of the enhancer.\n\
    \   1. Pitch estimation of each of the two/three new 80-sample blocks.\n   2.\
    \ Find the pitch-period-synchronous sequence n (for block k) by a\n      search\
    \ around the estimated pitch value.  Do this for n=1,2,3,\n      -1,-2,-3.\n \
    \  3. Calculate the smoothed residual generated by the six pitch-\n      period-synchronous\
    \ sequences from prior step.\n   4. Check if the smoothed residual satisfies the\
    \ criterion (section\n      4.6.4).\n   5. Use constraint to calculate mixing\
    \ factor (section 4.6.5).\n   6. Mix smoothed signal with unenhanced residual\
    \ (pssq(n) n=0).\n   The main idea of the enhancer is to find three 80 sample\
    \ blocks\n   before and three 80-sample blocks after the analyzed unenhanced sub-\n\
    \   block and to use these to improve the quality of the excitation in\n   that\
    \ sub-block.  The six blocks are chosen so that they have the\n   highest possible\
    \ correlation with the unenhanced sub-block that is\n   being enhanced.  In other\
    \ words, the six blocks are pitch-period-\n   synchronous sequences to the unenhanced\
    \ sub-block.\n   A linear combination of the six pitch-period-synchronous sequences\
    \ is\n   calculated that approximates the sub-block.  If the squared error\n \
    \  between the approximation and the unenhanced sub-block is small\n   enough,\
    \ the enhanced residual is set equal to this approximation.\n   For the cases\
    \ when the squared error criterion is not fulfilled, a\n   linear combination\
    \ of the approximation and the unenhanced residual\n   forms the enhanced residual.\n"
- title: 4.6.1.  Estimating the Pitch
  contents:
  - "4.6.1.  Estimating the Pitch\n   Pitch estimates are needed to determine the\
    \ locations of the pitch-\n   period-synchronous sequences in a complexity-efficient\
    \ way.  For each\n   of the new two/three sub-blocks, a pitch estimate is calculated\
    \ by\n   finding the maximum correlation in the range from lag 20 to lag 120.\n\
    \   These pitch estimates are used to narrow down the search for the best\n  \
    \ possible pitch-period-synchronous sequences.\n"
- title: 4.6.2.  Determination of the Pitch-Synchronous Sequences
  contents:
  - "4.6.2.  Determination of the Pitch-Synchronous Sequences\n   Upon receiving the\
    \ pitch estimates from the prior step, the enhancer\n   analyzes and enhances\
    \ one 80-sample sub-block at a time.  The pitch-\n   period-synchronous-sequences\
    \ pssq(n) can be viewed as vectors of\n   length 80 samples each shifted n*lag\
    \ samples from the current sub-\n   block.  The six pitch-period-synchronous-sequences,\
    \ pssq(-3) to\n   pssq(-1) and pssq(1) to pssq(3), are found one at a time by\
    \ the steps\n   below:\n   1) Calculate the estimate of the position of the pssq(n).\
    \  For\n      pssq(n) in front of pssq(0) (n > 0), the location of the pssq(n)\n\
    \      is estimated by moving one pitch estimate forward in time from the\n  \
    \    exact location of pssq(n-1).  Similarly, pssq(n) behind pssq(0) (n\n    \
    \  < 0) is estimated by moving one pitch estimate backward in time\n      from\
    \ the exact location of pssq(n+1).  If the estimated pssq(n)\n      vector location\
    \ is totally within the enhancer memory (Figure\n      4.3), steps 2, 3, and 4\
    \ are performed, otherwise the pssq(n) is\n      set to zeros.\n   2) Compute\
    \ the correlation between the unenhanced excitation and\n      vectors around\
    \ the estimated location interval of pssq(n).  The\n      correlation is calculated\
    \ in the interval estimated location +/- 2\n      samples.  This results in five\
    \ correlation values.\n   3) The five correlation values are upsampled by a factor\
    \ of 4, by\n      using four simple upsampling filters (MA filters with coefficients\n\
    \      upsFilter1.. upsFilter4).  Within these the maximum value is\n      found,\
    \ which specifies the best pitch-period with a resolution of\n      a quarter\
    \ of a sample.\n      upsFilter1[7]={0.000000 0.000000 0.000000 1.000000\n   \
    \          0.000000 0.000000 0.000000}\n      upsFilter2[7]={0.015625 -0.076904\
    \ 0.288330 0.862061\n            -0.106445 0.018799 -0.015625}\n      upsFilter3[7]={0.023682\
    \ -0.124268 0.601563 0.601563\n            -0.124268 0.023682 -0.023682}\n   \
    \   upsFilter4[7]={0.018799 -0.106445 0.862061 0.288330\n            -0.076904\
    \ 0.015625 -0.018799}\n   4) Generate the pssq(n) vector by upsampling of the\
    \ excitation memory\n      and extracting the sequence that corresponds to the\
    \ lag delay that\n      was calculated in prior step.\n   With the steps above,\
    \ all the pssq(n) can be found in an iterative\n   manner, first moving backward\
    \ in time from pssq(0) and then forward\n   in time from pssq(0).\n   0      \
    \        159             319             479             639\n   +---------------------------------------------------------------+\n\
    \   |  -5   |  -4   |  -3   |  -2   |  -1   |   0   |   1   |   2   |\n   +---------------------------------------------------------------+\n\
    \                                               |pssq 0 |\n                  \
    \                        |pssq -1| |pssq 1 |\n                               \
    \        |pssq -2|       |pssq 2 |\n                                    |pssq\
    \ -3|             |pssq 3 |\n   Figure 4.3.  Enhancement for 20 ms frame size.\n\
    \   Figure 4.3 depicts pitch-period-synchronous sequences in the\n   enhancement\
    \ of the first 80 sample block in the 20 ms frame size\n   mode.  The unenhanced\
    \ signal input is stored in the last two sub-\n   blocks (1 - 2), and the six\
    \ other sub-blocks contain unenhanced\n   residual prior-in-time.  We perform\
    \ the enhancement algorithm on two\n   blocks of 80 samples, where the first of\
    \ the two blocks consists of\n   the last 40 samples of sub-block 0 and the first\
    \ 40 samples of sub-\n   block 1.  The second 80-sample block consists of the\
    \ last 40 samples\n   of sub-block 1 and the first 40 samples of sub-block 2.\n\
    \   0              159             319             479             639\n   +---------------------------------------------------------------+\n\
    \   |  -4   |  -3   |  -2   |  -1   |   0   |   1   |   2   |   3   |\n   +---------------------------------------------------------------+\n\
    \                                   |pssq 0 |\n                              |pssq\
    \ -1| |pssq 1 |\n                           |pssq -2|       |pssq 2 |\n      \
    \                  |pssq -3|             |pssq 3 |\n   Figure 4.4.  Enhancement\
    \ for 30 ms frame size.\n   Figure 4.4 depicts pitch-period-synchronous sequences\
    \ in the\n   enhancement of the first 80-sample block in the 30 ms frame size\n\
    \   mode.  The unenhanced signal input is stored in the last three sub-\n   blocks\
    \ (1 - 3).  The five other sub-blocks contain unenhanced\n   residual prior-in-time.\
    \  The enhancement algorithm is performed on\n   the three 80 sample sub-blocks\
    \ 0, 1, and 2.\n"
- title: 4.6.3.  Calculation of the Smoothed Excitation
  contents:
  - "4.6.3.  Calculation of the Smoothed Excitation\n   A linear combination of the\
    \ six pssq(n) (n!=0) form a smoothed\n   approximation, z, of pssq(0).  Most of\
    \ the weight is put on the\n   sequences that are close to pssq(0), as these are\
    \ likely to be most\n   similar to pssq(0).  The smoothed vector is also rescaled\
    \ so that the\n   energy of z is the same as the energy of pssq(0).\n      ___\n\
    \      \\\n   y = > pssq(i) * pssq_weight(i)\n      /__\n   i=-3,-2,-1,1,2,3\n\
    \   pssq_weight(i) = 0.5*(1-cos(2*pi*(i+4)/(2*3+2)))\n   z = C * y, where C =\
    \ ||pssq(0)||/||y||\n"
- title: 4.6.4.  Enhancer Criterion
  contents:
  - "4.6.4.  Enhancer Criterion\n   The criterion of the enhancer is that the enhanced\
    \ excitation is not\n   allowed to differ much from the unenhanced excitation.\
    \  This\n   criterion is checked for each 80-sample sub-block.\n   e < (b * ||pssq(0)||^2),\
    \ where b=0.05 and   (Constraint 1)\n   e = (pssq(0)-z)*(pssq(0)-z), and \"*\"\
    \ means the dot product\n"
- title: 4.6.5.  Enhancing the excitation
  contents:
  - "4.6.5.  Enhancing the excitation\n   From the criterion in the previous section,\
    \ it is clear that the\n   excitation is not allowed to change much.  The purpose\
    \ of this\n   constraint is to prevent the creation of an enhanced signal\n  \
    \ significantly different from the original signal.  This also means\n   that\
    \ the constraint limits the numerical size of the errors that the\n   enhancement\
    \ procedure can make.  That is especially important in\n   unvoiced segments and\
    \ background noise segments for which increased\n   periodicity could lead to\
    \ lower perceived quality.\n   When the constraint in the prior section is not\
    \ met, the enhanced\n   residual is instead calculated through a constrained optimization\
    \ by\n   using the Lagrange multiplier technique.  The new constraint is that\n\
    \      e = (b * ||pssq(0)||^2)                     (Constraint 2)\n   We distinguish\
    \ two solution regions for the optimization: 1) the\n   region where the first\
    \ constraint is fulfilled and 2) the region\n   where the first constraint is\
    \ not fulfilled and the second constraint\n   must be used.\n   In the first case,\
    \ where the second constraint is not needed, the\n   optimized re-estimated vector\
    \ is simply z, the energy-scaled version\n   of y.\n   In the second case, where\
    \ the second constraint is activated and\n   becomes an equality constraint, we\
    \ have\n      z= A*y + B*pssq(0)\n   where\n      A = sqrt((b-b^2/4)*(w00*w00)/\
    \ (w11*w00 + w10*w10)) and\n      w11 = pssq(0)*pssq(0)\n      w00 = y*y\n   \
    \   w10 = y*pssq(0)    (* symbolizes the dot product)\n   and\n      B = 1 - b/2\
    \ - A * w10/w00\n   Appendix A.16 contains a listing of a reference implementation\
    \ for\n   the enhancement method.\n"
- title: 4.7.  Synthesis Filtering
  contents:
  - "4.7.  Synthesis Filtering\n   Upon decoding or PLC of the LP excitation block,\
    \ the decoded speech\n   block is obtained by running the decoded LP synthesis\
    \ filter,\n   1/A~k(z), over the block.  The synthesis filters have to be shifted\n\
    \   to compensate for the delay in the enhancer.  For 20 ms frame size\n   mode,\
    \ they SHOULD be shifted one 40-sample sub-block, and for 30 ms\n   frame size\
    \ mode, they SHOULD be shifted two 40-sample sub-blocks.\n   The LP coefficients\
    \ SHOULD be changed at the first sample of every\n   sub-block while keeping the\
    \ filter state.  For PLC blocks, one\n   solution is to apply the last LP coefficients\
    \ of the last decoded\n   speech block for all sub-blocks.\n   The reference implementation\
    \ for the synthesis filtering can be found\n   in Appendix A.48.\n"
- title: 4.8.  Post Filtering
  contents:
  - "4.8.  Post Filtering\n   If desired, the decoded block can be filtered by a high-pass\
    \ filter.\n   This removes the low frequencies of the decoded signal.  A reference\n\
    \   implementation of this, with cutoff at 65 Hz, is shown in Appendix\n   A.30.\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   This algorithm for the coding of speech signals\
    \ is not subject to any\n   known security consideration; however, its RTP payload\
    \ format [1] is\n   subject to several considerations, which are addressed there.\n\
    \   Confidentiality of the media streams is achieved by encryption;\n   therefore\
    \ external mechanisms, such as SRTP [5], MAY be used for that\n   purpose.\n"
- title: 6.  Evaluation of the iLBC Implementations
  contents:
  - "6.  Evaluation of the iLBC Implementations\n   It is possible and suggested to\
    \ evaluate certain iLBC implementation\n   by utilizing methodology and tools\
    \ available at\n   http://www.ilbcfreeware.org/evaluation.html\n"
- title: 7.  References
  contents:
  - '7.  References

    '
- title: 7.1.  Normative References
  contents:
  - "7.1.  Normative References\n   [1] Duric, A. and S. Andersen, \"Real-time Transport\
    \ Protocol (RTP)\n       Payload Format for internet Low Bit Rate Codec (iLBC)\
    \ Speech\",\n       RFC 3952, December 2004.\n   [2] Bradner, S., \"Key words\
    \ for use in RFCs to Indicate Requirement\n       Levels\", BCP 14, RFC 2119,\
    \ March 1997.\n   [3] PacketCable(TM) Audio/Video Codecs Specification, Cable\n\
    \       Television Laboratories, Inc.\n"
- title: 7.2.  Informative References
  contents:
  - "7.2.  Informative References\n   [4] ITU-T Recommendation G.711, available online\
    \ from the ITU\n       bookstore at http://www.itu.int.\n   [5] Baugher, M., McGrew,\
    \ D., Naslund, M., Carrara, E., and K. Norman,\n       \"The Secure Real Time\
    \ Transport Protocol (SRTP)\", RFC 3711, March\n       2004.\n"
- title: 8.  Acknowledgements
  contents:
  - "8.  Acknowledgements\n   This extensive work, besides listed authors, has the\
    \ following\n   authors, who could not have been listed among \"official\" authors\
    \ (due\n   to IESG restrictions in the number of authors who can be listed):\n\
    \      Manohar N. Murthi (Department of Electrical and Computer\n      Engineering,\
    \ University of Miami), Fredrik Galschiodt, Julian\n      Spittka, and Jan Skoglund\
    \ (Global IP Sound).\n   The authors are deeply indebted to the following people\
    \ and thank\n   them sincerely:\n      Henry Sinnreich, Patrik Faltstrom, Alan\
    \ Johnston, and Jean-\n      Francois Mule for great support of the iLBC initiative\
    \ and for\n      valuable feedback and comments.\n      Peter Vary, Frank Mertz,\
    \ and Christoph Erdmann (RWTH Aachen);\n      Vladimir Cuperman (Niftybox LLC);\
    \ Thomas Eriksson (Chalmers Univ\n      of Tech), and Gernot Kubin (TU Graz),\
    \ for thorough review of the\n      iLBC document and their valuable feedback\
    \ and remarks.\n"
- title: APPENDIX A.  Reference Implementation
  contents:
  - "APPENDIX A.  Reference Implementation\n   This appendix contains the complete\
    \ c-code for a reference\n   implementation of encoder and decoder for the specified\
    \ codec.\n   The c-code consists of the following files with highest-level\n \
    \  functions:\n         iLBC_test.c: main function for evaluation purpose\n  \
    \       iLBC_encode.h: encoder header\n         iLBC_encode.c: encoder function\n\
    \         iLBC_decode.h: decoder header\n         iLBC_decode.c: decoder function\n\
    \   The following files contain global defines and constants:\n         iLBC_define.h:\
    \ global defines\n         constants.h: global constants header\n         constants.c:\
    \ global constants memory allocations\n   The following files contain subroutines:\n\
    \         anaFilter.h: lpc analysis filter header\n         anaFilter.c: lpc analysis\
    \ filter function\n         createCB.h: codebook construction header\n       \
    \  createCB.c: codebook construction function\n         doCPLC.h: packet loss\
    \ concealment header\n         doCPLC.c: packet loss concealment function\n  \
    \       enhancer.h: signal enhancement header\n         enhancer.c: signal enhancement\
    \ function\n         filter.h: general filter header\n         filter.c: general\
    \ filter functions\n         FrameClassify.h: start state classification header\n\
    \         FrameClassify.c: start state classification function\n         gainquant.h:\
    \ gain quantization header\n         gainquant.c: gain quantization function\n\
    \         getCBvec.h: codebook vector construction header\n         getCBvec.c:\
    \ codebook vector construction function\n         helpfun.h: general purpose header\n\
    \         helpfun.c: general purpose functions\n         hpInput.h: input high\
    \ pass filter header\n         hpInput.c: input high pass filter function\n  \
    \       hpOutput.h: output high pass filter header\n         hpOutput.c: output\
    \ high pass filter function\n         iCBConstruct.h: excitation decoding header\n\
    \         iCBConstruct.c: excitation decoding function\n         iCBSearch.h:\
    \ excitation encoding header\n         iCBSearch.c: excitation encoding function\n\
    \         LPCdecode.h: lpc decoding header\n         LPCdecode.c: lpc decoding\
    \ function\n         LPCencode.h: lpc encoding header\n         LPCencode.c: lpc\
    \ encoding function\n         lsf.h: line spectral frequencies header\n      \
    \   lsf.c: line spectral frequencies functions\n         packing.h: bitstream\
    \ packetization header\n         packing.c: bitstream packetization functions\n\
    \         StateConstructW.h: state decoding header\n         StateConstructW.c:\
    \ state decoding functions\n         StateSearchW.h: state encoding header\n \
    \        StateSearchW.c: state encoding function\n         syntFilter.h: lpc synthesis\
    \ filter header\n         syntFilter.c: lpc synthesis filter function\n   The\
    \ implementation is portable and should work on many different\n   platforms.\
    \  However, it is not difficult to optimize the\n   implementation on particular\
    \ platforms, an exercise left to the\n   reader.\n"
- title: A.1.  iLBC_test.c
  contents:
  - "A.1.  iLBC_test.c\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       iLBC_test.c\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #include <math.h>\n   #include <stdlib.h>\n   #include <stdio.h>\n   #include\
    \ <string.h>\n   #include \"iLBC_define.h\"\n   #include \"iLBC_encode.h\"\n \
    \  #include \"iLBC_decode.h\"\n   /* Runtime statistics */\n   #include <time.h>\n\
    \   #define ILBCNOOFWORDS_MAX   (NO_OF_BYTES_30MS/2)\n   /*----------------------------------------------------------------*\n\
    \    *  Encoder interface function\n    *---------------------------------------------------------------*/\n\
    \   short encode(   /* (o) Number of bytes encoded */\n       iLBC_Enc_Inst_t\
    \ *iLBCenc_inst,\n                                   /* (i/o) Encoder instance\
    \ */\n       short *encoded_data,    /* (o) The encoded bytes */\n       short\
    \ *data                 /* (i) The signal block to encode*/\n   ){\n       float\
    \ block[BLOCKL_MAX];\n       int k;\n       /* convert signal to float */\n  \
    \     for (k=0; k<iLBCenc_inst->blockl; k++)\n           block[k] = (float)data[k];\n\
    \       /* do the actual encoding */\n       iLBC_encode((unsigned char *)encoded_data,\
    \ block, iLBCenc_inst);\n       return (iLBCenc_inst->no_of_bytes);\n   }\n  \
    \ /*----------------------------------------------------------------*\n    * \
    \ Decoder interface function\n    *---------------------------------------------------------------*/\n\
    \   short decode(       /* (o) Number of decoded samples */\n       iLBC_Dec_Inst_t\
    \ *iLBCdec_inst,  /* (i/o) Decoder instance */\n       short *decoded_data,  \
    \      /* (o) Decoded signal block*/\n       short *encoded_data,        /* (i)\
    \ Encoded bytes */\n       short mode                       /* (i) 0=PL, 1=Normal\
    \ */\n   ){\n       int k;\n       float decblock[BLOCKL_MAX], dtmp;\n       /*\
    \ check if mode is valid */\n       if (mode<0 || mode>1) {\n           printf(\"\
    \\nERROR - Wrong mode - 0, 1 allowed\\n\"); exit(3);}\n       /* do actual decoding\
    \ of block */\n       iLBC_decode(decblock, (unsigned char *)encoded_data,\n \
    \          iLBCdec_inst, mode);\n       /* convert to short */\n       for (k=0;\
    \ k<iLBCdec_inst->blockl; k++){\n           dtmp=decblock[k];\n           if (dtmp<MIN_SAMPLE)\n\
    \               dtmp=MIN_SAMPLE;\n           else if (dtmp>MAX_SAMPLE)\n     \
    \          dtmp=MAX_SAMPLE;\n           decoded_data[k] = (short) dtmp;\n    \
    \   }\n       return (iLBCdec_inst->blockl);\n   }\n   /*---------------------------------------------------------------*\n\
    \    *  Main program to test iLBC encoding and decoding\n    *\n    *  Usage:\n\
    \    *    exefile_name.exe <infile> <bytefile> <outfile> <channel>\n    *\n  \
    \  *    <infile>   : Input file, speech for encoder (16-bit pcm file)\n    * \
    \   <bytefile> : Bit stream output from the encoder\n    *    <outfile>  : Output\
    \ file, decoded speech (16-bit pcm file)\n    *    <channel>  : Bit error file,\
    \ optional (16-bit)\n    *                     1 - Packet received correctly\n\
    \    *                     0 - Packet Lost\n    *\n    *--------------------------------------------------------------*/\n\
    \   int main(int argc, char* argv[])\n   {\n       /* Runtime statistics */\n\
    \       float starttime;\n       float runtime;\n       float outtime;\n     \
    \  FILE *ifileid,*efileid,*ofileid, *cfileid;\n       short data[BLOCKL_MAX];\n\
    \       short encoded_data[ILBCNOOFWORDS_MAX], decoded_data[BLOCKL_MAX];\n   \
    \    int len;\n       short pli, mode;\n       int blockcount = 0;\n       int\
    \ packetlosscount = 0;\n       /* Create structs */\n       iLBC_Enc_Inst_t Enc_Inst;\n\
    \       iLBC_Dec_Inst_t Dec_Inst;\n       /* get arguments and open files */\n\
    \       if ((argc!=5) && (argc!=6)) {\n           fprintf(stderr,\n          \
    \ \"\\n*-----------------------------------------------*\\n\");\n           fprintf(stderr,\n\
    \           \"   %s <20,30> input encoded decoded (channel)\\n\\n\",\n       \
    \        argv[0]);\n           fprintf(stderr,\n           \"   mode    : Frame\
    \ size for the encoding/decoding\\n\");\n           fprintf(stderr,\n        \
    \   \"                 20 - 20 ms\\n\");\n           fprintf(stderr,\n       \
    \    \"                 30 - 30 ms\\n\");\n           fprintf(stderr,\n      \
    \     \"   input   : Speech for encoder (16-bit pcm file)\\n\");\n           fprintf(stderr,\n\
    \           \"   encoded : Encoded bit stream\\n\");\n           fprintf(stderr,\n\
    \           \"   decoded : Decoded speech (16-bit pcm file)\\n\");\n         \
    \  fprintf(stderr,\n           \"   channel : Packet loss pattern, optional (16-bit)\\\
    n\");\n           fprintf(stderr,\n           \"                  1 - Packet received\
    \ correctly\\n\");\n           fprintf(stderr,\n           \"                \
    \  0 - Packet Lost\\n\");\n           fprintf(stderr,\n           \"*-----------------------------------------------*\\\
    n\\n\");\n           exit(1);\n       }\n       mode=atoi(argv[1]);\n       if\
    \ (mode != 20 && mode != 30) {\n           fprintf(stderr,\"Wrong mode %s, must\
    \ be 20, or 30\\n\",\n               argv[1]);\n           exit(2);\n       }\n\
    \       if ( (ifileid=fopen(argv[2],\"rb\")) == NULL) {\n           fprintf(stderr,\"\
    Cannot open input file %s\\n\", argv[2]);\n           exit(2);}\n       if ( (efileid=fopen(argv[3],\"\
    wb\")) == NULL) {\n           fprintf(stderr, \"Cannot open encoded file %s\\\
    n\",\n               argv[3]); exit(1);}\n       if ( (ofileid=fopen(argv[4],\"\
    wb\")) == NULL) {\n           fprintf(stderr, \"Cannot open decoded file %s\\\
    n\",\n               argv[4]); exit(1);}\n       if (argc==6) {\n           if(\
    \ (cfileid=fopen(argv[5],\"rb\")) == NULL) {\n               fprintf(stderr, \"\
    Cannot open channel file %s\\n\",\n                   argv[5]);\n            \
    \   exit(1);\n           }\n       } else {\n           cfileid=NULL;\n      \
    \ }\n       /* print info */\n       fprintf(stderr, \"\\n\");\n       fprintf(stderr,\n\
    \           \"*---------------------------------------------------*\\n\");\n \
    \      fprintf(stderr,\n           \"*                                       \
    \            *\\n\");\n       fprintf(stderr,\n           \"*      iLBC test program\
    \                            *\\n\");\n       fprintf(stderr,\n           \"*\
    \                                                   *\\n\");\n       fprintf(stderr,\n\
    \           \"*                                                   *\\n\");\n \
    \      fprintf(stderr,\n           \"*---------------------------------------------------*\\\
    n\");\n       fprintf(stderr,\"\\nMode           : %2d ms\\n\", mode);\n     \
    \  fprintf(stderr,\"Input file     : %s\\n\", argv[2]);\n       fprintf(stderr,\"\
    Encoded file   : %s\\n\", argv[3]);\n       fprintf(stderr,\"Output file    :\
    \ %s\\n\", argv[4]);\n       if (argc==6) {\n           fprintf(stderr,\"Channel\
    \ file   : %s\\n\", argv[5]);\n       }\n       fprintf(stderr,\"\\n\");\n   \
    \    /* Initialization */\n       initEncode(&Enc_Inst, mode);\n       initDecode(&Dec_Inst,\
    \ mode, 1);\n       /* Runtime statistics */\n       starttime=clock()/(float)CLOCKS_PER_SEC;\n\
    \       /* loop over input blocks */\n       while (fread(data,sizeof(short),Enc_Inst.blockl,ifileid)==\n\
    \               Enc_Inst.blockl) {\n           blockcount++;\n           /* encoding\
    \ */\n           fprintf(stderr, \"--- Encoding block %i --- \",blockcount);\n\
    \           len=encode(&Enc_Inst, encoded_data, data);\n           fprintf(stderr,\
    \ \"\\r\");\n           /* write byte file */\n           fwrite(encoded_data,\
    \ sizeof(unsigned char), len, efileid);\n           /* get channel data if provided\
    \ */\n           if (argc==6) {\n               if (fread(&pli, sizeof(short),\
    \ 1, cfileid)) {\n                   if ((pli!=0)&&(pli!=1)) {\n             \
    \          fprintf(stderr, \"Error in channel file\\n\");\n                  \
    \     exit(0);\n                   }\n                   if (pli==0) {\n     \
    \                  /* Packet loss -> remove info from frame */\n             \
    \          memset(encoded_data, 0,\n                           sizeof(short)*ILBCNOOFWORDS_MAX);\n\
    \                       packetlosscount++;\n                   }\n           \
    \    } else {\n                   fprintf(stderr, \"Error. Channel file too short\\\
    n\");\n                   exit(0);\n               }\n           } else {\n  \
    \             pli=1;\n           }\n           /* decoding */\n           fprintf(stderr,\
    \ \"--- Decoding block %i --- \",blockcount);\n           len=decode(&Dec_Inst,\
    \ decoded_data, encoded_data, pli);\n           fprintf(stderr, \"\\r\");\n  \
    \         /* write output file */\n           fwrite(decoded_data,sizeof(short),len,ofileid);\n\
    \       }\n       /* Runtime statistics */\n       runtime = (float)(clock()/(float)CLOCKS_PER_SEC-starttime);\n\
    \       outtime = (float)((float)blockcount*(float)mode/1000.0);\n       printf(\"\
    \\n\\nLength of speech file: %.1f s\\n\", outtime);\n       printf(\"Packet loss\
    \          : %.1f%%\\n\",\n           100.0*(float)packetlosscount/(float)blockcount);\n\
    \       printf(\"Time to run iLBC     :\");\n       printf(\" %.1f s (%.1f %%\
    \ of realtime)\\n\\n\", runtime,\n           (100*runtime/outtime));\n       /*\
    \ close files */\n       fclose(ifileid);  fclose(efileid); fclose(ofileid);\n\
    \       if (argc==6) {\n           fclose(cfileid);\n       }\n       return(0);\n\
    \   }\n"
- title: A.2.  iLBC_encode.h
  contents:
  - "A.2.  iLBC_encode.h\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       iLBC_encode.h\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #ifndef __iLBC_ILBCENCODE_H\n   #define __iLBC_ILBCENCODE_H\n   #include \"\
    iLBC_define.h\"\n   short initEncode(                   /* (o) Number of bytes\n\
    \                                              encoded */\n       iLBC_Enc_Inst_t\
    \ *iLBCenc_inst,  /* (i/o) Encoder instance */\n       int mode              \
    \      /* (i) frame size mode */\n   );\n   void iLBC_encode(\n       unsigned\
    \ char *bytes,           /* (o) encoded data bits iLBC */\n       float *block,\
    \                   /* (o) speech vector to\n                                \
    \              encode */\n       iLBC_Enc_Inst_t *iLBCenc_inst   /* (i/o) the\
    \ general encoder\n                                              state */\n  \
    \ );\n   #endif\n"
- title: A.3.  iLBC_encode.c
  contents:
  - "A.3.  iLBC_encode.c\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       iLBC_encode.c\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #include <math.h>\n   #include <stdlib.h>\n   #include <string.h>\n   #include\
    \ \"iLBC_define.h\"\n   #include \"LPCencode.h\"\n   #include \"FrameClassify.h\"\
    \n   #include \"StateSearchW.h\"\n   #include \"StateConstructW.h\"\n   #include\
    \ \"helpfun.h\"\n   #include \"constants.h\"\n   #include \"packing.h\"\n   #include\
    \ \"iCBSearch.h\"\n   #include \"iCBConstruct.h\"\n   #include \"hpInput.h\"\n\
    \   #include \"anaFilter.h\"\n   #include \"syntFilter.h\"\n   /*----------------------------------------------------------------*\n\
    \    *  Initiation of encoder instance.\n    *---------------------------------------------------------------*/\n\
    \   short initEncode(                   /* (o) Number of bytes\n             \
    \                                 encoded */\n       iLBC_Enc_Inst_t *iLBCenc_inst,\
    \  /* (i/o) Encoder instance */\n       int mode                    /* (i) frame\
    \ size mode */\n   ){\n       iLBCenc_inst->mode = mode;\n       if (mode==30)\
    \ {\n           iLBCenc_inst->blockl = BLOCKL_30MS;\n           iLBCenc_inst->nsub\
    \ = NSUB_30MS;\n           iLBCenc_inst->nasub = NASUB_30MS;\n           iLBCenc_inst->lpc_n\
    \ = LPC_N_30MS;\n           iLBCenc_inst->no_of_bytes = NO_OF_BYTES_30MS;\n  \
    \         iLBCenc_inst->no_of_words = NO_OF_WORDS_30MS;\n           iLBCenc_inst->state_short_len=STATE_SHORT_LEN_30MS;\n\
    \           /* ULP init */\n           iLBCenc_inst->ULP_inst=&ULP_30msTbl;\n\
    \       }\n       else if (mode==20) {\n           iLBCenc_inst->blockl = BLOCKL_20MS;\n\
    \           iLBCenc_inst->nsub = NSUB_20MS;\n           iLBCenc_inst->nasub =\
    \ NASUB_20MS;\n           iLBCenc_inst->lpc_n = LPC_N_20MS;\n           iLBCenc_inst->no_of_bytes\
    \ = NO_OF_BYTES_20MS;\n           iLBCenc_inst->no_of_words = NO_OF_WORDS_20MS;\n\
    \           iLBCenc_inst->state_short_len=STATE_SHORT_LEN_20MS;\n           /*\
    \ ULP init */\n           iLBCenc_inst->ULP_inst=&ULP_20msTbl;\n       }\n   \
    \    else {\n           exit(2);\n       }\n       memset((*iLBCenc_inst).anaMem,\
    \ 0,\n           LPC_FILTERORDER*sizeof(float));\n       memcpy((*iLBCenc_inst).lsfold,\
    \ lsfmeanTbl,\n           LPC_FILTERORDER*sizeof(float));\n       memcpy((*iLBCenc_inst).lsfdeqold,\
    \ lsfmeanTbl,\n           LPC_FILTERORDER*sizeof(float));\n       memset((*iLBCenc_inst).lpc_buffer,\
    \ 0,\n           (LPC_LOOKBACK+BLOCKL_MAX)*sizeof(float));\n       memset((*iLBCenc_inst).hpimem,\
    \ 0, 4*sizeof(float));\n       return (iLBCenc_inst->no_of_bytes);\n   }\n   /*----------------------------------------------------------------*\n\
    \    *  main encoder function\n    *---------------------------------------------------------------*/\n\
    \   void iLBC_encode(\n       unsigned char *bytes,           /* (o) encoded data\
    \ bits iLBC */\n       float *block,                   /* (o) speech vector to\n\
    \                                              encode */\n       iLBC_Enc_Inst_t\
    \ *iLBCenc_inst   /* (i/o) the general encoder\n                             \
    \                 state */\n   ){\n       float data[BLOCKL_MAX];\n       float\
    \ residual[BLOCKL_MAX], reverseResidual[BLOCKL_MAX];\n       int start, idxForMax,\
    \ idxVec[STATE_LEN];\n       float reverseDecresidual[BLOCKL_MAX], mem[CB_MEML];\n\
    \       int n, k, meml_gotten, Nfor, Nback, i, pos;\n       int gain_index[CB_NSTAGES*NASUB_MAX],\n\
    \           extra_gain_index[CB_NSTAGES];\n       int cb_index[CB_NSTAGES*NASUB_MAX],extra_cb_index[CB_NSTAGES];\n\
    \       int lsf_i[LSF_NSPLIT*LPC_N_MAX];\n       unsigned char *pbytes;\n    \
    \   int diff, start_pos, state_first;\n       float en1, en2;\n       int index,\
    \ ulp, firstpart;\n       int subcount, subframe;\n       float weightState[LPC_FILTERORDER];\n\
    \       float syntdenum[NSUB_MAX*(LPC_FILTERORDER+1)];\n       float weightdenum[NSUB_MAX*(LPC_FILTERORDER+1)];\n\
    \       float decresidual[BLOCKL_MAX];\n       /* high pass filtering of input\
    \ signal if such is not done\n              prior to calling this function */\n\
    \       hpInput(block, iLBCenc_inst->blockl,\n                   data, (*iLBCenc_inst).hpimem);\n\
    \       /* otherwise simply copy */\n       /*memcpy(data,block,iLBCenc_inst->blockl*sizeof(float));*/\n\
    \       /* LPC of hp filtered input data */\n       LPCencode(syntdenum, weightdenum,\
    \ lsf_i, data, iLBCenc_inst);\n       /* inverse filter to get residual */\n \
    \      for (n=0; n<iLBCenc_inst->nsub; n++) {\n           anaFilter(&data[n*SUBL],\
    \ &syntdenum[n*(LPC_FILTERORDER+1)],\n               SUBL, &residual[n*SUBL],\
    \ iLBCenc_inst->anaMem);\n       }\n       /* find state location */\n       start\
    \ = FrameClassify(iLBCenc_inst, residual);\n       /* check if state should be\
    \ in first or last part of the\n       two subframes */\n       diff = STATE_LEN\
    \ - iLBCenc_inst->state_short_len;\n       en1 = 0;\n       index = (start-1)*SUBL;\n\
    \       for (i = 0; i < iLBCenc_inst->state_short_len; i++) {\n           en1\
    \ += residual[index+i]*residual[index+i];\n       }\n       en2 = 0;\n       index\
    \ = (start-1)*SUBL+diff;\n       for (i = 0; i < iLBCenc_inst->state_short_len;\
    \ i++) {\n           en2 += residual[index+i]*residual[index+i];\n       }\n \
    \      if (en1 > en2) {\n           state_first = 1;\n           start_pos = (start-1)*SUBL;\n\
    \       } else {\n           state_first = 0;\n           start_pos = (start-1)*SUBL\
    \ + diff;\n       }\n       /* scalar quantization of state */\n       StateSearchW(iLBCenc_inst,\
    \ &residual[start_pos],\n           &syntdenum[(start-1)*(LPC_FILTERORDER+1)],\n\
    \           &weightdenum[(start-1)*(LPC_FILTERORDER+1)], &idxForMax,\n       \
    \    idxVec, iLBCenc_inst->state_short_len, state_first);\n       StateConstructW(idxForMax,\
    \ idxVec,\n           &syntdenum[(start-1)*(LPC_FILTERORDER+1)],\n           &decresidual[start_pos],\
    \ iLBCenc_inst->state_short_len);\n       /* predictive quantization in state\
    \ */\n       if (state_first) { /* put adaptive part in the end */\n         \
    \  /* setup memory */\n           memset(mem, 0,\n               (CB_MEML-iLBCenc_inst->state_short_len)*sizeof(float));\n\
    \           memcpy(mem+CB_MEML-iLBCenc_inst->state_short_len,\n              \
    \ decresidual+start_pos,\n               iLBCenc_inst->state_short_len*sizeof(float));\n\
    \           memset(weightState, 0, LPC_FILTERORDER*sizeof(float));\n         \
    \  /* encode sub-frames */\n           iCBSearch(iLBCenc_inst, extra_cb_index,\
    \ extra_gain_index,\n               &residual[start_pos+iLBCenc_inst->state_short_len],\n\
    \               mem+CB_MEML-stMemLTbl,\n               stMemLTbl, diff, CB_NSTAGES,\n\
    \               &weightdenum[start*(LPC_FILTERORDER+1)],\n               weightState,\
    \ 0);\n           /* construct decoded vector */\n           iCBConstruct(\n \
    \              &decresidual[start_pos+iLBCenc_inst->state_short_len],\n      \
    \         extra_cb_index, extra_gain_index,\n               mem+CB_MEML-stMemLTbl,\n\
    \               stMemLTbl, diff, CB_NSTAGES);\n       }\n       else { /* put\
    \ adaptive part in the beginning */\n           /* create reversed vectors for\
    \ prediction */\n           for (k=0; k<diff; k++) {\n               reverseResidual[k]\
    \ = residual[(start+1)*SUBL-1\n                   -(k+iLBCenc_inst->state_short_len)];\n\
    \           }\n           /* setup memory */\n           meml_gotten = iLBCenc_inst->state_short_len;\n\
    \           for (k=0; k<meml_gotten; k++) {\n               mem[CB_MEML-1-k] =\
    \ decresidual[start_pos + k];\n           }\n           memset(mem, 0, (CB_MEML-k)*sizeof(float));\n\
    \           memset(weightState, 0, LPC_FILTERORDER*sizeof(float));\n         \
    \  /* encode sub-frames */\n           iCBSearch(iLBCenc_inst, extra_cb_index,\
    \ extra_gain_index,\n               reverseResidual, mem+CB_MEML-stMemLTbl, stMemLTbl,\n\
    \               diff, CB_NSTAGES,\n               &weightdenum[(start-1)*(LPC_FILTERORDER+1)],\n\
    \               weightState, 0);\n           /* construct decoded vector */\n\
    \           iCBConstruct(reverseDecresidual, extra_cb_index,\n               extra_gain_index,\
    \ mem+CB_MEML-stMemLTbl, stMemLTbl,\n               diff, CB_NSTAGES);\n     \
    \      /* get decoded residual from reversed vector */\n           for (k=0; k<diff;\
    \ k++) {\n               decresidual[start_pos-1-k] = reverseDecresidual[k];\n\
    \           }\n       }\n       /* counter for predicted sub-frames */\n     \
    \  subcount=0;\n       /* forward prediction of sub-frames */\n       Nfor = iLBCenc_inst->nsub-start-1;\n\
    \       if ( Nfor > 0 ) {\n           /* setup memory */\n           memset(mem,\
    \ 0, (CB_MEML-STATE_LEN)*sizeof(float));\n           memcpy(mem+CB_MEML-STATE_LEN,\
    \ decresidual+(start-1)*SUBL,\n               STATE_LEN*sizeof(float));\n    \
    \       memset(weightState, 0, LPC_FILTERORDER*sizeof(float));\n           /*\
    \ loop over sub-frames to encode */\n           for (subframe=0; subframe<Nfor;\
    \ subframe++) {\n               /* encode sub-frame */\n               iCBSearch(iLBCenc_inst,\
    \ cb_index+subcount*CB_NSTAGES,\n                   gain_index+subcount*CB_NSTAGES,\n\
    \                   &residual[(start+1+subframe)*SUBL],\n                   mem+CB_MEML-memLfTbl[subcount],\n\
    \                   memLfTbl[subcount], SUBL, CB_NSTAGES,\n                  \
    \ &weightdenum[(start+1+subframe)*\n                               (LPC_FILTERORDER+1)],\n\
    \                   weightState, subcount+1);\n               /* construct decoded\
    \ vector */\n               iCBConstruct(&decresidual[(start+1+subframe)*SUBL],\n\
    \                   cb_index+subcount*CB_NSTAGES,\n                   gain_index+subcount*CB_NSTAGES,\n\
    \                   mem+CB_MEML-memLfTbl[subcount],\n                   memLfTbl[subcount],\
    \ SUBL, CB_NSTAGES);\n               /* update memory */\n               memcpy(mem,\
    \ mem+SUBL, (CB_MEML-SUBL)*sizeof(float));\n               memcpy(mem+CB_MEML-SUBL,\n\
    \                   &decresidual[(start+1+subframe)*SUBL],\n                 \
    \  SUBL*sizeof(float));\n               memset(weightState, 0, LPC_FILTERORDER*sizeof(float));\n\
    \               subcount++;\n           }\n       }\n       /* backward prediction\
    \ of sub-frames */\n       Nback = start-1;\n       if ( Nback > 0 ) {\n     \
    \      /* create reverse order vectors */\n           for (n=0; n<Nback; n++)\
    \ {\n               for (k=0; k<SUBL; k++) {\n                   reverseResidual[n*SUBL+k]\
    \ =\n                       residual[(start-1)*SUBL-1-n*SUBL-k];\n           \
    \        reverseDecresidual[n*SUBL+k] =\n                       decresidual[(start-1)*SUBL-1-n*SUBL-k];\n\
    \               }\n           }\n           /* setup memory */\n           meml_gotten\
    \ = SUBL*(iLBCenc_inst->nsub+1-start);\n           if ( meml_gotten > CB_MEML\
    \ ) {\n               meml_gotten=CB_MEML;\n           }\n           for (k=0;\
    \ k<meml_gotten; k++) {\n               mem[CB_MEML-1-k] = decresidual[(start-1)*SUBL\
    \ + k];\n           }\n           memset(mem, 0, (CB_MEML-k)*sizeof(float));\n\
    \           memset(weightState, 0, LPC_FILTERORDER*sizeof(float));\n         \
    \  /* loop over sub-frames to encode */\n           for (subframe=0; subframe<Nback;\
    \ subframe++) {\n               /* encode sub-frame */\n               iCBSearch(iLBCenc_inst,\
    \ cb_index+subcount*CB_NSTAGES,\n                   gain_index+subcount*CB_NSTAGES,\n\
    \                   &reverseResidual[subframe*SUBL],\n                   mem+CB_MEML-memLfTbl[subcount],\n\
    \                   memLfTbl[subcount], SUBL, CB_NSTAGES,\n                  \
    \ &weightdenum[(start-2-subframe)*\n                               (LPC_FILTERORDER+1)],\n\
    \                   weightState, subcount+1);\n               /* construct decoded\
    \ vector */\n               iCBConstruct(&reverseDecresidual[subframe*SUBL],\n\
    \                   cb_index+subcount*CB_NSTAGES,\n                   gain_index+subcount*CB_NSTAGES,\n\
    \                   mem+CB_MEML-memLfTbl[subcount],\n                   memLfTbl[subcount],\
    \ SUBL, CB_NSTAGES);\n               /* update memory */\n               memcpy(mem,\
    \ mem+SUBL, (CB_MEML-SUBL)*sizeof(float));\n               memcpy(mem+CB_MEML-SUBL,\n\
    \                   &reverseDecresidual[subframe*SUBL],\n                   SUBL*sizeof(float));\n\
    \               memset(weightState, 0, LPC_FILTERORDER*sizeof(float));\n     \
    \          subcount++;\n           }\n           /* get decoded residual from\
    \ reversed vector */\n           for (i=0; i<SUBL*Nback; i++) {\n            \
    \   decresidual[SUBL*Nback - i - 1] =\n                   reverseDecresidual[i];\n\
    \           }\n       }\n       /* end encoding part */\n       /* adjust index\
    \ */\n       index_conv_enc(cb_index);\n       /* pack bytes */\n       pbytes=bytes;\n\
    \       pos=0;\n       /* loop over the 3 ULP classes */\n       for (ulp=0; ulp<3;\
    \ ulp++) {\n           /* LSF */\n           for (k=0; k<LSF_NSPLIT*iLBCenc_inst->lpc_n;\
    \ k++) {\n               packsplit(&lsf_i[k], &firstpart, &lsf_i[k],\n       \
    \            iLBCenc_inst->ULP_inst->lsf_bits[k][ulp],\n                   iLBCenc_inst->ULP_inst->lsf_bits[k][ulp]+\n\
    \                   iLBCenc_inst->ULP_inst->lsf_bits[k][ulp+1]+\n            \
    \       iLBCenc_inst->ULP_inst->lsf_bits[k][ulp+2]);\n               dopack( &pbytes,\
    \ firstpart,\n                   iLBCenc_inst->ULP_inst->lsf_bits[k][ulp], &pos);\n\
    \           }\n           /* Start block info */\n           packsplit(&start,\
    \ &firstpart, &start,\n               iLBCenc_inst->ULP_inst->start_bits[ulp],\n\
    \               iLBCenc_inst->ULP_inst->start_bits[ulp]+\n               iLBCenc_inst->ULP_inst->start_bits[ulp+1]+\n\
    \               iLBCenc_inst->ULP_inst->start_bits[ulp+2]);\n           dopack(\
    \ &pbytes, firstpart,\n               iLBCenc_inst->ULP_inst->start_bits[ulp],\
    \ &pos);\n           packsplit(&state_first, &firstpart, &state_first,\n     \
    \          iLBCenc_inst->ULP_inst->startfirst_bits[ulp],\n               iLBCenc_inst->ULP_inst->startfirst_bits[ulp]+\n\
    \               iLBCenc_inst->ULP_inst->startfirst_bits[ulp+1]+\n            \
    \   iLBCenc_inst->ULP_inst->startfirst_bits[ulp+2]);\n           dopack( &pbytes,\
    \ firstpart,\n               iLBCenc_inst->ULP_inst->startfirst_bits[ulp], &pos);\n\
    \           packsplit(&idxForMax, &firstpart, &idxForMax,\n               iLBCenc_inst->ULP_inst->scale_bits[ulp],\n\
    \               iLBCenc_inst->ULP_inst->scale_bits[ulp]+\n               iLBCenc_inst->ULP_inst->scale_bits[ulp+1]+\n\
    \               iLBCenc_inst->ULP_inst->scale_bits[ulp+2]);\n           dopack(\
    \ &pbytes, firstpart,\n               iLBCenc_inst->ULP_inst->scale_bits[ulp],\
    \ &pos);\n           for (k=0; k<iLBCenc_inst->state_short_len; k++) {\n     \
    \          packsplit(idxVec+k, &firstpart, idxVec+k,\n                   iLBCenc_inst->ULP_inst->state_bits[ulp],\n\
    \                   iLBCenc_inst->ULP_inst->state_bits[ulp]+\n               \
    \    iLBCenc_inst->ULP_inst->state_bits[ulp+1]+\n                   iLBCenc_inst->ULP_inst->state_bits[ulp+2]);\n\
    \               dopack( &pbytes, firstpart,\n                   iLBCenc_inst->ULP_inst->state_bits[ulp],\
    \ &pos);\n           }\n           /* 23/22 (20ms/30ms) sample block */\n    \
    \       for (k=0;k<CB_NSTAGES;k++) {\n               packsplit(extra_cb_index+k,\
    \ &firstpart,\n                   extra_cb_index+k,\n                   iLBCenc_inst->ULP_inst->extra_cb_index[k][ulp],\n\
    \                   iLBCenc_inst->ULP_inst->extra_cb_index[k][ulp]+\n        \
    \           iLBCenc_inst->ULP_inst->extra_cb_index[k][ulp+1]+\n              \
    \     iLBCenc_inst->ULP_inst->extra_cb_index[k][ulp+2]);\n               dopack(\
    \ &pbytes, firstpart,\n                   iLBCenc_inst->ULP_inst->extra_cb_index[k][ulp],\n\
    \                   &pos);\n           }\n           for (k=0;k<CB_NSTAGES;k++)\
    \ {\n               packsplit(extra_gain_index+k, &firstpart,\n              \
    \     extra_gain_index+k,\n                   iLBCenc_inst->ULP_inst->extra_cb_gain[k][ulp],\n\
    \                   iLBCenc_inst->ULP_inst->extra_cb_gain[k][ulp]+\n         \
    \          iLBCenc_inst->ULP_inst->extra_cb_gain[k][ulp+1]+\n                \
    \   iLBCenc_inst->ULP_inst->extra_cb_gain[k][ulp+2]);\n               dopack(\
    \ &pbytes, firstpart,\n                   iLBCenc_inst->ULP_inst->extra_cb_gain[k][ulp],\n\
    \                   &pos);\n           }\n           /* The two/four (20ms/30ms)\
    \ 40 sample sub-blocks */\n           for (i=0; i<iLBCenc_inst->nasub; i++) {\n\
    \               for (k=0; k<CB_NSTAGES; k++) {\n                   packsplit(cb_index+i*CB_NSTAGES+k,\
    \ &firstpart,\n                       cb_index+i*CB_NSTAGES+k,\n             \
    \          iLBCenc_inst->ULP_inst->cb_index[i][k][ulp],\n                    \
    \   iLBCenc_inst->ULP_inst->cb_index[i][k][ulp]+\n                       iLBCenc_inst->ULP_inst->cb_index[i][k][ulp+1]+\n\
    \                       iLBCenc_inst->ULP_inst->cb_index[i][k][ulp+2]);\n    \
    \               dopack( &pbytes, firstpart,\n                       iLBCenc_inst->ULP_inst->cb_index[i][k][ulp],\n\
    \                       &pos);\n               }\n           }\n           for\
    \ (i=0; i<iLBCenc_inst->nasub; i++) {\n               for (k=0; k<CB_NSTAGES;\
    \ k++) {\n                   packsplit(gain_index+i*CB_NSTAGES+k, &firstpart,\n\
    \                       gain_index+i*CB_NSTAGES+k,\n                       iLBCenc_inst->ULP_inst->cb_gain[i][k][ulp],\n\
    \                       iLBCenc_inst->ULP_inst->cb_gain[i][k][ulp]+\n        \
    \               iLBCenc_inst->ULP_inst->cb_gain[i][k][ulp+1]+\n              \
    \         iLBCenc_inst->ULP_inst->cb_gain[i][k][ulp+2]);\n                   dopack(\
    \ &pbytes, firstpart,\n                       iLBCenc_inst->ULP_inst->cb_gain[i][k][ulp],\n\
    \                       &pos);\n               }\n           }\n       }\n   \
    \    /* set the last bit to zero (otherwise the decoder\n          will treat\
    \ it as a lost frame) */\n       dopack( &pbytes, 0, 1, &pos);\n   }\n"
- title: A.4.  iLBC_decode.h
  contents:
  - "A.4.  iLBC_decode.h\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       iLBC_decode.h\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #ifndef __iLBC_ILBCDECODE_H\n   #define __iLBC_ILBCDECODE_H\n   #include \"\
    iLBC_define.h\"\n   short initDecode(                   /* (o) Number of decoded\n\
    \                                              samples */\n       iLBC_Dec_Inst_t\
    \ *iLBCdec_inst,  /* (i/o) Decoder instance */\n       int mode,             \
    \          /* (i) frame size mode */\n       int use_enhancer                /*\
    \ (i) 1 to use enhancer\n                                              0 to run\
    \ without\n                                                enhancer */\n   );\n\
    \   void iLBC_decode(\n       float *decblock,            /* (o) decoded signal\
    \ block */\n       unsigned char *bytes,           /* (i) encoded signal bits\
    \ */\n       iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) the decoder state\n    \
    \                                            structure */\n       int mode   \
    \                 /* (i) 0: bad packet, PLC,\n                               \
    \               1: normal */\n   );\n   #endif\n"
- title: A.5.  iLBC_decode.c
  contents:
  - "A.5.  iLBC_decode.c\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       iLBC_decode.c\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #include <math.h>\n   #include <stdlib.h>\n   #include \"iLBC_define.h\"\n\
    \   #include \"StateConstructW.h\"\n   #include \"LPCdecode.h\"\n   #include \"\
    iCBConstruct.h\"\n   #include \"doCPLC.h\"\n   #include \"helpfun.h\"\n   #include\
    \ \"constants.h\"\n   #include \"packing.h\"\n   #include \"string.h\"\n   #include\
    \ \"enhancer.h\"\n   #include \"hpOutput.h\"\n   #include \"syntFilter.h\"\n \
    \  /*----------------------------------------------------------------*\n    *\
    \  Initiation of decoder instance.\n    *---------------------------------------------------------------*/\n\
    \   short initDecode(                   /* (o) Number of decoded\n           \
    \                                   samples */\n       iLBC_Dec_Inst_t *iLBCdec_inst,\
    \  /* (i/o) Decoder instance */\n       int mode,                       /* (i)\
    \ frame size mode */\n       int use_enhancer                /* (i) 1 to use enhancer\n\
    \                                              0 to run without\n            \
    \                                    enhancer */\n   ){\n       int i;\n     \
    \  iLBCdec_inst->mode = mode;\n       if (mode==30) {\n           iLBCdec_inst->blockl\
    \ = BLOCKL_30MS;\n           iLBCdec_inst->nsub = NSUB_30MS;\n           iLBCdec_inst->nasub\
    \ = NASUB_30MS;\n           iLBCdec_inst->lpc_n = LPC_N_30MS;\n           iLBCdec_inst->no_of_bytes\
    \ = NO_OF_BYTES_30MS;\n           iLBCdec_inst->no_of_words = NO_OF_WORDS_30MS;\n\
    \           iLBCdec_inst->state_short_len=STATE_SHORT_LEN_30MS;\n           /*\
    \ ULP init */\n           iLBCdec_inst->ULP_inst=&ULP_30msTbl;\n       }\n   \
    \    else if (mode==20) {\n           iLBCdec_inst->blockl = BLOCKL_20MS;\n  \
    \         iLBCdec_inst->nsub = NSUB_20MS;\n           iLBCdec_inst->nasub = NASUB_20MS;\n\
    \           iLBCdec_inst->lpc_n = LPC_N_20MS;\n           iLBCdec_inst->no_of_bytes\
    \ = NO_OF_BYTES_20MS;\n           iLBCdec_inst->no_of_words = NO_OF_WORDS_20MS;\n\
    \           iLBCdec_inst->state_short_len=STATE_SHORT_LEN_20MS;\n           /*\
    \ ULP init */\n           iLBCdec_inst->ULP_inst=&ULP_20msTbl;\n       }\n   \
    \    else {\n           exit(2);\n       }\n       memset(iLBCdec_inst->syntMem,\
    \ 0,\n           LPC_FILTERORDER*sizeof(float));\n       memcpy((*iLBCdec_inst).lsfdeqold,\
    \ lsfmeanTbl,\n           LPC_FILTERORDER*sizeof(float));\n       memset(iLBCdec_inst->old_syntdenum,\
    \ 0,\n           ((LPC_FILTERORDER + 1)*NSUB_MAX)*sizeof(float));\n       for\
    \ (i=0; i<NSUB_MAX; i++)\n           iLBCdec_inst->old_syntdenum[i*(LPC_FILTERORDER+1)]=1.0;\n\
    \       iLBCdec_inst->last_lag = 20;\n       iLBCdec_inst->prevLag = 120;\n  \
    \     iLBCdec_inst->per = 0.0;\n       iLBCdec_inst->consPLICount = 0;\n     \
    \  iLBCdec_inst->prevPLI = 0;\n       iLBCdec_inst->prevLpc[0] = 1.0;\n      \
    \ memset(iLBCdec_inst->prevLpc+1,0,\n           LPC_FILTERORDER*sizeof(float));\n\
    \       memset(iLBCdec_inst->prevResidual, 0, BLOCKL_MAX*sizeof(float));\n   \
    \    iLBCdec_inst->seed=777;\n       memset(iLBCdec_inst->hpomem, 0, 4*sizeof(float));\n\
    \       iLBCdec_inst->use_enhancer = use_enhancer;\n       memset(iLBCdec_inst->enh_buf,\
    \ 0, ENH_BUFL*sizeof(float));\n       for (i=0;i<ENH_NBLOCKS_TOT;i++)\n      \
    \     iLBCdec_inst->enh_period[i]=(float)40.0;\n       iLBCdec_inst->prev_enh_pl\
    \ = 0;\n       return (iLBCdec_inst->blockl);\n   }\n   /*----------------------------------------------------------------*\n\
    \    *  frame residual decoder function (subrutine to iLBC_decode)\n    *---------------------------------------------------------------*/\n\
    \   void Decode(\n       iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) the decoder\
    \ state\n                                                structure */\n      \
    \ float *decresidual,             /* (o) decoded residual frame */\n       int\
    \ start,                      /* (i) location of start\n                     \
    \                         state */\n       int idxForMax,                  /*\
    \ (i) codebook index for the\n                                              maximum\
    \ value */\n       int *idxVec,                /* (i) codebook indexes for the\n\
    \                                              samples  in the start\n       \
    \                                       state */\n       float *syntdenum,   \
    \            /* (i) the decoded synthesis\n                                  \
    \            filter coefficients */\n       int *cb_index,                  /*\
    \ (i) the indexes for the\n                                              adaptive\
    \ codebook */\n       int *gain_index,            /* (i) the indexes for the\n\
    \                                              corresponding gains */\n      \
    \ int *extra_cb_index,        /* (i) the indexes for the\n                   \
    \                           adaptive codebook part\n                         \
    \                     of start state */\n       int *extra_gain_index,       \
    \   /* (i) the indexes for the\n                                             \
    \ corresponding gains */\n       int state_first                 /* (i) 1 if non\
    \ adaptive part\n                                              of start state\
    \ comes\n                                              first 0 if that part\n\
    \                                              comes last */\n   ){\n       float\
    \ reverseDecresidual[BLOCKL_MAX], mem[CB_MEML];\n       int k, meml_gotten, Nfor,\
    \ Nback, i;\n       int diff, start_pos;\n       int subcount, subframe;\n   \
    \    diff = STATE_LEN - iLBCdec_inst->state_short_len;\n       if (state_first\
    \ == 1) {\n           start_pos = (start-1)*SUBL;\n       } else {\n         \
    \  start_pos = (start-1)*SUBL + diff;\n       }\n       /* decode scalar part\
    \ of start state */\n       StateConstructW(idxForMax, idxVec,\n           &syntdenum[(start-1)*(LPC_FILTERORDER+1)],\n\
    \           &decresidual[start_pos], iLBCdec_inst->state_short_len);\n       if\
    \ (state_first) { /* put adaptive part in the end */\n           /* setup memory\
    \ */\n           memset(mem, 0,\n               (CB_MEML-iLBCdec_inst->state_short_len)*sizeof(float));\n\
    \           memcpy(mem+CB_MEML-iLBCdec_inst->state_short_len,\n              \
    \ decresidual+start_pos,\n               iLBCdec_inst->state_short_len*sizeof(float));\n\
    \           /* construct decoded vector */\n           iCBConstruct(\n       \
    \        &decresidual[start_pos+iLBCdec_inst->state_short_len],\n            \
    \   extra_cb_index, extra_gain_index, mem+CB_MEML-stMemLTbl,\n               stMemLTbl,\
    \ diff, CB_NSTAGES);\n       }\n       else {/* put adaptive part in the beginning\
    \ */\n           /* create reversed vectors for prediction */\n           for\
    \ (k=0; k<diff; k++) {\n               reverseDecresidual[k] =\n             \
    \      decresidual[(start+1)*SUBL-1-\n                           (k+iLBCdec_inst->state_short_len)];\n\
    \           }\n           /* setup memory */\n           meml_gotten = iLBCdec_inst->state_short_len;\n\
    \           for (k=0; k<meml_gotten; k++){\n               mem[CB_MEML-1-k] =\
    \ decresidual[start_pos + k];\n           }\n           memset(mem, 0, (CB_MEML-k)*sizeof(float));\n\
    \           /* construct decoded vector */\n           iCBConstruct(reverseDecresidual,\
    \ extra_cb_index,\n               extra_gain_index, mem+CB_MEML-stMemLTbl, stMemLTbl,\n\
    \               diff, CB_NSTAGES);\n           /* get decoded residual from reversed\
    \ vector */\n           for (k=0; k<diff; k++) {\n               decresidual[start_pos-1-k]\
    \ = reverseDecresidual[k];\n           }\n       }\n       /* counter for predicted\
    \ sub-frames */\n       subcount=0;\n       /* forward prediction of sub-frames\
    \ */\n       Nfor = iLBCdec_inst->nsub-start-1;\n       if ( Nfor > 0 ){\n   \
    \        /* setup memory */\n           memset(mem, 0, (CB_MEML-STATE_LEN)*sizeof(float));\n\
    \           memcpy(mem+CB_MEML-STATE_LEN, decresidual+(start-1)*SUBL,\n      \
    \         STATE_LEN*sizeof(float));\n           /* loop over sub-frames to encode\
    \ */\n           for (subframe=0; subframe<Nfor; subframe++) {\n             \
    \  /* construct decoded vector */\n               iCBConstruct(&decresidual[(start+1+subframe)*SUBL],\n\
    \                   cb_index+subcount*CB_NSTAGES,\n                   gain_index+subcount*CB_NSTAGES,\n\
    \                   mem+CB_MEML-memLfTbl[subcount],\n                   memLfTbl[subcount],\
    \ SUBL, CB_NSTAGES);\n               /* update memory */\n               memcpy(mem,\
    \ mem+SUBL, (CB_MEML-SUBL)*sizeof(float));\n               memcpy(mem+CB_MEML-SUBL,\n\
    \                   &decresidual[(start+1+subframe)*SUBL],\n                 \
    \  SUBL*sizeof(float));\n               subcount++;\n           }\n       }\n\
    \       /* backward prediction of sub-frames */\n       Nback = start-1;\n   \
    \    if ( Nback > 0 ) {\n           /* setup memory */\n           meml_gotten\
    \ = SUBL*(iLBCdec_inst->nsub+1-start);\n           if ( meml_gotten > CB_MEML\
    \ ) {\n               meml_gotten=CB_MEML;\n           }\n           for (k=0;\
    \ k<meml_gotten; k++) {\n               mem[CB_MEML-1-k] = decresidual[(start-1)*SUBL\
    \ + k];\n           }\n           memset(mem, 0, (CB_MEML-k)*sizeof(float));\n\
    \           /* loop over subframes to decode */\n           for (subframe=0; subframe<Nback;\
    \ subframe++) {\n               /* construct decoded vector */\n             \
    \  iCBConstruct(&reverseDecresidual[subframe*SUBL],\n                   cb_index+subcount*CB_NSTAGES,\n\
    \                   gain_index+subcount*CB_NSTAGES,\n                   mem+CB_MEML-memLfTbl[subcount],\
    \ memLfTbl[subcount],\n                   SUBL, CB_NSTAGES);\n               /*\
    \ update memory */\n               memcpy(mem, mem+SUBL, (CB_MEML-SUBL)*sizeof(float));\n\
    \               memcpy(mem+CB_MEML-SUBL,\n                   &reverseDecresidual[subframe*SUBL],\n\
    \                   SUBL*sizeof(float));\n               subcount++;\n       \
    \    }\n           /* get decoded residual from reversed vector */\n         \
    \  for (i=0; i<SUBL*Nback; i++)\n               decresidual[SUBL*Nback - i - 1]\
    \ =\n               reverseDecresidual[i];\n       }\n   }\n   /*----------------------------------------------------------------*\n\
    \    *  main decoder function\n    *---------------------------------------------------------------*/\n\
    \   void iLBC_decode(\n       float *decblock,            /* (o) decoded signal\
    \ block */\n       unsigned char *bytes,           /* (i) encoded signal bits\
    \ */\n       iLBC_Dec_Inst_t *iLBCdec_inst,  /* (i/o) the decoder state\n    \
    \                                            structure */\n       int mode   \
    \                 /* (i) 0: bad packet, PLC,\n                               \
    \               1: normal */\n   ){\n       float data[BLOCKL_MAX];\n       float\
    \ lsfdeq[LPC_FILTERORDER*LPC_N_MAX];\n       float PLCresidual[BLOCKL_MAX], PLClpc[LPC_FILTERORDER\
    \ + 1];\n       float zeros[BLOCKL_MAX], one[LPC_FILTERORDER + 1];\n       int\
    \ k, i, start, idxForMax, pos, lastpart, ulp;\n       int lag, ilag;\n       float\
    \ cc, maxcc;\n       int idxVec[STATE_LEN];\n       int check;\n       int gain_index[NASUB_MAX*CB_NSTAGES],\n\
    \           extra_gain_index[CB_NSTAGES];\n       int cb_index[CB_NSTAGES*NASUB_MAX],\
    \ extra_cb_index[CB_NSTAGES];\n       int lsf_i[LSF_NSPLIT*LPC_N_MAX];\n     \
    \  int state_first;\n       int last_bit;\n       unsigned char *pbytes;\n   \
    \    float weightdenum[(LPC_FILTERORDER + 1)*NSUB_MAX];\n       int order_plus_one;\n\
    \       float syntdenum[NSUB_MAX*(LPC_FILTERORDER+1)];\n       float decresidual[BLOCKL_MAX];\n\
    \       if (mode>0) { /* the data are good */\n           /* decode data */\n\
    \           pbytes=bytes;\n           pos=0;\n           /* Set everything to\
    \ zero before decoding */\n           for (k=0; k<LSF_NSPLIT*LPC_N_MAX; k++) {\n\
    \               lsf_i[k]=0;\n           }\n           start=0;\n           state_first=0;\n\
    \           idxForMax=0;\n           for (k=0; k<iLBCdec_inst->state_short_len;\
    \ k++) {\n               idxVec[k]=0;\n           }\n           for (k=0; k<CB_NSTAGES;\
    \ k++) {\n               extra_cb_index[k]=0;\n           }\n           for (k=0;\
    \ k<CB_NSTAGES; k++) {\n               extra_gain_index[k]=0;\n           }\n\
    \           for (i=0; i<iLBCdec_inst->nasub; i++) {\n               for (k=0;\
    \ k<CB_NSTAGES; k++) {\n                   cb_index[i*CB_NSTAGES+k]=0;\n     \
    \          }\n           }\n           for (i=0; i<iLBCdec_inst->nasub; i++) {\n\
    \               for (k=0; k<CB_NSTAGES; k++) {\n                   gain_index[i*CB_NSTAGES+k]=0;\n\
    \               }\n           }\n           /* loop over ULP classes */\n    \
    \       for (ulp=0; ulp<3; ulp++) {\n               /* LSF */\n              \
    \ for (k=0; k<LSF_NSPLIT*iLBCdec_inst->lpc_n; k++){\n                   unpack(\
    \ &pbytes, &lastpart,\n                       iLBCdec_inst->ULP_inst->lsf_bits[k][ulp],\
    \ &pos);\n                   packcombine(&lsf_i[k], lastpart,\n              \
    \         iLBCdec_inst->ULP_inst->lsf_bits[k][ulp]);\n               }\n     \
    \          /* Start block info */\n               unpack( &pbytes, &lastpart,\n\
    \                   iLBCdec_inst->ULP_inst->start_bits[ulp], &pos);\n        \
    \       packcombine(&start, lastpart,\n                   iLBCdec_inst->ULP_inst->start_bits[ulp]);\n\
    \               unpack( &pbytes, &lastpart,\n                   iLBCdec_inst->ULP_inst->startfirst_bits[ulp],\
    \ &pos);\n               packcombine(&state_first, lastpart,\n               \
    \    iLBCdec_inst->ULP_inst->startfirst_bits[ulp]);\n               unpack( &pbytes,\
    \ &lastpart,\n                   iLBCdec_inst->ULP_inst->scale_bits[ulp], &pos);\n\
    \               packcombine(&idxForMax, lastpart,\n                   iLBCdec_inst->ULP_inst->scale_bits[ulp]);\n\
    \               for (k=0; k<iLBCdec_inst->state_short_len; k++) {\n          \
    \         unpack( &pbytes, &lastpart,\n                       iLBCdec_inst->ULP_inst->state_bits[ulp],\
    \ &pos);\n                   packcombine(idxVec+k, lastpart,\n               \
    \        iLBCdec_inst->ULP_inst->state_bits[ulp]);\n               }\n       \
    \        /* 23/22 (20ms/30ms) sample block */\n               for (k=0; k<CB_NSTAGES;\
    \ k++) {\n                   unpack( &pbytes, &lastpart,\n                   \
    \    iLBCdec_inst->ULP_inst->extra_cb_index[k][ulp],\n                       &pos);\n\
    \                   packcombine(extra_cb_index+k, lastpart,\n                \
    \       iLBCdec_inst->ULP_inst->extra_cb_index[k][ulp]);\n               }\n \
    \              for (k=0; k<CB_NSTAGES; k++) {\n                   unpack( &pbytes,\
    \ &lastpart,\n                       iLBCdec_inst->ULP_inst->extra_cb_gain[k][ulp],\n\
    \                       &pos);\n                   packcombine(extra_gain_index+k,\
    \ lastpart,\n                       iLBCdec_inst->ULP_inst->extra_cb_gain[k][ulp]);\n\
    \               }\n               /* The two/four (20ms/30ms) 40 sample sub-blocks\
    \ */\n               for (i=0; i<iLBCdec_inst->nasub; i++) {\n               \
    \    for (k=0; k<CB_NSTAGES; k++) {\n                       unpack( &pbytes, &lastpart,\n\
    \                       iLBCdec_inst->ULP_inst->cb_index[i][k][ulp],\n       \
    \                    &pos);\n                       packcombine(cb_index+i*CB_NSTAGES+k,\
    \ lastpart,\n                       iLBCdec_inst->ULP_inst->cb_index[i][k][ulp]);\n\
    \                   }\n               }\n               for (i=0; i<iLBCdec_inst->nasub;\
    \ i++) {\n                   for (k=0; k<CB_NSTAGES; k++) {\n                \
    \       unpack( &pbytes, &lastpart,\n                       iLBCdec_inst->ULP_inst->cb_gain[i][k][ulp],\n\
    \                           &pos);\n                       packcombine(gain_index+i*CB_NSTAGES+k,\
    \ lastpart,\n                           iLBCdec_inst->ULP_inst->cb_gain[i][k][ulp]);\n\
    \                   }\n               }\n           }\n           /* Extract last\
    \ bit. If it is 1 this indicates an\n              empty/lost frame */\n     \
    \      unpack( &pbytes, &last_bit, 1, &pos);\n           /* Check for bit errors\
    \ or empty/lost frames */\n           if (start<1)\n               mode = 0;\n\
    \           if (iLBCdec_inst->mode==20 && start>3)\n               mode = 0;\n\
    \           if (iLBCdec_inst->mode==30 && start>5)\n               mode = 0;\n\
    \           if (last_bit==1)\n               mode = 0;\n           if (mode==1)\
    \ { /* No bit errors was detected,\n                             continue decoding\
    \ */\n               /* adjust index */\n               index_conv_dec(cb_index);\n\
    \               /* decode the lsf */\n               SimplelsfDEQ(lsfdeq, lsf_i,\
    \ iLBCdec_inst->lpc_n);\n               check=LSF_check(lsfdeq, LPC_FILTERORDER,\n\
    \                   iLBCdec_inst->lpc_n);\n               DecoderInterpolateLSF(syntdenum,\
    \ weightdenum,\n                   lsfdeq, LPC_FILTERORDER, iLBCdec_inst);\n \
    \              Decode(iLBCdec_inst, decresidual, start, idxForMax,\n         \
    \          idxVec, syntdenum, cb_index, gain_index,\n                   extra_cb_index,\
    \ extra_gain_index,\n                   state_first);\n               /* preparing\
    \ the plc for a future loss! */\n               doThePLC(PLCresidual, PLClpc,\
    \ 0, decresidual,\n                   syntdenum +\n                   (LPC_FILTERORDER\
    \ + 1)*(iLBCdec_inst->nsub - 1),\n                   (*iLBCdec_inst).last_lag,\
    \ iLBCdec_inst);\n               memcpy(decresidual, PLCresidual,\n          \
    \         iLBCdec_inst->blockl*sizeof(float));\n           }\n       }\n     \
    \  if (mode == 0) {\n           /* the data is bad (either a PLC call\n      \
    \      * was made or a severe bit error was detected)\n            */\n      \
    \     /* packet loss conceal */\n           memset(zeros, 0, BLOCKL_MAX*sizeof(float));\n\
    \           one[0] = 1;\n           memset(one+1, 0, LPC_FILTERORDER*sizeof(float));\n\
    \           start=0;\n           doThePLC(PLCresidual, PLClpc, 1, zeros, one,\n\
    \               (*iLBCdec_inst).last_lag, iLBCdec_inst);\n           memcpy(decresidual,\
    \ PLCresidual,\n               iLBCdec_inst->blockl*sizeof(float));\n        \
    \   order_plus_one = LPC_FILTERORDER + 1;\n           for (i = 0; i < iLBCdec_inst->nsub;\
    \ i++) {\n               memcpy(syntdenum+(i*order_plus_one), PLClpc,\n      \
    \             order_plus_one*sizeof(float));\n           }\n       }\n       if\
    \ (iLBCdec_inst->use_enhancer == 1) {\n           /* post filtering */\n     \
    \      iLBCdec_inst->last_lag =\n               enhancerInterface(data, decresidual,\
    \ iLBCdec_inst);\n           /* synthesis filtering */\n           if (iLBCdec_inst->mode==20)\
    \ {\n               /* Enhancer has 40 samples delay */\n               i=0;\n\
    \               syntFilter(data + i*SUBL,\n                   iLBCdec_inst->old_syntdenum\
    \ +\n                   (i+iLBCdec_inst->nsub-1)*(LPC_FILTERORDER+1),\n      \
    \             SUBL, iLBCdec_inst->syntMem);\n               for (i=1; i < iLBCdec_inst->nsub;\
    \ i++) {\n                   syntFilter(data + i*SUBL,\n                     \
    \  syntdenum + (i-1)*(LPC_FILTERORDER+1),\n                       SUBL, iLBCdec_inst->syntMem);\n\
    \               }\n           } else if (iLBCdec_inst->mode==30) {\n         \
    \      /* Enhancer has 80 samples delay */\n               for (i=0; i < 2; i++)\
    \ {\n                   syntFilter(data + i*SUBL,\n                       iLBCdec_inst->old_syntdenum\
    \ +\n                       (i+iLBCdec_inst->nsub-2)*(LPC_FILTERORDER+1),\n  \
    \                     SUBL, iLBCdec_inst->syntMem);\n               }\n      \
    \         for (i=2; i < iLBCdec_inst->nsub; i++) {\n                   syntFilter(data\
    \ + i*SUBL,\n                       syntdenum + (i-2)*(LPC_FILTERORDER+1), SUBL,\n\
    \                       iLBCdec_inst->syntMem);\n               }\n          \
    \ }\n       } else {\n           /* Find last lag */\n           lag = 20;\n \
    \          maxcc = xCorrCoef(&decresidual[BLOCKL_MAX-ENH_BLOCKL],\n          \
    \     &decresidual[BLOCKL_MAX-ENH_BLOCKL-lag], ENH_BLOCKL);\n           for (ilag=21;\
    \ ilag<120; ilag++) {\n               cc = xCorrCoef(&decresidual[BLOCKL_MAX-ENH_BLOCKL],\n\
    \                   &decresidual[BLOCKL_MAX-ENH_BLOCKL-ilag],\n              \
    \     ENH_BLOCKL);\n               if (cc > maxcc) {\n                   maxcc\
    \ = cc;\n                   lag = ilag;\n               }\n           }\n    \
    \       iLBCdec_inst->last_lag = lag;\n           /* copy data and run synthesis\
    \ filter */\n           memcpy(data, decresidual,\n               iLBCdec_inst->blockl*sizeof(float));\n\
    \           for (i=0; i < iLBCdec_inst->nsub; i++) {\n               syntFilter(data\
    \ + i*SUBL,\n                   syntdenum + i*(LPC_FILTERORDER+1), SUBL,\n   \
    \                iLBCdec_inst->syntMem);\n           }\n       }\n       /* high\
    \ pass filtering on output if desired, otherwise\n          copy to out */\n \
    \      hpOutput(data, iLBCdec_inst->blockl,\n                   decblock,iLBCdec_inst->hpomem);\n\
    \       /* memcpy(decblock,data,iLBCdec_inst->blockl*sizeof(float));*/\n     \
    \  memcpy(iLBCdec_inst->old_syntdenum, syntdenum,\n           iLBCdec_inst->nsub*(LPC_FILTERORDER+1)*sizeof(float));\n\
    \       iLBCdec_inst->prev_enh_pl=0;\n       if (mode==0) { /* PLC was used */\n\
    \           iLBCdec_inst->prev_enh_pl=1;\n       }\n   }\n"
- title: A.6.  iLBC_define.h
  contents:
  - "A.6.  iLBC_define.h\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       iLBC_define.h\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #include <string.h>\n   #ifndef __iLBC_ILBCDEFINE_H\n   #define __iLBC_ILBCDEFINE_H\n\
    \   /* general codec settings */\n   #define FS                      (float)8000.0\n\
    \   #define BLOCKL_20MS             160\n   #define BLOCKL_30MS             240\n\
    \   #define BLOCKL_MAX              240\n   #define NSUB_20MS               4\n\
    \   #define NSUB_30MS               6\n   #define NSUB_MAX            6\n   #define\
    \ NASUB_20MS              2\n   #define NASUB_30MS              4\n   #define\
    \ NASUB_MAX               4\n   #define SUBL                40\n   #define STATE_LEN\
    \               80\n   #define STATE_SHORT_LEN_30MS    58\n   #define STATE_SHORT_LEN_20MS\
    \    57\n   /* LPC settings */\n   #define LPC_FILTERORDER         10\n   #define\
    \ LPC_CHIRP_SYNTDENUM     (float)0.9025\n   #define LPC_CHIRP_WEIGHTDENUM   (float)0.4222\n\
    \   #define LPC_LOOKBACK        60\n   #define LPC_N_20MS              1\n   #define\
    \ LPC_N_30MS              2\n   #define LPC_N_MAX               2\n   #define\
    \ LPC_ASYMDIFF        20\n   #define LPC_BW                  (float)60.0\n   #define\
    \ LPC_WN                  (float)1.0001\n   #define LSF_NSPLIT              3\n\
    \   #define LSF_NUMBER_OF_STEPS     4\n   #define LPC_HALFORDER           (LPC_FILTERORDER/2)\n\
    \   /* cb settings */\n   #define CB_NSTAGES              3\n   #define CB_EXPAND\
    \               2\n   #define CB_MEML                 147\n   #define CB_FILTERLEN\
    \        2*4\n   #define CB_HALFFILTERLEN    4\n   #define CB_RESRANGE       \
    \      34\n   #define CB_MAXGAIN              (float)1.3\n   /* enhancer */\n\
    \   #define ENH_BLOCKL              80  /* block length */\n   #define ENH_BLOCKL_HALF\
    \         (ENH_BLOCKL/2)\n   #define ENH_HL                  3   /* 2*ENH_HL+1\
    \ is number blocks\n                                          in said second sequence\
    \ */\n   #define ENH_SLOP            2   /* max difference estimated and\n   \
    \                                       correct pitch period */\n   #define ENH_PLOCSL\
    \              20  /* pitch-estimates and pitch-\n                           \
    \               locations buffer length */\n   #define ENH_OVERHANG        2\n\
    \   #define ENH_UPS0            4   /* upsampling rate */\n   #define ENH_FL0\
    \                 3   /* 2*FLO+1 is the length of\n                          \
    \                each filter */\n   #define ENH_VECTL               (ENH_BLOCKL+2*ENH_FL0)\n\
    \   #define ENH_CORRDIM             (2*ENH_SLOP+1)\n   #define ENH_NBLOCKS   \
    \          (BLOCKL_MAX/ENH_BLOCKL)\n   #define ENH_NBLOCKS_EXTRA       5\n   #define\
    \ ENH_NBLOCKS_TOT         8   /* ENH_NBLOCKS +\n                             \
    \             ENH_NBLOCKS_EXTRA */\n   #define ENH_BUFL            (ENH_NBLOCKS_TOT)*ENH_BLOCKL\n\
    \   #define ENH_ALPHA0              (float)0.05\n   /* Down sampling */\n   #define\
    \ FILTERORDER_DS          7\n   #define DELAY_DS            3\n   #define FACTOR_DS\
    \               2\n   /* bit stream defs */\n   #define NO_OF_BYTES_20MS    38\n\
    \   #define NO_OF_BYTES_30MS    50\n   #define NO_OF_WORDS_20MS    19\n   #define\
    \ NO_OF_WORDS_30MS    25\n   #define STATE_BITS              3\n   #define BYTE_LEN\
    \            8\n   #define ULP_CLASSES             3\n   /* help parameters */\n\
    \   #define FLOAT_MAX               (float)1.0e37\n   #define EPS            \
    \         (float)2.220446049250313e-016\n   #define PI                      (float)3.14159265358979323846\n\
    \   #define MIN_SAMPLE              -32768\n   #define MAX_SAMPLE            \
    \  32767\n   #define TWO_PI                  (float)6.283185307\n   #define PI2\
    \                     (float)0.159154943\n   /* type definition encoder instance\
    \ */\n   typedef struct iLBC_ULP_Inst_t_ {\n       int lsf_bits[6][ULP_CLASSES+2];\n\
    \       int start_bits[ULP_CLASSES+2];\n       int startfirst_bits[ULP_CLASSES+2];\n\
    \       int scale_bits[ULP_CLASSES+2];\n       int state_bits[ULP_CLASSES+2];\n\
    \       int extra_cb_index[CB_NSTAGES][ULP_CLASSES+2];\n       int extra_cb_gain[CB_NSTAGES][ULP_CLASSES+2];\n\
    \       int cb_index[NSUB_MAX][CB_NSTAGES][ULP_CLASSES+2];\n       int cb_gain[NSUB_MAX][CB_NSTAGES][ULP_CLASSES+2];\n\
    \   } iLBC_ULP_Inst_t;\n   /* type definition encoder instance */\n   typedef\
    \ struct iLBC_Enc_Inst_t_ {\n       /* flag for frame size mode */\n       int\
    \ mode;\n       /* basic parameters for different frame sizes */\n       int blockl;\n\
    \       int nsub;\n       int nasub;\n       int no_of_bytes, no_of_words;\n \
    \      int lpc_n;\n       int state_short_len;\n       const iLBC_ULP_Inst_t *ULP_inst;\n\
    \       /* analysis filter state */\n       float anaMem[LPC_FILTERORDER];\n \
    \      /* old lsf parameters for interpolation */\n       float lsfold[LPC_FILTERORDER];\n\
    \       float lsfdeqold[LPC_FILTERORDER];\n       /* signal buffer for LP analysis\
    \ */\n       float lpc_buffer[LPC_LOOKBACK + BLOCKL_MAX];\n       /* state of\
    \ input HP filter */\n       float hpimem[4];\n   } iLBC_Enc_Inst_t;\n   /* type\
    \ definition decoder instance */\n   typedef struct iLBC_Dec_Inst_t_ {\n     \
    \  /* flag for frame size mode */\n       int mode;\n       /* basic parameters\
    \ for different frame sizes */\n       int blockl;\n       int nsub;\n       int\
    \ nasub;\n       int no_of_bytes, no_of_words;\n       int lpc_n;\n       int\
    \ state_short_len;\n       const iLBC_ULP_Inst_t *ULP_inst;\n       /* synthesis\
    \ filter state */\n       float syntMem[LPC_FILTERORDER];\n       /* old LSF for\
    \ interpolation */\n       float lsfdeqold[LPC_FILTERORDER];\n       /* pitch\
    \ lag estimated in enhancer and used in PLC */\n       int last_lag;\n       /*\
    \ PLC state information */\n       int prevLag, consPLICount, prevPLI, prev_enh_pl;\n\
    \       float prevLpc[LPC_FILTERORDER+1];\n       float prevResidual[NSUB_MAX*SUBL];\n\
    \       float per;\n       unsigned long seed;\n       /* previous synthesis filter\
    \ parameters */\n       float old_syntdenum[(LPC_FILTERORDER + 1)*NSUB_MAX];\n\
    \       /* state of output HP filter */\n       float hpomem[4];\n       /* enhancer\
    \ state information */\n       int use_enhancer;\n       float enh_buf[ENH_BUFL];\n\
    \       float enh_period[ENH_NBLOCKS_TOT];\n   } iLBC_Dec_Inst_t;\n   #endif\n"
- title: A.7.  constants.h
  contents:
  - "A.7.  constants.h\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       constants.h\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #ifndef __iLBC_CONSTANTS_H\n   #define __iLBC_CONSTANTS_H\n   #include \"\
    iLBC_define.h\"\n   /* ULP bit allocation */\n   extern const iLBC_ULP_Inst_t\
    \ ULP_20msTbl;\n   extern const iLBC_ULP_Inst_t ULP_30msTbl;\n   /* high pass\
    \ filters */\n   extern float hpi_zero_coefsTbl[];\n   extern float hpi_pole_coefsTbl[];\n\
    \   extern float hpo_zero_coefsTbl[];\n   extern float hpo_pole_coefsTbl[];\n\
    \   /* low pass filters */\n   extern float lpFilt_coefsTbl[];\n   /* LPC analysis\
    \ and quantization */\n   extern float lpc_winTbl[];\n   extern float lpc_asymwinTbl[];\n\
    \   extern float lpc_lagwinTbl[];\n   extern float lsfCbTbl[];\n   extern float\
    \ lsfmeanTbl[];\n   extern int   dim_lsfCbTbl[];\n   extern int   size_lsfCbTbl[];\n\
    \   extern float lsf_weightTbl_30ms[];\n   extern float lsf_weightTbl_20ms[];\n\
    \   /* state quantization tables */\n   extern float state_sq3Tbl[];\n   extern\
    \ float state_frgqTbl[];\n   /* gain quantization tables */\n   extern float gain_sq3Tbl[];\n\
    \   extern float gain_sq4Tbl[];\n   extern float gain_sq5Tbl[];\n   /* adaptive\
    \ codebook definitions */\n   extern int search_rangeTbl[5][CB_NSTAGES];\n   extern\
    \ int memLfTbl[];\n   extern int stMemLTbl;\n   extern float cbfiltersTbl[CB_FILTERLEN];\n\
    \   /* enhancer definitions */\n   extern float polyphaserTbl[];\n   extern float\
    \ enh_plocsTbl[];\n   #endif\n"
- title: A.8.  constants.c
  contents:
  - "A.8.  constants.c\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       constants.c\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #include \"iLBC_define.h\"\n   /* ULP bit allocation */\n       /* 20 ms frame\
    \ */\n   const iLBC_ULP_Inst_t ULP_20msTbl = {\n       /* LSF */\n       {   {6,0,0,0,0},\
    \ {7,0,0,0,0}, {7,0,0,0,0},\n           {0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}},\n\
    \       /* Start state location, gain and samples */\n       {2,0,0,0,0},\n  \
    \     {1,0,0,0,0},\n       {6,0,0,0,0},\n       {0,1,2,0,0},\n       /* extra\
    \ CB index and extra CB gain */\n       {{6,0,1,0,0}, {0,0,7,0,0}, {0,0,7,0,0}},\n\
    \       {{2,0,3,0,0}, {1,1,2,0,0}, {0,0,3,0,0}},\n       /* CB index and CB gain\
    \ */\n       {   {{7,0,1,0,0}, {0,0,7,0,0}, {0,0,7,0,0}},\n           {{0,0,8,0,0},\
    \ {0,0,8,0,0}, {0,0,8,0,0}},\n           {{0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}},\n\
    \           {{0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}}},\n       {   {{1,2,2,0,0},\
    \ {1,1,2,0,0}, {0,0,3,0,0}},\n           {{1,1,3,0,0}, {0,2,2,0,0}, {0,0,3,0,0}},\n\
    \           {{0,0,0,0,0}, {0,0,0,0,0}, {0,0,0,0,0}},\n           {{0,0,0,0,0},\
    \ {0,0,0,0,0}, {0,0,0,0,0}}}\n   };\n       /* 30 ms frame */\n   const iLBC_ULP_Inst_t\
    \ ULP_30msTbl = {\n       /* LSF */\n       {   {6,0,0,0,0}, {7,0,0,0,0}, {7,0,0,0,0},\n\
    \           {6,0,0,0,0}, {7,0,0,0,0}, {7,0,0,0,0}},\n       /* Start state location,\
    \ gain and samples */\n       {3,0,0,0,0},\n       {1,0,0,0,0},\n       {6,0,0,0,0},\n\
    \       {0,1,2,0,0},\n       /* extra CB index and extra CB gain */\n       {{4,2,1,0,0},\
    \ {0,0,7,0,0}, {0,0,7,0,0}},\n       {{1,1,3,0,0}, {1,1,2,0,0}, {0,0,3,0,0}},\n\
    \       /* CB index and CB gain */\n       {   {{6,1,1,0,0}, {0,0,7,0,0}, {0,0,7,0,0}},\n\
    \           {{0,7,1,0,0}, {0,0,8,0,0}, {0,0,8,0,0}},\n           {{0,7,1,0,0},\
    \ {0,0,8,0,0}, {0,0,8,0,0}},\n           {{0,7,1,0,0}, {0,0,8,0,0}, {0,0,8,0,0}}},\n\
    \       {   {{1,2,2,0,0}, {1,2,1,0,0}, {0,0,3,0,0}},\n           {{0,2,3,0,0},\
    \ {0,2,2,0,0}, {0,0,3,0,0}},\n           {{0,1,4,0,0}, {0,1,3,0,0}, {0,0,3,0,0}},\n\
    \           {{0,1,4,0,0}, {0,1,3,0,0}, {0,0,3,0,0}}}\n   };\n   /* HP Filters\
    \ */\n   float hpi_zero_coefsTbl[3] = {\n       (float)0.92727436, (float)-1.8544941,\
    \ (float)0.92727436\n   };\n   float hpi_pole_coefsTbl[3] = {\n       (float)1.0,\
    \ (float)-1.9059465, (float)0.9114024\n   };\n   float hpo_zero_coefsTbl[3] =\
    \ {\n       (float)0.93980581, (float)-1.8795834, (float)0.93980581\n   };\n \
    \  float hpo_pole_coefsTbl[3] = {\n       (float)1.0, (float)-1.9330735, (float)0.93589199\n\
    \   };\n   /* LP Filter */\n   float lpFilt_coefsTbl[FILTERORDER_DS]={\n     \
    \  (float)-0.066650, (float)0.125000, (float)0.316650,\n       (float)0.414063,\
    \ (float)0.316650,\n       (float)0.125000, (float)-0.066650\n   };\n   /* State\
    \ quantization tables */\n   float state_sq3Tbl[8] = {\n       (float)-3.719849,\
    \ (float)-2.177490, (float)-1.130005,\n       (float)-0.309692, (float)0.444214,\
    \ (float)1.329712,\n       (float)2.436279, (float)3.983887\n   };\n   float state_frgqTbl[64]\
    \ = {\n       (float)1.000085, (float)1.071695, (float)1.140395,\n       (float)1.206868,\
    \ (float)1.277188, (float)1.351503,\n       (float)1.429380, (float)1.500727,\
    \ (float)1.569049,\n       (float)1.639599, (float)1.707071, (float)1.781531,\n\
    \       (float)1.840799, (float)1.901550, (float)1.956695,\n       (float)2.006750,\
    \ (float)2.055474, (float)2.102787,\n       (float)2.142819, (float)2.183592,\
    \ (float)2.217962,\n       (float)2.257177, (float)2.295739, (float)2.332967,\n\
    \       (float)2.369248, (float)2.402792, (float)2.435080,\n       (float)2.468598,\
    \ (float)2.503394, (float)2.539284,\n       (float)2.572944, (float)2.605036,\
    \ (float)2.636331,\n       (float)2.668939, (float)2.698780, (float)2.729101,\n\
    \       (float)2.759786, (float)2.789834, (float)2.818679,\n       (float)2.848074,\
    \ (float)2.877470, (float)2.906899,\n       (float)2.936655, (float)2.967804,\
    \ (float)3.000115,\n       (float)3.033367, (float)3.066355, (float)3.104231,\n\
    \       (float)3.141499, (float)3.183012, (float)3.222952,\n       (float)3.265433,\
    \ (float)3.308441, (float)3.350823,\n       (float)3.395275, (float)3.442793,\
    \ (float)3.490801,\n       (float)3.542514, (float)3.604064, (float)3.666050,\n\
    \       (float)3.740994, (float)3.830749, (float)3.938770,\n       (float)4.101764\n\
    \   };\n   /* CB tables */\n   int search_rangeTbl[5][CB_NSTAGES]={{58,58,58},\
    \ {108,44,44},\n               {108,108,108}, {108,108,108}, {108,108,108}};\n\
    \   int stMemLTbl=85;\n   int memLfTbl[NASUB_MAX]={147,147,147,147};\n   /* expansion\
    \ filter(s) */\n   float cbfiltersTbl[CB_FILTERLEN]={\n       (float)-0.034180,\
    \ (float)0.108887, (float)-0.184326,\n       (float)0.806152,  (float)0.713379,\
    \ (float)-0.144043,\n       (float)0.083740,  (float)-0.033691\n   };\n   /* Gain\
    \ Quantization */\n   float gain_sq3Tbl[8]={\n       (float)-1.000000,  (float)-0.659973,\
    \  (float)-0.330017,\n       (float)0.000000, (float)0.250000, (float)0.500000,\n\
    \       (float)0.750000, (float)1.00000};\n   float gain_sq4Tbl[16]={\n      \
    \ (float)-1.049988, (float)-0.900024, (float)-0.750000,\n       (float)-0.599976,\
    \ (float)-0.450012, (float)-0.299988,\n       (float)-0.150024, (float)0.000000,\
    \ (float)0.150024,\n       (float)0.299988, (float)0.450012, (float)0.599976,\n\
    \       (float)0.750000, (float)0.900024, (float)1.049988,\n       (float)1.200012};\n\
    \   float gain_sq5Tbl[32]={\n       (float)0.037476, (float)0.075012, (float)0.112488,\n\
    \       (float)0.150024, (float)0.187500, (float)0.224976,\n       (float)0.262512,\
    \ (float)0.299988, (float)0.337524,\n       (float)0.375000, (float)0.412476,\
    \ (float)0.450012,\n       (float)0.487488, (float)0.525024, (float)0.562500,\n\
    \       (float)0.599976, (float)0.637512, (float)0.674988,\n       (float)0.712524,\
    \ (float)0.750000, (float)0.787476,\n       (float)0.825012, (float)0.862488,\
    \ (float)0.900024,\n       (float)0.937500, (float)0.974976, (float)1.012512,\n\
    \       (float)1.049988, (float)1.087524, (float)1.125000,\n       (float)1.162476,\
    \ (float)1.200012};\n   /* Enhancer - Upsamling a factor 4 (ENH_UPS0 = 4) */\n\
    \   float polyphaserTbl[ENH_UPS0*(2*ENH_FL0+1)]={\n       (float)0.000000, (float)0.000000,\
    \ (float)0.000000,\n   (float)1.000000,\n           (float)0.000000, (float)0.000000,\
    \ (float)0.000000,\n       (float)0.015625, (float)-0.076904, (float)0.288330,\n\
    \   (float)0.862061,\n           (float)-0.106445, (float)0.018799, (float)-0.015625,\n\
    \       (float)0.023682, (float)-0.124268, (float)0.601563,\n   (float)0.601563,\n\
    \           (float)-0.124268, (float)0.023682, (float)-0.023682,\n       (float)0.018799,\
    \ (float)-0.106445, (float)0.862061,\n   (float)0.288330,\n           (float)-0.076904,\
    \ (float)0.015625, (float)-0.018799};\n   float enh_plocsTbl[ENH_NBLOCKS_TOT]\
    \ = {(float)40.0, (float)120.0,\n               (float)200.0, (float)280.0, (float)360.0,\n\
    \               (float)440.0, (float)520.0, (float)600.0};\n   /* LPC analysis\
    \ and quantization */\n   int dim_lsfCbTbl[LSF_NSPLIT] = {3, 3, 4};\n   int size_lsfCbTbl[LSF_NSPLIT]\
    \ = {64,128,128};\n   float lsfmeanTbl[LPC_FILTERORDER] = {\n       (float)0.281738,\
    \ (float)0.445801, (float)0.663330,\n       (float)0.962524, (float)1.251831,\
    \ (float)1.533081,\n       (float)1.850586, (float)2.137817, (float)2.481445,\n\
    \       (float)2.777344};\n   float lsf_weightTbl_30ms[6] = {(float)(1.0/2.0),\
    \ (float)1.0,\n   (float)(2.0/3.0),\n       (float)(1.0/3.0), (float)0.0, (float)0.0};\n\
    \   float lsf_weightTbl_20ms[4] = {(float)(3.0/4.0), (float)(2.0/4.0),\n     \
    \  (float)(1.0/4.0), (float)(0.0)};\n   /* Hanning LPC window */\n   float lpc_winTbl[BLOCKL_MAX]={\n\
    \       (float)0.000183, (float)0.000671, (float)0.001526,\n       (float)0.002716,\
    \ (float)0.004242, (float)0.006104,\n       (float)0.008301, (float)0.010834,\
    \ (float)0.013702,\n       (float)0.016907, (float)0.020416, (float)0.024261,\n\
    \       (float)0.028442, (float)0.032928, (float)0.037750,\n       (float)0.042877,\
    \ (float)0.048309, (float)0.054047,\n       (float)0.060089, (float)0.066437,\
    \ (float)0.073090,\n       (float)0.080017, (float)0.087219, (float)0.094727,\n\
    \       (float)0.102509, (float)0.110535, (float)0.118835,\n       (float)0.127411,\
    \ (float)0.136230, (float)0.145294,\n       (float)0.154602, (float)0.164154,\
    \ (float)0.173920,\n       (float)0.183899, (float)0.194122, (float)0.204529,\n\
    \       (float)0.215149, (float)0.225952, (float)0.236938,\n       (float)0.248108,\
    \ (float)0.259460, (float)0.270966,\n       (float)0.282654, (float)0.294464,\
    \ (float)0.306396,\n       (float)0.318481, (float)0.330688, (float)0.343018,\n\
    \       (float)0.355438, (float)0.367981, (float)0.380585,\n       (float)0.393280,\
    \ (float)0.406067, (float)0.418884,\n       (float)0.431763, (float)0.444702,\
    \ (float)0.457672,\n       (float)0.470673, (float)0.483704, (float)0.496735,\n\
    \       (float)0.509766, (float)0.522797, (float)0.535828,\n       (float)0.548798,\
    \ (float)0.561768, (float)0.574677,\n       (float)0.587524, (float)0.600342,\
    \ (float)0.613068,\n       (float)0.625732, (float)0.638306, (float)0.650787,\n\
    \       (float)0.663147, (float)0.675415, (float)0.687561,\n       (float)0.699585,\
    \ (float)0.711487, (float)0.723206,\n       (float)0.734802, (float)0.746216,\
    \ (float)0.757477,\n       (float)0.768585, (float)0.779480, (float)0.790192,\n\
    \       (float)0.800720, (float)0.811005, (float)0.821106,\n       (float)0.830994,\
    \ (float)0.840668, (float)0.850067,\n       (float)0.859253, (float)0.868225,\
    \ (float)0.876892,\n       (float)0.885345, (float)0.893524, (float)0.901428,\n\
    \       (float)0.909058, (float)0.916412, (float)0.923492,\n       (float)0.930267,\
    \ (float)0.936768, (float)0.942963,\n       (float)0.948853, (float)0.954437,\
    \ (float)0.959717,\n       (float)0.964691, (float)0.969360, (float)0.973694,\n\
    \       (float)0.977692, (float)0.981384, (float)0.984741,\n       (float)0.987762,\
    \ (float)0.990479, (float)0.992828,\n       (float)0.994873, (float)0.996552,\
    \ (float)0.997925,\n       (float)0.998932, (float)0.999603, (float)0.999969,\n\
    \       (float)0.999969, (float)0.999603, (float)0.998932,\n       (float)0.997925,\
    \ (float)0.996552, (float)0.994873,\n       (float)0.992828, (float)0.990479,\
    \ (float)0.987762,\n       (float)0.984741, (float)0.981384, (float)0.977692,\n\
    \       (float)0.973694, (float)0.969360, (float)0.964691,\n       (float)0.959717,\
    \ (float)0.954437, (float)0.948853,\n       (float)0.942963, (float)0.936768,\
    \ (float)0.930267,\n       (float)0.923492, (float)0.916412, (float)0.909058,\n\
    \       (float)0.901428, (float)0.893524, (float)0.885345,\n       (float)0.876892,\
    \ (float)0.868225, (float)0.859253,\n       (float)0.850067, (float)0.840668,\
    \ (float)0.830994,\n       (float)0.821106, (float)0.811005, (float)0.800720,\n\
    \       (float)0.790192, (float)0.779480, (float)0.768585,\n       (float)0.757477,\
    \ (float)0.746216, (float)0.734802,\n       (float)0.723206, (float)0.711487,\
    \ (float)0.699585,\n       (float)0.687561, (float)0.675415, (float)0.663147,\n\
    \       (float)0.650787, (float)0.638306, (float)0.625732,\n       (float)0.613068,\
    \ (float)0.600342, (float)0.587524,\n       (float)0.574677, (float)0.561768,\
    \ (float)0.548798,\n       (float)0.535828, (float)0.522797, (float)0.509766,\n\
    \       (float)0.496735, (float)0.483704, (float)0.470673,\n       (float)0.457672,\
    \ (float)0.444702, (float)0.431763,\n       (float)0.418884, (float)0.406067,\
    \ (float)0.393280,\n       (float)0.380585, (float)0.367981, (float)0.355438,\n\
    \       (float)0.343018, (float)0.330688, (float)0.318481,\n       (float)0.306396,\
    \ (float)0.294464, (float)0.282654,\n       (float)0.270966, (float)0.259460,\
    \ (float)0.248108,\n       (float)0.236938, (float)0.225952, (float)0.215149,\n\
    \       (float)0.204529, (float)0.194122, (float)0.183899,\n       (float)0.173920,\
    \ (float)0.164154, (float)0.154602,\n       (float)0.145294, (float)0.136230,\
    \ (float)0.127411,\n       (float)0.118835, (float)0.110535, (float)0.102509,\n\
    \       (float)0.094727, (float)0.087219, (float)0.080017,\n       (float)0.073090,\
    \ (float)0.066437, (float)0.060089,\n       (float)0.054047, (float)0.048309,\
    \ (float)0.042877,\n       (float)0.037750, (float)0.032928, (float)0.028442,\n\
    \       (float)0.024261, (float)0.020416, (float)0.016907,\n       (float)0.013702,\
    \ (float)0.010834, (float)0.008301,\n       (float)0.006104, (float)0.004242,\
    \ (float)0.002716,\n       (float)0.001526, (float)0.000671, (float)0.000183\n\
    \   };\n   /* Asymmetric LPC window */\n   float lpc_asymwinTbl[BLOCKL_MAX]={\n\
    \       (float)0.000061, (float)0.000214, (float)0.000458,\n       (float)0.000824,\
    \ (float)0.001282, (float)0.001831,\n       (float)0.002472, (float)0.003235,\
    \ (float)0.004120,\n       (float)0.005066, (float)0.006134, (float)0.007294,\n\
    \       (float)0.008545, (float)0.009918, (float)0.011383,\n       (float)0.012939,\
    \ (float)0.014587, (float)0.016357,\n       (float)0.018219, (float)0.020172,\
    \ (float)0.022217,\n       (float)0.024353, (float)0.026611, (float)0.028961,\n\
    \       (float)0.031372, (float)0.033905, (float)0.036530,\n       (float)0.039276,\
    \ (float)0.042084, (float)0.044983,\n       (float)0.047974, (float)0.051086,\
    \ (float)0.054260,\n       (float)0.057526, (float)0.060883, (float)0.064331,\n\
    \       (float)0.067871, (float)0.071503, (float)0.075226,\n       (float)0.079010,\
    \ (float)0.082916, (float)0.086884,\n       (float)0.090942, (float)0.095062,\
    \ (float)0.099304,\n       (float)0.103607, (float)0.107971, (float)0.112427,\n\
    \       (float)0.116974, (float)0.121582, (float)0.126282,\n       (float)0.131073,\
    \ (float)0.135895, (float)0.140839,\n       (float)0.145813, (float)0.150879,\
    \ (float)0.156006,\n       (float)0.161224, (float)0.166504, (float)0.171844,\n\
    \       (float)0.177246, (float)0.182709, (float)0.188263,\n       (float)0.193848,\
    \ (float)0.199524, (float)0.205231,\n       (float)0.211029, (float)0.216858,\
    \ (float)0.222778,\n       (float)0.228729, (float)0.234741, (float)0.240814,\n\
    \       (float)0.246918, (float)0.253082, (float)0.259308,\n       (float)0.265564,\
    \ (float)0.271881, (float)0.278259,\n       (float)0.284668, (float)0.291107,\
    \ (float)0.297607,\n       (float)0.304138, (float)0.310730, (float)0.317322,\n\
    \       (float)0.323975, (float)0.330658, (float)0.337372,\n       (float)0.344147,\
    \ (float)0.350922, (float)0.357727,\n       (float)0.364594, (float)0.371460,\
    \ (float)0.378357,\n       (float)0.385284, (float)0.392212, (float)0.399170,\n\
    \       (float)0.406158, (float)0.413177, (float)0.420197,\n       (float)0.427246,\
    \ (float)0.434296, (float)0.441376,\n       (float)0.448456, (float)0.455536,\
    \ (float)0.462646,\n       (float)0.469757, (float)0.476868, (float)0.483978,\n\
    \       (float)0.491089, (float)0.498230, (float)0.505341,\n       (float)0.512451,\
    \ (float)0.519592, (float)0.526703,\n       (float)0.533813, (float)0.540924,\
    \ (float)0.548004,\n       (float)0.555084, (float)0.562164, (float)0.569244,\n\
    \       (float)0.576294, (float)0.583313, (float)0.590332,\n       (float)0.597321,\
    \ (float)0.604309, (float)0.611267,\n       (float)0.618195, (float)0.625092,\
    \ (float)0.631989,\n       (float)0.638855, (float)0.645660, (float)0.652466,\n\
    \       (float)0.659241, (float)0.665985, (float)0.672668,\n       (float)0.679352,\
    \ (float)0.685974, (float)0.692566,\n       (float)0.699127, (float)0.705658,\
    \ (float)0.712128,\n       (float)0.718536, (float)0.724945, (float)0.731262,\n\
    \       (float)0.737549, (float)0.743805, (float)0.750000,\n       (float)0.756134,\
    \ (float)0.762238, (float)0.768280,\n       (float)0.774261, (float)0.780182,\
    \ (float)0.786072,\n       (float)0.791870, (float)0.797638, (float)0.803314,\n\
    \       (float)0.808960, (float)0.814514, (float)0.820038,\n       (float)0.825470,\
    \ (float)0.830841, (float)0.836151,\n       (float)0.841400, (float)0.846558,\
    \ (float)0.851654,\n       (float)0.856689, (float)0.861633, (float)0.866516,\n\
    \       (float)0.871338, (float)0.876068, (float)0.880737,\n       (float)0.885315,\
    \ (float)0.889801, (float)0.894226,\n       (float)0.898560, (float)0.902832,\
    \ (float)0.907013,\n       (float)0.911102, (float)0.915100, (float)0.919037,\n\
    \       (float)0.922882, (float)0.926636, (float)0.930328,\n       (float)0.933899,\
    \ (float)0.937408, (float)0.940796,\n       (float)0.944122, (float)0.947357,\
    \ (float)0.950470,\n       (float)0.953522, (float)0.956482, (float)0.959351,\n\
    \       (float)0.962097, (float)0.964783, (float)0.967377,\n       (float)0.969849,\
    \ (float)0.972229, (float)0.974518,\n       (float)0.976715, (float)0.978821,\
    \ (float)0.980835,\n       (float)0.982727, (float)0.984528, (float)0.986237,\n\
    \       (float)0.987854, (float)0.989380, (float)0.990784,\n       (float)0.992096,\
    \ (float)0.993317, (float)0.994415,\n       (float)0.995422, (float)0.996338,\
    \ (float)0.997162,\n       (float)0.997864, (float)0.998474, (float)0.998962,\n\
    \       (float)0.999390, (float)0.999695, (float)0.999878,\n       (float)0.999969,\
    \ (float)0.999969, (float)0.996918,\n       (float)0.987701, (float)0.972382,\
    \ (float)0.951050,\n       (float)0.923889, (float)0.891022, (float)0.852631,\n\
    \       (float)0.809021, (float)0.760406, (float)0.707092,\n       (float)0.649445,\
    \ (float)0.587799, (float)0.522491,\n       (float)0.453979, (float)0.382690,\
    \ (float)0.309021,\n       (float)0.233459, (float)0.156433, (float)0.078461\n\
    \   };\n   /* Lag window for LPC */\n   float lpc_lagwinTbl[LPC_FILTERORDER +\
    \ 1]={\n       (float)1.000100, (float)0.998890, (float)0.995569,\n          \
    \ (float)0.990057, (float)0.982392,\n       (float)0.972623, (float)0.960816,\
    \ (float)0.947047,\n           (float)0.931405, (float)0.913989, (float)0.894909};\n\
    \   /* LSF quantization*/\n   float lsfCbTbl[64 * 3 + 128 * 3 + 128 * 4] = {\n\
    \   (float)0.155396, (float)0.273193, (float)0.451172,\n   (float)0.390503, (float)0.648071,\
    \ (float)1.002075,\n   (float)0.440186, (float)0.692261, (float)0.955688,\n  \
    \ (float)0.343628, (float)0.642334, (float)1.071533,\n   (float)0.318359, (float)0.491577,\
    \ (float)0.670532,\n   (float)0.193115, (float)0.375488, (float)0.725708,\n  \
    \ (float)0.364136, (float)0.510376, (float)0.658691,\n   (float)0.297485, (float)0.527588,\
    \ (float)0.842529,\n   (float)0.227173, (float)0.365967, (float)0.563110,\n  \
    \ (float)0.244995, (float)0.396729, (float)0.636475,\n   (float)0.169434, (float)0.300171,\
    \ (float)0.520264,\n   (float)0.312866, (float)0.464478, (float)0.643188,\n  \
    \ (float)0.248535, (float)0.429932, (float)0.626099,\n   (float)0.236206, (float)0.491333,\
    \ (float)0.817139,\n   (float)0.334961, (float)0.625122, (float)0.895752,\n  \
    \ (float)0.343018, (float)0.518555, (float)0.698608,\n   (float)0.372803, (float)0.659790,\
    \ (float)0.945435,\n   (float)0.176880, (float)0.316528, (float)0.581421,\n  \
    \ (float)0.416382, (float)0.625977, (float)0.805176,\n   (float)0.303223, (float)0.568726,\
    \ (float)0.915039,\n   (float)0.203613, (float)0.351440, (float)0.588135,\n  \
    \ (float)0.221191, (float)0.375000, (float)0.614746,\n   (float)0.199951, (float)0.323364,\
    \ (float)0.476074,\n   (float)0.300781, (float)0.433350, (float)0.566895,\n  \
    \ (float)0.226196, (float)0.354004, (float)0.507568,\n   (float)0.300049, (float)0.508179,\
    \ (float)0.711670,\n   (float)0.312012, (float)0.492676, (float)0.763428,\n  \
    \ (float)0.329956, (float)0.541016, (float)0.795776,\n   (float)0.373779, (float)0.604614,\
    \ (float)0.928833,\n   (float)0.210571, (float)0.452026, (float)0.755249,\n  \
    \ (float)0.271118, (float)0.473267, (float)0.662476,\n   (float)0.285522, (float)0.436890,\
    \ (float)0.634399,\n   (float)0.246704, (float)0.565552, (float)0.859009,\n  \
    \ (float)0.270508, (float)0.406250, (float)0.553589,\n   (float)0.361450, (float)0.578491,\
    \ (float)0.813843,\n   (float)0.342651, (float)0.482788, (float)0.622437,\n  \
    \ (float)0.340332, (float)0.549438, (float)0.743164,\n   (float)0.200439, (float)0.336304,\
    \ (float)0.540894,\n   (float)0.407837, (float)0.644775, (float)0.895142,\n  \
    \ (float)0.294678, (float)0.454834, (float)0.699097,\n   (float)0.193115, (float)0.344482,\
    \ (float)0.643188,\n   (float)0.275757, (float)0.420776, (float)0.598755,\n  \
    \ (float)0.380493, (float)0.608643, (float)0.861084,\n   (float)0.222778, (float)0.426147,\
    \ (float)0.676514,\n   (float)0.407471, (float)0.700195, (float)1.053101,\n  \
    \ (float)0.218384, (float)0.377197, (float)0.669922,\n   (float)0.313232, (float)0.454102,\
    \ (float)0.600952,\n   (float)0.347412, (float)0.571533, (float)0.874146,\n  \
    \ (float)0.238037, (float)0.405396, (float)0.729492,\n   (float)0.223877, (float)0.412964,\
    \ (float)0.822021,\n   (float)0.395264, (float)0.582153, (float)0.743896,\n  \
    \ (float)0.247925, (float)0.485596, (float)0.720581,\n   (float)0.229126, (float)0.496582,\
    \ (float)0.907715,\n   (float)0.260132, (float)0.566895, (float)1.012695,\n  \
    \ (float)0.337402, (float)0.611572, (float)0.978149,\n   (float)0.267822, (float)0.447632,\
    \ (float)0.769287,\n   (float)0.250610, (float)0.381714, (float)0.530029,\n  \
    \ (float)0.430054, (float)0.805054, (float)1.221924,\n   (float)0.382568, (float)0.544067,\
    \ (float)0.701660,\n   (float)0.383545, (float)0.710327, (float)1.149170,\n  \
    \ (float)0.271362, (float)0.529053, (float)0.775513,\n   (float)0.246826, (float)0.393555,\
    \ (float)0.588623,\n   (float)0.266846, (float)0.422119, (float)0.676758,\n  \
    \ (float)0.311523, (float)0.580688, (float)0.838623,\n   (float)1.331177, (float)1.576782,\
    \ (float)1.779541,\n   (float)1.160034, (float)1.401978, (float)1.768188,\n  \
    \ (float)1.161865, (float)1.525146, (float)1.715332,\n   (float)0.759521, (float)0.913940,\
    \ (float)1.119873,\n   (float)0.947144, (float)1.121338, (float)1.282471,\n  \
    \ (float)1.015015, (float)1.557007, (float)1.804932,\n   (float)1.172974, (float)1.402100,\
    \ (float)1.692627,\n   (float)1.087524, (float)1.474243, (float)1.665405,\n  \
    \ (float)0.899536, (float)1.105225, (float)1.406250,\n   (float)1.148438, (float)1.484741,\
    \ (float)1.796265,\n   (float)0.785645, (float)1.209839, (float)1.567749,\n  \
    \ (float)0.867798, (float)1.166504, (float)1.450684,\n   (float)0.922485, (float)1.229858,\
    \ (float)1.420898,\n   (float)0.791260, (float)1.123291, (float)1.409546,\n  \
    \ (float)0.788940, (float)0.966064, (float)1.340332,\n   (float)1.051147, (float)1.272827,\
    \ (float)1.556641,\n   (float)0.866821, (float)1.181152, (float)1.538818,\n  \
    \ (float)0.906738, (float)1.373535, (float)1.607910,\n   (float)1.244751, (float)1.581421,\
    \ (float)1.933838,\n   (float)0.913940, (float)1.337280, (float)1.539673,\n  \
    \ (float)0.680542, (float)0.959229, (float)1.662720,\n   (float)0.887207, (float)1.430542,\
    \ (float)1.800781,\n   (float)0.912598, (float)1.433594, (float)1.683960,\n  \
    \ (float)0.860474, (float)1.060303, (float)1.455322,\n   (float)1.005127, (float)1.381104,\
    \ (float)1.706909,\n   (float)0.800781, (float)1.363892, (float)1.829102,\n  \
    \ (float)0.781860, (float)1.124390, (float)1.505981,\n   (float)1.003662, (float)1.471436,\
    \ (float)1.684692,\n   (float)0.981323, (float)1.309570, (float)1.618042,\n  \
    \ (float)1.228760, (float)1.554321, (float)1.756470,\n   (float)0.734375, (float)0.895752,\
    \ (float)1.225586,\n   (float)0.841797, (float)1.055664, (float)1.249268,\n  \
    \ (float)0.920166, (float)1.119385, (float)1.486206,\n   (float)0.894409, (float)1.539063,\
    \ (float)1.828979,\n   (float)1.283691, (float)1.543335, (float)1.858276,\n  \
    \ (float)0.676025, (float)0.933105, (float)1.490845,\n   (float)0.821289, (float)1.491821,\
    \ (float)1.739868,\n   (float)0.923218, (float)1.144653, (float)1.580566,\n  \
    \ (float)1.057251, (float)1.345581, (float)1.635864,\n   (float)0.888672, (float)1.074951,\
    \ (float)1.353149,\n   (float)0.942749, (float)1.195435, (float)1.505493,\n  \
    \ (float)1.492310, (float)1.788086, (float)2.039673,\n   (float)1.070313, (float)1.634399,\
    \ (float)1.860962,\n   (float)1.253296, (float)1.488892, (float)1.686035,\n  \
    \ (float)0.647095, (float)0.864014, (float)1.401855,\n   (float)0.866699, (float)1.254883,\
    \ (float)1.453369,\n   (float)1.063965, (float)1.532593, (float)1.731323,\n  \
    \ (float)1.167847, (float)1.521484, (float)1.884033,\n   (float)0.956055, (float)1.502075,\
    \ (float)1.745605,\n   (float)0.928711, (float)1.288574, (float)1.479614,\n  \
    \ (float)1.088013, (float)1.380737, (float)1.570801,\n   (float)0.905029, (float)1.186768,\
    \ (float)1.371948,\n   (float)1.057861, (float)1.421021, (float)1.617432,\n  \
    \ (float)1.108276, (float)1.312500, (float)1.501465,\n   (float)0.979492, (float)1.416992,\
    \ (float)1.624268,\n   (float)1.276001, (float)1.661011, (float)2.007935,\n  \
    \ (float)0.993042, (float)1.168579, (float)1.331665,\n   (float)0.778198, (float)0.944946,\
    \ (float)1.235962,\n   (float)1.223755, (float)1.491333, (float)1.815674,\n  \
    \ (float)0.852661, (float)1.350464, (float)1.722290,\n   (float)1.134766, (float)1.593140,\
    \ (float)1.787354,\n   (float)1.051392, (float)1.339722, (float)1.531006,\n  \
    \ (float)0.803589, (float)1.271240, (float)1.652100,\n   (float)0.755737, (float)1.143555,\
    \ (float)1.639404,\n   (float)0.700928, (float)0.837280, (float)1.130371,\n  \
    \ (float)0.942749, (float)1.197876, (float)1.669800,\n   (float)0.993286, (float)1.378296,\
    \ (float)1.566528,\n   (float)0.801025, (float)1.095337, (float)1.298950,\n  \
    \ (float)0.739990, (float)1.032959, (float)1.383667,\n   (float)0.845703, (float)1.072266,\
    \ (float)1.543823,\n   (float)0.915649, (float)1.072266, (float)1.224487,\n  \
    \ (float)1.021973, (float)1.226196, (float)1.481323,\n   (float)0.999878, (float)1.204102,\
    \ (float)1.555908,\n   (float)0.722290, (float)0.913940, (float)1.340210,\n  \
    \ (float)0.673340, (float)0.835938, (float)1.259521,\n   (float)0.832397, (float)1.208374,\
    \ (float)1.394165,\n   (float)0.962158, (float)1.576172, (float)1.912842,\n  \
    \ (float)1.166748, (float)1.370850, (float)1.556763,\n   (float)0.946289, (float)1.138550,\
    \ (float)1.400391,\n   (float)1.035034, (float)1.218262, (float)1.386475,\n  \
    \ (float)1.393799, (float)1.717773, (float)2.000244,\n   (float)0.972656, (float)1.260986,\
    \ (float)1.760620,\n   (float)1.028198, (float)1.288452, (float)1.484619,\n  \
    \ (float)0.773560, (float)1.258057, (float)1.756714,\n   (float)1.080322, (float)1.328003,\
    \ (float)1.742676,\n   (float)0.823975, (float)1.450806, (float)1.917725,\n  \
    \ (float)0.859009, (float)1.016602, (float)1.191895,\n   (float)0.843994, (float)1.131104,\
    \ (float)1.645020,\n   (float)1.189697, (float)1.702759, (float)1.894409,\n  \
    \ (float)1.346680, (float)1.763184, (float)2.066040,\n   (float)0.980469, (float)1.253784,\
    \ (float)1.441650,\n   (float)1.338135, (float)1.641968, (float)1.932739,\n  \
    \ (float)1.223267, (float)1.424194, (float)1.626465,\n   (float)0.765747, (float)1.004150,\
    \ (float)1.579102,\n   (float)1.042847, (float)1.269165, (float)1.647461,\n  \
    \ (float)0.968750, (float)1.257568, (float)1.555786,\n   (float)0.826294, (float)0.993408,\
    \ (float)1.275146,\n   (float)0.742310, (float)0.950439, (float)1.430542,\n  \
    \ (float)1.054321, (float)1.439819, (float)1.828003,\n   (float)1.072998, (float)1.261719,\
    \ (float)1.441895,\n   (float)0.859375, (float)1.036377, (float)1.314819,\n  \
    \ (float)0.895752, (float)1.267212, (float)1.605591,\n   (float)0.805420, (float)0.962891,\
    \ (float)1.142334,\n   (float)0.795654, (float)1.005493, (float)1.468506,\n  \
    \ (float)1.105347, (float)1.313843, (float)1.584839,\n   (float)0.792236, (float)1.221802,\
    \ (float)1.465698,\n   (float)1.170532, (float)1.467651, (float)1.664063,\n  \
    \ (float)0.838257, (float)1.153198, (float)1.342163,\n   (float)0.968018, (float)1.198242,\
    \ (float)1.391235,\n   (float)1.250122, (float)1.623535, (float)1.823608,\n  \
    \ (float)0.711670, (float)1.058350, (float)1.512085,\n   (float)1.204834, (float)1.454468,\
    \ (float)1.739136,\n   (float)1.137451, (float)1.421753, (float)1.620117,\n  \
    \ (float)0.820435, (float)1.322754, (float)1.578247,\n   (float)0.798706, (float)1.005005,\
    \ (float)1.213867,\n   (float)0.980713, (float)1.324951, (float)1.512939,\n  \
    \ (float)1.112305, (float)1.438843, (float)1.735596,\n   (float)1.135498, (float)1.356689,\
    \ (float)1.635742,\n   (float)1.101318, (float)1.387451, (float)1.686523,\n  \
    \ (float)0.849854, (float)1.276978, (float)1.523438,\n   (float)1.377930, (float)1.627563,\
    \ (float)1.858154,\n   (float)0.884888, (float)1.095459, (float)1.287476,\n  \
    \ (float)1.289795, (float)1.505859, (float)1.756592,\n   (float)0.817505, (float)1.384155,\
    \ (float)1.650513,\n   (float)1.446655, (float)1.702148, (float)1.931885,\n  \
    \ (float)0.835815, (float)1.023071, (float)1.385376,\n   (float)0.916626, (float)1.139038,\
    \ (float)1.335327,\n   (float)0.980103, (float)1.174072, (float)1.453735,\n  \
    \ (float)1.705688, (float)2.153809, (float)2.398315, (float)2.743408,\n   (float)1.797119,\
    \ (float)2.016846, (float)2.445679, (float)2.701904,\n   (float)1.990356, (float)2.219116,\
    \ (float)2.576416, (float)2.813477,\n   (float)1.849365, (float)2.190918, (float)2.611572,\
    \ (float)2.835083,\n   (float)1.657959, (float)1.854370, (float)2.159058, (float)2.726196,\n\
    \   (float)1.437744, (float)1.897705, (float)2.253174, (float)2.655396,\n   (float)2.028687,\
    \ (float)2.247314, (float)2.542358, (float)2.875854,\n   (float)1.736938, (float)1.922119,\
    \ (float)2.185913, (float)2.743408,\n   (float)1.521606, (float)1.870972, (float)2.526855,\
    \ (float)2.786987,\n   (float)1.841431, (float)2.050659, (float)2.463623, (float)2.857666,\n\
    \   (float)1.590088, (float)2.067261, (float)2.427979, (float)2.794434,\n   (float)1.746826,\
    \ (float)2.057373, (float)2.320190, (float)2.800781,\n   (float)1.734619, (float)1.940552,\
    \ (float)2.306030, (float)2.826416,\n   (float)1.786255, (float)2.204468, (float)2.457520,\
    \ (float)2.795288,\n   (float)1.861084, (float)2.170532, (float)2.414551, (float)2.763672,\n\
    \   (float)2.001465, (float)2.307617, (float)2.552734, (float)2.811890,\n   (float)1.784424,\
    \ (float)2.124146, (float)2.381592, (float)2.645508,\n   (float)1.888794, (float)2.135864,\
    \ (float)2.418579, (float)2.861206,\n   (float)2.301147, (float)2.531250, (float)2.724976,\
    \ (float)2.913086,\n   (float)1.837769, (float)2.051270, (float)2.261963, (float)2.553223,\n\
    \   (float)2.012939, (float)2.221191, (float)2.440186, (float)2.678101,\n   (float)1.429565,\
    \ (float)1.858276, (float)2.582275, (float)2.845703,\n   (float)1.622803, (float)1.897705,\
    \ (float)2.367310, (float)2.621094,\n   (float)1.581543, (float)1.960449, (float)2.515869,\
    \ (float)2.736450,\n   (float)1.419434, (float)1.933960, (float)2.394653, (float)2.746704,\n\
    \   (float)1.721924, (float)2.059570, (float)2.421753, (float)2.769653,\n   (float)1.911011,\
    \ (float)2.220703, (float)2.461060, (float)2.740723,\n   (float)1.581177, (float)1.860840,\
    \ (float)2.516968, (float)2.874634,\n   (float)1.870361, (float)2.098755, (float)2.432373,\
    \ (float)2.656494,\n   (float)2.059692, (float)2.279785, (float)2.495605, (float)2.729370,\n\
    \   (float)1.815674, (float)2.181519, (float)2.451538, (float)2.680542,\n   (float)1.407959,\
    \ (float)1.768311, (float)2.343018, (float)2.668091,\n   (float)2.168701, (float)2.394653,\
    \ (float)2.604736, (float)2.829346,\n   (float)1.636230, (float)1.865723, (float)2.329102,\
    \ (float)2.824219,\n   (float)1.878906, (float)2.139526, (float)2.376709, (float)2.679810,\n\
    \   (float)1.765381, (float)1.971802, (float)2.195435, (float)2.586914,\n   (float)2.164795,\
    \ (float)2.410889, (float)2.673706, (float)2.903198,\n   (float)2.071899, (float)2.331055,\
    \ (float)2.645874, (float)2.907104,\n   (float)2.026001, (float)2.311523, (float)2.594849,\
    \ (float)2.863892,\n   (float)1.948975, (float)2.180786, (float)2.514893, (float)2.797852,\n\
    \   (float)1.881836, (float)2.130859, (float)2.478149, (float)2.804199,\n   (float)2.238159,\
    \ (float)2.452759, (float)2.652832, (float)2.868286,\n   (float)1.897949, (float)2.101685,\
    \ (float)2.524292, (float)2.880127,\n   (float)1.856445, (float)2.074585, (float)2.541016,\
    \ (float)2.791748,\n   (float)1.695557, (float)2.199097, (float)2.506226, (float)2.742676,\n\
    \   (float)1.612671, (float)1.877075, (float)2.435425, (float)2.732910,\n   (float)1.568848,\
    \ (float)1.786499, (float)2.194580, (float)2.768555,\n   (float)1.953369, (float)2.164551,\
    \ (float)2.486938, (float)2.874023,\n   (float)1.388306, (float)1.725342, (float)2.384521,\
    \ (float)2.771851,\n   (float)2.115356, (float)2.337769, (float)2.592896, (float)2.864014,\n\
    \   (float)1.905762, (float)2.111328, (float)2.363525, (float)2.789307,\n   (float)1.882568,\
    \ (float)2.332031, (float)2.598267, (float)2.827637,\n   (float)1.683594, (float)2.088745,\
    \ (float)2.361938, (float)2.608643,\n   (float)1.874023, (float)2.182129, (float)2.536133,\
    \ (float)2.766968,\n   (float)1.861938, (float)2.070435, (float)2.309692, (float)2.700562,\n\
    \   (float)1.722168, (float)2.107422, (float)2.477295, (float)2.837646,\n   (float)1.926880,\
    \ (float)2.184692, (float)2.442627, (float)2.663818,\n   (float)2.123901, (float)2.337280,\
    \ (float)2.553101, (float)2.777466,\n   (float)1.588135, (float)1.911499, (float)2.212769,\
    \ (float)2.543945,\n   (float)2.053955, (float)2.370850, (float)2.712158, (float)2.939941,\n\
    \   (float)2.210449, (float)2.519653, (float)2.770386, (float)2.958618,\n   (float)2.199463,\
    \ (float)2.474731, (float)2.718262, (float)2.919922,\n   (float)1.960083, (float)2.175415,\
    \ (float)2.608032, (float)2.888794,\n   (float)1.953735, (float)2.185181, (float)2.428223,\
    \ (float)2.809570,\n   (float)1.615234, (float)2.036499, (float)2.576538, (float)2.834595,\n\
    \   (float)1.621094, (float)2.028198, (float)2.431030, (float)2.664673,\n   (float)1.824951,\
    \ (float)2.267456, (float)2.514526, (float)2.747925,\n   (float)1.994263, (float)2.229126,\
    \ (float)2.475220, (float)2.833984,\n   (float)1.746338, (float)2.011353, (float)2.588257,\
    \ (float)2.826904,\n   (float)1.562866, (float)2.135986, (float)2.471680, (float)2.687256,\n\
    \   (float)1.748901, (float)2.083496, (float)2.460938, (float)2.686279,\n   (float)1.758057,\
    \ (float)2.131470, (float)2.636597, (float)2.891602,\n   (float)2.071289, (float)2.299072,\
    \ (float)2.550781, (float)2.814331,\n   (float)1.839600, (float)2.094360, (float)2.496460,\
    \ (float)2.723999,\n   (float)1.882202, (float)2.088257, (float)2.636841, (float)2.923096,\n\
    \   (float)1.957886, (float)2.153198, (float)2.384399, (float)2.615234,\n   (float)1.992920,\
    \ (float)2.351196, (float)2.654419, (float)2.889771,\n   (float)2.012817, (float)2.262451,\
    \ (float)2.643799, (float)2.903076,\n   (float)2.025635, (float)2.254761, (float)2.508423,\
    \ (float)2.784058,\n   (float)2.316040, (float)2.589355, (float)2.794189, (float)2.963623,\n\
    \   (float)1.741211, (float)2.279541, (float)2.578491, (float)2.816284,\n   (float)1.845337,\
    \ (float)2.055786, (float)2.348511, (float)2.822021,\n   (float)1.679932, (float)1.926514,\
    \ (float)2.499756, (float)2.835693,\n   (float)1.722534, (float)1.946899, (float)2.448486,\
    \ (float)2.728760,\n   (float)1.829834, (float)2.043213, (float)2.580444, (float)2.867676,\n\
    \   (float)1.676636, (float)2.071655, (float)2.322510, (float)2.704834,\n   (float)1.791504,\
    \ (float)2.113525, (float)2.469727, (float)2.784058,\n   (float)1.977051, (float)2.215088,\
    \ (float)2.497437, (float)2.726929,\n   (float)1.800171, (float)2.106689, (float)2.357788,\
    \ (float)2.738892,\n   (float)1.827759, (float)2.170166, (float)2.525879, (float)2.852417,\n\
    \   (float)1.918335, (float)2.132813, (float)2.488403, (float)2.728149,\n   (float)1.916748,\
    \ (float)2.225098, (float)2.542603, (float)2.857666,\n   (float)1.761230, (float)1.976074,\
    \ (float)2.507446, (float)2.884521,\n   (float)2.053711, (float)2.367432, (float)2.608032,\
    \ (float)2.837646,\n   (float)1.595337, (float)2.000977, (float)2.307129, (float)2.578247,\n\
    \   (float)1.470581, (float)2.031250, (float)2.375854, (float)2.647583,\n   (float)1.801392,\
    \ (float)2.128052, (float)2.399780, (float)2.822876,\n   (float)1.853638, (float)2.066650,\
    \ (float)2.429199, (float)2.751465,\n   (float)1.956299, (float)2.163696, (float)2.394775,\
    \ (float)2.734253,\n   (float)1.963623, (float)2.275757, (float)2.585327, (float)2.865234,\n\
    \   (float)1.887451, (float)2.105469, (float)2.331787, (float)2.587402,\n   (float)2.120117,\
    \ (float)2.443359, (float)2.733887, (float)2.941406,\n   (float)1.506348, (float)1.766968,\
    \ (float)2.400513, (float)2.851807,\n   (float)1.664551, (float)1.981079, (float)2.375732,\
    \ (float)2.774414,\n   (float)1.720703, (float)1.978882, (float)2.391479, (float)2.640991,\n\
    \   (float)1.483398, (float)1.814819, (float)2.434448, (float)2.722290,\n   (float)1.769043,\
    \ (float)2.136597, (float)2.563721, (float)2.774414,\n   (float)1.810791, (float)2.049316,\
    \ (float)2.373901, (float)2.613647,\n   (float)1.788330, (float)2.005981, (float)2.359131,\
    \ (float)2.723145,\n   (float)1.785156, (float)1.993164, (float)2.399780, (float)2.832520,\n\
    \   (float)1.695313, (float)2.022949, (float)2.522583, (float)2.745117,\n   (float)1.584106,\
    \ (float)1.965576, (float)2.299927, (float)2.715576,\n   (float)1.894897, (float)2.249878,\
    \ (float)2.655884, (float)2.897705,\n   (float)1.720581, (float)1.995728, (float)2.299438,\
    \ (float)2.557007,\n   (float)1.619385, (float)2.173950, (float)2.574219, (float)2.787964,\n\
    \   (float)1.883179, (float)2.220459, (float)2.474365, (float)2.825073,\n   (float)1.447632,\
    \ (float)2.045044, (float)2.555542, (float)2.744873,\n   (float)1.502686, (float)2.156616,\
    \ (float)2.653320, (float)2.846558,\n   (float)1.711548, (float)1.944092, (float)2.282959,\
    \ (float)2.685791,\n   (float)1.499756, (float)1.867554, (float)2.341064, (float)2.578857,\n\
    \   (float)1.916870, (float)2.135132, (float)2.568237, (float)2.826050,\n   (float)1.498047,\
    \ (float)1.711182, (float)2.223267, (float)2.755127,\n   (float)1.808716, (float)1.997559,\
    \ (float)2.256470, (float)2.758545,\n   (float)2.088501, (float)2.402710, (float)2.667358,\
    \ (float)2.890259,\n   (float)1.545044, (float)1.819214, (float)2.324097, (float)2.692993,\n\
    \   (float)1.796021, (float)2.012573, (float)2.505737, (float)2.784912,\n   (float)1.786499,\
    \ (float)2.041748, (float)2.290405, (float)2.650757,\n   (float)1.938232, (float)2.264404,\
    \ (float)2.529053, (float)2.796143\n   };\n"
- title: A.9.  anaFilter.h
  contents:
  - "A.9.  anaFilter.h\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       anaFilter.h\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #ifndef __iLBC_ANAFILTER_H\n   #define __iLBC_ANAFILTER_H\n   void anaFilter(\n\
    \       float *In,  /* (i) Signal to be filtered */\n       float *a,   /* (i)\
    \ LP parameters */\n       int len,/* (i) Length of signal */\n       float *Out,\
    \ /* (o) Filtered signal */\n       float *mem  /* (i/o) Filter state */\n   );\n\
    \   #endif\n"
- title: A.10.  anaFilter.c
  contents:
  - "A.10.  anaFilter.c\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       anaFilter.c\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #include <string.h>\n   #include \"iLBC_define.h\"\n   /*----------------------------------------------------------------*\n\
    \    *  LP analysis filter.\n    *---------------------------------------------------------------*/\n\
    \   void anaFilter(\n       float *In,  /* (i) Signal to be filtered */\n    \
    \   float *a,   /* (i) LP parameters */\n       int len,/* (i) Length of signal\
    \ */\n       float *Out, /* (o) Filtered signal */\n       float *mem  /* (i/o)\
    \ Filter state */\n   ){\n       int i, j;\n       float *po, *pi, *pm, *pa;\n\
    \       po = Out;\n       /* Filter first part using memory from past */\n   \
    \    for (i=0; i<LPC_FILTERORDER; i++) {\n           pi = &In[i];\n          \
    \ pm = &mem[LPC_FILTERORDER-1];\n           pa = a;\n           *po=0.0;\n   \
    \        for (j=0; j<=i; j++) {\n               *po+=(*pa++)*(*pi--);\n      \
    \     }\n           for (j=i+1; j<LPC_FILTERORDER+1; j++) {\n               *po+=(*pa++)*(*pm--);\n\
    \           }\n           po++;\n       }\n       /* Filter last part where the\
    \ state is entirely\n          in the input vector */\n       for (i=LPC_FILTERORDER;\
    \ i<len; i++) {\n           pi = &In[i];\n           pa = a;\n           *po=0.0;\n\
    \           for (j=0; j<LPC_FILTERORDER+1; j++) {\n               *po+=(*pa++)*(*pi--);\n\
    \           }\n           po++;\n       }\n       /* Update state vector */\n\
    \       memcpy(mem, &In[len-LPC_FILTERORDER],\n           LPC_FILTERORDER*sizeof(float));\n\
    \   }\n"
- title: A.11.  createCB.h
  contents:
  - "A.11.  createCB.h\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       createCB.h\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #ifndef __iLBC_CREATECB_H\n   #define __iLBC_CREATECB_H\n   void filteredCBvecs(\n\
    \       float *cbvectors,   /* (o) Codebook vector for the\n                 \
    \                 higher section */\n       float *mem,         /* (i) Buffer\
    \ to create codebook\n                                  vectors from */\n    \
    \   int lMem        /* (i) Length of buffer */\n   );\n   void searchAugmentedCB(\n\
    \       int low,        /* (i) Start index for the search */\n       int high,\
    \           /* (i) End index for the search */\n       int stage,          /*\
    \ (i) Current stage */\n       int startIndex,     /* (i) CB index for the first\n\
    \                                  augmented vector */\n       float *target,\
    \      /* (i) Target vector for encoding */\n       float *buffer,      /* (i)\
    \ Pointer to the end of the\n                                  buffer for augmented\
    \ codebook\n                                  construction */\n       float *max_measure,\
    \ /* (i/o) Currently maximum measure */\n       int *best_index,/* (o) Currently\
    \ the best index */\n       float *gain,    /* (o) Currently the best gain */\n\
    \       float *energy,      /* (o) Energy of augmented\n                     \
    \             codebook vectors */\n       float *invenergy/* (o) Inv energy of\
    \ aug codebook\n                                  vectors */\n   );\n   void createAugmentedVec(\n\
    \       int index,          /* (i) Index for the aug vector\n                \
    \                  to be created */\n       float *buffer,      /* (i) Pointer\
    \ to the end of the\n                                  buffer for augmented codebook\n\
    \                                  construction */\n       float *cbVec    /*\
    \ (o) The construced codebook vector */\n   );\n   #endif\n"
- title: A.12.  createCB.c
  contents:
  - "A.12.  createCB.c\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       createCB.c\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #include \"iLBC_define.h\"\n   #include \"constants.h\"\n   #include <string.h>\n\
    \   #include <math.h>\n   /*----------------------------------------------------------------*\n\
    \    *  Construct an additional codebook vector by filtering the\n    *  initial\
    \ codebook buffer. This vector is then used to expand\n    *  the codebook with\
    \ an additional section.\n    *---------------------------------------------------------------*/\n\
    \   void filteredCBvecs(\n       float *cbvectors,   /* (o) Codebook vectors for\
    \ the\n                                  higher section */\n       float *mem,\
    \         /* (i) Buffer to create codebook\n                                 \
    \ vector from */\n       int lMem        /* (i) Length of buffer */\n   ){\n \
    \      int j, k;\n       float *pp, *pp1;\n       float tempbuff2[CB_MEML+CB_FILTERLEN];\n\
    \       float *pos;\n       memset(tempbuff2, 0, (CB_HALFFILTERLEN-1)*sizeof(float));\n\
    \       memcpy(&tempbuff2[CB_HALFFILTERLEN-1], mem, lMem*sizeof(float));\n   \
    \    memset(&tempbuff2[lMem+CB_HALFFILTERLEN-1], 0,\n           (CB_HALFFILTERLEN+1)*sizeof(float));\n\
    \       /* Create codebook vector for higher section by filtering */\n       /*\
    \ do filtering */\n       pos=cbvectors;\n       memset(pos, 0, lMem*sizeof(float));\n\
    \       for (k=0; k<lMem; k++) {\n           pp=&tempbuff2[k];\n           pp1=&cbfiltersTbl[CB_FILTERLEN-1];\n\
    \           for (j=0;j<CB_FILTERLEN;j++) {\n               (*pos)+=(*pp++)*(*pp1--);\n\
    \           }\n           pos++;\n       }\n   }\n   /*----------------------------------------------------------------*\n\
    \    *  Search the augmented part of the codebook to find the best\n    *  measure.\n\
    \    *----------------------------------------------------------------*/\n   void\
    \ searchAugmentedCB(\n       int low,        /* (i) Start index for the search\
    \ */\n       int high,           /* (i) End index for the search */\n       int\
    \ stage,          /* (i) Current stage */\n       int startIndex,     /* (i) Codebook\
    \ index for the first\n                                  aug vector */\n     \
    \  float *target,      /* (i) Target vector for encoding */\n       float *buffer,\
    \      /* (i) Pointer to the end of the buffer for\n                         \
    \         augmented codebook construction */\n       float *max_measure, /* (i/o)\
    \ Currently maximum measure */\n       int *best_index,/* (o) Currently the best\
    \ index */\n       float *gain,    /* (o) Currently the best gain */\n       float\
    \ *energy,      /* (o) Energy of augmented codebook\n                        \
    \          vectors */\n       float *invenergy/* (o) Inv energy of augmented codebook\n\
    \                                  vectors */\n   ) {\n       int icount, ilow,\
    \ j, tmpIndex;\n       float *pp, *ppo, *ppi, *ppe, crossDot, alfa;\n       float\
    \ weighted, measure, nrjRecursive;\n       float ftmp;\n       /* Compute the\
    \ energy for the first (low-5)\n          noninterpolated samples */\n       nrjRecursive\
    \ = (float) 0.0;\n       pp = buffer - low + 1;\n       for (j=0; j<(low-5); j++)\
    \ {\n           nrjRecursive += ( (*pp)*(*pp) );\n           pp++;\n       }\n\
    \       ppe = buffer - low;\n       for (icount=low; icount<=high; icount++) {\n\
    \           /* Index of the codebook vector used for retrieving\n            \
    \  energy values */\n           tmpIndex = startIndex+icount-20;\n           ilow\
    \ = icount-4;\n           /* Update the energy recursively to save complexity\
    \ */\n           nrjRecursive = nrjRecursive + (*ppe)*(*ppe);\n           ppe--;\n\
    \           energy[tmpIndex] = nrjRecursive;\n           /* Compute cross dot\
    \ product for the first (low-5)\n              samples */\n           crossDot\
    \ = (float) 0.0;\n           pp = buffer-icount;\n           for (j=0; j<ilow;\
    \ j++) {\n               crossDot += target[j]*(*pp++);\n           }\n      \
    \     /* interpolation */\n           alfa = (float) 0.2;\n           ppo = buffer-4;\n\
    \           ppi = buffer-icount-4;\n           for (j=ilow; j<icount; j++) {\n\
    \               weighted = ((float)1.0-alfa)*(*ppo)+alfa*(*ppi);\n           \
    \    ppo++;\n               ppi++;\n               energy[tmpIndex] += weighted*weighted;\n\
    \               crossDot += target[j]*weighted;\n               alfa += (float)0.2;\n\
    \           }\n           /* Compute energy and cross dot product for the\n  \
    \            remaining samples */\n           pp = buffer - icount;\n        \
    \   for (j=icount; j<SUBL; j++) {\n               energy[tmpIndex] += (*pp)*(*pp);\n\
    \               crossDot += target[j]*(*pp++);\n           }\n           if (energy[tmpIndex]>0.0)\
    \ {\n               invenergy[tmpIndex]=(float)1.0/(energy[tmpIndex]+EPS);\n \
    \          } else {\n               invenergy[tmpIndex] = (float) 0.0;\n     \
    \      }\n           if (stage==0) {\n               measure = (float)-10000000.0;\n\
    \               if (crossDot > 0.0) {\n                   measure = crossDot*crossDot*invenergy[tmpIndex];\n\
    \               }\n           }\n           else {\n               measure = crossDot*crossDot*invenergy[tmpIndex];\n\
    \           }\n           /* check if measure is better */\n           ftmp =\
    \ crossDot*invenergy[tmpIndex];\n           if ((measure>*max_measure) && (fabs(ftmp)<CB_MAXGAIN))\
    \ {\n               *best_index = tmpIndex;\n               *max_measure = measure;\n\
    \               *gain = ftmp;\n           }\n       }\n   }\n   /*----------------------------------------------------------------*\n\
    \    *  Recreate a specific codebook vector from the augmented part.\n    *\n\
    \    *----------------------------------------------------------------*/\n   void\
    \ createAugmentedVec(\n       int index,      /* (i) Index for the augmented vector\n\
    \                              to be created */\n       float *buffer,  /* (i)\
    \ Pointer to the end of the buffer for\n                              augmented\
    \ codebook construction */\n       float *cbVec/* (o) The construced codebook\
    \ vector */\n   ) {\n       int ilow, j;\n       float *pp, *ppo, *ppi, alfa,\
    \ alfa1, weighted;\n       ilow = index-5;\n       /* copy the first noninterpolated\
    \ part */\n       pp = buffer-index;\n       memcpy(cbVec,pp,sizeof(float)*index);\n\
    \       /* interpolation */\n       alfa1 = (float)0.2;\n       alfa = 0.0;\n\
    \       ppo = buffer-5;\n       ppi = buffer-index-5;\n       for (j=ilow; j<index;\
    \ j++) {\n           weighted = ((float)1.0-alfa)*(*ppo)+alfa*(*ppi);\n      \
    \     ppo++;\n           ppi++;\n           cbVec[j] = weighted;\n           alfa\
    \ += alfa1;\n       }\n       /* copy the second noninterpolated part */\n   \
    \    pp = buffer - index;\n       memcpy(cbVec+index,pp,sizeof(float)*(SUBL-index));\n\
    \   }\n"
- title: A.13.  doCPLC.h
  contents:
  - "A.13.  doCPLC.h\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       doCPLC.h\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #ifndef __iLBC_DOLPC_H\n   #define __iLBC_DOLPC_H\n   void doThePLC(\n   \
    \    float *PLCresidual, /* (o) concealed residual */\n       float *PLClpc, \
    \     /* (o) concealed LP parameters */\n       int PLI,        /* (i) packet\
    \ loss indicator\n                                  0 - no PL, 1 = PL */\n   \
    \    float *decresidual, /* (i) decoded residual */\n       float *lpc,      \
    \   /* (i) decoded LPC (only used for no PL) */\n       int inlag,          /*\
    \ (i) pitch lag */\n       iLBC_Dec_Inst_t *iLBCdec_inst\n                   \
    \        /* (i/o) decoder instance */\n   );\n   #endif\n"
- title: A.14.  doCPLC.c
  contents:
  - "A.14.  doCPLC.c\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       doCPLC.c\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #include <math.h>\n   #include <string.h>\n   #include <stdio.h>\n   #include\
    \ \"iLBC_define.h\"\n   /*----------------------------------------------------------------*\n\
    \    *  Compute cross correlation and pitch gain for pitch prediction\n    * \
    \ of last subframe at given lag.\n    *---------------------------------------------------------------*/\n\
    \   void compCorr(\n       float *cc,      /* (o) cross correlation coefficient\
    \ */\n       float *gc,      /* (o) gain */\n       float *pm,\n       float *buffer,\
    \  /* (i) signal buffer */\n       int lag,    /* (i) pitch lag */\n       int\
    \ bLen,       /* (i) length of buffer */\n       int sRange      /* (i) correlation\
    \ search length */\n   ){\n       int i;\n       float ftmp1, ftmp2, ftmp3;\n\
    \       /* Guard against getting outside buffer */\n       if ((bLen-sRange-lag)<0)\
    \ {\n           sRange=bLen-lag;\n       }\n       ftmp1 = 0.0;\n       ftmp2\
    \ = 0.0;\n       ftmp3 = 0.0;\n       for (i=0; i<sRange; i++) {\n           ftmp1\
    \ += buffer[bLen-sRange+i] *\n               buffer[bLen-sRange+i-lag];\n    \
    \       ftmp2 += buffer[bLen-sRange+i-lag] *\n                   buffer[bLen-sRange+i-lag];\n\
    \           ftmp3 += buffer[bLen-sRange+i] *\n                   buffer[bLen-sRange+i];\n\
    \       }\n       if (ftmp2 > 0.0) {\n           *cc = ftmp1*ftmp1/ftmp2;\n  \
    \         *gc = (float)fabs(ftmp1/ftmp2);\n           *pm=(float)fabs(ftmp1)/\n\
    \               ((float)sqrt(ftmp2)*(float)sqrt(ftmp3));\n       }\n       else\
    \ {\n           *cc = 0.0;\n           *gc = 0.0;\n           *pm=0.0;\n     \
    \  }\n   }\n   /*----------------------------------------------------------------*\n\
    \    *  Packet loss concealment routine. Conceals a residual signal\n    *  and\
    \ LP parameters. If no packet loss, update state.\n    *---------------------------------------------------------------*/\n\
    \   void doThePLC(\n       float *PLCresidual, /* (o) concealed residual */\n\
    \       float *PLClpc,      /* (o) concealed LP parameters */\n       int PLI,\
    \        /* (i) packet loss indicator\n                                  0 - no\
    \ PL, 1 = PL */\n       float *decresidual, /* (i) decoded residual */\n     \
    \  float *lpc,         /* (i) decoded LPC (only used for no PL) */\n       int\
    \ inlag,          /* (i) pitch lag */\n       iLBC_Dec_Inst_t *iLBCdec_inst\n\
    \                           /* (i/o) decoder instance */\n   ){\n       int lag=20,\
    \ randlag;\n       float gain, maxcc;\n       float use_gain;\n       float gain_comp,\
    \ maxcc_comp, per, max_per;\n       int i, pick, use_lag;\n       float ftmp,\
    \ randvec[BLOCKL_MAX], pitchfact, energy;\n       /* Packet Loss */\n       if\
    \ (PLI == 1) {\n           iLBCdec_inst->consPLICount += 1;\n           /* if\
    \ previous frame not lost,\n              determine pitch pred. gain */\n    \
    \       if (iLBCdec_inst->prevPLI != 1) {\n               /* Search around the\
    \ previous lag to find the\n                  best pitch period */\n         \
    \      lag=inlag-3;\n               compCorr(&maxcc, &gain, &max_per,\n      \
    \             iLBCdec_inst->prevResidual,\n                   lag, iLBCdec_inst->blockl,\
    \ 60);\n               for (i=inlag-2;i<=inlag+3;i++) {\n                   compCorr(&maxcc_comp,\
    \ &gain_comp, &per,\n                       iLBCdec_inst->prevResidual,\n    \
    \                   i, iLBCdec_inst->blockl, 60);\n                   if (maxcc_comp>maxcc)\
    \ {\n                       maxcc=maxcc_comp;\n                       gain=gain_comp;\n\
    \                       lag=i;\n                       max_per=per;\n        \
    \           }\n               }\n           }\n           /* previous frame lost,\
    \ use recorded lag and periodicity */\n           else {\n               lag=iLBCdec_inst->prevLag;\n\
    \               max_per=iLBCdec_inst->per;\n           }\n           /* downscaling\
    \ */\n           use_gain=1.0;\n           if (iLBCdec_inst->consPLICount*iLBCdec_inst->blockl>320)\n\
    \               use_gain=(float)0.9;\n           else if (iLBCdec_inst->consPLICount*\n\
    \                           iLBCdec_inst->blockl>2*320)\n               use_gain=(float)0.7;\n\
    \           else if (iLBCdec_inst->consPLICount*\n                           iLBCdec_inst->blockl>3*320)\n\
    \               use_gain=(float)0.5;\n           else if (iLBCdec_inst->consPLICount*\n\
    \                           iLBCdec_inst->blockl>4*320)\n               use_gain=(float)0.0;\n\
    \           /* mix noise and pitch repeatition */\n           ftmp=(float)sqrt(max_per);\n\
    \           if (ftmp>(float)0.7)\n               pitchfact=(float)1.0;\n     \
    \      else if (ftmp>(float)0.4)\n               pitchfact=(ftmp-(float)0.4)/((float)0.7-(float)0.4);\n\
    \           else\n               pitchfact=0.0;\n           /* avoid repetition\
    \ of same pitch cycle */\n           use_lag=lag;\n           if (lag<80) {\n\
    \               use_lag=2*lag;\n           }\n           /* compute concealed\
    \ residual */\n           energy = 0.0;\n           for (i=0; i<iLBCdec_inst->blockl;\
    \ i++) {\n               /* noise component */\n               iLBCdec_inst->seed=(iLBCdec_inst->seed*69069L+1)\
    \ &\n                   (0x80000000L-1);\n               randlag = 50 + ((signed\
    \ long) iLBCdec_inst->seed)%70;\n               pick = i - randlag;\n        \
    \       if (pick < 0) {\n                   randvec[i] =\n                   \
    \    iLBCdec_inst->prevResidual[\n                                   iLBCdec_inst->blockl+pick];\n\
    \               } else {\n                   randvec[i] =  randvec[pick];\n  \
    \             }\n               /* pitch repeatition component */\n          \
    \     pick = i - use_lag;\n               if (pick < 0) {\n                  \
    \ PLCresidual[i] =\n                       iLBCdec_inst->prevResidual[\n     \
    \                              iLBCdec_inst->blockl+pick];\n               } else\
    \ {\n                   PLCresidual[i] = PLCresidual[pick];\n               }\n\
    \               /* mix random and periodicity component */\n               if\
    \ (i<80)\n                   PLCresidual[i] = use_gain*(pitchfact *\n        \
    \                       PLCresidual[i] +\n                               ((float)1.0\
    \ - pitchfact) * randvec[i]);\n               else if (i<160)\n              \
    \     PLCresidual[i] = (float)0.95*use_gain*(pitchfact *\n                   \
    \            PLCresidual[i] +\n                               ((float)1.0 - pitchfact)\
    \ * randvec[i]);\n               else\n                   PLCresidual[i] = (float)0.9*use_gain*(pitchfact\
    \ *\n                               PLCresidual[i] +\n                       \
    \        ((float)1.0 - pitchfact) * randvec[i]);\n               energy += PLCresidual[i]\
    \ * PLCresidual[i];\n           }\n           /* less than 30 dB, use only noise\
    \ */\n           if (sqrt(energy/(float)iLBCdec_inst->blockl) < 30.0) {\n    \
    \           gain=0.0;\n               for (i=0; i<iLBCdec_inst->blockl; i++) {\n\
    \                   PLCresidual[i] = randvec[i];\n               }\n         \
    \  }\n           /* use old LPC */\n           memcpy(PLClpc,iLBCdec_inst->prevLpc,\n\
    \               (LPC_FILTERORDER+1)*sizeof(float));\n       }\n       /* no packet\
    \ loss, copy input */\n       else {\n           memcpy(PLCresidual, decresidual,\n\
    \               iLBCdec_inst->blockl*sizeof(float));\n           memcpy(PLClpc,\
    \ lpc, (LPC_FILTERORDER+1)*sizeof(float));\n           iLBCdec_inst->consPLICount\
    \ = 0;\n       }\n       /* update state */\n       if (PLI) {\n           iLBCdec_inst->prevLag\
    \ = lag;\n           iLBCdec_inst->per=max_per;\n       }\n       iLBCdec_inst->prevPLI\
    \ = PLI;\n       memcpy(iLBCdec_inst->prevLpc, PLClpc,\n           (LPC_FILTERORDER+1)*sizeof(float));\n\
    \       memcpy(iLBCdec_inst->prevResidual, PLCresidual,\n           iLBCdec_inst->blockl*sizeof(float));\n\
    \   }\n"
- title: A.15.  enhancer.h
  contents:
  - "A.15.  enhancer.h\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       enhancer.h\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #ifndef __ENHANCER_H\n   #define __ENHANCER_H\n   #include \"iLBC_define.h\"\
    \n   float xCorrCoef(\n       float *target,      /* (i) first array */\n    \
    \   float *regressor,   /* (i) second array */\n       int subl        /* (i)\
    \ dimension arrays */\n   );\n   int enhancerInterface(\n       float *out,  \
    \       /* (o) the enhanced recidual signal */\n       float *in,          /*\
    \ (i) the recidual signal to enhance */\n       iLBC_Dec_Inst_t *iLBCdec_inst\n\
    \                           /* (i/o) the decoder state structure */\n   );\n \
    \  #endif\n"
- title: A.16.  enhancer.c
  contents:
  - "A.16.  enhancer.c\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       enhancer.c\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #include <math.h>\n   #include <string.h>\n   #include \"iLBC_define.h\"\n\
    \   #include \"constants.h\"\n   #include \"filter.h\"\n   /*----------------------------------------------------------------*\n\
    \    * Find index in array such that the array element with said\n    * index\
    \ is the element of said array closest to \"value\"\n    * according to the squared-error\
    \ criterion\n    *---------------------------------------------------------------*/\n\
    \   void NearestNeighbor(\n       int   *index,   /* (o) index of array element\
    \ closest\n                              to value */\n       float *array,   /*\
    \ (i) data array */\n       float value,/* (i) value */\n       int arlength/*\
    \ (i) dimension of data array */\n   ){\n       int i;\n       float bestcrit,crit;\n\
    \       crit=array[0]-value;\n       bestcrit=crit*crit;\n       *index=0;\n \
    \      for (i=1; i<arlength; i++) {\n           crit=array[i]-value;\n       \
    \    crit=crit*crit;\n           if (crit<bestcrit) {\n               bestcrit=crit;\n\
    \               *index=i;\n           }\n       }\n   }\n   /*----------------------------------------------------------------*\n\
    \    * compute cross correlation between sequences\n    *---------------------------------------------------------------*/\n\
    \   void mycorr1(\n       float* corr,    /* (o) correlation of seq1 and seq2\
    \ */\n       float* seq1,    /* (i) first sequence */\n       int dim1,      \
    \     /* (i) dimension first seq1 */\n       const float *seq2,  /* (i) second\
    \ sequence */\n       int dim2        /* (i) dimension seq2 */\n   ){\n      \
    \ int i,j;\n       for (i=0; i<=dim1-dim2; i++) {\n           corr[i]=0.0;\n \
    \          for (j=0; j<dim2; j++) {\n               corr[i] += seq1[i+j] * seq2[j];\n\
    \           }\n       }\n   }\n   /*----------------------------------------------------------------*\n\
    \    * upsample finite array assuming zeros outside bounds\n    *---------------------------------------------------------------*/\n\
    \   void enh_upsample(\n       float* useq1,   /* (o) upsampled output sequence\
    \ */\n       float* seq1,/* (i) unupsampled sequence */\n       int dim1,    \
    \   /* (i) dimension seq1 */\n       int hfl         /* (i) polyphase filter length=2*hfl+1\
    \ */\n   ){\n       float *pu,*ps;\n       int i,j,k,q,filterlength,hfl2;\n  \
    \     const float *polyp[ENH_UPS0]; /* pointers to\n                         \
    \               polyphase columns */\n       const float *pp;\n       /* define\
    \ pointers for filter */\n       filterlength=2*hfl+1;\n       if ( filterlength\
    \ > dim1 ) {\n           hfl2=(int) (dim1/2);\n           for (j=0; j<ENH_UPS0;\
    \ j++) {\n               polyp[j]=polyphaserTbl+j*filterlength+hfl-hfl2;\n   \
    \        }\n           hfl=hfl2;\n           filterlength=2*hfl+1;\n       }\n\
    \       else {\n           for (j=0; j<ENH_UPS0; j++) {\n               polyp[j]=polyphaserTbl+j*filterlength;\n\
    \           }\n       }\n       /* filtering: filter overhangs left side of sequence\
    \ */\n       pu=useq1;\n       for (i=hfl; i<filterlength; i++) {\n          \
    \ for (j=0; j<ENH_UPS0; j++) {\n               *pu=0.0;\n               pp = polyp[j];\n\
    \               ps = seq1+i;\n               for (k=0; k<=i; k++) {\n        \
    \           *pu += *ps-- * *pp++;\n               }\n               pu++;\n  \
    \         }\n       }\n       /* filtering: simple convolution=inner products\
    \ */\n       for (i=filterlength; i<dim1; i++) {\n           for (j=0;j<ENH_UPS0;\
    \ j++){\n               *pu=0.0;\n               pp = polyp[j];\n            \
    \   ps = seq1+i;\n               for (k=0; k<filterlength; k++) {\n          \
    \         *pu += *ps-- * *pp++;\n               }\n               pu++;\n    \
    \       }\n       }\n       /* filtering: filter overhangs right side of sequence\
    \ */\n       for (q=1; q<=hfl; q++) {\n           for (j=0; j<ENH_UPS0; j++) {\n\
    \               *pu=0.0;\n               pp = polyp[j]+q;\n               ps =\
    \ seq1+dim1-1;\n               for (k=0; k<filterlength-q; k++) {\n          \
    \         *pu += *ps-- * *pp++;\n               }\n               pu++;\n    \
    \       }\n       }\n   }\n   /*----------------------------------------------------------------*\n\
    \    * find segment starting near idata+estSegPos that has highest\n    * correlation\
    \ with idata+centerStartPos through\n    * idata+centerStartPos+ENH_BLOCKL-1 segment\
    \ is found at a\n    * resolution of ENH_UPSO times the original of the original\n\
    \    * sampling rate\n    *---------------------------------------------------------------*/\n\
    \   void refiner(\n       float *seg,         /* (o) segment array */\n      \
    \ float *updStartPos, /* (o) updated start point */\n       float* idata,    \
    \   /* (i) original data buffer */\n       int idatal,         /* (i) dimension\
    \ of idata */\n       int centerStartPos, /* (i) beginning center segment */\n\
    \       float estSegPos,/* (i) estimated beginning other segment */\n       float\
    \ period    /* (i) estimated pitch period */\n   ){\n       int estSegPosRounded,searchSegStartPos,searchSegEndPos,corrdim;\n\
    \       int tloc,tloc2,i,st,en,fraction;\n       float vect[ENH_VECTL],corrVec[ENH_CORRDIM],maxv;\n\
    \       float corrVecUps[ENH_CORRDIM*ENH_UPS0];\n       /* defining array bounds\
    \ */\n       estSegPosRounded=(int)(estSegPos - 0.5);\n       searchSegStartPos=estSegPosRounded-ENH_SLOP;\n\
    \       if (searchSegStartPos<0) {\n           searchSegStartPos=0;\n       }\n\
    \       searchSegEndPos=estSegPosRounded+ENH_SLOP;\n       if (searchSegEndPos+ENH_BLOCKL\
    \ >= idatal) {\n           searchSegEndPos=idatal-ENH_BLOCKL-1;\n       }\n  \
    \     corrdim=searchSegEndPos-searchSegStartPos+1;\n       /* compute upsampled\
    \ correlation (corr33) and find\n          location of max */\n       mycorr1(corrVec,idata+searchSegStartPos,\n\
    \           corrdim+ENH_BLOCKL-1,idata+centerStartPos,ENH_BLOCKL);\n       enh_upsample(corrVecUps,corrVec,corrdim,ENH_FL0);\n\
    \       tloc=0; maxv=corrVecUps[0];\n       for (i=1; i<ENH_UPS0*corrdim; i++)\
    \ {\n           if (corrVecUps[i]>maxv) {\n               tloc=i;\n          \
    \     maxv=corrVecUps[i];\n           }\n       }\n       /* make vector can be\
    \ upsampled without ever running outside\n          bounds */\n       *updStartPos=\
    \ (float)searchSegStartPos +\n           (float)tloc/(float)ENH_UPS0+(float)1.0;\n\
    \       tloc2=(int)(tloc/ENH_UPS0);\n       if (tloc>tloc2*ENH_UPS0) {\n     \
    \      tloc2++;\n       }\n       st=searchSegStartPos+tloc2-ENH_FL0;\n      \
    \ if (st<0) {\n           memset(vect,0,-st*sizeof(float));\n           memcpy(&vect[-st],idata,\
    \ (ENH_VECTL+st)*sizeof(float));\n       }\n       else {\n           en=st+ENH_VECTL;\n\
    \           if (en>idatal) {\n               memcpy(vect, &idata[st],\n      \
    \             (ENH_VECTL-(en-idatal))*sizeof(float));\n               memset(&vect[ENH_VECTL-(en-idatal)],\
    \ 0,\n                   (en-idatal)*sizeof(float));\n           }\n         \
    \  else {\n               memcpy(vect, &idata[st], ENH_VECTL*sizeof(float));\n\
    \           }\n       }\n       fraction=tloc2*ENH_UPS0-tloc;\n       /* compute\
    \ the segment (this is actually a convolution) */\n       mycorr1(seg,vect,ENH_VECTL,polyphaserTbl+(2*ENH_FL0+1)*fraction,\n\
    \           2*ENH_FL0+1);\n   }\n   /*----------------------------------------------------------------*\n\
    \    * find the smoothed output data\n    *---------------------------------------------------------------*/\n\
    \   void smath(\n       float *odata,   /* (o) smoothed output */\n       float\
    \ *sseq,/* (i) said second sequence of waveforms */\n       int hl,         /*\
    \ (i) 2*hl+1 is sseq dimension */\n       float alpha0/* (i) max smoothing energy\
    \ fraction */\n   ){\n       int i,k;\n       float w00,w10,w11,A,B,C,*psseq,err,errs;\n\
    \       float surround[BLOCKL_MAX]; /* shape contributed by other than\n     \
    \                                 current */\n       float wt[2*ENH_HL+1];   \
    \    /* waveform weighting to get\n                                      surround\
    \ shape */\n       float denom;\n       /* create shape of contribution from all\
    \ waveforms except the\n          current one */\n       for (i=1; i<=2*hl+1;\
    \ i++) {\n           wt[i-1] = (float)0.5*(1 - (float)cos(2*PI*i/(2*hl+2)));\n\
    \       }\n       wt[hl]=0.0; /* for clarity, not used */\n       for (i=0; i<ENH_BLOCKL;\
    \ i++) {\n           surround[i]=sseq[i]*wt[0];\n       }\n       for (k=1; k<hl;\
    \ k++) {\n           psseq=sseq+k*ENH_BLOCKL;\n           for(i=0;i<ENH_BLOCKL;\
    \ i++) {\n               surround[i]+=psseq[i]*wt[k];\n           }\n       }\n\
    \       for (k=hl+1; k<=2*hl; k++) {\n           psseq=sseq+k*ENH_BLOCKL;\n  \
    \         for(i=0;i<ENH_BLOCKL; i++) {\n               surround[i]+=psseq[i]*wt[k];\n\
    \           }\n       }\n       /* compute some inner products */\n       w00\
    \ = w10 = w11 = 0.0;\n       psseq=sseq+hl*ENH_BLOCKL; /* current block  */\n\
    \       for (i=0; i<ENH_BLOCKL;i++) {\n           w00+=psseq[i]*psseq[i];\n  \
    \         w11+=surround[i]*surround[i];\n           w10+=surround[i]*psseq[i];\n\
    \       }\n       if (fabs(w11) < 1.0) {\n           w11=1.0;\n       }\n    \
    \   C = (float)sqrt( w00/w11);\n       /* first try enhancement without power-constraint\
    \ */\n       errs=0.0;\n       psseq=sseq+hl*ENH_BLOCKL;\n       for (i=0; i<ENH_BLOCKL;\
    \ i++) {\n           odata[i]=C*surround[i];\n           err=psseq[i]-odata[i];\n\
    \           errs+=err*err;\n       }\n       /* if constraint violated by first\
    \ try, add constraint */\n       if (errs > alpha0 * w00) {\n           if ( w00\
    \ < 1) {\n               w00=1;\n           }\n           denom = (w11*w00-w10*w10)/(w00*w00);\n\
    \           if (denom > 0.0001) { /* eliminates numerical problems\n         \
    \                           for if smooth */\n               A = (float)sqrt(\
    \ (alpha0- alpha0*alpha0/4)/denom);\n               B = -alpha0/2 - A * w10/w00;\n\
    \               B = B+1;\n           }\n           else { /* essentially no difference\
    \ between cycles;\n                     smoothing not needed */\n            \
    \   A= 0.0;\n               B= 1.0;\n           }\n           /* create smoothed\
    \ sequence */\n           psseq=sseq+hl*ENH_BLOCKL;\n           for (i=0; i<ENH_BLOCKL;\
    \ i++) {\n               odata[i]=A*surround[i]+B*psseq[i];\n           }\n  \
    \     }\n   }\n   /*----------------------------------------------------------------*\n\
    \    * get the pitch-synchronous sample sequence\n    *---------------------------------------------------------------*/\n\
    \   void getsseq(\n       float *sseq,    /* (o) the pitch-synchronous sequence\
    \ */\n       float *idata,       /* (i) original data */\n       int idatal, \
    \        /* (i) dimension of data */\n       int centerStartPos, /* (i) where\
    \ current block starts */\n       float *period,      /* (i) rough-pitch-period\
    \ array */\n       float *plocs,       /* (i) where periods of period array\n\
    \                                  are taken */\n       int periodl,    /* (i)\
    \ dimension period array */\n       int hl              /* (i) 2*hl+1 is the number\
    \ of sequences */\n   ){\n       int i,centerEndPos,q;\n       float blockStartPos[2*ENH_HL+1];\n\
    \       int lagBlock[2*ENH_HL+1];\n       float plocs2[ENH_PLOCSL];\n       float\
    \ *psseq;\n       centerEndPos=centerStartPos+ENH_BLOCKL-1;\n       /* present\
    \ */\n       NearestNeighbor(lagBlock+hl,plocs,\n           (float)0.5*(centerStartPos+centerEndPos),periodl);\n\
    \       blockStartPos[hl]=(float)centerStartPos;\n       psseq=sseq+ENH_BLOCKL*hl;\n\
    \       memcpy(psseq, idata+centerStartPos, ENH_BLOCKL*sizeof(float));\n     \
    \  /* past */\n       for (q=hl-1; q>=0; q--) {\n           blockStartPos[q]=blockStartPos[q+1]-period[lagBlock[q+1]];\n\
    \           NearestNeighbor(lagBlock+q,plocs,\n               blockStartPos[q]+\n\
    \               ENH_BLOCKL_HALF-period[lagBlock[q+1]], periodl);\n           if\
    \ (blockStartPos[q]-ENH_OVERHANG>=0) {\n               refiner(sseq+q*ENH_BLOCKL,\
    \ blockStartPos+q, idata,\n                   idatal, centerStartPos, blockStartPos[q],\n\
    \                   period[lagBlock[q+1]]);\n           } else {\n           \
    \    psseq=sseq+q*ENH_BLOCKL;\n               memset(psseq, 0, ENH_BLOCKL*sizeof(float));\n\
    \           }\n       }\n       /* future */\n       for (i=0; i<periodl; i++)\
    \ {\n           plocs2[i]=plocs[i]-period[i];\n       }\n       for (q=hl+1; q<=2*hl;\
    \ q++) {\n           NearestNeighbor(lagBlock+q,plocs2,\n               blockStartPos[q-1]+ENH_BLOCKL_HALF,periodl);\n\
    \           blockStartPos[q]=blockStartPos[q-1]+period[lagBlock[q]];\n       \
    \    if (blockStartPos[q]+ENH_BLOCKL+ENH_OVERHANG<idatal) {\n               refiner(sseq+ENH_BLOCKL*q,\
    \ blockStartPos+q, idata,\n                   idatal, centerStartPos, blockStartPos[q],\n\
    \                   period[lagBlock[q]]);\n           }\n           else {\n \
    \              psseq=sseq+q*ENH_BLOCKL;\n               memset(psseq, 0, ENH_BLOCKL*sizeof(float));\n\
    \           }\n       }\n   }\n   /*----------------------------------------------------------------*\n\
    \    * perform enhancement on idata+centerStartPos through\n    * idata+centerStartPos+ENH_BLOCKL-1\n\
    \    *---------------------------------------------------------------*/\n   void\
    \ enhancer(\n       float *odata,       /* (o) smoothed block, dimension blockl\
    \ */\n       float *idata,       /* (i) data buffer used for enhancing */\n  \
    \     int idatal,         /* (i) dimension idata */\n       int centerStartPos,\
    \ /* (i) first sample current block\n                                  within\
    \ idata */\n       float alpha0,       /* (i) max correction-energy-fraction\n\
    \                                 (in [0,1]) */\n       float *period,      /*\
    \ (i) pitch period array */\n       float *plocs,       /* (i) locations where\
    \ period array\n                                  values valid */\n       int\
    \ periodl         /* (i) dimension of period and plocs */\n   ){\n       float\
    \ sseq[(2*ENH_HL+1)*ENH_BLOCKL];\n       /* get said second sequence of segments\
    \ */\n       getsseq(sseq,idata,idatal,centerStartPos,period,\n           plocs,periodl,ENH_HL);\n\
    \       /* compute the smoothed output from said second sequence */\n       smath(odata,sseq,ENH_HL,alpha0);\n\
    \   }\n   /*----------------------------------------------------------------*\n\
    \    * cross correlation\n    *---------------------------------------------------------------*/\n\
    \   float xCorrCoef(\n       float *target,      /* (i) first array */\n     \
    \  float *regressor,   /* (i) second array */\n       int subl        /* (i) dimension\
    \ arrays */\n   ){\n       int i;\n       float ftmp1, ftmp2;\n       ftmp1 =\
    \ 0.0;\n       ftmp2 = 0.0;\n       for (i=0; i<subl; i++) {\n           ftmp1\
    \ += target[i]*regressor[i];\n           ftmp2 += regressor[i]*regressor[i];\n\
    \       }\n       if (ftmp1 > 0.0) {\n           return (float)(ftmp1*ftmp1/ftmp2);\n\
    \       }\n       else {\n           return (float)0.0;\n       }\n   }\n   /*----------------------------------------------------------------*\n\
    \    * interface for enhancer\n    *---------------------------------------------------------------*/\n\
    \   int enhancerInterface(\n       float *out,                     /* (o) enhanced\
    \ signal */\n       float *in,                      /* (i) unenhanced signal */\n\
    \       iLBC_Dec_Inst_t *iLBCdec_inst   /* (i) buffers etc */\n   ){\n       float\
    \ *enh_buf, *enh_period;\n       int iblock, isample;\n       int lag=0, ilag,\
    \ i, ioffset;\n       float cc, maxcc;\n       float ftmp1, ftmp2;\n       float\
    \ *inPtr, *enh_bufPtr1, *enh_bufPtr2;\n       float plc_pred[ENH_BLOCKL];\n  \
    \     float lpState[6], downsampled[(ENH_NBLOCKS*ENH_BLOCKL+120)/2];\n       int\
    \ inLen=ENH_NBLOCKS*ENH_BLOCKL+120;\n       int start, plc_blockl, inlag;\n  \
    \     enh_buf=iLBCdec_inst->enh_buf;\n       enh_period=iLBCdec_inst->enh_period;\n\
    \       memmove(enh_buf, &enh_buf[iLBCdec_inst->blockl],\n           (ENH_BUFL-iLBCdec_inst->blockl)*sizeof(float));\n\
    \       memcpy(&enh_buf[ENH_BUFL-iLBCdec_inst->blockl], in,\n           iLBCdec_inst->blockl*sizeof(float));\n\
    \       if (iLBCdec_inst->mode==30)\n           plc_blockl=ENH_BLOCKL;\n     \
    \  else\n           plc_blockl=40;\n       /* when 20 ms frame, move processing\
    \ one block */\n       ioffset=0;\n       if (iLBCdec_inst->mode==20) ioffset=1;\n\
    \       i=3-ioffset;\n       memmove(enh_period, &enh_period[i],\n           (ENH_NBLOCKS_TOT-i)*sizeof(float));\n\
    \       /* Set state information to the 6 samples right before\n          the\
    \ samples to be downsampled. */\n       memcpy(lpState,\n           enh_buf+(ENH_NBLOCKS_EXTRA+ioffset)*ENH_BLOCKL-126,\n\
    \           6*sizeof(float));\n       /* Down sample a factor 2 to save computations\
    \ */\n       DownSample(enh_buf+(ENH_NBLOCKS_EXTRA+ioffset)*ENH_BLOCKL-120,\n\
    \                   lpFilt_coefsTbl, inLen-ioffset*ENH_BLOCKL,\n             \
    \      lpState, downsampled);\n       /* Estimate the pitch in the down sampled\
    \ domain. */\n       for (iblock = 0; iblock<ENH_NBLOCKS-ioffset; iblock++) {\n\
    \           lag = 10;\n           maxcc = xCorrCoef(downsampled+60+iblock*\n \
    \              ENH_BLOCKL_HALF, downsampled+60+iblock*\n               ENH_BLOCKL_HALF-lag,\
    \ ENH_BLOCKL_HALF);\n           for (ilag=11; ilag<60; ilag++) {\n           \
    \    cc = xCorrCoef(downsampled+60+iblock*\n                   ENH_BLOCKL_HALF,\
    \ downsampled+60+iblock*\n                   ENH_BLOCKL_HALF-ilag, ENH_BLOCKL_HALF);\n\
    \               if (cc > maxcc) {\n                   maxcc = cc;\n          \
    \         lag = ilag;\n               }\n           }\n           /* Store the\
    \ estimated lag in the non-downsampled domain */\n           enh_period[iblock+ENH_NBLOCKS_EXTRA+ioffset]\
    \ = (float)lag*2;\n       }\n       /* PLC was performed on the previous packet\
    \ */\n       if (iLBCdec_inst->prev_enh_pl==1) {\n           inlag=(int)enh_period[ENH_NBLOCKS_EXTRA+ioffset];\n\
    \           lag = inlag-1;\n           maxcc = xCorrCoef(in, in+lag, plc_blockl);\n\
    \           for (ilag=inlag; ilag<=inlag+1; ilag++) {\n               cc = xCorrCoef(in,\
    \ in+ilag, plc_blockl);\n               if (cc > maxcc) {\n                  \
    \ maxcc = cc;\n                   lag = ilag;\n               }\n           }\n\
    \           enh_period[ENH_NBLOCKS_EXTRA+ioffset-1]=(float)lag;\n           /*\
    \ compute new concealed residual for the old lookahead,\n              mix the\
    \ forward PLC with a backward PLC from\n              the new frame */\n     \
    \      inPtr=&in[lag-1];\n           enh_bufPtr1=&plc_pred[plc_blockl-1];\n  \
    \         if (lag>plc_blockl) {\n               start=plc_blockl;\n          \
    \ } else {\n               start=lag;\n           }\n           for (isample =\
    \ start; isample>0; isample--) {\n               *enh_bufPtr1-- = *inPtr--;\n\
    \           }\n           enh_bufPtr2=&enh_buf[ENH_BUFL-1-iLBCdec_inst->blockl];\n\
    \           for (isample = (plc_blockl-1-lag); isample>=0; isample--) {\n    \
    \           *enh_bufPtr1-- = *enh_bufPtr2--;\n           }\n           /* limit\
    \ energy change */\n           ftmp2=0.0;\n           ftmp1=0.0;\n           for\
    \ (i=0;i<plc_blockl;i++) {\n               ftmp2+=enh_buf[ENH_BUFL-1-iLBCdec_inst->blockl-i]*\n\
    \                   enh_buf[ENH_BUFL-1-iLBCdec_inst->blockl-i];\n            \
    \   ftmp1+=plc_pred[i]*plc_pred[i];\n           }\n           ftmp1=(float)sqrt(ftmp1/(float)plc_blockl);\n\
    \           ftmp2=(float)sqrt(ftmp2/(float)plc_blockl);\n           if (ftmp1>(float)2.0*ftmp2\
    \ && ftmp1>0.0) {\n               for (i=0;i<plc_blockl-10;i++) {\n          \
    \         plc_pred[i]*=(float)2.0*ftmp2/ftmp1;\n               }\n           \
    \    for (i=plc_blockl-10;i<plc_blockl;i++) {\n                   plc_pred[i]*=(float)(i-plc_blockl+10)*\n\
    \                       ((float)1.0-(float)2.0*ftmp2/ftmp1)/(float)(10)+\n   \
    \                    (float)2.0*ftmp2/ftmp1;\n               }\n           }\n\
    \           enh_bufPtr1=&enh_buf[ENH_BUFL-1-iLBCdec_inst->blockl];\n         \
    \  for (i=0; i<plc_blockl; i++) {\n               ftmp1 = (float) (i+1) / (float)\
    \ (plc_blockl+1);\n               *enh_bufPtr1 *= ftmp1;\n               *enh_bufPtr1\
    \ += ((float)1.0-ftmp1)*\n                                   plc_pred[plc_blockl-1-i];\n\
    \               enh_bufPtr1--;\n           }\n       }\n       if (iLBCdec_inst->mode==20)\
    \ {\n           /* Enhancer with 40 samples delay */\n           for (iblock =\
    \ 0; iblock<2; iblock++) {\n               enhancer(out+iblock*ENH_BLOCKL, enh_buf,\n\
    \                   ENH_BUFL, (5+iblock)*ENH_BLOCKL+40,\n                   ENH_ALPHA0,\
    \ enh_period, enh_plocsTbl,\n                       ENH_NBLOCKS_TOT);\n      \
    \     }\n       } else if (iLBCdec_inst->mode==30) {\n           /* Enhancer with\
    \ 80 samples delay */\n           for (iblock = 0; iblock<3; iblock++) {\n   \
    \            enhancer(out+iblock*ENH_BLOCKL, enh_buf,\n                   ENH_BUFL,\
    \ (4+iblock)*ENH_BLOCKL,\n                   ENH_ALPHA0, enh_period, enh_plocsTbl,\n\
    \                       ENH_NBLOCKS_TOT);\n           }\n       }\n       return\
    \ (lag*2);\n   }\n"
- title: A.17.  filter.h
  contents:
  - "A.17.  filter.h\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       filter.h\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #ifndef __iLBC_FILTER_H\n   #define __iLBC_FILTER_H\n   void AllPoleFilter(\n\
    \       float *InOut,   /* (i/o) on entrance InOut[-orderCoef] to\n          \
    \                    InOut[-1] contain the state of the\n                    \
    \          filter (delayed samples). InOut[0] to\n                           \
    \   InOut[lengthInOut-1] contain the filter\n                              input,\
    \ on en exit InOut[-orderCoef] to\n                              InOut[-1] is\
    \ unchanged and InOut[0] to\n                              InOut[lengthInOut-1]\
    \ contain filtered\n                              samples */\n       float *Coef,/*\
    \ (i) filter coefficients, Coef[0] is assumed\n                              to\
    \ be 1.0 */\n       int lengthInOut,/* (i) number of input/output samples */\n\
    \       int orderCoef   /* (i) number of filter coefficients */\n   );\n   void\
    \ AllZeroFilter(\n       float *In,      /* (i) In[0] to In[lengthInOut-1] contain\n\
    \                              filter input samples */\n       float *Coef,/*\
    \ (i) filter coefficients (Coef[0] is assumed\n                              to\
    \ be 1.0) */\n       int lengthInOut,/* (i) number of input/output samples */\n\
    \       int orderCoef,  /* (i) number of filter coefficients */\n       float\
    \ *Out      /* (i/o) on entrance Out[-orderCoef] to Out[-1]\n                \
    \              contain the filter state, on exit Out[0]\n                    \
    \          to Out[lengthInOut-1] contain filtered\n                          \
    \    samples */\n   );\n   void ZeroPoleFilter(\n       float *In,      /* (i)\
    \ In[0] to In[lengthInOut-1] contain filter\n                              input\
    \ samples In[-orderCoef] to In[-1]\n                              contain state\
    \ of all-zero section */\n       float *ZeroCoef,/* (i) filter coefficients for\
    \ all-zero\n                              section (ZeroCoef[0] is assumed to\n\
    \                              be 1.0) */\n       float *PoleCoef,/* (i) filter\
    \ coefficients for all-pole section\n                              (ZeroCoef[0]\
    \ is assumed to be 1.0) */\n       int lengthInOut,/* (i) number of input/output\
    \ samples */\n       int orderCoef,  /* (i) number of filter coefficients */\n\
    \       float *Out      /* (i/o) on entrance Out[-orderCoef] to Out[-1]\n    \
    \                          contain state of all-pole section. On\n           \
    \                   exit Out[0] to Out[lengthInOut-1]\n                      \
    \        contain filtered samples */\n   );\n   void DownSample (\n       float\
    \  *In,     /* (i) input samples */\n       float  *Coef,   /* (i) filter coefficients\
    \ */\n       int lengthIn,   /* (i) number of input samples */\n       float \
    \ *state,  /* (i) filter state */\n       float  *Out     /* (o) downsampled output\
    \ */\n   );\n   #endif\n"
- title: A.18.  filter.c
  contents:
  - "A.18.  filter.c\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       filter.c\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #include \"iLBC_define.h\"\n   /*----------------------------------------------------------------*\n\
    \    *  all-pole filter\n    *---------------------------------------------------------------*/\n\
    \   void AllPoleFilter(\n       float *InOut,   /* (i/o) on entrance InOut[-orderCoef]\
    \ to\n                              InOut[-1] contain the state of the\n     \
    \                         filter (delayed samples). InOut[0] to\n            \
    \                  InOut[lengthInOut-1] contain the filter\n                 \
    \             input, on en exit InOut[-orderCoef] to\n                       \
    \       InOut[-1] is unchanged and InOut[0] to\n                             \
    \ InOut[lengthInOut-1] contain filtered\n                              samples\
    \ */\n       float *Coef,/* (i) filter coefficients, Coef[0] is assumed\n    \
    \                          to be 1.0 */\n       int lengthInOut,/* (i) number\
    \ of input/output samples */\n       int orderCoef   /* (i) number of filter coefficients\
    \ */\n   ){\n       int n,k;\n       for(n=0;n<lengthInOut;n++){\n           for(k=1;k<=orderCoef;k++){\n\
    \               *InOut -= Coef[k]*InOut[-k];\n           }\n           InOut++;\n\
    \       }\n   }\n   /*----------------------------------------------------------------*\n\
    \    *  all-zero filter\n    *---------------------------------------------------------------*/\n\
    \   void AllZeroFilter(\n       float *In,      /* (i) In[0] to In[lengthInOut-1]\
    \ contain\n                              filter input samples */\n       float\
    \ *Coef,/* (i) filter coefficients (Coef[0] is assumed\n                     \
    \         to be 1.0) */\n       int lengthInOut,/* (i) number of input/output\
    \ samples */\n       int orderCoef,  /* (i) number of filter coefficients */\n\
    \       float *Out      /* (i/o) on entrance Out[-orderCoef] to Out[-1]\n    \
    \                          contain the filter state, on exit Out[0]\n        \
    \                      to Out[lengthInOut-1] contain filtered\n              \
    \                samples */\n   ){\n       int n,k;\n       for(n=0;n<lengthInOut;n++){\n\
    \           *Out = Coef[0]*In[0];\n           for(k=1;k<=orderCoef;k++){\n   \
    \            *Out += Coef[k]*In[-k];\n           }\n           Out++;\n      \
    \     In++;\n       }\n   }\n   /*----------------------------------------------------------------*\n\
    \    *  pole-zero filter\n    *---------------------------------------------------------------*/\n\
    \   void ZeroPoleFilter(\n       float *In,      /* (i) In[0] to In[lengthInOut-1]\
    \ contain\n                              filter input samples In[-orderCoef] to\n\
    \                              In[-1] contain state of all-zero\n            \
    \                  section */\n       float *ZeroCoef,/* (i) filter coefficients\
    \ for all-zero\n                              section (ZeroCoef[0] is assumed\
    \ to\n                              be 1.0) */\n       float *PoleCoef,/* (i)\
    \ filter coefficients for all-pole section\n                              (ZeroCoef[0]\
    \ is assumed to be 1.0) */\n       int lengthInOut,/* (i) number of input/output\
    \ samples */\n       int orderCoef,  /* (i) number of filter coefficients */\n\
    \       float *Out      /* (i/o) on entrance Out[-orderCoef] to Out[-1]\n    \
    \                          contain state of all-pole section. On\n           \
    \                   exit Out[0] to Out[lengthInOut-1]\n                      \
    \        contain filtered samples */\n   ){\n       AllZeroFilter(In,ZeroCoef,lengthInOut,orderCoef,Out);\n\
    \       AllPoleFilter(Out,PoleCoef,lengthInOut,orderCoef);\n   }\n   /*----------------------------------------------------------------*\n\
    \    * downsample (LP filter and decimation)\n    *---------------------------------------------------------------*/\n\
    \   void DownSample (\n       float  *In,     /* (i) input samples */\n      \
    \ float  *Coef,   /* (i) filter coefficients */\n       int lengthIn,   /* (i)\
    \ number of input samples */\n       float  *state,  /* (i) filter state */\n\
    \       float  *Out     /* (o) downsampled output */\n   ){\n       float   o;\n\
    \       float *Out_ptr = Out;\n       float *Coef_ptr, *In_ptr;\n       float\
    \ *state_ptr;\n       int i, j, stop;\n       /* LP filter and decimate at the\
    \ same time */\n       for (i = DELAY_DS; i < lengthIn; i+=FACTOR_DS)\n      \
    \ {\n           Coef_ptr = &Coef[0];\n           In_ptr = &In[i];\n          \
    \ state_ptr = &state[FILTERORDER_DS-2];\n           o = (float)0.0;\n        \
    \   stop = (i < FILTERORDER_DS) ? i + 1 : FILTERORDER_DS;\n           for (j =\
    \ 0; j < stop; j++)\n           {\n               o += *Coef_ptr++ * (*In_ptr--);\n\
    \           }\n           for (j = i + 1; j < FILTERORDER_DS; j++)\n         \
    \  {\n               o += *Coef_ptr++ * (*state_ptr--);\n           }\n      \
    \     *Out_ptr++ = o;\n       }\n       /* Get the last part (use zeros as input\
    \ for the future) */\n       for (i=(lengthIn+FACTOR_DS); i<(lengthIn+DELAY_DS);\n\
    \               i+=FACTOR_DS) {\n           o=(float)0.0;\n           if (i<lengthIn)\
    \ {\n               Coef_ptr = &Coef[0];\n               In_ptr = &In[i];\n  \
    \             for (j=0; j<FILTERORDER_DS; j++) {\n                       o +=\
    \ *Coef_ptr++ * (*Out_ptr--);\n               }\n           } else {\n       \
    \        Coef_ptr = &Coef[i-lengthIn];\n               In_ptr = &In[lengthIn-1];\n\
    \               for (j=0; j<FILTERORDER_DS-(i-lengthIn); j++) {\n            \
    \           o += *Coef_ptr++ * (*In_ptr--);\n               }\n           }\n\
    \           *Out_ptr++ = o;\n       }\n   }\n"
- title: A.19.  FrameClassify.h
  contents:
  - "A.19.  FrameClassify.h\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       FrameClassify.h\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #ifndef __iLBC_FRAMECLASSIFY_H\n   #define __iLBC_FRAMECLASSIFY_H\n   int\
    \ FrameClassify(      /* index to the max-energy sub-frame */\n       iLBC_Enc_Inst_t\
    \ *iLBCenc_inst,\n                           /* (i/o) the encoder state structure\
    \ */\n       float *residual     /* (i) lpc residual signal */\n   );\n   #endif\n"
- title: A.20.  FrameClassify.c
  contents:
  - "A.20.  FrameClassify.c\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       FrameClassify.c\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #include \"iLBC_define.h\"\n   /*---------------------------------------------------------------*\n\
    \    *  Classification of subframes to localize start state\n    *--------------------------------------------------------------*/\n\
    \   int FrameClassify(      /* index to the max-energy sub-frame */\n       iLBC_Enc_Inst_t\
    \ *iLBCenc_inst,\n                           /* (i/o) the encoder state structure\
    \ */\n       float *residual     /* (i) lpc residual signal */\n   ) {\n     \
    \  float max_ssqEn, fssqEn[NSUB_MAX], bssqEn[NSUB_MAX], *pp;\n       int n, l,\
    \ max_ssqEn_n;\n       const float ssqEn_win[NSUB_MAX-1]={(float)0.8,(float)0.9,\n\
    \           (float)1.0,(float)0.9,(float)0.8};\n       const float sampEn_win[5]={(float)1.0/(float)6.0,\n\
    \           (float)2.0/(float)6.0, (float)3.0/(float)6.0,\n           (float)4.0/(float)6.0,\
    \ (float)5.0/(float)6.0};\n       /* init the front and back energies to zero\
    \ */\n       memset(fssqEn, 0, NSUB_MAX*sizeof(float));\n       memset(bssqEn,\
    \ 0, NSUB_MAX*sizeof(float));\n       /* Calculate front of first seqence */\n\
    \       n=0;\n       pp=residual;\n       for (l=0; l<5; l++) {\n           fssqEn[n]\
    \ += sampEn_win[l] * (*pp) * (*pp);\n           pp++;\n       }\n       for (l=5;\
    \ l<SUBL; l++) {\n           fssqEn[n] += (*pp) * (*pp);\n           pp++;\n \
    \      }\n       /* Calculate front and back of all middle sequences */\n    \
    \   for (n=1; n<iLBCenc_inst->nsub-1; n++) {\n           pp=residual+n*SUBL;\n\
    \           for (l=0; l<5; l++) {\n               fssqEn[n] += sampEn_win[l] *\
    \ (*pp) * (*pp);\n               bssqEn[n] += (*pp) * (*pp);\n               pp++;\n\
    \           }\n           for (l=5; l<SUBL-5; l++) {\n               fssqEn[n]\
    \ += (*pp) * (*pp);\n               bssqEn[n] += (*pp) * (*pp);\n            \
    \   pp++;\n           }\n           for (l=SUBL-5; l<SUBL; l++) {\n          \
    \     fssqEn[n] += (*pp) * (*pp);\n               bssqEn[n] += sampEn_win[SUBL-l-1]\
    \ * (*pp) * (*pp);\n               pp++;\n           }\n       }\n       /* Calculate\
    \ back of last seqence */\n       n=iLBCenc_inst->nsub-1;\n       pp=residual+n*SUBL;\n\
    \       for (l=0; l<SUBL-5; l++) {\n           bssqEn[n] += (*pp) * (*pp);\n \
    \          pp++;\n       }\n       for (l=SUBL-5; l<SUBL; l++) {\n           bssqEn[n]\
    \ += sampEn_win[SUBL-l-1] * (*pp) * (*pp);\n           pp++;\n       }\n     \
    \  /* find the index to the weighted 80 sample with\n          most energy */\n\
    \       if (iLBCenc_inst->mode==20) l=1;\n       else                        l=0;\n\
    \       max_ssqEn=(fssqEn[0]+bssqEn[1])*ssqEn_win[l];\n       max_ssqEn_n=1;\n\
    \       for (n=2; n<iLBCenc_inst->nsub; n++) {\n           l++;\n           if\
    \ ((fssqEn[n-1]+bssqEn[n])*ssqEn_win[l] > max_ssqEn) {\n               max_ssqEn=(fssqEn[n-1]+bssqEn[n])\
    \ *\n                               ssqEn_win[l];\n               max_ssqEn_n=n;\n\
    \           }\n       }\n       return max_ssqEn_n;\n   }\n"
- title: A.21.  gainquant.h
  contents:
  - "A.21.  gainquant.h\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       gainquant.h\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #ifndef __iLBC_GAINQUANT_H\n   #define __iLBC_GAINQUANT_H\n   float gainquant(/*\
    \ (o) quantized gain value */\n       float in,       /* (i) gain value */\n \
    \      float maxIn,/* (i) maximum of gain value */\n       int cblen,      /*\
    \ (i) number of quantization indices */\n       int *index      /* (o) quantization\
    \ index */\n   );\n   float gaindequant(  /* (o) quantized gain value */\n   \
    \    int index,      /* (i) quantization index */\n       float maxIn,/* (i) maximum\
    \ of unquantized gain */\n       int cblen       /* (i) number of quantization\
    \ indices */\n   );\n   #endif\n"
- title: A.22.  gainquant.c
  contents:
  - "A.22.  gainquant.c\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       gainquant.c\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #include <string.h>\n   #include <math.h>\n   #include \"constants.h\"\n \
    \  #include \"filter.h\"\n   /*----------------------------------------------------------------*\n\
    \    *  quantizer for the gain in the gain-shape coding of residual\n    *---------------------------------------------------------------*/\n\
    \   float gainquant(/* (o) quantized gain value */\n       float in,       /*\
    \ (i) gain value */\n       float maxIn,/* (i) maximum of gain value */\n    \
    \   int cblen,      /* (i) number of quantization indices */\n       int *index\
    \      /* (o) quantization index */\n   ){\n       int i, tindex;\n       float\
    \ minmeasure,measure, *cb, scale;\n       /* ensure a lower bound on the scaling\
    \ factor */\n       scale=maxIn;\n       if (scale<0.1) {\n           scale=(float)0.1;\n\
    \       }\n       /* select the quantization table */\n       if (cblen == 8)\
    \ {\n           cb = gain_sq3Tbl;\n       } else if (cblen == 16) {\n        \
    \   cb = gain_sq4Tbl;\n       } else  {\n           cb = gain_sq5Tbl;\n      \
    \ }\n       /* select the best index in the quantization table */\n       minmeasure=10000000.0;\n\
    \       tindex=0;\n       for (i=0; i<cblen; i++) {\n           measure=(in-scale*cb[i])*(in-scale*cb[i]);\n\
    \           if (measure<minmeasure) {\n               tindex=i;\n            \
    \   minmeasure=measure;\n           }\n       }\n       *index=tindex;\n     \
    \  /* return the quantized value */\n       return scale*cb[tindex];\n   }\n \
    \  /*----------------------------------------------------------------*\n    *\
    \  decoder for quantized gains in the gain-shape coding of\n    *  residual\n\
    \    *---------------------------------------------------------------*/\n   float\
    \ gaindequant(  /* (o) quantized gain value */\n       int index,      /* (i)\
    \ quantization index */\n       float maxIn,/* (i) maximum of unquantized gain\
    \ */\n       int cblen       /* (i) number of quantization indices */\n   ){\n\
    \       float scale;\n       /* obtain correct scale factor */\n       scale=(float)fabs(maxIn);\n\
    \       if (scale<0.1) {\n           scale=(float)0.1;\n       }\n       /* select\
    \ the quantization table and return the decoded value */\n       if (cblen==8)\
    \ {\n           return scale*gain_sq3Tbl[index];\n       } else if (cblen==16)\
    \ {\n           return scale*gain_sq4Tbl[index];\n       }\n       else if (cblen==32)\
    \ {\n           return scale*gain_sq5Tbl[index];\n       }\n       return 0.0;\n\
    \   }\n"
- title: A.23.  getCBvec.h
  contents:
  - "A.23.  getCBvec.h\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       getCBvec.h\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #ifndef __iLBC_GETCBVEC_H\n   #define __iLBC_GETCBVEC_H\n   void getCBvec(\n\
    \       float *cbvec,   /* (o) Constructed codebook vector */\n       float *mem,\
    \     /* (i) Codebook buffer */\n       int index,      /* (i) Codebook index\
    \ */\n       int lMem,       /* (i) Length of codebook buffer */\n       int cbveclen/*\
    \ (i) Codebook vector length */\n   );\n   #endif\n"
- title: A.24.  getCBvec.c
  contents:
  - "A.24.  getCBvec.c\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       getCBvec.c\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #include \"iLBC_define.h\"\n   #include \"constants.h\"\n   #include <string.h>\n\
    \   /*----------------------------------------------------------------*\n    *\
    \  Construct codebook vector for given index.\n    *---------------------------------------------------------------*/\n\
    \   void getCBvec(\n       float *cbvec,   /* (o) Constructed codebook vector\
    \ */\n       float *mem,     /* (i) Codebook buffer */\n       int index,    \
    \  /* (i) Codebook index */\n       int lMem,       /* (i) Length of codebook\
    \ buffer */\n       int cbveclen/* (i) Codebook vector length */\n   ){\n    \
    \   int j, k, n, memInd, sFilt;\n       float tmpbuf[CB_MEML];\n       int base_size;\n\
    \       int ilow, ihigh;\n       float alfa, alfa1;\n       /* Determine size\
    \ of codebook sections */\n       base_size=lMem-cbveclen+1;\n       if (cbveclen==SUBL)\
    \ {\n           base_size+=cbveclen/2;\n       }\n       /* No filter -> First\
    \ codebook section */\n       if (index<lMem-cbveclen+1) {\n           /* first\
    \ non-interpolated vectors */\n           k=index+cbveclen;\n           /* get\
    \ vector */\n           memcpy(cbvec, mem+lMem-k, cbveclen*sizeof(float));\n \
    \      } else if (index < base_size) {\n           k=2*(index-(lMem-cbveclen+1))+cbveclen;\n\
    \           ihigh=k/2;\n           ilow=ihigh-5;\n           /* Copy first noninterpolated\
    \ part */\n           memcpy(cbvec, mem+lMem-k/2, ilow*sizeof(float));\n     \
    \      /* interpolation */\n           alfa1=(float)0.2;\n           alfa=0.0;\n\
    \           for (j=ilow; j<ihigh; j++) {\n               cbvec[j]=((float)1.0-alfa)*mem[lMem-k/2+j]+\n\
    \                   alfa*mem[lMem-k+j];\n               alfa+=alfa1;\n       \
    \    }\n           /* Copy second noninterpolated part */\n           memcpy(cbvec+ihigh,\
    \ mem+lMem-k+ihigh,\n               (cbveclen-ihigh)*sizeof(float));\n       }\n\
    \       /* Higher codebook section based on filtering */\n       else {\n    \
    \       /* first non-interpolated vectors */\n           if (index-base_size<lMem-cbveclen+1)\
    \ {\n               float tempbuff2[CB_MEML+CB_FILTERLEN+1];\n               float\
    \ *pos;\n               float *pp, *pp1;\n               memset(tempbuff2, 0,\n\
    \                   CB_HALFFILTERLEN*sizeof(float));\n               memcpy(&tempbuff2[CB_HALFFILTERLEN],\
    \ mem,\n                   lMem*sizeof(float));\n               memset(&tempbuff2[lMem+CB_HALFFILTERLEN],\
    \ 0,\n                   (CB_HALFFILTERLEN+1)*sizeof(float));\n              \
    \ k=index-base_size+cbveclen;\n               sFilt=lMem-k;\n               memInd=sFilt+1-CB_HALFFILTERLEN;\n\
    \               /* do filtering */\n               pos=cbvec;\n              \
    \ memset(pos, 0, cbveclen*sizeof(float));\n               for (n=0; n<cbveclen;\
    \ n++) {\n                   pp=&tempbuff2[memInd+n+CB_HALFFILTERLEN];\n     \
    \              pp1=&cbfiltersTbl[CB_FILTERLEN-1];\n                   for (j=0;\
    \ j<CB_FILTERLEN; j++) {\n                       (*pos)+=(*pp++)*(*pp1--);\n \
    \                  }\n                   pos++;\n               }\n          \
    \ }\n           /* interpolated vectors */\n           else {\n              \
    \ float tempbuff2[CB_MEML+CB_FILTERLEN+1];\n               float *pos;\n     \
    \          float *pp, *pp1;\n               int i;\n               memset(tempbuff2,\
    \ 0,\n                   CB_HALFFILTERLEN*sizeof(float));\n               memcpy(&tempbuff2[CB_HALFFILTERLEN],\
    \ mem,\n                   lMem*sizeof(float));\n               memset(&tempbuff2[lMem+CB_HALFFILTERLEN],\
    \ 0,\n                   (CB_HALFFILTERLEN+1)*sizeof(float));\n              \
    \ k=2*(index-base_size-\n                   (lMem-cbveclen+1))+cbveclen;\n   \
    \            sFilt=lMem-k;\n               memInd=sFilt+1-CB_HALFFILTERLEN;\n\
    \               /* do filtering */\n               pos=&tmpbuf[sFilt];\n     \
    \          memset(pos, 0, k*sizeof(float));\n               for (i=0; i<k; i++)\
    \ {\n                   pp=&tempbuff2[memInd+i+CB_HALFFILTERLEN];\n          \
    \         pp1=&cbfiltersTbl[CB_FILTERLEN-1];\n                   for (j=0; j<CB_FILTERLEN;\
    \ j++) {\n                       (*pos)+=(*pp++)*(*pp1--);\n                 \
    \  }\n                   pos++;\n               }\n               ihigh=k/2;\n\
    \               ilow=ihigh-5;\n               /* Copy first noninterpolated part\
    \ */\n               memcpy(cbvec, tmpbuf+lMem-k/2,\n                   ilow*sizeof(float));\n\
    \               /* interpolation */\n               alfa1=(float)0.2;\n      \
    \         alfa=0.0;\n               for (j=ilow; j<ihigh; j++) {\n           \
    \        cbvec[j]=((float)1.0-alfa)*\n                       tmpbuf[lMem-k/2+j]+alfa*tmpbuf[lMem-k+j];\n\
    \                   alfa+=alfa1;\n               }\n               /* Copy second\
    \ noninterpolated part */\n               memcpy(cbvec+ihigh, tmpbuf+lMem-k+ihigh,\n\
    \                   (cbveclen-ihigh)*sizeof(float));\n           }\n       }\n\
    \   }\n"
- title: A.25.  helpfun.h
  contents:
  - "A.25.  helpfun.h\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       helpfun.h\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #ifndef __iLBC_HELPFUN_H\n   #define __iLBC_HELPFUN_H\n   void autocorr(\n\
    \       float *r,       /* (o) autocorrelation vector */\n       const float *x,\
    \ /* (i) data vector */\n       int N,          /* (i) length of data vector */\n\
    \       int order       /* largest lag for calculated\n                      \
    \    autocorrelations */\n   );\n   void window(\n       float *z,       /* (o)\
    \ the windowed data */\n       const float *x, /* (i) the original data vector\
    \ */\n       const float *y, /* (i) the window */\n       int N           /* (i)\
    \ length of all vectors */\n   );\n   void levdurb(\n       float *a,       /*\
    \ (o) lpc coefficient vector starting\n                              with 1.0\
    \ */\n       float *k,       /* (o) reflection coefficients */\n       float *r,\
    \       /* (i) autocorrelation vector */\n       int order       /* (i) order\
    \ of lpc filter */\n   );\n   void interpolate(\n       float *out,     /* (o)\
    \ the interpolated vector */\n       float *in1,     /* (i) the first vector for\
    \ the\n                              interpolation */\n       float *in2,    \
    \ /* (i) the second vector for the\n                              interpolation\
    \ */\n       float coef,     /* (i) interpolation weights */\n       int length\
    \      /* (i) length of all vectors */\n   );\n   void bwexpand(\n       float\
    \ *out,     /* (o) the bandwidth expanded lpc\n                              coefficients\
    \ */\n       float *in,      /* (i) the lpc coefficients before bandwidth\n  \
    \                            expansion */\n       float coef,     /* (i) the bandwidth\
    \ expansion factor */\n       int length      /* (i) the length of lpc coefficient\
    \ vectors */\n   );\n   void vq(\n       float *Xq,      /* (o) the quantized\
    \ vector */\n       int *index,     /* (o) the quantization index */\n       const\
    \ float *CB,/* (i) the vector quantization codebook */\n       float *X,     \
    \  /* (i) the vector to quantize */\n       int n_cb,       /* (i) the number\
    \ of vectors in the codebook */\n       int dim         /* (i) the dimension of\
    \ all vectors */\n   );\n   void SplitVQ(\n       float *qX,      /* (o) the quantized\
    \ vector */\n       int *index,     /* (o) a vector of indexes for all vector\n\
    \                              codebooks in the split */\n       float *X,   \
    \    /* (i) the vector to quantize */\n       const float *CB,/* (i) the quantizer\
    \ codebook */\n       int nsplit,     /* the number of vector splits */\n    \
    \   const int *dim, /* the dimension of X and qX */\n       const int *cbsize\
    \ /* the number of vectors in the codebook */\n   );\n   void sort_sq(\n     \
    \  float *xq,      /* (o) the quantized value */\n       int *index,     /* (o)\
    \ the quantization index */\n       float x,    /* (i) the value to quantize */\n\
    \       const float *cb,/* (i) the quantization codebook */\n       int cb_size\
    \     /* (i) the size of the quantization codebook */\n   );\n   int LSF_check(\
    \      /* (o) 1 for stable lsf vectors and 0 for\n                           \
    \   nonstable ones */\n       float *lsf,     /* (i) a table of lsf vectors */\n\
    \       int dim,    /* (i) the dimension of each lsf vector */\n       int NoAn\
    \    /* (i) the number of lsf vectors in the\n                              table\
    \ */\n   );\n   #endif\n"
- title: A.26.  helpfun.c
  contents:
  - "A.26.  helpfun.c\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       helpfun.c\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #include <math.h>\n   #include \"iLBC_define.h\"\n   #include \"constants.h\"\
    \n   /*----------------------------------------------------------------*\n   \
    \ *  calculation of auto correlation\n    *---------------------------------------------------------------*/\n\
    \   void autocorr(\n       float *r,       /* (o) autocorrelation vector */\n\
    \       const float *x, /* (i) data vector */\n       int N,          /* (i) length\
    \ of data vector */\n       int order       /* largest lag for calculated\n  \
    \                        autocorrelations */\n   ){\n       int     lag, n;\n\
    \       float   sum;\n       for (lag = 0; lag <= order; lag++) {\n          \
    \ sum = 0;\n           for (n = 0; n < N - lag; n++) {\n               sum +=\
    \ x[n] * x[n+lag];\n           }\n           r[lag] = sum;\n       }\n   }\n \
    \  /*----------------------------------------------------------------*\n    *\
    \  window multiplication\n    *---------------------------------------------------------------*/\n\
    \   void window(\n       float *z,       /* (o) the windowed data */\n       const\
    \ float *x, /* (i) the original data vector */\n       const float *y, /* (i)\
    \ the window */\n       int N           /* (i) length of all vectors */\n   ){\n\
    \       int     i;\n       for (i = 0; i < N; i++) {\n           z[i] = x[i] *\
    \ y[i];\n       }\n   }\n   /*----------------------------------------------------------------*\n\
    \    *  levinson-durbin solution for lpc coefficients\n    *---------------------------------------------------------------*/\n\
    \   void levdurb(\n       float *a,       /* (o) lpc coefficient vector starting\n\
    \                              with 1.0 */\n       float *k,       /* (o) reflection\
    \ coefficients */\n       float *r,       /* (i) autocorrelation vector */\n \
    \      int order       /* (i) order of lpc filter */\n   ){\n       float  sum,\
    \ alpha;\n       int     m, m_h, i;\n       a[0] = 1.0;\n       if (r[0] < EPS)\
    \ { /* if r[0] <= 0, set LPC coeff. to zero */\n           for (i = 0; i < order;\
    \ i++) {\n               k[i] = 0;\n               a[i+1] = 0;\n           }\n\
    \       } else {\n           a[1] = k[0] = -r[1]/r[0];\n           alpha = r[0]\
    \ + r[1] * k[0];\n           for (m = 1; m < order; m++){\n               sum\
    \ = r[m + 1];\n               for (i = 0; i < m; i++){\n                   sum\
    \ += a[i+1] * r[m - i];\n               }\n               k[m] = -sum / alpha;\n\
    \               alpha += k[m] * sum;\n               m_h = (m + 1) >> 1;\n   \
    \            for (i = 0; i < m_h; i++){\n                   sum = a[i+1] + k[m]\
    \ * a[m - i];\n                   a[m - i] += k[m] * a[i+1];\n               \
    \    a[i+1] = sum;\n               }\n               a[m+1] = k[m];\n        \
    \   }\n       }\n   }\n   /*----------------------------------------------------------------*\n\
    \    *  interpolation between vectors\n    *---------------------------------------------------------------*/\n\
    \   void interpolate(\n       float *out,      /* (o) the interpolated vector\
    \ */\n       float *in1,     /* (i) the first vector for the\n               \
    \               interpolation */\n       float *in2,     /* (i) the second vector\
    \ for the\n                              interpolation */\n       float coef,\
    \      /* (i) interpolation weights */\n       int length      /* (i) length of\
    \ all vectors */\n   ){\n       int i;\n       float invcoef;\n       invcoef\
    \ = (float)1.0 - coef;\n       for (i = 0; i < length; i++) {\n           out[i]\
    \ = coef * in1[i] + invcoef * in2[i];\n       }\n   }\n   /*----------------------------------------------------------------*\n\
    \    *  lpc bandwidth expansion\n    *---------------------------------------------------------------*/\n\
    \   void bwexpand(\n       float *out,      /* (o) the bandwidth expanded lpc\n\
    \                              coefficients */\n       float *in,      /* (i)\
    \ the lpc coefficients before bandwidth\n                              expansion\
    \ */\n       float coef,     /* (i) the bandwidth expansion factor */\n      \
    \ int length      /* (i) the length of lpc coefficient vectors */\n   ){\n   \
    \    int i;\n       float  chirp;\n       chirp = coef;\n       out[0] = in[0];\n\
    \       for (i = 1; i < length; i++) {\n           out[i] = chirp * in[i];\n \
    \          chirp *= coef;\n       }\n   }\n   /*----------------------------------------------------------------*\n\
    \    *  vector quantization\n    *---------------------------------------------------------------*/\n\
    \   void vq(\n       float *Xq,      /* (o) the quantized vector */\n       int\
    \ *index,     /* (o) the quantization index */\n       const float *CB,/* (i)\
    \ the vector quantization codebook */\n       float *X,       /* (i) the vector\
    \ to quantize */\n       int n_cb,       /* (i) the number of vectors in the codebook\
    \ */\n       int dim         /* (i) the dimension of all vectors */\n   ){\n \
    \      int     i, j;\n       int     pos, minindex;\n       float   dist, tmp,\
    \ mindist;\n       pos = 0;\n       mindist = FLOAT_MAX;\n       minindex = 0;\n\
    \       for (j = 0; j < n_cb; j++) {\n           dist = X[0] - CB[pos];\n    \
    \       dist *= dist;\n           for (i = 1; i < dim; i++) {\n              \
    \ tmp = X[i] - CB[pos + i];\n               dist += tmp*tmp;\n           }\n \
    \          if (dist < mindist) {\n               mindist = dist;\n           \
    \    minindex = j;\n           }\n           pos += dim;\n       }\n       for\
    \ (i = 0; i < dim; i++) {\n           Xq[i] = CB[minindex*dim + i];\n       }\n\
    \       *index = minindex;\n   }\n   /*----------------------------------------------------------------*\n\
    \    *  split vector quantization\n    *---------------------------------------------------------------*/\n\
    \   void SplitVQ(\n       float *qX,      /* (o) the quantized vector */\n   \
    \    int *index,     /* (o) a vector of indexes for all vector\n             \
    \                 codebooks in the split */\n       float *X,       /* (i) the\
    \ vector to quantize */\n       const float *CB,/* (i) the quantizer codebook\
    \ */\n       int nsplit,     /* the number of vector splits */\n       const int\
    \ *dim, /* the dimension of X and qX */\n       const int *cbsize /* the number\
    \ of vectors in the codebook */\n   ){\n       int    cb_pos, X_pos, i;\n    \
    \   cb_pos = 0;\n       X_pos= 0;\n       for (i = 0; i < nsplit; i++) {\n   \
    \        vq(qX + X_pos, index + i, CB + cb_pos, X + X_pos,\n               cbsize[i],\
    \ dim[i]);\n           X_pos += dim[i];\n           cb_pos += dim[i] * cbsize[i];\n\
    \       }\n   }\n   /*----------------------------------------------------------------*\n\
    \    *  scalar quantization\n    *---------------------------------------------------------------*/\n\
    \   void sort_sq(\n       float *xq,      /* (o) the quantized value */\n    \
    \   int *index,     /* (o) the quantization index */\n       float x,    /* (i)\
    \ the value to quantize */\n       const float *cb,/* (i) the quantization codebook\
    \ */\n       int cb_size      /* (i) the size of the quantization codebook */\n\
    \   ){\n       int i;\n       if (x <= cb[0]) {\n           *index = 0;\n    \
    \       *xq = cb[0];\n       } else {\n           i = 0;\n           while ((x\
    \ > cb[i]) && i < cb_size - 1) {\n               i++;\n           }\n        \
    \   if (x > ((cb[i] + cb[i - 1])/2)) {\n               *index = i;\n         \
    \      *xq = cb[i];\n           } else {\n               *index = i - 1;\n   \
    \            *xq = cb[i - 1];\n           }\n       }\n   }\n   /*----------------------------------------------------------------*\n\
    \    *  check for stability of lsf coefficients\n    *---------------------------------------------------------------*/\n\
    \   int LSF_check(    /* (o) 1 for stable lsf vectors and 0 for\n            \
    \                  nonstable ones */\n       float *lsf,     /* (i) a table of\
    \ lsf vectors */\n       int dim,    /* (i) the dimension of each lsf vector */\n\
    \       int NoAn    /* (i) the number of lsf vectors in the\n                \
    \              table */\n   ){\n       int k,n,m, Nit=2, change=0,pos;\n     \
    \  float tmp;\n       static float eps=(float)0.039; /* 50 Hz */\n       static\
    \ float eps2=(float)0.0195;\n       static float maxlsf=(float)3.14; /* 4000 Hz\
    \ */\n       static float minlsf=(float)0.01; /* 0 Hz */\n       /* LSF separation\
    \ check*/\n       for (n=0; n<Nit; n++) { /* Run through a couple of times */\n\
    \           for (m=0; m<NoAn; m++) { /* Number of analyses per frame */\n    \
    \           for (k=0; k<(dim-1); k++) {\n                   pos=m*dim+k;\n   \
    \                if ((lsf[pos+1]-lsf[pos])<eps) {\n                       if (lsf[pos+1]<lsf[pos])\
    \ {\n                           tmp=lsf[pos+1];\n                           lsf[pos+1]=\
    \ lsf[pos]+eps2;\n                           lsf[pos]= lsf[pos+1]-eps2;\n    \
    \                   } else {\n                           lsf[pos]-=eps2;\n   \
    \                        lsf[pos+1]+=eps2;\n                       }\n       \
    \                change=1;\n                   }\n                   if (lsf[pos]<minlsf)\
    \ {\n                       lsf[pos]=minlsf;\n                       change=1;\n\
    \                   }\n                   if (lsf[pos]>maxlsf) {\n           \
    \            lsf[pos]=maxlsf;\n                       change=1;\n            \
    \       }\n               }\n           }\n       }\n       return change;\n \
    \  }\n"
- title: A.27.  hpInput.h
  contents:
  - "A.27.  hpInput.h\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       hpInput.h\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #ifndef __iLBC_HPINPUT_H\n   #define __iLBC_HPINPUT_H\n   void hpInput(\n\
    \       float *In,  /* (i) vector to filter */\n       int len,    /* (i) length\
    \ of vector to filter */\n       float *Out, /* (o) the resulting filtered vector\
    \ */\n       float *mem  /* (i/o) the filter state */\n   );\n   #endif\n"
- title: A.28.  hpInput.c
  contents:
  - "A.28.  hpInput.c\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       hpInput.c\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #include \"constants.h\"\n   /*----------------------------------------------------------------*\n\
    \    *  Input high-pass filter\n    *---------------------------------------------------------------*/\n\
    \   void hpInput(\n       float *In,  /* (i) vector to filter */\n       int len,\
    \    /* (i) length of vector to filter */\n       float *Out, /* (o) the resulting\
    \ filtered vector */\n       float *mem  /* (i/o) the filter state */\n   ){\n\
    \       int i;\n       float *pi, *po;\n       /* all-zero section*/\n       pi\
    \ = &In[0];\n       po = &Out[0];\n       for (i=0; i<len; i++) {\n          \
    \ *po = hpi_zero_coefsTbl[0] * (*pi);\n           *po += hpi_zero_coefsTbl[1]\
    \ * mem[0];\n           *po += hpi_zero_coefsTbl[2] * mem[1];\n           mem[1]\
    \ = mem[0];\n           mem[0] = *pi;\n           po++;\n           pi++;\n  \
    \     }\n       /* all-pole section*/\n       po = &Out[0];\n       for (i=0;\
    \ i<len; i++) {\n           *po -= hpi_pole_coefsTbl[1] * mem[2];\n          \
    \ *po -= hpi_pole_coefsTbl[2] * mem[3];\n           mem[3] = mem[2];\n       \
    \    mem[2] = *po;\n           po++;\n       }\n   }\n"
- title: A.29.  hpOutput.h
  contents:
  - "A.29.  hpOutput.h\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       hpOutput.h\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #ifndef __iLBC_HPOUTPUT_H\n   #define __iLBC_HPOUTPUT_H\n   void hpOutput(\n\
    \       float *In,  /* (i) vector to filter */\n       int len,/* (i) length of\
    \ vector to filter */\n       float *Out, /* (o) the resulting filtered vector\
    \ */\n       float *mem  /* (i/o) the filter state */\n   );\n   #endif\n"
- title: A.30.  hpOutput.c
  contents:
  - "A.30.  hpOutput.c\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       hpOutput.c\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #include \"constants.h\"\n   /*----------------------------------------------------------------*\n\
    \    *  Output high-pass filter\n    *---------------------------------------------------------------*/\n\
    \   void hpOutput(\n       float *In,  /* (i) vector to filter */\n       int\
    \ len,/* (i) length of vector to filter */\n       float *Out, /* (o) the resulting\
    \ filtered vector */\n       float *mem  /* (i/o) the filter state */\n   ){\n\
    \       int i;\n       float *pi, *po;\n       /* all-zero section*/\n       pi\
    \ = &In[0];\n       po = &Out[0];\n       for (i=0; i<len; i++) {\n          \
    \ *po = hpo_zero_coefsTbl[0] * (*pi);\n           *po += hpo_zero_coefsTbl[1]\
    \ * mem[0];\n           *po += hpo_zero_coefsTbl[2] * mem[1];\n           mem[1]\
    \ = mem[0];\n           mem[0] = *pi;\n           po++;\n           pi++;\n  \
    \     }\n       /* all-pole section*/\n       po = &Out[0];\n       for (i=0;\
    \ i<len; i++) {\n           *po -= hpo_pole_coefsTbl[1] * mem[2];\n          \
    \ *po -= hpo_pole_coefsTbl[2] * mem[3];\n           mem[3] = mem[2];\n       \
    \    mem[2] = *po;\n           po++;\n       }\n   }\n"
- title: A.31.  iCBConstruct.h
  contents:
  - "A.31.  iCBConstruct.h\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       iCBConstruct.h\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #ifndef __iLBC_ICBCONSTRUCT_H\n   #define __iLBC_ICBCONSTRUCT_H\n   void index_conv_enc(\n\
    \       int *index          /* (i/o) Codebook indexes */\n   );\n   void index_conv_dec(\n\
    \       int *index          /* (i/o) Codebook indexes */\n   );\n   void iCBConstruct(\n\
    \       float *decvector,   /* (o) Decoded vector */\n       int *index,     \
    \    /* (i) Codebook indices */\n       int *gain_index,/* (i) Gain quantization\
    \ indices */\n       float *mem,         /* (i) Buffer for codevector construction\
    \ */\n       int lMem,           /* (i) Length of buffer */\n       int veclen,\
    \         /* (i) Length of vector */\n       int nStages         /* (i) Number\
    \ of codebook stages */\n   );\n   #endif\n"
- title: A.32.  iCBConstruct.c
  contents:
  - "A.32.  iCBConstruct.c\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       iCBConstruct.c\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #include <math.h>\n   #include \"iLBC_define.h\"\n   #include \"gainquant.h\"\
    \n   #include \"getCBvec.h\"\n   /*----------------------------------------------------------------*\n\
    \    *  Convert the codebook indexes to make the search easier\n    *---------------------------------------------------------------*/\n\
    \   void index_conv_enc(\n       int *index          /* (i/o) Codebook indexes\
    \ */\n   ){\n       int k;\n       for (k=1; k<CB_NSTAGES; k++) {\n          \
    \ if ((index[k]>=108)&&(index[k]<172)) {\n               index[k]-=64;\n     \
    \      } else if (index[k]>=236) {\n               index[k]-=128;\n          \
    \ } else {\n               /* ERROR */\n           }\n       }\n   }\n   void\
    \ index_conv_dec(\n       int *index          /* (i/o) Codebook indexes */\n \
    \  ){\n       int k;\n       for (k=1; k<CB_NSTAGES; k++) {\n           if ((index[k]>=44)&&(index[k]<108))\
    \ {\n               index[k]+=64;\n           } else if ((index[k]>=108)&&(index[k]<128))\
    \ {\n               index[k]+=128;\n           } else {\n               /* ERROR\
    \ */\n           }\n       }\n   }\n   /*----------------------------------------------------------------*\n\
    \    *  Construct decoded vector from codebook and gains.\n    *---------------------------------------------------------------*/\n\
    \   void iCBConstruct(\n       float *decvector,   /* (o) Decoded vector */\n\
    \       int *index,         /* (i) Codebook indices */\n       int *gain_index,/*\
    \ (i) Gain quantization indices */\n       float *mem,         /* (i) Buffer for\
    \ codevector construction */\n       int lMem,           /* (i) Length of buffer\
    \ */\n       int veclen,         /* (i) Length of vector */\n       int nStages\
    \         /* (i) Number of codebook stages */\n   ){\n       int j,k;\n      \
    \ float gain[CB_NSTAGES];\n       float cbvec[SUBL];\n       /* gain de-quantization\
    \ */\n       gain[0] = gaindequant(gain_index[0], 1.0, 32);\n       if (nStages\
    \ > 1) {\n           gain[1] = gaindequant(gain_index[1],\n               (float)fabs(gain[0]),\
    \ 16);\n       }\n       if (nStages > 2) {\n           gain[2] = gaindequant(gain_index[2],\n\
    \               (float)fabs(gain[1]), 8);\n       }\n       /* codebook vector\
    \ construction and construction of\n       total vector */\n       getCBvec(cbvec,\
    \ mem, index[0], lMem, veclen);\n       for (j=0;j<veclen;j++){\n           decvector[j]\
    \ = gain[0]*cbvec[j];\n       }\n       if (nStages > 1) {\n           for (k=1;\
    \ k<nStages; k++) {\n               getCBvec(cbvec, mem, index[k], lMem, veclen);\n\
    \               for (j=0;j<veclen;j++) {\n                   decvector[j] += gain[k]*cbvec[j];\n\
    \               }\n           }\n       }\n   }\n"
- title: A.33.  iCBSearch.h
  contents:
  - "A.33.  iCBSearch.h\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       iCBSearch.h\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #ifndef __iLBC_ICBSEARCH_H\n   #define __iLBC_ICBSEARCH_H\n   void iCBSearch(\n\
    \       iLBC_Enc_Inst_t *iLBCenc_inst,\n                           /* (i) the\
    \ encoder state structure */\n       int *index,         /* (o) Codebook indices\
    \ */\n       int *gain_index,/* (o) Gain quantization indices */\n       float\
    \ *intarget,/* (i) Target vector for encoding */\n       float *mem,         /*\
    \ (i) Buffer for codebook construction */\n       int lMem,           /* (i) Length\
    \ of buffer */\n       int lTarget,    /* (i) Length of vector */\n       int\
    \ nStages,    /* (i) Number of codebook stages */\n       float *weightDenum,\
    \ /* (i) weighting filter coefficients */\n       float *weightState, /* (i) weighting\
    \ filter state */\n       int block           /* (i) the sub-block number */\n\
    \   );\n   #endif\n"
- title: A.34.  iCBSearch.c
  contents:
  - "A.34.  iCBSearch.c\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       iCBSearch.c\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #include <math.h>\n   #include <string.h>\n   #include \"iLBC_define.h\"\n\
    \   #include \"gainquant.h\"\n   #include \"createCB.h\"\n   #include \"filter.h\"\
    \n   #include \"constants.h\"\n   /*----------------------------------------------------------------*\n\
    \    *  Search routine for codebook encoding and gain quantization.\n    *---------------------------------------------------------------*/\n\
    \   void iCBSearch(\n       iLBC_Enc_Inst_t *iLBCenc_inst,\n                 \
    \          /* (i) the encoder state structure */\n       int *index,         /*\
    \ (o) Codebook indices */\n       int *gain_index,/* (o) Gain quantization indices\
    \ */\n       float *intarget,/* (i) Target vector for encoding */\n       float\
    \ *mem,         /* (i) Buffer for codebook construction */\n       int lMem, \
    \          /* (i) Length of buffer */\n       int lTarget,    /* (i) Length of\
    \ vector */\n       int nStages,    /* (i) Number of codebook stages */\n    \
    \   float *weightDenum, /* (i) weighting filter coefficients */\n       float\
    \ *weightState, /* (i) weighting filter state */\n       int block           /*\
    \ (i) the sub-block number */\n   ){\n       int i, j, icount, stage, best_index,\
    \ range, counter;\n       float max_measure, gain, measure, crossDot, ftmp;\n\
    \       float gains[CB_NSTAGES];\n       float target[SUBL];\n       int base_index,\
    \ sInd, eInd, base_size;\n       int sIndAug=0, eIndAug=0;\n       float buf[CB_MEML+SUBL+2*LPC_FILTERORDER];\n\
    \       float invenergy[CB_EXPAND*128], energy[CB_EXPAND*128];\n       float *pp,\
    \ *ppi=0, *ppo=0, *ppe=0;\n       float cbvectors[CB_MEML];\n       float tene,\
    \ cene, cvec[SUBL];\n       float aug_vec[SUBL];\n       memset(cvec,0,SUBL*sizeof(float));\n\
    \       /* Determine size of codebook sections */\n       base_size=lMem-lTarget+1;\n\
    \       if (lTarget==SUBL) {\n           base_size=lMem-lTarget+1+lTarget/2;\n\
    \       }\n       /* setup buffer for weighting */\n       memcpy(buf,weightState,sizeof(float)*LPC_FILTERORDER);\n\
    \       memcpy(buf+LPC_FILTERORDER,mem,lMem*sizeof(float));\n       memcpy(buf+LPC_FILTERORDER+lMem,intarget,lTarget*sizeof(float));\n\
    \       /* weighting */\n       AllPoleFilter(buf+LPC_FILTERORDER, weightDenum,\n\
    \           lMem+lTarget, LPC_FILTERORDER);\n       /* Construct the codebook\
    \ and target needed */\n       memcpy(target, buf+LPC_FILTERORDER+lMem, lTarget*sizeof(float));\n\
    \       tene=0.0;\n       for (i=0; i<lTarget; i++) {\n           tene+=target[i]*target[i];\n\
    \       }\n       /* Prepare search over one more codebook section. This section\n\
    \          is created by filtering the original buffer with a filter. */\n   \
    \    filteredCBvecs(cbvectors, buf+LPC_FILTERORDER, lMem);\n       /* The Main\
    \ Loop over stages */\n       for (stage=0; stage<nStages; stage++) {\n      \
    \     range = search_rangeTbl[block][stage];\n           /* initialize search\
    \ measure */\n           max_measure = (float)-10000000.0;\n           gain =\
    \ (float)0.0;\n           best_index = 0;\n           /* Compute cross dot product\
    \ between the target\n              and the CB memory */\n           crossDot=0.0;\n\
    \           pp=buf+LPC_FILTERORDER+lMem-lTarget;\n           for (j=0; j<lTarget;\
    \ j++) {\n               crossDot += target[j]*(*pp++);\n           }\n      \
    \     if (stage==0) {\n               /* Calculate energy in the first block of\n\
    \                 'lTarget' samples. */\n               ppe = energy;\n      \
    \         ppi = buf+LPC_FILTERORDER+lMem-lTarget-1;\n               ppo = buf+LPC_FILTERORDER+lMem-1;\n\
    \               *ppe=0.0;\n               pp=buf+LPC_FILTERORDER+lMem-lTarget;\n\
    \               for (j=0; j<lTarget; j++) {\n                   *ppe+=(*pp)*(*pp++);\n\
    \               }\n               if (*ppe>0.0) {\n                   invenergy[0]\
    \ = (float) 1.0 / (*ppe + EPS);\n               } else {\n                   invenergy[0]\
    \ = (float) 0.0;\n               }\n               ppe++;\n               measure=(float)-10000000.0;\n\
    \               if (crossDot > 0.0) {\n                      measure = crossDot*crossDot*invenergy[0];\n\
    \               }\n           }\n           else {\n               measure = crossDot*crossDot*invenergy[0];\n\
    \           }\n           /* check if measure is better */\n           ftmp =\
    \ crossDot*invenergy[0];\n           if ((measure>max_measure) && (fabs(ftmp)<CB_MAXGAIN))\
    \ {\n               best_index = 0;\n               max_measure = measure;\n \
    \              gain = ftmp;\n           }\n           /* loop over the main first\
    \ codebook section,\n              full search */\n           for (icount=1; icount<range;\
    \ icount++) {\n               /* calculate measure */\n               crossDot=0.0;\n\
    \               pp = buf+LPC_FILTERORDER+lMem-lTarget-icount;\n              \
    \ for (j=0; j<lTarget; j++) {\n                   crossDot += target[j]*(*pp++);\n\
    \               }\n               if (stage==0) {\n                   *ppe++ =\
    \ energy[icount-1] + (*ppi)*(*ppi) -\n                       (*ppo)*(*ppo);\n\
    \                   ppo--;\n                   ppi--;\n                   if (energy[icount]>0.0)\
    \ {\n                       invenergy[icount] =\n                           (float)1.0/(energy[icount]+EPS);\n\
    \                   } else {\n                       invenergy[icount] = (float)\
    \ 0.0;\n                   }\n                   measure=(float)-10000000.0;\n\
    \                   if (crossDot > 0.0) {\n                       measure = crossDot*crossDot*invenergy[icount];\n\
    \                   }\n               }\n               else {\n             \
    \      measure = crossDot*crossDot*invenergy[icount];\n               }\n    \
    \           /* check if measure is better */\n               ftmp = crossDot*invenergy[icount];\n\
    \               if ((measure>max_measure) && (fabs(ftmp)<CB_MAXGAIN)) {\n    \
    \               best_index = icount;\n                   max_measure = measure;\n\
    \                   gain = ftmp;\n               }\n           }\n           /*\
    \ Loop over augmented part in the first codebook\n            * section, full\
    \ search.\n            * The vectors are interpolated.\n            */\n     \
    \      if (lTarget==SUBL) {\n               /* Search for best possible cb vector\
    \ and\n                  compute the CB-vectors' energy. */\n               searchAugmentedCB(20,\
    \ 39, stage, base_size-lTarget/2,\n                   target, buf+LPC_FILTERORDER+lMem,\n\
    \                   &max_measure, &best_index, &gain, energy,\n              \
    \     invenergy);\n           }\n           /* set search range for following\
    \ codebook sections */\n           base_index=best_index;\n           /* unrestricted\
    \ search */\n           if (CB_RESRANGE == -1) {\n               sInd=0;\n   \
    \            eInd=range-1;\n               sIndAug=20;\n               eIndAug=39;\n\
    \           }\n           /* restricted search around best index from first\n\
    \           codebook section */\n           else {\n               /* Initialize\
    \ search indices */\n               sIndAug=0;\n               eIndAug=0;\n  \
    \             sInd=base_index-CB_RESRANGE/2;\n               eInd=sInd+CB_RESRANGE;\n\
    \               if (lTarget==SUBL) {\n                   if (sInd<0) {\n     \
    \                  sIndAug = 40 + sInd;\n                       eIndAug = 39;\n\
    \                       sInd=0;\n                   } else if ( base_index < (base_size-20)\
    \ ) {\n                       if (eInd > range) {\n                          \
    \ sInd -= (eInd-range);\n                           eInd = range;\n          \
    \             }\n                   } else { /* base_index >= (base_size-20) */\n\
    \                       if (sInd < (base_size-20)) {\n                       \
    \    sIndAug = 20;\n                           sInd = 0;\n                   \
    \        eInd = 0;\n                           eIndAug = 19 + CB_RESRANGE;\n \
    \                          if(eIndAug > 39) {\n                              \
    \ eInd = eIndAug-39;\n                               eIndAug = 39;\n         \
    \                  }\n                       } else {\n                      \
    \     sIndAug = 20 + sInd - (base_size-20);\n                           eIndAug\
    \ = 39;\n                           sInd = 0;\n                           eInd\
    \ = CB_RESRANGE - (eIndAug-sIndAug+1);\n                       }\n           \
    \        }\n               } else { /* lTarget = 22 or 23 */\n               \
    \    if (sInd < 0) {\n                       eInd -= sInd;\n                 \
    \      sInd = 0;\n                   }\n                   if(eInd > range) {\n\
    \                       sInd -= (eInd - range);\n                       eInd =\
    \ range;\n                   }\n               }\n           }\n           /*\
    \ search of higher codebook section */\n           /* index search range */\n\
    \           counter = sInd;\n           sInd += base_size;\n           eInd +=\
    \ base_size;\n           if (stage==0) {\n               ppe = energy+base_size;\n\
    \               *ppe=0.0;\n               pp=cbvectors+lMem-lTarget;\n       \
    \        for (j=0; j<lTarget; j++) {\n                   *ppe+=(*pp)*(*pp++);\n\
    \               }\n               ppi = cbvectors + lMem - 1 - lTarget;\n    \
    \           ppo = cbvectors + lMem - 1;\n               for (j=0; j<(range-1);\
    \ j++) {\n                   *(ppe+1) = *ppe + (*ppi)*(*ppi) - (*ppo)*(*ppo);\n\
    \                   ppo--;\n                   ppi--;\n                   ppe++;\n\
    \               }\n           }\n           /* loop over search range */\n   \
    \        for (icount=sInd; icount<eInd; icount++) {\n               /* calculate\
    \ measure */\n               crossDot=0.0;\n               pp=cbvectors + lMem\
    \ - (counter++) - lTarget;\n               for (j=0;j<lTarget;j++) {\n       \
    \            crossDot += target[j]*(*pp++);\n               }\n              \
    \ if (energy[icount]>0.0) {\n                   invenergy[icount] =(float)1.0/(energy[icount]+EPS);\n\
    \               } else {\n                   invenergy[icount] =(float)0.0;\n\
    \               }\n               if (stage==0) {\n                   measure=(float)-10000000.0;\n\
    \                   if (crossDot > 0.0) {\n                       measure = crossDot*crossDot*\n\
    \                           invenergy[icount];\n                   }\n       \
    \        }\n               else {\n                   measure = crossDot*crossDot*invenergy[icount];\n\
    \               }\n               /* check if measure is better */\n         \
    \      ftmp = crossDot*invenergy[icount];\n               if ((measure>max_measure)\
    \ && (fabs(ftmp)<CB_MAXGAIN)) {\n                   best_index = icount;\n   \
    \                max_measure = measure;\n                   gain = ftmp;\n   \
    \            }\n           }\n           /* Search the augmented CB inside the\
    \ limited range. */\n           if ((lTarget==SUBL)&&(sIndAug!=0)) {\n       \
    \        searchAugmentedCB(sIndAug, eIndAug, stage,\n                   2*base_size-20,\
    \ target, cbvectors+lMem,\n                   &max_measure, &best_index, &gain,\
    \ energy,\n                   invenergy);\n           }\n           /* record\
    \ best index */\n           index[stage] = best_index;\n           /* gain quantization\
    \ */\n           if (stage==0){\n               if (gain<0.0){\n             \
    \      gain = 0.0;\n               }\n               if (gain>CB_MAXGAIN) {\n\
    \                   gain = (float)CB_MAXGAIN;\n               }\n            \
    \   gain = gainquant(gain, 1.0, 32, &gain_index[stage]);\n           }\n     \
    \      else {\n               if (stage==1) {\n                   gain = gainquant(gain,\
    \ (float)fabs(gains[stage-1]),\n                       16, &gain_index[stage]);\n\
    \               } else {\n                   gain = gainquant(gain, (float)fabs(gains[stage-1]),\n\
    \                       8, &gain_index[stage]);\n               }\n          \
    \ }\n           /* Extract the best (according to measure)\n              codebook\
    \ vector */\n           if (lTarget==(STATE_LEN-iLBCenc_inst->state_short_len))\
    \ {\n               if (index[stage]<base_size) {\n                   pp=buf+LPC_FILTERORDER+lMem-lTarget-index[stage];\n\
    \               } else {\n                   pp=cbvectors+lMem-lTarget-\n    \
    \                   index[stage]+base_size;\n               }\n           } else\
    \ {\n               if (index[stage]<base_size) {\n                   if (index[stage]<(base_size-20))\
    \ {\n                       pp=buf+LPC_FILTERORDER+lMem-\n                   \
    \        lTarget-index[stage];\n                   } else {\n                \
    \       createAugmentedVec(index[stage]-base_size+40,\n                      \
    \         buf+LPC_FILTERORDER+lMem,aug_vec);\n                       pp=aug_vec;\n\
    \                   }\n               } else {\n                   int filterno,\
    \ position;\n                   filterno=index[stage]/base_size;\n           \
    \        position=index[stage]-filterno*base_size;\n                   if (position<(base_size-20))\
    \ {\n                       pp=cbvectors+filterno*lMem-lTarget-\n            \
    \               index[stage]+filterno*base_size;\n                   } else {\n\
    \                       createAugmentedVec(\n                           index[stage]-(filterno+1)*base_size+40,\n\
    \                           cbvectors+filterno*lMem,aug_vec);\n              \
    \         pp=aug_vec;\n                   }\n               }\n           }\n\
    \           /* Subtract the best codebook vector, according\n              to\
    \ measure, from the target vector */\n           for (j=0;j<lTarget;j++) {\n \
    \              cvec[j] += gain*(*pp);\n               target[j] -= gain*(*pp++);\n\
    \           }\n           /* record quantized gain */\n           gains[stage]=gain;\n\
    \       }/* end of Main Loop. for (stage=0;... */\n       /* Gain adjustment for\
    \ energy matching */\n       cene=0.0;\n       for (i=0; i<lTarget; i++) {\n \
    \          cene+=cvec[i]*cvec[i];\n       }\n       j=gain_index[0];\n       for\
    \ (i=gain_index[0]; i<32; i++) {\n           ftmp=cene*gain_sq5Tbl[i]*gain_sq5Tbl[i];\n\
    \           if ((ftmp<(tene*gains[0]*gains[0])) &&\n               (gain_sq5Tbl[j]<(2.0*gains[0])))\
    \ {\n               j=i;\n           }\n       }\n       gain_index[0]=j;\n  \
    \ }\n"
- title: A.35.  LPCdecode.h
  contents:
  - "A.35.  LPCdecode.h\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       LPC_decode.h\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #ifndef __iLBC_LPC_DECODE_H\n   #define __iLBC_LPC_DECODE_H\n   void LSFinterpolate2a_dec(\n\
    \       float *a,           /* (o) lpc coefficients for a sub-frame */\n     \
    \  float *lsf1,    /* (i) first lsf coefficient vector */\n       float *lsf2,\
    \    /* (i) second lsf coefficient vector */\n       float coef,         /* (i)\
    \ interpolation weight */\n       int length          /* (i) length of lsf vectors\
    \ */\n   );\n   void SimplelsfDEQ(\n       float *lsfdeq,      /* (o) dequantized\
    \ lsf coefficients */\n       int *index,         /* (i) quantization index */\n\
    \       int lpc_n           /* (i) number of LPCs */\n   );\n   void DecoderInterpolateLSF(\n\
    \       float *syntdenum,   /* (o) synthesis filter coefficients */\n       float\
    \ *weightdenum, /* (o) weighting denumerator\n                               \
    \   coefficients */\n       float *lsfdeq,      /* (i) dequantized lsf coefficients\
    \ */\n       int length,         /* (i) length of lsf coefficient vector */\n\
    \       iLBC_Dec_Inst_t *iLBCdec_inst\n                           /* (i) the decoder\
    \ state structure */\n   );\n   #endif\n"
- title: A.36.  LPCdecode.c
  contents:
  - "A.36.  LPCdecode.c\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       LPC_decode.c\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #include <math.h>\n   #include <string.h>\n   #include \"helpfun.h\"\n   #include\
    \ \"lsf.h\"\n   #include \"iLBC_define.h\"\n   #include \"constants.h\"\n   /*---------------------------------------------------------------*\n\
    \    *  interpolation of lsf coefficients for the decoder\n    *--------------------------------------------------------------*/\n\
    \   void LSFinterpolate2a_dec(\n       float *a,           /* (o) lpc coefficients\
    \ for a sub-frame */\n       float *lsf1,    /* (i) first lsf coefficient vector\
    \ */\n       float *lsf2,    /* (i) second lsf coefficient vector */\n       float\
    \ coef,         /* (i) interpolation weight */\n       int length          /*\
    \ (i) length of lsf vectors */\n   ){\n       float  lsftmp[LPC_FILTERORDER];\n\
    \       interpolate(lsftmp, lsf1, lsf2, coef, length);\n       lsf2a(a, lsftmp);\n\
    \   }\n   /*---------------------------------------------------------------*\n\
    \    *  obtain dequantized lsf coefficients from quantization index\n    *--------------------------------------------------------------*/\n\
    \   void SimplelsfDEQ(\n       float *lsfdeq,    /* (o) dequantized lsf coefficients\
    \ */\n       int *index,         /* (i) quantization index */\n       int lpc_n\
    \           /* (i) number of LPCs */\n   ){\n       int i, j, pos, cb_pos;\n \
    \      /* decode first LSF */\n       pos = 0;\n       cb_pos = 0;\n       for\
    \ (i = 0; i < LSF_NSPLIT; i++) {\n           for (j = 0; j < dim_lsfCbTbl[i];\
    \ j++) {\n               lsfdeq[pos + j] = lsfCbTbl[cb_pos +\n               \
    \    (long)(index[i])*dim_lsfCbTbl[i] + j];\n           }\n           pos += dim_lsfCbTbl[i];\n\
    \           cb_pos += size_lsfCbTbl[i]*dim_lsfCbTbl[i];\n       }\n       if (lpc_n>1)\
    \ {\n           /* decode last LSF */\n           pos = 0;\n           cb_pos\
    \ = 0;\n           for (i = 0; i < LSF_NSPLIT; i++) {\n               for (j =\
    \ 0; j < dim_lsfCbTbl[i]; j++) {\n                   lsfdeq[LPC_FILTERORDER +\
    \ pos + j] =\n                       lsfCbTbl[cb_pos +\n                     \
    \  (long)(index[LSF_NSPLIT + i])*\n                       dim_lsfCbTbl[i] + j];\n\
    \               }\n               pos += dim_lsfCbTbl[i];\n               cb_pos\
    \ += size_lsfCbTbl[i]*dim_lsfCbTbl[i];\n           }\n       }\n   }\n   /*----------------------------------------------------------------*\n\
    \    *  obtain synthesis and weighting filters form lsf coefficients\n    *---------------------------------------------------------------*/\n\
    \   void DecoderInterpolateLSF(\n       float *syntdenum, /* (o) synthesis filter\
    \ coefficients */\n       float *weightdenum, /* (o) weighting denumerator\n \
    \                                 coefficients */\n       float *lsfdeq,     \
    \  /* (i) dequantized lsf coefficients */\n       int length,         /* (i) length\
    \ of lsf coefficient vector */\n       iLBC_Dec_Inst_t *iLBCdec_inst\n       \
    \                    /* (i) the decoder state structure */\n   ){\n       int\
    \    i, pos, lp_length;\n       float  lp[LPC_FILTERORDER + 1], *lsfdeq2;\n  \
    \     lsfdeq2 = lsfdeq + length;\n       lp_length = length + 1;\n       if (iLBCdec_inst->mode==30)\
    \ {\n           /* sub-frame 1: Interpolation between old and first */\n     \
    \      LSFinterpolate2a_dec(lp, iLBCdec_inst->lsfdeqold, lsfdeq,\n           \
    \    lsf_weightTbl_30ms[0], length);\n           memcpy(syntdenum,lp,lp_length*sizeof(float));\n\
    \           bwexpand(weightdenum, lp, LPC_CHIRP_WEIGHTDENUM,\n               lp_length);\n\
    \           /* sub-frames 2 to 6: interpolation between first\n              and\
    \ last LSF */\n           pos = lp_length;\n           for (i = 1; i < 6; i++)\
    \ {\n               LSFinterpolate2a_dec(lp, lsfdeq, lsfdeq2,\n              \
    \     lsf_weightTbl_30ms[i], length);\n               memcpy(syntdenum + pos,lp,lp_length*sizeof(float));\n\
    \               bwexpand(weightdenum + pos, lp,\n                   LPC_CHIRP_WEIGHTDENUM,\
    \ lp_length);\n               pos += lp_length;\n           }\n       }\n    \
    \   else {\n           pos = 0;\n           for (i = 0; i < iLBCdec_inst->nsub;\
    \ i++) {\n               LSFinterpolate2a_dec(lp, iLBCdec_inst->lsfdeqold,\n \
    \                  lsfdeq, lsf_weightTbl_20ms[i], length);\n               memcpy(syntdenum+pos,lp,lp_length*sizeof(float));\n\
    \               bwexpand(weightdenum+pos, lp, LPC_CHIRP_WEIGHTDENUM,\n       \
    \            lp_length);\n               pos += lp_length;\n           }\n   \
    \    }\n       /* update memory */\n       if (iLBCdec_inst->mode==30)\n     \
    \      memcpy(iLBCdec_inst->lsfdeqold, lsfdeq2,\n                       length*sizeof(float));\n\
    \       else\n           memcpy(iLBCdec_inst->lsfdeqold, lsfdeq,\n           \
    \            length*sizeof(float));\n   }\n"
- title: A.37.  LPCencode.h
  contents:
  - "A.37.  LPCencode.h\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       LPCencode.h\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #ifndef __iLBC_LPCENCOD_H\n   #define __iLBC_LPCENCOD_H\n   void LPCencode(\n\
    \       float *syntdenum,   /* (i/o) synthesis filter coefficients\n         \
    \                         before/after encoding */\n       float *weightdenum,\
    \ /* (i/o) weighting denumerator coefficients\n                              \
    \    before/after encoding */\n       int *lsf_index,     /* (o) lsf quantization\
    \ index */\n       float *data,    /* (i) lsf coefficients to quantize */\n  \
    \     iLBC_Enc_Inst_t *iLBCenc_inst\n                           /* (i/o) the encoder\
    \ state structure */\n   );\n   #endif\n"
- title: A.38.  LPCencode.c
  contents:
  - "A.38.  LPCencode.c\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       LPCencode.c\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #include <string.h>\n   #include \"iLBC_define.h\"\n   #include \"helpfun.h\"\
    \n   #include \"lsf.h\"\n   #include \"constants.h\"\n   /*----------------------------------------------------------------*\n\
    \    *  lpc analysis (subrutine to LPCencode)\n    *---------------------------------------------------------------*/\n\
    \   void SimpleAnalysis(\n       float *lsf,         /* (o) lsf coefficients */\n\
    \       float *data,    /* (i) new data vector */\n       iLBC_Enc_Inst_t *iLBCenc_inst\n\
    \                           /* (i/o) the encoder state structure */\n   ){\n \
    \      int k, is;\n       float temp[BLOCKL_MAX], lp[LPC_FILTERORDER + 1];\n \
    \      float lp2[LPC_FILTERORDER + 1];\n       float r[LPC_FILTERORDER + 1];\n\
    \       is=LPC_LOOKBACK+BLOCKL_MAX-iLBCenc_inst->blockl;\n       memcpy(iLBCenc_inst->lpc_buffer+is,data,\n\
    \           iLBCenc_inst->blockl*sizeof(float));\n       /* No lookahead, last\
    \ window is asymmetric */\n       for (k = 0; k < iLBCenc_inst->lpc_n; k++) {\n\
    \           is = LPC_LOOKBACK;\n           if (k < (iLBCenc_inst->lpc_n - 1))\
    \ {\n               window(temp, lpc_winTbl,\n                   iLBCenc_inst->lpc_buffer,\
    \ BLOCKL_MAX);\n           } else {\n               window(temp, lpc_asymwinTbl,\n\
    \                   iLBCenc_inst->lpc_buffer + is, BLOCKL_MAX);\n           }\n\
    \           autocorr(r, temp, BLOCKL_MAX, LPC_FILTERORDER);\n           window(r,\
    \ r, lpc_lagwinTbl, LPC_FILTERORDER + 1);\n           levdurb(lp, temp, r, LPC_FILTERORDER);\n\
    \           bwexpand(lp2, lp, LPC_CHIRP_SYNTDENUM, LPC_FILTERORDER+1);\n     \
    \      a2lsf(lsf + k*LPC_FILTERORDER, lp2);\n       }\n       is=LPC_LOOKBACK+BLOCKL_MAX-iLBCenc_inst->blockl;\n\
    \       memmove(iLBCenc_inst->lpc_buffer,\n           iLBCenc_inst->lpc_buffer+LPC_LOOKBACK+BLOCKL_MAX-is,\n\
    \           is*sizeof(float));\n   }\n   /*----------------------------------------------------------------*\n\
    \    *  lsf interpolator and conversion from lsf to a coefficients\n    *  (subrutine\
    \ to SimpleInterpolateLSF)\n    *---------------------------------------------------------------*/\n\
    \   void LSFinterpolate2a_enc(\n       float *a,       /* (o) lpc coefficients\
    \ */\n       float *lsf1,/* (i) first set of lsf coefficients */\n       float\
    \ *lsf2,/* (i) second set of lsf coefficients */\n       float coef,     /* (i)\
    \ weighting coefficient to use between\n                              lsf1 and\
    \ lsf2 */\n       long length      /* (i) length of coefficient vectors */\n \
    \  ){\n       float  lsftmp[LPC_FILTERORDER];\n       interpolate(lsftmp, lsf1,\
    \ lsf2, coef, length);\n       lsf2a(a, lsftmp);\n   }\n   /*----------------------------------------------------------------*\n\
    \    *  lsf interpolator (subrutine to LPCencode)\n    *---------------------------------------------------------------*/\n\
    \   void SimpleInterpolateLSF(\n       float *syntdenum,   /* (o) the synthesis\
    \ filter denominator\n                                  resulting from the quantized\n\
    \                                  interpolated lsf */\n       float *weightdenum,\
    \ /* (o) the weighting filter denominator\n                                  resulting\
    \ from the unquantized\n                                  interpolated lsf */\n\
    \       float *lsf,         /* (i) the unquantized lsf coefficients */\n     \
    \  float *lsfdeq,      /* (i) the dequantized lsf coefficients */\n       float\
    \ *lsfold,      /* (i) the unquantized lsf coefficients of\n                 \
    \                 the previous signal frame */\n       float *lsfdeqold, /* (i)\
    \ the dequantized lsf coefficients of\n                                  the previous\
    \ signal frame */\n       int length,         /* (i) should equate LPC_FILTERORDER\
    \ */\n       iLBC_Enc_Inst_t *iLBCenc_inst\n                           /* (i/o)\
    \ the encoder state structure */\n   ){\n       int    i, pos, lp_length;\n  \
    \     float  lp[LPC_FILTERORDER + 1], *lsf2, *lsfdeq2;\n       lsf2 = lsf + length;\n\
    \       lsfdeq2 = lsfdeq + length;\n       lp_length = length + 1;\n       if\
    \ (iLBCenc_inst->mode==30) {\n           /* sub-frame 1: Interpolation between\
    \ old and first\n              set of lsf coefficients */\n           LSFinterpolate2a_enc(lp,\
    \ lsfdeqold, lsfdeq,\n               lsf_weightTbl_30ms[0], length);\n       \
    \    memcpy(syntdenum,lp,lp_length*sizeof(float));\n           LSFinterpolate2a_enc(lp,\
    \ lsfold, lsf,\n               lsf_weightTbl_30ms[0], length);\n           bwexpand(weightdenum,\
    \ lp, LPC_CHIRP_WEIGHTDENUM, lp_length);\n           /* sub-frame 2 to 6: Interpolation\
    \ between first\n              and second set of lsf coefficients */\n       \
    \    pos = lp_length;\n           for (i = 1; i < iLBCenc_inst->nsub; i++) {\n\
    \               LSFinterpolate2a_enc(lp, lsfdeq, lsfdeq2,\n                  \
    \ lsf_weightTbl_30ms[i], length);\n               memcpy(syntdenum + pos,lp,lp_length*sizeof(float));\n\
    \               LSFinterpolate2a_enc(lp, lsf, lsf2,\n                   lsf_weightTbl_30ms[i],\
    \ length);\n               bwexpand(weightdenum + pos, lp,\n                 \
    \  LPC_CHIRP_WEIGHTDENUM, lp_length);\n               pos += lp_length;\n    \
    \       }\n       }\n       else {\n           pos = 0;\n           for (i = 0;\
    \ i < iLBCenc_inst->nsub; i++) {\n               LSFinterpolate2a_enc(lp, lsfdeqold,\
    \ lsfdeq,\n                   lsf_weightTbl_20ms[i], length);\n              \
    \ memcpy(syntdenum+pos,lp,lp_length*sizeof(float));\n               LSFinterpolate2a_enc(lp,\
    \ lsfold, lsf,\n                   lsf_weightTbl_20ms[i], length);\n         \
    \      bwexpand(weightdenum+pos, lp,\n                   LPC_CHIRP_WEIGHTDENUM,\
    \ lp_length);\n               pos += lp_length;\n           }\n       }\n    \
    \   /* update memory */\n       if (iLBCenc_inst->mode==30) {\n           memcpy(lsfold,\
    \ lsf2, length*sizeof(float));\n           memcpy(lsfdeqold, lsfdeq2, length*sizeof(float));\n\
    \       }\n       else {\n           memcpy(lsfold, lsf, length*sizeof(float));\n\
    \           memcpy(lsfdeqold, lsfdeq, length*sizeof(float));\n       }\n   }\n\
    \   /*----------------------------------------------------------------*\n    *\
    \  lsf quantizer (subrutine to LPCencode)\n    *---------------------------------------------------------------*/\n\
    \   void SimplelsfQ(\n       float *lsfdeq,    /* (o) dequantized lsf coefficients\n\
    \                              (dimension FILTERORDER) */\n       int *index,\
    \     /* (o) quantization index */\n       float *lsf,      /* (i) the lsf coefficient\
    \ vector to be\n                              quantized (dimension FILTERORDER\
    \ ) */\n       int lpc_n     /* (i) number of lsf sets to quantize */\n   ){\n\
    \       /* Quantize first LSF with memoryless split VQ */\n       SplitVQ(lsfdeq,\
    \ index, lsf, lsfCbTbl, LSF_NSPLIT,\n           dim_lsfCbTbl, size_lsfCbTbl);\n\
    \       if (lpc_n==2) {\n           /* Quantize second LSF with memoryless split\
    \ VQ */\n           SplitVQ(lsfdeq + LPC_FILTERORDER, index + LSF_NSPLIT,\n  \
    \             lsf + LPC_FILTERORDER, lsfCbTbl, LSF_NSPLIT,\n               dim_lsfCbTbl,\
    \ size_lsfCbTbl);\n       }\n   }\n   /*----------------------------------------------------------------*\n\
    \    *  lpc encoder\n    *---------------------------------------------------------------*/\n\
    \   void LPCencode(\n       float *syntdenum, /* (i/o) synthesis filter coefficients\n\
    \                                  before/after encoding */\n       float *weightdenum,\
    \ /* (i/o) weighting denumerator\n                                  coefficients\
    \ before/after\n                                  encoding */\n       int *lsf_index,\
    \     /* (o) lsf quantization index */\n       float *data,    /* (i) lsf coefficients\
    \ to quantize */\n       iLBC_Enc_Inst_t *iLBCenc_inst\n                     \
    \      /* (i/o) the encoder state structure */\n   ){\n       float lsf[LPC_FILTERORDER\
    \ * LPC_N_MAX];\n       float lsfdeq[LPC_FILTERORDER * LPC_N_MAX];\n       int\
    \ change=0;\n       SimpleAnalysis(lsf, data, iLBCenc_inst);\n       SimplelsfQ(lsfdeq,\
    \ lsf_index, lsf, iLBCenc_inst->lpc_n);\n       change=LSF_check(lsfdeq, LPC_FILTERORDER,\
    \ iLBCenc_inst->lpc_n);\n       SimpleInterpolateLSF(syntdenum, weightdenum,\n\
    \           lsf, lsfdeq, iLBCenc_inst->lsfold,\n           iLBCenc_inst->lsfdeqold,\
    \ LPC_FILTERORDER, iLBCenc_inst);\n   }\n"
- title: A.39.  lsf.h
  contents:
  - "A.39.  lsf.h\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       lsf.h\n       Copyright (C)\
    \ The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #ifndef __iLBC_LSF_H\n   #define __iLBC_LSF_H\n   void a2lsf(\n       float\
    \ *freq,/* (o) lsf coefficients */\n       float *a    /* (i) lpc coefficients\
    \ */\n   );\n   void lsf2a(\n       float *a_coef,  /* (o) lpc coefficients */\n\
    \       float *freq     /* (i) lsf coefficients */\n   );\n   #endif\n"
- title: A.40.  lsf.c
  contents:
  - "A.40.  lsf.c\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       lsf.c\n       Copyright (C)\
    \ The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #include <string.h>\n   #include <math.h>\n   #include \"iLBC_define.h\"\n\
    \   /*----------------------------------------------------------------*\n    *\
    \  conversion from lpc coefficients to lsf coefficients\n    *---------------------------------------------------------------*/\n\
    \   void a2lsf(\n       float *freq,/* (o) lsf coefficients */\n       float *a\
    \    /* (i) lpc coefficients */\n   ){\n       float steps[LSF_NUMBER_OF_STEPS]\
    \ =\n           {(float)0.00635, (float)0.003175, (float)0.0015875,\n        \
    \   (float)0.00079375};\n       float step;\n       int step_idx;\n       int\
    \ lsp_index;\n       float p[LPC_HALFORDER];\n       float q[LPC_HALFORDER];\n\
    \       float p_pre[LPC_HALFORDER];\n       float q_pre[LPC_HALFORDER];\n    \
    \   float old_p, old_q, *old;\n       float *pq_coef;\n       float omega, old_omega;\n\
    \       int i;\n       float hlp, hlp1, hlp2, hlp3, hlp4, hlp5;\n       for (i=0;\
    \ i<LPC_HALFORDER; i++) {\n           p[i] = (float)-1.0 * (a[i + 1] + a[LPC_FILTERORDER\
    \ - i]);\n           q[i] = a[LPC_FILTERORDER - i] - a[i + 1];\n       }\n   \
    \    p_pre[0] = (float)-1.0 - p[0];\n       p_pre[1] = - p_pre[0] - p[1];\n  \
    \     p_pre[2] = - p_pre[1] - p[2];\n       p_pre[3] = - p_pre[2] - p[3];\n  \
    \     p_pre[4] = - p_pre[3] - p[4];\n       p_pre[4] = p_pre[4] / 2;\n       q_pre[0]\
    \ = (float)1.0 - q[0];\n       q_pre[1] = q_pre[0] - q[1];\n       q_pre[2] =\
    \ q_pre[1] - q[2];\n       q_pre[3] = q_pre[2] - q[3];\n       q_pre[4] = q_pre[3]\
    \ - q[4];\n       q_pre[4] = q_pre[4] / 2;\n       omega = 0.0;\n       old_omega\
    \ = 0.0;\n       old_p = FLOAT_MAX;\n       old_q = FLOAT_MAX;\n       /* Here\
    \ we loop through lsp_index to find all the\n          LPC_FILTERORDER roots for\
    \ omega. */\n       for (lsp_index = 0; lsp_index<LPC_FILTERORDER; lsp_index++)\
    \ {\n           /* Depending on lsp_index being even or odd, we\n           alternatively\
    \ solve the roots for the two LSP equations. */\n           if ((lsp_index & 0x1)\
    \ == 0) {\n               pq_coef = p_pre;\n               old = &old_p;\n   \
    \        } else {\n               pq_coef = q_pre;\n               old = &old_q;\n\
    \           }\n           /* Start with low resolution grid */\n           for\
    \ (step_idx = 0, step = steps[step_idx];\n               step_idx < LSF_NUMBER_OF_STEPS;){\n\
    \               /*  cos(10piw) + pq(0)cos(8piw) + pq(1)cos(6piw) +\n         \
    \      pq(2)cos(4piw) + pq(3)cod(2piw) + pq(4) */\n               hlp = (float)cos(omega\
    \ * TWO_PI);\n               hlp1 = (float)2.0 * hlp + pq_coef[0];\n         \
    \      hlp2 = (float)2.0 * hlp * hlp1 - (float)1.0 +\n                   pq_coef[1];\n\
    \               hlp3 = (float)2.0 * hlp * hlp2 - hlp1 + pq_coef[2];\n        \
    \       hlp4 = (float)2.0 * hlp * hlp3 - hlp2 + pq_coef[3];\n               hlp5\
    \ = hlp * hlp4 - hlp3 + pq_coef[4];\n               if (((hlp5 * (*old)) <= 0.0)\
    \ || (omega >= 0.5)){\n                   if (step_idx == (LSF_NUMBER_OF_STEPS\
    \ - 1)){\n                       if (fabs(hlp5) >= fabs(*old)) {\n           \
    \                freq[lsp_index] = omega - step;\n                       } else\
    \ {\n                           freq[lsp_index] = omega;\n                   \
    \    }\n                       if ((*old) >= 0.0){\n                         \
    \  *old = (float)-1.0 * FLOAT_MAX;\n                       } else {\n        \
    \                   *old = FLOAT_MAX;\n                       }\n            \
    \           omega = old_omega;\n                       step_idx = 0;\n       \
    \                step_idx = LSF_NUMBER_OF_STEPS;\n                   } else {\n\
    \                       if (step_idx == 0) {\n                           old_omega\
    \ = omega;\n                       }\n                       step_idx++;\n   \
    \                    omega -= steps[step_idx];\n                       /* Go back\
    \ one grid step */\n                       step = steps[step_idx];\n         \
    \          }\n               } else {\n               /* increment omega until\
    \ they are of different sign,\n               and we know there is at least one\
    \ root between omega\n               and old_omega */\n                   *old\
    \ = hlp5;\n                   omega += step;\n               }\n           }\n\
    \       }\n       for (i = 0; i<LPC_FILTERORDER; i++) {\n           freq[i] =\
    \ freq[i] * TWO_PI;\n       }\n   }\n   /*----------------------------------------------------------------*\n\
    \    *  conversion from lsf coefficients to lpc coefficients\n    *---------------------------------------------------------------*/\n\
    \   void lsf2a(\n       float *a_coef,  /* (o) lpc coefficients */\n       float\
    \ *freq     /* (i) lsf coefficients */\n   ){\n       int i, j;\n       float\
    \ hlp;\n       float p[LPC_HALFORDER], q[LPC_HALFORDER];\n       float a[LPC_HALFORDER\
    \ + 1], a1[LPC_HALFORDER],\n           a2[LPC_HALFORDER];\n       float b[LPC_HALFORDER\
    \ + 1], b1[LPC_HALFORDER],\n           b2[LPC_HALFORDER];\n       for (i=0; i<LPC_FILTERORDER;\
    \ i++) {\n           freq[i] = freq[i] * PI2;\n       }\n       /* Check input\
    \ for ill-conditioned cases.  This part is not\n       found in the TIA standard.\
    \  It involves the following 2 IF\n       blocks.  If \"freq\" is judged ill-conditioned,\
    \ then we first\n       modify freq[0] and freq[LPC_HALFORDER-1] (normally\n \
    \      LPC_HALFORDER = 10 for LPC applications), then we adjust\n       the other\
    \ \"freq\" values slightly */\n       if ((freq[0] <= 0.0) || (freq[LPC_FILTERORDER\
    \ - 1] >= 0.5)){\n           if (freq[0] <= 0.0) {\n               freq[0] = (float)0.022;\n\
    \           }\n           if (freq[LPC_FILTERORDER - 1] >= 0.5) {\n          \
    \     freq[LPC_FILTERORDER - 1] = (float)0.499;\n           }\n           hlp\
    \ = (freq[LPC_FILTERORDER - 1] - freq[0]) /\n               (float) (LPC_FILTERORDER\
    \ - 1);\n           for (i=1; i<LPC_FILTERORDER; i++) {\n               freq[i]\
    \ = freq[i - 1] + hlp;\n           }\n       }\n       memset(a1, 0, LPC_HALFORDER*sizeof(float));\n\
    \       memset(a2, 0, LPC_HALFORDER*sizeof(float));\n       memset(b1, 0, LPC_HALFORDER*sizeof(float));\n\
    \       memset(b2, 0, LPC_HALFORDER*sizeof(float));\n       memset(a, 0, (LPC_HALFORDER+1)*sizeof(float));\n\
    \       memset(b, 0, (LPC_HALFORDER+1)*sizeof(float));\n       /* p[i] and q[i]\
    \ compute cos(2*pi*omega_{2j}) and\n       cos(2*pi*omega_{2j-1} in eqs. 4.2.2.2-1\
    \ and 4.2.2.2-2.\n       Note that for this code p[i] specifies the coefficients\n\
    \       used in .Q_A(z) while q[i] specifies the coefficients used\n       in\
    \ .P_A(z) */\n       for (i=0; i<LPC_HALFORDER; i++) {\n           p[i] = (float)cos(TWO_PI\
    \ * freq[2 * i]);\n           q[i] = (float)cos(TWO_PI * freq[2 * i + 1]);\n \
    \      }\n       a[0] = 0.25;\n       b[0] = 0.25;\n       for (i= 0; i<LPC_HALFORDER;\
    \ i++) {\n           a[i + 1] = a[i] - 2 * p[i] * a1[i] + a2[i];\n           b[i\
    \ + 1] = b[i] - 2 * q[i] * b1[i] + b2[i];\n           a2[i] = a1[i];\n       \
    \    a1[i] = a[i];\n           b2[i] = b1[i];\n           b1[i] = b[i];\n    \
    \   }\n       for (j=0; j<LPC_FILTERORDER; j++) {\n           if (j == 0) {\n\
    \               a[0] = 0.25;\n               b[0] = -0.25;\n           } else\
    \ {\n               a[0] = b[0] = 0.0;\n           }\n           for (i=0; i<LPC_HALFORDER;\
    \ i++) {\n               a[i + 1] = a[i] - 2 * p[i] * a1[i] + a2[i];\n       \
    \        b[i + 1] = b[i] - 2 * q[i] * b1[i] + b2[i];\n               a2[i] = a1[i];\n\
    \               a1[i] = a[i];\n               b2[i] = b1[i];\n               b1[i]\
    \ = b[i];\n           }\n           a_coef[j + 1] = 2 * (a[LPC_HALFORDER] + b[LPC_HALFORDER]);\n\
    \       }\n       a_coef[0] = 1.0;\n   }\n"
- title: A.41.  packing.h
  contents:
  - "A.41.  packing.h\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       packing.h\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #ifndef __PACKING_H\n   #define __PACKING_H\n   void packsplit(\n       int\
    \ *index,                 /* (i) the value to split */\n       int *firstpart,\
    \             /* (o) the value specified by most\n                           \
    \               significant bits */\n       int *rest,                  /* (o)\
    \ the value specified by least\n                                          significant\
    \ bits */\n       int bitno_firstpart,    /* (i) number of bits in most\n    \
    \                                      significant part */\n       int bitno_total\
    \             /* (i) number of bits in full range\n                          \
    \                of value */\n   );\n   void packcombine(\n       int *index,\
    \                 /* (i/o) the msb value in the\n                            \
    \              combined value out */\n       int rest,                   /* (i)\
    \ the lsb value */\n       int bitno_rest              /* (i) the number of bits\
    \ in the\n                                          lsb part */\n   );\n   void\
    \ dopack(\n       unsigned char **bitstream,  /* (i/o) on entrance pointer to\n\
    \                                          place in bitstream to pack\n      \
    \                                    new data, on exit pointer\n             \
    \                             to place in bitstream to\n                     \
    \                     pack future data */\n       int index,                 \
    \ /* (i) the value to pack */\n       int bitno,                  /* (i) the number\
    \ of bits that the\n                                          value will fit within\
    \ */\n       int *pos                /* (i/o) write position in the\n        \
    \                                  current byte */\n   );\n   void unpack(\n \
    \      unsigned char **bitstream,  /* (i/o) on entrance pointer to\n         \
    \                                 place in bitstream to\n                    \
    \                      unpack new data from, on\n                            \
    \              exit pointer to place in\n                                    \
    \      bitstream to unpack future\n                                          data\
    \ from */\n       int *index,                 /* (o) resulting value */\n    \
    \   int bitno,                  /* (i) number of bits used to\n              \
    \                            represent the value */\n       int *pos         \
    \       /* (i/o) read position in the\n                                      \
    \    current byte */\n   );\n   #endif\n"
- title: A.42.  packing.c
  contents:
  - "A.42.  packing.c\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       packing.c\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #include <math.h>\n   #include <stdlib.h>\n   #include \"iLBC_define.h\"\n\
    \   #include \"constants.h\"\n   #include \"helpfun.h\"\n   #include \"string.h\"\
    \n   /*----------------------------------------------------------------*\n   \
    \ *  splitting an integer into first most significant bits and\n    *  remaining\
    \ least significant bits\n    *---------------------------------------------------------------*/\n\
    \   void packsplit(\n       int *index,                 /* (i) the value to split\
    \ */\n       int *firstpart,             /* (o) the value specified by most\n\
    \                                          significant bits */\n       int *rest,\
    \                  /* (o) the value specified by least\n                     \
    \                     significant bits */\n       int bitno_firstpart,    /* (i)\
    \ number of bits in most\n                                          significant\
    \ part */\n       int bitno_total             /* (i) number of bits in full range\n\
    \                                          of value */\n   ){\n       int bitno_rest\
    \ = bitno_total-bitno_firstpart;\n       *firstpart = *index>>(bitno_rest);\n\
    \       *rest = *index-(*firstpart<<(bitno_rest));\n   }\n   /*----------------------------------------------------------------*\n\
    \    *  combining a value corresponding to msb's with a value\n    *  corresponding\
    \ to lsb's\n    *---------------------------------------------------------------*/\n\
    \   void packcombine(\n       int *index,                 /* (i/o) the msb value\
    \ in the\n                                          combined value out */\n  \
    \     int rest,                   /* (i) the lsb value */\n       int bitno_rest\
    \              /* (i) the number of bits in the\n                            \
    \              lsb part */\n   ){\n       *index = *index<<bitno_rest;\n     \
    \  *index += rest;\n   }\n   /*----------------------------------------------------------------*\n\
    \    *  packing of bits into bitstream, i.e., vector of bytes\n    *---------------------------------------------------------------*/\n\
    \   void dopack(\n       unsigned char **bitstream,  /* (i/o) on entrance pointer\
    \ to\n                                          place in bitstream to pack\n \
    \                                         new data, on exit pointer\n        \
    \                                  to place in bitstream to\n                \
    \                          pack future data */\n       int index,            \
    \      /* (i) the value to pack */\n       int bitno,                  /* (i)\
    \ the number of bits that the\n                                          value\
    \ will fit within */\n       int *pos                /* (i/o) write position in\
    \ the\n                                          current byte */\n   ){\n    \
    \   int posLeft;\n       /* Clear the bits before starting in a new byte */\n\
    \       if ((*pos)==0) {\n           **bitstream=0;\n       }\n       while (bitno>0)\
    \ {\n           /* Jump to the next byte if end of this byte is reached*/\n  \
    \         if (*pos==8) {\n               *pos=0;\n               (*bitstream)++;\n\
    \               **bitstream=0;\n           }\n           posLeft=8-(*pos);\n \
    \          /* Insert index into the bitstream */\n           if (bitno <= posLeft)\
    \ {\n               **bitstream |= (unsigned char)(index<<(posLeft-bitno));\n\
    \               *pos+=bitno;\n               bitno=0;\n           } else {\n \
    \              **bitstream |= (unsigned char)(index>>(bitno-posLeft));\n     \
    \          *pos=8;\n               index-=((index>>(bitno-posLeft))<<(bitno-posLeft));\n\
    \               bitno-=posLeft;\n           }\n       }\n   }\n   /*----------------------------------------------------------------*\n\
    \    *  unpacking of bits from bitstream, i.e., vector of bytes\n    *---------------------------------------------------------------*/\n\
    \   void unpack(\n       unsigned char **bitstream,  /* (i/o) on entrance pointer\
    \ to\n                                          place in bitstream to\n      \
    \                                    unpack new data from, on\n              \
    \                            exit pointer to place in\n                      \
    \                    bitstream to unpack future\n                            \
    \              data from */\n       int *index,                 /* (o) resulting\
    \ value */\n       int bitno,                  /* (i) number of bits used to\n\
    \                                          represent the value */\n       int\
    \ *pos                /* (i/o) read position in the\n                        \
    \                  current byte */\n   ){\n       int BitsLeft;\n       *index=0;\n\
    \       while (bitno>0) {\n           /* move forward in bitstream when the end\
    \ of the\n              byte is reached */\n           if (*pos==8) {\n      \
    \         *pos=0;\n               (*bitstream)++;\n           }\n           BitsLeft=8-(*pos);\n\
    \           /* Extract bits to index */\n           if (BitsLeft>=bitno) {\n \
    \              *index+=((((**bitstream)<<(*pos)) & 0xFF)>>(8-bitno));\n      \
    \         *pos+=bitno;\n               bitno=0;\n           } else {\n       \
    \        if ((8-bitno)>0) {\n                   *index+=((((**bitstream)<<(*pos))\
    \ & 0xFF)>>\n                       (8-bitno));\n                   *pos=8;\n\
    \               } else {\n                   *index+=(((int)(((**bitstream)<<(*pos))\
    \ & 0xFF))<<\n                       (bitno-8));\n                   *pos=8;\n\
    \               }\n               bitno-=BitsLeft;\n           }\n       }\n \
    \  }\n"
- title: A.43.  StateConstructW.h
  contents:
  - "A.43.  StateConstructW.h\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       StateConstructW.h\n     \
    \  Copyright (C) The Internet Society (2004).\n       All Rights Reserved.\n \
    \  ******************************************************************/\n   #ifndef\
    \ __iLBC_STATECONSTRUCTW_H\n   #define __iLBC_STATECONSTRUCTW_H\n   void StateConstructW(\n\
    \       int idxForMax,      /* (i) 6-bit index for the quantization of\n     \
    \                             max amplitude */\n       int *idxVec,    /* (i)\
    \ vector of quantization indexes */\n       float *syntDenum,   /* (i) synthesis\
    \ filter denumerator */\n       float *out,         /* (o) the decoded state vector\
    \ */\n       int len             /* (i) length of a state vector */\n   );\n \
    \  #endif\n"
- title: A.44.  StateConstructW.c
  contents:
  - "A.44.  StateConstructW.c\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       StateConstructW.c\n     \
    \  Copyright (C) The Internet Society (2004).\n       All Rights Reserved.\n \
    \  ******************************************************************/\n   #include\
    \ <math.h>\n   #include <string.h>\n   #include \"iLBC_define.h\"\n   #include\
    \ \"constants.h\"\n   #include \"filter.h\"\n   /*----------------------------------------------------------------*\n\
    \    *  decoding of the start state\n    *---------------------------------------------------------------*/\n\
    \   void StateConstructW(\n       int idxForMax,      /* (i) 6-bit index for the\
    \ quantization of\n                                  max amplitude */\n      \
    \ int *idxVec,    /* (i) vector of quantization indexes */\n       float *syntDenum,\
    \   /* (i) synthesis filter denumerator */\n       float *out,         /* (o)\
    \ the decoded state vector */\n       int len             /* (i) length of a state\
    \ vector */\n   ){\n       float maxVal, tmpbuf[LPC_FILTERORDER+2*STATE_LEN],\
    \ *tmp,\n           numerator[LPC_FILTERORDER+1];\n       float foutbuf[LPC_FILTERORDER+2*STATE_LEN],\
    \ *fout;\n       int k,tmpi;\n       /* decoding of the maximum value */\n   \
    \    maxVal = state_frgqTbl[idxForMax];\n       maxVal = (float)pow(10,maxVal)/(float)4.5;\n\
    \       /* initialization of buffers and coefficients */\n       memset(tmpbuf,\
    \ 0, LPC_FILTERORDER*sizeof(float));\n       memset(foutbuf, 0, LPC_FILTERORDER*sizeof(float));\n\
    \       for (k=0; k<LPC_FILTERORDER; k++) {\n           numerator[k]=syntDenum[LPC_FILTERORDER-k];\n\
    \       }\n       numerator[LPC_FILTERORDER]=syntDenum[0];\n       tmp = &tmpbuf[LPC_FILTERORDER];\n\
    \       fout = &foutbuf[LPC_FILTERORDER];\n       /* decoding of the sample values\
    \ */\n       for (k=0; k<len; k++) {\n           tmpi = len-1-k;\n           /*\
    \ maxVal = 1/scal */\n           tmp[k] = maxVal*state_sq3Tbl[idxVec[tmpi]];\n\
    \       }\n       /* circular convolution with all-pass filter */\n       memset(tmp+len,\
    \ 0, len*sizeof(float));\n       ZeroPoleFilter(tmp, numerator, syntDenum, 2*len,\n\
    \           LPC_FILTERORDER, fout);\n       for (k=0;k<len;k++) {\n          \
    \ out[k] = fout[len-1-k]+fout[2*len-1-k];\n       }\n   }\n"
- title: A.45.  StateSearchW.h
  contents:
  - "A.45.  StateSearchW.h\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       StateSearchW.h\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #ifndef __iLBC_STATESEARCHW_H\n   #define __iLBC_STATESEARCHW_H\n   void AbsQuantW(\n\
    \       iLBC_Enc_Inst_t *iLBCenc_inst,\n                           /* (i) Encoder\
    \ instance */\n       float *in,          /* (i) vector to encode */\n       float\
    \ *syntDenum,   /* (i) denominator of synthesis filter */\n       float *weightDenum,\
    \ /* (i) denominator of weighting filter */\n       int *out,           /* (o)\
    \ vector of quantizer indexes */\n       int len,        /* (i) length of vector\
    \ to encode and\n                                  vector of quantizer indexes\
    \ */\n       int state_first     /* (i) position of start state in the\n     \
    \                             80 vec */\n   );\n   void StateSearchW(\n      \
    \ iLBC_Enc_Inst_t *iLBCenc_inst,\n                           /* (i) Encoder instance\
    \ */\n       float *residual,/* (i) target residual vector */\n       float *syntDenum,\
    \   /* (i) lpc synthesis filter */\n       float *weightDenum, /* (i) weighting\
    \ filter denuminator */\n       int *idxForMax,     /* (o) quantizer index for\
    \ maximum\n                                  amplitude */\n       int *idxVec,\
    \    /* (o) vector of quantization indexes */\n       int len,        /* (i) length\
    \ of all vectors */\n       int state_first     /* (i) position of start state\
    \ in the\n                                  80 vec */\n   );\n   #endif\n"
- title: A.46.  StateSearchW.c
  contents:
  - "A.46.  StateSearchW.c\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       StateSearchW.c\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #include <math.h>\n   #include <string.h>\n   #include \"iLBC_define.h\"\n\
    \   #include \"constants.h\"\n   #include \"filter.h\"\n   #include \"helpfun.h\"\
    \n   /*----------------------------------------------------------------*\n   \
    \ *  predictive noise shaping encoding of scaled start state\n    *  (subrutine\
    \ for StateSearchW)\n    *---------------------------------------------------------------*/\n\
    \   void AbsQuantW(\n       iLBC_Enc_Inst_t *iLBCenc_inst,\n                 \
    \          /* (i) Encoder instance */\n       float *in,          /* (i) vector\
    \ to encode */\n       float *syntDenum,   /* (i) denominator of synthesis filter\
    \ */\n       float *weightDenum, /* (i) denominator of weighting filter */\n \
    \      int *out,           /* (o) vector of quantizer indexes */\n       int len,\
    \        /* (i) length of vector to encode and\n                             \
    \     vector of quantizer indexes */\n       int state_first     /* (i) position\
    \ of start state in the\n                                  80 vec */\n   ){\n\
    \       float *syntOut;\n       float syntOutBuf[LPC_FILTERORDER+STATE_SHORT_LEN_30MS];\n\
    \       float toQ, xq;\n       int n;\n       int index;\n       /* initialization\
    \ of buffer for filtering */\n       memset(syntOutBuf, 0, LPC_FILTERORDER*sizeof(float));\n\
    \       /* initialization of pointer for filtering */\n       syntOut = &syntOutBuf[LPC_FILTERORDER];\n\
    \       /* synthesis and weighting filters on input */\n       if (state_first)\
    \ {\n           AllPoleFilter (in, weightDenum, SUBL, LPC_FILTERORDER);\n    \
    \   } else {\n           AllPoleFilter (in, weightDenum,\n               iLBCenc_inst->state_short_len-SUBL,\n\
    \               LPC_FILTERORDER);\n       }\n       /* encoding loop */\n    \
    \   for (n=0; n<len; n++) {\n           /* time update of filter coefficients\
    \ */\n           if ((state_first)&&(n==SUBL)){\n               syntDenum += (LPC_FILTERORDER+1);\n\
    \               weightDenum += (LPC_FILTERORDER+1);\n               /* synthesis\
    \ and weighting filters on input */\n               AllPoleFilter (&in[n], weightDenum,\
    \ len-n,\n                   LPC_FILTERORDER);\n           } else if ((state_first==0)&&\n\
    \               (n==(iLBCenc_inst->state_short_len-SUBL))) {\n               syntDenum\
    \ += (LPC_FILTERORDER+1);\n               weightDenum += (LPC_FILTERORDER+1);\n\
    \               /* synthesis and weighting filters on input */\n             \
    \  AllPoleFilter (&in[n], weightDenum, len-n,\n                   LPC_FILTERORDER);\n\
    \           }\n           /* prediction of synthesized and weighted input */\n\
    \           syntOut[n] = 0.0;\n           AllPoleFilter (&syntOut[n], weightDenum,\
    \ 1,\n               LPC_FILTERORDER);\n           /* quantization */\n      \
    \     toQ = in[n]-syntOut[n];\n           sort_sq(&xq, &index, toQ, state_sq3Tbl,\
    \ 8);\n           out[n]=index;\n           syntOut[n] = state_sq3Tbl[out[n]];\n\
    \           /* update of the prediction filter */\n           AllPoleFilter(&syntOut[n],\
    \ weightDenum, 1,\n               LPC_FILTERORDER);\n       }\n   }\n   /*----------------------------------------------------------------*\n\
    \    *  encoding of start state\n    *---------------------------------------------------------------*/\n\
    \   void StateSearchW(\n       iLBC_Enc_Inst_t *iLBCenc_inst,\n              \
    \             /* (i) Encoder instance */\n       float *residual,/* (i) target\
    \ residual vector */\n       float *syntDenum,   /* (i) lpc synthesis filter */\n\
    \       float *weightDenum, /* (i) weighting filter denuminator */\n       int\
    \ *idxForMax,     /* (o) quantizer index for maximum\n                       \
    \           amplitude */\n       int *idxVec,    /* (o) vector of quantization\
    \ indexes */\n       int len,        /* (i) length of all vectors */\n       int\
    \ state_first     /* (i) position of start state in the\n                    \
    \              80 vec */\n   ){\n       float dtmp, maxVal;\n       float tmpbuf[LPC_FILTERORDER+2*STATE_SHORT_LEN_30MS];\n\
    \       float *tmp, numerator[1+LPC_FILTERORDER];\n       float foutbuf[LPC_FILTERORDER+2*STATE_SHORT_LEN_30MS],\
    \ *fout;\n       int k;\n       float qmax, scal;\n       /* initialization of\
    \ buffers and filter coefficients */\n       memset(tmpbuf, 0, LPC_FILTERORDER*sizeof(float));\n\
    \       memset(foutbuf, 0, LPC_FILTERORDER*sizeof(float));\n       for (k=0; k<LPC_FILTERORDER;\
    \ k++) {\n           numerator[k]=syntDenum[LPC_FILTERORDER-k];\n       }\n  \
    \     numerator[LPC_FILTERORDER]=syntDenum[0];\n       tmp = &tmpbuf[LPC_FILTERORDER];\n\
    \       fout = &foutbuf[LPC_FILTERORDER];\n       /* circular convolution with\
    \ the all-pass filter */\n       memcpy(tmp, residual, len*sizeof(float));\n \
    \      memset(tmp+len, 0, len*sizeof(float));\n       ZeroPoleFilter(tmp, numerator,\
    \ syntDenum, 2*len,\n           LPC_FILTERORDER, fout);\n       for (k=0; k<len;\
    \ k++) {\n           fout[k] += fout[k+len];\n       }\n       /* identification\
    \ of the maximum amplitude value */\n       maxVal = fout[0];\n       for (k=1;\
    \ k<len; k++) {\n           if (fout[k]*fout[k] > maxVal*maxVal){\n          \
    \     maxVal = fout[k];\n           }\n       }\n       maxVal=(float)fabs(maxVal);\n\
    \       /* encoding of the maximum amplitude value */\n       if (maxVal < 10.0)\
    \ {\n           maxVal = 10.0;\n       }\n       maxVal = (float)log10(maxVal);\n\
    \       sort_sq(&dtmp, idxForMax, maxVal, state_frgqTbl, 64);\n       /* decoding\
    \ of the maximum amplitude representation value,\n          and corresponding\
    \ scaling of start state */\n       maxVal=state_frgqTbl[*idxForMax];\n      \
    \ qmax = (float)pow(10,maxVal);\n       scal = (float)(4.5)/qmax;\n       for\
    \ (k=0; k<len; k++){\n           fout[k] *= scal;\n       }\n       /* predictive\
    \ noise shaping encoding of scaled start state */\n       AbsQuantW(iLBCenc_inst,\
    \ fout,syntDenum,\n           weightDenum,idxVec, len, state_first);\n   }\n"
- title: A.47.  syntFilter.h
  contents:
  - "A.47.  syntFilter.h\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       syntFilter.h\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #ifndef __iLBC_SYNTFILTER_H\n   #define __iLBC_SYNTFILTER_H\n   void syntFilter(\n\
    \       float *Out,     /* (i/o) Signal to be filtered */\n       float *a,  \
    \     /* (i) LP parameters */\n       int len,    /* (i) Length of signal */\n\
    \       float *mem      /* (i/o) Filter state */\n   );\n   #endif\n"
- title: A.48.  syntFilter.c
  contents:
  - "A.48.  syntFilter.c\n   /******************************************************************\n\
    \       iLBC Speech Coder ANSI-C Source Code\n       syntFilter.c\n       Copyright\
    \ (C) The Internet Society (2004).\n       All Rights Reserved.\n   ******************************************************************/\n\
    \   #include \"iLBC_define.h\"\n   /*----------------------------------------------------------------*\n\
    \    *  LP synthesis filter.\n    *---------------------------------------------------------------*/\n\
    \   void syntFilter(\n       float *Out,     /* (i/o) Signal to be filtered */\n\
    \       float *a,       /* (i) LP parameters */\n       int len,    /* (i) Length\
    \ of signal */\n       float *mem      /* (i/o) Filter state */\n   ){\n     \
    \  int i, j;\n       float *po, *pi, *pa, *pm;\n       po=Out;\n       /* Filter\
    \ first part using memory from past */\n       for (i=0; i<LPC_FILTERORDER; i++)\
    \ {\n           pi=&Out[i-1];\n           pa=&a[1];\n           pm=&mem[LPC_FILTERORDER-1];\n\
    \           for (j=1; j<=i; j++) {\n               *po-=(*pa++)*(*pi--);\n   \
    \        }\n           for (j=i+1; j<LPC_FILTERORDER+1; j++) {\n             \
    \  *po-=(*pa++)*(*pm--);\n           }\n           po++;\n       }\n       /*\
    \ Filter last part where the state is entirely in\n          the output vector\
    \ */\n       for (i=LPC_FILTERORDER; i<len; i++) {\n           pi=&Out[i-1];\n\
    \           pa=&a[1];\n           for (j=1; j<LPC_FILTERORDER+1; j++) {\n    \
    \           *po-=(*pa++)*(*pi--);\n           }\n           po++;\n       }\n\
    \       /* Update state vector */\n       memcpy(mem, &Out[len-LPC_FILTERORDER],\n\
    \           LPC_FILTERORDER*sizeof(float));\n   }\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Soren Vang Andersen\n   Department of Communication Technology\n\
    \   Aalborg University\n   Fredrik Bajers Vej 7A\n   9200 Aalborg\n   Denmark\n\
    \   Phone:  ++45 9 6358627\n   EMail:  sva@kom.auc.dk\n   Alan Duric\n   Telio\
    \ AS\n   Stoperigt. 2\n   Oslo, N-0250\n   Norway\n   Phone:  +47 21673555\n \
    \  EMail:  alan.duric@telio.no\n   Henrik Astrom\n   Global IP Sound AB\n   Olandsgatan\
    \ 42\n   Stockholm, S-11663\n   Sweden\n   Phone:  +46 8 54553040\n   EMail: \
    \ henrik.astrom@globalipsound.com\n   Roar Hagen\n   Global IP Sound AB\n   Olandsgatan\
    \ 42\n   Stockholm, S-11663\n   Sweden\n   Phone:  +46 8 54553040\n   EMail: \
    \ roar.hagen@globalipsound.com\n   W. Bastiaan Kleijn\n   Global IP Sound AB\n\
    \   Olandsgatan 42\n   Stockholm, S-11663\n   Sweden\n   Phone:  +46 8 54553040\n\
    \   EMail:  bastiaan.kleijn@globalipsound.com\n   Jan Linden\n   Global IP Sound\
    \ Inc.\n   900 Kearny Street, suite 500\n   San Francisco, CA-94133\n   USA\n\
    \   Phone: +1 415 397 2555\n   EMail: jan.linden@globalipsound.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2004).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ IETF's procedures with respect to rights in IETF Documents can\n   be found\
    \ in BCP 78 and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat\
    \ and any\n   assurances of licenses to be made available, or the result of an\n\
    \   attempt made to obtain a general license or permission for the use of\n  \
    \ such proprietary rights by implementers or users of this\n   specification can\
    \ be obtained from the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n\
    \   The IETF invites any interested party to bring to its attention any\n   copyrights,\
    \ patents or patent applications, or other proprietary\n   rights that may cover\
    \ technology that may be required to implement\n   this standard.  Please address\
    \ the information to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
