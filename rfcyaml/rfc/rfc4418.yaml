- title: __initial_text__
  contents:
  - '       UMAC: Message Authentication Code using Universal Hashing

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
- title: Abstract
  contents:
  - "Abstract\n   This specification describes how to generate an authentication tag\n\
    \   using the UMAC message authentication algorithm.  UMAC is designed to\n  \
    \ be very fast to compute in software on contemporary uniprocessors.\n   Measured\
    \ speeds are as low as one cycle per byte.  UMAC relies on\n   addition of 32-bit\
    \ and 64-bit numbers and multiplication of 32-bit\n   numbers, operations well-supported\
    \ by contemporary machines.\n   To generate the authentication tag on a given\
    \ message, a \"universal\"\n   hash function is applied to the message and key\
    \ to produce a short,\n   fixed-length hash value, and this hash value is then\
    \ xor'ed with a\n   key-derived pseudorandom pad.  UMAC enjoys a rigorous security\n\
    \   analysis, and its only internal \"cryptographic\" component is a block\n \
    \  cipher used to generate the pseudorandom pads and internal key\n   material.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Notation and Basic Operations ...................................4\n  \
    \    2.1. Operations on strings ......................................4\n    \
    \  2.2. Operations on Integers .....................................5\n      2.3.\
    \ String-Integer Conversion Operations .......................6\n      2.4. Mathematical\
    \ Operations on Strings .........................6\n      2.5. ENDIAN-SWAP: Adjusting\
    \ Endian Orientation ..................6\n           2.5.1. ENDIAN-SWAP Algorithm\
    \ ...............................6\n   3. Key- and Pad-Derivation Functions ...............................7\n\
    \      3.1. Block Cipher Choice ........................................7\n  \
    \    3.2. KDF: Key-Derivation Function ...............................8\n    \
    \       3.2.1. KDF Algorithm .......................................8\n      3.3.\
    \ PDF: Pad-Derivation Function ...............................8\n           3.3.1.\
    \ PDF Algorithm .......................................9\n   4. UMAC Tag Generation\
    \ ............................................10\n      4.1. UMAC Algorithm ............................................10\n\
    \      4.2. UMAC-32, UMAC-64, UMAC-96, and UMAC-128 ...................10\n  \
    \ 5. UHASH: Universal Hash Function .................................10\n    \
    \  5.1. UHASH Algorithm ...........................................11\n      5.2.\
    \ L1-HASH: First-Layer Hash .................................12\n           5.2.1.\
    \ L1-HASH Algorithm ..................................12\n           5.2.2. NH\
    \ Algorithm .......................................13\n      5.3. L2-HASH: Second-Layer\
    \ Hash ................................14\n           5.3.1. L2-HASH Algorithm\
    \ ..................................14\n           5.3.2. POLY Algorithm .....................................15\n\
    \      5.4. L3-HASH: Third-Layer Hash .................................16\n  \
    \         5.4.1. L3-HASH Algorithm ..................................16\n   6.\
    \ Security Considerations ........................................17\n      6.1.\
    \ Resistance to Cryptanalysis ...............................17\n      6.2. Tag\
    \ Lengths and Forging Probability .......................17\n      6.3. Nonce\
    \ Considerations ......................................19\n      6.4. Replay Attacks\
    \ ............................................20\n      6.5. Tag-Prefix Verification\
    \ ...................................21\n      6.6. Side-Channel Attacks ......................................21\n\
    \   7. Acknowledgements ...............................................21\n  \
    \ Appendix. Test Vectors ............................................22\n   References\
    \ ........................................................24\n      Normative\
    \ References ...........................................24\n      Informative\
    \ References .........................................24\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   UMAC is a message authentication code (MAC) algorithm designed\
    \ for\n   high performance.  It is backed by a rigorous formal analysis, and\n\
    \   there are no intellectual property claims made by any of the authors\n   to\
    \ any ideas used in its design.\n   UMAC is a MAC in the style of Wegman and Carter\
    \ [4, 7].  A fast\n   \"universal\" hash function is used to hash an input message\
    \ M into a\n   short string.  This short string is then masked by xor'ing with\
    \ a\n   pseudorandom pad, resulting in the UMAC tag.  Security depends on the\n\
    \   sender and receiver sharing a randomly-chosen secret hash function\n   and\
    \ pseudorandom pad.  This is achieved by using keyed hash function\n   H and pseudorandom\
    \ function F.  A tag is generated by performing the\n   computation\n     Tag\
    \ = H_K1(M) xor F_K2(Nonce)\n   where K1 and K2 are secret random keys shared\
    \ by sender and receiver,\n   and Nonce is a value that changes with each generated\
    \ tag.  The\n   receiver needs to know which nonce was used by the sender, so\
    \ some\n   method of synchronizing nonces needs to be used.  This can be done\
    \ by\n   explicitly sending the nonce along with the message and tag, or\n   agreeing\
    \ upon the use of some other non-repeating value such as a\n   sequence number.\
    \  The nonce need not be kept secret, but care needs\n   to be taken to ensure\
    \ that, over the lifetime of a UMAC key, a\n   different nonce is used with each\
    \ message.\n   UMAC uses a keyed function, called UHASH (also specified in this\n\
    \   document), as the keyed hash function H and uses a pseudorandom\n   function\
    \ F whose default implementation uses the Advanced Encryption\n   Standard (AES)\
    \ algorithm.  UMAC is designed to produce 32-, 64-, 96-,\n   or 128-bit tags,\
    \ depending on the desired security level.  The theory\n   of Wegman-Carter MACs\
    \ and the analysis of UMAC show that if one\n   \"instantiates\" UMAC with truly\
    \ random keys and pads then the\n   probability that an attacker (even a computationally\
    \ unbounded one)\n   produces a correct tag for any message of its choosing is\
    \ no more\n   than 1/2^30, 1/2^60, 1/2^90, or 1/2^120 if the tags output by UMAC\n\
    \   are of length 32, 64, 96, or 128 bits, respectively (here the symbol\n   ^\
    \ represents exponentiation).  When an attacker makes N forgery\n   attempts,\
    \ the probability of getting one or more tags right increases\n   linearly to\
    \ at most N/2^30, N/2^60, N/2^90, or N/2^120.  In a real\n   implementation of\
    \ UMAC, using AES to produce keys and pads, the\n   forgery probabilities listed\
    \ above increase by a small amount related\n   to the security of AES.  As long\
    \ as AES is secure, this small\n   additive term is insignificant for any practical\
    \ attack.  See Section\n   6.2 for more details.  Analysis relevant to UMAC security\
    \ is in\n   [3, 6].\n   UMAC performs best in environments where 32-bit quantities\
    \ are\n   efficiently multiplied into 64-bit results.  In producing 64-bit tags\n\
    \   on an Intel Pentium 4 using SSE2 instructions, which do two of these\n   multiplications\
    \ in parallel, UMAC processes messages at a peak rate\n   of about one CPU cycle\
    \ per byte, with the peak being achieved on\n   messages of around four kilobytes\
    \ and longer.  On the Pentium III,\n   without the use of SSE parallelism, UMAC\
    \ achieves a peak of two\n   cycles per byte.  On shorter messages, UMAC still\
    \ performs well:\n   around four cycles per byte on 256-byte messages and under\
    \ two cycles\n   per byte on 1500-byte messages.  The time to produce a 32-bit\
    \ tag is\n   a little more than half that needed to produce a 64-bit tag, while\n\
    \   96- and 128-bit tags take one-and-a-half and twice as long,\n   respectively.\n\
    \   Optimized source code, performance data, errata, and papers\n   concerning\
    \ UMAC can be found at\n   http://www.cs.ucdavis.edu/~rogaway/umac/.\n"
- title: 2.  Notation and Basic Operations
  contents:
  - "2.  Notation and Basic Operations\n   The specification of UMAC involves the\
    \ manipulation of both strings\n   and numbers.  String variables are denoted\
    \ with an initial uppercase\n   letter, whereas numeric variables are denoted\
    \ in all lowercase.  The\n   algorithms of UMAC are denoted in all uppercase letters.\
    \  Simple\n   functions, like those for string-length and string-xor, are written\n\
    \   in all lowercase.\n   Whenever a variable is followed by an underscore (\"\
    _\"), the\n   underscore is intended to denote a subscript, with the subscripted\n\
    \   expression evaluated to resolve the meaning of the variable.  For\n   example,\
    \ if i=2, then M_{2 * i} refers to the variable M_4.\n"
- title: 2.1.  Operations on strings
  contents:
  - "2.1.  Operations on strings\n   Messages to be hashed are viewed as strings of\
    \ bits that get zero-\n   padded to an appropriate byte length.  Once the message\
    \ is padded,\n   all strings are viewed as strings of bytes.  A \"byte\" is an\
    \ 8-bit\n   string.  The following notation is used to manipulate these strings.\n\
    \         bytelength(S): The length of string S in bytes.\n         bitlength(S):\
    \  The length of string S in bits.\n         zeroes(n):     The string made of\
    \ n zero-bytes.\n         S xor T:       The string that is the bitwise exclusive-or\
    \ of S\n                        and T.  Strings S and T always have the same\n\
    \                        length.\n         S and T:       The string that is the\
    \ bitwise conjunction of S\n                        and T.  Strings S and T always\
    \ have the same\n                        length.\n         S[i]:          The\
    \ i-th byte of the string S (indices begin at\n                        1).\n \
    \        S[i...j]:      The substring of S consisting of bytes i through\n   \
    \                     j.\n         S || T:        The string S concatenated with\
    \ string T.\n         zeropad(S,n):  The string S, padded with zero-bits to the\n\
    \                        nearest positive multiple of n bytes.  Formally,\n  \
    \                      zeropad(S,n) = S || T, where T is the shortest\n      \
    \                  string of zero-bits (possibly empty) so that S\n          \
    \              || T is non-empty and 8n divides bitlength(S ||\n             \
    \           T).\n"
- title: 2.2.  Operations on Integers
  contents:
  - "2.2.  Operations on Integers\n   Standard notation is used for most mathematical\
    \ operations, such as\n   \"*\" for multiplication, \"+\" for addition and \"\
    mod\" for modular\n   reduction.  Some less standard notations are defined here.\n\
    \      a^i:      The integer a raised to the i-th power.\n      ceil(x):  The\
    \ smallest integer greater than or equal to x.\n      prime(n): The largest prime\
    \ number less than 2^n.\n   The prime numbers used in UMAC are:\n    +-----+--------------------+---------------------------------------+\n\
    \    |  n  | prime(n) [Decimal] | prime(n) [Hexadecimal]                |\n  \
    \  +-----+--------------------+---------------------------------------+\n    |\
    \ 36  | 2^36  - 5          | 0x0000000F FFFFFFFB                   |\n    | 64\
    \  | 2^64  - 59         | 0xFFFFFFFF FFFFFFC5                   |\n    | 128 |\
    \ 2^128 - 159        | 0xFFFFFFFF FFFFFFFF FFFFFFFF FFFFFF61 |\n    +-----+--------------------+---------------------------------------+\n"
- title: 2.3.  String-Integer Conversion Operations
  contents:
  - "2.3.  String-Integer Conversion Operations\n   Conversion between strings and\
    \ integers is done using the following\n   functions.  Each function treats initial\
    \ bits as more significant\n   than later ones.\n      bit(S,n):      Returns\
    \ the integer 1 if the n-th bit of the string\n                     S is 1, otherwise\
    \ returns the integer 0 (indices\n                     begin at 1).\n      str2uint(S):\
    \   The non-negative integer whose binary\n                     representation\
    \ is the string S.  More formally, if\n                     S is t bits long then\
    \ str2uint(S) = 2^{t-1} *\n                     bit(S,1) + 2^{t-2} * bit(S,2)\
    \ + ... + 2^{1} *\n                     bit(S,t-1) + bit(S,t).\n      uint2str(n,i):\
    \ The i-byte string S such that str2uint(S) = n.\n"
- title: 2.4.  Mathematical Operations on Strings
  contents:
  - "2.4.  Mathematical Operations on Strings\n   One of the primary operations in\
    \ UMAC is repeated application of\n   addition and multiplication on strings.\
    \  The operations \"+_32\",\n   \"+_64\", and \"*_64\"  are defined\n     \"S\
    \ +_32 T\" as uint2str(str2uint(S) + str2uint(T) mod 2^32, 4),\n     \"S +_64\
    \ T\" as uint2str(str2uint(S) + str2uint(T) mod 2^64, 8), and\n     \"S *_64 T\"\
    \ as uint2str(str2uint(S) * str2uint(T) mod 2^64, 8).\n   These operations correspond\
    \ well with the addition and multiplication\n   operations that are performed\
    \ efficiently by modern computers.\n"
- title: '2.5.  ENDIAN-SWAP: Adjusting Endian Orientation'
  contents:
  - "2.5.  ENDIAN-SWAP: Adjusting Endian Orientation\n   Message data is read little-endian\
    \ to speed tag generation on\n   little-endian computers.\n"
- title: 2.5.1.  ENDIAN-SWAP Algorithm
  contents:
  - "2.5.1.  ENDIAN-SWAP Algorithm\n   Input:\n     S, string with length divisible\
    \ by 4 bytes.\n   Output:\n     T, string S with each 4-byte word endian-reversed.\n\
    \   Compute T using the following algorithm.\n     //\n     // Break S into 4-byte\
    \ chunks\n     //\n     n = bytelength(S) / 4\n     Let S_1, S_2, ..., S_n be\
    \ strings of length 4 bytes\n        so that S_1 || S_2 || ... || S_n = S.\n \
    \    //\n     // Byte-reverse each chunk, and build-up T\n     //\n     T = <empty\
    \ string>\n     for i = 1 to n do\n       Let W_1, W_2, W_3, W_4  be bytes\n \
    \         so that W_1 || W_2 || W_3 || W_4 = S_i\n       SReversed_i = W_4 ||\
    \ W_3 || W_2 || W_1\n       T = T || SReversed_i\n     end for\n     Return T\n"
- title: 3.  Key- and Pad-Derivation Functions
  contents:
  - "3.  Key- and Pad-Derivation Functions\n   Pseudorandom bits are needed internally\
    \ by UHASH and at the time of\n   tag generation.  The functions listed in this\
    \ section use a block\n   cipher to generate these bits.\n"
- title: 3.1.  Block Cipher Choice
  contents:
  - "3.1.  Block Cipher Choice\n   UMAC uses the services of a block cipher.  The\
    \ selection of a block\n   cipher defines the following constants and functions.\n\
    \      BLOCKLEN         The length, in bytes, of the plaintext block on\n    \
    \                   which the block cipher operates.\n      KEYLEN           The\
    \ block cipher's key length, in bytes.\n      ENCIPHER(K,P)    The application\
    \ of the block cipher on P (a\n                       string of BLOCKLEN bytes)\
    \ using key K (a string\n                       of KEYLEN bytes).\n   As an example,\
    \ if AES is used with 16-byte keys, then BLOCKLEN would\n   equal 16 (because\
    \ AES employs 16-byte blocks), KEYLEN would equal 16,\n   and ENCIPHER would refer\
    \ to the AES function.\n   Unless specified otherwise, AES with 128-bit keys shall\
    \ be assumed to\n   be the chosen block cipher for UMAC.  Only if explicitly specified\n\
    \   otherwise, and agreed to by communicating parties, shall some other\n   block\
    \ cipher be used.  In any case, BLOCKLEN must be at least 16 and\n   a power of\
    \ two.\n   AES is defined in another document [1].\n"
- title: '3.2.  KDF: Key-Derivation Function'
  contents:
  - "3.2.  KDF: Key-Derivation Function\n   The key-derivation function generates\
    \ pseudorandom bits used to key\n   the hash functions.\n"
- title: 3.2.1.  KDF Algorithm
  contents:
  - "3.2.1.  KDF Algorithm\n   Input:\n     K, string of length KEYLEN bytes.\n  \
    \   index, a non-negative integer less than 2^64.\n     numbytes, a non-negative\
    \ integer less than 2^64.\n   Output:\n     Y, string of length numbytes bytes.\n\
    \   Compute Y using the following algorithm.\n     //\n     // Calculate number\
    \ of block cipher iterations\n     //\n     n = ceil(numbytes / BLOCKLEN)\n  \
    \   Y = <empty string>\n     //\n     // Build Y using block cipher in a counter\
    \ mode\n     //\n     for i = 1 to n do\n       T = uint2str(index, BLOCKLEN-8)\
    \ || uint2str(i, 8)\n       T = ENCIPHER(K, T)\n       Y = Y || T\n     end for\n\
    \     Y = Y[1...numbytes]\n     Return Y\n"
- title: '3.3.  PDF: Pad-Derivation Function'
  contents:
  - "3.3.  PDF: Pad-Derivation Function\n   This function takes a key and a nonce\
    \ and returns a pseudorandom pad\n   for use in tag generation.  A pad of length\
    \ 4, 8, 12, or 16 bytes can\n   be generated.  Notice that pads generated using\
    \ nonces that differ\n   only in their last bit (when generating 8-byte pads)\
    \ or last two bits\n   (when generating 4-byte pads) are derived from the same\
    \ block cipher\n   encryption.  This allows caching and sharing a single block\
    \ cipher\n   invocation for sequential nonces.\n"
- title: 3.3.1.  PDF Algorithm
  contents:
  - "3.3.1.  PDF Algorithm\n   Input:\n     K, string of length KEYLEN bytes.\n  \
    \   Nonce, string of length 1 to BLOCKLEN bytes.\n     taglen, the integer 4,\
    \ 8, 12 or 16.\n   Output:\n     Y, string of length taglen bytes.\n   Compute\
    \ Y using the following algorithm.\n      //\n      // Extract and zero low bit(s)\
    \ of Nonce if needed\n      //\n      if (taglen = 4 or taglen = 8)\n        index\
    \ = str2uint(Nonce) mod (BLOCKLEN/taglen)\n        Nonce = Nonce xor uint2str(index,\
    \ bytelength(Nonce))\n      end if\n      //\n      // Make Nonce BLOCKLEN bytes\
    \ by appending zeroes if needed\n      //\n      Nonce = Nonce || zeroes(BLOCKLEN\
    \ - bytelength(Nonce))\n      //\n      // Generate subkey, encipher and extract\
    \ indexed substring\n      //\n      K' = KDF(K, 0, KEYLEN)\n      T = ENCIPHER(K',\
    \ Nonce)\n      if (taglen = 4 or taglen = 8)\n        Y = T[1 + (index*taglen)\
    \ ... taglen + (index*taglen)]\n      else\n        Y = T[1...taglen]\n      end\
    \ if\n      Return Y\n"
- title: 4.  UMAC Tag Generation
  contents:
  - "4.  UMAC Tag Generation\n   Tag generation for UMAC proceeds by using UHASH (defined\
    \ in the next\n   section) to hash the message, applying the PDF to the nonce,\
    \ and\n   computing the xor of the resulting strings.  The length of the pad\n\
    \   and hash can be either 4, 8, 12, or 16 bytes.\n"
- title: 4.1.  UMAC Algorithm
  contents:
  - "4.1.  UMAC Algorithm\n   Input:\n     K, string of length KEYLEN bytes.\n   \
    \  M, string of length less than 2^67 bits.\n     Nonce, string of length 1 to\
    \ BLOCKLEN bytes.\n     taglen, the integer 4, 8, 12 or 16.\n   Output:\n    \
    \ Tag, string of length taglen bytes.\n   Compute Tag using the following algorithm.\n\
    \     HashedMessage = UHASH(K, M, taglen)\n     Pad           = PDF(K, Nonce,\
    \ taglen)\n     Tag           = Pad xor HashedMessage\n     Return Tag\n"
- title: 4.2.  UMAC-32, UMAC-64, UMAC-96, and UMAC-128
  contents:
  - "4.2.  UMAC-32, UMAC-64, UMAC-96, and UMAC-128\n   The preceding UMAC definition\
    \ has a parameter \"taglen\", which\n   specifies the length of tag generated\
    \ by the algorithm.  The\n   following aliases define names that make tag length\
    \ explicit in the\n   name.\n     UMAC-32(K, M, Nonce) = UMAC(K, M, Nonce, 4)\n\
    \     UMAC-64(K, M, Nonce) = UMAC(K, M, Nonce, 8)\n     UMAC-96(K, M, Nonce) =\
    \ UMAC(K, M, Nonce, 12)\n     UMAC-128(K, M, Nonce) = UMAC(K, M, Nonce, 16)\n"
- title: '5.  UHASH: Universal Hash Function'
  contents:
  - "5.  UHASH: Universal Hash Function\n   UHASH is a keyed hash function, which\
    \ takes as input a string of\n   arbitrary length, and produces a 4-, 8-, 12-,\
    \ or 16-byte output.\n   UHASH does its work in three stages, or layers.  A message\
    \ is first\n   hashed by L1-HASH, its output is then hashed by L2-HASH, whose\
    \ output\n   is then hashed by L3-HASH.  If the message being hashed is no longer\n\
    \   than 1024 bytes, then L2-HASH is skipped as an optimization.  Because\n  \
    \ L3-HASH outputs a string whose length is only four bytes long,\n   multiple\
    \ iterations of this three-layer hash are used if a total\n   hash-output longer\
    \ than four bytes is requested.  To reduce memory\n   use, L1-HASH reuses most\
    \ of its key material between iterations.  A\n   significant amount of internal\
    \ key is required for UHASH, but it\n   remains constant so long as UMAC's key\
    \ is unchanged.  It is the\n   implementer's choice whether to generate the internal\
    \ keys each time\n   a message is hashed, or to cache them between messages.\n\
    \   Please note that UHASH has certain combinatoric properties making it\n   suitable\
    \ for Wegman-Carter message authentication.  UHASH is not a\n   cryptographic\
    \ hash function and is not a suitable general replacement\n   for functions like\
    \ SHA-1.\n   UHASH is presented here in a top-down manner.  First, UHASH is\n\
    \   described, then each of its component hashes is presented.\n"
- title: 5.1.  UHASH Algorithm
  contents:
  - "5.1.  UHASH Algorithm\n   Input:\n     K, string of length KEYLEN bytes.\n  \
    \   M, string of length less than 2^67 bits.\n     taglen, the integer 4, 8, 12\
    \ or 16.\n   Output:\n     Y, string of length taglen bytes.\n   Compute Y using\
    \ the following algorithm.\n     //\n     // One internal iteration per 4 bytes\
    \ of output\n     //\n     iters = taglen / 4\n     //\n     // Define total key\
    \ needed for all iterations using KDF.\n     // L1Key reuses most key material\
    \ between iterations.\n     //\n     L1Key  = KDF(K, 1, 1024 + (iters - 1) * 16)\n\
    \     L2Key  = KDF(K, 2, iters * 24)\n     L3Key1 = KDF(K, 3, iters * 64)\n  \
    \   L3Key2 = KDF(K, 4, iters * 4)\n     //\n     // For each iteration, extract\
    \ key and do three-layer hash.\n     // If bytelength(M) <= 1024, then skip L2-HASH.\n\
    \     //\n     Y = <empty string>\n     for i = 1 to iters do\n       L1Key_i\
    \  = L1Key [(i-1) * 16 + 1 ... (i-1) * 16 + 1024]\n       L2Key_i  = L2Key [(i-1)\
    \ * 24 + 1 ... i * 24]\n       L3Key1_i = L3Key1[(i-1) * 64 + 1 ... i * 64]\n\
    \       L3Key2_i = L3Key2[(i-1) * 4  + 1 ... i * 4]\n       A = L1-HASH(L1Key_i,\
    \ M)\n       if (bitlength(M) <= bitlength(L1Key_i)) then\n         B = zeroes(8)\
    \ || A\n       else\n         B = L2-HASH(L2Key_i, A)\n       end if\n       C\
    \ = L3-HASH(L3Key1_i, L3Key2_i, B)\n       Y = Y || C\n     end for\n     Return\
    \ Y\n"
- title: '5.2.  L1-HASH: First-Layer Hash'
  contents:
  - "5.2.  L1-HASH: First-Layer Hash\n   The first-layer hash breaks the message into\
    \ 1024-byte chunks and\n   hashes each with a function called NH.  Concatenating\
    \ the results\n   forms a string, which is up to 128 times shorter than the original.\n"
- title: 5.2.1.  L1-HASH Algorithm
  contents:
  - "5.2.1.  L1-HASH Algorithm\n   Input:\n     K, string of length 1024 bytes.\n\
    \     M, string of length less than 2^67 bits.\n   Output:\n     Y, string of\
    \ length (8 * ceil(bitlength(M)/8192)) bytes.\n   Compute Y using the following\
    \ algorithm.\n     //\n     // Break M into 1024 byte chunks (final chunk may\
    \ be shorter)\n     //\n     t = max(ceil(bitlength(M)/8192), 1)\n     Let M_1,\
    \ M_2, ..., M_t be strings so that M = M_1 || M_2 || ... ||\n        M_t, and\
    \ bytelength(M_i) = 1024 for all 0 < i < t.\n     //\n     // For each chunk,\
    \ except the last: endian-adjust, NH hash\n     // and add bit-length.  Use results\
    \ to build Y.\n     //\n     Len = uint2str(1024 * 8, 8)\n     Y = <empty string>\n\
    \     for i = 1 to t-1 do\n       ENDIAN-SWAP(M_i)\n       Y = Y || (NH(K, M_i)\
    \ +_64 Len)\n     end for\n     //\n     // For the last chunk: pad to 32-byte\
    \ boundary, endian-adjust,\n     // NH hash and add bit-length.  Concatenate the\
    \ result to Y.\n     //\n     Len = uint2str(bitlength(M_t), 8)\n     M_t = zeropad(M_t,\
    \ 32)\n     ENDIAN-SWAP(M_t)\n     Y = Y || (NH(K, M_t) +_64 Len)\n     return\
    \ Y\n"
- title: 5.2.2.  NH Algorithm
  contents:
  - "5.2.2.  NH Algorithm\n   Because this routine is applied directly to every bit\
    \ of input data,\n   optimized implementation of it yields great benefit.\n  \
    \ Input:\n     K, string of length 1024 bytes.\n     M, string with length divisible\
    \ by 32 bytes.\n   Output:\n     Y, string of length 8 bytes.\n   Compute Y using\
    \ the following algorithm.\n     //\n     // Break M and K into 4-byte chunks\n\
    \     //\n     t = bytelength(M) / 4\n     Let M_1, M_2, ..., M_t be 4-byte strings\n\
    \       so that M = M_1 || M_2 || ... || M_t.\n     Let K_1, K_2, ..., K_t be\
    \ 4-byte strings\n       so that K_1 || K_2 || ... || K_t  is a prefix of K.\n\
    \     //\n     // Perform NH hash on the chunks, pairing words for multiplication\n\
    \     // which are 4 apart to accommodate vector-parallelism.\n     //\n     Y\
    \ = zeroes(8)\n     i = 1\n     while (i < t) do\n       Y = Y +_64 ((M_{i+0}\
    \ +_32 K_{i+0}) *_64 (M_{i+4} +_32 K_{i+4}))\n       Y = Y +_64 ((M_{i+1} +_32\
    \ K_{i+1}) *_64 (M_{i+5} +_32 K_{i+5}))\n       Y = Y +_64 ((M_{i+2} +_32 K_{i+2})\
    \ *_64 (M_{i+6} +_32 K_{i+6}))\n       Y = Y +_64 ((M_{i+3} +_32 K_{i+3}) *_64\
    \ (M_{i+7} +_32 K_{i+7}))\n       i = i + 8\n     end while\n     Return Y\n"
- title: '5.3.  L2-HASH: Second-Layer Hash'
  contents:
  - "5.3.  L2-HASH: Second-Layer Hash\n   The second-layer rehashes the L1-HASH output\
    \ using a polynomial hash\n   called POLY.  If the L1-HASH output is long, then\
    \ POLY is called once\n   on a prefix of the L1-HASH output and called using different\
    \ settings\n   on the remainder.  (This two-step hashing of the L1-HASH output\
    \ is\n   needed only if the message length is greater than 16 megabytes.)\n  \
    \ Careful implementation of POLY is necessary to avoid a possible\n   timing attack\
    \ (see Section 6.6 for more information).\n"
- title: 5.3.1.  L2-HASH Algorithm
  contents:
  - "5.3.1.  L2-HASH Algorithm\n   Input:\n     K, string of length 24 bytes.\n  \
    \   M, string of length less than 2^64 bytes.\n   Output:\n     Y, string of length\
    \ 16 bytes.\n   Compute y using the following algorithm.\n     //\n     //  Extract\
    \ keys and restrict to special key-sets\n     //\n     Mask64  = uint2str(0x01ffffff01ffffff,\
    \ 8)\n     Mask128 = uint2str(0x01ffffff01ffffff01ffffff01ffffff, 16)\n     k64\
    \    = str2uint(K[1...8]  and Mask64)\n     k128   = str2uint(K[9...24] and Mask128)\n\
    \     //\n     // If M is no more than 2^17 bytes, hash under 64-bit prime,\n\
    \     // otherwise, hash first 2^17 bytes under 64-bit prime and\n     // remainder\
    \ under 128-bit prime.\n     //\n     if (bytelength(M) <= 2^17) then        \
    \     // 2^14 64-bit words\n        //\n        // View M as an array of 64-bit\
    \ words, and use POLY modulo\n        // prime(64) (and with bound 2^64 - 2^32)\
    \ to hash it.\n        //\n        y = POLY(64, 2^64 - 2^32,  k64, M)\n     else\n\
    \        M_1 = M[1...2^17]\n        M_2 = M[2^17 + 1 ... bytelength(M)]\n    \
    \    M_2 = zeropad(M_2 || uint2str(0x80,1), 16)\n        y = POLY(64, 2^64 - 2^32,\
    \ k64, M_1)\n        y = POLY(128, 2^128 - 2^96, k128, uint2str(y, 16) || M_2)\n\
    \      end if\n     Y = uint2str(y, 16)\n     Return Y\n"
- title: 5.3.2.  POLY Algorithm
  contents:
  - "5.3.2.  POLY Algorithm\n   Input:\n     wordbits, the integer 64 or 128.\n  \
    \   maxwordrange, positive integer less than 2^wordbits.\n     k, integer in the\
    \ range 0 ... prime(wordbits) - 1.\n     M, string with length divisible by (wordbits\
    \ / 8) bytes.\n   Output:\n     y, integer in the range 0 ... prime(wordbits)\
    \ - 1.\n   Compute y using the following algorithm.\n     //\n     // Define constants\
    \ used for fixing out-of-range words\n     //\n     wordbytes = wordbits / 8\n\
    \     p = prime(wordbits)\n     offset = 2^wordbits - p\n     marker = p - 1\n\
    \     //\n     // Break M into chunks of length wordbytes bytes\n     //\n   \
    \  n = bytelength(M) / wordbytes\n     Let M_1, M_2, ..., M_n be strings of length\
    \ wordbytes bytes\n       so that M = M_1 || M_2 || ... || M_n\n     //\n    \
    \ // Each input word m is compared with maxwordrange.  If not smaller\n     //\
    \ then 'marker' and (m - offset), both in range, are hashed.\n     //\n     y\
    \ = 1\n     for i = 1 to n do\n       m = str2uint(M_i)\n       if (m >= maxwordrange)\
    \ then\n         y = (k * y + marker) mod p\n         y = (k * y + (m - offset))\
    \ mod p\n       else\n         y = (k * y + m) mod p\n       end if\n     end\
    \ for\n     Return y\n"
- title: '5.4.  L3-HASH: Third-Layer Hash'
  contents:
  - "5.4.  L3-HASH: Third-Layer Hash\n   The output from L2-HASH is 16 bytes long.\
    \  This final hash function\n   hashes the 16-byte string to a fixed length of\
    \ 4 bytes.\n"
- title: 5.4.1.  L3-HASH Algorithm
  contents:
  - "5.4.1.  L3-HASH Algorithm\n   Input:\n     K1, string of length 64 bytes.\n \
    \    K2, string of length 4 bytes.\n     M, string of length 16 bytes.\n   Output:\n\
    \     Y, string of length 4 bytes.\n   Compute Y using the following algorithm.\n\
    \     y = 0\n     //\n     // Break M and K1 into 8 chunks and convert to integers\n\
    \     //\n     for i = 1 to 8 do\n       M_i = M [(i - 1) * 2 + 1 ... i * 2]\n\
    \       K_i = K1[(i - 1) * 8 + 1 ... i * 8]\n       m_i = str2uint(M_i)\n    \
    \   k_i = str2uint(K_i) mod prime(36)\n     end for\n     //\n     // Inner-product\
    \ hash, extract last 32 bits and affine-translate\n     //\n     y = (m_1 * k_1\
    \ + ... + m_8 * k_8) mod prime(36)\n     y = y mod 2^32\n     Y = uint2str(y,\
    \ 4)\n     Y = Y xor K2\n     Return Y\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   As a message authentication code specification,\
    \ this entire document\n   is about security.  Here we describe some security\
    \ considerations\n   important for the proper understanding and use of UMAC.\n"
- title: 6.1.  Resistance to Cryptanalysis
  contents:
  - "6.1.  Resistance to Cryptanalysis\n   The strength of UMAC depends on the strength\
    \ of its underlying\n   cryptographic functions: the key-derivation function (KDF)\
    \ and the\n   pad-derivation function (PDF).  In this specification, both\n  \
    \ operations are implemented using a block cipher, by default the\n   Advanced\
    \ Encryption Standard (AES).  However, the design of UMAC\n   allows for the replacement\
    \ of these components.  Indeed, it is\n   possible to use other block ciphers\
    \ or other cryptographic objects,\n   such as (properly keyed) SHA-1 or HMAC for\
    \ the realization of the KDF\n   or PDF.\n   The core of the UMAC design, the\
    \ UHASH function, does not depend on\n   cryptographic assumptions: its strength\
    \ is specified by a purely\n   mathematical property stated in terms of collision\
    \ probability, and\n   this property is proven unconditionally [3, 6].  This means\
    \ the\n   strength of UHASH is guaranteed regardless of advances in\n   cryptanalysis.\n\
    \   The analysis of UMAC [3, 6] shows this scheme to have provable\n   security,\
    \ in the sense of modern cryptography, by way of tight\n   reductions.  What this\
    \ means is that an adversarial attack on UMAC\n   that forges with probability\
    \ that significantly exceeds the\n   established collision probability of UHASH\
    \ will give rise to an\n   attack of comparable complexity.  This attack will\
    \ break the block\n   cipher, in the sense of distinguishing the block cipher\
    \ from a family\n   of random permutations.  This design approach essentially\
    \ obviates\n   the need for cryptanalysis on UMAC: cryptanalytic efforts might\
    \ as\n   well focus on the block cipher, the results imply.\n"
- title: 6.2.  Tag Lengths and Forging Probability
  contents:
  - "6.2.  Tag Lengths and Forging Probability\n   A MAC algorithm is used to authenticate\
    \ messages between two parties\n   that share a secret MAC key K.  An authentication\
    \ tag is computed for\n   a message using K and, in some MAC algorithms such as\
    \ UMAC, a nonce.\n   Messages transmitted between parties are accompanied by their\
    \ tag\n   and, possibly, nonce.  Breaking the MAC means that the attacker is\n\
    \   able to generate, on its own, with no knowledge of the key K, a new\n   message\
    \ M (i.e., one not previously transmitted between the\n   legitimate parties)\
    \ and to compute on M a correct authentication tag\n   under the key K.  This\
    \ is called a forgery.  Note that if the\n   authentication tag is specified to\
    \ be of length t, then the attacker\n   can trivially break the MAC with probability\
    \ 1/2^t.  For this, the\n   attacker can just generate any message of its choice\
    \ and try a random\n   tag; obviously, the tag is correct with probability 1/2^t.\
    \  By\n   repeated guesses, the attacker can increase linearly its probability\n\
    \   of success.\n   In the case of UMAC-64, for example, the above guessing-attack\n\
    \   strategy is close to optimal.  An adversary can correctly guess an\n   8-byte\
    \ UMAC tag with probability 1/2^64 by simply guessing a random\n   value.  The\
    \ results of [3, 6] show that no attack strategy can\n   produce a correct tag\
    \ with probability better than 1/2^60 if UMAC\n   were to use a random function\
    \ in its work rather than AES.  Another\n   result [2], when combined with [3,\
    \ 6], shows that so long as AES is\n   secure as a pseudorandom permutation, it\
    \ can be used instead of a\n   random function without significantly increasing\
    \ the 1/2^60 forging\n   probability, assuming that no more than 2^64 messages\
    \ are\n   authenticated.  Likewise, 32-, 96-, and 128-bit tags cannot be forged\n\
    \   with more than 1/2^30, 1/2^90, and 1/2^120 probability plus the\n   probability\
    \ of a successful attack against AES as a pseudorandom\n   permutation.\n   AES\
    \ has undergone extensive study and is assumed to be very secure as\n   a pseudorandom\
    \ permutation.  If we assume that no attacker with\n   feasible computational\
    \ power can distinguish randomly-keyed AES from\n   a randomly-chosen permutation\
    \ with probability delta (more precisely,\n   delta is a function of the computational\
    \ resources of the attacker\n   and of its ability to sample the function), then\
    \ we obtain that no\n   such attacker can forge UMAC with probability greater\
    \ than 1/2^30,\n   1/^60, 1/2^90, or 1/2^120, plus 3*delta.  Over N forgery attempts,\n\
    \   forgery occurs with probability no more than N/2^30, N/^60, N/2^90,\n   or\
    \ N/2^120, plus 3*delta.  The value delta may exceed 1/2^30, 1/2^60,\n   1/2^90,\
    \ or 1/2^120, in which case the probability of UMAC forging is\n   dominated by\
    \ a term representing the security of AES.\n   With UMAC, off-line computation\
    \ aimed at exceeding the forging\n   probability is hopeless as long as the underlying\
    \ cipher is not\n   broken.  An attacker attempting to forge UMAC tags will need\
    \ to\n   interact with the entity that verifies message tags and try a large\n\
    \   number of forgeries before one is likely to succeed.  The system\n   architecture\
    \ will determine the extent to which this is possible.  In\n   a well-architected\
    \ system, there should not be any high-bandwidth\n   capability for presenting\
    \ forged MACs and determining if they are\n   valid.  In particular, the number\
    \ of authentication failures at the\n   verifying party should be limited.  If\
    \ a large number of such\n   attempts are detected, the session key in use should\
    \ be dropped and\n   the event be recorded in an audit log.\n   Let us reemphasize:\
    \ a forging probability of 1/2^60 does not mean\n   that there is an attack that\
    \ runs in 2^60 time; to the contrary, as\n   long as the block cipher in use is\
    \ not broken there is no such attack\n   for UMAC.  Instead, a 1/2^60 forging\
    \ probability means that if an\n   attacker could have N forgery attempts, then\
    \ the attacker would have\n   no more than N/2^60 probability of getting one or\
    \ more of them right.\n   It should be pointed out that once an attempted forgery\
    \ is\n   successful, it is possible, in principle, that subsequent messages\n\
    \   under this key may be easily forged.  This is important to understand\n  \
    \ in gauging the severity of a successful forgery, even though no such\n   attack\
    \ on UMAC is known to date.\n   In conclusion, 64-bit tags seem appropriate for\
    \ many security\n   architectures and commercial applications.  If one wants a\
    \ more\n   conservative option, at a cost of about 50% or 100% more computation,\n\
    \   UMAC can produce 96- or 128-bit tags that have basic collision\n   probabilities\
    \ of at most 1/2^90 and 1/2^120.  If one needs less\n   security, with the benefit\
    \ of about 50% less computation, UMAC can\n   produce 32-bit tags.  In this case,\
    \ under the same assumptions as\n   before, one cannot forge a message with probability\
    \ better than\n   1/2^30.  Special care must be taken when using 32-bit tags because\n\
    \   1/2^30 forgery probability is considered fairly high.  Still, high-\n   speed\
    \ low-security authentication can be applied usefully on low-\n   value data or\
    \ rapidly-changing key environments.\n"
- title: 6.3.  Nonce Considerations
  contents:
  - "6.3.  Nonce Considerations\n   UMAC requires a nonce with length in the range\
    \ 1 to BLOCKLEN bytes.\n   All nonces in an authentication session must be equal\
    \ in length.  For\n   secure operation, no nonce value should be repeated within\
    \ the life\n   of a single UMAC session key.  There is no guarantee of message\n\
    \   authenticity when a nonce is repeated, and so messages accompanied by\n  \
    \ a repeated nonce should be considered inauthentic.\n   To authenticate messages\
    \ over a duplex channel (where two parties\n   send messages to each other), a\
    \ different key could be used for each\n   direction.  If the same key is used\
    \ in both directions, then it is\n   crucial that all nonces be distinct.  For\
    \ example, one party can use\n   even nonces while the other party uses odd ones.\
    \  The receiving party\n   must verify that the sender is using a nonce of the\
    \ correct form.\n   This specification does not indicate how nonce values are\
    \ created,\n   updated, or communicated between the entity producing a tag and\
    \ the\n   entity verifying a tag.  The following are possibilities:\n   1.  The\
    \ nonce is an 8-byte unsigned number, Counter, which is\n       initialized to\
    \ zero, which is incremented by one following the\n       generation of each authentication\
    \ tag, and which is always\n       communicated along with the message and the\
    \ authentication tag.\n       An error occurs at the sender if there is an attempt\
    \ to\n       authenticate more than 2^64 messages within a session.\n   2.  The\
    \ nonce is a BLOCKLEN-byte unsigned number, Counter, which is\n       initialized\
    \ to zero and which is incremented by one following the\n       generation of\
    \ each authentication tag.  The Counter is not\n       explicitly communicated\
    \ between the sender and receiver.\n       Instead, the two are assumed to communicate\
    \ over a reliable\n       transport, and each maintains its own counter so as\
    \ to keep track\n       of what the current nonce value is.\n   3.  The nonce\
    \ is a BLOCKLEN-byte random value.  (Because repetitions\n       in a random n-bit\
    \ value are expected at around 2^(n/2) trials,\n       the number of messages\
    \ to be communicated in a session using\n       n-bit nonces should not be allowed\
    \ to approach 2^(n/2).)\n   We emphasize that the value of the nonce need not\
    \ be kept secret.\n   When UMAC is used within a higher-level protocol, there\
    \ may already\n   be a field, such as a sequence number, which can be co-opted\
    \ so as to\n   specify the nonce needed by UMAC [5].  The application will then\n\
    \   specify how to construct the nonce from this already-existing field.\n"
- title: 6.4.  Replay Attacks
  contents:
  - "6.4.  Replay Attacks\n   A replay attack entails the attacker repeating a message,\
    \ nonce, and\n   authentication tag.  In many applications, replay attacks may\
    \ be\n   quite damaging and must be prevented.  In UMAC, this would normally\n\
    \   be done at the receiver by having the receiver check that no nonce\n   value\
    \ is used twice.  On a reliable connection, when the nonce is a\n   counter, this\
    \ is trivial.  On an unreliable connection, when the\n   nonce is a counter, one\
    \ would normally cache some window of recent\n   nonces.  Out-of-order message\
    \ delivery in excess of what the window\n   allows will result in rejecting otherwise\
    \ valid authentication tags.\n   We emphasize that it is up to the receiver when\
    \ a given (message,\n   nonce, tag) triple will be deemed authentic.  Certainly,\
    \ the tag\n   should be valid for the message and nonce, as determined by UMAC,\
    \ but\n   the message may still be deemed inauthentic because the nonce is\n \
    \  detected to be a replay.\n"
- title: 6.5.  Tag-Prefix Verification
  contents:
  - "6.5.  Tag-Prefix Verification\n   UMAC's definition makes it possible to implement\
    \ tag-prefix\n   verification; for example, a receiver might verify only the 32-bit\n\
    \   prefix of a 64-bit tag if its computational load is high.  Or a\n   receiver\
    \ might reject out-of-hand a 64-bit tag whose 32-bit prefix is\n   incorrect.\
    \  Such practices are potentially dangerous and can lead to\n   attacks that reduce\
    \ the security of the session to the length of the\n   verified prefix.  A UMAC\
    \ key (or session) must have an associated and\n   immutable tag length and the\
    \ implementation should not leak\n   information that would reveal if a given\
    \ proper prefix of a tag is\n   valid or invalid.\n"
- title: 6.6.  Side-Channel Attacks
  contents:
  - "6.6.  Side-Channel Attacks\n   Side-channel attacks have the goal of subverting\
    \ the security of a\n   cryptographic system by exploiting its implementation\n\
    \   characteristics.  One common side-channel attack is to measure system\n  \
    \ response time and derive information regarding conditions met by the\n   data\
    \ being processed.  Such attacks are known as \"timing attacks\".\n   Discussion\
    \ of timing and other side-channel attacks is outside of\n   this document's scope.\
    \  However, we warn that there are places in the\n   UMAC algorithm where timing\
    \ information could be unintentionally\n   leaked.  In particular, the POLY algorithm\
    \ (Section 5.3.2) tests\n   whether a value m is out of a particular range, and\
    \ the behavior of\n   the algorithm differs depending on the result.  If timing\
    \ attacks are\n   to be avoided, care should be taken to equalize the computation\
    \ time\n   in both cases.  Timing attacks can also occur for more subtle\n   reasons,\
    \ including caching effects.\n"
- title: 7.  Acknowledgements
  contents:
  - "7.  Acknowledgements\n   David McGrew and Scott Fluhrer, of Cisco Systems, played\
    \ a\n   significant role in improving UMAC by encouraging us to pay more\n   attention\
    \ to the performance of short messages.  Thanks go to Jim\n   Schaad and to those\
    \ who made helpful suggestions to the CFRG mailing\n   list for improving this\
    \ document during RFC consideration.  Black,\n   Krovetz, and Rogaway have received\
    \ support for this work under NSF\n   awards 0208842, 0240000, and 9624560, and\
    \ a gift from Cisco Systems.\n"
- title: Appendix.  Test Vectors
  contents:
  - "Appendix.  Test Vectors\n   Following are some sample UMAC outputs over a collection\
    \ of input\n   values, using AES with 16-byte keys.  Let\n     K  = \"abcdefghijklmnop\"\
    \                  // A 16-byte UMAC key\n     N  = \"bcdefghi\"             \
    \             // An 8-byte nonce\n   The tags generated by UMAC using key K and\
    \ nonce N are:\n     Message      32-bit Tag    64-bit Tag            96-bit Tag\n\
    \     -------      ----------    ----------            ----------\n     <empty>\
    \       113145FB  6E155FAD26900BE1  32FEDB100C79AD58F07FF764\n     'a' * 3   \
    \    3B91D102  44B5CB542F220104  185E4FE905CBA7BD85E4C2DC\n     'a' * 2^10   \
    \ 599B350B  26BF2F5D60118BD9  7A54ABE04AF82D60FB298C3C\n     'a' * 2^15    58DCF532\
    \  27F8EF643B0D118D  7B136BD911E4B734286EF2BE\n     'a' * 2^20    DB6364D1  A4477E87E9F55853\
    \  F8ACFA3AC31CFEEA047F7B11\n     'a' * 2^25    5109A660  2E2DBC36860A0A5F  72C6388BACE3ACE6FBF062D9\n\
    \     'abc' * 1     ABF3A3A0  D4D7B9F6BD4FBFCF  883C3D4B97A61976FFCF2323\n   \
    \  'abc' * 500   ABEB3C8B  D4CF26DDEFD5C01A  8824A260C53C66A36C9260A6\n   The\
    \ first column lists a small sample of messages that are strings of\n   repeated\
    \ ASCII 'a' bytes or 'abc' strings.  The remaining columns\n   give in hexadecimal\
    \ the tags generated when UMAC is called with the\n   corresponding message, nonce\
    \ N and key K.\n   When using key K and producing a 64-bit tag, the following\
    \ relevant\n   keys are generated:\n                              Iteration 1\
    \         Iteration 2\n                              -----------         -----------\n\
    \     NH (Section 5.2.2)\n       K_1                     ACD79B4F            C6DFECA2\n\
    \       K_2                     6EDA0D0E            964A710D\n       K_3     \
    \                1625B603            AD7EDE4D\n       K_4                    \
    \ 84F9FC93            A1D3935E\n       K_5                     C6DFECA2      \
    \      62EC8672\n       ...\n       K_256                   0BF0F56C         \
    \   744C294F\n     L2-HASH (Section 5.3.1)\n       k64             0094B8DD0137BEF8\
    \    01036F4D000E7E72\n     L3-HASH (Section 5.4.1)\n       k_5              \
    \     056533C3A8          0504BF4D4E\n       k_6                   07591E062E\
    \          0126E922FF\n       k_7                   0C2D30F89D          030C0399E2\n\
    \       k_8                   046786437C          04C1CB8FED\n       K2      \
    \                2E79F461            A74C03AA\n   (Note that k_1 ... k_4 are not\
    \ listed in this example because they\n   are multiplied by zero in L3-HASH.)\n\
    \   When generating a 64-bit tag on input \"'abc' * 500\", the following\n   intermediate\
    \ results are produced:\n                   Iteration 1\n                   -----------\n\
    \     L1-HASH  E6096F94EDC45CAC1BEDCD0E7FDAA906\n     L2-HASH  0000000000000000A6C537D7986FA4AA\n\
    \     L3-HASH  05F86309\n                   Iteration 2\n                   -----------\n\
    \     L1-HASH  2665EAD321CFAE79C82F3B90261641E5\n     L2-HASH  00000000000000001D79EAF247B394BF\n\
    \     L3-HASH  DF9AD858\n   Concatenating the two L3-HASH results produces a final\
    \ UHASH result\n   of 05F86309DF9AD858.  The pad generated for nonce N is\n  \
    \ D13745D4304F1842, which when xor'ed with the L3-HASH result yields a\n   tag\
    \ of D4CF26DDEFD5C01A.\n"
- title: References
  contents:
  - 'References

    '
- title: Normative References
  contents:
  - "Normative References\n   [1]   FIPS-197, \"Advanced Encryption Standard (AES)\"\
    , National\n         Institute of Standards and Technology, 2001.\n"
- title: Informative References
  contents:
  - "Informative References\n   [2]   D. Bernstein, \"Stronger security bounds for\
    \ permutations\",\n         unpublished manuscript, 2005.  This work refines \"\
    Stronger\n         security bounds for Wegman-Carter-Shoup authenticators\",\n\
    \         Advances in Cryptology - EUROCRYPT 2005, LNCS vol. 3494, pp.\n     \
    \    164-180, Springer-Verlag, 2005.\n   [3]   J. Black, S. Halevi, H. Krawczyk,\
    \ T. Krovetz, and P. Rogaway,\n         \"UMAC: Fast and provably secure message\
    \ authentication\",\n         Advances in Cryptology - CRYPTO '99, LNCS vol. 1666,\
    \ pp. 216-\n         233, Springer-Verlag, 1999.\n   [4]   L. Carter and M. Wegman,\
    \ \"Universal classes of hash functions\",\n         Journal of Computer and System\
    \ Sciences, 18 (1979), pp. 143-\n         154.\n   [5]   Kent, S., \"IP Encapsulating\
    \ Security Payload (ESP)\", RFC 4303,\n         December 2005.\n   [6]   T. Krovetz,\
    \ \"Software-optimized universal hashing and message\n         authentication\"\
    , UMI Dissertation Services, 2000.\n   [7]   M. Wegman and L. Carter, \"New hash\
    \ functions and their use in\n         authentication and set equality\", Journal\
    \ of Computer and\n         System Sciences, 22 (1981), pp. 265-279.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   John Black\n   Department of Computer Science\n   University\
    \ of Colorado\n   Boulder, CO 80309\n   USA\n   EMail: jrblack@cs.colorado.edu\n\
    \   Shai Halevi\n   IBM T.J. Watson Research Center\n   P.O. Box 704\n   Yorktown\
    \ Heights, NY 10598\n   USA\n   EMail: shaih@alum.mit.edu\n   Alejandro Hevia\n\
    \   Department of Computer Science\n   University of Chile\n   Santiago 837-0459\n\
    \   CHILE\n   EMail: ahevia@dcc.uchile.cl\n   Hugo Krawczyk\n   IBM Research\n\
    \   19 Skyline Dr\n   Hawthorne, NY 10533\n   USA\n   EMail: hugo@ee.technion.ac.il\n\
    \   Ted Krovetz (Editor)\n   Department of Computer Science\n   California State\
    \ University\n   Sacramento, CA 95819\n   USA\n   EMail: tdk@acm.org\n   Phillip\
    \ Rogaway\n   Department of Computer Science\n   University of California\n  \
    \ Davis, CA 95616\n   USA\n   and\n   Department of Computer Science\n   Faculty\
    \ of Science\n   Chiang Mai University\n   Chiang Mai 50200\n   THAILAND\n   EMail:\
    \ rogaway@cs.ucdavis.edu\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n\
    \   Administrative Support Activity (IASA).\n"
