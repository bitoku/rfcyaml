- title: __initial_text__
  contents:
  - ''
- title: 'IEN: 129'
  contents:
  - "IEN: 129\n                              DOD STANDARD\n                     TRANSMISSION\
    \ CONTROL PROTOCOL\n                              January 1980\n             \
    \                 prepared for\n               Defense Advanced Research Projects\
    \ Agency\n                Information Processing Techniques Office\n         \
    \                1400 Wilson Boulevard\n                       Arlington, Virginia\
    \  22209\n                     Information Sciences Institute\n              \
    \             TABLE OF CONTENTS\n    PREFACE ........................................................\
    \ iii\n"
- title: 1.  INTRODUCTION ..................................................... 1
  contents:
  - "1.  INTRODUCTION ..................................................... 1\n  1.1\
    \  Motivation .................................................... 1\n  1.2  Scope\
    \ ......................................................... 2\n  1.3  About This\
    \ Document ........................................... 2\n  1.4  Interfaces ....................................................\
    \ 3\n  1.5  Operation ..................................................... 3\n"
- title: 2.  PHILOSOPHY ....................................................... 7
  contents:
  - "2.  PHILOSOPHY ....................................................... 7\n  2.1\
    \  Elements of the Internetwork System ........................... 7\n  2.2  Model\
    \ of Operation ............................................ 7\n  2.3  The Host\
    \ Environment .......................................... 8\n  2.4  Interfaces\
    \ .................................................... 9\n  2.5  Relation to Other\
    \ Protocols ................................... 9\n  2.6  Reliable Communication\
    \ ....................................... 10\n  2.7  Connection Establishment\
    \ and Clearing ........................ 10\n  2.8  Data Communication ...........................................\
    \ 12\n  2.9  Precedence and Security ...................................... 13\n\
    \  2.10 Robustness Principle ......................................... 13\n"
- title: 3.  FUNCTIONAL SPECIFICATION ........................................ 15
  contents:
  - "3.  FUNCTIONAL SPECIFICATION ........................................ 15\n  3.1\
    \  Header Format ................................................ 15\n  3.2  Terminology\
    \ .................................................. 19\n  3.3  Sequence Numbers\
    \ ............................................. 24\n  3.4  Establishing a connection\
    \ .................................... 29\n  3.5  Closing a Connection .........................................\
    \ 35\n  3.6  Precedence and Security ...................................... 38\n\
    \  3.7  Data Communication ........................................... 38\n  3.8\
    \  Interfaces ................................................... 42\n  3.9  Event\
    \ Processing ............................................. 52\n"
- title: GLOSSARY ............................................................ 75
  contents:
  - 'GLOSSARY ............................................................ 75

    '
- title: REFERENCES .......................................................... 83
  contents:
  - 'REFERENCES .......................................................... 83

    '
- title: Transmission Control Protocol
  contents:
  - "Transmission Control Protocol\n                                           Transmission\
    \ Control Protocol\n                                PREFACE\n"
- title: This document describes the DoD Standard Transmission Control Protocol
  contents:
  - 'This document describes the DoD Standard Transmission Control Protocol

    '
- title: (TCP).  There have been eight earlier editions of the ARPA TCP
  contents:
  - '(TCP).  There have been eight earlier editions of the ARPA TCP

    '
- title: specification on which this standard is based, and the present text
  contents:
  - 'specification on which this standard is based, and the present text

    '
- title: draws heavily from them.  There have been many contributors to this work
  contents:
  - 'draws heavily from them.  There have been many contributors to this work

    '
- title: both in terms of concepts and in terms of text.  This edition
  contents:
  - 'both in terms of concepts and in terms of text.  This edition

    '
- title: incorporates the addition of security, compartmentation, and precedence
  contents:
  - 'incorporates the addition of security, compartmentation, and precedence

    '
- title: concepts into the TCP specification.
  contents:
  - "concepts into the TCP specification.\n                                      \
    \                     Jon Postel\n                                           \
    \                Editor\n"
- title: RFC:761
  contents:
  - 'RFC:761

    '
- title: IEN:129
  contents:
  - 'IEN:129

    '
- title: 'Replaces:  IENs 124, 112,'
  contents:
  - 'Replaces:  IENs 124, 112,

    '
- title: 81, 55, 44, 40, 27, 21, 5
  contents:
  - "81, 55, 44, 40, 27, 21, 5\n                              DOD STANDARD\n     \
    \                TRANSMISSION CONTROL PROTOCOL\n                            1.\
    \  INTRODUCTION\n"
- title: The Transmission Control Protocol (TCP) is intended for use as a highly
  contents:
  - 'The Transmission Control Protocol (TCP) is intended for use as a highly

    '
- title: reliable host-to-host protocol between hosts in packet-switched computer
  contents:
  - 'reliable host-to-host protocol between hosts in packet-switched computer

    '
- title: communication networks, and especially in interconnected systems of such
  contents:
  - 'communication networks, and especially in interconnected systems of such

    '
- title: networks.
  contents:
  - 'networks.

    '
- title: This document describes the functions to be performed by the
  contents:
  - 'This document describes the functions to be performed by the

    '
- title: Transmission Control Protocol, the program that implements it, and its
  contents:
  - 'Transmission Control Protocol, the program that implements it, and its

    '
- title: interface to programs or users that require its services.
  contents:
  - 'interface to programs or users that require its services.

    '
- title: 1.1.  Motivation
  contents:
  - "1.1.  Motivation\n  Computer communication systems are playing an increasingly\
    \ important\n  role in military, government, and civilian environments.  This\n\
    \  document primarily focuses its attention on military computer\n  communication\
    \ requirements, especially robustness in the presence of\n  communication unreliability\
    \ and availability in the presence of\n  congestion, but many of these problems\
    \ are found in the civilian and\n  government sector as well.\n  As strategic\
    \ and tactical computer communication networks are\n  developed and deployed,\
    \ it is essential to provide means of\n  interconnecting them and to provide standard\
    \ interprocess\n  communication protocols which can support a broad range of\n\
    \  applications.  In anticipation of the need for such standards, the\n  Deputy\
    \ Undersecretary of Defense for Research and Engineering has\n  declared the Transmission\
    \ Control Protocol (TCP) described herein to\n  be a basis for DoD-wide inter-process\
    \ communication protocol\n  standardization.\n  TCP is a connection-oriented,\
    \ end-to-end reliable protocol designed to\n  fit into a layered hierarchy of\
    \ protocols which support multi-network\n  applications.  The TCP provides for\
    \ reliable inter-process\n  communication between pairs of processes in host computers\
    \ attached to\n  distinct but interconnected computer communication networks.\
    \  Very few\n  assumptions are made as to the reliability of the communication\n\
    \  protocols below the TCP layer.  TCP assumes it can obtain a simple,\n  potentially\
    \ unreliable datagram service from the lower level\n  protocols.  In principle,\
    \ the TCP should be able to operate above a\n  wide spectrum of communication\
    \ systems ranging from hard-wired\n  connections to packet-switched or circuit-switched\
    \ networks.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Introduction
  contents:
  - "Introduction\n  TCP is based on concepts first described by Cerf and Kahn in\
    \ [1].  The\n  TCP fits into a layered protocol architecture just above a basic\n\
    \  Internet Protocol [2] which provides a way for the TCP to send and\n  receive\
    \ variable-length segments of information enclosed in internet\n  datagram \"\
    envelopes\".  The internet datagram provides a means for\n  addressing source\
    \ and destination TCPs in different networks.  The\n  internet protocol also deals\
    \ with any fragmentation or reassembly of\n  the TCP segments required to achieve\
    \ transport and delivery through\n  multiple networks and interconnecting gateways.\
    \  The internet protocol\n  also carries information on the precedence, security\
    \ classification\n  and compartmentation of the TCP segments, so this information\
    \ can be\n  communicated end-to-end across multiple networks.\n              \
    \             Protocol Layering\n                        +---------------------+\n\
    \                        |     higher-level    |\n                        +---------------------+\n\
    \                        |        TCP          |\n                        +---------------------+\n\
    \                        |  internet protocol  |\n                        +---------------------+\n\
    \                        |communication network|\n                        +---------------------+\n\
    \                                Figure 1\n  Much of this document is written\
    \ in the context of TCP implementations\n  which are co-resident with higher level\
    \ protocols in the host\n  computer.  As a practical matter, many computer systems\
    \ will be\n  connected to networks via front-end computers which house the TCP\
    \ and\n  internet protocol layers, as well as network specific software.  The\n\
    \  TCP specification describes an interface to the higher level protocols\n  which\
    \ appears to be implementable even for the front-end case, as long\n  as a suitable\
    \ host-to-front end protocol is implemented.\n"
- title: 1.2.  Scope
  contents:
  - "1.2.  Scope\n  The TCP is intended to provide a reliable process-to-process\n\
    \  communication service in a multinetwork environment.  The TCP is\n  intended\
    \ to be a host-to-host protocol in common use in multiple\n  networks.\n"
- title: 1.3.  About this Document
  contents:
  - "1.3.  About this Document\n  This document represents a specification of the\
    \ behavior required of\n  any TCP implementation, both in its interactions with\
    \ higher level\n  protocols and in its interactions with other TCPs.  The rest\
    \ of this\n                                           Transmission Control Protocol\n\
    \                                                            Introduction\n  section\
    \ offers a very brief view of the protocol interfaces and\n  operation.  Section\
    \ 2 summarizes the philosophical basis for the TCP\n  design.  Section 3 offers\
    \ both a detailed description of the actions\n  required of TCP when various events\
    \ occur (arrival of new segments,\n  user calls, errors, etc.) and the details\
    \ of the formats of TCP\n  segments.\n"
- title: 1.4.  Interfaces
  contents:
  - "1.4.  Interfaces\n  The TCP interfaces on one side to user or application processes\
    \ and on\n  the other side to a lower level protocol such as Internet Protocol.\n\
    \  The interface between an application process and the TCP is\n  illustrated\
    \ in reasonable detail.  This interface consists of a set of\n  calls much like\
    \ the calls an operating system provides to an\n  application process for manipulating\
    \ files.  For example, there are\n  calls to open and close connections and to\
    \ send and receive letters on\n  established connections.  It is also expected\
    \ that the TCP can\n  asynchronously communicate with application programs.  Although\n\
    \  considerable freedom is permitted to TCP implementors to design\n  interfaces\
    \ which are appropriate to a particular operating system\n  environment, a minimum\
    \ functionality is required at the TCP/user\n  interface for any valid implementation.\n\
    \  The interface between TCP and lower level protocol is essentially\n  unspecified\
    \ except that it is assumed there is a mechanism whereby the\n  two levels can\
    \ asynchronously pass information to each other.\n  Typically, one expects the\
    \ lower level protocol to specify this\n  interface.  TCP is designed to work\
    \ in a very general environment of\n  interconnected networks.  The lower level\
    \ protocol which is assumed\n  throughout this document is the Internet Protocol\
    \ [2].\n"
- title: 1.5.  Operation
  contents:
  - "1.5.  Operation\n  As noted above, the primary purpose of the TCP is to provide\
    \ reliable,\n  securable logical circuit or connection service between pairs of\n\
    \  processes.  To provide this service on top of a less reliable internet\n  communication\
    \ system requires facilities in the following areas:\n    Basic Data Transfer\n\
    \    Reliability\n    Flow Control\n    Multiplexing\n    Connections\n    Precedence\
    \ and Security\n  The basic operation of the TCP in each of these areas is described\
    \ in\n  the following paragraphs.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Introduction
  contents:
  - "Introduction\n  Basic Data Transfer:\n    The TCP is able to transfer a continuous\
    \ stream of octets in each\n    direction between its users by packaging some\
    \ number of octets into\n    segments for transmission through the internet system.\
    \  In this\n    stream mode, the TCPs decide when to block and forward data at\
    \ their\n    own convenience.\n    For users who desire a record-oriented service,\
    \ the TCP also permits\n    the user to submit records, called letters, for transmission.\
    \  When\n    the sending user indicates a record boundary (end-of-letter), this\n\
    \    causes the TCPs to promptly forward and deliver data up to that\n    point\
    \ to the receiver.\n  Reliability:\n    The TCP must recover from data that is\
    \ damaged, lost, duplicated, or\n    delivered out of order by the internet communication\
    \ system.  This\n    is achieved by assigning a sequence number to each octet\n\
    \    transmitted, and requiring a positive acknowledgment (ACK) from the\n   \
    \ receiving TCP.  If the ACK is not received within a timeout\n    interval, the\
    \ data is retransmitted.  At the receiver, the sequence\n    numbers are used\
    \ to correctly order segments that may be received\n    out of order and to eliminate\
    \ duplicates.  Damage is handled by\n    adding a checksum to each segment transmitted,\
    \ checking it at the\n    receiver, and discarding damaged segments.\n    As long\
    \ as the TCPs continue to function properly and the internet\n    system does\
    \ not become completely partitioned, no transmission\n    errors will affect the\
    \ users.  TCP recovers from internet\n    communication system errors.\n  Flow\
    \ Control:\n    TCP provides a means for the receiver to govern the amount of\
    \ data\n    sent by the sender.  This is achieved by returning a \"window\" with\n\
    \    every ACK indicating a range of acceptable sequence numbers beyond\n    the\
    \ last segment successfully received.  For stream mode, the window\n    indicates\
    \ an allowed number of octets that the sender may transmit\n    before receiving\
    \ further permission.  For record mode, the window\n    indicates an allowed amount\
    \ of buffer space the sender may consume,\n    this may be more than the number\
    \ of data octets transmitted if there\n    is a mismatch between letter size and\
    \ buffer size.\n                                           Transmission Control\
    \ Protocol\n                                                            Introduction\n\
    \  Multiplexing:\n    To allow for many processes within a single Host to use\
    \ TCP\n    communication facilities simultaneously, the TCP provides a set of\n\
    \    addresses or ports within each host.  Concatenated with the network\n   \
    \ and host addresses from the internet communication layer, this forms\n    a\
    \ socket.  A pair of sockets uniquely identifies each connection.\n    That is,\
    \ a socket may be simultaneously used in multiple\n    connections.\n    The binding\
    \ of ports to processes is handled independently by each\n    Host.  However,\
    \ it proves useful to attach frequently used processes\n    (e.g., a \"logger\"\
    \ or timesharing service) to fixed sockets which are\n    made known to the public.\
    \  These services can then be accessed\n    through the known addresses.  Establishing\
    \ and learning the port\n    addresses of other processes may involve more dynamic\
    \ mechanisms.\n  Connections:\n    The reliability and flow control mechanisms\
    \ described above require\n    that TCPs initialize and maintain certain status\
    \ information for\n    each data stream.  The combination of this information,\
    \ including\n    sockets, sequence numbers, and window sizes, is called a connection.\n\
    \    Each connection is uniquely specified by a pair of sockets\n    identifying\
    \ its two sides.\n    When two processes wish to communicate, their TCP's must\
    \ first\n    establish a connection (initialize the status information on each\n\
    \    side).  When their communication is complete, the connection is\n    terminated\
    \ or closed to free the resources for other uses.\n    Since connections must\
    \ be established between unreliable hosts and\n    over the unreliable internet\
    \ communication system, a handshake\n    mechanism with clock-based sequence numbers\
    \ is used to avoid\n    erroneous initialization of connections.\n  Precedence\
    \ and Security:\n    The users of TCP may indicate the security and precedence\
    \ of their\n    communication.  Provision is made for default values to be used\
    \ when\n    these features are not needed.\n"
- title: Transmission Control Protocol
  contents:
  - "Transmission Control Protocol\n                                           Transmission\
    \ Control Protocol\n                             2.  PHILOSOPHY\n"
- title: 2.1.  Elements of the Internetwork System
  contents:
  - "2.1.  Elements of the Internetwork System\n  The internetwork environment consists\
    \ of hosts connected to networks\n  which are in turn interconnected via gateways.\
    \  It is assumed here\n  that the networks may be either local networks (e.g.,\
    \ the ETHERNET) or\n  large networks (e.g., the ARPANET), but in any case are\
    \ based on\n  packet switching technology.  The active agents that produce and\n\
    \  consume messages are processes.  Various levels of protocols in the\n  networks,\
    \ the gateways, and the hosts support an interprocess\n  communication system\
    \ that provides two-way data flow on logical\n  connections between process ports.\n\
    \  We specifically assume that data is transmitted from host to host\n  through\
    \ means of a set of  networks.  When we say network, we have in\n  mind a packet\
    \ switched network (PSN).  This assumption is probably\n  unnecessary, since a\
    \ circuit switched network or a hybrid combination\n  of the two could also be\
    \ used; but for concreteness, we explicitly\n  assume that the hosts are connected\
    \ to one or more packet switches of\n  a PSN.\n  The term packet is used generically\
    \ here to mean the data of one\n  transaction between a host and a packet switch.\
    \  The format of data\n  blocks exchanged between the packet switches in a network\
    \ will\n  generally not be of concern to us.\n  Hosts are computers attached to\
    \ a network, and from the communication\n  network's point of view, are the sources\
    \ and destinations of packets.\n  Processes are viewed as the active elements\
    \ in host computers (in\n  accordance with the fairly common definition of a process\
    \ as a program\n  in execution).  Even terminals and files or other I/O devices\
    \ are\n  viewed as communicating with each other through the use of processes.\n\
    \  Thus, all communication is viewed as inter-process communication.\n  Since\
    \ a process may need to distinguish among several communication\n  streams between\
    \ itself and another process (or processes), we imagine\n  that each process may\
    \ have a number of ports through which it\n  communicates with the ports of other\
    \ processes.\n"
- title: 2.2.  Model of Operation
  contents:
  - "2.2.  Model of Operation\n  Processes transmit data by calling on the TCP and\
    \ passing buffers of\n  data as arguments.  The TCP packages the data from these\
    \ buffers into\n  segments and calls on the internet module to transmit each segment\
    \ to\n  the destination TCP.  The receiving TCP places the data from a segment\n\
    \  into the receiving user's buffer and notifies the receiving user.  The\n  TCPs\
    \ include control information in the segments which they use to\n  ensure reliable\
    \ ordered data transmission.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Philosophy
  contents:
  - "Philosophy\n  The model of internet communication is that there is an internet\n\
    \  protocol module associated with each TCP which provides an interface\n  to\
    \ the local network.  This internet module packages TCP segments\n  inside internet\
    \ datagrams and routes these datagrams to a destination\n  internet module or\
    \ intermediate gateway.  To transmit the datagram\n  through the local network,\
    \ it is embedded in a local network packet.\n  The packet switches may perform\
    \ further packaging, fragmentation, or\n  other operations to achieve the delivery\
    \ of the local packet to the\n  destination internet module.\n  At a gateway between\
    \ networks, the internet datagram is \"unwrapped\"\n  from its local packet and\
    \ examined to determine through which network\n  the internet datagram should\
    \ travel next.  The internet datagram is\n  then \"wrapped\" in a local packet\
    \ suitable to the next network and\n  routed to the next gateway, or to the final\
    \ destination.\n  A gateway is permitted to break up an internet datagram into\
    \ smaller\n  internet datagram fragments if this is necessary for transmission\n\
    \  through the next network.  To do this, the gateway produces a set of\n  internet\
    \ datagrams; each carrying a fragment.  Fragments may be broken\n  into smaller\
    \ ones at intermediate gateways.  The internet datagram\n  fragment format is\
    \ designed so that the destination internet module\n  can reassemble fragments\
    \ into internet datagrams.\n  A destination internet module unwraps the segment\
    \ from the datagram\n  (after reassembling the datagram, if necessary) and passes\
    \ it to the\n  destination TCP.\n  This simple model of the operation glosses\
    \ over many details.  One\n  important feature is the type of service.  This provides\
    \ information\n  to the gateway (or internet module) to guide it in selecting\
    \ the\n  service parameters to be used in traversing the next network.\n  Included\
    \ in the type of service information is the precedence of the\n  datagram.  Datagrams\
    \ may also carry security information to permit\n  host and gateways that operate\
    \ in multilevel secure environments to\n  properly segregate datagrams for security\
    \ considerations.\n"
- title: 2.3.  The Host Environment
  contents:
  - "2.3.  The Host Environment\n  The TCP is assumed to be a module in a time sharing\
    \ operating system.\n  The users access the TCP much like they would access the\
    \ file system.\n  The TCP may call on other operating system functions, for example,\
    \ to\n  manage data structures.  The actual interface to the network is\n  assumed\
    \ to be controlled by a device driver module.  The TCP does not\n  call on the\
    \ network device driver directly, but rather calls on the\n  internet datagram\
    \ protocol module which may in turn call on the device\n  driver.\n          \
    \                                 Transmission Control Protocol\n            \
    \                                                  Philosophy\n  Though it is\
    \ assumed here that processes are supported by the host\n  operating system, the\
    \ mechanisms of TCP do not preclude implementation\n  of the TCP in a front-end\
    \ processor.  However, in such an\n  implementation, a host-to-front-end protocol\
    \ must provide the\n  functionality to support the type of TCP-user interface\
    \ described\n  above.\n"
- title: 2.4.  Interfaces
  contents:
  - "2.4.  Interfaces\n  The TCP/user interface provides for calls made by the user\
    \ on the TCP\n  to OPEN or CLOSE a connection, to SEND or RECEIVE data, or to\
    \ obtain\n  STATUS about a connection.  These calls are like other calls from\
    \ user\n  programs on the operating system, for example, the calls to open, read\n\
    \  from, and close a file.\n  The TCP/internet interface provides calls to send\
    \ and receive\n  datagrams addressed to TCP modules in hosts anywhere in the internet\n\
    \  system.  These calls have parameters for passing the address, type of\n  service,\
    \ precedence, security, and other control information.\n"
- title: 2.5.  Relation to Other Protocols
  contents:
  - "2.5.  Relation to Other Protocols\n  The following diagram illustrates the place\
    \ of the TCP in the protocol\n  hierarchy:\n       +------+ +-----+ +-----+  \
    \     +-----+                    \n       |Telnet| | FTP | |Voice|  ...  |   \
    \  |  Application Level \n       +------+ +-----+ +-----+       +-----+      \
    \              \n             |   |         |             |                  \
    \     \n            +-----+     +-----+       +-----+                    \n  \
    \          | TCP |     | RTP |  ...  |     |  Host Level        \n           \
    \ +-----+     +-----+       +-----+                    \n               |    \
    \       |             |                       \n            +-------------------------------+\
    \                    \n            |      Internet Protocol        |  Gateway\
    \ Level     \n            +-------------------------------+                  \
    \  \n                           |                                     \n     \
    \         +---------------------------+                      \n              |\
    \   Local Network Protocol  |    Network Level     \n              +---------------------------+\
    \                      \n                           |                        \
    \             \n                         Protocol Relationships\n            \
    \                   Figure 2.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Philosophy
  contents:
  - "Philosophy\n  It is expected that the TCP will be able to support higher level\n\
    \  protocols efficiently.  It should be easy to interface higher level\n  protocols\
    \ like the ARPANET Telnet [3] or AUTODIN II THP to the TCP.\n"
- title: 2.6.  Reliable Communication
  contents:
  - "2.6.  Reliable Communication\n  A stream of data sent on a TCP connection is\
    \ delivered reliably and in\n  order at the destination.\n  Transmission is made\
    \ reliable via the use of sequence numbers and\n  acknowledgments.  Conceptually,\
    \ each octet of data is assigned a\n  sequence number.  The sequence number of\
    \ the first octet of data in a\n  segment is the sequence number transmitted with\
    \ that segment and is\n  called the segment sequence number.  Segments also carry\
    \ an\n  acknowledgment number which is the sequence number of the next\n  expected\
    \ data octet of transmissions in the reverse direction.  When\n  the TCP transmits\
    \ a segment, it puts a copy on a retransmission queue\n  and starts a timer; when\
    \ the acknowledgment for that data is received,\n  the segment is deleted from\
    \ the queue.  If the acknowledgment is not\n  received before the timer runs out,\
    \ the segment is retransmitted.\n  An acknowledgment by TCP does not guarantee\
    \ that the data has been\n  delivered to the end user, but only that the receiving\
    \ TCP has taken\n  the responsibility to do so.\n  To govern the flow of data\
    \ into a TCP, a flow control mechanism is\n  employed.  The the data receiving\
    \ TCP reports a window to the sending\n  TCP.  This window specifies the number\
    \ of octets, starting with the\n  acknowledgment number that the data receiving\
    \ TCP is currently\n  prepared to receive.\n"
- title: 2.7.  Connection Establishment and Clearing
  contents:
  - "2.7.  Connection Establishment and Clearing\n  To identify the separate data\
    \ streams that a TCP may handle, the TCP\n  provides a port identifier.  Since\
    \ port identifiers are selected\n  independently by each operating system, TCP,\
    \ or user, they might not\n  be unique.  To provide for unique addresses at each\
    \ TCP, we\n  concatenate an internet address identifying the TCP with a port\n\
    \  identifier to create a socket which will be unique throughout all\n  networks\
    \ connected together.\n  A connection is fully specified by the pair of sockets\
    \ at the ends.  A\n  local socket may participate in many connections to different\
    \ foreign\n  sockets.  A connection can be used to carry data in both directions,\n\
    \  that is, it is \"full duplex\".\n  TCPs are free to associate ports with processes\
    \ however they choose.\n  However, several basic concepts seem necessary in any\
    \ implementation.\n                                           Transmission Control\
    \ Protocol\n                                                              Philosophy\n\
    \  There must be well-known sockets which the TCP associates only with\n  the\
    \ \"appropriate\" processes by some means.  We envision that processes\n  may\
    \ \"own\" ports, and that processes can only initiate connections on\n  the ports\
    \ they own.  (Means for implementing ownership is a local\n  issue, but we envision\
    \ a Request Port user command, or a method of\n  uniquely allocating a group of\
    \ ports to a given process, e.g., by\n  associating the high order bits of a port\
    \ name with a given process.)\n  A connection is specified in the OPEN call by\
    \ the local port and\n  foreign socket arguments.  In return, the TCP supplies\
    \ a (short) local\n  connection name by which the user refers to the connection\
    \ in\n  subsequent calls.  There are several things that must be remembered\n\
    \  about a connection.  To store this information we imagine that there\n  is\
    \ a data structure called a Transmission Control Block (TCB).  One\n  implementation\
    \ strategy would have the local connection name be a\n  pointer to the TCB for\
    \ this connection.  The OPEN call also specifies\n  whether the connection establishment\
    \ is to be actively pursued, or to\n  be passively waited for.\n  A passive OPEN\
    \ request means that the process wants to accept incoming\n  connection requests\
    \ rather than attempting to initiate a connection.\n  Often the process requesting\
    \ a passive OPEN will accept a connection\n  request from any caller.  In this\
    \ case a foreign socket of all zeros\n  is used to denote an unspecified socket.\
    \  Unspecified foreign sockets\n  are allowed only on passive OPENs.\n  A service\
    \ process that wished to provide services for unknown other\n  processes could\
    \ issue a passive OPEN request with an unspecified\n  foreign socket.  Then a\
    \ connection could be made with any process that\n  requested a connection to\
    \ this local socket.  It would help if this\n  local socket were known to be associated\
    \ with this service.\n  Well-known sockets are a convenient mechanism for a priori\
    \ associating\n  a socket address with a standard service.  For instance, the\n\
    \  \"Telnet-Server\" process might be permanently assigned to a particular\n \
    \ socket, and other sockets might be reserved for File Transfer, Remote\n  Job\
    \ Entry, Text Generator, Echoer, and Sink processes (the last three\n  being for\
    \ test purposes).  A socket address might be reserved for\n  access to a \"Look-Up\"\
    \ service which would return the specific socket\n  at which a newly created service\
    \ would be provided.  The concept of a\n  well-known socket is part of the TCP\
    \ specification, but the assignment\n  of sockets to services is outside this\
    \ specification.\n  Processes can issue passive OPENs and wait for matching calls\
    \ from\n  other processes and be informed by the TCP when connections have been\n\
    \  established.  Two processes which issue calls to each other at the\n  same\
    \ time are correctly connected.  This flexibility is critical for\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Philosophy
  contents:
  - "Philosophy\n  the support of distributed computing in which components act\n\
    \  asynchronously with respect to each other.\n  There are two cases for matching\
    \ the sockets in the local request and\n  an incoming segment.  In the first case,\
    \ the local request has fully\n  specified the foreign socket.  In this case,\
    \ the match must be exact.\n  In the second case, the local request has left the\
    \ foreign socket\n  unspecified.  In this case, any foreign socket is acceptable\
    \ as long\n  as the local sockets match.\n  If there are several pending passive\
    \ OPENs (recorded in TCBs) with the\n  same local socket, an incoming segment\
    \ should be matched to a request\n  with the specific foreign socket in the segment,\
    \ if such a request\n  exists, before selecting a request with an unspecified\
    \ foreign socket.\n  The procedures to establish and clear connections utilize\
    \ synchronize\n  (SYN) and finis (FIN) control flags and involve an exchange of\
    \ three\n  messages.  This exchange has been termed a three-way hand shake [4].\n\
    \  A connection is initiated by the rendezvous of an arriving segment\n  containing\
    \ a SYN and a waiting TCB entry created by a user OPEN\n  command.  The matching\
    \ of local and foreign sockets determines when a\n  connection has been initiated.\
    \  The connection becomes \"established\"\n  when sequence numbers have been synchronized\
    \ in both directions.\n  The clearing of a connection also involves the exchange\
    \ of segments,\n  in this case carrying the FIN control flag.\n"
- title: 2.8.  Data Communication
  contents:
  - "2.8.  Data Communication\n  The data that flows on a connection may be thought\
    \ of as a stream of\n  octets, or as a sequence of records.  In TCP the records\
    \ are called\n  letters and are of variable length.  The sending user indicates\
    \ in\n  each SEND call whether the data in that call completes a letter by the\n\
    \  setting of the end-of-letter parameter.\n  The length of a letter may be such\
    \ that it must be broken into\n  segments before it can be transmitted to its\
    \ destination.  We assume\n  that the segments will normally be reassembled into\
    \ a letter before\n  being passed to the receiving process.  A segment may contain\
    \ all or a\n  part of a letter, but a segment never contains parts of more than\
    \ one\n  letter.  The end of a letter is marked by the appearance of an EOL\n\
    \  control flag in a segment.  A sending TCP is allowed to collect data\n  from\
    \ the sending user and to send that data in segments at its own\n  convenience,\
    \ until the end of letter is signaled then it must send all\n  unsent data.  When\
    \ a receiving TCP has a complete letter, it must not\n  wait for more data from\
    \ the sending TCP before passing the letter to\n  the receiving process.\n   \
    \                                        Transmission Control Protocol\n     \
    \                                                         Philosophy\n  There\
    \ is a coupling between letters as sent and the use of buffers of\n  data that\
    \ cross the TCP/user interface.  Each time an end-of-letter\n  (EOL) flag is associated\
    \ with data placed into the receiving user's\n  buffer, the buffer is returned\
    \ to the user for processing even if the\n  buffer is not filled.  If a letter\
    \ is longer than the user's buffer,\n  the letter is passed to the user in buffer\
    \ size units, the last of\n  which may be only partly full.  The receiving TCP's\
    \ buffer size may be\n  communicated to the sending TCP when the connection is\
    \ being\n  established.\n  The TCP is responsible for regulating the flow of segments\
    \ on the\n  connections, as a way of preventing itself from becoming saturated\
    \ or\n  overloaded with traffic.  This is done using a window flow control\n \
    \ mechanism.  The data receiving TCP reports to the data sending TCP a\n  window\
    \ which is the range of sequence numbers of data octets that data\n  receiving\
    \ TCP is currently prepared to accept.\n  TCP also provides a means to communicate\
    \ to the receiver of data that\n  at some point further along in the data stream\
    \ than the receiver is\n  currently reading there is urgent data.  TCP does not\
    \ attempt to\n  define what the user specifically does upon being notified of\
    \ pending\n  urgent data, but the general notion is that the receiving process\n\
    \  should take action to read through the end urgent data quickly.\n"
- title: 2.9.  Precedence and Security
  contents:
  - "2.9.  Precedence and Security\n  The TCP makes use of the internet protocol type\
    \ of service field and\n  security option to provide precedence and security on\
    \ a per connection\n  basis to TCP users.  Not all TCP modules will necessarily\
    \ function in\n  a multilevel secure environment, some may be limited to unclassified\n\
    \  use only, and others may operate at only one security level and\n  compartment.\
    \  Consequently, some TCP implementations and services to\n  users may be limited\
    \ to a subset of the multilevel secure case.\n  TCP modules which operate in a\
    \ multilevel secure environment should\n  properly mark outgoing segments with\
    \ the security, compartment, and\n  precedence.  Such TCP modules should also\
    \ provide to their users or\n  higher level protocols such as Telnet or THP an\
    \ interface to allow\n  them to specify the desired security level, compartment,\
    \ and\n  precedence of connections.\n"
- title: 2.10.  Robustness Principle
  contents:
  - "2.10.  Robustness Principle\n  TCP implementations should follow a general principle\
    \ of robustness:\n  be conservative in what you do, be liberal in what you accept\
    \ from\n  others.\n"
- title: Transmission Control Protocol
  contents:
  - "Transmission Control Protocol\n                                           Transmission\
    \ Control Protocol\n                      3.  FUNCTIONAL SPECIFICATION\n"
- title: 3.1.  Header Format
  contents:
  - "3.1.  Header Format\n  TCP segments are sent as internet datagrams.  The Internet\
    \ Protocol\n  header carries several information fields, including the source\
    \ and\n  destination host addresses [2].  A TCP header follows the internet\n\
    \  header, supplying information specific to the TCP protocol.  This\n  division\
    \ allows for the existence of host level protocols other than\n  TCP.\n  TCP Header\
    \ Format\n    0                   1                   2                   3  \
    \ \n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 \n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |          Source Port          |       Destination Port        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                        Sequence Number                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Acknowledgment Number                      |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Data |           |U|A|E|R|S|F|                               |\n   | Offset|\
    \ Reserved  |R|C|O|S|Y|I|            Window             |\n   |       |      \
    \     |G|K|L|T|N|N|                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |           Checksum            |         Urgent Pointer        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                    Options                    |    Padding    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                             data                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                            TCP Header Format\n          Note that one tick mark\
    \ represents one bit position.\n                               Figure 3.\n  Source\
    \ Port:  16 bits\n    The source port number.\n  Destination Port:  16 bits\n\
    \    The destination port number.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n  Sequence Number:  32 bits\n    The sequence number\
    \ of the first data octet in this segment (except\n    when SYN is present).\n\
    \  Acknowledgment Number:  32 bits\n    If the ACK control bit is set this field\
    \ contains the value of the\n    next sequence number the sender of the segment\
    \ is expecting to\n    receive.  Once a connection is established this is always\
    \ sent.\n  Data Offset:  4 bits\n    The number of 32 bit words in the TCP Header.\
    \  This indicates where\n    the data begins.  The TCP header including options\
    \ is an integral\n    number of 32 bits long.\n  Reserved:  6 bits\n    Reserved\
    \ for future use.  Must be zero.\n  Control Bits:  8 bits (from left to right):\n\
    \    URG:  Urgent Pointer field significant\n    ACK:  Acknowledgment field significant\n\
    \    EOL:  End of Letter\n    RST:  Reset the connection\n    SYN:  Synchronize\
    \ sequence numbers\n    FIN:  No more data from sender\n  Window:  16 bits\n \
    \   The number of data octets beginning with the one indicated in the\n    acknowledgment\
    \ field which the sender of this segment is willing to\n    accept.\n  Checksum:\
    \  16 bits\n    The checksum field is the 16 bit one's complement of the one's\n\
    \    complement sum of all 16 bit words in the header and text.  If a\n    segment\
    \ contains an odd number of header and text octets to be\n    checksummed, the\
    \ last octet is padded on the right with zeros to\n    form a 16 bit word for\
    \ checksum purposes.  The pad is not\n    transmitted as part of the segment.\
    \  While computing the checksum,\n    the checksum field itself is replaced with\
    \ zeros.\n    The checksum also covers a 96 bit pseudo header conceptually\n \
    \   prefixed to the TCP header.  This pseudo header contains the Source\n    \
    \                                       Transmission Control Protocol\n      \
    \                                          Functional Specification\n    Address,\
    \ the Destination Address, the Protocol, and TCP length.\n    This gives the TCP\
    \ protection against misrouted segments.  This\n    information is carried in\
    \ the Internet Protocol and is transferred\n    across the TCP/Network interface\
    \ in the arguments or results of\n    calls by the TCP on the IP.\n          \
    \           +--------------------------+\n                     |      Source Address\
    \      |\n                     +--------------------------+\n                \
    \     |    Destination Address   |\n                     +--------------------------+\n\
    \                     | zero | PTCL | TCP Length |\n                     +--------------------------+\n\
    \      The TCP Length is the TCP header plus the data length in octets\n     \
    \ (this is not an explicitly transmitted quantity, but is computed\n      from\
    \ the total length, and the header length).\n  Urgent Pointer:  16 bits\n    This\
    \ field communicates the current value of the urgent pointer as a\n    positive\
    \ offset from the sequence number in this segment.  The\n    urgent pointer points\
    \ to the sequence number of the octet following\n    the urgent data.  This field\
    \ should only be interpreted in segments\n    with the URG control bit set.\n\
    \  Options:  variable\n    Options may occupy space at the end of the TCP header\
    \ and are a\n    multiple of 8 bits in length.  All options are included in the\n\
    \    checksum.  An option may begin on any octet boundary.  There are two\n  \
    \  cases for the format of an option:\n      Case 1:  A single octet of option-kind.\n\
    \      Case 2:  An octet of option-kind, an octet of option-length, and\n    \
    \           the actual option-data octets.\n    The option-length counts the two\
    \ octets of option-kind and\n    option-length as well as the option-data octets.\n\
    \    Note that the list of options may be shorter than the data offset\n    field\
    \ might imply.  The content of the header beyond the\n    End-of-Option option\
    \ should be header padding (i.e., zero).\n    A TCP must implement all options.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n    Currently defined options include (kind indicated\
    \ in octal):\n      Kind     Length    Meaning\n      ----     ------    -------\n\
    \       0         -       End of option list.\n       1         -       No-Operation.\n\
    \      100        -       Reserved.\n      105        4       Buffer Size.\n \
    \   Specific Option Definitions\n      End of Option List\n        +--------+\n\
    \        |00000000|\n        +--------+\n         Kind=0\n        This option\
    \ code indicates the end of the option list.  This\n        might not coincide\
    \ with the end of the TCP header according to\n        the Data Offset field.\
    \  This is used at the end of all options,\n        not the end of each option,\
    \ and need only be used if the end of\n        the options would not otherwise\
    \ coincide with the end of the TCP\n        header.\n      No-Operation\n    \
    \    +--------+\n        |00000001|\n        +--------+\n         Kind=1\n   \
    \     This option code may be used between options, for example, to\n        align\
    \ the beginning of a subsequent option on a word boundary.\n        There is no\
    \ guarantee that senders will use this option, so\n        receivers must be prepared\
    \ to process options even if they do\n        not begin on a word boundary.\n\
    \      Buffer Size\n        +--------+--------+---------+--------+\n        |01000101|00000100|\
    \    buffer size   |\n        +--------+--------+---------+--------+\n       \
    \  Kind=105 Length=4\n                                           Transmission\
    \ Control Protocol\n                                                Functional\
    \ Specification\n        Buffer Size Option Data:  16 bits\n          If this\
    \ option is present, then it communicates the receive\n          buffer size at\
    \ the TCP which sends this segment.  This field\n          should only be sent\
    \ in the initial connection request (i.e.,\n          in segments with the SYN\
    \ control bit set).  If this option is\n          not used, the default buffer\
    \ size of one octet is assumed.\n  Padding:  variable\n    The TCP header padding\
    \ is used to ensure that the TCP header ends\n    and data begins on a 32 bit\
    \ boundary.  The padding is composed of\n    zeros.\n"
- title: 3.2.  Terminology
  contents:
  - "3.2.  Terminology\n  Before we can discuss very much about the operation of the\
    \ TCP we need\n  to introduce some detailed terminology.  The maintenance of a\
    \ TCP\n  connection requires the remembering of several variables.  We conceive\n\
    \  of these variables being stored in a connection record called a\n  Transmission\
    \ Control Block or TCB.  Among the variables stored in the\n  TCB are the local\
    \ and remote socket numbers, the security and\n  precedence of the connection,\
    \ pointers to the user's send and receive\n  buffers, pointers to the retransmit\
    \ queue and to the current segment.\n  In addition several variables relating\
    \ to the send and receive\n  sequence numbers are stored in the TCB.\n    Send\
    \ Sequence Variables\n      SND.UNA - send unacknowledged\n      SND.NXT - send\
    \ sequence\n      SND.WND - send window\n      SND.BS  - send buffer size\n  \
    \    SND.UP  - send urgent pointer\n      SND.WL  - send sequence number used\
    \ for last window update\n      SND.LBB - send last buffer beginning\n      ISS\
    \     - initial send sequence number\n    Receive Sequence Variables\n      RCV.NXT\
    \ - receive sequence\n      RCV.WND - receive window\n      RCV.BS  - receive\
    \ buffer size\n      RCV.UP  - receive urgent pointer\n      RCV.LBB - receive\
    \ last buffer beginning\n      IRS     - initial receive sequence number\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n  The following diagrams may help to relate some of\
    \ these variables to\n  the sequence space.\n  Send Sequence Space\n         \
    \          1         2          3          4      \n              ----------|----------|----------|----------\
    \ \n                     SND.UNA    SND.NXT    SND.UNA        \n             \
    \                             +SND.WND        \n        1 - old sequence numbers\
    \ which have been acknowledged  \n        2 - sequence numbers of unacknowledged\
    \ data            \n        3 - sequence numbers allowed for new data transmission\
    \ \n        4 - future sequence numbers which are not yet allowed  \n        \
    \                  Send Sequence Space\n                               Figure\
    \ 4.\n  Receive Sequence Space\n                       1          2          3\
    \      \n                   ----------|----------|---------- \n              \
    \            RCV.NXT    RCV.NXT        \n                                    +RCV.WND\
    \        \n        1 - old sequence numbers which have been acknowledged  \n \
    \       2 - sequence numbers allowed for new reception         \n        3 - future\
    \ sequence numbers which are not yet allowed  \n                         Receive\
    \ Sequence Space\n                               Figure 5.\n  There are also some\
    \ variables used frequently in the discussion that\n  take their values from the\
    \ fields of the current segment.\n                                           Transmission\
    \ Control Protocol\n                                                Functional\
    \ Specification\n    Current Segment Variables\n      SEG.SEQ - segment sequence\
    \ number\n      SEG.ACK - segment acknowledgment number\n      SEG.LEN - segment\
    \ length\n      SEG.WND - segment window\n      SEG.UP  - segment urgent pointer\n\
    \      SEG.PRC - segment precedence value\n  A connection progresses through a\
    \ series of states during its\n  lifetime.  The states are:  LISTEN, SYN-SENT,\
    \ SYN-RECEIVED,\n  ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, TIME-WAIT, CLOSE-WAIT,\
    \ CLOSING,\n  and the fictional state CLOSED.  CLOSED is fictional because it\n\
    \  represents the state when there is no TCB, and therefore, no\n  connection.\
    \  Briefly the meanings of the states are:\n    LISTEN - represents waiting for\
    \ a connection request from any remote\n    TCP and port.\n    SYN-SENT - represents\
    \ waiting for a matching connection request\n    after having sent a connection\
    \ request.\n    SYN-RECEIVED - represents waiting for a confirming connection\n\
    \    request acknowledgment after having both received and sent a\n    connection\
    \ request.\n    ESTABLISHED - represents an open connection, ready to transmit\
    \ and\n    receive data segments.\n    FIN-WAIT-1 - represents waiting for a connection\
    \ termination request\n    from the remote TCP, or an acknowledgment of the connection\n\
    \    termination request previously sent.\n    FIN-WAIT-2 - represents waiting\
    \ for a connection termination request\n    from the remote TCP.\n    TIME-WAIT\
    \ - represents waiting for enough time to pass to be sure\n    the remote TCP\
    \ received the acknowledgment of its connection\n    termination request.\n  \
    \  CLOSE-WAIT - represents waiting for a connection termination request\n    from\
    \ the local user.\n    CLOSING - represents waiting for a connection termination\
    \ request\n    acknowledgment from the remote TCP.\n    CLOSED - represents no\
    \ connection state at all.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n  A TCP connection progresses from one state to another\
    \ in response to\n  events.  The events are the user calls, OPEN, SEND, RECEIVE,\
    \ CLOSE,\n  ABORT, and STATUS; the incoming segments, particularly those\n  containing\
    \ the SYN and FIN flags; and timeouts.\n  The Glossary contains a more complete\
    \ list of terms and their\n  definitions.\n  The state diagram in figure 6 only\
    \ illustrates state changes, together\n  with the causing events and resulting\
    \ actions, but addresses neither\n  error conditions nor actions which are not\
    \ connected with state\n  changes.  In a later section, more detail is offered\
    \ with respect to\n  the reaction of the TCP to events.\n                    \
    \                       Transmission Control Protocol\n                      \
    \                          Functional Specification\n                        \
    \      +---------+ ---------\\      active OPEN  \n                          \
    \    |  CLOSED |            \\    -----------  \n                            \
    \  +---------+<---------\\   \\   create TCB  \n                             \
    \   |     ^              \\   \\  snd SYN    \n                   passive OPEN\
    \ |     |   CLOSE        \\   \\           \n                   ------------ |\
    \     | ----------       \\   \\         \n                    create TCB  | \
    \    | delete TCB         \\   \\       \n                                V  \
    \   |                      \\   \\     \n                              +---------+\
    \            CLOSE    |    \\   \n                              |  LISTEN |  \
    \        ---------- |     |  \n                              +---------+     \
    \     delete TCB |     |  \n                   rcv SYN      |     |     SEND \
    \             |     |  \n                  -----------   |     |    -------  \
    \          |     V  \n +---------+      snd SYN,ACK  /       \\   snd SYN    \
    \      +---------+\n |         |<-----------------           ------------------>|\
    \         |\n |   SYN   |                    rcv SYN                     |   SYN\
    \   |\n |   RCVD  |<-----------------------------------------------|   SENT  |\n\
    \ |         |                    snd ACK                     |         |\n | \
    \        |------------------           -------------------|         |\n +---------+\
    \   rcv ACK of SYN  \\       /  rcv SYN,ACK       +---------+\n   |          \
    \ --------------   |     |   -----------                  \n   |             \
    \     x         |     |     snd ACK                    \n   |                \
    \            V     V                                \n   |  CLOSE            \
    \       +---------+                              \n   | -------              \
    \    |  ESTAB  |                              \n   | snd FIN                 \
    \ +---------+                              \n   |                   CLOSE    |\
    \     |    rcv FIN                     \n   V                  -------   |   \
    \  |    -------                     \n +---------+          snd FIN  /       \\\
    \   snd ACK          +---------+\n |  FIN    |<-----------------           ------------------>|\
    \  CLOSE  |\n | WAIT-1  |------------------           -------------------|   WAIT\
    \  |\n +---------+          rcv FIN  \\       /   CLOSE            +---------+\n\
    \   | rcv ACK of FIN   -------   |     |   -------                      \n   |\
    \ --------------   snd ACK   |     |   snd FIN                      \n   V   \
    \     x                   V     V                                \n +---------+\
    \                  +---------+                              \n |FINWAIT-2|   \
    \               | CLOSING |                              \n +---------+      \
    \            +---------+                              \n   | rcv FIN         \
    \                 | rcv ACK of FIN                 \n   | -------    Timeout=2MSL\
    \          | --------------                 \n   V snd ACK    ------------   \
    \       V   delete TCB                   \n +---------+     delete TCB   +---------+\
    \                              \n |TIME WAIT|----------------->| CLOSED  |   \
    \                           \n +---------+                  +---------+      \
    \                        \n                      TCP Connection State Diagram\n\
    \                               Figure 6.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - 'Functional Specification

    '
- title: 3.3.  Sequence Numbers
  contents:
  - "3.3.  Sequence Numbers\n  A fundamental notion in the design is that every octet\
    \ of data sent\n  over a TCP connection has a sequence number.  Since every octet\
    \ is\n  sequenced, each of them can be acknowledged.  The acknowledgment\n  mechanism\
    \ employed is cumulative so that an acknowledgment of sequence\n  number X indicates\
    \ that all octets up to but not including X have been\n  received.  This mechanism\
    \ allows for straight-forward duplicate\n  detection in the presence of retransmission.\
    \  Numbering of octets\n  within a segment is that the first data octet immediately\
    \ following\n  the header is the lowest numbered, and the following octets are\n\
    \  numbered consecutively.\n  It is essential to remember that the actual sequence\
    \ number space is\n  finite, though very large.  This space ranges from 0 to 2**32\
    \ - 1.\n  Since the space is finite, all arithmetic dealing with sequence\n  numbers\
    \ must be performed modulo 2**32.  This unsigned arithmetic\n  preserves the relationship\
    \ of sequence numbers as they cycle from\n  2**32 - 1 to 0 again.  There are some\
    \ subtleties to computer modulo\n  arithmetic, so great care should be taken in\
    \ programming the\n  comparison of such values.  The typical kinds of sequence\
    \ number\n  comparisons which the TCP must perform include:\n    (a)  Determining\
    \ that an acknowledgment refers to some sequence\n         number sent but not\
    \ yet acknowledged.\n    (b)  Determining that all sequence numbers occupied by\
    \ a segment\n         have been acknowledged (e.g., to remove the segment from\
    \ a\n         retransmission queue).\n    (c)  Determining that an incoming segment\
    \ contains sequence numbers\n         which are expected (i.e., that the segment\
    \ \"overlaps\" the\n         receive window).\n                              \
    \             Transmission Control Protocol\n                                \
    \                Functional Specification\n  On send connections the following\
    \ comparisons are needed:\n    older sequence numbers                        newer\
    \ sequence numbers\n        SND.UNA                SEG.ACK                 SND.NXT\
    \  \n           |                      |                       |     \n      \
    \ ----|----XXXXXXX------XXXXXXXXXX---------XXXXXX----|---- \n           |    |\
    \            |    |             |         |     \n                |          \
    \  |                  |               \n             Segment 1    Segment 2  \
    \        Segment 3          \n                      <----- sequence space ----->\n\
    \                   Sending Sequence Space Information\n                     \
    \          Figure 7.\n    SND.UNA = oldest unacknowledged sequence number\n  \
    \  SND.NXT = next sequence number to be sent\n    SEG.ACK = acknowledgment (next\
    \ sequence number expected by the\n              acknowledging TCP)\n    SEG.SEQ\
    \ = first sequence number of a segment\n    SEG.SEQ+SEG.LEN-1 = last sequence\
    \ number of a segment\n  A new acknowledgment (called an \"acceptable ack\"),\
    \ is one for which\n  the inequality below holds:\n    SND.UNA < SEG.ACK =< SND.NXT\n\
    \  All arithmetic is modulo 2**32 and that comparisons are unsigned.\n  \"=<\"\
    \ means \"less than or equal\".\n  A segment on the retransmission queue is fully\
    \ acknowledged if the sum\n  of its sequence number and length is less than the\
    \ acknowledgment\n  value in the incoming segment.\n  SEG.LEN is the number of\
    \ octets occupied by the data in the segment.\n  It is important to note that\
    \ SEG.LEN must be non-zero; segments which\n  do not occupy any sequence space\
    \ (e.g., empty acknowledgment segments)\n  are never placed on the retransmission\
    \ queue, so would not go through\n  this particular test.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n  On receive connections the following comparisons\
    \ are needed:\n    older sequence numbers                        newer sequence\
    \ numbers\n                RCV.NXT                         RCV.NXT+RCV.WND \n\
    \                   |                               |            \n       ---------XXX|XXX------XXXXXXXXXX---------XXX|XX---------\
    \ \n                |  |         |                  |  |            \n       \
    \         |            |                  |               \n             Segment\
    \ 1    Segment 2          Segment 3          \n                      <----- sequence\
    \ space ----->\n                  Receiving Sequence Space Information\n     \
    \                           Figure 8.\n    RCV.NXT = next sequence number expected\
    \ on incoming segments\n    RCV.NXT+RCV.WND = last sequence number expected on\
    \ incoming\n        segments, plus one\n    SEG.SEQ = first sequence number occupied\
    \ by the incoming segment\n    SEG.SEQ+SEG.LEN-1 = last sequence number occupied\
    \ by the incoming\n        segment\n  A segment is judged to occupy a portion\
    \ of valid receive sequence\n  space if\n     0 =< (SEG.SEQ+SEG.LEN-1 - RCV.NXT)\
    \ < (RCV.NXT+RCV.WND - RCV.NXT)\n  SEG.SEQ+SEG.LEN-1 is the last sequence number\
    \ occupied by the segment;\n  RCV.NXT is the next sequence number expected on\
    \ an incoming segment;\n  and RCV.NXT+RCV.WND is the right edge of the receive\
    \ window.\n  Actually, it is a little more complicated than this.  Due to zero\n\
    \  windows and zero length segments, we have four cases for the\n  acceptability\
    \ of an incoming segment:\n                                           Transmission\
    \ Control Protocol\n                                                Functional\
    \ Specification\n    Segment Receive  Test\n    Length  Window\n    ------- -------\
    \  -------------------------------------------\n       0       0     SEG.SEQ =\
    \ RCV.NXT\n       0      >0     RCV.NXT =< SEG.SEQ < RCV.NXT+RCV.WND\n      >0\
    \       0     not acceptable\n      >0      >0     RCV.NXT < SEG.SEQ+SEG.LEN =<\
    \ RCV.NXT+RCV.WND\n  Note that the acceptance test for a segment, since it requires\
    \ the end\n  of a segment to lie in the window, is somewhat more restrictive than\n\
    \  is absolutely necessary.  If at least the first sequence number of the\n  segment\
    \ lies in the receive window, or if some part of the segment\n  lies in the receive\
    \ window, then the segment might be judged\n  acceptable.  Thus, in figure 8,\
    \ at least segments 1 and 2 are\n  acceptable by the strict rule, and segment\
    \ 3 may or may not be,\n  depending on the strictness of interpretation of the\
    \ rule.\n  Note that when the receive window is zero no segments should be\n \
    \ acceptable except ACK segments.  Thus, it should be possible for a TCP\n  to\
    \ maintain a zero receive window while transmitting data and\n  receiving ACKs.\n\
    \  We have taken advantage of the numbering scheme to protect certain\n  control\
    \ information as well.  This is achieved by implicitly including\n  some control\
    \ flags in the sequence space so they can be retransmitted\n  and acknowledged\
    \ without confusion (i.e., one and only one copy of the\n  control will be acted\
    \ upon).  Control information is not physically\n  carried in the segment data\
    \ space.  Consequently, we must adopt rules\n  for implicitly assigning sequence\
    \ numbers to control.  The SYN and FIN\n  are the only controls requiring this\
    \ protection, and these controls\n  are used only at connection opening and closing.\
    \  For sequence number\n  purposes, the SYN is considered to occur before the\
    \ first actual data\n  octet of the segment in which it occurs, while the FIN\
    \ is considered\n  to occur after the last actual data octet in a segment in which\
    \ it\n  occurs.  The segment length includes both data and sequence space\n  occupying\
    \ controls.  When a SYN is present then SEG.SEQ is the\n  sequence number of the\
    \ SYN.\n  Initial Sequence Number Selection\n  The protocol places no restriction\
    \ on a particular connection being\n  used over and over again.  A connection\
    \ is defined by a pair of\n  sockets.  New instances of a connection will be referred\
    \ to as\n  incarnations of the connection.  The problem that arises owing to this\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n  is -- \"how does the TCP identify duplicate segments\
    \ from previous\n  incarnations of the connection?\"  This problem becomes apparent\
    \ if the\n  connection is being opened and closed in quick succession, or if the\n\
    \  connection breaks with loss of memory and is then reestablished.\n  To avoid\
    \ confusion we must prevent segments from one incarnation of a\n  connection from\
    \ being used while the same sequence numbers may still\n  be present in the network\
    \ from an earlier incarnation.  We want to\n  assure this, even if a TCP crashes\
    \ and loses all knowledge of the\n  sequence numbers it has been using.  When\
    \ new connections are created,\n  an initial sequence number (ISN) generator is\
    \ employed which selects a\n  new 32 bit ISN.  The generator is bound to a (possibly\
    \ fictitious) 32\n  bit clock whose low order bit is incremented roughly every\
    \ 4\n  microseconds.  Thus, the ISN cycles approximately every 4.55 hours.\n \
    \ Since we assume that segments will stay in the network no more than\n  tens\
    \ of seconds or minutes, at worst, we can reasonably assume that\n  ISN's will\
    \ be unique.\n  For each connection there is a send sequence number and a receive\n\
    \  sequence number.  The initial send sequence number (ISS) is chosen by\n  the\
    \ data sending TCP, and the initial receive sequence number (IRS) is\n  learned\
    \ during the connection establishing procedure.\n  For a connection to be established\
    \ or initialized, the two TCPs must\n  synchronize on each other's initial sequence\
    \ numbers.  This is done in\n  an exchange of connection establishing messages\
    \ carrying a control bit\n  called \"SYN\" (for synchronize) and the initial sequence\
    \ numbers.  As a\n  shorthand, messages carrying the SYN bit are also called \"\
    SYNs\".\n  Hence, the solution requires a suitable mechanism for picking an\n\
    \  initial sequence number and a slightly involved handshake to exchange\n  the\
    \ ISN's.  A \"three way handshake\" is necessary because sequence\n  numbers are\
    \ not tied to a global clock in the network, and TCPs may\n  have different mechanisms\
    \ for picking the ISN's.  The receiver of the\n  first SYN has no way of knowing\
    \ whether the segment was an old delayed\n  one or not, unless it remembers the\
    \ last sequence number used on the\n  connection (which is not always possible),\
    \ and so it must ask the\n  sender to verify this SYN.\n  The \"three way handshake\"\
    \ and the advantages of a \"clock-driven\"\n  scheme are discussed in [4].\n \
    \ Knowing When to Keep Quiet\n  To be sure that a TCP does not create a segment\
    \ that carries a\n  sequence number which may be duplicated by an old segment\
    \ remaining in\n  the network, the TCP must keep quiet for a maximum segment lifetime\n\
    \  (MSL) before assigning any sequence numbers upon starting up or\n  recovering\
    \ from a crash in which memory of sequence numbers in use was\n              \
    \                             Transmission Control Protocol\n                \
    \                                Functional Specification\n  lost.  For this specification\
    \ the MSL is taken to be 2 minutes.  This\n  is an engineering choice, and may\
    \ be changed if experience indicates\n  it is desirable to do so.  Note that if\
    \ a TCP is reinitialized in some\n  sense, yet retains its memory of sequence\
    \ numbers in use, then it need\n  not wait at all; it must only be sure to use\
    \ sequence numbers larger\n  than those recently used.\n  It should be noted that\
    \ this strategy does not protect against\n  spoofing or other replay type duplicate\
    \ message problems.\n"
- title: 3.4.  Establishing a connection
  contents:
  - "3.4.  Establishing a connection\n  The \"three-way handshake\" is the procedure\
    \ used to establish a\n  connection.  This procedure normally is initiated by\
    \ one TCP and\n  responded to by another TCP.  The procedure also works if two\
    \ TCP\n  simultaneously initiate the procedure.  When simultaneous attempt\n \
    \ occurs, the TCP receives a \"SYN\" segment which carries no\n  acknowledgment\
    \ after it has sent a \"SYN\".  Of course, the arrival of\n  an old duplicate\
    \ \"SYN\" segment can potentially make it appear, to the\n  recipient, that a\
    \ simultaneous connection initiation is in progress.\n  Proper use of \"reset\"\
    \ segments can disambiguate these cases.  Several\n  examples of connection initiation\
    \ follow.  Although these examples do\n  not show connection synchronization using\
    \ data-carrying segments, this\n  is perfectly legitimate, so long as the receiving\
    \ TCP doesn't deliver\n  the data to the user until it is clear the data is valid\
    \ (i.e., the\n  data must be buffered at the receiver until the connection reaches\
    \ the\n  ESTABLISHED state).  The three-way handshake reduces the possibility\n\
    \  of false connections.  It is the implementation of a trade-off between\n  memory\
    \ and messages to provide information for this checking.\n  The simplest three-way\
    \ handshake is shown in figure 9 below.  The\n  figures should be interpreted\
    \ in the following way.  Each line is\n  numbered for reference purposes.  Right\
    \ arrows (-->) indicate\n  departure of a TCP segment from TCP A to TCP B, or\
    \ arrival of a\n  segment at B from A.  Left arrows (<--), indicate the reverse.\n\
    \  Ellipsis (...) indicates a segment which is still in the network\n  (delayed).\
    \  An \"XXX\" indicates a segment which is lost or rejected.\n  Comments appear\
    \ in parentheses.  TCP states represent the state AFTER\n  the departure or arrival\
    \ of the segment (whose contents are shown in\n  the center of each line).  Segment\
    \ contents are shown in abbreviated\n  form, with sequence number, control flags,\
    \ and ACK field.  Other\n  fields such as window, addresses, lengths, and text\
    \ have been left out\n  in the interest of clarity.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n      TCP A                                       \
    \         TCP B\n  1.  CLOSED                                               LISTEN\n\
    \  2.  SYN-SENT    --> <SEQ=100><CTL=SYN>               --> SYN-RECEIVED\n  3.\
    \  ESTABLISHED <-- <SEQ=300><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED\n  4.  ESTABLISHED\
    \ --> <SEQ=101><ACK=301><CTL=ACK>       --> ESTABLISHED\n  5.  ESTABLISHED -->\
    \ <SEQ=101><ACK=301><CTL=ACK><DATA> --> ESTABLISHED\n          Basic 3-Way Handshake\
    \ for Connection Synchronization\n                                Figure 9.\n\
    \  In line 2 of figure 9, TCP A begins by sending a SYN segment\n  indicating\
    \ that it will use sequence numbers starting with sequence\n  number 100.  In\
    \ line 3, TCP B sends a SYN and acknowledges the SYN it\n  received from TCP A.\
    \  Note that the acknowledgment field indicates TCP\n  B is now expecting to hear\
    \ sequence 101, acknowledging the SYN which\n  occupied sequence 100.\n  At line\
    \ 4, TCP A responds with an empty segment containing an ACK for\n  TCP B's SYN;\
    \ and in line 5, TCP A sends some data.  Note that the\n  sequence number of the\
    \ segment in line 5 is the same as in line 4\n  because the ACK does not occupy\
    \ sequence number space (if it did, we\n  would wind up ACKing ACK's!).\n  Simultaneous\
    \ initiation is only slightly more complex, as is shown in\n  figure 10.  Each\
    \ TCP cycles from CLOSED to SYN-SENT to SYN-RECEIVED to\n  ESTABLISHED.\n  The\
    \ principle reason for the three-way handshake is to prevent old\n  duplicate\
    \ connection initiations from causing confusion.  To deal with\n  this, a special\
    \ control message, reset, has been devised.  If the\n  receiving TCP is in a \
    \ non-synchronized state (i.e., SYN-SENT,\n  SYN-RECEIVED), it returns to LISTEN\
    \ on receiving an acceptable reset.\n  If the TCP is in one of the synchronized\
    \ states (ESTABLISHED,\n  FIN-WAIT-1, FIN-WAIT-2, TIME-WAIT, CLOSE-WAIT, CLOSING),\
    \ it aborts the\n  connection and informs its user.  We discuss this latter case\
    \ under\n  \"half-open\" connections below.\n                                \
    \           Transmission Control Protocol\n                                  \
    \              Functional Specification\n      TCP A                         \
    \               TCP B\n  1.  CLOSED                                       CLOSED\n\
    \  2.  SYN-SENT     --> <SEQ=100><CTL=SYN>          ...\n  3.  SYN-RECEIVED <--\
    \ <SEQ=300><CTL=SYN>          <-- SYN-SENT\n  4.               ... <SEQ=100><CTL=SYN>\
    \          --> SYN-RECEIVED\n  5.  SYN-RECEIVED --> <SEQ=101><ACK=301><CTL=ACK>\
    \ ...\n  6.  ESTABLISHED  <-- <SEQ=301><ACK=101><CTL=ACK> <-- SYN-RECEIVED\n \
    \ 7.               ... <SEQ=101><ACK=301><CTL=ACK> --> ESTABLISHED\n         \
    \       Simultaneous Connection Synchronization\n                            \
    \   Figure 10.\n      TCP A                                                TCP\
    \ B\n  1.  CLOSED                                               LISTEN\n  2. \
    \ SYN-SENT    --> <SEQ=100><CTL=SYN>               ...\n  3.  (duplicate) ...\
    \ <SEQ=1000><CTL=SYN>              --> SYN-RECEIVED\n  4.  SYN-SENT    <-- <SEQ=300><ACK=1001><CTL=SYN,ACK>\
    \ <-- SYN-RECEIVED\n  5.  SYN-SENT    --> <SEQ=1001><CTL=RST>              -->\
    \ LISTEN\n  6.              ... <SEQ=100><CTL=SYN>               --> SYN-RECEIVED\n\
    \  7.  SYN-SENT    <-- <SEQ=400><ACK=101><CTL=SYN,ACK>  <-- SYN-RECEIVED\n  8.\
    \  ESTABLISHED --> <SEQ=101><ACK=401><CTL=ACK>      --> ESTABLISHED\n        \
    \            Recovery from Old Duplicate SYN\n                               Figure\
    \ 11.\n  As a simple example of recovery from old duplicates, consider\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n  figure 11.  At line 3, an old duplicate SYN arrives\
    \ at TCP B.  TCP B\n  cannot tell that this is an old duplicate, so it responds\
    \ normally\n  (line 4).  TCP A detects that the ACK field is incorrect and returns\
    \ a\n  RST (reset) with its SEQ field selected to make the segment\n  believable.\
    \  TCP B, on receiving the RST, returns to the LISTEN state.\n  When the original\
    \ SYN (pun intended) finally arrives at line 6, the\n  synchronization proceeds\
    \ normally.  If the SYN at line 6 had arrived\n  before the RST, a more complex\
    \ exchange might have occurred with RST's\n  sent in both directions.\n  Half-Open\
    \ Connections and Other Anomalies\n  An established connection is said to be \
    \ \"half-open\" if one of the\n  TCPs has closed or aborted the connection at\
    \ its end without the\n  knowledge of the other, or if the two ends of the connection\
    \ have\n  become desynchronized owing to a crash that resulted in loss of\n  memory.\
    \  Such connections will automatically become reset if an\n  attempt is made to\
    \ send data in either direction.  However, half-open\n  connections are expected\
    \ to be unusual, and the recovery procedure is\n  mildly involved.\n  If at site\
    \ A the connection no longer exists, then an attempt by the\n  user at site B\
    \ to send any data on it will result in the site B TCP\n  receiving a reset control\
    \ message.  Such a message should indicate to\n  the site B TCP that something\
    \ is wrong, and it is expected to abort\n  the connection.\n  Assume that two\
    \ user processes A and B are communicating with one\n  another when a crash occurs\
    \ causing loss of memory to A's TCP.\n  Depending on the operating system supporting\
    \ A's TCP, it is likely\n  that some error recovery mechanism exists.  When the\
    \ TCP is up again,\n  A is likely to start again from the beginning or from a\
    \ recovery\n  point.  As a result, A will probably try to OPEN the connection\
    \ again\n  or try to SEND on the connection it believes open.  In the latter\n\
    \  case, it receives the error message \"connection not open\" from the\n  local\
    \ (A's) TCP.  In an attempt to establish the connection, A's TCP\n  will send\
    \ a segment containing SYN.  This scenario leads to the\n  example shown in figure\
    \ 12.  After TCP A crashes, the user attempts to\n  re-open the connection.  TCP\
    \ B, in the meantime, thinks the connection\n  is open.\n                    \
    \                       Transmission Control Protocol\n                      \
    \                          Functional Specification\n      TCP A             \
    \                              TCP B\n  1.  (CRASH)                          \
    \     (send 300,receive 100)\n  2.  CLOSED                                   \
    \        ESTABLISHED\n  3.  SYN-SENT --> <SEQ=400><CTL=SYN>              --> (??)\n\
    \  4.  (!!)     <-- <SEQ=300><ACK=100><CTL=ACK>     <-- ESTABLISHED\n  5.  SYN-SENT\
    \ --> <SEQ=100><CTL=RST>              --> (Abort!!)\n  6.                    \
    \                               CLOSED\n  7.  SYN-SENT --> <SEQ=400><CTL=SYN>\
    \              -->\n                     Half-Open Connection Discovery\n    \
    \                           Figure 12.\n  When the SYN arrives at line 3, TCP\
    \ B, being in a synchronized state,\n  responds with an acknowledgment indicating\
    \ what sequence it next\n  expects to hear (ACK 100).  TCP A sees that this segment\
    \ does not\n  acknowledge anything it sent and, being unsynchronized, sends a\
    \ reset\n  (RST) because it has detected a half-open connection.  TCP B aborts\
    \ at\n  line 5.  TCP A will continue to try to establish the connection; the\n\
    \  problem is now reduced to the basic 3-way handshake of figure 9.\n  An interesting\
    \ alternative case occurs when TCP A crashes and TCP B\n  tries to send data on\
    \ what it thinks is a synchronized connection.\n  This is illustrated in figure\
    \ 13.  In this case, the data arriving at\n  TCP A from TCP B (line 2) is unacceptable\
    \ because no such connection\n  exists, so TCP A sends a RST.  The RST is acceptable\
    \ so TCP B\n  processes it and aborts the connection.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n        TCP A                                     \
    \         TCP B\n  1.  (CRASH)                                   (send 300,receive\
    \ 100)\n  2.  (??)    <-- <SEQ=300><ACK=100><DATA=10><CTL=ACK> <-- ESTABLISHED\n\
    \  3.          --> <SEQ=100><CTL=RST>                   --> (ABORT!!)\n      \
    \     Active Side Causes Half-Open Connection Discovery\n                    \
    \           Figure 13.\n  In figure 14, we find the two TCPs A and B with passive\
    \ connections\n  waiting for SYN.  An old duplicate arriving at TCP B (line 2)\
    \ stirs B\n  into action.  A SYN-ACK is returned (line 3) and causes TCP A to\n\
    \  generate a RST (the ACK in line 3 is not acceptable).  TCP B accepts\n  the\
    \ reset and returns to its passive LISTEN state.\n      TCP A                \
    \                         TCP B\n  1.  LISTEN                                \
    \        LISTEN\n  2.       ... <SEQ=Z><CTL=SYN>                -->  SYN-RECEIVED\n\
    \  3.  (??) <-- <SEQ=X><ACK=Z+1><CTL=SYN,ACK>   <--  SYN-RECEIVED\n  4.      \
    \ --> <SEQ=Z+1><CTL=RST>              -->  (return to LISTEN!)\n  5.  LISTEN \
    \                                       LISTEN\n       Old Duplicate SYN Initiates\
    \ a Reset on two Passive Sockets\n                               Figure 14.\n\
    \  A variety of other cases are possible, all of which are accounted for\n  by\
    \ the following rules for RST generation and processing.\n  Reset Generation\n\
    \  As a general rule, reset (RST) should be sent whenever a segment\n  arrives\
    \ which apparently is not intended for the current or a future\n  incarnation\
    \ of the connection.  A reset should not be sent if it is\n  not clear that this\
    \ is the case.  Thus, if any segment arrives for a\n  nonexistent connection,\
    \ a reset should be sent.  If a segment ACKs\n                               \
    \            Transmission Control Protocol\n                                 \
    \               Functional Specification\n  something which has never been sent\
    \ on the current connection, then\n  one of the following two cases applies.\n\
    \  1.  If the connection is in any non-synchronized state (LISTEN,\n  SYN-SENT,\
    \ SYN-RECEIVED) or if the connection does not exist, a reset\n  (RST) should be\
    \ formed and sent for any segment that acknowledges\n  something not yet sent.\
    \  The RST should take its SEQ field from the\n  ACK field of the offending segment\
    \ (if the ACK control bit was set),\n  and its ACK bit should be reset (zero),\
    \ except to refuse a initial\n  SYN.  A reset is also sent if an incoming segment\
    \ has a security level\n  or compartment which does not exactly match the level\
    \ and compartment\n  requested for the connection.  If the precedence of the incoming\n\
    \  segment is less than the precedence level requested a reset is sent.\n  2.\
    \  If the connection is in a synchronized state (ESTABLISHED,\n  FIN-WAIT-1, FIN-WAIT-2,\
    \ TIME-WAIT, CLOSE-WAIT, CLOSING), any\n  unacceptable segment should elicit only\
    \ an empty acknowledgment\n  segment containing the current send-sequence number\
    \ and an\n  acknowledgment indicating the next sequence number expected to be\n\
    \  received.\n  Reset Processing\n  All reset (RST) segments are validated by\
    \ checking their SEQ-fields.\n  A reset is valid if its sequence number is in\
    \ the window.  In the case\n  of a RST received in response to an initial SYN\
    \ any sequence number is\n  acceptable if the ACK field acknowledges the SYN.\n\
    \  The receiver of a RST first validates it, then changes state.  If the\n  receiver\
    \ was in the LISTEN state, it ignores it.  If the receiver was\n  in SYN-RECEIVED\
    \ state and had previously been in the LISTEN state,\n  then the receiver returns\
    \ to the LISTEN state, otherwise the receiver\n  aborts the connection and goes\
    \ to the CLOSED state.  If the receiver\n  was in any other state, it aborts the\
    \ connection and advises the user\n  and goes to the CLOSED state.\n"
- title: 3.5.  Closing a Connection
  contents:
  - "3.5.  Closing a Connection\n  CLOSE is an operation meaning \"I have no more\
    \ data to send.\"  The\n  notion of closing a full-duplex connection is subject\
    \ to ambiguous\n  interpretation, of course, since it may not be obvious how to\
    \ treat\n  the receiving side of the connection.  We have chosen to treat CLOSE\n\
    \  in a simplex fashion.  The user who CLOSEs may continue to RECEIVE\n  until\
    \ he is told that the other side has CLOSED also.  Thus, a program\n  could initiate\
    \ several SENDs followed by a CLOSE, and then continue to\n  RECEIVE until signaled\
    \ that a RECEIVE failed because the other side\n  has CLOSED.  We assume that\
    \ the TCP will signal a user, even if no\n  RECEIVEs are outstanding, that the\
    \ other side has closed, so the user\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n  can terminate his side gracefully.  A TCP will reliably\
    \ deliver all\n  buffers SENT before the connection was CLOSED so a user who expects\
    \ no\n  data in return need only wait to hear the connection was CLOSED\n  successfully\
    \ to know that all his data was received at the destination\n  TCP.\n  There are\
    \ essentially three cases:\n    1) The user initiates by telling the TCP to CLOSE\
    \ the connection\n    2) The remote TCP initiates by sending a FIN control signal\n\
    \    3) Both users CLOSE simultaneously\n  Case 1:  Local user initiates the close\n\
    \    In this case, a FIN segment can be constructed and placed on the\n    outgoing\
    \ segment queue.  No further SENDs from the user will be\n    accepted by the\
    \ TCP, and it enters the FIN-WAIT-1 state.  RECEIVEs\n    are allowed in this\
    \ state.  All segments preceding and including FIN\n    will be retransmitted\
    \ until acknowledged.  When the other TCP has\n    both acknowledged the FIN and\
    \ sent a FIN of its own, the first TCP\n    can ACK this FIN.  It should be noted\
    \ that a TCP receiving a FIN\n    will ACK but not send its own FIN until its\
    \ user has CLOSED the\n    connection also.\n  Case 2:  TCP receives a FIN from\
    \ the network\n    If an unsolicited FIN arrives from the network, the receiving\
    \ TCP\n    can ACK it and tell the user that the connection is closing.  The\n\
    \    user should respond with a CLOSE, upon which the TCP can send a FIN\n   \
    \ to the other TCP.  The TCP then waits until its own FIN is\n    acknowledged\
    \ whereupon it deletes the connection.  If an ACK is not\n    forthcoming, after\
    \ a timeout the connection is aborted and the user\n    is told.\n  Case 3:  both\
    \ users close simultaneously\n    A simultaneous CLOSE by users at both ends of\
    \ a connection causes\n    FIN segments to be exchanged.  When all segments preceding\
    \ the FINs\n    have been processed and acknowledged, each TCP can ACK the FIN\
    \ it\n    has received.  Both will, upon receiving these ACKs, delete the\n  \
    \  connection.\n                                           Transmission Control\
    \ Protocol\n                                                Functional Specification\n\
    \      TCP A                                                TCP B\n  1.  ESTABLISHED\
    \                                          ESTABLISHED\n  2.  (Close)\n      FIN-WAIT-1\
    \  --> <SEQ=100><CTL=FIN>               --> CLOSE-WAIT\n  3.  FIN-WAIT-2  <--\
    \ <SEQ=300><ACK=101><CTL=ACK>      <-- CLOSE-WAIT\n  4.                      \
    \                                 (Close)\n      TIME-WAIT   <-- <SEQ=301><CTL=FIN>\
    \               <-- CLOSING\n  5.  TIME-WAIT   --> <SEQ=100><ACK=301><CTL=ACK>\
    \      --> CLOSED\n  6.  (2 MSL)\n      CLOSED\n                         Normal\
    \ Close Sequence\n                               Figure 15.\n      TCP A     \
    \                                           TCP B\n  1.  ESTABLISHED         \
    \                                 ESTABLISHED\n  2.  (Close)                 \
    \                             (Close)\n      FIN-WAIT-1  --> <SEQ=100><CTL=FIN>\
    \               ... FIN-WAIT-1\n                  <-- <SEQ=300><CTL=FIN>     \
    \          <--\n                  ... <SEQ=100><CTL=FIN>               -->\n \
    \ 3.  CLOSING     --> <SEQ=100><ACK=301><CTL=ACK>      ... CLOSING\n         \
    \         <-- <SEQ=300><ACK=101><CTL=ACK>      <--\n                  ... <SEQ=100><ACK=301><CTL=ACK>\
    \      -->\n  4.  CLOSED                                               CLOSED\n\
    \                      Simultaneous Close Sequence\n                         \
    \      Figure 16.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - 'Functional Specification

    '
- title: 3.6.  Precedence and Security
  contents:
  - "3.6.  Precedence and Security\n  The intent is that connection be allowed only\
    \ between ports operating\n  with exactly the same security and compartment values\
    \ and at the\n  higher of the precedence level requested by the two parts.\n \
    \ The precedence levels are:\n    flash override - 111\n    flash          - 110\n\
    \    immediate      - 10X\n    priority       - 01X\n    routine        - 00X\n\
    \  The security levels are:\n    top secret    - 11\n    secret        - 10\n\
    \    confidential  - 01\n    unclassified  - 00\n  The compartments are assigned\
    \ by the Defense Communications Agency.\n  The defaults are precedence:  routine,\
    \ security:  unclassified,\n  compartment:  zero.  A host which does not implement\
    \ precedence or\n  security feature should clear these fields to zero for segments\
    \ it\n  sends.\n  A connection attempt with mismatched security/compartment values\
    \ or a\n  lower precedence value should be rejected by sending a reset.\n  Note\
    \ that TCP modules which operate only at the default value of\n  precedence will\
    \ still have to check the precedence of incoming\n  segments and possibly raise\
    \ the precedence level they use on the\n  connection.\n"
- title: 3.7.  Data Communication
  contents:
  - "3.7.  Data Communication\n  Once the connection is established data is communicated\
    \ by the\n  exchange of segments.  Because segments may be lost due to errors\n\
    \  (checksum test failure), or network congestion, TCP uses\n  retransmission\
    \ (after a timeout) to ensure delivery of every segment.\n  Duplicate segments\
    \ may arrive due to network or TCP retransmission.\n  As discussed in the section\
    \ on sequence numbers the TCP performs\n  certain tests on the sequence and acknowledgment\
    \ numbers in the\n  segments to verify their acceptability.\n  The sender of data\
    \ keeps track of the next sequence number to use in\n  the variable SND.NXT. \
    \ The receiver of data keeps track of the next\n                             \
    \              Transmission Control Protocol\n                               \
    \                 Functional Specification\n  sequence number to expect in the\
    \ variable RCV.NXT.  The sender of data\n  keeps track of the oldest unacknowledged\
    \ sequence number in the\n  variable SND.UNA.  If the data flow is momentarily\
    \ idle and all data\n  sent has been acknowledged then the three variables will\
    \ be equal.\n  When the sender creates a segment and transmits it the sender advances\n\
    \  SND.NXT.  When the receiver accepts a segment it advances RCV.NXT and\n  sends\
    \ an acknowledgment.  When the data sender receives an\n  acknowledgment it advances\
    \ SND.UNA.  The extent to which the values of\n  these variables differ is a measure\
    \ of the delay in the communication.\n  Normally the amount by which the variables\
    \ are advanced is the length\n  of the data in the segment.  However, when letters\
    \ are used there are\n  special provisions for coordination the sequence numbers,\
    \ the letter\n  boundaries, and the receive buffer boundaries.\n  End of Letter\
    \ Sequence Number Adjustments\n  There is provision in TCP for the receiver of\
    \ data to optionally\n  communicate to the sender of data on a connection at the\
    \ time of the\n  connection synchronization the receiver's buffer size.  If this\
    \ is\n  done the receiver must use this fixed size of buffers for the lifetime\n\
    \  of the connection.  If a buffer size is communicated then there is a\n  coordination\
    \ between receive buffers, letters, and sequence numbers.\n  Each time a buffer\
    \ is completed either due to being filled or due to\n  an end of letter, the sequence\
    \ number is incremented through the end\n  of that buffer.\n  That is, whenever\
    \ an EOL is transmitted, the sender advances its send\n  sequence number, SND.NXT,\
    \ by an amount sufficient to consume all the\n  unused space in the receiver's\
    \ buffer.  The amount of space consumed\n  in this fashion is subtracted from\
    \ the send window just as is the\n  space consumed by actual data.\n  And, whenever\
    \ an EOL is received, the receiver advances its receive\n  sequence number, RCV.NXT,\
    \ by an amount sufficient to consume all the\n  unused space in the receiver's\
    \ buffer.  The amount of space consumed\n  in this fashion is subtracted from\
    \ the receive window just as is the\n  space consumed by actual data.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n    older sequence numbers                        newer\
    \ sequence numbers\n            |           Buffer 1            |   Buffer 2 \
    \      \n            |                               |                  \n   \
    \     ----+-------------------------------+----------------- \n            XXXXXXXXXXXXXXXXXXXXX+++++++++++\
    \                   \n            |                    |          |          \
    \        \n            |<-----SEG.LEN------>|          |                  \n \
    \           |                    |          |                  \n            |\
    \                    |          |                  \n         SEG.SEQ        \
    \         A          B                  \n                    XXX - data octets\
    \ from segment \n                    +++ - phantom data             \n       \
    \               <----- sequence space ----->\n                        End of Letter\
    \ Adjustment\n                               Figure 17.\n  In the case illustrated\
    \ above, if the segment does not carry an EOL\n  flag, the next value of SND.NXT\
    \ or RCV.NXT will be A.  If it does\n  carry an EOL flag, the next value will\
    \ be B.\n  The exchange of buffer size and sequencing information is done in\n\
    \  units of octets.  If no buffer size is stated, then the buffer size is\n  assumed\
    \ to be 1 octet.  The receiver tells the sender the size of the\n  buffer in a\
    \ SYN segment that contains the 16 bit buffer size data in\n  an option field\
    \ in the TCP header.\n  Each EOL advances the sequence number (SN) to the next\
    \ buffer boundary\n    While LBB < SEG.SEQ+SEG.LEN\n    Do LBB <- LBB + BS End\n\
    \    SN <- LBB\n    where LBB is the Last Buffer Beginning, and BS is the buffer\
    \ size.\n  The CLOSE user call implies an end of letter, as does the FIN control\n\
    \  flag in an incoming segment.\n  The Communication of Urgent Information\n \
    \ The objective of the TCP urgent mechanism is to allow the sending user\n  to\
    \ stimulate the receiving user to accept some urgent data and to\n  permit the\
    \ receiving TCP to indicate to the receiving user when all\n  the currently known\
    \ urgent data has been received by the user.\n                               \
    \            Transmission Control Protocol\n                                 \
    \               Functional Specification\n  This mechanism permits a point in\
    \ the data stream to be designated as\n  the end of \"urgent\" information.  Whenever\
    \ this point is in advance of\n  the receive sequence number (RCV.NXT) at the\
    \ receiving TCP, that TCP\n  should tell the user to go into \"urgent mode\";\
    \ when the receive\n  sequence number catches up to the urgent pointer, the TCP\
    \ should tell\n  user to go into \"normal mode\".  If the urgent pointer is updated\
    \ while\n  the user is in \"read fast\" mode, the update will be invisible to\
    \ the\n  user.\n  The method employs a urgent field which is carried in all segments\n\
    \  transmitted.  The URG control flag indicates that the urgent field is\n  meaningful\
    \ and should be added to the segment sequence number to yield\n  the urgent pointer.\
    \  The absence of this flag indicates that the\n  urgent pointer has not changed.\n\
    \  To send an urgent indication the user must also send at least one data\n  octet.\
    \  If the sending user also indicates end of letter, timely\n  delivery of the\
    \ urgent information to the destination process is\n  enhanced.\n  Managing the\
    \ Window\n  The window sent in each segment indicates the range of sequence number\n\
    \  the sender of the window (the data receiver) is currently prepared to\n  accept.\
    \  There is an assumption that this is related to the currently\n  available data\
    \ buffer space available for this connection.  The window\n  information is a\
    \ guideline to be aimed at.\n  Indicating a large window encourages transmissions.\
    \  If more data\n  arrives than can be accepted, it will be discarded.  This will\
    \ result\n  in excessive retransmissions, adding unnecessarily to the load on\
    \ the\n  network and the TCPs.  Indicating a small window may restrict the\n \
    \ transmission of data to the point of introducing a round trip delay\n  between\
    \ each new segment transmitted.\n  The mechanisms provided allow a TCP to advertise\
    \ a large window and to\n  subsequently advertise a much smaller window without\
    \ having accepted\n  that much data.  This, so called \"shrinking the window,\"\
    \ is strongly\n  discouraged.  The robustness principle dictates that TCPs will\
    \ not\n  shrink the window themselves, but will be prepared for such behavior\n\
    \  on the part of other TCPs.\n  The sending TCP must be prepared to accept and\
    \ send at least one octet\n  of new data even if the send window is zero.  The\
    \ sending TCP should\n  regularly retransmit to the receiving TCP even when the\
    \ window is\n  zero.  Two minutes is recommended for the retransmission interval\
    \ when\n  the window is zero.  This retransmission is essential to guarantee\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n  that when either TCP has a zero window the re-opening\
    \ of the window\n  will be reliably reported to the other.\n  The sending TCP\
    \ packages the data to be transmitted into segments\n  which fit the current window,\
    \ and may repackage segments on the\n  retransmission queue.  Such repackaging\
    \ is not required, but may be\n  helpful.\n  Users must keep reading connections\
    \ they close for sending until the\n  TCP says no more data.\n  In a connection\
    \ with a one-way data flow, the window information will\n  be carried in acknowledgment\
    \ segments that all have the same sequence\n  number so there will be no way to\
    \ reorder them if they arrive out of\n  order.  This is not a serious problem,\
    \ but it will allow the window\n  information to be on occasion temporarily based\
    \ on old reports from\n  the data receiver.\n"
- title: 3.8.  Interfaces
  contents:
  - "3.8.  Interfaces\n  There are of course two interfaces of concern:  the user/TCP\
    \ interface\n  and the TCP/IP interface.  We have a fairly elaborate model of\
    \ the\n  user/TCP interface, but only a sketch of the interface to the lower\n\
    \  level protocol module.\n  User/TCP Interface\n    The functional description\
    \ of user commands to the TCP is, at best,\n    fictional, since every operating\
    \ system will have different\n    facilities.  Consequently, we must warn readers\
    \ that different TCP\n    implementations may have different user interfaces.\
    \  However, all\n    TCPs must provide a certain minimum set of services to guarantee\n\
    \    that all TCP implementations can support the same protocol\n    hierarchy.\
    \  This section specifies the functional interfaces\n    required of all TCP implementations.\n\
    \    TCP User Commands\n      The following sections functionally characterize\
    \ a USER/TCP\n      interface.  The notation used is similar to most procedure\
    \ or\n      function calls in high level languages, but this usage is not\n  \
    \    meant to rule out trap type service calls (e.g., SVCs, UUOs,\n      EMTs).\n\
    \      The user commands described below specify the basic functions the\n   \
    \   TCP must perform to support interprocess communication.\n      Individual\
    \ implementations should define their own exact format,\n      and may provide\
    \ combinations or subsets of the basic functions in\n                        \
    \                   Transmission Control Protocol\n                          \
    \                      Functional Specification\n      single calls.  In particular,\
    \ some implementations may wish to\n      automatically OPEN a connection on the\
    \ first SEND or RECEIVE\n      issued by the user for a given connection.\n  \
    \    In providing interprocess communication facilities, the TCP must\n      not\
    \ only accept commands, but must also return information to the\n      processes\
    \ it serves.  The latter consists of:\n        (a) general information about a\
    \ connection (e.g., interrupts,\n        remote close, binding of unspecified\
    \ foreign socket).\n        (b) replies to specific user commands indicating success\
    \ or\n        various types of failure.\n      Open\n        Format:  OPEN (local\
    \ port, foreign socket, active/passive\n        [, buffer size] [, timeout] [,\
    \ precedence]\n        [, security/compartment]) -> local connection name\n  \
    \      We assume that the local TCP is aware of the identity of the\n        processes\
    \ it serves and will check the authority of the process\n        to use the connection\
    \ specified.  Depending upon the\n        implementation of the TCP, the local\
    \ network and TCP identifiers\n        for the source address will either be supplied\
    \ by the TCP or by\n        the processes that serve it (e.g., the program which\
    \ interfaces\n        the TCP network).  These considerations are the result of\n\
    \        concern about security, to the extent that no TCP be able to\n      \
    \  masquerade as another one, and so on.  Similarly, no process can\n        masquerade\
    \ as another without the collusion of the TCP.\n        If the active/passive\
    \ flag is set to passive, then this is a\n        call to LISTEN for an incoming\
    \ connection.  A passive open may\n        have either a fully specified foreign\
    \ socket to wait for a\n        particular connection or an unspecified foreign\
    \ socket to wait\n        for any call.  A fully specified passive call can be\
    \ made active\n        by the subsequent execution of a SEND.\n        A full-duplex\
    \ transmission control block (TCB) is created and\n        partially filled in\
    \ with data from the OPEN command parameters.\n        On an active OPEN command,\
    \ the TCP will begin the procedure to\n        synchronize (i.e., establish) the\
    \ connection at once.\n        The buffer size, if present, indicates that the\
    \ caller will\n        always receive data from the connection in that size of\
    \ buffers.\n        This buffer size is a measure of the buffer between the user\
    \ and\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n        the local TCP.  The buffer size between the\
    \ two TCPs may be\n        different.\n        The timeout, if present, permits\
    \ the caller to set up a timeout\n        for all buffers transmitted on the connection.\
    \  If a buffer is\n        not successfully delivered to the destination within\
    \ the timeout\n        period, the TCP will abort the connection.  The present\
    \ global\n        default is 30 seconds.  The buffer retransmission rate may vary;\n\
    \        most likely, it will be related to the measured time for\n        responses\
    \ from the remote TCP.\n        The TCP or some component of the operating system\
    \ will verify\n        the users authority to open a connection with the specified\n\
    \        precedence or security/compartment.  The absence of precedence\n    \
    \    or security/compartment specification in the OPEN call indicates\n      \
    \  the default values should be used.\n        TCP will accept incoming requests\
    \ as matching only if the\n        security/compartment information is exactly\
    \ the same and only if\n        the precedence is equal to or higher than the\
    \ precedence\n        requested in the OPEN call.\n        The precedence for\
    \ the connection is the higher of the values\n        requested in the OPEN call\
    \ and received from the incoming\n        request, and fixed at that value for\
    \ the life of the connection.\n        Depending on the TCP implementation, either\
    \ a local connection\n        name will be returned to the user by the TCP, or\
    \ the user will\n        specify this local connection name (in which case another\n\
    \        parameter is needed in the call).  The local connection name can\n  \
    \      then be used as a short hand term for the connection defined by\n     \
    \   the <local socket, foreign socket> pair.\n      Send\n        Format:  SEND(local\
    \ connection name, buffer address, byte count,\n        EOL flag, URGENT flag\
    \ [, timeout])\n        This call causes the data contained in the indicated user\
    \ buffer\n        to be sent on the indicated connection.  If the connection has\n\
    \        not been opened, the SEND is considered an error.  Some\n        implementations\
    \ may allow users to SEND first; in which case, an\n        automatic OPEN would\
    \ be done.  If the calling process is not\n        authorized to use this connection,\
    \ an error is returned.\n        If the EOL flag is set, the data is the End Of\
    \ a Letter, and the\n        EOL bit will be set in the last TCP segment created\
    \ from the\n                                           Transmission Control Protocol\n\
    \                                                Functional Specification\n  \
    \      buffer.  If the EOL flag is not set, subsequent SENDs will\n        appear\
    \ to be part of the same letter.\n        If the URGENT flag is set, segments\
    \ resulting from this call\n        will have the urgent pointer set to indicate\
    \ that some of the\n        data associated with this call is urgent.  This facility,\
    \ for\n        example, can be used to simulate \"break\" signals from terminals\n\
    \        or error or completion codes from I/O devices.  The semantics of\n  \
    \      this signal to the receiving process are unspecified.  The\n        receiving\
    \ TCP will signal the urgent condition to the receiving\n        process as long\
    \ as the urgent pointer indicates that data\n        preceding the urgent pointer\
    \ has not been consumed by the\n        receiving process.  The purpose of urgent\
    \ is to stimulate the\n        receiver to accept some urgent data and to indicate\
    \ to the\n        receiver when all the currently known urgent data has been\n\
    \        received.\n        The number of times the sending user's TCP signals\
    \ urgent will\n        not necessarily be equal to the number of times the receiving\n\
    \        user will be notified of the presence of urgent data.\n        If no\
    \ foreign socket was specified in the OPEN, but the\n        connection is established\
    \ (e.g., because a LISTENing connection\n        has become specific due to a\
    \ foreign segment arriving for the\n        local socket), then the designated\
    \ buffer is sent to the implied\n        foreign socket.  In general, users who\
    \ make use of OPEN with an\n        unspecified foreign socket can make use of\
    \ SEND without ever\n        explicitly knowing the foreign socket address.\n\
    \        However, if a SEND is attempted before the foreign socket\n        becomes\
    \ specified, an error will be returned.  Users can use the\n        STATUS call\
    \ to determine the status of the connection.  In some\n        implementations\
    \ the TCP may notify the user when an unspecified\n        socket is bound.\n\
    \        If a timeout is specified, then the current timeout for this\n      \
    \  connection is changed to the new one.\n        In the simplest implementation,\
    \ SEND would not return control to\n        the sending process until either the\
    \ transmission was complete\n        or the timeout had been exceeded.  However,\
    \ this simple method\n        is both subject to deadlocks (for example, both\
    \ sides of the\n        connection might try to do SENDs before doing any RECEIVEs)\
    \ and\n        offers poor performance, so it is not recommended.  A more\n  \
    \      sophisticated implementation would return immediately to allow\n      \
    \  the process to run concurrently with network I/O, and,\n        furthermore,\
    \ to allow multiple SENDs to be in progress.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n        Multiple SENDs are served in first come, first\
    \ served order, so\n        the TCP will queue those it cannot service immediately.\n\
    \        We have implicitly assumed an asynchronous user interface in\n      \
    \  which a SEND later elicits some kind of SIGNAL or\n        pseudo-interrupt\
    \ from the serving TCP.  An alternative is to\n        return a response immediately.\
    \  For instance, SENDs might return\n        immediate local acknowledgment, even\
    \ if the segment sent had not\n        been acknowledged by the distant TCP. \
    \ We could optimistically\n        assume eventual success.  If we are wrong,\
    \ the connection will\n        close anyway due to the timeout.  In implementations\
    \ of this\n        kind (synchronous), there will still be some asynchronous\n\
    \        signals, but these will deal with the connection itself, and not\n  \
    \      with specific segments or letters.\n        NOTA BENE: In order for the\
    \ process to distinguish among error\n        or success indications for different\
    \ SENDs, it might be\n        appropriate for the buffer address to be returned\
    \ along with the\n        coded response to the SEND request.  TCP-to-user signals\
    \ are\n        discussed below, indicating the information which should be\n \
    \       returned to the calling process.\n      Receive\n        Format:  RECEIVE\
    \ (local connection name, buffer address, byte\n        count)\n        This command\
    \ allocates a receiving buffer associated with the\n        specified connection.\
    \  If no OPEN precedes this command or the\n        calling process is not authorized\
    \ to use this connection, an\n        error is returned.\n        In the simplest\
    \ implementation, control would not return to the\n        calling program until\
    \ either the buffer was filled, or some\n        error occurred, but this scheme\
    \ is highly subject to deadlocks.\n        A more sophisticated implementation\
    \ would permit several\n        RECEIVEs to be outstanding at once.  These would\
    \ be filled as,\n        segments arrive.  This strategy permits increased throughput\
    \ at\n        the cost of a more elaborate scheme (possibly asynchronous) to\n\
    \        notify the calling program that a letter has been received or a\n   \
    \     buffer filled.\n        If insufficient buffer space is given to reassemble\
    \ a complete\n        letter, the EOL flag will not be set in the response to\
    \ the\n        RECEIVE.  The buffer will be filled with as much data as it can\n\
    \        hold.  The last buffer required to hold the letter is returned\n    \
    \    with EOL signaled.\n                                           Transmission\
    \ Control Protocol\n                                                Functional\
    \ Specification\n        The remaining parts of a partly delivered letter will\
    \ be placed\n        in buffers as they are made available via successive RECEIVEs.\n\
    \        If a number of RECEIVEs are outstanding, they may be filled with\n  \
    \      parts of a single long letter or with at most one letter each.\n      \
    \  The return codes associated with each RECEIVE will indicate what\n        is\
    \ contained in the buffer.\n        If a buffer size was given in the OPEN call,\
    \ then all buffers\n        presented in RECEIVE calls must be of exactly that\
    \ size, or an\n        error indication will be returned.\n        The URGENT\
    \ flag will be set only if the receiving user has\n        previously been informed\
    \ via a TCP-to-user signal, that urgent\n        data is waiting.  The receiving\
    \ user should thus be in\n        \"read-fast\" mode.  If the URGENT flag is on,\
    \ additional urgent\n        data remains.  If the URGENT flag is off, this call\
    \ to RECEIVE\n        has returned all the urgent data, and the user may now leave\n\
    \        \"read-fast\" mode.\n        To distinguish among several outstanding\
    \ RECEIVEs and to take\n        care of the case that a letter is smaller than\
    \ the buffer\n        supplied, the return code is accompanied by both a buffer\n\
    \        pointer and a byte count indicating the actual length of the\n      \
    \  letter received.\n        Alternative implementations of RECEIVE might have\
    \ the TCP\n        allocate buffer storage, or the TCP might share a ring buffer\n\
    \        with the user.  Variations of this kind will produce obvious\n      \
    \  variation in user interface to the TCP.\n      Close\n        Format:  CLOSE(local\
    \ connection name)\n        This command causes the connection specified to be\
    \ closed.  If\n        the connection is not open or the calling process is not\n\
    \        authorized to use this connection, an error is returned.\n        Closing\
    \ connections is intended to be a graceful operation in\n        the sense that\
    \ outstanding SENDs will be transmitted (and\n        retransmitted), as flow\
    \ control permits, until all have been\n        serviced.  Thus, it should be\
    \ acceptable to make several SEND\n        calls, followed by a CLOSE, and expect\
    \ all the data to be sent\n        to the destination.  It should also be clear\
    \ that users should\n        continue to RECEIVE on CLOSING connections, since\
    \ the other side\n        may be trying to transmit the last of its data.  Thus,\
    \ CLOSE\n        means \"I have no more to send\" but does not mean \"I will not\n\
    \        receive any more.\"  It may happen (if the user level protocol is\n \
    \       not well thought out) that the closing side is unable to get rid\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n        of all its data before timing out.  In this\
    \ event, CLOSE turns\n        into ABORT, and the closing TCP gives up.\n    \
    \    The user may CLOSE the connection at any time on his own\n        initiative,\
    \ or in response to various prompts from the TCP\n        (e.g., remote close\
    \ executed, transmission timeout exceeded,\n        destination inaccessible).\n\
    \        Because closing a connection requires communication with the\n      \
    \  foreign TCP, connections may remain in the closing state for a\n        short\
    \ time.  Attempts to reopen the connection before the TCP\n        replies to\
    \ the CLOSE command will result in error responses.\n        Close also implies\
    \ end of letter.\n      Status\n        Format:  STATUS(local connection name)\n\
    \        This is an implementation dependent user command and could be\n     \
    \   excluded without adverse effect.  Information returned would\n        typically\
    \ come from the TCB associated with the connection.\n        This command returns\
    \ a data block containing the following\n        information:\n          local\
    \ socket,\n          foreign socket,\n          local connection name,\n     \
    \     receive window,\n          send window,\n          connection state,\n \
    \         number of buffers awaiting acknowledgment,\n          number of buffers\
    \ pending receipt (including partial ones),\n          receive buffer size,\n\
    \          urgent state,\n          precedence,\n          security/compartment,\n\
    \          and default transmission timeout.\n        Depending on the state of\
    \ the connection, or on the\n        implementation itself, some of this information\
    \ may not be\n        available or meaningful.  If the calling process is not\n\
    \        authorized to use this connection, an error is returned.  This\n    \
    \    prevents unauthorized processes from gaining information about a\n      \
    \  connection.\n                                           Transmission Control\
    \ Protocol\n                                                Functional Specification\n\
    \      Abort\n        Format:  ABORT (local connection name)\n        This command\
    \ causes all pending SENDs and RECEIVES to be\n        aborted, the TCB to be\
    \ removed, and a special RESET message to\n        be sent to the TCP on the other\
    \ side of the connection.\n        Depending on the implementation, users may\
    \ receive abort\n        indications for each outstanding SEND or RECEIVE, or\
    \ may simply\n        receive an ABORT-acknowledgment.\n    TCP-to-User Messages\n\
    \      It is assumed that the operating system environment provides a\n      means\
    \ for the TCP to asynchronously signal the user program.  When\n      the TCP\
    \ does signal a user program, certain information is passed\n      to the user.\
    \  Often in the specification the information will be\n      an error message.\
    \  In other cases there will be information\n      relating to the completion\
    \ of processing a SEND or RECEIVE or\n      other user call.\n      The following\
    \ information is provided:\n        Local Connection Name                    Always\n\
    \        Response String                          Always\n        Buffer Address\
    \                           Send & Receive\n        Byte count (counts bytes received)\
    \       Receive\n        End-of-Letter flag                       Receive\n  \
    \      End-of-Urgent flag                       Receive\n  TCP/Network Interface\n\
    \    The TCP calls on a lower level protocol module to actually send and\n   \
    \ receive information over a network.  One case is that of the ARPA\n    internetwork\
    \ system where the lower level module is the Internet\n    Protocol [2].  In most\
    \ cases the following simple interface would be\n    adequate.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n    The following two calls satisfy the requirements\
    \ for the TCP to\n    internet protocol module communication:\n      SEND (dest,\
    \ TOS, TTL, BufPTR, len, Id, DF, options => result)\n        where:\n        \
    \  dest = destination address\n          TOS = type of service\n          TTL\
    \ = time to live\n          BufPTR = buffer pointer\n          len = length of\
    \ buffer\n          Id  = Identifier\n          DF = Don't Fragment\n        \
    \  options = internet option data\n          result = response\n            OK\
    \ = datagram sent ok\n            Error = error in arguments or local network\
    \ error\n        Note that the precedence is included in the TOS and the\n   \
    \     security/compartment is passed as an option.\n      RECV (BufPTR => result,\
    \ source, dest, prot, TOS, len)\n        where:\n          BufPTR = buffer pointer\n\
    \          result = response\n            OK = datagram received ok\n        \
    \    Error = error in arguments\n          source = source address\n         \
    \ dest = destination address\n          prot = protocol\n          TOS = type\
    \ of service\n          options = internet option data\n          len = length\
    \ of buffer\n        Note that the precedence is in the TOS, and the\n       \
    \ security/compartment is an option.\n      When the TCP sends a segment, it executes\
    \ the SEND call supplying\n      all the arguments.  The internet protocol module,\
    \ on receiving\n      this call, checks the arguments and prepares and sends the\n\
    \      message.  If the arguments are good and the segment is accepted by\n  \
    \    the local network, the call returns successfully.  If either the\n      arguments\
    \ are bad, or the segment is not accepted by the local\n      network, the call\
    \ returns unsuccessfully.  On unsuccessful\n      returns, a reasonable report\
    \ should be made as to the cause of the\n                                    \
    \       Transmission Control Protocol\n                                      \
    \          Functional Specification\n      problem, but the details of such reports\
    \ are up to individual\n      implementations.\n      When a segment arrives at\
    \ the internet protocol module from the\n      local network, either there is\
    \ a pending RECV call from TCP or\n      there is not.  In the first case, the\
    \ pending call is satisfied by\n      passing the information from the segment\
    \ to the TCP.  In the\n      second case, the TCP is notified of a pending segment.\n\
    \      The notification of a TCP may be via a pseudo interrupt or similar\n  \
    \    mechanism, as appropriate in the particular operating system\n      environment\
    \ of the implementation.\n      A TCP's RECV call may then either be immediately\
    \ satisfied by a\n      pending segment, or the call may be pending until a segment\n\
    \      arrives.\n      We note that the Internet Protocol provides arguments for\
    \ a type\n      of service and for a time to live.  TCP uses the following\n \
    \     settings for these parameters:\n        Type of Service = Precedence:  none,\
    \ Package:  stream,\n        Reliability:  higher, Preference:  speed, Speed:\
    \  higher; or\n        00011111.\n        Time to Live    = one minute, or 00111100.\n\
    \          Note that the assumed maximum segment lifetime is two minutes.\n  \
    \        Here we explicitly ask that a segment be destroyed if it\n          cannot\
    \ be delivered by the internet system within one minute.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - 'Functional Specification

    '
- title: 3.9.  Event Processing
  contents:
  - "3.9.  Event Processing\n  The activity of the TCP can be characterized as responding\
    \ to events.\n  The events that occur can be cast into three categories:  user\
    \ calls,\n  arriving segments, and timeouts.  This section describes the\n  processing\
    \ the TCP does in response to each of the events.  In many\n  cases the processing\
    \ required depends on the state of the connection.\n    Events that occur:\n \
    \     User Calls\n        OPEN\n        SEND\n        RECEIVE\n        CLOSE\n\
    \        ABORT\n        STATUS\n      Arriving Segments\n        SEGMENT ARRIVES\n\
    \      Timeouts\n        USER TIMEOUT\n        RETRANSMISSION TIMEOUT\n  The model\
    \ of the TCP/user interface is that user commands receive an\n  immediate return\
    \ and possibly a delayed response via an event or\n  pseudo interrupt.  In the\
    \ following descriptions, the term \"signal\"\n  means cause a delayed response.\n\
    \  Error responses are given as character strings.  For example, user\n  commands\
    \ referencing connections that do not exist receive \"error:\n  connection not\
    \ open\".\n  Please note in the following that all arithmetic on sequence numbers,\n\
    \  acknowledgment numbers, windows, et cetera, is modulo 2**32 the size\n  of\
    \ the sequence number space.  Also note that \"=<\" means less than or\n  equal\
    \ to.\n  A natural way to think about processing incoming segments is to\n  imagine\
    \ that they are first tested for proper sequence number (i.e.,\n  that their contents\
    \ lie in the range of the expected \"receive window\"\n  in the sequence number\
    \ space) and then that they are generally queued\n  and processed in sequence\
    \ number order.\n                                           Transmission Control\
    \ Protocol\n                                                Functional Specification\n\
    \  When a segment overlaps other already received segments we reconstruct\n  the\
    \ segment to contain just the new data, and adjust the header fields\n  to be\
    \ consistent.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n                                                  \
    \             OPEN Call\n  OPEN Call\n    CLOSED STATE (i.e., TCB does not exist)\n\
    \      Create a new transmission control block (TCB) to hold connection\n    \
    \  state information.  Fill in local socket identifier, foreign\n      socket,\
    \ precedence, security/compartment, and user timeout\n      information.  Verify\
    \ the security and precedence requested are\n      allowed for this user, if not\
    \ return \"error:  precedence not\n      allowed\" or \"error:  security/compartment\
    \ not allowed.\"  If active\n      and the foreign socket is unspecified, return\
    \ \"error:  foreign\n      socket unspecified\"; if active and the foreign socket\
    \ is\n      specified, issue a SYN segment.  An initial send sequence number\n\
    \      (ISS) is selected and the TCP receive buffer size is selected (if\n   \
    \   applicable).  A SYN segment of the form <SEQ=ISS><CTL=SYN> is sent\n     \
    \ (this may include the buffer size option if applicable).  Set\n      SND.UNA\
    \ to ISS, SND.NXT to ISS+1, SND.LBB to ISS+1, enter SYN-SENT\n      state, and\
    \ return.\n      If the caller does not have access to the local socket specified,\n\
    \      return \"error:  connection illegal for this process\".  If there is\n\
    \      no room to create a new connection, return \"error:  insufficient\n   \
    \   resources\".\n    LISTEN STATE\n    SYN-SENT STATE\n    SYN-RECEIVED STATE\n\
    \    ESTABLISHED STATE\n    FIN-WAIT-1 STATE\n    FIN-WAIT-2 STATE\n    TIME-WAIT\
    \ STATE\n    CLOSE-WAIT STATE\n    CLOSING STATE\n      Return \"error:  connection\
    \ already exists\".\n                                           Transmission Control\
    \ Protocol\n                                                Functional Specification\n"
- title: SEND Call
  contents:
  - "SEND Call\n  SEND Call\n    CLOSED STATE (i.e., TCB does not exist)\n      If\
    \ the user should no have access to such a connection, then\n      return \"error:\
    \  connection illegal for this process\".\n      Otherwise, return \"error:  connection\
    \ does not exist\".\n    LISTEN STATE\n      If the foreign socket is specified,\
    \ then change the connection\n      from passive to active, select an ISS, and\
    \ select the receive\n      buffer size.  Send a SYN segment, set SND.UNA to ISS,\
    \ SND.NXT to\n      ISS+1 and SND.LBB to ISS+1.  Enter SYN-SENT state.  Data\n\
    \      associated with SEND may be sent with SYN segment or queued for\n     \
    \ transmission after entering ESTABLISHED state.  The urgent bit if\n      requested\
    \ in the command should be sent with the first data\n      segment sent as a result\
    \ of this command.  If there is no room to\n      queue the request, respond with\
    \ \"error:  insufficient resources\".\n      If Foreign socket was not specified,\
    \ then return \"error:  foreign\n      socket unspecified\".\n    SYN-SENT STATE\n\
    \      Queue for processing after the connection is ESTABLISHED.\n      Typically,\
    \ nothing can be sent yet, anyway, because the send\n      window has not yet\
    \ been set by the other side.  If no space,\n      return \"error:  insufficient\
    \ resources\".\n    SYN-RECEIVED STATE\n      Queue for later processing after\
    \ entering ESTABLISHED state.  If\n      no space to queue, respond with \"error:\
    \  insufficient resources\".\n    ESTABLISHED STATE\n      Segmentize the buffer,\
    \ send or queue it for output, with a\n      piggybacked acknowledgment (acknowledgment\
    \ value = RCV.NXT) with\n      the data.  If there is insufficient space to remember\
    \ this buffer,\n      simply return \"error:  insufficient resources\".\n    \
    \  If remote buffer size is not one octet, and, if this is the end of\n      a\
    \ letter, do the following end-of-letter/buffer-size adjustment\n      processing:\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n                                                  \
    \             SEND Call\n        if EOL = 0 then\n          SND.NXT <- SEG.SEQ\
    \ + SEG.LEN\n        if EOL = 1 then\n          While SND.LBB < SEG.SEQ + SEG.LEN\n\
    \          Do SND.LBB <- SND.LBB + SND.BS End\n          SND.NXT <- SND.LBB\n\
    \      If the urgent flag is set, then SND.UP <- SND.NXT-1 and set the\n     \
    \ urgent pointer in the outgoing segment.\n    FIN-WAIT-1 STATE\n    FIN-WAIT-2\
    \ STATE\n    TIME-WAIT STATE\n      Return \"error:  connection closing\" and\
    \ do not service request.\n    CLOSE-WAIT STATE\n      Segmentize any text to\
    \ be sent and queue for output.  If there is\n      insufficient space to remember\
    \ the SEND, return \"error:\n      insufficient resources\"\n    CLOSING STATE\n\
    \      Respond with \"error:  connection closing\"\n                         \
    \                  Transmission Control Protocol\n                           \
    \                     Functional Specification\n"
- title: RECEIVE Call
  contents:
  - "RECEIVE Call\n  RECEIVE Call\n    CLOSED STATE (i.e., TCB does not exist)\n \
    \     If the user should no have access to such a connection, return\n      \"\
    error:  connection illegal for this process\".\n      Otherwise return \"error:\
    \  connection does not exist\".\n    LISTEN STATE\n    SYN-SENT STATE\n    SYN-RECEIVED\
    \ STATE\n      Queue for processing after entering ESTABLISHED state.  If there\n\
    \      is no room to queue this request, respond with \"error:\n      insufficient\
    \ resources\".\n    ESTABLISHED STATE\n      If insufficient incoming segments\
    \ are queued to satisfy the\n      request, queue the request.  If there is no\
    \ queue space to\n      remember the RECEIVE, respond with \"error:  insufficient\n\
    \      resources\".\n      Reassemble queued incoming segments into receive buffer\
    \ and return\n      to user.  Mark \"end of letter\" (EOL) if this is the case.\n\
    \      If RCV.UP is in advance of the data currently being passed to the\n   \
    \   user notify the user of the presence of urgent data.\n      When the TCP takes\
    \ responsibility for delivering data to the user\n      that fact must be communicated\
    \ to the sender via an\n      acknowledgment.  The formation of such an acknowledgment\
    \ is\n      described below in the discussion of processing an incoming\n    \
    \  segment.\n    FIN-WAIT-1 STATE\n    FIN-WAIT-2 STATE\n      Reassemble and\
    \ return a letter, or as much as will fit, in the\n      user buffer.  Queue the\
    \ request if it cannot be serviced\n      immediately.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n                                                  \
    \          RECEIVE Call\n    TIME-WAIT STATE\n    CLOSE-WAIT STATE\n      Since\
    \ the remote side has already sent FIN, RECEIVEs must be\n      satisfied by text\
    \ already reassembled, but not yet delivered to\n      the user.  If no reassembled\
    \ segment text is awaiting delivery,\n      the RECEIVE should get a \"error:\
    \  connection closing\" response.\n      Otherwise, any remaining text can be\
    \ used to satisfy the RECEIVE.\n    CLOSING STATE\n      Return \"error:  connection\
    \ closing\"\n                                           Transmission Control Protocol\n\
    \                                                Functional Specification\n"
- title: CLOSE Call
  contents:
  - "CLOSE Call\n  CLOSE Call\n    CLOSED STATE (i.e., TCB does not exist)\n     \
    \ If the user should no have access to such a connection, return\n      \"error:\
    \  connection illegal for this process\".\n      Otherwise, return \"error:  connection\
    \ does not exist\".\n    LISTEN STATE\n      Any outstanding RECEIVEs should be\
    \ returned with \"error:  closing\"\n      responses.  Delete TCB, return \"ok\"\
    .\n    SYN-SENT STATE\n      Delete the TCB and return \"error:  closing\" responses\
    \ to any\n      queued SENDs, or RECEIVEs.\n    SYN-RECEIVED STATE\n      Queue\
    \ for processing after entering ESTABLISHED state or\n      segmentize and send\
    \ FIN segment.  If the latter, enter FIN-WAIT-1\n      state.\n    ESTABLISHED\
    \ STATE\n      Queue this until all preceding SENDs have been segmentized, then\n\
    \      form a FIN segment and send it.  In any case, enter FIN-WAIT-1\n      state.\n\
    \    FIN-WAIT-1 STATE\n    FIN-WAIT-2 STATE\n      Strictly speaking, this is\
    \ an error and should receive a \"error:\n      connection closing\" response.\
    \  An \"ok\" response would be\n      acceptable, too, as long as a second FIN\
    \ is not emitted (the first\n      FIN may be retransmitted though).\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n                                                  \
    \            CLOSE Call\n    TIME-WAIT STATE\n      Strictly speaking, this is\
    \ an error and should receive a \"error:\n      connection closing\" response.\
    \  An \"ok\" response would be\n      acceptable, too.  However, since the FIN\
    \ has been sent and\n      acknowledged, nothing should be sent (or retransmitted).\n\
    \    CLOSE-WAIT STATE\n      Queue this request until all preceding SENDs have\
    \ been\n      segmentized; then send a FIN segment, enter CLOSING state.\n   \
    \ CLOSING STATE\n      Respond with \"error:  connection closing\"\n         \
    \                                  Transmission Control Protocol\n           \
    \                                     Functional Specification\n"
- title: ABORT Call
  contents:
  - "ABORT Call\n  ABORT Call\n    CLOSED STATE (i.e., TCB does not exist)\n     \
    \ If the user should no have access to such a connection, return\n      \"error:\
    \  connection illegal for this process\".\n      Otherwise return \"error:  connection\
    \ does not exist\".\n    LISTEN STATE\n      Any outstanding RECEIVEs should be\
    \ returned with \"error:\n      connection reset\" responses.  Delete TCB, return\
    \ \"ok\".\n    SYN-SENT STATE\n      Delete the TCB and return \"reset\" responses\
    \ to any queued SENDs,\n      or RECEIVEs.\n    SYN-RECEIVED STATE\n      Send\
    \ a RST of the form:\n        <SEQ=SND.NXT><ACK=RCV.NXT><CTL=RST,ACK>\n      and\
    \ return any unprocessed SENDs, or RECEIVEs with \"reset\" code,\n      delete\
    \ the TCB.\n    ESTABLISHED STATE\n      Send a reset segment:\n        <SEQ=SND.NXT><ACK=RCV.NXT><CTL=RST,ACK>\n\
    \      All queued SENDs and RECEIVEs should be given \"reset\" responses;\n  \
    \    all segments queued for transmission (except for the RST formed\n      above)\
    \ or retransmission should be flushed, delete the TCB.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n                                                  \
    \            ABORT Call\n    FIN-WAIT-1 STATE\n    FIN-WAIT-2 STATE\n      A reset\
    \ segment (RST) should be formed and sent:\n        <SEQ=SND.NXT><ACK=RCV.NXT><CTL=RST,ACK>\n\
    \      Outstanding SENDs, RECEIVEs, CLOSEs, and/or segments queued for\n     \
    \ retransmission, or segmentizing, should be flushed, with\n      \"connection\
    \ reset\" notification to the user, delete the TCB.\n    TIME-WAIT STATE\n   \
    \   Respond with \"ok\" and delete the TCB.\n    CLOSE-WAIT STATE\n      Flush\
    \ any pending SENDs and RECEIVEs, returning \"connection reset\"\n      responses\
    \ for them.  Form and send a RST segment:\n        <SEQ=SND.NXT><ACK=RCV.NXT><CTL=RST,ACK>\n\
    \      Flush all segment queues and delete the TCB.\n    CLOSING STATE\n     \
    \ Respond with \"ok\" and delete the TCB; flush any remaining segment\n      queues.\
    \  If a CLOSE command is still pending, respond \"error:\n      connection reset\"\
    .\n                                           Transmission Control Protocol\n\
    \                                                Functional Specification\n"
- title: STATUS Call
  contents:
  - "STATUS Call\n  STATUS Call\n    CLOSED STATE (i.e., TCB does not exist)\n   \
    \   If the user should no have access to such a connection, return\n      \"error:\
    \  connection illegal for this process\".\n      Otherwise return \"error:  connection\
    \ does not exist\".\n    LISTEN STATE\n      Return \"state = LISTEN\", and the\
    \ TCB pointer.\n    SYN-SENT STATE\n      Return \"state = SYN-SENT\", and the\
    \ TCB pointer.\n    SYN-RECEIVED STATE\n      Return \"state = SYN-RECEIVED\"\
    , and the TCB pointer.\n    ESTABLISHED STATE\n      Return \"state = ESTABLISHED\"\
    , and the TCB pointer.\n    FIN-WAIT-1 STATE\n      Return \"state = FIN-WAIT-1\"\
    , and the TCB pointer.\n    FIN-WAIT-2 STATE\n      Return \"state = FIN-WAIT-2\"\
    , and the TCB pointer.\n    TIME-WAIT STATE\n      Return \"state = TIME-WAIT\
    \ and the TCB pointer.\n    CLOSE-WAIT STATE\n      Return \"state = CLOSE-WAIT\"\
    , and the TCB pointer.\n    CLOSING STATE\n      Return \"state = CLOSING\", and\
    \ the TCB pointer.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n                                                  \
    \       SEGMENT ARRIVES\n  SEGMENT ARRIVES\n    If the state is CLOSED (i.e.,\
    \ TCB does not exist) then\n      all data in the incoming segment is discarded.\
    \  An incoming\n      segment containing a RST is discarded.  An incoming segment\
    \ not\n      containing a RST causes a RST to be sent in response.  The\n    \
    \  acknowledgment and sequence field values are selected to make the\n      reset\
    \ sequence acceptable to the TCP that sent the offending\n      segment.\n   \
    \   If the ACK bit is off, sequence number zero is used,\n        <SEQ=0><ACK=SEG.SEQ+SEG.LEN><CTL=RST,ACK>\n\
    \      If the ACK bit is on,\n        <SEQ=SEG.ACK><CTL=RST>\n      Return.\n\
    \    If the state is LISTEN then\n      first check for an ACK\n        Any acknowledgment\
    \ is bad if it arrives on a connection still in\n        the LISTEN state.  An\
    \ acceptable reset segment should be formed\n        for any arriving ACK-bearing\
    \ segment, except another RST.  The\n        RST should be formatted as follows:\n\
    \          <SEQ=SEG.ACK><CTL=RST>\n        Return.\n        An incoming RST should\
    \ be ignored.  Return.\n      if there was no ACK then check for a SYN\n     \
    \   If the SYN bit is set, check the security.  If the\n        security/compartment\
    \ on the incoming segment does not exactly\n        match the security/compartment\
    \ in the TCB then send a reset and\n        return.  If the SEG.PRC is less than\
    \ the TCB.PRC then send a\n        reset and return.  If the SEG.PRC is greater\
    \ than the TCB.PRC\n        then set TCB.PRC<-SEG.PRC.  Now RCV.NXT and RCV.LBB\
    \ are set to\n        SEG.SEQ+1, IRS is set to SEG.SEQ and any other control or\
    \ text\n        should be queued for processing later.  ISS should be selected\n\
    \        and a SYN segment sent of the form:\n                               \
    \            Transmission Control Protocol\n                                 \
    \               Functional Specification\n"
- title: SEGMENT ARRIVES
  contents:
  - "SEGMENT ARRIVES\n          <SEQ=ISS><ACK=RCV.NXT><CTL=SYN,ACK>\n        SND.NXT\
    \ and SND.LBB are set to ISS+1 and SND.UNA to ISS.  The\n        connection state\
    \ should be changed to SYN-RECEIVED.  Note that\n        any other incoming control\
    \ or data (combined with SYN) will be\n        processed in the SYN-RECEIVED state,\
    \ but processing of SYN and\n        ACK should not be repeated.  If the listen\
    \ was not fully\n        specified (i.e., the foreign socket was not fully specified),\n\
    \        then the unspecified fields should be filled in now.\n      if there\
    \ was no SYN but there was other text or control\n        Any other control or\
    \ text-bearing segment (not containing SYN)\n        must have an ACK and thus\
    \ would be discarded by the ACK\n        processing.  An incoming RST segment\
    \ could not be valid, since\n        it could not have been sent in response to\
    \ anything sent by this\n        incarnation of the connection.  So you are unlikely\
    \ to get here,\n        but if you do, drop the segment, and return.\n    If the\
    \ state is SYN-SENT then\n      first check for an ACK\n        If SEG.ACK =<\
    \ ISS, or SEG.ACK > SND.NXT, or the\n        security/compartment in the segment\
    \ does not exactly match the\n        security/compartment in the TCB, or the\
    \ precedence in the\n        segment is less than the precedence in the TCB, send\
    \ a reset\n          <SEQ=SEG.ACK><CTL=RST>\n        and discard the segment.\
    \  Return.\n        If SND.UNA =< SEG.ACK =< SND.NXT and the security/compartment\n\
    \        and precedence are acceptable then the ACK is acceptable.\n        SND.UNA\
    \ should be advanced to equal SEG.ACK, and any segments on\n        the retransmission\
    \ queue which are thereby acknowledged should\n        be removed.\n      if the\
    \ ACK is ok (or there is no ACK), check the RST bit\n        If the RST bit is\
    \ set then signal the user \"error:  connection\n        reset\", enter CLOSED\
    \ state, drop the segment, delete TCB, and\n        return.\n      if the ACK\
    \ is ok (or there is no ACK) and it was not a RST, check\n      the SYN bit\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n                                                  \
    \       SEGMENT ARRIVES\n        If the SYN bit is on and the security/compartment\
    \ and precedence\n        are acceptable then, RCV.NXT and RCV.LBB are set to\
    \ SEG.SEQ+1,\n        IRS is set to SEG.SEQ.  If SND.UNA > ISS (our SYN has been\n\
    \        ACKed), change the connection state to ESTABLISHED, otherwise\n     \
    \   enter SYN-RECEIVED.  In any case, form an ACK segment:\n          <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>\n\
    \        and send it.  Data or controls which were queued for\n        transmission\
    \ may be included.\n        If SEG.PRC is greater than TCB.PRC set TCB.PRC<-SEG.PRC.\n\
    \        If there are other controls or text in the segment then continue\n  \
    \      processing at the fifth step below where the URG bit is checked,\n    \
    \    otherwise return.\n                                           Transmission\
    \ Control Protocol\n                                                Functional\
    \ Specification\n"
- title: SEGMENT ARRIVES
  contents:
  - "SEGMENT ARRIVES\n    Otherwise,\n    first check sequence number\n      SYN-RECEIVED\
    \ STATE\n      ESTABLISHED STATE\n      FIN-WAIT-1 STATE\n      FIN-WAIT-2 STATE\n\
    \      TIME-WAIT STATE\n      CLOSE-WAIT STATE\n      CLOSING STATE\n        Segments\
    \ are processed in sequence.  Initial tests on arrival\n        are used to discard\
    \ old duplicates, but further processing is\n        done in SEG.SEQ order.  If\
    \ a segment's contents straddle the\n        boundary between old and new, only\
    \ the new parts should be\n        processed.\n        There are four cases for\
    \ the acceptability test for an incoming\n        segment:\n        Segment Receive\
    \  Test\n        Length  Window\n        ------- -------  -------------------------------------------\n\
    \           0       0     SEG.SEQ = RCV.NXT\n           0      >0     RCV.NXT\
    \ =< SEG.SEQ < RCV.NXT+RCV.WND\n          >0       0     not acceptable\n    \
    \      >0      >0     RCV.NXT < SEG.SEQ+SEG.LEN =< RCV.NXT+RCV.WND\n        Note\
    \ that the test above guarantees that the last sequence\n        number used by\
    \ the segment lies in the receive-window.  If the\n        RCV.WND is zero, no\
    \ segments will be acceptable, but special\n        allowance should be made to\
    \ accept valid ACKs, URGs and RSTs.\n        If an incoming segment is not acceptable,\
    \ an acknowledgment\n        should be sent in reply:\n          <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>\n\
    \        If the incoming segment is unacceptable, drop it and return.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n                                                  \
    \       SEGMENT ARRIVES\n    second check security and precedence\n      If the\
    \ security/compartment and precedence in the segment do not\n      exactly match\
    \ the security/compartment and precedence in the TCB\n      then form a reset\
    \ and return.\n      Note this check is placed following the sequence check to\
    \ prevent\n      a segment from an old connection between these parts with a\n\
    \      different security or precedence from causing an abort of the\n      current\
    \ connection.\n    third check the ACK field,\n      SYN-RECEIVED STATE\n    \
    \    If the RST bit is off and SND.UNA < SEG.ACK =< SND.NXT then set\n       \
    \ SND.UNA <- SEG.ACK, remove any acknowledged segments from the\n        retransmission\
    \ queue, and enter ESTABLISHED state.\n        If the segment acknowledgment is\
    \ not acceptable, form a reset\n        segment,\n          <SEQ=SEG.ACK><CTL=RST>\n\
    \        and send it, unless the incoming segment is an RST (or there is\n   \
    \     no ACK), in which case, it should be discarded, then return.\n      ESTABLISHED\
    \ STATE\n        If SND.UNA < SEG.ACK =< SND.NXT then, set SND.UNA <- SEG.ACK.\n\
    \        Any segments on the retransmission queue which are thereby\n        entirely\
    \ acknowledged are removed.  Users should receive\n        positive acknowledgments\
    \ for buffers which have been SENT and\n        fully acknowledged (i.e., SEND\
    \ buffer should be returned with\n        \"ok\" response).  If the ACK is a duplicate,\
    \ it can be ignored.\n        If the segment passes the sequence number and acknowledgment\n\
    \        number tests, the send window should be updated.  If\n        SND.WL\
    \ =< SEG.SEQ, set SND.WND <- SEG.WND and set\n        SND.WL <- SEG.SEQ.\n   \
    \     If the remote buffer size is not one, then the\n        end-of-letter/buffer-size\
    \ adjustment to sequence numbers may\n        have an effect on the next expected\
    \ sequence number to be\n        acknowledged.  It is possible that the remote\
    \ TCP will\n        acknowledge with a SEG.ACK equal to a sequence number of an\n\
    \                                           Transmission Control Protocol\n  \
    \                                              Functional Specification\n"
- title: SEGMENT ARRIVES
  contents:
  - "SEGMENT ARRIVES\n        octet that was skipped over at the end of a letter.\
    \  This a mild\n        error on the remote TCPs part, but not cause for alarm.\n\
    \      FIN-WAIT-1 STATE\n      FIN-WAIT-2 STATE\n        In addition to the processing\
    \ for the ESTABLISHED state, if the\n        retransmission queue is empty, the\
    \ user's CLOSE can be\n        acknowledged (\"ok\") but do not delete the TCB.\n\
    \      TIME-WAIT STATE\n        The only thing that can arrive in this state is\
    \ a retransmission\n        of the remote FIN.  Acknowledge it, and restart the\
    \ 2 MSL\n        timeout.\n      CLOSE-WAIT STATE\n        Do the same processing\
    \ as for the ESTABLISHED state.\n      CLOSING STATE\n        If the ACK acknowledges\
    \ our FIN then delete the TCB (enter the\n        CLOSED state), otherwise ignore\
    \ the segment.\n    fourth check the RST bit,\n      SYN-RECEIVED STATE\n    \
    \    If the RST bit is set then, if the segment has passed sequence\n        and\
    \ acknowledgment tests, it is valid.  If this connection was\n        initiated\
    \ with a passive OPEN (i.e., came from the LISTEN\n        state), then return\
    \ this connection to LISTEN state.  The user\n        need not be informed.  If\
    \ this connection was initiated with an\n        active OPEN (i.e., came from\
    \ SYN-SENT state) then the connection\n        was refused, signal the user \"\
    connection refused\".  In either\n        case, all segments on the retransmission\
    \ queue should be\n        removed.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n                                                  \
    \       SEGMENT ARRIVES\n      ESTABLISHED\n      FIN-WAIT-1\n      FIN-WAIT-2\n\
    \      CLOSE-WAIT\n      CLOSING STATE\n        If the RST bit is set then, any\
    \ outstanding RECEIVEs and SEND\n        should receive \"reset\" responses. \
    \ All segment queues should be\n        flushed.  Users should also receive an\
    \ unsolicited general\n        \"connection reset\" signal.  Enter the CLOSED\
    \ state, delete the\n        TCB, and return.\n      TIME-WAIT\n        Enter\
    \ the CLOSED state, delete the TCB, and return.\n    fifth, check the SYN bit,\n\
    \      SYN-RECEIVED\n      ESTABLISHED STATE\n        If the SYN bit is set, check\
    \ the segment sequence number against\n        the receive window.  The segment\
    \ sequence number must be in the\n        receive window; if not, ignore the segment.\
    \  If the SYN is on\n        and SEG.SEQ = IRS then everything is ok and no action\
    \ is needed;\n        but if they are not equal, there is an error and a reset\
    \ must be\n        sent.\n          If a reset must be sent it is formed as follows:\n\
    \            <SEQ=SEG.ACK><CTL=RST>\n          The connection must be aborted\
    \ as if a RST had been received.\n      FIN-WAIT STATE-1\n      FIN-WAIT STATE-2\n\
    \      TIME-WAIT STATE\n      CLOSE-WAIT STATE\n      CLOSING STATE\n        This\
    \ case should not occur, since a duplicate of the SYN which\n        started the\
    \ current connection incarnation will have been\n        filtered in the SEG.SEQ\
    \ processing.  Other SYN's will have been\n        rejected by this test as well\
    \ (see SYN processing for\n        ESTABLISHED state).\n                     \
    \                      Transmission Control Protocol\n                       \
    \                         Functional Specification\n"
- title: SEGMENT ARRIVES
  contents:
  - "SEGMENT ARRIVES\n    sixth, check the URG bit,\n      ESTABLISHED STATE\n   \
    \   FIN-WAIT-1 STATE\n      FIN-WAIT-2 STATE\n        If the URG bit is set, RCV.UP\
    \ <- max(RCV.UP,SEG.UP), and signal\n        the user that the remote side has\
    \ urgent data if the urgent\n        pointer (RCV.UP) is in advance of the data\
    \ consumed.  If the\n        user has already been signaled (or is still in the\
    \ \"urgent\n        mode\") for this continuous sequence of urgent data, do not\n\
    \        signal the user again.\n      TIME-WAIT STATE\n      CLOSE-WAIT STATE\n\
    \      CLOSING\n        This should not occur, since a FIN has been received from\
    \ the\n        remote side.  Ignore the URG.\n    seventh, process the segment\
    \ text,\n      ESTABLISHED STATE\n        Once in the ESTABLISHED state, it is\
    \ possible to deliver segment\n        text to user RECEIVE buffers.  Text from\
    \ segments can be moved\n        into buffers until either the buffer is full\
    \ or the segment is\n        empty.  If the segment empties and carries an EOL\
    \ flag, then the\n        user is informed, when the buffer is returned, that\
    \ an EOL has\n        been received.\n        If buffer size is not one octet,\
    \ then do  the following\n        end-of-letter/buffer-size adjustment processing:\n\
    \          if EOL = 0 then\n            RCV.NXT <- SEG.SEQ + SEG.LEN\n       \
    \   if EOL = 1 then\n            While RCV.LBB < SEG.SEQ+SEG.LEN\n           \
    \ Do RCV.LBB <- RCV.LBB + RCV.BS End\n            RCV.NXT <- RCV.LBB\n       \
    \ When the TCP takes responsibility for delivering the data to the\n        user\
    \ it must also acknowledge the receipt of the data.  Send an\n        acknowledgment\
    \ of the form:\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Functional Specification
  contents:
  - "Functional Specification\n                                                  \
    \       SEGMENT ARRIVES\n          <SEQ=SND.NXT><ACK=RCV.NXT><CTL=ACK>\n     \
    \   This acknowledgment should be piggybacked on a segment being\n        transmitted\
    \ if possible without incurring undue delay.\n      FIN-WAIT-1 STATE\n      FIN-WAIT-2\
    \ STATE\n        If there are outstanding RECEIVEs, they should be satisfied,\
    \ if\n        possible, with the text of this segment; remaining text should\n\
    \        be queued for further processing.  If a RECEIVE is satisfied,\n     \
    \   the user should be notified, with \"end-of-letter\" (EOL) signal,\n      \
    \  if appropriate.\n      TIME-WAIT STATE\n      CLOSE-WAIT STATE\n        This\
    \ should not occur, since a FIN has been received from the\n        remote side.\
    \  Ignore the segment text.\n    eighth, check the FIN bit,\n      Send an acknowledgment\
    \ for the FIN.  Signal the user \"connection\n      closing\", and return any\
    \ pending RECEIVEs with same message.  Note\n      that FIN implies EOL for any\
    \ segment text not yet delivered to the\n      user.  If the current state is\
    \ ESTABLISHED, enter the CLOSE-WAIT\n      state.  If the current state is FIN-WAIT-1,\
    \ enter the CLOSING\n      state.  If the current state is FIN-WAIT-2, enter the\
    \ TIME-WAIT\n      state.\n    and return.\n                                 \
    \          Transmission Control Protocol\n                                   \
    \             Functional Specification\n"
- title: USER TIMEOUT
  contents:
  - "USER TIMEOUT\n  USER TIMEOUT\n    For any state if the user timeout expires,\
    \ flush all queues, signal\n    the user \"error:  connection aborted due to user\
    \ timeout\" in general\n    and for any outstanding calls, delete the TCB, and\
    \ return.\n  RETRANSMISSION TIMEOUT\n    For any state if the retransmission timeout\
    \ expires on a segment in\n    the retransmission queue, send the segment at the\
    \ front of the\n    retransmission queue again, reinitialize the retransmission\
    \ timer,\n    and return.\n"
- title: Transmission Control Protocol
  contents:
  - "Transmission Control Protocol\n                                           Transmission\
    \ Control Protocol\n                                GLOSSARY\n"
- title: '1822'
  contents:
  - "1822\n          BBN Report 1822, \"The Specification of the Interconnection of\n\
    \          a Host and an IMP\".  The specification of interface between a\n  \
    \        host and the ARPANET.\n"
- title: ACK
  contents:
  - "ACK\n          A control bit (acknowledge) occupying no sequence space, which\n\
    \          indicates that the acknowledgment field of this segment\n         \
    \ specifies the next sequence number the sender of this segment\n          is\
    \ expecting to receive, hence acknowledging receipt of all\n          previous\
    \ sequence numbers.\n"
- title: ARPANET message
  contents:
  - "ARPANET message\n          The unit of transmission between a host and an IMP\
    \ in the\n          ARPANET.  The maximum size is about 1012 octets (8096 bits).\n"
- title: ARPANET packet
  contents:
  - "ARPANET packet\n          A unit of transmission used internally in the ARPANET\
    \ between\n          IMPs.  The maximum size is about 126 octets (1008 bits).\n"
- title: buffer size
  contents:
  - "buffer size\n          An option (buffer size) used to state the receive data\
    \ buffer\n          size of the sender of this option.  May only be sent in a\n\
    \          segment that also carries a SYN.\n"
- title: connection
  contents:
  - "connection\n          A logical communication path identified by a pair of sockets.\n"
- title: datagram
  contents:
  - "datagram\n          A message sent in a packet switched computer communications\n\
    \          network.\n"
- title: Destination Address
  contents:
  - "Destination Address\n          The destination address, usually the network and\
    \ host\n          identifiers.\n"
- title: EOL
  contents:
  - "EOL\n          A control bit (End of Letter) occupying no sequence space,\n \
    \         indicating that this segment ends a logical letter with the\n      \
    \    last data octet in the segment.  If this end of letter causes\n         \
    \ a less than full buffer to be released to the user and the\n          connection\
    \ buffer size is not one octet then the\n          end-of-letter/buffer-size adjustment\
    \ to the receive sequence\n          number must be made.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Glossary
  contents:
  - 'Glossary

    '
- title: FIN
  contents:
  - "FIN\n          A control bit (finis) occupying one sequence number, which\n \
    \         indicates that the sender will send no more data or control\n      \
    \    occupying sequence space.\n"
- title: fragment
  contents:
  - "fragment\n          A portion of a logical unit of data, in particular an internet\n\
    \          fragment is a portion of an internet datagram.\n"
- title: FTP
  contents:
  - "FTP\n          A file transfer protocol.\n"
- title: header
  contents:
  - "header\n          Control information at the beginning of a message, segment,\n\
    \          fragment, packet or block of data.\n"
- title: host
  contents:
  - "host\n          A computer.  In particular a source or destination of messages\n\
    \          from the point of view of the communication network.\n"
- title: Identification
  contents:
  - "Identification\n          An Internet Protocol field.  This identifying value\
    \ assigned\n          by the sender aids in assembling the fragments of a datagram.\n"
- title: IMP
  contents:
  - "IMP\n          The Interface Message Processor, the packet switch of the\n  \
    \        ARPANET.\n"
- title: internet address
  contents:
  - "internet address\n          A source or destination address specific to the host\
    \ level.\n"
- title: internet datagram
  contents:
  - "internet datagram\n          The unit of data exchanged between an internet module\
    \ and the\n          higher level protocol together with the internet header.\n"
- title: internet fragment
  contents:
  - "internet fragment\n          A portion of the data of an internet datagram with\
    \ an internet\n          header.\n"
- title: IP
  contents:
  - "IP\n          Internet Protocol.\n"
- title: IRS
  contents:
  - "IRS\n          The Initial Receive Sequence number.  The first sequence\n   \
    \       number used by the sender on a connection.\n                         \
    \                  Transmission Control Protocol\n                           \
    \                                     Glossary\n"
- title: ISN
  contents:
  - "ISN\n          The Initial Sequence Number.  The first sequence number used\n\
    \          on a connection, (either ISS or IRS).  Selected on a clock\n      \
    \    based procedure.\n"
- title: ISS
  contents:
  - "ISS\n          The Initial Send Sequence number.  The first sequence number\n\
    \          used by the sender on a connection.\n"
- title: leader
  contents:
  - "leader\n          Control information at the beginning of a message or block\
    \ of\n          data.  In particular, in the ARPANET, the control information\n\
    \          on an ARPANET message at the host-IMP interface.\n"
- title: left sequence
  contents:
  - "left sequence\n          This is the next sequence number to be acknowledged\
    \ by the\n          data receiving TCP (or the lowest currently unacknowledged\n\
    \          sequence number) and is sometimes referred to as the left edge\n  \
    \        of the send window.\n"
- title: letter
  contents:
  - "letter\n          A logical unit of data, in particular the logical unit of data\n\
    \          transmitted between processes via TCP.\n"
- title: local packet
  contents:
  - "local packet\n          The unit of transmission within a local network.\n"
- title: module
  contents:
  - "module\n          An implementation, usually in software, of a protocol or other\n\
    \          procedure.\n"
- title: MSL
  contents:
  - "MSL\n          Maximum Segment Lifetime, the time a TCP segment can exist in\n\
    \          the internetwork system.  Arbitrarily defined to be 2 minutes.\n"
- title: octet
  contents:
  - "octet\n          An eight bit byte.\n"
- title: Options
  contents:
  - "Options\n          An Option field may contain several options, and each option\n\
    \          may be several octets in length.  The options are used\n          primarily\
    \ in testing situations; for example, to carry\n          timestamps.  Both the\
    \ Internet Protocol and TCP provide for\n          options fields.\n"
- title: packet
  contents:
  - "packet\n          A package of data with a header which may or may not be\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Glossary
  contents:
  - "Glossary\n          logically complete.  More often a physical packaging than\
    \ a\n          logical packaging of data.\n"
- title: port
  contents:
  - "port\n          The portion of a socket that specifies which logical input or\n\
    \          output channel of a process is associated with the data.\n"
- title: process
  contents:
  - "process\n          A program in execution.  A source or destination of data from\n\
    \          the point of view of the TCP or other host-to-host protocol.\n"
- title: PSN
  contents:
  - "PSN\n          A Packet Switched Network.  For example, the ARPANET.\n"
- title: RCV.BS
  contents:
  - "RCV.BS\n          receive buffer size, the remote buffer size\n"
- title: RCV.LBB
  contents:
  - "RCV.LBB\n          receive last buffer beginning\n"
- title: RCV.NXT
  contents:
  - "RCV.NXT\n          receive next sequence number\n"
- title: RCV.UP
  contents:
  - "RCV.UP\n          receive urgent pointer\n"
- title: RCV.WND
  contents:
  - "RCV.WND\n          receive window\n"
- title: receive last buffer beginning
  contents:
  - "receive last buffer beginning\n          This is the sequence number of the first\
    \ octet of the most\n          recent buffer.  This value is use in calculating\
    \ the next\n          sequence number when a segment contains an end of letter\n\
    \          indication.\n"
- title: receive next sequence number
  contents:
  - "receive next sequence number\n          This is the next sequence number the\
    \ local TCP is expecting to\n          receive.\n"
- title: receive window
  contents:
  - "receive window\n          This represents the sequence numbers the local (receiving)\
    \ TCP\n          is willing to receive.  Thus, the local TCP considers that\n\
    \          segments overlapping the range RCV.NXT to\n          RCV.NXT + RCV.WND\
    \ - 1 carry acceptable data or control.\n          Segments containing sequence\
    \ numbers entirely outside of this\n          range are considered duplicates\
    \ and discarded.\n                                           Transmission Control\
    \ Protocol\n                                                                Glossary\n"
- title: RST
  contents:
  - "RST\n          A control bit (reset), occupying no sequence space, indicating\n\
    \          that the receiver should delete the connection without further\n  \
    \        interaction.  The receiver can determine, based on the\n          sequence\
    \ number and acknowledgment fields of the incoming\n          segment, whether\
    \ it should honor the reset command or ignore\n          it.  In no case does\
    \ receipt of a segment containing RST give\n          rise to a RST in response.\n"
- title: RTP
  contents:
  - "RTP\n          Real Time Protocol:  A host-to-host protocol for communication\n\
    \          of time critical information.\n"
- title: Rubber EOL
  contents:
  - "Rubber EOL\n          An end of letter (EOL) requiring a sequence number adjustment\n\
    \          to align the beginning of the next letter on a buffer\n          boundary.\n"
- title: SEG.ACK
  contents:
  - "SEG.ACK\n          segment acknowledgment\n"
- title: SEG.LEN
  contents:
  - "SEG.LEN\n          segment length\n"
- title: SEG.PRC
  contents:
  - "SEG.PRC\n          segment precedence value\n"
- title: SEG.SEQ
  contents:
  - "SEG.SEQ\n          segment sequence\n"
- title: SEG.UP
  contents:
  - "SEG.UP\n          segment urgent pointer field\n"
- title: SEG.WND
  contents:
  - "SEG.WND\n          segment window field\n"
- title: segment
  contents:
  - "segment\n          A logical unit of data, in particular a TCP segment is the\n\
    \          unit of data transfered between a pair of TCP modules.\n"
- title: segment acknowledgment
  contents:
  - "segment acknowledgment\n          The sequence number in the acknowledgment field\
    \ of the\n          arriving segment.\n"
- title: segment length
  contents:
  - "segment length\n          The amount of sequence number space occupied by a segment,\n\
    \          including any controls which occupy sequence space.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
- title: Glossary
  contents:
  - 'Glossary

    '
- title: segment sequence
  contents:
  - "segment sequence\n          The number in the sequence field of the arriving\
    \ segment.\n"
- title: send last buffer beginning
  contents:
  - "send last buffer beginning\n          This is the sequence number of the first\
    \ octet of the most\n          recent buffer.  This value is used in calculating\
    \ the next\n          sequence number when a segment contains an end of letter\n\
    \          indication.\n"
- title: send sequence
  contents:
  - "send sequence\n          This is the next sequence number the local (sending)\
    \ TCP will\n          use on the connection.  It is initially selected from an\n\
    \          initial sequence number curve (ISN) and is incremented for\n      \
    \    each octet of data or sequenced control transmitted.\n"
- title: send window
  contents:
  - "send window\n          This represents the sequence numbers which the remote\n\
    \          (receiving) TCP is willing to receive.  It is the value of the\n  \
    \        window field specified in segments from the remote (data\n          receiving)\
    \ TCP.  The range of sequence numbers which may be\n          emitted by a TCP\
    \ lies between SND.NXT and\n          SND.UNA + SND.WND - 1.\n"
- title: SND.BS
  contents:
  - "SND.BS\n           send buffer size, the local buffer size\n"
- title: SND.LBB
  contents:
  - "SND.LBB\n          send last buffer beginning\n"
- title: SND.NXT
  contents:
  - "SND.NXT\n          send sequence\n"
- title: SND.UNA
  contents:
  - "SND.UNA\n          left sequence\n"
- title: SND.UP
  contents:
  - "SND.UP\n          send urgent pointer\n"
- title: SND.WL
  contents:
  - "SND.WL\n          send sequence number at last window update\n"
- title: SND.WND
  contents:
  - "SND.WND\n          send window\n"
- title: socket
  contents:
  - "socket\n          An address which specifically includes a port identifier, that\n\
    \          is, the concatenation of an Internet Address with a TCP port.\n   \
    \                                        Transmission Control Protocol\n     \
    \                                                           Glossary\n"
- title: Source Address
  contents:
  - "Source Address\n          The source address, usually the network and host identifiers.\n"
- title: SYN
  contents:
  - "SYN\n          A control bit in the incoming segment, occupying one sequence\n\
    \          number, used at the initiation of a connection, to indicate\n     \
    \     where the sequence numbering will start.\n"
- title: TCB
  contents:
  - "TCB\n          Transmission control block, the data structure that records\n\
    \          the state of a connection.\n"
- title: TCB.PRC
  contents:
  - "TCB.PRC\n          The precedence of the connection.\n"
- title: TCP
  contents:
  - "TCP\n          Transmission Control Protocol:  A host-to-host protocol for\n\
    \          reliable communication in internetwork environments.\n"
- title: TOS
  contents:
  - "TOS\n          Type of Service, an Internet Protocol field.\n"
- title: Type of Service
  contents:
  - "Type of Service\n          An Internet Protocol field which indicates the type\
    \ of service\n          for this internet fragment.\n"
- title: URG
  contents:
  - "URG\n          A control bit (urgent), occupying no sequence space, used to\n\
    \          indicate that the receiving user should be notified to do\n       \
    \   urgent processing as long as there is data to be consumed with\n         \
    \ sequence numbers less than the value indicated in the urgent\n          pointer.\n"
- title: urgent pointer
  contents:
  - "urgent pointer\n          A control field meaningful only when the URG bit is\
    \ on.  This\n          field communicates the value of the urgent pointer which\n\
    \          indicates the data octet associated with the sending user's\n     \
    \     urgent call.\n"
- title: Transmission Control Protocol
  contents:
  - "Transmission Control Protocol\n                                           Transmission\
    \ Control Protocol\n                               REFERENCES\n"
- title: '[1]  Cerf, V., and R. Kahn, "A Protocol for Packet Network'
  contents:
  - "[1]  Cerf, V., and R. Kahn, \"A Protocol for Packet Network\n     Intercommunication,\"\
    \ IEEE Transactions on Communications,\n     Vol. COM-22, No. 5, pp 637-648, May\
    \ 1974.\n"
- title: '[2]  Postel, J. (ed.), "DOD Standard Internet Protocol," Defense'
  contents:
  - "[2]  Postel, J. (ed.), \"DOD Standard Internet Protocol,\" Defense\n     Advanced\
    \ Research Projects Agency, Information Processing\n     Techniques Office, RFC\
    \ 760, IEN 128, January 1980.\n"
- title: '[3]  Feinler, E. and J. Postel, ARPANET Protocol Handbook, Network'
  contents:
  - "[3]  Feinler, E. and J. Postel, ARPANET Protocol Handbook, Network\n     Information\
    \ Center, SRI International, Menlo Park, CA,\n     January 1978.\n"
- title: '[4]  Dalal, Y. and C. Sunshine, "Connection Management in Transport'
  contents:
  - "[4]  Dalal, Y. and C. Sunshine, \"Connection Management in Transport\n     Protocols,\"\
    \ Computer Networks, Vol. 2, No. 6, pp. 454-473,\n     December 1978.\n"
- title: Transmission Control Protocol
  contents:
  - 'Transmission Control Protocol

    '
