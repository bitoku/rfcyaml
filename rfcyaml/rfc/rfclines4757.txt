This document documents the RC4 Kerberos encryption types first introduced in Microsoft Windows 2000.
Since then, these encryption types have been implemented in a number of Kerberos implementations.
The IETF Kerberos community supports publishing this specification as an informational document in order to describe this widely implemented technology.
However, while these encryption types provide the operations necessary to implement the base Kerberos specification [RFC4120], they do not provide all the required operations in the Kerberos cryptography framework [RFC3961].
As a result, it is not generally possible to implement potential extensions to Kerberos using these encryption types.
The Kerberos encryption type negotiation mechanism [RFC4537] provides one approach for using such extensions even when a Kerberos infrastructure uses long term RC4 keys.
Because this specification does not implement operations required by RFC 3961 and because of security concerns with the use of RC4 and MD4 discussed in Section 8, this specification is not appropriate for publication on the standards track.
Abstract The Microsoft Windows 2000 implementation of Kerberos introduces a new encryption type based on the RC4 encryption algorithm and using an MD5 HMAC for checksum.
This is offered as an alternative to using the existing DES based encryption types.
The RC4 HMAC encryption types are used to ease upgrade of existing Windows NT environments, provide strong cryptography (128 bit key lengths), and provide exportable (meet United States government export restriction requirements) encryption.
This document describes the implementation of those encryption types.
The Microsoft Windows 2000 implementation of Kerberos contains new encryption and checksum types for two reasons.
First, for export reasons early in the development process, 56 bit DES encryption could not be exported, and, second, upon upgrade from Windows NT 4.0 to Windows 2000, accounts will not have the appropriate DES keying material to do the standard DES encryption.
Furthermore, 3DES was not available for export when Windows 2000 was released, and there was a desire to use a single flavor of encryption in the product for both US and international products.
As a result, there are two new encryption types and one new checksum type introduced in Microsoft Windows 2000.
Note that these cryptosystems aren't intended to be complete, general purpose Kerberos encryption or checksum systems as defined in [RFC3961]: there is no one one mapping between the operations in this documents and the primitives described in [RFC3961].
Conventions Used in This Document
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "
SHALL NOT", "SHOULD", "SHOULD NOT",
"RECOMMENDED", "MAY", and "OPTIONAL" are to be interpreted as described in [RFC2119].
On upgrade from existing Windows NT domains, the user accounts would not have a DES based key available to enable the use of DES base encryption types specified in [RFC4120] and [RFC3961].
The key used for RC4 HMAC is the same as the existing Windows NT key (NT Password Hash) for compatibility reasons.
Once the account password is changed, the DES based keys are created and maintained.
Once the DES keys are available, DES based encryption types can be used with Kerberos.
The RC4 HMAC string to key function is defined as follows:
The RC4 HMAC keys are generated by using the Windows UNICODE version of the password.
Each Windows UNICODE character is encoded in little endian format of 2 octets each.
Then an MD4 [RFC1320] hash operation is performed on just the UNICODE characters of the password (not including the terminating zero octets).
For an account with a password of "foo", this String2Key("foo") will return: 0xac, 0x8e, 0x65, 0x7f, 0x83, 0xdf, 0x82, 0xbe, 0xea, 0x5d, 0x43, 0xbd, 0xaf, 0x78, 0x00, 0xcc 3.
The MD5 HMAC function is defined in [RFC2104].
It is used in this encryption type for checksum operations.
Refer to [RFC2104] for details on its operation.
In this document, this function is referred to as HMAC(Key, Data) returning the checksum using the specified key on the data.
The basic MD5 hash operation is used in this encryption type and defined in [RFC1321].
In this document, this function is referred to as MD5(Data) returning the checksum of the data.
RC4 is a stream cipher licensed by RSA Data Security.
In this document, the function is referred to as RC4(Key, Data) returning the encrypted data using the specified key on the data.
These encryption types use key derivation.
With each message, the message type (T) is used as a component of the keying material.
The following table summarizes the different key derivation values used in the various operations.
Note that these differ from the key derivations used in other Kerberos encryption types.
the message type, encoded as a little endian four byte integer.
AS REQ PA ENC TIMESTAMP padata timestamp, encrypted with the client key (T 1) 2.
REP Ticket and TGS REP Ticket (includes TGS session key or application session key), encrypted with the service key (T 2) 3.
REP encrypted part (includes TGS session key or application session key), encrypted with the client key (T 8) 4.
TGS REQ KDC REQ BODY AuthorizationData, encrypted with the TGS session key (T 4) 5.
TGS REQ KDC REQ BODY AuthorizationData, encrypted with the TGS authenticator subkey (T 5) 6.
TGS REQ PA TGS REQ padata AP REQ Authenticator cksum, keyed with the TGS session key (T 6) 7.
TGS REQ PA TGS REQ padata AP REQ Authenticator (includes TGS authenticator subkey), encrypted with the TGS session key T 7) 8.
TGS REP encrypted part (includes application session key), encrypted with the TGS session key (T 8) 9.
TGS REP encrypted part (includes application session key), encrypted with the TGS authenticator subkey (T 8) 10.
AP REQ Authenticator cksum, keyed with the application session key (T 10) 11.
AP REQ Authenticator (includes application authenticator subkey), encrypted with the application session key (T 11) 12.
AP REP encrypted part (includes application session subkey), encrypted with the application session key (T 12) 13.
KRB PRIV encrypted part, encrypted with a key chosen by the application.
Also for data encrypted with GSS Wrap (T 13) 14.
KRB CRED encrypted part, encrypted with a key chosen by the application (T 14) 15.
KRB SAFE cksum, keyed with a key chosen by the application.
Also for data signed in GSS MIC (T 15) Relative to RFC 1964 key uses
: T   0 in the generation of sequence number for the MIC token T   0 in the generation of sequence number for the WRAP token T   0 in the generation of encrypted data for the WRAPPED token All strings in this document
are ASCII unless otherwise specified.
The lengths of ASCII encoded character strings include the trailing terminator character (0).
function will return the logical concatenation (left to right) of the values of the arguments.
The nonce(n) function returns a pseudo random number of "n" octets.
There is one checksum type used in this encryption type.
The Kerberos constant for this type is: #define KERB CHECKSUM HMAC MD5 ( 138)
The function is defined as follows:
K   the Key T   the message type, encoded as a little endian four byte integer CHKSUM(K, T, data)
zero octet at end tmp
There are two encryption types used in these encryption types.
The basic encryption function is defined as follows:
T   the message type, encoded as a little endian four byte integer.
Checksum   HMAC (K2, edata); K3   HMAC (K1, edata.
The character constant "fortybits" evolved from the time when a 40 bit key length was all that was exportable from the United States.
It is now used to recognize that the key length is of "exportable" length.
In this description, the key size is actually 56 bits.
The pseudo random operation [RFC3961] for both enctypes above is defined as follows:
HMAC SHA1(K, S) where K is the protocol key and S is the input octet string.
HMAC SHA1 is defined in [RFC2104] and the output of HMAC SHA1 is the 20 octet digest.
A Kerberos client and server can negotiate over key length if they are using mutual authentication.
If the client is unable to perform full strength encryption, it may propose a key in the "subkey" field of the authenticator, using a weaker encryption type.
The server must then either return the same key or suggest its own key in the subkey field of the AP reply message.
The key used to encrypt data is derived from the key returned by the server.
If the client is able to perform strong encryption but the server is not, it may propose a subkey in the AP reply without first being sent a subkey in the authenticator.
GSS API Kerberos V5 Mechanism Type 7.1.
Mechanism Specific Changes The Generic Security Service Application Program Interface (GSS API) per
message tokens also require new checksum and encryption types.
The GSS API per message tokens are adapted to support these new encryption types.
The only support quality of protection is: #define GSS KRB5 INTEG C QOP DEFAULT    0x0
When using this RC4 based encryption type, the sequence number is always sent in big endian rather than little endian order.
The Windows 2000 implementation also defines new GSS API flags in the initial token passed when initializing a security context.
These flags are passed in the checksum field of the authenticator.
This flag was added for use with Microsoft's implementation of Distributed Computing Environment Remote Procedure Call (DCE RPC), which initially expected three legs of authentication.
Setting this flag causes an extra AP reply to be sent from the client back to the server after receiving the server's AP reply.
In addition, the context negotiation tokens do not have GSS API per message tokens
they are raw AP messages that do not include object identifiers.
#define GSS C DCE STYLE
This flag allows the client to indicate to the server that it should only allow the server application to identify the client by name and ID, but not to impersonate the client.
GSS C EXTENDED ERROR FLAG
this flag indicates that the client wants to be informed of extended error information.
In particular, Windows 2000 status codes may be returned in the data field of a Kerberos error message.
This allows the client to understand a server failure more precisely.
In addition, the server may return errors to the client that are normally handled at the application layer in the server, in order to let the client try to recover.
After receiving an error message, the client may attempt to resubmit an AP request.
#define GSS C EXTENDED ERROR FLAG
These flags are only used if a client is aware of these conventions when using the Security Support Provider Interface (SSPI) on the Windows platform; they are not generally used by default.
When NetBIOS addresses are used in the GSS API, they are identified by the GSS C AF NETBIOS value.
NetBios addresses are 16 octet addresses typically composed of 1 to 15 characters, trailing blank (ASCII char 20) filled, with a 16th octet of 0x0.
The GSS API checksum type and algorithm are defined in Section 5.
Only the first 8 octets of the checksum are used.
The resulting checksum is stored in the SGN CKSUM field.
See [RFC1964] Section 1.2 for GSS GetMIC
() and GSS Wrap(conf flag FALSE).
Tokens emitted by GSS GetMIC() contain the hex value 01 01 in this field.
SND SEQ    Sequence number field.
The MIC mechanism used for GSS MIC based messages is as follows:
GetMIC(Kss, direction, export, seq num, data) { struct Token {
Create the sequence number if (direction   sender is initiator)
SEQ 4, 0xff, 4) }
else if (direction   sender is acceptor)
SEND SEQ 4, 0, 4)
Generate checksum of message SGN CKSUM //
Key derivation salt   15 Sgn Cksum   MD5((int32)15, Token.
Save first 8 octets of HMAC Sgn Cksum Sgn Cksum   HMAC(Ksign, Sgn Cksum); memcpy(Token.
Encrypt the sequence number //
Derive encryption key for the sequence number //
{ Kseq   HMAC(Kss, "fortybits", (int32)0)
Encrypt the sequence number RC4(Kseq, Token.
There are two encryption keys for GSS API message tokens, one that is 128 bits in strength and one that is 56 bits in strength as defined in Section 6.
All padding is rounded up to 1 byte.
One byte is needed to say that there is 1 byte of padding.
The DES based mechanism type uses 8 byte padding.
The RC4 HMAC GSS Wrap
() token has the following format:
Tokens emitted by GSS Wrap() contain the hex value 02 01 in this field.
The encryption mechanism used for GSS wrap based messages is as follows: WRAP(Kss, encrypt, direction, export, seq num, data)
TOK ID   02 01; Token.
SGN SLG   11 00; Token.
Create the sequence number if (direction   sender is initiator)
} else if (direction   sender is acceptor)
Derive signing key from session key Ksign   HMAC(Kss, "signaturekey")
Key derivation salt   15 Sgn Cksum   MD5((int32)15, Token.
Key derivation salt   0 for (i   0
; i < 16; i ) Klocal[i]
{ Kcrypt   HMAC(Klocal, "fortybits", (int32)0);
Encrypt confounder (if encrypting) if (encrypt) RC4(Kcrypt, Token.
Encrypt the data (if encrypting)
Save first 8 octets of HMAC Sgn Cksum Sgn Cksum   HMAC(Ksign, Sgn Cksum); memcpy(Token.
Derive encryption key for the sequence number //
{ Kseq   HMAC(Kss, "fortybits", (int32)0)
Encrypt the sequence number RC4(Kseq, Token.
The character constant "fortybits" evolved from the time when a 40 bit key length was all that was exportable from the United States.
It is now used to recognize that the key length is of "exportable" length.
In this description, the key size is actually 56 bits.
Security Considerations Care must be taken in implementing these encryption types because they use a stream cipher.
If a different IV is not used in each direction when using a session key, the encryption is weak.
By using the sequence number as an IV, this is avoided.
There are two classes of attack on RC4 described in [MIRONOV].
Strong distinguishers distinguish an RC4 keystream from randomness at the start of the stream.
Weak distinguishers can operate on any part of the keystream, and the best ones, described in [FMcG] and [MANTIN05], can exploit data from multiple, different keystreams.
A consequence of these is that encrypting the same data (for instance, a password) sufficiently many times in separate RC4 keystreams can be sufficient to leak information to an adversary.
The encryption types defined in this document defend against these by constructing a new keystream for every message.
However, it is RECOMMENDED not to use the RC4 encryption types defined in this document for high volume connections.
Weaknesses in MD4 [BOER91] were demonstrated by den Boer and Bosselaers in 1991.
In August 2004, Xiaoyun Wang, et al., reported MD4 collisions generated using hand calculation [WANG04].
Implementations based on Wang's algorithm can find collisions in real time.
However, the intended usage of MD4 described in this document does not rely on the collision resistant property of MD4.
Furthermore, MD4 is always used in the context of a keyed hash in this document.
Although no evidence has suggested keyed MD4 hashes are vulnerable to collision based attacks, no study has directly proved that the HMAC MD4 is secure: the existing study simply assumed that the hash function used in HMAC is collision proof.
It is thus RECOMMENDED not to use the RC4 encryption types defined in this document if alternative stronger encryption types, such as aes256 cts hmac sha1 96 [RFC3962], are available.
IANA Considerations Section 5 of this document defines two Kerberos encryption types rc4 hmac (23) and rc4 hmac exp (24).
The Kerberos parameters registration page at <http://www.iana.org/assignments/kerberos
parameters> has been updated to reference this document for these two encryption types.
