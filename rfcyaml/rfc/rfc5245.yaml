- title: __initial_text__
  contents:
  - "             Interactive Connectivity Establishment (ICE):\n     A Protocol for\
    \ Network Address Translator (NAT) Traversal for\n                         Offer/Answer\
    \ Protocols\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes a protocol for Network Address Translator\n\
    \   (NAT) traversal for UDP-based multimedia sessions established with\n   the\
    \ offer/answer model.  This protocol is called Interactive\n   Connectivity Establishment\
    \ (ICE).  ICE makes use of the Session\n   Traversal Utilities for NAT (STUN)\
    \ protocol and its extension,\n   Traversal Using Relay NAT (TURN).  ICE can be\
    \ used by any protocol\n   utilizing the offer/answer model, such as the Session\
    \ Initiation\n   Protocol (SIP).\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This\
    \ document is a product of the Internet Engineering Task Force\n   (IETF).  It\
    \ represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   Internet Standards is available\
    \ in Section 2 of RFC 5741.\n   Information about the current status of this document,\
    \ any errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc5245.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   6\n   2.  Overview of ICE . . . . . . . . . . . . . . . . . . .\
    \ . . . .   7\n     2.1.  Gathering Candidate Addresses . . . . . . . . . . .\
    \ . . .   9\n     2.2.  Connectivity Checks . . . . . . . . . . . . . . . . .\
    \ . .  11\n     2.3.  Sorting Candidates  . . . . . . . . . . . . . . . . . .\
    \ .  12\n     2.4.  Frozen Candidates . . . . . . . . . . . . . . . . . . . .\
    \  13\n     2.5.  Security for Checks . . . . . . . . . . . . . . . . . . .  14\n\
    \     2.6.  Concluding ICE  . . . . . . . . . . . . . . . . . . . . .  14\n  \
    \   2.7.  Lite Implementations  . . . . . . . . . . . . . . . . . .  16\n   3.\
    \  Terminology . . . . . . . . . . . . . . . . . . . . . . . . .  16\n   4.  Sending\
    \ the Initial Offer . . . . . . . . . . . . . . . . . .  19\n     4.1.  Full Implementation\
    \ Requirements  . . . . . . . . . . . .  19\n       4.1.1.  Gathering Candidates\
    \  . . . . . . . . . . . . . . . .  19\n         4.1.1.1.  Host Candidates . .\
    \ . . . . . . . . . . . . . . .  20\n         4.1.1.2.  Server Reflexive and Relayed\
    \ Candidates . . . . .  20\n         4.1.1.3.  Computing Foundations . . . . .\
    \ . . . . . . . . .  22\n         4.1.1.4.  Keeping Candidates Alive  . . . .\
    \ . . . . . . . .  22\n       4.1.2.  Prioritizing Candidates . . . . . . . .\
    \ . . . . . . .  22\n         4.1.2.1.  Recommended Formula . . . . . . . . .\
    \ . . . . . .  23\n         4.1.2.2.  Guidelines for Choosing Type and Local\n\
    \                   Preferences . . . . . . . . . . . . . . . . . . .  23\n  \
    \     4.1.3.  Eliminating Redundant Candidates  . . . . . . . . . .  25\n    \
    \   4.1.4.  Choosing Default Candidates . . . . . . . . . . . . .  25\n     4.2.\
    \  Lite Implementation Requirements  . . . . . . . . . . . .  25\n     4.3.  Encoding\
    \ the SDP  . . . . . . . . . . . . . . . . . . . .  26\n   5.  Receiving the Initial\
    \ Offer . . . . . . . . . . . . . . . . .  28\n     5.1.  Verifying ICE Support\
    \ . . . . . . . . . . . . . . . . . .  28\n     5.2.  Determining Role  . . .\
    \ . . . . . . . . . . . . . . . . .  29\n     5.3.  Gathering Candidates  . .\
    \ . . . . . . . . . . . . . . . .  30\n     5.4.  Prioritizing Candidates . .\
    \ . . . . . . . . . . . . . . .  30\n     5.5.  Choosing Default Candidates .\
    \ . . . . . . . . . . . . . .  31\n     5.6.  Encoding the SDP  . . . . . . .\
    \ . . . . . . . . . . . . .  31\n     5.7.  Forming the Check Lists . . . . .\
    \ . . . . . . . . . . . .  31\n       5.7.1.  Forming Candidate Pairs . . . .\
    \ . . . . . . . . . . .  31\n       5.7.2.  Computing Pair Priority and Ordering\
    \ Pairs  . . . . .  34\n       5.7.3.  Pruning the Pairs . . . . . . . . . . .\
    \ . . . . . . .  34\n       5.7.4.  Computing States  . . . . . . . . . . . .\
    \ . . . . . .  34\n     5.8.  Scheduling Checks . . . . . . . . . . . . . . .\
    \ . . . . .  37\n   6.  Receipt of the Initial Answer . . . . . . . . . . . .\
    \ . . . .  39\n     6.1.  Verifying ICE Support . . . . . . . . . . . . . . .\
    \ . . .  39\n     6.2.  Determining Role  . . . . . . . . . . . . . . . . . .\
    \ . .  39\n     6.3.  Forming the Check List  . . . . . . . . . . . . . . . .\
    \ .  40\n     6.4.  Performing Ordinary Checks  . . . . . . . . . . . . . . .\
    \  40\n   7.  Performing Connectivity Checks  . . . . . . . . . . . . . . .  40\n\
    \     7.1.  STUN Client Procedures  . . . . . . . . . . . . . . . . .  40\n  \
    \     7.1.1.  Creating Permissions for Relayed Candidates . . . . .  40\n    \
    \   7.1.2.  Sending the Request . . . . . . . . . . . . . . . . .  40\n      \
    \   7.1.2.1.  PRIORITY and USE-CANDIDATE  . . . . . . . . . . .  41\n        \
    \ 7.1.2.2.  ICE-CONTROLLED and ICE-CONTROLLING  . . . . . . .  41\n         7.1.2.3.\
    \  Forming Credentials . . . . . . . . . . . . . . .  41\n         7.1.2.4.  DiffServ\
    \ Treatment  . . . . . . . . . . . . . . .  42\n       7.1.3.  Processing the\
    \ Response . . . . . . . . . . . . . . .  42\n         7.1.3.1.  Failure Cases\
    \ . . . . . . . . . . . . . . . . . .  42\n         7.1.3.2.  Success Cases .\
    \ . . . . . . . . . . . . . . . . .  43\n           7.1.3.2.1.  Discovering Peer\
    \ Reflexive Candidates . . . .  43\n           7.1.3.2.2.  Constructing a Valid\
    \ Pair . . . . . . . . . .  44\n           7.1.3.2.3.  Updating Pair States  .\
    \ . . . . . . . . . . .  45\n           7.1.3.2.4.  Updating the Nominated Flag\
    \ . . . . . . . . .  46\n         7.1.3.3.  Check List and Timer State Updates\
    \  . . . . . . .  46\n     7.2.  STUN Server Procedures  . . . . . . . . . . .\
    \ . . . . . .  46\n       7.2.1.  Additional Procedures for Full Implementations\
    \  . . .  47\n         7.2.1.1.  Detecting and Repairing Role Conflicts  . . .\
    \ . .  47\n         7.2.1.2.  Computing Mapped Address  . . . . . . . . . . .\
    \ .  48\n         7.2.1.3.  Learning Peer Reflexive Candidates  . . . . . . .\
    \  49\n         7.2.1.4.  Triggered Checks  . . . . . . . . . . . . . . . .  49\n\
    \         7.2.1.5.  Updating the Nominated Flag . . . . . . . . . . .  50\n  \
    \     7.2.2.  Additional Procedures for Lite Implementations  . . .  51\n   8.\
    \  Concluding ICE Processing . . . . . . . . . . . . . . . . . .  51\n     8.1.\
    \  Procedures for Full Implementations . . . . . . . . . . .  51\n       8.1.1.\
    \  Nominating Pairs  . . . . . . . . . . . . . . . . . .  51\n         8.1.1.1.\
    \  Regular Nomination  . . . . . . . . . . . . . . .  52\n         8.1.1.2.  Aggressive\
    \ Nomination . . . . . . . . . . . . . .  52\n       8.1.2.  Updating States .\
    \ . . . . . . . . . . . . . . . . . .  53\n     8.2.  Procedures for Lite Implementations\
    \ . . . . . . . . . . .  54\n       8.2.1.  Peer Is Full  . . . . . . . . . .\
    \ . . . . . . . . . .  54\n       8.2.2.  Peer Is Lite  . . . . . . . . . . .\
    \ . . . . . . . . .  55\n     8.3.  Freeing Candidates  . . . . . . . . . . .\
    \ . . . . . . . .  56\n       8.3.1.  Full Implementation Procedures  . . . .\
    \ . . . . . . .  56\n       8.3.2.  Lite Implementation Procedures  . . . . .\
    \ . . . . . .  56\n   9.  Subsequent Offer/Answer Exchanges . . . . . . . . .\
    \ . . . . .  56\n     9.1.  Generating the Offer  . . . . . . . . . . . . . .\
    \ . . . .  57\n       9.1.1.  Procedures for All Implementations  . . . . . .\
    \ . . .  57\n         9.1.1.1.  ICE Restarts  . . . . . . . . . . . . . . . .\
    \ . .  57\n         9.1.1.2.  Removing a Media Stream . . . . . . . . . . . .\
    \ .  58\n         9.1.1.3.  Adding a Media Stream . . . . . . . . . . . . . .\
    \  58\n       9.1.2.  Procedures for Full Implementations . . . . . . . . .  58\n\
    \         9.1.2.1.  Existing Media Streams with ICE Running . . . . .  58\n  \
    \       9.1.2.2.  Existing Media Streams with ICE Completed . . . .  59\n    \
    \   9.1.3.  Procedures for Lite Implementations . . . . . . . . .  59\n      \
    \   9.1.3.1.  Existing Media Streams with ICE Running . . . . .  59\n        \
    \ 9.1.3.2.  Existing Media Streams with ICE Completed . . . .  60\n     9.2. \
    \ Receiving the Offer and Generating an Answer  . . . . . .  60\n       9.2.1.\
    \  Procedures for All Implementations  . . . . . . . . .  60\n         9.2.1.1.\
    \  Detecting ICE Restart . . . . . . . . . . . . . .  60\n         9.2.1.2.  New\
    \ Media Stream  . . . . . . . . . . . . . . . .  61\n         9.2.1.3.  Removed\
    \ Media Stream  . . . . . . . . . . . . . .  61\n       9.2.2.  Procedures for\
    \ Full Implementations . . . . . . . . .  61\n         9.2.2.1.  Existing Media\
    \ Streams with ICE Running and no\n                   remote-candidates . . .\
    \ . . . . . . . . . . . . .  61\n         9.2.2.2.  Existing Media Streams with\
    \ ICE Completed and\n                   no remote-candidates  . . . . . . . .\
    \ . . . . . .  61\n         9.2.2.3.  Existing Media Streams and remote-candidates\
    \  . .  61\n       9.2.3.  Procedures for Lite Implementations . . . . . . . .\
    \ .  62\n     9.3.  Updating the Check and Valid Lists  . . . . . . . . . . .\
    \  63\n       9.3.1.  Procedures for Full Implementations . . . . . . . . .  63\n\
    \         9.3.1.1.  ICE Restarts  . . . . . . . . . . . . . . . . . .  63\n  \
    \       9.3.1.2.  New Media Stream  . . . . . . . . . . . . . . . .  63\n    \
    \     9.3.1.3.  Removed Media Stream  . . . . . . . . . . . . . .  64\n      \
    \   9.3.1.4.  ICE Continuing for Existing Media Stream  . . . .  64\n       9.3.2.\
    \  Procedures for Lite Implementations . . . . . . . . .  64\n   10. Keepalives\
    \  . . . . . . . . . . . . . . . . . . . . . . . . .  65\n   11. Media Handling\
    \  . . . . . . . . . . . . . . . . . . . . . . .  66\n     11.1. Sending Media\
    \ . . . . . . . . . . . . . . . . . . . . . .  66\n       11.1.1. Procedures for\
    \ Full Implementations . . . . . . . . .  66\n       11.1.2. Procedures for Lite\
    \ Implementations . . . . . . . . .  67\n       11.1.3. Procedures for All Implementations\
    \  . . . . . . . . .  67\n     11.2. Receiving Media . . . . . . . . . . . . .\
    \ . . . . . . . .  67\n   12. Usage with SIP  . . . . . . . . . . . . . . . .\
    \ . . . . . . .  68\n     12.1. Latency Guidelines  . . . . . . . . . . . . .\
    \ . . . . . .  68\n       12.1.1. Offer in INVITE . . . . . . . . . . . . . .\
    \ . . . . .  68\n       12.1.2. Offer in Response . . . . . . . . . . . . . .\
    \ . . . .  70\n     12.2. SIP Option Tags and Media Feature Tags  . . . . . .\
    \ . . .  70\n     12.3. Interactions with Forking . . . . . . . . . . . . . .\
    \ . .  70\n     12.4. Interactions with Preconditions . . . . . . . . . . . .\
    \ .  70\n     12.5. Interactions with Third Party Call Control  . . . . . . .\
    \  71\n   13. Relationship with ANAT  . . . . . . . . . . . . . . . . . . .  71\n\
    \   14. Extensibility Considerations  . . . . . . . . . . . . . . . .  72\n  \
    \ 15. Grammar . . . . . . . . . . . . . . . . . . . . . . . . . . .  73\n    \
    \ 15.1. \"candidate\" Attribute . . . . . . . . . . . . . . . . . .  73\n    \
    \ 15.2. \"remote-candidates\" Attribute . . . . . . . . . . . . . .  75\n    \
    \ 15.3. \"ice-lite\" and \"ice-mismatch\" Attributes  . . . . . . . .  75\n  \
    \   15.4. \"ice-ufrag\" and \"ice-pwd\" Attributes  . . . . . . . . . .  76\n\
    \     15.5. \"ice-options\" Attribute . . . . . . . . . . . . . . . . .  76\n\
    \   16. Setting Ta and RTO  . . . . . . . . . . . . . . . . . . . . .  76\n  \
    \   16.1. RTP Media Streams . . . . . . . . . . . . . . . . . . . .  77\n    \
    \ 16.2. Non-RTP Sessions  . . . . . . . . . . . . . . . . . . . .  78\n   17.\
    \ Example . . . . . . . . . . . . . . . . . . . . . . . . . . .  79\n   18. Security\
    \ Considerations . . . . . . . . . . . . . . . . . . .  85\n     18.1. Attacks\
    \ on Connectivity Checks  . . . . . . . . . . . . .  86\n     18.2. Attacks on\
    \ Server Reflexive Address Gathering . . . . . .  88\n     18.3. Attacks on Relayed\
    \ Candidate Gathering  . . . . . . . . .  89\n     18.4. Attacks on the Offer/Answer\
    \ Exchanges . . . . . . . . . .  89\n     18.5. Insider Attacks . . . . . . .\
    \ . . . . . . . . . . . . . .  90\n       18.5.1. The Voice Hammer Attack . .\
    \ . . . . . . . . . . . . .  90\n       18.5.2. STUN Amplification Attack . .\
    \ . . . . . . . . . . . .  90\n     18.6. Interactions with Application Layer\
    \ Gateways and SIP  . .  91\n   19. STUN Extensions . . . . . . . . . . . . .\
    \ . . . . . . . . . .  92\n     19.1. New Attributes  . . . . . . . . . . . .\
    \ . . . . . . . . .  92\n     19.2. New Error Response Codes  . . . . . . . .\
    \ . . . . . . . .  93\n   20. Operational Considerations  . . . . . . . . . .\
    \ . . . . . . .  93\n     20.1. NAT and Firewall Types  . . . . . . . . . . .\
    \ . . . . . .  93\n     20.2. Bandwidth Requirements  . . . . . . . . . . . .\
    \ . . . . .  93\n       20.2.1. STUN and TURN Server Capacity Planning  . . .\
    \ . . . .  93\n       20.2.2. Gathering and Connectivity Checks . . . . . . .\
    \ . . .  94\n       20.2.3. Keepalives  . . . . . . . . . . . . . . . . . . .\
    \ . .  94\n     20.3. ICE and ICE-lite  . . . . . . . . . . . . . . . . . . .\
    \ .  95\n     20.4. Troubleshooting and Performance Management  . . . . . . .\
    \  95\n     20.5. Endpoint Configuration  . . . . . . . . . . . . . . . . .  95\n\
    \   21. IANA Considerations . . . . . . . . . . . . . . . . . . . . .  96\n  \
    \   21.1. SDP Attributes  . . . . . . . . . . . . . . . . . . . . .  96\n    \
    \   21.1.1. candidate Attribute . . . . . . . . . . . . . . . . .  96\n      \
    \ 21.1.2. remote-candidates Attribute . . . . . . . . . . . . .  96\n       21.1.3.\
    \ ice-lite Attribute  . . . . . . . . . . . . . . . . .  97\n       21.1.4. ice-mismatch\
    \ Attribute  . . . . . . . . . . . . . . .  97\n       21.1.5. ice-pwd Attribute\
    \ . . . . . . . . . . . . . . . . . .  98\n       21.1.6. ice-ufrag Attribute\
    \ . . . . . . . . . . . . . . . . .  98\n       21.1.7. ice-options Attribute\
    \ . . . . . . . . . . . . . . . .  98\n     21.2. STUN Attributes . . . . . .\
    \ . . . . . . . . . . . . . . .  99\n     21.3. STUN Error Responses  . . . .\
    \ . . . . . . . . . . . . . .  99\n   22. IAB Considerations  . . . . . . . .\
    \ . . . . . . . . . . . . .  99\n     22.1. Problem Definition  . . . . . . .\
    \ . . . . . . . . . . . . 100\n     22.2. Exit Strategy . . . . . . . . . . .\
    \ . . . . . . . . . . . 100\n     22.3. Brittleness Introduced by ICE . . . .\
    \ . . . . . . . . . . 101\n     22.4. Requirements for a Long-Term Solution .\
    \ . . . . . . . . . 102\n     22.5. Issues with Existing NAPT Boxes . . . . .\
    \ . . . . . . . . 102\n   23. Acknowledgements  . . . . . . . . . . . . . . .\
    \ . . . . . . . 102\n   24. References  . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . 103\n     24.1. Normative References  . . . . . . . . . . . . .\
    \ . . . . . 103\n     24.2. Informative References  . . . . . . . . . . . . .\
    \ . . . . 104\n   Appendix A.  Lite and Full Implementations  . . . . . . . .\
    \ . . . 107\n   Appendix B.  Design Motivations . . . . . . . . . . . . . . .\
    \ . . 108\n     B.1.  Pacing of STUN Transactions . . . . . . . . . . . . . .\
    \ . 108\n     B.2.  Candidates with Multiple Bases  . . . . . . . . . . . . .\
    \ 109\n     B.3.  Purpose of the <rel-addr> and <rel-port> Attributes . . . 111\n\
    \     B.4.  Importance of the STUN Username . . . . . . . . . . . . . 111\n  \
    \   B.5.  The Candidate Pair Priority Formula . . . . . . . . . . . 113\n    \
    \ B.6.  The remote-candidates Attribute . . . . . . . . . . . . . 113\n     B.7.\
    \  Why Are Keepalives Needed?  . . . . . . . . . . . . . . . 114\n     B.8.  Why\
    \ Prefer Peer Reflexive Candidates? . . . . . . . . . . 115\n     B.9.  Why Send\
    \ an Updated Offer?  . . . . . . . . . . . . . . . 115\n     B.10. Why Are Binding\
    \ Indications Used for Keepalives?  . . . . 115\n     B.11. Why Is the Conflict\
    \ Resolution Mechanism Needed?  . . . . 116\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   RFC 3264 [RFC3264] defines a two-phase exchange of Session\n\
    \   Description Protocol (SDP) messages [RFC4566] for the purposes of\n   establishment\
    \ of multimedia sessions.  This offer/answer mechanism is\n   used by protocols\
    \ such as the Session Initiation Protocol (SIP)\n   [RFC3261].\n   Protocols using\
    \ offer/answer are difficult to operate through Network\n   Address Translators\
    \ (NATs).  Because their purpose is to establish a\n   flow of media packets,\
    \ they tend to carry the IP addresses and ports\n   of media sources and sinks\
    \ within their messages, which is known to\n   be problematic through NAT [RFC3235].\
    \  The protocols also seek to\n   create a media flow directly between participants,\
    \ so that there is\n   no application layer intermediary between them.  This is\
    \ done to\n   reduce media latency, decrease packet loss, and reduce the\n   operational\
    \ costs of deploying the application.  However, this is\n   difficult to accomplish\
    \ through NAT.  A full treatment of the reasons\n   for this is beyond the scope\
    \ of this specification.\n   Numerous solutions have been defined for allowing\
    \ these protocols to\n   operate through NAT.  These include Application Layer\
    \ Gateways\n   (ALGs), the Middlebox Control Protocol [RFC3303], the original\
    \ Simple\n   Traversal of UDP Through NAT (STUN) [RFC3489] specification, and\n\
    \   Realm Specific IP [RFC3102] [RFC3103] along with session description\n   extensions\
    \ needed to make them work, such as the Session Description\n   Protocol (SDP)\
    \ [RFC4566] attribute for the Real Time Control Protocol\n   (RTCP) [RFC3605].\
    \  Unfortunately, these techniques all have pros and\n   cons which, make each\
    \ one optimal in some network topologies, but a\n   poor choice in others.  The\
    \ result is that administrators and\n   implementors are making assumptions about\
    \ the topologies of the\n   networks in which their solutions will be deployed.\
    \  This introduces\n   complexity and brittleness into the system.  What is needed\
    \ is a\n   single solution that is flexible enough to work well in all\n   situations.\n\
    \   This specification defines Interactive Connectivity Establishment\n   (ICE)\
    \ as a technique for NAT traversal for UDP-based media streams\n   (though ICE\
    \ can be extended to handle other transport protocols, such\n   as TCP [ICE-TCP])\
    \ established by the offer/answer model.  ICE is an\n   extension to the offer/answer\
    \ model, and works by including a\n   multiplicity of IP addresses and ports in\
    \ SDP offers and answers,\n   which are then tested for connectivity by peer-to-peer\
    \ connectivity\n   checks.  The IP addresses and ports included in the SDP and\
    \ the\n   connectivity checks are performed using the revised STUN\n   specification\
    \ [RFC5389], now renamed to Session Traversal Utilities\n   for NAT.  The new\
    \ name and new specification reflect its new role as\n   a tool that is used with\
    \ other NAT traversal techniques (namely ICE)\n   rather than a standalone NAT\
    \ traversal solution, as the original STUN\n   specification was.  ICE also makes\
    \ use of Traversal Using Relays\n   around NAT (TURN) [RFC5766], an extension\
    \ to STUN.  Because ICE\n   exchanges a multiplicity of IP addresses and ports\
    \ for each media\n   stream, it also allows for address selection for multihomed\
    \ and dual-\n   stack hosts, and for this reason it deprecates RFC 4091 [RFC4091]\
    \ and\n   [RFC4092].\n"
- title: 2.  Overview of ICE
  contents:
  - "2.  Overview of ICE\n   In a typical ICE deployment, we have two endpoints (known\
    \ as AGENTS\n   in RFC 3264 terminology) that want to communicate.  They are able\
    \ to\n   communicate indirectly via some signaling protocol (such as SIP), by\n\
    \   which they can perform an offer/answer exchange of SDP [RFC3264]\n   messages.\
    \  Note that ICE is not intended for NAT traversal for SIP,\n   which is assumed\
    \ to be provided via another mechanism [RFC5626].  At\n   the beginning of the\
    \ ICE process, the agents are ignorant of their\n   own topologies.  In particular,\
    \ they might or might not be behind a\n   NAT (or multiple tiers of NATs).  ICE\
    \ allows the agents to discover\n   enough information about their topologies\
    \ to potentially find one or\n   more paths by which they can communicate.\n \
    \  Figure 1 shows a typical environment for ICE deployment.  The two\n   endpoints\
    \ are labelled L and R (for left and right, which helps\n   visualize call flows).\
    \  Both L and R are behind their own respective\n   NATs though they may not be\
    \ aware of it.  The type of NAT and its\n   properties are also unknown.  Agents\
    \ L and R are capable of engaging\n   in an offer/answer exchange by which they\
    \ can exchange SDP messages,\n   whose purpose is to set up a media session between\
    \ L and R.\n   Typically, this exchange will occur through a SIP server.\n   In\
    \ addition to the agents, a SIP server and NATs, ICE is typically\n   used in\
    \ concert with STUN or TURN servers in the network.  Each agent\n   can have its\
    \ own STUN or TURN server, or they can be the same.\n                        \
    \      +-------+\n                              | SIP   |\n           +-------+\
    \          | Srvr  |          +-------+\n           | STUN  |          |     \
    \  |          | STUN  |\n           | Srvr  |          +-------+          | Srvr\
    \  |\n           |       |         /         \\         |       |\n          \
    \ +-------+        /           \\        +-------+\n                         \
    \  /             \\\n                          /               \\\n          \
    \               /                 \\\n                        /              \
    \     \\\n                       /  <-  Signaling  ->  \\\n                  \
    \    /                       \\\n                     /                      \
    \   \\\n               +--------+                   +--------+\n             \
    \  |  NAT   |                   |  NAT   |\n               +--------+        \
    \           +--------+\n                 /                                \\\n\
    \                /                                  \\\n               /     \
    \                               \\\n           +-------+                     \
    \        +-------+\n           | Agent |                             | Agent |\n\
    \           |   L   |                             |   R   |\n           |    \
    \   |                             |       |\n           +-------+            \
    \                 +-------+\n                     Figure 1: ICE Deployment Scenario\n\
    \   The basic idea behind ICE is as follows: each agent has a variety of\n   candidate\
    \ TRANSPORT ADDRESSES (combination of IP address and port for\n   a particular\
    \ transport protocol, which is always UDP in this\n   specification)) it could\
    \ use to communicate with the other agent.\n   These might include:\n   o  A transport\
    \ address on a directly attached network interface\n   o  A translated transport\
    \ address on the public side of a NAT (a\n      \"server reflexive\" address)\n\
    \   o  A transport address allocated from a TURN server (a \"relayed\n      address\"\
    ).\n   Potentially, any of L's candidate transport addresses can be used to\n\
    \   communicate with any of R's candidate transport addresses.  In\n   practice,\
    \ however, many combinations will not work.  For instance, if\n   L and R are\
    \ both behind NATs, their directly attached interface\n   addresses are unlikely\
    \ to be able to communicate directly (this is\n   why ICE is needed, after all!).\
    \  The purpose of ICE is to discover\n   which pairs of addresses will work. \
    \ The way that ICE does this is to\n   systematically try all possible pairs (in\
    \ a carefully sorted order)\n   until it finds one or more that work.\n"
- title: 2.1.  Gathering Candidate Addresses
  contents:
  - "2.1.  Gathering Candidate Addresses\n   In order to execute ICE, an agent has\
    \ to identify all of its address\n   candidates.  A CANDIDATE is a transport address\
    \ -- a combination of\n   IP address and port for a particular transport protocol\
    \ (with only\n   UDP specified here).  This document defines three types of\n\
    \   candidates, some derived from physical or logical network interfaces,\n  \
    \ others discoverable via STUN and TURN.  Naturally, one viable\n   candidate\
    \ is a transport address obtained directly from a local\n   interface.  Such a\
    \ candidate is called a HOST CANDIDATE.  The local\n   interface could be ethernet\
    \ or WiFi, or it could be one that is\n   obtained through a tunnel mechanism,\
    \ such as a Virtual Private\n   Network (VPN) or Mobile IP (MIP).  In all cases,\
    \ such a network\n   interface appears to the agent as a local interface from\
    \ which ports\n   (and thus candidates) can be allocated.\n   If an agent is multihomed,\
    \ it obtains a candidate from each IP\n   address.  Depending on the location\
    \ of the PEER (the other agent in\n   the session) on the IP network relative\
    \ to the agent, the agent may\n   be reachable by the peer through one or more\
    \ of those IP addresses.\n   Consider, for example, an agent that has a local\
    \ IP address on a\n   private net 10 network (I1), and a second connected to the\
    \ public\n   Internet (I2).  A candidate from I1 will be directly reachable when\n\
    \   communicating with a peer on the same private net 10 network, while a\n  \
    \ candidate from I2 will be directly reachable when communicating with\n   a peer\
    \ on the public Internet.  Rather than trying to guess which IP\n   address will\
    \ work prior to sending an offer, the offering agent\n   includes both candidates\
    \ in its offer.\n   Next, the agent uses STUN or TURN to obtain additional candidates.\n\
    \   These come in two flavors: translated addresses on the public side of\n  \
    \ a NAT (SERVER REFLEXIVE CANDIDATES) and addresses on TURN servers\n   (RELAYED\
    \ CANDIDATES).  When TURN servers are utilized, both types of\n   candidates are\
    \ obtained from the TURN server.  If only STUN servers\n   are utilized, only\
    \ server reflexive candidates are obtained from\n   them.  The relationship of\
    \ these candidates to the host candidate is\n   shown in Figure 2.  In this figure,\
    \ both types of candidates are\n   discovered using TURN.  In the figure, the\
    \ notation X:x means IP\n   address X and UDP port x.\n                 To Internet\n\
    \                     |\n                     |\n                     |  /------------\
    \  Relayed\n                 Y:y | /               Address\n                 +--------+\n\
    \                 |        |\n                 |  TURN  |\n                 |\
    \ Server |\n                 |        |\n                 +--------+\n       \
    \              |\n                     |\n                     | /------------\
    \  Server\n              X1':x1'|/               Reflexive\n               +------------+\
    \         Address\n               |    NAT     |\n               +------------+\n\
    \                     |\n                     | /------------  Local\n       \
    \          X:x |/               Address\n                 +--------+\n       \
    \          |        |\n                 | Agent  |\n                 |       \
    \ |\n                 +--------+\n                     Figure 2: Candidate Relationships\n\
    \   When the agent sends the TURN Allocate request from IP address and\n   port\
    \ X:x, the NAT (assuming there is one) will create a binding\n   X1':x1', mapping\
    \ this server reflexive candidate to the host\n   candidate X:x.  Outgoing packets\
    \ sent from the host candidate will be\n   translated by the NAT to the server\
    \ reflexive candidate.  Incoming\n   packets sent to the server reflexive candidate\
    \ will be translated by\n   the NAT to the host candidate and forwarded to the\
    \ agent.  We call\n   the host candidate associated with a given server reflexive\
    \ candidate\n   the BASE.\n      Note: \"Base\" refers to the address an agent\
    \ sends from for a\n      particular candidate.  Thus, as a degenerate case host\
    \ candidates\n      also have a base, but it's the same as the host candidate.\n\
    \   When there are multiple NATs between the agent and the TURN server,\n   the\
    \ TURN request will create a binding on each NAT, but only the\n   outermost server\
    \ reflexive candidate (the one nearest the TURN\n   server) will be discovered\
    \ by the agent.  If the agent is not behind\n   a NAT, then the base candidate\
    \ will be the same as the server\n   reflexive candidate and the server reflexive\
    \ candidate is redundant\n   and will be eliminated.\n   The Allocate request\
    \ then arrives at the TURN server.  The TURN\n   server allocates a port y from\
    \ its local IP address Y, and generates\n   an Allocate response, informing the\
    \ agent of this relayed candidate.\n   The TURN server also informs the agent\
    \ of the server reflexive\n   candidate, X1':x1' by copying the source transport\
    \ address of the\n   Allocate request into the Allocate response.  The TURN server\
    \ acts as\n   a packet relay, forwarding traffic between L and R. In order to\
    \ send\n   traffic to L, R sends traffic to the TURN server at Y:y, and the TURN\n\
    \   server forwards that to X1':x1', which passes through the NAT where\n   it\
    \ is mapped to X:x and delivered to L.\n   When only STUN servers are utilized,\
    \ the agent sends a STUN Binding\n   request [RFC5389] to its STUN server.  The\
    \ STUN server will inform\n   the agent of the server reflexive candidate X1':x1'\
    \ by copying the\n   source transport address of the Binding request into the\
    \ Binding\n   response.\n"
- title: 2.2.  Connectivity Checks
  contents:
  - "2.2.  Connectivity Checks\n   Once L has gathered all of its candidates, it orders\
    \ them in highest\n   to lowest priority and sends them to R over the signaling\
    \ channel.\n   The candidates are carried in attributes in the SDP offer.  When\
    \ R\n   receives the offer, it performs the same gathering process and\n   responds\
    \ with its own list of candidates.  At the end of this\n   process, each agent\
    \ has a complete list of both its candidates and\n   its peer's candidates.  It\
    \ pairs them up, resulting in CANDIDATE\n   PAIRS.  To see which pairs work, each\
    \ agent schedules a series of\n   CHECKS.  Each check is a STUN request/response\
    \ transaction that the\n   client will perform on a particular candidate pair\
    \ by sending a STUN\n   request from the local candidate to the remote candidate.\n\
    \   The basic principle of the connectivity checks is simple:\n   1.  Sort the\
    \ candidate pairs in priority order.\n   2.  Send checks on each candidate pair\
    \ in priority order.\n   3.  Acknowledge checks received from the other agent.\n\
    \   With both agents performing a check on a candidate pair, the result\n   is\
    \ a 4-way handshake:\n   L                        R\n   -                    \
    \    -\n   STUN request ->             \\  L's\n             <- STUN response\
    \  /  check\n              <- STUN request  \\  R's\n   STUN response ->     \
    \       /  check\n                    Figure 3: Basic Connectivity Check\n   It\
    \ is important to note that the STUN requests are sent to and from\n   the exact\
    \ same IP addresses and ports that will be used for media\n   (e.g., RTP and RTCP).\
    \  Consequently, agents demultiplex STUN and RTP/\n   RTCP using contents of the\
    \ packets, rather than the port on which\n   they are received.  Fortunately,\
    \ this demultiplexing is easy to do,\n   especially for RTP and RTCP.\n   Because\
    \ a STUN Binding request is used for the connectivity check,\n   the STUN Binding\
    \ response will contain the agent's translated\n   transport address on the public\
    \ side of any NATs between the agent\n   and its peer.  If this transport address\
    \ is different from other\n   candidates the agent already learned, it represents\
    \ a new candidate,\n   called a PEER REFLEXIVE CANDIDATE, which then gets tested\
    \ by ICE just\n   the same as any other candidate.\n   As an optimization, as\
    \ soon as R gets L's check message, R schedules\n   a connectivity check message\
    \ to be sent to L on the same candidate\n   pair.  This accelerates the process\
    \ of finding a valid candidate, and\n   is called a TRIGGERED CHECK.\n   At the\
    \ end of this handshake, both L and R know that they can send\n   (and receive)\
    \ messages end-to-end in both directions.\n"
- title: 2.3.  Sorting Candidates
  contents:
  - "2.3.  Sorting Candidates\n   Because the algorithm above searches all candidate\
    \ pairs, if a\n   working pair exists it will eventually find it no matter what\
    \ order\n   the candidates are tried in.  In order to produce faster (and better)\n\
    \   results, the candidates are sorted in a specified order.  The\n   resulting\
    \ list of sorted candidate pairs is called the CHECK LIST.\n   The algorithm is\
    \ described in Section 4.1.2 but follows two general\n   principles:\n   o  Each\
    \ agent gives its candidates a numeric priority, which is sent\n      along with\
    \ the candidate to the peer.\n   o  The local and remote priorities are combined\
    \ so that each agent\n      has the same ordering for the candidate pairs.\n \
    \  The second property is important for getting ICE to work when there\n   are\
    \ NATs in front of L and R.  Frequently, NATs will not allow\n   packets in from\
    \ a host until the agent behind the NAT has sent a\n   packet towards that host.\
    \  Consequently, ICE checks in each direction\n   will not succeed until both\
    \ sides have sent a check through their\n   respective NATs.\n   The agent works\
    \ through this check list by sending a STUN request for\n   the next candidate\
    \ pair on the list periodically.  These are called\n   ORDINARY CHECKS.\n   In\
    \ general, the priority algorithm is designed so that candidates of\n   similar\
    \ type get similar priorities and so that more direct routes\n   (that is, through\
    \ fewer media relays and through fewer NATs) are\n   preferred over indirect ones\
    \ (ones with more media relays and more\n   NATs).  Within those guidelines, however,\
    \ agents have a fair amount\n   of discretion about how to tune their algorithms.\n"
- title: 2.4.  Frozen Candidates
  contents:
  - "2.4.  Frozen Candidates\n   The previous description only addresses the case\
    \ where the agents\n   wish to establish a media session with one COMPONENT (a\
    \ piece of a\n   media stream requiring a single transport address; a media stream\
    \ may\n   require multiple components, each of which has to work for the media\n\
    \   stream as a whole to be work).  Typically (e.g., with RTP and RTCP),\n   the\
    \ agents actually need to establish connectivity for more than one\n   flow.\n\
    \   The network properties are likely to be very similar for each\n   component\
    \ (especially because RTP and RTCP are sent and received from\n   the same IP\
    \ address).  It is usually possible to leverage information\n   from one media\
    \ component in order to determine the best candidates\n   for another.  ICE does\
    \ this with a mechanism called \"frozen\n   candidates\".\n   Each candidate is\
    \ associated with a property called its FOUNDATION.\n   Two candidates have the\
    \ same foundation when they are \"similar\" -- of\n   the same type and obtained\
    \ from the same host candidate and STUN\n   server using the same protocol.  Otherwise,\
    \ their foundation is\n   different.  A candidate pair has a foundation too, which\
    \ is just the\n   concatenation of the foundations of its two candidates.  Initially,\n\
    \   only the candidate pairs with unique foundations are tested.  The\n   other\
    \ candidate pairs are marked \"frozen\".  When the connectivity\n   checks for\
    \ a candidate pair succeed, the other candidate pairs with\n   the same foundation\
    \ are unfrozen.  This avoids repeated checking of\n   components that are superficially\
    \ more attractive but in fact are\n   likely to fail.\n   While we've described\
    \ \"frozen\" here as a separate mechanism for\n   expository purposes, in fact\
    \ it is an integral part of ICE and the\n   ICE prioritization algorithm automatically\
    \ ensures that the right\n   candidates are unfrozen and checked in the right\
    \ order.\n"
- title: 2.5.  Security for Checks
  contents:
  - "2.5.  Security for Checks\n   Because ICE is used to discover which addresses\
    \ can be used to send\n   media between two agents, it is important to ensure\
    \ that the process\n   cannot be hijacked to send media to the wrong location.\
    \  Each STUN\n   connectivity check is covered by a message authentication code\
    \ (MAC)\n   computed using a key exchanged in the signaling channel.  This MAC\n\
    \   provides message integrity and data origin authentication, thus\n   stopping\
    \ an attacker from forging or modifying connectivity check\n   messages.  Furthermore,\
    \ if the SIP [RFC3261] caller is using ICE, and\n   their call forks, the ICE\
    \ exchanges happen independently with each\n   forked recipient.  In such a case,\
    \ the keys exchanged in the\n   signaling help associate each ICE exchange with\
    \ each forked\n   recipient.\n"
- title: 2.6.  Concluding ICE
  contents:
  - "2.6.  Concluding ICE\n   ICE checks are performed in a specific sequence, so\
    \ that high-\n   priority candidate pairs are checked first, followed by lower-\n\
    \   priority ones.  One way to conclude ICE is to declare victory as soon\n  \
    \ as a check for each component of each media stream completes\n   successfully.\
    \  Indeed, this is a reasonable algorithm, and details\n   for it are provided\
    \ below.  However, it is possible that a packet\n   loss will cause a higher-priority\
    \ check to take longer to complete.\n   In that case, allowing ICE to run a little\
    \ longer might produce\n   better results.  More fundamentally, however, the prioritization\n\
    \   defined by this specification may not yield \"optimal\" results.  As an\n\
    \   example, if the aim is to select low-latency media paths, usage of a\n   relay\
    \ is a hint that latencies may be higher, but it is nothing more\n   than a hint.\
    \  An actual round-trip time (RTT) measurement could be\n   made, and it might\
    \ demonstrate that a pair with lower priority is\n   actually better than one\
    \ with higher priority.\n   Consequently, ICE assigns one of the agents in the\
    \ role of the\n   CONTROLLING AGENT, and the other of the CONTROLLED AGENT.  The\n\
    \   controlling agent gets to nominate which candidate pairs will get\n   used\
    \ for media amongst the ones that are valid.  It can do this in\n   one of two\
    \ ways -- using REGULAR NOMINATION or AGGRESSIVE NOMINATION.\n   With regular\
    \ nomination, the controlling agent lets the checks\n   continue until at least\
    \ one valid candidate pair for each media\n   stream is found.  Then, it picks\
    \ amongst those that are valid, and\n   sends a second STUN request on its NOMINATED\
    \ candidate pair, but this\n   time with a flag set to tell the peer that this\
    \ pair has been\n   nominated for use.  This is shown in Figure 4.\n   L     \
    \                   R\n   -                        -\n   STUN request ->     \
    \        \\  L's\n             <- STUN response  /  check\n              <- STUN\
    \ request  \\  R's\n   STUN response ->            /  check\n   STUN request +\
    \ flag ->      \\  L's\n             <- STUN response  /  check\n            \
    \           Figure 4: Regular Nomination\n   Once the STUN transaction with the\
    \ flag completes, both sides cancel\n   any future checks for that media stream.\
    \  ICE will now send media\n   using this pair.  The pair an ICE agent is using\
    \ for media is called\n   the SELECTED PAIR.\n   In aggressive nomination, the\
    \ controlling agent puts the flag in\n   every STUN request it sends.  This way,\
    \ once the first check\n   succeeds, ICE processing is complete for that media\
    \ stream and the\n   controlling agent doesn't have to send a second STUN request.\
    \  The\n   selected pair will be the highest-priority valid pair whose check\n\
    \   succeeded.  Aggressive nomination is faster than regular nomination,\n   but\
    \ gives less flexibility.  Aggressive nomination is shown in\n   Figure 5.\n \
    \  L                        R\n   -                        -\n   STUN request\
    \ + flag ->      \\  L's\n             <- STUN response  /  check\n          \
    \    <- STUN request  \\  R's\n   STUN response ->            /  check\n     \
    \                 Figure 5: Aggressive Nomination\n   Once all of the media streams\
    \ are completed, the controlling endpoint\n   sends an updated offer if the candidates\
    \ in the m and c lines for the\n   media stream (called the DEFAULT CANDIDATES)\
    \ don't match ICE's\n   SELECTED CANDIDATES.\n   Once ICE is concluded, it can\
    \ be restarted at any time for one or all\n   of the media streams by either agent.\
    \  This is done by sending an\n   updated offer indicating a restart.\n"
- title: 2.7.  Lite Implementations
  contents:
  - "2.7.  Lite Implementations\n   In order for ICE to be used in a call, both agents\
    \ need to support\n   it.  However, certain agents will always be connected to\
    \ the public\n   Internet and have a public IP address at which it can receive\
    \ packets\n   from any correspondent.  To make it easier for these devices to\n\
    \   support ICE, ICE defines a special type of implementation called LITE\n  \
    \ (in contrast to the normal FULL implementation).  A lite\n   implementation\
    \ doesn't gather candidates; it includes only host\n   candidates for any media\
    \ stream.  Lite agents do not generate\n   connectivity checks or run the state\
    \ machines, though they need to be\n   able to respond to connectivity checks.\
    \  When a lite implementation\n   connects with a full implementation, the full\
    \ agent takes the role of\n   the controlling agent, and the lite agent takes\
    \ on the controlled\n   role.  When two lite implementations connect, no checks\
    \ are sent.\n   For guidance on when a lite implementation is appropriate, see\
    \ the\n   discussion in Appendix A.\n   It is important to note that the lite\
    \ implementation was added to\n   this specification to provide a stepping stone\
    \ to full\n   implementation.  Even for devices that are always connected to the\n\
    \   public Internet, a full implementation is preferable if achievable.\n"
- title: 3.  Terminology
  contents:
  - "3.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC\
    \ 2119 [RFC2119].\n   Readers should be familiar with the terminology defined\
    \ in the offer/\n   answer model [RFC3264], STUN [RFC5389], and NAT Behavioral\n\
    \   requirements for UDP [RFC4787].\n   This specification makes use of the following\
    \ additional terminology:\n   Agent:  As defined in RFC 3264, an agent is the\
    \ protocol\n      implementation involved in the offer/answer exchange.  There\
    \ are\n      two agents involved in an offer/answer exchange.\n   Peer:  From\
    \ the perspective of one of the agents in a session, its\n      peer is the other\
    \ agent.  Specifically, from the perspective of\n      the offerer, the peer is\
    \ the answerer.  From the perspective of\n      the answerer, the peer is the\
    \ offerer.\n   Transport Address:  The combination of an IP address and transport\n\
    \      protocol (such as UDP or TCP) port.\n   Candidate:  A transport address\
    \ that is a potential point of contact\n      for receipt of media.  Candidates\
    \ also have properties -- their\n      type (server reflexive, relayed or host),\
    \ priority, foundation,\n      and base.\n   Component:  A component is a piece\
    \ of a media stream requiring a\n      single transport address; a media stream\
    \ may require multiple\n      components, each of which has to work for the media\
    \ stream as a\n      whole to work.  For media streams based on RTP, there are\
    \ two\n      components per media stream -- one for RTP, and one for RTCP.\n \
    \  Host Candidate:  A candidate obtained by binding to a specific port\n     \
    \ from an IP address on the host.  This includes IP addresses on\n      physical\
    \ interfaces and logical ones, such as ones obtained\n      through Virtual Private\
    \ Networks (VPNs) and Realm Specific IP\n      (RSIP) [RFC3102] (which lives at\
    \ the operating system level).\n   Server Reflexive Candidate:  A candidate whose\
    \ IP address and port\n      are a binding allocated by a NAT for an agent when\
    \ it sent a\n      packet through the NAT to a server.  Server reflexive candidates\n\
    \      can be learned by STUN servers using the Binding request, or TURN\n   \
    \   servers, which provides both a relayed and server reflexive\n      candidate.\n\
    \   Peer Reflexive Candidate:  A candidate whose IP address and port are\n   \
    \   a binding allocated by a NAT for an agent when it sent a STUN\n      Binding\
    \ request through the NAT to its peer.\n   Relayed Candidate:  A candidate obtained\
    \ by sending a TURN Allocate\n      request from a host candidate to a TURN server.\
    \  The relayed\n      candidate is resident on the TURN server, and the TURN server\n\
    \      relays packets back towards the agent.\n   Base:  The base of a server\
    \ reflexive candidate is the host candidate\n      from which it was derived.\
    \  A host candidate is also said to have\n      a base, equal to that candidate\
    \ itself.  Similarly, the base of a\n      relayed candidate is that candidate\
    \ itself.\n   Foundation:  An arbitrary string that is the same for two candidates\n\
    \      that have the same type, base IP address, protocol (UDP, TCP,\n      etc.),\
    \ and STUN or TURN server.  If any of these are different,\n      then the foundation\
    \ will be different.  Two candidate pairs with\n      the same foundation pairs\
    \ are likely to have similar network\n      characteristics.  Foundations are\
    \ used in the frozen algorithm.\n   Local Candidate:  A candidate that an agent\
    \ has obtained and included\n      in an offer or answer it sent.\n   Remote Candidate:\
    \  A candidate that an agent received in an offer or\n      answer from its peer.\n\
    \   Default Destination/Candidate:  The default destination for a\n      component\
    \ of a media stream is the transport address that would be\n      used by an agent\
    \ that is not ICE aware.  For the RTP component,\n      the default IP address\
    \ is in the c line of the SDP, and the port\n      is in the m line.  For the\
    \ RTCP component, it is in the rtcp\n      attribute when present, and when not\
    \ present, the IP address is in\n      the c line and 1 plus the port is in the\
    \ m line.  A default\n      candidate for a component is one whose transport address\
    \ matches\n      the default destination for that component.\n   Candidate Pair:\
    \  A pairing containing a local candidate and a remote\n      candidate.\n   Check,\
    \ Connectivity Check, STUN Check:  A STUN Binding request\n      transaction for\
    \ the purposes of verifying connectivity.  A check\n      is sent from the local\
    \ candidate to the remote candidate of a\n      candidate pair.\n   Check List:\
    \  An ordered set of candidate pairs that an agent will use\n      to generate\
    \ checks.\n   Ordinary Check:  A connectivity check generated by an agent as a\n\
    \      consequence of a timer that fires periodically, instructing it to\n   \
    \   send a check.\n   Triggered Check:  A connectivity check generated as a consequence\
    \ of\n      the receipt of a connectivity check from the peer.\n   Valid List:\
    \  An ordered set of candidate pairs for a media stream\n      that have been\
    \ validated by a successful STUN transaction.\n   Full:  An ICE implementation\
    \ that performs the complete set of\n      functionality defined by this specification.\n\
    \   Lite:  An ICE implementation that omits certain functions,\n      implementing\
    \ only as much as is necessary for a peer\n      implementation that is full to\
    \ gain the benefits of ICE.  Lite\n      implementations do not maintain any of\
    \ the state machines and do\n      not generate connectivity checks.\n   Controlling\
    \ Agent:  The ICE agent that is responsible for selecting\n      the final choice\
    \ of candidate pairs and signaling them through\n      STUN and an updated offer,\
    \ if needed.  In any session, one agent\n      is always controlling.  The other\
    \ is the controlled agent.\n   Controlled Agent:  An ICE agent that waits for\
    \ the controlling agent\n      to select the final choice of candidate pairs.\n\
    \   Regular Nomination:  The process of picking a valid candidate pair\n     \
    \ for media traffic by validating the pair with one STUN request,\n      and then\
    \ picking it by sending a second STUN request with a flag\n      indicating its\
    \ nomination.\n   Aggressive Nomination:  The process of picking a valid candidate\
    \ pair\n      for media traffic by including a flag in every STUN request, such\n\
    \      that the first one to produce a valid candidate pair is used for\n    \
    \  media.\n   Nominated:  If a valid candidate pair has its nominated flag set,\
    \ it\n      means that it may be selected by ICE for sending and receiving\n \
    \     media.\n   Selected Pair, Selected Candidate:  The candidate pair selected\
    \ by\n      ICE for sending and receiving media is called the selected pair,\n\
    \      and each of its candidates is called the selected candidate.\n"
- title: 4.  Sending the Initial Offer
  contents:
  - "4.  Sending the Initial Offer\n   In order to send the initial offer in an offer/answer\
    \ exchange, an\n   agent must (1) gather candidates, (2) prioritize them, (3)\
    \ eliminate\n   redundant candidates, (4) choose default candidates, and then\
    \ (5)\n   formulate and send the SDP offer.  All but the last of these five\n\
    \   steps differ for full and lite implementations.\n"
- title: 4.1.  Full Implementation Requirements
  contents:
  - '4.1.  Full Implementation Requirements

    '
- title: 4.1.1.  Gathering Candidates
  contents:
  - "4.1.1.  Gathering Candidates\n   An agent gathers candidates when it believes\
    \ that communication is\n   imminent.  An offerer can do this based on a user\
    \ interface cue, or\n   based on an explicit request to initiate a session.  Every\
    \ candidate\n   is a transport address.  It also has a type and a base.  Four\
    \ types\n   are defined and gathered by this specification -- host candidates,\n\
    \   server reflexive candidates, peer reflexive candidates, and relayed\n   candidates.\
    \  The server reflexive candidates are gathered using STUN\n   or TURN, and relayed\
    \ candidates are obtained through TURN.  Peer\n   reflexive candidates are obtained\
    \ in later phases of ICE, as a\n   consequence of connectivity checks.  The base\
    \ of a candidate is the\n   candidate that an agent must send from when using\
    \ that candidate.\n"
- title: 4.1.1.1.  Host Candidates
  contents:
  - "4.1.1.1.  Host Candidates\n   The first step is to gather host candidates.  Host\
    \ candidates are\n   obtained by binding to ports (typically ephemeral) on a IP\
    \ address\n   attached to an interface (physical or virtual, including VPN\n \
    \  interfaces) on the host.\n   For each UDP media stream the agent wishes to\
    \ use, the agent SHOULD\n   obtain a candidate for each component of the media\
    \ stream on each IP\n   address that the host has.  It obtains each candidate\
    \ by binding to a\n   UDP port on the specific IP address.  A host candidate (and\
    \ indeed\n   every candidate) is always associated with a specific component for\n\
    \   which it is a candidate.  Each component has an ID assigned to it,\n   called\
    \ the component ID.  For RTP-based media streams, the RTP itself\n   has a component\
    \ ID of 1, and RTCP a component ID of 2.  If an agent\n   is using RTCP, it MUST\
    \ obtain a candidate for it.  If an agent is\n   using both RTP and RTCP, it would\
    \ end up with 2*K host candidates if\n   an agent has K IP addresses.\n   The\
    \ base for each host candidate is set to the candidate itself.\n"
- title: 4.1.1.2.  Server Reflexive and Relayed Candidates
  contents:
  - "4.1.1.2.  Server Reflexive and Relayed Candidates\n   Agents SHOULD obtain relayed\
    \ candidates and SHOULD obtain server\n   reflexive candidates.  These requirements\
    \ are at SHOULD strength to\n   allow for provider variation.  Use of STUN and\
    \ TURN servers may be\n   unnecessary in closed networks where agents are never\
    \ connected to\n   the public Internet or to endpoints outside of the closed network.\n\
    \   In such cases, a full implementation would be used for agents that\n   are\
    \ dual stack or multihomed, to select a host candidate.  Use of\n   TURN servers\
    \ is expensive, and when ICE is being used, they will only\n   be utilized when\
    \ both endpoints are behind NATs that perform address\n   and port dependent mapping.\
    \  Consequently, some deployments might\n   consider this use case to be marginal,\
    \ and elect not to use TURN\n   servers.  If an agent does not gather server reflexive\
    \ or relayed\n   candidates, it is RECOMMENDED that the functionality be implemented\n\
    \   and just disabled through configuration, so that it can be re-enabled\n  \
    \ through configuration if conditions change in the future.\n   If an agent is\
    \ gathering both relayed and server reflexive\n   candidates, it uses a TURN server.\
    \  If it is gathering just server\n   reflexive candidates, it uses a STUN server.\n\
    \   The agent next pairs each host candidate with the STUN or TURN server\n  \
    \ with which it is configured or has discovered by some means.  If a\n   STUN\
    \ or TURN server is configured, it is RECOMMENDED that a domain\n   name be configured,\
    \ and the DNS procedures in [RFC5389] (using SRV\n   records with the \"stun\"\
    \ service) be used to discover the STUN server,\n   and the DNS procedures in\
    \ [RFC5766] (using SRV records with the\n   \"turn\" service) be used to discover\
    \ the TURN server.\n   This specification only considers usage of a single STUN\
    \ or TURN\n   server.  When there are multiple choices for that single STUN or\
    \ TURN\n   server (when, for example, they are learned through DNS records and\n\
    \   multiple results are returned), an agent SHOULD use a single STUN or\n   TURN\
    \ server (based on its IP address) for all candidates for a\n   particular session.\
    \  This improves the performance of ICE.  The\n   result is a set of pairs of\
    \ host candidates with STUN or TURN\n   servers.  The agent then chooses one pair,\
    \ and sends a Binding or\n   Allocate request to the server from that host candidate.\
    \  Binding\n   requests to a STUN server are not authenticated, and any ALTERNATE-\n\
    \   SERVER attribute in a response is ignored.  Agents MUST support the\n   backwards\
    \ compatibility mode for the Binding request defined in\n   [RFC5389].  Allocate\
    \ requests SHOULD be authenticated using a long-\n   term credential obtained\
    \ by the client through some other means.\n   Every Ta milliseconds thereafter,\
    \ the agent can generate another new\n   STUN or TURN transaction.  This transaction\
    \ can either be a retry of\n   a previous transaction that failed with a recoverable\
    \ error (such as\n   authentication failure), or a transaction for a new host\
    \ candidate\n   and STUN or TURN server pair.  The agent SHOULD NOT generate\n\
    \   transactions more frequently than one every Ta milliseconds.  See\n   Section\
    \ 16 for guidance on how to set Ta and the STUN retransmit\n   timer, RTO.\n \
    \  The agent will receive a Binding or Allocate response.  A successful\n   Allocate\
    \ response will provide the agent with a server reflexive\n   candidate (obtained\
    \ from the mapped address) and a relayed candidate\n   in the XOR-RELAYED-ADDRESS\
    \ attribute.  If the Allocate request is\n   rejected because the server lacks\
    \ resources to fulfill it, the agent\n   SHOULD instead send a Binding request\
    \ to obtain a server reflexive\n   candidate.  A Binding response will provide\
    \ the agent with only a\n   server reflexive candidate (also obtained from the\
    \ mapped address).\n   The base of the server reflexive candidate is the host\
    \ candidate from\n   which the Allocate or Binding request was sent.  The base\
    \ of a\n   relayed candidate is that candidate itself.  If a relayed candidate\n\
    \   is identical to a host candidate (which can happen in rare cases),\n   the\
    \ relayed candidate MUST be discarded.\n"
- title: 4.1.1.3.  Computing Foundations
  contents:
  - "4.1.1.3.  Computing Foundations\n   Finally, the agent assigns each candidate\
    \ a foundation.  The\n   foundation is an identifier, scoped within a session.\
    \  Two candidates\n   MUST have the same foundation ID when all of the following\
    \ are true:\n   o  they are of the same type (host, relayed, server reflexive,\
    \ or\n      peer reflexive).\n   o  their bases have the same IP address (the\
    \ ports can be different).\n   o  for reflexive and relayed candidates, the STUN\
    \ or TURN servers\n      used to obtain them have the same IP address.\n   o \
    \ they were obtained using the same transport protocol (TCP, UDP,\n      etc.).\n\
    \   Similarly, two candidates MUST have different foundations if their\n   types\
    \ are different, their bases have different IP addresses, the\n   STUN or TURN\
    \ servers used to obtain them have different IP addresses,\n   or their transport\
    \ protocols are different.\n"
- title: 4.1.1.4.  Keeping Candidates Alive
  contents:
  - "4.1.1.4.  Keeping Candidates Alive\n   Once server reflexive and relayed candidates\
    \ are allocated, they MUST\n   be kept alive until ICE processing has completed,\
    \ as described in\n   Section 8.3.  For server reflexive candidates learned through\
    \ a\n   Binding request, the bindings MUST be kept alive by additional\n   Binding\
    \ requests to the server.  Refreshes for allocations are done\n   using the Refresh\
    \ transaction, as described in [RFC5766].  The\n   Refresh requests will also\
    \ refresh the server reflexive candidate.\n"
- title: 4.1.2.  Prioritizing Candidates
  contents:
  - "4.1.2.  Prioritizing Candidates\n   The prioritization process results in the\
    \ assignment of a priority to\n   each candidate.  Each candidate for a media\
    \ stream MUST have a unique\n   priority that MUST be a positive integer between\
    \ 1 and (2**31 - 1).\n   This priority will be used by ICE to determine the order\
    \ of the\n   connectivity checks and the relative preference for candidates.\n\
    \   An agent SHOULD compute this priority using the formula in\n   Section 4.1.2.1\
    \ and choose its parameters using the guidelines in\n   Section 4.1.2.2.  If an\
    \ agent elects to use a different formula, ICE\n   will take longer to converge\
    \ since both agents will not be\n   coordinated in their checks.\n"
- title: 4.1.2.1.  Recommended Formula
  contents:
  - "4.1.2.1.  Recommended Formula\n   When using the formula, an agent computes the\
    \ priority by determining\n   a preference for each type of candidate (server\
    \ reflexive, peer\n   reflexive, relayed, and host), and, when the agent is multihomed,\n\
    \   choosing a preference for its IP addresses.  These two preferences\n   are\
    \ then combined to compute the priority for a candidate.  That\n   priority is\
    \ computed using the following formula:\n   priority = (2^24)*(type preference)\
    \ +\n              (2^8)*(local preference) +\n              (2^0)*(256 - component\
    \ ID)\n   The type preference MUST be an integer from 0 to 126 inclusive, and\n\
    \   represents the preference for the type of the candidate (where the\n   types\
    \ are local, server reflexive, peer reflexive, and relayed).  A\n   126 is the\
    \ highest preference, and a 0 is the lowest.  Setting the\n   value to a 0 means\
    \ that candidates of this type will only be used as\n   a last resort.  The type\
    \ preference MUST be identical for all\n   candidates of the same type and MUST\
    \ be different for candidates of\n   different types.  The type preference for\
    \ peer reflexive candidates\n   MUST be higher than that of server reflexive candidates.\
    \  Note that\n   candidates gathered based on the procedures of Section 4.1.1\
    \ will\n   never be peer reflexive candidates; candidates of these type are\n\
    \   learned from the connectivity checks performed by ICE.\n   The local preference\
    \ MUST be an integer from 0 to 65535 inclusive.\n   It represents a preference\
    \ for the particular IP address from which\n   the candidate was obtained, in\
    \ cases where an agent is multihomed.\n   65535 represents the highest preference,\
    \ and a zero, the lowest.\n   When there is only a single IP address, this value\
    \ SHOULD be set to\n   65535.  More generally, if there are multiple candidates\
    \ for a\n   particular component for a particular media stream that have the same\n\
    \   type, the local preference MUST be unique for each one.  In this\n   specification,\
    \ this only happens for multihomed hosts.  If a host is\n   multihomed because\
    \ it is dual stack, the local preference SHOULD be\n   set equal to the precedence\
    \ value for IP addresses described in RFC\n   3484 [RFC3484].\n   The component\
    \ ID is the component ID for the candidate, and MUST be\n   between 1 and 256\
    \ inclusive.\n"
- title: 4.1.2.2.  Guidelines for Choosing Type and Local Preferences
  contents:
  - "4.1.2.2.  Guidelines for Choosing Type and Local Preferences\n   One criterion\
    \ for selection of the type and local preference values\n   is the use of a media\
    \ intermediary, such as a TURN server, VPN\n   server, or NAT.  With a media intermediary,\
    \ if media is sent to that\n   candidate, it will first transit the media intermediary\
    \ before being\n   received.  Relayed candidates are one type of candidate that\
    \ involves\n   a media intermediary.  Another are host candidates obtained from\
    \ a\n   VPN interface.  When media is transited through a media intermediary,\n\
    \   it can increase the latency between transmission and reception.  It\n   can\
    \ increase the packet losses, because of the additional router hops\n   that may\
    \ be taken.  It may increase the cost of providing service,\n   since media will\
    \ be routed in and right back out of a media\n   intermediary run by a provider.\
    \  If these concerns are important, the\n   type preference for relayed candidates\
    \ SHOULD be lower than host\n   candidates.  The RECOMMENDED values are 126 for\
    \ host candidates, 100\n   for server reflexive candidates, 110 for peer reflexive\
    \ candidates,\n   and 0 for relayed candidates.  Furthermore, if an agent is multihomed\n\
    \   and has multiple IP addresses, the local preference for host\n   candidates\
    \ from a VPN interface SHOULD have a priority of 0.\n   Another criterion for\
    \ selection of preferences is IP address family.\n   ICE works with both IPv4\
    \ and IPv6.  It therefore provides a\n   transition mechanism that allows dual-stack\
    \ hosts to prefer\n   connectivity over IPv6, but to fall back to IPv4 in case\
    \ the v6\n   networks are disconnected (due, for example, to a failure in a 6to4\n\
    \   relay) [RFC3056].  It can also help with hosts that have both a\n   native\
    \ IPv6 address and a 6to4 address.  In such a case, higher local\n   preferences\
    \ could be assigned to the v6 addresses, followed by the\n   6to4 addresses, followed\
    \ by the v4 addresses.  This allows a site to\n   obtain and begin using native\
    \ v6 addresses immediately, yet still\n   fall back to 6to4 addresses when communicating\
    \ with agents in other\n   sites that do not yet have native v6 connectivity.\n\
    \   Another criterion for selecting preferences is security.  If a user\n   is\
    \ a telecommuter, and therefore connected to a corporate network and\n   a local\
    \ home network, the user may prefer their voice traffic to be\n   routed over\
    \ the VPN in order to keep it on the corporate network when\n   communicating\
    \ within the enterprise, but use the local network when\n   communicating with\
    \ users outside of the enterprise.  In such a case,\n   a VPN address would have\
    \ a higher local preference than any other\n   address.\n   Another criterion\
    \ for selecting preferences is topological awareness.\n   This is most useful\
    \ for candidates that make use of intermediaries.\n   In those cases, if an agent\
    \ has preconfigured or dynamically\n   discovered knowledge of the topological\
    \ proximity of the\n   intermediaries to itself, it can use that to assign higher\
    \ local\n   preferences to candidates obtained from closer intermediaries.\n"
- title: 4.1.3.  Eliminating Redundant Candidates
  contents:
  - "4.1.3.  Eliminating Redundant Candidates\n   Next, the agent eliminates redundant\
    \ candidates.  A candidate is\n   redundant if its transport address equals another\
    \ candidate, and its\n   base equals the base of that other candidate.  Note that\
    \ two\n   candidates can have the same transport address yet have different\n\
    \   bases, and these would not be considered redundant.  Frequently, a\n   server\
    \ reflexive candidate and a host candidate will be redundant\n   when the agent\
    \ is not behind a NAT.  The agent SHOULD eliminate the\n   redundant candidate\
    \ with the lower priority.\n"
- title: 4.1.4.  Choosing Default Candidates
  contents:
  - "4.1.4.  Choosing Default Candidates\n   A candidate is said to be default if\
    \ it would be the target of media\n   from a non-ICE peer; that target is called\
    \ the DEFAULT DESTINATION.\n   If the default candidates are not selected by the\
    \ ICE algorithm when\n   communicating with an ICE-aware peer, an updated offer/answer\
    \ will be\n   required after ICE processing completes in order to \"fix up\" the\
    \ SDP\n   so that the default destination for media matches the candidates\n \
    \  selected by ICE.  If ICE happens to select the default candidates, no\n   updated\
    \ offer/answer is required.\n   An agent MUST choose a set of candidates, one\
    \ for each component of\n   each in-use media stream, to be default.  A media\
    \ stream is in-use if\n   it does not have a port of zero (which is used in RFC\
    \ 3264 to reject\n   a media stream).  Consequently, a media stream is in-use\
    \ even if it\n   is marked as a=inactive [RFC4566] or has a bandwidth value of\
    \ zero.\n   It is RECOMMENDED that default candidates be chosen based on the\n\
    \   likelihood of those candidates to work with the peer that is being\n   contacted.\
    \  It is RECOMMENDED that the default candidates are the\n   relayed candidates\
    \ (if relayed candidates are available), server\n   reflexive candidates (if server\
    \ reflexive candidates are available),\n   and finally host candidates.\n"
- title: 4.2.  Lite Implementation Requirements
  contents:
  - "4.2.  Lite Implementation Requirements\n   Lite implementations only utilize\
    \ host candidates.  A lite\n   implementation MUST, for each component of each\
    \ media stream,\n   allocate zero or one IPv4 candidates.  It MAY allocate zero\
    \ or more\n   IPv6 candidates, but no more than one per each IPv6 address utilized\n\
    \   by the host.  Since there can be no more than one IPv4 candidate per\n   component\
    \ of each media stream, if an agent has multiple IPv4\n   addresses, it MUST choose\
    \ one for allocating the candidate.  If a\n   host is dual stack, it is RECOMMENDED\
    \ that it allocate one IPv4\n   candidate and one global IPv6 address.  With the\
    \ lite implementation,\n   ICE cannot be used to dynamically choose amongst candidates.\n\
    \   Therefore, including more than one candidate from a particular scope\n   is\
    \ NOT RECOMMENDED, since only a connectivity check can truly\n   determine whether\
    \ to use one address or the other.\n   Each component has an ID assigned to it,\
    \ called the component ID.\n   For RTP-based media streams, the RTP itself has\
    \ a component ID of 1,\n   and RTCP a component ID of 2.  If an agent is using\
    \ RTCP, it MUST\n   obtain candidates for it.\n   Each candidate is assigned a\
    \ foundation.  The foundation MUST be\n   different for two candidates allocated\
    \ from different IP addresses,\n   and MUST be the same otherwise.  A simple integer\
    \ that increments for\n   each IP address will suffice.  In addition, each candidate\
    \ MUST be\n   assigned a unique priority amongst all candidates for the same media\n\
    \   stream.  This priority SHOULD be equal to:\n   priority = (2^24)*(126) +\n\
    \              (2^8)*(IP precedence) +\n              (2^0)*(256 - component ID)\n\
    \   If a host is v4-only, it SHOULD set the IP precedence to 65535.  If a\n  \
    \ host is v6 or dual stack, the IP precedence SHOULD be the precedence\n   value\
    \ for IP addresses described in RFC 3484 [RFC3484].\n   Next, an agent chooses\
    \ a default candidate for each component of each\n   media stream.  If a host\
    \ is IPv4 only, there would only be one\n   candidate for each component of each\
    \ media stream, and therefore that\n   candidate is the default.  If a host is\
    \ IPv6 or dual stack, the\n   selection of default is a matter of local policy.\
    \  This default\n   SHOULD be chosen such that it is the candidate most likely\
    \ to be used\n   with a peer.  For IPv6-only hosts, this would typically be a\
    \ globally\n   scoped IPv6 address.  For dual-stack hosts, the IPv4 address is\n\
    \   RECOMMENDED.\n"
- title: 4.3.  Encoding the SDP
  contents:
  - "4.3.  Encoding the SDP\n   The process of encoding the SDP is identical between\
    \ full and lite\n   implementations.\n   The agent will include an m line for\
    \ each media stream it wishes to\n   use.  The ordering of media streams in the\
    \ SDP is relevant for ICE.\n   ICE will perform its connectivity checks for the\
    \ first m line first,\n   and consequently media will be able to flow for that\
    \ stream first.\n   Agents SHOULD place their most important media stream, if\
    \ there is\n   one, first in the SDP.\n   There will be a candidate attribute\
    \ for each candidate for a\n   particular media stream.  Section 15 provides detailed\
    \ rules for\n   constructing this attribute.  The attribute carries the IP address,\n\
    \   port, and transport protocol for the candidate, in addition to its\n   properties\
    \ that need to be signaled to the peer for ICE to work: the\n   priority, foundation,\
    \ and component ID.  The candidate attribute also\n   carries information about\
    \ the candidate that is useful for\n   diagnostics and other functions: its type\
    \ and related transport\n   addresses.\n   STUN connectivity checks between agents\
    \ are authenticated using the\n   short-term credential mechanism defined for\
    \ STUN [RFC5389].  This\n   mechanism relies on a username and password that are\
    \ exchanged\n   through protocol machinery between the client and server.  With\
    \ ICE,\n   the offer/answer exchange is used to exchange them.  The username\n\
    \   part of this credential is formed by concatenating a username\n   fragment\
    \ from each agent, separated by a colon.  Each agent also\n   provides a password,\
    \ used to compute the message integrity for\n   requests it receives.  The username\
    \ fragment and password are\n   exchanged in the ice-ufrag and ice-pwd attributes,\
    \ respectively.  In\n   addition to providing security, the username provides\
    \ disambiguation\n   and correlation of checks to media streams.  See Appendix\
    \ B.4 for\n   motivation.\n   If an agent is a lite implementation, it MUST include\
    \ an \"a=ice-lite\"\n   session-level attribute in its SDP.  If an agent is a\
    \ full\n   implementation, it MUST NOT include this attribute.\n   The default\
    \ candidates are added to the SDP as the default\n   destination for media.  For\
    \ streams based on RTP, this is done by\n   placing the IP address and port of\
    \ the RTP candidate into the c and m\n   lines, respectively.  If the agent is\
    \ utilizing RTCP, it MUST encode\n   the RTCP candidate using the a=rtcp attribute\
    \ as defined in RFC 3605\n   [RFC3605].  If RTCP is not in use, the agent MUST\
    \ signal that using\n   b=RS:0 and b=RR:0 as defined in RFC 3556 [RFC3556].\n\
    \   The transport addresses that will be the default destination for\n   media\
    \ when communicating with non-ICE peers MUST also be present as\n   candidates\
    \ in one or more a=candidate lines.\n   ICE provides for extensibility by allowing\
    \ an offer or answer to\n   contain a series of tokens that identify the ICE extensions\
    \ used by\n   that agent.  If an agent supports an ICE extension, it MUST include\n\
    \   the token defined for that extension in the ice-options attribute.\n   The\
    \ following is an example SDP message that includes ICE attributes\n   (lines\
    \ folded for readability):\n       v=0\n       o=jdoe 2890844526 2890842807 IN\
    \ IP4 10.0.1.1\n       s=\n       c=IN IP4 192.0.2.3\n       t=0 0\n       a=ice-pwd:asd88fgpdd777uzjYhagZg\n\
    \       a=ice-ufrag:8hhY\n       m=audio 45664 RTP/AVP 0\n       b=RS:0\n    \
    \   b=RR:0\n       a=rtpmap:0 PCMU/8000\n       a=candidate:1 1 UDP 2130706431\
    \ 10.0.1.1 8998 typ host\n       a=candidate:2 1 UDP 1694498815 192.0.2.3 45664\
    \ typ srflx raddr\n   10.0.1.1 rport 8998\n   Once an agent has sent its offer\
    \ or its answer, that agent MUST be\n   prepared to receive both STUN and media\
    \ packets on each candidate.\n   As discussed in Section 11.1, media packets can\
    \ be sent to a\n   candidate prior to its appearance as the default destination\
    \ for\n   media in an offer or answer.\n"
- title: 5.  Receiving the Initial Offer
  contents:
  - "5.  Receiving the Initial Offer\n   When an agent receives an initial offer,\
    \ it will check if the offerer\n   supports ICE, determine its own role, gather\
    \ candidates, prioritize\n   them, choose default candidates, encode and send\
    \ an answer, and for\n   full implementations, form the check lists and begin\
    \ connectivity\n   checks.\n"
- title: 5.1.  Verifying ICE Support
  contents:
  - "5.1.  Verifying ICE Support\n   The agent will proceed with the ICE procedures\
    \ defined in this\n   specification if, for each media stream in the SDP it received,\
    \ the\n   default destination for each component of that media stream appears\n\
    \   in a candidate attribute.  For example, in the case of RTP, the IP\n   address\
    \ and port in the c and m lines, respectively, appear in a\n   candidate attribute\
    \ and the value in the rtcp attribute appears in a\n   candidate attribute.\n\
    \   If this condition is not met, the agent MUST process the SDP based on\n  \
    \ normal RFC 3264 procedures, without using any of the ICE mechanisms\n   described\
    \ in the remainder of this specification with the following\n   exceptions:\n\
    \   1.  The agent MUST follow the rules of Section 10, which describe\n      \
    \ keepalive procedures for all agents.\n   2.  If the agent is not proceeding\
    \ with ICE because there were\n       a=candidate attributes, but none that matched\
    \ the default\n       destination of the media stream, the agent MUST include\
    \ an a=ice-\n       mismatch attribute in its answer.\n   3.  If the default candidates\
    \ were relayed candidates learned through\n       a TURN server, the agent MUST\
    \ create permissions in the TURN\n       server for the IP addresses learned from\
    \ its peer in the SDP it\n       just received.  If this is not done, initial\
    \ packets in the media\n       stream from the peer may be lost.\n"
- title: 5.2.  Determining Role
  contents:
  - "5.2.  Determining Role\n   For each session, each agent takes on a role.  There\
    \ are two roles --\n   controlling and controlled.  The controlling agent is responsible\
    \ for\n   the choice of the final candidate pairs used for communications.  For\n\
    \   a full agent, this means nominating the candidate pairs that can be\n   used\
    \ by ICE for each media stream, and for generating the updated\n   offer based\
    \ on ICE's selection, when needed.  For a lite\n   implementation, being the controlling\
    \ agent means selecting a\n   candidate pair based on the ones in the offer and\
    \ answer (for IPv4,\n   there is only ever one pair), and then generating an updated\
    \ offer\n   reflecting that selection, when needed (it is never needed for an\n\
    \   IPv4-only host).  The controlled agent is told which candidate pairs\n   to\
    \ use for each media stream, and does not generate an updated offer\n   to signal\
    \ this information.  The sections below describe in detail\n   the actual procedures\
    \ followed by controlling and controlled nodes.\n   The rules for determining\
    \ the role and the impact on behavior are as\n   follows:\n   Both agents are\
    \ full:  The agent that generated the offer which\n      started the ICE processing\
    \ MUST take the controlling role, and the\n      other MUST take the controlled\
    \ role.  Both agents will form check\n      lists, run the ICE state machines,\
    \ and generate connectivity\n      checks.  The controlling agent will execute\
    \ the logic in\n      Section 8.1 to nominate pairs that will be selected by ICE,\
    \ and\n      then both agents end ICE as described in Section 8.1.2.  In\n   \
    \   unusual cases, described in Appendix B.11, it is possible for both\n     \
    \ agents to mistakenly believe they are controlled or controlling.\n      To resolve\
    \ this, each agent MUST select a random number, called\n      the tie-breaker,\
    \ uniformly distributed between 0 and (2**64) - 1\n      (that is, a 64-bit positive\
    \ integer).  This number is used in\n      connectivity checks to detect and repair\
    \ this case, as described\n      in Section 7.1.2.2.\n   One agent full, one lite:\
    \  The full agent MUST take the controlling\n      role, and the lite agent MUST\
    \ take the controlled role.  The full\n      agent will form check lists, run\
    \ the ICE state machines, and\n      generate connectivity checks.  That agent\
    \ will execute the logic\n      in Section 8.1 to nominate pairs that will be\
    \ selected by ICE, and\n      use the logic in Section 8.1.2 to end ICE.  The\
    \ lite\n      implementation will just listen for connectivity checks, receive\n\
    \      them and respond to them, and then conclude ICE as described in\n     \
    \ Section 8.2.  For the lite implementation, the state of ICE\n      processing\
    \ for each media stream is considered to be Running, and\n      the state of ICE\
    \ overall is Running.\n   Both lite:  The agent that generated the offer which\
    \ started the ICE\n      processing MUST take the controlling role, and the other\
    \ MUST take\n      the controlled role.  In this case, no connectivity checks\
    \ are\n      ever sent.  Rather, once the offer/answer exchange completes, each\n\
    \      agent performs the processing described in Section 8 without\n      connectivity\
    \ checks.  It is possible that both agents will believe\n      they are controlled\
    \ or controlling.  In the latter case, the\n      conflict is resolved through\
    \ glare detection capabilities in the\n      signaling protocol carrying the offer/answer\
    \ exchange.  The state\n      of ICE processing for each media stream is considered\
    \ to be\n      Running, and the state of ICE overall is Running.\n   Once roles\
    \ are determined for a session, they persist unless ICE is\n   restarted.  An\
    \ ICE restart (Section 9.1) causes a new selection of\n   roles and tie-breakers.\n"
- title: 5.3.  Gathering Candidates
  contents:
  - "5.3.  Gathering Candidates\n   The process for gathering candidates at the answerer\
    \ is identical to\n   the process for the offerer as described in Section 4.1.1\
    \ for full\n   implementations and Section 4.2 for lite implementations.  It is\n\
    \   RECOMMENDED that this process begin immediately on receipt of the\n   offer,\
    \ prior to alerting the user.  Such gathering MAY begin when an\n   agent starts.\n"
- title: 5.4.  Prioritizing Candidates
  contents:
  - "5.4.  Prioritizing Candidates\n   The process for prioritizing candidates at\
    \ the answerer is identical\n   to the process followed by the offerer, as described\
    \ in Section 4.1.2\n   for full implementations and Section 4.2 for lite implementations.\n"
- title: 5.5.  Choosing Default Candidates
  contents:
  - "5.5.  Choosing Default Candidates\n   The process for selecting default candidates\
    \ at the answerer is\n   identical to the process followed by the offerer, as\
    \ described in\n   Section 4.1.4 for full implementations and Section 4.2 for\
    \ lite\n   implementations.\n"
- title: 5.6.  Encoding the SDP
  contents:
  - "5.6.  Encoding the SDP\n   The process for encoding the SDP at the answerer is\
    \ identical to the\n   process followed by the offerer for both full and lite\n\
    \   implementations, as described in Section 4.3.\n"
- title: 5.7.  Forming the Check Lists
  contents:
  - "5.7.  Forming the Check Lists\n   Forming check lists is done only by full implementations.\
    \  Lite\n   implementations MUST skip the steps defined in this section.\n   There\
    \ is one check list per in-use media stream resulting from the\n   offer/answer\
    \ exchange.  To form the check list for a media stream,\n   the agent forms candidate\
    \ pairs, computes a candidate pair priority,\n   orders the pairs by priority,\
    \ prunes them, and sets their states.\n   These steps are described in this section.\n"
- title: 5.7.1.  Forming Candidate Pairs
  contents:
  - "5.7.1.  Forming Candidate Pairs\n   First, the agent takes each of its candidates\
    \ for a media stream\n   (called LOCAL CANDIDATES) and pairs them with the candidates\
    \ it\n   received from its peer (called REMOTE CANDIDATES) for that media\n  \
    \ stream.  In order to prevent the attacks described in Section 18.5.2,\n   agents\
    \ MAY limit the number of candidates they'll accept in an offer\n   or answer.\
    \  A local candidate is paired with a remote candidate if\n   and only if the\
    \ two candidates have the same component ID and have\n   the same IP address version.\
    \  It is possible that some of the local\n   candidates won't get paired with\
    \ remote candidates, and some of the\n   remote candidates won't get paired with\
    \ local candidates.  This can\n   happen if one agent doesn't include candidates\
    \ for the all of the\n   components for a media stream.  If this happens, the\
    \ number of\n   components for that media stream is effectively reduced, and\n\
    \   considered to be equal to the minimum across both agents of the\n   maximum\
    \ component ID provided by each agent across all components for\n   the media\
    \ stream.\n   In the case of RTP, this would happen when one agent provides\n\
    \   candidates for RTCP, and the other does not.  As another example, the\n  \
    \ offerer can multiplex RTP and RTCP on the same port and signals that\n   it\
    \ can do that in the SDP through an SDP attribute [RFC5761].\n   However, since\
    \ the offerer doesn't know if the answerer can perform\n   such multiplexing,\
    \ the offerer includes candidates for RTP and RTCP\n   on separate ports, so that\
    \ the offer has two components per media\n   stream.  If the answerer can perform\
    \ such multiplexing, it would\n   include just a single component for each candidate\
    \ - for the combined\n   RTP/RTCP mux.  ICE would end up acting as if there was\
    \ just a single\n   component for this candidate.\n   The candidate pairs whose\
    \ local and remote candidates are both the\n   default candidates for a particular\
    \ component is called,\n   unsurprisingly, the default candidate pair for that\
    \ component.  This\n   is the pair that would be used to transmit media if both\
    \ agents had\n   not been ICE aware.\n   In order to aid understanding, Figure\
    \ 6 shows the relationships\n   between several key concepts -- transport addresses,\
    \ candidates,\n   candidate pairs, and check lists, in addition to indicating\
    \ the main\n   properties of candidates and candidate pairs.\n       +------------------------------------------+\n\
    \       |                                          |\n       | +---------------------+\
    \                  |\n       | |+----+ +----+ +----+ |   +Type          |\n  \
    \     | || IP | |Port| |Tran| |   +Priority      |\n       | ||Addr| |    | |\
    \    | |   +Foundation    |\n       | |+----+ +----+ +----+ |   +ComponentiD \
    \  |\n       | |      Transport      |   +RelatedAddr   |\n       | |        Addr\
    \         |                  |\n       | +---------------------+   +Base     \
    \     |\n       |             Candidate                    |\n       +------------------------------------------+\n\
    \       *                                         *\n       *    *************************************\n\
    \       *    *\n     +-------------------------------+\n    .|               \
    \                |\n     | Local     Remote              |\n     | +----+    +----+\
    \   +default?  |\n     | |Cand|    |Cand|   +valid?    |\n     | +----+    +----+\
    \   +nominated?|\n     |                    +State     |\n     |             \
    \                  |\n     |                               |\n     |         \
    \ Candidate Pair       |\n     +-------------------------------+\n     *     \
    \                         *\n     *                  ************\n     *    \
    \              *\n     +------------------+\n     |  Candidate Pair  |\n     +------------------+\n\
    \     +------------------+\n     |  Candidate Pair  |\n     +------------------+\n\
    \     +------------------+\n     |  Candidate Pair  |\n     +------------------+\n\
    \            Check\n            List\n               Figure 6: Conceptual Diagram\
    \ of a Check List\n"
- title: 5.7.2.  Computing Pair Priority and Ordering Pairs
  contents:
  - "5.7.2.  Computing Pair Priority and Ordering Pairs\n   Once the pairs are formed,\
    \ a candidate pair priority is computed.\n   Let G be the priority for the candidate\
    \ provided by the controlling\n   agent.  Let D be the priority for the candidate\
    \ provided by the\n   controlled agent.  The priority for a pair is computed as:\n\
    \      pair priority = 2^32*MIN(G,D) + 2*MAX(G,D) + (G>D?1:0)\n   Where G>D?1:0\
    \ is an expression whose value is 1 if G is greater than\n   D, and 0 otherwise.\
    \  Once the priority is assigned, the agent sorts\n   the candidate pairs in decreasing\
    \ order of priority.  If two pairs\n   have identical priority, the ordering amongst\
    \ them is arbitrary.\n"
- title: 5.7.3.  Pruning the Pairs
  contents:
  - "5.7.3.  Pruning the Pairs\n   This sorted list of candidate pairs is used to\
    \ determine a sequence\n   of connectivity checks that will be performed.  Each\
    \ check involves\n   sending a request from a local candidate to a remote candidate.\n\
    \   Since an agent cannot send requests directly from a reflexive\n   candidate,\
    \ but only from its base, the agent next goes through the\n   sorted list of candidate\
    \ pairs.  For each pair where the local\n   candidate is server reflexive, the\
    \ server reflexive candidate MUST be\n   replaced by its base.  Once this has\
    \ been done, the agent MUST prune\n   the list.  This is done by removing a pair\
    \ if its local and remote\n   candidates are identical to the local and remote\
    \ candidates of a pair\n   higher up on the priority list.  The result is a sequence\
    \ of ordered\n   candidate pairs, called the check list for that media stream.\n\
    \   In addition, in order to limit the attacks described in\n   Section 18.5.2,\
    \ an agent MUST limit the total number of connectivity\n   checks the agent performs\
    \ across all check lists to a specific value,\n   and this value MUST be configurable.\
    \  A default of 100 is\n   RECOMMENDED.  This limit is enforced by discarding\
    \ the lower-priority\n   candidate pairs until there are less than 100.  It is\
    \ RECOMMENDED\n   that a lower value be utilized when possible, set to the maximum\n\
    \   number of plausible checks that might be seen in an actual deployment\n  \
    \ configuration.  The requirement for configuration is meant to provide\n   a\
    \ tool for fixing this value in the field if, once deployed, it is\n   found to\
    \ be problematic.\n"
- title: 5.7.4.  Computing States
  contents:
  - "5.7.4.  Computing States\n   Each candidate pair in the check list has a foundation\
    \ and a state.\n   The foundation is the combination of the foundations of the\
    \ local and\n   remote candidates in the pair.  The state is assigned once the\
    \ check\n   list for each media stream has been computed.  There are five\n  \
    \ potential values that the state can have:\n   Waiting:  A check has not been\
    \ performed for this pair, and can be\n      performed as soon as it is the highest-priority\
    \ Waiting pair on\n      the check list.\n   In-Progress:  A check has been sent\
    \ for this pair, but the\n      transaction is in progress.\n   Succeeded:  A\
    \ check for this pair was already done and produced a\n      successful result.\n\
    \   Failed:  A check for this pair was already done and failed, either\n     \
    \ never producing any response or producing an unrecoverable failure\n      response.\n\
    \   Frozen:  A check for this pair hasn't been performed, and it can't\n     \
    \ yet be performed until some other check succeeds, allowing this\n      pair\
    \ to unfreeze and move into the Waiting state.\n   As ICE runs, the pairs will\
    \ move between states as shown in Figure 7.\n      +-----------+\n      |    \
    \       |\n      |           |\n      |  Frozen   |\n      |           |\n   \
    \   |           |\n      +-----------+\n            |\n            |unfreeze\n\
    \            |\n            V\n      +-----------+         +-----------+\n   \
    \   |           |         |           |\n      |           | perform |       \
    \    |\n      |  Waiting  |-------->|In-Progress|\n      |           |       \
    \  |           |\n      |           |         |           |\n      +-----------+\
    \         +-----------+\n                                  / |\n             \
    \                   //  |\n                              //    |\n           \
    \                 //      |\n                           /        |\n         \
    \                //         |\n               failure //           |success\n\
    \                     //             |\n                    /               |\n\
    \                  //                |\n                //                  |\n\
    \              //                    |\n             V                      V\n\
    \      +-----------+         +-----------+\n      |           |         |    \
    \       |\n      |           |         |           |\n      |   Failed  |    \
    \     | Succeeded |\n      |           |         |           |\n      |      \
    \     |         |           |\n      +-----------+         +-----------+\n   \
    \                      Figure 7: Pair State FSM\n   The initial states for each\
    \ pair in a check list are computed by\n   performing the following sequence of\
    \ steps:\n   1.  The agent sets all of the pairs in each check list to the Frozen\n\
    \       state.\n   2.  The agent examines the check list for the first media stream\
    \ (a\n       media stream is the first media stream when it is described by\n\
    \       the first m line in the SDP offer and answer).  For that media\n     \
    \  stream:\n       *  For all pairs with the same foundation, it sets the state\
    \ of\n          the pair with the lowest component ID to Waiting.  If there is\n\
    \          more than one such pair, the one with the highest priority is\n   \
    \       used.\n   One of the check lists will have some number of pairs in the\
    \ Waiting\n   state, and the other check lists will have all of their pairs in\
    \ the\n   Frozen state.  A check list with at least one pair that is Waiting is\n\
    \   called an active check list, and a check list with all pairs Frozen\n   is\
    \ called a frozen check list.\n   The check list itself is associated with a state,\
    \ which captures the\n   state of ICE checks for that media stream.  There are\
    \ three states:\n   Running:  In this state, ICE checks are still in progress\
    \ for this\n      media stream.\n   Completed:  In this state, ICE checks have\
    \ produced nominated pairs\n      for each component of the media stream.  Consequently,\
    \ ICE has\n      succeeded and media can be sent.\n   Failed:  In this state,\
    \ the ICE checks have not completed\n      successfully for this media stream.\n\
    \   When a check list is first constructed as the consequence of an\n   offer/answer\
    \ exchange, it is placed in the Running state.\n   ICE processing across all media\
    \ streams also has a state associated\n   with it.  This state is equal to Running\
    \ while ICE processing is\n   under way.  The state is Completed when ICE processing\
    \ is complete\n   and Failed if it failed without success.  Rules for transitioning\n\
    \   between states are described below.\n"
- title: 5.8.  Scheduling Checks
  contents:
  - "5.8.  Scheduling Checks\n   Checks are generated only by full implementations.\
    \  Lite\n   implementations MUST skip the steps described in this section.\n \
    \  An agent performs ordinary checks and triggered checks.  The\n   generation\
    \ of both checks is governed by a timer that fires\n   periodically for each media\
    \ stream.  The agent maintains a FIFO\n   queue, called the triggered check queue,\
    \ which contains candidate\n   pairs for which checks are to be sent at the next\
    \ available\n   opportunity.  When the timer fires, the agent removes the top\
    \ pair\n   from the triggered check queue, performs a connectivity check on that\n\
    \   pair, and sets the state of the candidate pair to In-Progress.  If\n   there\
    \ are no pairs in the triggered check queue, an ordinary check is\n   sent.\n\
    \   Once the agent has computed the check lists as described in\n   Section 5.7,\
    \ it sets a timer for each active check list.  The timer\n   fires every Ta*N\
    \ seconds, where N is the number of active check lists\n   (initially, there is\
    \ only one active check list).  Implementations\n   MAY set the timer to fire\
    \ less frequently than this.  Implementations\n   SHOULD take care to spread out\
    \ these timers so that they do not fire\n   at the same time for each media stream.\
    \  Ta and the retransmit timer\n   RTO are computed as described in Section 16.\
    \  Multiplying by N allows\n   this aggregate check throughput to be split between\
    \ all active check\n   lists.  The first timer fires immediately, so that the\
    \ agent performs\n   a connectivity check the moment the offer/answer exchange\
    \ has been\n   done, followed by the next check Ta seconds later (since there\
    \ is\n   only one active check list).\n   When the timer fires and there is no\
    \ triggered check to be sent, the\n   agent MUST choose an ordinary check as follows:\n\
    \   o  Find the highest-priority pair in that check list that is in the\n    \
    \  Waiting state.\n   o  If there is such a pair:\n      *  Send a STUN check\
    \ from the local candidate of that pair to the\n         remote candidate of that\
    \ pair.  The procedures for forming the\n         STUN request for this purpose\
    \ are described in Section 7.1.2.\n      *  Set the state of the candidate pair\
    \ to In-Progress.\n   o  If there is no such pair:\n      *  Find the highest-priority\
    \ pair in that check list that is in\n         the Frozen state.\n      *  If\
    \ there is such a pair:\n         +  Unfreeze the pair.\n         +  Perform a\
    \ check for that pair, causing its state to\n            transition to In-Progress.\n\
    \      *  If there is no such pair:\n         +  Terminate the timer for that\
    \ check list.\n   To compute the message integrity for the check, the agent uses\
    \ the\n   remote username fragment and password learned from the SDP from its\n\
    \   peer.  The local username fragment is known directly by the agent for\n  \
    \ its own candidate.\n"
- title: 6.  Receipt of the Initial Answer
  contents:
  - "6.  Receipt of the Initial Answer\n   This section describes the procedures that\
    \ an agent follows when it\n   receives the answer from the peer.  It verifies\
    \ that its peer\n   supports ICE, determines its role, and for full implementations,\n\
    \   forms the check list and begins performing ordinary checks.\n   When ICE is\
    \ used with SIP, forking may result in a single offer\n   generating a multiplicity\
    \ of answers.  In that case, ICE proceeds\n   completely in parallel and independently\
    \ for each answer, treating\n   the combination of its offer and each answer as\
    \ an independent offer/\n   answer exchange, with its own set of pairs, check\
    \ lists, states, and\n   so on.  The only case in which processing of one pair\
    \ impacts another\n   is freeing of candidates, discussed below in Section 8.3.\n"
- title: 6.1.  Verifying ICE Support
  contents:
  - "6.1.  Verifying ICE Support\n   The logic at the offerer is identical to that\
    \ of the answerer as\n   described in Section 5.1, with the exception that an\
    \ offerer would\n   not ever generate a=ice-mismatch attributes in an SDP.\n \
    \  In some cases, the answer may omit a=candidate attributes for the\n   media\
    \ streams, and instead include an a=ice-mismatch attribute for\n   one or more\
    \ of the media streams in the SDP.  This signals to the\n   offerer that the answerer\
    \ supports ICE, but that ICE processing was\n   not used for the session because\
    \ a signaling intermediary modified\n   the default destination for media components\
    \ without modifying the\n   corresponding candidate attributes.  See Section 18\
    \ for a discussion\n   of cases where this can happen.  This specification provides\
    \ no\n   guidance on how an agent should proceed in such a failure case.\n"
- title: 6.2.  Determining Role
  contents:
  - "6.2.  Determining Role\n   The offerer follows the same procedures described\
    \ for the answerer in\n   Section 5.2.\n"
- title: 6.3.  Forming the Check List
  contents:
  - "6.3.  Forming the Check List\n   Formation of check lists is performed only by\
    \ full implementations.\n   The offerer follows the same procedures described\
    \ for the answerer in\n   Section 5.7.\n"
- title: 6.4.  Performing Ordinary Checks
  contents:
  - "6.4.  Performing Ordinary Checks\n   Ordinary checks are performed only by full\
    \ implementations.  The\n   offerer follows the same procedures described for\
    \ the answerer in\n   Section 5.8.\n"
- title: 7.  Performing Connectivity Checks
  contents:
  - "7.  Performing Connectivity Checks\n   This section describes how connectivity\
    \ checks are performed.  All\n   ICE implementations are required to be compliant\
    \ to [RFC5389], as\n   opposed to the older [RFC3489].  However, whereas a full\n\
    \   implementation will both generate checks (acting as a STUN client)\n   and\
    \ receive them (acting as a STUN server), a lite implementation\n   will only\
    \ receive checks, and thus will only act as a STUN server.\n"
- title: 7.1.  STUN Client Procedures
  contents:
  - "7.1.  STUN Client Procedures\n   These procedures define how an agent sends a\
    \ connectivity check,\n   whether it is an ordinary or a triggered check.  These\
    \ procedures are\n   only applicable to full implementations.\n"
- title: 7.1.1.  Creating Permissions for Relayed Candidates
  contents:
  - "7.1.1.  Creating Permissions for Relayed Candidates\n   If the connectivity check\
    \ is being sent using a relayed local\n   candidate, the client MUST create a\
    \ permission first if it has not\n   already created one previously.  It would\
    \ have created one previously\n   if it had told the TURN server to create a permission\
    \ for the given\n   relayed candidate towards the IP address of the remote candidate.\
    \  To\n   create the permission, the agent follows the procedures defined in\n\
    \   [RFC5766].  The permission MUST be created towards the IP address of\n   the\
    \ remote candidate.  It is RECOMMENDED that the agent defer\n   creation of a\
    \ TURN channel until ICE completes, in which case\n   permissions for connectivity\
    \ checks are normally created using a\n   CreatePermission request.  Once established,\
    \ the agent MUST keep the\n   permission active until ICE concludes.\n"
- title: 7.1.2.  Sending the Request
  contents:
  - "7.1.2.  Sending the Request\n   The check is generated by sending a Binding request\
    \ from a local\n   candidate to a remote candidate.  [RFC5389] describes how Binding\n\
    \   requests are constructed and generated.  A connectivity check MUST\n   utilize\
    \ the STUN short-term credential mechanism.  Support for\n   backwards compatibility\
    \ with RFC 3489 MUST NOT be used or assumed\n   with connectivity checks.  The\
    \ FINGERPRINT mechanism MUST be used for\n   connectivity checks.\n   ICE extends\
    \ STUN by defining several new attributes, including\n   PRIORITY, USE-CANDIDATE,\
    \ ICE-CONTROLLED, and ICE-CONTROLLING.  These\n   new attributes are formally\
    \ defined in Section 19.1, and their usage\n   is described in the subsections\
    \ below.  These STUN extensions are\n   applicable only to connectivity checks\
    \ used for ICE.\n"
- title: 7.1.2.1.  PRIORITY and USE-CANDIDATE
  contents:
  - "7.1.2.1.  PRIORITY and USE-CANDIDATE\n   An agent MUST include the PRIORITY attribute\
    \ in its Binding request.\n   The attribute MUST be set equal to the priority\
    \ that would be\n   assigned, based on the algorithm in Section 4.1.2, to a peer\n\
    \   reflexive candidate, should one be learned as a consequence of this\n   check\
    \ (see Section 7.1.3.2.1 for how peer reflexive candidates are\n   learned). \
    \ This priority value will be computed identically to how\n   the priority for\
    \ the local candidate of the pair was computed, except\n   that the type preference\
    \ is set to the value for peer reflexive\n   candidate types.\n   The controlling\
    \ agent MAY include the USE-CANDIDATE attribute in the\n   Binding request.  The\
    \ controlled agent MUST NOT include it in its\n   Binding request.  This attribute\
    \ signals that the controlling agent\n   wishes to cease checks for this component,\
    \ and use the candidate pair\n   resulting from the check for this component.\
    \  Section 8.1.1 provides\n   guidance on determining when to include it.\n"
- title: 7.1.2.2.  ICE-CONTROLLED and ICE-CONTROLLING
  contents:
  - "7.1.2.2.  ICE-CONTROLLED and ICE-CONTROLLING\n   The agent MUST include the ICE-CONTROLLED\
    \ attribute in the request if\n   it is in the controlled role, and MUST include\
    \ the ICE-CONTROLLING\n   attribute in the request if it is in the controlling\
    \ role.  The\n   content of either attribute MUST be the tie-breaker that was\n\
    \   determined in Section 5.2.  These attributes are defined fully in\n   Section\
    \ 19.1.\n"
- title: 7.1.2.3.  Forming Credentials
  contents:
  - "7.1.2.3.  Forming Credentials\n   A Binding request serving as a connectivity\
    \ check MUST utilize the\n   STUN short-term credential mechanism.  The username\
    \ for the\n   credential is formed by concatenating the username fragment provided\n\
    \   by the peer with the username fragment of the agent sending the\n   request,\
    \ separated by a colon (\":\").  The password is equal to the\n   password provided\
    \ by the peer.  For example, consider the case where\n   agent L is the offerer,\
    \ and agent R is the answerer.  Agent L\n   included a username fragment of LFRAG\
    \ for its candidates and a\n   password of LPASS.  Agent R provided a username\
    \ fragment of RFRAG and\n   a password of RPASS.  A connectivity check from L\
    \ to R utilizes the\n   username RFRAG:LFRAG and a password of RPASS.  A connectivity\
    \ check\n   from R to L utilizes the username LFRAG:RFRAG and a password of\n\
    \   LPASS.  The responses utilize the same usernames and passwords as the\n  \
    \ requests (note that the USERNAME attribute is not present in the\n   response).\n"
- title: 7.1.2.4.  DiffServ Treatment
  contents:
  - "7.1.2.4.  DiffServ Treatment\n   If the agent is using Diffserv Codepoint markings\
    \ [RFC2475] in its\n   media packets, it SHOULD apply those same markings to its\n\
    \   connectivity checks.\n"
- title: 7.1.3.  Processing the Response
  contents:
  - "7.1.3.  Processing the Response\n   When a Binding response is received, it is\
    \ correlated to its Binding\n   request using the transaction ID, as defined in\
    \ [RFC5389], which then\n   ties it to the candidate pair for which the Binding\
    \ request was sent.\n   This section defines additional procedures for processing\
    \ Binding\n   responses specific to this usage of STUN.\n"
- title: 7.1.3.1.  Failure Cases
  contents:
  - "7.1.3.1.  Failure Cases\n   If the STUN transaction generates a 487 (Role Conflict)\
    \ error\n   response, the agent checks whether it included the ICE-CONTROLLED\
    \ or\n   ICE-CONTROLLING attribute in the Binding request.  If the request\n \
    \  contained the ICE-CONTROLLED attribute, the agent MUST switch to the\n   controlling\
    \ role if it has not already done so.  If the request\n   contained the ICE-CONTROLLING\
    \ attribute, the agent MUST switch to the\n   controlled role if it has not already\
    \ done so.  Once it has switched,\n   the agent MUST enqueue the candidate pair\
    \ whose check generated the\n   487 into the triggered check queue.  The state\
    \ of that pair is set to\n   Waiting.  When the triggered check is sent, it will\
    \ contain an ICE-\n   CONTROLLING or ICE-CONTROLLED attribute reflecting its new\
    \ role.\n   Note, however, that the tie-breaker value MUST NOT be reselected.\n\
    \   A change in roles will require an agent to recompute pair priorities\n   (Section\
    \ 5.7.2), since those priorities are a function of controlling\n   and controlled\
    \ roles.  The change in role will also impact whether\n   the agent is responsible\
    \ for selecting nominated pairs and generating\n   updated offers upon conclusion\
    \ of ICE.\n   Agents MAY support receipt of ICMP errors for connectivity checks.\n\
    \   If the STUN transaction generates an ICMP error, the agent sets the\n   state\
    \ of the pair to Failed.  If the STUN transaction generates a\n   STUN error response\
    \ that is unrecoverable (as defined in [RFC5389])\n   or times out, the agent\
    \ sets the state of the pair to Failed.\n   The agent MUST check that the source\
    \ IP address and port of the\n   response equal the destination IP address and\
    \ port to which the\n   Binding request was sent, and that the destination IP\
    \ address and\n   port of the response match the source IP address and port from\
    \ which\n   the Binding request was sent.  In other words, the source and\n  \
    \ destination transport addresses in the request and responses are\n   symmetric.\
    \  If they are not symmetric, the agent sets the state of\n   the pair to Failed.\n"
- title: 7.1.3.2.  Success Cases
  contents:
  - "7.1.3.2.  Success Cases\n   A check is considered to be a success if all of the\
    \ following are\n   true:\n   o  The STUN transaction generated a success response.\n\
    \   o  The source IP address and port of the response equals the\n      destination\
    \ IP address and port to which the Binding request was\n      sent.\n   o  The\
    \ destination IP address and port of the response match the\n      source IP address\
    \ and port from which the Binding request was\n      sent.\n"
- title: 7.1.3.2.1.  Discovering Peer Reflexive Candidates
  contents:
  - "7.1.3.2.1.  Discovering Peer Reflexive Candidates\n   The agent checks the mapped\
    \ address from the STUN response.  If the\n   transport address does not match\
    \ any of the local candidates that the\n   agent knows about, the mapped address\
    \ represents a new candidate -- a\n   peer reflexive candidate.  Like other candidates,\
    \ it has a type,\n   base, priority, and foundation.  They are computed as follows:\n\
    \   o  Its type is equal to peer reflexive.\n   o  Its base is set equal to the\
    \ local candidate of the candidate pair\n      from which the STUN check was sent.\n\
    \   o  Its priority is set equal to the value of the PRIORITY attribute\n    \
    \  in the Binding request.\n   o  Its foundation is selected as described in Section\
    \ 4.1.1.3.\n   This peer reflexive candidate is then added to the list of local\n\
    \   candidates for the media stream.  Its username fragment and password\n   are\
    \ the same as all other local candidates for that media stream.\n   However, the\
    \ peer reflexive candidate is not paired with other remote\n   candidates.  This\
    \ is not necessary; a valid pair will be generated\n   from it momentarily based\
    \ on the procedures in Section 7.1.3.2.2.  If\n   an agent wishes to pair the\
    \ peer reflexive candidate with other\n   remote candidates besides the one in\
    \ the valid pair that will be\n   generated, the agent MAY generate an updated\
    \ offer which includes the\n   peer reflexive candidate.  This will cause it to\
    \ be paired with all\n   other remote candidates.\n"
- title: 7.1.3.2.2.  Constructing a Valid Pair
  contents:
  - "7.1.3.2.2.  Constructing a Valid Pair\n   The agent constructs a candidate pair\
    \ whose local candidate equals\n   the mapped address of the response, and whose\
    \ remote candidate equals\n   the destination address to which the request was\
    \ sent.  This is\n   called a valid pair, since it has been validated by a STUN\n\
    \   connectivity check.  The valid pair may equal the pair that generated\n  \
    \ the check, may equal a different pair in the check list, or may be a\n   pair\
    \ not currently on any check list.  If the pair equals the pair\n   that generated\
    \ the check or is on a check list currently, it is also\n   added to the VALID\
    \ LIST, which is maintained by the agent for each\n   media stream.  This list\
    \ is empty at the start of ICE processing, and\n   fills as checks are performed,\
    \ resulting in valid candidate pairs.\n   It will be very common that the pair\
    \ will not be on any check list.\n   Recall that the check list has pairs whose\
    \ local candidates are never\n   server reflexive; those pairs had their local\
    \ candidates converted to\n   the base of the server reflexive candidates, and\
    \ then pruned if they\n   were redundant.  When the response to the STUN check\
    \ arrives, the\n   mapped address will be reflexive if there is a NAT between\
    \ the two.\n   In that case, the valid pair will have a local candidate that doesn't\n\
    \   match any of the pairs in the check list.\n   If the pair is not on any check\
    \ list, the agent computes the priority\n   for the pair based on the priority\
    \ of each candidate, using the\n   algorithm in Section 5.7.  The priority of\
    \ the local candidate\n   depends on its type.  If it is not peer reflexive, it\
    \ is equal to the\n   priority signaled for that candidate in the SDP.  If it\
    \ is peer\n   reflexive, it is equal to the PRIORITY attribute the agent placed\
    \ in\n   the Binding request that just completed.  The priority of the remote\n\
    \   candidate is taken from the SDP of the peer.  If the candidate does\n   not\
    \ appear there, then the check must have been a triggered check to\n   a new remote\
    \ candidate.  In that case, the priority is taken as the\n   value of the PRIORITY\
    \ attribute in the Binding request that triggered\n   the check that just completed.\
    \  The pair is then added to the VALID\n   LIST.\n"
- title: 7.1.3.2.3.  Updating Pair States
  contents:
  - "7.1.3.2.3.  Updating Pair States\n   The agent sets the state of the pair that\
    \ *generated* the check to\n   Succeeded.  Note that, the pair which *generated*\
    \ the check may be\n   different than the valid pair constructed in Section 7.1.3.2.2\
    \ as a\n   consequence of the response.  The success of this check might also\n\
    \   cause the state of other checks to change as well.  The agent MUST\n   perform\
    \ the following two steps:\n   1.  The agent changes the states for all other\
    \ Frozen pairs for the\n       same media stream and same foundation to Waiting.\
    \  Typically, but\n       not always, these other pairs will have different component\
    \ IDs.\n   2.  If there is a pair in the valid list for every component of this\n\
    \       media stream (where this is the actual number of components being\n  \
    \     used, in cases where the number of components signaled in the SDP\n    \
    \   differs from offerer to answerer), the success of this check may\n       unfreeze\
    \ checks for other media streams.  Note that this step is\n       followed not\
    \ just the first time the valid list under\n       consideration has a pair for\
    \ every component, but every\n       subsequent time a check succeeds and adds\
    \ yet another pair to\n       that valid list.  The agent examines the check list\
    \ for each\n       other media stream in turn:\n       *  If the check list is\
    \ active, the agent changes the state of\n          all Frozen pairs in that check\
    \ list whose foundation matches a\n          pair in the valid list under consideration\
    \ to Waiting.\n       *  If the check list is frozen, and there is at least one\
    \ pair in\n          the check list whose foundation matches a pair in the valid\n\
    \          list under consideration, the state of all pairs in the check\n   \
    \       list whose foundation matches a pair in the valid list under\n       \
    \   consideration is set to Waiting.  This will cause the check\n          list\
    \ to become active, and ordinary checks will begin for it,\n          as described\
    \ in Section 5.8.\n       *  If the check list is frozen, and there are no pairs\
    \ in the\n          check list whose foundation matches a pair in the valid list\n\
    \          under consideration, the agent\n          +  groups together all of\
    \ the pairs with the same foundation,\n             and\n          +  for each\
    \ group, sets the state of the pair with the lowest\n             component ID\
    \ to Waiting.  If there is more than one such\n             pair, the one with\
    \ the highest priority is used.\n"
- title: 7.1.3.2.4.  Updating the Nominated Flag
  contents:
  - "7.1.3.2.4.  Updating the Nominated Flag\n   If the agent was a controlling agent,\
    \ and it had included a USE-\n   CANDIDATE attribute in the Binding request, the\
    \ valid pair generated\n   from that check has its nominated flag set to true.\
    \  This flag\n   indicates that this valid pair should be used for media if it\
    \ is the\n   highest-priority one amongst those whose nominated flag is set. \
    \ This\n   may conclude ICE processing for this media stream or all media\n  \
    \ streams; see Section 8.\n   If the agent is the controlled agent, the response\
    \ may be the result\n   of a triggered check that was sent in response to a request\
    \ that\n   itself had the USE-CANDIDATE attribute.  This case is described in\n\
    \   Section 7.2.1.5, and may now result in setting the nominated flag for\n  \
    \ the pair learned from the original request.\n"
- title: 7.1.3.3.  Check List and Timer State Updates
  contents:
  - "7.1.3.3.  Check List and Timer State Updates\n   Regardless of whether the check\
    \ was successful or failed, the\n   completion of the transaction may require\
    \ updating of check list and\n   timer states.\n   If all of the pairs in the\
    \ check list are now either in the Failed or\n   Succeeded state:\n   o  If there\
    \ is not a pair in the valid list for each component of the\n      media stream,\
    \ the state of the check list is set to Failed.\n   o  For each frozen check list,\
    \ the agent\n      *  groups together all of the pairs with the same foundation,\
    \ and\n      *  for each group, sets the state of the pair with the lowest\n \
    \        component ID to Waiting.  If there is more than one such pair,\n    \
    \     the one with the highest priority is used.\n   If none of the pairs in the\
    \ check list are in the Waiting or Frozen\n   state, the check list is no longer\
    \ considered active, and will not\n   count towards the value of N in the computation\
    \ of timers for\n   ordinary checks as described in Section 5.8.\n"
- title: 7.2.  STUN Server Procedures
  contents:
  - "7.2.  STUN Server Procedures\n   An agent MUST be prepared to receive a Binding\
    \ request on the base of\n   each candidate it included in its most recent offer\
    \ or answer.  This\n   requirement holds even if the peer is a lite implementation.\n\
    \   The agent MUST use a short-term credential to authenticate the\n   request\
    \ and perform a message integrity check.  The agent MUST\n   consider the username\
    \ to be valid if it consists of two values\n   separated by a colon, where the\
    \ first value is equal to the username\n   fragment generated by the agent in\
    \ an offer or answer for a session\n   in-progress.  It is possible (and in fact\
    \ very likely) that an\n   offerer will receive a Binding request prior to receiving\
    \ the answer\n   from its peer.  If this happens, the agent MUST immediately generate\n\
    \   a response (including computation of the mapped address as described\n   in\
    \ Section 7.2.1.2).  The agent has sufficient information at this\n   point to\
    \ generate the response; the password from the peer is not\n   required.  Once\
    \ the answer is received, it MUST proceed with the\n   remaining steps required,\
    \ namely, 7.2.1.3, 7.2.1.4, and 7.2.1.5 for\n   full implementations.  In cases\
    \ where multiple STUN requests are\n   received before the answer, this may cause\
    \ several pairs to be queued\n   up in the triggered check queue.\n   An agent\
    \ MUST NOT utilize the ALTERNATE-SERVER mechanism, and MUST\n   NOT support the\
    \ backwards-compatibility mechanisms to RFC 3489.  It\n   MUST utilize the FINGERPRINT\
    \ mechanism.\n   If the agent is using Diffserv Codepoint markings [RFC2475] in\
    \ its\n   media packets, it SHOULD apply those same markings to its responses\n\
    \   to Binding requests.  The same would apply to any layer 2 markings\n   the\
    \ endpoint might be applying to media packets.\n"
- title: 7.2.1.  Additional Procedures for Full Implementations
  contents:
  - "7.2.1.  Additional Procedures for Full Implementations\n   This subsection defines\
    \ the additional server procedures applicable\n   to full implementations.\n"
- title: 7.2.1.1.  Detecting and Repairing Role Conflicts
  contents:
  - "7.2.1.1.  Detecting and Repairing Role Conflicts\n   Normally, the rules for\
    \ selection of a role in Section 5.2 will\n   result in each agent selecting a\
    \ different role -- one controlling\n   and one controlled.  However, in unusual\
    \ call flows, typically\n   utilizing third party call control, it is possible\
    \ for both agents to\n   select the same role.  This section describes procedures\
    \ for checking\n   for this case and repairing it.\n   An agent MUST examine the\
    \ Binding request for either the ICE-\n   CONTROLLING or ICE-CONTROLLED attribute.\
    \  It MUST follow these\n   procedures:\n   o  If neither ICE-CONTROLLING nor\
    \ ICE-CONTROLLED is present in the\n      request, the peer agent may have implemented\
    \ a previous version of\n      this specification.  There may be a conflict, but\
    \ it cannot be\n      detected.\n   o  If the agent is in the controlling role,\
    \ and the ICE-CONTROLLING\n      attribute is present in the request:\n      *\
    \  If the agent's tie-breaker is larger than or equal to the\n         contents\
    \ of the ICE-CONTROLLING attribute, the agent generates\n         a Binding error\
    \ response and includes an ERROR-CODE attribute\n         with a value of 487\
    \ (Role Conflict) but retains its role.\n      *  If the agent's tie-breaker is\
    \ less than the contents of the\n         ICE-CONTROLLING attribute, the agent\
    \ switches to the controlled\n         role.\n   o  If the agent is in the controlled\
    \ role, and the ICE-CONTROLLED\n      attribute is present in the request:\n \
    \     *  If the agent's tie-breaker is larger than or equal to the\n         contents\
    \ of the ICE-CONTROLLED attribute, the agent switches to\n         the controlling\
    \ role.\n      *  If the agent's tie-breaker is less than the contents of the\n\
    \         ICE-CONTROLLED attribute, the agent generates a Binding error\n    \
    \     response and includes an ERROR-CODE attribute with a value of\n        \
    \ 487 (Role Conflict) but retains its role.\n   o  If the agent is in the controlled\
    \ role and the ICE-CONTROLLING\n      attribute was present in the request, or\
    \ the agent was in the\n      controlling role and the ICE-CONTROLLED attribute\
    \ was present in\n      the request, there is no conflict.\n   A change in roles\
    \ will require an agent to recompute pair priorities\n   (Section 5.7.2), since\
    \ those priorities are a function of controlling\n   and controlled roles.  The\
    \ change in role will also impact whether\n   the agent is responsible for selecting\
    \ nominated pairs and generated\n   updated offers upon conclusion of ICE.\n \
    \  The remaining sections in Section 7.2.1 are followed if the server\n   generated\
    \ a successful response to the Binding request, even if the\n   agent changed\
    \ roles.\n"
- title: 7.2.1.2.  Computing Mapped Address
  contents:
  - "7.2.1.2.  Computing Mapped Address\n   For requests being received on a relayed\
    \ candidate, the source\n   transport address used for STUN processing (namely,\
    \ generation of the\n   XOR-MAPPED-ADDRESS attribute) is the transport address\
    \ as seen by the\n   TURN server.  That source transport address will be present\
    \ in the\n   XOR-PEER-ADDRESS attribute of a Data Indication message, if the\n\
    \   Binding request was delivered through a Data Indication.  If the\n   Binding\
    \ request was delivered through a ChannelData message, the\n   source transport\
    \ address is the one that was bound to the channel.\n"
- title: 7.2.1.3.  Learning Peer Reflexive Candidates
  contents:
  - "7.2.1.3.  Learning Peer Reflexive Candidates\n   If the source transport address\
    \ of the request does not match any\n   existing remote candidates, it represents\
    \ a new peer reflexive remote\n   candidate.  This candidate is constructed as\
    \ follows:\n   o  The priority of the candidate is set to the PRIORITY attribute\n\
    \      from the request.\n   o  The type of the candidate is set to peer reflexive.\n\
    \   o  The foundation of the candidate is set to an arbitrary value,\n      different\
    \ from the foundation for all other remote candidates.  If\n      any subsequent\
    \ offer/answer exchanges contain this peer reflexive\n      candidate in the SDP,\
    \ it will signal the actual foundation for the\n      candidate.\n   o  The component\
    \ ID of this candidate is set to the component ID for\n      the local candidate\
    \ to which the request was sent.\n   This candidate is added to the list of remote\
    \ candidates.  However,\n   the agent does not pair this candidate with any local\
    \ candidates.\n"
- title: 7.2.1.4.  Triggered Checks
  contents:
  - "7.2.1.4.  Triggered Checks\n   Next, the agent constructs a pair whose local\
    \ candidate is equal to\n   the transport address on which the STUN request was\
    \ received, and a\n   remote candidate equal to the source transport address where\
    \ the\n   request came from (which may be the peer reflexive remote candidate\n\
    \   that was just learned).  The local candidate will either be a host\n   candidate\
    \ (for cases where the request was not received through a\n   relay) or a relayed\
    \ candidate (for cases where it is received through\n   a relay).  The local candidate\
    \ can never be a server reflexive\n   candidate.  Since both candidates are known\
    \ to the agent, it can\n   obtain their priorities and compute the candidate pair\
    \ priority.\n   This pair is then looked up in the check list.  There can be one\
    \ of\n   several outcomes:\n   o  If the pair is already on the check list:\n\
    \      *  If the state of that pair is Waiting or Frozen, a check for\n      \
    \   that pair is enqueued into the triggered check queue if not\n         already\
    \ present.\n      *  If the state of that pair is In-Progress, the agent cancels\
    \ the\n         in-progress transaction.  Cancellation means that the agent\n\
    \         will not retransmit the request, will not treat the lack of\n      \
    \   response to be a failure, but will wait the duration of the\n         transaction\
    \ timeout for a response.  In addition, the agent\n         MUST create a new\
    \ connectivity check for that pair\n         (representing a new STUN Binding\
    \ request transaction) by\n         enqueueing the pair in the triggered check\
    \ queue.  The state of\n         the pair is then changed to Waiting.\n      *\
    \  If the state of the pair is Failed, it is changed to Waiting\n         and\
    \ the agent MUST create a new connectivity check for that\n         pair (representing\
    \ a new STUN Binding request transaction), by\n         enqueueing the pair in\
    \ the triggered check queue.\n      *  If the state of that pair is Succeeded,\
    \ nothing further is\n         done.\n      These steps are done to facilitate\
    \ rapid completion of ICE when\n      both agents are behind NAT.\n   o  If the\
    \ pair is not already on the check list:\n      *  The pair is inserted into the\
    \ check list based on its priority.\n      *  Its state is set to Waiting.\n \
    \     *  The pair is enqueued into the triggered check queue.\n   When a triggered\
    \ check is to be sent, it is constructed and processed\n   as described in Section\
    \ 7.1.2.  These procedures require the agent to\n   know the transport address,\
    \ username fragment, and password for the\n   peer.  The username fragment for\
    \ the remote candidate is equal to the\n   part after the colon of the USERNAME\
    \ in the Binding request that was\n   just received.  Using that username fragment,\
    \ the agent can check the\n   SDP messages received from its peer (there may be\
    \ more than one in\n   cases of forking), and find this username fragment.  The\n\
    \   corresponding password is then selected.\n"
- title: 7.2.1.5.  Updating the Nominated Flag
  contents:
  - "7.2.1.5.  Updating the Nominated Flag\n   If the Binding request received by\
    \ the agent had the USE-CANDIDATE\n   attribute set, and the agent is in the controlled\
    \ role, the agent\n   looks at the state of the pair computed in Section 7.2.1.4:\n\
    \   o  If the state of this pair is Succeeded, it means that the check\n     \
    \ generated by this pair produced a successful response.  This would\n      have\
    \ caused the agent to construct a valid pair when that success\n      response\
    \ was received (see Section 7.1.3.2.2).  The agent now sets\n      the nominated\
    \ flag in the valid pair to true.  This may end ICE\n      processing for this\
    \ media stream; see Section 8.\n   o  If the state of this pair is In-Progress,\
    \ if its check produces a\n      successful result, the resulting valid pair has\
    \ its nominated flag\n      set when the response arrives.  This may end ICE processing\
    \ for\n      this media stream when it arrives; see Section 8.\n"
- title: 7.2.2.  Additional Procedures for Lite Implementations
  contents:
  - "7.2.2.  Additional Procedures for Lite Implementations\n   If the check that\
    \ was just received contained a USE-CANDIDATE\n   attribute, the agent constructs\
    \ a candidate pair whose local\n   candidate is equal to the transport address\
    \ on which the request was\n   received, and whose remote candidate is equal to\
    \ the source transport\n   address of the request that was received.  This candidate\
    \ pair is\n   assigned an arbitrary priority, and placed into a list of valid\n\
    \   candidates called the valid list.  The agent sets the nominated flag\n   for\
    \ that pair to true.  ICE processing is considered complete for a\n   media stream\
    \ if the valid list contains a candidate pair for each\n   component.\n"
- title: 8.  Concluding ICE Processing
  contents:
  - "8.  Concluding ICE Processing\n   This section describes how an agent completes\
    \ ICE.\n"
- title: 8.1.  Procedures for Full Implementations
  contents:
  - "8.1.  Procedures for Full Implementations\n   Concluding ICE involves nominating\
    \ pairs by the controlling agent and\n   updating of state machinery.\n"
- title: 8.1.1.  Nominating Pairs
  contents:
  - "8.1.1.  Nominating Pairs\n   The controlling agent nominates pairs to be selected\
    \ by ICE by using\n   one of two techniques: regular nomination or aggressive\
    \ nomination.\n   If its peer has a lite implementation, an agent MUST use a regular\n\
    \   nomination algorithm.  If its peer is using ICE options (present in\n   an\
    \ ice-options attribute from the peer) that the agent does not\n   understand,\
    \ the agent MUST use a regular nomination algorithm.  If\n   its peer is a full\
    \ implementation and isn't using any ICE options or\n   is using ICE options understood\
    \ by the agent, the agent MAY use\n   either the aggressive or the regular nomination\
    \ algorithm.  However,\n   the regular algorithm is RECOMMENDED since it provides\
    \ greater\n   stability.\n"
- title: 8.1.1.1.  Regular Nomination
  contents:
  - "8.1.1.1.  Regular Nomination\n   With regular nomination, the agent lets some\
    \ number of checks\n   complete, each of which omit the USE-CANDIDATE attribute.\
    \  Once one\n   or more checks complete successfully for a component of a media\n\
    \   stream, valid pairs are generated and added to the valid list.  The\n   agent\
    \ lets the checks continue until some stopping criterion is met,\n   and then\
    \ picks amongst the valid pairs based on an evaluation\n   criterion.  The criteria\
    \ for stopping the checks and for evaluating\n   the valid pairs is entirely a\
    \ matter of local optimization.\n   When the controlling agent selects the valid\
    \ pair, it repeats the\n   check that produced this valid pair (by enqueuing the\
    \ pair that\n   generated the check into the triggered check queue), this time\
    \ with\n   the USE-CANDIDATE attribute.  This check should succeed (since the\n\
    \   previous did), causing the nominated flag of that and only that pair\n   to\
    \ be set.  Consequently, there will be only a single nominated pair\n   in the\
    \ valid list for each component, and when the state of the check\n   list moves\
    \ to completed, that exact pair is selected by ICE for\n   sending and receiving\
    \ media for that component.\n   Regular nomination provides the most flexibility,\
    \ since the agent has\n   control over the stopping and selection criteria for\
    \ checks.  The\n   only requirement is that the agent MUST eventually pick one\
    \ and only\n   one candidate pair and generate a check for that pair with the\
    \ USE-\n   CANDIDATE attribute present.  Regular nomination also improves ICE's\n\
    \   resilience to variations in implementation (see Section 14).  Regular\n  \
    \ nomination is also more stable, allowing both agents to converge on a\n   single\
    \ pair for media without any transient selections, which can\n   happen with the\
    \ aggressive algorithm.  The drawback of regular\n   nomination is that it is\
    \ guaranteed to increase latencies because it\n   requires an additional check\
    \ to be done.\n"
- title: 8.1.1.2.  Aggressive Nomination
  contents:
  - "8.1.1.2.  Aggressive Nomination\n   With aggressive nomination, the controlling\
    \ agent includes the USE-\n   CANDIDATE attribute in every check it sends.  Once\
    \ the first check\n   for a component succeeds, it will be added to the valid\
    \ list and have\n   its nominated flag set.  When all components have a nominated\
    \ pair in\n   the valid list, media can begin to flow using the highest priority\n\
    \   nominated pair.  However, because the agent included the USE-\n   CANDIDATE\
    \ attribute in all of its checks, another check may yet\n   complete, causing\
    \ another valid pair to have its nominated flag set.\n   ICE always selects the\
    \ highest-priority nominated candidate pair from\n   the valid list as the one\
    \ used for media.  Consequently, the selected\n   pair may actually change briefly\
    \ as ICE checks complete, resulting in\n   a set of transient selections until\
    \ it stabilizes.\n"
- title: 8.1.2.  Updating States
  contents:
  - "8.1.2.  Updating States\n   For both controlling and controlled agents, the state\
    \ of ICE\n   processing depends on the presence of nominated candidate pairs in\n\
    \   the valid list and on the state of the check list.  Note that, at any\n  \
    \ time, more than one of the following cases can apply:\n   o  If there are no\
    \ nominated pairs in the valid list for a media\n      stream and the state of\
    \ the check list is Running, ICE processing\n      continues.\n   o  If there\
    \ is at least one nominated pair in the valid list for a\n      media stream and\
    \ the state of the check list is Running:\n      *  The agent MUST remove all\
    \ Waiting and Frozen pairs in the check\n         list and triggered check queue\
    \ for the same component as the\n         nominated pairs for that media stream.\n\
    \      *  If an In-Progress pair in the check list is for the same\n         component\
    \ as a nominated pair, the agent SHOULD cease\n         retransmissions for its\
    \ check if its pair priority is lower\n         than the lowest-priority nominated\
    \ pair for that component.\n   o  Once there is at least one nominated pair in\
    \ the valid list for\n      every component of at least one media stream and the\
    \ state of the\n      check list is Running:\n      *  The agent MUST change the\
    \ state of processing for its check\n         list for that media stream to Completed.\n\
    \      *  The agent MUST continue to respond to any checks it may still\n    \
    \     receive for that media stream, and MUST perform triggered\n         checks\
    \ if required by the processing of Section 7.2.\n      *  The agent MUST continue\
    \ retransmitting any In-Progress checks\n         for that check list.\n     \
    \ *  The agent MAY begin transmitting media for this media stream as\n       \
    \  described in Section 11.1.\n   o  Once the state of each check list is Completed:\n\
    \      *  The agent sets the state of ICE processing overall to\n         Completed.\n\
    \      *  If an agent is controlling, it examines the highest-priority\n     \
    \    nominated candidate pair for each component of each media\n         stream.\
    \  If any of those candidate pairs differ from the\n         default candidate\
    \ pairs in the most recent offer/answer\n         exchange, the controlling agent\
    \ MUST generate an updated offer\n         as described in Section 9.  If the\
    \ controlling agent is using\n         an aggressive nomination algorithm, this\
    \ may result in several\n         updated offers as the pairs selected for media\
    \ change.  An\n         agent MAY delay sending the offer for a brief interval\
    \ (one\n         second is RECOMMENDED) in order to allow the selected pairs to\n\
    \         stabilize.\n   o  If the state of the check list is Failed, ICE has\
    \ not been able to\n      complete for this media stream.  The correct behavior\
    \ depends on\n      the state of the check lists for other media streams:\n  \
    \    *  If all check lists are Failed, ICE processing overall is\n         considered\
    \ to be in the Failed state, and the agent SHOULD\n         consider the session\
    \ a failure, SHOULD NOT restart ICE, and the\n         controlling agent SHOULD\
    \ terminate the entire session.\n      *  If at least one of the check lists for\
    \ other media streams is\n         Completed, the controlling agent SHOULD remove\
    \ the failed media\n         stream from the session in its updated offer.\n \
    \     *  If none of the check lists for other media streams are\n         Completed,\
    \ but at least one is Running, the agent SHOULD let\n         ICE continue.\n"
- title: 8.2.  Procedures for Lite Implementations
  contents:
  - "8.2.  Procedures for Lite Implementations\n   Concluding ICE for a lite implementation\
    \ is relatively\n   straightforward.  There are two cases to consider:\n     \
    \ The implementation is lite, and its peer is full.\n      The implementation\
    \ is lite, and its peer is lite.\n   The effect of ICE concluding is that the\
    \ agent can free any allocated\n   host candidates that were not utilized by ICE,\
    \ as described in\n   Section 8.3.\n"
- title: 8.2.1.  Peer Is Full
  contents:
  - "8.2.1.  Peer Is Full\n   In this case, the agent will receive connectivity checks\
    \ from its\n   peer.  When an agent has received a connectivity check that includes\n\
    \   the USE-CANDIDATE attribute for each component of a media stream, the\n  \
    \ state of ICE processing for that media stream moves from Running to\n   Completed.\
    \  When the state of ICE processing for all media streams is\n   Completed, the\
    \ state of ICE processing overall is Completed.\n   The lite implementation will\
    \ never itself determine that ICE\n   processing has failed for a media stream;\
    \ rather, the full peer will\n   make that determination and then remove or restart\
    \ the failed media\n   stream in a subsequent offer.\n"
- title: 8.2.2.  Peer Is Lite
  contents:
  - "8.2.2.  Peer Is Lite\n   Once the offer/answer exchange has completed, both agents\
    \ examine\n   their candidates and those of its peer.  For each media stream,\
    \ each\n   agent pairs up its own candidates with the candidates of its peer for\n\
    \   that media stream.  Two candidates are paired up when they are for\n   the\
    \ same component, utilize the same transport protocol (UDP in this\n   specification),\
    \ and are from the same IP address family (IPv4 or\n   IPv6).\n   o  If there\
    \ is a single pair per component, that pair is added to the\n      Valid list.\
    \  If all of the components for a media stream had one\n      pair, the state\
    \ of ICE processing for that media stream is set to\n      Completed.  If all\
    \ media streams are Completed, the state of ICE\n      processing is set to Completed\
    \ overall.  This will always be the\n      case for implementations that are IPv4\
    \ only.\n   o  If there is more than one pair per component:\n      *  The agent\
    \ MUST select a pair based on local policy.  Since this\n         case only arises\
    \ for IPv6, it is RECOMMENDED that an agent\n         follow the procedures of\
    \ RFC 3484 [RFC3484] to select a single\n         pair.\n      *  The agent adds\
    \ the selected pair for each component to the\n         valid list.  As described\
    \ in Section 11.1, this will permit\n         media to begin flowing.  However,\
    \ it is possible (and in fact\n         likely) that both agents have chosen different\
    \ pairs.\n      *  To reconcile this, the controlling agent MUST send an updated\n\
    \         offer as described in Section 9.1.3, which will include the\n      \
    \   remote-candidates attribute.\n      *  The agent MUST NOT update the state\
    \ of ICE processing when the\n         offer is sent.  If this subsequent offer\
    \ completes, the\n         controlling agent MUST change the state of ICE processing\
    \ to\n         Completed for all media streams, and the state of ICE\n       \
    \  processing overall to Completed.  The states for the controlled\n         agent\
    \ are set based on the logic in Section 9.2.3.\n"
- title: 8.3.  Freeing Candidates
  contents:
  - '8.3.  Freeing Candidates

    '
- title: 8.3.1.  Full Implementation Procedures
  contents:
  - "8.3.1.  Full Implementation Procedures\n   The procedures in Section 8 require\
    \ that an agent continue to listen\n   for STUN requests and continue to generate\
    \ triggered checks for a\n   media stream, even once processing for that stream\
    \ completes.  The\n   rules in this section describe when it is safe for an agent\
    \ to cease\n   sending or receiving checks on a candidate that was not selected\
    \ by\n   ICE, and then free the candidate.\n   When ICE is used with SIP, and\
    \ an offer is forked to multiple\n   recipients, ICE proceeds in parallel and\
    \ independently with each\n   answerer, all using the same local candidates. \
    \ Once ICE processing\n   has reached the Completed state for all peers for media\
    \ streams using\n   those candidates, the agent SHOULD wait an additional three\
    \ seconds,\n   and then it MAY cease responding to checks or generating triggered\n\
    \   checks on that candidate.  It MAY free the candidate at that time.\n   Freeing\
    \ of server reflexive candidates is never explicit; it happens\n   by lack of\
    \ a keepalive.  The three-second delay handles cases when\n   aggressive nomination\
    \ is used, and the selected pairs can quickly\n   change after ICE has completed.\n"
- title: 8.3.2.  Lite Implementation Procedures
  contents:
  - "8.3.2.  Lite Implementation Procedures\n   A lite implementation MAY free candidates\
    \ not selected by ICE as soon\n   as ICE processing has reached the Completed\
    \ state for all peers for\n   all media streams using those candidates.\n"
- title: 9.  Subsequent Offer/Answer Exchanges
  contents:
  - "9.  Subsequent Offer/Answer Exchanges\n   Either agent MAY generate a subsequent\
    \ offer at any time allowed by\n   RFC 3264 [RFC3264].  The rules in Section 8\
    \ will cause the\n   controlling agent to send an updated offer at the conclusion\
    \ of ICE\n   processing when ICE has selected different candidate pairs from the\n\
    \   default pairs.  This section defines rules for construction of\n   subsequent\
    \ offers and answers.\n   Should a subsequent offer be rejected, ICE processing\
    \ continues as if\n   the subsequent offer had never been made.\n"
- title: 9.1.  Generating the Offer
  contents:
  - '9.1.  Generating the Offer

    '
- title: 9.1.1.  Procedures for All Implementations
  contents:
  - '9.1.1.  Procedures for All Implementations

    '
- title: 9.1.1.1.  ICE Restarts
  contents:
  - "9.1.1.1.  ICE Restarts\n   An agent MAY restart ICE processing for an existing\
    \ media stream.  An\n   ICE restart, as the name implies, will cause all previous\
    \ states of\n   ICE processing to be flushed and checks to start anew.  The only\n\
    \   difference between an ICE restart and a brand new media session is\n   that,\
    \ during the restart, media can continue to be sent to the\n   previously validated\
    \ pair.\n   An agent MUST restart ICE for a media stream if:\n   o  The offer\
    \ is being generated for the purposes of changing the\n      target of the media\
    \ stream.  In other words, if an agent wants to\n      generate an updated offer\
    \ that, had ICE not been in use, would\n      result in a new value for the destination\
    \ of a media component.\n   o  An agent is changing its implementation level.\
    \  This typically\n      only happens in third party call control use cases, where\
    \ the\n      entity performing the signaling is not the entity receiving the\n\
    \      media, and it has changed the target of media mid-session to\n      another\
    \ entity that has a different ICE implementation.\n   These rules imply that setting\
    \ the IP address in the c line to\n   0.0.0.0 will cause an ICE restart.  Consequently,\
    \ ICE implementations\n   MUST NOT utilize this mechanism for call hold, and instead\
    \ MUST use\n   a=inactive and a=sendonly as described in [RFC3264].\n   To restart\
    \ ICE, an agent MUST change both the ice-pwd and the ice-\n   ufrag for the media\
    \ stream in an offer.  Note that it is permissible\n   to use a session-level\
    \ attribute in one offer, but to provide the\n   same ice-pwd or ice-ufrag as\
    \ a media-level attribute in a subsequent\n   offer.  This is not a change in\
    \ password, just a change in its\n   representation, and does not cause an ICE\
    \ restart.\n   An agent sets the rest of the fields in the SDP for this media\
    \ stream\n   as it would in an initial offer of this media stream (see\n   Section\
    \ 4.3).  Consequently, the set of candidates MAY include some,\n   none, or all\
    \ of the previous candidates for that stream and MAY\n   include a totally new\
    \ set of candidates gathered as described in\n   Section 4.1.1.\n"
- title: 9.1.1.2.  Removing a Media Stream
  contents:
  - "9.1.1.2.  Removing a Media Stream\n   If an agent removes a media stream by setting\
    \ its port to zero, it\n   MUST NOT include any candidate attributes for that\
    \ media stream and\n   SHOULD NOT include any other ICE-related attributes defined\
    \ in\n   Section 15 for that media stream.\n"
- title: 9.1.1.3.  Adding a Media Stream
  contents:
  - "9.1.1.3.  Adding a Media Stream\n   If an agent wishes to add a new media stream,\
    \ it sets the fields in\n   the SDP for this media stream as if this was an initial\
    \ offer for\n   that media stream (see Section 4.3).  This will cause ICE processing\n\
    \   to begin for this media stream.\n"
- title: 9.1.2.  Procedures for Full Implementations
  contents:
  - "9.1.2.  Procedures for Full Implementations\n   This section describes additional\
    \ procedures for full\n   implementations, covering existing media streams.\n\
    \   The username fragments, password, and implementation level MUST\n   remain\
    \ the same as used previously.  If an agent needs to change one\n   of these,\
    \ it MUST restart ICE for that media stream.\n   Additional behavior depends on\
    \ the state ICE processing for that\n   media stream.\n"
- title: 9.1.2.1.  Existing Media Streams with ICE Running
  contents:
  - "9.1.2.1.  Existing Media Streams with ICE Running\n   If an agent generates an\
    \ updated offer including a media stream that\n   was previously established,\
    \ and for which ICE checks are in the\n   Running state, the agent follows the\
    \ procedures defined here.\n   An agent MUST include candidate attributes for\
    \ all local candidates\n   it had signaled previously for that media stream. \
    \ The properties of\n   that candidate as signaled in SDP -- the priority, foundation,\
    \ type,\n   and related transport address -- SHOULD remain the same.  The IP\n\
    \   address, port, and transport protocol, which fundamentally identify\n   that\
    \ candidate, MUST remain the same (if they change, it would be a\n   new candidate).\
    \  The component ID MUST remain the same.  The agent\n   MAY include additional\
    \ candidates it did not offer previously, but\n   which it has gathered since\
    \ the last offer/answer exchange, including\n   peer reflexive candidates.\n \
    \  The agent MAY change the default destination for media.  As with\n   initial\
    \ offers, there MUST be a set of candidate attributes in the\n   offer matching\
    \ this default destination.\n"
- title: 9.1.2.2.  Existing Media Streams with ICE Completed
  contents:
  - "9.1.2.2.  Existing Media Streams with ICE Completed\n   If an agent generates\
    \ an updated offer including a media stream that\n   was previously established,\
    \ and for which ICE checks are in the\n   Completed state, the agent follows the\
    \ procedures defined here.\n   The default destination for media (i.e., the values\
    \ of the IP\n   addresses and ports in the m and c lines used for that media stream)\n\
    \   MUST be the local candidate from the highest-priority nominated pair\n   in\
    \ the valid list for each component.  This \"fixes\" the default\n   destination\
    \ for media to equal the destination ICE has selected for\n   media.\n   The agent\
    \ MUST include candidate attributes for candidates matching\n   the default destination\
    \ for each component of the media stream, and\n   MUST NOT include any other candidates.\n\
    \   In addition, if the agent is controlling, it MUST include the\n   a=remote-candidates\
    \ attribute for each media stream whose check list\n   is in the Completed state.\
    \  The attribute contains the remote\n   candidates from the highest-priority\
    \ nominated pair in the valid list\n   for each component of that media stream.\
    \  It is needed to avoid a\n   race condition whereby the controlling agent chooses\
    \ its pairs, but\n   the updated offer beats the connectivity checks to the controlled\n\
    \   agent, which doesn't even know these pairs are valid, let alone\n   selected.\
    \  See Appendix B.6 for elaboration on this race condition.\n"
- title: 9.1.3.  Procedures for Lite Implementations
  contents:
  - '9.1.3.  Procedures for Lite Implementations

    '
- title: 9.1.3.1.  Existing Media Streams with ICE Running
  contents:
  - "9.1.3.1.  Existing Media Streams with ICE Running\n   This section describes\
    \ procedures for lite implementations for\n   existing streams for which ICE is\
    \ running.\n   A lite implementation MUST include all of its candidates for each\n\
    \   component of each media stream in an a=candidate attribute in any\n   subsequent\
    \ offer.  These candidates are formed identically to the\n   procedures for initial\
    \ offers, as described in Section 4.2.\n   A lite implementation MUST NOT add\
    \ additional host candidates in a\n   subsequent offer.  If an agent needs to\
    \ offer additional candidates,\n   it MUST restart ICE.\n   The username fragments,\
    \ password, and implementation level MUST\n   remain the same as used previously.\
    \  If an agent needs to change one\n   of these, it MUST restart ICE for that\
    \ media stream.\n"
- title: 9.1.3.2.  Existing Media Streams with ICE Completed
  contents:
  - "9.1.3.2.  Existing Media Streams with ICE Completed\n   If ICE has completed\
    \ for a media stream, the default destination for\n   that media stream MUST be\
    \ set to the remote candidate of the\n   candidate pair for that component in\
    \ the valid list.  For a lite\n   implementation, there is always just a single\
    \ candidate pair in the\n   valid list for each component of a media stream. \
    \ Additionally, the\n   agent MUST include a candidate attribute for each default\n\
    \   destination.\n   Additionally, if the agent is controlling (which only happens\
    \ when\n   both agents are lite), the agent MUST include the a=remote-candidates\n\
    \   attribute for each media stream.  The attribute contains the remote\n   candidates\
    \ from the candidate pairs in the valid list (one pair for\n   each component\
    \ of each media stream).\n"
- title: 9.2.  Receiving the Offer and Generating an Answer
  contents:
  - '9.2.  Receiving the Offer and Generating an Answer

    '
- title: 9.2.1.  Procedures for All Implementations
  contents:
  - "9.2.1.  Procedures for All Implementations\n   When receiving a subsequent offer\
    \ within an existing session, an\n   agent MUST reapply the verification procedures\
    \ in Section 5.1 without\n   regard to the results of verification from any previous\
    \ offer/answer\n   exchanges.  Indeed, it is possible that a previous offer/answer\n\
    \   exchange resulted in ICE not being used, but it is used as a\n   consequence\
    \ of a subsequent exchange.\n"
- title: 9.2.1.1.  Detecting ICE Restart
  contents:
  - "9.2.1.1.  Detecting ICE Restart\n   If the offer contained a change in the a=ice-ufrag\
    \ or a=ice-pwd\n   attributes compared to the previous SDP from the peer, it indicates\n\
    \   that ICE is restarting for this media stream.  If all media streams\n   are\
    \ restarting, then ICE is restarting overall.\n   If ICE is restarting for a media\
    \ stream:\n   o  The agent MUST change the a=ice-ufrag and a=ice-pwd attributes\
    \ in\n      the answer.\n   o  The agent MAY change its implementation level in\
    \ the answer.\n   An agent sets the rest of the fields in the SDP for this media\
    \ stream\n   as it would in an initial answer to this media stream (see\n   Section\
    \ 4.3).  Consequently, the set of candidates MAY include some,\n   none, or all\
    \ of the previous candidates for that stream and MAY\n   include a totally new\
    \ set of candidates gathered as described in\n   Section 4.1.1.\n"
- title: 9.2.1.2.  New Media Stream
  contents:
  - "9.2.1.2.  New Media Stream\n   If the offer contains a new media stream, the\
    \ agent sets the fields\n   in the answer as if it had received an initial offer\
    \ containing that\n   media stream (see Section 4.3).  This will cause ICE processing\
    \ to\n   begin for this media stream.\n"
- title: 9.2.1.3.  Removed Media Stream
  contents:
  - "9.2.1.3.  Removed Media Stream\n   If an offer contains a media stream whose\
    \ port is zero, the agent\n   MUST NOT include any candidate attributes for that\
    \ media stream in\n   its answer and SHOULD NOT include any other ICE-related\
    \ attributes\n   defined in Section 15 for that media stream.\n"
- title: 9.2.2.  Procedures for Full Implementations
  contents:
  - "9.2.2.  Procedures for Full Implementations\n   Unless the agent has detected\
    \ an ICE restart from the offer, the\n   username fragments, password, and implementation\
    \ level MUST remain\n   the same as used previously.  If an agent needs to change\
    \ one of\n   these it MUST restart ICE for that media stream by generating an\n\
    \   offer; ICE cannot be restarted in an answer.\n   Additional behaviors depend\
    \ on the state of ICE processing for that\n   media stream.\n"
- title: 9.2.2.1.  Existing Media Streams with ICE Running and no remote-
  contents:
  - "9.2.2.1.  Existing Media Streams with ICE Running and no remote-\n          candidates\n\
    \   If ICE is running for a media stream, and the offer for that media\n   stream\
    \ lacked the remote-candidates attribute, the rules for\n   construction of the\
    \ answer are identical to those for the offerer as\n   described in Section 9.1.2.1.\n"
- title: 9.2.2.2.  Existing Media Streams with ICE Completed and no remote-
  contents:
  - "9.2.2.2.  Existing Media Streams with ICE Completed and no remote-\n        \
    \  candidates\n   If ICE is Completed for a media stream, and the offer for that\
    \ media\n   stream lacked the remote-candidates attribute, the rules for\n   construction\
    \ of the answer are identical to those for the offerer as\n   described in Section\
    \ 9.1.2.2, except that the answerer MUST NOT\n   include the a=remote-candidates\
    \ attribute in the answer.\n"
- title: 9.2.2.3.  Existing Media Streams and remote-candidates
  contents:
  - "9.2.2.3.  Existing Media Streams and remote-candidates\n   A controlled agent\
    \ will receive an offer with the a=remote-candidates\n   attribute for a media\
    \ stream when its peer has concluded ICE\n   processing for that media stream.\
    \  This attribute is present in the\n   offer to deal with a race condition between\
    \ the receipt of the offer,\n   and the receipt of the Binding response that tells\
    \ the answerer the\n   candidate that will be selected by ICE.  See Appendix B.6\
    \ for an\n   explanation of this race condition.  Consequently, processing of\
    \ an\n   offer with this attribute depends on the winner of the race.\n   The\
    \ agent forms a candidate pair for each component of the media\n   stream by:\n\
    \   o  Setting the remote candidate equal to the offerer's default\n      destination\
    \ for that component (e.g., the contents of the m and c\n      lines for RTP,\
    \ and the a=rtcp attribute for RTCP)\n   o  Setting the local candidate equal\
    \ to the transport address for\n      that same component in the a=remote-candidates\
    \ attribute in the\n      offer.\n   The agent then sees if each of these candidate\
    \ pairs is present in\n   the valid list.  If a particular pair is not in the\
    \ valid list, the\n   check has \"lost\" the race.  Call such a pair a \"losing\
    \ pair\".\n   The agent finds all the pairs in the check list whose remote\n \
    \  candidates equal the remote candidate in the losing pair:\n   o  If none of\
    \ the pairs are In-Progress, and at least one is Failed,\n      it is most likely\
    \ that a network failure, such as a network\n      partition or serious packet\
    \ loss, has occurred.  The agent SHOULD\n      generate an answer for this media\
    \ stream as if the remote-\n      candidates attribute had not been present, and\
    \ then restart ICE\n      for this stream.\n   o  If at least one of the pairs\
    \ is In-Progress, the agent SHOULD wait\n      for those checks to complete, and\
    \ as each completes, redo the\n      processing in this section until there are\
    \ no losing pairs.\n   Once there are no losing pairs, the agent can generate\
    \ the answer.\n   It MUST set the default destination for media to the candidates\
    \ in\n   the remote-candidates attribute from the offer (each of which will\n\
    \   now be the local candidate of a candidate pair in the valid list).\n   It\
    \ MUST include a candidate attribute in the answer for each\n   candidate in the\
    \ remote-candidates attribute in the offer.\n"
- title: 9.2.3.  Procedures for Lite Implementations
  contents:
  - "9.2.3.  Procedures for Lite Implementations\n   If the received offer contains\
    \ the remote-candidates attribute for a\n   media stream, the agent forms a candidate\
    \ pair for each component of\n   the media stream by:\n   o  Setting the remote\
    \ candidate equal to the offerer's default\n      destination for that component\
    \ (e.g., the contents of the m and c\n      lines for RTP, and the a=rtcp attribute\
    \ for RTCP).\n   o  Setting the local candidate equal to the transport address\
    \ for\n      that same component in the a=remote-candidates attribute in the\n\
    \      offer.\n   It then places those candidates into the Valid list for the\
    \ media\n   stream.  The state of ICE processing for that media stream is set\
    \ to\n   Completed.\n   Furthermore, if the agent believed it was controlling,\
    \ but the offer\n   contained the remote-candidates attribute, both agents believe\
    \ they\n   are controlling.  In this case, both would have sent updated offers\n\
    \   around the same time.  However, the signaling protocol carrying the\n   offer/answer\
    \ exchanges will have resolved this glare condition, so\n   that one agent is\
    \ always the 'winner' by having its offer received\n   before its peer has sent\
    \ an offer.  The winner takes the role of\n   controlled, so that the loser (the\
    \ answerer under consideration in\n   this section) MUST change its role to controlled.\
    \  Consequently, if\n   the agent was going to send an updated offer since, based\
    \ on the\n   rules in Section 8.2.2, it was controlling, it no longer needs to.\n\
    \   Besides the potential role change, change in the Valid list, and\n   state\
    \ changes, the construction of the answer is performed\n   identically to the\
    \ construction of an offer as described in\n   Section 9.1.3.\n"
- title: 9.3.  Updating the Check and Valid Lists
  contents:
  - '9.3.  Updating the Check and Valid Lists

    '
- title: 9.3.1.  Procedures for Full Implementations
  contents:
  - '9.3.1.  Procedures for Full Implementations

    '
- title: 9.3.1.1.  ICE Restarts
  contents:
  - "9.3.1.1.  ICE Restarts\n   The agent MUST remember the highest-priority nominated\
    \ pairs in the\n   Valid list for each component of the media stream, called the\n\
    \   previous selected pairs, prior to the restart.  The agent will\n   continue\
    \ to send media using these pairs, as described in\n   Section 11.1.  Once these\
    \ destinations are noted, the agent MUST\n   flush the valid and check lists,\
    \ and then recompute the check list\n   and its states as described in Section\
    \ 5.7.\n"
- title: 9.3.1.2.  New Media Stream
  contents:
  - "9.3.1.2.  New Media Stream\n   If the offer/answer exchange added a new media\
    \ stream, the agent MUST\n   create a new check list for it (and an empty Valid\
    \ list to start of\n   course), as described in Section 5.7.\n"
- title: 9.3.1.3.  Removed Media Stream
  contents:
  - "9.3.1.3.  Removed Media Stream\n   If the offer/answer exchange removed a media\
    \ stream, or an answer\n   rejected an offered media stream, an agent MUST flush\
    \ the Valid list\n   for that media stream.  It MUST terminate any STUN transactions\
    \ in\n   progress for that media stream.  An agent MUST remove the check list\n\
    \   for that media stream and cancel any pending ordinary checks for it.\n"
- title: 9.3.1.4.  ICE Continuing for Existing Media Stream
  contents:
  - "9.3.1.4.  ICE Continuing for Existing Media Stream\n   The valid list is not\
    \ affected by an updated offer/answer exchange\n   unless ICE is restarting.\n\
    \   If an agent is in the Running state for that media stream, the check\n   list\
    \ is updated (the check list is irrelevant if the state is\n   completed).  To\
    \ do that, the agent recomputes the check list using\n   the procedures described\
    \ in Section 5.7.  If a pair on the new check\n   list was also on the previous\
    \ check list, and its state was Waiting,\n   In-Progress, Succeeded, or Failed,\
    \ its state is copied over.\n   Otherwise, its state is set to Frozen.\n   If\
    \ none of the check lists are active (meaning that the pairs in each\n   check\
    \ list are Frozen), the full-mode agent sets the first pair in\n   the check list\
    \ for the first media stream to Waiting, and then sets\n   the state of all other\
    \ pairs in that check list for the same\n   component ID and with the same foundation\
    \ to Waiting as well.\n   Next, the agent goes through each check list, starting\
    \ with the\n   highest-priority pair.  If a pair has a state of Succeeded, and\
    \ it\n   has a component ID of 1, then all Frozen pairs in the same check list\n\
    \   with the same foundation whose component IDs are not 1 have their\n   state\
    \ set to Waiting.  If, for a particular check list, there are\n   pairs for each\
    \ component of that media stream in the Succeeded state,\n   the agent moves the\
    \ state of all Frozen pairs for the first component\n   of all other media streams\
    \ (and thus in different check lists) with\n   the same foundation to Waiting.\n"
- title: 9.3.2.  Procedures for Lite Implementations
  contents:
  - "9.3.2.  Procedures for Lite Implementations\n   If ICE is restarting for a media\
    \ stream, the agent MUST start a new\n   Valid list for that media stream.  It\
    \ MUST remember the pairs in the\n   previous Valid list for each component of\
    \ the media stream, called\n   the previous selected pairs, and continue to send\
    \ media there as\n   described in Section 11.1.  The state of ICE processing for\
    \ each\n   media stream MUST change to Running, and the state of ICE processing\n\
    \   MUST change to Running.\n"
- title: 10.  Keepalives
  contents:
  - "10.  Keepalives\n   All endpoints MUST send keepalives for each media session.\
    \  These\n   keepalives serve the purpose of keeping NAT bindings alive for the\n\
    \   media session.  These keepalives MUST be sent regardless of whether\n   the\
    \ media stream is currently inactive, sendonly, recvonly, or\n   sendrecv, and\
    \ regardless of the presence or value of the bandwidth\n   attribute.  These keepalives\
    \ MUST be sent even if ICE is not being\n   utilized for the session at all. \
    \ The keepalive SHOULD be sent using\n   a format that is supported by its peer.\
    \  ICE endpoints allow for\n   STUN-based keepalives for UDP streams, and as such,\
    \ STUN keepalives\n   MUST be used when an agent is a full ICE implementation\
    \ and is\n   communicating with a peer that supports ICE (lite or full).  An agent\n\
    \   can determine that its peer supports ICE by the presence of\n   a=candidate\
    \ attributes for each media session.  If the peer does not\n   support ICE, the\
    \ choice of a packet format for keepalives is a matter\n   of local implementation.\
    \  A format that allows packets to easily be\n   sent in the absence of actual\
    \ media content is RECOMMENDED.  Examples\n   of formats that readily meet this\
    \ goal are RTP No-Op [NO-OP-RTP], and\n   in cases where both sides support it,\
    \ RTP comfort noise [RFC3389].\n   If the peer doesn't support any formats that\
    \ are particularly well\n   suited for keepalives, an agent SHOULD send RTP packets\
    \ with an\n   incorrect version number, or some other form of error that would\n\
    \   cause them to be discarded by the peer.\n   If there has been no packet sent\
    \ on the candidate pair ICE is using\n   for a media component for Tr seconds\
    \ (where packets include those\n   defined for the component (RTP or RTCP) and\
    \ previous keepalives), an\n   agent MUST generate a keepalive on that pair. \
    \ Tr SHOULD be\n   configurable and SHOULD have a default of 15 seconds.  Tr MUST\
    \ NOT be\n   configured to less than 15 seconds.  Alternatively, if an agent has\
    \ a\n   dynamic way to discover the binding lifetimes of the intervening\n   NATs,\
    \ it can use that value to determine Tr.  Administrators\n   deploying ICE in\
    \ more controlled networking environments SHOULD set\n   Tr to the longest duration\
    \ possible in their environment.\n   If STUN is being used for keepalives, a STUN\
    \ Binding Indication is\n   used [RFC5389].  The Indication MUST NOT utilize any\
    \ authentication\n   mechanism.  It SHOULD contain the FINGERPRINT attribute to\
    \ aid in\n   demultiplexing, but SHOULD NOT contain any other attributes.  It\
    \ is\n   used solely to keep the NAT bindings alive.  The Binding Indication\n\
    \   is sent using the same local and remote candidates that are being\n   used\
    \ for media.  Though Binding Indications are used for keepalives,\n   an agent\
    \ MUST be prepared to receive a connectivity check as well.\n   If a connectivity\
    \ check is received, a response is generated as\n   discussed in [RFC5389], but\
    \ there is no impact on ICE processing\n   otherwise.\n   An agent MUST begin\
    \ the keepalive processing once ICE has selected\n   candidates for usage with\
    \ media, or media begins to flow, whichever\n   happens first.  Keepalives end\
    \ once the session terminates or the\n   media stream is removed.\n"
- title: 11.  Media Handling
  contents:
  - '11.  Media Handling

    '
- title: 11.1.  Sending Media
  contents:
  - "11.1.  Sending Media\n   Procedures for sending media differ for full and lite\n\
    \   implementations.\n"
- title: 11.1.1.  Procedures for Full Implementations
  contents:
  - "11.1.1.  Procedures for Full Implementations\n   Agents always send media using\
    \ a candidate pair, called the selected\n   candidate pair.  An agent will send\
    \ media to the remote candidate in\n   the selected pair (setting the destination\
    \ address and port of the\n   packet equal to that remote candidate), and will\
    \ send it from the\n   local candidate of the selected pair.  When the local candidate\
    \ is\n   server or peer reflexive, media is originated from the base.  Media\n\
    \   sent from a relayed candidate is sent from the base through that TURN\n  \
    \ server, using procedures defined in [RFC5766].\n   If the local candidate is\
    \ a relayed candidate, it is RECOMMENDED that\n   an agent create a channel on\
    \ the TURN server towards the remote\n   candidate.  This is done using the procedures\
    \ for channel creation as\n   defined in Section 11 of [RFC5766].\n   The selected\
    \ pair for a component of a media stream is:\n   o  empty if the state of the\
    \ check list for that media stream is\n      Running, and there is no previous\
    \ selected pair for that component\n      due to an ICE restart\n   o  equal to\
    \ the previous selected pair for a component of a media\n      stream if the state\
    \ of the check list for that media stream is\n      Running, and there was a previous\
    \ selected pair for that component\n      due to an ICE restart\n   o  equal to\
    \ the highest-priority nominated pair for that component in\n      the valid list\
    \ if the state of the check list is Completed\n   If the selected pair for at\
    \ least one component of a media stream is\n   empty, an agent MUST NOT send media\
    \ for any component of that media\n   stream.  If the selected pair for each component\
    \ of a media stream\n   has a value, an agent MAY send media for all components\
    \ of that media\n   stream.\n   Note that the selected pair for a component of\
    \ a media stream may not\n   equal the default pair for that same component from\
    \ the most recent\n   offer/answer exchange.  When this happens, the selected\
    \ pair is used\n   for media, not the default pair.  When ICE first completes,\
    \ if the\n   selected pairs aren't a match for the default pairs, the controlling\n\
    \   agent sends an updated offer/answer exchange to remedy this\n   disparity.\
    \  However, until that updated offer arrives, there will not\n   be a match. \
    \ Furthermore, in very unusual cases, the default\n   candidates in the updated\
    \ offer/answer will not be a match.\n"
- title: 11.1.2.  Procedures for Lite Implementations
  contents:
  - "11.1.2.  Procedures for Lite Implementations\n   A lite implementation MUST NOT\
    \ send media until it has a Valid list\n   that contains a candidate pair for\
    \ each component of that media\n   stream.  Once that happens, the agent MAY begin\
    \ sending media\n   packets.  To do that, it sends media to the remote candidate\
    \ in the\n   pair (setting the destination address and port of the packet equal\
    \ to\n   that remote candidate), and will send it from the local candidate.\n"
- title: 11.1.3.  Procedures for All Implementations
  contents:
  - "11.1.3.  Procedures for All Implementations\n   ICE has interactions with jitter\
    \ buffer adaptation mechanisms.  An\n   RTP stream can begin using one candidate,\
    \ and switch to another one,\n   though this happens rarely with ICE.  The newer\
    \ candidate may result\n   in RTP packets taking a different path through the\
    \ network -- one\n   with different delay characteristics.  As discussed below,\
    \ agents are\n   encouraged to re-adjust jitter buffers when there are changes\
    \ in\n   source or destination address of media packets.  Furthermore, many\n\
    \   audio codecs use the marker bit to signal the beginning of a\n   talkspurt,\
    \ for the purposes of jitter buffer adaptation.  For such\n   codecs, it is RECOMMENDED\
    \ that the sender set the marker bit\n   [RFC3550] when an agent switches transmission\
    \ of media from one\n   candidate pair to another.\n"
- title: 11.2.  Receiving Media
  contents:
  - "11.2.  Receiving Media\n   ICE implementations MUST be prepared to receive media\
    \ on each\n   component on any candidates provided for that component in the most\n\
    \   recent offer/answer exchange (in the case of RTP, this would include\n   both\
    \ RTP and RTCP if candidates were provided for both).\n   It is RECOMMENDED that,\
    \ when an agent receives an RTP packet with a\n   new source or destination IP\
    \ address for a particular media stream,\n   that the agent re-adjust its jitter\
    \ buffers.\n   RFC 3550 [RFC3550] describes an algorithm in Section 8.2 for\n\
    \   detecting synchronization source (SSRC) collisions and loops.  These\n   algorithms\
    \ are based, in part, on seeing different source transport\n   addresses with\
    \ the same SSRC.  However, when ICE is used, such\n   changes will sometimes occur\
    \ as the media streams switch between\n   candidates.  An agent will be able to\
    \ determine that a media stream\n   is from the same peer as a consequence of\
    \ the STUN exchange that\n   proceeds media transmission.  Thus, if there is a\
    \ change in source\n   transport address, but the media packets come from the\
    \ same peer\n   agent, this SHOULD NOT be treated as an SSRC collision.\n"
- title: 12.  Usage with SIP
  contents:
  - '12.  Usage with SIP

    '
- title: 12.1.  Latency Guidelines
  contents:
  - "12.1.  Latency Guidelines\n   ICE requires a series of STUN-based connectivity\
    \ checks to take place\n   between endpoints.  These checks start from the answerer\
    \ on\n   generation of its answer, and start from the offerer when it receives\n\
    \   the answer.  These checks can take time to complete, and as such, the\n  \
    \ selection of messages to use with offers and answers can affect\n   perceived\
    \ user latency.  Two latency figures are of particular\n   interest.  These are\
    \ the post-pickup delay and the post-dial delay.\n   The post-pickup delay refers\
    \ to the time between when a user \"answers\n   the phone\" and when any speech\
    \ they utter can be delivered to the\n   caller.  The post-dial delay refers to\
    \ the time between when a user\n   enters the destination address for the user\
    \ and ringback begins as a\n   consequence of having successfully started ringing\
    \ the phone of the\n   called party.\n   Two cases can be considered -- one where\
    \ the offer is present in the\n   initial INVITE and one where it is in a response.\n"
- title: 12.1.1.  Offer in INVITE
  contents:
  - "12.1.1.  Offer in INVITE\n   To reduce post-dial delays, it is RECOMMENDED that\
    \ the caller begin\n   gathering candidates prior to actually sending its initial\
    \ INVITE.\n   This can be started upon user interface cues that a call is pending,\n\
    \   such as activity on a keypad or the phone going offhook.\n   If an offer is\
    \ received in an INVITE request, the answerer SHOULD\n   begin to gather its candidates\
    \ on receipt of the offer and then\n   generate an answer in a provisional response\
    \ once it has completed\n   that process.  ICE requires that a provisional response\
    \ with an SDP\n   be transmitted reliably.  This can be done through the existing\n\
    \   Provisional Response Acknowledgment (PRACK) mechanism [RFC3262] or\n   through\
    \ an optimization that is specific to ICE.  With this\n   optimization, provisional\
    \ responses containing an SDP answer that\n   begins ICE processing for one or\
    \ more media streams can be sent\n   reliably without RFC 3262.  To do this, the\
    \ agent retransmits the\n   provisional response with the exponential backoff\
    \ timers described in\n   RFC 3262.  Retransmits MUST cease on receipt of a STUN\
    \ Binding\n   request for one of the media streams signaled in that SDP (because\n\
    \   receipt of a Binding request indicates the offerer has received the\n   answer)\
    \ or on transmission of the answer in a 2xx response.  If the\n   peer agent is\
    \ lite, there will never be a STUN Binding request.  In\n   such a case, the agent\
    \ MUST cease retransmitting the 18x after\n   sending it four times (ICE will\
    \ actually work even if the peer never\n   receives the 18x; however, experience\
    \ has shown that sending it is\n   important for middleboxes and firewall traversal).\
    \  If no Binding\n   request is received prior to the last retransmit, the agent\
    \ does not\n   consider the session terminated.  Despite the fact that the\n \
    \  provisional response will be delivered reliably, the rules for when\n   an\
    \ agent can send an updated offer or answer do not change from those\n   specified\
    \ in RFC 3262.  Specifically, if the INVITE contained an\n   offer, the same answer\
    \ appears in all of the 1xx and in the 2xx\n   response to the INVITE.  Only after\
    \ that 2xx has been sent can an\n   updated offer/answer exchange occur.  This\
    \ optimization SHOULD NOT be\n   used if both agents support PRACK.  Note that\
    \ the optimization is\n   very specific to provisional response carrying answers\
    \ that start ICE\n   processing; it is not a general technique for 1xx reliability.\n\
    \   Alternatively, an agent MAY delay sending an answer until the 200 OK;\n  \
    \ however, this results in a poor user experience and is NOT\n   RECOMMENDED.\n\
    \   Once the answer has been sent, the agent SHOULD begin its\n   connectivity\
    \ checks.  Once candidate pairs for each component of a\n   media stream enter\
    \ the valid list, the answerer can begin sending\n   media on that media stream.\n\
    \   However, prior to this point, any media that needs to be sent towards\n  \
    \ the caller (such as SIP early media [RFC3960]) MUST NOT be\n   transmitted.\
    \  For this reason, implementations SHOULD delay alerting\n   the called party\
    \ until candidates for each component of each media\n   stream have entered the\
    \ valid list.  In the case of a PSTN gateway,\n   this would mean that the setup\
    \ message into the PSTN is delayed until\n   this point.  Doing this increases\
    \ the post-dial delay, but has the\n   effect of eliminating 'ghost rings'.  Ghost\
    \ rings are cases where the\n   called party hears the phone ring, picks up, but\
    \ hears nothing and\n   cannot be heard.  This technique works without requiring\
    \ support for,\n   or usage of, preconditions [RFC3312], since it's a localized\n\
    \   decision.  It also has the benefit of guaranteeing that not a single\n   packet\
    \ of media will get clipped, so that post-pickup delay is zero.\n   If an agent\
    \ chooses to delay local alerting in this way, it SHOULD\n   generate a 180 response\
    \ once alerting begins.\n"
- title: 12.1.2.  Offer in Response
  contents:
  - "12.1.2.  Offer in Response\n   In addition to uses where the offer is in an INVITE,\
    \ and the answer\n   is in the provisional and/or 200 OK response, ICE works with\
    \ cases\n   where the offer appears in the response.  In such cases, which are\n\
    \   common in third party call control [RFC3725], ICE agents SHOULD\n   generate\
    \ their offers in a reliable provisional response (which MUST\n   utilize RFC\
    \ 3262), and not alert the user on receipt of the INVITE.\n   The answer will\
    \ arrive in a PRACK.  This allows for ICE processing to\n   take place prior to\
    \ alerting, so that there is no post-pickup delay,\n   at the expense of increased\
    \ call setup delays.  Once ICE completes,\n   the callee can alert the user and\
    \ then generate a 200 OK when they\n   answer.  The 200 OK would contain no SDP,\
    \ since the offer/answer\n   exchange has completed.\n   Alternatively, agents\
    \ MAY place the offer in a 2xx instead (in which\n   case the answer comes in\
    \ the ACK).  When this happens, the callee\n   will alert the user on receipt\
    \ of the INVITE, and the ICE exchanges\n   will take place only after the user\
    \ answers.  This has the effect of\n   reducing call setup delay, but can cause\
    \ substantial post-pickup\n   delays and media clipping.\n"
- title: 12.2.  SIP Option Tags and Media Feature Tags
  contents:
  - "12.2.  SIP Option Tags and Media Feature Tags\n   [RFC5768] specifies a SIP option\
    \ tag and media feature tag for usage\n   with ICE.  ICE implementations using\
    \ SIP SHOULD support this\n   specification, which uses a feature tag in registrations\
    \ to\n   facilitate interoperability through signaling intermediaries.\n"
- title: 12.3.  Interactions with Forking
  contents:
  - "12.3.  Interactions with Forking\n   ICE interacts very well with forking.  Indeed,\
    \ ICE fixes some of the\n   problems associated with forking.  Without ICE, when\
    \ a call forks and\n   the caller receives multiple incoming media streams, it\
    \ cannot\n   determine which media stream corresponds to which callee.\n   With\
    \ ICE, this problem is resolved.  The connectivity checks which\n   occur prior\
    \ to transmission of media carry username fragments, which\n   in turn are correlated\
    \ to a specific callee.  Subsequent media\n   packets that arrive on the same\
    \ candidate pair as the connectivity\n   check will be associated with that same\
    \ callee.  Thus, the caller can\n   perform this correlation as long as it has\
    \ received an answer.\n"
- title: 12.4.  Interactions with Preconditions
  contents:
  - "12.4.  Interactions with Preconditions\n   Quality of Service (QoS) preconditions,\
    \ which are defined in RFC 3312\n   [RFC3312] and RFC 4032 [RFC4032], apply only\
    \ to the transport\n   addresses listed as the default targets for media in an\
    \ offer/answer.\n   If ICE changes the transport address where media is received,\
    \ this\n   change is reflected in an updated offer that changes the default\n\
    \   destination for media to match ICE's selection.  As such, it appears\n   like\
    \ any other re-INVITE would, and is fully treated in RFCs 3312 and\n   4032, which\
    \ apply without regard to the fact that the destination for\n   media is changing\
    \ due to ICE negotiations occurring \"in the\n   background\".\n   Indeed, an\
    \ agent SHOULD NOT indicate that QoS preconditions have been\n   met until the\
    \ checks have completed and selected the candidate pairs\n   to be used for media.\n\
    \   ICE also has (purposeful) interactions with connectivity\n   preconditions\
    \ [SDP-PRECON].  Those interactions are described there.\n   Note that the procedures\
    \ described in Section 12.1 describe their own\n   type of \"preconditions\",\
    \ albeit with less functionality than those\n   provided by the explicit preconditions\
    \ in [SDP-PRECON].\n"
- title: 12.5.  Interactions with Third Party Call Control
  contents:
  - "12.5.  Interactions with Third Party Call Control\n   ICE works with Flows I,\
    \ III, and IV as described in [RFC3725].  Flow\n   I works without the controller\
    \ supporting or being aware of ICE.\n   Flow IV will work as long as the controller\
    \ passes along the ICE\n   attributes without alteration.  Flow II is fundamentally\
    \ incompatible\n   with ICE; each agent will believe itself to be the answerer\
    \ and thus\n   never generate a re-INVITE.\n   The flows for continued operation,\
    \ as described in Section 7 of RFC\n   3725, require additional behavior of ICE\
    \ implementations to support.\n   In particular, if an agent receives a mid-dialog\
    \ re-INVITE that\n   contains no offer, it MUST restart ICE for each media stream\
    \ and go\n   through the process of gathering new candidates.  Furthermore, that\n\
    \   list of candidates SHOULD include the ones currently being used for\n   media.\n"
- title: 13.  Relationship with ANAT
  contents:
  - "13.  Relationship with ANAT\n   RFC 4091 [RFC4091], the Alternative Network Address\
    \ Types (ANAT)\n   Semantics for the SDP grouping framework, and RFC 4092 [RFC4092],\
    \ its\n   usage with SIP, define a mechanism for indicating that an agent can\n\
    \   support both IPv4 and IPv6 for a media stream, and it does so by\n   including\
    \ two m lines, one for v4 and one for v6.  This is similar to\n   ICE, which allows\
    \ for an agent to indicate multiple transport\n   addresses using the candidate\
    \ attribute.  However, ANAT relies on\n   static selection to pick between choices,\
    \ rather than a dynamic\n   connectivity check used by ICE.\n   This specification\
    \ deprecates RFC 4091 and RFC 4092.  Instead, agents\n   wishing to support dual\
    \ stack will utilize ICE.\n"
- title: 14.  Extensibility Considerations
  contents:
  - "14.  Extensibility Considerations\n   This specification makes very specific\
    \ choices about how both agents\n   in a session coordinate to arrive at the set\
    \ of candidate pairs that\n   are selected for media.  It is anticipated that\
    \ future specifications\n   will want to alter these algorithms, whether they\
    \ are simple changes\n   like timer tweaks or larger changes like a revamp of\
    \ the priority\n   algorithm.  When such a change is made, providing interoperability\n\
    \   between the two agents in a session is critical.\n   First, ICE provides the\
    \ a=ice-options SDP attribute.  Each extension\n   or change to ICE is associated\
    \ with a token.  When an agent\n   supporting such an extension or change generates\
    \ an offer or an\n   answer, it MUST include the token for that extension in this\n\
    \   attribute.  This allows each side to know what the other side is\n   doing.\
    \  This attribute MUST NOT be present if the agent doesn't\n   support any ICE\
    \ extensions or changes.\n   At this time, no IANA registry or registration procedures\
    \ are defined\n   for these option tags.  At time of writing, it is unclear whether\
    \ ICE\n   changes and extensions will be sufficiently common to warrant a\n  \
    \ registry.\n   One of the complications in achieving interoperability is that\
    \ ICE\n   relies on a distributed algorithm running on both agents to converge\n\
    \   on an agreed set of candidate pairs.  If the two agents run different\n  \
    \ algorithms, it can be difficult to guarantee convergence on the same\n   candidate\
    \ pairs.  The regular nomination procedure described in\n   Section 8 eliminates\
    \ some of the tight coordination by delegating the\n   selection algorithm completely\
    \ to the controlling agent.\n   Consequently, when a controlling agent is communicating\
    \ with a peer\n   that supports options it doesn't know about, the agent MUST\
    \ run a\n   regular nomination algorithm.  When regular nomination is used, ICE\n\
    \   will converge perfectly even when both agents use different pair\n   prioritization\
    \ algorithms.  One of the keys to such convergence is\n   triggered checks, which\
    \ ensure that the nominated pair is validated\n   by both agents.  Consequently,\
    \ any future ICE enhancements MUST\n   preserve triggered checks.\n   ICE is also\
    \ extensible to other media streams beyond RTP, and for\n   transport protocols\
    \ beyond UDP.  Extensions to ICE for non-RTP media\n   streams need to specify\
    \ how many components they utilize, and assign\n   component IDs to them, starting\
    \ at 1 for the most important component\n   ID.  Specifications for new transport\
    \ protocols must define how, if\n   at all, various steps in the ICE processing\
    \ differ from UDP.\n"
- title: 15.  Grammar
  contents:
  - "15.  Grammar\n   This specification defines seven new SDP attributes -- the\n\
    \   \"candidate\", \"remote-candidates\", \"ice-lite\", \"ice-mismatch\", \"ice-\n\
    \   ufrag\", \"ice-pwd\", and \"ice-options\" attributes.\n"
- title: 15.1.  "candidate" Attribute
  contents:
  - "15.1.  \"candidate\" Attribute\n   The candidate attribute is a media-level attribute\
    \ only.  It contains\n   a transport address for a candidate that can be used\
    \ for connectivity\n   checks.\n   The syntax of this attribute is defined using\
    \ Augmented BNF as\n   defined in RFC 5234 [RFC5234]:\n   candidate-attribute\
    \   = \"candidate\" \":\" foundation SP component-id SP\n                    \
    \       transport SP\n                           priority SP\n               \
    \            connection-address SP     ;from RFC 4566\n                      \
    \     port         ;port from RFC 4566\n                           SP cand-type\n\
    \                           [SP rel-addr]\n                           [SP rel-port]\n\
    \                           *(SP extension-att-name SP\n                     \
    \           extension-att-value)\n   foundation            = 1*32ice-char\n  \
    \ component-id          = 1*5DIGIT\n   transport             = \"UDP\" / transport-extension\n\
    \   transport-extension   = token              ; from RFC 3261\n   priority  \
    \            = 1*10DIGIT\n   cand-type             = \"typ\" SP candidate-types\n\
    \   candidate-types       = \"host\" / \"srflx\" / \"prflx\" / \"relay\" / token\n\
    \   rel-addr              = \"raddr\" SP connection-address\n   rel-port     \
    \         = \"rport\" SP port\n   extension-att-name    = byte-string    ;from\
    \ RFC 4566\n   extension-att-value   = byte-string\n   ice-char              =\
    \ ALPHA / DIGIT / \"+\" / \"/\"\n   This grammar encodes the primary information\
    \ about a candidate: its\n   IP address, port and transport protocol, and its\
    \ properties: the\n   foundation, component ID, priority, type, and related transport\n\
    \   address:\n   <connection-address>:  is taken from RFC 4566 [RFC4566].  It\
    \ is the\n      IP address of the candidate, allowing for IPv4 addresses, IPv6\n\
    \      addresses, and fully qualified domain names (FQDNs).  When parsing\n  \
    \    this field, an agent can differentiate an IPv4 address and an IPv6\n    \
    \  address by presence of a colon in its value - the presence of a\n      colon\
    \ indicates IPv6.  An agent MUST ignore candidate lines that\n      include candidates\
    \ with IP address versions that are not supported\n      or recognized.  An IP\
    \ address SHOULD be used, but an FQDN MAY be\n      used in place of an IP address.\
    \  In that case, when receiving an\n      offer or answer containing an FQDN in\
    \ an a=candidate attribute,\n      the FQDN is looked up in the DNS first using\
    \ an AAAA record\n      (assuming the agent supports IPv6), and if no result is\
    \ found or\n      the agent only supports IPv4, using an A.  If the DNS query\n\
    \      returns more than one IP address, one is chosen, and then used for\n  \
    \    the remainder of ICE processing.\n   <port>:  is also taken from RFC 4566\
    \ [RFC4566].  It is the port of\n      the candidate.\n   <transport>:  indicates\
    \ the transport protocol for the candidate.\n      This specification only defines\
    \ UDP.  However, extensibility is\n      provided to allow for future transport\
    \ protocols to be used with\n      ICE, such as TCP or the Datagram Congestion\
    \ Control Protocol\n      (DCCP) [RFC4340].\n   <foundation>:  is composed of\
    \ 1 to 32 <ice-char>s.  It is an\n      identifier that is equivalent for two\
    \ candidates that are of the\n      same type, share the same base, and come from\
    \ the same STUN\n      server.  The foundation is used to optimize ICE performance\
    \ in the\n      Frozen algorithm.\n   <component-id>:  is a positive integer between\
    \ 1 and 256 that\n      identifies the specific component of the media stream\
    \ for which\n      this is a candidate.  It MUST start at 1 and MUST increment\
    \ by 1\n      for each component of a particular candidate.  For media streams\n\
    \      based on RTP, candidates for the actual RTP media MUST have a\n      component\
    \ ID of 1, and candidates for RTCP MUST have a component\n      ID of 2.  Other\
    \ types of media streams that require multiple\n      components MUST develop\
    \ specifications that define the mapping of\n      components to component IDs.\
    \  See Section 14 for additional\n      discussion on extending ICE to new media\
    \ streams.\n   <priority>:  is a positive integer between 1 and (2**31 - 1).\n\
    \   <cand-type>:  encodes the type of candidate.  This specification\n      defines\
    \ the values \"host\", \"srflx\", \"prflx\", and \"relay\" for host,\n      server\
    \ reflexive, peer reflexive, and relayed candidates,\n      respectively.  The\
    \ set of candidate types is extensible for the\n      future.\n   <rel-addr> and\
    \ <rel-port>:  convey transport addresses related to the\n      candidate, useful\
    \ for diagnostics and other purposes. <rel-addr>\n      and <rel-port> MUST be\
    \ present for server reflexive, peer\n      reflexive, and relayed candidates.\
    \  If a candidate is server or\n      peer reflexive, <rel-addr> and <rel-port>\
    \ are equal to the base\n      for that server or peer reflexive candidate.  If\
    \ the candidate is\n      relayed, <rel-addr> and <rel-port> is equal to the mapped\
    \ address\n      in the Allocate response that provided the client with that\n\
    \      relayed candidate (see Appendix B.3 for a discussion of its\n      purpose).\
    \  If the candidate is a host candidate, <rel-addr> and\n      <rel-port> MUST\
    \ be omitted.\n   The candidate attribute can itself be extended.  The grammar\
    \ allows\n   for new name/value pairs to be added at the end of the attribute.\
    \  An\n   implementation MUST ignore any name/value pairs it doesn't\n   understand.\n"
- title: 15.2.  "remote-candidates" Attribute
  contents:
  - "15.2.  \"remote-candidates\" Attribute\n   The syntax of the \"remote-candidates\"\
    \ attribute is defined using\n   Augmented BNF as defined in RFC 5234 [RFC5234].\
    \  The remote-\n   candidates attribute is a media-level attribute only.\n   remote-candidate-att\
    \ = \"remote-candidates\" \":\" remote-candidate\n                           0*(SP\
    \ remote-candidate)\n   remote-candidate = component-ID SP connection-address\
    \ SP port\n   The attribute contains a connection-address and port for each\n\
    \   component.  The ordering of components is irrelevant.  However, a\n   value\
    \ MUST be present for each component of a media stream.  This\n   attribute MUST\
    \ be included in an offer by a controlling agent for a\n   media stream that is\
    \ Completed, and MUST NOT be included in any other\n   case.\n"
- title: 15.3.  "ice-lite" and "ice-mismatch" Attributes
  contents:
  - "15.3.  \"ice-lite\" and \"ice-mismatch\" Attributes\n   The syntax of the \"\
    ice-lite\" and \"ice-mismatch\" attributes, both of\n   which are flags, is:\n\
    \   ice-lite               = \"ice-lite\"\n   ice-mismatch           = \"ice-mismatch\"\
    \n   \"ice-lite\" is a session-level attribute only, and indicates that an\n \
    \  agent is a lite implementation. \"ice-mismatch\" is a media-level\n   attribute\
    \ only, and when present in an answer, indicates that the\n   offer arrived with\
    \ a default destination for a media component that\n   didn't have a corresponding\
    \ candidate attribute.\n"
- title: 15.4.  "ice-ufrag" and "ice-pwd" Attributes
  contents:
  - "15.4.  \"ice-ufrag\" and \"ice-pwd\" Attributes\n   The \"ice-ufrag\" and \"\
    ice-pwd\" attributes convey the username fragment\n   and password used by ICE\
    \ for message integrity.  Their syntax is:\n   ice-pwd-att           = \"ice-pwd\"\
    \ \":\" password\n   ice-ufrag-att         = \"ice-ufrag\" \":\" ufrag\n   password\
    \              = 22*256ice-char\n   ufrag                 = 4*256ice-char\n  \
    \ The \"ice-pwd\" and \"ice-ufrag\" attributes can appear at either the\n   session-level\
    \ or media-level.  When present in both, the value in the\n   media-level takes\
    \ precedence.  Thus, the value at the session-level\n   is effectively a default\
    \ that applies to all media streams, unless\n   overridden by a media-level value.\
    \  Whether present at the session or\n   media-level, there MUST be an ice-pwd\
    \ and ice-ufrag attribute for\n   each media stream.  If two media streams have\
    \ identical ice-ufrag's,\n   they MUST have identical ice-pwd's.\n   The ice-ufrag\
    \ and ice-pwd attributes MUST be chosen randomly at the\n   beginning of a session.\
    \  The ice-ufrag attribute MUST contain at\n   least 24 bits of randomness, and\
    \ the ice-pwd attribute MUST contain\n   at least 128 bits of randomness.  This\
    \ means that the ice-ufrag\n   attribute will be at least 4 characters long, and\
    \ the ice-pwd at\n   least 22 characters long, since the grammar for these attributes\n\
    \   allows for 6 bits of randomness per character.  The attributes MAY be\n  \
    \ longer than 4 and 22 characters, respectively, of course, up to 256\n   characters.\
    \  The upper limit allows for buffer sizing in\n   implementations.  Its large\
    \ upper limit allows for increased amounts\n   of randomness to be added over\
    \ time.\n"
- title: 15.5.  "ice-options" Attribute
  contents:
  - "15.5.  \"ice-options\" Attribute\n   The \"ice-options\" attribute is a session-level\
    \ attribute.  It\n   contains a series of tokens that identify the options supported\
    \ by\n   the agent.  Its grammar is:\n   ice-options           = \"ice-options\"\
    \ \":\" ice-option-tag\n                             0*(SP ice-option-tag)\n \
    \  ice-option-tag        = 1*ice-char\n"
- title: 16.  Setting Ta and RTO
  contents:
  - "16.  Setting Ta and RTO\n   During the gathering phase of ICE (Section 4.1.1)\
    \ and while ICE is\n   performing connectivity checks (Section 7), an agent sends\
    \ STUN and\n   TURN transactions.  These transactions are paced at a rate of one\n\
    \   every Ta milliseconds, and utilize a specific RTO.  This section\n   describes\
    \ how the values of Ta and RTO are computed.  This\n   computation depends on\
    \ whether ICE is being used with a real-time\n   media stream (such as RTP) or\
    \ something else.  When ICE is used for a\n   stream with a known maximum bandwidth,\
    \ the computation in\n   Section 16.1 MAY be followed to rate-control the ICE\
    \ exchanges.  For\n   all other streams, the computation in Section 16.2 MUST\
    \ be followed.\n"
- title: 16.1.  RTP Media Streams
  contents:
  - "16.1.  RTP Media Streams\n   The values of RTO and Ta change during the lifetime\
    \ of ICE\n   processing.  One set of values applies during the gathering phase,\n\
    \   and the other, for connectivity checks.\n   The value of Ta SHOULD be configurable,\
    \ and SHOULD have a default of:\n   For each media stream i:\n    Ta_i = (stun_packet_size\
    \ / rtp_packet_size) * rtp_ptime\n                           1\n     Ta = MAX\
    \ (20ms, ------------------- )\n                           k\n               \
    \          ----\n                         \\        1\n                      \
    \    >    ------\n                         /       Ta_i\n                    \
    \     ----\n                          i=1\n   where k is the number of media streams.\
    \  During the gathering phase,\n   Ta is computed based on the number of media\
    \ streams the agent has\n   indicated in its offer or answer, and the RTP packet\
    \ size and RTP\n   ptime are those of the most preferred codec for each media\
    \ stream.\n   Once an offer and answer have been exchanged, the agent recomputes\
    \ Ta\n   to pace the connectivity checks.  In that case, the value of Ta is\n\
    \   based on the number of media streams that will actually be used in\n   the\
    \ session, and the RTP packet size and RTP ptime are those of the\n   most preferred\
    \ codec with which the agent will send.\n   In addition, the retransmission timer\
    \ for the STUN transactions, RTO,\n   defined in [RFC5389], SHOULD be configurable\
    \ and during the gathering\n   phase, SHOULD have a default of:\n     RTO = MAX\
    \ (100ms, Ta * (number of pairs))\n   where the number of pairs refers to the\
    \ number of pairs of candidates\n   with STUN or TURN servers.\n   For connectivity\
    \ checks, RTO SHOULD be configurable and SHOULD have a\n   default of:\n     RTO\
    \ = MAX (100ms, Ta*N * (Num-Waiting + Num-In-Progress))\n   where Num-Waiting\
    \ is the number of checks in the check list in the\n   Waiting state, and Num-In-Progress\
    \ is the number of checks in the In-\n   Progress state.  Note that the RTO will\
    \ be different for each\n   transaction as the number of checks in the Waiting\
    \ and In-Progress\n   states change.\n   These formulas are aimed at causing STUN\
    \ transactions to be paced at\n   the same rate as media.  This ensures that ICE\
    \ will work properly\n   under the same network conditions needed to support the\
    \ media as\n   well.  See Appendix B.1 for additional discussion and motivations.\n\
    \   Because of this pacing, it will take a certain amount of time to\n   obtain\
    \ all of the server reflexive and relayed candidates.\n   Implementations should\
    \ be aware of the time required to do this, and\n   if the application requires\
    \ a time budget, limit the number of\n   candidates that are gathered.\n   The\
    \ formulas result in a behavior whereby an agent will send its\n   first packet\
    \ for every single connectivity check before performing a\n   retransmit.  This\
    \ can be seen in the formulas for the RTO (which\n   represents the retransmit\
    \ interval).  Those formulas scale with N,\n   the number of checks to be performed.\
    \  As a result of this, ICE\n   maintains a nicely constant rate, but becomes\
    \ more sensitive to\n   packet loss.  The loss of the first single packet for\
    \ any\n   connectivity check is likely to cause that pair to take a long time\n\
    \   to be validated, and instead, a lower-priority check (but one for\n   which\
    \ there was no packet loss) is much more likely to complete\n   first.  This results\
    \ in ICE performing sub-optimally, choosing lower-\n   priority pairs over higher-priority\
    \ pairs.  Implementors should be\n   aware of this consequence, but still should\
    \ utilize the timer values\n   described here.\n"
- title: 16.2.  Non-RTP Sessions
  contents:
  - "16.2.  Non-RTP Sessions\n   In cases where ICE is used to establish some kind\
    \ of session that is\n   not real time, and has no fixed rate associated with\
    \ it that is known\n   to work on the network in which ICE is deployed, Ta and\
    \ RTO revert to\n   more conservative values.  Ta SHOULD be configurable, SHOULD\
    \ have a\n   default of 500 ms, and MUST NOT be configurable to be less than 500\n\
    \   ms.\n   In addition, the retransmission timer for the STUN transactions, RTO,\n\
    \   SHOULD be configurable and during the gathering phase, SHOULD have a\n   default\
    \ of:\n     RTO = MAX (500ms, Ta * (number of pairs))\n   where the number of\
    \ pairs refers to the number of pairs of candidates\n   with STUN or TURN servers.\n\
    \   For connectivity checks, RTO SHOULD be configurable and SHOULD have a\n  \
    \ default of:\n     RTO = MAX (500ms, Ta*N * (Num-Waiting + Num-In-Progress))\n"
- title: 17.  Example
  contents:
  - "17.  Example\n   The example is based on the simplified topology of Figure 8.\n\
    \                             +-----+\n                             |     |\n\
    \                             |STUN |\n                             | Srvr|\n\
    \                             +-----+\n                                |\n   \
    \                  +---------------------+\n                     |           \
    \          |\n                     |      Internet       |\n                 \
    \    |                     |\n                     |                     |\n \
    \                    +---------------------+\n                       |       \
    \         |\n                       |                |\n                +---------+\
    \             |\n                |  NAT    |             |\n                +---------+\
    \             |\n                     |                  |\n                 \
    \    |                  |\n                     |                  |\n       \
    \           +-----+            +-----+\n                  |     |            |\
    \     |\n                  |  L  |            |  R  |\n                  |   \
    \  |            |     |\n                  +-----+            +-----+\n      \
    \                  Figure 8: Example Topology\n   Two agents, L and R, are using\
    \ ICE.  Both are full-mode ICE\n   implementations and use aggressive nomination\
    \ when they are\n   controlling.  Both agents have a single IPv4 address.  For\
    \ agent L,\n   it is 10.0.1.1 in private address space [RFC1918], and for agent\
    \ R,\n   192.0.2.1 on the public Internet.  Both are configured with the same\n\
    \   STUN server (shown in this example for simplicity, although in\n   practice\
    \ the agents do not need to use the same STUN server), which\n   is listening\
    \ for STUN Binding requests at an IP address of 192.0.2.2\n   and port 3478. \
    \ TURN servers are not used in this example.  Agent L\n   is behind a NAT, and\
    \ agent R is on the public Internet.  The NAT has\n   an endpoint independent\
    \ mapping property and an address dependent\n   filtering property.  The public\
    \ side of the NAT has an IP address of\n   192.0.2.3.\n   To facilitate understanding,\
    \ transport addresses are listed using\n   variables that have mnemonic names.\
    \  The format of the name is\n   entity-type-seqno, where entity refers to the\
    \ entity whose IP address\n   the transport address is on, and is one of \"L\"\
    , \"R\", \"STUN\", or\n   \"NAT\".  The type is either \"PUB\" for transport addresses\
    \ that are\n   public, and \"PRIV\" for transport addresses that are private.\n\
    \   Finally, seq-no is a sequence number that is different for each\n   transport\
    \ address of the same type on a particular entity.  Each\n   variable has an IP\
    \ address and port, denoted by varname.IP and\n   varname.PORT, respectively,\
    \ where varname is the name of the\n   variable.\n   The STUN server has advertised\
    \ transport address STUN-PUB-1 (which is\n   192.0.2.2:3478).\n   In the call\
    \ flow itself, STUN messages are annotated with several\n   attributes.  The \"\
    S=\" attribute indicates the source transport\n   address of the message.  The\
    \ \"D=\" attribute indicates the destination\n   transport address of the message.\
    \  The \"MA=\" attribute is used in\n   STUN Binding response messages and refers\
    \ to the mapped address.\n   \"USE-CAND\" implies the presence of the USE-CANDIDATE\
    \ attribute.\n   The call flow examples omit STUN authentication operations and\
    \ RTCP,\n   and focus on RTP for a single media stream between two full\n   implementations.\n\
    \             L             NAT           STUN             R\n             |RTP\
    \ STUN alloc.              |              |\n             |(1) STUN Req  |   \
    \           |              |\n             |S=$L-PRIV-1   |              |   \
    \           |\n             |D=$STUN-PUB-1 |              |              |\n \
    \            |------------->|              |              |\n             |  \
    \            |(2) STUN Req  |              |\n             |              |S=$NAT-PUB-1\
    \  |              |\n             |              |D=$STUN-PUB-1 |            \
    \  |\n             |              |------------->|              |\n          \
    \   |              |(3) STUN Res  |              |\n             |           \
    \   |S=$STUN-PUB-1 |              |\n             |              |D=$NAT-PUB-1\
    \  |              |\n             |              |MA=$NAT-PUB-1 |            \
    \  |\n             |              |<-------------|              |\n          \
    \   |(4) STUN Res  |              |              |\n             |S=$STUN-PUB-1\
    \ |              |              |\n             |D=$L-PRIV-1   |             \
    \ |              |\n             |MA=$NAT-PUB-1 |              |             \
    \ |\n             |<-------------|              |              |\n           \
    \  |(5) Offer     |              |              |\n             |------------------------------------------->|\n\
    \             |              |              |              |RTP STUN\n       \
    \      alloc.\n             |              |              |(6) STUN Req  |\n \
    \            |              |              |S=$R-PUB-1    |\n             |  \
    \            |              |D=$STUN-PUB-1 |\n             |              |  \
    \            |<-------------|\n             |              |              |(7)\
    \ STUN Res  |\n             |              |              |S=$STUN-PUB-1 |\n \
    \            |              |              |D=$R-PUB-1    |\n             |  \
    \            |              |MA=$R-PUB-1   |\n             |              |  \
    \            |------------->|\n             |(8) answer    |              |  \
    \            |\n             |<-------------------------------------------|\n\
    \             |              |(9) Bind Req  |              |Begin\n          \
    \   |              |S=$R-PUB-1    |              |Connectivity\n             |\
    \              |D=L-PRIV-1    |              |Checks\n             |         \
    \     |<----------------------------|\n             |              |Dropped  \
    \     |              |\n             |(10) Bind Req |              |         \
    \     |\n             |S=$L-PRIV-1   |              |              |\n       \
    \      |D=$R-PUB-1    |              |              |\n             |USE-CAND\
    \      |              |              |\n             |------------->|        \
    \      |              |\n             |              |(11) Bind Req |        \
    \      |\n             |              |S=$NAT-PUB-1  |              |\n      \
    \       |              |D=$R-PUB-1    |              |\n             |       \
    \       |USE-CAND      |              |\n             |              |---------------------------->|\n\
    \             |              |(12) Bind Res |              |\n             | \
    \             |S=$R-PUB-1    |              |\n             |              |D=$NAT-PUB-1\
    \  |              |\n             |              |MA=$NAT-PUB-1 |            \
    \  |\n             |              |<----------------------------|\n          \
    \   |(13) Bind Res |              |              |\n             |S=$R-PUB-1 \
    \   |              |              |\n             |D=$L-PRIV-1   |           \
    \   |              |\n             |MA=$NAT-PUB-1 |              |           \
    \   |\n             |<-------------|              |              |\n         \
    \    |RTP flows     |              |              |\n             |          \
    \    |(14) Bind Req |              |\n             |              |S=$R-PUB-1\
    \    |              |\n             |              |D=$NAT-PUB-1  |          \
    \    |\n             |              |<----------------------------|\n        \
    \     |(15) Bind Req |              |              |\n             |S=$R-PUB-1\
    \    |              |              |\n             |D=$L-PRIV-1   |          \
    \    |              |\n             |<-------------|              |          \
    \    |\n             |(16) Bind Res |              |              |\n        \
    \     |S=$L-PRIV-1   |              |              |\n             |D=$R-PUB-1\
    \    |              |              |\n             |MA=$R-PUB-1   |          \
    \    |              |\n             |------------->|              |          \
    \    |\n             |              |(17) Bind Res |              |\n        \
    \     |              |S=$NAT-PUB-1  |              |\n             |         \
    \     |D=$R-PUB-1    |              |\n             |              |MA=$R-PUB-1\
    \   |              |\n             |              |---------------------------->|\n\
    \             |              |              |              |RTP flows\n      \
    \                    Figure 9: Example Flow\n   First, agent L obtains a host\
    \ candidate from its local IP address\n   (not shown), and from that, sends a\
    \ STUN Binding request to the STUN\n   server to get a server reflexive candidate\
    \ (messages 1-4).  Recall\n   that the NAT has the address and port independent\
    \ mapping property.\n   Here, it creates a binding of NAT-PUB-1 for this UDP request,\
    \ and\n   this becomes the server reflexive candidate for RTP.\n   Agent L sets\
    \ a type preference of 126 for the host candidate and 100\n   for the server reflexive.\
    \  The local preference is 65535.  Based on\n   this, the priority of the host\
    \ candidate is 2130706431 and for the\n   server reflexive candidate is 1694498815.\
    \  The host candidate is\n   assigned a foundation of 1, and the server reflexive,\
    \ a foundation of\n   2.  It chooses its server reflexive candidate as the default\n\
    \   candidate, and encodes it into the m and c lines.  The resulting\n   offer\
    \ (message 5) looks like (lines folded for clarity):\n       v=0\n       o=jdoe\
    \ 2890844526 2890842807 IN IP4 $L-PRIV-1.IP\n       s=\n       c=IN IP4 $NAT-PUB-1.IP\n\
    \       t=0 0\n       a=ice-pwd:asd88fgpdd777uzjYhagZg\n       a=ice-ufrag:8hhY\n\
    \       m=audio $NAT-PUB-1.PORT RTP/AVP 0\n       b=RS:0\n       b=RR:0\n    \
    \   a=rtpmap:0 PCMU/8000\n       a=candidate:1 1 UDP 2130706431 $L-PRIV-1.IP $L-PRIV-1.PORT\
    \ typ\n       host\n       a=candidate:2 1 UDP 1694498815 $NAT-PUB-1.IP $NAT-PUB-1.PORT\
    \ typ\n        srflx raddr $L-PRIV-1.IP rport $L-PRIV-1.PORT\n   The offer, with\
    \ the variables replaced with their values, will look\n   like (lines folded for\
    \ clarity):\n       v=0\n       o=jdoe 2890844526 2890842807 IN IP4 10.0.1.1\n\
    \       s=\n       c=IN IP4 192.0.2.3\n       t=0 0\n       a=ice-pwd:asd88fgpdd777uzjYhagZg\n\
    \       a=ice-ufrag:8hhY\n       m=audio 45664 RTP/AVP 0\n       b=RS:0\n    \
    \   b=RR:0\n       a=rtpmap:0 PCMU/8000\n       a=candidate:1 1 UDP 2130706431\
    \ 10.0.1.1 8998 typ host\n       a=candidate:2 1 UDP 1694498815 192.0.2.3 45664\
    \ typ srflx raddr\n   10.0.1.1 rport 8998\n   This offer is received at agent\
    \ R.  Agent R will obtain a host\n   candidate, and from it, obtain a server reflexive\
    \ candidate (messages\n   6-7).  Since R is not behind a NAT, this candidate is\
    \ identical to\n   its host candidate, and they share the same base.  It therefore\n\
    \   discards this redundant candidate and ends up with a single host\n   candidate.\
    \  With identical type and local preferences as L, the\n   priority for this candidate\
    \ is 2130706431.  It chooses a foundation\n   of 1 for its single candidate. \
    \ Its resulting answer looks like:\n       v=0\n       o=bob 2808844564 2808844564\
    \ IN IP4 $R-PUB-1.IP\n       s=\n       c=IN IP4 $R-PUB-1.IP\n       t=0 0\n \
    \      a=ice-pwd:YH75Fviy6338Vbrhrlp8Yh\n       a=ice-ufrag:9uB6\n       m=audio\
    \ $R-PUB-1.PORT RTP/AVP 0\n       b=RS:0\n       b=RR:0\n       a=rtpmap:0 PCMU/8000\n\
    \       a=candidate:1 1 UDP 2130706431 $R-PUB-1.IP $R-PUB-1.PORT typ host\n  \
    \ With the variables filled in:\n       v=0\n       o=bob 2808844564 2808844564\
    \ IN IP4 192.0.2.1\n       s=\n       c=IN IP4 192.0.2.1\n       t=0 0\n     \
    \  a=ice-pwd:YH75Fviy6338Vbrhrlp8Yh\n       a=ice-ufrag:9uB6\n       m=audio 3478\
    \ RTP/AVP 0\n       b=RS:0\n       b=RR:0\n       a=rtpmap:0 PCMU/8000\n     \
    \  a=candidate:1 1 UDP 2130706431 192.0.2.1 3478 typ host\n   Since neither side\
    \ indicated that it is lite, the agent that sent the\n   offer that began ICE\
    \ processing (agent L) becomes the controlling\n   agent.\n   Agents L and R both\
    \ pair up the candidates.  They both initially have\n   two pairs.  However, agent\
    \ L will prune the pair containing its\n   server reflexive candidate, resulting\
    \ in just one.  At agent L, this\n   pair has a local candidate of $L_PRIV_1 and\
    \ remote candidate of\n   $R_PUB_1, and has a candidate pair priority of 4.57566E+18\
    \ (note that\n   an implementation would represent this as a 64-bit integer so\
    \ as not\n   to lose precision).  At agent R, there are two pairs.  The highest\n\
    \   priority has a local candidate of $R_PUB_1 and remote candidate of\n   $L_PRIV_1\
    \ and has a priority of 4.57566E+18, and the second has a\n   local candidate\
    \ of $R_PUB_1 and remote candidate of $NAT_PUB_1 and\n   priority 3.63891E+18.\n\
    \   Agent R begins its connectivity check (message 9) for the first pair\n   (between\
    \ the two host candidates).  Since R is the controlled agent\n   for this session,\
    \ the check omits the USE-CANDIDATE attribute.  The\n   host candidate from agent\
    \ L is private and behind a NAT, and thus\n   this check won't be successful,\
    \ because the packet cannot be routed\n   from R to L.\n   When agent L gets the\
    \ answer, it performs its one and only\n   connectivity check (messages 10-13).\
    \  It implements the aggressive\n   nomination algorithm, and thus includes a\
    \ USE-CANDIDATE attribute in\n   this check.  Since the check succeeds, agent\
    \ L creates a new pair,\n   whose local candidate is from the mapped address in\
    \ the Binding\n   response (NAT-PUB-1 from message 13) and whose remote candidate\
    \ is\n   the destination of the request (R-PUB-1 from message 10).  This is\n\
    \   added to the valid list.  In addition, it is marked as selected since\n  \
    \ the Binding request contained the USE-CANDIDATE attribute.  Since\n   there\
    \ is a selected candidate in the Valid list for the one component\n   of this\
    \ media stream, ICE processing for this stream moves into the\n   Completed state.\
    \  Agent L can now send media if it so chooses.\n   Soon after receipt of the\
    \ STUN Binding request from agent L (message\n   11), agent R will generate its\
    \ triggered check.  This check happens\n   to match the next one on its check\
    \ list -- from its host candidate to\n   agent L's server reflexive candidate.\
    \  This check (messages 14-17)\n   will succeed.  Consequently, agent R constructs\
    \ a new candidate pair\n   using the mapped address from the response as the local\
    \ candidate\n   (R-PUB-1) and the destination of the request (NAT-PUB-1) as the\n\
    \   remote candidate.  This pair is added to the Valid list for that\n   media\
    \ stream.  Since the check was generated in the reverse direction\n   of a check\
    \ that contained the USE-CANDIDATE attribute, the candidate\n   pair is marked\
    \ as selected.  Consequently, processing for this stream\n   moves into the Completed\
    \ state, and agent R can also send media.\n"
- title: 18.  Security Considerations
  contents:
  - "18.  Security Considerations\n   There are several types of attacks possible\
    \ in an ICE system.  This\n   section considers these attacks and their countermeasures.\
    \  These\n   countermeasures include:\n   o  Using ICE in conjunction with secure\
    \ signaling techniques, such as\n      SIPS.\n   o  Limiting the total number\
    \ of connectivity checks to 100, and\n      optionally limiting the number of\
    \ candidates they'll accept in an\n      offer or answer.\n"
- title: 18.1.  Attacks on Connectivity Checks
  contents:
  - "18.1.  Attacks on Connectivity Checks\n   An attacker might attempt to disrupt\
    \ the STUN connectivity checks.\n   Ultimately, all of these attacks fool an agent\
    \ into thinking\n   something incorrect about the results of the connectivity\
    \ checks.\n   The possible false conclusions an attacker can try and cause are:\n\
    \   False Invalid:  An attacker can fool a pair of agents into thinking a\n  \
    \    candidate pair is invalid, when it isn't.  This can be used to\n      cause\
    \ an agent to prefer a different candidate (such as one\n      injected by the\
    \ attacker) or to disrupt a call by forcing all\n      candidates to fail.\n \
    \  False Valid:  An attacker can fool a pair of agents into thinking a\n     \
    \ candidate pair is valid, when it isn't.  This can cause an agent\n      to proceed\
    \ with a session, but then not be able to receive any\n      media.\n   False\
    \ Peer Reflexive Candidate:  An attacker can cause an agent to\n      discover\
    \ a new peer reflexive candidate, when it shouldn't have.\n      This can be used\
    \ to redirect media streams to a Denial-of-Service\n      (DoS) target or to the\
    \ attacker, for eavesdropping or other\n      purposes.\n   False Valid on False\
    \ Candidate:  An attacker has already convinced an\n      agent that there is\
    \ a candidate with an address that doesn't\n      actually route to that agent\
    \ (for example, by injecting a false\n      peer reflexive candidate or false\
    \ server reflexive candidate).  It\n      must then launch an attack that forces\
    \ the agents to believe that\n      this candidate is valid.\n      If an attacker\
    \ can cause a false peer reflexive candidate or false\n      valid on a false\
    \ candidate, it can launch any of the attacks\n      described in [RFC5389].\n\
    \   To force the false invalid result, the attacker has to wait for the\n   connectivity\
    \ check from one of the agents to be sent.  When it is,\n   the attacker needs\
    \ to inject a fake response with an unrecoverable\n   error response, such as\
    \ a 400.  However, since the candidate is, in\n   fact, valid, the original request\
    \ may reach the peer agent, and\n   result in a success response.  The attacker\
    \ needs to force this\n   packet or its response to be dropped, through a DoS\
    \ attack, layer 2\n   network disruption, or other technique.  If it doesn't do\
    \ this, the\n   success response will also reach the originator, alerting it to\
    \ a\n   possible attack.  Fortunately, this attack is mitigated completely\n \
    \  through the STUN short-term credential mechanism.  The attacker needs\n   to\
    \ inject a fake response, and in order for this response to be\n   processed,\
    \ the attacker needs the password.  If the offer/answer\n   signaling is secured,\
    \ the attacker will not have the password and its\n   response will be discarded.\n\
    \   Forcing the fake valid result works in a similar way.  The agent\n   needs\
    \ to wait for the Binding request from each agent, and inject a\n   fake success\
    \ response.  The attacker won't need to worry about\n   disrupting the actual\
    \ response since, if the candidate is not valid,\n   it presumably wouldn't be\
    \ received anyway.  However, like the fake\n   invalid attack, this attack is\
    \ mitigated by the STUN short-term\n   credential mechanism in conjunction with\
    \ a secure offer/answer\n   exchange.\n   Forcing the false peer reflexive candidate\
    \ result can be done either\n   with fake requests or responses, or with replays.\
    \  We consider the\n   fake requests and responses case first.  It requires the\
    \ attacker to\n   send a Binding request to one agent with a source IP address\
    \ and port\n   for the false candidate.  In addition, the attacker must wait for\
    \ a\n   Binding request from the other agent, and generate a fake response\n \
    \  with a XOR-MAPPED-ADDRESS attribute containing the false candidate.\n   Like\
    \ the other attacks described here, this attack is mitigated by\n   the STUN message\
    \ integrity mechanisms and secure offer/answer\n   exchanges.\n   Forcing the\
    \ false peer reflexive candidate result with packet replays\n   is different.\
    \  The attacker waits until one of the agents sends a\n   check.  It intercepts\
    \ this request, and replays it towards the other\n   agent with a faked source\
    \ IP address.  It must also prevent the\n   original request from reaching the\
    \ remote agent, either by launching\n   a DoS attack to cause the packet to be\
    \ dropped, or forcing it to be\n   dropped using layer 2 mechanisms.  The replayed\
    \ packet is received at\n   the other agent, and accepted, since the integrity\
    \ check passes (the\n   integrity check cannot and does not cover the source IP\
    \ address and\n   port).  It is then responded to.  This response will contain\
    \ a XOR-\n   MAPPED-ADDRESS with the false candidate, and will be sent to that\n\
    \   false candidate.  The attacker must then receive it and relay it\n   towards\
    \ the originator.\n   The other agent will then initiate a connectivity check\
    \ towards that\n   false candidate.  This validation needs to succeed.  This requires\n\
    \   the attacker to force a false valid on a false candidate.  Injecting\n   of\
    \ fake requests or responses to achieve this goal is prevented using\n   the integrity\
    \ mechanisms of STUN and the offer/answer exchange.\n   Thus, this attack can\
    \ only be launched through replays.  To do that,\n   the attacker must intercept\
    \ the check towards this false candidate,\n   and replay it towards the other\
    \ agent.  Then, it must intercept the\n   response and replay that back as well.\n\
    \   This attack is very hard to launch unless the attacker is identified\n   by\
    \ the fake candidate.  This is because it requires the attacker to\n   intercept\
    \ and replay packets sent by two different hosts.  If both\n   agents are on different\
    \ networks (for example, across the public\n   Internet), this attack can be hard\
    \ to coordinate, since it needs to\n   occur against two different endpoints on\
    \ different parts of the\n   network at the same time.\n   If the attacker itself\
    \ is identified by the fake candidate, the\n   attack is easier to coordinate.\
    \  However, if SRTP is used [RFC3711],\n   the attacker will not be able to play\
    \ the media packets, but will\n   only be able to discard them, effectively disabling\
    \ the media stream\n   for the call.  However, this attack requires the agent\
    \ to disrupt\n   packets in order to block the connectivity check from reaching\
    \ the\n   target.  In that case, if the goal is to disrupt the media stream,\n\
    \   it's much easier to just disrupt it with the same mechanism, rather\n   than\
    \ attack ICE.\n"
- title: 18.2.  Attacks on Server Reflexive Address Gathering
  contents:
  - "18.2.  Attacks on Server Reflexive Address Gathering\n   ICE endpoints make use\
    \ of STUN Binding requests for gathering server\n   reflexive candidates from\
    \ a STUN server.  These requests are not\n   authenticated in any way.  As a consequence,\
    \ there are numerous\n   techniques an attacker can employ to provide the client\
    \ with a false\n   server reflexive candidate:\n   o  An attacker can compromise\
    \ the DNS, causing DNS queries to return\n      a rogue STUN server address. \
    \ That server can provide the client\n      with fake server reflexive candidates.\
    \  This attack is mitigated\n      by DNS security, though DNS-SEC is not required\
    \ to address it.\n   o  An attacker that can observe STUN messages (such as an\
    \ attacker on\n      a shared network segment, like WiFi) can inject a fake response\n\
    \      that is valid and will be accepted by the client.\n   o  An attacker can\
    \ compromise a STUN server by means of a virus, and\n      cause it to send responses\
    \ with incorrect mapped addresses.\n   A false mapped address learned by these\
    \ attacks will be used as a\n   server reflexive candidate in the ICE exchange.\
    \  For this candidate\n   to actually be used for media, the attacker must also\
    \ attack the\n   connectivity checks, and in particular, force a false valid on\
    \ a\n   false candidate.  This attack is very hard to launch if the false\n  \
    \ address identifies a fourth party (neither the offerer, answerer, nor\n   attacker),\
    \ since it requires attacking the checks generated by each\n   agent in the session,\
    \ and is prevented by SRTP if it identifies the\n   attacker themself.\n   If\
    \ the attacker elects not to attack the connectivity checks, the\n   worst it\
    \ can do is prevent the server reflexive candidate from being\n   used.  However,\
    \ if the peer agent has at least one candidate that is\n   reachable by the agent\
    \ under attack, the STUN connectivity checks\n   themselves will provide a peer\
    \ reflexive candidate that can be used\n   for the exchange of media.  Peer reflexive\
    \ candidates are generally\n   preferred over server reflexive candidates.  As\
    \ such, an attack\n   solely on the STUN address gathering will normally have\
    \ no impact on\n   a session at all.\n"
- title: 18.3.  Attacks on Relayed Candidate Gathering
  contents:
  - "18.3.  Attacks on Relayed Candidate Gathering\n   An attacker might attempt to\
    \ disrupt the gathering of relayed\n   candidates, forcing the client to believe\
    \ it has a false relayed\n   candidate.  Exchanges with the TURN server are authenticated\
    \ using a\n   long-term credential.  Consequently, injection of fake responses\
    \ or\n   requests will not work.  In addition, unlike Binding requests,\n   Allocate\
    \ requests are not susceptible to replay attacks with modified\n   source IP addresses\
    \ and ports, since the source IP address and port\n   are not utilized to provide\
    \ the client with its relayed candidate.\n   However, TURN servers are susceptible\
    \ to DNS attacks, or to viruses\n   aimed at the TURN server, for purposes of\
    \ turning it into a zombie or\n   rogue server.  These attacks can be mitigated\
    \ by DNS-SEC and through\n   good box and software security on TURN servers.\n\
    \   Even if an attacker has caused the client to believe in a false\n   relayed\
    \ candidate, the connectivity checks cause such a candidate to\n   be used only\
    \ if they succeed.  Thus, an attacker must launch a false\n   valid on a false\
    \ candidate, per above, which is a very difficult\n   attack to coordinate.\n"
- title: 18.4.  Attacks on the Offer/Answer Exchanges
  contents:
  - "18.4.  Attacks on the Offer/Answer Exchanges\n   An attacker that can modify\
    \ or disrupt the offer/answer exchanges\n   themselves can readily launch a variety\
    \ of attacks with ICE.  They\n   could direct media to a target of a DoS attack,\
    \ they could insert\n   themselves into the media stream, and so on.  These are\
    \ similar to\n   the general security considerations for offer/answer exchanges,\
    \ and\n   the security considerations in RFC 3264 [RFC3264] apply.  These\n  \
    \ require techniques for message integrity and encryption for offers\n   and answers,\
    \ which are satisfied by the SIPS mechanism [RFC3261] when\n   SIP is used.  As\
    \ such, the usage of SIPS with ICE is RECOMMENDED.\n"
- title: 18.5.  Insider Attacks
  contents:
  - "18.5.  Insider Attacks\n   In addition to attacks where the attacker is a third\
    \ party trying to\n   insert fake offers, answers, or stun messages, there are\
    \ several\n   attacks possible with ICE when the attacker is an authenticated\
    \ and\n   valid participant in the ICE exchange.\n"
- title: 18.5.1.  The Voice Hammer Attack
  contents:
  - "18.5.1.  The Voice Hammer Attack\n   The voice hammer attack is an amplification\
    \ attack.  In this attack,\n   the attacker initiates sessions to other agents,\
    \ and maliciously\n   includes the IP address and port of a DoS target as the\
    \ destination\n   for media traffic signaled in the SDP.  This causes substantial\n\
    \   amplification; a single offer/answer exchange can create a continuing\n  \
    \ flood of media packets, possibly at high rates (consider video\n   sources).\
    \  This attack is not specific to ICE, but ICE can help\n   provide remediation.\n\
    \   Specifically, if ICE is used, the agent receiving the malicious SDP\n   will\
    \ first perform connectivity checks to the target of media before\n   sending\
    \ media there.  If this target is a third-party host, the\n   checks will not\
    \ succeed, and media is never sent.\n   Unfortunately, ICE doesn't help if its\
    \ not used, in which case an\n   attacker could simply send the offer without\
    \ the ICE parameters.\n   However, in environments where the set of clients is\
    \ known, and is\n   limited to ones that support ICE, the server can reject any\
    \ offers or\n   answers that don't indicate ICE support.\n"
- title: 18.5.2.  STUN Amplification Attack
  contents:
  - "18.5.2.  STUN Amplification Attack\n   The STUN amplification attack is similar\
    \ to the voice hammer.\n   However, instead of voice packets being directed to\
    \ the target, STUN\n   connectivity checks are directed to the target.  The attacker\
    \ sends\n   an offer with a large number of candidates, say, 50.  The answerer\n\
    \   receives the offer, and starts its checks, which are directed at the\n   target,\
    \ and consequently, never generate a response.  The answerer\n   will start a\
    \ new connectivity check every Ta ms (say, Ta=20ms).\n   However, the retransmission\
    \ timers are set to a large number due to\n   the large number of candidates.\
    \  As a consequence, packets will be\n   sent at an interval of one every Ta milliseconds,\
    \ and then with\n   increasing intervals after that.  Thus, STUN will not send\
    \ packets at\n   a rate faster than media would be sent, and the STUN packets\
    \ persist\n   only briefly, until ICE fails for the session.  Nonetheless, this\
    \ is\n   an amplification mechanism.\n   It is impossible to eliminate the amplification,\
    \ but the volume can\n   be reduced through a variety of heuristics.  Agents SHOULD\
    \ limit the\n   total number of connectivity checks they perform to 100.\n   Additionally,\
    \ agents MAY limit the number of candidates they'll\n   accept in an offer or\
    \ answer.\n   Frequently, protocols that wish to avoid these kinds of attacks\
    \ force\n   the initiator to wait for a response prior to sending the next\n \
    \  message.  However, in the case of ICE, this is not possible.  It is\n   not\
    \ possible to differentiate the following two cases:\n   o  There was no response\
    \ because the initiator is being used to\n      launch a DoS attack against an\
    \ unsuspecting target that will not\n      respond.\n   o  There was no response\
    \ because the IP address and port are not\n      reachable by the initiator.\n\
    \   In the second case, another check should be sent at the next\n   opportunity,\
    \ while in the former case, no further checks should be\n   sent.\n"
- title: 18.6.  Interactions with Application Layer Gateways and SIP
  contents:
  - "18.6.  Interactions with Application Layer Gateways and SIP\n   Application Layer\
    \ Gateways (ALGs) are functions present in a NAT\n   device that inspect the contents\
    \ of packets and modify them, in order\n   to facilitate NAT traversal for application\
    \ protocols.  Session\n   Border Controllers (SBCs) are close cousins of ALGs,\
    \ but are less\n   transparent since they actually exist as application layer\
    \ SIP\n   intermediaries.  ICE has interactions with SBCs and ALGs.\n   If an\
    \ ALG is SIP aware but not ICE aware, ICE will work through it as\n   long as\
    \ the ALG correctly modifies the SDP.  A correct ALG\n   implementation behaves\
    \ as follows:\n   o  The ALG does not modify the m and c lines or the rtcp attribute\
    \ if\n      they contain external addresses.\n   o  If the m and c lines contain\
    \ internal addresses, the modification\n      depends on the state of the ALG:\n\
    \         If the ALG already has a binding established that maps an\n        \
    \ external port to an internal IP address and port matching the\n         values\
    \ in the m and c lines or rtcp attribute, the ALG uses\n         that binding\
    \ instead of creating a new one.\n         If the ALG does not already have a\
    \ binding, it creates a new\n         one and modifies the SDP, rewriting the\
    \ m and c lines and rtcp\n         attribute.\n   Unfortunately, many ALGs are\
    \ known to work poorly in these corner\n   cases.  ICE does not try to work around\
    \ broken ALGs, as this is\n   outside the scope of its functionality.  ICE can\
    \ help diagnose these\n   conditions, which often show up as a mismatch between\
    \ the set of\n   candidates and the m and c lines and rtcp attributes.  The ice-\n\
    \   mismatch attribute is used for this purpose.\n   ICE works best through ALGs\
    \ when the signaling is run over TLS.  This\n   prevents the ALG from manipulating\
    \ the SDP messages and interfering\n   with ICE operation.  Implementations that\
    \ are expected to be deployed\n   behind ALGs SHOULD provide for TLS transport\
    \ of the SDP.\n   If an SBC is SIP aware but not ICE aware, the result depends\
    \ on the\n   behavior of the SBC.  If it is acting as a proper Back-to-Back User\n\
    \   Agent (B2BUA), the SBC will remove any SDP attributes it doesn't\n   understand,\
    \ including the ICE attributes.  Consequently, the call\n   will appear to both\
    \ endpoints as if the other side doesn't support\n   ICE.  This will result in\
    \ ICE being disabled, and media flowing\n   through the SBC, if the SBC has requested\
    \ it.  If, however, the SBC\n   passes the ICE attributes without modification,\
    \ yet modifies the\n   default destination for media (contained in the m and c\
    \ lines and\n   rtcp attribute), this will be detected as an ICE mismatch, and\
    \ ICE\n   processing is aborted for the call.  It is outside of the scope of\n\
    \   ICE for it to act as a tool for \"working around\" SBCs.  If one is\n   present,\
    \ ICE will not be used and the SBC techniques take precedence.\n"
- title: 19.  STUN Extensions
  contents:
  - '19.  STUN Extensions

    '
- title: 19.1.  New Attributes
  contents:
  - "19.1.  New Attributes\n   This specification defines four new attributes, PRIORITY,\
    \ USE-\n   CANDIDATE, ICE-CONTROLLED, and ICE-CONTROLLING.\n   The PRIORITY attribute\
    \ indicates the priority that is to be\n   associated with a peer reflexive candidate,\
    \ should one be discovered\n   by this check.  It is a 32-bit unsigned integer,\
    \ and has an attribute\n   value of 0x0024.\n   The USE-CANDIDATE attribute indicates\
    \ that the candidate pair\n   resulting from this check should be used for transmission\
    \ of media.\n   The attribute has no content (the Length field of the attribute\
    \ is\n   zero); it serves as a flag.  It has an attribute value of 0x0025.\n \
    \  The ICE-CONTROLLED attribute is present in a Binding request and\n   indicates\
    \ that the client believes it is currently in the controlled\n   role.  The content\
    \ of the attribute is a 64-bit unsigned integer in\n   network byte order, which\
    \ contains a random number used for tie-\n   breaking of role conflicts.\n   The\
    \ ICE-CONTROLLING attribute is present in a Binding request and\n   indicates\
    \ that the client believes it is currently in the controlling\n   role.  The content\
    \ of the attribute is a 64-bit unsigned integer in\n   network byte order, which\
    \ contains a random number used for tie-\n   breaking of role conflicts.\n"
- title: 19.2.  New Error Response Codes
  contents:
  - "19.2.  New Error Response Codes\n   This specification defines a single error\
    \ response code:\n   487 (Role Conflict):  The Binding request contained either\
    \ the ICE-\n      CONTROLLING or ICE-CONTROLLED attribute, indicating a role that\n\
    \      conflicted with the server.  The server ran a tie-breaker based on\n  \
    \    the tie-breaker value in the request and determined that the\n      client\
    \ needs to switch roles.\n"
- title: 20.  Operational Considerations
  contents:
  - "20.  Operational Considerations\n   This section discusses issues relevant to\
    \ network operators looking\n   to deploy ICE.\n"
- title: 20.1.  NAT and Firewall Types
  contents:
  - "20.1.  NAT and Firewall Types\n   ICE was designed to work with existing NAT\
    \ and firewall equipment.\n   Consequently, it is not necessary to replace or\
    \ reconfigure existing\n   firewall and NAT equipment in order to facilitate deployment\
    \ of ICE.\n   Indeed, ICE was developed to be deployed in environments where the\n\
    \   Voice over IP (VoIP) operator has no control over the IP network\n   infrastructure,\
    \ including firewalls and NAT.\n   That said, ICE works best in environments where\
    \ the NAT devices are\n   \"behave\" compliant, meeting the recommendations defined\
    \ in [RFC4787]\n   and [RFC5766].  In networks with behave-compliant NAT, ICE\
    \ will work\n   without the need for a TURN server, thus improving voice quality,\n\
    \   decreasing call setup times, and reducing the bandwidth demands on\n   the\
    \ network operator.\n"
- title: 20.2.  Bandwidth Requirements
  contents:
  - "20.2.  Bandwidth Requirements\n   Deployment of ICE can have several interactions\
    \ with available\n   network capacity that operators should take into consideration.\n"
- title: 20.2.1.  STUN and TURN Server Capacity Planning
  contents:
  - "20.2.1.  STUN and TURN Server Capacity Planning\n   First and foremost, ICE makes\
    \ use of TURN and STUN servers, which\n   would typically be located in the network\
    \ operator's data centers.\n   The STUN servers require relatively little bandwidth.\
    \  For each\n   component of each media stream, there will be one or more STUN\n\
    \   transactions from each client to the STUN server.  In a basic voice-\n   only\
    \ IPv4 VoIP deployment, there will be four transactions per call\n   (one for\
    \ RTP and one for RTCP, for both caller and callee).  Each\n   transaction is\
    \ a single request and a single response, the former\n   being 20 bytes long,\
    \ and the latter, 28.  Consequently, if a system\n   has N users, and each makes\
    \ four calls in a busy hour, this would\n   require N*1.7bps.  For one million\
    \ users, this is 1.7 Mbps, a very\n   small number (relatively speaking).\n  \
    \ TURN traffic is more substantial.  The TURN server will see traffic\n   volume\
    \ equal to the STUN volume (indeed, if TURN servers are\n   deployed, there is\
    \ no need for a separate STUN server), in addition\n   to the traffic for the\
    \ actual media traffic.  The amount of calls\n   requiring TURN for media relay\
    \ is highly dependent on network\n   topologies, and can and will vary over time.\
    \  In a network with 100%\n   behave-compliant NAT, it is exactly zero.  At time\
    \ of writing, large-\n   scale consumer deployments were seeing between 5 and\
    \ 10 percent of\n   calls requiring TURN servers.  Considering a voice-only deployment\n\
    \   using G.711 (so 80 kbps in each direction), with .2 erlangs during\n   the\
    \ busy hour, this is N*3.2 kbps.  For a population of one million\n   users, this\
    \ is 3.2 Gbps, assuming a 10% usage of TURN servers.\n"
- title: 20.2.2.  Gathering and Connectivity Checks
  contents:
  - "20.2.2.  Gathering and Connectivity Checks\n   The process of gathering of candidates\
    \ and performing of connectivity\n   checks can be bandwidth intensive.  ICE has\
    \ been designed to pace\n   both of these processes.  The gathering phase and\
    \ the connectivity\n   check phase are meant to generate traffic at roughly the\
    \ same\n   bandwidth as the media traffic itself.  This was done to ensure that,\n\
    \   if a network is designed to support multimedia traffic of a certain\n   type\
    \ (voice, video, or just text), it will have sufficient capacity\n   to support\
    \ the ICE checks for that media.  Of course, the ICE checks\n   will cause a marginal\
    \ increase in the total utilization; however,\n   this will typically be an extremely\
    \ small increase.\n   Congestion due to the gathering and check phases has proven\
    \ to be a\n   problem in deployments that did not utilize pacing.  Typically,\n\
    \   access links became congested as the endpoints flooded the network\n   with\
    \ checks as fast as they can send them.  Consequently, network\n   operators should\
    \ make sure that their ICE implementations support the\n   pacing feature.  Though\
    \ this pacing does increase call setup times,\n   it makes ICE network friendly\
    \ and easier to deploy.\n"
- title: 20.2.3.  Keepalives
  contents:
  - "20.2.3.  Keepalives\n   STUN keepalives (in the form of STUN Binding Indications)\
    \ are sent in\n   the middle of a media session.  However, they are sent only\
    \ in the\n   absence of actual media traffic.  In deployments that are not\n \
    \  utilizing Voice Activity Detection (VAD), the keepalives are never\n   used\
    \ and there is no increase in bandwidth usage.  When VAD is being\n   used, keepalives\
    \ will be sent during silence periods.  This involves\n   a single packet every\
    \ 15-20 seconds, far less than the packet every\n   20-30 ms that is sent when\
    \ there is voice.  Therefore, keepalives\n   don't have any real impact on capacity\
    \ planning.\n"
- title: 20.3.  ICE and ICE-lite
  contents:
  - "20.3.  ICE and ICE-lite\n   Deployments utilizing a mix of ICE and ICE-lite interoperate\n\
    \   perfectly.  They have been explicitly designed to do so, without loss\n  \
    \ of function.\n   However, ICE-lite can only be deployed in limited use cases.\
    \  Those\n   cases, and the caveats involved in doing so, are documented in\n\
    \   Appendix A.\n"
- title: 20.4.  Troubleshooting and Performance Management
  contents:
  - "20.4.  Troubleshooting and Performance Management\n   ICE utilizes end-to-end\
    \ connectivity checks, and places much of the\n   processing in the endpoints.\
    \  This introduces a challenge to the\n   network operator -- how can they troubleshoot\
    \ ICE deployments?  How\n   can they know how ICE is performing?\n   ICE has built-in\
    \ features to help deal with these problems.  SIP\n   servers on the signaling\
    \ path, typically deployed in the data centers\n   of the network operator, will\
    \ see the contents of the offer/answer\n   exchanges that convey the ICE parameters.\
    \  These parameters include\n   the type of each candidate (host, server reflexive,\
    \ or relayed),\n   along with their related addresses.  Once ICE processing has\n\
    \   completed, an updated offer/answer exchange takes place, signaling\n   the\
    \ selected address (and its type).  This updated re-INVITE is\n   performed exactly\
    \ for the purposes of educating network equipment\n   (such as a diagnostic tool\
    \ attached to a SIP server) about the\n   results of ICE processing.\n   As a\
    \ consequence, through the logs generated by the SIP server, a\n   network operator\
    \ can observe what types of candidates are being used\n   for each call, and what\
    \ address was selected by ICE.  This is the\n   primary information that helps\
    \ evaluate how ICE is performing.\n"
- title: 20.5.  Endpoint Configuration
  contents:
  - "20.5.  Endpoint Configuration\n   ICE relies on several pieces of data being\
    \ configured into the\n   endpoints.  This configuration data includes timers,\
    \ credentials for\n   TURN servers, and hostnames for STUN and TURN servers. \
    \ ICE itself\n   does not provide a mechanism for this configuration.  Instead,\
    \ it is\n   assumed that this information is attached to whatever mechanism is\n\
    \   used to configure all of the other parameters in the endpoint.  For\n   SIP\
    \ phones, standard solutions such as the configuration framework\n   [SIP-UA-FRMWK]\
    \ have been defined.\n"
- title: 21.  IANA Considerations
  contents:
  - "21.  IANA Considerations\n   This specification registers new SDP attributes,\
    \ four new STUN\n   attributes, and one new STUN error response.\n"
- title: 21.1.  SDP Attributes
  contents:
  - "21.1.  SDP Attributes\n   This specification defines seven new SDP attributes\
    \ per the\n   procedures of Section 8.2.4 of [RFC4566].  The required information\n\
    \   for the registrations is included here.\n"
- title: 21.1.1.  candidate Attribute
  contents:
  - "21.1.1.  candidate Attribute\n   Contact Name:  Jonathan Rosenberg, jdrosen@jdrosen.net.\n\
    \   Attribute Name:  candidate\n   Long Form:  candidate\n   Type of Attribute:\
    \  media-level\n   Charset Considerations:  The attribute is not subject to the\
    \ charset\n      attribute.\n   Purpose:  This attribute is used with Interactive\
    \ Connectivity\n      Establishment (ICE), and provides one of many possible candidate\n\
    \      addresses for communication.  These addresses are validated with\n    \
    \  an end-to-end connectivity check using Session Traversal Utilities\n      for\
    \ NAT (STUN)).\n   Appropriate Values:  See Section 15 of RFC 5245.\n"
- title: 21.1.2.  remote-candidates Attribute
  contents:
  - "21.1.2.  remote-candidates Attribute\n   Contact Name:  Jonathan Rosenberg, jdrosen@jdrosen.net.\n\
    \   Attribute Name:  remote-candidates\n   Long Form:  remote-candidates\n   Type\
    \ of Attribute:  media-level\n   Charset Considerations:  The attribute is not\
    \ subject to the charset\n      attribute.\n   Purpose:  This attribute is used\
    \ with Interactive Connectivity\n      Establishment (ICE), and provides the identity\
    \ of the remote\n      candidates that the offerer wishes the answerer to use\
    \ in its\n      answer.\n   Appropriate Values:  See Section 15 of RFC 5245.\n"
- title: 21.1.3.  ice-lite Attribute
  contents:
  - "21.1.3.  ice-lite Attribute\n   Contact Name:  Jonathan Rosenberg, jdrosen@jdrosen.net.\n\
    \   Attribute Name:  ice-lite\n   Long Form:  ice-lite\n   Type of Attribute:\
    \  session-level\n   Charset Considerations:  The attribute is not subject to\
    \ the charset\n      attribute.\n   Purpose:  This attribute is used with Interactive\
    \ Connectivity\n      Establishment (ICE), and indicates that an agent has the\
    \ minimum\n      functionality required to support ICE inter-operation with a\
    \ peer\n      that has a full implementation.\n   Appropriate Values:  See Section\
    \ 15 of RFC 5245.\n"
- title: 21.1.4.  ice-mismatch Attribute
  contents:
  - "21.1.4.  ice-mismatch Attribute\n   Contact Name:  Jonathan Rosenberg, jdrosen@jdrosen.net.\n\
    \   Attribute Name:  ice-mismatch\n   Long Form:  ice-mismatch\n   Type of Attribute:\
    \  session-level\n   Charset Considerations:  The attribute is not subject to\
    \ the charset\n      attribute.\n   Purpose:  This attribute is used with Interactive\
    \ Connectivity\n      Establishment (ICE), and indicates that an agent is ICE\
    \ capable,\n      but did not proceed with ICE due to a mismatch of candidates\
    \ with\n      the default destination for media signaled in the SDP.\n   Appropriate\
    \ Values:  See Section 15 of RFC 5245.\n"
- title: 21.1.5.  ice-pwd Attribute
  contents:
  - "21.1.5.  ice-pwd Attribute\n   Contact Name:  Jonathan Rosenberg, jdrosen@jdrosen.net.\n\
    \   Attribute Name:  ice-pwd\n   Long Form:  ice-pwd\n   Type of Attribute:  session-\
    \ or media-level\n   Charset Considerations:  The attribute is not subject to\
    \ the charset\n      attribute.\n   Purpose:  This attribute is used with Interactive\
    \ Connectivity\n      Establishment (ICE), and provides the password used to protect\n\
    \      STUN connectivity checks.\n   Appropriate Values:  See Section 15 of RFC\
    \ 5245.\n"
- title: 21.1.6.  ice-ufrag Attribute
  contents:
  - "21.1.6.  ice-ufrag Attribute\n   Contact Name:  Jonathan Rosenberg, jdrosen@jdrosen.net.\n\
    \   Attribute Name:  ice-ufrag\n   Long Form:  ice-ufrag\n   Type of Attribute:\
    \  session- or media-level\n   Charset Considerations:  The attribute is not subject\
    \ to the charset\n      attribute.\n   Purpose:  This attribute is used with Interactive\
    \ Connectivity\n      Establishment (ICE), and provides the fragments used to\
    \ construct\n      the username in STUN connectivity checks.\n   Appropriate Values:\
    \  See Section 15 of RFC 5245.\n"
- title: 21.1.7.  ice-options Attribute
  contents:
  - "21.1.7.  ice-options Attribute\n   Contact Name:  Jonathan Rosenberg, jdrosen@jdrosen.net.\n\
    \   Attribute Name:  ice-options\n   Long Form:  ice-options\n   Type of Attribute:\
    \  session-level\n   Charset Considerations:  The attribute is not subject to\
    \ the charset\n      attribute.\n   Purpose:  This attribute is used with Interactive\
    \ Connectivity\n      Establishment (ICE), and indicates the ICE options or extensions\n\
    \      used by the agent.\n   Appropriate Values:  See Section 15 of RFC 5245.\n"
- title: 21.2.  STUN Attributes
  contents:
  - "21.2.  STUN Attributes\n   This section registers four new STUN attributes per\
    \ the procedures in\n   [RFC5389].\n      0x0024 PRIORITY\n      0x0025 USE-CANDIDATE\n\
    \      0x8029 ICE-CONTROLLED\n      0x802A ICE-CONTROLLING\n"
- title: 21.3.  STUN Error Responses
  contents:
  - "21.3.  STUN Error Responses\n   This section registers one new STUN error response\
    \ code per the\n   procedures in [RFC5389].\n      487   Role Conflict: The client\
    \ asserted an ICE role (controlling\n      or\n            controlled) that is\
    \ in conflict with the role of the server.\n"
- title: 22.  IAB Considerations
  contents:
  - "22.  IAB Considerations\n   The IAB has studied the problem of \"Unilateral Self-Address\
    \ Fixing\",\n   which is the general process by which a agent attempts to determine\n\
    \   its address in another realm on the other side of a NAT through a\n   collaborative\
    \ protocol reflection mechanism [RFC3424].  ICE is an\n   example of a protocol\
    \ that performs this type of function.\n   Interestingly, the process for ICE\
    \ is not unilateral, but bilateral,\n   and the difference has a significant impact\
    \ on the issues raised by\n   IAB.  Indeed, ICE can be considered a B-SAF (Bilateral\
    \ Self-Address\n   Fixing) protocol, rather than an UNSAF protocol.  Regardless,\
    \ the IAB\n   has mandated that any protocols developed for this purpose document\
    \ a\n   specific set of considerations.  This section meets those\n   requirements.\n"
- title: 22.1.  Problem Definition
  contents:
  - "22.1.  Problem Definition\n   >From RFC 3424, any UNSAF proposal must provide:\n\
    \      Precise definition of a specific, limited-scope problem that is to\n  \
    \    be solved with the UNSAF proposal.  A short-term fix should not be\n    \
    \  generalized to solve other problems; this is why \"short-term fixes\n     \
    \ usually aren't\".\n   The specific problems being solved by ICE are:\n     \
    \ Provide a means for two peers to determine the set of transport\n      addresses\
    \ that can be used for communication.\n      Provide a means for a agent to determine\
    \ an address that is\n      reachable by another peer with which it wishes to\
    \ communicate.\n"
- title: 22.2.  Exit Strategy
  contents:
  - "22.2.  Exit Strategy\n   >From RFC 3424, any UNSAF proposal must provide:\n \
    \     Description of an exit strategy/transition plan.  The better\n      short-term\
    \ fixes are the ones that will naturally see less and\n      less use as the appropriate\
    \ technology is deployed.\n   ICE itself doesn't easily get phased out.  However,\
    \ it is useful even\n   in a globally connected Internet, to serve as a means\
    \ for detecting\n   whether a router failure has temporarily disrupted connectivity,\
    \ for\n   example.  ICE also helps prevent certain security attacks that have\n\
    \   nothing to do with NAT.  However, what ICE does is help phase out\n   other\
    \ UNSAF mechanisms.  ICE effectively selects amongst those\n   mechanisms, prioritizing\
    \ ones that are better, and deprioritizing\n   ones that are worse.  Local IPv6\
    \ addresses can be preferred.  As NATs\n   begin to dissipate as IPv6 is introduced,\
    \ server reflexive and\n   relayed candidates (both forms of UNSAF addresses)\
    \ simply never get\n   used, because higher-priority connectivity exists to the\
    \ native host\n   candidates.  Therefore, the servers get used less and less,\
    \ and can\n   eventually be remove when their usage goes to zero.\n   Indeed,\
    \ ICE can assist in the transition from IPv4 to IPv6.  It can\n   be used to determine\
    \ whether to use IPv6 or IPv4 when two dual-stack\n   hosts communicate with SIP\
    \ (IPv6 gets used).  It can also allow a\n   network with both 6to4 and native\
    \ v6 connectivity to determine which\n   address to use when communicating with\
    \ a peer.\n"
- title: 22.3.  Brittleness Introduced by ICE
  contents:
  - "22.3.  Brittleness Introduced by ICE\n   >From RFC 3424, any UNSAF proposal must\
    \ provide:\n      Discussion of specific issues that may render systems more\n\
    \      \"brittle\".  For example, approaches that involve using data at\n    \
    \  multiple network layers create more dependencies, increase\n      debugging\
    \ challenges, and make it harder to transition.\n   ICE actually removes brittleness\
    \ from existing UNSAF mechanisms.  In\n   particular, classic STUN (as described\
    \ in RFC 3489 [RFC3489]) has\n   several points of brittleness.  One of them is\
    \ the discovery process\n   that requires an agent to try to classify the type\
    \ of NAT it is\n   behind.  This process is error-prone.  With ICE, that discovery\n\
    \   process is simply not used.  Rather than unilaterally assessing the\n   validity\
    \ of the address, its validity is dynamically determined by\n   measuring connectivity\
    \ to a peer.  The process of determining\n   connectivity is very robust.\n  \
    \ Another point of brittleness in classic STUN and any other unilateral\n   mechanism\
    \ is its absolute reliance on an additional server.  ICE\n   makes use of a server\
    \ for allocating unilateral addresses, but allows\n   agents to directly connect\
    \ if possible.  Therefore, in some cases,\n   the failure of a STUN server would\
    \ still allow for a call to progress\n   when ICE is used.\n   Another point of\
    \ brittleness in classic STUN is that it assumes that\n   the STUN server is on\
    \ the public Internet.  Interestingly, with ICE,\n   that is not necessary.  There\
    \ can be a multitude of STUN servers in a\n   variety of address realms.  ICE\
    \ will discover the one that has\n   provided a usable address.\n   The most troubling\
    \ point of brittleness in classic STUN is that it\n   doesn't work in all network\
    \ topologies.  In cases where there is a\n   shared NAT between each agent and\
    \ the STUN server, traditional STUN\n   may not work.  With ICE, that restriction\
    \ is removed.\n   Classic STUN also introduces some security considerations.\n\
    \   Fortunately, those security considerations are also mitigated by ICE.\n  \
    \ Consequently, ICE serves to repair the brittleness introduced in\n   classic\
    \ STUN, and does not introduce any additional brittleness into\n   the system.\n\
    \   The penalty of these improvements is that ICE increases session\n   establishment\
    \ times.\n"
- title: 22.4.  Requirements for a Long-Term Solution
  contents:
  - "22.4.  Requirements for a Long-Term Solution\n   From RFC 3424, any UNSAF proposal\
    \ must provide:\n      ... requirements for longer term, sound technical solutions\
    \ --\n      contribute to the process of finding the right longer term\n     \
    \ solution.\n   Our conclusions from RFC 3489 remain unchanged.  However, we feel\
    \ ICE\n   actually helps because we believe it can be part of the long-term\n\
    \   solution.\n"
- title: 22.5.  Issues with Existing NAPT Boxes
  contents:
  - "22.5.  Issues with Existing NAPT Boxes\n   From RFC 3424, any UNSAF proposal\
    \ must provide:\n      Discussion of the impact of the noted practical issues\
    \ with\n      existing, deployed NA[P]Ts and experience reports.\n   A number\
    \ of NAT boxes are now being deployed into the market that try\n   to provide\
    \ \"generic\" ALG functionality.  These generic ALGs hunt for\n   IP addresses,\
    \ either in text or binary form within a packet, and\n   rewrite them if they\
    \ match a binding.  This interferes with classic\n   STUN.  However, the update\
    \ to STUN [RFC5389] uses an encoding that\n   hides these binary addresses from\
    \ generic ALGs.\n   Existing NAPT boxes have non-deterministic and typically short\n\
    \   expiration times for UDP-based bindings.  This requires\n   implementations\
    \ to send periodic keepalives to maintain those\n   bindings.  ICE uses a default\
    \ of 15 s, which is a very conservative\n   estimate.  Eventually, over time,\
    \ as NAT boxes become compliant to\n   behave [RFC4787], this minimum keepalive\
    \ will become deterministic\n   and well-known, and the ICE timers can be adjusted.\
    \  Having a way to\n   discover and control the minimum keepalive interval would\
    \ be far\n   better still.\n"
- title: 23.  Acknowledgements
  contents:
  - "23.  Acknowledgements\n   The authors would like to thank Dan Wing, Eric Rescorla,\
    \ Flemming\n   Andreasen, Rohan Mahy, Dean Willis, Eric Cooper, Jason Fischl,\n\
    \   Douglas Otis, Tim Moore, Jean-Francois Mule, Kevin Johns, Jonathan\n   Lennox,\
    \ and Francois Audet for their comments and input.  A special\n   thanks goes\
    \ to Bill May, who suggested several of the concepts in\n   this specification,\
    \ Philip Matthews, who suggested many of the key\n   performance optimizations\
    \ in this specification, Eric Rescorla, who\n   drafted the text in the introduction,\
    \ and Magnus Westerlund, for\n   doing several detailed reviews on the various\
    \ revisions of this\n   specification.\n"
- title: 24.  References
  contents:
  - '24.  References

    '
- title: 24.1.  Normative References
  contents:
  - "24.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [RFC3605]  Huitema, C., \"Real Time Control Protocol (RTCP) attribute\n\
    \              in Session Description Protocol (SDP)\", RFC 3605,\n          \
    \    October 2003.\n   [RFC3261]  Rosenberg, J., Schulzrinne, H., Camarillo, G.,\
    \ Johnston,\n              A., Peterson, J., Sparks, R., Handley, M., and E.\n\
    \              Schooler, \"SIP: Session Initiation Protocol\", RFC 3261,\n   \
    \           June 2002.\n   [RFC3264]  Rosenberg, J. and H. Schulzrinne, \"An Offer/Answer\
    \ Model\n              with Session Description Protocol (SDP)\", RFC 3264,\n\
    \              June 2002.\n   [RFC3556]  Casner, S., \"Session Description Protocol\
    \ (SDP) Bandwidth\n              Modifiers for RTP Control Protocol (RTCP) Bandwidth\"\
    ,\n              RFC 3556, July 2003.\n   [RFC3312]  Camarillo, G., Marshall,\
    \ W., and J. Rosenberg,\n              \"Integration of Resource Management and\
    \ Session Initiation\n              Protocol (SIP)\", RFC 3312, October 2002.\n\
    \   [RFC4032]  Camarillo, G. and P. Kyzivat, \"Update to the Session\n       \
    \       Initiation Protocol (SIP) Preconditions Framework\",\n              RFC\
    \ 4032, March 2005.\n   [RFC3262]  Rosenberg, J. and H. Schulzrinne, \"Reliability\
    \ of\n              Provisional Responses in Session Initiation Protocol\n   \
    \           (SIP)\", RFC 3262, June 2002.\n   [RFC4566]  Handley, M., Jacobson,\
    \ V., and C. Perkins, \"SDP: Session\n              Description Protocol\", RFC\
    \ 4566, July 2006.\n   [RFC4091]  Camarillo, G. and J. Rosenberg, \"The Alternative\
    \ Network\n              Address Types (ANAT) Semantics for the Session Description\n\
    \              Protocol (SDP) Grouping Framework\", RFC 4091, June 2005.\n   [RFC4092]\
    \  Camarillo, G. and J. Rosenberg, \"Usage of the Session\n              Description\
    \ Protocol (SDP) Alternative Network Address\n              Types (ANAT) Semantics\
    \ in the Session Initiation Protocol\n              (SIP)\", RFC 4092, June 2005.\n\
    \   [RFC3484]  Draves, R., \"Default Address Selection for Internet\n        \
    \      Protocol version 6 (IPv6)\", RFC 3484, February 2003.\n   [RFC5234]  Crocker,\
    \ D., Ed., and P. Overell, \"Augmented BNF for\n              Syntax Specifications:\
    \ ABNF\", STD 68, RFC 5234, January\n              2008.\n   [RFC5389]  Rosenberg,\
    \ J., Mahy, R., Matthews, P., and D. Wing,\n              \"Session Traversal\
    \ Utilities for NAT (STUN)\", RFC 5389,\n              October 2008.\n   [RFC5766]\
    \  Mahy, R., Matthews, P., and J. Rosenberg, \"Traversal Using\n             \
    \ Relays around NAT (TURN): Relay Extensions to Session\n              Traversal\
    \ Utilities for NAT (STUN)\", RFC 5766, April 2010.\n   [RFC5768]  Rosenberg,\
    \ J., \"Indicating Support for Interactive\n              Connectivity Establishment\
    \ (ICE) in the Session Initiation\n              Protocol (SIP)\", RFC 5768, April\
    \ 2010.\n"
- title: 24.2.  Informative References
  contents:
  - "24.2.  Informative References\n   [RFC3489]  Rosenberg, J., Weinberger, J., Huitema,\
    \ C., and R. Mahy,\n              \"STUN - Simple Traversal of User Datagram Protocol\
    \ (UDP)\n              Through Network Address Translators (NATs)\", RFC 3489,\n\
    \              March 2003.\n   [RFC3235]  Senie, D., \"Network Address Translator\
    \ (NAT)-Friendly\n              Application Design Guidelines\", RFC 3235, January\
    \ 2002.\n   [RFC3303]  Srisuresh, P., Kuthan, J., Rosenberg, J., Molitor, A.,\
    \ and\n              A. Rayhan, \"Middlebox communication architecture and\n \
    \             framework\", RFC 3303, August 2002.\n   [RFC3725]  Rosenberg, J.,\
    \ Peterson, J., Schulzrinne, H., and G.\n              Camarillo, \"Best Current\
    \ Practices for Third Party Call\n              Control (3pcc) in the Session\
    \ Initiation Protocol (SIP)\",\n              BCP 85, RFC 3725, April 2004.\n\
    \   [RFC3102]  Borella, M., Lo, J., Grabelsky, D., and G. Montenegro,\n      \
    \        \"Realm Specific IP: Framework\", RFC 3102, October 2001.\n   [RFC3103]\
    \  Borella, M., Grabelsky, D., Lo, J., and K. Taniguchi,\n              \"Realm\
    \ Specific IP: Protocol Specification\", RFC 3103,\n              October 2001.\n\
    \   [RFC3424]  Daigle, L. and IAB, \"IAB Considerations for UNilateral\n     \
    \         Self-Address Fixing (UNSAF) Across Network Address\n              Translation\"\
    , RFC 3424, November 2002.\n   [RFC3550]  Schulzrinne, H., Casner, S., Frederick,\
    \ R., and V.\n              Jacobson, \"RTP: A Transport Protocol for Real-Time\n\
    \              Applications\", STD 64, RFC 3550, July 2003.\n   [RFC3711]  Baugher,\
    \ M., McGrew, D., Naslund, M., Carrara, E., and K.\n              Norrman, \"\
    The Secure Real-time Transport Protocol (SRTP)\",\n              RFC 3711, March\
    \ 2004.\n   [RFC3056]  Carpenter, B. and K. Moore, \"Connection of IPv6 Domains\n\
    \              via IPv4 Clouds\", RFC 3056, February 2001.\n   [RFC3389]  Zopf,\
    \ R., \"Real-time Transport Protocol (RTP) Payload for\n              Comfort\
    \ Noise (CN)\", RFC 3389, September 2002.\n   [RFC3960]  Camarillo, G. and H.\
    \ Schulzrinne, \"Early Media and Ringing\n              Tone Generation in the\
    \ Session Initiation Protocol (SIP)\",\n              RFC 3960, December 2004.\n\
    \   [RFC2475]  Blake, S., Black, D., Carlson, M., Davies, E., Wang, Z.,\n    \
    \          and W. Weiss, \"An Architecture for Differentiated\n              Services\"\
    , RFC 2475, December 1998.\n   [RFC1918]  Rekhter, Y., Moskowitz, R., Karrenberg,\
    \ D., Groot, G., and\n              E. Lear, \"Address Allocation for Private\
    \ Internets\",\n              BCP 5, RFC 1918, February 1996.\n   [RFC4787]  Audet,\
    \ F. and C. Jennings, \"Network Address Translation\n              (NAT) Behavioral\
    \ Requirements for Unicast UDP\", BCP 127,\n              RFC 4787, January 2007.\n\
    \   [SDP-PRECON]\n              Andreasen, F., Camarillo, G., Oran, D., and D.\
    \ Wing,\n              \"Connectivity Preconditions for Session Description\n\
    \              Protocol Media Streams\", Work in Progress, March 2010.\n   [NO-OP-RTP]\n\
    \              Andreasen, F., Oran, D., and D. Wing, \"A No-Op Payload\n     \
    \         Format for RTP\", Work in Progress, May 2007.\n   [RFC5761]  Perkins,\
    \ C. and M. Westerlund, \"Multiplexing RTP Data and\n              Control Packets\
    \ on a Single Port\", RFC 5761, April 2010.\n   [RFC4340]  Kohler, E., Handley,\
    \ M., and S. Floyd, \"Datagram\n              Congestion Control Protocol (DCCP)\"\
    , RFC 4340, March 2006.\n   [RFC4103]  Hellstrom, G. and P. Jones, \"RTP Payload\
    \ for Text\n              Conversation\", RFC 4103, June 2005.\n   [RFC5626] \
    \ Jennings, C., Mahy, R., and F. Audet, \"Managing Client-\n              Initiated\
    \ Connections in the Session Initiation Protocol\n              (SIP)\", RFC 5626,\
    \ October 2009.\n   [RFC5382]  Guha, S., Biswas, K., Ford, B., Sivakumar, S.,\
    \ and P.\n              Srisuresh, \"NAT Behavioral Requirements for TCP\", BCP\
    \ 142,\n              RFC 5382, October 2008.\n   [SIP-UA-FRMWK]\n           \
    \   Petrie, D. and S. Channabasappa, Ed., \"A Framework for\n              Session\
    \ Initiation Protocol User Agent Profile Delivery\",\n              Work in Progress,\
    \ February 2010.\n   [ICE-TCP]  Perreault, S., Ed. and J. Rosenberg, \"TCP Candidates\
    \ with\n              Interactive Connectivity Establishment (ICE)\", Work\n \
    \             in Progress, October 2009.\n"
- title: Appendix A.  Lite and Full Implementations
  contents:
  - "Appendix A.  Lite and Full Implementations\n   ICE allows for two types of implementations.\
    \  A full implementation\n   supports the controlling and controlled roles in\
    \ a session, and can\n   also perform address gathering.  In contrast, a lite\
    \ implementation\n   is a minimalist implementation that does little but respond\
    \ to STUN\n   checks.\n   Because ICE requires both endpoints to support it in\
    \ order to bring\n   benefits to either endpoint, incremental deployment of ICE\
    \ in a\n   network is more complicated.  Many sessions involve an endpoint that\n\
    \   is, by itself, not behind a NAT and not one that would worry about\n   NAT\
    \ traversal.  A very common case is to have one endpoint that\n   requires NAT\
    \ traversal (such as a VoIP hard phone or soft phone) make\n   a call to one of\
    \ these devices.  Even if the phone supports a full\n   ICE implementation, ICE\
    \ won't be used at all if the other device\n   doesn't support it.  The lite implementation\
    \ allows for a low-cost\n   entry point for these devices.  Once they support\
    \ the lite\n   implementation, full implementations can connect to them and get\
    \ the\n   full benefits of ICE.\n   Consequently, a lite implementation is only\
    \ appropriate for devices\n   that will *always* be connected to the public Internet\
    \ and have a\n   public IP address at which it can receive packets from any\n\
    \   correspondent.  ICE will not function when a lite implementation is\n   placed\
    \ behind a NAT.\n   ICE allows a lite implementation to have a single IPv4 host\
    \ candidate\n   and several IPv6 addresses.  In that case, candidate pairs are\n\
    \   selected by the controlling agent using a static algorithm, such as\n   the\
    \ one in RFC 3484, which is recommended by this specification.\n   However, static\
    \ mechanisms for address selection are always prone to\n   error, since they cannot\
    \ ever reflect the actual topology and can\n   never provide actual guarantees\
    \ on connectivity.  They are always\n   heuristics.  Consequently, if an agent\
    \ is implementing ICE just to\n   select between its IPv4 and IPv6 addresses,\
    \ and none of its IP\n   addresses are behind NAT, usage of full ICE is still\
    \ RECOMMENDED in\n   order to provide the most robust form of address selection\
    \ possible.\n   It is important to note that the lite implementation was added\
    \ to\n   this specification to provide a stepping stone to full\n   implementation.\
    \  Even for devices that are always connected to the\n   public Internet with\
    \ just a single IPv4 address, a full\n   implementation is preferable if achievable.\
    \  A full implementation\n   will reduce call setup times, since ICE's aggressive\
    \ mode can be\n   used.  Full implementations also obtain the security benefits\
    \ of ICE\n   unrelated to NAT traversal; in particular, the voice hammer attack\n\
    \   described in Section 18 is prevented only for full implementations,\n   not\
    \ lite.  Finally, it is often the case that a device that finds\n   itself with\
    \ a public address today will be placed in a network\n   tomorrow where it will\
    \ be behind a NAT.  It is difficult to\n   definitively know, over the lifetime\
    \ of a device or product, that it\n   will always be used on the public Internet.\
    \  Full implementation\n   provides assurance that communications will always\
    \ work.\n"
- title: Appendix B.  Design Motivations
  contents:
  - "Appendix B.  Design Motivations\n   ICE contains a number of normative behaviors\
    \ that may themselves be\n   simple, but derive from complicated or non-obvious\
    \ thinking or use\n   cases that merit further discussion.  Since these design\
    \ motivations\n   are not neccesary to understand for purposes of implementation,\
    \ they\n   are discussed here in an appendix to the specification.  This section\n\
    \   is non-normative.\n"
- title: B.1.  Pacing of STUN Transactions
  contents:
  - "B.1.  Pacing of STUN Transactions\n   STUN transactions used to gather candidates\
    \ and to verify\n   connectivity are paced out at an approximate rate of one new\n\
    \   transaction every Ta milliseconds.  Each transaction, in turn, has a\n   retransmission\
    \ timer RTO that is a function of Ta as well.  Why are\n   these transactions\
    \ paced, and why are these formulas used?\n   Sending of these STUN requests will\
    \ often have the effect of creating\n   bindings on NAT devices between the client\
    \ and the STUN servers.\n   Experience has shown that many NAT devices have upper\
    \ limits on the\n   rate at which they will create new bindings.  Experiments\
    \ have shown\n   that once every 20 ms is well supported, but not much lower than\n\
    \   that.  This is why Ta has a lower bound of 20 ms.  Furthermore,\n   transmission\
    \ of these packets on the network makes use of bandwidth\n   and needs to be rate\
    \ limited by the agent.  Deployments based on\n   earlier draft versions of this\
    \ document tended to overload rate-\n   constrained access links and perform poorly\
    \ overall, in addition to\n   negatively impacting the network.  As a consequence,\
    \ the pacing\n   ensures that the NAT device does not get overloaded and that\
    \ traffic\n   is kept at a reasonable rate.\n   The definition of a \"reasonable\"\
    \ rate is that STUN should not use\n   more bandwidth than the RTP itself will\
    \ use, once media starts\n   flowing.  The formula for Ta is designed so that,\
    \ if a STUN packet\n   were sent every Ta seconds, it would consume the same amount\
    \ of\n   bandwidth as RTP packets, summed across all media streams.  Of\n   course,\
    \ STUN has retransmits, and the desire is to pace those as\n   well.  For this\
    \ reason, RTO is set such that the first retransmit on\n   the first transaction\
    \ happens just as the first STUN request on the\n   last transaction occurs. \
    \ Pictorially:\n              First Packets              Retransmits\n       \
    \             |                        |\n                    |              \
    \          |\n             -------+------           -------+------\n         \
    \   /               \\        /               \\\n           /               \
    \  \\      /                 \\\n           +--+    +--+    +--+    +--+    +--+\
    \    +--+\n           |A1|    |B1|    |C1|    |A2|    |B2|    |C2|\n         \
    \  +--+    +--+    +--+    +--+    +--+    +--+\n        ---+-------+-------+-------+-------+-------+------------\
    \ Time\n           0       Ta      2Ta     3Ta     4Ta     5Ta\n   In this picture,\
    \ there are three transactions that will be sent (for\n   example, in the case\
    \ of candidate gathering, there are three host\n   candidate/STUN server pairs).\
    \  These are transactions A, B, and C.\n   The retransmit timer is set so that\
    \ the first retransmission on the\n   first transaction (packet A2) is sent at\
    \ time 3Ta.\n   Subsequent retransmits after the first will occur even less\n\
    \   frequently than Ta milliseconds apart, since STUN uses an exponential\n  \
    \ back-off on its retransmissions.\n"
- title: B.2.  Candidates with Multiple Bases
  contents:
  - "B.2.  Candidates with Multiple Bases\n   Section 4.1.3 talks about eliminating\
    \ candidates that have the same\n   transport address and base.  However, candidates\
    \ with the same\n   transport addresses but different bases are not redundant.\
    \  When can\n   an agent have two candidates that have the same IP address and\
    \ port,\n   but different bases?  Consider the topology of Figure 10:\n      \
    \    +----------+\n          | STUN Srvr|\n          +----------+\n          \
    \     |\n               |\n             -----\n           //     \\\\\n      \
    \    |         |\n         |  B:net10  |\n          |         |\n           \\\
    \\     //\n             -----\n               |\n               |\n          +----------+\n\
    \          |   NAT    |\n          +----------+\n               |\n          \
    \     |\n             -----\n           //     \\\\\n          |    A    |\n \
    \        |192.168/16 |\n          |         |\n           \\\\     //\n      \
    \       -----\n               |\n               |\n               |192.168.1.100\
    \      -----\n          +----------+           //     \\\\             +----------+\n\
    \          |          |          |         |            |          |\n       \
    \   | Offerer  |---------|  C:net10  |-----------| Answerer |\n          |   \
    \       |10.0.1.100|         | 10.0.1.101 |          |\n          +----------+\
    \           \\\\     //             +----------+\n                           \
    \        -----\n           Figure 10: Identical Candidates with Different Bases\n\
    \   In this case, the offerer is multihomed.  It has one IP address,\n   10.0.1.100,\
    \ on network C, which is a net 10 private network.  The\n   answerer is on this\
    \ same network.  The offerer is also connected to\n   network A, which is 192.168/16.\
    \  The offerer has an IP address of\n   192.168.1.100 on this network.  There\
    \ is a NAT on this network,\n   natting into network B, which is another net 10\
    \ private network, but\n   not connected to network C.  There is a STUN server\
    \ on network B.\n   The offerer obtains a host candidate on its IP address on\
    \ network C\n   (10.0.1.100:2498) and a host candidate on its IP address on network\
    \ A\n   (192.168.1.100:3344).  It performs a STUN query to its configured\n  \
    \ STUN server from 192.168.1.100:3344.  This query passes through the\n   NAT,\
    \ which happens to assign the binding 10.0.1.100:2498.  The STUN\n   server reflects\
    \ this in the STUN Binding response.  Now, the offerer\n   has obtained a server\
    \ reflexive candidate with a transport address\n   that is identical to a host\
    \ candidate (10.0.1.100:2498).  However,\n   the server reflexive candidate has\
    \ a base of 192.168.1.100:3344, and\n   the host candidate has a base of 10.0.1.100:2498.\n"
- title: B.3.  Purpose of the <rel-addr> and <rel-port> Attributes
  contents:
  - "B.3.  Purpose of the <rel-addr> and <rel-port> Attributes\n   The candidate attribute\
    \ contains two values that are not used at all\n   by ICE itself -- <rel-addr>\
    \ and <rel-port>.  Why is it present?\n   There are two motivations for its inclusion.\
    \  The first is\n   diagnostic.  It is very useful to know the relationship between\
    \ the\n   different types of candidates.  By including it, an agent can know\n\
    \   which relayed candidate is associated with which reflexive candidate,\n  \
    \ which in turn is associated with a specific host candidate.  When\n   checks\
    \ for one candidate succeed and not for others, this provides\n   useful diagnostics\
    \ on what is going on in the network.\n   The second reason has to do with off-path\
    \ Quality of Service (QoS)\n   mechanisms.  When ICE is used in environments such\
    \ as PacketCable\n   2.0, proxies will, in addition to performing normal SIP operations,\n\
    \   inspect the SDP in SIP messages, and extract the IP address and port\n   for\
    \ media traffic.  They can then interact, through policy servers,\n   with access\
    \ routers in the network, to establish guaranteed QoS for\n   the media flows.\
    \  This QoS is provided by classifying the RTP traffic\n   based on 5-tuple, and\
    \ then providing it a guaranteed rate, or marking\n   its Diffserv codepoints\
    \ appropriately.  When a residential NAT is\n   present, and a relayed candidate\
    \ gets selected for media, this\n   relayed candidate will be a transport address\
    \ on an actual TURN\n   server.  That address says nothing about the actual transport\
    \ address\n   in the access router that would be used to classify packets for\
    \ QoS\n   treatment.  Rather, the server reflexive candidate towards the TURN\n\
    \   server is needed.  By carrying the translation in the SDP, the proxy\n   can\
    \ use that transport address to request QoS from the access router.\n"
- title: B.4.  Importance of the STUN Username
  contents:
  - "B.4.  Importance of the STUN Username\n   ICE requires the usage of message integrity\
    \ with STUN using its\n   short-term credential functionality.  The actual short-term\n\
    \   credential is formed by exchanging username fragments in the SDP\n   offer/answer\
    \ exchange.  The need for this mechanism goes beyond just\n   security; it is\
    \ actually required for correct operation of ICE in the\n   first place.\n   Consider\
    \ agents L, R, and Z.  L and R are within private enterprise\n   1, which is using\
    \ 10.0.0.0/8.  Z is within private enterprise 2,\n   which is also using 10.0.0.0/8.\
    \  As it turns out, R and Z both have\n   IP address 10.0.1.1.  L sends an offer\
    \ to Z.  Z, in its answer,\n   provides L with its host candidates.  In this case,\
    \ those candidates\n   are 10.0.1.1:8866 and 10.0.1.1:8877.  As it turns out,\
    \ R is in a\n   session at that same time, and is also using 10.0.1.1:8866 and\n\
    \   10.0.1.1:8877 as host candidates.  This means that R is prepared to\n   accept\
    \ STUN messages on those ports, just as Z is.  L will send a\n   STUN request\
    \ to 10.0.1.1:8866 and another to 10.0.1.1:8877.  However,\n   these do not go\
    \ to Z as expected.  Instead, they go to R!  If R just\n   replied to them, L\
    \ would believe it has connectivity to Z, when in\n   fact it has connectivity\
    \ to a completely different user, R.  To fix\n   this, the STUN short-term credential\
    \ mechanisms are used.  The\n   username fragments are sufficiently random that\
    \ it is highly unlikely\n   that R would be using the same values as Z.  Consequently,\
    \ R would\n   reject the STUN request since the credentials were invalid.  In\n\
    \   essence, the STUN username fragments provide a form of transient host\n  \
    \ identifiers, bound to a particular offer/answer session.\n   An unfortunate\
    \ consequence of the non-uniqueness of IP addresses is\n   that, in the above\
    \ example, R might not even be an ICE agent.  It\n   could be any host, and the\
    \ port to which the STUN packet is directed\n   could be any ephemeral port on\
    \ that host.  If there is an application\n   listening on this socket for packets,\
    \ and it is not prepared to\n   handle malformed packets for whatever protocol\
    \ is in use, the\n   operation of that application could be affected.  Fortunately,\
    \ since\n   the ports exchanged in SDP are ephemeral and usually drawn from the\n\
    \   dynamic or registered range, the odds are good that the port is not\n   used\
    \ to run a server on host R, but rather is the agent side of some\n   protocol.\
    \  This decreases the probability of hitting an allocated\n   port, due to the\
    \ transient nature of port usage in this range.\n   However, the possibility of\
    \ a problem does exist, and network\n   deployers should be prepared for it. \
    \ Note that this is not a problem\n   specific to ICE; stray packets can arrive\
    \ at a port at any time for\n   any type of protocol, especially ones on the public\
    \ Internet.  As\n   such, this requirement is just restating a general design\
    \ guideline\n   for Internet applications -- be prepared for unknown packets on\
    \ any\n   port.\n"
- title: B.5.  The Candidate Pair Priority Formula
  contents:
  - "B.5.  The Candidate Pair Priority Formula\n   The priority for a candidate pair\
    \ has an odd form.  It is:\n      pair priority = 2^32*MIN(G,D) + 2*MAX(G,D) +\
    \ (G>D?1:0)\n   Why is this?  When the candidate pairs are sorted based on this\n\
    \   value, the resulting sorting has the MAX/MIN property.  This means\n   that\
    \ the pairs are first sorted based on decreasing value of the\n   minimum of the\
    \ two priorities.  For pairs that have the same value of\n   the minimum priority,\
    \ the maximum priority is used to sort amongst\n   them.  If the max and the min\
    \ priorities are the same, the\n   controlling agent's priority is used as the\
    \ tie-breaker in the last\n   part of the expression.  The factor of 2*32 is used\
    \ since the\n   priority of a single candidate is always less than 2*32, resulting\
    \ in\n   the pair priority being a \"concatenation\" of the two component\n  \
    \ priorities.  This creates the MAX/MIN sorting.  MAX/MIN ensures that,\n   for\
    \ a particular agent, a lower-priority candidate is never used\n   until all higher-priority\
    \ candidates have been tried.\n"
- title: B.6.  The remote-candidates Attribute
  contents:
  - "B.6.  The remote-candidates Attribute\n   The a=remote-candidates attribute exists\
    \ to eliminate a race\n   condition between the updated offer and the response\
    \ to the STUN\n   Binding request that moved a candidate into the Valid list.\
    \  This\n   race condition is shown in Figure 11.  On receipt of message 4, agent\n\
    \   L adds a candidate pair to the valid list.  If there was only a\n   single\
    \ media stream with a single component, agent L could now send\n   an updated\
    \ offer.  However, the check from agent R has not yet\n   generated a response,\
    \ and agent R receives the updated offer (message\n   7) before getting the response\
    \ (message 9).  Thus, it does not yet\n   know that this particular pair is valid.\
    \  To eliminate this\n   condition, the actual candidates at R that were selected\
    \ by the\n   offerer (the remote candidates) are included in the offer itself,\
    \ and\n   the answerer delays its answer until those pairs validate.\n       \
    \   Agent A               Network               Agent B\n             |(1) Offer\
    \            |                     |\n             |------------------------------------------>|\n\
    \             |(2) Answer           |                     |\n             |<------------------------------------------|\n\
    \             |(3) STUN Req.        |                     |\n             |------------------------------------------>|\n\
    \             |(4) STUN Res.        |                     |\n             |<------------------------------------------|\n\
    \             |(5) STUN Req.        |                     |\n             |<------------------------------------------|\n\
    \             |(6) STUN Res.        |                     |\n             |-------------------->|\
    \                     |\n             |                     |Lost            \
    \     |\n             |(7) Offer            |                     |\n        \
    \     |------------------------------------------>|\n             |(8) STUN Req.\
    \        |                     |\n             |<------------------------------------------|\n\
    \             |(9) STUN Res.        |                     |\n             |------------------------------------------>|\n\
    \             |(10) Answer          |                     |\n             |<------------------------------------------|\n\
    \                      Figure 11: Race Condition Flow\n"
- title: B.7.  Why Are Keepalives Needed?
  contents:
  - "B.7.  Why Are Keepalives Needed?\n   Once media begins flowing on a candidate\
    \ pair, it is still necessary\n   to keep the bindings alive at intermediate NATs\
    \ for the duration of\n   the session.  Normally, the media stream packets themselves\
    \ (e.g.,\n   RTP) meet this objective.  However, several cases merit further\n\
    \   discussion.  Firstly, in some RTP usages, such as SIP, the media\n   streams\
    \ can be \"put on hold\".  This is accomplished by using the SDP\n   \"sendonly\"\
    \ or \"inactive\" attributes, as defined in RFC 3264\n   [RFC3264].  RFC 3264\
    \ directs implementations to cease transmission of\n   media in these cases. \
    \ However, doing so may cause NAT bindings to\n   timeout, and media won't be\
    \ able to come off hold.\n   Secondly, some RTP payload formats, such as the payload\
    \ format for\n   text conversation [RFC4103], may send packets so infrequently\
    \ that\n   the interval exceeds the NAT binding timeouts.\n   Thirdly, if silence\
    \ suppression is in use, long periods of silence\n   may cause media transmission\
    \ to cease sufficiently long for NAT\n   bindings to time out.\n   For these reasons,\
    \ the media packets themselves cannot be relied\n   upon.  ICE defines a simple\
    \ periodic keepalive utilizing STUN Binding\n   indications.  This makes its bandwidth\
    \ requirements highly\n   predictable, and thus amenable to QoS reservations.\n"
- title: B.8.  Why Prefer Peer Reflexive Candidates?
  contents:
  - "B.8.  Why Prefer Peer Reflexive Candidates?\n   Section 4.1.2 describes procedures\
    \ for computing the priority of\n   candidate based on its type and local preferences.\
    \  That section\n   requires that the type preference for peer reflexive candidates\n\
    \   always be higher than server reflexive.  Why is that?  The reason has\n  \
    \ to do with the security considerations in Section 18.  It is much\n   easier\
    \ for an attacker to cause an agent to use a false server\n   reflexive candidate\
    \ than it is for an attacker to cause an agent to\n   use a false peer reflexive\
    \ candidate.  Consequently, attacks against\n   address gathering with Binding\
    \ requests are thwarted by ICE by\n   preferring the peer reflexive candidates.\n"
- title: B.9.  Why Send an Updated Offer?
  contents:
  - "B.9.  Why Send an Updated Offer?\n   Section 11.1 describes rules for sending\
    \ media.  Both agents can send\n   media once ICE checks complete, without waiting\
    \ for an updated offer.\n   Indeed, the only purpose of the updated offer is to\
    \ \"correct\" the SDP\n   so that the default destination for media matches where\
    \ media is\n   being sent based on ICE procedures (which will be the highest-\n\
    \   priority nominated candidate pair).\n   This begs the question -- why is the\
    \ updated offer/answer exchange\n   needed at all?  Indeed, in a pure offer/answer\
    \ environment, it would\n   not be.  The offerer and answerer will agree on the\
    \ candidates to use\n   through ICE, and then can begin using them.  As far as\
    \ the agents\n   themselves are concerned, the updated offer/answer provides no\
    \ new\n   information.  However, in practice, numerous components along the\n\
    \   signaling path look at the SDP information.  These include entities\n   performing\
    \ off-path QoS reservations, NAT traversal components such\n   as ALGs and Session\
    \ Border Controllers (SBCs), and diagnostic tools\n   that passively monitor the\
    \ network.  For these tools to continue to\n   function without change, the core\
    \ property of SDP -- that the\n   existing, pre-ICE definitions of the addresses\
    \ used for media -- the\n   m and c lines and the rtcp attribute -- must be retained.\
    \  For this\n   reason, an updated offer must be sent.\n"
- title: B.10.  Why Are Binding Indications Used for Keepalives?
  contents:
  - "B.10.  Why Are Binding Indications Used for Keepalives?\n   Media keepalives\
    \ are described in Section 10.  These keepalives make\n   use of STUN when both\
    \ endpoints are ICE capable.  However, rather\n   than using a Binding request\
    \ transaction (which generates a\n   response), the keepalives use an Indication.\
    \  Why is that?\n   The primary reason has to do with network QoS mechanisms.\
    \  Once media\n   begins flowing, network elements will assume that the media\
    \ stream\n   has a fairly regular structure, making use of periodic packets at\n\
    \   fixed intervals, with the possibility of jitter.  If an agent is\n   sending\
    \ media packets, and then receives a Binding request, it would\n   need to generate\
    \ a response packet along with its media packets.\n   This will increase the actual\
    \ bandwidth requirements for the 5-tuple\n   carrying the media packets, and introduce\
    \ jitter in the delivery of\n   those packets.  Analysis has shown that this is\
    \ a concern in certain\n   layer 2 access networks that use fairly tight packet\
    \ schedulers for\n   media.\n   Additionally, using a Binding Indication allows\
    \ integrity to be\n   disabled, allowing for better performance.  This is useful\
    \ for large-\n   scale endpoints, such as PSTN gateways and SBCs.\n"
- title: B.11.  Why Is the Conflict Resolution Mechanism Needed?
  contents:
  - "B.11.  Why Is the Conflict Resolution Mechanism Needed?\n   When ICE runs between\
    \ two peers, one agent acts as controlled, and\n   the other as controlling. \
    \ Rules are defined as a function of\n   implementation type and offerer/answerer\
    \ to determine who is\n   controlling and who is controlled.  However, the specification\n\
    \   mentions that, in some cases, both sides might believe they are\n   controlling,\
    \ or both sides might believe they are controlled.  How\n   can this happen?\n\
    \   The condition when both agents believe they are controlled shows up\n   in\
    \ third party call control cases.  Consider the following flow:\n            \
    \ A         Controller          B\n             |(1) INV()     |             \
    \ |\n             |<-------------|              |\n             |(2) 200(SDP1)\
    \ |              |\n             |------------->|              |\n           \
    \  |              |(3) INV()     |\n             |              |------------->|\n\
    \             |              |(4) 200(SDP2) |\n             |              |<-------------|\n\
    \             |(5) ACK(SDP2) |              |\n             |<-------------| \
    \             |\n             |              |(6) ACK(SDP1) |\n             |\
    \              |------------->|\n                       Figure 12: Role Conflict\
    \ Flow\n   This flow is a variation on flow III of RFC 3725 [RFC3725].  In fact,\n\
    \   it works better than flow III since it produces fewer messages.  In\n   this\
    \ flow, the controller sends an offerless INVITE to agent A, which\n   responds\
    \ with its offer, SDP1.  The agent then sends an offerless\n   INVITE to agent\
    \ B, which it responds to with its offer, SDP2.  The\n   controller then uses\
    \ the offer from each agent to generate the\n   answers.  When this flow is used,\
    \ ICE will run between agents A and\n   B, but both will believe they are in the\
    \ controlling role.  With the\n   role conflict resolution procedures, this flow\
    \ will function properly\n   when ICE is used.\n   At this time, there are no\
    \ documented flows that can result in the\n   case where both agents believe they\
    \ are controlled.  However, the\n   conflict resolution procedures allow for this\
    \ case, should a flow\n   arise that would fit into this category.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Jonathan Rosenberg\n   jdrosen.net\n   Monmouth, NJ\n  \
    \ US\n   Email: jdrosen@jdrosen.net\n   URI:   http://www.jdrosen.net\n"
