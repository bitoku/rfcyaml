- contents:
  - '        Extensible Messaging and Presence Protocol (XMPP): Core

    '
  title: __initial_text__
- contents:
  - "Abstract\n   The Extensible Messaging and Presence Protocol (XMPP) is an\n   application
    profile of the Extensible Markup Language (XML) that\n   enables the near-real-time
    exchange of structured yet extensible data\n   between any two or more network
    entities.  This document defines\n   XMPP's core protocol methods: setup and teardown
    of XML streams,\n   channel encryption, authentication, error handling, and communication\n
    \  primitives for messaging, network availability (\"presence\"), and\n   request-response
    interactions.  This document obsoletes RFC 3920.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6120.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   8\n     1.1.   Overview . . . . . . . . . . . . . . . . . . . . .
    . . .   8\n     1.2.   History  . . . . . . . . . . . . . . . . . . . . . . .
    .   8\n     1.3.   Functional Summary . . . . . . . . . . . . . . . . . . .   9\n
    \    1.4.   Terminology  . . . . . . . . . . . . . . . . . . . . . .  11\n   2.
    \ Architecture  . . . . . . . . . . . . . . . . . . . . . . . .  13\n     2.1.
    \  Global Addresses . . . . . . . . . . . . . . . . . . . .  13\n     2.2.   Presence
    . . . . . . . . . . . . . . . . . . . . . . . .  14\n     2.3.   Persistent Streams
    . . . . . . . . . . . . . . . . . . .  14\n     2.4.   Structured Data  . . .
    . . . . . . . . . . . . . . . . .  14\n     2.5.   Distributed Network of Clients
    and Servers . . . . . . .  14\n   3.  TCP Binding . . . . . . . . . . . . . .
    . . . . . . . . . . .  16\n     3.1.   Scope  . . . . . . . . . . . . . . . .
    . . . . . . . . .  16\n     3.2.   Resolution of Fully Qualified Domain Names
    . . . . . . .  17\n       3.2.1.   Preferred Process: SRV Lookup  . . . . . .
    . . . . .  17\n       3.2.2.   Fallback Processes . . . . . . . . . . . . . .
    . . .  18\n       3.2.3.   When Not to Use SRV  . . . . . . . . . . . . . . .
    .  18\n       3.2.4.   Use of SRV Records with Add-On Services  . . . . . .  19\n
    \    3.3.   Reconnection . . . . . . . . . . . . . . . . . . . . . .  19\n     3.4.
    \  Reliability  . . . . . . . . . . . . . . . . . . . . . .  20\n   4.  XML Streams
    . . . . . . . . . . . . . . . . . . . . . . . . .  20\n     4.1.   Stream Fundamentals
    \ . . . . . . . . . . . . . . . . . .  20\n     4.2.   Opening a Stream . . .
    . . . . . . . . . . . . . . . . .  23\n     4.3.   Stream Negotiation . . . .
    . . . . . . . . . . . . . . .  24\n       4.3.1.   Basic Concepts . . . . . .
    . . . . . . . . . . . . .  24\n       4.3.2.   Stream Features Format . . . .
    . . . . . . . . . . .  25\n       4.3.3.   Restarts . . . . . . . . . . . . .
    . . . . . . . . .  27\n       4.3.4.   Resending Features . . . . . . . . . .
    . . . . . . .  27\n       4.3.5.   Completion of Stream Negotiation . . . . .
    . . . . .  27\n       4.3.6.   Determination of Addresses . . . . . . . . . .
    . . .  28\n       4.3.7.   Flow Chart . . . . . . . . . . . . . . . . . . . .
    .  29\n     4.4.   Closing a Stream . . . . . . . . . . . . . . . . . . . .  31\n
    \    4.5.   Directionality . . . . . . . . . . . . . . . . . . . . .  32\n     4.6.
    \  Handling of Silent Peers . . . . . . . . . . . . . . . .  33\n       4.6.1.
    \  Dead Connection  . . . . . . . . . . . . . . . . . .  34\n       4.6.2.   Broken
    Stream  . . . . . . . . . . . . . . . . . . .  34\n       4.6.3.   Idle Peer  .
    . . . . . . . . . . . . . . . . . . . .  34\n       4.6.4.   Use of Checking Methods
    \ . . . . . . . . . . . . . .  35\n     4.7.   Stream Attributes  . . . . . .
    . . . . . . . . . . . . .  35\n       4.7.1.   from . . . . . . . . . . . . .
    . . . . . . . . . . .  35\n       4.7.2.   to . . . . . . . . . . . . . . . .
    . . . . . . . . .  37\n       4.7.3.   id . . . . . . . . . . . . . . . . . .
    . . . . . . .  38\n       4.7.4.   xml:lang . . . . . . . . . . . . . . . . .
    . . . . .  39\n       4.7.5.   version  . . . . . . . . . . . . . . . . . . .
    . . .  41\n       4.7.6.   Summary of Stream Attributes . . . . . . . . . . .
    .  43\n     4.8.   XML Namespaces . . . . . . . . . . . . . . . . . . . . .  43\n
    \      4.8.1.   Stream Namespace . . . . . . . . . . . . . . . . . .  43\n       4.8.2.
    \  Content Namespace  . . . . . . . . . . . . . . . . .  43\n       4.8.3.   XMPP
    Content Namespaces  . . . . . . . . . . . . . .  44\n       4.8.4.   Other Namespaces
    . . . . . . . . . . . . . . . . . .  46\n       4.8.5.   Namespace Declarations
    and Prefixes  . . . . . . . .  47\n     4.9.   Stream Errors  . . . . . . . .
    . . . . . . . . . . . . .  48\n       4.9.1.   Rules  . . . . . . . . . . . .
    . . . . . . . . . . .  48\n         4.9.1.1.  Stream Errors Are Unrecoverable
    . . . . . . . . .  48\n         4.9.1.2.  Stream Errors Can Occur During Setup
    \ . . . . . .  49\n         4.9.1.3.  Stream Errors When the Host Is Unspecified
    or\n                   Unknown . . . . . . . . . . . . . . . . . . . . .  50\n
    \        4.9.1.4.  Where Stream Errors Are Sent  . . . . . . . . . .  50\n       4.9.2.
    \  Syntax . . . . . . . . . . . . . . . . . . . . . . .  51\n       4.9.3.   Defined
    Stream Error Conditions  . . . . . . . . . .  52\n         4.9.3.1.  bad-format
    \ . . . . . . . . . . . . . . . . . . .  52\n         4.9.3.2.  bad-namespace-prefix
    \ . . . . . . . . . . . . . .  52\n         4.9.3.3.  conflict  . . . . . . .
    . . . . . . . . . . . . .  53\n         4.9.3.4.  connection-timeout  . . . .
    . . . . . . . . . . .  54\n         4.9.3.5.  host-gone . . . . . . . . . . .
    . . . . . . . . .  54\n         4.9.3.6.  host-unknown  . . . . . . . . . . .
    . . . . . . .  55\n         4.9.3.7.  improper-addressing . . . . . . . . . .
    . . . . .  56\n         4.9.3.8.  internal-server-error . . . . . . . . . . .
    . . .  56\n         4.9.3.9.  invalid-from  . . . . . . . . . . . . . . . . .
    .  56\n         4.9.3.10. invalid-namespace . . . . . . . . . . . . . . . .  57\n
    \        4.9.3.11. invalid-xml . . . . . . . . . . . . . . . . . . .  57\n         4.9.3.12.
    not-authorized  . . . . . . . . . . . . . . . . .  58\n         4.9.3.13. not-well-formed
    . . . . . . . . . . . . . . . . .  59\n         4.9.3.14. policy-violation  .
    . . . . . . . . . . . . . . .  59\n         4.9.3.15. remote-connection-failed
    \ . . . . . . . . . . . .  60\n         4.9.3.16. reset . . . . . . . . . . .
    . . . . . . . . . . .  60\n         4.9.3.17. resource-constraint . . . . . .
    . . . . . . . . .  61\n         4.9.3.18. restricted-xml  . . . . . . . . . .
    . . . . . . .  61\n         4.9.3.19. see-other-host  . . . . . . . . . . . .
    . . . . .  62\n         4.9.3.20. system-shutdown . . . . . . . . . . . . . .
    . . .  64\n         4.9.3.21. undefined-condition . . . . . . . . . . . . . .
    .  64\n         4.9.3.22. unsupported-encoding  . . . . . . . . . . . . . .  64\n
    \        4.9.3.23. unsupported-feature . . . . . . . . . . . . . . .  65\n         4.9.3.24.
    unsupported-stanza-type . . . . . . . . . . . . .  65\n         4.9.3.25. unsupported-version
    . . . . . . . . . . . . . . .  66\n       4.9.4.   Application-Specific Conditions
    \ . . . . . . . . . .  67\n     4.10.  Simplified Stream Examples . . . . . .
    . . . . . . . . .  68\n   5.  STARTTLS Negotiation  . . . . . . . . . . . . .
    . . . . . . .  69\n     5.1.   Fundamentals . . . . . . . . . . . . . . . . .
    . . . . .  69\n     5.2.   Support  . . . . . . . . . . . . . . . . . . . . .
    . . .  70\n     5.3.   Stream Negotiation Rules . . . . . . . . . . . . . . .
    .  70\n       5.3.1.   Mandatory-to-Negotiate . . . . . . . . . . . . . . .  70\n
    \      5.3.2.   Restart  . . . . . . . . . . . . . . . . . . . . . .  70\n       5.3.3.
    \  Data Formatting  . . . . . . . . . . . . . . . . . .  70\n       5.3.4.   Order
    of TLS and SASL Negotiations . . . . . . . . .  71\n       5.3.5.   TLS Renegotiation
    \ . . . . . . . . . . . . . . . . .  71\n       5.3.6.   TLS Extensions . . .
    . . . . . . . . . . . . . . . .  72\n     5.4.   Process  . . . . . . . . . .
    . . . . . . . . . . . . . .  72\n       5.4.1.   Exchange of Stream Headers and
    Stream Features . . .  72\n       5.4.2.   Initiation of STARTTLS Negotiation
    . . . . . . . . .  73\n         5.4.2.1.  STARTTLS Command  . . . . . . . . .
    . . . . . . .  73\n         5.4.2.2.  Failure Case  . . . . . . . . . . . . .
    . . . . .  73\n         5.4.2.3.  Proceed Case  . . . . . . . . . . . . . . .
    . . .  74\n       5.4.3.   TLS Negotiation  . . . . . . . . . . . . . . . . .
    .  74\n         5.4.3.1.  Rules . . . . . . . . . . . . . . . . . . . . . .  74\n
    \        5.4.3.2.  TLS Failure . . . . . . . . . . . . . . . . . . .  75\n         5.4.3.3.
    \ TLS Success . . . . . . . . . . . . . . . . . . .  76\n   6.  SASL Negotiation
    \ . . . . . . . . . . . . . . . . . . . . . .  77\n     6.1.   Fundamentals .
    . . . . . . . . . . . . . . . . . . . . .  77\n     6.2.   Support  . . . . .
    . . . . . . . . . . . . . . . . . . .  77\n     6.3.   Stream Negotiation Rules
    . . . . . . . . . . . . . . . .  77\n       6.3.1.   Mandatory-to-Negotiate .
    . . . . . . . . . . . . . .  77\n       6.3.2.   Restart  . . . . . . . . . .
    . . . . . . . . . . . .  78\n       6.3.3.   Mechanism Preferences  . . . . .
    . . . . . . . . . .  78\n       6.3.4.   Mechanism Offers . . . . . . . . . .
    . . . . . . . .  78\n       6.3.5.   Data Formatting  . . . . . . . . . . . .
    . . . . . .  79\n       6.3.6.   Security Layers  . . . . . . . . . . . . . .
    . . . .  80\n       6.3.7.   Simple User Name . . . . . . . . . . . . . . . .
    . .  80\n       6.3.8.   Authorization Identity . . . . . . . . . . . . . . .
    \ 80\n       6.3.9.   Realms . . . . . . . . . . . . . . . . . . . . . . .  81\n
    \      6.3.10.  Round Trips  . . . . . . . . . . . . . . . . . . . .  81\n     6.4.
    \  Process  . . . . . . . . . . . . . . . . . . . . . . . .  82\n       6.4.1.
    \  Exchange of Stream Headers and Stream Features . . .  82\n       6.4.2.   Initiation
    . . . . . . . . . . . . . . . . . . . . .  83\n       6.4.3.   Challenge-Response
    Sequence  . . . . . . . . . . . .  84\n       6.4.4.   Abort  . . . . . . . .
    . . . . . . . . . . . . . . .  84\n       6.4.5.   SASL Failure . . . . . . .
    . . . . . . . . . . . . .  85\n       6.4.6.   SASL Success . . . . . . . . .
    . . . . . . . . . . .  86\n     6.5.   SASL Errors  . . . . . . . . . . . . .
    . . . . . . . . .  87\n       6.5.1.   aborted  . . . . . . . . . . . . . . .
    . . . . . . .  88\n       6.5.2.   account-disabled . . . . . . . . . . . . .
    . . . . .  88\n       6.5.3.   credentials-expired  . . . . . . . . . . . . .
    . . .  88\n       6.5.4.   encryption-required  . . . . . . . . . . . . . . .
    .  89\n       6.5.5.   incorrect-encoding . . . . . . . . . . . . . . . . .  89\n
    \      6.5.6.   invalid-authzid  . . . . . . . . . . . . . . . . . .  89\n       6.5.7.
    \  invalid-mechanism  . . . . . . . . . . . . . . . . .  90\n       6.5.8.   malformed-request
    \ . . . . . . . . . . . . . . . . .  90\n       6.5.9.   mechanism-too-weak .
    . . . . . . . . . . . . . . . .  90\n       6.5.10.  not-authorized . . . . .
    . . . . . . . . . . . . . .  91\n       6.5.11.  temporary-auth-failure . . .
    . . . . . . . . . . . .  91\n     6.6.   SASL Definition  . . . . . . . . . .
    . . . . . . . . . .  91\n   7.  Resource Binding  . . . . . . . . . . . . . .
    . . . . . . . .  92\n     7.1.   Fundamentals . . . . . . . . . . . . . . . .
    . . . . . .  92\n     7.2.   Support  . . . . . . . . . . . . . . . . . . . .
    . . . .  93\n     7.3.   Stream Negotiation Rules . . . . . . . . . . . . . .
    . .  93\n       7.3.1.   Mandatory-to-Negotiate . . . . . . . . . . . . . . .
    \ 93\n       7.3.2.   Restart  . . . . . . . . . . . . . . . . . . . . . .  93\n
    \    7.4.   Advertising Support  . . . . . . . . . . . . . . . . . .  93\n     7.5.
    \  Generation of Resource Identifiers . . . . . . . . . . .  94\n     7.6.   Server-Generated
    Resource Identifier . . . . . . . . . .  94\n       7.6.1.   Success Case . .
    . . . . . . . . . . . . . . . . . .  94\n       7.6.2.   Error Cases  . . . .
    . . . . . . . . . . . . . . . .  95\n         7.6.2.1.  Resource Constraint .
    . . . . . . . . . . . . . .  95\n         7.6.2.2.  Not Allowed . . . . . . .
    . . . . . . . . . . . .  96\n     7.7.   Client-Submitted Resource Identifier
    . . . . . . . . . .  96\n       7.7.1.   Success Case . . . . . . . . . . . .
    . . . . . . . .  96\n       7.7.2.   Error Cases  . . . . . . . . . . . . . .
    . . . . . .  97\n         7.7.2.1.  Bad Request . . . . . . . . . . . . . . .
    . . . .  97\n         7.7.2.2.  Conflict  . . . . . . . . . . . . . . . . . .
    . .  97\n       7.7.3.   Retries  . . . . . . . . . . . . . . . . . . . . . .
    \ 99\n   8.  XML Stanzas . . . . . . . . . . . . . . . . . . . . . . . . .  99\n
    \    8.1.   Common Attributes  . . . . . . . . . . . . . . . . . . . 100\n       8.1.1.
    \  to . . . . . . . . . . . . . . . . . . . . . . . . . 100\n         8.1.1.1.
    \ Client-to-Server Streams  . . . . . . . . . . . . 100\n         8.1.1.2.  Server-to-Server
    Streams  . . . . . . . . . . . . 101\n       8.1.2.   from . . . . . . . . . .
    . . . . . . . . . . . . . . 101\n         8.1.2.1.  Client-to-Server Streams  .
    . . . . . . . . . . . 101\n         8.1.2.2.  Server-to-Server Streams  . . .
    . . . . . . . . . 102\n       8.1.3.   id . . . . . . . . . . . . . . . . . .
    . . . . . . . 103\n       8.1.4.   type . . . . . . . . . . . . . . . . . . .
    . . . . . 103\n       8.1.5.   xml:lang . . . . . . . . . . . . . . . . . . .
    . . . 103\n     8.2.   Basic Semantics  . . . . . . . . . . . . . . . . . . .
    . 105\n       8.2.1.   Message Semantics  . . . . . . . . . . . . . . . . . 105\n
    \      8.2.2.   Presence Semantics . . . . . . . . . . . . . . . . . 105\n       8.2.3.
    \  IQ Semantics . . . . . . . . . . . . . . . . . . . . 105\n     8.3.   Stanza
    Errors  . . . . . . . . . . . . . . . . . . . . . 107\n       8.3.1.   Rules  .
    . . . . . . . . . . . . . . . . . . . . . . 108\n       8.3.2.   Syntax . . .
    . . . . . . . . . . . . . . . . . . . . 109\n       8.3.3.   Defined Conditions
    . . . . . . . . . . . . . . . . . 110\n         8.3.3.1.  bad-request . . . .
    . . . . . . . . . . . . . . . 110\n         8.3.3.2.  conflict  . . . . . . .
    . . . . . . . . . . . . . 111\n         8.3.3.3.  feature-not-implemented . .
    . . . . . . . . . . . 111\n         8.3.3.4.  forbidden . . . . . . . . . . .
    . . . . . . . . . 112\n         8.3.3.5.  gone  . . . . . . . . . . . . . . .
    . . . . . . . 113\n         8.3.3.6.  internal-server-error . . . . . . . . .
    . . . . . 113\n         8.3.3.7.  item-not-found  . . . . . . . . . . . . . .
    . . . 114\n         8.3.3.8.  jid-malformed . . . . . . . . . . . . . . . . .
    . 114\n         8.3.3.9.  not-acceptable  . . . . . . . . . . . . . . . . . 115\n
    \        8.3.3.10. not-allowed . . . . . . . . . . . . . . . . . . . 116\n         8.3.3.11.
    not-authorized  . . . . . . . . . . . . . . . . . 116\n         8.3.3.12. policy-violation
    \ . . . . . . . . . . . . . . . . 117\n         8.3.3.13. recipient-unavailable
    . . . . . . . . . . . . . . 117\n         8.3.3.14. redirect  . . . . . . . .
    . . . . . . . . . . . . 118\n         8.3.3.15. registration-required . . . .
    . . . . . . . . . . 119\n         8.3.3.16. remote-server-not-found . . . . .
    . . . . . . . . 119\n         8.3.3.17. remote-server-timeout . . . . . . . .
    . . . . . . 120\n         8.3.3.18. resource-constraint . . . . . . . . . . .
    . . . . 121\n         8.3.3.19. service-unavailable . . . . . . . . . . . . .
    . . 121\n         8.3.3.20. subscription-required . . . . . . . . . . . . . .
    122\n         8.3.3.21. undefined-condition . . . . . . . . . . . . . . . 123\n
    \        8.3.3.22. unexpected-request  . . . . . . . . . . . . . . . 123\n       8.3.4.
    \  Application-Specific Conditions  . . . . . . . . . . 124\n     8.4.   Extended
    Content . . . . . . . . . . . . . . . . . . . . 125\n   9.  Detailed Examples
    . . . . . . . . . . . . . . . . . . . . . . 128\n     9.1.   Client-to-Server
    Examples  . . . . . . . . . . . . . . . 128\n       9.1.1.   TLS  . . . . . .
    . . . . . . . . . . . . . . . . . . 128\n       9.1.2.   SASL . . . . . . . .
    . . . . . . . . . . . . . . . . 130\n       9.1.3.   Resource Binding . . . .
    . . . . . . . . . . . . . . 132\n       9.1.4.   Stanza Exchange  . . . . . .
    . . . . . . . . . . . . 133\n       9.1.5.   Close  . . . . . . . . . . . . .
    . . . . . . . . . . 134\n     9.2.   Server-to-Server Examples  . . . . . . .
    . . . . . . . . 134\n       9.2.1.   TLS  . . . . . . . . . . . . . . . . . .
    . . . . . . 134\n       9.2.2.   SASL . . . . . . . . . . . . . . . . . . . .
    . . . . 136\n       9.2.3.   Stanza Exchange  . . . . . . . . . . . . . . . .
    . . 137\n       9.2.4.   Close  . . . . . . . . . . . . . . . . . . . . . . .
    137\n   10. Server Rules for Processing XML Stanzas . . . . . . . . . . . 138\n
    \    10.1.  In-Order Processing  . . . . . . . . . . . . . . . . . . 138\n     10.2.
    \ General Considerations . . . . . . . . . . . . . . . . . 140\n     10.3.  No
    'to' Address  . . . . . . . . . . . . . . . . . . . . 141\n       10.3.1.  Message
    \ . . . . . . . . . . . . . . . . . . . . . . 141\n       10.3.2.  Presence .
    . . . . . . . . . . . . . . . . . . . . . 141\n       10.3.3.  IQ . . . . . .
    . . . . . . . . . . . . . . . . . . . 141\n     10.4.  Remote Domain  . . . .
    . . . . . . . . . . . . . . . . . 142\n       10.4.1.  Existing Stream  . . .
    . . . . . . . . . . . . . . . 142\n       10.4.2.  No Existing Stream . . . .
    . . . . . . . . . . . . . 142\n       10.4.3.  Error Handling . . . . . . . .
    . . . . . . . . . . . 143\n     10.5.  Local Domain . . . . . . . . . . . . .
    . . . . . . . . . 143\n       10.5.1.  domainpart . . . . . . . . . . . . . .
    . . . . . . . 143\n       10.5.2.  domainpart/resourcepart  . . . . . . . . .
    . . . . . 143\n       10.5.3.  localpart@domainpart . . . . . . . . . . . . .
    . . . 143\n         10.5.3.1. No Such User  . . . . . . . . . . . . . . . . .
    . 144\n         10.5.3.2. User Exists . . . . . . . . . . . . . . . . . . . 144\n
    \      10.5.4.  localpart@domainpart/resourcepart  . . . . . . . . . 144\n   11.
    XML Usage . . . . . . . . . . . . . . . . . . . . . . . . . . 145\n     11.1.
    \ XML Restrictions . . . . . . . . . . . . . . . . . . . . 145\n     11.2.  XML
    Namespace Names and Prefixes . . . . . . . . . . . . 146\n     11.3.  Well-Formedness
    \ . . . . . . . . . . . . . . . . . . . . 146\n     11.4.  Validation . . . .
    . . . . . . . . . . . . . . . . . . . 147\n     11.5.  Inclusion of XML Declaration
    . . . . . . . . . . . . . . 147\n     11.6.  Character Encoding . . . . . . .
    . . . . . . . . . . . . 147\n     11.7.  Whitespace . . . . . . . . . . . . .
    . . . . . . . . . . 148\n     11.8.  XML Versions . . . . . . . . . . . . . .
    . . . . . . . . 148\n   12. Internationalization Considerations . . . . . . .
    . . . . . . 148\n   13. Security Considerations . . . . . . . . . . . . . . .
    . . . . 148\n     13.1.  Fundamentals . . . . . . . . . . . . . . . . . . . .
    . . 148\n     13.2.  Threat Model . . . . . . . . . . . . . . . . . . . . . .
    149\n     13.3.  Order of Layers  . . . . . . . . . . . . . . . . . . . . 150\n
    \    13.4.  Confidentiality and Integrity  . . . . . . . . . . . . . 150\n     13.5.
    \ Peer Entity Authentication . . . . . . . . . . . . . . . 151\n     13.6.  Strong
    Security  . . . . . . . . . . . . . . . . . . . . 151\n     13.7.  Certificates
    . . . . . . . . . . . . . . . . . . . . . . 152\n       13.7.1.  Certificate Generation
    . . . . . . . . . . . . . . . 152\n         13.7.1.1. General Considerations  .
    . . . . . . . . . . . . 152\n         13.7.1.2. Server Certificates . . . . .
    . . . . . . . . . . 153\n         13.7.1.3. Client Certificates . . . . . . .
    . . . . . . . . 156\n         13.7.1.4. XmppAddr Identifier Type  . . . . . .
    . . . . . . 156\n       13.7.2.  Certificate Validation . . . . . . . . . . .
    . . . . 157\n         13.7.2.1. Server Certificates . . . . . . . . . . . . .
    . . 158\n         13.7.2.2. Client Certificates . . . . . . . . . . . . . . .
    158\n         13.7.2.3. Checking of Certificates in Long-Lived Streams  . 160\n
    \        13.7.2.4. Use of Certificates in XMPP Extensions  . . . . . 160\n     13.8.
    \ Mandatory-to-Implement TLS and SASL Technologies . . . . 160\n       13.8.1.
    \ For Authentication Only  . . . . . . . . . . . . . . 161\n       13.8.2.  For
    Confidentiality Only . . . . . . . . . . . . . . 161\n       13.8.3.  For Confidentiality
    and Authentication with\n                Passwords  . . . . . . . . . . . . .
    . . . . . . . . 162\n       13.8.4.  For Confidentiality and Authentication without\n
    \               Passwords  . . . . . . . . . . . . . . . . . . . . . 163\n     13.9.
    \ Technology Reuse . . . . . . . . . . . . . . . . . . . . 163\n       13.9.1.
    \ Use of Base 64 in SASL . . . . . . . . . . . . . . . 163\n       13.9.2.  Use
    of DNS . . . . . . . . . . . . . . . . . . . . . 163\n       13.9.3.  Use of Hash
    Functions  . . . . . . . . . . . . . . . 164\n       13.9.4.  Use of SASL  . .
    . . . . . . . . . . . . . . . . . . 164\n       13.9.5.  Use of TLS . . . . .
    . . . . . . . . . . . . . . . . 165\n       13.9.6.  Use of UTF-8 . . . . . .
    . . . . . . . . . . . . . . 165\n       13.9.7.  Use of XML . . . . . . . . .
    . . . . . . . . . . . . 166\n     13.10. Information Leaks  . . . . . . . . .
    . . . . . . . . . . 166\n       13.10.1. IP Addresses . . . . . . . . . . . .
    . . . . . . . . 166\n       13.10.2. Presence Information . . . . . . . . . .
    . . . . . . 166\n     13.11. Directory Harvesting . . . . . . . . . . . . . .
    . . . . 166\n     13.12. Denial of Service  . . . . . . . . . . . . . . . . .
    . . 167\n     13.13. Firewalls  . . . . . . . . . . . . . . . . . . . . . . .
    169\n     13.14. Interdomain Federation . . . . . . . . . . . . . . . . . 169\n
    \    13.15. Non-Repudiation  . . . . . . . . . . . . . . . . . . . . 169\n   14.
    IANA Considerations . . . . . . . . . . . . . . . . . . . . . 170\n     14.1.
    \ XML Namespace Name for TLS Data  . . . . . . . . . . . . 170\n     14.2.  XML
    Namespace Name for SASL Data . . . . . . . . . . . . 170\n     14.3.  XML Namespace
    Name for Stream Errors . . . . . . . . . . 170\n     14.4.  XML Namespace Name
    for Resource Binding  . . . . . . . . 171\n     14.5.  XML Namespace Name for
    Stanza Errors . . . . . . . . . . 171\n     14.6.  GSSAPI Service Name  . . .
    . . . . . . . . . . . . . . . 171\n     14.7.  Port Numbers and Service Names
    . . . . . . . . . . . . . 171\n   15. Conformance Requirements  . . . . . . .
    . . . . . . . . . . . 172\n   16. References  . . . . . . . . . . . . . . . .
    . . . . . . . . . 181\n     16.1.  Normative References . . . . . . . . . . .
    . . . . . . . 181\n     16.2.  Informative References . . . . . . . . . . . .
    . . . . . 184\n   Appendix A.  XML Schemas  . . . . . . . . . . . . . . . . .
    . . . 190\n     A.1.   Stream Namespace . . . . . . . . . . . . . . . . . . .
    . 190\n     A.2.   Stream Error Namespace . . . . . . . . . . . . . . . . . 192\n
    \    A.3.   STARTTLS Namespace . . . . . . . . . . . . . . . . . . . 193\n     A.4.
    \  SASL Namespace . . . . . . . . . . . . . . . . . . . . . 194\n     A.5.   Client
    Namespace . . . . . . . . . . . . . . . . . . . . 196\n     A.6.   Server Namespace
    . . . . . . . . . . . . . . . . . . . . 201\n     A.7.   Resource Binding Namespace
    . . . . . . . . . . . . . . . 206\n     A.8.   Stanza Error Namespace . . . .
    . . . . . . . . . . . . . 206\n   Appendix B.  Contact Addresses  . . . . . .
    . . . . . . . . . . . 208\n   Appendix C.  Account Provisioning . . . . . . .
    . . . . . . . . . 208\n   Appendix D.  Differences from RFC 3920  . . . . . .
    . . . . . . . 208\n   Appendix E.  Acknowledgements . . . . . . . . . . . . .
    . . . . . 210\n"
  title: Table of Contents
- contents:
  - '1.  Introduction

    '
  - contents:
    - "1.1.  Overview\n   The Extensible Messaging and Presence Protocol (XMPP) is
      an\n   application profile of the Extensible Markup Language [XML] that\n   enables
      the near-real-time exchange of structured yet extensible data\n   between any
      two or more network entities.  This document defines\n   XMPP's core protocol
      methods: setup and teardown of XML streams,\n   channel encryption, authentication,
      error handling, and communication\n   primitives for messaging, network availability
      (\"presence\"), and\n   request-response interactions.\n"
    title: 1.1.  Overview
  - contents:
    - "1.2.  History\n   The basic syntax and semantics of XMPP were developed originally\n
      \  within the Jabber open-source community, mainly in 1999.  In late\n   2002,
      the XMPP Working Group was chartered with developing an\n   adaptation of the
      base Jabber protocol that would be suitable as an\n   IETF instant messaging
      (IM) and presence technology in accordance\n   with [IMP-REQS].  In October
      2004, [RFC3920] and [RFC3921] were\n   published, representing the most complete
      definition of XMPP at that\n   time.\n   Since 2004 the Internet community has
      gained extensive implementation\n   and deployment experience with XMPP, including
      formal\n   interoperability testing carried out under the auspices of the XMPP\n
      \  Standards Foundation (XSF).  This document incorporates comprehensive\n   feedback
      from software developers and XMPP service providers,\n   including a number
      of backward-compatible modifications summarized\n   under Appendix D.  As a
      result, this document reflects the rough\n   consensus of the Internet community
      regarding the core features of\n   XMPP 1.0, thus obsoleting RFC 3920.\n"
    title: 1.2.  History
  - contents:
    - "1.3.  Functional Summary\n   This non-normative section provides a developer-friendly,
      functional\n   summary of XMPP; refer to the sections that follow for a normative\n
      \  definition of XMPP.\n   The purpose of XMPP is to enable the exchange of
      relatively small\n   pieces of structured data (called \"XML stanzas\") over
      a network\n   between any two (or more) entities.  XMPP is typically implemented\n
      \  using a distributed client-server architecture, wherein a client\n   needs
      to connect to a server in order to gain access to the network\n   and thus be
      allowed to exchange XML stanzas with other entities\n   (which can be associated
      with other servers).  The process whereby a\n   client connects to a server,
      exchanges XML stanzas, and ends the\n   connection is:\n   1.  Determine the
      IP address and port at which to connect, typically\n       based on resolution
      of a fully qualified domain name\n       (Section 3.2)\n   2.  Open a Transmission
      Control Protocol [TCP] connection\n   3.  Open an XML stream over TCP (Section
      4.2)\n   4.  Preferably negotiate Transport Layer Security [TLS] for channel\n
      \      encryption (Section 5)\n   5.  Authenticate using a Simple Authentication
      and Security Layer\n       [SASL] mechanism (Section 6)\n   6.  Bind a resource
      to the stream (Section 7)\n   7.  Exchange an unbounded number of XML stanzas
      with other entities\n       on the network (Section 8)\n   8.  Close the XML
      stream (Section 4.4)\n   9.  Close the TCP connection\n   Within XMPP, one server
      can optionally connect to another server to\n   enable inter-domain or inter-server
      communication.  For this to\n   happen, the two servers need to negotiate a
      connection between\n   themselves and then exchange XML stanzas; the process
      for doing so\n   is:\n   1.  Determine the IP address and port at which to connect,
      typically\n       based on resolution of a fully qualified domain name\n       (Section
      3.2)\n   2.  Open a TCP connection\n   3.  Open an XML stream (Section 4.2)\n
      \  4.  Preferably negotiate TLS for channel encryption (Section 5)\n   5.  Authenticate
      using a Simple Authentication and Security Layer\n       [SASL] mechanism (Section
      6) *\n   6.  Exchange an unbounded number of XML stanzas both directly for the\n
      \      servers and indirectly on behalf of entities associated with each\n       server,
      such as connected clients (Section 8)\n   7.  Close the XML stream (Section
      4.4)\n   8.  Close the TCP connection\n      * Interoperability Note: At the
      time of writing, most deployed\n      servers still use the Server Dialback
      protocol [XEP-0220] to\n      provide weak identity verification instead of
      using SASL with PKIX\n      certificates to provide strong authentication, especially
      in cases\n      where SASL negotiation would not result in strong authentication\n
      \     anyway (e.g., because TLS negotiation was not mandated by the peer\n      server,
      or because the PKIX certificate presented by the peer\n      server during TLS
      negotiation is self-signed and has not been\n      previously accepted); for
      details, see [XEP-0220].  The solutions\n      specified in this document offer
      a significantly stronger level of\n      security (see also Section 13.6).\n
      \  This document specifies how clients connect to servers and specifies\n   the
      basic semantics of XML stanzas.  However, this document does not\n   define
      the \"payloads\" of the XML stanzas that might be exchanged once\n   a connection
      is successfully established; instead, those payloads are\n   defined by various
      XMPP extensions.  For example, [XMPP-IM] defines\n   extensions for basic instant
      messaging and presence functionality.\n   In addition, various specifications
      produced in the XSF's XEP series\n   [XEP-0001] define extensions for a wide
      range of applications.\n"
    title: 1.3.  Functional Summary
  - contents:
    - "1.4.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
      \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\",
      \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described
      in RFC\n   2119 [KEYWORDS].\n   Certain security-related terms are to be understood
      in the sense\n   defined in [SEC-TERMS]; such terms include, but are not limited
      to,\n   \"assurance\", \"attack\", \"authentication\", \"authorization\",\n
      \  \"certificate\", \"certification authority\", \"certification path\",\n   \"confidentiality\",
      \"credential\", \"downgrade\", \"encryption\", \"hash\n   value\", \"identity\",
      \"integrity\", \"signature\", \"self-signed\n   certificate\", \"sign\", \"spoof\",
      \"tamper\", \"trust\", \"trust anchor\",\n   \"validate\", and \"verify\".\n
      \  Certain terms related to certificates, domains, and application\n   service
      identity are to be understood in the sense defined in\n   [TLS-CERTS]; these
      include, but are not limited to, \"PKIX\n   certificate\", \"source domain\",
      \"derived domain\", and the identifier\n   types \"CN-ID\", \"DNS-ID\", and
      \"SRV-ID\".\n   Other security-related terms are to be understood in the sense\n
      \  defined in the referenced specifications (for example, \"denial of\n   service\"
      as described in [DOS] or \"end entity certificate\" as\n   described in [PKIX]).\n
      \  The term \"whitespace\" is used to refer to any character or characters\n
      \  matching the \"S\" production from [XML], i.e., one or more instances\n   of
      the SP, HTAB, CR, or LF rules defined in [ABNF].\n   The terms \"localpart\",
      \"domainpart\", and \"resourcepart\" are defined\n   in [XMPP-ADDR].\n   The
      term \"bare JID\" refers to an XMPP address of the form\n   <localpart@domainpart>
      (for an account at a server) or of the form\n   <domainpart> (for a server).\n
      \  The term \"full JID\" refers to an XMPP address of the form\n   <localpart@domainpart/resourcepart>
      (for a particular authorized\n   client or device associated with an account)
      or of the form\n   <domainpart/resourcepart> (for a particular resource or script\n
      \  associated with a server).\n   The term \"XML stream\" (also \"stream\")
      is defined under Section 4.1.\n   The term \"XML stanza\" (also \"stanza\")
      is defined under Section 4.1.\n   There are three kinds of stanzas: message,
      presence, and IQ (short\n   for \"Info/Query\").  These communication primitives
      are defined under\n   Sections 8.2.1, 8.2.2, and 8.2.3, respectively.\n   The
      term \"originating entity\" refers to the entity that first\n   generates a
      stanza that is sent over an XMPP network (e.g., a\n   connected client, an add-on
      service, or a server).  The term\n   \"generated stanza\" refers to the stanza
      so generated.\n   The term \"input stream\" designates an XML stream over which
      a server\n   receives data from a connected client or remote server, and the
      term\n   \"output stream\" designates an XML stream over which a server sends\n
      \  data to a connected client or remote server.  The following terms\n   designate
      some of the actions that a server can perform when\n   processing data received
      over an input stream:\n      route:  pass the data to a remote server for direct
      processing by\n         the remote server or eventual delivery to a client associated\n
      \        with the remote server\n      deliver:  pass the data to a connected
      client\n      ignore:  discard the data without acting upon it or returning
      an\n         error to the sender\n   When the term \"ignore\" is used with regard
      to client processing of\n   data it receives, the phrase \"without acting upon
      it\" explicitly\n   includes not presenting the data to a human user.\n   Following
      the \"XML Notation\" used in [IRI] to represent characters\n   that cannot be
      rendered in ASCII-only documents, some examples in\n   this document use the
      form \"&#x....\" as a notational device to\n   represent [UNICODE] characters
      (e.g., the string \"&#x0159;\" stands\n   for the Unicode character LATIN SMALL
      LETTER R WITH CARON); this form\n   is definitely not to be sent over the wire
      in XMPP systems.\n   Consistent with the convention used in [URI] to represent
      Uniform\n   Resource Identifiers, XMPP addresses in running text are enclosed\n
      \  between '<' and '>' (although natively they are not URIs).\n   In examples,
      lines have been wrapped for improved readability,\n   \"[...]\" means elision,
      and the following prepended strings are used\n   (these prepended strings are
      not to be sent over the wire):\n   o  C: = a client\n   o  E: = any XMPP entity\n
      \  o  I: = an initiating entity\n   o  P: = a peer server\n   o  R: = a receiving
      entity\n   o  S: = a server\n   o  S1: = server1\n   o  S2: = server2\n   Readers
      need to be aware that the examples are not exhaustive and\n   that, in examples
      for some protocol flows, the alternate steps shown\n   would not necessarily
      be triggered by the exact data sent in the\n   previous step; in all cases the
      protocol definitions specified in\n   this document or in normatively referenced
      documents rule over any\n   examples provided here.  All examples are fictional
      and the\n   information exchanged (e.g., usernames and passwords) does not\n
      \  represent any existing users or servers.\n"
    title: 1.4.  Terminology
  title: 1.  Introduction
- contents:
  - "2.  Architecture\n   XMPP provides a technology for the asynchronous, end-to-end
    exchange\n   of structured data by means of direct, persistent XML streams among
    a\n   distributed network of globally addressable, presence-aware clients\n   and
    servers.  Because this architectural style involves ubiquitous\n   knowledge of
    network availability and a conceptually unlimited number\n   of concurrent information
    transactions in the context of a given\n   client-to-server or server-to-server
    session, we label it\n   \"Availability for Concurrent Transactions\" (ACT) to
    distinguish it\n   from the \"Representational State Transfer\" [REST] architectural
    style\n   familiar from the World Wide Web.  Although the architecture of XMPP\n
    \  is similar in important ways to that of email (see [EMAIL-ARCH]), it\n   introduces
    several modifications to facilitate communication in close\n   to real time.  The
    salient features of this ACTive architectural\n   style are as follows.\n"
  - contents:
    - "2.1.  Global Addresses\n   As with email, XMPP uses globally unique addresses
      (based on the\n   Domain Name System) in order to route and deliver messages
      over the\n   network.  All XMPP entities are addressable on the network, most\n
      \  particularly clients and servers but also various additional services\n   that
      can be accessed by clients and servers.  In general, server\n   addresses are
      of the form <domainpart> (e.g., <im.example.com>),\n   accounts hosted at a
      server are of the form <localpart@domainpart>\n   (e.g., <juliet@im.example.com>,
      called a \"bare JID\"), and a\n   particular connected device or resource that
      is currently authorized\n   for interaction on behalf of an account is of the
      form\n   <localpart@domainpart/resourcepart> (e.g.,\n   <juliet@im.example.com/balcony>,
      called a \"full JID\").  For\n   historical reasons, XMPP addresses are often
      called Jabber IDs or\n   JIDs.  Because the formal specification of the XMPP
      address format\n   depends on internationalization technologies that are in
      flux at the\n   time of writing, the format is defined in [XMPP-ADDR] instead
      of this\n   document.  The terms \"localpart\", \"domainpart\", and \"resourcepart\"\n
      \  are defined more formally in [XMPP-ADDR].\n"
    title: 2.1.  Global Addresses
  - contents:
    - "2.2.  Presence\n   XMPP includes the ability for an entity to advertise its
      network\n   availability or \"presence\" to other entities.  In XMPP, this\n
      \  availability for communication is signaled end-to-end by means of a\n   dedicated
      communication primitive: the <presence/> stanza.  Although\n   knowledge of
      network availability is not strictly necessary for the\n   exchange of XMPP
      messages, it facilitates real-time interaction\n   because the originator of
      a message can know before initiating\n   communication that the intended recipient
      is online and available.\n   End-to-end presence is defined in [XMPP-IM].\n"
    title: 2.2.  Presence
  - contents:
    - "2.3.  Persistent Streams\n   Availability for communication is also built into
      each point-to-point\n   \"hop\" through the use of persistent XML streams over
      long-lived TCP\n   connections.  These \"always-on\" client-to-server and server-to-server\n
      \  streams enable each party to push data to the other party at any time\n   for
      immediate routing or delivery.  XML streams are defined under\n   Section 4.\n"
    title: 2.3.  Persistent Streams
  - contents:
    - "2.4.  Structured Data\n   The basic protocol data unit in XMPP is not an XML
      stream (which\n   simply provides the transport for point-to-point communication)
      but\n   an XML \"stanza\", which is essentially a fragment of XML that is sent\n
      \  over a stream.  The root element of a stanza includes routing\n   attributes
      (such as \"from\" and \"to\" addresses), and the child\n   elements of the stanza
      contain a payload for delivery to the intended\n   recipient.  XML stanzas are
      defined under Section 8.\n"
    title: 2.4.  Structured Data
  - contents:
    - "2.5.  Distributed Network of Clients and Servers\n   In practice, XMPP consists
      of a network of clients and servers that\n   inter-communicate (however, communication
      between any two given\n   deployed servers is strictly discretionary and a matter
      of local\n   service policy).  Thus, for example, the user <juliet@im.example.com>\n
      \  associated with the server <im.example.com> might be able to exchange\n   messages,
      presence, and other structured data with the user\n   <romeo@example.net> associated
      with the server <example.net>.  This\n   pattern is familiar from messaging
      protocols that make use of global\n   addresses, such as the email network (see
      [SMTP] and [EMAIL-ARCH]).\n   As a result, end-to-end communication in XMPP
      is logically peer-to-\n   peer but physically client-to-server-to-server-to-client,
      as\n   illustrated in the following diagram.\n     example.net <-------------->
      im.example.com\n        ^                                ^\n        |                                |\n
      \       v                                v\n   romeo@example.net           juliet@im.example.com\n
      \            Figure 1: Distributed Client-Server Architecture\n      Informational
      Note: Architectures that employ XML streams\n      (Section 4) and XML stanzas
      (Section 8) but that establish peer-\n      to-peer connections directly between
      clients using technologies\n      based on [LINKLOCAL] have been deployed, but
      such architectures\n      are not defined in this specification and are best
      described as\n      \"XMPP-like\"; for details, see [XEP-0174].  In addition,
      XML\n      streams can be established end-to-end over any reliable transport,\n
      \     including extensions to XMPP itself; however, such methods are out\n      of
      scope for this specification.\n   The following paragraphs describe the responsibilities
      of clients and\n   servers on the network.\n   A client is an entity that establishes
      an XML stream with a server by\n   authenticating using the credentials of a
      registered account (via\n   SASL negotiation (Section 6)) and that then completes
      resource\n   binding (Section 7) in order to enable delivery of XML stanzas\n
      \  between the server and the client over the negotiated stream.  The\n   client
      then uses XMPP to communicate with its server, other clients,\n   and any other
      entities on the network, where the server is\n   responsible for delivering
      stanzas to other connected clients at the\n   same server or routing them to
      remote servers.  Multiple clients can\n   connect simultaneously to a server
      on behalf of the same registered\n   account, where each client is differentiated
      by the resourcepart of\n   an XMPP address (e.g., <juliet@im.example.com/balcony>
      vs.\n   <juliet@im.example.com/chamber>), as defined under [XMPP-ADDR] and\n
      \  Section 7.\n   A server is an entity whose primary responsibilities are to:\n
      \  o  Manage XML streams (Section 4) with connected clients and deliver\n      XML
      stanzas (Section 8) to those clients over the negotiated\n      streams; this
      includes responsibility for ensuring that a client\n      authenticates with
      the server before being granted access to the\n      XMPP network.\n   o  Subject
      to local service policies on server-to-server\n      communication, manage XML
      streams (Section 4) with remote servers\n      and route XML stanzas (Section
      8) to those servers over the\n      negotiated streams.\n   Depending on the
      application, the secondary responsibilities of an\n   XMPP server can include:\n
      \  o  Storing data that is used by clients (e.g., contact lists for\n      users
      of XMPP-based instant messaging and presence applications as\n      defined
      in [XMPP-IM]); in this case, the relevant XML stanza is\n      handled directly
      by the server itself on behalf of the client and\n      is not routed to a remote
      server or delivered to a connected\n      client.\n   o  Hosting add-on services
      that also use XMPP as the basis for\n      communication but that provide additional
      functionality beyond\n      that defined in this document or in [XMPP-IM]; examples
      include\n      multi-user conferencing services as specified in [XEP-0045] and\n
      \     publish-subscribe services as specified in [XEP-0060].\n"
    title: 2.5.  Distributed Network of Clients and Servers
  title: 2.  Architecture
- contents:
  - '3.  TCP Binding

    '
  - contents:
    - "3.1.  Scope\n   As XMPP is defined in this specification, an initiating entity\n
      \  (client or server) MUST open a Transmission Control Protocol [TCP]\n   connection
      to the receiving entity (server) before it negotiates XML\n   streams with the
      receiving entity.  The parties then maintain that\n   TCP connection for as
      long as the XML streams are in use.  The rules\n   specified in the following
      sections apply to the TCP binding.\n      Informational Note: There is no necessary
      coupling of XML streams\n      to TCP, and other transports are possible.  For
      example, two\n      entities could connect to each other by means of [HTTP]
      as\n      specified in [XEP-0124] and [XEP-0206].  However, this\n      specification
      defines only a binding of XMPP to TCP.\n"
    title: 3.1.  Scope
  - contents:
    - "3.2.  Resolution of Fully Qualified Domain Names\n   Because XML streams are
      sent over TCP, the initiating entity needs to\n   determine the IPv4 or IPv6
      address (and port) of the receiving entity\n   before it can attempt to open
      an XML stream.  Typically this is done\n   by resolving the receiving entity's
      fully qualified domain name or\n   FQDN (see [DNS-CONCEPTS]).\n"
    - contents:
      - "3.2.1.  Preferred Process: SRV Lookup\n   The preferred process for FQDN
        resolution is to use [DNS-SRV] records\n   as follows:\n   1.  The initiating
        entity constructs a DNS SRV query whose inputs\n       are:\n       *  a Service
        of \"xmpp-client\" (for client-to-server connections)\n          or \"xmpp-server\"
        (for server-to-server connections)\n       *  a Proto of \"tcp\"\n       *
        \ a Name corresponding to the \"origin domain\" [TLS-CERTS] of the\n          XMPP
        service to which the initiating entity wishes to connect\n          (e.g.,
        \"example.net\" or \"im.example.com\")\n   2.  The result is a query such
        as \"_xmpp-client._tcp.example.net.\" or\n       \"_xmpp-server._tcp.im.example.com.\".\n
        \  3.  If a response is received, it will contain one or more\n       combinations
        of a port and FDQN, each of which is weighted and\n       prioritized as described
        in [DNS-SRV].  (However, if the result\n       of the SRV lookup is a single
        resource record with a Target of\n       \".\", i.e., the root domain, then
        the initiating entity MUST abort\n       SRV processing at this point because
        according to [DNS-SRV] such\n       a Target \"means that the service is decidedly
        not available at\n       this domain\".)\n   4.  The initiating entity chooses
        at least one of the returned FQDNs\n       to resolve (following the rules
        in [DNS-SRV]), which it does by\n       performing DNS \"A\" or \"AAAA\" lookups
        on the FDQN; this will\n       result in an IPv4 or IPv6 address.\n   5.  The
        initiating entity uses the IP address(es) from the\n       successfully resolved
        FDQN (with the corresponding port number\n       returned by the SRV lookup)
        as the connection address for the\n       receiving entity.\n   6.  If the
        initiating entity fails to connect using that IP address\n       but the \"A\"
        or \"AAAA\" lookups returned more than one IP address,\n       then the initiating
        entity uses the next resolved IP address for\n       that FDQN as the connection
        address.\n   7.  If the initiating entity fails to connect using all resolved
        IP\n       addresses for a given FDQN, then it repeats the process of\n       resolution
        and connection for the next FQDN returned by the SRV\n       lookup based
        on the priority and weight as defined in [DNS-SRV].\n   8.  If the initiating
        entity receives a response to its SRV query but\n       it is not able to
        establish an XMPP connection using the data\n       received in the response,
        it SHOULD NOT attempt the fallback\n       process described in the next section
        (this helps to prevent a\n       state mismatch between inbound and outbound
        connections).\n   9.  If the initiating entity does not receive a response
        to its SRV\n       query, it SHOULD attempt the fallback process described
        in the\n       next section.\n"
      title: '3.2.1.  Preferred Process: SRV Lookup'
    - contents:
      - "3.2.2.  Fallback Processes\n   The fallback process SHOULD be a normal \"A\"
        or \"AAAA\" address record\n   resolution to determine the IPv4 or IPv6 address
        of the origin\n   domain, where the port used is the \"xmpp-client\" port
        of 5222 for\n   client-to-server connections or the \"xmpp-server\" port of
        5269 for\n   server-to-server connections (these are the default ports as\n
        \  registered with the IANA as described under Section 14.7).\n   If connections
        via TCP are unsuccessful, the initiating entity might\n   attempt to find
        and use alternative connection methods such as the\n   HTTP binding (see [XEP-0124]
        and [XEP-0206]), which might be\n   discovered using [DNS-TXT] records as
        described in [XEP-0156].\n"
      title: 3.2.2.  Fallback Processes
    - contents:
      - "3.2.3.  When Not to Use SRV\n   If the initiating entity has been explicitly
        configured to associate\n   a particular FQDN (and potentially port) with
        the origin domain of\n   the receiving entity (say, to \"hardcode\" an association
        from an\n   origin domain of example.net to a configured FQDN of\n   apps.example.com),
        the initiating entity is encouraged to use the\n   configured name instead
        of performing the preferred SRV resolution\n   process on the origin domain.\n"
      title: 3.2.3.  When Not to Use SRV
    - contents:
      - "3.2.4.  Use of SRV Records with Add-On Services\n   Many XMPP servers are
        implemented in such a way that they can host\n   add-on services (beyond those
        defined in this specification and\n   [XMPP-IM]) at DNS domain names that
        typically are \"subdomains\" of the\n   main XMPP service (e.g., conference.example.net
        for a [XEP-0045]\n   service associated with the example.net XMPP service)
        or \"subdomains\"\n   of the first-level domain of the underlying service
        (e.g.,\n   muc.example.com for a [XEP-0045] service associated with the\n
        \  im.example.com XMPP service).  If an entity associated with a remote\n
        \  XMPP server wishes to communicate with such an add-on service, it\n   would
        generate an appropriate XML stanza and the remote server would\n   attempt
        to resolve the add-on service's DNS domain name via an SRV\n   lookup on resource
        records such as \"_xmpp-\n   server._tcp.conference.example.net.\" or \"_xmpp-\n
        \  server._tcp.muc.example.com.\".  Therefore, if the administrators of\n
        \  an XMPP service wish to enable entities associated with remote\n   servers
        to access such add-on services, they need to advertise the\n   appropriate
        \"_xmpp-server\" SRV records in addition to the \"_xmpp-\n   server\" record
        for their main XMPP service.  In case SRV records are\n   not available, the
        fallback methods described under Section 3.2.2 can\n   be used to resolve
        the DNS domain names of add-on services.\n"
      title: 3.2.4.  Use of SRV Records with Add-On Services
    title: 3.2.  Resolution of Fully Qualified Domain Names
  - contents:
    - "3.3.  Reconnection\n   It can happen that an XMPP server goes offline unexpectedly
      while\n   servicing TCP connections from connected clients and remote servers.\n
      \  Because the number of such connections can be quite large, the\n   reconnection
      algorithm employed by entities that seek to reconnect\n   can have a significant
      impact on software performance and network\n   congestion.  If an entity chooses
      to reconnect, it:\n   o  SHOULD set the number of seconds that expire before
      reconnecting\n      to an unpredictable number between 0 and 60 (this helps
      to ensure\n      that not all entities attempt to reconnect at exactly the same\n
      \     number of seconds after being disconnected).\n   o  SHOULD back off increasingly
      on the time between subsequent\n      reconnection attempts (e.g., in accordance
      with \"truncated binary\n      exponential backoff\" as described in [ETHERNET])
      if the first\n      reconnection attempt does not succeed.\n   It is RECOMMENDED
      to make use of TLS session resumption [TLS-RESUME]\n   when reconnecting.  A
      future version of this document, or a separate\n   specification, might provide
      more detailed guidelines regarding\n   methods for speeding the reconnection
      process.\n"
    title: 3.3.  Reconnection
  - contents:
    - "3.4.  Reliability\n   The use of long-lived TCP connections in XMPP implies
      that the\n   sending of XML stanzas over XML streams can be unreliable, since
      the\n   parties to a long-lived TCP connection might not discover a\n   connectivity
      disruption in a timely manner.  At the XMPP application\n   layer, long connectivity
      disruptions can result in undelivered\n   stanzas.  Although the core XMPP technology
      defined in this\n   specification does not contain features to overcome this
      lack of\n   reliability, there exist XMPP extensions for doing so (e.g.,\n   [XEP-0198]).\n"
    title: 3.4.  Reliability
  title: 3.  TCP Binding
- contents:
  - '4.  XML Streams

    '
  - contents:
    - "4.1.  Stream Fundamentals\n   Two fundamental concepts make possible the rapid,
      asynchronous\n   exchange of relatively small payloads of structured information\n
      \  between XMPP entities: XML streams and XML stanzas.  These terms are\n   defined
      as follows.\n   Definition of XML Stream:  An XML stream is a container for
      the\n      exchange of XML elements between any two entities over a network.\n
      \     The start of an XML stream is denoted unambiguously by an opening\n      \"stream
      header\" (i.e., an XML <stream> tag with appropriate\n      attributes and namespace
      declarations), while the end of the XML\n      stream is denoted unambiguously
      by a closing XML </stream> tag.\n      During the life of the stream, the entity
      that initiated it can\n      send an unbounded number of XML elements over the
      stream, either\n      elements used to negotiate the stream (e.g., to complete
      TLS\n      negotiation (Section 5) or SASL negotiation (Section 6)) or XML\n
      \     stanzas.  The \"initial stream\" is negotiated from the initiating\n      entity
      (typically a client or server) to the receiving entity\n      (typically a server),
      and can be seen as corresponding to the\n      initiating entity's \"connection
      to\" or \"session with\" the\n      receiving entity.  The initial stream enables
      unidirectional\n      communication from the initiating entity to the receiving
      entity;\n      in order to enable exchange of stanzas from the receiving entity\n
      \     to the initiating entity, the receiving entity MUST negotiate a\n      stream
      in the opposite direction (the \"response stream\").\n   Definition of XML Stanza:
      \ An XML stanza is the basic unit of meaning\n      in XMPP.  A stanza is a
      first-level element (at depth=1 of the\n      stream) whose element name is
      \"message\", \"presence\", or \"iq\" and\n      whose qualifying namespace is
      'jabber:client' or 'jabber:server'.\n      By contrast, a first-level element
      qualified by any other\n      namespace is not an XML stanza (stream errors,
      stream features,\n      TLS-related elements, SASL-related elements, etc.),
      nor is a\n      <message/>, <presence/>, or <iq/> element that is qualified
      by the\n      'jabber:client' or 'jabber:server' namespace but that occurs at
      a\n      depth other than one (e.g., a <message/> element contained within\n
      \     an extension element (Section 8.4) for reporting purposes), nor is\n      a
      <message/>, <presence/>, or <iq/> element that is qualified by a\n      namespace
      other than 'jabber:client' or 'jabber:server'.  An XML\n      stanza typically
      contains one or more child elements (with\n      accompanying attributes, elements,
      and XML character data) as\n      necessary in order to convey the desired information,
      which MAY be\n      qualified by any XML namespace (see [XML-NAMES] as well
      as\n      Section 8.4 in this specification).\n   There are three kinds of stanzas:
      message, presence, and IQ (short\n   for \"Info/Query\").  These stanza types
      provide three different\n   communication primitives: a \"push\" mechanism for
      generalized\n   messaging, a specialized \"publish-subscribe\" mechanism for\n
      \  broadcasting information about network availability, and a \"request-\n   response\"
      mechanism for more structured exchanges of data (similar to\n   [HTTP]).  Further
      explanations are provided under Section 8.2.1,\n   Section 8.2.2, and Section
      8.2.3, respectively.\n   Consider the example of a client's connection to a
      server.  The\n   client initiates an XML stream by sending a stream header to
      the\n   server, preferably preceded by an XML declaration specifying the XML\n
      \  version and the character encoding supported (see Section 11.5 and\n   Section
      11.6).  Subject to local policies and service provisioning,\n   the server then
      replies with a second XML stream back to the client,\n   again preferably preceded
      by an XML declaration.  Once the client has\n   completed SASL negotiation (Section
      6) and resource binding\n   (Section 7), the client can send an unbounded number
      of XML stanzas\n   over the stream.  When the client desires to close the stream,
      it\n   simply sends a closing </stream> tag to the server as further\n   described
      under Section 4.4.\n   In essence, then, one XML stream functions as an envelope
      for the XML\n   stanzas sent during a session and another XML stream functions
      as an\n   envelope for the XML stanzas received during a session.  We can\n
      \  represent this in a simplistic fashion as follows.\n   +--------------------+--------------------+\n
      \  | INITIAL STREAM     |  RESPONSE STREAM   |\n   +--------------------+--------------------+\n
      \  | <stream>           |                    |\n   |--------------------|--------------------|\n
      \  |                    | <stream>           |\n   |--------------------|--------------------|\n
      \  | <presence>         |                    |\n   |   <show/>          |                    |\n
      \  | </presence>        |                    |\n   |--------------------|--------------------|\n
      \  | <message to='foo'> |                    |\n   |   <body/>          |                    |\n
      \  | </message>         |                    |\n   |--------------------|--------------------|\n
      \  | <iq to='bar'       |                    |\n   |     type='get'>    |                    |\n
      \  |   <query/>         |                    |\n   | </iq>              |                    |\n
      \  |--------------------|--------------------|\n   |                    | <iq
      from='bar'     |\n   |                    |     type='result'> |\n   |                    |
      \  <query/>         |\n   |                    | </iq>              |\n   |--------------------|--------------------|\n
      \  | [ ... ]            |                    |\n   |--------------------|--------------------|\n
      \  |                    | [ ... ]            |\n   |--------------------|--------------------|\n
      \  | </stream>          |                    |\n   |--------------------|--------------------|\n
      \  |                    | </stream>          |\n   +--------------------+--------------------+\n
      \               Figure 2: A Simplistic View of Two Streams\n   Those who are
      accustomed to thinking of XML in a document-centric\n   manner might find the
      following analogies useful:\n   o  The two XML streams are like two \"documents\"
      (matching the\n      \"document\" production from [XML]) that are built up through
      the\n      accumulation of XML stanzas.\n   o  The root <stream/> element is
      like the \"document entity\" for each\n      \"document\" (as described in Section
      4.8 of [XML]).\n   o  The XML stanzas sent over the streams are like \"fragments\"
      of the\n      \"documents\" (as described in [XML-FRAG]).\n   However, these
      descriptions are merely analogies, because XMPP does\n   not deal in documents
      and fragments but in streams and stanzas.\n   The remainder of this section
      defines the following aspects of XML\n   streams (along with related topics):\n
      \  o  How to open a stream (Section 4.2)\n   o  The stream negotiation process
      (Section 4.3)\n   o  How to close a stream (Section 4.4)\n   o  The directionality
      of XML streams (Section 4.5)\n   o  How to handle peers that are silent (Section
      4.6)\n   o  The XML attributes of a stream (Section 4.7)\n   o  The XML namespaces
      of a stream (Section 4.8)\n   o  Error handling related to XML streams (Section
      4.9)\n"
    title: 4.1.  Stream Fundamentals
  - contents:
    - "4.2.  Opening a Stream\n   After connecting to the appropriate IP address and
      port of the\n   receiving entity, the initiating entity opens a stream by sending
      a\n   stream header (the \"initial stream header\") to the receiving entity.\n
      \  I: <?xml version='1.0'?>\n      <stream:stream\n          from='juliet@im.example.com'\n
      \         to='im.example.com'\n          version='1.0'\n          xml:lang='en'\n
      \         xmlns='jabber:client'\n          xmlns:stream='http://etherx.jabber.org/streams'>\n
      \  The receiving entity then replies by sending a stream header of its\n   own
      (the \"response stream header\") to the initiating entity.\n   R: <?xml version='1.0'?>\n
      \     <stream:stream\n          from='im.example.com'\n          id='++TR84Sm6A3hnt3Q065SnAbbk3Y='\n
      \         to='juliet@im.example.com'\n          version='1.0'\n          xml:lang='en'\n
      \         xmlns='jabber:client'\n          xmlns:stream='http://etherx.jabber.org/streams'>\n
      \  The entities can then proceed with the remainder of the stream\n   negotiation
      process.\n"
    title: 4.2.  Opening a Stream
  - contents:
    - '4.3.  Stream Negotiation

      '
    - contents:
      - "4.3.1.  Basic Concepts\n   Because the receiving entity for a stream acts
        as a gatekeeper to the\n   domains it services, it imposes certain conditions
        for connecting as\n   a client or as a peer server.  At a minimum, the initiating
        entity\n   needs to authenticate with the receiving entity before it is allowed\n
        \  to send stanzas to the receiving entity (for client-to-server streams\n
        \  this means using SASL as described under Section 6).  However, the\n   receiving
        entity can consider conditions other than authentication to\n   be mandatory-to-negotiate,
        such as encryption using TLS as described\n   under Section 5.  The receiving
        entity informs the initiating entity\n   about such conditions by communicating
        \"stream features\": the set of\n   particular protocol interactions that
        the initiating entity needs to\n   complete before the receiving entity will
        accept XML stanzas from the\n   initiating entity, as well as any protocol
        interactions that are\n   voluntary-to-negotiate but that might improve the
        handling of an XML\n   stream (e.g., establishment of application-layer compression
        as\n   described in [XEP-0138]).\n   The existence of conditions for connecting
        implies that streams need\n   to be negotiated.  The order of layers (TCP,
        then TLS, then SASL,\n   then XMPP as described under Section 13.3) implies
        that stream\n   negotiation is a multi-stage process.  Further structure is
        imposed\n   by two factors: (1) a given stream feature might be offered only
        to\n   certain entities or only after certain other features have been\n   negotiated
        (e.g., resource binding is offered only after SASL\n   authentication), and
        (2) stream features can be either mandatory-to-\n   negotiate or voluntary-to-negotiate.
        \ Finally, for security reasons\n   the parties to a stream need to discard
        knowledge that they gained\n   during the negotiation process after successfully
        completing the\n   protocol interactions defined for certain features (e.g.,
        TLS in all\n   cases and SASL in the case when a security layer might be\n
        \  established, as defined in the specification for the relevant SASL\n   mechanism).
        \ This is done by flushing the old stream context and\n   exchanging new stream
        headers over the existing TCP connection.\n"
      title: 4.3.1.  Basic Concepts
    - contents:
      - "4.3.2.  Stream Features Format\n   If the initiating entity includes in the
        initial stream header the\n   'version' attribute set to a value of at least
        \"1.0\" (see\n   Section 4.7.5), after sending the response stream header
        the\n   receiving entity MUST send a <features/> child element (typically\n
        \  prefixed by the stream namespace prefix as described under\n   Section
        4.8.5) to the initiating entity in order to announce any\n   conditions for
        continuation of the stream negotiation process.  Each\n   condition takes
        the form of a child element of the <features/>\n   element, qualified by a
        namespace that is different from the stream\n   namespace and the content
        namespace.  The <features/> element can\n   contain one child, contain multiple
        children, or be empty.\n      Implementation Note: The order of child elements
        contained in any\n      given <features/> element is not significant.\n   If
        a particular stream feature is or can be mandatory-to-negotiate,\n   the definition
        of that feature needs to do one of the following:\n   1.  Declare that the
        feature is always mandatory-to-negotiate (e.g.,\n       this is true of resource
        binding for XMPP clients); or\n   2.  Specify a way for the receiving entity
        to flag the feature as\n       mandatory-to-negotiate for this interaction
        (e.g., for STARTTLS,\n       this is done by including an empty <required/>
        element in the\n       advertisement for that stream feature, but that is
        not a generic\n       format for all stream features); it is RECOMMENDED that
        stream\n       feature definitions for new mandatory-to-negotiate features
        do so\n       by including an empty <required/> element as is done for\n       STARTTLS.\n
        \     Informational Note: Because there is no generic format for\n      indicating
        that a feature is mandatory-to-negotiate, it is\n      possible that a feature
        that is not understood by the initiating\n      entity might be considered
        mandatory-to-negotiate by the receiving\n      entity, resulting in failure
        of the stream negotiation process.\n      Although such an outcome would be
        undesirable, the working group\n      deemed it rare enough that a generic
        format was not needed.\n   For security reasons, certain stream features necessitate
        the\n   initiating entity to send a new initial stream header upon successful\n
        \  negotiation of the feature (e.g., TLS in all cases and SASL in the\n   case
        when a security layer might be established).  If this is true of\n   a given
        stream feature, the definition of that feature needs to\n   specify that a
        stream restart is expected after negotiation of the\n   feature.\n   A <features/>
        element that contains at least one mandatory-to-\n   negotiate feature indicates
        that the stream negotiation is not\n   complete and that the initiating entity
        MUST negotiate further\n   features.\n   R: <stream:features>\n        <starttls
        xmlns='urn:ietf:params:xml:ns:xmpp-tls'>\n          <required/>\n        </starttls>\n
        \     </stream:features>\n   A <features/> element MAY contain more than one
        mandatory-to-\n   negotiate feature.  This means that the initiating entity
        can choose\n   among the mandatory-to-negotiate features at this stage of
        the stream\n   negotiation process.  As an example, perhaps a future technology
        will\n   perform roughly the same function as TLS, so the receiving entity\n
        \  might advertise support for both TLS and the future technology at the\n
        \  same stage of the stream negotiation process.  However, this applies\n
        \  only at a given stage of the stream negotiation process and does not\n
        \  apply to features that are mandatory-to-negotiate at different stages\n
        \  (e.g., the receiving entity would not advertise both STARTTLS and\n   SASL
        as mandatory-to-negotiate, or both SASL and resource binding as\n   mandatory-to-negotiate,
        because TLS would need to be negotiated\n   before SASL and because SASL would
        need to be negotiated before\n   resource binding).\n   A <features/> element
        that contains both mandatory-to-negotiate and\n   voluntary-to-negotiate features
        indicates that the negotiation is not\n   complete but that the initiating
        entity MAY complete the voluntary-\n   to-negotiate feature(s) before it attempts
        to negotiate the\n   mandatory-to-negotiate feature(s).\n   R: <stream:features>\n
        \       <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'/>\n        <compression
        xmlns='http://jabber.org/features/compress'>\n          <method>zlib</method>\n
        \         <method>lzw</method>\n        </compression>\n      </stream:features>\n
        \  A <features/> element that contains only voluntary-to-negotiate\n   features
        indicates that the stream negotiation is complete and that\n   the initiating
        entity is cleared to send XML stanzas, but that the\n   initiating entity
        MAY negotiate further features if desired.\n   R: <stream:features>\n        <compression
        xmlns='http://jabber.org/features/compress'>\n          <method>zlib</method>\n
        \         <method>lzw</method>\n        </compression>\n      </stream:features>\n
        \  An empty <features/> element indicates that the stream negotiation is\n
        \  complete and that the initiating entity is cleared to send XML\n   stanzas.\n
        \  R: <stream:features/>\n"
      title: 4.3.2.  Stream Features Format
    - contents:
      - "4.3.3.  Restarts\n   On successful negotiation of a feature that necessitates
        a stream\n   restart, both parties MUST consider the previous stream to be\n
        \  replaced but MUST NOT send a closing </stream> tag and MUST NOT\n   terminate
        the underlying TCP connection; instead, the parties MUST\n   reuse the existing
        connection, which might be in a new state (e.g.,\n   encrypted as a result
        of TLS negotiation).  The initiating entity\n   then MUST send a new initial
        stream header, which SHOULD be preceded\n   by an XML declaration as described
        under Section 11.5.  When the\n   receiving entity receives the new initial
        stream header, it MUST\n   generate a new stream ID (instead of reusing the
        old stream ID)\n   before sending a new response stream header (which SHOULD
        be preceded\n   by an XML declaration as described under Section 11.5).\n"
      title: 4.3.3.  Restarts
    - contents:
      - "4.3.4.  Resending Features\n   The receiving entity MUST send an updated
        list of stream features to\n   the initiating entity after a stream restart.
        \ The list of updated\n   features MAY be empty if there are no further features
        to be\n   advertised or MAY include any combination of features.\n"
      title: 4.3.4.  Resending Features
    - contents:
      - "4.3.5.  Completion of Stream Negotiation\n   The receiving entity indicates
        completion of the stream negotiation\n   process by sending to the initiating
        entity either an empty\n   <features/> element or a <features/> element that
        contains only\n   voluntary-to-negotiate features.  After doing so, the receiving\n
        \  entity MAY send an empty <features/> element (e.g., after negotiation\n
        \  of such voluntary-to-negotiate features) but MUST NOT send additional\n
        \  stream features to the initiating entity (if the receiving entity has\n
        \  new features to offer, preferably limited to mandatory-to-negotiate\n   or
        security-critical features, it can simply close the stream with a\n   <reset/>
        stream error (Section 4.9.3.16) and then advertise the new\n   features when
        the initiating entity reconnects, preferably closing\n   existing streams
        in a staggered way so that not all of the initiating\n   entities reconnect
        at once).  Once stream negotiation is complete,\n   the initiating entity
        is cleared to send XML stanzas over the stream\n   for as long as the stream
        is maintained by both parties.\n      Informational Note: Resource binding
        as specified under Section 7\n      is an historical exception to the foregoing
        rule, since it is\n      mandatory-to-negotiate for clients but uses XML stanzas
        for\n      negotiation purposes.\n   The initiating entity MUST NOT attempt
        to send XML stanzas\n   (Section 8) to entities other than itself (i.e., the
        client's\n   connected resource or any other authenticated resource of the\n
        \  client's account) or the server to which it is connected until stream\n
        \  negotiation has been completed.  Even if the initiating entity does\n   attempt
        to do so, the receiving entity MUST NOT accept such stanzas\n   and MUST close
        the stream with a <not-authorized/> stream error\n   (Section 4.9.3.12).  This
        rule applies to XML stanzas only (i.e.,\n   <message/>, <presence/>, and <iq/>
        elements qualified by the content\n   namespace) and not to XML elements used
        for stream negotiation (e.g.,\n   elements used to complete TLS negotiation
        (Section 5) or SASL\n   negotiation (Section 6)).\n"
      title: 4.3.5.  Completion of Stream Negotiation
    - contents:
      - "4.3.6.  Determination of Addresses\n   After the parties to an XML stream
        have completed the appropriate\n   aspects of stream negotiation, the receiving
        entity for a stream MUST\n   determine the initiating entity's JID.\n   For
        client-to-server communication, both SASL negotiation (Section 6)\n   and
        resource binding (Section 7) MUST be completed before the server\n   can determine
        the client's address.  The client's bare JID\n   (<localpart@domainpart>)
        MUST be the authorization identity (as\n   defined by [SASL]), either (1)
        as directly communicated by the client\n   during SASL negotiation (Section
        6) or (2) as derived by the server\n   from the authentication identity if
        no authorization identity was\n   specified during SASL negotiation.  The
        resourcepart of the full JID\n   (<localpart@domainpart/resourcepart>) MUST
        be the resource negotiated\n   by the client and server during resource binding
        (Section 7).  A\n   client MUST NOT attempt to guess at its JID but instead
        MUST consider\n   its JID to be whatever the server returns to it during resource\n
        \  binding.  The server MUST ensure that the resulting JID (including\n   localpart,
        domainpart, resourcepart, and separator characters)\n   conforms to the canonical
        format for XMPP addresses defined in\n   [XMPP-ADDR]; to meet this restriction,
        the server MAY replace the JID\n   sent by the client with the canonicalized
        JID as determined by the\n   server and communicate that JID to the client
        during resource\n   binding.\n   For server-to-server communication, the initiating
        server's bare JID\n   (<domainpart>) MUST be the authorization identity (as
        defined by\n   [SASL]), either (1) as directly communicated by the initiating
        server\n   during SASL negotiation (Section 6) or (2) as derived by the\n
        \  receiving server from the authentication identity if no authorization\n
        \  identity was specified during SASL negotiation.  In the absence of\n   SASL
        negotiation, the receiving server MAY consider the authorization\n   identity
        to be an identity negotiated within the relevant\n   verification protocol
        (e.g., the 'from' attribute of the <result/>\n   element in Server Dialback
        [XEP-0220]).\n      Security Warning: Because it is possible for a third party
        to\n      tamper with information that is sent over the stream before a\n
        \     security layer such as TLS is successfully negotiated, it is\n      advisable
        for the receiving server to treat any such unprotected\n      information
        with caution; this applies especially to the 'from'\n      and 'to' addresses
        on the first initial stream header sent by the\n      initiating entity.\n"
      title: 4.3.6.  Determination of Addresses
    - contents:
      - "4.3.7.  Flow Chart\n   We summarize the foregoing rules in the following
        non-normative flow\n   chart for the stream negotiation process, presented
        from the\n   perspective of the initiating entity.\n                   +---------------------+\n
        \                  | open TCP connection |\n                   +---------------------+\n
        \                             |\n                              v\n                       +---------------+\n
        \                      | send initial  |<-------------------------+\n                       |
        stream header |                          ^\n                       +---------------+
        \                         |\n                              |                                   |\n
        \                             v                                   |\n                      +------------------+
        \                       |\n                      | receive response |                        |\n
        \                     | stream header    |                        |\n                      +------------------+
        \                       |\n                              |                                   |\n
        \                             v                                   |\n                       +----------------+
        \                        |\n                       | receive stream |                         |\n
        \  +------------------>| features       |                         |\n   ^
        \  {OPTIONAL}      +----------------+                         |\n   |                          |
        \                                  |\n   |                          v                                   |\n
        \  |       +<-----------------+                                   |\n   |
        \      |                                                      |\n   |    {empty?}
        ----> {all voluntary?} ----> {some mandatory?}   |\n   |       |      no          |
        \         no         |             |\n   |       | yes              | yes
        \                | yes         |\n   |       |                  v                     v
        \            |\n   |       |           +---------------+    +----------------+
        \   |\n   |       |           | MAY negotiate |    | MUST negotiate |    |\n
        \  |       |           | any or none   |    | one feature    |    |\n   |
        \      |           +---------------+    +----------------+    |\n   |       v
        \                 |                     |             |\n   |   +---------+
        \           v                     |             |\n   |   |  DONE   |<-----
        {negotiate?}               |             |\n   |   +---------+   no       |
        \                    |             |\n   |                     yes  |                     |
        \            |\n   |                          v                     v             |\n
        \  |                          +--------->+<---------+             |\n   |
        \                                    |                        |\n   |                                     v
        \                       |\n   +<-------------------------- {restart mandatory?}
        ------------>+\n                  no                                     yes\n
        \                 Figure 3: Stream Negotiation Flow Chart\n"
      title: 4.3.7.  Flow Chart
    title: 4.3.  Stream Negotiation
  - contents:
    - "4.4.  Closing a Stream\n   An XML stream from one entity to another can be
      closed at any time,\n   either because a specific stream error (Section 4.9)
      has occurred or\n   in the absence of an error (e.g., when a client simply ends
      its\n   session).\n   A stream is closed by sending a closing </stream> tag.\n
      \  E: </stream:stream>\n   If the parties are using either two streams over
      a single TCP\n   connection or two streams over two TCP connections, the entity
      that\n   sends the closing stream tag MUST behave as follows:\n   1.  Wait for
      the other party to also close its outbound stream before\n       terminating
      the underlying TCP connection(s); this gives the\n       other party an opportunity
      to finish transmitting any outbound\n       data to the closing entity before
      the termination of the TCP\n       connection(s).\n   2.  Refrain from sending
      any further data over its outbound stream to\n       the other entity, but continue
      to process data received from the\n       other entity (and, if necessary, process
      such data).\n   3.  Consider both streams to be void if the other party does
      not send\n       its closing stream tag within a reasonable amount of time (where\n
      \      the definition of \"reasonable\" is a matter of implementation or\n       deployment).\n
      \  4.  After receiving a reciprocal closing stream tag from the other\n       party
      or waiting a reasonable amount of time with no response,\n       terminate the
      underlying TCP connection(s).\n      Security Warning: In accordance with Section
      7.2.1 of [TLS], to\n      help prevent a truncation attack the party that is
      closing the\n      stream MUST send a TLS close_notify alert and MUST receive
      a\n      responding close_notify alert from the other party before\n      terminating
      the underlying TCP connection(s).\n   If the parties are using multiple streams
      over multiple TCP\n   connections, there is no defined pairing of streams and
      therefore the\n   behavior is a matter for implementation.\n"
    title: 4.4.  Closing a Stream
  - contents:
    - "4.5.  Directionality\n   An XML stream is always unidirectional, by which is
      meant that XML\n   stanzas can be sent in only one direction over the stream
      (either\n   from the initiating entity to the receiving entity or from the\n
      \  receiving entity to the initiating entity).\n   Depending on the type of
      session that has been negotiated and the\n   nature of the entities involved,
      the entities might use:\n   o  Two streams over a single TCP connection, where
      the security\n      context negotiated for the first stream is applied to the
      second\n      stream.  This is typical for client-to-server sessions, and a\n
      \     server MUST allow a client to use the same TCP connection for both\n      streams.\n
      \  o  Two streams over two TCP connections, where each stream is\n      separately
      secured.  In this approach, one TCP connection is used\n      for the stream
      in which stanzas are sent from the initiating\n      entity to the receiving
      entity, and the other TCP connection is\n      used for the stream in which
      stanzas are sent from the receiving\n      entity to the initiating entity.
      \ This is typical for server-to-\n      server sessions.\n   o  Multiple streams
      over two or more TCP connections, where each\n      stream is separately secured.
      \ This approach is sometimes used for\n      server-to-server communication
      between two large XMPP service\n      providers; however, this can make it difficult
      to maintain\n      coherence of data received over multiple streams in situations\n
      \     described under Section 10.1, which is why a server MAY close the\n      stream
      with a <conflict/> stream error (Section 4.9.3.3) if a\n      remote server
      attempts to negotiate more than one stream (as\n      described under Section
      4.9.3.3).\n   This concept of directionality applies only to stanzas and explicitly\n
      \  does not apply to first-level children of the stream root that are\n   used
      to bootstrap or manage the stream (e.g., first-level elements\n   used for TLS
      negotiation, SASL negotiation, Server Dialback\n   [XEP-0220], and Stream Management
      [XEP-0198]).\n   The foregoing considerations imply that while completing STARTTLS\n
      \  negotiation (Section 5) and SASL negotiation (Section 6) two servers\n   would
      use one TCP connection, but after the stream negotiation\n   process is done
      that original TCP connection would be used only for\n   the initiating server
      to send XML stanzas to the receiving server.\n   In order for the receiving
      server to send XML stanzas to the\n   initiating server, the receiving server
      would need to reverse the\n   roles and negotiate an XML stream from the receiving
      server to the\n   initiating server over a separate TCP connection.  This separate
      TCP\n   connection is then secured using a new round of TLS and/or SASL\n   negotiation.\n
      \     Implementation Note: For historical reasons, a server-to-server\n      session
      always uses two TCP connections.  While that approach\n      remains the standard
      behavior described in this document,\n      extensions such as [XEP-0288] enable
      servers to negotiate the use\n      of a single TCP connection for bidirectional
      stanza exchange.\n      Informational Note: Although XMPP developers sometimes
      apply the\n      terms \"unidirectional\" and \"bidirectional\" to the underlying
      TCP\n      connection (e.g., calling the TCP connection for a client-to-\n      server
      session \"bidirectional\" and the TCP connection for a\n      server-to-server
      session \"unidirectional\"), strictly speaking a\n      stream is always unidirectional
      (because the initiating entity and\n      receiving entity always have a minimum
      of two streams, one in each\n      direction) and a TCP connection is always
      bidirectional (because\n      TCP traffic can be sent in both directions).  Directionality\n
      \     applies to the application-layer traffic sent over the TCP\n      connection,
      not to the transport-layer traffic sent over the TCP\n      connection itself.\n"
    title: 4.5.  Directionality
  - contents:
    - "4.6.  Handling of Silent Peers\n   When an entity that is a party to a stream
      has not received any XMPP\n   traffic from its stream peer for some period of
      time, the peer might\n   appear to be silent.  There are several reasons why
      this might\n   happen:\n   1.  The underlying TCP connection is dead.\n   2.
      \ The XML stream is broken despite the fact that the underlying TCP\n       connection
      is alive.\n   3.  The peer is idle and simply has not sent any XMPP traffic
      over\n       its XML stream to the entity.\n   These three conditions are best
      handled separately, as described in\n   the following sections.\n      Implementation
      Note: For the purpose of handling silent peers, we\n      treat a two unidirectional
      TCP connections as conceptually\n      equivalent to a single bidirectional
      TCP connection (see\n      Section 4.5); however, implementers need to be aware
      that, in the\n      case of two unidirectional TCP connections, responses to
      traffic\n      at the XMPP application layer will come back from the peer on
      the\n      second TCP connection.  In addition, the use of multiple streams\n
      \     in each direction (which is a somewhat frequent deployment choice\n      for
      server-to-server connectivity among large XMPP service\n      providers) further
      complicates application-level checking of XMPP\n      streams and their underlying
      TCP connections, because there is no\n      necessary correlation between any
      given initial stream and any\n      given response stream.\n"
    - contents:
      - "4.6.1.  Dead Connection\n   If the underlying TCP connection is dead, stream-level
        checks (e.g.,\n   [XEP-0199] and [XEP-0198]) are ineffective.  Therefore,
        it is\n   unnecessary to close the stream with or without an error, and it
        is\n   appropriate instead to simply terminate the TCP connection.\n   One
        common method for checking the TCP connection is to send a space\n   character
        (U+0020) between XML stanzas, which is allowed for XML\n   streams as described
        under Section 11.7; the sending of such a space\n   character is properly
        called a \"whitespace keepalive\" (the term\n   \"whitespace ping\" is often
        used, despite the fact that it is not a\n   ping since no \"pong\" is possible).
        \ However, this is not allowed\n   during TLS negotiation or SASL negotiation,
        as described under\n   Section 5.3.3 and Section 6.3.5.\n"
      title: 4.6.1.  Dead Connection
    - contents:
      - "4.6.2.  Broken Stream\n   Even if the underlying TCP connection is alive,
        the peer might never\n   respond to XMPP traffic that the entity sends, whether
        normal stanzas\n   or specialized stream-checking traffic such as the application-level\n
        \  pings defined in [XEP-0199] or the more comprehensive Stream\n   Management
        protocol defined in [XEP-0198].  In this case, it is\n   appropriate for the
        entity to close a broken stream with a\n   <connection-timeout/> stream error
        (Section 4.9.3.4).\n"
      title: 4.6.2.  Broken Stream
    - contents:
      - "4.6.3.  Idle Peer\n   Even if the underlying TCP connection is alive and
        the stream is not\n   broken, the peer might have sent no stanzas for a certain
        period of\n   time.  In this case, the peer itself MAY close the stream (as\n
        \  described under Section 4.4) rather than leaving an unused stream\n   open.
        \ If the idle peer does not close the stream, the other party\n   MAY either
        close the stream using the handshake described under\n   Section 4.4 or close
        the stream with a stream error (e.g., <resource-\n   constraint/> (Section
        4.9.3.17) if the entity has reached a limit on\n   the number of open TCP
        connections or <policy-violation/>\n   (Section 4.9.3.14) if the connection
        has exceeded a local timeout\n   policy).  However, consistent with the order
        of layers (specified\n   under Section 13.3), the other party is advised to
        verify that the\n   underlying TCP connection is alive and the stream is unbroken
        (as\n   described above) before concluding that the peer is idle.\n   Furthermore,
        it is preferable to be liberal in accepting idle peers,\n   since experience
        has shown that doing so improves the reliability of\n   communication over
        XMPP networks and that it is typically more\n   efficient to maintain a stream
        between two servers than to\n   aggressively time out such a stream.\n"
      title: 4.6.3.  Idle Peer
    - contents:
      - "4.6.4.  Use of Checking Methods\n   Implementers are advised to support whichever
        stream-checking and\n   connection-checking methods they deem appropriate,
        but to carefully\n   weigh the network impact of such methods against the
        benefits of\n   discovering broken streams and dead TCP connections in a timely\n
        \  manner.  The length of time between the use of any particular check\n   is
        very much a matter of local service policy and depends strongly on\n   the
        network environment and usage scenarios of a given deployment and\n   connection
        type.  At the time of writing, it is RECOMMENDED that any\n   such check be
        performed not more than once every 5 minutes and that,\n   ideally, such checks
        will be initiated by clients rather than\n   servers.  Those who implement
        XMPP software and deploy XMPP services\n   are encouraged to seek additional
        advice regarding appropriate timing\n   of stream-checking and connection-checking
        methods, particularly when\n   power-constrained devices are being used (e.g.,
        in mobile\n   environments).\n"
      title: 4.6.4.  Use of Checking Methods
    title: 4.6.  Handling of Silent Peers
  - contents:
    - "4.7.  Stream Attributes\n   The attributes of the root <stream/> element are
      defined in the\n   following sections.\n      Security Warning: Until and unless
      the confidentiality and\n      integrity of the stream are protected via TLS
      as described under\n      Section 5 or an equivalent security layer (such as
      the SASL GSSAPI\n      mechanism), the attributes provided in a stream header
      could be\n      tampered with by an attacker.\n      Implementation Note: The
      attributes of the root <stream/> element\n      are not prepended by a namespace
      prefix because, as explained in\n      [XML-NAMES], \"[d]efault namespace declarations
      do not apply\n      directly to attribute names; the interpretation of unprefixed\n
      \     attributes is determined by the element on which they appear.\"\n"
    - contents:
      - "4.7.1.  from\n   The 'from' attribute specifies an XMPP identity of the entity
        sending\n   the stream element.\n   For initial stream headers in client-to-server
        communication, the\n   'from' attribute is the XMPP identity of the principal
        controlling\n   the client, i.e., a JID of the form <localpart@domainpart>.
        \ The\n   client might not know the XMPP identity, e.g., because the XMPP\n
        \  identity is assigned at a level other than the XMPP application layer\n
        \  (as in the Generic Security Service Application Program Interface\n   [GSS-API])
        or is derived by the server from information provided by\n   the client (as
        in some deployments of end-user certificates with the\n   SASL EXTERNAL mechanism).
        \ Furthermore, if the client considers the\n   XMPP identity to be private
        information then it is advised not to\n   include a 'from' attribute before
        the confidentiality and integrity\n   of the stream are protected via TLS
        or an equivalent security layer.\n   However, if the client knows the XMPP
        identity then it SHOULD include\n   the 'from' attribute after the confidentiality
        and integrity of the\n   stream are protected via TLS or an equivalent security
        layer.\n   I: <?xml version='1.0'?>\n      <stream:stream\n          from='juliet@im.example.com'\n
        \         to='im.example.com'\n          version='1.0'\n          xml:lang='en'\n
        \         xmlns='jabber:client'\n          xmlns:stream='http://etherx.jabber.org/streams'>\n
        \  For initial stream headers in server-to-server communication, the\n   'from'
        attribute is one of the configured FQDNs of the server, i.e.,\n   a JID of
        the form <domainpart>.  The initiating server might have\n   more than one
        XMPP identity, e.g., in the case of a server that\n   provides virtual hosting,
        so it will need to choose an identity that\n   is associated with this output
        stream (e.g., based on the 'to'\n   attribute of the stanza that triggered
        the stream negotiation\n   attempt).  Because a server is a \"public entity\"
        on the XMPP network,\n   it MUST include the 'from' attribute after the confidentiality
        and\n   integrity of the stream are protected via TLS or an equivalent\n   security
        layer.\n   I: <?xml version='1.0'?>\n      <stream:stream\n          from='example.net'\n
        \         to='im.example.com'\n          version='1.0'\n          xml:lang='en'\n
        \         xmlns='jabber:server'\n          xmlns:stream='http://etherx.jabber.org/streams'>\n
        \  For response stream headers in both client-to-server and server-to-\n   server
        communication, the receiving entity MUST include the 'from'\n   attribute
        and MUST set its value to one of the receiving entity's\n   FQDNs (which MAY
        be an FQDN other than that specified in the 'to'\n   attribute of the initial
        stream header, as described under\n   Section 4.9.1.3 and Section 4.9.3.6).\n
        \  R: <?xml version='1.0'?>\n      <stream:stream\n          from='im.example.com'\n
        \         id='++TR84Sm6A3hnt3Q065SnAbbk3Y='\n          to='juliet@im.example.com'\n
        \         version='1.0'\n          xml:lang='en'\n          xmlns='jabber:client'\n
        \         xmlns:stream='http://etherx.jabber.org/streams'>\n   Whether or
        not the 'from' attribute is included, each entity MUST\n   verify the identity
        of the other entity before exchanging XML stanzas\n   with it, as described
        under Section 13.5.\n      Interoperability Note: It is possible that implementations
        based\n      on [RFC3920] will not include the 'from' address on any stream\n
        \     headers (even ones whose confidentiality and integrity are\n      protected);
        an entity SHOULD be liberal in accepting such stream\n      headers.\n"
      title: 4.7.1.  from
    - contents:
      - "4.7.2.  to\n   For initial stream headers in both client-to-server and server-to-\n
        \  server communication, the initiating entity MUST include the 'to'\n   attribute
        and MUST set its value to a domainpart that the initiating\n   entity knows
        or expects the receiving entity to service.  (The same\n   information can
        be provided in other ways, such as a Server Name\n   Indication during TLS
        negotiation as described in [TLS-EXT].)\n   I: <?xml version='1.0'?>\n      <stream:stream\n
        \         from='juliet@im.example.com'\n          to='im.example.com'\n          version='1.0'\n
        \         xml:lang='en'\n          xmlns='jabber:client'\n          xmlns:stream='http://etherx.jabber.org/streams'>\n
        \  For response stream headers in client-to-server communication, if the\n
        \  client included a 'from' attribute in the initial stream header then\n
        \  the server MUST include a 'to' attribute in the response stream\n   header
        and MUST set its value to the bare JID specified in the 'from'\n   attribute
        of the initial stream header.  If the client did not\n   include a 'from'
        attribute in the initial stream header then the\n   server MUST NOT include
        a 'to' attribute in the response stream\n   header.\n   R: <?xml version='1.0'?>\n
        \     <stream:stream\n          from='im.example.com'\n          id='++TR84Sm6A3hnt3Q065SnAbbk3Y='\n
        \         to='juliet@im.example.com'\n          version='1.0'\n          xml:lang='en'\n
        \         xmlns='jabber:client'\n          xmlns:stream='http://etherx.jabber.org/streams'>\n
        \  For response stream headers in server-to-server communication, the\n   receiving
        entity MUST include a 'to' attribute in the response stream\n   header and
        MUST set its value to the domainpart specified in the\n   'from' attribute
        of the initial stream header.\n   R: <?xml version='1.0'?>\n      <stream:stream\n
        \         from='im.example.com'\n          id='g4qSvGvBxJ+xeAd7QKezOQJFFlw='\n
        \         to='example.net'\n          version='1.0'\n          xml:lang='en'\n
        \         xmlns='jabber:server'\n          xmlns:stream='http://etherx.jabber.org/streams'>\n
        \  Whether or not the 'to' attribute is included, each entity MUST\n   verify
        the identity of the other entity before exchanging XML stanzas\n   with it,
        as described under Section 13.5.\n      Interoperability Note: It is possible
        that implementations based\n      on [RFC3920] will not include the 'to' address
        on stream headers;\n      an entity SHOULD be liberal in accepting such stream
        headers.\n"
      title: 4.7.2.  to
    - contents:
      - "4.7.3.  id\n   The 'id' attribute specifies a unique identifier for the stream,\n
        \  called a \"stream ID\".  The stream ID MUST be generated by the\n   receiving
        entity when it sends a response stream header and MUST BE\n   unique within
        the receiving application (normally a server).\n      Security Warning: The
        stream ID MUST be both unpredictable and\n      non-repeating because it can
        be security-critical when reused by\n      an authentication mechanisms, as
        is the case for Server Dialback\n      [XEP-0220] and the \"XMPP 0.9\" authentication
        mechanism used before\n      RFC 3920 defined the use of SASL in XMPP; for
        recommendations\n      regarding randomness for security purposes, see [RANDOM].\n
        \  For initial stream headers, the initiating entity MUST NOT include\n   the
        'id' attribute; however, if the 'id' attribute is included, the\n   receiving
        entity MUST ignore it.\n   For response stream headers, the receiving entity
        MUST include the\n   'id' attribute.\n   R: <?xml version='1.0'?>\n      <stream:stream\n
        \         from='im.example.com'\n          id='++TR84Sm6A3hnt3Q065SnAbbk3Y='\n
        \         to='juliet@im.example.com'\n          version='1.0'\n          xml:lang='en'\n
        \         xmlns='jabber:client'\n          xmlns:stream='http://etherx.jabber.org/streams'>\n
        \     Interoperability Note: In RFC 3920, the text regarding inclusion\n      of
        the 'id' attribute was ambiguous, leading some implementations\n      to leave
        the attribute off the response stream header.\n"
      title: 4.7.3.  id
    - contents:
      - "4.7.4.  xml:lang\n   The 'xml:lang' attribute specifies an entity's preferred
        or default\n   language for any human-readable XML character data to be sent
        over\n   the stream (an XML stanza can also possess an 'xml:lang' attribute,\n
        \  as discussed under Section 8.1.5).  The syntax of this attribute is\n   defined
        in Section 2.12 of [XML]; in particular, the value of the\n   'xml:lang' attribute
        MUST conform to the NMTOKEN datatype (as defined\n   in Section 2.3 of [XML])
        and MUST conform to the language identifier\n   format defined in [LANGTAGS].\n
        \  For initial stream headers, the initiating entity SHOULD include the\n
        \  'xml:lang' attribute.\n   I: <?xml version='1.0'?>\n      <stream:stream\n
        \         from='juliet@im.example.com'\n          to='im.example.com'\n          version='1.0'\n
        \         xml:lang='en'\n          xmlns='jabber:client'\n          xmlns:stream='http://etherx.jabber.org/streams'>\n
        \  For response stream headers, the receiving entity MUST include the\n   'xml:lang'
        attribute.  The following rules apply:\n   o  If the initiating entity included
        an 'xml:lang' attribute in its\n      initial stream header and the receiving
        entity supports that\n      language in the human-readable XML character data
        that it\n      generates and sends to the initiating entity (e.g., in the
        <text/>\n      element for stream and stanza errors), the value of the 'xml:lang'\n
        \     attribute MUST be the identifier for the initiating entity's\n      preferred
        language (e.g., \"de-CH\").\n   o  If the receiving entity supports a language
        that matches the\n      initiating entity's preferred language according to
        the \"lookup\n      scheme\" specified in Section 3.4 of [LANGMATCH] (e.g.,
        \"de\"\n      instead of \"de-CH\"), then the value of the 'xml:lang' attribute\n
        \     SHOULD be the identifier for the matching language.\n   o  If the receiving
        entity does not support the initiating entity's\n      preferred language
        or a matching language according to the lookup\n      scheme (or if the initiating
        entity did not include the 'xml:lang'\n      attribute in its initial stream
        header), then the value of the\n      'xml:lang' attribute MUST be the identifier
        for the default\n      language of the receiving entity (e.g., \"en\").\n
        \  R: <?xml version='1.0'?>\n      <stream:stream\n          from='im.example.com'\n
        \         id='++TR84Sm6A3hnt3Q065SnAbbk3Y='\n          to='juliet@im.example.com'\n
        \         version='1.0'\n          xml:lang='en'\n          xmlns='jabber:client'\n
        \         xmlns:stream='http://etherx.jabber.org/streams'>\n   If the initiating
        entity included the 'xml:lang' attribute in its\n   initial stream header,
        the receiving entity SHOULD remember that\n   value as the default xml:lang
        for all stanzas sent by the initiating\n   entity over the current stream.
        \ As described under Section 8.1.5,\n   the initiating entity MAY include
        the 'xml:lang' attribute in any XML\n   stanzas it sends over the stream.
        \ If the initiating entity does not\n   include the 'xml:lang' attribute in
        any such stanza, the receiving\n   entity SHOULD add the 'xml:lang' attribute
        to the stanza when routing\n   it to a remote server or delivering it to a
        connected client, where\n   the value of the attribute MUST be the identifier
        for the language\n   preferred by the initiating entity (even if the receiving
        entity does\n   not support that language for human-readable XML character
        data it\n   generates and sends to the initiating entity, such as in stream
        or\n   stanza errors).  If the initiating entity includes the 'xml:lang'\n
        \  attribute in any such stanza, the receiving entity MUST NOT modify or\n
        \  delete it when routing it to a remote server or delivering it to a\n   connected
        client.\n"
      title: 4.7.4.  xml:lang
    - contents:
      - "4.7.5.  version\n   The inclusion of the version attribute set to a value
        of at least\n   \"1.0\" signals support for the stream-related protocols defined
        in\n   this specification, including TLS negotiation (Section 5), SASL\n   negotiation
        (Section 6), stream features (Section 4.3.2), and stream\n   errors (Section
        4.9).\n   The version of XMPP specified in this specification is \"1.0\";
        in\n   particular, XMPP 1.0 encapsulates the stream-related protocols as\n
        \  well as the basic semantics of the three defined XML stanza types\n   (<message/>,
        <presence/>, and <iq/> as described under Sections\n   8.2.1, 8.2.2, and 8.2.3,
        respectively).\n   The numbering scheme for XMPP versions is \"<major>.<minor>\".
        \ The\n   major and minor numbers MUST be treated as separate integers and
        each\n   number MAY be incremented higher than a single digit.  Thus, \"XMPP\n
        \  2.4\" would be a lower version than \"XMPP 2.13\", which in turn would\n
        \  be lower than \"XMPP 12.3\".  Leading zeros (e.g., \"XMPP 6.01\") MUST
        be\n   ignored by recipients and MUST NOT be sent.\n   The major version number
        will be incremented only if the stream and\n   stanza formats or obligatory
        actions have changed so dramatically\n   that an older version entity would
        not be able to interoperate with a\n   newer version entity if it simply ignored
        the elements and attributes\n   it did not understand and took the actions
        defined in the older\n   specification.\n   The minor version number will
        be incremented only if significant new\n   capabilities have been added to
        the core protocol (e.g., a newly\n   defined value of the 'type' attribute
        for message, presence, or IQ\n   stanzas).  The minor version number MUST
        be ignored by an entity with\n   a smaller minor version number, but MAY be
        used for informational\n   purposes by the entity with the larger minor version
        number (e.g.,\n   the entity with the larger minor version number would simply
        note\n   that its correspondent would not be able to understand that value
        of\n   the 'type' attribute and therefore would not send it).\n   The following
        rules apply to the generation and handling of the\n   'version' attribute
        within stream headers:\n   1.  The initiating entity MUST set the value of
        the 'version'\n       attribute in the initial stream header to the highest
        version\n       number it supports (e.g., if the highest version number it\n
        \      supports is that defined in this specification, it MUST set the\n       value
        to \"1.0\").\n   2.  The receiving entity MUST set the value of the 'version'\n
        \      attribute in the response stream header to either the value\n       supplied
        by the initiating entity or the highest version number\n       supported by
        the receiving entity, whichever is lower.  The\n       receiving entity MUST
        perform a numeric comparison on the major\n       and minor version numbers,
        not a string match on\n       \"<major>.<minor>\".\n   3.  If the version
        number included in the response stream header is\n       at least one major
        version lower than the version number included\n       in the initial stream
        header and newer version entities cannot\n       interoperate with older version
        entities as described, the\n       initiating entity SHOULD close the stream
        with an <unsupported-\n       version/> stream error (Section 4.9.3.25).\n
        \  4.  If either entity receives a stream header with no 'version'\n       attribute,
        the entity MUST consider the version supported by the\n       other entity
        to be \"0.9\" and SHOULD NOT include a 'version'\n       attribute in the
        response stream header.\n"
      title: 4.7.5.  version
    - contents:
      - "4.7.6.  Summary of Stream Attributes\n   The following table summarizes the
        attributes of the root <stream/>\n   element.\n   +----------+--------------------------+-------------------------+\n
        \  |          | initiating to receiving  | receiving to initiating |\n   +----------+--------------------------+-------------------------+\n
        \  | to       | JID of receiver          | JID of initiator        |\n   |
        from     | JID of initiator         | JID of receiver         |\n   | id       |
        ignored                  | stream identifier       |\n   | xml:lang | default
        language         | default language        |\n   | version  | XMPP 1.0+ supported
        \     | XMPP 1.0+ supported     |\n   +----------+--------------------------+-------------------------+\n
        \                       Figure 4: Stream Attributes\n"
      title: 4.7.6.  Summary of Stream Attributes
    title: 4.7.  Stream Attributes
  - contents:
    - "4.8.  XML Namespaces\n   Readers are referred to the specification of XML namespaces\n
      \  [XML-NAMES] for a full understanding of the concepts used in this\n   section,
      especially the concept of a \"default namespace\" as provided\n   in Section
      3 and Section 6.2 of that specification.\n"
    - contents:
      - "4.8.1.  Stream Namespace\n   The root <stream/> element (\"stream header\")
        MUST be qualified by the\n   namespace 'http://etherx.jabber.org/streams'
        (the \"stream\n   namespace\").  If this rule is violated, the entity that
        receives the\n   offending stream header MUST close the stream with a stream
        error,\n   which SHOULD be <invalid-namespace/> (Section 4.9.3.10), although\n
        \  some existing implementations send <bad-format/> (Section 4.9.3.1)\n   instead.\n"
      title: 4.8.1.  Stream Namespace
    - contents:
      - "4.8.2.  Content Namespace\n   An entity MAY declare a \"content namespace\"
        as the default namespace\n   for data sent over the stream (i.e., data other
        than elements\n   qualified by the stream namespace).  If so, (1) the content
        namespace\n   MUST be other than the stream namespace, and (2) the content\n
        \  namespace MUST be the same for the initial stream and the response\n   stream
        so that both streams are qualified consistently.  The content\n   namespace
        applies to all first-level child elements sent over the\n   stream unless
        explicitly qualified by another namespace (i.e., the\n   content namespace
        is the default namespace).\n   Alternatively (i.e., instead of declaring the
        content namespace as\n   the default namespace), an entity MAY explicitly
        qualify the\n   namespace for each first-level child element of the stream,
        using so-\n   called \"prefix-free canonicalization\".  These two styles are
        shown in\n   the following examples.\n   When a content namespace is declared
        as the default namespace, in\n   rough outline a stream will look something
        like the following.\n   <stream:stream\n       from='juliet@im.example.com'\n
        \      to='im.example.com'\n       version='1.0'\n       xml:lang='en'\n       xmlns='jabber:client'\n
        \      xmlns:stream='http://etherx.jabber.org/streams'>\n     <message>\n
        \      <body>foo</body>\n     </message>\n   </stream:stream>\n   When a content
        namespace is not declared as the default namespace and\n   so-called \"prefix-free
        canonicalization\" is used instead, in rough\n   outline a stream will look
        something like the following.\n   <stream\n       from='juliet@im.example.com'\n
        \      to='im.example.com'\n       version='1.0'\n       xml:lang='en'\n       xmlns='http://etherx.jabber.org/streams'>\n
        \    <message xmlns='jabber:client'>\n       <body>foo</body>\n     </message>\n
        \  </stream>\n   Traditionally, most XMPP implementations have used the content-\n
        \  namespace-as-default-namespace style rather than the prefix-free\n   canonicalization
        style for stream headers; however, both styles are\n   acceptable since they
        are semantically equivalent.\n"
      title: 4.8.2.  Content Namespace
    - contents:
      - "4.8.3.  XMPP Content Namespaces\n   XMPP as defined in this specification
        uses two content namespaces:\n   'jabber:client' and 'jabber:server'.  These
        namespaces are nearly\n   identical but are used in different contexts (client-to-server\n
        \  communication for 'jabber:client' and server-to-server communication\n
        \  for 'jabber:server').  The only difference between the two is that\n   the
        'to' and 'from' attributes are OPTIONAL on stanzas sent over XML\n   streams
        qualified by the 'jabber:client' namespace, whereas they are\n   REQUIRED
        on stanzas sent over XML streams qualified by the 'jabber:\n   server' namespace.
        \ Support for these content namespaces implies\n   support for the common
        attributes (Section 8.1) and basic semantics\n   (Section 8.2) of all three
        core stanza types (message, presence, and\n   IQ).\n   An implementation MAY
        support content namespaces other than 'jabber:\n   client' or 'jabber:server'.
        \ However, because such namespaces would\n   define applications other than
        XMPP, they are to be defined in\n   separate specifications.\n   An implementation
        MAY refuse to support any other content namespaces\n   as default namespaces.
        \ If an entity receives a first-level child\n   element qualified by a content
        namespace it does not support, it MUST\n   close the stream with an <invalid-namespace/>
        stream error\n   (Section 4.9.3.10).\n   Client implementations MUST support
        the 'jabber:client' content\n   namespace as a default namespace.  The 'jabber:server'
        content\n   namespace is out of scope for an XMPP client, and a client MUST
        NOT\n   send stanzas qualified by the 'jabber:server' namespace.\n   Server
        implementations MUST support as default content namespaces\n   both the 'jabber:client'
        namespace (when the stream is used for\n   communication between a client
        and a server) and the 'jabber:server'\n   namespace (when the stream is used
        for communication between two\n   servers).  When communicating with a connected
        client, a server MUST\n   NOT send stanzas qualified by the 'jabber:server'
        namespace; when\n   communicating with a peer server, a server MUST NOT send
        stanzas\n   qualified by the 'jabber:client' namespace.\n      Implementation
        Note: Because a client sends stanzas over a stream\n      whose content namespace
        is 'jabber:client', if a server routes to\n      a peer server a stanza it
        has received from a connected client\n      then it needs to \"re-scope\"
        the stanza so that its content\n      namespace is 'jabber:server'.  Similarly,
        if a server delivers to\n      a connected client a stanza it has received
        from a peer server\n      then it needs to \"re-scope\" the stanza so that
        its content\n      namespace is 'jabber:client'.  This rule applies to XML
        stanzas as\n      defined under Section 4.1 (i.e., a first-level <message/>,\n
        \     <presence/>, or <iq/> element qualified by the 'jabber:client' or\n
        \     'jabber:server' namespace), and by namespace inheritance to all\n      child
        elements of a stanza.  However, the rule does not apply to\n      elements
        qualified by namespaces other than 'jabber:client' and\n      'jabber:server'
        nor to any children of such elements (e.g., a\n      <message/> element contained
        within an extension element\n      (Section 8.4) for reporting purposes).
        \ Although it is not\n      forbidden for an entity to generate stanzas in
        which an extension\n      element contains a child element qualified by the
        'jabber:client'\n      or 'jabber:server' namespace, existing implementations
        handle such\n      stanzas inconsistently; therefore, implementers are advised
        to\n      weigh the likely lack of interoperability against the possible\n
        \     utility of such stanzas.  Finally, servers are advised to apply\n      stanza
        re-scoping to other stream connection methods and\n      alternative XMPP
        connection methods, such as those specified in\n      [XEP-0124], [XEP-0206],
        [XEP-0114], and [XEP-0225].\n"
      title: 4.8.3.  XMPP Content Namespaces
    - contents:
      - "4.8.4.  Other Namespaces\n   Either party to a stream MAY send data qualified
        by namespaces other\n   than the content namespace and the stream namespace.
        \ For example,\n   this is how data related to TLS negotiation and SASL negotiation
        are\n   exchanged, as well as XMPP extensions such as Stream Management\n
        \  [XEP-0198] and Server Dialback [XEP-0220].\n      Interoperability Note:
        For historical reasons, some server\n      implementations expect a declaration
        of the 'jabber:server:\n      dialback' namespace on server-to-server streams,
        as explained in\n      [XEP-0220].\n   However, an XMPP server MUST NOT route
        or deliver data received over\n   an input stream if that data is (a) qualified
        by another namespace\n   and (b) addressed to an entity other than the server,
        unless the\n   other party to the output stream over which the server would
        send the\n   data has explicitly negotiated or advertised support for receiving\n
        \  arbitrary data from the server.  This rule is included because XMPP\n   is
        designed for the exchange of XML stanzas (not arbitrary XML data),\n   and
        because allowing an entity to send arbitrary data to other\n   entities could
        significantly increase the potential for exchanging\n   malicious information.
        \ As an example of this rule, the server\n   hosting the example.net domain
        would not route the following first-\n   level XML element from <romeo@example.net>
        to <juliet@example.com>:\n     <ns1:foo xmlns:ns1='http://example.org/ns1'\n
        \             from='romeo@example.net/resource1'\n              to='juliet@example.com'>\n
        \      <ns1:bar/>\n     </ns1:foo>\n   This rule also applies to first-level
        elements that look like stanzas\n   but that are improperly namespaced and
        therefore really are not\n   stanzas at all (see also Section 4.8.5), for
        example:\n     <ns2:message xmlns:ns2='http://example.org/ns2'\n                  from='romeo@example.net/resource1'\n
        \                 to='juliet@example.com'>\n       <body>hi</body>\n     </ns2:message>\n
        \  Upon receiving arbitrary first-level XML elements over an input\n   stream,
        a server MUST either ignore the data or close the stream with\n   a stream
        error, which SHOULD be <unsupported-stanza-type/>\n   (Section 4.9.3.24).\n"
      title: 4.8.4.  Other Namespaces
    - contents:
      - "4.8.5.  Namespace Declarations and Prefixes\n   Because the content namespace
        is other than the stream namespace, if\n   a content namespace is declared
        as the default namespace then the\n   following statements are true:\n   1.
        \ The stream header needs to contain a namespace declaration for\n       both
        the content namespace and the stream namespace.\n   2.  The stream namespace
        declaration needs to include a namespace\n       prefix for the stream namespace.\n
        \     Interoperability Note: For historical reasons, an implementation\n      MAY
        accept only the prefix 'stream' for the stream namespace\n      (resulting
        in prefixed names such as <stream:stream> and <stream:\n      features>);
        this specification retains that allowance from\n      [RFC3920] for the purpose
        of backward compatibility.\n      Implementations are advised that using a
        prefix other than\n      'stream' for the stream namespace might result in
        interoperability\n      problems.  If an entity receives a stream header with
        a stream\n      namespace prefix it does not accept, it MUST close the stream
        with\n      a stream error, which SHOULD be <bad-namespace-prefix/>\n      (Section
        4.9.3.2), although some existing implementations send\n      <bad-format/>
        (Section 4.9.3.1) instead.\n   An implementation MUST NOT generate namespace
        prefixes for elements\n   qualified by the content namespace (i.e., the default
        namespace for\n   data sent over the stream) if the content namespace is 'jabber:\n
        \  client' or 'jabber:server'.  For example, the following is illegal:\n   <stream:stream\n
        \      from='juliet@im.example.com'\n       to='im.example.com'\n       version='1.0'\n
        \      xml:lang='en'\n       xmlns='jabber:client'\n       xmlns:stream='http://etherx.jabber.org/streams'>\n
        \    <foo:message xmlns:foo='jabber:client'>\n       <foo:body>foo</foo:body>\n
        \    </foo:message>\n   An XMPP entity SHOULD NOT accept data that violates
        this rule (in\n   particular, an XMPP server MUST NOT route or deliver such
        data to\n   another entity without first correcting the error); instead it
        SHOULD\n   either ignore the data or close the stream with a stream error,
        which\n   SHOULD be <bad-namespace-prefix/> (Section 4.9.3.2).\n   Namespaces
        declared in a stream header MUST apply only to that stream\n   (e.g., the
        'jabber:server:dialback' namespace used in Server Dialback\n   [XEP-0220]).
        \ In particular, because XML stanzas intended for routing\n   or delivery
        over streams with other entities will lose the namespace\n   context declared
        in the header of the stream in which those stanzas\n   originated, namespaces
        for extended content within such stanzas MUST\n   NOT be declared in that
        stream header (see also Section 8.4).  If\n   either party to a stream declares
        such namespaces, the other party to\n   the stream SHOULD close the stream
        with an <invalid-namespace/>\n   stream error (Section 4.9.3.10).  In any
        case, an entity MUST ensure\n   that such namespaces are properly declared
        (according to this\n   section) when routing or delivering stanzas from an
        input stream to\n   an output stream.\n"
      title: 4.8.5.  Namespace Declarations and Prefixes
    title: 4.8.  XML Namespaces
  - contents:
    - "4.9.  Stream Errors\n   The root stream element MAY contain an <error/> child
      element that is\n   qualified by the stream namespace.  The error child SHALL
      be sent by\n   a compliant entity if it perceives that a stream-level error
      has\n   occurred.\n"
    - contents:
      - "4.9.1.  Rules\n   The following rules apply to stream-level errors.\n"
      - contents:
        - "4.9.1.1.  Stream Errors Are Unrecoverable\n   Stream-level errors are unrecoverable.
          \ Therefore, if an error occurs\n   at the level of the stream, the entity
          that detects the error MUST\n   send an <error/> element with an appropriate
          child element specifying\n   the error condition and then immediately close
          the stream as\n   described under Section 4.4.\n   C: <message><body>No
          closing tag!</message>\n   S: <stream:error>\n        <not-well-formed\n
          \           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n      </stream:error>\n
          \     </stream:stream>\n   The entity that receives the stream error then
          SHALL close the stream\n   as explained under Section 4.4.\n   C: </stream:stream>\n"
        title: 4.9.1.1.  Stream Errors Are Unrecoverable
      - contents:
        - "4.9.1.2.  Stream Errors Can Occur During Setup\n   If the error is triggered
          by the initial stream header, the receiving\n   entity MUST still send the
          opening <stream> tag, include the <error/>\n   element as a child of the
          stream element, and send the closing\n   </stream> tag (preferably in the
          same TCP packet).\n   C: <?xml version='1.0'?>\n      <stream:stream\n          from='juliet@im.example.com'\n
          \         to='im.example.com'\n          version='1.0'\n          xml:lang='en'\n
          \         xmlns='jabber:client'\n          xmlns:stream='http://wrong.namespace.example.org/'>\n
          \  S: <?xml version='1.0'?>\n      <stream:stream\n          from='im.example.com'\n
          \         id='++TR84Sm6A3hnt3Q065SnAbbk3Y='\n          to='juliet@im.example.com'\n
          \         version='1.0'\n          xml:lang='en'\n          xmlns='jabber:client'\n
          \         xmlns:stream='http://etherx.jabber.org/streams'>\n      <stream:error>\n
          \       <invalid-namespace\n            xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n
          \     </stream:error>\n      </stream:stream>\n"
        title: 4.9.1.2.  Stream Errors Can Occur During Setup
      - contents:
        - "4.9.1.3.  Stream Errors When the Host Is Unspecified or Unknown\n   If
          the initiating entity provides no 'to' attribute or provides an\n   unknown
          host in the 'to' attribute and the error occurs during stream\n   setup,
          the value of the 'from' attribute returned by the receiving\n   entity in
          the stream header sent before closing the stream MUST be\n   either an authoritative
          FQDN for the receiving entity or the empty\n   string.\n   C: <?xml version='1.0'?>\n
          \     <stream:stream\n          from='juliet@im.example.com'\n          to='unknown.host.example.com'\n
          \         version='1.0'\n          xml:lang='en'\n          xmlns='jabber:client'\n
          \         xmlns:stream='http://etherx.jabber.org/streams'>\n   S: <?xml
          version='1.0'?>\n      <stream:stream\n          from='im.example.com'\n
          \         id='++TR84Sm6A3hnt3Q065SnAbbk3Y='\n          to='juliet@im.example.com'\n
          \         version='1.0'\n          xml:lang='en'\n          xmlns='jabber:client'\n
          \         xmlns:stream='http://etherx.jabber.org/streams'>\n      <stream:error>\n
          \       <host-unknown\n            xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n
          \     </stream:error>\n      </stream:stream>\n"
        title: 4.9.1.3.  Stream Errors When the Host Is Unspecified or Unknown
      - contents:
        - "4.9.1.4.  Where Stream Errors Are Sent\n   When two TCP connections are
          used between the initiating entity and\n   the receiving entity (one in
          each direction) rather than using a\n   single bidirectional connection,
          the following rules apply:\n   o  Stream-level errors related to the initial
          stream are returned by\n      the receiving entity on the response stream
          via the same TCP\n      connection.\n   o  Stanza errors triggered by outbound
          stanzas sent from the\n      initiating entity over the initial stream via
          the same TCP\n      connection are returned by the receiving entity on the
          response\n      stream via the other (\"return\") TCP connection, since
          they are\n      inbound stanzas from the perspective of the initiating entity.\n"
        title: 4.9.1.4.  Where Stream Errors Are Sent
      title: 4.9.1.  Rules
    - contents:
      - "4.9.2.  Syntax\n   The syntax for stream errors is as follows, where XML
        data shown\n   within the square brackets '[' and ']' is OPTIONAL.\n   <stream:error>\n
        \    <defined-condition xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n     [<text
        xmlns='urn:ietf:params:xml:ns:xmpp-streams'\n            xml:lang='langcode'>\n
        \       OPTIONAL descriptive text\n     </text>]\n     [OPTIONAL application-specific
        condition element]\n   </stream:error>\n   The \"defined-condition\" MUST
        correspond to one of the stream error\n   conditions defined under Section
        4.9.3.  However, because additional\n   error conditions might be defined
        in the future, if an entity\n   receives a stream error condition that it
        does not understand then it\n   MUST treat the unknown condition as equivalent
        to <undefined-\n   condition/> (Section 4.9.3.21).  If the designers of an
        XMPP protocol\n   extension or the developers of an XMPP implementation need
        to\n   communicate a stream error condition that is not defined in this\n
        \  specification, they can do so by defining an application-specific\n   error
        condition element qualified by an application-specific\n   namespace.\n   The
        <error/> element:\n   o  MUST contain a child element corresponding to one
        of the defined\n      stream error conditions (Section 4.9.3); this element
        MUST be\n      qualified by the 'urn:ietf:params:xml:ns:xmpp-streams' namespace.\n
        \  o  MAY contain a <text/> child element containing XML character data\n
        \     that describes the error in more detail; this element MUST be\n      qualified
        by the 'urn:ietf:params:xml:ns:xmpp-streams' namespace\n      and SHOULD possess
        an 'xml:lang' attribute specifying the natural\n      language of the XML
        character data.\n   o  MAY contain a child element for an application-specific
        error\n      condition; this element MUST be qualified by an application-\n
        \     defined namespace, and its structure is defined by that namespace\n
        \     (see Section 4.9.4).\n   The <text/> element is OPTIONAL.  If included,
        it MUST be used only\n   to provide descriptive or diagnostic information
        that supplements the\n   meaning of a defined condition or application-specific
        condition.  It\n   MUST NOT be interpreted programmatically by an application.
        \ It MUST\n   NOT be used as the error message presented to a human user,
        but MAY\n   be shown in addition to the error message associated with the
        defined\n   condition element (and, optionally, the application-specific\n
        \  condition element).\n"
      title: 4.9.2.  Syntax
    - contents:
      - "4.9.3.  Defined Stream Error Conditions\n   The following stream-level error
        conditions are defined.\n"
      - contents:
        - "4.9.3.1.  bad-format\n   The entity has sent XML that cannot be processed.\n
          \  (In the following example, the client sends an XMPP message that is\n
          \  not well-formed XML, which alternatively might trigger a <not-well-\n
          \  formed/> stream error (Section 4.9.3.13).)\n   C: <message>\n        <body>No
          closing tag!\n      </message>\n   S: <stream:error>\n        <bad-format\n
          \           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n      </stream:error>\n
          \     </stream:stream>\n   This error can be used instead of the more specific
          XML-related\n   errors, such as <bad-namespace-prefix/>, <invalid-xml/>,
          <not-well-\n   formed/>, <restricted-xml/>, and <unsupported-encoding/>.
          \ However,\n   the more specific errors are RECOMMENDED.\n"
        title: 4.9.3.1.  bad-format
      - contents:
        - "4.9.3.2.  bad-namespace-prefix\n   The entity has sent a namespace prefix
          that is unsupported, or has\n   sent no namespace prefix on an element that
          needs such a prefix (see\n   Section 11.2).\n   (In the following example,
          the client specifies a namespace prefix of\n   \"foobar\" for the XML stream
          namespace.)\n   C: <?xml version='1.0'?>\n      <foobar:stream\n          from='juliet@im.example.com'\n
          \         to='im.example.com'\n          version='1.0'\n          xmlns='jabber:client'\n
          \         xmlns:foobar='http://etherx.jabber.org/streams'>\n   S: <?xml
          version='1.0'?>\n      <stream:stream\n          from='im.example.com'\n
          \         id='++TR84Sm6A3hnt3Q065SnAbbk3Y='\n          to='juliet@im.example.com'\n
          \         version='1.0'\n          xml:lang='en'\n          xmlns='jabber:client'\n
          \         xmlns:stream='http://etherx.jabber.org/streams'>\n      <stream:error>\n
          \       <bad-namespace-prefix\n            xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n
          \     </stream:error>\n      </stream:stream>\n"
        title: 4.9.3.2.  bad-namespace-prefix
      - contents:
        - "4.9.3.3.  conflict\n   The server either (1) is closing the existing stream
          for this entity\n   because a new stream has been initiated that conflicts
          with the\n   existing stream, or (2) is refusing a new stream for this entity\n
          \  because allowing the new stream would conflict with an existing\n   stream
          (e.g., because the server allows only a certain number of\n   connections
          from the same IP address or allows only one server-to-\n   server stream
          for a given domain pair as a way of helping to ensure\n   in-order processing
          as described under Section 10.1).\n   C: <?xml version='1.0'?>\n      <stream:stream\n
          \         from='juliet@im.example.com'\n          to='im.example.com'\n
          \         version='1.0'\n          xmlns='jabber:client'\n          xmlns:stream='http://etherx.jabber.org/streams'>\n
          \  S: <?xml version='1.0'?>\n      <stream:stream\n          from='im.example.com'\n
          \         id='++TR84Sm6A3hnt3Q065SnAbbk3Y='\n          to='juliet@im.example.com'\n
          \         version='1.0'\n          xml:lang='en'\n          xmlns='jabber:client'\n
          \         xmlns:stream='http://etherx.jabber.org/streams'>\n      <stream:error>\n
          \       <conflict\n            xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n
          \     </stream:error>\n      </stream:stream>\n   If a client receives a
          <conflict/> stream error (Section 4.9.3.3),\n   during the resource binding
          aspect of its reconnection attempt it\n   MUST NOT blindly request the resourcepart
          it used during the former\n   session but instead MUST choose a different
          resourcepart; details are\n   provided under Section 7.\n"
        title: 4.9.3.3.  conflict
      - contents:
        - "4.9.3.4.  connection-timeout\n   One party is closing the stream because
          it has reason to believe that\n   the other party has permanently lost the
          ability to communicate over\n   the stream.  The lack of ability to communicate
          can be discovered\n   using various methods, such as whitespace keepalives
          as specified\n   under Section 4.4, XMPP-level pings as defined in [XEP-0199],
          and\n   XMPP Stream Management as defined in [XEP-0198].\n   P: <stream:error>\n
          \       <connection-timeout\n            xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n
          \     </stream:error>\n      </stream:stream>\n      Interoperability Note:
          RFC 3920 specified that the <connection-\n      timeout/> stream error (Section
          4.9.3.4) is to be used if the peer\n      has not generated any traffic
          over the stream for some period of\n      time.  That behavior is no longer
          recommended; instead, the error\n      SHOULD be used only if the connected
          client or peer server has not\n      responded to data sent over the stream.\n"
        title: 4.9.3.4.  connection-timeout
      - contents:
        - "4.9.3.5.  host-gone\n   The value of the 'to' attribute provided in the
          initial stream header\n   corresponds to an FQDN that is no longer serviced
          by the receiving\n   entity.\n   (In the following example, the peer specifies
          a 'to' address of\n   \"foo.im.example.com\" when connecting to the \"im.example.com\"
          server,\n   but the server no longer hosts a service at that address.)\n
          \  P: <?xml version='1.0'?>\n      <stream:stream\n          from='example.net'\n
          \         to='foo.im.example.com'\n          version='1.0'\n          xmlns='jabber:server'\n
          \         xmlns:stream='http://etherx.jabber.org/streams'>\n   S: <?xml
          version='1.0'?>\n      <stream:stream\n          from='im.example.com'\n
          \         id='g4qSvGvBxJ+xeAd7QKezOQJFFlw='\n          to='example.net'\n
          \         version='1.0'\n          xml:lang='en'\n          xmlns='jabber:server'\n
          \         xmlns:stream='http://etherx.jabber.org/streams'>\n      <stream:error>\n
          \       <host-gone\n            xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n
          \     </stream:error>\n      </stream:stream>\n"
        title: 4.9.3.5.  host-gone
      - contents:
        - "4.9.3.6.  host-unknown\n   The value of the 'to' attribute provided in
          the initial stream header\n   does not correspond to an FQDN that is serviced
          by the receiving\n   entity.\n   (In the following example, the peer specifies
          a 'to' address of\n   \"example.org\" when connecting to the \"im.example.com\"
          server, but the\n   server knows nothing of that address.)\n   P: <?xml
          version='1.0'?>\n      <stream:stream\n          from='example.net'\n          to='example.org'\n
          \         version='1.0'\n          xmlns='jabber:server'\n          xmlns:stream='http://etherx.jabber.org/streams'>\n
          \  S: <?xml version='1.0'?>\n      <stream:stream\n          from='im.example.com'\n
          \         id='g4qSvGvBxJ+xeAd7QKezOQJFFlw='\n          to='example.net'\n
          \         version='1.0'\n          xml:lang='en'\n          xmlns='jabber:server'\n
          \         xmlns:stream='http://etherx.jabber.org/streams'>\n      <stream:error>\n
          \       <host-unknown\n            xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n
          \     </stream:error>\n      </stream:stream>\n"
        title: 4.9.3.6.  host-unknown
      - contents:
        - "4.9.3.7.  improper-addressing\n   A stanza sent between two servers lacks
          a 'to' or 'from' attribute,\n   the 'from' or 'to' attribute has no value,
          or the value violates the\n   rules for XMPP addresses [XMPP-ADDR].\n   (In
          the following example, the peer sends a stanza without a 'to'\n   address
          over a server-to-server stream.)\n   P: <message from='juliet@im.example.com'>\n
          \       <body>Wherefore art thou?</body>\n      </message>\n   S: <stream:error>\n
          \       <improper-addressing\n            xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n
          \     </stream:error>\n      </stream:stream>\n"
        title: 4.9.3.7.  improper-addressing
      - contents:
        - "4.9.3.8.  internal-server-error\n   The server has experienced a misconfiguration
          or other internal error\n   that prevents it from servicing the stream.\n
          \  S: <stream:error>\n        <internal-server-error\n            xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n
          \     </stream:error>\n      </stream:stream>\n"
        title: 4.9.3.8.  internal-server-error
      - contents:
        - "4.9.3.9.  invalid-from\n   The data provided in a 'from' attribute does
          not match an authorized\n   JID or validated domain as negotiated (1) between
          two servers using\n   SASL or Server Dialback, or (2) between a client and
          a server via\n   SASL authentication and resource binding.\n   (In the following
          example, a peer that has authenticated only as\n   \"example.net\" attempts
          to send a stanza from an address at\n   \"example.org\".)\n   P: <message
          from='romeo@example.org' to='juliet@im.example.com'>\n        <body>Neither,
          fair saint, if either thee dislike.</body>\n      </message>\n   S: <stream:error>\n
          \       <invalid-from\n            xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n
          \     </stream:error>\n      </stream:stream>\n"
        title: 4.9.3.9.  invalid-from
      - contents:
        - "4.9.3.10.  invalid-namespace\n   The stream namespace name is something
          other than\n   \"http://etherx.jabber.org/streams\" (see Section 11.2) or
          the content\n   namespace declared as the default namespace is not supported
          (e.g.,\n   something other than \"jabber:client\" or \"jabber:server\").\n
          \  (In the following example, the client specifies a namespace of\n   'http://wrong.namespace.example.org/'
          for the stream.)\n   C: <?xml version='1.0'?>\n      <stream:stream\n          from='juliet@im.example.com'\n
          \         to='im.example.com'\n          version='1.0'\n          xmlns='jabber:client'\n
          \         xmlns:stream='http://wrong.namespace.example.org/'>\n   S: <?xml
          version='1.0'?>\n      <stream:stream\n          from='im.example.com'\n
          \         id='++TR84Sm6A3hnt3Q065SnAbbk3Y='\n          to='juliet@im.example.com'\n
          \         version='1.0'\n          xml:lang='en'\n          xmlns='jabber:client'\n
          \         xmlns:stream='http://etherx.jabber.org/streams'>\n      <stream:error>\n
          \       <invalid-namespace\n            xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n
          \     </stream:error>\n      </stream:stream>\n"
        title: 4.9.3.10.  invalid-namespace
      - contents:
        - "4.9.3.11.  invalid-xml\n   The entity has sent invalid XML over the stream
          to a server that\n   performs validation (see Section 11.4).\n   (In the
          following example, the peer attempts to send an IQ stanza of\n   type \"subscribe\",
          but the XML schema defines no such value for the\n   'type' attribute.)\n
          \  P: <iq from='example.net'\n          id='l3b1vs75'\n          to='im.example.com'\n
          \         type='subscribe'>\n        <ping xmlns='urn:xmpp:ping'/>\n      </iq>\n
          \  S: <stream:error>\n        <invalid-xml\n            xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n
          \     </stream:error>\n      </stream:stream>\n"
        title: 4.9.3.11.  invalid-xml
      - contents:
        - "4.9.3.12.  not-authorized\n   The entity has attempted to send XML stanzas
          or other outbound data\n   before the stream has been authenticated, or
          otherwise is not\n   authorized to perform an action related to stream negotiation;
          the\n   receiving entity MUST NOT process the offending data before sending\n
          \  the stream error.\n   (In the following example, the client attempts
          to send XML stanzas\n   before authenticating with the server.)\n   C: <?xml
          version='1.0'?>\n      <stream:stream\n          from='juliet@im.example.com'\n
          \         to='im.example.com'\n          version='1.0'\n          xmlns='jabber:client'\n
          \         xmlns:stream='http://etherx.jabber.org/streams'>\n   S: <?xml
          version='1.0'?>\n      <stream:stream\n          from='im.example.com'\n
          \         id='++TR84Sm6A3hnt3Q065SnAbbk3Y='\n          to='juliet@im.example.com'\n
          \         version='1.0'\n          xml:lang='en'\n          xmlns='jabber:client'\n
          \         xmlns:stream='http://etherx.jabber.org/streams'>\n   C: <message
          to='romeo@example.net'>\n        <body>Wherefore art thou?</body>\n      </message>\n
          \  S: <stream:error>\n        <not-authorized\n            xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n
          \     </stream:error>\n      </stream:stream>\n"
        title: 4.9.3.12.  not-authorized
      - contents:
        - "4.9.3.13.  not-well-formed\n   The initiating entity has sent XML that
          violates the well-formedness\n   rules of [XML] or [XML-NAMES].\n   (In
          the following example, the client sends an XMPP message that is\n   not
          namespace-well-formed.)\n   C: <message>\n        <foo:body>What is this
          foo?</foo:body>\n      </message>\n   S: <stream:error>\n        <not-well-formed\n
          \           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n      </stream:error>\n
          \     </stream:stream>\n      Interoperability Note: In RFC 3920, the name
          of this error\n      condition was \"xml-not-well-formed\" instead of \"not-well-formed\".\n
          \     The name was changed because the element name <xml-not-well-\n      formed/>
          violates the constraint from Section 3 of [XML] that\n      \"names beginning
          with a match to (('X'|'x')('M'|'m')('L'|'l')) are\n      reserved for standardization
          in this or future versions of this\n      specification\".\n"
        title: 4.9.3.13.  not-well-formed
      - contents:
        - "4.9.3.14.  policy-violation\n   The entity has violated some local service
          policy (e.g., a stanza\n   exceeds a configured size limit); the server
          MAY choose to specify\n   the policy in the <text/> element or in an application-specific\n
          \  condition element.\n   (In the following example, the client sends an
          XMPP message that is\n   too large according to the server's local service
          policy.)\n   C: <message to='juliet@im.example.com' id='foo'>\n        <body>[
          ... the-emacs-manual ... ]</body>\n      </message>\n   S: <stream:error>\n
          \       <policy-violation\n            xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n
          \       <stanza-too-big xmlns='urn:xmpp:errors'/>\n      </stream:error>\n
          \  S: </stream:stream>\n"
        title: 4.9.3.14.  policy-violation
      - contents:
        - "4.9.3.15.  remote-connection-failed\n   The server is unable to properly
          connect to a remote entity that is\n   needed for authentication or authorization
          (e.g., in certain\n   scenarios related to Server Dialback [XEP-0220]);
          this condition is\n   not to be used when the cause of the error is within
          the\n   administrative domain of the XMPP service provider, in which case
          the\n   <internal-server-error/> condition is more appropriate.\n   C: <?xml
          version='1.0'?>\n      <stream:stream\n          from='juliet@im.example.com'\n
          \         to='im.example.com'\n          version='1.0'\n          xmlns='jabber:client'\n
          \         xmlns:stream='http://etherx.jabber.org/streams'>\n   S: <?xml
          version='1.0'?>\n      <stream:stream\n          from='im.example.com'\n
          \         id='++TR84Sm6A3hnt3Q065SnAbbk3Y='\n          to='juliet@im.example.com'\n
          \         version='1.0'\n          xml:lang='en'\n          xmlns='jabber:client'\n
          \         xmlns:stream='http://etherx.jabber.org/streams'>\n      <stream:error>\n
          \       <remote-connection-failed\n            xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n
          \     </stream:error>\n      </stream:stream>\n"
        title: 4.9.3.15.  remote-connection-failed
      - contents:
        - "4.9.3.16.  reset\n   The server is closing the stream because it has new
          (typically\n   security-critical) features to offer, because the keys or\n
          \  certificates used to establish a secure context for the stream have\n
          \  expired or have been revoked during the life of the stream\n   (Section
          13.7.2.3), because the TLS sequence number has wrapped\n   (Section 5.3.5),
          etc.  The reset applies to the stream and to any\n   security context established
          for that stream (e.g., via TLS and\n   SASL), which means that encryption
          and authentication need to be\n   negotiated again for the new stream (e.g.,
          TLS session resumption\n   cannot be used).\n   S: <stream:error>\n        <reset\n
          \           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n      </stream:error>\n
          \     </stream:stream>\n"
        title: 4.9.3.16.  reset
      - contents:
        - "4.9.3.17.  resource-constraint\n   The server lacks the system resources
          necessary to service the\n   stream.\n   C: <?xml version='1.0'?>\n      <stream:stream\n
          \         from='juliet@im.example.com'\n          to='im.example.com'\n
          \         version='1.0'\n          xmlns='jabber:client'\n          xmlns:stream='http://etherx.jabber.org/streams'>\n
          \  S: <?xml version='1.0'?>\n      <stream:stream\n          from='im.example.com'\n
          \         id='++TR84Sm6A3hnt3Q065SnAbbk3Y='\n          to='juliet@im.example.com'\n
          \         version='1.0'\n          xml:lang='en'\n          xmlns='jabber:client'\n
          \         xmlns:stream='http://etherx.jabber.org/streams'>\n      <stream:error>\n
          \       <resource-constraint\n            xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n
          \     </stream:error>\n      </stream:stream>\n"
        title: 4.9.3.17.  resource-constraint
      - contents:
        - "4.9.3.18.  restricted-xml\n   The entity has attempted to send restricted
          XML features such as a\n   comment, processing instruction, DTD subset,
          or XML entity reference\n   (see Section 11.1).\n   (In the following example,
          the client sends an XMPP message\n   containing an XML comment.)\n   C:
          <message to='juliet@im.example.com'>\n        <!--<subject/>-->\n        <body>This
          message has no subject.</body>\n      </message>\n   S: <stream:error>\n
          \       <restricted-xml\n            xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n
          \     </stream:error>\n      </stream:stream>\n"
        title: 4.9.3.18.  restricted-xml
      - contents:
        - "4.9.3.19.  see-other-host\n   The server will not provide service to the
          initiating entity but is\n   redirecting traffic to another host under the
          administrative control\n   of the same service provider.  The XML character
          data of the <see-\n   other-host/> element returned by the server MUST specify
          the\n   alternate FQDN or IP address at which to connect, which MUST be
          a\n   valid domainpart or a domainpart plus port number (separated by the\n
          \  ':' character in the form \"domainpart:port\").  If the domainpart is\n
          \  the same as the source domain, derived domain, or resolved IPv4 or\n
          \  IPv6 address to which the initiating entity originally connected\n   (differing
          only by the port number), then the initiating entity\n   SHOULD simply attempt
          to reconnect at that address.  (The format of\n   an IPv6 address MUST follow
          [IPv6-ADDR], which includes the enclosing\n   the IPv6 address in square
          brackets '[' and ']' as originally defined\n   by [URI].)  Otherwise, the
          initiating entity MUST resolve the FQDN\n   specified in the <see-other-host/>
          element as described under\n   Section 3.2.\n   C: <?xml version='1.0'?>\n
          \     <stream:stream\n          from='juliet@im.example.com'\n          to='im.example.com'\n
          \         version='1.0'\n          xmlns='jabber:client'\n          xmlns:stream='http://etherx.jabber.org/streams'>\n
          \  S: <?xml version='1.0'?>\n      <stream:stream\n          from='im.example.com'\n
          \         id='++TR84Sm6A3hnt3Q065SnAbbk3Y='\n          to='juliet@im.example.com'\n
          \         version='1.0'\n          xml:lang='en'\n          xmlns='jabber:client'\n
          \         xmlns:stream='http://etherx.jabber.org/streams'>\n      <stream:error>\n
          \       <see-other-host\n            xmlns='urn:ietf:params:xml:ns:xmpp-streams'>\n
          \         [2001:41D0:1:A49b::1]:9222\n        </see-other-host>\n      </stream:error>\n
          \     </stream:stream>\n   When negotiating a stream with the host to which
          it has been\n   redirected, the initiating entity MUST apply the same policies
          it\n   would have applied to the original connection attempt (e.g., a policy\n
          \  requiring TLS), MUST specify the same 'to' address on the initial\n   stream
          header, and MUST verify the identity of the new host using the\n   same
          reference identifier(s) it would have used for the original\n   connection
          attempt (in accordance with [TLS-CERTS]).  Even if the\n   receiving entity
          returns a <see-other-host/> error before the\n   confidentiality and integrity
          of the stream have been established\n   (thus introducing the possibility
          of a denial-of-service attack), the\n   fact that the initiating entity
          needs to verify the identity of the\n   XMPP service based on the same reference
          identifiers implies that the\n   initiating entity will not connect to a
          malicious entity.  To reduce\n   the possibility of a denial-of-service
          attack, (a) the receiving\n   entity SHOULD NOT close the stream with a
          <see-other-host/> stream\n   error until after the confidentiality and integrity
          of the stream\n   have been protected via TLS or an equivalent security
          layer (such as\n   the SASL GSSAPI mechanism), and (b) the receiving entity
          MAY have a\n   policy of following redirects only if it has authenticated
          the\n   receiving entity.  In addition, the initiating entity SHOULD abort\n
          \  the connection attempt after a certain number of successive redirects\n
          \  (e.g., at least 2 but no more than 5).\n"
        title: 4.9.3.19.  see-other-host
      - contents:
        - "4.9.3.20.  system-shutdown\n   The server is being shut down and all active
          streams are being\n   closed.\n   S: <stream:error>\n        <system-shutdown\n
          \           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n      </stream:error>\n
          \     </stream:stream>\n"
        title: 4.9.3.20.  system-shutdown
      - contents:
        - "4.9.3.21.  undefined-condition\n   The error condition is not one of those
          defined by the other\n   conditions in this list; this error condition SHOULD
          NOT be used\n   except in conjunction with an application-specific condition.\n
          \  S: <stream:error>\n        <undefined-condition\n            xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n
          \       <app-error xmlns='http://example.org/ns'/>\n      </stream:error>\n
          \     </stream:stream>\n"
        title: 4.9.3.21.  undefined-condition
      - contents:
        - "4.9.3.22.  unsupported-encoding\n   The initiating entity has encoded the
          stream in an encoding that is\n   not supported by the server (see Section
          11.6) or has otherwise\n   improperly encoded the stream (e.g., by violating
          the rules of the\n   [UTF-8] encoding).\n   (In the following example, the
          client attempts to encode data using\n   UTF-16 instead of UTF-8.)\n   C:
          <?xml version='1.0' encoding='UTF-16'?>\n      <stream:stream\n          from='juliet@im.example.com'\n
          \         to='im.example.com'\n          version='1.0'\n          xmlns='jabber:client'\n
          \         xmlns:stream='http://etherx.jabber.org/streams'>\n   S: <?xml
          version='1.0'?>\n      <stream:stream\n          from='im.example.com'\n
          \         id='++TR84Sm6A3hnt3Q065SnAbbk3Y='\n          to='juliet@im.example.com'\n
          \         version='1.0'\n          xml:lang='en'\n          xmlns='jabber:client'\n
          \         xmlns:stream='http://etherx.jabber.org/streams'>\n      <stream:error>\n
          \       <unsupported-encoding\n            xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n
          \     </stream:error>\n      </stream:stream>\n"
        title: 4.9.3.22.  unsupported-encoding
      - contents:
        - "4.9.3.23.  unsupported-feature\n   The receiving entity has advertised
          a mandatory-to-negotiate stream\n   feature that the initiating entity does
          not support, and has offered\n   no other mandatory-to-negotiate feature
          alongside the unsupported\n   feature.\n   (In the following example, the
          receiving entity requires negotiation\n   of an example feature, but the
          initiating entity does not support the\n   feature.)\n   R: <stream:features>\n
          \       <example xmlns='urn:xmpp:example'>\n          <required/>\n        </example>\n
          \     </stream:features>\n   I: <stream:error>\n        <unsupported-feature\n
          \           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n      </stream:error>\n
          \     </stream:stream>\n"
        title: 4.9.3.23.  unsupported-feature
      - contents:
        - "4.9.3.24.  unsupported-stanza-type\n   The initiating entity has sent a
          first-level child of the stream that\n   is not supported by the server,
          either because the receiving entity\n   does not understand the namespace
          or because the receiving entity\n   does not understand the element name
          for the applicable namespace\n   (which might be the content namespace declared
          as the default\n   namespace).\n   (In the following example, the client
          attempts to send a first-level\n   child element of <pubsub/> qualified
          by the 'jabber:client'\n   namespace, but the schema for that namespace
          defines no such\n   element.)\n   C: <pubsub xmlns='jabber:client'>\n        <publish
          node='princely_musings'>\n          <item id='ae890ac52d0df67ed7cfdf51b644e901'>\n
          \           <entry xmlns='http://www.w3.org/2005/Atom'>\n              <title>Soliloquy</title>\n
          \             <summary>\n   To be, or not to be: that is the question:\n
          \  Whether 'tis nobler in the mind to suffer\n   The slings and arrows of
          outrageous fortune,\n   Or to take arms against a sea of troubles,\n   And
          by opposing end them?\n              </summary>\n              <link rel='alternate'
          type='text/html'\n                    href='http://denmark.example/2003/12/13/atom03'/>\n
          \             <id>tag:denmark.example,2003:entry-32397</id>\n              <published>2003-12-13T18:30:02Z</published>\n
          \             <updated>2003-12-13T18:30:02Z</updated>\n            </entry>\n
          \         </item>\n        </publish>\n      </pubsub>\n   S: <stream:error>\n
          \       <unsupported-stanza-type\n            xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n
          \     </stream:error>\n      </stream:stream>\n"
        title: 4.9.3.24.  unsupported-stanza-type
      - contents:
        - "4.9.3.25.  unsupported-version\n   The 'version' attribute provided by
          the initiating entity in the\n   stream header specifies a version of XMPP
          that is not supported by\n   the server.\n   C: <?xml version='1.0'?>\n
          \     <stream:stream\n          from='juliet@im.example.com'\n          to='im.example.com'\n
          \         version='11.0'\n          xmlns='jabber:client'\n          xmlns:stream='http://etherx.jabber.org/streams'>\n
          \  S: <?xml version='1.0'?>\n      <stream:stream\n          from='im.example.com'\n
          \         id='++TR84Sm6A3hnt3Q065SnAbbk3Y='\n          to='juliet@im.example.com'\n
          \         version='1.0'\n          xml:lang='en'\n          xmlns='jabber:client'\n
          \         xmlns:stream='http://etherx.jabber.org/streams'>\n      <stream:error>\n
          \       <unsupported-version\n            xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n
          \     </stream:error>\n      </stream:stream>\n"
        title: 4.9.3.25.  unsupported-version
      title: 4.9.3.  Defined Stream Error Conditions
    - contents:
      - "4.9.4.  Application-Specific Conditions\n   As noted, an application MAY
        provide application-specific stream\n   error information by including a properly
        namespaced child in the\n   error element.  The application-specific element
        SHOULD supplement or\n   further qualify a defined element.  Thus, the <error/>
        element will\n   contain two or three child elements.\n   C: <message>\n        <body>\n
        \         My keyboard layout is:\n          QWERTYUIOP{}|\n          ASDFGHJKL:\"\n
        \         ZXCVBNM<>?\n        </body>\n      </message>\n   S: <stream:error>\n
        \       <not-well-formed\n            xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n
        \       <text xml:lang='en' xmlns='urn:ietf:params:xml:ns:xmpp-streams'>\n
        \         Some special application diagnostic information!\n        </text>\n
        \       <escape-your-data xmlns='http://example.org/ns'/>\n      </stream:error>\n
        \     </stream:stream>\n"
      title: 4.9.4.  Application-Specific Conditions
    title: 4.9.  Stream Errors
  - contents:
    - "4.10.  Simplified Stream Examples\n   This section contains two highly simplified
      examples of a stream-\n   based connection between a client and a server; these
      examples are\n   included for the purpose of illustrating the concepts introduced
      thus\n   far, but the reader needs to be aware that these examples elide many\n
      \  details (see Section 9 for more complete examples).\n   A basic connection:\n
      \  C: <?xml version='1.0'?>\n      <stream:stream\n          from='juliet@im.example.com'\n
      \         to='im.example.com'\n          version='1.0'\n          xml:lang='en'\n
      \         xmlns='jabber:client'\n          xmlns:stream='http://etherx.jabber.org/streams'>\n
      \  S: <?xml version='1.0'?>\n      <stream:stream\n          from='im.example.com'\n
      \         id='++TR84Sm6A3hnt3Q065SnAbbk3Y='\n          to='juliet@im.example.com'\n
      \         version='1.0'\n          xml:lang='en'\n          xmlns='jabber:client'\n
      \         xmlns:stream='http://etherx.jabber.org/streams'>\n   [ ... stream
      negotiation ... ]\n   C:   <message from='juliet@im.example.com/balcony'\n                 to='romeo@example.net'\n
      \                xml:lang='en'>\n          <body>Art thou not Romeo, and a Montague?</body>\n
      \       </message>\n   S:   <message from='romeo@example.net/orchard'\n                 to='juliet@im.example.com/balcony'\n
      \                xml:lang='en'>\n          <body>Neither, fair saint, if either
      thee dislike.</body>\n        </message>\n   C: </stream:stream>\n   S: </stream:stream>\n
      \  A connection gone bad:\n   C: <?xml version='1.0'?>\n      <stream:stream\n
      \         from='juliet@im.example.com'\n          to='im.example.com'\n          version='1.0'\n
      \         xml:lang='en'\n          xmlns='jabber:client'\n          xmlns:stream='http://etherx.jabber.org/streams'>\n
      \  S: <?xml version='1.0'?>\n      <stream:stream\n          from='im.example.com'\n
      \         id='++TR84Sm6A3hnt3Q065SnAbbk3Y='\n          to='juliet@im.example.com'\n
      \         version='1.0'\n          xml:lang='en'\n          xmlns='jabber:client'\n
      \         xmlns:stream='http://etherx.jabber.org/streams'>\n   [ ... stream
      negotiation ... ]\n   C:   <message from='juliet@im.example.com/balcony'\n                 to='romeo@example.net'\n
      \                xml:lang='en'>\n          <body>No closing tag!\n        </message>\n
      \  S: <stream:error>\n       <not-well-formed\n           xmlns='urn:ietf:params:xml:ns:xmpp-streams'/>\n
      \     </stream:error>\n      </stream:stream>\n   More detailed examples are
      provided under Section 9.\n"
    title: 4.10.  Simplified Stream Examples
  title: 4.  XML Streams
- contents:
  - '5.  STARTTLS Negotiation

    '
  - contents:
    - "5.1.  Fundamentals\n   XMPP includes a method for securing the stream from
      tampering and\n   eavesdropping.  This channel encryption method makes use of
      the\n   Transport Layer Security [TLS] protocol, specifically a \"STARTTLS\"\n
      \  extension that is modeled after similar extensions for the [IMAP],\n   [POP3],
      and [ACAP] protocols as described in [USINGTLS].  The XML\n   namespace name
      for the STARTTLS extension is\n   'urn:ietf:params:xml:ns:xmpp-tls'.\n"
    title: 5.1.  Fundamentals
  - contents:
    - "5.2.  Support\n   Support for STARTTLS is REQUIRED in XMPP client and server\n
      \  implementations.  An administrator of a given deployment MAY specify\n   that
      TLS is mandatory-to-negotiate for client-to-server\n   communication, server-to-server
      communication, or both.  An\n   initiating entity SHOULD use TLS to secure its
      stream with the\n   receiving entity before proceeding with SASL authentication.\n"
    title: 5.2.  Support
  - contents:
    - '5.3.  Stream Negotiation Rules

      '
    - contents:
      - "5.3.1.  Mandatory-to-Negotiate\n   If the receiving entity advertises only
        the STARTTLS feature or if\n   the receiving entity includes the <required/>
        child element as\n   explained under Section 5.4.1, the parties MUST consider
        TLS as\n   mandatory-to-negotiate.  If TLS is mandatory-to-negotiate, the\n
        \  receiving entity SHOULD NOT advertise support for any stream feature\n
        \  except STARTTLS during the initial stage of the stream negotiation\n   process,
        because further stream features might depend on prior\n   negotiation of TLS
        given the order of layers in XMPP (e.g., the\n   particular SASL mechanisms
        offered by the receiving entity will\n   likely depend on whether TLS has
        been negotiated).\n"
      title: 5.3.1.  Mandatory-to-Negotiate
    - contents:
      - "5.3.2.  Restart\n   After TLS negotiation, the parties MUST restart the stream.\n"
      title: 5.3.2.  Restart
    - contents:
      - "5.3.3.  Data Formatting\n   During STARTTLS negotiation, the entities MUST
        NOT send any\n   whitespace as separators between XML elements (i.e., from
        the last\n   character of the first-level <starttls/> element qualified by
        the\n   'urn:ietf:params:xml:ns:xmpp-tls' namespace as sent by the initiating\n
        \  entity, until the last character of the first-level <proceed/>\n   element
        qualified by the 'urn:ietf:params:xml:ns:xmpp-tls' namespace\n   as sent by
        the receiving entity).  This prohibition helps to ensure\n   proper security
        layer byte precision.  Any such whitespace shown in\n   the STARTTLS examples
        provided in this document is included only for\n   the sake of readability.\n"
      title: 5.3.3.  Data Formatting
    - contents:
      - "5.3.4.  Order of TLS and SASL Negotiations\n   If the initiating entity chooses
        to use TLS, STARTTLS negotiation\n   MUST be completed before proceeding to
        SASL negotiation (Section 6);\n   this order of negotiation is necessary to
        help safeguard\n   authentication information sent during SASL negotiation,
        as well as\n   to make it possible to base the use of the SASL EXTERNAL mechanism
        on\n   a certificate (or other credentials) provided during prior TLS\n   negotiation.\n"
      title: 5.3.4.  Order of TLS and SASL Negotiations
    - contents:
      - "5.3.5.  TLS Renegotiation\n   The TLS protocol allows either party in a TLS-protected
        channel to\n   initiate a new handshake that establishes new cryptographic\n
        \  parameters (see [TLS-NEG]).  The cases most commonly mentioned are:\n   1.
        \ Refreshing encryption keys.\n   2.  Wrapping the TLS sequence number as
        explained in Section 6.1 of\n       [TLS].\n   3.  Protecting client credentials
        by completing server authentication\n       first and then completing client
        authentication over the\n       protected channel.\n   Because it is relatively
        inexpensive to establish streams in XMPP,\n   for the first two cases it is
        preferable to use an XMPP stream reset\n   (as described under Section 4.9.3.16)
        instead of performing TLS\n   renegotiation.\n   The third case has improved
        security characteristics when the TLS\n   client (which might be an XMPP server)
        presents credentials to the\n   TLS server.  If communicating such credentials
        to an unauthenticated\n   TLS server might leak private information, it can
        be appropriate to\n   complete TLS negotiation for the purpose of authenticating
        the TLS\n   server to the TLS client and then attempt TLS renegotiation for
        the\n   purpose of authenticating the TLS client to the TLS server.  However,\n
        \  this case is extremely rare because the credentials presented by an\n   XMPP
        server or XMPP client acting as a TLS client are almost always\n   public
        (i.e., a PKIX certificate), and therefore providing those\n   credentials
        before authenticating the XMPP server acting as a TLS\n   server would not
        in general leak private information.\n   As a result, implementers are encouraged
        to carefully weigh the costs\n   and benefits of TLS renegotiation before
        supporting it in their\n   software, and XMPP entities that act as TLS clients
        are discouraged\n   from attempting TLS renegotiation unless the certificate
        (or other\n   credential information) sent during TLS negotiation is known
        to be\n   private.\n   Support for TLS renegotiation is strictly OPTIONAL.
        \ However,\n   implementations that support TLS renegotiation MUST implement
        and use\n   the TLS Renegotiation Extension [TLS-NEG].\n   If an entity that
        does not support TLS renegotiation detects a\n   renegotiation attempt, then
        it MUST immediately close the underlying\n   TCP connection without returning
        a stream error (since the violation\n   has occurred at the TLS layer, not
        the XMPP layer, as described under\n   Section 13.3).\n   If an entity that
        supports TLS renegotiation detects a TLS\n   renegotiation attempt that does
        not use the TLS Renegotiation\n   Extension [TLS-NEG], then it MUST immediately
        close the underlying\n   TCP connection without returning a stream error (since
        the violation\n   has occurred at the TLS layer, not the XMPP layer as described
        under\n   Section 13.3).\n"
      title: 5.3.5.  TLS Renegotiation
    - contents:
      - "5.3.6.  TLS Extensions\n   Either party to a stream MAY include any TLS extension
        during the TLS\n   negotiation itself.  This is a matter for the TLS layer,
        not the XMPP\n   layer.\n"
      title: 5.3.6.  TLS Extensions
    title: 5.3.  Stream Negotiation Rules
  - contents:
    - '5.4.  Process

      '
    - contents:
      - "5.4.1.  Exchange of Stream Headers and Stream Features\n   The initiating
        entity resolves the FQDN of the receiving entity as\n   specified under Section
        3, opens a TCP connection to the advertised\n   port at the resolved IP address,
        and sends an initial stream header\n   to the receiving entity.\n   I: <stream:stream\n
        \       from='juliet@im.example.com'\n        to='im.example.com'\n        version='1.0'\n
        \       xml:lang='en'\n        xmlns='jabber:client'\n        xmlns:stream='http://etherx.jabber.org/streams'>\n
        \  The receiving entity MUST send a response stream header to the\n   initiating
        entity over the TCP connection opened by the initiating\n   entity.\n   R:
        <stream:stream\n        from='im.example.com'\n        id='t7AMCin9zjMNwQKDnplntZPIDEI='\n
        \       to='juliet@im.example.com'\n        version='1.0'\n        xml:lang='en'\n
        \       xmlns='jabber:client'\n        xmlns:stream='http://etherx.jabber.org/streams'>\n
        \  The receiving entity then MUST send stream features to the initiating\n
        \  entity.  If the receiving entity supports TLS, the stream features\n   MUST
        include an advertisement for support of STARTTLS negotiation,\n   i.e., a
        <starttls/> element qualified by the\n   'urn:ietf:params:xml:ns:xmpp-tls'
        namespace.\n   If the receiving entity considers STARTTLS negotiation to be\n
        \  mandatory-to-negotiate, the <starttls/> element MUST contain an empty\n
        \  <required/> child element.\n   R: <stream:features>\n        <starttls
        xmlns='urn:ietf:params:xml:ns:xmpp-tls'>\n          <required/>\n        </starttls>\n
        \     </stream:features>\n"
      title: 5.4.1.  Exchange of Stream Headers and Stream Features
    - contents:
      - '5.4.2.  Initiation of STARTTLS Negotiation

        '
      - contents:
        - "5.4.2.1.  STARTTLS Command\n   In order to begin the STARTTLS negotiation,
          the initiating entity\n   issues the STARTTLS command (i.e., a <starttls/>
          element qualified by\n   the 'urn:ietf:params:xml:ns:xmpp-tls' namespace)
          to instruct the\n   receiving entity that it wishes to begin a STARTTLS
          negotiation to\n   secure the stream.\n   I: <starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>\n
          \  The receiving entity MUST reply with either a <proceed/> element\n   (proceed
          case) or a <failure/> element (failure case) qualified by\n   the 'urn:ietf:params:xml:ns:xmpp-tls'
          namespace.\n"
        title: 5.4.2.1.  STARTTLS Command
      - contents:
        - "5.4.2.2.  Failure Case\n   If the failure case occurs, the receiving entity
          MUST return a\n   <failure/> element qualified by the 'urn:ietf:params:xml:ns:xmpp-tls'\n
          \  namespace, close the XML stream, and terminate the underlying TCP\n   connection.\n
          \  R: <failure xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>\n   R: </stream:stream>\n
          \  Causes for the failure case include but are not limited to:\n   1.  The
          initiating entity has sent a malformed STARTTLS command.\n   2.  The receiving
          entity did not offer the STARTTLS feature in its\n       stream features.\n
          \  3.  The receiving entity cannot complete STARTTLS negotiation because\n
          \      of an internal error.\n      Informational Note: STARTTLS failure
          is not triggered by TLS\n      errors such as bad_certificate or handshake_failure,
          which are\n      generated and handled during the TLS negotiation itself
          as\n      described in [TLS].\n   If the failure case occurs, the initiating
          entity MAY attempt to\n   reconnect as explained under Section 3.3.\n"
        title: 5.4.2.2.  Failure Case
      - contents:
        - "5.4.2.3.  Proceed Case\n   If the proceed case occurs, the receiving entity
          MUST return a\n   <proceed/> element qualified by the 'urn:ietf:params:xml:ns:xmpp-tls'\n
          \  namespace.\n   R: <proceed xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>\n
          \  The receiving entity MUST consider the TLS negotiation to have begun\n
          \  immediately after sending the closing '>' character of the <proceed/>\n
          \  element to the initiating entity.  The initiating entity MUST\n   consider
          the TLS negotiation to have begun immediately after\n   receiving the closing
          '>' character of the <proceed/> element from\n   the receiving entity.\n
          \  The entities now proceed to TLS negotiation as explained in the next\n
          \  section.\n"
        title: 5.4.2.3.  Proceed Case
      title: 5.4.2.  Initiation of STARTTLS Negotiation
    - contents:
      - '5.4.3.  TLS Negotiation

        '
      - contents:
        - "5.4.3.1.  Rules\n   In order to complete TLS negotiation over the TCP connection,
          the\n   entities MUST follow the process defined in [TLS].\n   The following
          rules apply:\n   1.  The entities MUST NOT send any further XML data until
          the TLS\n       negotiation is complete.\n   2.  When using any of the mandatory-to-implement
          (MTI) ciphersuites\n       specified under Section 13.8, the receiving entity
          MUST present a\n       certificate.\n   3.  So that mutual certificate authentication
          will be possible, the\n       receiving entity SHOULD send a certificate
          request to the\n       initiating entity, and the initiating entity SHOULD
          send a\n       certificate to the receiving entity (but for privacy reasons\n
          \      might opt not to send a certificate until after the receiving\n       entity
          has authenticated to the initiating entity).\n   4.  The receiving entity
          SHOULD choose which certificate to present\n       based on the domainpart
          contained in the 'to' attribute of the\n       initial stream header (in
          essence, this domainpart is\n       functionally equivalent to the Server
          Name Indication defined for\n       TLS in [TLS-EXT]).\n   5.  To determine
          if the TLS negotiation will succeed, the initiating\n       entity MUST
          attempt to validate the receiving entity's\n       certificate in accordance
          with the certificate validation\n       procedures specified under Section
          13.7.2.\n   6.  If the initiating entity presents a certificate, the receiving\n
          \      entity too MUST attempt to validate the initiating entity's\n       certificate
          in accordance with the certificate validation\n       procedures specified
          under Section 13.7.2.\n   7.  Following successful TLS negotiation, all
          further data\n       transmitted by either party MUST be protected with
          the negotiated\n       algorithms, keys, and secrets (i.e., encrypted, integrity-\n
          \      protected, or both depending on the ciphersuite used).\n      Security
          Warning: See Section 13.8 regarding ciphersuites that\n      MUST be supported
          for TLS; naturally, other ciphersuites MAY be\n      supported as well.\n"
        title: 5.4.3.1.  Rules
      - contents:
        - "5.4.3.2.  TLS Failure\n   If the TLS negotiation results in failure, the
          receiving entity MUST\n   terminate the TCP connection.\n   The receiving
          entity MUST NOT send a closing </stream> tag before\n   terminating the
          TCP connection (since the failure has occurred at the\n   TLS layer, not
          the XMPP layer as described under Section 13.3).\n   The initiating entity
          MAY attempt to reconnect as explained under\n   Section 3.3, with or without
          attempting TLS negotiation (in\n   accordance with local service policy,
          user-configured preferences,\n   etc.).\n"
        title: 5.4.3.2.  TLS Failure
      - contents:
        - "5.4.3.3.  TLS Success\n   If the TLS negotiation is successful, then the
          entities MUST proceed\n   as follows.\n   1.  The initiating entity MUST
          discard any information transmitted in\n       layers above TCP that it
          obtained from the receiving entity in an\n       insecure manner before
          TLS took effect (e.g., the receiving\n       entity's 'from' address or
          the stream ID and stream features\n       received from the receiving entity).\n
          \  2.  The receiving entity MUST discard any information transmitted in\n
          \      layers above TCP that it obtained from the initiating entity in\n
          \      an insecure manner before TLS took effect (e.g., the initiating\n
          \      entity's 'from' address).\n   3.  The initiating entity MUST send
          a new initial stream header to\n       the receiving entity over the encrypted
          connection (as specified\n       under Section 4.3.3, the initiating entity
          MUST NOT send a\n       closing </stream> tag before sending the new initial
          stream\n       header, since the receiving entity and initiating entity
          MUST\n       consider the original stream to be replaced upon success of
          the\n       TLS negotiation).\n   I: <stream:stream\n        from='juliet@im.example.com'\n
          \       to='im.example.com'\n        version='1.0'\n        xml:lang='en'\n
          \       xmlns='jabber:client'\n        xmlns:stream='http://etherx.jabber.org/streams'>\n
          \  4.  The receiving entity MUST respond with a new response stream\n       header
          over the encrypted connection (for which it MUST generate\n       a new
          stream ID instead of reusing the old stream ID).\n   R: <stream:stream\n
          \       from='im.example.com'\n        id='vgKi/bkYME8OAj4rlXMkpucAqe4='\n
          \       to='juliet@im.example.com'\n        version='1.0'\n        xml:lang='en'\n
          \       xmlns='jabber:client'\n        xmlns:stream='http://etherx.jabber.org/streams'>\n
          \  5.  The receiving entity also MUST send stream features to the\n       initiating
          entity, which MUST NOT include the STARTTLS feature\n       but which SHOULD
          include the SASL stream feature as described\n       under Section 6 (see
          especially Section 6.4.1 regarding the few\n       reasons why the SASL
          stream feature would not be offered here).\n   R: <stream:features>\n        <mechanisms
          xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\n          <mechanism>EXTERNAL</mechanism>\n
          \         <mechanism>SCRAM-SHA-1-PLUS</mechanism>\n          <mechanism>SCRAM-SHA-1</mechanism>\n
          \         <mechanism>PLAIN</mechanism>\n        </mechanisms>\n      </stream:features>\n"
        title: 5.4.3.3.  TLS Success
      title: 5.4.3.  TLS Negotiation
    title: 5.4.  Process
  title: 5.  STARTTLS Negotiation
- contents:
  - '6.  SASL Negotiation

    '
  - contents:
    - "6.1.  Fundamentals\n   XMPP includes a method for authenticating a stream by
      means of an\n   XMPP-specific profile of the Simple Authentication and Security
      Layer\n   protocol (see [SASL]).  SASL provides a generalized method for adding\n
      \  authentication support to connection-based protocols, and XMPP uses\n   an
      XML namespace profile of SASL that conforms to the profiling\n   requirements
      of [SASL].  The XML namespace name for the SASL\n   extension is 'urn:ietf:params:xml:ns:xmpp-sasl'.\n"
    title: 6.1.  Fundamentals
  - contents:
    - "6.2.  Support\n   Support for SASL negotiation is REQUIRED in XMPP client and
      server\n   implementations.\n"
    title: 6.2.  Support
  - contents:
    - '6.3.  Stream Negotiation Rules

      '
    - contents:
      - "6.3.1.  Mandatory-to-Negotiate\n   The parties to a stream MUST consider
        SASL as mandatory-to-negotiate.\n"
      title: 6.3.1.  Mandatory-to-Negotiate
    - contents:
      - "6.3.2.  Restart\n   After SASL negotiation, the parties MUST restart the
        stream.\n"
      title: 6.3.2.  Restart
    - contents:
      - "6.3.3.  Mechanism Preferences\n   Any entity that will act as a SASL client
        or a SASL server MUST\n   maintain an ordered list of its preferred SASL mechanisms
        according\n   to the client or server, where the list is ordered according
        to local\n   policy or user configuration (which SHOULD be in order of perceived\n
        \  strength to enable the strongest authentication possible).  The\n   initiating
        entity MUST maintain its own preference order independent\n   of the preference
        order of the receiving entity.  A client MUST try\n   SASL mechanisms in its
        preference order.  For example, if the server\n   offers the ordered list
        \"PLAIN SCRAM-SHA-1 GSSAPI\" or \"SCRAM-SHA-1\n   GSSAPI PLAIN\" but the client's
        ordered list is \"GSSAPI SCRAM-SHA-1\",\n   the client MUST try GSSAPI first
        and then SCRAM-SHA-1 but MUST NOT\n   try PLAIN (since PLAIN is not on its
        list).\n"
      title: 6.3.3.  Mechanism Preferences
    - contents:
      - "6.3.4.  Mechanism Offers\n   If the receiving entity considers TLS negotiation
        (Section 5) to be\n   mandatory-to-negotiate before it will accept authentication
        with a\n   particular SASL mechanism, it MUST NOT advertise that mechanism
        in\n   its list of available SASL mechanisms before TLS negotiation has been\n
        \  completed.\n   The receiving entity SHOULD offer the SASL EXTERNAL mechanism
        if both\n   of the following conditions hold:\n   1.  During TLS negotiation
        the initiating entity presented a\n       certificate that is acceptable to
        the receiving entity for\n       purposes of strong identity verification
        in accordance with local\n       service policies (e.g., because said certificate
        is unexpired, is\n       unrevoked, and is anchored to a root trusted by the
        receiving\n       entity).\n   2.  The receiving entity expects that the initiating
        entity will be\n       able to authenticate and authorize as the identity
        provided in\n       the certificate; in the case of a server-to-server stream,
        the\n       receiving entity might have such an expectation because a DNS\n
        \      domain name presented in the initiating entity's certificate\n       matches
        the domain referenced in the 'from' attribute of the\n       initial stream
        header, where the matching rules of [TLS-CERTS]\n       apply; in the case
        of a client-to-server stream, the receiving\n       entity might have such
        an expectation because the bare JID\n       presented in the initiating entity's
        certificate matches a user\n       account that is registered with the server
        or because other\n       information contained in the initiating entity's
        certificate\n       matches that of an entity that has permission to use the
        server\n       for access to an XMPP network.\n   However, the receiving entity
        MAY offer the SASL EXTERNAL mechanism\n   under other circumstances, as well.\n
        \  When the receiving entity offers the SASL EXTERNAL mechanism, the\n   receiving
        entity SHOULD list the EXTERNAL mechanism first among its\n   offered SASL
        mechanisms and the initiating entity SHOULD attempt SASL\n   negotiation using
        the EXTERNAL mechanism first (this preference will\n   tend to increase the
        likelihood that the parties can negotiate mutual\n   certificate authentication).\n
        \  Section 13.8 specifies SASL mechanisms that MUST be supported;\n   naturally,
        other SASL mechanisms MAY be supported as well.\n      Informational Note:
        Best practices for the use of SASL in the\n      context of XMPP are described
        in [XEP-0175] for the ANONYMOUS\n      mechanism and in [XEP-0178] for the
        EXTERNAL mechanism.\n"
      title: 6.3.4.  Mechanism Offers
    - contents:
      - "6.3.5.  Data Formatting\n   The following data formatting rules apply to
        the SASL negotiation:\n   1.  During SASL negotiation, the entities MUST NOT
        send any\n       whitespace as separators between XML elements (i.e., from
        the\n       last character of the first-level <auth/> element qualified by\n
        \      the 'urn:ietf:params:xml:ns:xmpp-sasl' namespace as sent by the\n       initiating
        entity, until the last character of the first-level\n       <success/> element
        qualified by the\n       'urn:ietf:params:xml:ns:xmpp-sasl' namespace as sent
        by the\n       receiving entity).  This prohibition helps to ensure proper\n
        \      security layer byte precision.  Any such whitespace shown in the\n
        \      SASL examples provided in this document is included only for the\n
        \      sake of readability.\n   2.  Any XML character data contained within
        the XML elements MUST be\n       encoded using base 64, where the encoding
        adheres to the\n       definition in Section 4 of [BASE64] and where the padding
        bits\n       are set to zero.\n   3.  As formally specified in the XML schema
        for the\n       'urn:ietf:params:xml:ns:xmpp-sasl' namespace under Appendix
        A.4,\n       the receiving entity MAY include one or more application-specific\n
        \      child elements inside the <mechanisms/> element to provide\n       information
        that might be needed by the initiating entity in\n       order to complete
        successful SASL negotiation using one or more\n       of the offered mechanisms;
        however, the syntax and semantics of\n       all such elements are out of
        scope for this specification (see\n       [XEP-0233] for one example).\n"
      title: 6.3.5.  Data Formatting
    - contents:
      - "6.3.6.  Security Layers\n   Upon successful SASL negotiation that involves
        negotiation of a\n   security layer, both the initiating entity and the receiving
        entity\n   MUST discard any application-layer state (i.e, state from the XMPP\n
        \  layer, excluding state from the TLS negotiation or SASL negotiation).\n"
      title: 6.3.6.  Security Layers
    - contents:
      - "6.3.7.  Simple User Name\n   Some SASL mechanisms (e.g., CRAM-MD5, DIGEST-MD5,
        and SCRAM) specify\n   that the authentication identity used in the context
        of such\n   mechanisms is a \"simple user name\" (see Section 2 of [SASL]
        as well\n   as [SASLPREP]).  The exact form of the simple user name in any\n
        \  particular mechanism or deployment thereof is a local matter, and a\n   simple
        user name does not necessarily map to an application\n   identifier such as
        a JID or JID component (e.g., a localpart).\n   However, in the absence of
        local information provided by the server,\n   an XMPP client SHOULD assume
        that the authentication identity for\n   such a SASL mechanism is a simple
        user name equal to the localpart of\n   the user's JID.\n"
      title: 6.3.7.  Simple User Name
    - contents:
      - "6.3.8.  Authorization Identity\n   An authorization identity is an OPTIONAL
        identity included by the\n   initiating entity to specify an identity to act
        as (see Section 2 of\n   [SASL]).  In client-to-server streams, it would most
        likely be used\n   by an administrator to perform some management task on
        behalf of\n   another user, whereas in server-to-server streams it would most\n
        \  likely be used to specify a particular add-on service at an XMPP\n   service
        (e.g., a multi-user chat server at conference.example.com\n   that is hosted
        by the example.com XMPP service).  If the initiating\n   entity wishes to
        act on behalf of another entity and the selected\n   SASL mechanism supports
        transmission of an authorization identity,\n   the initiating entity MUST
        provide an authorization identity during\n   SASL negotiation.  If the initiating
        entity does not wish to act on\n   behalf of another entity, it MUST NOT provide
        an authorization\n   identity.\n   In the case of client-to-server communication,
        the value of an\n   authorization identity MUST be a bare JID (<localpart@domainpart>)\n
        \  rather than a full JID (<localpart@domainpart/resourcepart>).\n   In the
        case of server-to-server communication, the value of an\n   authorization
        identity MUST be a domainpart only (<domainpart>).\n   If the initiating entity
        provides an authorization identity during\n   SASL negotiation, the receiving
        entity is responsible for verifying\n   that the initiating entity is in fact
        allowed to assume the specified\n   authorization identity; if not, the receiving
        entity MUST return an\n   <invalid-authzid/> SASL error as described under
        Section 6.5.6.\n"
      title: 6.3.8.  Authorization Identity
    - contents:
      - "6.3.9.  Realms\n   The receiving entity MAY include a realm when negotiating
        certain\n   SASL mechanisms (e.g., both the GSSAPI and DIGEST-MD5 mechanisms\n
        \  allow the authentication exchange to include a realm, though in\n   different
        ways, whereas the EXTERNAL, SCRAM, and PLAIN mechanisms do\n   not).  If the
        receiving entity does not communicate a realm, the\n   initiating entity MUST
        NOT assume that any realm exists.  The realm\n   MUST be used only for the
        purpose of authentication; in particular,\n   an initiating entity MUST NOT
        attempt to derive an XMPP domainpart\n   from the realm information provided
        by the receiving entity.\n"
      title: 6.3.9.  Realms
    - contents:
      - "6.3.10.  Round Trips\n   [SASL] specifies that a using protocol such as XMPP
        can define two\n   methods by which the protocol can save round trips where
        allowed for\n   the SASL mechanism:\n   1.  When the SASL client (the XMPP
        \"initiating entity\") requests an\n       authentication exchange, it can
        include \"initial response\" data\n       with its request if appropriate
        for the SASL mechanism in use.\n       In XMPP, this is done by including
        the initial response as the\n       XML character data of the <auth/> element.\n
        \  2.  At the end of the authentication exchange, the SASL server (the\n       XMPP
        \"receiving entity\") can include \"additional data with\n       success\"
        if appropriate for the SASL mechanism in use.  In XMPP,\n       this is done
        by including the additional data as the XML\n       character data of the
        <success/> element.\n   For the sake of protocol efficiency, it is REQUIRED
        for clients and\n   servers to support these methods and RECOMMENDED to use
        them;\n   however, clients and servers MUST support the less efficient modes
        as\n   well.\n"
      title: 6.3.10.  Round Trips
    title: 6.3.  Stream Negotiation Rules
  - contents:
    - "6.4.  Process\n   The process for SASL negotiation is as follows.\n"
    - contents:
      - "6.4.1.  Exchange of Stream Headers and Stream Features\n   If SASL negotiation
        follows successful STARTTLS negotiation\n   (Section 5), then the SASL negotiation
        occurs over the protected\n   stream that has already been negotiated.  If
        not, the initiating\n   entity resolves the FQDN of the receiving entity as
        specified under\n   Section 3, opens a TCP connection to the advertised port
        at the\n   resolved IP address, and sends an initial stream header to the\n
        \  receiving entity.  In either case, the receiving entity will receive\n
        \  an initial stream from the initiating entity.\n   I: <stream:stream\n        from='juliet@im.example.com'\n
        \       to='im.example.com'\n        version='1.0'\n        xml:lang='en'\n
        \       xmlns='jabber:client'\n        xmlns:stream='http://etherx.jabber.org/streams'>\n
        \  When the receiving entity processes an initial stream header from the\n
        \  initiating entity, it MUST send a response stream header to the\n   initiating
        entity (for which it MUST generate a unique stream ID.  If\n   TLS negotiation
        has already succeeded, then this stream ID MUST be\n   different from the
        stream ID sent before TLS negotiation succeeded).\n   R: <stream:stream\n
        \       from='im.example.com'\n        id='vgKi/bkYME8OAj4rlXMkpucAqe4='\n
        \       to='juliet@im.example.com'\n        version='1.0'\n        xml:lang='en'\n
        \       xmlns='jabber:client'\n        xmlns:stream='http://etherx.jabber.org/streams'>\n
        \  The receiving entity also MUST send stream features to the initiating\n
        \  entity.  The stream features SHOULD include an advertisement for\n   support
        of SASL negotiation, i.e., a <mechanisms/> element qualified\n   by the 'urn:ietf:params:xml:ns:xmpp-sasl'
        namespace.  Typically there\n   are only three cases in which support for
        SASL negotiation would not\n   be advertised here:\n   o  TLS negotiation
        needs to happen before SASL can be offered (i.e.,\n      TLS is required and
        the receiving entity is responding to the very\n      first initial stream
        header it has received for this connection\n      attempt).\n   o  SASL negotiation
        is impossible for a server-to-server connection\n      (i.e., the initiating
        server has not provided a certificate that\n      would enable strong authentication
        and therefore the receiving\n      server is falling back to weak identity
        verification using the\n      Server Dialback protocol [XEP-0220]).\n   o
        \ SASL has already been negotiated (i.e., the receiving entity is\n      responding
        to an initial stream header sent as a stream restart\n      after successful
        SASL negotiation).\n   The <mechanisms/> element MUST contain one <mechanism/>
        child element\n   for each authentication mechanism the receiving entity offers
        to the\n   initiating entity.  As noted, the order of <mechanism/> elements
        in\n   the XML indicates the preference order of the SASL mechanisms\n   according
        to the receiving entity (which is not necessarily the\n   preference order
        according to the initiating entity).\n   R: <stream:features>\n        <mechanisms
        xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\n          <mechanism>EXTERNAL</mechanism>\n
        \         <mechanism>SCRAM-SHA-1-PLUS</mechanism>\n          <mechanism>SCRAM-SHA-1</mechanism>\n
        \         <mechanism>PLAIN</mechanism>\n        </mechanisms>\n      </stream:features>\n"
      title: 6.4.1.  Exchange of Stream Headers and Stream Features
    - contents:
      - "6.4.2.  Initiation\n   In order to begin the SASL negotiation, the initiating
        entity sends\n   an <auth/> element qualified by the\n   'urn:ietf:params:xml:ns:xmpp-sasl'
        namespace and includes an\n   appropriate value for the 'mechanism' attribute,
        thus starting the\n   handshake for that particular authentication mechanism.
        \ This element\n   MAY contain XML character data (in SASL terminology, the
        \"initial\n   response\") if the mechanism supports or requires it.  If the\n
        \  initiating entity needs to send a zero-length initial response, it\n   MUST
        transmit the response as a single equals sign character (\"=\"),\n   which
        indicates that the response is present but contains no data.\n   I: <auth
        xmlns='urn:ietf:params:xml:ns:xmpp-sasl'\n            mechanism='PLAIN'>AGp1bGlldAByMG0zMG15cjBtMzA=</auth>\n
        \  If the initiating entity subsequently sends another <auth/> element\n   and
        the ongoing authentication handshake has not yet completed, the\n   receiving
        entity MUST discard the ongoing handshake and MUST process\n   a new handshake
        for the subsequently requested SASL mechanism.\n"
      title: 6.4.2.  Initiation
    - contents:
      - "6.4.3.  Challenge-Response Sequence\n   If necessary, the receiving entity
        challenges the initiating entity\n   by sending a <challenge/> element qualified
        by the\n   'urn:ietf:params:xml:ns:xmpp-sasl' namespace; this element MAY\n
        \  contain XML character data (which MUST be generated in accordance\n   with
        the definition of the SASL mechanism chosen by the initiating\n   entity).\n
        \  The initiating entity responds to the challenge by sending a\n   <response/>
        element qualified by the\n   'urn:ietf:params:xml:ns:xmpp-sasl' namespace;
        this element MAY\n   contain XML character data (which MUST be generated in
        accordance\n   with the definition of the SASL mechanism chosen by the initiating\n
        \  entity).\n   If necessary, the receiving entity sends more challenges and
        the\n   initiating entity sends more responses.\n   This series of challenge/response
        pairs continues until one of three\n   things happens:\n   o  The initiating
        entity aborts the handshake for this authentication\n      mechanism.\n   o
        \ The receiving entity reports failure of the handshake.\n   o  The receiving
        entity reports success of the handshake.\n   These scenarios are described
        in the following sections.\n"
      title: 6.4.3.  Challenge-Response Sequence
    - contents:
      - "6.4.4.  Abort\n   The initiating entity aborts the handshake for this authentication\n
        \  mechanism by sending an <abort/> element qualified by the\n   'urn:ietf:params:xml:ns:xmpp-sasl'
        namespace.\n   I: <abort xmlns='urn:ietf:params:xml:ns:xmpp-sasl'/>\n   Upon
        receiving an <abort/> element, the receiving entity MUST return\n   a <failure/>
        element qualified by the\n   'urn:ietf:params:xml:ns:xmpp-sasl' namespace
        and containing an\n   <aborted/> child element.\n   R: <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\n
        \       <aborted/>\n      </failure>\n"
      title: 6.4.4.  Abort
    - contents:
      - "6.4.5.  SASL Failure\n   The receiving entity reports failure of the handshake
        for this\n   authentication mechanism by sending a <failure/> element qualified
        by\n   the 'urn:ietf:params:xml:ns:xmpp-sasl' namespace (the particular\n
        \  cause of failure MUST be communicated in an appropriate child element\n
        \  of the <failure/> element as defined under Section 6.5).\n   R: <failure
        xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\n        <not-authorized/>\n      </failure>\n
        \  Where appropriate for the chosen SASL mechanism, the receiving entity\n
        \  SHOULD allow a configurable but reasonable number of retries (at\n   least
        2 and no more than 5); this enables the initiating entity\n   (e.g., an end-user
        client) to tolerate incorrectly provided\n   credentials (e.g., a mistyped
        password) without being forced to\n   reconnect (which it would if the receiving
        entity immediately\n   returned a SASL failure and closed the stream).\n   If
        the initiating entity attempts a reasonable number of retries with\n   the
        same SASL mechanism and all attempts fail, it MAY fall back to\n   the next
        mechanism in its ordered list by sending a new <auth/>\n   request to the
        receiving entity, thus starting a new handshake for\n   that authentication
        mechanism.  If all handshakes fail and there are\n   no remaining mechanisms
        in the initiating entity's list of supported\n   and acceptable mechanisms,
        the initiating entity SHOULD simply close\n   the stream as described under
        Section 4.4 (instead of waiting for the\n   stream to time out).\n   If the
        initiating entity exceeds the number of retries, the receiving\n   entity
        MUST close the stream with a stream error, which SHOULD be\n   <policy-violation/>
        (Section 4.9.3.14), although some existing\n   implementations send <not-authorized/>
        (Section 4.9.3.12) instead.\n      Implementation Note: For server-to-server
        streams, if the\n      receiving entity cannot offer the SASL EXTERNAL mechanism
        or any\n      other SASL mechanism based on the security context established\n
        \     during TLS negotiation, the receiving entity MAY attempt to\n      complete
        weak identity verification using the Server Dialback\n      protocol [XEP-0220];
        however, if according to local service\n      policies weak identity verification
        is insufficient then the\n      receiving entity SHOULD instead close the
        stream with a <policy-\n      violation/> stream error (Section 4.9.3.14)
        instead of waiting for\n      the stream to time out.\n"
      title: 6.4.5.  SASL Failure
    - contents:
      - "6.4.6.  SASL Success\n   Before considering the SASL handshake to be a success,
        if the\n   initiating entity provided a 'from' attribute on an initial stream\n
        \  header whose confidentiality and integrity were protected via TLS or\n
        \  an equivalent security layer (such as the SASL GSSAPI mechanism) then\n
        \  the receiving entity SHOULD correlate the authentication identity\n   resulting
        from the SASL negotiation with that 'from' address; if the\n   two identities
        do not match then the receiving entity SHOULD\n   terminate the connection
        attempt (however, the receiving entity might\n   have legitimate reasons not
        to terminate the connection attempt, for\n   example, because it has overridden
        a connecting client's address to\n   correct the JID format or assign a JID
        based on information presented\n   in an end-user certificate).\n   The receiving
        entity reports success of the handshake by sending a\n   <success/> element
        qualified by the\n   'urn:ietf:params:xml:ns:xmpp-sasl' namespace; this element
        MAY\n   contain XML character data (in SASL terminology, \"additional data\n
        \  with success\") if the chosen SASL mechanism supports or requires it.\n
        \  If the receiving entity needs to send additional data of zero length,\n
        \  it MUST transmit the data as a single equals sign character (\"=\").\n
        \  R: <success xmlns='urn:ietf:params:xml:ns:xmpp-sasl'/>\n      Informational
        Note: For client-to-server streams, the\n      authorization identity communicated
        during SASL negotiation is\n      used to determine the canonical address
        for the initiating client\n      according to the receiving server, as described
        under\n      Section 4.3.6.\n   Upon receiving the <success/> element, the
        initiating entity MUST\n   initiate a new stream over the existing TCP connection
        by sending a\n   new initial stream header to the receiving entity (as specified
        under\n   Section 4.3.3, the initiating entity MUST NOT send a closing\n   </stream>
        tag before sending the new initial stream header, since the\n   receiving
        entity and initiating entity MUST consider the original\n   stream to be replaced
        upon success of the SASL negotiation).\n   I: <stream:stream\n        from='juliet@im.example.com'\n
        \       to='im.example.com'\n        version='1.0'\n        xml:lang='en'\n
        \       xmlns='jabber:client'\n        xmlns:stream='http://etherx.jabber.org/streams'>\n
        \  Upon receiving the new initial stream header from the initiating\n   entity,
        the receiving entity MUST respond by sending a new response\n   stream header
        to the initiating entity (for which it MUST generate a\n   new stream ID instead
        of reusing the old stream ID).\n   R: <stream:stream\n        from='im.example.com'\n
        \       id='gPybzaOzBmaADgxKXu9UClbprp0='\n        to='juliet@im.example.com'\n
        \       version='1.0'\n        xml:lang='en'\n        xmlns='jabber:client'\n
        \       xmlns:stream='http://etherx.jabber.org/streams'>\n   The receiving
        entity MUST also send stream features, containing any\n   further available
        features or containing no features (via an empty\n   <features/> element).\n
        \  R: <stream:features>\n        <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'/>\n
        \     </stream:features>\n"
      title: 6.4.6.  SASL Success
    title: 6.4.  Process
  - contents:
    - "6.5.  SASL Errors\n   The syntax of SASL errors is as follows, where the XML
      data shown\n   within the square brackets '[' and ']' is OPTIONAL.\n   <failure
      xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\n     <defined-condition/>\n     [<text
      xml:lang='langcode'>\n         OPTIONAL descriptive text\n     </text>]\n   </failure>\n
      \  The \"defined-condition\" MUST be one of the SASL-related error\n   conditions
      defined in the following sections.  However, because\n   additional error conditions
      might be defined in the future, if an\n   entity receives a SASL error condition
      that it does not understand\n   then it MUST treat the unknown condition as
      a generic authentication\n   failure, i.e., as equivalent to <not-authorized/>
      (Section 6.5.10).\n   Inclusion of the <text/> element is OPTIONAL, and can
      be used to\n   provide application-specific information about the error condition,\n
      \  which information MAY be displayed to a human but only as a\n   supplement
      to the defined condition.\n   Because XMPP itself defines an application profile
      of SASL and there\n   is no expectation that more specialized XMPP applications
      will be\n   built on top of SASL, the SASL error format does not provide\n   extensibility
      for application-specific error conditions as is done\n   for XML streams (Section
      4.9.4) and XML stanzas (Section 8.3.4).\n"
    - contents:
      - "6.5.1.  aborted\n   The receiving entity acknowledges that the authentication
        handshake\n   has been aborted by the initiating entity; sent in reply to
        the\n   <abort/> element.\n   I: <abort xmlns='urn:ietf:params:xml:ns:xmpp-sasl'/>\n
        \  R: <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\n        <aborted/>\n
        \     </failure>\n"
      title: 6.5.1.  aborted
    - contents:
      - "6.5.2.  account-disabled\n   The account of the initiating entity has been
        temporarily disabled;\n   sent in reply to an <auth/> element (with or without
        initial response\n   data) or a <response/> element.\n   I: <auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl'\n
        \           mechanism='PLAIN'>AGp1bGlldAByMG0zMG15cjBtMzA=</auth>\n   R: <failure
        xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\n        <account-disabled/>\n        <text
        xml:lang='en'>Call 212-555-1212 for assistance.</text>\n      </failure>\n"
      title: 6.5.2.  account-disabled
    - contents:
      - "6.5.3.  credentials-expired\n   The authentication failed because the initiating
        entity provided\n   credentials that have expired; sent in reply to a <response/>
        element\n   or an <auth/> element with initial response data.\n   I: <response
        xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\n        [ ... ]\n      </response>\n
        \  R: <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\n        <credentials-expired/>\n
        \     </failure>\n"
      title: 6.5.3.  credentials-expired
    - contents:
      - "6.5.4.  encryption-required\n   The mechanism requested by the initiating
        entity cannot be used\n   unless the confidentiality and integrity of the
        underlying stream are\n   protected (typically via TLS); sent in reply to
        an <auth/> element\n   (with or without initial response data).\n   I: <auth
        xmlns='urn:ietf:params:xml:ns:xmpp-sasl'\n            mechanism='PLAIN'>AGp1bGlldAByMG0zMG15cjBtMzA=</auth>\n
        \  R: <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\n        <encryption-required/>\n
        \     </failure>\n"
      title: 6.5.4.  encryption-required
    - contents:
      - "6.5.5.  incorrect-encoding\n   The data provided by the initiating entity
        could not be processed\n   because the base 64 encoding is incorrect (e.g.,
        because the encoding\n   does not adhere to the definition in Section 4 of
        [BASE64]); sent in\n   reply to a <response/> element or an <auth/> element
        with initial\n   response data.\n   I: <auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl'\n
        \           mechanism='DIGEST-MD5'>[ ... ]</auth>\n   R: <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\n
        \       <incorrect-encoding/>\n      </failure>\n"
      title: 6.5.5.  incorrect-encoding
    - contents:
      - "6.5.6.  invalid-authzid\n   The authzid provided by the initiating entity
        is invalid, either\n   because it is incorrectly formatted or because the
        initiating entity\n   does not have permissions to authorize that ID; sent
        in reply to a\n   <response/> element or an <auth/> element with initial response
        data.\n   I: <response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\n        [
        ... ]\n      </response>\n   R: <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\n
        \       <invalid-authzid/>\n      </failure>\n"
      title: 6.5.6.  invalid-authzid
    - contents:
      - "6.5.7.  invalid-mechanism\n   The initiating entity did not specify a mechanism,
        or requested a\n   mechanism that is not supported by the receiving entity;
        sent in\n   reply to an <auth/> element.\n   I: <auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl'\n
        \           mechanism='CRAM-MD5'/>\n   R: <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\n
        \       <invalid-mechanism/>\n      </failure>\n"
      title: 6.5.7.  invalid-mechanism
    - contents:
      - "6.5.8.  malformed-request\n   The request is malformed (e.g., the <auth/>
        element includes initial\n   response data but the mechanism does not allow
        that, or the data sent\n   violates the syntax for the specified SASL mechanism);
        sent in reply\n   to an <abort/>, <auth/>, <challenge/>, or <response/> element.\n
        \  (In the following example, the XML character data of the <auth/>\n   element
        contains more than 255 UTF-8-encoded Unicode characters and\n   therefore
        violates the \"token\" production for the SASL ANONYMOUS\n   mechanism as
        specified in [ANONYMOUS].)\n   I: <auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl'\n
        \           mechanism='ANONYMOUS'>[ ... some-long-token ... ]</auth>\n   R:
        <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\n        <malformed-request/>\n
        \     </failure>\n"
      title: 6.5.8.  malformed-request
    - contents:
      - "6.5.9.  mechanism-too-weak\n   The mechanism requested by the initiating
        entity is weaker than\n   server policy permits for that initiating entity;
        sent in reply to an\n   <auth/> element (with or without initial response
        data).\n   I: <auth xmlns='urn:ietf:params:xml:ns:xmpp-sasl'\n            mechanism='PLAIN'>AGp1bGlldAByMG0zMG15cjBtMzA=</auth>\n
        \  R: <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\n        <mechanism-too-weak/>\n
        \     </failure>\n"
      title: 6.5.9.  mechanism-too-weak
    - contents:
      - "6.5.10.  not-authorized\n   The authentication failed because the initiating
        entity did not\n   provide proper credentials, or because some generic authentication\n
        \  failure has occurred but the receiving entity does not wish to\n   disclose
        specific information about the cause of the failure; sent in\n   reply to
        a <response/> element or an <auth/> element with initial\n   response data.\n
        \  I: <response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\n        [ ... ]\n
        \     </response>\n   R: <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\n
        \       <not-authorized/>\n      </failure>\n      Security Warning: This
        error condition includes but is not limited\n      to the case of incorrect
        credentials or a nonexistent username.\n      In order to discourage directory
        harvest attacks, no\n      differentiation is made between incorrect credentials
        and a\n      nonexistent username.\n"
      title: 6.5.10.  not-authorized
    - contents:
      - "6.5.11.  temporary-auth-failure\n   The authentication failed because of
        a temporary error condition\n   within the receiving entity, and it is advisable
        for the initiating\n   entity to try again later; sent in reply to an <auth/>
        element or a\n   <response/> element.\n   I: <response xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\n
        \       [ ... ]\n      </response>\n   R: <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\n
        \       <temporary-auth-failure/>\n      </failure>\n"
      title: 6.5.11.  temporary-auth-failure
    title: 6.5.  SASL Errors
  - contents:
    - "6.6.  SASL Definition\n   The profiling requirements of [SASL] require that
      the following\n   information be supplied by the definition of a using protocol.\n
      \  service name:  \"xmpp\"\n   initiation sequence:  After the initiating entity
      provides an opening\n      XML stream header and the receiving entity replies
      in kind, the\n      receiving entity provides a list of acceptable authentication\n
      \     methods.  The initiating entity chooses one method from the list\n      and
      sends it to the receiving entity as the value of the\n      'mechanism' attribute
      possessed by an <auth/> element, optionally\n      including an initial response
      to avoid a round trip.\n   exchange sequence:  Challenges and responses are
      carried through the\n      exchange of <challenge/> elements from receiving
      entity to\n      initiating entity and <response/> elements from initiating
      entity\n      to receiving entity.  The receiving entity reports failure by\n
      \     sending a <failure/> element and success by sending a <success/>\n      element;
      the initiating entity aborts the exchange by sending an\n      <abort/> element.
      \ Upon successful negotiation, both sides\n      consider the original XML stream
      to be closed and new stream\n      headers are sent by both entities.\n   security
      layer negotiation:  The security layer takes effect\n      immediately after
      sending the closing '>' character of the\n      <success/> element for the receiving
      entity, and immediately after\n      receiving the closing '>' character of
      the <success/> element for\n      the initiating entity.  The order of layers
      is first [TCP], then\n      [TLS], then [SASL], then XMPP.\n   use of the authorization
      identity:  The authorization identity can be\n      used in XMPP to denote the
      non-default <localpart@domainpart> of a\n      client; an empty string is equivalent
      to an absent authorization\n      identity.\n"
    title: 6.6.  SASL Definition
  title: 6.  SASL Negotiation
- contents:
  - '7.  Resource Binding

    '
  - contents:
    - "7.1.  Fundamentals\n   After a client authenticates with a server, it MUST
      bind a specific\n   resource to the stream so that the server can properly address
      the\n   client.  That is, there MUST be an XMPP resource associated with the\n
      \  bare JID (<localpart@domainpart>) of the client, so that the address\n   for
      use over that stream is a full JID of the form\n   <localpart@domainpart/resource>
      (including the resourcepart).  This\n   ensures that the server can deliver
      XML stanzas to and receive XML\n   stanzas from the client in relation to entities
      other than the server\n   itself or the client's account, as explained under
      Section 10.\n      Informational Note: The client could exchange stanzas with
      the\n      server itself or the client's account before binding a resource\n
      \     since the full JID is needed only for addressing outside the\n      context
      of the stream negotiated between the client and the\n      server, but this
      is not commonly done.\n   After a client has bound a resource to the stream,
      it is referred to\n   as a \"connected resource\".  A server SHOULD allow an
      entity to\n   maintain multiple connected resources simultaneously, where each\n
      \  connected resource is associated with a distinct XML stream and is\n   differentiated
      from the other connected resources by a distinct\n   resourcepart.\n      Security
      Warning: A server SHOULD enable the administrator of an\n      XMPP service
      to limit the number of connected resources in order\n      to prevent certain
      denial-of-service attacks as described under\n      Section 13.12.\n   If, before
      completing the resource binding step, the client attempts\n   to send an XML
      stanza to an entity other than the server itself or\n   the client's account,
      the server MUST NOT process the stanza and MUST\n   close the stream with a
      <not-authorized/> stream error\n   (Section 4.9.3.12).\n   The XML namespace
      name for the resource binding extension is\n   'urn:ietf:params:xml:ns:xmpp-bind'.\n"
    title: 7.1.  Fundamentals
  - contents:
    - "7.2.  Support\n   Support for resource binding is REQUIRED in XMPP client and
      server\n   implementations.\n"
    title: 7.2.  Support
  - contents:
    - '7.3.  Stream Negotiation Rules

      '
    - contents:
      - "7.3.1.  Mandatory-to-Negotiate\n   The parties to a stream MUST consider
        resource binding as mandatory-\n   to-negotiate.\n"
      title: 7.3.1.  Mandatory-to-Negotiate
    - contents:
      - "7.3.2.  Restart\n   After resource binding, the parties MUST NOT restart
        the stream.\n"
      title: 7.3.2.  Restart
    title: 7.3.  Stream Negotiation Rules
  - contents:
    - "7.4.  Advertising Support\n   Upon sending a new response stream header to
      the client after\n   successful SASL negotiation, the server MUST include a
      <bind/>\n   element qualified by the 'urn:ietf:params:xml:ns:xmpp-bind' namespace\n
      \  in the stream features it presents to the client.\n   The server MUST NOT
      include the resource binding stream feature until\n   after the client has authenticated,
      typically by means of successful\n   SASL negotiation.\n   S: <stream:stream\n
      \         from='im.example.com'\n          id='gPybzaOzBmaADgxKXu9UClbprp0='\n
      \         to='juliet@im.example.com'\n          version='1.0'\n          xml:lang='en'\n
      \         xmlns='jabber:client'\n          xmlns:stream='http://etherx.jabber.org/streams'>\n
      \  S: <stream:features>\n        <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'/>\n
      \     </stream:features>\n   Upon being informed that resource binding is mandatory-to-negotiate,\n
      \  the client MUST bind a resource to the stream as described in the\n   following
      sections.\n"
    title: 7.4.  Advertising Support
  - contents:
    - "7.5.  Generation of Resource Identifiers\n   A resourcepart MUST at a minimum
      be unique among the connected\n   resources for that <localpart@domainpart>.
      \ Enforcement of this\n   policy is the responsibility of the server.\n      Security
      Warning: A resourcepart can be security-critical.  For\n      example, if a
      malicious entity can guess a client's resourcepart\n      then it might be able
      to determine if the client (and therefore\n      the controlling principal)
      is online or offline, thus resulting in\n      a presence leak as described
      under Section 13.10.2.  To prevent\n      that possibility, a client can either
      (1) generate a random\n      resourcepart on its own or (2) ask the server to
      generate a\n      resourcepart on its behalf.  One method for ensuring that
      the\n      resourcepart is random is to generate a Universally Unique\n      Identifier
      (UUID) as specified in [UUID].\n"
    title: 7.5.  Generation of Resource Identifiers
  - contents:
    - "7.6.  Server-Generated Resource Identifier\n   A server MUST be able to generate
      an XMPP resourcepart on behalf of a\n   client.  The resourcepart generated
      by the server MUST be random (see\n   [RANDOM]).\n"
    - contents:
      - "7.6.1.  Success Case\n   A client requests a server-generated resourcepart
        by sending an IQ\n   stanza of type \"set\" (see Section 8.2.3) containing
        an empty <bind/>\n   element qualified by the 'urn:ietf:params:xml:ns:xmpp-bind'\n
        \  namespace.\n   C: <iq id='tn281v37' type='set'>\n       <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'/>\n
        \     </iq>\n   Once the server has generated an XMPP resourcepart for the
        client, it\n   MUST return an IQ stanza of type \"result\" to the client,
        which MUST\n   include a <jid/> child element that specifies the full JID
        for the\n   connected resource as determined by the server.\n   S: <iq id='tn281v37'
        type='result'>\n       <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>\n         <jid>\n
        \          juliet@im.example.com/4db06f06-1ea4-11dc-aca3-000bcd821bfb\n         </jid>\n
        \      </bind>\n      </iq>\n"
      title: 7.6.1.  Success Case
    - contents:
      - "7.6.2.  Error Cases\n   When a client asks the server to generate a resourcepart
        during\n   resource binding, the following stanza error conditions are defined:\n
        \  o  The account has reached a limit on the number of simultaneous\n      connected
        resources allowed.\n   o  The client is otherwise not allowed to bind a resource
        to the\n      stream.\n   Naturally, it is possible that error conditions
        not specified here\n   might occur, as described under Section 8.3.\n"
      - contents:
        - "7.6.2.1.  Resource Constraint\n   If the account has reached a limit on
          the number of simultaneous\n   connected resources allowed, the server MUST
          return a <resource-\n   constraint/> stanza error (Section 8.3.3.18).\n
          \  S: <iq id='tn281v37' type='error'>\n        <error type='wait'>\n          <resource-constraint\n
          \             xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n        </error>\n
          \     </iq>\n"
        title: 7.6.2.1.  Resource Constraint
      - contents:
        - "7.6.2.2.  Not Allowed\n   If the client is otherwise not allowed to bind
          a resource to the\n   stream, the server MUST return a <not-allowed/> stanza
          error\n   (Section 8.3.3.10).\n   S: <iq id='tn281v37' type='error'>\n        <error
          type='cancel'>\n          <not-allowed\n              xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n
          \       </error>\n      </iq>\n"
        title: 7.6.2.2.  Not Allowed
      title: 7.6.2.  Error Cases
    title: 7.6.  Server-Generated Resource Identifier
  - contents:
    - "7.7.  Client-Submitted Resource Identifier\n   Instead of asking the server
      to generate a resourcepart on its\n   behalf, a client MAY attempt to submit
      a resourcepart that it has\n   generated or that the controlling user has provided.\n"
    - contents:
      - "7.7.1.  Success Case\n   A client asks its server to accept a client-submitted
        resourcepart by\n   sending an IQ stanza of type \"set\" containing a <bind/>
        element with\n   a child <resource/> element containing non-zero-length XML
        character\n   data.\n   C: <iq id='wy2xa82b4' type='set'>\n        <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>\n
        \         <resource>balcony</resource>\n        </bind>\n      </iq>\n   The
        server SHOULD accept the client-submitted resourcepart.  It does\n   so by
        returning an IQ stanza of type \"result\" to the client,\n   including a <jid/>
        child element that specifies the full JID for the\n   connected resource and
        contains without modification the client-\n   submitted text.\n   S: <iq id='wy2xa82b4'
        type='result'>\n       <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>\n         <jid>juliet@im.example.com/balcony</jid>\n
        \      </bind>\n      </iq>\n   Alternatively, in accordance with local service
        policies the server\n   MAY refuse the client-submitted resourcepart and override
        it with a\n   resourcepart that the server generates.\n   S: <iq id='wy2xa82b4'
        type='result'>\n       <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>\n         <jid>\n
        \     juliet@im.example.com/balcony 4db06f06-1ea4-11dc-aca3-000bcd821bfb\n
        \        </jid>\n       </bind>\n      </iq>\n"
      title: 7.7.1.  Success Case
    - contents:
      - "7.7.2.  Error Cases\n   When a client attempts to submit its own XMPP resourcepart
        during\n   resource binding, the following stanza error conditions are defined\n
        \  in addition to those described under Section 7.6.2:\n   o  The provided
        resourcepart cannot be processed by the server.\n   o  The provided resourcepart
        is already in use.\n   Naturally, it is possible that error conditions not
        specified here\n   might occur, as described under Section 8.3.\n"
      - contents:
        - "7.7.2.1.  Bad Request\n   If the provided resourcepart cannot be processed
          by the server (e.g.,\n   because it is of zero length or because it otherwise
          violates the\n   rules for resourceparts specified in [XMPP-ADDR]), the
          server can\n   return a <bad-request/> stanza error (Section 8.3.3.1) but
          SHOULD\n   instead process the resourcepart so that it is in conformance.\n
          \  S: <iq id='wy2xa82b4' type='error'>\n        <error type='modify'>\n
          \         <bad-request xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n        </error>\n
          \     </iq>\n"
        title: 7.7.2.1.  Bad Request
      - contents:
        - "7.7.2.2.  Conflict\n   If there is a currently connected client whose session
          has the\n   resourcepart being requested by the newly connecting client,
          the\n   server MUST do one of the following (which of these the server does\n
          \  is a matter for implementation or local service policy, although\n   suggestions
          are provided below).\n   1.  Override the resourcepart provided by the newly
          connecting client\n       with a server-generated resourcepart.  This behavior
          is\n       encouraged, because it simplifies the resource binding process\n
          \      for client implementations.\n   2.  Disallow the resource binding
          attempt of the newly connecting\n       client and maintain the session
          of the currently connected\n       client.  This behavior is neither encouraged
          nor discouraged,\n       despite the fact that it was implicitly encouraged
          in RFC 3920;\n       however, note that handling of the <conflict/> error
          is unevenly\n       supported among existing client implementations, which
          often\n       treat it as an authentication error and have been observed
          to\n       discard cached credentials when receiving it.\n   3.  Terminate
          the session of the currently connected client and allow\n       the resource
          binding attempt of the newly connecting client.\n       Although this was
          the traditional behavior of early XMPP server\n       implementations, it
          is now discouraged because it can lead to a\n       never-ending cycle of
          two clients effectively disconnecting each\n       other; however, note
          that this behavior can be appropriate in\n       some deployment scenarios
          or if the server knows that the\n       currently connected client has a
          dead connection or broken stream\n       as described under Section 4.6.\n
          \  If the server follows behavior #1, it returns an <iq/> stanza of type\n
          \  \"result\" to the newly connecting client, where the <jid/> child of\n
          \  the <bind/> element contains XML character data that indicates the\n
          \  full JID of the client, including the resourcepart that was generated\n
          \  by the server.\n   S: <iq id='wy2xa82b4' type='result'>\n       <bind
          xmlns='urn:ietf:params:xml:ns:xmpp-bind'>\n         <jid>\n      juliet@im.example.com/balcony
          4db06f06-1ea4-11dc-aca3-000bcd821bfb\n         </jid>\n       </bind>\n
          \     </iq>\n   If the server follows behavior #2, it sends a <conflict/>
          stanza\n   error (Section 8.3.3.2) in response to the resource binding attempt\n
          \  of the newly connecting client but maintains the XML stream so that\n
          \  the newly connecting client has an opportunity to negotiate a non-\n
          \  conflicting resourcepart (i.e., the newly connecting client needs to\n
          \  choose a different resourcepart before making another attempt to bind\n
          \  a resource).\n   S: <iq id='wy2xa82b4' type='error'>\n        <error
          type='modify'>\n          <conflict xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n
          \       </error>\n      </iq>\n   If the server follows behavior #3, it
          returns a <conflict/> stream\n   error (Section 4.9.3.3) to the currently
          connected client (as\n   described under Section 4.9.3.3) and returns an
          IQ stanza of type\n   \"result\" (indicating success) in response to the
          resource binding\n   attempt of the newly connecting client.\n   S: <iq
          id='wy2xa82b4' type='result'>\n        <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>\n
          \         <jid>\n            juliet@im.example.com/balcony\n          </jid>\n
          \       </bind>\n      </iq>\n"
        title: 7.7.2.2.  Conflict
      title: 7.7.2.  Error Cases
    - contents:
      - "7.7.3.  Retries\n   If an error occurs when a client submits a resourcepart,
        the server\n   SHOULD allow a configurable but reasonable number of retries
        (at\n   least 5 and no more than 10); this enables the client to tolerate\n
        \  incorrectly provided resourceparts (e.g., bad data formats or\n   duplicate
        text strings) without being forced to reconnect.\n   After the client has
        reached the retry limit, the server MUST close\n   the stream with a <policy-violation/>
        stream error\n   (Section 4.9.3.14).\n"
      title: 7.7.3.  Retries
    title: 7.7.  Client-Submitted Resource Identifier
  title: 7.  Resource Binding
- contents:
  - "8.  XML Stanzas\n   After a client and a server (or two servers) have completed
    stream\n   negotiation, either party can send XML stanzas.  Three kinds of XML\n
    \  stanza are defined for the 'jabber:client' and 'jabber:server'\n   namespaces:
    <message/>, <presence/>, and <iq/>.  In addition, there\n   are five common attributes
    for these stanza types.  These common\n   attributes, as well as the basic semantics
    of the three stanza types,\n   are defined in this specification; more detailed
    information\n   regarding the syntax of XML stanzas for instant messaging and\n
    \  presence applications is provided in [XMPP-IM], and for other\n   applications
    in the relevant XMPP extension specifications.\n   Support for the XML stanza
    syntax and semantics defined in this\n   specification is REQUIRED in XMPP client
    and server implementations.\n      Security Warning: A server MUST NOT process
    a partial stanza and\n      MUST NOT attach meaning to the transmission timing
    of any part of\n      a stanza (before receipt of the closing tag).\n"
  - contents:
    - "8.1.  Common Attributes\n   The following five attributes are common to message,
      presence, and IQ\n   stanzas.\n"
    - contents:
      - "8.1.1.  to\n   The 'to' attribute specifies the JID of the intended recipient
        for\n   the stanza.\n   <message to='romeo@example.net'>\n     <body>Art thou
        not Romeo, and a Montague?</body>\n   </message>\n   For information about
        server processing of inbound and outbound XML\n   stanzas based on the 'to'
        address, refer to Section 10.\n"
      - contents:
        - "8.1.1.1.  Client-to-Server Streams\n   The following rules apply to inclusion
          of the 'to' attribute in\n   stanzas sent from a connected client to its
          server over an XML stream\n   qualified by the 'jabber:client' namespace.\n
          \  1.  A stanza with a specific intended recipient (e.g., a conversation\n
          \      partner, a remote service, the server itself, even another\n       resource
          associated with the user's bare JID) MUST possess a 'to'\n       attribute
          whose value is an XMPP address.\n   2.  A stanza sent from a client to a
          server for direct processing by\n       the server (e.g., roster processing
          as described in [XMPP-IM] or\n       presence sent to the server for broadcasting
          to other entities)\n       MUST NOT possess a 'to' attribute.\n   The following
          rules apply to inclusion of the 'to' attribute in\n   stanzas sent from
          a server to a connected client over an XML stream\n   qualified by the 'jabber:client'
          namespace.\n   1.  If the server has received the stanza from another connected\n
          \      client or from a peer server, the server MUST NOT modify the 'to'\n
          \      address before delivering the stanza to the client.\n   2.  If the
          server has itself generated the stanza (e.g., a response\n       to an IQ
          stanza of type \"get\" or \"set\", even if the stanza did\n       not include
          a 'to' address), the stanza MAY include a 'to'\n       address, which MUST
          be the full JID of the client; however, if\n       the stanza does not include
          a 'to' address then the client MUST\n       treat it as if the 'to' address
          were included with a value of the\n       client's full JID.\n      Implementation
          Note: It is the server's responsibility to deliver\n      only stanzas that
          are addressed to the client's full JID or the\n      user's bare JID; thus,
          there is no need for the client to check\n      the 'to' address of incoming
          stanzas.  However, if the client does\n      check the 'to' address then
          it is suggested to check at most the\n      bare JID portion (not the full
          JID), since the 'to' address might\n      be the user's bare JID, the client's
          current full JID, or even a\n      full JID with a different resourcepart
          (e.g., in the case of so-\n      called \"offline messages\" as described
          in [XEP-0160]).\n"
        title: 8.1.1.1.  Client-to-Server Streams
      - contents:
        - "8.1.1.2.  Server-to-Server Streams\n   The following rules apply to inclusion
          of the 'to' attribute in the\n   context of XML streams qualified by the
          'jabber:server' namespace\n   (i.e., server-to-server streams).\n   1.  A
          stanza MUST possess a 'to' attribute whose value is an XMPP\n       address;
          if a server receives a stanza that does not meet this\n       restriction,
          it MUST close the stream with an <improper-\n       addressing/> stream
          error (Section 4.9.3.7).\n   2.  The domainpart of the JID contained in
          the stanza's 'to'\n       attribute MUST match the FQDN of the receiving
          server (or any\n       validated domain thereof) as communicated via SASL
          negotiation\n       (see Section 6), Server Dialback (see [XEP-0220]), or
          similar\n       means; if a server receives a stanza that does not meet
          this\n       restriction, it MUST close the stream with a <host-unknown/>\n
          \      stream error (Section 4.9.3.6) or a <host-gone/> stream error\n       (Section
          4.9.3.5).\n"
        title: 8.1.1.2.  Server-to-Server Streams
      title: 8.1.1.  to
    - contents:
      - "8.1.2.  from\n   The 'from' attribute specifies the JID of the sender.\n
        \  <message from='juliet@im.example.com/balcony'\n            to='romeo@example.net'>\n
        \    <body>Art thou not Romeo, and a Montague?</body>\n   </message>\n"
      - contents:
        - "8.1.2.1.  Client-to-Server Streams\n   The following rules apply to the
          'from' attribute in the context of\n   XML streams qualified by the 'jabber:client'
          namespace (i.e., client-\n   to-server streams).\n   1.  When a server receives
          an XML stanza from a connected client, the\n       server MUST add a 'from'
          attribute to the stanza or override the\n       'from' attribute specified
          by the client, where the value of the\n       'from' attribute MUST be the
          full JID\n       (<localpart@domainpart/resource>) determined by the server
          for\n       the connected resource that generated the stanza (see\n       Section
          4.3.6), or the bare JID (<localpart@domainpart>) in the\n       case of
          subscription-related presence stanzas (see [XMPP-IM]).\n   2.  When the
          server generates a stanza on its own behalf for delivery\n       to the
          client from the server itself, the stanza MUST include a\n       'from'
          attribute whose value is the bare JID (i.e., <domainpart>)\n       of the
          server as agreed upon during stream negotiation (e.g.,\n       based on
          the 'to' attribute of the initial stream header).\n   3.  When the server
          generates a stanza from the server for delivery\n       to the client on
          behalf of the account of the connected client\n       (e.g., in the context
          of data storage services provided by the\n       server on behalf of the
          client), the stanza MUST either (a) not\n       include a 'from' attribute
          or (b) include a 'from' attribute\n       whose value is the account's bare
          JID (<localpart@domainpart>).\n   4.  A server MUST NOT send to the client
          a stanza without a 'from'\n       attribute if the stanza was not generated
          by the server on its\n       own behalf (e.g., if it was generated by another
          client or a peer\n       server and the server is merely delivering it to
          the client on\n       behalf of some other entity); therefore, when a client
          receives a\n       stanza that does not include a 'from' attribute, it MUST
          assume\n       that the stanza is from the user's account on the server.\n"
        title: 8.1.2.1.  Client-to-Server Streams
      - contents:
        - "8.1.2.2.  Server-to-Server Streams\n   The following rules apply to the
          'from' attribute in the context of\n   XML streams qualified by the 'jabber:server'
          namespace (i.e., server-\n   to-server streams).\n   1.  A stanza MUST possess
          a 'from' attribute whose value is an XMPP\n       address; if a server receives
          a stanza that does not meet this\n       restriction, it MUST close the
          stream with an <improper-\n       addressing/> stream error (Section 4.9.3.7).\n
          \  2.  The domainpart of the JID contained in the stanza's 'from'\n       attribute
          MUST match the FQDN of the sending server (or any\n       validated domain
          thereof) as communicated via SASL negotiation\n       (see Section 6), Server
          Dialback (see [XEP-0220]), or similar\n       means; if a server receives
          a stanza that does not meet this\n       restriction, it MUST close the
          stream with an <invalid-from/>\n       stream error (Section 4.9.3.9).\n
          \  Enforcement of these rules helps to prevent certain denial-of-service\n
          \  attacks as described under Section 13.12.\n"
        title: 8.1.2.2.  Server-to-Server Streams
      title: 8.1.2.  from
    - contents:
      - "8.1.3.  id\n   The 'id' attribute is used by the originating entity to track
        any\n   response or error stanza that it might receive in relation to the\n
        \  generated stanza from another entity (such as an intermediate server\n
        \  or the intended recipient).\n   It is up to the originating entity whether
        the value of the 'id'\n   attribute is unique only within its current stream
        or unique\n   globally.\n   For <message/> and <presence/> stanzas, it is
        RECOMMENDED for the\n   originating entity to include an 'id' attribute; for
        <iq/> stanzas,\n   it is REQUIRED.\n   If the generated stanza includes an
        'id' attribute then it is\n   REQUIRED for the response or error stanza to
        also include an 'id'\n   attribute, where the value of the 'id' attribute
        MUST match that of\n   the generated stanza.\n   The semantics of IQ stanzas
        impose additional restrictions as\n   described under Section 8.2.3.\n"
      title: 8.1.3.  id
    - contents:
      - "8.1.4.  type\n   The 'type' attribute specifies the purpose or context of
        the message,\n   presence, or IQ stanza.  The particular allowable values
        for the\n   'type' attribute vary depending on whether the stanza is a message,\n
        \  presence, or IQ stanza.  The defined values for message and presence\n
        \  stanzas are specific to instant messaging and presence applications\n   and
        therefore are defined in [XMPP-IM], whereas the values for IQ\n   stanzas
        specify the part of the semantics for all structured request-\n   response
        exchanges (no matter what the payload) and therefore are\n   specified under
        Section 8.2.3.  The only 'type' value common to all\n   three kinds of stanzas
        is \"error\" as described under Section 8.3.\n"
      title: 8.1.4.  type
    - contents:
      - "8.1.5.  xml:lang\n   A stanza SHOULD possess an 'xml:lang' attribute (as
        defined in\n   Section 2.12 of [XML]) if the stanza contains XML character
        data that\n   is intended to be presented to a human user (as explained in\n
        \  [CHARSETS], \"internationalization is for humans\").  The value of the\n
        \  'xml:lang' attribute specifies the default language of any such\n   human-readable
        XML character data.\n   <presence from='romeo@example.net/orchard' xml:lang='en'>\n
        \    <show>dnd</show>\n     <status>Wooing Juliet</status>\n   </presence>\n
        \  The value of the 'xml:lang' attribute MAY be overridden by the 'xml:\n
        \  lang' attribute of a specific child element.\n   <presence from='romeo@example.net/orchard'
        xml:lang='en'>\n     <show>dnd</show>\n     <status>Wooing Juliet</status>\n
        \    <status xml:lang='cs'>Dvo&#x0159;&#x00ED;m se Julii</status>\n   </presence>\n
        \  If an outbound stanza generated by a client does not possess an 'xml:\n
        \  lang' attribute, the client's server SHOULD add an 'xml:lang'\n   attribute
        whose value is that specified for the client's output\n   stream as defined
        under Section 4.7.4.\n   C: <presence from='romeo@example.net/orchard'>\n
        \       <show>dnd</show>\n        <status>Wooing Juliet</status>\n      </presence>\n
        \  S: <presence from='romeo@example.net/orchard'\n                to='juliet@im.example.com'\n
        \               xml:lang='en'>\n        <show>dnd</show>\n        <status>Wooing
        Juliet</status>\n      </presence>\n   If an inbound stanza received by a
        client or server does not possess\n   an 'xml:lang' attribute, an implementation
        MUST assume that the\n   default language is that specified for the entity's
        input stream as\n   defined under Section 4.7.4.\n   The value of the 'xml:lang'
        attribute MUST conform to the NMTOKEN\n   datatype (as defined in Section
        2.3 of [XML]) and MUST conform to the\n   format defined in [LANGTAGS].\n
        \  A server MUST NOT modify or delete 'xml:lang' attributes on stanzas\n   it
        receives from other entities.\n"
      title: 8.1.5.  xml:lang
    title: 8.1.  Common Attributes
  - contents:
    - '8.2.  Basic Semantics

      '
    - contents:
      - "8.2.1.  Message Semantics\n   The <message/> stanza is a \"push\" mechanism
        whereby one entity pushes\n   information to another entity, similar to the
        communications that\n   occur in a system such as email.  All message stanzas
        will possess a\n   'to' attribute that specifies the intended recipient of
        the message\n   (see Section 8.1.1 and Section 10.3), unless the message is
        being\n   sent to the bare JID of a connected client's account.  Upon receiving\n
        \  a message stanza with a 'to' address, a server SHOULD attempt to\n   route
        or deliver it to the intended recipient (see Section 10 for\n   general routing
        and delivery rules related to XML stanzas).\n"
      title: 8.2.1.  Message Semantics
    - contents:
      - "8.2.2.  Presence Semantics\n   The <presence/> stanza is a specialized \"broadcast\"
        or \"publish-\n   subscribe\" mechanism, whereby multiple entities receive
        information\n   (in this case, network availability information) about an
        entity to\n   which they have subscribed.  In general, a publishing client
        SHOULD\n   send a presence stanza with no 'to' attribute, in which case the\n
        \  server to which the client is connected will broadcast that stanza to\n
        \  all subscribed entities.  However, a publishing client MAY also send\n
        \  a presence stanza with a 'to' attribute, in which case the server\n   will
        route or deliver that stanza to the intended recipient.\n   Although the <presence/>
        stanza is most often used by XMPP clients,\n   it can also be used by servers,
        add-on services, and any other kind\n   of XMPP entity.  See Section 10 for
        general routing and delivery\n   rules related to XML stanzas, and [XMPP-IM]
        for rules specific to\n   presence applications.\n"
      title: 8.2.2.  Presence Semantics
    - contents:
      - "8.2.3.  IQ Semantics\n   Info/Query, or IQ, is a \"request-response\" mechanism,
        similar in some\n   ways to the Hypertext Transfer Protocol [HTTP].  The semantics
        of IQ\n   enable an entity to make a request of, and receive a response from,\n
        \  another entity.  The data content of the request and response is\n   defined
        by the schema or other structural definition associated with\n   the XML namespace
        that qualifies the direct child element of the IQ\n   element (see Section
        8.4), and the interaction is tracked by the\n   requesting entity through
        use of the 'id' attribute.  Thus, IQ\n   interactions follow a common pattern
        of structured data exchange such\n   as get/result or set/result (although
        an error can be returned in\n   reply to a request if appropriate):\n   Requesting
        \                 Responding\n     Entity                      Entity\n   ----------
        \                 ----------\n       |                            |\n       |
        <iq id='1' type='get'>     |\n       |   [ ... payload ... ]      |\n       |
        </iq>                      |\n       | -------------------------> |\n       |
        \                           |\n       | <iq id='1' type='result'>  |\n       |
        \  [ ... payload ... ]      |\n       | </iq>                      |\n       |
        <------------------------- |\n       |                            |\n       |
        <iq id='2' type='set'>     |\n       |   [ ... payload ... ]      |\n       |
        </iq>                      |\n       | -------------------------> |\n       |
        \                           |\n       | <iq id='2' type='error'>   |\n       |
        \  [ ... condition ... ]    |\n       | </iq>                      |\n       |
        <------------------------- |\n       |                            |\n                     Figure
        5: Semantics of IQ Stanzas\n   To enforce these semantics, the following rules
        apply:\n   1.  The 'id' attribute is REQUIRED for IQ stanzas.\n   2.  The
        'type' attribute is REQUIRED for IQ stanzas.  The value MUST\n       be one
        of the following; if not, the recipient or an intermediate\n       router
        MUST return a <bad-request/> stanza error\n       (Section 8.3.3.1).\n       *
        \ get -- The stanza requests information, inquires about what\n          data
        is needed in order to complete further operations, etc.\n       *  set --
        The stanza provides data that is needed for an\n          operation to be
        completed, sets new values, replaces existing\n          values, etc.\n       *
        \ result -- The stanza is a response to a successful get or set\n          request.\n
        \      *  error -- The stanza reports an error that has occurred\n          regarding
        processing or delivery of a get or set request (see\n          Section 8.3).\n
        \  3.  An entity that receives an IQ request of type \"get\" or \"set\" MUST\n
        \      reply with an IQ response of type \"result\" or \"error\".  The\n       response
        MUST preserve the 'id' attribute of the request (or be\n       empty if the
        generated stanza did not include an 'id' attribute).\n   4.  An entity that
        receives a stanza of type \"result\" or \"error\" MUST\n       NOT respond
        to the stanza by sending a further IQ response of\n       type \"result\"
        or \"error\"; however, the requesting entity MAY send\n       another request
        (e.g., an IQ of type \"set\" to provide obligatory\n       information discovered
        through a get/result pair).\n   5.  An IQ stanza of type \"get\" or \"set\"
        MUST contain exactly one\n       child element, which specifies the semantics
        of the particular\n       request.\n   6.  An IQ stanza of type \"result\"
        MUST include zero or one child\n       elements.\n   7.  An IQ stanza of type
        \"error\" MAY include the child element\n       contained in the associated
        \"get\" or \"set\" and MUST include an\n       <error/> child; for details,
        see Section 8.3.\n"
      title: 8.2.3.  IQ Semantics
    title: 8.2.  Basic Semantics
  - contents:
    - "8.3.  Stanza Errors\n   Stanza-related errors are handled in a manner similar
      to stream\n   errors (Section 4.9).  Unlike stream errors, stanza errors are\n
      \  recoverable; therefore, they do not result in termination of the XML\n   stream
      and underlying TCP connection.  Instead, the entity that\n   discovers the error
      condition returns an error stanza, which is a\n   stanza that:\n   o  is of
      the same kind (message, presence, or IQ) as the generated\n      stanza that
      triggered the error\n   o  has a 'type' attribute set to a value of \"error\"\n
      \  o  typically swaps the 'from' and 'to' addresses of the generated\n      stanza\n
      \  o  mirrors the 'id' attribute (if any) of the generated stanza that\n      triggered
      the error\n   o  contains an <error/> child element that specifies the error\n
      \     condition and therefore provides a hint regarding actions that the\n      sender
      might be able to take in an effort to remedy the error\n      (however, it is
      not always possible to remedy the error)\n"
    - contents:
      - "8.3.1.  Rules\n   The following rules apply to stanza errors:\n   1.  The
        receiving or processing entity that detects an error\n       condition in
        relation to a stanza SHOULD return an error stanza\n       (and MUST do so
        for IQ stanzas).\n   2.  The error stanza SHOULD simply swap the 'from' and
        'to' addresses\n       from the generated stanza, unless doing so would (1)
        result in an\n       information leak (see under Section 13.10) or other breach
        of\n       security, or (2) force the sender of the error stanza to include\n
        \      a malformed JID in the 'from' or 'to' address of the error\n       stanza.\n
        \  3.  If the generated stanza was <message/> or <presence/> and\n       included
        an 'id' attribute then it is REQUIRED for the error\n       stanza to also
        include an 'id' attribute.  If the generated\n       stanza was <iq/> then
        the error stanza MUST include an 'id'\n       attribute.  In all cases, the
        value of the 'id' attribute MUST\n       match that of the generated stanza
        (or be empty if the generated\n       stanza did not include an 'id' attribute).\n
        \  4.  An error stanza MUST contain an <error/> child element.\n   5.  The
        entity that returns an error stanza MAY pass along its JID to\n       the
        sender of the generated stanza (e.g., for diagnostic or\n       tracking purposes)
        through the addition of a 'by' attribute to\n       the <error/> child element.\n
        \  6.  The entity that returns an error stanza MAY include the original\n
        \      XML sent so that the sender can inspect and, if necessary,\n       correct
        the XML before attempting to resend (however, this is a\n       courtesy only
        and the originating entity MUST NOT depend on\n       receiving the original
        payload).  Naturally, the entity MUST NOT\n       include the original data
        if it not well-formed XML, violates the\n       XML restrictions of XMPP (see
        under Section 11.1), or is\n       otherwise harmful (e.g., exceeds a size
        limit).\n   7.  An <error/> child MUST NOT be included if the 'type' attribute\n
        \      has a value other than \"error\" (or if there is no 'type'\n       attribute).\n
        \  8.  An entity that receives an error stanza MUST NOT respond to the\n       stanza
        with a further error stanza; this helps to prevent\n       looping.\n"
      title: 8.3.1.  Rules
    - contents:
      - "8.3.2.  Syntax\n   The syntax for stanza-related errors is as follows, where
        XML data\n   shown within the square brackets '[' and ']' is OPTIONAL, 'intended-\n
        \  recipient' is the JID of the entity to which the original stanza was\n
        \  addressed, 'sender' is the JID of the originating entity, and 'error-\n
        \  generator' is the entity that detects the fact that an error has\n   occurred
        and thus returns an error stanza.\n   <stanza-kind from='intended-recipient'
        to='sender' type='error'>\n     [OPTIONAL to include sender XML here]\n     <error
        [by='error-generator']\n            type='error-type'>\n       <defined-condition
        xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n       [<text xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'\n
        \             xml:lang='langcode'>\n         OPTIONAL descriptive text\n       </text>]\n
        \      [OPTIONAL application-specific condition element]\n     </error>\n
        \  </stanza-kind>\n   The \"stanza-kind\" MUST be one of message, presence,
        or iq.\n   The \"error-type\" MUST be one of the following:\n   o  auth --
        retry after providing credentials\n   o  cancel -- do not retry (the error
        cannot be remedied)\n   o  continue -- proceed (the condition was only a warning)\n
        \  o  modify -- retry after changing the data sent\n   o  wait -- retry after
        waiting (the error is temporary)\n   The \"defined-condition\" MUST correspond
        to one of the stanza error\n   conditions defined under Section 8.3.3.  However,
        because additional\n   error conditions might be defined in the future, if
        an entity\n   receives a stanza error condition that it does not understand
        then it\n   MUST treat the unknown condition as equivalent to <undefined-\n
        \  condition/> (Section 8.3.3.21).  If the designers of an XMPP protocol\n
        \  extension or the developers of an XMPP implementation need to\n   communicate
        a stanza error condition that is not defined in this\n   specification, they
        can do so by defining an application-specific\n   error condition element
        qualified by an application-specific\n   namespace.\n   The <error/> element:\n
        \  o  MUST contain a defined condition element.\n   o  MAY contain a <text/>
        child element containing XML character data\n      that describes the error
        in more detail; this element MUST be\n      qualified by the 'urn:ietf:params:xml:ns:xmpp-stanzas'
        namespace\n      and SHOULD possess an 'xml:lang' attribute specifying the
        natural\n      language of the XML character data.\n   o  MAY contain a child
        element for an application-specific error\n      condition; this element MUST
        be qualified by an application-\n      specific namespace that defines the
        syntax and semantics of the\n      element.\n   The <text/> element is OPTIONAL.
        \ If included, it is to be used only\n   to provide descriptive or diagnostic
        information that supplements the\n   meaning of a defined condition or application-specific
        condition.  It\n   MUST NOT be interpreted programmatically by an application.
        \ It\n   SHOULD NOT be used as the error message presented to a human user,\n
        \  but MAY be shown in addition to the error message associated with the\n
        \  defined condition element (and, optionally, the application-specific\n
        \  condition element).\n      Interoperability Note: The syntax defined in
        [RFC3920] included a\n      legacy 'code' attribute, whose semantics have
        been replaced by the\n      defined condition elements; information about
        mapping defined\n      condition elements to values of the legacy 'code' attribute
        can be\n      found in [XEP-0086].\n"
      title: 8.3.2.  Syntax
    - contents:
      - "8.3.3.  Defined Conditions\n   The following conditions are defined for use
        in stanza errors.\n   The error-type value that is RECOMMENDED for each defined
        condition\n   is the usual expected type; however, in some circumstances a\n
        \  different type might be more appropriate.\n"
      - contents:
        - "8.3.3.1.  bad-request\n   The sender has sent a stanza containing XML that
          does not conform to\n   the appropriate schema or that cannot be processed
          (e.g., an IQ\n   stanza that includes an unrecognized value of the 'type'
          attribute,\n   or an element that is qualified by a recognized namespace
          but that\n   violates the defined syntax for the element); the associated
          error\n   type SHOULD be \"modify\".\n   C: <iq from='juliet@im.example.com/balcony'\n
          \         id='zj3v142b'\n          to='im.example.com'\n          type='subscribe'>\n
          \       <ping xmlns='urn:xmpp:ping'/>\n      </iq>\n   S: <iq from='im.example.com'\n
          \         id='zj3v142b'\n          to='juliet@im.example.com/balcony'\n
          \         type='error'>\n        <error type='modify'>\n          <bad-request
          xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n        </error>\n      </iq>\n"
        title: 8.3.3.1.  bad-request
      - contents:
        - "8.3.3.2.  conflict\n   Access cannot be granted because an existing resource
          exists with the\n   same name or address; the associated error type SHOULD
          be \"cancel\".\n   C: <iq id='wy2xa82b4' type='set'>\n        <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>\n
          \         <resource>balcony</resource>\n        </bind>\n      </iq>\n   S:
          <iq id='wy2xa82b4' type='error'>\n        <error type='cancel'>\n          <conflict
          xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n        </error>\n      </iq>\n"
        title: 8.3.3.2.  conflict
      - contents:
        - "8.3.3.3.  feature-not-implemented\n   The feature represented in the XML
          stanza is not implemented by the\n   intended recipient or an intermediate
          server and therefore the stanza\n   cannot be processed (e.g., the entity
          understands the namespace but\n   does not recognize the element name);
          the associated error type\n   SHOULD be \"cancel\" or \"modify\".\n   C:
          <iq from='juliet@im.example.com/balcony'\n          id='9u2bax16'\n          to='pubsub.example.com'\n
          \         type='get'>\n        <pubsub xmlns='http://jabber.org/protocol/pubsub'>\n
          \         <subscriptions/>\n        </pubsub>\n      </iq>\n   E: <iq from='pubsub.example.com'\n
          \         id='9u2bax16'\n          to='juliet@im.example.com/balcony'\n
          \         type='error'>\n        <error type='cancel'>\n          <feature-not-implemented\n
          \             xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n          <unsupported\n
          \             xmlns='http://jabber.org/protocol/pubsub#errors'\n              feature='retrieve-subscriptions'/>\n
          \       </error>\n      </iq>\n"
        title: 8.3.3.3.  feature-not-implemented
      - contents:
        - "8.3.3.4.  forbidden\n   The requesting entity does not possess the necessary
          permissions to\n   perform an action that only certain authorized roles
          or individuals\n   are allowed to complete (i.e., it typically relates to
          authorization\n   rather than authentication); the associated error type
          SHOULD be\n   \"auth\".\n   C: <presence\n          from='juliet@im.example.com/balcony'\n
          \         id='y2bs71v4'\n          to='characters@muc.example.com/JulieC'>\n
          \       <x xmlns='http://jabber.org/protocol/muc'/>\n      </presence>\n
          \  E: <presence\n          from='characters@muc.example.com/JulieC'\n          id='y2bs71v4'\n
          \         to='juliet@im.example.com/balcony'\n          type='error'>\n
          \       <error type='auth'>\n          <forbidden xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n
          \       </error>\n      </presence>\n"
        title: 8.3.3.4.  forbidden
      - contents:
        - "8.3.3.5.  gone\n   The recipient or server can no longer be contacted at
          this address,\n   typically on a permanent basis (as opposed to the <redirect/>
          error\n   condition, which is used for temporary addressing failures); the\n
          \  associated error type SHOULD be \"cancel\" and the error stanza SHOULD\n
          \  include a new address (if available) as the XML character data of the\n
          \  <gone/> element (which MUST be a Uniform Resource Identifier [URI] or\n
          \  Internationalized Resource Identifier [IRI] at which the entity can\n
          \  be contacted, typically an XMPP IRI as specified in [XMPP-URI]).\n   C:
          <message\n          from='juliet@im.example.com/churchyard'\n          id='sj2b371v'\n
          \         to='romeo@example.net'\n          type='chat'>\n        <body>Thy
          lips are warm.</body>\n      </message>\n   S: <message\n          from='romeo@example.net'\n
          \         id='sj2b371v'\n          to='juliet@im.example.com/churchyard'\n
          \         type='error'>\n        <error by='example.net'\n               type='cancel'>\n
          \         <gone xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'>\n            xmpp:romeo@afterlife.example.net\n
          \         </gone>\n        </error>\n      </message>\n"
        title: 8.3.3.5.  gone
      - contents:
        - "8.3.3.6.  internal-server-error\n   The server has experienced a misconfiguration
          or other internal error\n   that prevents it from processing the stanza;
          the associated error\n   type SHOULD be \"cancel\".\n   C: <presence\n          from='juliet@im.example.com/balcony'\n
          \         id='y2bs71v4'\n          to='characters@muc.example.com/JulieC'>\n
          \       <x xmlns='http://jabber.org/protocol/muc'/>\n      </presence>\n
          \  E: <presence\n          from='characters@muc.example.com/JulieC'\n          id='y2bs71v4'\n
          \         to='juliet@im.example.com/balcony'\n          type='error'>\n
          \       <error type='cancel'>\n          <internal-server-error\n              xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n
          \       </error>\n      </presence>\n"
        title: 8.3.3.6.  internal-server-error
      - contents:
        - "8.3.3.7.  item-not-found\n   The addressed JID or item requested cannot
          be found; the associated\n   error type SHOULD be \"cancel\".\n   C: <presence
          from='userfoo@example.com/bar'\n                id='pwb2n78i'\n                to='nosuchroom@conference.example.org/foo'/>\n
          \  S: <presence from='nosuchroom@conference.example.org/foo'\n                id='pwb2n78i'\n
          \               to='userfoo@example.com/bar'\n                type='error'>\n
          \       <error type='cancel'>\n          <item-not-found xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n
          \       </error>\n      </presence>\n      Security Warning: An application
          MUST NOT return this error if\n      doing so would provide information
          about the intended recipient's\n      network availability to an entity
          that is not authorized to know\n      such information (for a more detailed
          discussion of presence\n      authorization, refer to the discussion of
          presence subscriptions\n      in [XMPP-IM]); instead it MUST return a <service-unavailable/>\n
          \     stanza error (Section 8.3.3.19).\n"
        title: 8.3.3.7.  item-not-found
      - contents:
        - "8.3.3.8.  jid-malformed\n   The sending entity has provided (e.g., during
          resource binding) or\n   communicated (e.g., in the 'to' address of a stanza)
          an XMPP address\n   or aspect thereof that violates the rules defined in
          [XMPP-ADDR]; the\n   associated error type SHOULD be \"modify\".\n   C:
          <presence\n          from='juliet@im.example.com/balcony'\n          id='y2bs71v4'\n
          \         to='ch@r@cters@muc.example.com/JulieC'>\n        <x xmlns='http://jabber.org/protocol/muc'/>\n
          \     </presence>\n   E: <presence\n          from='ch@r@cters@muc.example.com/JulieC'\n
          \         id='y2bs71v4'\n          to='juliet@im.example.com/balcony'\n
          \         type='error'>\n        <error by='muc.example.com'\n               type='modify'>\n
          \         <jid-malformed\n              xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n
          \       </error>\n      </presence>\n      Implementation Note: Enforcement
          of the format for XMPP localparts\n      is primarily the responsibility
          of the service at which the\n      associated account or entity is located
          (e.g., the example.com\n      service is responsible for returning <jid-malformed/>
          errors\n      related to all JIDs of the form <localpart@example.com>),
          whereas\n      enforcement of the format for XMPP domainparts is primarily
          the\n      responsibility of the service that seeks to route a stanza to
          the\n      service identified by that domainpart (e.g., the example.org\n
          \     service is responsible for returning <jid-malformed/> errors\n      related
          to stanzas that users of that service have to tried send\n      to JIDs
          of the form <localpart@example.com>).  However, any entity\n      that detects
          a malformed JID MAY return this error.\n"
        title: 8.3.3.8.  jid-malformed
      - contents:
        - "8.3.3.9.  not-acceptable\n   The recipient or server understands the request
          but cannot process it\n   because the request does not meet criteria defined
          by the recipient\n   or server (e.g., a request to subscribe to information
          that does not\n   simultaneously include configuration parameters needed
          by the\n   recipient); the associated error type SHOULD be \"modify\".\n
          \  C: <message to='juliet@im.example.com' id='yt2vs71m'>\n        <body>[
          ... the-emacs-manual ... ]</body>\n      </message>\n   S: <message from='juliet@im.example.com'
          id='yt2vs71m'>\n        <error type='modify'>\n          <not-acceptable\n
          \             xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n        </error>\n
          \     </message>\n"
        title: 8.3.3.9.  not-acceptable
      - contents:
        - "8.3.3.10.  not-allowed\n   The recipient or server does not allow any entity
          to perform the\n   action (e.g., sending to entities at a blacklisted domain);
          the\n   associated error type SHOULD be \"cancel\".\n   C: <presence\n          from='juliet@im.example.com/balcony'\n
          \         id='y2bs71v4'\n          to='characters@muc.example.com/JulieC'>\n
          \       <x xmlns='http://jabber.org/protocol/muc'/>\n      </presence>\n
          \  E: <presence\n          from='characters@muc.example.com/JulieC'\n          id='y2bs71v4'\n
          \         to='juliet@im.example.com/balcony'\n          type='error'>\n
          \       <error type='cancel'>\n          <not-allowed xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n
          \       </error>\n      </presence>\n"
        title: 8.3.3.10.  not-allowed
      - contents:
        - "8.3.3.11.  not-authorized\n   The sender needs to provide credentials before
          being allowed to\n   perform the action, or has provided improper credentials
          (the name\n   \"not-authorized\", which was borrowed from the \"401 Unauthorized\"\n
          \  error of [HTTP], might lead the reader to think that this condition\n
          \  relates to authorization, but instead it is typically used in\n   relation
          to authentication); the associated error type SHOULD be\n   \"auth\".\n
          \  C: <presence\n          from='juliet@im.example.com/balcony'\n          id='y2bs71v4'\n
          \         to='characters@muc.example.com/JulieC'>\n        <x xmlns='http://jabber.org/protocol/muc'/>\n
          \     </presence>\n   E: <presence\n          from='characters@muc.example.com/JulieC'\n
          \         id='y2bs71v4'\n          to='juliet@im.example.com/balcony'>\n
          \       <error type='auth'>\n          <not-authorized xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n
          \       </error>\n      </presence>\n"
        title: 8.3.3.11.  not-authorized
      - contents:
        - "8.3.3.12.  policy-violation\n   The entity has violated some local service
          policy (e.g., a message\n   contains words that are prohibited by the service)
          and the server MAY\n   choose to specify the policy in the <text/> element
          or in an\n   application-specific condition element; the associated error
          type\n   SHOULD be \"modify\" or \"wait\" depending on the policy being
          violated.\n   (In the following example, the client sends an XMPP message\n
          \  containing words that are forbidden according to the server's local\n
          \  service policy.)\n   C: <message from='romeo@example.net/foo'\n               to='bill@im.example.com'\n
          \              id='vq71f4nb'>\n        <body>%#&@^!!!</body>\n      </message>\n
          \  S: <message from='bill@im.example.com'\n               id='vq71f4nb'\n
          \              to='romeo@example.net/foo'>\n        <error by='example.net'
          type='modify'>\n          <policy-violation\n              xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n
          \       </error>\n      </message>\n"
        title: 8.3.3.12.  policy-violation
      - contents:
        - "8.3.3.13.  recipient-unavailable\n   The intended recipient is temporarily
          unavailable, undergoing\n   maintenance, etc.; the associated error type
          SHOULD be \"wait\".\n   C: <presence\n          from='juliet@im.example.com/balcony'\n
          \         id='y2bs71v4'\n          to='characters@muc.example.com/JulieC'>\n
          \       <x xmlns='http://jabber.org/protocol/muc'/>\n      </presence>\n
          \  E: <presence\n          from='characters@muc.example.com/JulieC'\n          id='y2bs71v4'\n
          \         to='juliet@im.example.com/balcony'>\n        <error type='wait'>\n
          \         <recipient-unavailable\n              xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n
          \       </error>\n      </presence>\n      Security Warning: An application
          MUST NOT return this error if\n      doing so would provide information
          about the intended recipient's\n      network availability to an entity
          that is not authorized to know\n      such information (for a more detailed
          discussion of presence\n      authorization, refer to the discussion of
          presence subscriptions\n      in [XMPP-IM]); instead it MUST return a <service-unavailable/>\n
          \     stanza error (Section 8.3.3.19).\n"
        title: 8.3.3.13.  recipient-unavailable
      - contents:
        - "8.3.3.14.  redirect\n   The recipient or server is redirecting requests
          for this information\n   to another entity, typically in a temporary fashion
          (as opposed to\n   the <gone/> error condition, which is used for permanent
          addressing\n   failures); the associated error type SHOULD be \"modify\"
          and the error\n   stanza SHOULD contain the alternate address in the XML
          character data\n   of the <redirect/> element (which MUST be a URI or IRI
          with which the\n   sender can communicate, typically an XMPP IRI as specified
          in\n   [XMPP-URI]).\n   C: <presence\n          from='juliet@im.example.com/balcony'\n
          \         id='y2bs71v4'\n          to='characters@muc.example.com/JulieC'>\n
          \       <x xmlns='http://jabber.org/protocol/muc'/>\n      </presence>\n
          \  E: <presence\n          from='characters@muc.example.com/JulieC'\n          id='y2bs71v4'\n
          \         to='juliet@im.example.com/balcony'\n          type='error'>\n
          \       <error type='modify'>\n          <redirect xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'>\n
          \           xmpp:characters@conference.example.org\n          </redirect>\n
          \       </error>\n      </presence>\n      Security Warning: An application
          receiving a stanza-level redirect\n      SHOULD warn a human user of the
          redirection attempt and request\n      approval before proceeding to communicate
          with the entity whose\n      address is contained in the XML character data
          of the <redirect/>\n      element, because that entity might have a different
          identity or\n      might enforce different security policies.  The end-to-end\n
          \     authentication or signing of XMPP stanzas could help to mitigate\n
          \     this risk, since it would enable the sender to determine if the\n
          \     entity to which it has been redirected has the same identity as\n
          \     the entity it originally attempted to contact.  An application MAY\n
          \     have a policy of following redirects only if it has authenticated\n
          \     the receiving entity.  In addition, an application SHOULD abort\n
          \     the communication attempt after a certain number of successive\n      redirects
          (e.g., at least 2 but no more than 5).\n"
        title: 8.3.3.14.  redirect
      - contents:
        - "8.3.3.15.  registration-required\n   The requesting entity is not authorized
          to access the requested\n   service because prior registration is necessary
          (examples of prior\n   registration include members-only rooms in XMPP multi-user
          chat\n   [XEP-0045] and gateways to non-XMPP instant messaging services,
          which\n   traditionally required registration in order to use the gateway\n
          \  [XEP-0100]); the associated error type SHOULD be \"auth\".\n   C: <presence\n
          \         from='juliet@im.example.com/balcony'\n          id='y2bs71v4'\n
          \         to='characters@muc.example.com/JulieC'>\n        <x xmlns='http://jabber.org/protocol/muc'/>\n
          \     </presence>\n   E: <presence\n          from='characters@muc.example.com/JulieC'\n
          \         id='y2bs71v4'\n          to='juliet@im.example.com/balcony'>\n
          \       <error type='auth'>\n          <registration-required\n              xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n
          \       </error>\n      </presence>\n"
        title: 8.3.3.15.  registration-required
      - contents:
        - "8.3.3.16.  remote-server-not-found\n   A remote server or service specified
          as part or all of the JID of the\n   intended recipient does not exist or
          cannot be resolved (e.g., there\n   is no _xmpp-server._tcp DNS SRV record,
          the A or AAAA fallback\n   resolution fails, or A/AAAA lookups succeed but
          there is no response\n   on the IANA-registered port 5269); the associated
          error type SHOULD\n   be \"cancel\".\n   C: <message\n          from='romeo@example.net/home'\n
          \         id='ud7n1f4h'\n          to='bar@example.org'\n          type='chat'>\n
          \      <body>yt?</body>\n      </message>\n   E: <message\n          from='bar@example.org'\n
          \         id='ud7n1f4h'\n          to='romeo@example.net/home'\n          type='error'>\n
          \       <error type='cancel'>\n          <remote-server-not-found\n              xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n
          \       </error>\n      </message>\n"
        title: 8.3.3.16.  remote-server-not-found
      - contents:
        - "8.3.3.17.  remote-server-timeout\n   A remote server or service specified
          as part or all of the JID of the\n   intended recipient (or needed to fulfill
          a request) was resolved but\n   communications could not be established
          within a reasonable amount of\n   time (e.g., an XML stream cannot be established
          at the resolved IP\n   address and port, or an XML stream can be established
          but stream\n   negotiation fails because of problems with TLS, SASL, Server\n
          \  Dialback, etc.); the associated error type SHOULD be \"wait\" (unless\n
          \  the error is of a more permanent nature, e.g., the remote server is\n
          \  found but it cannot be authenticated or it violates security\n   policies).\n
          \  C: <message\n          from='romeo@example.net/home'\n          id='ud7n1f4h'\n
          \         to='bar@example.org'\n          type='chat'>\n       <body>yt?</body>\n
          \     </message>\n   E: <message\n          from='bar@example.org'\n          id='ud7n1f4h'\n
          \         to='romeo@example.net/home'\n          type='error'>\n        <error
          type='wait'>\n          <remote-server-timeout\n              xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n
          \       </error>\n      </message>\n"
        title: 8.3.3.17.  remote-server-timeout
      - contents:
        - "8.3.3.18.  resource-constraint\n   The server or recipient is busy or lacks
          the system resources\n   necessary to service the request; the associated
          error type SHOULD be\n   \"wait\".\n   C: <iq from='romeo@example.net/foo'\n
          \         id='kj4vz31m'\n          to='pubsub.example.com'\n          type='get'>\n
          \       <pubsub xmlns='http://jabber.org/protocol/pubsub'>\n          <items
          node='my_musings'/>\n        </pubsub>\n      </iq>\n   E: <iq from='pubsub.example.com'\n
          \         id='kj4vz31m'\n          to='romeo@example.net/foo'\n          type='error'>\n
          \       <error type='wait'>\n          <resource-constraint\n              xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n
          \       </error>\n      </iq>\n"
        title: 8.3.3.18.  resource-constraint
      - contents:
        - "8.3.3.19.  service-unavailable\n   The server or recipient does not currently
          provide the requested\n   service; the associated error type SHOULD be \"cancel\".\n
          \  C: <message from='romeo@example.net/foo'\n               to='juliet@im.example.com'>\n
          \       <body>Hello?</body>\n      </message>\n   S: <message from='juliet@im.example.com/foo'\n
          \              to='romeo@example.net'>\n        <error type='cancel'>\n
          \         <service-unavailable\n              xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n
          \       </error>\n      </message>\n      Security Warning: An application
          MUST return a <service-\n      unavailable/> stanza error (Section 8.3.3.19)
          instead of <item-\n      not-found/> (Section 8.3.3.7) or <recipient-unavailable/>\n
          \     (Section 8.3.3.13) if sending one of the latter errors would\n      provide
          information about the intended recipient's network\n      availability to
          an entity that is not authorized to know such\n      information (for a
          more detailed discussion of presence\n      authorization, refer to [XMPP-IM]).\n"
        title: 8.3.3.19.  service-unavailable
      - contents:
        - "8.3.3.20.  subscription-required\n   The requesting entity is not authorized
          to access the requested\n   service because a prior subscription is necessary
          (examples of prior\n   subscription include authorization to receive presence
          information as\n   defined in [XMPP-IM] and opt-in data feeds for XMPP publish-subscribe\n
          \  as defined in [XEP-0060]); the associated error type SHOULD be\n   \"auth\".\n
          \  C: <message\n          from='romeo@example.net/orchard'\n          id='pa73b4n7'\n
          \         to='playwright@shakespeare.example.com'\n          type='chat'>\n
          \       <subject>ACT II, SCENE II</subject>\n        <body>help, I forgot
          my lines!</body>\n      </message>\n   E: <message\n          from='playwright@shakespeare.example.com'\n
          \         id='pa73b4n7'\n          to='romeo@example.net/orchard'\n          type='error'>\n
          \       <error type='auth'>\n          <subscription-required\n              xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n
          \       </error>\n      </message>\n"
        title: 8.3.3.20.  subscription-required
      - contents:
        - "8.3.3.21.  undefined-condition\n   The error condition is not one of those
          defined by the other\n   conditions in this list; any error type can be
          associated with this\n   condition, and it SHOULD NOT be used except in
          conjunction with an\n   application-specific condition.\n   C: <message\n
          \         from='northumberland@shakespeare.example'\n          id='richard2-4.1.247'\n
          \         to='kingrichard@royalty.england.example'>\n        <body>My lord,
          dispatch; read o'er these articles.</body>\n        <amp xmlns='http://jabber.org/protocol/amp'>\n
          \         <rule action='notify'\n                condition='deliver'\n                value='stored'/>\n
          \       </amp>\n      </message>\n   S: <message from='example.org'\n               id='amp1'\n
          \              to='northumberland@example.net/field'\n               type='error'>\n
          \       <amp xmlns='http://jabber.org/protocol/amp'\n             from='kingrichard@example.org'\n
          \            status='error'\n             to='northumberland@example.net/field'>\n
          \         <rule action='error'\n                condition='deliver'\n                value='stored'/>\n
          \       </amp>\n        <error type='modify'>\n          <undefined-condition\n
          \             xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n          <failed-rules
          xmlns='http://jabber.org/protocol/amp#errors'>\n            <rule action='error'\n
          \                 condition='deliver'\n                  value='stored'/>\n
          \         </failed-rules>\n        </error>\n      </message>\n"
        title: 8.3.3.21.  undefined-condition
      - contents:
        - "8.3.3.22.  unexpected-request\n   The recipient or server understood the
          request but was not expecting\n   it at this time (e.g., the request was
          out of order); the associated\n   error type SHOULD be \"wait\" or \"modify\".\n
          \  C: <iq from='romeo@example.net/foo'\n          id='o6hsv25z'\n          to='pubsub.example.com'\n
          \         type='set'>\n        <pubsub xmlns='http://jabber.org/protocol/pubsub'>\n
          \          <unsubscribe\n               node='my_musings'\n               jid='romeo@example.net'/>\n
          \       </pubsub>\n      </iq>\n   E: <iq from='pubsub.example.com'\n          id='o6hsv25z'\n
          \         to='romeo@example.net/foo'\n          type='error'>\n        <error
          type='modify'>\n          <unexpected-request\n              xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n
          \         <not-subscribed\n              xmlns='http://jabber.org/protocol/pubsub#errors'/>\n
          \       </error>\n      </iq>\n"
        title: 8.3.3.22.  unexpected-request
      title: 8.3.3.  Defined Conditions
    - contents:
      - "8.3.4.  Application-Specific Conditions\n   As noted, an application MAY
        provide application-specific stanza\n   error information by including a properly
        namespaced child within the\n   error element.  Typically, the application-specific
        element\n   supplements or further qualifies a defined element.  Thus, the\n
        \  <error/> element will contain two or three child elements.\n   <iq id='ixc3v1b9'
        type='error'>\n     <error type='modify'>\n       <bad-request xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n
        \      <too-many-parameters xmlns='http://example.org/ns'/>\n     </error>\n
        \  </iq>\n   <message type='error' id='7h3baci9'>\n     <error type='modify'>\n
        \      <undefined-condition\n             xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n
        \      <text xml:lang='en'\n             xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'>\n
        \        [ ... application-specific information ... ]\n       </text>\n       <too-many-parameters
        xmlns='http://example.org/ns'/>\n     </error>\n   </message>\n   An entity
        that receives an application-specific error condition it\n   does not understand
        MUST ignore that condition but appropriately\n   process the rest of the error
        stanza.\n"
      title: 8.3.4.  Application-Specific Conditions
    title: 8.3.  Stanza Errors
  - contents:
    - "8.4.  Extended Content\n   Although the message, presence, and IQ stanzas provide
      basic\n   semantics for messaging, availability, and request-response\n   interactions,
      XMPP uses XML namespaces (see [XML-NAMES]) to extend\n   the basic stanza syntax
      for the purpose of providing additional\n   functionality.\n   A message or
      presence stanza MAY contain one or more optional child\n   elements specifying
      content that extends the meaning of the message\n   (e.g., an XHTML-formatted
      version of the message body as described in\n   [XEP-0071]), and an IQ stanza
      of type \"get\" or \"set\" MUST contain one\n   such child element.  Such a
      child element MAY have any name and MUST\n   possess a namespace declaration
      (other than \"jabber:client\", \"jabber:\n   server\", or \"http://etherx.jabber.org/streams\")
      that defines the data\n   contained within the child element.  Such a child
      element is called\n   an \"extension element\".  An extension element can be
      included either\n   at the direct child level of the stanza or in any mix of
      levels.\n   Similarly, \"extension attributes\" are allowed.  That is: a stanza\n
      \  itself (i.e., an <iq/>, <message/>, or <presence/> element qualified\n   by
      the \"jabber:client\" or \"jabber:server\" content namespace) or any\n   child
      element of such a stanza (whether an extension element or a\n   child element
      qualified by the content namespace) MAY also include\n   one or more attributes
      qualified by XML namespaces other than the\n   content namespace or the reserved\n
      \  \"http://www.w3.org/XML/1998/namespace\" namespace (including the so-\n   called
      \"empty namespace\" if the attribute is not prefixed as\n   described under
      [XML-NAMES]).\n      Interoperability Note: For the sake of backward compatibility
      and\n      maximum interoperability, an entity that generates a stanza SHOULD\n
      \     NOT include such attributes in the stanza itself or in child\n      elements
      of the stanza that are qualified by the content\n      namespaces \"jabber:client\"
      or \"jabber:server\" (e.g., the <body/>\n      child of the <message/> stanza).\n
      \  An extension element or extension attribute is said to be \"extended\n   content\"
      and the qualifying namespace for such an element or\n   attribute is said to
      be an \"extended namespace\".\n      Informational Note: Although extended namespaces
      for XMPP are\n      commonly defined by the XMPP Standards Foundation (XSF)
      and by the\n      IETF, no specification or IETF standards action is necessary
      to\n      define extended namespaces, and any individual or organization is\n
      \     free to define XMPP extensions.\n   To illustrate these concepts, several
      examples follow.\n   The following stanza contains one direct child element
      whose extended\n   namespace is 'jabber:iq:roster':\n   <iq from='juliet@capulet.com/balcony'\n
      \      id='h83vxa4c'\n       type='get'>\n    <query xmlns='jabber:iq:roster'/>\n
      \  </iq>\n   The following stanza contains two direct child elements with two\n
      \  different extended namespaces.\n   <presence from='juliet@capulet.com/balcony'>\n
      \    <c xmlns='http://jabber.org/protocol/caps'\n        hash='sha-1'\n        node='http://code.google.com/p/exodus'\n
      \       ver='QgayPKawpkPSDYmwT/WM94uAlu0='/>\n     <x xmlns='vcard-temp:x:update'>\n
      \      <photo>sha1-hash-of-image</photo>\n     </x>\n   </presence>\n   The
      following stanza contains two child elements, one of which is\n   qualified
      by the \"jabber:client\" or \"jabber:server\" content namespace\n   and one
      of which is qualified by an extended namespace; the extension\n   element in
      turn contains a child element that is qualified by a\n   different extended
      namespace.\n   <message to='juliet@capulet.com'>\n     <body>Hello?</body>\n
      \    <html xmlns='http://jabber.org/protocol/xhtml-im'>\n       <body xmlns='http://www.w3.org/1999/xhtml'>\n
      \        <p style='font-weight:bold'>Hello?</p>\n       </body>\n     </html>\n
      \  </message>\n   It is conventional in the XMPP community for implementations
      to not\n   generate namespace prefixes for elements that are qualified by\n
      \  extended namespaces (in the XML community, this convention is\n   sometimes
      called \"prefix-free canonicalization\").  However, if an\n   implementation
      generates such namespace prefixes then it MUST include\n   the namespace declaration
      in the stanza itself or a child element of\n   the stanza, not in the stream
      header (see Section 4.8.4).\n   Routing entities (typically servers) SHOULD
      try to maintain prefixes\n   when serializing XML stanzas for processing, but
      receiving entities\n   MUST NOT depend on the prefix strings to have any particular
      value\n   (the allowance for the 'stream' prefix, described under\n   Section
      4.8.5, is an exception to this rule, albeit for streams\n   rather than stanzas).\n
      \  Support for any given extended namespace is OPTIONAL on the part of\n   any
      implementation.  If an entity does not understand such a\n   namespace, the
      entity's expected behavior depends on whether the\n   entity is (1) the recipient
      or (2) a server that is routing or\n   delivering the stanza to the recipient.\n
      \  If a recipient receives a stanza that contains an element or\n   attribute
      it does not understand, it MUST NOT attempt to process that\n   XML data and
      instead MUST proceed as follows.\n   o  If an intended recipient receives a
      message stanza whose only\n      child element is qualified by a namespace it
      does not understand,\n      then depending on the XMPP application it MUST either
      ignore the\n      entire stanza or return a stanza error, which SHOULD be <service-\n
      \     unavailable/> (Section 8.3.3.19).\n   o  If an intended recipient receives
      a presence stanza whose only\n      child element is qualified by a namespace
      it does not understand,\n      then it MUST ignore the child element by treating
      the presence\n      stanza as if it contained no child element.\n   o  If an
      intended recipient receives a message or presence stanza\n      that contains
      XML data qualified by a namespace it does not\n      understand, then it MUST
      ignore the portion of the stanza\n      qualified by the unknown namespace.\n
      \  o  If an intended recipient receives an IQ stanza of type \"get\" or\n      \"set\"
      containing a child element qualified by a namespace it does\n      not understand,
      then the entity MUST return an IQ stanza of type\n      \"error\" with an error
      condition of <service-unavailable/>.\n   If a server handles a stanza that is
      intended for delivery to another\n   entity and that contains a child element
      it does not understand, it\n   MUST route the stanza unmodified to a remote
      server or deliver the\n   stanza unmodified to a connected client associated
      with a local\n   account.\n"
    title: 8.4.  Extended Content
  title: 8.  XML Stanzas
- contents:
  - "9.  Detailed Examples\n   The detailed examples in this section further illustrate
    the\n   protocols defined in this specification.\n"
  - contents:
    - "9.1.  Client-to-Server Examples\n   The following examples show the XMPP data
      flow for a client\n   negotiating an XML stream with a server, exchanging XML
      stanzas, and\n   closing the negotiated stream.  The server is \"im.example.com\",
      the\n   server requires use of TLS, the client authenticates via the SASL\n
      \  SCRAM-SHA-1 mechanism as <juliet@im.example.com> with a password of\n   \"r0m30myr0m30\",
      and the client binds a client-submitted resource to\n   the stream.  It is assumed
      that before sending the initial stream\n   header, the client has already resolved
      an SRV record of\n   _xmpp-client._tcp.im.example.com and has opened a TCP connection
      to\n   the advertised port at the resolved IP address.\n"
    - contents:
      - "9.1.1.  TLS\n   Step 1: Client initiates stream to server:\n   C: <stream:stream\n
        \       from='juliet@im.example.com'\n        to='im.example.com'\n        version='1.0'\n
        \       xml:lang='en'\n        xmlns='jabber:client'\n        xmlns:stream='http://etherx.jabber.org/streams'>\n
        \  Step 2: Server responds by sending a response stream header to\n   client:\n
        \  S: <stream:stream\n        from='im.example.com'\n        id='t7AMCin9zjMNwQKDnplntZPIDEI='\n
        \       to='juliet@im.example.com'\n        version='1.0'\n        xml:lang='en'\n
        \       xmlns='jabber:client'\n        xmlns:stream='http://etherx.jabber.org/streams'>\n
        \  Step 3: Server sends stream features to client (only the STARTTLS\n   extension
        at this point, which is mandatory-to-negotiate):\n   S: <stream:features>\n
        \       <starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'>\n          <required/>\n
        \       </starttls>\n      </stream:features>\n   Step 4: Client sends STARTTLS
        command to server:\n   C: <starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>\n
        \  Step 5: Server informs client that it is allowed to proceed:\n   S: <proceed
        xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>\n   Step 5 (alt): Server informs
        client that STARTTLS negotiation has\n   failed, closes the XML stream, and
        terminates the TCP connection\n   (thus, the stream negotiation process ends
        unsuccessfully and the\n   parties do not move on to the next step):\n   S:
        <failure xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>\n      </stream:stream>\n
        \  Step 6: Client and server attempt to complete TLS negotiation over\n   the
        existing TCP connection (see [TLS] for details).\n   Step 7: If TLS negotiation
        is successful, client initiates a new\n   stream to server over the TLS-protected
        TCP connection:\n   C: <stream:stream\n        from='juliet@im.example.com'\n
        \       to='im.example.com'\n        version='1.0'\n        xml:lang='en'\n
        \       xmlns='jabber:client'\n        xmlns:stream='http://etherx.jabber.org/streams'>\n
        \  Step 7 (alt): If TLS negotiation is unsuccessful, server closes TCP\n   connection
        (thus, the stream negotiation process ends unsuccessfully\n   and the parties
        do not move on to the next step):\n"
      title: 9.1.1.  TLS
    - contents:
      - "9.1.2.  SASL\n   Step 8: Server responds by sending a stream header to client
        along\n   with any available stream features:\n   S: <stream:stream\n        from='im.example.com'\n
        \       id='vgKi/bkYME8OAj4rlXMkpucAqe4='\n        to='juliet@im.example.com'\n
        \       version='1.0'\n        xml:lang='en'\n        xmlns='jabber:client'\n
        \       xmlns:stream='http://etherx.jabber.org/streams'>\n   S: <stream:features>\n
        \       <mechanisms xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\n          <mechanism>SCRAM-SHA-1-PLUS</mechanism>\n
        \         <mechanism>SCRAM-SHA-1</mechanism>\n          <mechanism>PLAIN</mechanism>\n
        \       </mechanisms>\n      </stream:features>\n   Step 9: Client selects
        an authentication mechanism (in this case,\n   SCRAM-SHA-1), including initial
        response data:\n   C: <auth xmlns=\"urn:ietf:params:xml:ns:xmpp-sasl\"\n            mechanism=\"SCRAM-SHA-1\">\n
        \       biwsbj1qdWxpZXQscj1vTXNUQUF3QUFBQU1BQUFBTlAwVEFBQUFBQUJQVTBBQQ==\n
        \     </auth>\n   The decoded base 64 data is\n   \"n,,n=juliet,r=oMsTAAwAAAAMAAAANP0TAAAAAABPU0AA\".\n
        \  Step 10: Server sends a challenge:\n   S: <challenge xmlns=\"urn:ietf:params:xml:ns:xmpp-sasl\">\n
        \       cj1vTXNUQUF3QUFBQU1BQUFBTlAwVEFBQUFBQUJQVTBBQWUxMjQ2OTViLTY5Y\n        TktNGRlNi05YzMwLWI1MWIzODA4YzU5ZSxzPU5qaGtZVE0wTURndE5HWTBaaT\n
        \       AwTmpkbUxUa3hNbVV0TkRsbU5UTm1ORE5rTURNeixpPTQwOTY=\n      </challenge>\n
        \  The decoded base 64 data is \"r=oMsTAAwAAAAMAAAANP0TAAAAAABPU0AAe12469\n
        \  5b-69a9-4de6-9c30-\n   b51b3808c59e,s=NjhkYTM0MDgtNGY0Zi00NjdmLTkxMmUtNDlmNTNmNDNkMDMz,i=409\n
        \  6\" (line breaks not included in actual data).\n   Step 11: Client sends
        a response:\n   C: <response xmlns=\"urn:ietf:params:xml:ns:xmpp-sasl\">\n
        \       Yz1iaXdzLHI9b01zVEFBd0FBQUFNQUFBQU5QMFRBQUFBQUFCUFUwQUFlMTI0N\n        jk1Yi02OWE5LTRkZTYtOWMzMC1iNTFiMzgwOGM1OWUscD1VQTU3dE0vU3ZwQV\n
        \       RCa0gyRlhzMFdEWHZKWXc9\n      </response>\n   The decoded base 64
        data is \"c=biws,r=oMsTAAwAAAAMAAAANP0TAAAAAABPU0\n   AAe124695b-69a9-4de6-9c30-b51b3808c59e,p=UA57tM/\n
        \  SvpATBkH2FXs0WDXvJYw=\" (line breaks not included in actual data).\n   Step
        12: Server informs client of success, including additional data\n   with success:\n
        \  S: <success xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\n        dj1wTk5ERlZFUXh1WHhDb1NFaVc4R0VaKzFSU289\n
        \     </success>\n   The decoded base 64 data is \"v=pNNDFVEQxuXxCoSEiW8GEZ+1RSo=\".\n
        \  Step 12 (alt): Server returns a SASL error to client (thus, the\n   stream
        negotiation process ends unsuccessfully and the parties do not\n   move on
        to the next step):\n   S: <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\n
        \       <not-authorized/>\n      </failure>\n      </stream>\n   Step 13:
        Client initiates a new stream to server:\n   C: <stream:stream\n        from='juliet@im.example.com'\n
        \       to='im.example.com'\n        version='1.0'\n        xml:lang='en'\n
        \       xmlns='jabber:client'\n        xmlns:stream='http://etherx.jabber.org/streams'>\n"
      title: 9.1.2.  SASL
    - contents:
      - "9.1.3.  Resource Binding\n   Step 14: Server responds by sending a stream
        header to client along\n   with supported features (in this case, resource
        binding):\n   S: <stream:stream\n        from='im.example.com'\n        id='gPybzaOzBmaADgxKXu9UClbprp0='\n
        \       to='juliet@im.example.com'\n        version='1.0'\n        xml:lang='en'\n
        \       xmlns='jabber:client'\n        xmlns:stream='http://etherx.jabber.org/streams'>\n
        \  S: <stream:features>\n        <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'/>\n
        \     </stream:features>\n   Upon being informed that resource binding is
        mandatory-to-negotiate,\n   the client needs to bind a resource to the stream;
        here we assume\n   that the client submits a human-readable text string.\n
        \  Step 15: Client binds a resource:\n   C: <iq id='yhc13a95' type='set'>\n
        \       <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>\n          <resource>balcony</resource>\n
        \       </bind>\n      </iq>\n   Step 16: Server accepts submitted resourcepart
        and informs client of\n   successful resource binding:\n   S: <iq id='yhc13a95'
        type='result'>\n        <bind xmlns='urn:ietf:params:xml:ns:xmpp-bind'>\n
        \         <jid>\n            juliet@im.example.com/balcony\n          </jid>\n
        \       </bind>\n      </iq>\n   Step 16 (alt): Server returns error to client
        (thus, the stream\n   negotiation process ends unsuccessfully and the parties
        do not move\n   on to the next step):\n   S: <iq id='yhc13a95' type='error'>\n
        \       <error type='cancel'>\n          <conflict xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n
        \       </error>\n      </iq>\n"
      title: 9.1.3.  Resource Binding
    - contents:
      - "9.1.4.  Stanza Exchange\n   Now the client is allowed to send XML stanzas
        over the negotiated\n   stream.\n   C: <message from='juliet@im.example.com/balcony'\n
        \              id='ju2ba41c'\n               to='romeo@example.net'\n               type='chat'\n
        \              xml:lang='en'>\n        <body>Art thou not Romeo, and a Montague?</body>\n
        \     </message>\n   If necessary, sender's server negotiates XML streams
        with intended\n   recipient's server (see Section 9.2).\n   The intended recipient
        replies, and the message is delivered to the\n   client.\n   E: <message from='romeo@example.net/orchard'\n
        \              id='ju2ba41c'\n               to='juliet@im.example.com/balcony'\n
        \              type='chat'\n               xml:lang='en'>\n        <body>Neither,
        fair saint, if either thee dislike.</body>\n      </message>\n   The client
        can subsequently send and receive an unbounded number of\n   subsequent XML
        stanzas over the stream.\n"
      title: 9.1.4.  Stanza Exchange
    - contents:
      - "9.1.5.  Close\n   Desiring to send no further messages, the client closes
        its stream to\n   the server but waits for incoming data from the server.\n
        \  C: </stream:stream>\n   Consistent with Section 4.4, the server might send
        additional data to\n   the client and then closes its stream to the client.\n
        \  S: </stream:stream>\n   The client now sends a TLS close_notify alert,
        receives a responding\n   close_notify alert from the server, and then terminates
        the\n   underlying TCP connection.\n"
      title: 9.1.5.  Close
    title: 9.1.  Client-to-Server Examples
  - contents:
    - "9.2.  Server-to-Server Examples\n   The following examples show the data flow
      for a server negotiating an\n   XML stream with a peer server, exchanging XML
      stanzas, and closing\n   the negotiated stream.  The initiating server (\"Server1\")
      is\n   im.example.com; the receiving server (\"Server2\") is example.net and\n
      \  it requires use of TLS; im.example.com presents a certificate and\n   authenticates
      via the SASL EXTERNAL mechanism.  It is assumed that\n   before sending the
      initial stream header, Server1 has already\n   resolved an SRV record of _xmpp-server._tcp.example.net
      and has\n   opened a TCP connection to the advertised port at the resolved IP\n
      \  address.  Note how Server1 declares the content namespace \"jabber:\n   server\"
      as the default namespace and uses prefixes for stream-related\n   elements,
      whereas Server2 uses prefix-free canonicalization.\n"
    - contents:
      - "9.2.1.  TLS\n   Step 1: Server1 initiates stream to Server2:\n   S1: <stream:stream\n
        \        from='im.example.com'\n         to='example.net'\n         version='1.0'\n
        \        xmlns='jabber:server'\n         xmlns:stream='http://etherx.jabber.org/streams'>\n
        \  Step 2: Server2 responds by sending a response stream header to\n   Server1:\n
        \  S2: <stream\n         from='example.net'\n         id='hTiXkW+ih9k2SqdGkk/AZi0OJ/Q='\n
        \        to='im.example.com'\n         version='1.0'\n         xmlns='http://etherx.jabber.org/streams'>\n
        \  Step 3: Server2 sends stream features to Server1 (only the STARTTLS\n   extension
        at this point, which is mandatory-to-negotiate):\n   S2: <features xmlns='http://etherx.jabber.org/streams'>\n
        \        <starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'>\n           <required/>\n
        \        </starttls>\n       </features>\n   Step 4: Server1 sends the STARTTLS
        command to Server2:\n   S1: <starttls xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>\n
        \  Step 5: Server2 informs Server1 that it is allowed to proceed:\n   S2:
        <proceed xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>\n   Step 5 (alt): Server2
        informs Server1 that STARTTLS negotiation has\n   failed, closes the stream,
        and terminates the TCP connection (thus,\n   the stream negotiation process
        ends unsuccessfully and the parties do\n   not move on to the next step):\n
        \  S2: <failure xmlns='urn:ietf:params:xml:ns:xmpp-tls'/>\n       </stream>\n
        \  Step 6: Server1 and Server2 attempt to complete TLS negotiation via\n   TCP
        (see [TLS] for details).\n   Step 7: If TLS negotiation is successful, Server1
        initiates a new\n   stream to Server2 over the TLS-protected TCP connection:\n
        \  S1: <stream:stream\n         from='im.example.com'\n         to='example.net'\n
        \        version='1.0'\n         xmlns='jabber:server'\n         xmlns:stream='http://etherx.jabber.org/streams'>\n
        \  Step 7 (alt): If TLS negotiation is unsuccessful, Server2 closes the\n
        \  TCP connection (thus, the stream negotiation process ends\n   unsuccessfully
        and the parties do not move on to the next step).\n"
      title: 9.2.1.  TLS
    - contents:
      - "9.2.2.  SASL\n   Step 8: Server2 sends a response stream header to Server1
        along with\n   available stream features (including a preference for the SASL\n
        \  EXTERNAL mechanism):\n   S2: <stream\n         from='example.net'\n         id='RChdjlgj/TIBcbT9Keu31zDihH4='\n
        \        to='im.example.com'\n         version='1.0'\n         xmlns='http://etherx.jabber.org/streams'>\n
        \  S2: <features xmlns='http://etherx.jabber.org/streams'>\n         <mechanisms
        xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\n           <mechanism>EXTERNAL</mechanism>\n
        \        </mechanisms>\n       </features>\n   Step 9: Server1 selects the
        EXTERNAL mechanism (including an empty\n   response of \"=\"):\n   S1: <auth
        xmlns='urn:ietf:params:xml:ns:xmpp-sasl'\n             mechanism='EXTERNAL'>=</auth>\n
        \  Step 10: Server2 returns success:\n   S2: <success xmlns='urn:ietf:params:xml:ns:xmpp-sasl'/>\n
        \  Step 10 (alt): Server2 informs Server1 of failed authentication\n   (thus,
        the stream negotiation process ends unsuccessfully and the\n   parties do
        not move on to the next step):\n   S2: <failure xmlns='urn:ietf:params:xml:ns:xmpp-sasl'>\n
        \        <not-authorized/>\n       </failure>\n       </stream>\n   Step 11:
        Server1 initiates a new stream to Server2:\n   S1: <stream:stream\n         from='im.example.com'\n
        \        to='example.net'\n         version='1.0'\n         xmlns='jabber:server'\n
        \        xmlns:stream='http://etherx.jabber.org/streams'>\n   Step 12: Server2
        responds by sending a stream header to Server1 along\n   with any additional
        features (or, in this case, an empty features\n   element):\n   S2: <stream\n
        \        from='example.net'\n         id='MbbV2FeojySpUIP6J91qaa+TWHM='\n
        \        to='im.example.com'\n         version='1.0'\n         xmlns='http://etherx.jabber.org/streams'>\n
        \  S2: <features xmlns='http://etherx.jabber.org/streams'/>\n"
      title: 9.2.2.  SASL
    - contents:
      - "9.2.3.  Stanza Exchange\n   Now Server1 is allowed to send XML stanzas to
        Server2 over the\n   negotiated stream from im.example.com to example.net;
        here we assume\n   that the transferred stanzas are those shown earlier for
        client-to-\n   server communication, albeit over a server-to-server stream
        qualified\n   by the 'jabber:server' namespace.\n   Server1 sends XML stanza
        to Server2:\n   S1: <message from='juliet@im.example.com/balcony'\n                id='ju2ba41c'\n
        \               to='romeo@example.net'\n                type='chat'\n                xml:lang='en'>\n
        \      <body>Art thou not Romeo, and a Montague?</body>\n      </message>\n"
      title: 9.2.3.  Stanza Exchange
    - contents:
      - "9.2.4.  Close\n   Desiring to send no further messages, Server1 closes its
        stream to\n   Server2 but waits for incoming data from Server2.  (In practice,
        the\n   stream would most likely remain open for some time, since Server1
        and\n   Server2 do not immediately know if the stream will be needed for\n
        \  further communication.)\n   S1: </stream:stream>\n   Consistent with the
        recommended stream closing handshake, Server2\n   closes the stream as well:\n
        \  S2: </stream>\n   Server1 now sends a TLS close_notify alert, receives
        a responding\n   close_notify alert from Server2, and then terminates the
        underlying\n   TCP connection.\n"
      title: 9.2.4.  Close
    title: 9.2.  Server-to-Server Examples
  title: 9.  Detailed Examples
- contents:
  - "10.  Server Rules for Processing XML Stanzas\n   Each server implementation will
    contain its own logic for processing\n   stanzas it receives.  Such logic determines
    whether the server needs\n   to route a given stanza to another domain, deliver
    it to a local\n   entity (typically a connected client associated with a local\n
    \  account), or handle it directly within the server itself.  This\n   section
    provides general rules for processing XML stanzas.  However,\n   particular XMPP
    applications MAY specify delivery rules that modify\n   or supplement the following
    rules (e.g., a set of delivery rules for\n   instant messaging and presence applications
    is defined in [XMPP-IM]).\n"
  - contents:
    - "10.1.  In-Order Processing\n   An XMPP server MUST ensure in-order processing
      of the stanzas and\n   other XML elements it receives over a given input stream
      from a\n   connected client or remote server.\n   In-order processing applies
      (a) to any XML elements used to negotiate\n   and manage XML streams, and (b)
      to all uses of XML stanzas, including\n   but not limited to the following:\n
      \  1.  Stanzas sent by a client to its server or to its own bare JID for\n       direct
      processing by the server (e.g., in-order processing of a\n       roster get
      and initial presence as described in [XMPP-IM]).\n   2.  Stanzas sent by a connected
      client and intended for delivery to\n       another entity associated with the
      server (e.g., stanzas\n       addressed from <juliet@im.example.com> to\n       <nurse@im.example.com>).
      \ The server MUST ensure that it delivers\n       stanzas addressed to the intended
      recipient in the order it\n       receives them over the input stream from the
      sending client,\n       treating stanzas addressed to the bare JID and the full
      JID of\n       the intended recipient as equivalent for delivery purposes.\n
      \  3.  Stanzas sent by a connected client and intended for delivery to\n       an
      entity located at a remote domain (e.g., stanzas addressed\n       from <juliet@im.example.com>
      to <romeo@example.net>).  The\n       routing server MUST ensure that it routes
      stanzas addressed to\n       the intended recipient in the order it receives
      them over the\n       input stream from the sending client, treating stanzas
      addressed\n       to the bare JID and the full JID of the intended recipient
      as\n       equivalent for routing purposes.  To help ensure in-order\n       processing,
      the routing server MUST route such stanzas over a\n       single output stream
      to the remote domain, rather than sending\n       some stanzas over one server-to-server
      stream and other stanzas\n       over another server-to-server stream.\n   4.
      \ Stanzas routed from one server to another server for delivery to\n       an
      entity associated with the remote domain (e.g., stanzas\n       addressed from
      <juliet@im.example.com> to <romeo@example.net> and\n       routed by <im.example.com>
      over a server-to-server stream to\n       <example.net>).  The delivering server
      MUST ensure that it\n       delivers stanzas to the intended recipient in the
      order it\n       receives them over the input stream from the routing server,\n
      \      treating stanzas addressed to the bare JID and the full JID of\n       the
      intended recipient as equivalent for delivery purposes.\n   5.  Stanzas sent
      by one server to another server for direct\n       processing by the server
      that is hosting the remote domain (e.g.,\n       stanzas addressed from <im.example.com>
      to <example.net>).\n   If the server's processing of a particular request could
      have an\n   effect on its processing of subsequent data it might receive over\n
      \  that input stream (e.g., enforcement of communication policies), it\n   MUST
      suspend processing of subsequent data until it has processed the\n   request.\n
      \  In-order processing applies only to a single input stream.\n   Therefore,
      a server is not responsible for ensuring the coherence of\n   data it receives
      across multiple input streams associated with the\n   same local account (e.g.,
      stanzas received over two different input\n   streams from <juliet@im.example.com/balcony>
      and\n   <juliet@im.example.com/chamber>) or the same remote domain (e.g., two\n
      \  different input streams negotiated by a remote domain; however, a\n   server
      MAY close the stream with a <conflict/> stream error\n   (Section 4.9.3.3) if
      a remote server attempts to negotiate more than\n   one stream, as described
      under Section 4.9.3.3).\n"
    title: 10.1.  In-Order Processing
  - contents:
    - "10.2.  General Considerations\n   At high level, there are three primary considerations
      at play in\n   server processing of XML stanzas, which sometimes are at odds
      but\n   need to be managed in a consistent way:\n   1.  It is good to deliver
      a stanza to the intended recipient if\n       possible.\n   2.  If a stanza
      cannot be delivered, it is helpful to inform the\n       sender.\n   3.  It
      is bad to facilitate directory harvesting attacks\n       (Section 13.11) and
      presence leaks (Section 13.10.2).\n   With regard to possible delivery-related
      attacks, the following\n   points need to be kept in mind:\n   1.  From the
      perspective of an attacker, there is little if any\n       effective difference
      between the server's (i) delivering the\n       stanza or storing it offline
      for later delivery (see [XMPP-IM])\n       and (ii) silently ignoring it (because
      an error is not returned\n       immediately in any of those cases); therefore,
      in scenarios where\n       a server delivers a stanza or places the stanza into
      offline\n       storage for later delivery, it needs to silently ignore the\n
      \      stanza if that account does not exist.\n   2.  How a server processes
      stanzas sent to the bare JID\n       <localpart@domainpart> has implications
      for directory harvesting,\n       because an attacker could determine whether
      an account exists if\n       the server responds differently depending on whether
      there is an\n       account for a given bare JID.\n   3.  How a server processes
      stanzas sent to a full JID has\n       implications for presence leaks, because
      an attacker could send\n       requests to multiple full JIDs and receive different
      replies\n       depending on whether the user has a device currently online
      at\n       that full JID.  The use of randomized resourceparts (whether\n       generated
      by the client or the server as described under\n       Section 7) significantly
      helps to mitigate this attack, so it is\n       of somewhat lesser concern than
      the directory harvesting attack.\n   Naturally, presence is not leaked if the
      entity to which a user's\n   server returns an error already knows the user's
      presence or is\n   authorized to do so (e.g., by means of a presence subscription
      or\n   directed presence), and a server does not enable a directory\n   harvesting
      attack if it returns an error to an entity that already\n   knows if a user
      exists (e.g., because the entity is in the user's\n   contact list); these matters
      are discussed more fully in [XMPP-IM].\n"
    title: 10.2.  General Considerations
  - contents:
    - "10.3.  No 'to' Address\n   If the stanza possesses no 'to' attribute, the server
      MUST handle it\n   directly on behalf of the entity that sent it, where the
      meaning of\n   \"handle it directly\" depends on whether the stanza is message,\n
      \  presence, or IQ.  Because all stanzas received from other servers\n   MUST
      possess a 'to' attribute, this rule applies only to stanzas\n   received from
      a local entity (typically a client) that is connected\n   to the server.\n"
    - contents:
      - "10.3.1.  Message\n   If the server receives a message stanza with no 'to'
        attribute, it\n   MUST treat the message as if the 'to' address were the bare
        JID\n   <localpart@domainpart> of the sending entity.\n"
      title: 10.3.1.  Message
    - contents:
      - "10.3.2.  Presence\n   If the server receives a presence stanza with no 'to'
        attribute, it\n   MUST broadcast it to the entities that are subscribed to
        the sending\n   entity's presence, if applicable ([XMPP-IM] defines the semantics
        of\n   such broadcasting for presence applications).\n"
      title: 10.3.2.  Presence
    - contents:
      - "10.3.3.  IQ\n   If the server receives an IQ stanza with no 'to' attribute,
        it MUST\n   process the stanza on behalf of the account from which received
        the\n   stanza, as follows:\n   1.  If the IQ stanza is of type \"get\" or
        \"set\" and the server\n       understands the namespace that qualifies the
        payload, the server\n       MUST handle the stanza on behalf of the sending
        entity or return\n       an appropriate error to the sending entity.  Although
        the meaning\n       of \"handle\" is determined by the semantics of the qualifying\n
        \      namespace, in general the server will respond to the IQ stanza of\n
        \      type \"get\" or \"set\" by returning an appropriate IQ stanza of type\n
        \      \"result\" or \"error\", responding as if the server were the bare\n
        \      JID of the sending entity.  As an example, if the sending entity\n
        \      sends an IQ stanza of type \"get\" where the payload is qualified\n
        \      by the 'jabber:iq:roster' namespace (as described in [XMPP-IM]),\n
        \      then the server will return the roster associated with the\n       sending
        entity's bare JID to the particular resource of the\n       sending entity
        that requested the roster.\n   2.  If the IQ stanza is of type \"get\" or
        \"set\" and the server does\n       not understand the namespace that qualifies
        the payload, the\n       server MUST return an error to the sending entity,
        which MUST be\n       <service-unavailable/>.\n   3.  If the IQ stanza is
        of type \"error\" or \"result\", the server MUST\n       handle the error
        or result in accordance with the payload of the\n       associated IQ stanza
        or type \"get\" or \"set\" (if there is no such\n       associated stanza,
        the server MUST ignore the error or result\n       stanza).\n"
      title: 10.3.3.  IQ
    title: 10.3.  No 'to' Address
  - contents:
    - "10.4.  Remote Domain\n   If the domainpart of the JID contained in the 'to'
      attribute does not\n   match one of the configured FQDNs of the server, the
      server SHOULD\n   attempt to route the stanza to the remote domain (subject
      to local\n   service provisioning and security policies regarding inter-domain\n
      \  communication, since such communication is OPTIONAL for any given\n   deployment).
      \ As described in the following sections, there are two\n   possible cases.\n
      \     Security Warning: These rules apply only client-to-server streams.\n      As
      described under Section 8.1.1.2, a server MUST NOT accept a\n      stanza over
      a server-to-server stream if the domainpart of the JID\n      in the 'to' attribute
      does not match an FQDN serviced by the\n      receiving server.\n"
    - contents:
      - "10.4.1.  Existing Stream\n   If a server-to-server stream already exists
        between the two domains,\n   the sender's server SHOULD attempt to route the
        stanza to the\n   authoritative server for the remote domain over the existing
        stream.\n"
      title: 10.4.1.  Existing Stream
    - contents:
      - "10.4.2.  No Existing Stream\n   If there exists no server-to-server stream
        between the two domains,\n   the sender's server will proceed as follows:\n
        \  1.  Resolve the FQDN of the remote domain (as described under\n       Section
        13.9.2).\n   2.  Negotiate a server-to-server stream between the two domains
        (as\n       defined under Section 5 and Section 6).\n   3.  Route the stanza
        to the authoritative server for the remote\n       domain over the newly established
        stream.\n"
      title: 10.4.2.  No Existing Stream
    - contents:
      - "10.4.3.  Error Handling\n   If routing of a stanza to the intended recipient's
        server is\n   unsuccessful, the sender's server MUST return an error to the
        sender.\n   If resolution of the remote domain is unsuccessful, the stanza
        error\n   MUST be <remote-server-not-found/> (Section 8.3.3.16).  If resolution\n
        \  succeeds but streams cannot be negotiated, the stanza error MUST be\n   <remote-server-timeout/>
        (Section 8.3.3.17).\n   If stream negotiation with the intended recipient's
        server is\n   successful but the remote server cannot deliver the stanza to
        the\n   recipient, the remote server MUST return an appropriate error to the\n
        \  sender by way of the sender's server.\n"
      title: 10.4.3.  Error Handling
    title: 10.4.  Remote Domain
  - contents:
    - "10.5.  Local Domain\n   If the domainpart of the JID contained in the 'to'
      attribute matches\n   one of the configured FQDNs of the server, the server
      MUST first\n   determine if the FQDN is serviced by the server itself or by
      a\n   specialized local service.  If the latter, the server MUST route the\n
      \  stanza to that service.  If the former, the server MUST proceed as\n   follows.
      \ However, the server MUST NOT route or \"forward\" the stanza\n   to another
      domain, because it is the server's responsibility to\n   process all stanzas
      for which the domainpart of the 'to' address\n   matches one of the configured
      FQDNs of the server (among other\n   things, this helps to prevent looping).\n"
    - contents:
      - "10.5.1.  domainpart\n   If the JID contained in the 'to' attribute is of
        the form\n   <domainpart>, then the server MUST either (a) handle the stanza
        as\n   appropriate for the stanza kind or (b) return an error stanza to the\n
        \  sender.\n"
      title: 10.5.1.  domainpart
    - contents:
      - "10.5.2.  domainpart/resourcepart\n   If the JID contained in the 'to' attribute
        is of the form\n   <domainpart/resourcepart>, then the server MUST either
        (a) handle the\n   stanza as appropriate for the stanza kind or (b) return
        an error\n   stanza to the sender.\n"
      title: 10.5.2.  domainpart/resourcepart
    - contents:
      - "10.5.3.  localpart@domainpart\n   An address of this type is normally associated
        with an account on the\n   server.  The following rules provide some general
        guidelines; more\n   detailed rules in the context of instant messaging and
        presence\n   applications are provided in [XMPP-IM].\n"
      - contents:
        - "10.5.3.1.  No Such User\n   If there is no local account associated with
          the\n   <localpart@domainpart>, how the stanza is processed depends on the\n
          \  stanza type.\n   o  For a message stanza, the server MUST either (a)
          silently ignore\n      the stanza or (b) return a <service-unavailable/>
          stanza error\n      (Section 8.3.3.19) to the sender.\n   o  For a presence
          stanza, the server SHOULD ignore the stanza (or\n      behave as described
          in [XMPP-IM]).\n   o  For an IQ stanza, the server MUST return a <service-unavailable/>\n
          \     stanza error (Section 8.3.3.19) to the sender.\n"
        title: 10.5.3.1.  No Such User
      - contents:
        - "10.5.3.2.  User Exists\n   If the JID contained in the 'to' attribute is
          of the form\n   <localpart@domainpart>, how the stanza is processed depends
          on the\n   stanza type.\n   o  For a message stanza, if there exists at
          least one connected\n      resource for the account then the server SHOULD
          deliver it to at\n      least one of the connected resources.  If there
          exists no\n      connected resource then the server MUST either (a) store
          the\n      message offline for delivery when the account next has a connected\n
          \     resource or (b) return a <service-unavailable/> stanza error\n      (Section
          8.3.3.19).\n   o  For a presence stanza, if there exists at least one connected\n
          \     resource that has sent initial presence (i.e., has a \"presence\n
          \     session\" as defined in [XMPP-IM]) then the server SHOULD deliver\n
          \     it to such resources.  If there exists no connected resource then\n
          \     the server SHOULD ignore the stanza (or behave as described in\n      [XMPP-IM]).\n
          \  o  For an IQ stanza, the server MUST handle it directly on behalf of\n
          \     the intended recipient.\n"
        title: 10.5.3.2.  User Exists
      title: 10.5.3.  localpart@domainpart
    - contents:
      - "10.5.4.  localpart@domainpart/resourcepart\n   If the JID contained in the
        'to' attribute is of the form\n   <localpart@domainpart/resourcepart> and
        the user exists but there is\n   no connected resource that exactly matches
        the full JID, the stanza\n   SHOULD be processed as if the JID were of the
        form\n   <localpart@domainpart> as described under Section 10.5.3.2.\n   If
        the JID contained in the 'to' attribute is of the form\n   <localpart@domainpart/resourcepart>,
        the user exists, and there is a\n   connected resource that exactly matches
        the full JID, the server MUST\n   deliver the stanza to that connected resource.\n"
      title: 10.5.4.  localpart@domainpart/resourcepart
    title: 10.5.  Local Domain
  title: 10.  Server Rules for Processing XML Stanzas
- contents:
  - '11.  XML Usage

    '
  - contents:
    - "11.1.  XML Restrictions\n   XMPP defines a class of data objects called XML
      streams as well as\n   the behavior of computer programs that process XML streams.
      \ XMPP is\n   an application profile or restricted form of the Extensible Markup\n
      \  Language [XML], and a complete XML stream (including start and end\n   stream
      tags) is a conforming XML document.\n   However, XMPP does not deal with XML
      documents but with XML streams.\n   Because XMPP does not require the parsing
      of arbitrary and complete\n   XML documents, there is no requirement that XMPP
      needs to support the\n   full feature set of [XML].  Furthermore, XMPP uses
      XML to define\n   protocol data structures and extensions for the purpose of
      structured\n   interactions between network entities and therefore adheres to
      the\n   recommendations provided in [XML-GUIDE] regarding restrictions on the\n
      \  use of XML in IETF protocols.  As a result, the following features of\n   XML
      are prohibited in XMPP:\n   o  comments (as defined in Section 2.5 of [XML])\n
      \  o  processing instructions (Section 2.6 therein)\n   o  internal or external
      DTD subsets (Section 2.8 therein)\n   o  internal or external entity references
      (Section 4.2 therein) with\n      the exception of the predefined entities (Section
      4.6 therein)\n   An XMPP implementation MUST behave as follows with regard to
      these\n   features:\n   1.  An XMPP implementation MUST NOT inject characters
      matching such\n       features into an XML stream.\n   2.  If an XMPP implementation
      receives characters matching such\n       features over an XML stream, it MUST
      close the stream with a\n       stream error, which SHOULD be <restricted-xml/>\n
      \      (Section 4.9.3.18), although some existing implementations send\n       <bad-format/>
      (Section 4.9.3.1) instead.\n"
    title: 11.1.  XML Restrictions
  - contents:
    - "11.2.  XML Namespace Names and Prefixes\n   XML namespaces (see [XML-NAMES])
      are used within XMPP streams to\n   create strict boundaries of data ownership.
      \ The basic function of\n   namespaces is to separate different vocabularies
      of XML elements that\n   are structurally mixed together.  Ensuring that XMPP
      streams are\n   namespace-aware enables any allowable XML to be structurally
      mixed\n   with any data element within XMPP.  XMPP-specific rules for XML\n
      \  namespace names and prefixes are defined under Section 4.8 for XML\n   streams
      and Section 8.4 for XML stanzas.\n"
    title: 11.2.  XML Namespace Names and Prefixes
  - contents:
    - "11.3.  Well-Formedness\n   In XML, there are two varieties of well-formedness:\n
      \  o  \"XML-well-formedness\" in accordance with the definition of \"well-\n
      \     formed\" from Section 2.1 of [XML].\n   o  \"Namespace-well-formedness\"
      in accordance with the definition of\n      \"namespace-well-formed\" from Section
      7 of [XML-NAMES].\n   The following rules apply:\n   1.  An XMPP entity MUST
      NOT generate data that is not XML-well-\n       formed.\n   2.  An XMPP entity
      MUST NOT accept data that is not XML-well-formed;\n       instead it MUST close
      the stream over which the data was received\n       with a <not-well-formed/>
      stream error (Section 4.9.3.13).\n   3.  An XMPP entity MUST NOT generate data
      that is not namespace-well-\n       formed.\n   4.  An XMPP entity MUST NOT
      accept data that is not namespace-well-\n       formed (in particular, an XMPP
      server MUST NOT route or deliver\n       data that is not namespace-well-formed);
      instead it MUST return\n       either a <not-acceptable/> stanza error (Section
      8.3.3.9) or\n       close the stream with a <not-well-formed/> stream error\n
      \      (Section 4.9.3.13), where it is preferable to close the stream\n       with
      a stream error because accepting such data can open an\n       entity to certain
      denial-of-service attacks.\n      Interoperability Note: Because these restrictions
      were\n      underspecified in [RFC3920], it is possible that implementations\n
      \     based on that specification will send data that does not comply\n      with
      these restrictions.\n"
    title: 11.3.  Well-Formedness
  - contents:
    - "11.4.  Validation\n   A server is not responsible for ensuring that XML data
      delivered to a\n   connected client or routed to a peer server is valid, in
      accordance\n   with the definition of \"valid\" provided in Section 2.8 of [XML].
      \ An\n   implementation MAY choose to accept or send only data that has been\n
      \  explicitly validated against the schemas provided in this document,\n   but
      such behavior is OPTIONAL.  Clients are advised not to rely on\n   the ability
      to send data that does not conform to the schemas, and\n   SHOULD ignore any
      non-conformant elements or attributes on the\n   incoming XML stream.\n      Informational
      Note: The terms \"valid\" and \"well-formed\" are\n      distinct in XML.\n"
    title: 11.4.  Validation
  - contents:
    - "11.5.  Inclusion of XML Declaration\n   Before sending a stream header, an
      implementation SHOULD send an XML\n   declaration (matching the \"XMLDecl\"
      production from [XML]).\n   Applications MUST follow the rules provided in [XML]
      regarding the\n   format of the XML declaration and the circumstances under
      which the\n   XML declaration is included.\n   Because external markup declarations
      are prohibited in XMPP (as\n   described under Section 11.1), the standalone
      document declaration\n   (matching the \"SDDecl\" production from [XML]) would
      have no meaning\n   and therefore MUST NOT be included in an XML declaration
      sent over an\n   XML stream.  If an XMPP entity receives an XML declaration
      containing\n   a standalone document declaration set to a value of \"no\", the
      entity\n   MUST either ignore the standalone document declaration or close the\n
      \  stream with a stream error, which SHOULD be <restricted-xml/>\n   (Section
      4.9.3.18).\n"
    title: 11.5.  Inclusion of XML Declaration
  - contents:
    - "11.6.  Character Encoding\n   Implementations MUST support the UTF-8 transformation
      of Universal\n   Character Set [UCS2] characters, as needed for conformance
      with\n   [CHARSETS] and as defined in [UTF-8].  Implementations MUST NOT\n   attempt
      to use any other encoding.  If one party to an XML stream\n   detects that the
      other party has attempted to send XML data with an\n   encoding other than UTF-8,
      it MUST close the stream with a stream\n   error, which SHOULD be <unsupported-encoding/>
      (Section 4.9.3.22),\n   although some existing implementations send <bad-format/>\n
      \  (Section 4.9.3.1) instead.\n   Because it is mandatory for an XMPP implementation
      to support all and\n   only the UTF-8 encoding and because UTF-8 always has
      the same byte\n   order, an implementation MUST NOT send a byte order mark (\"BOM\")
      at\n   the beginning of the data stream.  If an entity receives the\n   [UNICODE]
      character U+FEFF anywhere in an XML stream (including as\n   the first character
      of the stream), it MUST interpret that character\n   as a zero width no-break
      space, not as a byte order mark.\n"
    title: 11.6.  Character Encoding
  - contents:
    - "11.7.  Whitespace\n   Except where explicitly disallowed (e.g., during TLS
      negotiation\n   (Section 5) and SASL negotiation (Section 6)), either entity
      MAY send\n   whitespace as separators between XML stanzas or between any other\n
      \  first-level elements sent over the stream.  One common use for\n   sending
      such whitespace is explained under Section 4.4.\n"
    title: 11.7.  Whitespace
  - contents:
    - "11.8.  XML Versions\n   XMPP is an application profile of XML 1.0.  A future
      version of XMPP\n   might be defined in terms of higher versions of XML, but
      this\n   specification defines XMPP only in terms of XML 1.0.\n"
    title: 11.8.  XML Versions
  title: 11.  XML Usage
- contents:
  - "12.  Internationalization Considerations\n   As specified under Section 11.6,
    XML streams MUST be encoded in\n   UTF-8.\n   As specified under Section 4.7,
    an XML stream SHOULD include an 'xml:\n   lang' attribute specifying the default
    language for any XML character\n   data that is intended to be presented to a
    human user.  As specified\n   under Section 8.1.5, an XML stanza SHOULD include
    an 'xml:lang'\n   attribute if the stanza contains XML character data that is
    intended\n   to be presented to a human user.  A server SHOULD apply the default\n
    \  'xml:lang' attribute to stanzas it routes or delivers on behalf of\n   connected
    entities, and MUST NOT modify or delete 'xml:lang'\n   attributes on stanzas it
    receives from other entities.\n   Internationalization of XMPP addresses is specified
    in [XMPP-ADDR].\n"
  title: 12.  Internationalization Considerations
- contents:
  - '13.  Security Considerations

    '
  - contents:
    - "13.1.  Fundamentals\n   XMPP technologies are typically deployed using a decentralized\n
      \  client-server architecture.  As a result, several paths are possible\n   when
      two XMPP entities need to communicate:\n   1.  Both entities are servers.  In
      this case, the entities can\n       establish a direct server-to-server stream
      between themselves.\n   2.  One entity is a server and the other entity is a
      client whose\n       account is hosted on that server.  In this case, the entities
      can\n       establish a direct client-to-server stream between themselves.\n
      \  3.  Both entities are clients whose accounts are hosted on the same\n       server.
      \ In this case, the entities cannot establish a direct\n       stream between
      themselves, but there is only one intermediate\n       entity between them,
      whose policies they might understand and in\n       which they might have some
      level of trust (e.g., the server might\n       require the use of Transport
      Layer Security for all client\n       connections).\n   4.  Both entities are
      clients but their accounts are hosted on\n       different servers.  In this
      case, the entities cannot establish a\n       direct stream between themselves
      and there are two intermediate\n       entities between them; each client might
      have some trust in the\n       server that hosts its account but might know
      nothing about the\n       policies of the server to which the other client connects.\n
      \  This specification covers only the security of a direct XML stream\n   between
      two servers or between a client and a server (cases #1 and\n   #2), where each
      stream can be considered a single \"hop\" along a\n   communication path.  The
      goal of security for a multi-hop path (cases\n   #3 and #4), although very desirable,
      is out of scope for this\n   specification.\n   In accordance with [SEC-GUIDE],
      this specification covers\n   communication security (confidentiality, data
      integrity, and peer\n   entity authentication), non-repudiation, and systems
      security\n   (unauthorized usage, inappropriate usage, and denial of service).
      \ We\n   also discuss common security issues such as information leaks,\n   firewalls,
      and directory harvesting, as well as best practices\n   related to the reuse
      of technologies such as base 64, DNS,\n   cryptographic hash functions, SASL,
      TLS, UTF-8, and XML.\n"
    title: 13.1.  Fundamentals
  - contents:
    - "13.2.  Threat Model\n   The threat model for XMPP is in essence the standard
      \"Internet Threat\n   Model\" described in [SEC-GUIDE].  Attackers are assumed
      to be\n   interested in and capable of launching the following attacks against\n
      \  unprotected XMPP systems:\n   o  Eavesdropping\n   o  Sniffing passwords\n
      \  o  Breaking passwords through dictionary attacks\n   o  Discovering usernames
      through directory harvesting attacks\n   o  Replaying, inserting, deleting,
      or modifying stanzas\n   o  Spoofing users\n   o  Gaining unauthorized entry
      to a server or account\n   o  Using a server or account inappropriately\n   o
      \ Denying service to other entities\n   o  Subverting communication streams
      through man-in-the-middle attacks\n   o  Gaining control over on-path servers\n
      \  Where appropriate, the following sections describe methods for\n   protecting
      against these threats.\n"
    title: 13.2.  Threat Model
  - contents:
    - "13.3.  Order of Layers\n   The order of layers in which protocols MUST be stacked
      is as follows:\n   1.  TCP\n   2.  TLS\n   3.  SASL\n   4.  XMPP\n   This order
      has important security implications, as described\n   throughout these security
      considerations.\n   Within XMPP, XML stanzas are further ordered on top of XML
      streams,\n   as described under Section 4.\n"
    title: 13.3.  Order of Layers
  - contents:
    - "13.4.  Confidentiality and Integrity\n   The use of Transport Layer Security
      (TLS) with appropriate\n   ciphersuites provides a reliable mechanism to ensure
      the\n   confidentiality and integrity of data exchanged between a client and\n
      \  a server or between two servers.  Therefore, TLS can help to protect\n   against
      eavesdropping, password sniffing, man-in-the-middle attacks,\n   and stanza
      replays, insertion, deletion, and modification over an XML\n   stream.  XMPP
      clients and servers MUST support TLS as defined under\n   Section 5.\n      Informational
      Note: The confidentiality and integrity of a stream\n      can be protected
      by methods other than TLS, e.g., by means of a\n      SASL mechanism that involves
      negotiation of a security layer.\n      Security Warning: The use of TLS in
      XMPP applies to a single\n      stream.  Because XMPP is typically deployed
      using a distributed\n      client-server architecture (as explained under Section
      2.5), a\n      stanza might traverse multiple streams, and not all of those\n
      \     streams might be TLS-protected.  For example, a stanza sent from a\n      client
      with a session at one server (e.g.,\n      <romeo@example.net/orchard>) and
      intended for delivery to a client\n      with a session at another server (e.g.,\n
      \     <juliet@example.com/balcony>) will traverse three streams: (1) the\n      stream
      from the sender's client to its server, (2) the stream from\n      the sender's
      server to the recipient's server, and (3) the stream\n      from the recipient's
      server to the recipient's client.\n      Furthermore, the stanza will be processed
      as cleartext within the\n      sender's server and the recipient's server.  Therefore,
      even if\n      the stream from the sender's client to its server is protected,\n
      \     the confidentiality and integrity of a stanza sent over that\n      protected
      stream cannot be guaranteed when the stanza is processed\n      by the sender's
      server, sent from the sender's server to the\n      recipient's server, processed
      by the recipient's server, or sent\n      from the recipient's server to the
      recipient's client.  Only a\n      robust technology for end-to-end encryption
      could ensure the\n      confidentiality and integrity of a stanza as it traverses
      all of\n      the \"hops\" along a communication path (e.g., a technology that\n
      \     meets the requirements defined in [E2E-REQS]).  Unfortunately, the\n      XMPP
      community has so far failed to produce an end-to-end\n      encryption technology
      that might be suitable for widespread\n      implementation and deployment,
      and definition of such a technology\n      is out of scope for this document.\n"
    title: 13.4.  Confidentiality and Integrity
  - contents:
    - "13.5.  Peer Entity Authentication\n   The use of the Simple Authentication
      and Security Layer (SASL) for\n   authentication provides a reliable mechanism
      for peer entity\n   authentication.  Therefore, SASL helps to protect against
      user\n   spoofing, unauthorized usage, and man-in-the middle attacks.  XMPP\n
      \  clients and servers MUST support SASL as defined under Section 6.\n"
    title: 13.5.  Peer Entity Authentication
  - contents:
    - "13.6.  Strong Security\n   [STRONGSEC] defines \"strong security\" and its
      importance to\n   communication over the Internet.  For the purpose of XMPP\n
      \  communication over client-to-server and server-to-server streams, the\n   term
      \"strong security\" refers to the use of security technologies\n   that provide
      both mutual authentication and integrity checking (e.g.,\n   a combination of
      TLS encryption and SASL authentication using\n   appropriate SASL mechanisms).\n
      \  Implementations MUST support strong security.  Service provisioning\n   SHOULD
      use strong security.\n   An implementation SHOULD make it possible for an end
      user or service\n   administrator to provision a deployment with specific trust
      anchors\n   for the certificate presented by a connecting entity (either client\n
      \  or server); when an application is thus provisioned, it MUST NOT use\n   a
      generic PKI trust store to authenticate the connecting entity.\n   More detailed
      rules and guidelines regarding certificate validation\n   are provided in the
      next section.\n   The initial stream and the response stream MUST be secured\n
      \  separately, although security in both directions MAY be established\n   via
      mechanisms that provide mutual authentication.\n"
    title: 13.6.  Strong Security
  - contents:
    - "13.7.  Certificates\n   Channel encryption of an XML stream using Transport
      Layer Security as\n   described under Section 5, and in some cases also authentication
      as\n   described under Section 6, is commonly based on a PKIX certificate\n
      \  presented by the receiving entity (or, in the case of mutual\n   certificate
      authentication, both the receiving entity and the\n   initiating entity).  This
      section describes best practices regarding\n   the generation of PKIX certificates
      to be presented by XMPP entities\n   and the verification of PKIX certificates
      presented by XMPP entities.\n   In general, the following sections rely on and
      extend the rules and\n   guidelines provided in the [PKIX] profile of [X509],
      and in\n   [TLS-CERTS].  The reader is referred to those specifications for
      a\n   detailed understanding of PKIX certificates and their use in TLS.\n"
    - contents:
      - '13.7.1.  Certificate Generation

        '
      - contents:
        - "13.7.1.1.  General Considerations\n   The following rules apply to end
          entity public key certificates that\n   are issued to XMPP servers or clients:\n
          \  1.  The certificate MUST conform to [PKIX].\n   2.  The certificate MUST
          NOT contain a basicConstraints extension\n       with the cA boolean set
          to TRUE.\n   3.  The subject field MUST NOT be null.\n   4.  The signatureAlgorithm
          SHOULD be the PKCS #1 version 1.5\n       signature algorithm with SHA-256
          as defined by [PKIX-ALGO], or a\n       stronger algorithm if available.\n
          \  5.  The certificate SHOULD include an Authority Information Access\n
          \      (AIA) extension that specifies the address of an Online\n       Certificate
          Status Protocol [OCSP] responder (if not, a relying\n       party would
          need to fall back on the use of Certificate\n       Revocation Lists (CRLs)
          as described in [PKIX]).\n   The following rules apply to certification
          authority (CA)\n   certificates that are used by issuers of XMPP end entity\n
          \  certificates:\n   1.  The certificate MUST conform to [PKIX].\n   2.
          \ The certificate MUST contain a keyUsage extension with the\n       digitalSignature
          bit set.\n   3.  The subject field MUST NOT be null.\n   4.  The signatureAlgorithm
          SHOULD be the PKCS #1 version 1.5\n       signature algorithm with SHA-256
          as defined by [PKIX-ALGO], or a\n       stronger algorithm if available.\n
          \  5.  For issuers of public key certificates, the issuer's certificate\n
          \      MUST contain a basicConstraints extension with the cA boolean set\n
          \      to TRUE.\n"
        title: 13.7.1.1.  General Considerations
      - contents:
        - '13.7.1.2.  Server Certificates

          '
        - contents:
          - "13.7.1.2.1.  Rules\n   In a PKIX certificate to be presented by an XMPP
            server (i.e., a\n   \"server certificate\"), the certificate SHOULD include
            one or more\n   XMPP addresses (i.e., domainparts) associated with XMPP
            services\n   hosted at the server.  The rules and guidelines defined in\n
            \  [TLS-CERTS] apply to XMPP server certificates, with the following\n
            \  XMPP-specific considerations:\n   o  Support for the DNS-ID identifier
            type [PKIX] is REQUIRED in XMPP\n      client and server software implementations.
            \ Certification\n      authorities that issue XMPP-specific certificates
            MUST support the\n      DNS-ID identifier type.  XMPP service providers
            SHOULD include the\n      DNS-ID identifier type in certificate requests.\n
            \  o  Support for the SRV-ID identifier type [PKIX-SRV] is REQUIRED for\n
            \     XMPP client and server software implementations (for verification\n
            \     purposes XMPP client implementations need to support only the\n
            \     \"_xmpp-client\" service type, whereas XMPP server implementations\n
            \     need to support both the \"_xmpp-client\" and \"_xmpp-server\" service\n
            \     types).  Certification authorities that issue XMPP-specific\n      certificates
            SHOULD support the SRV-ID identifier type.  XMPP\n      service providers
            SHOULD include the SRV-ID identifier type in\n      certificate requests.\n
            \  o  Support for the XmppAddr identifier type (specified under\n      Section
            13.7.1.4) is encouraged in XMPP client and server software\n      implementations
            for the sake of backward-compatibility, but is no\n      longer encouraged
            in certificates issued by certification\n      authorities or requested
            by XMPP service providers.\n   o  DNS domain names in server certificates
            MAY contain the wildcard\n      character '*' as the complete left-most
            label within the\n      identifier.\n"
          title: 13.7.1.2.1.  Rules
        - contents:
          - "13.7.1.2.2.  Examples\n   For our first (relatively simple) example,
            consider a company called\n   \"Example Products, Inc.\"  It hosts an
            XMPP service at\n   \"im.example.com\" (i.e., user addresses at the service
            are of the form\n   \"user@im.example.com\"), and SRV lookups for the
            xmpp-client and xmpp-\n   server services at \"im.example.com\" yield
            one machine, called\n   \"x.example.com\", as follows:\n   _xmpp-client._tcp.im.example.com.
            400 IN SRV 20 0 5222 x.example.com\n   _xmpp-server._tcp.im.example.com.
            400 IN SRV 20 0 5269 x.example.com\n   The certificate presented by x.example.com
            contains the following\n   representations:\n   o  An otherName type of
            SRVName (id-on-dnsSRV) containing an\n      IA5String (ASCII) string of
            \"_xmpp-client.im.example.com\"\n   o  An otherName type of SRVName (id-on-dnsSRV)
            containing an\n      IA5String (ASCII) string of \"_xmpp-server.im.example.com\"\n
            \  o  A dNSName containing an ASCII string of \"im.example.com\"\n   o
            \ An otherName type of XmppAddr (id-on-xmppAddr) containing a UTF-8\n
            \     string of \"im.example.com\"\n   o  A CN containing an ASCII string
            of \"Example Products, Inc.\"\n   For our second (more complex) example,
            consider an ISP called\n   \"Example Internet Services\".  It hosts an
            XMPP service at\n   \"example.net\" (i.e., user addresses at the service
            are of the form\n   \"user@example.net\"), but SRV lookups for the xmpp-client
            and xmpp-\n   server services at \"example.net\" yield two machines (\"x1.example.net\"\n
            \  and \"x2.example.net\"), as follows:\n   _xmpp-client._tcp.example.net.
            68400 IN SRV 20 0 5222 x1.example.net.\n   _xmpp-client._tcp.example.net.
            68400 IN SRV 20 0 5222 x2.example.net.\n   _xmpp-server._tcp.example.net.
            68400 IN SRV 20 0 5269 x1.example.net.\n   _xmpp-server._tcp.example.net.
            68400 IN SRV 20 0 5269 x2.example.net.\n   Example Internet Services also
            hosts chatrooms at chat.example.net,\n   and provides an xmpp-server SRV
            record for that service as well (thus\n   enabling entities from remote
            domains to access that service).  It\n   also might provide other such
            services in the future, so it wishes to\n   represent a wildcard in its
            certificate to handle such growth.\n   The certificate presented by either
            x1.example.net or x2.example.net\n   contains the following representations:\n
            \  o  An otherName type of SRVName (id-on-dnsSRV) containing an\n      IA5String
            (ASCII) string of \"_xmpp-client.example.net\"\n   o  An otherName type
            of SRVName (id-on-dnsSRV) containing an\n      IA5String (ASCII) string
            of \"_xmpp-server.example.net\"\n   o  An otherName type of SRVName (id-on-dnsSRV)
            containing an\n      IA5String (ASCII) string of \"_xmpp-server.chat.example.net\"\n
            \  o  A dNSName containing an ASCII string of \"example.net\"\n   o  A
            dNSName containing an ASCII string of \"*.example.net\"\n   o  An otherName
            type of XmppAddr (id-on-xmppAddr) containing a UTF-8\n      string of
            \"example.net\"\n   o  An otherName type of XmppAddr (id-on-xmppAddr)
            containing a UTF-8\n      string of \"chat.example.net\"\n   o  A CN containing
            an ASCII string of \"Example Internet Services\"\n"
          title: 13.7.1.2.2.  Examples
        title: 13.7.1.2.  Server Certificates
      - contents:
        - "13.7.1.3.  Client Certificates\n   In a PKIX certificate to be presented
          by an XMPP client controlled by\n   a human user (i.e., a \"client certificate\"),
          it is RECOMMENDED for\n   the certificate to include one or more JIDs associated
          with an XMPP\n   user.  If included, a JID MUST be represented as an XmppAddr
          as\n   specified under Section 13.7.1.4.\n"
        title: 13.7.1.3.  Client Certificates
      - contents:
        - "13.7.1.4.  XmppAddr Identifier Type\n   The XmppAddr identifier type is
          a UTF8String within an otherName\n   entity inside the subjectAltName, using
          the [ASN.1] Object Identifier\n   \"id-on-xmppAddr\" specified below.\n
          \  id-pkix OBJECT IDENTIFIER ::= { iso(1) identified-organization(3)\n           dod(6)
          internet(1) security(5) mechanisms(5) pkix(7) }\n   id-on  OBJECT IDENTIFIER
          ::= { id-pkix 8 }  -- other name forms\n   id-on-xmppAddr  OBJECT IDENTIFIER
          ::= { id-on 5 }\n   XmppAddr ::= UTF8String\n   As an alternative to the
          \"id-on-xmppAddr\" notation, this Object\n   Identifier MAY be represented
          in dotted display format (i.e.,\n   \"1.3.6.1.5.5.7.8.5\") or in the Uniform
          Resource Name notation\n   specified in [URN-OID] (i.e., \"urn:oid:1.3.6.1.5.5.7.8.5\").\n
          \  Thus for example the JID <juliet@im.example.com> as included in a\n   certificate
          could be formatted in any of the following three ways:\n   id-on-xmppAddr:\n
          \     subjectAltName=otherName:id-on-xmppAddr;UTF8:juliet@im.example.com\n
          \  dotted display format:  subjectAltName=otherName:\n      1.3.6.1.5.5.7.8.5;UTF8:juliet@im.example.com\n
          \  URN notation:  subjectAltName=otherName:urn:oid:\n      1.3.6.1.5.5.7.8.5;UTF8:juliet@im.example.com\n
          \  Use of the \"id-on-xmppAddr\" format is RECOMMENDED in the generation\n
          \  of certificates, but all three formats MUST be supported for the\n   purpose
          of certificate validation.\n   The \"id-on-xmppAddr\" object identifier
          MAY be used in conjunction\n   with the extended key usage extension specified
          in Section 4.2.1.12\n   of [PKIX] in order to explicitly define and limit
          the intended use of\n   a certificate to the XMPP network.\n"
        title: 13.7.1.4.  XmppAddr Identifier Type
      title: 13.7.1.  Certificate Generation
    - contents:
      - "13.7.2.  Certificate Validation\n   When an XMPP entity is presented with
        a server certificate or client\n   certificate by a peer for the purpose of
        encryption or authentication\n   of XML streams as described under Section
        5 and Section 6, the entity\n   MUST attempt to validate the certificate to
        determine if the\n   certificate will be considered a \"trusted certificate\",
        i.e., a\n   certificate that is acceptable for encryption and/or authentication\n
        \  in accordance with the XMPP entity's local service policies or\n   configured
        settings.\n   For both server certificates and client certificates, the validating\n
        \  entity MUST do the following:\n   1.  Attempt to verify the integrity of
        the certificate.\n   2.  Attempt to verify that the certificate has been properly
        signed\n       by the issuing Certificate Authority.\n   3.  Attempt to validate
        the full certification path.\n   4.  Check the rules for end entity public
        key certificates and\n       certification authority certificates specified
        under\n       Section 13.7.1.1 for the general case and under either\n       Section
        13.7.1.2 or Section 13.7.1.3 for XMPP server or client\n       certificates,
        respectively.\n   5.  Check certificate revocation messages via Certificate
        Revocation\n       Lists (CRLs), the Online Certificate Status Protocol [OCSP],
        or\n       both.\n   If any of those validation attempts fail, the validating
        entity MUST\n   unilaterally terminate the session.\n   The following sections
        describe the additional identity verification\n   rules that apply to server-to-server
        and client-to-server streams.\n   Once the identity of the stream peer has
        been validated, the\n   validating entity SHOULD also correlate the validated
        identity with\n   the 'from' address (if any) of the stream header it received
        from the\n   peer.  If the two identities do not match, the validating entity\n
        \  SHOULD terminate the connection attempt (however, there might be good\n
        \  reasons why the identities do not match, as described under\n   Section
        4.7.1).\n"
      - contents:
        - "13.7.2.1.  Server Certificates\n   For server certificates, the rules and
          guidelines defined in\n   [TLS-CERTS] apply, with the proviso that the XmppAddr
          identifier\n   specified under Section 13.7.1.4 is allowed as a reference\n
          \  identifier.\n   The identities to be checked are set as follows:\n   o
          \ The initiating entity sets the source domain of its reference\n      identifiers
          to the 'to' address it communicates in the initial\n      stream header;
          i.e., this is the identity it expects the receiving\n      entity to provide
          in a PKIX certificate.\n   o  The receiving entity sets the source domain
          of its reference\n      identifiers to the 'from' address communicated by
          the initiating\n      entity in the initial stream header; i.e., this is
          the identity\n      that the initiating entity is trying to assert.\n   In
          the case of server-to-server communication, the matching procedure\n   described
          in [TLS-CERTS] can be performed by an application server\n   (receiving
          entity) when verifying an incoming server-to-server\n   connection from
          a peer server (initiating entity).  In this case, the\n   receiving entity
          verifies the identity of the initiating entity and\n   uses as the source
          domain of its reference identifiers the DNS domain\n   name asserted by
          the initiating entity in the 'from' attribute of the\n   initial stream
          header.  However, the matching procedure described in\n   [TLS-CERTS] remains
          unchanged and is applied in the same way.\n"
        title: 13.7.2.1.  Server Certificates
      - contents:
        - "13.7.2.2.  Client Certificates\n   When an XMPP server validates a certificate
          presented by a client,\n   there are three possible cases, as discussed
          in the following\n   sections.\n   The identities to be checked are set
          as follows:\n   o  The client sets the source domain of its reference identifiers
          to\n      the 'to' address it communicates in the initial stream header;\n
          \     i.e., this is the identity it expects the server to provide in a\n
          \     PKIX certificate.\n   o  The server sets the bare JID of its reference
          identifiers to the\n      'from' address communicated by the initiating
          entity in the\n      initial stream header; i.e., this is the identity that
          the client\n      is trying to assert.\n"
        - contents:
          - "13.7.2.2.1.  Case #1\n   If the client certificate appears to be certified
            by a certification\n   path terminating in a trust anchor (as described
            in Section 6.1 of\n   [PKIX]), the server MUST check the certificate for
            any instances of\n   the XmppAddr as described under Section 13.7.1.4.
            \ There are three\n   possible sub-cases:\n   Sub-Case #1:  The server
            finds one XmppAddr for which the domainpart\n      of the represented
            JID matches one of the configured FQDNs of the\n      server; the server
            SHOULD use this represented JID as the\n      validated identity of the
            client.\n   Sub-Case #2:  The server finds more than one XmppAddr for
            which the\n      domainpart of the represented JID matches one of the
            configured\n      FQDNs of the server; the server SHOULD use one of these\n
            \     represented JIDs as the validated identity of the client, choosing\n
            \     among them based on the bare JID contained in the 'from' address\n
            \     of the initial stream header (if any), based on the domainpart\n
            \     contained in the 'to' address of the initial stream header, or in\n
            \     accordance with local service policies (such as a lookup in a user\n
            \     database based on other information contained in the client\n      certificate).\n
            \  Sub-Case #3:  The server finds no XmppAddrs, or finds at least one\n
            \     XmppAddr but the domainpart of the represented JID does not match\n
            \     one of the configured FQDNs of the server; the server MUST NOT use\n
            \     the represented JID (if any) as the validated identity of the\n
            \     client but instead MUST validate the identity of the client using\n
            \     other means in accordance with local service policies (such as a\n
            \     lookup in a user database based on other information contained in\n
            \     the client certificate).  If the identity cannot be so validated,\n
            \     the server MAY abort the validation process and terminate the TLS\n
            \     negotiation.\n"
          title: '13.7.2.2.1.  Case #1'
        - contents:
          - "13.7.2.2.2.  Case #2\n   If the client certificate is certified by a
            Certificate Authority not\n   known to the server, the server MUST proceed
            as under Case #1, Sub-\n   Case #3.\n"
          title: '13.7.2.2.2.  Case #2'
        - contents:
          - "13.7.2.2.3.  Case #3\n   If the client certificate is self-signed, the
            server MUST proceed as\n   under Case #1, Sub-Case #3.\n"
          title: '13.7.2.2.3.  Case #3'
        title: 13.7.2.2.  Client Certificates
      - contents:
        - "13.7.2.3.  Checking of Certificates in Long-Lived Streams\n   Because XMPP
          uses long-lived XML streams, it is possible that a\n   certificate presented
          during stream negotiation might expire or be\n   revoked while the stream
          is still live (this is especially relevant\n   in the context of server-to-server
          streams).  Therefore, each party\n   to a long-lived stream SHOULD:\n   1.
          \ Cache the expiration date of the certificate presented by the\n       other
          party and any certificates on which that certificate\n       depends (such
          as a root or intermediate certificate for a\n       certification authority),
          and close the stream when any such\n       certificate expires, with a stream
          error of <reset/>\n       (Section 4.9.3.16).\n   2.  Periodically query
          the Online Certificate Status Protocol [OCSP]\n       responder listed in
          the Authority Information Access (AIA)\n       extension of the certificate
          presented by the other party and any\n       certificates on which that
          certificate depends (such as a root or\n       intermediate certificate
          for a certification authority), and\n       close the stream if any such
          certificate has been revoked, with a\n       stream error of <reset/> (Section
          4.9.3.16).  It is RECOMMENDED\n       to query the OSCP responder at or
          near the time communicated via\n       the nextUpdate field received in
          the OCSP response or, if the\n       nextUpdate field is not set, to query
          every 24 hours.\n   After the stream is closed, the initiating entity from
          the closed\n   stream will need to reconnect and the receiving entity will
          need to\n   authenticate the initiating entity based on whatever certificate
          it\n   presents during negotiation of the new stream.\n"
        title: 13.7.2.3.  Checking of Certificates in Long-Lived Streams
      - contents:
        - "13.7.2.4.  Use of Certificates in XMPP Extensions\n   Certificates MAY
          be used in extensions to XMPP for the purpose of\n   application-layer encryption
          or authentication above the level of XML\n   streams (e.g., for end-to-end
          encryption).  Such extensions will\n   define their own certificate handling
          rules.  At a minimum, such\n   extensions are encouraged to remain consistent
          with the rules defined\n   in this specification, specifying additional
          rules only when\n   necessary.\n"
        title: 13.7.2.4.  Use of Certificates in XMPP Extensions
      title: 13.7.2.  Certificate Validation
    title: 13.7.  Certificates
  - contents:
    - "13.8.  Mandatory-to-Implement TLS and SASL Technologies\n   The following TLS
      ciphersuites and SASL mechanisms are mandatory-to-\n   implement (naturally,
      implementations MAY support other ciphersuites\n   and mechanisms as well).
      \ For security considerations related to TLS\n   ciphersuites, see Section 13.9.4
      and [TLS].  For security\n   considerations related to SASL mechanisms, see
      Section 13.9.4,\n   [SASL], and specifications for particular SASL mechanisms
      such as\n   [SCRAM], [DIGEST-MD5], and [PLAIN].\n"
    - contents:
      - "13.8.1.  For Authentication Only\n   For authentication only, servers and
        clients MUST support the SASL\n   Salted Challenge Response Authentication
        Mechanism [SCRAM] -- in\n   particular, the SCRAM-SHA-1 and SCRAM-SHA-1-PLUS
        variants.\n      Security Warning: Even though it is possible to complete\n
        \     authentication only without confidentiality, it is RECOMMENDED for\n
        \     servers and clients to protect the stream with TLS before\n      attempting
        authentication with SASL, both to help protect the\n      information exchanged
        during SASL negotiation and to help prevent\n      certain downgrade attacks
        as described under Section 13.9.4 and\n      Section 13.9.5.  Even if TLS
        is used, implementations SHOULD also\n      enforce channel binding as described
        under Section 13.9.4.\n      Interoperability Note: The SCRAM-SHA-1 or SASL-SCRAM-SHA-1-PLUS\n
        \     variants of the SCRAM mechanism replace the SASL DIGEST-MD5\n      mechanism
        as XMPP's mandatory-to-implement password-based method\n      for authentication
        only.  For backward-compatibility with existing\n      deployed infrastructure,
        implementations are encouraged to\n      continue supporting the DIGEST-MD5
        mechanism as specified in\n      [DIGEST-MD5]; however, there are known interoperability
        issues\n      with DIGEST-MD5 that make it impractical in the long term.\n"
      title: 13.8.1.  For Authentication Only
    - contents:
      - "13.8.2.  For Confidentiality Only\n   For confidentiality only, servers MUST
        support TLS with the\n   TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite.\n      Security
        Warning: Because a connection with confidentiality only\n      has weaker
        security properties than a connection with both\n      confidentiality and
        authentication, it is RECOMMENDED for servers\n      and clients to prefer
        connections with both qualities (e.g., by\n      protecting the stream with
        TLS before attempting authentication\n      with SASL).  In practice, confidentiality
        only is employed merely\n      for server-to-server connections when the peer
        server does not\n      present a trusted certificate and the servers use Server
        Dialback\n      [XEP-0220] for weak identity verification, but TLS with\n
        \     confidentiality only is still desirable to protect the connection\n
        \     against casual eavesdropping.\n"
      title: 13.8.2.  For Confidentiality Only
    - contents:
      - "13.8.3.  For Confidentiality and Authentication with Passwords\n   For both
        confidentiality and authentication with passwords, servers\n   and clients
        MUST implement TLS with the TLS_RSA_WITH_AES_128_CBC_SHA\n   ciphersuite plus
        SASL SCRAM, in particular the SCRAM-SHA-1 and\n   SCRAM-SHA-1-PLUS variants
        (with SCRAM-SHA1-PLUS being preferred, as\n   described under Section 13.9.4).\n
        \  As further explained in the following Security Warning, in certain\n   circumstances
        a server MAY offer TLS with the\n   TLS_RSA_WITH_AES_128_CBC_SHA ciphersuite
        plus SASL PLAIN when it is\n   not possible to offer more secure alternatives;
        in addition, clients\n   SHOULD implement PLAIN over TLS in order to maximize
        interoperability\n   with servers that are not able to deploy more secure
        alternatives.\n      Security Warning: In practice, many servers offer, and
        many\n      clients use, TLS plus SASL PLAIN.  The SCRAM-SHA-1 and especially\n
        \     SCRAM-SHA-1-PLUS variants of the SCRAM mechanism are strongly\n      preferred
        over the PLAIN mechanism because of their superior\n      security properties
        (including for SCRAM-SHA-1-PLUS the ability to\n      enforce channel binding
        as described under Section 13.9.4).  A\n      client SHOULD treat TLS plus
        SASL PLAIN as a technology of last\n      resort to be used only when interacting
        with a server that does\n      not offer SCRAM (or other alternatives that
        are more secure than\n      TLS plus SASL PLAIN), MUST prefer more secure
        mechanisms (e.g.,\n      EXTERNAL, SCRAM-SHA-1-PLUS, SCRAM-SHA-1, or the older
        DIGEST-MD5\n      mechanism) to the PLAIN mechanism, and MUST NOT use the
        PLAIN\n      mechanism if the stream does not at a minimum have confidentiality\n
        \     and integrity protection via TLS with full certificate validation\n
        \     as described under Section 13.7.2.1.  A server MUST NOT offer SASL\n
        \     PLAIN if the confidentiality and integrity of the stream are not\n      protected
        via TLS or an equivalent security layer.  A server\n      SHOULD NOT offer
        TLS plus SASL PLAIN unless it is unable to offer\n      some variant of SASL
        SCRAM (or other alternatives that are more\n      secure than TLS plus SASL
        PLAIN), e.g., because the XMPP service\n      depends for authentication purposes
        on a database or directory\n      that is not under the control of the XMPP
        administrators, such as\n      Pluggable Authentication Modules (PAM), an
        Lightweight Directory\n      Access Protocol (LDAP) directory [LDAP], or an
        Authentication,\n      Authorization, and Accounting (AAA) key management
        protocol (for\n      guidance, refer to [AAA]).  However, offering TLS plus
        SASL PLAIN\n      even when the server supports more secure alternatives might
        be\n      appropriate if the server needs to enable interoperability with
        an\n      installed base of clients that do not yet support SCRAM or other\n
        \     alternatives that are more secure than TLS plus SASL PLAIN.\n"
      title: 13.8.3.  For Confidentiality and Authentication with Passwords
    - contents:
      - "13.8.4.  For Confidentiality and Authentication without Passwords\n   For
        both confidentiality and authentication without passwords,\n   servers MUST
        and clients SHOULD implement TLS with the\n   TLS_RSA_WITH_AES_128_CBC_SHA
        ciphersuite plus the SASL EXTERNAL\n   mechanism (see Appendix A of [SASL])
        with PKIX certificates.\n"
      title: 13.8.4.  For Confidentiality and Authentication without Passwords
    title: 13.8.  Mandatory-to-Implement TLS and SASL Technologies
  - contents:
    - '13.9.  Technology Reuse

      '
    - contents:
      - "13.9.1.  Use of Base 64 in SASL\n   Both the client and the server MUST verify
        any base 64 data received\n   during SASL negotiation (Section 6).  An implementation
        MUST reject\n   (not ignore) any characters that are not explicitly allowed
        by the\n   base 64 alphabet; this helps to guard against creation of a covert\n
        \  channel that could be used to \"leak\" information.\n   An implementation
        MUST NOT break on invalid input and MUST reject any\n   sequence of base 64
        characters containing the pad ('=') character if\n   that character is included
        as something other than the last character\n   of the data (e.g., \"=AAA\"
        or \"BBBB=CCC\"); this helps to guard against\n   buffer overflow attacks
        and other attacks on the implementation.\n   While base 64 encoding visually
        hides otherwise easily recognized\n   information (such as passwords), it
        does not provide any\n   computational confidentiality.\n   All uses of base
        64 encoding MUST follow the definition in Section 4\n   of [BASE64] and padding
        bits MUST be set to zero.\n"
      title: 13.9.1.  Use of Base 64 in SASL
    - contents:
      - "13.9.2.  Use of DNS\n   XMPP typically relies on the Domain Name System (specifically\n
        \  [DNS-SRV] records) to resolve a fully qualified domain name to an IP\n
        \  address before a client connects to a server or before a peer server\n
        \  connects to another server.  Before attempting to negotiate an XML\n   stream,
        the initiating entity MUST NOT proceed until it has resolved\n   the DNS domain
        name of the receiving entity as specified under\n   Section 3 (although it
        is not necessary to resolve the DNS domain\n   name before each connection
        attempt, because DNS resolution results\n   can be temporarily cached in accordance
        with time-to-live values).\n   However, in the absence of a secure DNS option
        (e.g., as provided by\n   [DNSSEC]), a malicious attacker with access to the
        DNS server data,\n   or able to cause spoofed answers to be cached in a recursive\n
        \  resolver, can potentially cause the initiating entity to connect to\n   any
        XMPP server chosen by the attacker.  Deployment and validation of\n   server
        certificates help to prevent such attacks.\n"
      title: 13.9.2.  Use of DNS
    - contents:
      - "13.9.3.  Use of Hash Functions\n   XMPP itself does not directly mandate
        the use of any particular\n   cryptographic hash function.  However, technologies
        on which XMPP\n   depends (e.g., TLS and particular SASL mechanisms), as well
        as\n   various XMPP extensions, might make use of cryptographic hash\n   functions.
        \ Those who implement XMPP technologies or who develop XMPP\n   extensions
        are advised to closely monitor the state of the art\n   regarding attacks
        against cryptographic hash functions in Internet\n   protocols as they relate
        to XMPP.  For helpful guidance, refer to\n   [HASHES].\n"
      title: 13.9.3.  Use of Hash Functions
    - contents:
      - "13.9.4.  Use of SASL\n   Because the initiating entity chooses an acceptable
        SASL mechanism\n   from the list presented by the receiving entity, the initiating\n
        \  entity depends on the receiving entity's list for authentication.\n   This
        dependency introduces the possibility of a downgrade attack if\n   an attacker
        can gain control of the channel and therefore present a\n   weak list of mechanisms.
        \ To mitigate this attack, the parties SHOULD\n   protect the channel using
        TLS before attempting SASL negotiation and\n   either perform full certificate
        validation as described under\n   Section 13.7.2.1 or use a SASL mechanism
        that provides channel\n   bindings, such as SCRAM-SHA-1-PLUS.  (Protecting
        the channel via TLS\n   with full certificate validation can help to ensure
        the\n   confidentiality and integrity of the information exchanged during\n
        \  SASL negotiation.)\n   The SASL framework itself does not provide a method
        for binding SASL\n   authentication to a security layer providing confidentiality
        and\n   integrity protection that was negotiated at a lower layer (e.g.,\n
        \  TLS).  Such a binding is known as a \"channel binding\" (see\n   [CHANNEL]).
        \ Some SASL mechanisms provide channel bindings, which in\n   the case of
        XMPP would typically be a binding to TLS (see\n   [CHANNEL-TLS]).  If a SASL
        mechanism provides a channel binding\n   (e.g., this is true of [SCRAM]),
        then XMPP entities using that\n   mechanism SHOULD prefer the channel binding
        variant (e.g., preferring\n   \"SCRAM-SHA-1-PLUS\" over \"SCRAM-SHA-1\").
        \ If a SASL mechanism does not\n   provide a channel binding, then the mechanism
        cannot provide a way to\n   verify that the source and destination end points
        to which the lower\n   layer's security is bound are equivalent to the end
        points that SASL\n   is authenticating; furthermore, if the end points are
        not identical,\n   then the lower layer's security cannot be trusted to protect
        data\n   transmitted between the SASL-authenticated entities.  In such a\n
        \  situation, a SASL security layer SHOULD be negotiated that\n   effectively
        ignores the presence of the lower-layer security.\n   Many deployed XMPP services
        authenticate client connections by means\n   of passwords.  It is well known
        that most human users choose\n   relatively weak passwords.  Although service
        provisioning is out of\n   scope for this document, XMPP servers that allow
        password-based\n   authentication SHOULD enforce minimal criteria for password
        strength\n   to help prevent dictionary attacks.  Because all password-based\n
        \  authentication mechanisms are susceptible to password guessing\n   attacks,
        XMPP servers MUST limit the number of retries allowed during\n   SASL authentication,
        as described under Section 6.4.5.\n   Some SASL mechanisms (e.g., [ANONYMOUS])
        do not provide strong peer\n   entity authentication of the client to the
        server.  Service\n   administrators are advised to enable such mechanisms
        with caution.\n   Best practices for the use of the SASL ANONYMOUS mechanism
        in XMPP\n   are described in [XEP-0175].\n"
      title: 13.9.4.  Use of SASL
    - contents:
      - "13.9.5.  Use of TLS\n   Implementations of TLS typically support multiple
        versions of the\n   Transport Layer Security protocol as well as the older
        Secure Sockets\n   Layer (SSL) protocol.  Because of known security vulnerabilities,\n
        \  XMPP servers and clients MUST NOT request, offer, or use SSL 2.0.\n   For
        further details, see Appendix E.2 of [TLS] along with [TLS-SSL2].\n   To prevent
        man-in-the-middle attacks, the TLS client (which might be\n   an XMPP client
        or an XMPP server) MUST verify the certificate of the\n   TLS server and MUST
        check its understanding of the server FQDN\n   against the server's identity
        as presented in the TLS Certificate\n   message as described under Section
        13.7.2.1 (for further details, see\n   [TLS-CERTS].\n   Support for TLS renegotiation
        is strictly OPTIONAL.  However,\n   implementations that support TLS renegotiation
        MUST implement and use\n   the TLS Renegotiation Extension [TLS-NEG].  Further
        details are\n   provided under Section 5.3.5.\n"
      title: 13.9.5.  Use of TLS
    - contents:
      - "13.9.6.  Use of UTF-8\n   The use of UTF-8 makes it possible to transport
        non-ASCII characters,\n   and thus enables character \"spoofing\" scenarios,
        in which a displayed\n   value appears to be something other than it is.  Furthermore,
        there\n   are known attack scenarios related to the decoding of UTF-8 data.
        \ On\n   both of these points, refer to [UTF-8] for more information.\n"
      title: 13.9.6.  Use of UTF-8
    - contents:
      - "13.9.7.  Use of XML\n   Because XMPP is an application profile of the Extensible
        Markup\n   Language [XML], many of the security considerations described in\n
        \  [XML-MEDIA] and [XML-GUIDE] also apply to XMPP.  Several aspects of\n   XMPP
        mitigate the risks described there, such as the prohibitions\n   specified
        under Section 11.1 and the lack of external references to\n   style sheets
        or transformations, but these mitigating factors are by\n   no means comprehensive.\n"
      title: 13.9.7.  Use of XML
    title: 13.9.  Technology Reuse
  - contents:
    - '13.10.  Information Leaks

      '
    - contents:
      - "13.10.1.  IP Addresses\n   A client's IP address and method of access MUST
        NOT be made public by\n   a server (e.g., as typically occurs in [IRC]).\n"
      title: 13.10.1.  IP Addresses
    - contents:
      - "13.10.2.  Presence Information\n   One of the core aspects of XMPP is presence:
        information about the\n   network availability of an XMPP entity (i.e., whether
        the entity is\n   currently online or offline).  A \"presence leak\" occurs
        when an\n   entity's network availability is inadvertently and involuntarily\n
        \  revealed to a second entity that is not authorized to know the first\n
        \  entity's network availability.\n   Although presence is discussed more
        fully in [XMPP-IM], it is\n   important to note that an XMPP server MUST NOT
        leak presence.  In\n   particular at the core XMPP level, real-time addressing
        and network\n   availability is associated with a specific connected resource;\n
        \  therefore, any disclosure of a connected resource's full JID\n   comprises
        a presence leak.  To help prevent such a presence leak, a\n   server MUST
        NOT return different stanza errors depending on whether a\n   potential attacker
        sends XML stanzas to the entity's bare JID\n   (<localpart@domainpart>) or
        full JID\n   (<localpart@domainpart/resourcepart>).\n"
      title: 13.10.2.  Presence Information
    title: 13.10.  Information Leaks
  - contents:
    - "13.11.  Directory Harvesting\n   If a server generates an error stanza in response
      to receiving a\n   stanza for a user account that does not exist, using the
      <service-\n   unavailable/> stanza error condition (Section 8.3.3.19) can help\n
      \  protect against directory harvesting attacks, since this is the same\n   error
      condition that is returned if, for instance, the namespace of\n   an IQ child
      element is not understood, or if \"offline message\n   storage\" ([XEP-0160])
      or message forwarding is not enabled for a\n   domain.  However, subtle differences
      in the exact XML of error\n   stanzas, as well as in the timing with which such
      errors are\n   returned, can enable an attacker to determine the network presence
      of\n   a user when more advanced blocking technologies are not used (see for\n
      \  instance [XEP-0016] and [XEP-0191]).  Therefore, a server that\n   exercises
      a higher level of caution might not return any error at all\n   in response
      to certain kinds of received stanzas, so that a non-\n   existent user appears
      to behave like a user that has no interest in\n   conversing with the sender.\n"
    title: 13.11.  Directory Harvesting
  - contents:
    - "13.12.  Denial of Service\n   [DOS] defines denial of service as follows:\n
      \     A denial-of-service (DoS) attack is an attack in which one or more\n      machines
      target a victim and attempt to prevent the victim from\n      doing useful work.
      \ The victim can be a network server, client or\n      router, a network link
      or an entire network, an individual\n      Internet user or a company doing
      business using the Internet, an\n      Internet Service Provider (ISP), country,
      or any combination of or\n      variant on these.\n   Some considerations discussed
      in this document help to prevent\n   denial-of-service attacks (e.g., the mandate
      that a server MUST NOT\n   process XML stanzas from clients that have not yet
      provided\n   appropriate authentication credentials and MUST NOT process XML\n
      \  stanzas from peer servers whose identity it has not either\n   authenticated
      via SASL or weakly verified via Server Dialback).\n   In addition, [XEP-0205]
      provides a detailed discussion of potential\n   denial-of-service attacks against
      XMPP systems along with best\n   practices for preventing such attacks.  The
      recommendations include:\n   1.  A server implementation SHOULD enable a server
      administrator to\n       limit the number of TCP connections that it will accept
      from a\n       given IP address at any one time.  If an entity attempts to\n
      \      connect but the maximum number of TCP connections has been\n       reached,
      the receiving server MUST NOT allow the new connection\n       to proceed.\n
      \  2.  A server implementation SHOULD enable a server administrator to\n       limit
      the number of TCP connection attempts that it will accept\n       from a given
      IP address in a given time period.  If an entity\n       attempts to connect
      but the maximum number of connection attempts\n       has been reached, the
      receiving server MUST NOT allow the new\n       connection to proceed.\n   3.
      \ A server implementation SHOULD enable a server administrator to\n       limit
      the number of connected resources it will allow an account\n       to bind at
      any one time.  If a client attempts to bind a resource\n       but it has already
      reached the configured number of allowable\n       resources, the receiving
      server MUST return a <resource-\n       constraint/> stanza error (Section 8.3.3.18).\n
      \  4.  A server implementation SHOULD enable a server administrator to\n       limit
      the size of stanzas it will accept from a connected client\n       or peer server
      (where \"size\" is inclusive of all XML markup as\n       defined in Section
      2.4 of [XML], from the opening \"<\" character\n       of the stanza to the
      closing \">\" character).  A deployed server's\n       maximum stanza size MUST
      NOT be smaller than 10000 bytes, which\n       reflects a reasonable compromise
      between the benefits of\n       expressiveness for originating entities and
      the costs of stanza\n       processing for servers.  A server implementation
      SHOULD NOT\n       blindly set 10000 bytes as the value for all deployments
      but\n       instead SHOULD enable server administrators to set their own\n       limits.
      \ If a connected resource or peer server sends a stanza\n       that violates
      the upper limit, the receiving server MUST either\n       return a <policy-violation/>
      stanza error (Section 8.3.3.12),\n       thus allowing the sender to recover,
      or close the stream with a\n       <policy-violation/> stream error (Section
      4.9.3.14).\n   5.  A server implementation SHOULD enable a server administrator
      to\n       limit the number of XML stanzas that a connected client is\n       allowed
      to send to distinct recipients within a given time\n       period.  If a connected
      client sends too many stanzas to distinct\n       recipients in a given time
      period, the receiving server SHOULD\n       NOT process the stanza and instead
      SHOULD return a <policy-\n       violation/> stanza error (Section 8.3.3.12).\n
      \  6.  A server implementation SHOULD enable a server administrator to\n       limit
      the amount of bandwidth it will allow a connected client or\n       peer server
      to use in a given time period.\n   7.  A server implementation MAY enable a
      server administrator to\n       limit the types of stanzas (based on the extended
      content\n       \"payload\") that it will allow a connected resource or peer
      server\n       send over an active connection.  Such limits and restrictions
      are\n       a matter of deployment policy.\n   8.  A server implementation MAY
      refuse to route or deliver any stanza\n       that it considers to be abusive,
      with or without returning an\n       error to the sender.\n   For more detailed
      recommendations regarding denial-of-service attacks\n   in XMPP systems, refer
      to [XEP-0205].\n"
    title: 13.12.  Denial of Service
  - contents:
    - "13.13.  Firewalls\n   Although DNS SRV records can instruct connecting entities
      to use TCP\n   ports other than 5222 (client-to-server) and 5269 (server-to-server),\n
      \  communication using XMPP typically occurs over those ports, which are\n   registered
      with the IANA (see Section 14).  Use of these well-known\n   ports allows administrators
      to easily enable or disable XMPP activity\n   through existing and commonly
      deployed firewalls.\n"
    title: 13.13.  Firewalls
  - contents:
    - "13.14.  Interdomain Federation\n   The term \"federation\" is commonly used
      to describe communication\n   between two servers.\n   Because service provisioning
      is a matter of policy, it is OPTIONAL\n   for any given server to support federation.
      \ If a particular server\n   enables federation, it SHOULD enable strong security
      as previously\n   described to ensure both authentication and confidentiality;\n
      \  compliant implementations SHOULD support TLS and SASL for this\n   purpose.\n
      \  Before RFC 3920 defined TLS plus SASL EXTERNAL with certificates for\n   encryption
      and authentication of server-to-server streams, the only\n   method for weak
      identity verification of a peer server was Server\n   Dialback as defined in
      [XEP-0220].  Even when [DNSSEC] is used,\n   Server Dialback provides only weak
      identity verification and provides\n   no confidentiality or integrity.  At
      the time of writing, Server\n   Dialback is still the most widely used technique
      for some level of\n   assurance over server-to-server streams.  This reality
      introduces the\n   possibility of a downgrade attack from TLS + SASL EXTERNAL
      to Server\n   Dialback if an attacker can gain control of the channel and therefore\n
      \  convince the initiating server that the receiving server does not\n   support
      TLS or does not have an appropriate certificate.  To help\n   prevent this attack,
      the parties SHOULD protect the channel using TLS\n   before proceeding, even
      if the presented certificates are self-signed\n   or otherwise untrusted.\n"
    title: 13.14.  Interdomain Federation
  - contents:
    - "13.15.  Non-Repudiation\n   Systems that provide both peer entity authentication
      and data\n   integrity have the potential to enable an entity to prove to a
      third\n   party that another entity intended to send particular data.  Although\n
      \  XMPP systems can provide both peer entity authentication and data\n   integrity,
      XMPP was never designed to provide non-repudiation.\n"
    title: 13.15.  Non-Repudiation
  title: 13.  Security Considerations
- contents:
  - "14.  IANA Considerations\n   The following subsections update the registrations
    provided in\n   [RFC3920].  This section is to be interpreted according to\n   [IANA-GUIDE].\n"
  - contents:
    - "14.1.  XML Namespace Name for TLS Data\n   A URN sub-namespace for STARTTLS
      negotiation data in the Extensible\n   Messaging and Presence Protocol (XMPP)
      is defined as follows.  (This\n   namespace name adheres to the format defined
      in [XML-REG].)\n   URI:  urn:ietf:params:xml:ns:xmpp-tls\n   Specification:
      \ RFC 6120\n   Description:  This is the XML namespace name for STARTTLS negotiation\n
      \     data in the Extensible Messaging and Presence Protocol (XMPP) as\n      defined
      by RFC 6120.\n   Registrant Contact:  IESG <iesg@ietf.org>\n"
    title: 14.1.  XML Namespace Name for TLS Data
  - contents:
    - "14.2.  XML Namespace Name for SASL Data\n   A URN sub-namespace for SASL negotiation
      data in the Extensible\n   Messaging and Presence Protocol (XMPP) is defined
      as follows.  (This\n   namespace name adheres to the format defined in [XML-REG].)\n
      \  URI:  urn:ietf:params:xml:ns:xmpp-sasl\n   Specification:  RFC 6120\n   Description:
      \ This is the XML namespace name for SASL negotiation\n      data in the Extensible
      Messaging and Presence Protocol (XMPP) as\n      defined by RFC 6120.\n   Registrant
      Contact:  IESG <iesg@ietf.org>\n"
    title: 14.2.  XML Namespace Name for SASL Data
  - contents:
    - "14.3.  XML Namespace Name for Stream Errors\n   A URN sub-namespace for stream
      error data in the Extensible Messaging\n   and Presence Protocol (XMPP) is defined
      as follows.  (This namespace\n   name adheres to the format defined in [XML-REG].)\n
      \  URI:  urn:ietf:params:xml:ns:xmpp-streams\n   Specification:  RFC 6120\n
      \  Description:  This is the XML namespace name for stream error data in\n      the
      Extensible Messaging and Presence Protocol (XMPP) as defined\n      by RFC 6120.\n
      \  Registrant Contact:  IESG <iesg@ietf.org>\n"
    title: 14.3.  XML Namespace Name for Stream Errors
  - contents:
    - "14.4.  XML Namespace Name for Resource Binding\n   A URN sub-namespace for
      resource binding in the Extensible Messaging\n   and Presence Protocol (XMPP)
      is defined as follows.  (This namespace\n   name adheres to the format defined
      in [XML-REG].)\n   URI:  urn:ietf:params:xml:ns:xmpp-bind\n   Specification:
      \ RFC 6120\n   Description:  This is the XML namespace name for resource binding
      in\n      the Extensible Messaging and Presence Protocol (XMPP) as defined\n
      \     by RFC 6120.\n   Registrant Contact:  IESG <iesg@ietf.org>\n"
    title: 14.4.  XML Namespace Name for Resource Binding
  - contents:
    - "14.5.  XML Namespace Name for Stanza Errors\n   A URN sub-namespace for stanza
      error data in the Extensible Messaging\n   and Presence Protocol (XMPP) is defined
      as follows.  (This namespace\n   name adheres to the format defined in [XML-REG].)\n
      \  URI:  urn:ietf:params:xml:ns:xmpp-stanzas\n   Specification:  RFC 6120\n
      \  Description:  This is the XML namespace name for stanza error data in\n      the
      Extensible Messaging and Presence Protocol (XMPP) as defined\n      by RFC 6120.\n
      \  Registrant Contact:  IESG <iesg@ietf.org>\n"
    title: 14.5.  XML Namespace Name for Stanza Errors
  - contents:
    - "14.6.  GSSAPI Service Name\n   The IANA has registered \"xmpp\" as a [GSS-API]
      service name, as\n   defined under Section 6.6.\n"
    title: 14.6.  GSSAPI Service Name
  - contents:
    - "14.7.  Port Numbers and Service Names\n   The IANA has registered \"xmpp-client\"
      and \"xmpp-server\" as keywords\n   for [TCP] ports 5222 and 5269, respectively.
      \ In accordance with\n   [IANA-PORTS], this document updates the existing registration,
      as\n   follows.\n   Service Name:  xmpp-client\n   Transport Protocol:  TCP\n
      \  Description:  A service offering support for connections by XMPP\n      client
      applications\n   Registrant:  IETF XMPP Working Group\n   Contact:  IESG <iesg@ietf.org>\n
      \  Reference:  RFC 6120\n   Port Number:  5222\n   Service Name:  xmpp-server\n
      \  Transport Protocol:  TCP\n   Description:  A service offering support for
      connections by XMPP\n      server applications\n   Registrant:  IETF XMPP Working
      Group\n   Contact:  IESG <iesg@ietf.org>\n   Reference:  RFC 6120\n   Port Number:
      \ 5269\n"
    title: 14.7.  Port Numbers and Service Names
  title: 14.  IANA Considerations
- contents:
  - "15.  Conformance Requirements\n   This section describes a protocol feature set
    that summarizes the\n   conformance requirements of this specification.  This
    feature set is\n   appropriate for use in software certification, interoperability\n
    \  testing, and implementation reports.  For each feature, this section\n   provides
    the following information:\n   o  A human-readable name\n   o  An informational
    description\n   o  A reference to the particular section of this document that\n
    \     normatively defines the feature\n   o  Whether the feature applies to the
    Client role, the Server role,\n      or both (where \"N/A\" signifies that the
    feature is not applicable\n      to the specified role)\n   o  Whether the feature
    MUST or SHOULD be implemented, where the\n      capitalized terms are to be understood
    as described in [KEYWORDS]\n   The feature set specified here attempts to adhere
    to the concepts and\n   formats proposed by Larry Masinter within the IETF's NEWTRK
    Working\n   Group in 2005, as captured in [INTEROP].  Although this feature set\n
    \  is more detailed than called for by [REPORTS], it provides a suitable\n   basis
    for the generation of implementation reports to be submitted in\n   support of
    advancing this specification from Proposed Standard to\n   Draft Standard in accordance
    with [PROCESS].\n   Feature:  bind-gen\n   Description:  Generate a random resource
    on demand.\n   Section:  Section 7.6\n   Roles:  Client N/A, Server MUST.\n   Feature:
    \ bind-mtn\n   Description:  Consider resource binding as mandatory-to-negotiate.\n
    \  Section:  Section 7.3.1\n   Roles:  Client MUST, Server MUST.\n   Feature:
    \ bind-restart\n   Description:  Do not restart the stream after negotiation of
    resource\n      binding.\n   Section:  Section 7.3.2\n   Roles:  Client MUST,
    Server MUST.\n   Feature:  bind-support\n   Description:  Support binding of client
    resources to an authenticated\n      stream.\n   Section:  Section 7\n   Roles:
    \ Client MUST, Server MUST.\n   Feature:  sasl-correlate\n   Description:  When
    authenticating a stream peer using SASL, correlate\n      the authentication identifier
    resulting from SASL negotiation with\n      the 'from' address (if any) of the
    stream header it received from\n      the peer.\n   Section:  Section 6.4.6\n
    \  Roles:  Client SHOULD, Server SHOULD.\n   Feature:  sasl-errors\n   Description:
    \ Support SASL errors during the negotiation process.\n   Section:  Section 6.5\n
    \  Roles:  Client MUST, Server MUST.\n   Feature:  sasl-mtn\n   Description:  Consider
    SASL as mandatory-to-negotiate.\n   Section:  Section 6.3.1\n   Roles:  Client
    MUST, Server MUST.\n   Feature:  sasl-restart\n   Description:  Initiate or handle
    a stream restart after SASL\n      negotiation.\n   Section:  Section 6.3.2\n
    \  Roles:  Client MUST, Server MUST.\n   Feature:  sasl-support\n   Description:
    \ Support the Simple Authentication and Security Layer\n      for stream authentication.\n
    \  Section:  Section 6\n   Roles:  Client MUST, Server MUST.\n   Feature:  security-mti-auth-scram\n
    \  Description:  Support the SASL SCRAM mechanism for authentication\n      only
    (this implies support for both the SCRAM-SHA-1 and\n      SCRAM-SHA-1-PLUS variants).\n
    \  Section:  Section 13.8\n   Roles:  Client MUST, Server MUST.\n   Feature:  security-mti-both-external\n
    \  Description:  Support TLS with SASL EXTERNAL for confidentiality and\n      authentication.\n
    \  Section:  Section 13.8\n   Roles:  Client SHOULD, Server MUST.\n   Feature:
    \ security-mti-both-plain\n   Description:  Support TLS using the TLS_RSA_WITH_AES_128_CBC_SHA\n
    \     ciphersuite plus the SASL PLAIN mechanism for confidentiality and\n      authentication.\n
    \  Section:  Section 13.8\n   Roles:  Client SHOULD, Server MAY.\n   Feature:
    \ security-mti-both-scram\n   Description:  Support TLS using the TLS_RSA_WITH_AES_128_CBC_SHA\n
    \     ciphersuite plus the SCRAM-SHA-1 and SCRAM-SHA-1-PLUS variants of\n      the
    SASL SCRAM mechanism for confidentiality and authentication.\n   Section:  Section
    13.8\n   Roles:  Client MUST, Server MUST.\n   Feature:  security-mti-confidentiality\n
    \  Description:  Support TLS using the TLS_RSA_WITH_AES_128_CBC_SHA\n      ciphersuite
    for confidentiality only.\n   Section:  Section 13.8\n   Roles:  Client N/A, Server
    SHOULD.\n   Feature:  stanza-attribute-from\n   Description:  Support the common
    'from' attribute for all stanza\n      kinds.\n   Section:  Section 8.1.2\n   Roles:
    \ Client MUST, Server MUST.\n   Feature:  stanza-attribute-from-stamp\n   Description:
    \ Stamp or rewrite the 'from' address of all stanzas\n      received from connected
    clients.\n   Section:  Section 8.1.2.1\n   Roles:  Client N/A, Server MUST.\n
    \  Feature:  stanza-attribute-from-validate\n   Description:  Validate the 'from'
    address of all stanzas received\n      from peer servers.\n   Section:  Section
    8.1.2.2\n   Roles:  Client N/A, Server MUST.\n   Feature:  stanza-attribute-id\n
    \  Description:  Support the common 'id' attribute for all stanza kinds.\n   Section:
    \ Section 8.1.3\n   Roles:  Client MUST, Server MUST.\n   Feature:  stanza-attribute-to\n
    \  Description:  Support the common 'to' attribute for all stanza kinds.\n   Section:
    \ Section 8.1.1\n   Roles:  Client MUST, Server MUST.\n   Feature:  stanza-attribute-to-validate\n
    \  Description:  Ensure that all stanzas received from peer servers\n      include
    a 'to' address.\n   Section:  Section 8.1.1\n   Roles:  Client N/A, Server MUST.\n
    \  Feature:  stanza-attribute-type\n   Description:  Support the common 'type'
    attribute for all stanza\n      kinds.\n   Section:  Section 8.1.4\n   Roles:
    \ Client MUST, Server MUST.\n   Feature:  stanza-attribute-xmllang\n   Description:
    \ Support the common 'xml:lang' attribute for all stanza\n      kinds.\n   Section:
    \ Section 8.1.5\n   Roles:  Client MUST, Server MUST.\n   Feature:  stanza-error\n
    \  Description:  Generate and handle stanzas of type \"error\" for all\n      stanza
    kinds.\n   Section:  Section 8.3\n   Roles:  Client MUST, Server MUST.\n   Feature:
    \ stanza-error-child\n   Description:  Ensure that stanzas of type \"error\" include
    an <error/>\n      child element.\n   Section:  Section 8.3\n   Roles:  Client
    MUST, Server MUST.\n   Feature:  stanza-error-id\n   Description:  Ensure that
    stanzas of type \"error\" preserve the 'id'\n      provided in the triggering
    stanza.\n   Section:  Section 8.3\n   Roles:  Client MUST, Server MUST.\n   Feature:
    \ stanza-error-reply\n   Description:  Do not reply to a stanza of type \"error\"
    with another\n      stanza of type \"error\".\n   Section:  Section 8.3\n   Roles:
    \ Client MUST, Server MUST.\n   Feature:  stanza-extension\n   Description:  Correctly
    process XML data qualified by an unsupported\n      XML namespace, where \"correctly
    process\" means to ignore that\n      portion of the stanza in the case of a message
    or presence stanza\n      and return an error in the case of an IQ stanza (for
    the intended\n      recipient), and to route or deliver the stanza (for a routing\n
    \     entity such as a server).\n   Section:  Section 8.4\n   Roles:  Client MUST,
    Server MUST.\n   Feature:  stanza-iq-child\n   Description:  Include exactly one
    child element in an <iq/> stanza of\n      type \"get\" or \"set\", zero or one
    child elements in an <iq/> stanza\n      of type \"result\", and one or two child
    elements in an <iq/> stanza\n      of type \"error\".\n   Section:  Section 8.2.3\n
    \  Roles:  Client MUST, Server MUST.\n   Feature:  stanza-iq-id\n   Description:
    \ Ensure that all <iq/> stanzas include an 'id'\n      attribute.\n   Section:
    \ Section 8.2.3\n   Roles:  Client MUST, Server MUST.\n   Feature:  stanza-iq-reply\n
    \  Description:  Reply to an <iq/> stanza of type \"get\" or \"set\" with an\n
    \     <iq/> stanza of type \"result\" or \"error\".\n   Section:  Section 8.2.3\n
    \  Roles:  Client MUST, Server MUST.\n   Feature:  stanza-iq-type\n   Description:
    \ Ensure that all <iq/> stanzas include a 'type'\n      attribute whose value
    is \"get\", \"set\", \"result\", or \"error\".\n   Section:  Section 8.2.3\n   Roles:
    \ Client MUST, Server MUST.\n   Feature:  stanza-kind-iq\n   Description:  Support
    the <iq/> stanza.\n   Section:  Section 8.2.3\n   Roles:  Client MUST, Server
    MUST.\n   Feature:  stanza-kind-message\n   Description:  Support the <message/>
    stanza.\n   Section:  Section 8.2.1\n   Roles:  Client MUST, Server MUST.\n   Feature:
    \ stanza-kind-presence\n   Description:  Support the <presence/> stanza.\n   Section:
    \ Section 8.2.2\n   Roles:  Client MUST, Server MUST.\n   Feature:  stream-attribute-initial-from\n
    \  Description:  Include a 'from' attribute in the initial stream\n      header.\n
    \  Section:  Section 4.7.1\n   Roles:  Client SHOULD, Server MUST.\n   Feature:
    \ stream-attribute-initial-lang\n   Description:  Include an 'xml:lang' attribute
    in the initial stream\n      header.\n   Section:  Section 4.7.4\n   Roles:  Client
    SHOULD, Server SHOULD.\n   Feature:  stream-attribute-initial-to\n   Description:
    \ Include a 'to' attribute in the initial stream header.\n   Section:  Section
    4.7.2\n   Roles:  Client MUST, Server MUST.\n   Feature:  stream-attribute-response-from\n
    \  Description:  Include a 'from' attribute in the response stream\n      header.\n
    \  Section:  Section 4.7.1\n   Roles:  Client N/A, Server MUST.\n   Feature:  stream-attribute-response-id\n
    \  Description:  Include an 'id' attribute in the response stream\n      header.\n
    \  Section:  Section 4.7.3\n   Roles:  Client N/A, Server MUST.\n   Feature:  stream-attribute-response-id-unique\n
    \  Description:  Ensure that the 'id' attribute in the response stream\n      header
    is unique within the context of the receiving entity.\n   Section:  Section 4.7.3\n
    \  Roles:  Client N/A, Server MUST.\n   Feature:  stream-attribute-response-to\n
    \  Description:  Include a 'to' attribute in the response stream header.\n   Section:
    \ Section 4.7.2\n   Roles:  Client N/A, Server SHOULD.\n   Feature:  stream-error-generate\n
    \  Description:  Generate a stream error (followed by a closing stream\n      tag
    and termination of the TCP connection) upon detecting a\n      stream-related
    error condition.\n   Section:  Section 4.9\n   Roles:  Client MUST, Server MUST.\n
    \  Feature:  stream-fqdn-resolution\n   Description:  Resolve FQDNs before opening
    a TCP connection to the\n      receiving entity.\n   Section:  Section 3.2\n   Roles:
    \ Client MUST, Server MUST.\n   Feature:  stream-negotiation-complete\n   Description:
    \ Do not consider the stream negotiation process to be\n      complete until the
    receiving entity sends a stream features\n      advertisement that is empty or
    that contains only voluntary-to-\n      negotiate features.\n   Section:  Section
    4.3.5\n   Roles:  Client MUST, Server MUST.\n   Feature:  stream-negotiation-features\n
    \  Description:  Send stream features after sending a response stream\n      header.\n
    \  Section:  Section 4.3.2\n   Roles:  Client N/A, Server MUST.\n   Feature:  stream-negotiation-restart\n
    \  Description:  Consider the previous stream to be replaced upon\n      negotiation
    of a stream feature that necessitates a stream\n      restart, and send or receive
    a new initial stream header after\n      negotiation of such a stream feature.\n
    \  Section:  Section 4.3.3\n   Roles:  Client MUST, Server MUST.\n   Feature:
    \ stream-reconnect\n   Description:  Reconnect with exponential backoff if a TCP
    connection\n      is terminated unexpectedly.\n   Section:  Section 3.3\n   Roles:
    \ Client MUST, Server MUST.\n   Feature:  stream-tcp-binding\n   Description:
    \ Bind an XML stream to a TCP connection.\n   Section:  Section 3\n   Roles:  Client
    MUST, Server MUST.\n   Feature:  tls-certs\n   Description:  Check the identity
    specified in a certificate that is\n      presented during TLS negotiation.\n
    \  Section:  Section 13.7.2\n   Roles:  Client MUST, Server MUST.\n   Feature:
    \ tls-mtn\n   Description:  Consider TLS as mandatory-to-negotiate if STARTTLS
    is\n      the only feature advertised or if the STARTTLS feature\n      advertisement
    includes an empty <required/> element.\n   Section:  Section 5.3.1\n   Roles:
    \ Client MUST, Server MUST.\n   Feature:  tls-restart\n   Description:  Initiate
    or handle a stream restart after TLS\n      negotiation.\n   Section:  Section
    5.3.2\n   Roles:  Client MUST, Server MUST.\n   Feature:  tls-support\n   Description:
    \ Support Transport Layer Security for stream encryption.\n   Section:  Section
    5\n   Roles:  Client MUST, Server MUST.\n   Feature:  tls-correlate\n   Description:
    \ When validating a certificate presented by a stream\n      peer during TLS negotiation,
    correlate the validated identity with\n      the 'from' address (if any) of the
    stream header it received from\n      the peer.\n   Section:  Section 13.7.2\n
    \  Roles:  Client SHOULD, Server SHOULD.\n   Feature:  xml-namespace-content-client\n
    \  Description:  Support 'jabber:client' as a content namespace.\n   Section:
    \ Section 4.8.2\n   Roles:  Client MUST, Server MUST.\n   Feature:  xml-namespace-content-server\n
    \  Description:  Support 'jabber:server' as a content namespace.\n   Section:
    \ Section 4.8.2\n   Roles:  Client N/A, Server MUST.\n   Feature:  xml-namespace-streams-declaration\n
    \  Description:  Ensure that there is a namespace declaration for the\n      'http://etherx.jabber.org/streams'
    namespace.\n   Section:  Section 4.8.1\n   Roles:  Client MUST, Server MUST.\n
    \  Feature:  xml-namespace-streams-prefix\n   Description:  Ensure that all elements
    qualified by the\n      'http://etherx.jabber.org/streams' namespace are prefixed
    by the\n      prefix (if any) defined in the namespace declaration.\n   Section:
    \ Section 4.8.1\n   Roles:  Client MUST, Server MUST.\n   Feature:  xml-restriction-comment\n
    \  Description:  Do not generate or accept XML comments.\n   Section:  Section
    11.1\n   Roles:  Client MUST, Server MUST.\n   Feature:  xml-restriction-dtd\n
    \  Description:  Do not generate or accept internal or external DTD\n      subsets.\n
    \  Section:  Section 11.1\n   Roles:  Client MUST, Server MUST.\n   Feature:  xml-restriction-pi\n
    \  Description:  Do not generate or accept XML processing instructions.\n   Section:
    \ Section 11.1\n   Roles:  Client MUST, Server MUST.\n   Feature:  xml-restriction-ref\n
    \  Description:  Do not generate or accept internal or external entity\n      references
    with the exception of the predefined entities.\n   Section:  Section 11.1\n   Roles:
    \ Client MUST, Server MUST.\n   Feature:  xml-wellformed-xml\n   Description:
    \ Do not generate or accept data that is not XML-well-\n      formed.\n   Section:
    \ Section 11.3\n   Roles:  Client MUST, Server MUST.\n   Feature:  xml-wellformed-ns\n
    \  Description:  Do not generate or accept data that is not namespace-\n      well-formed.\n
    \  Section:  Section 11.3\n   Roles:  Client MUST, Server MUST.\n"
  title: 15.  Conformance Requirements
- contents:
  - '16.  References

    '
  - contents:
    - "16.1.  Normative References\n   [BASE64]        Josefsson, S., \"The Base16,
      Base32, and Base64 Data\n                   Encodings\", RFC 4648, October 2006.\n
      \  [CHANNEL]       Williams, N., \"On the Use of Channel Bindings to\n                   Secure
      Channels\", RFC 5056, November 2007.\n   [CHANNEL-TLS]   Altman, J., Williams,
      N., and L. Zhu, \"Channel\n                   Bindings for TLS\", RFC 5929,
      July 2010.\n   [CHARSETS]      Alvestrand, H., \"IETF Policy on Character Sets
      and\n                   Languages\", BCP 18, RFC 2277, January 1998.\n   [DNS-CONCEPTS]
      \ Mockapetris, P., \"Domain names - concepts and\n                   facilities\",
      STD 13, RFC 1034, November 1987.\n   [DNS-SRV]       Gulbrandsen, A., Vixie,
      P., and L. Esibov, \"A DNS RR\n                   for specifying the location
      of services (DNS SRV)\",\n                   RFC 2782, February 2000.\n   [IPv6-ADDR]
      \    Kawamura, S. and M. Kawashima, \"A Recommendation for\n                   IPv6
      Address Text Representation\", RFC 5952,\n                   August 2010.\n
      \  [KEYWORDS]      Bradner, S., \"Key words for use in RFCs to Indicate\n                   Requirement
      Levels\", BCP 14, RFC 2119, March 1997.\n   [LANGMATCH]     Phillips, A. and
      M. Davis, \"Matching of Language\n                   Tags\", BCP 47, RFC 4647,
      September 2006.\n   [LANGTAGS]      Phillips, A. and M. Davis, \"Tags for Identifying\n
      \                  Languages\", BCP 47, RFC 5646, September 2009.\n   [OCSP]
      \         Myers, M., Ankney, R., Malpani, A., Galperin, S., and\n                   C.
      Adams, \"X.509 Internet Public Key Infrastructure\n                   Online
      Certificate Status Protocol - OCSP\", RFC 2560,\n                   June 1999.\n
      \  [PKIX]          Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,\n                   Housley,
      R., and W. Polk, \"Internet X.509 Public Key\n                   Infrastructure
      Certificate and Certificate Revocation\n                   List (CRL) Profile\",
      RFC 5280, May 2008.\n   [PKIX-ALGO]     Jonsson, J. and B. Kaliski, \"Public-Key
      Cryptography\n                   Standards (PKCS) #1: RSA Cryptography Specifications\n
      \                  Version 2.1\", RFC 3447, February 2003.\n   [PKIX-SRV]      Santesson,
      S., \"Internet X.509 Public Key\n                   Infrastructure Subject Alternative
      Name for\n                   Expression of Service Name\", RFC 4985, August
      2007.\n   [PLAIN]         Zeilenga, K., \"The PLAIN Simple Authentication and\n
      \                  Security Layer (SASL) Mechanism\", RFC 4616,\n                   August
      2006.\n   [RANDOM]        Eastlake, D., Schiller, J., and S. Crocker,\n                   \"Randomness
      Requirements for Security\", BCP 106,\n                   RFC 4086, June 2005.\n
      \  [SASL]          Melnikov, A. and K. Zeilenga, \"Simple Authentication\n                   and
      Security Layer (SASL)\", RFC 4422, June 2006.\n   [SCRAM]         Newman, C.,
      Menon-Sen, A., Melnikov, A., and N.\n                   Williams, \"Salted Challenge
      Response Authentication\n                   Mechanism (SCRAM) SASL and GSS-API
      Mechanisms\",\n                   RFC 5802, July 2010.\n   [STRONGSEC]     Schiller,
      J., \"Strong Security Requirements for\n                   Internet Engineering
      Task Force Standard Protocols\",\n                   BCP 61, RFC 3365, August
      2002.\n   [TCP]           Postel, J., \"Transmission Control Protocol\", STD
      7,\n                   RFC 793, September 1981.\n   [TLS]           Dierks,
      T. and E. Rescorla, \"The Transport Layer\n                   Security (TLS)
      Protocol Version 1.2\", RFC 5246,\n                   August 2008.\n   [TLS-CERTS]
      \    Saint-Andre, P. and J. Hodges, \"Representation and\n                   Verification
      of Domain-Based Application Service\n                   Identity within Internet
      Public Key Infrastructure\n                   Using X.509 (PKIX) Certificates
      in the Context of\n                   Transport Layer Security (TLS)\", RFC
      6125,\n                   March 2011.\n   [TLS-NEG]       Rescorla, E., Ray,
      M., Dispensa, S., and N. Oskov,\n                   \"Transport Layer Security
      (TLS) Renegotiation\n                   Indication Extension\", RFC 5746, February
      2010.\n   [TLS-SSL2]      Turner, S. and T. Polk, \"Prohibiting Secure Sockets\n
      \                  Layer (SSL) Version 2.0\", RFC 6176, March 2011.\n   [UCS2]
      \         International Organization for Standardization,\n                   \"Information
      Technology - Universal Multiple-octet\n                   coded Character Set
      (UCS) - Amendment 2: UCS\n                   Transformation Format 8 (UTF-8)\",
      ISO Standard\n                   10646-1 Addendum 2, October 1996.\n   [UNICODE]
      \      The Unicode Consortium, \"The Unicode Standard,\n                   Version
      6.0\", 2010,\n                   <http://www.unicode.org/versions/Unicode6.0.0/>.\n
      \  [UTF-8]         Yergeau, F., \"UTF-8, a transformation format of ISO\n                   10646\",
      STD 63, RFC 3629, November 2003.\n   [URI]           Berners-Lee, T., Fielding,
      R., and L. Masinter,\n                   \"Uniform Resource Identifier (URI):
      Generic Syntax\",\n                   STD 66, RFC 3986, January 2005.\n   [X509]
      \         International Telecommunications Union, \"Information\n                   technology
      - Open Systems Interconnection - The\n                   Directory: Public-key
      and attribute certificate\n                   frameworks\", ITU-T Recommendation
      X.509, ISO Standard\n                   9594-8, March 2000.\n   [XML]           Maler,
      E., Yergeau, F., Sperberg-McQueen, C., Paoli,\n                   J., and T.
      Bray, \"Extensible Markup Language (XML)\n                   1.0 (Fifth Edition)\",
      World Wide Web Consortium\n                   Recommendation REC-xml-20081126,
      November 2008,\n                   <http://www.w3.org/TR/2008/REC-xml-20081126>.\n
      \  [XML-GUIDE]     Hollenbeck, S., Rose, M., and L. Masinter,\n                   \"Guidelines
      for the Use of Extensible Markup Language\n                   (XML) within IETF
      Protocols\", BCP 70, RFC 3470,\n                   January 2003.\n   [XML-MEDIA]
      \    Murata, M., St. Laurent, S., and D. Kohn, \"XML Media\n                   Types\",
      RFC 3023, January 2001.\n   [XML-NAMES]     Thompson, H., Hollander, D., Layman,
      A., Bray, T.,\n                   and R. Tobin, \"Namespaces in XML 1.0 (Third\n
      \                  Edition)\", World Wide Web Consortium\n                   Recommendation
      REC-xml-names-20091208, December 2009,\n                   <http://www.w3.org/TR/2009/REC-xml-names-20091208>.\n
      \  [XMPP-ADDR]     Saint-Andre, P., \"Extensible Messaging and Presence\n                   Protocol
      (XMPP): Address Format\", RFC 6122,\n                   March 2011.\n   [XMPP-IM]
      \      Saint-Andre, P., \"Extensible Messaging and Presence\n                   Protocol
      (XMPP): Instant Messaging and Presence\",\n                   RFC 6121, March
      2011.\n"
    title: 16.1.  Normative References
  - contents:
    - "16.2.  Informative References\n   [AAA]           Housley, R. and B. Aboba,
      \"Guidance for\n                   Authentication, Authorization, and Accounting
      (AAA)\n                   Key Management\", BCP 132, RFC 4962, July 2007.\n
      \  [ABNF]          Crocker, D. and P. Overell, \"Augmented BNF for Syntax\n
      \                  Specifications: ABNF\", STD 68, RFC 5234,\n                   January
      2008.\n   [ACAP]          Newman, C. and J. Myers, \"ACAP -- Application\n                   Configuration
      Access Protocol\", RFC 2244,\n                   November 1997.\n   [ANONYMOUS]
      \    Zeilenga, K., \"Anonymous Simple Authentication and\n                   Security
      Layer (SASL) Mechanism\", RFC 4505,\n                   June 2006.\n   [ASN.1]
      \        CCITT, \"Recommendation X.208: Specification of\n                   Abstract
      Syntax Notation One (ASN.1)\", 1988.\n   [DIGEST-MD5]    Leach, P. and C. Newman,
      \"Using Digest Authentication\n                   as a SASL Mechanism\", RFC
      2831, May 2000.\n   [DNSSEC]        Arends, R., Austein, R., Larson, M., Massey,
      D., and\n                   S. Rose, \"DNS Security Introduction and\n                   Requirements\",
      RFC 4033, March 2005.\n   [DNS-TXT]       Rosenbaum, R., \"Using the Domain
      Name System To Store\n                   Arbitrary String Attributes\", RFC
      1464, May 1993.\n   [DOS]           Handley, M., Rescorla, E., and IAB, \"Internet
      Denial-\n                   of-Service Considerations\", RFC 4732, December
      2006.\n   [E2E-REQS]      Saint-Andre, P., \"Requirements for End-to-End\n                   Encryption
      in the Extensible Messaging and Presence\n                   Protocol (XMPP)\",
      Work in Progress, March 2010.\n   [EMAIL-ARCH]    Crocker, D., \"Internet Mail
      Architecture\", RFC 5598,\n                   July 2009.\n   [ETHERNET]      \"Information
      technology - Telecommunications and\n                   information exchange
      between systems - Local and\n                   metropolitan area networks -
      Specific requirements -\n                   Part 3: Carrier sense multiple access
      with collision\n                   detection (CSMA/CD) access method and physical
      layer\n                   specifications\", IEEE Standard 802.3, September 1998.\n
      \  [GSS-API]       Linn, J., \"Generic Security Service Application\n                   Program
      Interface Version 2, Update 1\", RFC 2743,\n                   January 2000.\n
      \  [HASHES]        Hoffman, P. and B. Schneier, \"Attacks on\n                   Cryptographic
      Hashes in Internet Protocols\",\n                   RFC 4270, November 2005.\n
      \  [HTTP]          Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,\n                   Masinter,
      L., Leach, P., and T. Berners-Lee,\n                   \"Hypertext Transfer
      Protocol -- HTTP/1.1\", RFC 2616,\n                   June 1999.\n   [IANA-GUIDE]
      \   Narten, T. and H. Alvestrand, \"Guidelines for Writing\n                   an
      IANA Considerations Section in RFCs\", BCP 26,\n                   RFC 5226,
      May 2008.\n   [IANA-PORTS]    Cotton, M., Eggert, L., Touch, J., Westerlund,
      M.,\n                   and S. Cheshire, \"Internet Assigned Numbers Authority\n
      \                  (IANA) Procedures for the Management of the Transport\n                   Protocol
      Port Number and Service Name Registry\", Work\n                   in Progress,
      February 2011.\n   [IMAP]          Crispin, M., \"INTERNET MESSAGE ACCESS PROTOCOL
      -\n                   VERSION 4rev1\", RFC 3501, March 2003.\n   [IMP-REQS]
      \     Day, M., Aggarwal, S., and J. Vincent, \"Instant\n                   Messaging
      / Presence Protocol Requirements\",\n                   RFC 2779, February 2000.\n
      \  [INTEROP]       Masinter, L., \"Formalizing IETF Interoperability\n                   Reporting\",
      Work in Progress, October 2005.\n   [IRC]           Kalt, C., \"Internet Relay
      Chat: Architecture\",\n                   RFC 2810, April 2000.\n   [IRI]           Duerst,
      M. and M. Suignard, \"Internationalized\n                   Resource Identifiers
      (IRIs)\", RFC 3987, January 2005.\n   [LDAP]          Zeilenga, K., \"Lightweight
      Directory Access Protocol\n                   (LDAP): Technical Specification
      Road Map\", RFC 4510,\n                   June 2006.\n   [LINKLOCAL]     Cheshire,
      S., Aboba, B., and E. Guttman, \"Dynamic\n                   Configuration of
      IPv4 Link-Local Addresses\",\n                   RFC 3927, May 2005.\n   [MAILBOXES]
      \    Crocker, D., \"MAILBOX NAMES FOR COMMON SERVICES,\n                   ROLES
      AND FUNCTIONS\", RFC 2142, May 1997.\n   [POP3]          Myers, J. and M. Rose,
      \"Post Office Protocol -\n                   Version 3\", STD 53, RFC 1939,
      May 1996.\n   [PROCESS]       Bradner, S., \"The Internet Standards Process
      --\n                   Revision 3\", BCP 9, RFC 2026, October 1996.\n   [REPORTS]
      \      Dusseault, L. and R. Sparks, \"Guidance on\n                   Interoperation
      and Implementation Reports for\n                   Advancement to Draft Standard\",
      BCP 9, RFC 5657,\n                   September 2009.\n   [REST]          Fielding,
      R., \"Architectural Styles and the Design of\n                   Network-based
      Software Architectures\",  2000.\n   [RFC3920]       Saint-Andre, P., Ed., \"Extensible
      Messaging and\n                   Presence Protocol (XMPP): Core\", RFC 3920,\n
      \                  October 2004.\n   [RFC3921]       Saint-Andre, P., Ed., \"Extensible
      Messaging and\n                   Presence Protocol (XMPP): Instant Messaging
      and\n                   Presence\", RFC 3921, October 2004.\n   [SASLPREP]      Zeilenga,
      K., \"SASLprep: Stringprep Profile for User\n                   Names and Passwords\",
      RFC 4013, February 2005.\n   [SEC-TERMS]     Shirey, R., \"Internet Security
      Glossary, Version 2\",\n                   RFC 4949, August 2007.\n   [SMTP]
      \         Klensin, J., \"Simple Mail Transfer Protocol\",\n                   RFC
      5321, October 2008.\n   [SEC-GUIDE]     Rescorla, E. and B. Korver, \"Guidelines
      for Writing\n                   RFC Text on Security Considerations\", BCP 72,\n
      \                  RFC 3552, July 2003.\n   [TLS-EXT]       Eastlake 3rd, D.,
      \"Transport Layer Security (TLS)\n                   Extensions: Extension Definitions\",
      RFC 6066,\n                   January 2011.\n   [TLS-RESUME]    Salowey, J.,
      Zhou, H., Eronen, P., and H. Tschofenig,\n                   \"Transport Layer
      Security (TLS) Session Resumption\n                   without Server-Side State\",
      RFC 5077, January 2008.\n   [URN-OID]       Mealling, M., \"A URN Namespace
      of Object\n                   Identifiers\", RFC 3061, February 2001.\n   [USINGTLS]
      \     Newman, C., \"Using TLS with IMAP, POP3 and ACAP\",\n                   RFC
      2595, June 1999.\n   [UUID]          Leach, P., Mealling, M., and R. Salz, \"A
      Universally\n                   Unique IDentifier (UUID) URN Namespace\", RFC
      4122,\n                   July 2005.\n   [XEP-0001]      Saint-Andre, P., \"XMPP
      Extension Protocols\", XSF\n                   XEP 0001, March 2010.\n   [XEP-0016]
      \     Millard, P. and P. Saint-Andre, \"Privacy Lists\", XSF\n                   XEP
      0016, February 2007.\n   [XEP-0045]      Saint-Andre, P., \"Multi-User Chat\",
      XSF XEP 0045,\n                   July 2007.\n   [XEP-0060]      Millard, P.,
      Saint-Andre, P., and R. Meijer,\n                   \"Publish-Subscribe\", XSF
      XEP 0060, July 2010.\n   [XEP-0071]      Saint-Andre, P., \"XHTML-IM\", XSF
      XEP 0071,\n                   September 2008.\n   [XEP-0077]      Saint-Andre,
      P., \"In-Band Registration\", XSF\n                   XEP 0077, September 2009.\n
      \  [XEP-0086]      Norris, R. and P. Saint-Andre, \"Error Condition\n                   Mappings\",
      XSF XEP 0086, February 2004.\n   [XEP-0100]      Saint-Andre, P. and D. Smith,
      \"Gateway Interaction\",\n                   XSF XEP 0100, October 2005.\n   [XEP-0114]
      \     Saint-Andre, P., \"Jabber Component Protocol\", XSF\n                   XEP
      0114, March 2005.\n   [XEP-0124]      Paterson, I., Smith, D., and P. Saint-Andre,\n
      \                  \"Bidirectional-streams Over Synchronous HTTP (BOSH)\",\n
      \                  XSF XEP 0124, July 2010.\n   [XEP-0138]      Hildebrand,
      J. and P. Saint-Andre, \"Stream\n                   Compression\", XSF XEP 0138,
      May 2009.\n   [XEP-0156]      Hildebrand, J. and P. Saint-Andre, \"Discovering\n
      \                  Alternative XMPP Connection Methods\", XSF XEP 0156,\n                   June
      2007.\n   [XEP-0160]      Saint-Andre, P., \"Best Practices for Handling Offline\n
      \                  Messages\", XSF XEP 0160, January 2006.\n   [XEP-0174]      Saint-Andre,
      P., \"Link-Local Messaging\", XSF\n                   XEP 0174, November 2008.\n
      \  [XEP-0175]      Saint-Andre, P., \"Best Practices for Use of SASL\n                   ANONYMOUS\",
      XSF XEP 0175, September 2009.\n   [XEP-0178]      Saint-Andre, P. and P. Millard,
      \"Best Practices for\n                   Use of SASL EXTERNAL with Certificates\",
      XSF\n                   XEP 0178, February 2007.\n   [XEP-0191]      Saint-Andre,
      P., \"Simple Communications Blocking\",\n                   XSF XEP 0191, February
      2007.\n   [XEP-0198]      Karneges, J., Hildebrand, J., Saint-Andre, P., Forno,\n
      \                  F., Cridland, D., and M. Wild, \"Stream Management\",\n                   XSF
      XEP 0198, February 2011.\n   [XEP-0199]      Saint-Andre, P., \"XMPP Ping\",
      XSF XEP 0199,\n                   June 2009.\n   [XEP-0205]      Saint-Andre,
      P., \"Best Practices to Discourage Denial\n                   of Service Attacks\",
      XSF XEP 0205, January 2009.\n   [XEP-0206]      Paterson, I. and P. Saint-Andre,
      \"XMPP Over BOSH\",\n                   XSF XEP 0206, July 2010.\n   [XEP-0220]
      \     Miller, J., Saint-Andre, P., and P. Hancke, \"Server\n                   Dialback\",
      XSF XEP 0220, March 2010.\n   [XEP-0225]      Saint-Andre, P., \"Component Connections\",
      XSF\n                   XEP 0225, October 2008.\n   [XEP-0233]      Miller,
      M., Saint-Andre, P., and J. Hildebrand,\n                   \"Domain-Based Service
      Names in XMPP SASL\n                   Negotiation\", XSF XEP 0233, June 2010.\n
      \  [XEP-0288]      Hancke, P. and D. Cridland, \"Bidirectional Server-to-\n
      \                  Server Connections\", XSF XEP 0288, October 2010.\n   [XML-FRAG]
      \     Grosso, P. and D. Veillard, \"XML Fragment\n                   Interchange\",
      World Wide Web Consortium CR CR-xml-\n                   fragment-20010212,
      February 2001,\n                   <http://www.w3.org/TR/2001/CR-xml-fragment-20010212>.\n
      \  [XML-REG]       Mealling, M., \"The IETF XML Registry\", BCP 81,\n                   RFC
      3688, January 2004.\n   [XML-SCHEMA]    Thompson, H., Maloney, M., Mendelsohn,
      N., and D.\n                   Beech, \"XML Schema Part 1: Structures Second\n
      \                  Edition\", World Wide Web Consortium\n                   Recommendation
      REC-xmlschema-1-20041028,\n                   October 2004,\n                   <http://www.w3.org/TR/2004/REC-xmlschema-1-20041028>.\n
      \  [XMPP-URI]      Saint-Andre, P., \"Internationalized Resource\n                   Identifiers
      (IRIs) and Uniform Resource Identifiers\n                   (URIs) for the Extensible
      Messaging and Presence\n                   Protocol (XMPP)\", RFC 5122, February
      2008.\n"
    title: 16.2.  Informative References
  title: 16.  References
- contents:
  - "Appendix A.  XML Schemas\n   The following schemas formally define various namespaces
    used in this\n   document, in conformance with [XML-SCHEMA].  Because validation
    of\n   XML streams and stanzas is optional, these schemas are not normative\n
    \  and are provided for descriptive purposes only.\n"
  - contents:
    - "A.1.  Stream Namespace\n   <?xml version='1.0' encoding='UTF-8'?>\n   <xs:schema\n
      \      xmlns:xs='http://www.w3.org/2001/XMLSchema'\n       targetNamespace='http://etherx.jabber.org/streams'\n
      \      xmlns='http://etherx.jabber.org/streams'\n       elementFormDefault='unqualified'>\n
      \    <xs:import namespace='jabber:client'/>\n     <xs:import namespace='jabber:server'/>\n
      \    <xs:import namespace='urn:ietf:params:xml:ns:xmpp-sasl'/>\n     <xs:import
      namespace='urn:ietf:params:xml:ns:xmpp-streams'/>\n     <xs:import namespace='urn:ietf:params:xml:ns:xmpp-tls'/>\n
      \    <xs:element name='stream'>\n       <xs:complexType>\n         <xs:sequence
      xmlns:client='jabber:client'\n                      xmlns:server='jabber:server'>\n
      \          <xs:element ref='features'\n                       minOccurs='0'\n
      \                      maxOccurs='1'/>\n           <xs:any namespace='urn:ietf:params:xml:ns:xmpp-tls'\n
      \                  minOccurs='0'\n                   maxOccurs='1'/>\n           <xs:any
      namespace='urn:ietf:params:xml:ns:xmpp-sasl'\n                   minOccurs='0'\n
      \                  maxOccurs='1'/>\n           <xs:any namespace='##other'\n
      \                  minOccurs='0'\n                   maxOccurs='unbounded'\n
      \                  processContents='lax'/>\n           <xs:choice minOccurs='0'
      maxOccurs='1'>\n             <xs:choice minOccurs='0' maxOccurs='unbounded'>\n
      \              <xs:element ref='client:message'/>\n               <xs:element
      ref='client:presence'/>\n               <xs:element ref='client:iq'/>\n             </xs:choice>\n
      \            <xs:choice minOccurs='0' maxOccurs='unbounded'>\n               <xs:element
      ref='server:message'/>\n               <xs:element ref='server:presence'/>\n
      \              <xs:element ref='server:iq'/>\n             </xs:choice>\n           </xs:choice>\n
      \          <xs:element ref='error' minOccurs='0' maxOccurs='1'/>\n         </xs:sequence>\n
      \        <xs:attribute name='from' type='xs:string' use='optional'/>\n         <xs:attribute
      name='id' type='xs:string' use='optional'/>\n         <xs:attribute name='to'
      type='xs:string' use='optional'/>\n         <xs:attribute name='version' type='xs:decimal'
      use='optional'/>\n         <xs:attribute ref='xml:lang' use='optional'/>\n         <xs:anyAttribute
      namespace='##other' processContents='lax'/>\n       </xs:complexType>\n     </xs:element>\n
      \    <xs:element name='features'>\n       <xs:complexType>\n         <xs:sequence>\n
      \          <xs:any namespace='##other'\n                   minOccurs='0'\n                   maxOccurs='unbounded'\n
      \                  processContents='lax'/>\n         </xs:sequence>\n       </xs:complexType>\n
      \    </xs:element>\n     <xs:element name='error'>\n       <xs:complexType>\n
      \        <xs:sequence  xmlns:err='urn:ietf:params:xml:ns:xmpp-streams'>\n           <xs:group
      \  ref='err:streamErrorGroup'/>\n           <xs:element ref='err:text'\n                       minOccurs='0'\n
      \                      maxOccurs='1'/>\n           <xs:any     namespace='##other'\n
      \                      minOccurs='0'\n                       maxOccurs='1'\n
      \                      processContents='lax'/>\n         </xs:sequence>\n       </xs:complexType>\n
      \    </xs:element>\n   </xs:schema>\n"
    title: A.1.  Stream Namespace
  - contents:
    - "A.2.  Stream Error Namespace\n   <?xml version='1.0' encoding='UTF-8'?>\n   <xs:schema\n
      \      xmlns:xs='http://www.w3.org/2001/XMLSchema'\n       targetNamespace='urn:ietf:params:xml:ns:xmpp-streams'\n
      \      xmlns='urn:ietf:params:xml:ns:xmpp-streams'\n       elementFormDefault='qualified'>\n
      \    <xs:element name='bad-format' type='empty'/>\n     <xs:element name='bad-namespace-prefix'
      type='empty'/>\n     <xs:element name='conflict' type='empty'/>\n     <xs:element
      name='connection-timeout' type='empty'/>\n     <xs:element name='host-gone'
      type='empty'/>\n     <xs:element name='host-unknown' type='empty'/>\n     <xs:element
      name='improper-addressing' type='empty'/>\n     <xs:element name='internal-server-error'
      type='empty'/>\n     <xs:element name='invalid-from' type='empty'/>\n     <xs:element
      name='invalid-id' type='empty'/>\n     <xs:element name='invalid-namespace'
      type='empty'/>\n     <xs:element name='invalid-xml' type='empty'/>\n     <xs:element
      name='not-authorized' type='empty'/>\n     <xs:element name='not-well-formed'
      type='empty'/>\n     <xs:element name='policy-violation' type='empty'/>\n     <xs:element
      name='remote-connection-failed' type='empty'/>\n     <xs:element name='reset'
      type='empty'/>\n     <xs:element name='resource-constraint' type='empty'/>\n
      \    <xs:element name='restricted-xml' type='empty'/>\n     <xs:element name='see-other-host'
      type='xs:string'/>\n     <xs:element name='system-shutdown' type='empty'/>\n
      \    <xs:element name='undefined-condition' type='empty'/>\n     <xs:element
      name='unsupported-encoding' type='empty'/>\n     <xs:element name='unsupported-stanza-type'
      type='empty'/>\n     <xs:element name='unsupported-version' type='empty'/>\n
      \    <xs:group name='streamErrorGroup'>\n       <xs:choice>\n         <xs:element
      ref='bad-format'/>\n         <xs:element ref='bad-namespace-prefix'/>\n         <xs:element
      ref='conflict'/>\n         <xs:element ref='connection-timeout'/>\n         <xs:element
      ref='host-gone'/>\n         <xs:element ref='host-unknown'/>\n         <xs:element
      ref='improper-addressing'/>\n         <xs:element ref='internal-server-error'/>\n
      \        <xs:element ref='invalid-from'/>\n         <xs:element ref='invalid-id'/>\n
      \        <xs:element ref='invalid-namespace'/>\n         <xs:element ref='invalid-xml'/>\n
      \        <xs:element ref='not-authorized'/>\n         <xs:element ref='not-well-formed'/>\n
      \        <xs:element ref='policy-violation'/>\n         <xs:element ref='remote-connection-failed'/>\n
      \        <xs:element ref='reset'/>\n         <xs:element ref='resource-constraint'/>\n
      \        <xs:element ref='restricted-xml'/>\n         <xs:element ref='see-other-host'/>\n
      \        <xs:element ref='system-shutdown'/>\n         <xs:element ref='undefined-condition'/>\n
      \        <xs:element ref='unsupported-encoding'/>\n         <xs:element ref='unsupported-stanza-type'/>\n
      \        <xs:element ref='unsupported-version'/>\n       </xs:choice>\n     </xs:group>\n
      \    <xs:element name='text'>\n       <xs:complexType>\n         <xs:simpleContent>\n
      \          <xs:extension base='xs:string'>\n             <xs:attribute ref='xml:lang'
      use='optional'/>\n           </xs:extension>\n         </xs:simpleContent>\n
      \      </xs:complexType>\n     </xs:element>\n     <xs:simpleType name='empty'>\n
      \      <xs:restriction base='xs:string'>\n         <xs:enumeration value=''/>\n
      \      </xs:restriction>\n     </xs:simpleType>\n   </xs:schema>\n"
    title: A.2.  Stream Error Namespace
  - contents:
    - "A.3.  STARTTLS Namespace\n   <?xml version='1.0' encoding='UTF-8'?>\n   <xs:schema\n
      \      xmlns:xs='http://www.w3.org/2001/XMLSchema'\n       targetNamespace='urn:ietf:params:xml:ns:xmpp-tls'\n
      \      xmlns='urn:ietf:params:xml:ns:xmpp-tls'\n       elementFormDefault='qualified'>\n
      \    <xs:element name='starttls'>\n       <xs:complexType>\n         <xs:choice
      minOccurs='0' maxOccurs='1'>\n           <xs:element name='required' type='empty'/>\n
      \        </xs:choice>\n       </xs:complexType>\n     </xs:element>\n     <xs:element
      name='proceed' type='empty'/>\n     <xs:element name='failure' type='empty'/>\n
      \    <xs:simpleType name='empty'>\n       <xs:restriction base='xs:string'>\n
      \        <xs:enumeration value=''/>\n       </xs:restriction>\n     </xs:simpleType>\n
      \  </xs:schema>\n"
    title: A.3.  STARTTLS Namespace
  - contents:
    - "A.4.  SASL Namespace\n   <?xml version='1.0' encoding='UTF-8'?>\n   <xs:schema\n
      \      xmlns:xs='http://www.w3.org/2001/XMLSchema'\n       targetNamespace='urn:ietf:params:xml:ns:xmpp-sasl'\n
      \      xmlns='urn:ietf:params:xml:ns:xmpp-sasl'\n       elementFormDefault='qualified'>\n
      \    <xs:element name='mechanisms'>\n       <xs:complexType>\n         <xs:sequence>\n
      \          <xs:element name='mechanism'\n                       minOccurs='1'\n
      \                      maxOccurs='unbounded'\n                       type='xs:NMTOKEN'/>\n
      \          <xs:any namespace='##other'\n                   minOccurs='0'\n                   maxOccurs='unbounded'\n
      \                  processContents='lax'/>\n         </xs:sequence>\n       </xs:complexType>\n
      \    </xs:element>\n     <xs:element name='abort' type='empty'/>\n     <xs:element
      name='auth'>\n       <xs:complexType>\n         <xs:simpleContent>\n           <xs:extension
      base='xs:string'>\n             <xs:attribute name='mechanism'\n                           type='xs:NMTOKEN'\n
      \                          use='required'/>\n           </xs:extension>\n         </xs:simpleContent>\n
      \      </xs:complexType>\n     </xs:element>\n     <xs:element name='challenge'
      type='xs:string'/>\n     <xs:element name='response' type='xs:string'/>\n     <xs:element
      name='success' type='xs:string'/>\n     <xs:element name='failure'>\n       <xs:complexType>\n
      \        <xs:sequence>\n           <xs:choice minOccurs='0'>\n             <xs:element
      name='aborted' type='empty'/>\n             <xs:element name='account-disabled'
      type='empty'/>\n             <xs:element name='credentials-expired' type='empty'/>\n
      \            <xs:element name='encryption-required' type='empty'/>\n             <xs:element
      name='incorrect-encoding' type='empty'/>\n             <xs:element name='invalid-authzid'
      type='empty'/>\n             <xs:element name='invalid-mechanism' type='empty'/>\n
      \            <xs:element name='malformed-request' type='empty'/>\n             <xs:element
      name='mechanism-too-weak' type='empty'/>\n             <xs:element name='not-authorized'
      type='empty'/>\n             <xs:element name='temporary-auth-failure' type='empty'/>\n
      \          </xs:choice>\n           <xs:element ref='text' minOccurs='0' maxOccurs='1'/>\n
      \        </xs:sequence>\n       </xs:complexType>\n     </xs:element>\n     <xs:element
      name='text'>\n       <xs:complexType>\n         <xs:simpleContent>\n           <xs:extension
      base='xs:string'>\n             <xs:attribute ref='xml:lang' use='optional'/>\n
      \          </xs:extension>\n         </xs:simpleContent>\n       </xs:complexType>\n
      \    </xs:element>\n     <xs:simpleType name='empty'>\n       <xs:restriction
      base='xs:string'>\n         <xs:enumeration value=''/>\n       </xs:restriction>\n
      \    </xs:simpleType>\n   </xs:schema>\n"
    title: A.4.  SASL Namespace
  - contents:
    - "A.5.  Client Namespace\n   <?xml version='1.0' encoding='UTF-8'?>\n   <xs:schema\n
      \      xmlns:xs='http://www.w3.org/2001/XMLSchema'\n       targetNamespace='jabber:client'\n
      \      xmlns='jabber:client'\n       elementFormDefault='qualified'>\n     <xs:import\n
      \        namespace='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n     <xs:element
      name='message'>\n        <xs:complexType>\n           <xs:sequence>\n             <xs:choice
      minOccurs='0' maxOccurs='unbounded'>\n               <xs:element ref='subject'/>\n
      \              <xs:element ref='body'/>\n               <xs:element ref='thread'/>\n
      \            </xs:choice>\n             <xs:any     namespace='##other'\n                         minOccurs='0'\n
      \                        maxOccurs='unbounded'\n                         processContents='lax'/>\n
      \            <xs:element ref='error'\n                         minOccurs='0'/>\n
      \          </xs:sequence>\n           <xs:attribute name='from'\n                         type='xs:string'\n
      \                        use='optional'/>\n           <xs:attribute name='id'\n
      \                        type='xs:NMTOKEN'\n                         use='optional'/>\n
      \          <xs:attribute name='to'\n                         type='xs:string'\n
      \                        use='optional'/>\n           <xs:attribute name='type'\n
      \                        use='optional'\n                         default='normal'>\n
      \            <xs:simpleType>\n               <xs:restriction base='xs:NMTOKEN'>\n
      \                <xs:enumeration value='chat'/>\n                 <xs:enumeration
      value='error'/>\n                 <xs:enumeration value='groupchat'/>\n                 <xs:enumeration
      value='headline'/>\n                 <xs:enumeration value='normal'/>\n               </xs:restriction>\n
      \            </xs:simpleType>\n           </xs:attribute>\n           <xs:attribute
      ref='xml:lang' use='optional'/>\n        </xs:complexType>\n     </xs:element>\n
      \    <xs:element name='body'>\n       <xs:complexType>\n         <xs:simpleContent>\n
      \          <xs:extension base='xs:string'>\n             <xs:attribute ref='xml:lang'
      use='optional'/>\n           </xs:extension>\n         </xs:simpleContent>\n
      \      </xs:complexType>\n     </xs:element>\n     <xs:element name='subject'>\n
      \      <xs:complexType>\n         <xs:simpleContent>\n           <xs:extension
      base='xs:string'>\n             <xs:attribute ref='xml:lang' use='optional'/>\n
      \          </xs:extension>\n         </xs:simpleContent>\n       </xs:complexType>\n
      \    </xs:element>\n     <xs:element name='thread'>\n       <xs:complexType>\n
      \        <xs:simpleContent>\n           <xs:extension base='xs:NMTOKEN'>\n             <xs:attribute
      name='parent'\n                           type='xs:NMTOKEN'\n                           use='optional'/>\n
      \          </xs:extension>\n         </xs:simpleContent>\n       </xs:complexType>\n
      \    </xs:element>\n     <xs:element name='presence'>\n       <xs:complexType>\n
      \        <xs:sequence>\n           <xs:choice minOccurs='0' maxOccurs='unbounded'>\n
      \            <xs:element ref='show'/>\n             <xs:element ref='status'/>\n
      \            <xs:element ref='priority'/>\n           </xs:choice>\n           <xs:any
      \    namespace='##other'\n                       minOccurs='0'\n                       maxOccurs='unbounded'\n
      \                      processContents='lax'/>\n           <xs:element ref='error'\n
      \                      minOccurs='0'/>\n         </xs:sequence>\n         <xs:attribute
      name='from'\n                       type='xs:string'\n                       use='optional'/>\n
      \        <xs:attribute name='id'\n                       type='xs:NMTOKEN'\n
      \                      use='optional'/>\n         <xs:attribute name='to'\n
      \                      type='xs:string'\n                       use='optional'/>\n
      \        <xs:attribute name='type' use='optional'>\n           <xs:simpleType>\n
      \            <xs:restriction base='xs:NMTOKEN'>\n               <xs:enumeration
      value='error'/>\n               <xs:enumeration value='probe'/>\n               <xs:enumeration
      value='subscribe'/>\n               <xs:enumeration value='subscribed'/>\n               <xs:enumeration
      value='unavailable'/>\n               <xs:enumeration value='unsubscribe'/>\n
      \              <xs:enumeration value='unsubscribed'/>\n             </xs:restriction>\n
      \          </xs:simpleType>\n         </xs:attribute>\n         <xs:attribute
      ref='xml:lang' use='optional'/>\n       </xs:complexType>\n     </xs:element>\n
      \    <xs:element name='show'>\n       <xs:simpleType>\n         <xs:restriction
      base='xs:NMTOKEN'>\n           <xs:enumeration value='away'/>\n           <xs:enumeration
      value='chat'/>\n           <xs:enumeration value='dnd'/>\n           <xs:enumeration
      value='xa'/>\n         </xs:restriction>\n       </xs:simpleType>\n     </xs:element>\n
      \    <xs:element name='status'>\n       <xs:complexType>\n         <xs:simpleContent>\n
      \          <xs:extension base='string1024'>\n             <xs:attribute ref='xml:lang'
      use='optional'/>\n           </xs:extension>\n         </xs:simpleContent>\n
      \      </xs:complexType>\n     </xs:element>\n     <xs:simpleType name='string1024'>\n
      \      <xs:restriction base='xs:string'>\n         <xs:minLength value='1'/>\n
      \        <xs:maxLength value='1024'/>\n       </xs:restriction>\n     </xs:simpleType>\n
      \    <xs:element name='priority' type='xs:byte'/>\n     <xs:element name='iq'>\n
      \      <xs:complexType>\n         <xs:sequence>\n           <xs:any     namespace='##other'\n
      \                      minOccurs='0'\n                       maxOccurs='1'\n
      \                      processContents='lax'/>\n           <xs:element ref='error'\n
      \                      minOccurs='0'/>\n         </xs:sequence>\n         <xs:attribute
      name='from'\n                       type='xs:string'\n                       use='optional'/>\n
      \        <xs:attribute name='id'\n                       type='xs:NMTOKEN'\n
      \                      use='required'/>\n         <xs:attribute name='to'\n
      \                      type='xs:string'\n                       use='optional'/>\n
      \        <xs:attribute name='type' use='required'>\n           <xs:simpleType>\n
      \            <xs:restriction base='xs:NMTOKEN'>\n               <xs:enumeration
      value='error'/>\n               <xs:enumeration value='get'/>\n               <xs:enumeration
      value='result'/>\n               <xs:enumeration value='set'/>\n             </xs:restriction>\n
      \          </xs:simpleType>\n         </xs:attribute>\n         <xs:attribute
      ref='xml:lang' use='optional'/>\n       </xs:complexType>\n     </xs:element>\n
      \    <xs:element name='error'>\n       <xs:complexType>\n         <xs:sequence
      xmlns:err='urn:ietf:params:xml:ns:xmpp-stanzas'>\n           <xs:group ref='err:stanzaErrorGroup'/>\n
      \          <xs:element ref='err:text'\n                       minOccurs='0'/>\n
      \        </xs:sequence>\n         <xs:attribute name='by'\n                       type='xs:string'\n
      \                      use='optional'/>\n         <xs:attribute name='type'
      use='required'>\n           <xs:simpleType>\n             <xs:restriction base='xs:NMTOKEN'>\n
      \              <xs:enumeration value='auth'/>\n               <xs:enumeration
      value='cancel'/>\n               <xs:enumeration value='continue'/>\n               <xs:enumeration
      value='modify'/>\n               <xs:enumeration value='wait'/>\n             </xs:restriction>\n
      \          </xs:simpleType>\n         </xs:attribute>\n       </xs:complexType>\n
      \    </xs:element>\n   </xs:schema>\n"
    title: A.5.  Client Namespace
  - contents:
    - "A.6.  Server Namespace\n   <?xml version='1.0' encoding='UTF-8'?>\n   <xs:schema\n
      \      xmlns:xs='http://www.w3.org/2001/XMLSchema'\n       targetNamespace='jabber:server'\n
      \      xmlns='jabber:server'\n       elementFormDefault='qualified'>\n     <xs:import\n
      \        namespace='urn:ietf:params:xml:ns:xmpp-stanzas'/>\n     <xs:element
      name='message'>\n        <xs:complexType>\n           <xs:sequence>\n             <xs:choice
      minOccurs='0' maxOccurs='unbounded'>\n               <xs:element ref='subject'/>\n
      \              <xs:element ref='body'/>\n               <xs:element ref='thread'/>\n
      \            </xs:choice>\n             <xs:any namespace='##other'\n                     minOccurs='0'\n
      \                    maxOccurs='unbounded'\n                     processContents='lax'/>\n
      \            <xs:element ref='error'\n                         minOccurs='0'/>\n
      \          </xs:sequence>\n           <xs:attribute name='from'\n                         type='xs:string'\n
      \                        use='required'/>\n           <xs:attribute name='id'\n
      \                        type='xs:NMTOKEN'\n                         use='optional'/>\n
      \          <xs:attribute name='to'\n                         type='xs:string'\n
      \                        use='required'/>\n           <xs:attribute name='type'\n
      \                        use='optional'\n                         default='normal'>\n
      \            <xs:simpleType>\n               <xs:restriction base='xs:NMTOKEN'>\n
      \                <xs:enumeration value='chat'/>\n                 <xs:enumeration
      value='error'/>\n                 <xs:enumeration value='groupchat'/>\n                 <xs:enumeration
      value='headline'/>\n                 <xs:enumeration value='normal'/>\n               </xs:restriction>\n
      \            </xs:simpleType>\n           </xs:attribute>\n           <xs:attribute
      ref='xml:lang' use='optional'/>\n        </xs:complexType>\n     </xs:element>\n
      \    <xs:element name='body'>\n       <xs:complexType>\n         <xs:simpleContent>\n
      \          <xs:extension base='xs:string'>\n             <xs:attribute ref='xml:lang'
      use='optional'/>\n           </xs:extension>\n         </xs:simpleContent>\n
      \      </xs:complexType>\n     </xs:element>\n     <xs:element name='subject'>\n
      \      <xs:complexType>\n         <xs:simpleContent>\n           <xs:extension
      base='xs:string'>\n             <xs:attribute ref='xml:lang' use='optional'/>\n
      \          </xs:extension>\n         </xs:simpleContent>\n       </xs:complexType>\n
      \    </xs:element>\n     <xs:element name='thread'>\n       <xs:complexType>\n
      \        <xs:simpleContent>\n           <xs:extension base='xs:NMTOKEN'>\n             <xs:attribute
      name='parent'\n                           type='xs:NMTOKEN'\n                           use='optional'/>\n
      \          </xs:extension>\n         </xs:simpleContent>\n       </xs:complexType>\n
      \    </xs:element>\n     <xs:element name='subject'>\n       <xs:complexType>\n
      \        <xs:simpleContent>\n           <xs:extension base='xs:NMTOKEN'>\n             <xs:attribute
      name='parent'\n                           type='xs:NMTOKEN'\n                           use='optional'/>\n
      \          </xs:extension>\n         </xs:simpleContent>\n       </xs:complexType>\n
      \    </xs:element>\n     <xs:element name='presence'>\n       <xs:complexType>\n
      \        <xs:sequence>\n           <xs:choice minOccurs='0' maxOccurs='unbounded'>\n
      \            <xs:element ref='show'/>\n             <xs:element ref='status'/>\n
      \            <xs:element ref='priority'/>\n           </xs:choice>\n           <xs:any
      \    namespace='##other'\n                       minOccurs='0'\n                       maxOccurs='unbounded'\n
      \                      processContents='lax'/>\n           <xs:element ref='error'\n
      \                      minOccurs='0'/>\n         </xs:sequence>\n         <xs:attribute
      name='from'\n                       type='xs:string'\n                       use='required'/>\n
      \        <xs:attribute name='id'\n                       type='xs:NMTOKEN'\n
      \                      use='optional'/>\n         <xs:attribute name='to'\n
      \                      type='xs:string'\n                       use='required'/>\n
      \        <xs:attribute name='type' use='optional'>\n           <xs:simpleType>\n
      \            <xs:restriction base='xs:NMTOKEN'>\n               <xs:enumeration
      value='error'/>\n               <xs:enumeration value='probe'/>\n               <xs:enumeration
      value='subscribe'/>\n               <xs:enumeration value='subscribed'/>\n               <xs:enumeration
      value='unavailable'/>\n               <xs:enumeration value='unsubscribe'/>\n
      \              <xs:enumeration value='unsubscribed'/>\n             </xs:restriction>\n
      \          </xs:simpleType>\n         </xs:attribute>\n         <xs:attribute
      ref='xml:lang' use='optional'/>\n       </xs:complexType>\n     </xs:element>\n
      \    <xs:element name='show'>\n       <xs:simpleType>\n         <xs:restriction
      base='xs:NMTOKEN'>\n           <xs:enumeration value='away'/>\n           <xs:enumeration
      value='chat'/>\n           <xs:enumeration value='dnd'/>\n           <xs:enumeration
      value='xa'/>\n         </xs:restriction>\n       </xs:simpleType>\n     </xs:element>\n
      \    <xs:element name='status'>\n       <xs:complexType>\n         <xs:simpleContent>\n
      \          <xs:extension base='string1024'>\n             <xs:attribute ref='xml:lang'
      use='optional'/>\n           </xs:extension>\n         </xs:simpleContent>\n
      \      </xs:complexType>\n     </xs:element>\n     <xs:simpleType name='string1024'>\n
      \      <xs:restriction base='xs:string'>\n         <xs:minLength value='1'/>\n
      \        <xs:maxLength value='1024'/>\n       </xs:restriction>\n     </xs:simpleType>\n
      \    <xs:element name='priority' type='xs:byte' default='0'/>\n     <xs:element
      name='iq'>\n       <xs:complexType>\n         <xs:sequence>\n           <xs:any
      namespace='##other'\n                   minOccurs='0'\n                   maxOccurs='1'\n
      \                  processContents='lax'/>\n           <xs:element ref='error'\n
      \                      minOccurs='0'/>\n         </xs:sequence>\n         <xs:attribute
      name='from'\n                       type='xs:string'\n                       use='required'/>\n
      \        <xs:attribute name='id'\n                       type='xs:NMTOKEN'\n
      \                      use='required'/>\n         <xs:attribute name='to'\n
      \                      type='xs:string'\n                       use='required'/>\n
      \        <xs:attribute name='type' use='required'>\n           <xs:simpleType>\n
      \            <xs:restriction base='xs:NMTOKEN'>\n               <xs:enumeration
      value='error'/>\n               <xs:enumeration value='get'/>\n               <xs:enumeration
      value='result'/>\n               <xs:enumeration value='set'/>\n             </xs:restriction>\n
      \          </xs:simpleType>\n         </xs:attribute>\n         <xs:attribute
      ref='xml:lang' use='optional'/>\n       </xs:complexType>\n     </xs:element>\n
      \    <xs:element name='error'>\n       <xs:complexType>\n         <xs:sequence
      xmlns:err='urn:ietf:params:xml:ns:xmpp-stanzas'>\n           <xs:group ref='err:stanzaErrorGroup'/>\n
      \          <xs:element ref='err:text'\n                       minOccurs='0'/>\n
      \        </xs:sequence>\n         <xs:attribute name='by'\n                       type='xs:string'\n
      \                      use='optional'/>\n         <xs:attribute name='type'
      use='required'>\n           <xs:simpleType>\n             <xs:restriction base='xs:NMTOKEN'>\n
      \              <xs:enumeration value='auth'/>\n               <xs:enumeration
      value='cancel'/>\n               <xs:enumeration value='continue'/>\n               <xs:enumeration
      value='modify'/>\n               <xs:enumeration value='wait'/>\n             </xs:restriction>\n
      \          </xs:simpleType>\n         </xs:attribute>\n       </xs:complexType>\n
      \    </xs:element>\n   </xs:schema>\n"
    title: A.6.  Server Namespace
  - contents:
    - "A.7.  Resource Binding Namespace\n   <?xml version='1.0' encoding='UTF-8'?>\n
      \  <xs:schema\n       xmlns:xs='http://www.w3.org/2001/XMLSchema'\n       targetNamespace='urn:ietf:params:xml:ns:xmpp-bind'\n
      \      xmlns='urn:ietf:params:xml:ns:xmpp-bind'\n       elementFormDefault='qualified'>\n
      \    <xs:element name='bind'>\n       <xs:complexType>\n         <xs:choice>\n
      \          <xs:element name='resource' type='resourceType'/>\n           <xs:element
      name='jid' type='fullJIDType'/>\n         </xs:choice>\n       </xs:complexType>\n
      \    </xs:element>\n     <xs:simpleType name='fullJIDType'>\n       <xs:restriction
      base='xs:string'>\n         <xs:minLength value='8'/>\n         <xs:maxLength
      value='3071'/>\n       </xs:restriction>\n     </xs:simpleType>\n     <xs:simpleType
      name='resourceType'>\n       <xs:restriction base='xs:string'>\n         <xs:minLength
      value='1'/>\n         <xs:maxLength value='1023'/>\n       </xs:restriction>\n
      \    </xs:simpleType>\n   </xs:schema>\n"
    title: A.7.  Resource Binding Namespace
  - contents:
    - "A.8.  Stanza Error Namespace\n   <?xml version='1.0' encoding='UTF-8'?>\n   <xs:schema\n
      \      xmlns:xs='http://www.w3.org/2001/XMLSchema'\n       targetNamespace='urn:ietf:params:xml:ns:xmpp-stanzas'\n
      \      xmlns='urn:ietf:params:xml:ns:xmpp-stanzas'\n       elementFormDefault='qualified'>\n
      \    <xs:element name='bad-request' type='empty'/>\n     <xs:element name='conflict'
      type='empty'/>\n     <xs:element name='feature-not-implemented' type='empty'/>\n
      \    <xs:element name='forbidden' type='empty'/>\n     <xs:element name='gone'
      type='xs:string'/>\n     <xs:element name='internal-server-error' type='empty'/>\n
      \    <xs:element name='item-not-found' type='empty'/>\n     <xs:element name='jid-malformed'
      type='empty'/>\n     <xs:element name='not-acceptable' type='empty'/>\n     <xs:element
      name='not-allowed' type='empty'/>\n     <xs:element name='not-authorized' type='empty'/>\n
      \    <xs:element name='policy-violation' type='empty'/>\n     <xs:element name='recipient-unavailable'
      type='empty'/>\n     <xs:element name='redirect' type='xs:string'/>\n     <xs:element
      name='registration-required' type='empty'/>\n     <xs:element name='remote-server-not-found'
      type='empty'/>\n     <xs:element name='remote-server-timeout' type='empty'/>\n
      \    <xs:element name='resource-constraint' type='empty'/>\n     <xs:element
      name='service-unavailable' type='empty'/>\n     <xs:element name='subscription-required'
      type='empty'/>\n     <xs:element name='undefined-condition' type='empty'/>\n
      \    <xs:element name='unexpected-request' type='empty'/>\n     <xs:group name='stanzaErrorGroup'>\n
      \      <xs:choice>\n         <xs:element ref='bad-request'/>\n         <xs:element
      ref='conflict'/>\n         <xs:element ref='feature-not-implemented'/>\n         <xs:element
      ref='forbidden'/>\n         <xs:element ref='gone'/>\n         <xs:element ref='internal-server-error'/>\n
      \        <xs:element ref='item-not-found'/>\n         <xs:element ref='jid-malformed'/>\n
      \        <xs:element ref='not-acceptable'/>\n         <xs:element ref='not-authorized'/>\n
      \        <xs:element ref='not-allowed'/>\n         <xs:element ref='policy-violation'/>\n
      \        <xs:element ref='recipient-unavailable'/>\n         <xs:element ref='redirect'/>\n
      \        <xs:element ref='registration-required'/>\n         <xs:element ref='remote-server-not-found'/>\n
      \        <xs:element ref='remote-server-timeout'/>\n         <xs:element ref='resource-constraint'/>\n
      \        <xs:element ref='service-unavailable'/>\n         <xs:element ref='subscription-required'/>\n
      \        <xs:element ref='undefined-condition'/>\n         <xs:element ref='unexpected-request'/>\n
      \      </xs:choice>\n     </xs:group>\n     <xs:element name='text'>\n       <xs:complexType>\n
      \        <xs:simpleContent>\n           <xs:extension base='xs:string'>\n             <xs:attribute
      ref='xml:lang' use='optional'/>\n           </xs:extension>\n         </xs:simpleContent>\n
      \      </xs:complexType>\n     </xs:element>\n     <xs:simpleType name='empty'>\n
      \      <xs:restriction base='xs:string'>\n         <xs:enumeration value=''/>\n
      \      </xs:restriction>\n     </xs:simpleType>\n   </xs:schema>\n"
    title: A.8.  Stanza Error Namespace
  title: Appendix A.  XML Schemas
- contents:
  - "Appendix B.  Contact Addresses\n   Consistent with [MAILBOXES], organization
    that offer XMPP services\n   are encouraged to provide an Internet mailbox of
    \"XMPP\" for inquiries\n   related to that service, where the host portion of
    the resulting\n   mailto URI is the organization's domain, not the domain of the
    XMPP\n   service itself (e.g., the XMPP service might be offered at\n   im.example.com
    but the Internet mailbox would be <xmpp@example.com>).\n"
  title: Appendix B.  Contact Addresses
- contents:
  - "Appendix C.  Account Provisioning\n   Account provisioning is out of scope for
    this specification.\n   Possible methods for account provisioning include account
    creation by\n   a server administrator and in-band account registration using
    the\n   'jabber:iq:register' namespace as documented in [XEP-0077].  An XMPP\n
    \  server implementation or administrative function MUST ensure that any\n   JID
    assigned during account provisioning (including localpart,\n   domainpart, resourcepart,
    and separator characters) conforms to the\n   canonical format for XMPP addresses
    defined in [XMPP-ADDR].\n"
  title: Appendix C.  Account Provisioning
- contents:
  - "Appendix D.  Differences from RFC 3920\n   Based on consensus derived from implementation
    and deployment\n   experience as well as formal interoperability testing, the
    following\n   substantive modifications were made from RFC 3920 (in addition to\n
    \  numerous changes of an editorial nature).\n   o  Moved specification of the
    XMPP address format to a separate\n      document.\n   o  Recommended or mandated
    use of the 'from' and 'to' attributes on\n      stream headers.\n   o  More fully
    specified the stream closing handshake.\n   o  Specified the recommended stream
    reconnection algorithm.\n   o  Changed the name of the <xml-not-well-formed/>
    stream error\n      condition to <not-well-formed/> for compliance with the XML\n
    \     specification.\n   o  Removed the unnecessary and unused <invalid-id/> stream
    error (see\n      RFC 3920 for historical documentation).\n   o  Specified return
    of the <restricted-xml/> stream error in response\n      to receipt of prohibited
    XML features.\n   o  More completely specified the format and handling of the
    <see-\n      other-host/> stream error, including consistency with RFC 3986 and\n
    \     RFC 5952 with regard to IPv6 addresses (e.g., enclosing the IPv6\n      address
    in square brackets '[' and ']').\n   o  Specified that the SASL SCRAM mechanism
    is a mandatory-to-\n      implement technology for client-to-server streams.\n
    \  o  Specified that TLS plus the SASL PLAIN mechanism is a mandatory-\n      to-implement
    technology for client-to-server streams.\n   o  Specified that support for the
    SASL EXTERNAL mechanism is required\n      for servers but only recommended for
    clients (since end-user X.509\n      certificates are difficult to obtain and
    not yet widely deployed).\n   o  Removed the hard two-connection rule for server-to-server
    streams.\n   o  More clearly specified the certificate profile for both public
    key\n      certificates and issuer certificates.\n   o  Added the <reset/> stream
    error (Section 4.9.3.16) condition to\n      handle expired/revoked certificates
    or the addition of security-\n      critical features to an existing stream.\n
    \  o  Added the <account-disabled/>, <credentials-expired/>,\n      <encryption-required/>,
    and <malformed-request/> SASL error\n      conditions to handle error flows mistakenly
    left out of RFC 3920\n      or discussed in RFC 4422 but not in RFC 2222.\n   o
    \ Removed the unused <payment-required/> stanza error.\n   o  Removed the unnecessary
    requirement for escaping of characters\n      that map to certain predefined entities,
    since they do not need to\n      be escaped in XML.\n   o  Clarified the process
    of DNS SRV lookups and fallbacks.\n   o  Clarified the handling of SASL security
    layers.\n   o  Clarified that a SASL simple user name is the localpart, not the\n
    \     bare JID.\n   o  Clarified the stream negotiation process and associated
    flow\n      chart.\n   o  Clarified the handling of stream features.\n   o  Added
    a 'by' attribute to the <error/> element for stanza errors\n      so that the
    entity that has detected the error can include its JID\n      for diagnostic or
    tracking purposes.\n   o  Clarified the handling of data that violates the well-formedness\n
    \     definitions for XML 1.0 and XML namespaces.\n   o  Specified the security
    considerations in more detail, especially\n      with regard to presence leaks
    and denial-of-service attacks.\n   o  Moved documentation of the Server Dialback
    protocol from this\n      specification to a separate specification maintained
    by the XMPP\n      Standards Foundation.\n"
  title: Appendix D.  Differences from RFC 3920
- contents:
  - "Appendix E.  Acknowledgements\n   This document is an update to, and derived
    from, RFC 3920.  This\n   document would have been impossible without the work
    of the\n   contributors and commenters acknowledged there.\n   Hundreds of people
    have provided implementation feedback, bug\n   reports, requests for clarification,
    and suggestions for improvement\n   since publication of RFC 3920.  Although the
    document editor has\n   endeavored to address all such feedback, he is solely
    responsible for\n   any remaining errors and ambiguities.\n   Special thanks are
    due to Kevin Smith, Matthew Wild, Dave Cridland,\n   Philipp Hancke, Waqas Hussain,
    Florian Zeitz, Ben Campbell, Jehan\n   Pages, Paul Aurich, Justin Karneges, Kurt
    Zeilenga, Simon Josefsson,\n   Ralph Meijer, Curtis King, and others for their
    comments during\n   Working Group Last Call.\n   Thanks also to Yaron Sheffer
    and Elwyn Davies for their reviews on\n   behalf of the Security Directorate and
    the General Area Review Team,\n   respectively.\n   The Working Group chairs were
    Ben Campbell and Joe Hildebrand.  The\n   responsible Area Director was Gonzalo
    Camarillo.\n"
  title: Appendix E.  Acknowledgements
- contents:
  - "Author's Address\n   Peter Saint-Andre\n   Cisco\n   1899 Wyknoop Street, Suite
    600\n   Denver, CO  80202\n   USA\n   Phone: +1-303-308-3282\n   EMail: psaintan@cisco.com\n"
  title: Author's Address
