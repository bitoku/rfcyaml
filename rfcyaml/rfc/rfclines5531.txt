Abstract This document describes the Open Network Computing (ONC) Remote Procedure Call (RPC) version 2 protocol as it is currently deployed and accepted.
This document obsoletes RFC 1831.
This document specifies version 2 of the message protocol used in ONC Remote Procedure Call (RPC).
The message protocol is specified with the eXternal Data Representation (XDR) language [RFC4506].
This document assumes that the reader is familiar with XDR.
It does not attempt to justify remote procedure call systems or describe their use.
The paper by Birrell and Nelson [XRPC] is recommended as an excellent background for the remote procedure call concept.
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC2119].
This document obsoletes [RFC1831] as the authoritative document describing RPC, without introducing any over the wire protocol changes.
The main changes from RFC 1831 are:  Addition of an Appendix that describes how an implementor can request new RPC program numbers, authentication flavor numbers, and authentication status numbers from IANA, rather than from Sun Microsystems  Addition of an "IANA Considerations" section that describes past number assignment policy and how IANA is intended to assign them in the future  Clarification of the RPC Language Specification to match current usage  Enhancement of the "Security Considerations" section to reflect experience with strong security flavors  Specification of new authentication errors that are in common use in modern RPC implementations  Updates for the latest IETF intellectual property statements 3.
This document discusses clients, calls, servers, replies, services, programs, procedures, and versions.
Each remote procedure call has two sides: an active client side that makes the call to a server side, which sends back a reply.
A network service is a collection of one or more remote programs.
A remote program implements one or more remote procedures; the procedures, their parameters, and results are documented in the specific program's protocol specification.
A server may support more than one version of a remote program in order to be compatible with changing protocols.
For example, a network file service may be composed of two programs.
One program may deal with high level applications such as file system access control and locking.
The other may deal with low level file input and output and have procedures like "read" and "write".
A client of the network file service would call the procedures associated with the two programs of the service on behalf of the client.
The terms "client" and "server" only apply to a particular transaction; a particular hardware entity (host) or software entity (process or program) could operate in both roles at different times.
For example, a program that supplies remote execution service could also be a client of a network file service.
The ONC RPC protocol is based on the remote procedure call model, which is similar to the local procedure call model.
In the local case, the caller places arguments to a procedure in some well  specified location (such as a register window).
It then transfers control to the procedure, and eventually regains control.
At that point, the results of the procedure are extracted from the well  specified location, and the caller continues execution.
The remote procedure call model is similar.
One thread of control logically winds through two processes: the caller's process and a server's process.
The caller first sends a call message to the server process and waits (blocks) for a reply message.
The call message includes the procedure's parameters, and the reply message includes the procedure's results.
Once the reply message is received, the results of the procedure are extracted, and the caller's execution is resumed.
On the server side, a process is dormant awaiting the arrival of a call message.
When one arrives, the server process extracts the procedure's parameters, computes the results, sends a reply message, and then awaits the next call message.
In this model, only one of the two processes is active at any given time.
However, this model is only given as an example.
The ONC RPC protocol makes no restrictions on the concurrency model implemented, and others are possible.
For example, an implementation may choose to have RPC calls be asynchronous so that the client may do useful work while waiting for the reply from the server.
Another possibility is to have the server create a separate task to process an incoming call so that the original server can be free to receive other requests.
There are a few important ways in which remote procedure calls differ from local procedure calls.
failures of the remote server or network must be handled when using remote procedure calls.
Global variables and side effects: since the server does not have access to the client's address space, hidden arguments cannot be passed as global variables or returned as side effects.
remote procedures usually operate at one or more orders of magnitude slower than local procedure calls.
Authentication: since remote procedure calls can be transported over unsecured networks, authentication may be necessary.
Authentication prevents one entity from masquerading as some other entity.
The conclusion is that even though there are tools to automatically generate client and server libraries for a given service, protocols must still be designed carefully.
The RPC protocol can be implemented on several different transport protocols.
The scope of the definition of the RPC protocol excludes how a message is passed from one process to another, and includes only the specification and interpretation of messages.
However, the application may wish to obtain information about (and perhaps control over) the transport layer through an interface not specified in this document.
For example, the transport protocol may impose a restriction on the maximum size of RPC messages, or it may be stream oriented like TCP [RFC0793] with no size limit.
The client and server must agree on their transport protocol choices.
It is important to point out that RPC does not try to implement any kind of reliability and that the application may need to be aware of the type of transport protocol underneath RPC.
If it knows it is running on top of a reliable transport such as TCP, then most of the work is already done for it.
On the other hand, if it is running on top of an unreliable transport such as UDP [RFC0768], it must implement its own time out, retransmission, and duplicate detection policies as the RPC protocol does not provide these services.
Because of transport independence, the RPC protocol does not attach specific semantics to the remote procedures or their execution requirements.
Semantics can be inferred from (but should be explicitly specified by) the underlying transport protocol.
For example, consider RPC running on top of an unreliable transport such as UDP.
If an application retransmits RPC call messages after time  outs, and does not receive a reply, it cannot infer anything about the number of times the procedure was executed.
If it does receive a reply, then it can infer that the procedure was executed at least once.
A server may wish to remember previously granted requests from a client and not regrant them, in order to insure some degree of execute at most once semantics.
A server can do this by taking advantage of the transaction ID that is packaged with every RPC message.
The main use of this transaction ID is by the client RPC entity in matching replies to calls.
However, a client application may choose to reuse its previous transaction ID when retransmitting a call.
The server may choose to remember this ID after executing a call and not execute calls with the same ID, in order to achieve some degree of execute at most once semantics.
The server is not allowed to examine this ID in any other way except as a test for equality.
On the other hand, if using a "reliable" transport such as TCP, the application can infer from a reply message that the procedure was executed exactly once, but if it receives no reply message, it cannot assume that the remote procedure was not executed.
Note that even if a connection oriented protocol like TCP is used, an application still needs time outs and reconnections to handle server crashes.
There are other possibilities for transports besides datagram  or connection oriented protocols.
For example, a request reply protocol such as [VMTP] is perhaps a natural transport for RPC.
ONC RPC currently uses both TCP and UDP transport protocols.
Section 11 ("Record Marking Standard") describes the mechanism employed by ONC RPC to utilize a connection oriented, stream oriented transport such as TCP.
The mechanism by which future transports having different structural characteristics should be used to transfer ONC RPC messages should be specified by means of a Standards Track RFC, once such additional transports are defined.
The act of binding a particular client to a particular service and transport parameters is NOT part of this RPC protocol specification.
This important and necessary function is left up to some higher level software.
Implementors could think of the RPC protocol as the jump subroutine instruction (JSR) of a network; the loader (binder) makes JSR useful, and the loader itself uses JSR to accomplish its task.
Likewise, the binding software makes RPC useful, possibly using RPC to accomplish this task.
The RPC protocol provides the fields necessary for a client to identify itself to a service, and vice versa, in each call and reply message.
Security and access control mechanisms can be built on top of this message authentication.
Several different authentication protocols can be supported.
A field in the RPC header indicates which protocol is being used.
More information on specific authentication protocols is in Section 8.2, "Authentication, Integrity and Privacy".
The RPC protocol must provide for the following:
Unique specification of a procedure to be called  Provisions for matching response messages to request messages  Provisions for authenticating the caller to service and vice versa Besides these requirements, features that detect the following are worth supporting because of protocol roll over errors, implementation bugs, user error, and network administration:  RPC protocol mismatches
Remote program protocol version mismatches  Protocol errors (such as misspecification of a procedure's parameters)
Reasons why remote authentication failed  Any other reasons why the desired procedure was not called 8.1.
The RPC call message has three unsigned integer fields   remote program number, remote program version number, and remote procedure number   that uniquely identify the procedure to be called.
Program numbers are administered by a central authority (IANA).
Once implementors have a program number, they can implement their remote program; the first implementation would most likely have the version number 1 but MUST NOT be the number zero.
Because most new protocols evolve, a "version" field of the call message identifies which version of the protocol the caller is using.
Version numbers enable support of both old and new protocols through the same server process.
The procedure number identifies the procedure to be called.
These numbers are documented in the specific program's protocol specification.
For example, a file service's protocol specification may state that its procedure number 5 is "read" and
procedure number 12 is "write".
Just as remote program protocols may change over several versions, the actual RPC message protocol could also change.
Therefore, the call message also has in it the RPC version number, which is always equal to 2 for the version of RPC described here.
The reply message to a request message has enough information to distinguish the following error conditions:
The remote implementation of RPC does not support protocol version 2.
The lowest and highest supported RPC version numbers are returned.
The remote program is not available on the remote system.
The remote program does not support the requested version number.
The lowest and highest supported remote program version numbers are returned.
The requested procedure number does not exist.
(This is usually a client side protocol or programming error.)
The parameters to the remote procedure appear to be garbage from the server's point of view.
(Again, this is usually caused by a disagreement about the protocol between client and service.)
Authentication, Integrity, and Privacy Provisions for authentication of caller to service and vice versa are provided as a part of the RPC protocol.
The call message has two authentication fields: the credential and the verifier.
The reply message has one authentication field: the response verifier.
The RPC protocol specification defines all three fields to be the following opaque type (in the eXternal Data Representation (XDR) language [RFC4506]):
enum auth flavor { AUTH
The interpretation and semantics of the data contained within the authentication fields are specified by individual, independent authentication protocol specifications.
If authentication parameters were rejected, the reply message contains information stating why they were rejected.
As demonstrated by RPCSEC GSS, it is possible for an "auth flavor" to also support integrity and privacy.
Program Number Assignment Program numbers are given out in groups according to the following chart: 0x00000000
To be assigned by IANA 0x20000000
Defined by local administrator (some blocks assigned here) 0x40000000
The first group is a range of numbers administered by IANA and should be identical for all sites.
The second range is for applications peculiar to a particular site.
This range is intended primarily for debugging new programs.
When a site develops an application that might be of general interest, that application should be given an assigned number in the first range.
Application developers may apply for blocks of RPC program numbers in the first range by methods described in Appendix B.
The third group is for applications that generate program numbers dynamically.
The final groups are reserved for future use, and should not be used.
Other Uses of the RPC Protocol
The intended use of this protocol is for calling remote procedures.
Normally, each call message is matched with a reply message.
However, the protocol itself is a message passing protocol with which other (non procedure call) protocols can be implemented.
Batching Batching is useful when a client wishes to send an arbitrarily large sequence of call messages to a server.
Batching typically uses reliable byte stream protocols (like TCP) for its transport.
In the case of batching, the client never waits for a reply from the server, and the server does not send replies to batch calls.
A sequence of batch calls is usually terminated by a legitimate remote procedure call operation in order to flush the pipeline and get positive acknowledgement.
In broadcast protocols, the client sends a broadcast call to the network and waits for numerous replies.
This requires the use of packet based protocols (like UDP) as its transport protocol.
Servers that support broadcast protocols usually respond only when the call is successfully processed and are silent in the face of errors, but this varies with the application.
The principles of broadcast RPC also apply to multicasting
an RPC request can be sent to a multicast address.
This section defines the RPC message protocol in the XDR data description language [RFC4506].
enum msg type { CALL    0, REPLY   1 }; A reply to a call message can take on two forms: the message was either accepted or rejected.
enum auth stat { AUTH
IANA will hand out new auth stat numbers on a simple First Come First Served basis as defined in the "IANA Considerations" and Appendix B.
The RPC message: All messages start with a transaction identifier, xid, followed by a two armed discriminated union.
The union's discriminant is a msg type that switches to one of the two types of the message.
The xid of a REPLY message always matches that of the initiating CALL message.
NB: The "xid" field is only used for clients matching reply messages with call messages or for servers detecting retransmissions; the service side cannot treat this id as any type of sequence number.
struct rpc msg { unsigned int xid; union switch (msg type mtype) {
In version 2 of the RPC protocol specification, rpcvers MUST be equal to 2.
The fields "prog", "vers", and "proc" specify the remote program, its version number, and the procedure within the remote program to be called.
After these fields are two authentication parameters: cred (authentication credential) and verf (authentication verifier).
The two authentication parameters are followed by the parameters to the remote procedure, which are specified by the specific program protocol.
The purpose of the authentication verifier is to validate the authentication credential.
Note that these two items are historically separate, but are always used together as one logical entity.
accepted reply areply; case MSG DENIED: rejected reply rreply; } reply; Reply to an RPC call that was accepted by the server: There could be an error even though the call was accepted.
The first field is an authentication verifier that the server generates in order to validate itself to the client.
It is followed by a union whose discriminant is an enum accept stat.
The SUCCESS arm of the union is protocol specific.
The PROG UNAVAIL, PROC UNAVAIL, GARBAGE ARGS, and SYSTEM ERR arms of the union are void.
The PROG MISMATCH arm specifies the lowest and highest version numbers of the remote program supported by the server.
struct accepted reply { opaque auth verf; union switch (accept stat stat)
{ case SUCCESS: opaque results[0]
Cases include PROG UNAVAIL, PROC UNAVAIL,   GARBAGE ARGS, and SYSTEM ERR.
In case of an RPC version mismatch, the server returns the lowest and highest supported RPC version numbers.
In case of invalid authentication, failure status is returned.
union rejected reply switch (reject stat stat) { case RPC MISMATCH: struct { unsigned int low; unsigned int high; } mismatch info; case AUTH ERROR:
As previously stated, authentication parameters are opaque, but open ended to the rest of the RPC protocol.
This section defines two standard flavors of authentication.
Implementors are free to invent new authentication types, with the same rules of flavor number assignment as there are for program number assignment.
The flavor of a credential or verifier refers to the value of the "flavor" field in the opaque auth structure.
Flavor numbers, like RPC program numbers, are also administered centrally, and developers may assign new flavor numbers by methods described in Appendix B.  Credentials and verifiers are represented as variable length opaque data (the "body" field in the opaque auth structure).
In this document, two flavors of authentication are described.
Of these, Null authentication (described in the next subsection) is mandatory
it MUST be available in all implementations.
System authentication (AUTH SYS) is described in Appendix A.  Implementors MAY include AUTH SYS in their implementations to support existing applications.
See "Security Considerations" for information about other, more secure, authentication flavors.
Null Authentication Often, calls must be made where the client does not care about its identity or the server does not care who the client is.
In this case, the flavor of the RPC message's credential, verifier, and reply verifier is "AUTH NONE".
Opaque data associated with "AUTH NONE" is undefined.
It is recommended that the length of the opaque data be zero.
When RPC messages are passed on top of a byte stream transport protocol (like TCP), it is necessary to delimit one message from another in order to detect and possibly recover from protocol errors.
This is called record marking (RM).
One RPC message fits into one RM record.
A record is composed of one or more record fragments.
A record fragment is a four byte header followed by 0 to (2  31) 1 bytes of fragment data.
The bytes encode an unsigned binary number; as with XDR integers, the byte order is from highest to lowest.
The number encodes two values   a boolean that indicates whether the fragment is the last fragment of the record (bit value 1 implies the fragment is the last fragment) and a 31 bit unsigned binary value that is the length in bytes of the fragment's data.
The boolean value is the highest order bit of the header; the length is the 31 low order bits.
(Note that this record specification is NOT in XDR standard form!)
The RPC Language Just as there was a need to describe the XDR data types in a formal language, there is also need to describe the procedures that operate on these XDR data types in a formal language as well.
The RPC language is an extension to the XDR language, with the addition of "program", "procedure", and "version" declarations.
The keywords "program" and "version" are reserved in the RPC language, and implementations of XDR compilers MAY reserve these keywords even when provided with pure XDR, non RPC, descriptions.
The following example is used to describe the essence of the language.
An Example Service Described in the RPC Language
Here is an example of the specification of a simple ping program.
/ version PING VERS PINGBACK { void PINGPROC NULL(void)
1 if the operation   timed out.
The first version described is PING VERS PINGBACK with two procedures: PINGPROC NULL and PINGPROC PINGBACK.
PINGPROC NULL takes no arguments and returns no results, but it is useful for computing round trip times from the client to the server and back again.
By convention, procedure 0 of any RPC protocol should have the same semantics and never require any kind of authentication.
The second procedure is used for the client to have the server do a reverse ping operation back to the client, and it returns the amount of time (in microseconds) that the operation used.
The next version, PING VERS ORIG, is the original version of the protocol, and it does not contain the PINGPROC PINGBACK procedure.
It is useful for compatibility with old client programs, and as this program matures, it may be dropped from the protocol entirely.
The RPC language is identical to the XDR language defined in RFC 4506, except for the added definition of a "program def", described below.
The following keywords are added and cannot be used as identifiers: "program" and "version".
A version name cannot occur more than once within the scope of a program definition.
Neither can a version number occur more than once within the scope of a program definition.
A procedure name cannot occur more than once within the scope of a version definition.
Neither can a procedure number occur more than once within the scope of version definition.
Program identifiers are in the same name space as constant and type identifiers.
Only unsigned constants can be assigned to programs, versions, and procedures.
Current RPC language compilers do not generally support more than one type specifier in procedure argument lists; the usual practice is to wrap arguments into a structure.
The assignment of RPC program numbers, authentication flavor numbers, and authentication status numbers has in the past been performed by Sun Microsystems, Inc (Sun).
This is inappropriate for an IETF Standards Track protocol, as such work is done well by the Internet Assigned Numbers Authority (IANA).
This document proposes the transfer of authority over RPC program numbers, authentication flavor numbers, and authentication status numbers described here from Sun Microsystems, Inc. to IANA and describes how IANA will maintain and assign these numbers.
Users of RPC protocols will benefit by having an independent body responsible for these number assignments.
Numbering Requests to IANA Appendix B of this document describes the information to be sent to IANA to request one or more RPC numbers and the rules that apply.
IANA will store the request for documentary purposes and put the following information into the public registry:
The short description of purpose and use  The program number(s) assigned  The short identifier string(s) 13.2.
Sun has made assignments in both the RPC program number space and the RPC authentication flavor number space since the original deployment of RPC.
The assignments made by Sun Microsystems are still valid, and will be preserved.
Sun has communicated all current assignments in both number spaces to IANA and final handoff of number assignment is complete.
Current program and auth number assignments are provided in Appendix C.  Current authentication status numbers are listed in Section 9 of this document in the "enum auth stat" definition.
RPC Number Assignment Future IANA practice will deal with the following partitioning of the 32 bit number space as listed in Section 8.3.
Detailed information for the administration of the partitioned blocks in Section 8.3 is given below.
To Be Assigned By IANA The first block will be administered by IANA, with previous assignments by Sun protected.
Previous assignments were restricted to the range decimal 100000 399999 (0x000186a0 to 0x00061a7f); therefore, IANA will begin assignments at decimal 400000.
Individual numbers should be grated on a First Come First Served basis, and blocks should be granted under rules related to the size of the block.
The "Defined by local administrator" block is available for any local administrative domain to use, in a similar manner to IP address ranges reserved for private use.
The expected use would be through the establishment of a local domain "authority" for assigning numbers from this range.
This authority would establish any policies or procedures to be used within that local domain for use or assignment of RPC numbers from the range.
The local domain should be sufficiently isolated that it would be unlikely that RPC applications developed by other local domains could communicate with the domain.
This could result in RPC number contention, which would cause one of the applications to fail.
In the absence of a local administrator, this block can be utilized in a "Private Use" manner per [RFC5226].
The "Transient" block can be used by any RPC application on an "as available" basis.
This range is intended for services that can communicate a dynamically selected RPC program number to clients of the service.
Any mechanism can be used to communicate the number.
For example, either shared memory when the client and server are located on the same system or a network message (either RPC or otherwise) that disseminates the selected number can be used.
The transient block is not administered.
An RPC service uses this range by selecting a number in the transient range and attempting to register that number with the local system's RPC bindery (see the RPCBPROC SET or PMAPPROC SET procedures in "Binding Protocols for ONC RPC Version 2", [RFC1833]).
If successful, no other RPC service was using that number and
the RPC Bindery has assigned that number to the requesting RPC application.
The registration is valid until the RPC Bindery terminates, which normally would only happen if the system reboots, causing all applications, including the RPC service using the transient number, to terminate.
If the transient number registration fails, another RPC application is using the number and the requestor must select another number and try again.
To avoid conflicts, the recommended method is to select a number randomly from the transient range.
The "Reserved" blocks are available for future use.
RPC applications must not use numbers in these ranges unless their use is allowed by future action by the IESG.
RPC Number Sub Blocks RPC numbers are usually assigned for specific RPC services.
Some applications, however, require multiple RPC numbers for a service.
The most common example is an RPC service that needs to have multiple instances of the service active simultaneously at a specific site.
RPC does not have an "instance identifier" in the protocol, so either a mechanism must be implemented to multiplex RPC requests amongst various instances of the service or unique RPC numbers must be used by each instance.
In these cases, the RPC protocol used with the various numbers may be different or the same.
The numbers may either be assigned dynamically by the application, or as part of a site specific administrative decision.
If possible, RPC services that dynamically assign RPC numbers should use the "Transient" RPC number block defined in Section 13.3.3.
If not possible, RPC number sub blocks may be requested.
Assignment of RPC Number Sub Blocks is controlled by the size of the sub block being requested.
"Specification Required" and "IESG Approval" are used as defined by Section 4.1 of [RFC5226].
IANA More than 1000 numbers
IESG Approval required    IESG Note: sub blocks can be any size.
The limits given above are maximums, and smaller size sub blocks are allowed.
Sub blocks sized up to 100 numbers may be assigned by IANA on a First Come First Served basis.
The RPC Service Description included in the range must include an indication of how the sub block is managed.
At a minimum, the statement should indicate whether the sub block is used with a single RPC protocol or multiple RPC protocols, and whether the numbers are dynamically assigned or statically (through administrative action) assigned.
Sub blocks of up to 1000 numbers must be documented in detail.
The documentation must describe the RPC protocol or protocols that are to be used in the range.
It must also describe how the numbers within the sub block are to be assigned or used.
Sub blocks sized over 1000 numbers must be documented as described above, and the assignment must be approved by the IESG.
It is expected that this will be rare.
In order to avoid multiple requests of large blocks of numbers, the following rule is proposed.
Requests up to and including 100 RPC numbers are handled via the First Come First Served assignment method.
This 100 number threshold applies to the total number of RPC numbers assigned to an individual or entity.
For example, if an individual or entity first requests, say, 70 numbers, and then later requests 40 numbers, then the request for the 40 numbers will be assigned via the Specification Required method.
As long as the total number of numbers assigned does not exceed 1000, IANA is free to waive the Specification Required assignment for incremental requests of less than 100 numbers.
If an individual or entity has under 1000 numbers and later requests an additional set of numbers such that the individual or entity would be granted over 1000 numbers, then the additional request will require IESG Approval.
RPC Authentication Flavor Number Assignment
The second number space is the authentication mechanism identifier, or "flavor", number.
This number is used to distinguish between various authentication mechanisms that can be optionally used with an RPC message.
An authentication identifier is used in the "flavor" field of the "opaque auth" structure.
Assignment Policy Appendix B of this document describes the information to be sent to IANA to request one or more RPC auth numbers and the rules that apply.
IANA will store the request for documentary purposes and put the following information into the public registry:
The short description of purpose and use 13.4.2.
Pseudo Flavors Recent progress in RPC security has moved away from new auth flavors as used by AUTH DH [DH], and has focused on using the existing RPCSEC GSS [RFC2203] flavor and inventing novel GSS API (Generic Security Services Application Programming Interface) mechanisms that can be used with it.
Even though RPCSEC GSS is an assigned authentication flavor, use of a new RPCSEC GSS mechanism with the Network File System (NFS) ([RFC1094] [RFC1813], and [RFC3530]) will require the registration of 'pseudo flavors' that are used to negotiate security mechanisms in an unambiguous way, as defined by [RFC2623].
Existing pseudo flavors have been granted in the decimal range 390000 390255.
New pseudo flavor requests will be granted by IANA within this block on a First Come First Served basis.
For non pseudo flavor requests, IANA will begin granting RPC authentication flavor numbers at 400000 on a First Come First Served basis to avoid conflicts with currently granted numbers.
For authentication flavors or RPCSEC GSS mechanisms to be used on the Internet, it is strongly advised that an Informational or Standards Track RFC be published describing the authentication mechanism behaviour and parameters.
The final number space is the authentication status or "auth stat" values that describe the nature of a problem found during an attempt to authenticate or validate authentication.
The complete initial list of these values is found in Section 9 of this document, in the "auth stat" enum listing.
It is expected that it will be rare to add values, but that a small number of new values may be added from time to time as new authentication flavors introduce new possibilities.
Numbers should be granted on a First Come First Served basis to avoid conflicts with currently granted numbers.
Assignment Policy Appendix B of this document describes the information to be sent to IANA to request one or more auth stat values and the rules that apply.
IANA will store the request for documentary purposes, and put the following information into the public registry:  The short identifier string(s)
The short description of purpose and use 14.
Security Considerations AUTH SYS as described in Appendix A is known to be insecure due to the lack of a verifier to permit the credential to be validated.
SYS SHOULD NOT be used for services that permit clients to modify data.
AUTH SYS MUST NOT be specified as RECOMMENDED or REQUIRED for any Standards Track RPC service.
AUTH DH as mentioned in Sections 8.2 and 13.4.2 is considered obsolete and insecure; see [RFC2695].
AUTH DH SHOULD NOT be used for services that permit clients to modify data.
AUTH DH MUST NOT be specified as RECOMMENDED or REQUIRED for any Standards Track RPC service.
[RFC2203] defines a new security flavor, RPCSEC GSS, which permits GSS API [RFC2743] mechanisms to be used for securing RPC.
All non  trivial RPC programs developed in the future should implement RPCSEC GSS based security appropriately.
[RFC2623] describes how this was done for a widely deployed RPC program.
Standards Track RPC services MUST mandate support for RPCSEC GSS, and MUST mandate support for an authentication pseudo flavor with appropriate levels of security, depending on the need for simple authentication, integrity (a.k.a. non repudiation), or data privacy.
The client may wish to identify itself, for example, as it is identified on a UNIX(tm) system.
The flavor of the client credential is "AUTH SYS".
The "machinename" is the name of the caller's machine (like "krypton").
The "uid" is the caller's effective user ID.
The "gid" is the caller's effective group ID.
"gids" are a counted array of groups that contain the caller as a member.
The verifier accompanying the credential should have "AUTH NONE" flavor value (defined above).
Note that this credential is only unique within a particular domain of machine names, uids, and gids.
The flavor value of the verifier received in the reply message from the server may be "AUTH NONE" or "AUTH SHORT".
In the case of "AUTH SHORT", the bytes of the reply verifier's string encode an opaque structure.
This new opaque structure may now be passed to the server instead of the original "AUTH SYS" flavor credential.
The server may keep a cache that maps shorthand opaque structures (passed back by way of an "AUTH SHORT" style reply verifier) to the original credentials of the caller.
The caller can save network bandwidth and server cpu cycles by using the shorthand credential.
The server may flush the shorthand opaque structure at any time.
If this happens, the remote procedure call message will be rejected due to an authentication error.
The reason for the failure will be "AUTH REJECTEDCRED".
At this point, the client may wish to try the original "AUTH SYS" style of credential.
It should be noted that use of this flavor of authentication does not guarantee any security for the users or providers of a service, in itself.
The authentication provided by this scheme can be considered legitimate only when applications using this scheme and the network can be secured externally, and privileged transport addresses are used for the communicating end points (an example of this is the use of privileged TCP/UDP ports in UNIX systems   note that not all systems enforce privileged transport address mechanisms).
Requesting RPC Related Numbers from IANA RPC program numbers, authentication flavor numbers, and authentication status numbers that must be unique across all networks are assigned by the Internet Assigned Number Authority.
To apply for a single number or a block of numbers, electronic mail must be sent to IANA
(program number or authentication flavor number or authentication status number) sought  How many numbers are sought  The name of the person or company that will use the number  An "identifier string" that associates the number with a service  Email address of the contact person for the service that will be using the number  A short description of the purpose and use of the number
If an authentication flavor number is sought, and the number will be a 'pseudo flavor' intended for use with RPCSEC GSS and NFS, mappings analogous to those in Section 4.2 of [RFC2623]
Specific numbers cannot be requested.
Numbers are assigned on a First Come First Served basis.
For all RPC authentication flavor and authentication status numbers to be used on the Internet, it is strongly advised that an Informational or Standards Track RFC be published describing the authentication mechanism behaviour and parameters.
# # Sun assigned RPC numbers
nse activate prog sunview help
100080    autodump prog Event protocol
100083    database service Consulting Services
remote activation svc Consulting Services
autofs 100100    msgboard event dispatching agent [eventd]   100101    netmgt eventd prog statistics/event logger [netlogd]  100102    netmgt netlogd prog topology display manager
[topology]100103    netmgt topology prog syncstat agent
dm 100149    rkstat 100150    ocfserv 100151    sccheckd 100152
nfsmapid 100167    SUN WBEM C CIMON HANDLE 100168
ha dbms serv 100223 100225
cachefsd 100236    msmprog Media Server 100237
100246    ctid cluster transport interface 100247
pmfd 100249    dmi2 client 100250    mfs admin 100251    ndshared
slink 100254    cbs control board server 100255    skiserv 100256
ndshared enable 100259    sms account admin 100260    sms modem admin 100261
sms r login 100262    sms r subaccount mgt 100263    sms service admin 100264    session admin 100265    canci ancs program 100266    canci sms program 100267
id map 100271    ncall 100272
Working Group FedFS   100418 100421 100422    mdcommd 100423
[unknown] TOPS external attribute storage    150003
daemon0 170101    domf daemon1 170102
cetcomprog 180008    cetsysprog 180009    cghapresenceprog 180010
crimsyscomponentprog 180023    crimsysservicesprog 180024    csmagtapiprog 180025    csmagtcallbackprog 180026    csmreplicaprog
pyramid reserved 200002    cadds image 200003    stellar name prog 200004
200007    lookupids 200008    ax statd prog 200009    ax statd2 prog 200010
knfsd 200020    ftnfsd ftnfsd program 200021    ftsyncd ftsyncd
program 200022    ftstatd ftstatd program 200023    exportmap 200024
rvd 300007    entombing daemon 300008    account mgmt system 300009    frame prog2
300010    beeper access 300011    dptuprog 300012
300013    instrument file access 300014    file system statistics 300015    unify database server 300016    tmd msg 300017
case tool 300035    delta 300036
[unknown] 300040    dtia rpc server 300041    cms 300042
viewer 300043    aqm 300044    exclaim 300045
masterplan 300046    fig tool 300047
remote get login 300084    odcprog 300085
300091    smartdoc 300092    superping 300093
chembench 300094    uacman/alfil uacman 300095    ait rcagent prog
300096    ait rcagent appl prog 300097    smart 300098    ecoprog
cadc fhlockprog 300117    highscan 300118
300153    arimage 300154    xdb workbench 300155    frontdesk 300156
dmc 300157    expressight 6000 300158
netuser x 300179    rmntprog 300180
[unknown] 300198    trend idbd 300199    rres 300200    sd.masterd 300201
msbd 300206    stagedprog 300207    mountprog 300208    watchdprog 300209
[unknown] 300211    session server program 300212    session program 300213    debug serverprog 300214
radavx 300231    radview 300232    rsys prog 300233    rsys prog 300234    fm rpc prog 300235    aries 300236
uapman 300237    ddman 300238    top 300239
statuslicenseprog 300243    oema rmpf svc 300244
oema smpf svc 300245    oema rmsg svc 300246
ds master 300248    ds transfer 300249
ds logger 300250    ds query 300251
300256    floorplanner 300257    reach 300258    tactic 300259    cachescientific1 300260
text processor 300268    xess 300269
orionscanplus 300272    openlink xx 300273
the xprt 300277    cmg srvprog 300278
jincv2 300286    isls 300287    systemstatprog 300288
axess 300291    armor rpcd 300292
dictionary rpcd 300293    armor miscd 300294    filetransfer
prog 300295    bl swda 300296    bl hwda 300297
300306    sns7000 300307    igprog 300308
tbisam 300316    tbis 300317    adsprog 300318
mobil1 300323    sld service locator daemon 300324
drprog 300327    ressys commands 300328
lsd 300337    geomgrd 300338    generic fts 300339
ft ack 300340    lymb 300341
vantage 300342    cltstd clooptstdprog 300343
cmd dispatch maxm ems 300347    callpath receive program 300348
sbc frs 300352    atommgr 300353
setcimrpc 300364    virtual protocol adapter 300365
uniarch 300367    unifile 300368    unisrex 300369    uniscmd 300370    rsc 300371
rcnlib 300379    rcnlib attach 300380    evergreen mgmt agent 300381
rui remote user interface 300383
300387    pipecs cs pipeprog ppktrpc 300388    uv net univision 300389
eeei reserved 1 300394    eeei reserved
6 300399    eeei reserved 7 300400    eeei reserved 8 300401    cprlm 300402
ov msg ctlg svc 300416    ov advt reg svc 300417 300424
daatd 300426    swiftnet 300427    ovomdel 300428    ovomreq 300429
msg dispatcher 300430    pcshare server 300431    rcvs 300432
fdfserver 300433    bssd 300434    drdd 300435
nwsbumv 300440    dgux mgr 300441
300452 300453    ckt implementation 300454
pc idisched 300472    dg pc idiserv 300473    apd 300474
ap sspd 300475    callpatheventrecorder 300476
300479    iqddsrv 300480    iqjobsrv 300481    tacosxx 300482
wheeldbmg 300483    cnxmgr nm prog 300484    cnxmgr cfg prog 300485
rpc svc 300488    lfn 300489    salesnet 300490    defaxo
300491    dbqtsd 300492    kms 300493    rpc.iced
ars server 300500    ars client 300501
evama 300505    conama 300506    service process
300507    reuse proxy 300508    mars ctrl 300509    mars
tbpipcip 300513    top acs svc 300514
atsr gc 300521    alarm alarm prog 300522
callpathasyncmsghandler 300532    optix arc 300533    optix ts 300534    optix wf 300535    maxopenc 300536    cev cev server 300537
dcdbd 300542    dcpsd 300543    supportlink prog 300544    broker 300545    listner 300546
300548    spai adaption 300549    chimera ci chimera clientinterface 300550    chimera pi chimera processinvoker 300551
teamware fl teamware foundationlevel 300552    teamware sl teamware systemlevel 300553
teamware ui teamware userinterface 300554    lprm 300555    mpsprog Mensuration Proxy Server 300556
mo symdis 300557    retsideprog 300558
m rpc teamconference 300561    license prog license 300562    stuple stuple prog 300563
gentranmentorsecurity 300565    gentranmentorprovider 300566    latituded latitude license server
gentranmentorreq3 300570    rj server 300571
gws rdb 300572    gws mpmd 300573
gws spmd 300574    vwcalcd 300575    vworad 300576    vwsybd 300577
vwave 300578    online assistant 300579    internet assistant 300580
300586    aapi 300587    rstrt 300588
empress 300591    sched server LiveScheduler 300592    path server
c2scf 300595    btsas 300596    sdtas 300597
pscd panther software corp daemon 300600
wwcommo 300603    mx mie 300604    mx mie debug 300605    idmn 300606
samserver 300609    sams server 300610    chrysalis 300611
ddm is 300613    mx bcp debug 300614
nrp 300622    hpid 300623    mailwatch
fos bc fcrb receiver 300625    cs sysadmin svr 300626    cs controller svr 300627    nokia nms eai 300628    dbg 300629
Impress Server 300636    colorstar 300637    gwugui 300638    gwsgui 300639    dai command proxy 300640
dai fui proxy 300642    spai command proxy 300643    spai alarm server
300644    iris 300645    hcxttp 300646    updatedb rsched 300647
urn 300648    iqwpsrv 300649    dskutild 300650
300654    wwpollerrpc 300655    wwmodelrpc 300656
nsdistd 300658    recollect 300659    lssexecd
lss res 300660    lssagend lss rea 300661    cdinfo 300662    sninsr addon 300663    mm sap 300664
tdmesmgt 300676    olm 300677    mediamanagement 300678    rdbprog fieldowsrv 300679    rpwdprog rpwd 300680    sapi trace
300681    sapi master daemon 300682    omdcuprog
tndidprog 300685    rkey setsecretprog 300686
ole 300691    rtc 300692    disp 300693    sql compilation agent 300694    tnsysprog
300695    ius sapimd 300696    apteam dx 300697    rmsrpc 300698    seismic system 300699    remote 300700
tt1 ts event nokia nms 300701    fxrs 300702
300718    caaui 300719    cescda 300720
vcapi20 300722    tcfs 300723    csed 300724
300728    bestcomm 300729    lprpasswd 300730
300736    ando ts 300737    intermezzo 300738
ftel sdh request 300739    ftel sdh response 300740
vrc abb 300746    vrc comau 300747    vrc fanuc 300748
300755    intransa location 300756    intransa management 300757    intransa federation 300758
300759    ipmiprot 300760    aceapi 300761
f6000pss 300762    vsmapi program 300763
ubertuple 300764    ctconcrpcif 300765    mfuadmin 300766
twrled 300786    twrcfgdb BMC software
wfmMgmtFut1 351353    wfmMgmtFut1 351354    wfmAPM 351355    wfmIAMgr 351356    wfmECMgr 351357
sched28d 351379    sched29d 351380    sched30d 351381    sched31d 351382
sched37d 351388    sched38d 351389    sched39d
RSENDEVENTPROG 351395    snapp 351396    snapad 351397    sdsoodb 351398
fsmonitor 351404    fsdisp 351405    fssession 351406
tbdbserv 351417    tbprojserv 351418    genericserver
351419    dynarc ds 351420    dnscmdr 351421    ipcmdr 351422    faild 351423
[unknown] 351427    siemens srs 351428
voicemail 351437    kis 351438    SOFTSERV NOTIFY 351439
hc 351441    iopas 351442    iopcs 351443
matilda dbs 351449    matilda sps 351450    matilda svs 351451
hp graphicsd 351457    berkeley db berkeley db svc 351458
Queue 351471    ARCserveIT Device 351472    ARCserveIT
Discover 351473    ARCserveIT Alert 351474    ARCserveIT Database 351475
351483    iprobe 351484    omniconf 351485
380000    opensna 380001    probenet 380002
na.vlb 380008    cds mhs agent 380009
cds x500 agent 380010    cds mailhub agent 380011
codex 6500 proxy 380012    codex 6500 trapd 380013
na.nm212 380014    cds mta metrics agent 380015
390400 390499 Client Server Tech.
isps 391759    isps admin 391760
mars admin 391762    attcis spare0 391763
attcis spare1 391764    mail server 391765    mail server spare 391766
attcis spare2 391767    attcis spare3 391768    attcis spare4 391769
qhrbackup 391852    minutedata 391853    prefecture 391854
supc 391855    suadmincrw 391856    suadminotas 391857
sumessage 391858    sublock 391859    sumotd staffware dev.
disksrvr 391882    tapesrvr 391883    migsrvr 391884
391959 391967 391968    sra legato 391969    sra legato imgsvr 391970
1 391972    sra legato 2 391973    sra legato
3 391974    sra legato 4 391975    sra legato 5 391976
6 391977    sra legato 7 391978    sra legato
8 391979    sra legato 9
ife satcom 395171    ife seat 395172    ife dbmgr 395173    ife testmgr 395174    atrium server 395175    ase director 395176    ase agent 395177    ase hsm 395178    ase mgr 395179
# # Sun assigned authentication flavor numbers
RFC 1831  / AUTH DH
AUTH DES, see RFC 2695  / AUTH KERB
Univ. of Guelph Not Quite
NFS 'pseudo' flavors for RPCSEC GSS 390003 kerberos v5 authentication, RFC 2623 390004 kerberos v5 with data integrity, RFC 2623 390005 kerberos v5 with data privacy,
