- title: __initial_text__
  contents:
  - ''
- title: Independent Submission                                       A. McKenzie
  contents:
  - "Independent Submission                                       A. McKenzie\n  \
    \              Host/Host Protocol for the ARPA Network\n"
- title: Abstract
  contents:
  - "Abstract\n   This document reproduces the Host/Host Protocol developed by the\
    \ ARPA\n   Network Working Group during 1969, 1970, and 1971.  It describes a\n\
    \   protocol used to manage communication between processes residing on\n   independent\
    \ Hosts.  It addresses issues of multiplexing multiple\n   streams of communication\
    \ (including addressing, flow control,\n   connection establishment/disestablishment,\
    \ and other signaling) over\n   a single hardware interface.  It was the official\
    \ protocol of the\n   ARPA Network from January 1972 until the switch to TCP/IP\
    \ in January\n   1983.  It is offered as an RFC at this late date to help complete\
    \ the\n   historical record available through the RFC series.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for the historical record.\n   This document defines a Historic\
    \ Document for the Internet community.\n   This is a contribution to the RFC Series,\
    \ independent of any other\n   RFC stream.  The RFC Editor has chosen to publish\
    \ this document at\n   its discretion and makes no statement about its value for\n\
    \   implementation or deployment.  Documents approved for publication by\n   the\
    \ RFC Editor are not a candidate for any level of Internet\n   Standard; see Section\
    \ 2 of RFC 5741.\n   Information about the current status of this document, any\
    \ errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6529.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2012 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. A Few Comments on Nomenclature and Key Concepts .................4\n  \
    \ 3. Host/Host Protocol Document .....................................5\n    \
    \  (with its own table of contents on page 7)\n   4. Security Considerations ........................................34\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The Host/Host Protocol for the ARPA Network was created\
    \ during 1969,\n   1970, and 1971 by the Network Working Group, chaired by Steve\n\
    \   Crocker, a graduate student at UCLA.  Many of the RFCs with numbers\n   less\
    \ than 72, plus RFCs 102, 107, 111, 124, 132, 154, and 179 dealt\n   with the\
    \ development of this protocol.  The first official document\n   defining the\
    \ protocol was issued by Crocker on August 3, 1970 as\n   \"Host-Host Protocol\
    \ Document No. 1\" (see citation in RFC 65), which\n   was based on RFC 54 by\
    \ Crocker, Postel, Newkirk, and Kraley.\n   Revision of Document No. 1 began in\
    \ mid-February 1971, as discussed\n   in RFC 102.  Although McKenzie is listed\
    \ as the author of the January\n   1972 document, which superseded Document No.\
    \ 1, it is more correct to\n   say McKenzie was the person who compiled and edited\
    \ the document.\n   Most or all of the ideas in the document originated with others.\n\
    \   At the time \"Host-Host Protocol Document No. 1\" was issued it was not\n\
    \   given an RFC number because it was not to be viewed as a \"request for\n \
    \  comments\" but as a standard for implementation.  It was one of a set\n   of\
    \ such standards maintained as a separate set of documentation by\n   the Network\
    \ Information Center (NIC) at Stanford Research Institute\n   (SRI).  The January\
    \ 1972 version (NIC 8246) reproduced here also\n   followed that approach.  It\
    \ has been noted by many that all\n   subsequent standards were issued as RFCs,\
    \ and the absence of the\n   Host/Host Protocol specification from the RFC series\
    \ creates a\n   curious gap in the historical record.  It is to fill that gap\
    \ that\n   this RFC is offered.\n   In 1972, most ARPA Network documents, RFCs\
    \ and others, were prepared\n   and distributed in hard copy.  The Host/Host Protocol\
    \ document was\n   typed on a typewriter (probably an IBM Selectric), which had\n\
    \   interchangeable print elements, and used both italic and boldface\n   fonts\
    \ in addition to the regular font.  Diagrams were drawn by a\n   graphic artist\
    \ and pasted into the typed document.  Since RFCs are\n   constrained to use a\
    \ single typeface, we have tried to indicate\n   boldface by the use of either\
    \ all capitals or by a double underline,\n   and to indicate italics by the use\
    \ of underscores around words in\n   place of spaces.  The resulting document\
    \ is a bit more difficult to\n   read, but preserves the emphases of the original.\
    \  Of course, the\n   pagination has changed, and we hope we have correctly modified\
    \ all of\n   the page numbers.  There were three footnotes in the original\n \
    \  document and we have moved these into the text, set off by\n   indentation\
    \ and square brackets.  A .pdf image of the original\n   document can be found\
    \ at\n   http://www.cbi.umn.edu/hostedpublications/pdf/McKenzieNCP1972.pdf.\n"
- title: 2.  A Few Comments on Nomenclature and Key Concepts
  contents:
  - "2.  A Few Comments on Nomenclature and Key Concepts\n   In the protocol definition,\
    \ \"RFC\" is used to mean \"Request for\n   Connection\", which refers to either\
    \ a \"Sender to Receiver\" or a\n   \"Receiver to Sender\" request to initiate\
    \ a connection.  In\n   retrospect, this seems like an unnecessarily confusing\
    \ choice of\n   terminology.\n   At the time this protocol was defined, it was\
    \ given the\n   undistinguished name \"Host-Host Protocol.\"  The acronym \"NCP\"\
    \ meant\n   \"Network Control Program\" and referred to the code that had to be\n\
    \   added to the operating system within each host to enable it to\n   interact\
    \ with its Interface Message Processor (IMP) and manage\n   multiple connections.\
    \  Over time, and particularly in the context of\n   the change from this protocol\
    \ to TCP/IP, this protocol was commonly\n   called \"NCP\" and the expansion changed\
    \ to \"Network Control Protocol.\"\n   This protocol was superseded by TCP.  In\
    \ this document, the protocol\n   is referred to as a second layer (or \"level\"\
    ) protocol, whereas in\n   current writings TCP is usually referred to as a layer\
    \ 4 protocol.\n   When this protocol was created, it was expected that over time\
    \ new\n   layers would be created on top of, below, and even in between\n   existing\
    \ layers.\n   This protocol used a separate channel (the control link) to manage\n\
    \   connections.  This was abandoned in future protocols.\n   In this design,\
    \ there was no checksum or other form of error control\n   except for the RST.\
    \  There had been in earlier versions, but it was\n   removed at the insistence\
    \ of the IMP designers who argued vigorously\n   that the underlying network of\
    \ IMPs would never lose a packet or\n   deliver one with errors.  Although the\
    \ IMP network was generally\n   quite reliable, there were instances where the\
    \ interface between the\n   IMP and the host could drop bits, and, of course,\
    \ experience with\n   congestion control as the network was more heavily used\
    \ made it clear\n   that the host layer would have to deal with occasional losses\
    \ in\n   transmission.  These changes were built into TCP.\n   Uncertainty about\
    \ timing constraints in the design of protocols is\n   evident in this document\
    \ and remains a source of ambiguity,\n   limitation, and error in today's design\
    \ processes.\n"
- title: 3.  Host/Host Protocol Document
  contents:
  - "3.  Host/Host Protocol Document\n                              Host/Host Protocol\n\
    \                                   for the\n                                \
    \ ARPA Network\n   Prepared for the Network Working Group by\n      Alex McKenzie\n\
    \      BBN\n      January 1972\n                                  PREFACE\n  \
    \ This document specifies a protocol for use in communication between\n   Host\
    \ computers on the ARPA Network.  In particular, it provides for\n   connection\
    \ of independent processes in different Hosts, control of\n   the flow of data\
    \ over established connections, and several ancillary\n   functions.  Although\
    \ basically self-contained, this document\n   specifies only one of several ARPA\
    \ Network protocols; all protocol\n   specifications are collected in the document\n\
    \   _Current_Network_Protocols,_ NIC #7104.\n   This document supersedes NIC #7147\
    \ of the same title.  Principal\n   differences between the documents include:\n\
    \      - prohibition of spontaneous RET, ERP, and RRP commands\n      - a discussion\
    \ of the problem of unanswered CLS commands (page 16)\n      - a discussion of\
    \ the implications of queueing and not queueing\n        RFCs (page 14)\n    \
    \  - the strong recommendation that received ERR commands be logged,\n       \
    \ and some additional ERR specifications.\n   In addition to the above, several\
    \ minor editorial changes have been\n   made.\n   Although there are many individuals\
    \ associated with the network who\n   are knowledgeable about protocol issues,\
    \ individuals with questions\n   pertaining to Network protocols should initially\
    \ contact one of the\n   following:\n      Steve Crocker\n      Advanced Research\
    \ Projects Agency\n      1400 Wilson Boulevard\n      Arlington, Virginia 22209\n\
    \      (202) 694-5921 or 5922\n      Alex McKenzie\n      Bolt Beranek and Newman\
    \ Inc.\n      50 Moulton Street\n      Cambridge, Massachusetts 02133\n      (617)\
    \ 491-1350 ext. 441\n      Jon Postel\n      University of California at Los Angeles\n\
    \      Computer Science Department\n      3732 Boelter Hall\n      Los Angeles,\
    \ California 90024\n      (213) 325-2363\n                              TABLE\
    \ OF CONTENTS\n   I.    INTRODUCTION..................................................8\n\
    \         An overview of the multi-leveled protocol structure in the ARPA\n  \
    \       Network.\n   II.   COMMUNICATION CONCEPTS.......................................10\n\
    \         Definitions of terminology and a description of the overall\n      \
    \   strategy used in Host-to-Host communication.\n   III.  NCP FUNCTIONS................................................13\n\
    \         The meat of the document for the first-time reader.  Host-to-\n    \
    \     Host \"commands\" are introduced with descriptions of conditions\n     \
    \    of their use, discussion of possible problems, and other\n         background\
    \ material.\n               Connection Establishment..........................13\n\
    \               Connection Termination............................15\n       \
    \        Flow Control......................................17\n              \
    \ Interrupts........................................20\n               Test Inquiry......................................20\n\
    \               Reinitialization..................................21\n   IV. \
    \  DECLARATIVE SPECIFICATIONS...................................23\n         Details\
    \ for the NCP implementer.  A few additional \"commands\"\n         are introduced,\
    \ and those described in Section III are\n         reviewed.  Formats and code\
    \ and link assignments are specified.\n               Message Format....................................23\n\
    \               Link Assignment...................................25\n       \
    \        Control Messages..................................25\n              \
    \ Control Commands..................................25\n               Opcode\
    \ Assignment.................................31\n               Control Command\
    \ Summary...........................31\n                             I.  INTRODUCTION\n\
    \   The ARPA Network provides a capability for geographically separated\n   computers,\
    \ called Hosts, to communicate with each other.  The Host\n   computers typically\
    \ differ from one another in type, speed, word\n   length, operating system, etc.\
    \  Each Host computer is connected into\n   the network through a local small\
    \ computer called an _Interface_\n   _Message_Processor_(IMP)._  The complete\
    \ network is formed by\n   interconnecting these IMPs, all of which are virtually\
    \ identical,\n   through wideband communications lines supplied by the telephone\n\
    \   company.  Each IMP is programmed to store and forward messages to the\n  \
    \ neighboring IMPs in the network.  During a typical operation, a Host\n   passes\
    \ a message to its local IMP; the first 32 bits of this message\n   include the\
    \ \"network address\" of a destination Host.  The message is\n   passed from IMP\
    \ to IMP through the Network until it finally arrives\n   at the destination IMP,\
    \ which in turn passes it along to the\n   destination Host.\n   Specifications\
    \ for the physical and logical message transfer between\n   a Host and its local\
    \ IMP are contained in Bolt Beranek and Newman\n   (BBN) Report No. 1822.  These\
    \ specifications are generally called the\n   _first_level_protocol_ or Host/IMP\
    \ Protocol.  This protocol is not by\n   itself, however, sufficient to specify\
    \ meaningful communication\n   between processes running in two dissimilar Hosts.\
    \  Rather, the\n   processes must have some agreement as to the method of initiating\n\
    \   communication, the interpretation of transmitted data, and so forth.\n   Although\
    \ it would be possible for such agreements to be reached by\n   each pair of Hosts\
    \ (or processes) interested in communication, a more\n   general arrangement is\
    \ desirable in order to minimize the amount of\n   implementation necessary for\
    \ Network-wide communication.\n   Accordingly, the Host organizations formed a\
    \ Network Working Group\n   (NWG) to facilitate an exchange of ideas and to formulate\
    \ additional\n   specifications for Host-to-Host communications.\n   The NWG has\
    \ adopted a \"layered\" approach to the specification of\n   communications protocol.\
    \  The inner layer is the Host/IMP protocol.\n   The next layer specifies methods\
    \ of establishing communications\n   paths, managing buffer space at each end\
    \ of a communications path,\n   and providing a method of \"interrupting\" a communications\
    \ path.  This\n   protocol, which will be used by all higher-level protocols,\
    \ is known\n   as the _second_level_protocol,_ or Host/Host protocol.  (It is\
    \ worth\n   noting that, although the IMP sub-network provides a capability for\n\
    \   _message_switching,_ the Host/Host protocol is based on the concept\n   of\
    \ _line_switching._)  Examples of further layers of protocol\n   currently developed\
    \ or anticipated include:\n   1) An _Initial_Connection_Protocol_ (ICP) which\
    \ provides a convenient\n      standard method for several processes to gain simultaneous\
    \ access\n      to some specific process (such as the \"logger\") at another Host.\n\
    \   2) A _Telecommunication_Network_ (TELNET) protocol which provides for\n  \
    \    the \"mapping\" of an arbitrary keyboard-printer terminal into a\n      Network\
    \ Virtual Terminal (NVT), to facilitate communication\n      between a terminal\
    \ user at one Host site and a terminal-serving\n      process at some other site\
    \ which \"expects\" to be connected to a\n      (local) terminal logically different\
    \ from the (remote) terminal\n      actually in use.  The TELNET protocol specifies\
    \ use of the ICP to\n      establish the communication path between the terminal\
    \ user and the\n      terminal-service process.\n   3) A _Data_Transfer_ protocol\
    \ to specify standard methods of\n      formatting data for shipment through the\
    \ network.\n   4) A _File_Transfer_ protocol to specify methods for reading,\n\
    \      writing, and updating files stored at a remote Host.  The File\n      Transfer\
    \ protocol specifies that the actual transmission of data\n      should be performed\
    \ in accordance with the Data Transfer protocol.\n   5) A _Graphics_ protocol\
    \ to specify the means for exchanging graphics\n      display information.\n \
    \  6) A _Remote_Job_Service_ (RJS) protocol to specify methods for\n      submitting\
    \ input to, obtaining output from, and exercising control\n      over Hosts which\
    \ provide batch processing facilities.\n   The remainder of this document describes\
    \ and specifies the Host/Host,\n   or second level, protocol as formulated by\
    \ the Network Working Group.\n                        II.  COMMUNICATION CONCEPTS\n\
    \   The IMP sub-network imposes a number of physical restrictions on\n   communications\
    \ between Hosts; these restrictions are presented in BBN\n   Report Number 1822.\
    \  In particular, the concepts of leaders,\n   messages, padding, links, and message\
    \ types are of interest to the\n   design of Host/Host protocol.  The following\
    \ discussion assumes that\n   the reader is familiar with these concepts.\n  \
    \ Although there is little uniformity among the Hosts in either\n   hardware or\
    \ operating systems, the notion of multiprogramming\n   dominates most of the\
    \ systems.  These Hosts can each concurrently\n   support several users, with\
    \ each user running one or more processes.\n   Many of these processes may want\
    \ to use the network concurrently, and\n   thus a fundamental requirement of the\
    \ Host/Host protocol is to\n   provide for process-to-process communication over\
    \ the network.  Since\n   the first level protocol only takes cognizance of Hosts,\
    \ and since\n   the several processes in execution within a Host are usually\n\
    \   independent, it is necessary for the second level protocol to provide\n  \
    \ a richer addressing structure.\n   Another factor which influenced the Host/Host\
    \ protocol design is the\n   expectation that typical process-to-process communication\
    \ will be\n   based, not on a solitary message, but rather upon a sequence of\n\
    \   messages.  One example is the sending of a large body of information,\n  \
    \ such as a data base, from one process to another.  Another example is\n   an\
    \ interactive conversation between two processes, with many\n   exchanges.\n \
    \  These considerations led to the introduction of the notions of\n   connections,\
    \ a Network Control Program, a \"control link\", \"control\n   commands\", connection\
    \ byte size, message headers, and sockets.\n   A _connection_ is an extension\
    \ of a link.  A connection couples two\n   processes so that output from one process\
    \ is input to the other.\n   Connections are defined to be simplex (i.e., unidirectional),\
    \ so two\n   connections are necessary if a pair of processes are to converse\
    \ in\n   both directions.\n   Processes within a Host are envisioned as communicating\
    \ with the rest\n   of the network through a _Network_Control_Program_ (NCP),\
    \ resident in\n   that Host, which implements the second level protocol.  The\
    \ primary\n   function of the NCP is to establish connections, break connections,\n\
    \   and control data flow over the connections.  We will describe the NCP\n  \
    \ as though it were part of the operating system of a Host supporting\n   multiprogramming,\
    \ although the actual method of implementing the NCP\n   may be different in some\
    \ Hosts.\n   In order to accomplish its tasks, the NCP of one Host must\n   communicate\
    \ with the NCPs of other Hosts.  To this end, a particular\n   link between each\
    \ pair of Hosts has been designated as the\n   _control_link._  Messages transmitted\
    \ over the control link are\n   called _control_messages_*, and must always be\
    \ interpreted by an NCP\n   as a sequence of one or more _control_commands_. \
    \ For example, one\n   kind of control command is used to initiate a connection,\
    \ while\n   another kind carries notification that a connection has been\n   terminated.\n\
    \      [*Note that in BBN Report Number 1822, messages of non-zero type\n    \
    \  are called control messages, and are used to control the flow of\n      information\
    \ between a Host and its IMP.  In this document, the\n      term \"control message\"\
    \ is used for a message of type zero\n      transmitted over the control link.\
    \  The IMPs take no special\n      notice of these messages.]\n   The concept\
    \ of a message, as used above, is an artifact of the IMP\n   sub-network; network\
    \ message boundaries may have little intrinsic\n   meaning to communicating processes.\
    \  Accordingly, it has been decided\n   that the NCP (rather than each transmitting\
    \ process) should be\n   responsible for segmenting interprocess communication\
    \ into network\n   messages.  Therefore, it is a principal of the second level\
    \ protocol\n   that no significance may be inferred from message boundaries by\
    \ a\n   receiving process.  _The_only_exception_to_this_principle_is_in_\n   _control_messages,_each_of_which_must_contain_an_integral_number_of_\n\
    \   _control_commands._\n   Since message boundaries are selected by the transmitting\
    \ NCP, the\n   receiving NCP must be prepared to concatenate successive messages\n\
    \   from the network into a single (or differently divided) transmission\n   for\
    \ delivery to the receiving process.  The fact that Hosts have\n   different word\
    \ sizes means that a message from the network might end\n   in the middle of a\
    \ word at the receiving end, and thus the\n   concatenation of the next message\
    \ might require the receiving Host to\n   carry out extensive bit-shifting.  Because\
    \ bit-shifting is typically\n   very costly in terms of computer processing time,\
    \ the protocol\n   includes the notions of connection byte size and message headers.\n\
    \   As part of the process of establishing a connection, the processes\n   involved\
    \ must agree on a _connection_byte_size._  Each message sent\n   over the connection\
    \ must then contain an integral number of bytes of\n   this size.  Thus the pair\
    \ of processes involved in a connection can\n   choose a mutually convenient byte\
    \ size, for example, the least common\n   multiple of their Host word lengths.\
    \  It is important to note that\n   the ability to choose a byte size _must_ be\
    \ available to the\n   processes involved in the connection; an NCP is prohibited\
    \ from\n   imposing an arbitrary byte size on any process running in its own\n\
    \   Host.  In particular, an outer layer of protocol may specify a byte\n   size\
    \ to be used by that protocol.  If some NCP is unable to handle\n   that byte\
    \ size, then the outer layer of protocol will not be\n   implementable on that\
    \ Host.\n   The IMP sub-network requires that the first 32 bits of each message\n\
    \   (called the leader) contain addressing information, including\n   destination\
    \ Host address and link number.  The second level protocol\n   extends the required\
    \ information at the beginning of each message to\n   a total of 72 bits; these\
    \ 72 bits are called the _message_header._  A\n   length of 72 bits is chosen\
    \ since most Hosts either can work\n   conveniently with 8-bit units of data or\
    \ have word lengths of 18 or\n   36 bits; 72 is the least common multiple of these\
    \ lengths.  Thus, the\n   length chosen for the message header should reduce bit-shifting\n\
    \   problems for many Hosts.  In addition to the leader, the message\n   header\
    \ includes a field giving the byte size used in the message, a\n   field giving\
    \ the number of bytes in the message, and \"filler\" fields.\n   The format of\
    \ the message header is fully described in Section IV.\n   Another major concern\
    \ of the second level protocol is a method for\n   reference to processes in other\
    \ Hosts.  Each Host has some internal\n   scheme for naming processes, but these\
    \ various schemes are typically\n   different and may even be incompatible.  Since\
    \ it is not practical to\n   impose a common internal process naming scheme, a\
    \ standard\n   intermediate name space is used, with a separate portion of the\
    \ name\n   space allocated to each Host.  Each Host must have the ability to map\n\
    \   internal process identifiers into its portion of this name space.\n   The\
    \ elements of the name space are called _sockets._  A socket forms\n   one end\
    \ of a connection, and a connection is fully specified by a\n   pair of sockets.\
    \  A socket is identified by a Host number and a\n   32-bit socket number.  The\
    \ same 32-bit number in different Hosts\n   represents different sockets.\n  \
    \ A socket is either a _receive_socket_ or a _send_socket,_ and is so\n   marked\
    \ by its low-order bit (0 = receive; 1 = send).  This property\n   is called the\
    \ socket's _gender._  The sockets at either end of a\n   connection must be of\
    \ opposite gender.  Except for the gender, second\n   level protocol places no\
    \ constraints on the assignment of socket\n   numbers within a Host.\n       \
    \                     III.  NCP FUNCTIONS\n   The functions of the NCP are to\
    \ establish connections, terminate\n   connections, control flow, transmit interrupts,\
    \ and respond to test\n   inquiries.  These functions are explained in this section,\
    \ and\n   control commands are introduced as needed.  In Section IV the formats\n\
    \   of all control commands are presented together.\n   Connection Establishment\n\
    \   ========================\n   The commands used to establish a connection are\
    \ STR (sender-to-\n   receiver) and RTS (receiver- to-sender).\n           8*\
    \         32               32           8\n        +----------------------------------------------+\n\
    \        | STR |   send socket  | receive socket | size |\n        +----------------------------------------------+\n\
    \      [*The number shown above each control command field is the length\n   \
    \   of that field in bits.]\n           8          32               32       \
    \    8\n        +----------------------------------------------+\n        | RTS\
    \ | receive socket |  send socket   | link |\n        +----------------------------------------------+\n\
    \   The STR command is sent from a prospective sender to a prospective\n   receiver,\
    \ and the RTS from a prospective receiver to a prospective\n   sender.  The send\
    \ socket field names a socket local to the\n   prospective sender; the receive\
    \ socket field names a socket local to\n   the prospective receiver.  In the STR\
    \ command, the \"size\" field\n   contains an unsigned binary number (in the range\
    \ 1 to 255; zero is\n   prohibited) specifying the byte size to be used for all\
    \ messages over\n   the connection.  In the RTS command, the \"link\" field specifies\
    \ a\n   link number; all messages over the connection must be sent over the\n\
    \   link specified by this number.  These two commands are referred to as\n  \
    \ requests-for-connection (RFCs).  An STR and an RTS match if the\n   receive\
    \ socket fields match and the send socket fields match.  A\n   connection is established\
    \ when a matching pair of RFCs have been\n   exchanged.  _Hosts_are_prohibited_from_establishing_more_than_one_\n\
    \   _connection_to_any_local_socket._\n   With respect to a particular connection,\
    \ the Host containing the send\n   socket is called the _sending_Host_ and the\
    \ Host containing the\n   receive socket is called the _receiving_Host._  A Host\
    \ may connect\n   one of its receive sockets to one of its send sockets, thus\
    \ becoming\n   both the sending Host and the receiving Host for that connection.\n\
    \   These terms apply only to data flow; control messages will, in\n   general,\
    \ be transmitted in both directions.\n   A Host sends an RFC either to request\
    \ a connection, or to accept a\n   foreign Host's request.  Since RFC commands\
    \ are used both for\n   requesting and for accepting the establishment of a connection,\
    \ it is\n   possible for either of two cooperating processes to initiate\n   connection\
    \ establishment.  As a consequence, a family of processes\n   may be created with\
    \ connection-initiating actions built-in, and the\n   processes within this family\
    \ may be started up (in different Hosts)\n   in arbitrary order provided that\
    \ appropriate queueing is performed by\n   the Hosts involved (see below).\n \
    \  _There_is_no_prescribed_lifetime_for_an_RFC._  A Host is permitted to\n   queue\
    \ incoming RFCs and withhold a response for an arbitrarily long\n   time, or,\
    \ alternatively, to reject requests (see Connection\n   Termination below) immediately\
    \ if it does not have a matching RFC\n   outstanding.  It may be reasonable, for\
    \ example, for an NCP to queue\n   an RFC that refers to some currently unused\
    \ socket until a local\n   process takes control of that socket number and tells\
    \ the NCP to\n   accept or reject the request.  Of course, the Host which sent\
    \ the RFC\n   may be unwilling to wait for an arbitrarily long time, so it may\n\
    \   abort the request.  On the other hand, some NCP implementations may\n   not\
    \ include any space for queueing RFCs, and thus can be expected to\n   reject\
    \ RFCs unless the RFC sequence was initiated locally.\n   _Queueing_Considerations_\n\
    \   The decision to queue, or not queue, incoming RFCs has important\n   implications\
    \ which NCP implementers must not ignore.  Each RFC which\n   is queued, of course,\
    \ requires a small amount of memory in the Host\n   doing the queueing.  If each\
    \ incoming RFC is queued until a local\n   process seizes the local socket and\
    \ accepts (or rejects) the RFC, but\n   no local process ever seizes the socket,\
    \ the RFC must be queued\n   \"forever.\"  Theoretically this could occur infinitely\
    \ many times\n   (there is no reason not to queue several RFCs for a single local\n\
    \   socket, letting the local process decide which, if any, to accept)\n   thus\
    \ requiring infinite storage for the RFC queue.  On the other\n   hand, if no\
    \ queueing is performed the cooperating processes described\n   above will be\
    \ able to establish a desired connection only by accident\n   (when they are started\
    \ up such that one issues its RFC while the RFC\n   of the other is in transit\
    \ in the network -- clearly an unlikely\n   occurrence).\n   Perhaps the most\
    \ reasonable solution to the problems posed above is\n   for _each_ NCP to give\
    \ processes running in its own Host two options\n   for attempting to initiate\
    \ connections.  The first option would allow\n   a process to cause an RFC to\
    \ be sent to a specified remote socket;\n   with the NCP notifying the process\
    \ as to whether the RFC were\n   accepted or rejected by the remote Host.  The\
    \ second option would\n   allow a process to tell _its_own_ NCP to \"listen\"\
    \ for an RFC to a\n   specified local socket from some remote socket (the process\
    \ might\n   also specify the particular remote socket and/or Host it wishes to\n\
    \   communicate with) and to accept the RFC (i.e., return a matching RFC)\n  \
    \ if and when it arrives.  Note that this also involves queueing (of\n   \"listen\"\
    \ requests), but it is internal queueing which is susceptible\n   to reasonable\
    \ management by the local Host.  If this implementation\n   were available, one\
    \ of two cooperating processes could \"listen\" while\n   the other process caused\
    \ a series of RFCs to be sent to the\n   \"listening\" socket until one was accepted.\
    \  Thus, no queueing of\n   incoming RFCs would be required, although it would\
    \ do no harm.\n   _It_is_the_intent_of_the_protocol_that_each_NCP_should_provide_\n\
    \   _either_the_\"listen\"_option_described_above_or_a_SUBSTANTIAL_\n   _queueing_facility._\
    \  This is not, however, an absolute requirement\n   of the protocol.\n   Connection\
    \ Termination\n   ======================\n   The command used to terminate a connection\
    \ is CLS (close).\n           8        32            32\n        +-----+-------------+-------------+\n\
    \        | CLS |  my socket  | your socket |\n        +-----+-------------+-------------+\n\
    \   The \"my socket\" field contains the socket local to the sender of the\n \
    \  CLS command.  The \"your socket\" field contains the socket local to\n   the\
    \ receiver of the CLS command.  _Each_side_must_send_and_receive_a_\n   _CLS_command_before_connection_termination_is_completed_and_the_\n\
    \   _sockets_are_free_to_participate_in_other_connections._\n   It is not necessary\
    \ for a connection to be established (i.e., for\n   _both_ RFCs to be exchanged)\
    \ before connection termination begins.\n   For example, if a Host wishes to refuse\
    \ a request for connection, it\n   sends back a CLS instead of a matching RFC.\
    \  The refusing Host then\n   waits for the initiating Host to acknowledge the\
    \ refusal by returning\n   a CLS.  Similarly, if a Host wishes to abort its outstanding\
    \ request\n   for a connection, it sends a CLS command.  The foreign Host is\n\
    \   obliged to acknowledge the CLS with its own CLS.  Note that even\n   though\
    \ the connection was never established, CLS commands must be\n   exchanged before\
    \ the sockets are free for other use.\n   After a connection is established, CLS\
    \ commands sent by the receiver\n   and sender have slightly different effects.\
    \  CLS commands sent by the\n   sender indicate that no more messages will be\
    \ sent over the\n   connection.  _This_command_must_not_be_sent_if_there_is_a_message_\n\
    \   _in_transit_over_the_connection._  A CLS command sent by the receiver\n  \
    \ acts as a demand on the sender to terminate transmission.  However,\n   since\
    \ there is a delay in getting the CLS command to the sender, the\n   receiver\
    \ must expect more input.\n   A Host should \"quickly\" acknowledge an incoming\
    \ CLS so the foreign\n   Host can purge its tables.  However, _there_is_no_prescribed_time_\n\
    \   _period_in_which_a_CLS_must_be_acknowledged._\n   Because the CLS command\
    \ is used both to initiate closing, aborting\n   and refusing a connection, and\
    \ to acknowledge closing, aborting and\n   refusing a connection, race conditions\
    \ can occur.  However, they do\n   not lead to ambiguous or erroneous results,\
    \ as illustrated in the\n   following examples.\n      EXAMPLE 1: Suppose that\
    \ Host A sends Host B a request for\n      connection, and then A sends a CLS\
    \ to Host B because it is tired\n      of waiting for a reply.  However, just\
    \ when A sends its CLS to B,\n      B sends a CLS to A to refuse the connection.\
    \  A will \"believe\" B\n      is acknowledging the abort, and B will \"believe\"\
    \ A is\n      acknowledging its refusal, but the outcome will be correct.\n  \
    \    EXAMPLE 2: Suppose that Host A sends Host B an RFC followed by a\n      CLS\
    \ as in example 1.  In this case, however, B sends a matching\n      RFC to A\
    \ just when A sends its CLS.  Host A may \"believe\" that the\n      RFC is an\
    \ attempt (on the part of B) to establish a new connection\n      or may understand\
    \ the race condition; in either case it can\n      discard the RFC since its socket\
    \ is not yet free.  Host B will\n      \"believe\" that the CLS is breaking an\
    \ _established_ connection,\n      but the outcome is correct since a matching\
    \ CLS is the required\n      response, and both A and B will then terminate the\
    \ connection.\n   Every NCP implementation is faced with the problem of what to\
    \ do if a\n   matching CLS is not returned \"quickly\" by a foreign Host (i.e.,\
    \ if\n   the foreign Host appears to be violating protocol in this respect).\n\
    \   One naive answer is to hold the connection in a partially closed\n   state\
    \ \"forever\" waiting for a matching CLS.  There are two\n   difficulties with\
    \ this solution.  First, the socket involved may be a\n   \"scarce resource\"\
    \ such as the \"logger\" socket specified by an Initial\n   Connection Protocol\
    \ (see NIC # 7101) which the local Host cannot\n   afford to tie up indefinitely.\
    \  Second, a partially broken (or\n   malicious) process in a foreign Host may\
    \ send an unending stream of\n   RFCs which the local Host wishes to refuse by\
    \ sending CLS commands\n   and waiting for a match.  This could, in worst cases,\
    \ require 2^32 !\n   socket pairs to be stored before duplicates began to appear.\n\
    \   Clearly, no Host is prepared to store (or search) this much\n   information.\n\
    \   A second possibility sometimes suggested is for the Host which is\n   waiting\
    \ for matching CLS commands (Host A) to send a RST (see page\n   20) to the offending\
    \ Host (Host B), thus allowing all tables to be\n   reinitialized at both ends.\
    \  This would be rather unsatisfactory to\n   any user at Host A who happened\
    \ to be performing useful work on Host\n   B via network connections, since these\
    \ connections would also be\n   broken by the RST.\n   Most implementers, recognizing\
    \ these problems, have adopted some\n   unofficial timeout period after which\
    \ they \"forget\" a connection even\n   if a matching CLS has not been received.\
    \  The danger with such an\n   arrangement is that if a second connection between\
    \ the same pair of\n   sockets is later established, and a CLS finally arrives\
    \ for the first\n   connection, the second connection is likely to be closed.\
    \  This\n   situation can only arise, however, if one Host violates protocol in\n\
    \   two ways; first by failing to respond quickly to an incoming CLS, and\n  \
    \ second by permitting establishment of a connection involving a socket\n   which\
    \ it believes is already in use.  It has been suggested that the\n   network adopt\
    \ some standard timeout period, but the NWG has been\n   unable to arrive at a\
    \ period which is both short enough to be useful\n   and long enough to be acceptable\
    \ to every Host.  Timeout periods in\n   current use seem to range between approximately\
    \ one minute and\n   approximately five minutes.  _It_must_be_emphasized_that_all_timeout_\n\
    \   _periods,_although_they_are_relatively_common,_reasonably_safe,_and_\n   _quite_useful,_are_in_violation_of_the_protocol_since_their_use_can_\n\
    \   _lead_to_connection_ambiguities._\n   Flow Control\n   ============\n   After\
    \ a connection is established, the sending Host sends messages\n   over the agreed-upon\
    \ link to the receiving Host.  The receiving NCP\n   accepts messages from its\
    \ IMP and queues them for its various\n   processes.  Since it may happen that\
    \ the messages arrive faster than\n   they can be processed, some mechanism is\
    \ required which permits the\n   receiving Host to quench the flow from the sending\
    \ Host.\n   The flow control mechanism requires the receiving Host to allocate\n\
    \   buffer space for each connection and to notify the sending Host of\n   how\
    \ much space is available.  The sending Host keeps track of how\n   much room\
    \ is available and never sends more data than it believes the\n   receiving Host\
    \ can accept.\n   To implement this mechanism, the sending Host keeps two counters\n\
    \   associated with each connection, a _message_counter_ and a\n   _bit_counter._\
    \  Each counter is initialized to zero when the\n   connection is established\
    \ and is increased by allocate (ALL) control\n   commands sent from the receiving\
    \ Host as described below.  When\n   sending a message, the NCP of the sending\
    \ Host subtracts one from the\n   message counter and the _text_length_ (defined\
    \ below) from the bit\n   counter.  The sender is prohibited from sending if either\
    \ counter\n   would be decremented below zero.  The sending Host may also return\n\
    \   all or part of the message or bit space allocation with a return\n   (RET)\
    \ command upon receiving a give-back (GVB) command from the\n   receiving Host\
    \ (see below).\n   The _text_length_ of a message is defined as the product of\
    \ the\n   connection byte size and the byte count for the message; both of\n \
    \  these quantities appear in the message header.  Messages with a zero\n   byte\
    \ count, hence a zero text length, are specifically permitted.\n   Messages with\
    \ zero text length do not use bit space allocation, but\n   do use message space\
    \ allocation.  The flow control mechanisms do not\n   pertain to the control link,\
    \ since connections are never explicitly\n   established over this link.\n   The\
    \ control command used to increase the sender's bit counter and\n   message counter\
    \ is ALL (allocate).\n           8      8       16           32\n        +------------------------------------+\n\
    \        | ALL | link | msg space | bit space |\n        +------------------------------------+\n\
    \   This command is sent only from the receiving Host to the sending\n   Host,\
    \ and is legal only when a connection using the link number\n   appearing in the\
    \ \"link\" field is established.  The \"msg space\" field\n   and the \"bit space\"\
    \ field are defined to be unsigned binary integers\n   specifying the amounts\
    \ by which the sender's message counter and bit\n   counter (respectively) are\
    \ to be incremented.  The receiver is\n   prohibited from incrementing the sender's\
    \ counter above (2^16 - 1),\n   or the sender's bit counter above (2^32 - 1).\
    \  In general, this rule\n   will require the receiver to maintain counters which\
    \ are incremented\n   and decremented according to the same rules as the sender's\
    \ counters.\n   The receiving Host may request that the sending Host return all\
    \ or\n   part of its current allocation.  The control command for this request\n\
    \   is GVB (give-back).\n           8      8    8    8\n        +----------------------+\n\
    \        | GVB | link | fm | fb |\n        +----------------------+\n   This command\
    \ is sent only from the receiving Host to the sending\n   Host, and is legal only\
    \ when a connection using the link number in\n   the \"link\" field is established.\
    \  The fields fm and fb are defined as\n   the fraction (in 128ths) of the current\
    \ message space allocation and\n   bit space allocation (respectively) to be returned.\
    \  If either of the\n   fractions is equal to or greater than one, _all_ of the\
    \ corresponding\n   allocation must be returned.  Fractions are used since, with\
    \ messages\n   in transit, the sender and receiver may not agree on the actual\n\
    \   allocation at every point in time.\n   Upon receiving a GVB command, the sending\
    \ Host must return _at_\n   _least_* the requested portions of the message and\
    \ bit space\n   allocations.  (A sending Host is prohibited from spontaneously\n\
    \   returning portions of the message and bit space allocations.)  The\n   control\
    \ command for performing this function is RET (return).\n      [*In particular,\
    \ fractional returns must be rounded up, not\n      truncated.]\n           8\
    \      8       16           32\n        +------------------------------------+\n\
    \        | RET | link | msg space | bit space |\n        +------------------------------------+\n\
    \   This command is sent only from the sending Host to the receiving\n   Host,\
    \ and is legal only when a connection using the link number in\n   the \"link\"\
    \ field is established and a GVB command has been received\n   from the receiving\
    \ Host.  The \"msg space\" field and the \"bit space\"\n   field are defined as\
    \ unsigned binary integers specifying the amounts\n   by which the sender's message\
    \ counter and bit counter (respectively)\n   have been decremented due to the\
    \ RET activity (i.e., the amounts of\n   message and bit space allocation being\
    \ returned).  NCPs are obliged\n   to answer a GVB with a RET \"quickly\"; however,\
    \ there is _no_\n   prescribed time period in which the answering RET must be\
    \ sent.\n   Some Hosts will allocate only as much space as they can guarantee\
    \ for\n   each link.  These Hosts will tend to use the GVB command only to\n \
    \  reclaim space which is being filled very slowly or not at all.  Other\n   Hosts\
    \ will allocate more space than they have, so that they may use\n   their space\
    \ more efficiently.  Such a Host will then need to use the\n   GVB command when\
    \ the input over a particular link comes faster than\n   it is being processed.\n\
    \   Interrupts\n   ==========\n   The second level protocol has included a mechanism\
    \ by which the\n   transmission over a connection may be \"interrupted.\" The\
    \ meaning of\n   the \"interrupt\" is not defined at this level, but is made available\n\
    \   for use by outer layers of protocol.  The interrupt command sent from\n  \
    \ the receiving Host to the sending Host is INR (interrupt-by-\n   receiver).\n\
    \           8      8\n        +------------+\n        | INR | link |\n       \
    \ +------------+\n   The interrupt command sent from the sending Host to the receiving\n\
    \   Host is INS (interrupt-by-sender).\n           8      8\n        +------------+\n\
    \        | INS | link |\n        +------------+\n   The INR and INS commands are\
    \ legal only when a connection using the\n   link number in the \"link\" field\
    \ is established.\n   Test Inquiry\n   ============\n   It may sometimes be useful\
    \ for one Host to determine if some other\n   Host is capable of carrying on network\
    \ conversations.  The control\n   command to be used for this purpose is ECO (echo).\n\
    \           8      8\n        +------------+\n        | ECO | data |\n       \
    \ +------------+\n   The \"data\" field may contain any bit configuration chosen\
    \ by the Host\n   sending the ECO.  Upon receiving an ECO command an NCP must\
    \ respond\n   by returning the data to the sender in an ERP (echo-reply) command.\n\
    \           8      8\n        +------------+\n        | ERP | data |\n       \
    \ +------------+\n   A Host should \"quickly\" respond (with an ERP command) to\
    \ an incoming\n   ECO command.  However, there is no prescribed time period, after\
    \ the\n   receipt of an ECO, in which the ERP must be returned.  A Host is\n \
    \  prohibited from sending an ERP when no ECO has been received, or from\n   sending\
    \ an ECO to a Host while a previous ECO to that Host remains\n   \"unanswered.\"\
    \  Any of the following constitute an \"answer\" to an ECO:\n   information from\
    \ the local IMP that the ECO was discarded by the\n   network (e.g., IMP/Host\
    \ message type 7 - Destination Dead), ERP, RST,\n   or RRP (see below).\n   Reinitialization\n\
    \   ================\n   Occasionally, due to lost control messages, system \"\
    crashes\", NCP\n   errors, or other factors, communication between two NCPs will\
    \ be\n   disrupted.  One possible effect of any such disruption might be that\n\
    \   neither of the involved NCPs could be sure that its stored\n   information\
    \ regarding connections with the other Host matched the\n   information stored\
    \ by the NCP of the other Host.  In this situation,\n   an NCP may wish to reinitialize\
    \ its tables and request that the other\n   Host do likewise; for this purpose\
    \ the protocol provides the pair of\n   control commands RST (reset) and RRP (reset-reply).\n\
    \           8\n        +-----+\n        | RST |\n        +-----+\n           8\n\
    \        +-----+\n        | RRP |\n        +-----+\n   The RST command is to be\
    \ interpreted by the Host receiving it as a\n   signal to purge its NCP tables\
    \ of any entries which arose from\n   communication with the Host which sent the\
    \ RST.  The Host sending the\n   RST should likewise purge its NCP tables of any\
    \ entries which arise\n   from communication with the Host to which the RST was\
    \ sent.  The Host\n   receiving the RST should acknowledge receipt by returning\
    \ an RRP.\n   _Once_the_first_Host_has_sent_an_RST_to_the_second_Host,_the_first_\n\
    \   _Host_is_not_obliged_to_communicate_with_the_second_Host_(except_for_\n  \
    \ _responding_to_RST)_until_the_second_Host_returns_an_RRP._  In fact,\n   to\
    \ avoid synchronization errors, the first Host _should_not_\n   communicate with\
    \ the second until the RST is answered.  Of course, if\n   the IMP subnetwork\
    \ returns a \"Destination Dead\" (type 7) message in\n   response to the control\
    \ message containing the RST, an RRP should not\n   be expected.  If both NCPs\
    \ decide to send RSTs at approximately the\n   same time, then each Host will\
    \ receive an RST and each must answer\n   with an RRP, even though its own RST\
    \ has not yet been answered.\n   Some Hosts may choose to \"broadcast\" RSTs to\
    \ the entire network when\n   they \"come up.\" One method of accomplishing this\
    \ would be to send an\n   RST command to each of the 256 possible Host addresses;\
    \ the IMP\n   subnetwork would return a \"Destination Dead\" (type 7) message\
    \ for\n   each non-existent Host, as well as for each Host actually \"dead.\"\n\
    \   _However,_no_Host_is_ever_obliged_to_transmit_an_RST_command._\n   Hosts are\
    \ prohibited from sending an RRP when no RST has been\n   received.  Further,\
    \ Hosts may send only one RST in a single control\n   message and should wait\
    \ a \"reasonable time\" before sending another\n   RST to the same Host.  Under\
    \ these conditions, a single RRP\n   constitutes an \"answer\" to _all_ RSTs sent\
    \ to that Host, and any\n   other RRPs arriving from that Host should be discarded.\n\
    \                      IV.  DECLARATIVE SPECIFICATIONS\n   Message Format\n  \
    \ ==============\n   All Host-to-Host messages (i.e., messages of type zero) shall\
    \ have a\n   header 72 bits long consisting of the following fields (see Figure\n\
    \   1):\n      Bits 1-32   Leader - The contents of this field must be\n     \
    \             constructed according to the specifications contained\n        \
    \          in BBN Report Number 1822.\n      Bits 33-40  Field M1 - Must be zero.\n\
    \      Bits 41-48  Field S - Connection byte size.  This size must be\n      \
    \            identical to the byte size in the STR used in\n                 \
    \ establishing the connection.  If this message is being\n                  transmitted\
    \ over the control link the connection byte\n                  size must be 8.\n\
    \      Bits 49-64  Field C - Byte Count.  This field specifies the number\n  \
    \                of bytes in the text portion of the message.  A zero\n      \
    \            value in the C field is explicitly permitted.\n      Bits 65-72 \
    \ Field M2 - Must be zero.\n   Following the header, the message shall consist\
    \ of a text field of C\n   bytes, where each byte is S bits in length.  Following\
    \ the text there\n   will be field M3 followed by padding.  The M3 field is zero\
    \ or more\n   bits long and must be all zero; this field may be used to fill out\
    \ a\n   message to a word boundary.\n   |<---------------------------32 bits--------------------------->|\n\
    \   |<----8 bits--->|<----8 bits--->|<-----------16 bits----------->|\n   +---------------------------------------------------------------+\n\
    \   |                                                               |\n   |  \
    \                           LEADER                            |\n   |        \
    \                                                       |\n   +---------------------------------------------------------------|\n\
    \   |               |               |                               |\n   |  \
    \  FIELD M1   |    FIELD S    |            FIELD C            |\n   |        \
    \       |               |                               |\n   +---------------+---------------+-------------------------------+\n\
    \   |               |               ^                               |\n   |  \
    \  FIELD M2   |               |                               |\n   |        \
    \       |               |                               |\n   +---------------+\
    \               |                               |\n   |                      \
    \         |                               |\n   |                            \
    \   |                               |\n   |                               |  \
    \                             |\n   |                               |        \
    \                       |\n   |                             TEXT             \
    \                 |\n   |                               |                    \
    \           |\n   |                               |                          \
    \     |\n   |                               |                               |\n\
    \   |                               |                               |\n   |  \
    \                             |          +--------------------+\n   |        \
    \                       |          |                    |\n   |              \
    \                 |          |      FIELD M3      |\n   |                    \
    \           V          |                    |\n   +-----------------------------------+------+--------------------+\n\
    \   |                                   |\n   |      10-----------------0    \
    \     |<-------PADDING\n   |                                   |\n   +-----------------------------------+\n\
    \                               Figure 1\n                               ========\n\
    \   The message header must, among other things, enable the NCP at the\n   receiving\
    \ Host to identify correctly the connection over which the\n   message was sent.\
    \  Given a set of messages from Host A to Host B, the\n   only field in the header\
    \ under the control of the NCP at Host B is\n   the link number (assigned via\
    \ the RTS control command).  Therefore,\n   each NCP must insure that, at a given\
    \ point in time, for each\n   connection for which it is the receiver, a unique\
    \ link is assigned.\n   Recall that the link is specified by the sender's address\
    \ and the\n   link number; thus a unique link number must be assigned to each\n\
    \   connection to a given Host.\n   Link Assignment\n   ===============\n    \
    \  Links are assigned as follows:\n      Link number    Assignment\n      ===========\
    \    ==========\n      0              Control link\n      2-71           Available\
    \ for connections\n      1, 72-190      Reserved - not for current use\n     \
    \ 191            To be used only for measurement work under the\n            \
    \         direction of the Network Measurement Center at UCLA\n      192-255 \
    \       Available for private experimental use.\n   Control Messages\n   ================\n\
    \   Messages sent over the control link have the same format as other\n   Host-to-Host\
    \ messages.  The connection byte size (Field S in the\n   message header) must\
    \ be 8.  Control messages may not contain more\n   than 120 bytes of text; thus\
    \ the value of the byte count (Field C in\n   the message header) must be less\
    \ than or equal to 120.\n   Control messages must contain an integral number of\
    \ control commands.\n   A single control command may not be split into parts which\
    \ are\n   transmitted in different control messages.\n   Control Commands\n  \
    \ ================\n   Each control command begins with an 8-bit _opcode._  These\
    \ opcodes\n   have values of 0, 1, ...  to permit table lookup upon receipt.\n\
    \   Private experimental protocols should be tested using opcodes of 255,\n  \
    \ 254, ...  Most of the control commands are more fully explained in\n   Section\
    \ III.\n   NOP - No operation\n   ==================\n           8\n        +-----+\n\
    \        | NOP |\n        +-----+\n   The NOP command may be sent at any time\
    \ and should be discarded by\n   the receiver.  It may be useful for formatting\
    \ control messages.\n   RST - Reset\n   ===========\n           8\n        +-----+\n\
    \        | RST |\n        +-----+\n   The RST command is used by one Host to inform\
    \ another that all\n   information regarding previously existing connections,\
    \ including\n   partially terminated connections, between the two Hosts should\
    \ be\n   purged from the NCP tables of the Host receiving the RST.  Except for\n\
    \   responding to RSTs, the Host which sent the RST is not obliged to\n   communicate\
    \ further with the other Host until an RRP is received in\n   response.\n   RRP\
    \ - Reset reply\n   =================\n           8\n        +-----+\n       \
    \ | RRP |\n        +-----+\n   The RRP command must be sent in reply to an RST\
    \ command.\n   RTS - Request connection, receiver to sender\n   ============================================\n\
    \           8          32               32           8\n        +----------------------------------------------+\n\
    \        | RTS | receive socket |  send socket   | link |\n        +----------------------------------------------+\n\
    \   The RTS command is used to establish a connection and is sent from\n   the\
    \ Host containing the receive socket to the Host containing the\n   send socket.\
    \  The link number for message transmission over the\n   connection is assigned\
    \ with this command; the \"link\" field must be\n   between 2 and 71, inclusive.\n\
    \   STR - Request connection, sender to receiver\n   ============================================\n\
    \           8          32               32           8\n        +----------------------------------------------+\n\
    \        | STR |   send socket  | receive socket | size |\n        +----------------------------------------------+\n\
    \   The STR command is used to establish a connection and is sent from\n   the\
    \ Host containing the send socket to the Host containing the\n   receive socket.\
    \  The connection byte size is assigned with this\n   command; the size must be\
    \ between 1 and 255, inclusive.\n   CLS - Close\n   ===========\n           8\
    \        32            32\n        +-----+-------------+-------------+\n     \
    \   | CLS |  my socket  | your socket |\n        +-----+-------------+-------------+\n\
    \   The CLS command is used to terminate a connection.  A connection need\n  \
    \ not be completely established before a CLS is sent.\n   ALL - Allocate\n   ==============\n\
    \           8      8       16           32\n        +------------------------------------+\n\
    \        | ALL | link | msg space | bit space |\n        +------------------------------------+\n\
    \   The ALL command is sent from a receiving Host to a sending Host to\n   increase\
    \ the sending Host's space counters.  This command may be sent\n   only while\
    \ the connection is established.  The receiving Host is\n   prohibited from incrementing\
    \ the Host's message counter above\n   (2^16 - 1) or bit counter above (2^32 -\
    \ 1).\n   GVB - Give back\n   ===============\n           8      8    8    8\n\
    \        +----------------------+\n        | GVB | link | fm | fb |\n        +----------------------+\n\
    \                       ^    ^\n                       |    +--- bit fraction\n\
    \                       +-------- message fraction\n   The GVB command is sent\
    \ from a receiving Host to a sending Host to\n   request that the sending Host\
    \ return all or part of its message space\n   and/or bit space allocations.  The\
    \ \"fractions\" specify what portion\n   (in 128ths) of each allocation must be\
    \ returned.  This command may be\n   sent only while the connection is established.\n\
    \   RET - Return\n   ============\n           8      8       16           32\n\
    \        +------------------------------------+\n        | RET | link | msg space\
    \ | bit space |\n        +------------------------------------+\n   The RET command\
    \ is sent from the sending Host to the receiving Host\n   to return all or a part\
    \ of its message space and/or bit space\n   allocations in response to a GVB command.\
    \  This command may be sent\n   only while the connection is established.\n  \
    \ INR - Interrupt by receiver\n   ===========================\n           8  \
    \    8\n        +------------+\n        | INR | link |\n        +------------+\n\
    \   The INR command is sent from the receiving Host to the sending Host\n   when\
    \ the receiving process wants to interrupt the sending process.\n   This command\
    \ may be sent only while the connection is established.\n   INS - Interrupt by\
    \ sender\n   =========================\n           8      8\n        +------------+\n\
    \        | INS | link |\n        +------------+\n   The INS command is sent from\
    \ the sending Host to the receiving Host\n   when the sending process wants to\
    \ interrupt the receiving process.\n   This command may be sent only while the\
    \ connection is established.\n   ECO - Echo request\n   ==================\n \
    \          8      8\n        +------------+\n        | ECO | data |\n        +------------+\n\
    \   The ECO command is used only for test purposes.  The data field may\n   be\
    \ any bit configuration convenient to the Host sending the ECO\n   command.\n\
    \   ERP - Echo reply\n   ================\n           8      8\n        +------------+\n\
    \        | ERP | data |\n        +------------+\n   The ERP command must be sent\
    \ in reply to an ECO command.  The data\n   field must be identical to the data\
    \ field in the incoming ECO\n   command.\n   ERR - Error detected\n   ====================\n\
    \           8      8                    80\n        +-----+------+----------------------------\
    \ ~ -------------+\n        | ERR | code |                data               \
    \         |\n        +-----+------+---------------------------- ~ -------------+\n\
    \   The ERR command may be sent whenever a second level protocol error is\n  \
    \ detected in the input from another Host.  In the case that the error\n   condition\
    \ has a predefined error code, the \"code\" field specifies the\n   specific error,\
    \ and the data field gives parameters.  For other\n   errors the code field is\
    \ zero and the data field is idiosyncratic to\n   the sender.  Implementers of\
    \ Network Control Programs are expected to\n   publish timely information on their\
    \ ERR commands.\n   The usefulness of the ERR command is compromised if it is\
    \ merely\n   discarded by the receiver.  Thus, sites are urged to record incoming\n\
    \   ERRs if possible, and to investigate their cause in conjunction with\n   the\
    \ sending site.  The following codes are defined.  Additional codes\n   may be\
    \ defined later.\n      a. Undefined (Error code = 0)\n        The \"data\" field\
    \ is idiosyncratic to the sender.\n      b. Illegal opcode (Error code = 1)\n\
    \        An illegal opcode was detected in a control message.  The \"data\"\n\
    \        field contains the ten bytes of the control message beginning\n     \
    \   with the byte containing the illegal opcode.  If the remainder\n        of\
    \ the control message contains less than ten bytes, fill will\n        be necessary;\
    \ the value of the fill is zeros.\n      c. Short parameter space (Error code\
    \ = 2)\n        The end of a control message was encountered before all the\n\
    \        required parameters of the control command being decoded were\n     \
    \   found.  The \"data\" field contains the command in error; the\n        value\
    \ of any fill necessary is zeros.\n      d. Bad parameters (Error code = 3)\n\
    \        Erroneous parameters were found in a control command.  For\n        example,\
    \ two receive or two send sockets in an STR, RTS, or CLS;\n        a link number\
    \ outside the range 2 to 71 (inclusive); an ALL\n        containing a space allocation\
    \ too large.  The \"data\" field\n        contains the command in error; the value\
    \ of any fill necessary\n        is zeros.\n      e. Request on a non-existent\
    \ socket (Error code = 4)\n        A request other than STR or RTS was made for\
    \ a socket (or link)\n        for which no RFC has been transmitted in either\
    \ direction.  This\n        code is meant to indicate to the NCP receiving it\
    \ that functions\n        are being performed out of order.  The \"data\" field\
    \ contains the\n        command in error; the value of any fill necessary is zeros.\n\
    \      f. Socket (link) not connected (Error code = 5)\n        There are two\
    \ cases:\n        1.  A control command other than STR or RTS refers to a socket\n\
    \           (or link) which is not part of an established connection.\n      \
    \     This code would be used when one RFC had been transmitted,\n           but\
    \ the matching RFC had not.  It is meant to indicate the\n           failure of\
    \ the NCP receiving it to wait for a response to an\n           RFC.  The \"data\"\
    \ field contains the command in error; the\n           value of any fill necessary\
    \ is zeros.\n        2. A message was received over a link which is not currently\n\
    \           being used for any connection.  The contents of the \"data\"\n   \
    \        field are the message header followed by the first eight bits\n     \
    \      of text (if any) or zeros.\n   Opcode Assignment\n   =================\n\
    \   Opcodes are defined to be eight-bit unsigned binary numbers.  The\n   values\
    \ assigned to opcodes are:\n      NOP = 0\n      RTS = 1\n      STR = 2\n    \
    \  CLS = 3\n      ALL = 4\n      GVB = 5\n      RET = 6\n      INR = 7\n     \
    \ INS = 8\n      ECO = 9\n      ERP = 10\n      ERR = 11\n      RST = 12\n   \
    \   RRP = 13\n   Control Command Summary\n   =======================\n       \
    \    8\n        +-----+\n        | NOP |\n        +-----+\n           8      \
    \    32               32           8\n        +----------------------------------------------+\n\
    \        | RTS | receive socket |  send socket   | link |\n        +----------------------------------------------+\n\
    \           8          32               32           8\n        +----------------------------------------------+\n\
    \        | STR |   send socket  | receive socket | size |\n        +----------------------------------------------+\n\
    \           8        32            32\n        +-----+-------------+-------------+\n\
    \        | CLS |  my socket  | your socket |\n        +-----+-------------+-------------+\n\
    \           8      8       16           32\n        +------------------------------------+\n\
    \        | ALL | link | msg space | bit space |\n        +------------------------------------+\n\
    \           8      8    8    8\n        +----------------------+\n        | GVB\
    \ | link | fm | fb |\n        +----------------------+\n           8      8  \
    \     16           32\n        +------------------------------------+\n      \
    \  | RET | link | msg space | bit space |\n        +------------------------------------+\n\
    \           8      8\n        +------------+\n        | INR | link |\n       \
    \ +------------+\n           8      8\n        +------------+\n        | INS |\
    \ link |\n        +------------+\n           8      8\n        +------------+\n\
    \        | ECO | data |\n        +------------+\n           8      8\n       \
    \ +------------+\n        | ERP | data |\n        +------------+\n           8\
    \      8                    80\n        +-----+------+----------------------------\
    \ ~ -------------+\n        | ERR | code |                data               \
    \         |\n        +-----+------+---------------------------- ~ -------------+\n\
    \           8\n        +-----+\n        | RST |\n        +-----+\n           8\n\
    \        +-----+\n        | RRP |\n        +-----+\n   [ This is the end of the\
    \ January 1972 document. ]\n"
- title: 4.  Security Considerations
  contents:
  - "4.  Security Considerations\n   This document does not discuss any security considerations.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Alexander McKenzie\n   PMB #4334, PO Box 2428\n   Pensacola,\
    \ FL 32513\n   USA\n   EMail: amckenzie3@yahoo.com\n   Steve Crocker\n   5110\
    \ Edgemoor Lane\n   Bethesda, MD 20814\n   USA\n   EMail: steve@stevecrocker.com\n"
