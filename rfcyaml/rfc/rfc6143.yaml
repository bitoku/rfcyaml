- title: __initial_text__
  contents:
  - '                    The Remote Framebuffer Protocol

    '
- title: Abstract
  contents:
  - "Abstract\n   RFB (\"remote framebuffer\") is a simple protocol for remote access\
    \ to\n   graphical user interfaces that allows a client to view and control a\n\
    \   window system on another computer.  Because it works at the\n   framebuffer\
    \ level, RFB is applicable to all windowing systems and\n   applications.  This\
    \ document describes the protocol used to\n   communicate between an RFB client\
    \ and RFB server.  RFB is the\n   protocol used in VNC.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc6143.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  3\n   2.  Initial Connection . . . . . . . . . . . . . . . . .\
    \ . . . . .  4\n   3.  Display Protocol . . . . . . . . . . . . . . . . . . .\
    \ . . . .  4\n   4.  Input Protocol . . . . . . . . . . . . . . . . . . . . .\
    \ . . .  5\n   5.  Representation of Pixel Data . . . . . . . . . . . . . . .\
    \ . .  5\n   6.  Protocol Versions and Extensions . . . . . . . . . . . . . .\
    \ .  6\n   7.  Protocol Messages  . . . . . . . . . . . . . . . . . . . . . .\
    \  7\n     7.1.  Handshake Messages . . . . . . . . . . . . . . . . . . . .  8\n\
    \       7.1.1.  ProtocolVersion Handshake  . . . . . . . . . . . . . .  8\n  \
    \     7.1.2.  Security Handshake . . . . . . . . . . . . . . . . . .  8\n    \
    \   7.1.3.  SecurityResult Handshake . . . . . . . . . . . . . . . 10\n     7.2.\
    \  Security Types . . . . . . . . . . . . . . . . . . . . . . 10\n       7.2.1.\
    \  None . . . . . . . . . . . . . . . . . . . . . . . . . 10\n       7.2.2.  VNC\
    \ Authentication . . . . . . . . . . . . . . . . . . 10\n     7.3.  Initialization\
    \ Messages  . . . . . . . . . . . . . . . . . 11\n       7.3.1.  ClientInit .\
    \ . . . . . . . . . . . . . . . . . . . . . 11\n       7.3.2.  ServerInit . .\
    \ . . . . . . . . . . . . . . . . . . . . 11\n     7.4.  Pixel Format Data Structure\
    \  . . . . . . . . . . . . . . . 12\n     7.5.  Client-to-Server Messages  . .\
    \ . . . . . . . . . . . . . . 13\n       7.5.1.  SetPixelFormat . . . . . . .\
    \ . . . . . . . . . . . . . 13\n       7.5.2.  SetEncodings . . . . . . . . .\
    \ . . . . . . . . . . . . 14\n       7.5.3.  FramebufferUpdateRequest . . . .\
    \ . . . . . . . . . . . 15\n       7.5.4.  KeyEvent . . . . . . . . . . . . .\
    \ . . . . . . . . . . 16\n       7.5.5.  PointerEvent . . . . . . . . . . . .\
    \ . . . . . . . . . 19\n       7.5.6.  ClientCutText  . . . . . . . . . . . .\
    \ . . . . . . . . 19\n     7.6.  Server-to-Client Messages  . . . . . . . . .\
    \ . . . . . . . 20\n       7.6.1.  FramebufferUpdate  . . . . . . . . . . . .\
    \ . . . . . . 20\n       7.6.2.  SetColorMapEntries . . . . . . . . . . . . .\
    \ . . . . . 21\n       7.6.3.  Bell . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . 22\n       7.6.4.  ServerCutText  . . . . . . . . . . . . . . . . .\
    \ . . . 22\n     7.7.  Encodings  . . . . . . . . . . . . . . . . . . . . . .\
    \ . . 22\n       7.7.1.  Raw Encoding . . . . . . . . . . . . . . . . . . . .\
    \ . 23\n       7.7.2.  CopyRect Encoding  . . . . . . . . . . . . . . . . . .\
    \ 23\n       7.7.3.  RRE Encoding . . . . . . . . . . . . . . . . . . . . . 23\n\
    \       7.7.4.  Hextile Encoding . . . . . . . . . . . . . . . . . . . 24\n  \
    \     7.7.5.  TRLE . . . . . . . . . . . . . . . . . . . . . . . . . 27\n    \
    \   7.7.6.  ZRLE . . . . . . . . . . . . . . . . . . . . . . . . . 30\n     7.8.\
    \  Pseudo-Encodings . . . . . . . . . . . . . . . . . . . . . 30\n       7.8.1.\
    \  Cursor Pseudo-Encoding . . . . . . . . . . . . . . . . 30\n       7.8.2.  DesktopSize\
    \ Pseudo-Encoding  . . . . . . . . . . . . . 31\n   8.  IANA Considerations  .\
    \ . . . . . . . . . . . . . . . . . . . . 31\n     8.1.  RFB Security Types .\
    \ . . . . . . . . . . . . . . . . . . . 32\n       8.1.1.  Registry Name  . .\
    \ . . . . . . . . . . . . . . . . . . 32\n       8.1.2.  Registry Contents  .\
    \ . . . . . . . . . . . . . . . . . 32\n     8.2.  Client-to-Server Message Types\
    \ . . . . . . . . . . . . . . 32\n       8.2.1.  Registry Name  . . . . . . .\
    \ . . . . . . . . . . . . . 32\n       8.2.2.  Registry Contents  . . . . . .\
    \ . . . . . . . . . . . . 32\n     8.3.  Server-to-Client Message Types . . .\
    \ . . . . . . . . . . . 33\n       8.3.1.  Registry Name  . . . . . . . . . .\
    \ . . . . . . . . . . 33\n       8.3.2.  Registry Contents  . . . . . . . . .\
    \ . . . . . . . . . 33\n     8.4.  RFB Encoding Types . . . . . . . . . . . .\
    \ . . . . . . . . 34\n       8.4.1.  Registry Name  . . . . . . . . . . . . .\
    \ . . . . . . . 34\n       8.4.2.  Registry Contents  . . . . . . . . . . . .\
    \ . . . . . . 34\n   9.  Security . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . 36\n   10. Acknowledgements . . . . . . . . . . . . . . . . . . .\
    \ . . . . 36\n   11. References . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . 36\n     11.1. Normative References . . . . . . . . . . . . . . . . .\
    \ . . 36\n     11.2. Informative References . . . . . . . . . . . . . . . . .\
    \ . 36\n   Appendix A.  Differences in Earlier Protocol Versions  . . . . . .\
    \ 38\n     A.1.  Differences in the Version 3.3 Protocol  . . . . . . . . . 38\n\
    \     A.2.  Differences in the Version 3.7 Protocol  . . . . . . . . . 38\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   RFB (\"remote framebuffer\") is a simple protocol for remote\
    \ access to\n   graphical user interfaces.  Because it works at the framebuffer\n\
    \   level, it is applicable to all windowing systems and applications,\n   including\
    \ X11, Windows, and Macintosh.  RFB is the protocol used in\n   VNC.  The protocol\
    \ is widely implemented and has had fairly good\n   interoperability.\n   The\
    \ remote endpoint where the user sits (typically with a display,\n   keyboard,\
    \ and pointer) is called the RFB client or viewer.  The\n   endpoint where changes\
    \ to the framebuffer originate (i.e., the\n   windowing system and applications)\
    \ is known as the RFB server.\n   RFB is a \"thin client\" protocol.  The emphasis\
    \ in the design of the\n   RFB protocol is to make very few requirements of the\
    \ client.  In this\n   way, clients can run on the widest range of hardware, and\
    \ the task of\n   implementing a client is made as simple as possible.\n   The\
    \ protocol also makes the client stateless.  If a client\n   disconnects from\
    \ a given server and subsequently reconnects to that\n   same server, the state\
    \ of the user interface is preserved.\n   Furthermore, a different client endpoint\
    \ can be used to connect to\n   the same RFB server.  At the new endpoint, the\
    \ user will see exactly\n   the same graphical user interface as at the original\
    \ endpoint.  In\n   effect, the interface to the user's applications becomes completely\n\
    \   mobile.  Wherever suitable network connectivity exists, the user can\n   access\
    \ their own personal applications, and the state of these\n   applications is\
    \ preserved between accesses from different locations.\n   This provides the user\
    \ with a familiar, uniform view of the computing\n   infrastructure wherever they\
    \ go.\n   The RFB protocol has evolved over the past decade, and has been\n  \
    \ implemented several times, including at least one open source\n   version. \
    \ This document describes the RFB protocol as actually\n   implemented, so that\
    \ future implementers can interoperate with\n   existing clients and servers.\n"
- title: 2.  Initial Connection
  contents:
  - "2.  Initial Connection\n   An RFB server is typically a long-lived process that\
    \ maintains the\n   state of a framebuffer.  RFB clients typically connect, communicate\n\
    \   with the server for a period of time to use and manipulate the\n   framebuffer,\
    \ then disconnect.  A subsequent RFB session will then\n   pick up where a prior\
    \ session left off, with the state of the\n   framebuffer intact.\n   An RFB client\
    \ contacts the server on TCP port 5900.  On systems with\n   multiple RFB servers,\
    \ server N typically listens on port 5900+N,\n   analogous to the way that X Window\
    \ servers listen on port 6000+N.\n   Some browser-based clients use a Java application\
    \ to run the RFB\n   protocol.  RFB servers sometimes provide a simple HTTP server\
    \ on port\n   5800 that provides the requisite Java applet.\n   In some cases,\
    \ the initial roles of the client and server are\n   reversed, with the RFB client\
    \ listening on port 5500, and the RFB\n   server contacting the RFB client.  Once\
    \ the connection is\n   established, the two sides take their normal roles, with\
    \ the RFB\n   server sending the first handshake message.\n   Note that the only\
    \ port number assigned by IANA for RFB is port 5900,\n   so RFB clients and servers\
    \ should avoid using other port numbers\n   unless they are communicating with\
    \ servers or clients known to use\n   the non-standard ports.\n"
- title: 3.  Display Protocol
  contents:
  - "3.  Display Protocol\n   The display side of the protocol is based around a single\
    \ graphics\n   primitive: \"put a rectangle of pixel data at a given x,y position\"\
    .\n   This might seem an inefficient way of drawing many user interface\n   components.\
    \  However, allowing various different encodings for the\n   pixel data gives\
    \ us a large degree of flexibility in how to trade off\n   various parameters\
    \ such as network bandwidth, client drawing speed,\n   and server processing speed.\n\
    \   A sequence of these rectangles makes a framebuffer update (simply\n   referred\
    \ to here as \"update\").  An update represents a change from\n   one valid framebuffer\
    \ state to another, so in some ways is similar to\n   a frame of video.  The rectangles\
    \ in an update are usually but not\n   always disjoint.\n   The update protocol\
    \ is demand-driven by the client.  That is, an\n   update is only sent from the\
    \ server to the client in response to an\n   explicit request from the client.\
    \  This gives the protocol an\n   adaptive quality.  The slower the client and\
    \ the network are, the\n   lower the rate of updates.  With typical applications,\
    \ changes to the\n   same area of the framebuffer tend to happen soon after one\
    \ another.\n   With a slow client or network, transient states of the framebuffer\n\
    \   can be ignored, resulting in less network traffic and less drawing\n   for\
    \ the client.\n   After the initial handshake sequence, the protocol is asynchronous,\n\
    \   with each side sending messages as needed.  The server must not send\n   unsolicited\
    \ updates.  An update must only be sent in response to a\n   request from the\
    \ client.  When several requests from the client are\n   outstanding, a single\
    \ update from the server may satisfy all of them.\n"
- title: 4.  Input Protocol
  contents:
  - "4.  Input Protocol\n   The input side of the protocol is based on a standard\
    \ workstation\n   model of a keyboard and multi-button pointing device.  Input\
    \ events\n   are simply sent to the server by the client whenever the user presses\n\
    \   a key or pointer button, or whenever the pointing device is moved.\n   These\
    \ input events can also be synthesized from other non-standard\n   I/O devices.\
    \  For example, a pen-based handwriting recognition engine\n   might generate\
    \ keyboard events.\n"
- title: 5.  Representation of Pixel Data
  contents:
  - "5.  Representation of Pixel Data\n   Initial interaction between the RFB client\
    \ and server involves a\n   negotiation of the format and encoding of the pixel\
    \ data that will be\n   sent.  This negotiation has been designed to make the\
    \ job of the\n   client as easy as possible.  The server must always be able to\
    \ supply\n   pixel data in the form the client wants.  However, if the client\
    \ is\n   able to cope equally with several different formats or encodings, it\n\
    \   may choose one that is easier for the server to produce.\n   Pixel format\
    \ refers to the representation of individual colors by\n   pixel values.  The\
    \ most common pixel formats are 24-bit or 16-bit\n   \"true color\", where bit-fields\
    \ within the pixel value translate\n   directly to red, green, and blue intensities,\
    \ and 8-bit \"color map\"\n   (palette) where the pixel values are indices into\
    \ a 256-entry table\n   that contains the actual RGB intensities.\n   Encoding\
    \ refers to the way that a rectangle of pixel data will be\n   sent to the client.\
    \  Every rectangle of pixel data is prefixed by a\n   header giving the X,Y position\
    \ of the rectangle on the screen, the\n   width and height of the rectangle, and\
    \ an encoding type which\n   specifies the encoding of the pixel data.  The data\
    \ itself then\n   follows using the specified encoding.\n   The encoding types\
    \ defined at present are: Raw, CopyRect, RRE, TRLE,\n   Hextile, and ZRLE.  In\
    \ practice, current servers use the ZRLE, TRLE,\n   and CopyRect encodings since\
    \ they provide the best compression for\n   typical desktops.  Clients generally\
    \ also support Hextile, which was\n   often used by older RFB servers that didn't\
    \ support TRLE.  See\n   Section 7.7 for a description of each of the encodings.\n"
- title: 6.  Protocol Versions and Extensions
  contents:
  - "6.  Protocol Versions and Extensions\n   The RFB protocol has evolved through\
    \ three published versions: 3.3,\n   3.7, and 3.8.  This document primarily documents\
    \ the final version\n   3.8; differences from the earlier versions, which are\
    \ minor, are\n   described in Appendix A.  Under no circumstances should an\n\
    \   implementation use a protocol version number other than one defined\n   in\
    \ this document.  Over the years, different implementations of RFB\n   have attempted\
    \ to use different version numbers to add undocumented\n   extensions, with the\
    \ result being that to interoperate, any unknown\n   3.x version must be treated\
    \ as 3.3, so it is not possible to add a\n   3.9 or higher version in a backward-compatible\
    \ fashion.  Future\n   evolution of RFB will use 4.x version numbers.\n   It is\
    \ not necessary to change the protocol version number to extend\n   the protocol.\
    \  The protocol can be extended within an existing\n   version by:\n   New encodings\n\
    \      A new encoding type can be added to the protocol relatively easily\n  \
    \    while maintaining compatibility with existing clients and servers.\n    \
    \  Existing servers will simply ignore requests for a new encoding\n      that\
    \ they don't support.  Existing clients will never request the\n      new encoding\
    \ so will never see rectangles encoded that way.\n   Pseudo-encodings\n      In\
    \ addition to genuine encodings, a client can request a \"pseudo-\n      encoding\"\
    \ to declare to the server that it supports a certain\n      extension to the\
    \ protocol.  A server that does not support the\n      extension will simply ignore\
    \ the pseudo-encoding.  Note that this\n      means the client must assume that\
    \ the server does not support the\n      extension until it gets some extension-specific\
    \ confirmation from\n      the server.  See Section 7.8 for a description of current\
    \ pseudo-\n      encodings.\n   New security types\n      Adding a new security\
    \ type gives full flexibility in modifying the\n      behavior of the protocol\
    \ without sacrificing compatibility with\n      existing clients and servers.\
    \  A client and server that agree on a\n      new security type can effectively\
    \ talk whatever protocol they like\n      after that -- it doesn't necessarily\
    \ have to be anything like the\n      RFB protocol.\n   See Section 8 for information\
    \ on obtaining an ID for a new encoding\n   or security type.\n"
- title: 7.  Protocol Messages
  contents:
  - "7.  Protocol Messages\n   The RFB protocol can operate over any reliable transport,\
    \ either\n   byte-stream or message based.  It usually operates over a TCP/IP\n\
    \   connection.  There are three stages to the protocol.  First is the\n   handshaking\
    \ phase, the purpose of which is to agree upon the protocol\n   version and the\
    \ type of security to be used.  The second stage is an\n   initialization phase\
    \ where the client and server exchange ClientInit\n   and ServerInit messages.\
    \  The final stage is the normal protocol\n   interaction.  The client can send\
    \ whichever messages it wants, and\n   may receive messages from the server as\
    \ a result.  All these messages\n   begin with a message-type byte, followed by\
    \ message-specific data.\n   The following descriptions of protocol messages use\
    \ the basic types\n   U8, U16, U32, S8, S16, and S32.  These represent, respectively,\
    \ 8-,\n   16-, and 32-bit unsigned integers and 8-, 16-, and 32-bit signed\n \
    \  integers.  All multiple-byte integers (other than pixel values\n   themselves)\
    \ are in big endian order (most significant byte first).\n   Some messages use\
    \ arrays of the basic types, with the number of\n   entries in the array determined\
    \ from fields preceding the array.\n   The type PIXEL means a pixel value of bytesPerPixel\
    \ bytes, where\n   bytesPerPixel is the number of bits-per-pixel divided by 8.\
    \  The\n   bits-per-pixel is agreed by the client and server, either in the\n\
    \   ServerInit message (Section 7.3.2) or a SetPixelFormat message\n   (Section\
    \ 7.5.1).  See Section 7.4 for the detailed description of the\n   pixel format.\n\
    \   Several message formats include padding bits or bytes.  For maximum\n   compatibility,\
    \ messages should be generated with padding set to zero,\n   but message recipients\
    \ should not assume padding has any particular\n   value.\n"
- title: 7.1.  Handshake Messages
  contents:
  - "7.1.  Handshake Messages\n   When an RFB client and server first connect, they\
    \ exchange a sequence\n   of handshake messages that determine the protocol version,\
    \ what type\n   of connection security (if any) to use, a password check if the\n\
    \   security type requires it, and some initialization information.\n"
- title: 7.1.1.  ProtocolVersion Handshake
  contents:
  - "7.1.1.  ProtocolVersion Handshake\n   Handshaking begins by the server sending\
    \ the client a ProtocolVersion\n   message.  This lets the client know which is\
    \ the highest RFB protocol\n   version number supported by the server.  The client\
    \ then replies with\n   a similar message giving the version number of the protocol\
    \ that\n   should actually be used (which may be different to that quoted by the\n\
    \   server).  A client should never request a protocol version higher\n   than\
    \ that offered by the server.  It is intended that both clients\n   and servers\
    \ may provide some level of backwards compatibility by this\n   mechanism.\n \
    \  The only published protocol versions at this time are 3.3, 3.7, and\n   3.8.\
    \  Other version numbers are reported by some servers and clients,\n   but should\
    \ be interpreted as 3.3 since they do not implement the\n   different handshake\
    \ in 3.7 or 3.8.  Addition of a new encoding or\n   pseudo-encoding type does\
    \ not require a change in protocol version,\n   since a server can simply ignore\
    \ encodings it does not understand.\n   The ProtocolVersion message consists of\
    \ 12 bytes interpreted as a\n   string of ASCII characters in the format \"RFB\
    \ xxx.yyy\\n\" where xxx\n   and yyy are the major and minor version numbers,\
    \ left-padded with\n   zeros:\n       RFB 003.008\\n (hex 52 46 42 20 30 30 33\
    \ 2e 30 30 38 0a)\n"
- title: 7.1.2.  Security Handshake
  contents:
  - "7.1.2.  Security Handshake\n   Once the protocol version has been decided, the\
    \ server and client\n   must agree on the type of security to be used on the connection.\
    \  The\n   server lists the security types that it supports:\n   +--------------------------+-------------+--------------------------+\n\
    \   | No. of bytes             | Type        | Description              |\n  \
    \ |                          | [Value]     |                          |\n   +--------------------------+-------------+--------------------------+\n\
    \   | 1                        | U8          | number-of-security-types |\n  \
    \ | number-of-security-types | U8 array    | security-types           |\n   +--------------------------+-------------+--------------------------+\n\
    \   If the server listed at least one valid security type supported by\n   the\
    \ client, the client sends back a single byte indicating which\n   security type\
    \ is to be used on the connection:\n              +--------------+--------------+---------------+\n\
    \              | No. of bytes | Type [Value] | Description   |\n             \
    \ +--------------+--------------+---------------+\n              | 1         \
    \   | U8           | security-type |\n              +--------------+--------------+---------------+\n\
    \   If number-of-security-types is zero, then for some reason the\n   connection\
    \ failed (e.g., the server cannot support the desired\n   protocol version). \
    \ This is followed by a string describing the\n   reason (where a string is specified\
    \ as a length followed by that many\n   ASCII characters):\n             +---------------+--------------+---------------+\n\
    \             | No. of bytes  | Type [Value] | Description   |\n             +---------------+--------------+---------------+\n\
    \             | 4             | U32          | reason-length |\n             |\
    \ reason-length | U8 array     | reason-string |\n             +---------------+--------------+---------------+\n\
    \   The server closes the connection after sending the reason-string.\n      \
    \       The security types defined in this document are:\n                   \
    \   +--------+--------------------+\n                      | Number | Name   \
    \            |\n                      +--------+--------------------+\n      \
    \                | 0      | Invalid            |\n                      | 1  \
    \    | None               |\n                      | 2      | VNC Authentication\
    \ |\n                      +--------+--------------------+\n   Other security\
    \ types exist but are not publicly documented.\n   Once the security-type has\
    \ been decided, data specific to that\n   security-type follows (see Section 7.2\
    \ for details).  At the end of\n   the security handshaking phase, the protocol\
    \ normally continues with\n   the SecurityResult message.\n   Note that after\
    \ the security handshaking phase, it is possible that\n   further communication\
    \ is over an encrypted or otherwise altered\n   channel if the two ends agree\
    \ on an extended security type beyond the\n   ones described here.\n"
- title: 7.1.3.  SecurityResult Handshake
  contents:
  - "7.1.3.  SecurityResult Handshake\n   The server sends a word to inform the client\
    \ whether the security\n   handshaking was successful.\n               +--------------+--------------+-------------+\n\
    \               | No. of bytes | Type [Value] | Description |\n              \
    \ +--------------+--------------+-------------+\n               | 4          \
    \  | U32          | status:     |\n               |              | 0         \
    \   | OK          |\n               |              | 1            | failed   \
    \   |\n               +--------------+--------------+-------------+\n   If successful,\
    \ the protocol passes to the initialization phase\n   (Section 7.3).\n   If unsuccessful,\
    \ the server sends a string describing the reason for\n   the failure, and then\
    \ closes the connection:\n             +---------------+--------------+---------------+\n\
    \             | No. of bytes  | Type [Value] | Description   |\n             +---------------+--------------+---------------+\n\
    \             | 4             | U32          | reason-length |\n             |\
    \ reason-length | U8 array     | reason-string |\n             +---------------+--------------+---------------+\n"
- title: 7.2.  Security Types
  contents:
  - "7.2.  Security Types\n   Two security types are defined here.\n"
- title: 7.2.1.  None
  contents:
  - "7.2.1.  None\n   No authentication is needed.  The protocol continues with the\n\
    \   SecurityResult message.\n"
- title: 7.2.2.  VNC Authentication
  contents:
  - "7.2.2.  VNC Authentication\n   VNC authentication is to be used.  The server\
    \ sends a random 16-byte\n   challenge:\n               +--------------+--------------+-------------+\n\
    \               | No. of bytes | Type [Value] | Description |\n              \
    \ +--------------+--------------+-------------+\n               | 16         \
    \  | U8           | challenge   |\n               +--------------+--------------+-------------+\n\
    \   The client encrypts the challenge with DES, using a password supplied\n  \
    \ by the user as the key.  To form the key, the password is truncated\n   to eight\
    \ characters, or padded with null bytes on the right.  The\n   client then sends\
    \ the resulting 16-byte response:\n               +--------------+--------------+-------------+\n\
    \               | No. of bytes | Type [Value] | Description |\n              \
    \ +--------------+--------------+-------------+\n               | 16         \
    \  | U8           | response    |\n               +--------------+--------------+-------------+\n\
    \   The protocol continues with the SecurityResult message.\n   This type of authentication\
    \ is known to be cryptographically weak and\n   is not intended for use on untrusted\
    \ networks.  Many implementations\n   will want to use stronger security, such\
    \ as running the session over\n   an encrypted channel provided by IPsec [RFC4301]\
    \ or SSH [RFC4254].\n"
- title: 7.3.  Initialization Messages
  contents:
  - "7.3.  Initialization Messages\n   Once the client and server agree on and perhaps\
    \ validate a security\n   type, the protocol passes to the initialization stage.\
    \  The client\n   sends a ClientInit message.  Then, the server sends a ServerInit\n\
    \   message.\n"
- title: 7.3.1.  ClientInit
  contents:
  - "7.3.1.  ClientInit\n               +--------------+--------------+-------------+\n\
    \               | No. of bytes | Type [Value] | Description |\n              \
    \ +--------------+--------------+-------------+\n               | 1          \
    \  | U8           | shared-flag |\n               +--------------+--------------+-------------+\n\
    \   Shared-flag is non-zero (true) if the server should try to share the\n   desktop\
    \ by leaving other clients connected, and zero (false) if it\n   should give exclusive\
    \ access to this client by disconnecting all\n   other clients.\n"
- title: 7.3.2.  ServerInit
  contents:
  - "7.3.2.  ServerInit\n   After receiving the ClientInit message, the server sends\
    \ a ServerInit\n   message.  This tells the client the width and height of the\
    \ server's\n   framebuffer, its pixel format, and the name associated with the\n\
    \   desktop:\n      +--------------+--------------+------------------------------+\n\
    \      | No. of bytes | Type [Value] | Description                  |\n      +--------------+--------------+------------------------------+\n\
    \      | 2            | U16          | framebuffer-width in pixels  |\n      |\
    \ 2            | U16          | framebuffer-height in pixels |\n      | 16   \
    \        | PIXEL_FORMAT | server-pixel-format          |\n      | 4          \
    \  | U32          | name-length                  |\n      | name-length  | U8\
    \ array     | name-string                  |\n      +--------------+--------------+------------------------------+\n\
    \   Server-pixel-format specifies the server's natural pixel format.\n   This\
    \ pixel format will be used unless the client requests a different\n   format\
    \ using the SetPixelFormat message (Section 7.5.1).\n"
- title: 7.4.  Pixel Format Data Structure
  contents:
  - "7.4.  Pixel Format Data Structure\n   Several server-to-client messages include\
    \ a PIXEL_FORMAT, a 16-byte\n   structure that describes the way a pixel is transmitted.\n\
    \             +--------------+--------------+-----------------+\n            \
    \ | No. of bytes | Type [Value] | Description     |\n             +--------------+--------------+-----------------+\n\
    \             | 1            | U8           | bits-per-pixel  |\n            \
    \ | 1            | U8           | depth           |\n             | 1        \
    \    | U8           | big-endian-flag |\n             | 1            | U8    \
    \       | true-color-flag |\n             | 2            | U16          | red-max\
    \         |\n             | 2            | U16          | green-max       |\n\
    \             | 2            | U16          | blue-max        |\n            \
    \ | 1            | U8           | red-shift       |\n             | 1        \
    \    | U8           | green-shift     |\n             | 1            | U8    \
    \       | blue-shift      |\n             | 3            |              | padding\
    \         |\n             +--------------+--------------+-----------------+\n\
    \   Bits-per-pixel is the number of bits used for each pixel value on the\n  \
    \ wire.  This must be greater than or equal to the depth, which is the\n   number\
    \ of useful bits in the pixel value.  Currently bits-per-pixel\n   must be 8,\
    \ 16, or 32.  Big-endian-flag is non-zero (true) if multi-\n   byte pixels are\
    \ interpreted as big endian.  Although the depth should\n   be consistent with\
    \ the bits-per-pixel and the various -max values,\n   clients do not use it when\
    \ interpreting pixel data.\n   If true-color-flag is non-zero (true), then the\
    \ last six items\n   specify how to extract the red, green, and blue intensities\
    \ from the\n   pixel value.  Red-max is the maximum red value and must be 2^N\
    \ - 1,\n   where N is the number of bits used for red.  Note the -max values are\n\
    \   always in big endian order.  Red-shift is the number of shifts needed\n  \
    \ to get the red value in a pixel to the least significant bit.  Green-\n   max,\
    \ green-shift, blue-max, and blue-shift are similar for green and\n   blue.  For\
    \ example, to find the red value (between 0 and red-max)\n   from a given pixel,\
    \ do the following:\n   o  Swap the pixel value according to big-endian-flag,\
    \ e.g., if big-\n      endian-flag is zero (false) and host byte order is big\
    \ endian,\n      then swap.\n   o  Shift right by red-shift.\n   o  AND with red-max\
    \ (in host byte order).\n   If true-color-flag is zero (false), then the server\
    \ uses pixel values\n   that are not directly composed from the red, green, and\
    \ blue\n   intensities, but serve as indices into a color map.  Entries in the\n\
    \   color map are set by the server using the SetColorMapEntries message\n   (See\
    \ Section 7.6.2).\n"
- title: 7.5.  Client-to-Server Messages
  contents:
  - "7.5.  Client-to-Server Messages\n   The client-to-server message types defined\
    \ in this document are:\n                   +--------+--------------------------+\n\
    \                   | Number | Name                     |\n                  \
    \ +--------+--------------------------+\n                   | 0      | SetPixelFormat\
    \           |\n                   | 2      | SetEncodings             |\n    \
    \               | 3      | FramebufferUpdateRequest |\n                   | 4\
    \      | KeyEvent                 |\n                   | 5      | PointerEvent\
    \             |\n                   | 6      | ClientCutText            |\n  \
    \                 +--------+--------------------------+\n   Other message types\
    \ exist but are not publicly documented.  Before\n   sending a message other than\
    \ those described in this document, a\n   client must have determined that the\
    \ server supports the relevant\n   extension by receiving an appropriate extension-specific\
    \ confirmation\n   from the server.\n"
- title: 7.5.1.  SetPixelFormat
  contents:
  - "7.5.1.  SetPixelFormat\n   A SetPixelFormat message sets the format in which\
    \ pixel values should\n   be sent in FramebufferUpdate messages.  If the client\
    \ does not send a\n   SetPixelFormat message, then the server sends pixel values\
    \ in its\n   natural format as specified in the ServerInit message\n   (Section\
    \ 7.3.2).\n   If true-color-flag is zero (false), then this indicates that a \"\
    color\n   map\" is to be used.  The server can set any of the entries in the\n\
    \   color map using the SetColorMapEntries message (Section 7.6.2).\n   Immediately\
    \ after the client has sent this message, the contents of\n   the color map are\
    \ undefined, even if entries had previously been set\n   by the server.\n    \
    \          +--------------+--------------+--------------+\n              | No.\
    \ of bytes | Type [Value] | Description  |\n              +--------------+--------------+--------------+\n\
    \              | 1            | U8 [0]       | message-type |\n              |\
    \ 3            |              | padding      |\n              | 16           |\
    \ PIXEL_FORMAT | pixel-format |\n              +--------------+--------------+--------------+\n\
    \               PIXEL_FORMAT is as described in Section 7.4.\n"
- title: 7.5.2.  SetEncodings
  contents:
  - "7.5.2.  SetEncodings\n   A SetEncodings message sets the encoding types in which\
    \ pixel data\n   can be sent by the server.  The order of the encoding types given\
    \ in\n   this message is a hint by the client as to its preference (the first\n\
    \   encoding specified being most preferred).  The server may or may not\n   choose\
    \ to make use of this hint.  Pixel data may always be sent in\n   raw encoding\
    \ even if not specified explicitly here.\n   In addition to genuine encodings,\
    \ a client can request \"pseudo-\n   encodings\" to declare to the server that\
    \ it supports certain\n   extensions to the protocol.  A server that does not\
    \ support the\n   extension will simply ignore the pseudo-encoding.  Note that\
    \ this\n   means the client must assume that the server does not support the\n\
    \   extension until it gets some extension-specific confirmation from the\n  \
    \ server.\n   See Section 7.7 for a description of each encoding and Section 7.8\n\
    \   for the meaning of pseudo-encodings.\n           +--------------+--------------+---------------------+\n\
    \           | No. of bytes | Type [Value] | Description         |\n          \
    \ +--------------+--------------+---------------------+\n           | 1      \
    \      | U8 [2]       | message-type        |\n           | 1            |   \
    \           | padding             |\n           | 2            | U16         \
    \ | number-of-encodings |\n           +--------------+--------------+---------------------+\n\
    \   This is followed by number-of-encodings repetitions of the following:\n  \
    \            +--------------+--------------+---------------+\n              |\
    \ No. of bytes | Type [Value] | Description   |\n              +--------------+--------------+---------------+\n\
    \              | 4            | S32          | encoding-type |\n             \
    \ +--------------+--------------+---------------+\n"
- title: 7.5.3.  FramebufferUpdateRequest
  contents:
  - "7.5.3.  FramebufferUpdateRequest\n   A FramebufferUpdateRequest message notifies\
    \ the server that the\n   client is interested in the area of the framebuffer\
    \ specified by\n   x-position, y-position, width, and height.  The server usually\n\
    \   responds to a FramebufferUpdateRequest by sending a\n   FramebufferUpdate.\
    \  A single FramebufferUpdate may be sent in reply\n   to several FramebufferUpdateRequests.\n\
    \   The server assumes that the client keeps a copy of all parts of the\n   framebuffer\
    \ in which it is interested.  This means that normally the\n   server only needs\
    \ to send incremental updates to the client.\n   If the client has lost the contents\
    \ of a particular area that it\n   needs, then the client sends a FramebufferUpdateRequest\
    \ with\n   incremental set to zero (false).  This requests that the server send\n\
    \   the entire contents of the specified area as soon as possible.  The\n   area\
    \ will not be updated using the CopyRect encoding.\n   If the client has not lost\
    \ any contents of the area in which it is\n   interested, then it sends a FramebufferUpdateRequest\
    \ with incremental\n   set to non-zero (true).  If and when there are changes\
    \ to the\n   specified area of the framebuffer, the server will send a\n   FramebufferUpdate.\
    \  Note that there may be an indefinite period\n   between the FramebufferUpdateRequest\
    \ and the FramebufferUpdate.\n   In the case of a fast client, the client may\
    \ want to regulate the\n   rate at which it sends incremental FramebufferUpdateRequests\
    \ to avoid\n   excessive network traffic.\n              +--------------+--------------+--------------+\n\
    \              | No. of bytes | Type [Value] | Description  |\n              +--------------+--------------+--------------+\n\
    \              | 1            | U8 [3]       | message-type |\n              |\
    \ 1            | U8           | incremental  |\n              | 2            |\
    \ U16          | x-position   |\n              | 2            | U16          |\
    \ y-position   |\n              | 2            | U16          | width        |\n\
    \              | 2            | U16          | height       |\n              +--------------+--------------+--------------+\n"
- title: 7.5.4.  KeyEvent
  contents:
  - "7.5.4.  KeyEvent\n   A KeyEvent message indicates a key press or release.  Down-flag\
    \ is\n   non-zero (true) if the key is now pressed, and zero (false) if it is\n\
    \   now released.  The key itself is specified using the \"keysym\" values\n \
    \  defined by the X Window System, even if the client or server is not\n   running\
    \ the X Window System.\n              +--------------+--------------+--------------+\n\
    \              | No. of bytes | Type [Value] | Description  |\n              +--------------+--------------+--------------+\n\
    \              | 1            | U8 [4]       | message-type |\n              |\
    \ 1            | U8           | down-flag    |\n              | 2            |\
    \              | padding      |\n              | 4            | U32          |\
    \ key          |\n              +--------------+--------------+--------------+\n\
    \   For most ordinary keys, the keysym is the same as the corresponding\n   ASCII\
    \ value.  For full details, see [XLIBREF] or see the header file\n   <X11/keysymdef.h>\
    \ in the X Window System distribution.  Some other\n   common keys are:\n    \
    \             +-----------------+--------------------+\n                 | Key\
    \ name        | Keysym value (hex) |\n                 +-----------------+--------------------+\n\
    \                 | BackSpace       | 0xff08             |\n                 |\
    \ Tab             | 0xff09             |\n                 | Return or Enter |\
    \ 0xff0d             |\n                 | Escape          | 0xff1b          \
    \   |\n                 | Insert          | 0xff63             |\n           \
    \      | Delete          | 0xffff             |\n                 | Home     \
    \       | 0xff50             |\n                 | End             | 0xff57  \
    \           |\n                 | Page Up         | 0xff55             |\n   \
    \              | Page Down       | 0xff56             |\n                 | Left\
    \            | 0xff51             |\n                 | Up              | 0xff52\
    \             |\n                 | Right           | 0xff53             |\n \
    \                | Down            | 0xff54             |\n                 |\
    \ F1              | 0xffbe             |\n                 | F2              |\
    \ 0xffbf             |\n                 | F3              | 0xffc0          \
    \   |\n                 | F4              | 0xffc1             |\n           \
    \      | ...             | ...                |\n                 | F12      \
    \       | 0xffc9             |\n                 | Shift (left)    | 0xffe1  \
    \           |\n                 | Shift (right)   | 0xffe2             |\n   \
    \              | Control (left)  | 0xffe3             |\n                 | Control\
    \ (right) | 0xffe4             |\n                 | Meta (left)     | 0xffe7\
    \             |\n                 | Meta (right)    | 0xffe8             |\n \
    \                | Alt (left)      | 0xffe9             |\n                 |\
    \ Alt (right)     | 0xffea             |\n                 +-----------------+--------------------+\n\
    \   The interpretation of keysyms is a complex area.  In order to be as\n   widely\
    \ interoperable as possible, the following guidelines should be\n   followed:\n\
    \   o  The \"shift state\" (i.e., whether either of the Shift keysyms is\n   \
    \   down) should only be used as a hint when interpreting a keysym.\n      For\
    \ example, on a US keyboard the '#' character is shifted, but on\n      a UK keyboard\
    \ it is not.  A server with a US keyboard receiving a\n      '#' character from\
    \ a client with a UK keyboard will not have been\n      sent any shift presses.\
    \  In this case, it is likely that the\n      server will internally need to simulate\
    \ a shift press on its local\n      system in order to get a '#' character and\
    \ not a '3'.\n   o  The difference between upper and lower case keysyms is\n \
    \     significant.  This is unlike some of the keyboard processing in\n      the\
    \ X Window System that treats them as the same.  For example, a\n      server\
    \ receiving an upper case 'A' keysym without any shift\n      presses should interpret\
    \ it as an upper case 'A'.  Again this may\n      involve an internal simulated\
    \ shift press.\n   o  Servers should ignore \"lock\" keysyms such as CapsLock\
    \ and NumLock\n      where possible.  Instead, they should interpret each character-\n\
    \      based keysym according to its case.\n   o  Unlike Shift, the state of modifier\
    \ keys such as Control and Alt\n      should be taken as modifying the interpretation\
    \ of other keysyms.\n      Note that there are no keysyms for ASCII control characters\
    \ such\n      as Ctrl-A -- these should be generated by clients sending a\n  \
    \    Control press followed by an 'a' press.\n   o  On a client where modifiers\
    \ like Control and Alt can also be used\n      to generate character-based keysyms,\
    \ the client may need to send\n      extra \"release\" events in order that the\
    \ keysym is interpreted\n      correctly.  For example, on a German PC keyboard,\
    \ Ctrl-Alt-Q\n      generates the '@' character.  In this case, the client needs\
    \ to\n      send simulated release events for Control and Alt in order that\n\
    \      the '@' character is interpreted correctly, since Ctrl-Alt-@ may\n    \
    \  mean something completely different to the server.\n   o  There is no universal\
    \ standard for \"backward tab\" in the X Window\n      System.  On some systems\
    \ shift+tab gives the keysym\n      \"ISO_Left_Tab\", on others it gives a private\
    \ \"BackTab\" keysym, and\n      on others it gives \"Tab\" and applications tell\
    \ from the shift\n      state that it means backward-tab rather than forward-tab.\
    \  In the\n      RFB protocol, the latter approach is preferred.  Clients should\n\
    \      generate a shifted Tab rather than ISO_Left_Tab.  However, to be\n    \
    \  backwards-compatible with existing clients, servers should also\n      recognize\
    \ ISO_Left_Tab as meaning a shifted Tab.\n   o  Modern versions of the X Window\
    \ System handle keysyms for Unicode\n      characters, consisting of the Unicode\
    \ character with the hex\n      1000000 bit set.  For maximum compatibility, if\
    \ a key has both a\n      Unicode and a legacy encoding, clients should send the\
    \ legacy\n      encoding.\n   o  Some systems give a special interpretation to\
    \ key combinations\n      such as Ctrl-Alt-Delete.  RFB clients typically provide\
    \ a menu or\n      toolbar function to send such key combinations.  The RFB protocol\n\
    \      does not treat them specially; to send Ctrl-Alt-Delete, the client\n  \
    \    sends the key presses for left or right Control, left or right\n      Alt,\
    \ and Delete, followed by the key releases.  Many RFB servers\n      accept Shift-Ctrl-Alt-Delete\
    \ as a synonym for Ctrl-Alt-Delete that\n      can be entered directly from the\
    \ keyboard.\n"
- title: 7.5.5.  PointerEvent
  contents:
  - "7.5.5.  PointerEvent\n   A PointerEvent message indicates either pointer movement\
    \ or a pointer\n   button press or release.  The pointer is now at (x-position,\n\
    \   y-position), and the current state of buttons 1 to 8 are represented\n   by\
    \ bits 0 to 7 of button-mask, respectively; 0 means up, 1 means down\n   (pressed).\n\
    \   On a conventional mouse, buttons 1, 2, and 3 correspond to the left,\n   middle,\
    \ and right buttons on the mouse.  On a wheel mouse, each step\n   of the wheel\
    \ upwards is represented by a press and release of button\n   4, and each step\
    \ downwards is represented by a press and release of\n   button 5.\n         \
    \     +--------------+--------------+--------------+\n              | No. of bytes\
    \ | Type [Value] | Description  |\n              +--------------+--------------+--------------+\n\
    \              | 1            | U8 [5]       | message-type |\n              |\
    \ 1            | U8           | button-mask  |\n              | 2            |\
    \ U16          | x-position   |\n              | 2            | U16          |\
    \ y-position   |\n              +--------------+--------------+--------------+\n"
- title: 7.5.6.  ClientCutText
  contents:
  - "7.5.6.  ClientCutText\n   RFB provides limited support for synchronizing the\
    \ \"cut buffer\" of\n   selected text between client and server.  This message\
    \ tells the\n   server that the client has new ISO 8859-1 (Latin-1) text in its\
    \ cut\n   buffer.  Ends of lines are represented by the newline character (hex\n\
    \   0a) alone.  No carriage-return (hex 0d) is used.  There is no way to\n   transfer\
    \ text outside the Latin-1 character set.\n              +--------------+--------------+--------------+\n\
    \              | No. of bytes | Type [Value] | Description  |\n              +--------------+--------------+--------------+\n\
    \              | 1            | U8 [6]       | message-type |\n              |\
    \ 3            |              | padding      |\n              | 4            |\
    \ U32          | length       |\n              | length       | U8 array     |\
    \ text         |\n              +--------------+--------------+--------------+\n"
- title: 7.6.  Server-to-Client Messages
  contents:
  - "7.6.  Server-to-Client Messages\n   The server-to-client message types defined\
    \ in this document are:\n                      +--------+--------------------+\n\
    \                      | Number | Name               |\n                     \
    \ +--------+--------------------+\n                      | 0      | FramebufferUpdate\
    \  |\n                      | 1      | SetColorMapEntries |\n                \
    \      | 2      | Bell               |\n                      | 3      | ServerCutText\
    \      |\n                      +--------+--------------------+\n   Other private\
    \ message types exist but are not publicly documented.\n   Before sending a message\
    \ other than those described in this document\n   a server must have determined\
    \ that the client supports the relevant\n   extension by receiving some extension-specific\
    \ confirmation from the\n   client -- usually a request for a given pseudo-encoding.\n"
- title: 7.6.1.  FramebufferUpdate
  contents:
  - "7.6.1.  FramebufferUpdate\n   A framebuffer update consists of a sequence of\
    \ rectangles of pixel\n   data that the client should put into its framebuffer.\
    \  It is sent in\n   response to a FramebufferUpdateRequest from the client. \
    \ Note that\n   there may be an indefinite period between the\n   FramebufferUpdateRequest\
    \ and the FramebufferUpdate.\n          +--------------+--------------+----------------------+\n\
    \          | No. of bytes | Type [Value] | Description          |\n          +--------------+--------------+----------------------+\n\
    \          | 1            | U8 [0]       | message-type         |\n          |\
    \ 1            |              | padding              |\n          | 2        \
    \    | U16          | number-of-rectangles |\n          +--------------+--------------+----------------------+\n\
    \   This header is followed by number-of-rectangles rectangles of pixel\n   data.\
    \  Each rectangle starts with a rectangle header:\n              +--------------+--------------+---------------+\n\
    \              | No. of bytes | Type [Value] | Description   |\n             \
    \ +--------------+--------------+---------------+\n              | 2         \
    \   | U16          | x-position    |\n              | 2            | U16     \
    \     | y-position    |\n              | 2            | U16          | width \
    \        |\n              | 2            | U16          | height        |\n  \
    \            | 4            | S32          | encoding-type |\n              +--------------+--------------+---------------+\n\
    \   The rectangle header is followed by the pixel data in the specified\n   encoding.\
    \  See Section 7.7 for the format of the data for each\n   encoding and Section\
    \ 7.8 for the meaning of pseudo-encodings.\n"
- title: 7.6.2.  SetColorMapEntries
  contents:
  - "7.6.2.  SetColorMapEntries\n   When the pixel format uses a \"color map\", this\
    \ message tells the\n   client that the specified pixel values should be mapped\
    \ to the given\n   RGB values.  Note that this message may only update part of\
    \ the color\n   map.  This message should not be sent by the server until after\
    \ the\n   client has sent at least one FramebufferUpdateRequest, and only when\n\
    \   the agreed pixel format uses a color map.\n   Color map values are always\
    \ 16 bits, with the range of values running\n   from 0 to 65535, regardless of\
    \ the display hardware in use.  The\n   color map value for white, for example,\
    \ is 65535,65535,65535.\n   The message starts with a header describing the range\
    \ of colormap\n   entries to be updated.\n            +--------------+--------------+------------------+\n\
    \            | No. of bytes | Type [Value] | Description      |\n            +--------------+--------------+------------------+\n\
    \            | 1            | U8 [1]       | message-type     |\n            |\
    \ 1            |              | padding          |\n            | 2          \
    \  | U16          | first-color      |\n            | 2            | U16     \
    \     | number-of-colors |\n            +--------------+--------------+------------------+\n\
    \   This header is followed by number-of-colors RGB values, each of which\n  \
    \ is in this format:\n               +--------------+--------------+-------------+\n\
    \               | No. of bytes | Type [Value] | Description |\n              \
    \ +--------------+--------------+-------------+\n               | 2          \
    \  | U16          | red         |\n               | 2            | U16       \
    \   | green       |\n               | 2            | U16          | blue     \
    \   |\n               +--------------+--------------+-------------+\n"
- title: 7.6.3.  Bell
  contents:
  - "7.6.3.  Bell\n   A Bell message makes an audible signal on the client if it provides\n\
    \   one.\n              +--------------+--------------+--------------+\n     \
    \         | No. of bytes | Type [Value] | Description  |\n              +--------------+--------------+--------------+\n\
    \              | 1            | U8 [2]       | message-type |\n              +--------------+--------------+--------------+\n"
- title: 7.6.4.  ServerCutText
  contents:
  - "7.6.4.  ServerCutText\n   The server has new ISO 8859-1 (Latin-1) text in its\
    \ cut buffer.  Ends\n   of lines are represented by the newline character (hex\
    \ 0a) alone.  No\n   carriage-return (hex 0d) is used.  There is no way to transfer\
    \ text\n   outside the Latin-1 character set.\n              +--------------+--------------+--------------+\n\
    \              | No. of bytes | Type [Value] | Description  |\n              +--------------+--------------+--------------+\n\
    \              | 1            | U8 [3]       | message-type |\n              |\
    \ 3            |              | padding      |\n              | 4            |\
    \ U32          | length       |\n              | length       | U8 array     |\
    \ text         |\n              +--------------+--------------+--------------+\n"
- title: 7.7.  Encodings
  contents:
  - "7.7.  Encodings\n   The encodings defined in this document are:\n           \
    \      +--------+-----------------------------+\n                 | Number | Name\
    \                        |\n                 +--------+-----------------------------+\n\
    \                 | 0      | Raw                         |\n                 |\
    \ 1      | CopyRect                    |\n                 | 2      | RRE    \
    \                     |\n                 | 5      | Hextile                 \
    \    |\n                 | 15     | TRLE                        |\n          \
    \       | 16     | ZRLE                        |\n                 | -239   |\
    \ Cursor pseudo-encoding      |\n                 | -223   | DesktopSize pseudo-encoding\
    \ |\n                 +--------+-----------------------------+\n   Other encoding\
    \ types exist but are not publicly documented.\n"
- title: 7.7.1.  Raw Encoding
  contents:
  - "7.7.1.  Raw Encoding\n   The simplest encoding type is raw pixel data.  In this\
    \ case, the data\n   consists of width*height pixel values (where width and height\
    \ are the\n   width and height of the rectangle).  The values simply represent\
    \ each\n   pixel in left-to-right scan line order.  All RFB clients must be able\n\
    \   to handle pixel data in this raw encoding, and RFB servers should\n   only\
    \ produce raw encoding unless the client specifically asks for\n   some other\
    \ encoding type.\n        +----------------------------+--------------+-------------+\n\
    \        | No. of bytes               | Type [Value] | Description |\n       \
    \ +----------------------------+--------------+-------------+\n        | width*height*bytesPerPixel\
    \ | PIXEL array  | pixels      |\n        +----------------------------+--------------+-------------+\n"
- title: 7.7.2.  CopyRect Encoding
  contents:
  - "7.7.2.  CopyRect Encoding\n   The CopyRect (copy rectangle) encoding is a very\
    \ simple and efficient\n   encoding that can be used when the client already has\
    \ the same pixel\n   data elsewhere in its framebuffer.  The encoding on the wire\
    \ simply\n   consists of an X,Y coordinate.  This gives a position in the\n  \
    \ framebuffer from which the client can copy the rectangle of pixel\n   data.\
    \  This can be used in a variety of situations, the most common\n   of which are\
    \ when the user moves a window across the screen, and when\n   the contents of\
    \ a window are scrolled.\n             +--------------+--------------+----------------+\n\
    \             | No. of bytes | Type [Value] | Description    |\n             +--------------+--------------+----------------+\n\
    \             | 2            | U16          | src-x-position |\n             |\
    \ 2            | U16          | src-y-position |\n             +--------------+--------------+----------------+\n\
    \   For maximum compatibility, the source rectangle of a CopyRect should\n   not\
    \ include pixels updated by previous entries in the same\n   FramebufferUpdate\
    \ message.\n"
- title: 7.7.3.  RRE Encoding
  contents:
  - "7.7.3.  RRE Encoding\n   Note: RRE encoding is obsolescent.  In general, ZRLE\
    \ and TRLE\n   encodings are more compact.\n   RRE stands for rise-and-run-length\
    \ encoding.  As its name implies, it\n   is essentially a two-dimensional analogue\
    \ of run-length encoding.\n   RRE-encoded rectangles arrive at the client in a\
    \ form that can be\n   rendered immediately by the simplest of graphics engines.\
    \  RRE is not\n   appropriate for complex desktops, but can be useful in some\n\
    \   situations.\n   The basic idea behind RRE is the partitioning of a rectangle\
    \ of pixel\n   data into rectangular subregions (subrectangles) each of which\n\
    \   consists of pixels of a single value, and the union of which\n   comprises\
    \ the original rectangular region.  The near-optimal\n   partition of a given\
    \ rectangle into such subrectangles is relatively\n   easy to compute.\n   The\
    \ encoding consists of a background pixel value, Vb (typically the\n   most prevalent\
    \ pixel value in the rectangle) and a count N, followed\n   by a list of N subrectangles,\
    \ each of which consists of a tuple\n   <v,x,y,w,h> where v (which should be different\
    \ from Vb) is the pixel\n   value, (x,y) are the coordinates of the subrectangle\
    \ relative to the\n   top-left corner of the rectangle, and (w,h) are the width\
    \ and height\n   of the subrectangle.  The client can render the original rectangle\
    \ by\n   drawing a filled rectangle of the background pixel value and then\n \
    \  drawing a filled rectangle corresponding to each subrectangle.\n   On the wire,\
    \ the data begins with the header:\n        +---------------+--------------+-------------------------+\n\
    \        | No. of bytes  | Type [Value] | Description             |\n        +---------------+--------------+-------------------------+\n\
    \        | 4             | U32          | number-of-subrectangles |\n        |\
    \ bytesPerPixel | PIXEL        | background-pixel-value  |\n        +---------------+--------------+-------------------------+\n\
    \   This is followed by number-of-subrectangles instances of the\n   following\
    \ structure:\n          +---------------+--------------+---------------------+\n\
    \          | No. of bytes  | Type [Value] | Description         |\n          +---------------+--------------+---------------------+\n\
    \          | bytesPerPixel | PIXEL        | subrect-pixel-value |\n          |\
    \ 2             | U16          | x-position          |\n          | 2        \
    \     | U16          | y-position          |\n          | 2             | U16\
    \          | width               |\n          | 2             | U16          |\
    \ height              |\n          +---------------+--------------+---------------------+\n"
- title: 7.7.4.  Hextile Encoding
  contents:
  - "7.7.4.  Hextile Encoding\n   Note: Hextile encoding is obsolescent.  In general,\
    \ ZRLE and TRLE\n   encodings are more compact.\n   Hextile is a variation on\
    \ RRE.  Rectangles are split up into 16x16\n   tiles, allowing the dimensions\
    \ of the subrectangles to be specified\n   in 4 bits each, 16 bits in total. \
    \ The rectangle is split into tiles\n   starting at the top left going in left-to-right,\
    \ top-to-bottom order.\n   The encoded contents of the tiles simply follow one\
    \ another in the\n   predetermined order.  If the width of the whole rectangle\
    \ is not an\n   exact multiple of 16, then the width of the last tile in each\
    \ row\n   will be correspondingly smaller.  Similarly, if the height of the\n\
    \   whole rectangle is not an exact multiple of 16, then the height of\n   each\
    \ tile in the final row will also be smaller.\n   Each tile is either encoded\
    \ as raw pixel data, or as a variation on\n   RRE.  Each tile has a background\
    \ pixel value, as before.  The\n   background pixel value does not need to be\
    \ explicitly specified for a\n   given tile if it is the same as the background\
    \ of the previous tile.\n   However, the background pixel value may not be carried\
    \ over if the\n   previous tile was raw.  If all of the subrectangles of a tile\
    \ have\n   the same pixel value, this can be specified once as a foreground\n\
    \   pixel value for the whole tile.  As with the background, the\n   foreground\
    \ pixel value can be left unspecified, meaning it is carried\n   over from the\
    \ previous tile.  The foreground pixel value may not be\n   carried over if the\
    \ previous tile was raw or had the SubrectsColored\n   bit set.  It may, however,\
    \ be carried over from a previous tile with\n   the AnySubrects bit clear, as\
    \ long as that tile itself carried over a\n   valid foreground from its previous\
    \ tile.\n   The data consists of each tile encoded in order.  Each tile begins\n\
    \   with a subencoding type byte, which is a mask made up of a number of\n   bits:\n\
    \           +--------------+--------------+---------------------+\n          \
    \ | No. of bytes | Type [Value] | Description         |\n           +--------------+--------------+---------------------+\n\
    \           | 1            | U8           | subencoding-mask:   |\n          \
    \ |              | [1]          | Raw                 |\n           |        \
    \      | [2]          | BackgroundSpecified |\n           |              | [4]\
    \          | ForegroundSpecified |\n           |              | [8]          |\
    \ AnySubrects         |\n           |              | [16]         | SubrectsColored\
    \     |\n           +--------------+--------------+---------------------+\n  \
    \ If the Raw bit is set, then the other bits are irrelevant;\n   width*height\
    \ pixel values follow (where width and height are the\n   width and height of\
    \ the tile).  Otherwise, the other bits in the mask\n   are as follows:\n   BackgroundSpecified\n\
    \      If set, a pixel value of bytesPerPixel bytes follows and specifies\n  \
    \    the background color for this tile.  The first non-raw tile in a\n      rectangle\
    \ must have this bit set.  If this bit isn't set, then the\n      background is\
    \ the same as the last tile.\n   ForegroundSpecified\n      If set, a pixel value\
    \ of bytesPerPixel bytes follows and specifies\n      the foreground color to\
    \ be used for all subrectangles in this\n      tile.\n      If this bit is set,\
    \ then the SubrectsColored bit must be zero.\n   AnySubrects\n      If set, a\
    \ single byte follows and gives the number of\n      subrectangles following.\
    \  If not set, there are no subrectangles\n      (i.e., the whole tile is just\
    \ solid background color).\n   SubrectsColored\n      If set, then each subrectangle\
    \ is preceded by a pixel value giving\n      the color of that subrectangle, so\
    \ a subrectangle is:\n          +---------------+--------------+---------------------+\n\
    \          | No. of bytes  | Type [Value] | Description         |\n          +---------------+--------------+---------------------+\n\
    \          | bytesPerPixel | PIXEL        | subrect-pixel-value |\n          |\
    \ 1             | U8           | x-and-y-position    |\n          | 1        \
    \     | U8           | width-and-height    |\n          +---------------+--------------+---------------------+\n\
    \      If not set, all subrectangles are the same color -- the foreground\n  \
    \    color; if the ForegroundSpecified bit wasn't set, then the\n      foreground\
    \ is the same as the last tile.  A subrectangle is:\n            +--------------+--------------+------------------+\n\
    \            | No. of bytes | Type [Value] | Description      |\n            +--------------+--------------+------------------+\n\
    \            | 1            | U8           | x-and-y-position |\n            |\
    \ 1            | U8           | width-and-height |\n            +--------------+--------------+------------------+\n\
    \   The position and size of each subrectangle is specified in two bytes,\n  \
    \ x-and-y-position and width-and-height.  The most significant 4 bits\n   of x-and-y-position\
    \ specify the X position, the least significant\n   specify the Y position.  The\
    \ most significant 4 bits of width-and-\n   height specify the width minus 1,\
    \ the least significant specify the\n   height minus 1.\n"
- title: 7.7.5.  TRLE
  contents:
  - "7.7.5.  TRLE\n   TRLE stands for Tiled Run-Length Encoding, and combines tiling,\n\
    \   palettization, and run-length encoding.  The rectangle is divided\n   into\
    \ tiles of 16x16 pixels in left-to-right, top-to-bottom order,\n   similar to\
    \ Hextile.  If the width of the rectangle is not an exact\n   multiple of 16,\
    \ then the width of the last tile in each row is\n   smaller, and if the height\
    \ of the rectangle is not an exact multiple\n   of 16, then the height of each\
    \ tile in the final row is smaller.\n   TRLE makes use of a new type CPIXEL (compressed\
    \ pixel).  This is the\n   same as a PIXEL for the agreed pixel format, except\
    \ as a special\n   case, it uses a more compact format if true-color-flag is non-zero,\n\
    \   bits-per-pixel is 32, depth is 24 or less, and all of the bits making\n  \
    \ up the red, green, and blue intensities fit in either the least\n   significant\
    \ 3 bytes or the most significant 3 bytes.  If all of these\n   are the case,\
    \ a CPIXEL is only 3 bytes long, and contains the least\n   significant or the\
    \ most significant 3 bytes as appropriate.\n   bytesPerCPixel is the number of\
    \ bytes in a CPIXEL.\n   Each tile begins with a subencoding type byte.  The top\
    \ bit of this\n   byte is set if the tile has been run-length encoded, clear otherwise.\n\
    \   The bottom 7 bits indicate the size of the palette used: zero means\n   no\
    \ palette, 1 means that the tile is of a single color, and 2 to 127\n   indicate\
    \ a palette of that size.  The special subencoding values 129\n   and 127 indicate\
    \ that the palette is to be reused from the last tile\n   that had a palette,\
    \ with and without RLE, respectively.\n   Note: in this discussion, the div(a,b)\
    \ function means the result of\n   dividing a/b truncated to an integer.\n   The\
    \ possible values of subencoding are:\n   0: Raw pixel data. width*height pixel\
    \ values follow (where width and\n      height are the width and height of the\
    \ tile):\n       +-----------------------------+--------------+-------------+\n\
    \       | No. of bytes                | Type [Value] | Description |\n       +-----------------------------+--------------+-------------+\n\
    \       | width*height*BytesPerCPixel | CPIXEL array | pixels      |\n       +-----------------------------+--------------+-------------+\n\
    \   1: A solid tile consisting of a single color.  The pixel value\n      follows:\n\
    \              +----------------+--------------+-------------+\n             \
    \ | No. of bytes   | Type [Value] | Description |\n              +----------------+--------------+-------------+\n\
    \              | bytesPerCPixel | CPIXEL       | pixelValue  |\n             \
    \ +----------------+--------------+-------------+\n   2 to 16:  Packed palette\
    \ types.  The paletteSize is the value of the\n      subencoding, which is followed\
    \ by the palette, consisting of\n      paletteSize pixel values.  The packed pixels\
    \ follow, with each\n      pixel represented as a bit field yielding a zero-based\
    \ index into\n      the palette.  For paletteSize 2, a 1-bit field is used; for\n\
    \      paletteSize 3 or 4, a 2-bit field is used; and for paletteSize\n      from\
    \ 5 to 16, a 4-bit field is used.  The bit fields are packed\n      into bytes,\
    \ with the most significant bits representing the\n      leftmost pixel (i.e.,\
    \ big endian).  For tiles not a multiple of 8,\n      4, or 2 pixels wide (as\
    \ appropriate), padding bits are used to\n      align each row to an exact number\
    \ of bytes.\n       +----------------------------+--------------+--------------+\n\
    \       | No. of bytes               | Type [Value] | Description  |\n       +----------------------------+--------------+--------------+\n\
    \       | paletteSize*bytesPerCPixel | CPIXEL array | palette      |\n       |\
    \ m                          | U8 array     | packedPixels |\n       +----------------------------+--------------+--------------+\n\
    \      where m is the number of bytes representing the packed pixels.\n      For\
    \ paletteSize of 2, this is div(width+7,8)*height; for\n      paletteSize of 3\
    \ or 4, this is div(width+3,4)*height; or for\n      paletteSize of 5 to 16, this\
    \ is div(width+1,2)*height.\n   17 to 126:  Unused.  (Packed palettes of these\
    \ sizes would offer no\n      advantage over palette RLE).\n   127:  Packed palette\
    \ with the palette reused from the previous tile.\n      The subencoding byte\
    \ is followed by the packed pixels as described\n      above for packed palette\
    \ types.\n   128:  Plain RLE.  The data consists of a number of runs, repeated\n\
    \      until the tile is done.  Runs may continue from the end of one row\n  \
    \    to the beginning of the next.  Each run is represented by a single\n    \
    \  pixel value followed by the length of the run.  The length is\n      represented\
    \ as one or more bytes.  The length is calculated as one\n      more than the\
    \ sum of all the bytes representing the length.  Any\n      byte value other than\
    \ 255 indicates the final byte.  So for\n      example, length 1 is represented\
    \ as [0], 255 as [254], 256 as\n      [255,0], 257 as [255,1], 510 as [255,254],\
    \ 511 as [255,255,0], and\n      so on.\n    +-------------------------+--------------+-----------------------+\n\
    \    | No. of bytes            | Type [Value] | Description           |\n    +-------------------------+--------------+-----------------------+\n\
    \    | bytesPerCPixel          | CPIXEL       | pixelValue            |\n    |\
    \ div(runLength - 1, 255) | U8 array     | 255                   |\n    | 1  \
    \                     | U8           | (runLength-1) mod 255 |\n    +-------------------------+--------------+-----------------------+\n\
    \   129:  Palette RLE with the palette reused from the previous tile.\n      Followed\
    \ by a number of runs, repeated until the tile is done, as\n      described below\
    \ for 130 to 255.\n   130 to 255:  Palette RLE.  Followed by the palette, consisting\
    \ of\n      paletteSize = (subencoding - 128) pixel values:\n        +----------------------------+--------------+-------------+\n\
    \        | No. of bytes               | Type [Value] | Description |\n       \
    \ +----------------------------+--------------+-------------+\n        | paletteSize*bytesPerCPixel\
    \ | CPIXEL array | palette     |\n        +----------------------------+--------------+-------------+\n\
    \      Following the palette is, as with plain RLE, a number of runs,\n      repeated\
    \ until the tile is done.  A run of length one is\n      represented simply by\
    \ a palette index:\n              +--------------+--------------+--------------+\n\
    \              | No. of bytes | Type [Value] | Description  |\n              +--------------+--------------+--------------+\n\
    \              | 1            | U8           | paletteIndex |\n              +--------------+--------------+--------------+\n\
    \      A run of length more than one is represented by a palette index\n     \
    \ with the top bit set, followed by the length of the run as for\n      plain\
    \ RLE.\n    +-------------------------+--------------+-----------------------+\n\
    \    | No. of bytes            | Type [Value] | Description           |\n    +-------------------------+--------------+-----------------------+\n\
    \    | 1                       | U8           | paletteIndex + 128    |\n    |\
    \ div(runLength - 1, 255) | U8 array     | 255                   |\n    | 1  \
    \                     | U8           | (runLength-1) mod 255 |\n    +-------------------------+--------------+-----------------------+\n"
- title: 7.7.6.  ZRLE
  contents:
  - "7.7.6.  ZRLE\n   ZRLE stands for Zlib (see [RFC1950] and [RFC1951]) Run-Length\n\
    \   Encoding, and combines an encoding similar to TRLE with zlib\n   compression.\
    \  On the wire, the rectangle begins with a 4-byte length\n   field, and is followed\
    \ by that many bytes of zlib-compressed data.  A\n   single zlib \"stream\" object\
    \ is used for a given RFB protocol\n   connection, so that ZRLE rectangles must\
    \ be encoded and decoded\n   strictly in order.\n               +--------------+--------------+-------------+\n\
    \               | No. of bytes | Type [Value] | Description |\n              \
    \ +--------------+--------------+-------------+\n               | 4          \
    \  | U32          | length      |\n               | length       | U8 array  \
    \   | zlibData    |\n               +--------------+--------------+-------------+\n\
    \   The zlibData when uncompressed represents tiles in left-to-right,\n   top-to-bottom\
    \ order, similar to TRLE, but with a tile size of 64x64\n   pixels.  If the width\
    \ of the rectangle is not an exact multiple of\n   64, then the width of the last\
    \ tile in each row is smaller, and if\n   the height of the rectangle is not an\
    \ exact multiple of 64, then the\n   height of each tile in the final row is smaller.\n\
    \   The tiles are encoded in exactly the same way as TRLE, except that\n   subencoding\
    \ may not take the values 127 or 129, i.e., palettes cannot\n   be reused between\
    \ tiles.\n   The server flushes the zlib stream to a byte boundary at the end\
    \ of\n   each ZRLE-encoded rectangle.  It need not flush the stream between\n\
    \   tiles within a rectangle.  Since the zlibData for a single rectangle\n   can\
    \ potentially be quite large, clients can incrementally decode and\n   interpret\
    \ the zlibData but must not assume that encoded tile data is\n   byte aligned.\n"
- title: 7.8.  Pseudo-Encodings
  contents:
  - "7.8.  Pseudo-Encodings\n   An update rectangle with a \"pseudo-encoding\" does\
    \ not directly\n   represent pixel data but instead allows the server to send\
    \ arbitrary\n   data to the client.  How this data is interpreted depends on the\n\
    \   pseudo-encoding.\n"
- title: 7.8.1.  Cursor Pseudo-Encoding
  contents:
  - "7.8.1.  Cursor Pseudo-Encoding\n   A client that requests the Cursor pseudo-encoding\
    \ is declaring that\n   it is capable of drawing a pointer cursor locally.  This\
    \ can\n   significantly improve perceived performance over slow links.  The\n\
    \   server sets the cursor shape by sending a rectangle with the Cursor\n   pseudo-encoding\
    \ as part of an update.  The rectangle's x-position and\n   y-position indicate\
    \ the hotspot of the cursor, and width and height\n   indicate the width and height\
    \ of the cursor in pixels.  The data\n   consists of width*height raw pixel values\
    \ followed by a shape\n   bitmask, with one bit corresponding to each pixel in\
    \ the cursor\n   rectangle.  The bitmask consists of left-to-right, top-to-bottom\
    \ scan\n   lines, where each scan line is padded to a whole number of bytes, the\n\
    \   number being div(width+7,8).  Within each byte, the most significant\n   bit\
    \ represents the leftmost pixel; a bit set to 1 means the\n   corresponding pixel\
    \ in the cursor is valid.\n       +----------------------------+--------------+---------------+\n\
    \       | No. of bytes               | Type [Value] | Description   |\n      \
    \ +----------------------------+--------------+---------------+\n       | width*height*bytesPerPixel\
    \ | PIXEL array  | cursor-pixels |\n       | div(width+7,8)*height      | U8 array\
    \     | bitmask       |\n       +----------------------------+--------------+---------------+\n"
- title: 7.8.2.  DesktopSize Pseudo-Encoding
  contents:
  - "7.8.2.  DesktopSize Pseudo-Encoding\n   A client that requests the DesktopSize\
    \ pseudo-encoding is declaring\n   that it is capable of coping with a change\
    \ in the framebuffer width\n   and height.  The server changes the desktop size\
    \ by sending a\n   rectangle with the DesktopSize pseudo-encoding as the last\
    \ rectangle\n   in an update.  The rectangle's x-position and y-position are ignored,\n\
    \   and width and height indicate the new width and height of the\n   framebuffer.\n\
    \   There is no further data associated with the rectangle.  After\n   changing\
    \ the desktop size, the server must assume that the client no\n   longer has the\
    \ previous framebuffer contents.  This will usually\n   result in a complete update\
    \ of the framebuffer at the next update.\n   However, for maximum interoperability\
    \ with existing servers the\n   client should preserve the top-left portion of\
    \ the framebuffer\n   between the old and new sizes.\n"
- title: 8.  IANA Considerations
  contents:
  - "8.  IANA Considerations\n   IANA has allocated port 5900 to the RFB protocol.\
    \  The other port\n   numbers mentioned in Section 2 are called out for historical\
    \ context\n   and do not match IANA allocations.\n   Future assignments to the\
    \ IANA registries created by this\n   specification are to be made through either\
    \ \"Expert Review\" or \"IESG\n   Approval\" (if there is no currently appointed\
    \ expert) as defined in\n   [RFC5226].\n"
- title: 8.1.  RFB Security Types
  contents:
  - '8.1.  RFB Security Types

    '
- title: 8.1.1.  Registry Name
  contents:
  - "8.1.1.  Registry Name\n   The name of this registry is \"Remote Framebuffer Security\
    \ Types\".\n"
- title: 8.1.2.  Registry Contents
  contents:
  - "8.1.2.  Registry Contents\n   IANA established a registry for security types\
    \ that are used with the\n   RFB protocol.\n   The initial entries in the registry\
    \ are:\n     +------------+-------------------------+-----------------------+\n\
    \     | Number     | Name                    | References            |\n     +------------+-------------------------+-----------------------+\n\
    \     | 0          | Invalid                 | (this document)       |\n     |\
    \ 1          | None                    | (this document)       |\n     | 2   \
    \       | VNC Authentication      | (this document)       |\n     | 3 to 15  \
    \  | RealVNC                 | (historic assignment) |\n     | 16         | Tight\
    \                   | (historic assignment) |\n     | 17         | Ultra     \
    \              | (historic assignment) |\n     | 18         | TLS            \
    \         | (historic assignment) |\n     | 19         | VeNCrypt            \
    \    | (historic assignment) |\n     | 20         | GTK-VNC SASL            |\
    \ (historic assignment) |\n     | 21         | MD5 hash authentication | (historic\
    \ assignment) |\n     | 22         | Colin Dean xvp          | (historic assignment)\
    \ |\n     | 128 to 255 | RealVNC                 | (historic assignment) |\n \
    \    +------------+-------------------------+-----------------------+\n"
- title: 8.2.  Client-to-Server Message Types
  contents:
  - '8.2.  Client-to-Server Message Types

    '
- title: 8.2.1.  Registry Name
  contents:
  - "8.2.1.  Registry Name\n   The name of this registry is \"Remote Framebuffer Client-to-Server\n\
    \   Message Types\".\n"
- title: 8.2.2.  Registry Contents
  contents:
  - "8.2.2.  Registry Contents\n   IANA established a registry for client-to-server\
    \ message types that\n   are used with the RFB protocol.\n   The initial entries\
    \ in the registry are:\n     +--------+------------------------------+-----------------------+\n\
    \     | Number | Name                         | References            |\n    \
    \ +--------+------------------------------+-----------------------+\n     | 0\
    \      | SetPixelFormat               | (this document)       |\n     | 2    \
    \  | SetEncodings                 | (this document)       |\n     | 3      | FramebufferUpdateRequest\
    \     | (this document)       |\n     | 4      | KeyEvent                    \
    \ | (this document)       |\n     | 5      | PointerEvent                 | (this\
    \ document)       |\n     | 6      | ClientCutText                | (this document)\
    \       |\n     | 127    | VMWare                       | (historic assignment)\
    \ |\n     | 128    | Nokia Terminal Mode Spec     | (historic assignment) |\n\
    \     | 249    | OLIVE Call Control           | (historic assignment) |\n    \
    \ | 250    | Colin Dean xvp               | (historic assignment) |\n     | 251\
    \    | Pierre Ossman SetDesktopSize | (historic assignment) |\n     | 252    |\
    \ tight                        | (historic assignment) |\n     | 253    | gii\
    \                          | (historic assignment) |\n     | 254    | VMWare \
    \                      | (historic assignment) |\n     | 255    | Anthony Liguori\
    \              | (historic assignment) |\n     +--------+------------------------------+-----------------------+\n"
- title: 8.3.  Server-to-Client Message Types
  contents:
  - '8.3.  Server-to-Client Message Types

    '
- title: 8.3.1.  Registry Name
  contents:
  - "8.3.1.  Registry Name\n   The name of this registry is \"Remote Framebuffer Server-to-Client\n\
    \   Message Types\".\n"
- title: 8.3.2.  Registry Contents
  contents:
  - "8.3.2.  Registry Contents\n   IANA established a registry for server-to-client\
    \ message types that\n   are used with the RFB protocol.\n   The initial entries\
    \ in the registry are:\n       +--------+--------------------------+-----------------------+\n\
    \       | Number | Name                     | References            |\n      \
    \ +--------+--------------------------+-----------------------+\n       | 0  \
    \    | FramebufferUpdate        | (this document)       |\n       | 1      | SetColourMapEntries\
    \      | (this document)       |\n       | 2      | Bell                     |\
    \ (this document)       |\n       | 3      | ServerCutText            | (this\
    \ document)       |\n       | 127    | VMWare                   | (historic assignment)\
    \ |\n       | 128    | Nokia Terminal Mode Spec | (historic assignment) |\n  \
    \     | 249    | OLIVE Call Control       | (historic assignment) |\n       |\
    \ 250    | Colin Dean xvp           | (historic assignment) |\n       | 252  \
    \  | tight                    | (historic assignment) |\n       | 253    | gii\
    \                      | (historic assignment) |\n       | 254    | VMWare   \
    \                | (historic assignment) |\n       | 255    | Anthony Liguori\
    \          | (historic assignment) |\n       +--------+--------------------------+-----------------------+\n"
- title: 8.4.  RFB Encoding Types
  contents:
  - '8.4.  RFB Encoding Types

    '
- title: 8.4.1.  Registry Name
  contents:
  - "8.4.1.  Registry Name\n   The name of this registry is \"Remote Framebuffer Encoding\
    \ Types\".\n"
- title: 8.4.2.  Registry Contents
  contents:
  - "8.4.2.  Registry Contents\n   IANA established a registry for encoding types\
    \ that are used with the\n   RFB protocol.\n   The initial entries in the registry\
    \ are:\n   +-------------------+----------------------------+------------------+\n\
    \   | Number            | Name                       | References       |\n  \
    \ +-------------------+----------------------------+------------------+\n   |\
    \ 0                 | Raw                        | (this document)  |\n   | 1\
    \                 | CopyRect                   | (this document)  |\n   | 2  \
    \               | RRE                        | (this document)  |\n   | 5    \
    \             | Hextile                    | (this document)  |\n   | 16     \
    \           | ZRLE                       | (this document)  |\n   | -239     \
    \         | Cursor pseudo-encoding     | (this document)  |\n   | -223       \
    \       | DesktopSize                | (this document)  |\n   |              \
    \     | pseudo-encoding            |                  |\n   | 4              \
    \   | CoRRE                      | (historic        |\n   |                  \
    \ |                            | assignment)      |\n   | 6                 |\
    \ zlib                       | (historic        |\n   |                   |  \
    \                          | assignment)      |\n   | 7                 | tight\
    \                      | (historic        |\n   |                   |        \
    \                    | assignment)      |\n   | 8                 | zlibhex  \
    \                  | (historic        |\n   |                   |            \
    \                | assignment)      |\n   | 15                | TRLE         \
    \              | (this document)  |\n   | 17                | Hitachi ZYWRLE \
    \            | (historic        |\n   |                   |                  \
    \          | assignment)      |\n   | 1024 to 1099      | RealVNC            \
    \        | (historic        |\n   |                   |                      \
    \      | assignment)      |\n   | -1 to -222        | tight options          \
    \    | (historic        |\n   |                   |                          \
    \  | assignment)      |\n   | -224 to -238      | tight options              |\
    \ (historic        |\n   |                   |                            | assignment)\
    \      |\n   | -240 to -256      | tight options              | (historic    \
    \    |\n   |                   |                            | assignment)    \
    \  |\n   | -257 to -272      | Anthony Liguori            | (historic        |\n\
    \   |                   |                            | assignment)      |\n  \
    \ | -273 to -304      | VMWare                     | (historic        |\n   |\
    \                   |                            | assignment)      |\n   | -305\
    \              | gii                        | (historic        |\n   |       \
    \            |                            | assignment)      |\n   | -306    \
    \          | popa                       | (historic        |\n   |           \
    \        |                            | assignment)      |\n   | -307        \
    \      | Peter Astrand DesktopName  | (historic        |\n   |               \
    \    |                            | assignment)      |\n   | -308            \
    \  | Pierre Ossman              | (historic        |\n   |                   |\
    \ ExtendedDesktopSize        | assignment)      |\n   | -309              | Colin\
    \ Dean xvp             | (historic        |\n   |                   |        \
    \                    | assignment)      |\n   | -310              | OLIVE Call\
    \ Control         | (historic        |\n   |                   |             \
    \               | assignment)      |\n   | -412 to -512      | TurboVNC fine-grained\
    \      | (historic        |\n   |                   | quality level          \
    \    | assignment)      |\n   | -523 to -524      | Nokia Terminal Mode Spec \
    \  | (historic        |\n   |                   |                            |\
    \ assignment)      |\n   | -763 to -768      | TurboVNC subsampling level | (historic\
    \        |\n   |                   |                            | assignment)\
    \      |\n   | 0x574d5600 to     | VMWare                     | (historic    \
    \    |\n   | 0x574d56ff        |                            | assignment)    \
    \  |\n   +-------------------+----------------------------+------------------+\n"
- title: 9.  Security
  contents:
  - "9.  Security\n   The RFB protocol as defined here provides no security beyond\
    \ the\n   optional and cryptographically weak password check described in\n  \
    \ Section 7.2.2.  In particular, it provides no protection against\n   observation\
    \ of or tampering with the data stream.  It has typically\n   been used on secure\
    \ physical or virtual networks.\n   Security methods beyond those described here\
    \ may be used to protect\n   the integrity of the data.  The client and server\
    \ might agree to use\n   an extended security type to encrypt the session, or\
    \ the session\n   might be transmitted over a secure channel such as IPsec [RFC4301]\
    \ or\n   SSH [RFC4254].\n"
- title: 10.  Acknowledgements
  contents:
  - "10.  Acknowledgements\n   James Weatherall, Andy Harter, and Ken Wood also contributed\
    \ to the\n   design of the RFB protocol.\n   RFB and VNC are registered trademarks\
    \ of RealVNC Ltd. in the U.S. and\n   in other countries.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [RFC1950]  Deutsch, L. and J-L. Gailly, \"ZLIB\
    \ Compressed Data Format\n              Specification version 3.3\", RFC 1950,\
    \ May 1996.\n   [RFC1951]  Deutsch, P., \"DEFLATE Compressed Data Format Specification\n\
    \              version 1.3\", RFC 1951, May 1996.\n   [XLIBREF]  Nye, A., \"XLIB\
    \ Reference Manual R5\", June 1994.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [RFC4254]  Ylonen, T. and C. Lonvick, \"The\
    \ Secure Shell (SSH)\n              Connection Protocol\", RFC 4254, January 2006.\n\
    \   [RFC4301]  Kent, S. and K. Seo, \"Security Architecture for the\n        \
    \      Internet Protocol\", RFC 4301, December 2005.\n   [RFC5226]  Narten, T.\
    \ and H. Alvestrand, \"Guidelines for Writing an\n              IANA Considerations\
    \ Section in RFCs\", BCP 26, RFC 5226,\n              May 2008.\n"
- title: Appendix A.  Differences in Earlier Protocol Versions
  contents:
  - "Appendix A.  Differences in Earlier Protocol Versions\n   For maximum interoperability,\
    \ clients and servers should be prepared\n   to fall back to the earlier 3.3 and\
    \ 3.7 versions of the RFB protocol.\n   Any version reported other than 3.7 or\
    \ 3.8 should be treated as 3.3.\n   All of the differences occur in the initial\
    \ handshake phase.  Once\n   the session reaches the ClientInit and ServerInit\
    \ messages, all three\n   protocol versions are identical.  Even within a protocol\
    \ version,\n   clients and servers may support different subsets of the encoding\
    \ and\n   pseudo-encoding types.\n"
- title: A.1.  Differences in the Version 3.3 Protocol
  contents:
  - "A.1.  Differences in the Version 3.3 Protocol\n   The ProtocolVersion message\
    \ is:\n       RFB 003.003\\n (hex 52 46 42 20 30 30 33 2e 30 30 33 0a)\n   In\
    \ the security handshake (Section 7.1.2), rather than a two-way\n   negotiation,\
    \ the server decides the security type and sends a single\n   word:\n        \
    \      +--------------+--------------+---------------+\n              | No. of\
    \ bytes | Type [Value] | Description   |\n              +--------------+--------------+---------------+\n\
    \              | 4            | U32          | security-type |\n             \
    \ +--------------+--------------+---------------+\n   The security-type may only\
    \ take the value 0, 1, or 2.  A value of 0\n   means that the connection has failed\
    \ and is followed by a string\n   giving the reason, as described in Section 7.1.2.\n\
    \   If the security-type is 1, for no authentication, the server does not\n  \
    \ send the SecurityResult message but proceeds directly to the\n   initialization\
    \ messages (Section 7.3).\n   In VNC Authentication (Section 7.2.2), if the authentication\
    \ fails,\n   the server sends the SecurityResult message, but does not send an\n\
    \   error message before closing the connection.\n"
- title: A.2.  Differences in the Version 3.7 Protocol
  contents:
  - "A.2.  Differences in the Version 3.7 Protocol\n   The ProtocolVersion message\
    \ is:\n       RFB 003.007\\n (hex 52 46 42 20 30 30 33 2e 30 30 37 0a)\n   After\
    \ the security handshake, if the security-type is 1, for no\n   authentication,\
    \ the server does not send the SecurityResult message\n   but proceeds directly\
    \ to the initialization messages (Section 7.3).\n   In VNC Authentication (Section\
    \ 7.2.2), if the authentication fails,\n   the server sends the SecurityResult\
    \ message, but does not send an\n   error message before closing the connection.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Tristan Richardson\n   RealVNC Ltd.\n   Betjeman House,\
    \ 104 Hills Road\n   Cambridge  CB2 1LQ\n   UK\n   Phone: +44 1223 310400\n  \
    \ EMail: standards@realvnc.com\n   URI:   http://www.realvnc.com\n   John Levine\n\
    \   RealVNC Ltd.\n   Phone: +44 1223 790005\n   EMail: standards@taugh.com\n \
    \  URI:   http://jl.ly\n"
