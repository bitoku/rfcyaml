- title: __initial_text__
  contents:
  - '                 NETBLT: A Bulk Data Transfer Protocol

    '
- title: 1. STATUS OF THIS MEMO
  contents:
  - "1. STATUS OF THIS MEMO\n   This RFC suggests a proposed protocol for the ARPA-Internet\n\
    \   community, and requests discussion and suggestions for improvements.\n   This\
    \ is a preliminary discussion of the NETBLT protocol.  It is\n   published for\
    \ discussion and comment, and does not constitute a\n   standard.  As the proposal\
    \ may change, implementation of this\n   document is not advised.  Distribution\
    \ of this memo is unlimited.\n"
- title: 2. INTRODUCTION
  contents:
  - "2. INTRODUCTION\n   NETBLT (Network Block Transfer) is a transport level protocol\n\
    \   intended for the rapid transfer of a large quantity of data between\n   computers.\
    \ It provides a transfer that is reliable and flow\n   controlled, and is structured\
    \ to provide maximum throughput over a\n   wide variety of networks.\n   The protocol\
    \ works by opening a connection between two clients the\n   sender and the receiver),\
    \ transferring the data in a series of large\n   data aggregates called buffers,\
    \ and then closing the connection.\n   Because the amount of data to be transferred\
    \ can be arbitrarily\n   large, the client is not required to provide at once\
    \ all the data to\n   the protocol module.  Instead, the data is provided by the\
    \ client in\n   buffers.  The NETBLT layer transfers each buffer as a sequence\
    \ of\n   packets, but since each buffer is composed of a large number of\n   packets,\
    \ the per-buffer interaction between NETBLT and its client is\n   far more efficient\
    \ than a per-packet interaction would be.\n   In its simplest form, a NETBLT transfer\
    \ works as follows.  The\n   sending client loads a buffer of data and calls down\
    \ to the NETBLT\n   layer to transfer it.  The NETBLT layer breaks the buffer\
    \ up into\n   packets and sends these packets across the network in Internet\n\
    \   datagrams.  The receiving NETBLT layer loads these packets into a\n   matching\
    \ buffer provided by the receiving client.  When the last\n   packet in the buffer\
    \ has been transmitted, the receiving NETBLT\n   checks to see that all packets\
    \ in that buffer have arrived.  If some\n   packets are missing, the receiving\
    \ NETBLT requests that they be\n   resent.  When the buffer has been completely\
    \ transmitted, the\n   receiving client is notified by its NETBLT layer.  The\
    \ receiving\n   client disposes of the buffer and provides a new buffer to receive\n\
    \   more data.  The receiving NETBLT notifies the sender that the buffer\n   arrived,\
    \ and the sender prepares and sends the next buffer in the\n"
- title: RFC 969                                                    December 1985
  contents:
  - 'RFC 969                                                    December 1985

    '
- title: 'NETBLT: A Bulk Data Transfer Protocol'
  contents:
  - "NETBLT: A Bulk Data Transfer Protocol\n   same manner.  This continues until\
    \ all buffers have been sent, at\n   which time the sender notifies the receiver\
    \ that the transmission has\n   been completed.  The connection is then closed.\n\
    \   As described above, the NETBLT protocol is \"lock-step\"; action is\n   halted\
    \ after a buffer is transmitted, and begins again after\n   confirmation is received\
    \ from the receiver of data.  NETBLT provides\n   for multiple buffering, in which\
    \ several buffers can be transmitted\n   concurrently.  Multiple buffering makes\
    \ packet flow essentially\n   continuous and can improve performance markedly.\n\
    \   The remainder of this document describes NETBLT in detail.  The next\n   sections\
    \ describe the philosophy behind a number of protocol\n   features: packetization,\
    \ flow control, reliability, and connection\n   management. The final sections\
    \ describe the protocol format.\n"
- title: 3. BUFFERS AND PACKETS
  contents:
  - "3. BUFFERS AND PACKETS\n   NETBLT is designed to permit transfer of an essentially\
    \ arbitrary\n   amount of data between two clients.  During connection setup the\n\
    \   sending NETBLT can optionally inform the receiving NETBLT of the\n   transfer\
    \ size; the maximum transfer length is imposed by the field\n   width, and is\
    \ 2**32 bytes.  This limit should permit any practical\n   application.  The transfer\
    \ size parameter is for the use of the\n   receiving client; the receiving NETBLT\
    \ makes no use of it.  A NETBLT\n   receiver accepts data until told by the sender\
    \ that the transfer is\n   complete.\n   The data to be sent must be broken up\
    \ into buffers by the client.\n   Each buffer must be the same size, save for\
    \ the last buffer.  During\n   connection setup, the sending and receiving NETBLTs\
    \ negotiate the\n   buffer size, based on limits provided by the clients.  Buffer\
    \ sizes\n   are in bytes only; the client is responsible for breaking up data\n\
    \   into buffers on byte boundaries.\n   NETBLT has been designed and should be\
    \ implemented to work with\n   buffers of arbitrary size.  The only fundamental\
    \ limitation on buffer\n   size should be the amount of memory available to the\
    \ client.  Buffers\n   should be as large as possible since this minimizes the\
    \ number of\n   buffer transmissions and therefore improves performance.\n   NETBLT\
    \ is designed to require a minimum of its own memory, allowing\n   the client\
    \ to allocate as much memory as possible for buffer storage.\n   In particular,\
    \ NETBLT does not keep buffer copies for retransmission\n   purposes.  Instead,\
    \ data to be retransmitted is recopied directly\n"
- title: RFC 969                                                    December 1985
  contents:
  - 'RFC 969                                                    December 1985

    '
- title: 'NETBLT: A Bulk Data Transfer Protocol'
  contents:
  - "NETBLT: A Bulk Data Transfer Protocol\n   from the client buffer.  This does\
    \ mean that the client cannot\n   release buffer storage piece by piece as the\
    \ buffer is sent, but this\n   has not proved a problem in preliminary NETBLT\
    \ implementations.\n   Buffers are broken down by the NETBLT layer into sequences\
    \ of DATA\n   packets.  As with the buffer size, the packet size is negotiated\n\
    \   between the sending and receiving NETBLTs during connection setup.\n   Unlike\
    \ buffer size, packet size is visible only to the NETBLT layer.\n   All DATA packets\
    \ save the last packet in a buffer must be the same\n   size.  Packets should\
    \ be as large as possible, since in most cases\n   (including the preliminary\
    \ protocol implementation) performance is\n   directly related to packet size.\
    \  At the same time, the packets\n   should not be so large as to cause Internet\
    \ fragmentation, since this\n   normally causes performance degrada- tion.\n \
    \  All buffers save the last buffer must be the same size; obviously the\n   last\
    \ buffer can be any size required to complete the transfer. Since\n   the receiving\
    \ NETBLT does not know the transfer size in advance, it\n   needs some way of\
    \ identifying the last packet in each buffer.  For\n   this reason, the last packet\
    \ of every buffer is not a DATA packet but\n   rather an LDATA packet.  DATA and\
    \ LDATA packets are identical save\n   for the packet type.\n"
- title: 4. FLOW CONTROL
  contents:
  - "4. FLOW CONTROL\n   NETBLT uses two strategies for flow control, one internal\
    \ and one at\n   the client level.\n   The sending and receiving NETBLTs transmit\
    \ data in buffers; client\n   flow control is therefore at a buffer level.  Before\
    \ a buffer can be\n   transmitted, NETBLT confirms that both clients have set\
    \ up matching\n   buffers, that one is ready to send data, and that the other\
    \ is ready\n   to receive data.  Either client can therefore control the flow\
    \ of\n   data by not providing a new buffer.  Clients cannot stop a buffer\n \
    \  transfer while it is in progress.\n   Since buffers can be quite large, there\
    \ has to be another method for\n   flow control that is used during a buffer transfer.\
    \  The NETBLT layer\n   provides this form of flow control.\n   There are several\
    \ flow control problems that could arise while a\n   buffer is being transmitted.\
    \  If the sending NETBLT is transferring\n   data faster than the receiving NETBLT\
    \ can process it, the receiver's\n   ability to buffer unprocessed packets could\
    \ be overflowed, causing\n   packets to be lost.  Similarly, a slow gateway or\
    \ intermediate\n   network could cause packets to collect and overflow network\
    \ packet\n"
- title: RFC 969                                                    December 1985
  contents:
  - 'RFC 969                                                    December 1985

    '
- title: 'NETBLT: A Bulk Data Transfer Protocol'
  contents:
  - "NETBLT: A Bulk Data Transfer Protocol\n   buffer space.  Packets will then be\
    \ lost within the network,\n   degrading performance.  This problem is particularly\
    \ acute for NETBLT\n   because NETBLT buffers will generally be quite large, and\
    \ therefore\n   composed of many packets.\n   A traditional solution to packet\
    \ flow control is a window system, in\n   which the sending end is permitted to\
    \ send only a certain number of\n   packets at a time.  Unfortunately, flow control\
    \ using windows tends\n   to result in low throughput.  Windows must be kept small\
    \ in order to\n   avoid overflowing hosts and gateways, and cannot easily be updated,\n\
    \   since an end-to-end exchange is required for each change.\n   To permit high\
    \ throughput over a variety of networks and gateways of\n   differing speeds,\
    \ NETBLT uses a novel flow control ethod: rate\n   control.  The transmission\
    \ rate is negotiated by the sending and\n   receiving NETBLTs during connection\
    \ setup and after each buffer\n   transmission.  The sender uses timers, rather\
    \ than messages from the\n   receiver, to maintain the negotiated rate.\n   In\
    \ its simplest form, rate control specifies a minimum time period\n   per packet\
    \ transmission.  This can cause performance problems for\n   several reasons:\
    \ the transmission time for a single packet is very\n   small, frequently smaller\
    \ than the granularity of the timing\n   mechanism.  Also, the overhead required\
    \ to maintain timing mechanisms\n   on a per packet basis is relatively high,\
    \ which degrades performance.\n   The solution is to control the transmission\
    \ rate of groups of\n   packets, rather than single packets.  The sender transmits\
    \ a burst of\n   packets over negotiated interval, then sends another burst. \
    \ In this\n   way, the overhead decreases by a factor of the burst size, and the\n\
    \   per-burst transmission rate is large enough that timing mechanisms\n   will\
    \ work properly.  The NETBLT's rate control therefore has two\n   parts, a burst\
    \ size and a burst rate, with (burst size)/(burst rate)\n   equal to the average\
    \ transmission rate per packet.\n   The burst size and burst rate should be based\
    \ not only on the packet\n   transmission and processing speed which each end\
    \ can handle, but also\n   on the capacities of those gateways and networks intermediate\
    \ to the\n   transfer.  Following are some intuitive values for packet size,\n\
    \   buffer size, burst size, and burst rate.\n   Packet sizes can be as small\
    \ as 128 bytes.  Performance with packets\n   this small is almost always bad,\
    \ because of the high per-packet\n   processing overhead.  Even the default Internet\
    \ Protocol packet size\n   of 576 bytes is barely big enough for adequate performance.\
    \  Most\n"
- title: RFC 969                                                    December 1985
  contents:
  - 'RFC 969                                                    December 1985

    '
- title: 'NETBLT: A Bulk Data Transfer Protocol'
  contents:
  - "NETBLT: A Bulk Data Transfer Protocol\n   networks do not support packet sizes\
    \ much larger than one or two\n   thousand bytes, and packets of this size can\
    \ also get fragmented when\n   traveling over intermediate networks, degrading\
    \ performance.\n   The size of a NETBLT buffer is limited only by the amount of\
    \ memory\n   available to a client.  Theoretically, buffers of 100K bytes or more\n\
    \   are possible.  This would mean the transmission of 50 to 100 packets\n   per\
    \ buffer.\n   The burst size and burst rate are obviously very machine dependent.\n\
    \   There is a certain amount of transmission overhead in the sending and\n  \
    \ receiving machines associated with maintaining timers and scheduling\n   processes.\
    \  This overhead can be minimized by sending packets in\n   large bursts.  There\
    \ are also limitations imposed on the burst size\n   by the number of available\
    \ packet buffers.  On most modern operating\n   systems, a burst size of between\
    \ five and ten packets should reduce\n   the overhead to an acceptable level.\
    \  In fact, a preliminary NETBLT\n   implementation for the IBM PC/AT sends packets\
    \ in bursts of five.  It\n   could send more, but is limited by available memory.\n\
    \   The burst rate is in part determined by the granularity of the\n   sender's\
    \ timing mechanism, and in part by the processing speed of the\n   receiver and\
    \ any intermediate gateways.  It is also directly related\n   to the burst size.\
    \  Burst rates from 60 to 100 milliseconds have been\n   tried on the preliminary\
    \ NETBLT implementation with good results\n   within a single local-area network.\
    \  This value clearly depends on\n   the network bandwidth and packet buffering\
    \ available.\n   All NETBLT flow control parameters (packet size, buffer size,\
    \ burst\n   size, and burst rate) are negotiated during connection setup.  The\n\
    \   negotiation process is the same for all parameters.  The client\n   initiating\
    \ the connection (the active end) proposes and sends a set\n   of values for each\
    \ parameter with its open connection request.  The\n   other client (the passive\
    \ end) compares these values with the\n   highest-performance values it can support.\
    \  The passive end can then\n   modify any of the parameters only by making them\
    \ more restrictive.\n   The modified parameters are then sent back to the active\
    \ end in the\n   response message.  In addition, the burst size and burst rate\
    \ can be\n   re-negotiated after each buffer transmission to adjust the transfer\n\
    \   rate according to the performance observed from transferring the\n   previous\
    \ buffer.  The receiving end sends a pair of burst size and\n   burst rate values\
    \ in the OK message.  The sender compares these\n   values with the values it\
    \ can support.  Again, it may then modify any\n   of the parameters only by making\
    \ them more restrictive.  The modified\n   parameters are then communicated to\
    \ the receiver in a NULL-ACK\n   packet, described later.\n"
- title: RFC 969                                                    December 1985
  contents:
  - 'RFC 969                                                    December 1985

    '
- title: 'NETBLT: A Bulk Data Transfer Protocol'
  contents:
  - "NETBLT: A Bulk Data Transfer Protocol\n   Obviously each of the parameters depend\
    \ on many factors-- gateway and\n   host processing speeds, available memory,\
    \ timer granularity--some of\n   which cannot be checked by either client.  Each\
    \ client must therefore\n   try to make as best a guess as it can, tuning for\
    \ performance on\n   subsequent transfers.\n"
- title: 5. RELIABILITY
  contents:
  - "5. RELIABILITY\n   Each NETBLT transfer has three stages, connection setup, data\n\
    \   transfer, and connection close.  Each stage must be completed\n   reliably;\
    \ methods for doing this are described below.\n   5.1. Connection Setup\n    \
    \  A NETBLT connection is set up by an exchange of two packets\n      between\
    \ the active client and the passive client.  Note that\n      either client can\
    \ send or receive data; the words \"active\" and\n      \"passive\" are only used\
    \ to differentiate the client initiating the\n      connection process from the\
    \ client responding to the connection\n      request.  The first packet sent is\
    \ an OPEN packet; the passive end\n      acknowledges the OPEN packet by sending\
    \ a RESPONSE packet.  After\n      these two packets have been exchanged, the\
    \ transfer can begin.\n      As discussed in the previous section, the OPEN and\
    \ RESPONSE\n      packets are used to negotiate flow control parameters.  Other\n\
    \      parameters used in the transfer of data are also negotiated.\n      These\
    \ parameters are (1) the maximum number of buffers that can be\n      sending\
    \ at any one time (this permits multiple buffering and\n      higher throughput)\
    \ and (2) whether or not DATA/LDATA packet data\n      will be checksummed.  NETBLT\
    \ automatically checksums all\n      non-DATA/LDATA packets.  If the negotiated\
    \ checksum flag is set to\n      TRUE (1), both the header and the data of a DATA/LDATA\
    \ packet are\n      checksummed; if set to FALSE (0), only the header is checksummed.\n\
    \      NETBLT uses the same checksumming algorithm as TCP uses.\n      Finally,\
    \ each end transmits its death-timeout value in either the\n      OPEN or the\
    \ RESPONSE packet.  The death-timeout value will be used\n      to determine the\
    \ frequency with which to send KEEPALIVE packets\n      during idle periods of\
    \ an opened connection (death timers and\n      KEEPALIVE packets are described\
    \ in the following section).\n      The active end specifies a passive client\
    \ through a\n      client-specific \"well-known\" 16 bit port number on which\
    \ the\n      passive end listens.  The active end identifies itself through a\n\
    \      32 bit Internet address and a 16 bit port number.\n      In order to allow\
    \ the active and passive ends to communicate\n"
- title: RFC 969                                                    December 1985
  contents:
  - 'RFC 969                                                    December 1985

    '
- title: 'NETBLT: A Bulk Data Transfer Protocol'
  contents:
  - "NETBLT: A Bulk Data Transfer Protocol\n      miscellaneous useful information,\
    \ an unstructured, variable-\n      length field is provided in OPEN and RESPONSE\
    \ messages for an\n      client-specific information that may be required.\n \
    \     Recovery for lost OPEN and RESPONSE packets is provided by the use\n   \
    \   of timers.  The active end sets a timer when it sends an OPEN\n      packet.\
    \ When the timer expires, another OPEN packet is sent, until\n      some pre-determined\
    \ maximum number of OPEN packets have been sent.\n      A similar scheme is used\
    \ for the passive end when it sends a\n      RESPONSE packet.  When a RESPONSE\
    \ packet is received by the active\n      end, it clears its timer.  The passive\
    \ end's timer is cleared\n      either by receipt of a GO or a DATA packet, as\
    \ described in the\n      section on data transfer.\n      To prevent duplication\
    \ of OPEN and RESPONSE packets, the OPEN\n      packet contains a 32 bit connection\
    \ unique ID that must be\n      returned in the RESPONSE packet.  This prevents\
    \ the initiator from\n      confusing the response to the current request with\
    \ the response to\n      an earlier connection request (there can only be one\
    \ connection\n      between any two ports).  Any OPEN or RESPONSE packet with\
    \ a\n      destination port matching that of an open connection has its\n    \
    \  unique ID checked.  A matching unique ID implies a duplicate\n      packet,\
    \ and the packet is ignored.  A non-matching unique ID must\n      be treated\
    \ as an attempt to open a second connection between the\n      same port pair\
    \ and must be rejected by sending an ABORT message.\n   5.2. Data Transfer\n \
    \     The simplest model of data transfer proceeds as follows.  The\n      sending\
    \ client sets up a buffer full of data.  The receiving\n      NETBLT sends a GO\
    \ message inside a CONTROL packet to the sender,\n      signifying that it too\
    \ has set up a buffer and is ready to receive\n      data into it. Once the GO\
    \ message has been received, the sender\n      transmits the buffer as a series\
    \ of DATA packets followed by an\n      LDATA packet.  When the last packet in\
    \ the buffer has been\n      received, the receiver sends a RESEND message inside\
    \ a CONTROL\n      packet containing a list of packets that were not received.\
    \  The\n      sender resends these packets.  This process continues until there\n\
    \      are no missing packets, at which time the receiver sends an OK\n      message\
    \ inside a CONTROL packet to the sender, sets up another\n      buffer to receive\
    \ data and sends another GO message.  The sender,\n      having received the OK\
    \ message, sets up another buffer, waits for\n      the GO message, and repeats\
    \ the process.\n      There are several obvious flaws with this scheme.  First,\
    \ if the\n      LDATA packet is lost, how does the receiver know when the buffer\n\
    \      has been transmitted?  Second, what if the GO, OK, or RESEND\n"
- title: RFC 969                                                    December 1985
  contents:
  - 'RFC 969                                                    December 1985

    '
- title: 'NETBLT: A Bulk Data Transfer Protocol'
  contents:
  - "NETBLT: A Bulk Data Transfer Protocol\n      messages are lost?  The sender cannot\
    \ act on a packet it has not\n      received, so the protocol will hang.  Solutions\
    \ for each of these\n      problems are presented below, and are based on two\
    \ kinds of\n      timers, a data timer and a control timer.\n      NETBLT solves\
    \ the LDATA packet loss problem by using a data timer\n      at the receiving\
    \ end.  When the first DATA packet in a buffer\n      arrives, the receiving NETBLT\
    \ sets its data timer; at the same\n      time, it clears its control timer, described\
    \ below.  If the data\n      timer expires, the receiving end assumes the buffer\
    \ has been\n      transmitted and all missing packets lost.  It then sends a RESEND\n\
    \      message containing a list of the missing packets.\n      NETBLT solves\
    \ the second problem, that of missing OK, GO, and\n      RESEND messages, through\
    \ use of a control timer.  The receiver can\n      send one or more control messages\
    \ (OK, GO, or RESEND) within a\n      single CONTROL packet.  Whenever the receiver\
    \ sends a control\n      packet, it sets a control timer (at the same time it\
    \ clears its\n      data timer, if one has been set).\n      The control timer\
    \ is cleared as follows: Each control message\n      includes a sequence number\
    \ which starts at one and increases by\n      one for each control message sent.\
    \  The sending NETBLT checks the\n      sequence number of every incoming control\
    \ message against all\n      other sequence numbers it has received.  It stores\
    \ the highest\n      sequence number below which all other received sequence numbers\n\
    \      are consecutive, and returns this number in every packet flowing\n    \
    \  back to the receiver.  The receiver is permitted to clear the\n      control\
    \ timer of every packet with a sequence number equal to or\n      lower than the\
    \ sequence number returned by the sender.\n      Ideally, a NETBLT implementation\
    \ should be able to cope with\n      out-of-sequence messages, perhaps collecting\
    \ them for later\n      processing, or even processing them immediately.  If an\
    \ incoming\n      control message \"fills\" a \"hole\" in a group of message sequence\n\
    \      numbers, the implementation could even be clever enough to detect\n   \
    \   this and adjust its outgoing sequence value accordingly.\n      When the control\
    \ timer expires, the receiving NETBLT resends the\n      control message and resets\
    \ the timer.  After a predetermined\n      number of resends, the receiving NETBLT\
    \ can assume that the\n      sending NETBLT has died, and can reset the connection.\n\
    \      The sending NETBLT, upon receiving a control message, should act\n    \
    \  as quickly as possible on the packet; it either sets up a new\n      buffer\
    \ (upon receipt of an OK packet for a previous buffer),\n      resends data (upon\
    \ receipt of a RESEND packet), or sends data\n"
- title: RFC 969                                                    December 1985
  contents:
  - 'RFC 969                                                    December 1985

    '
- title: 'NETBLT: A Bulk Data Transfer Protocol'
  contents:
  - "NETBLT: A Bulk Data Transfer Protocol\n      (upon receipt of a GO packet). \
    \ If the sending NETBLT is not in a\n      position to send data, it sends a NULL-ACK\
    \ packet, which contains\n      a\n      high-received-sequence-number as described\
    \ above (this permits the\n      receiving NETBLT to clear the control timers\
    \ of any packets which\n      are outstanding), and waits until it can send more\
    \ data.  In all\n      of these cases, the overhead for a response to the incoming\n\
    \      control message should be small; the total time for a response to\n   \
    \   reach the receiving NETBLT should not be much more than the\n      network\
    \ round-trip transit time, plus a variance factor.\n      The timer system can\
    \ be summarized as follows: normally, the\n      receiving NETBLT is working under\
    \ one of two types of timers, a\n      control timer or a data timer.  There is\
    \ one data timer per buffer\n      transmission and one control timer per control\
    \ packet.  The data\n      timer is active while its buffer is being transferred;\
    \ a control\n      timer is active while it is between buffer transfers.\n   \
    \   The above system still leaves a few problems.  If the sending\n      NETBLT\
    \ is not ready to send, it sends a single NULL-ACK packet to\n      clear any\
    \ outstanding control timers at the receiving end.  After\n      this the receiver\
    \ will wait.  The sending NETBLT could die and the\n      receiver, with all its\
    \ control timers cleared, would hang.  Also,\n      the above system puts timers\
    \ only on the receiving NETBLT.  The\n      sending NETBLT has no timers; if the\
    \ receiving NETBLT dies, the\n      sending NETBLT will just hang waiting for\
    \ control messages.\n      The solution to the above two problems is the use of\
    \ a death timer\n      and a keepalive packet for both the sending and receiving\
    \ NETBLTs.\n      As soon as the connection is opened, each end sets a death timer;\n\
    \      this timer is reset every time a packet is received.  When a\n      NETBLT's\
    \ death timer at one end expires, it can assume the other\n      end has died\
    \ and can close the connection.\n      It is quite possible that the sending or\
    \ receiving NETBLTs will\n      have to wait for long periods of time while their\
    \ respective\n      clients get buffer space and load their buffers with data.\
    \  Since\n      a NETBLT waiting for buffer space is in a perfectly valid state,\n\
    \      the protocol must have some method for preventing the other end's\n   \
    \   death timer from expiring. The solution is to use a KEEPALIVE\n      packet,\
    \ which is sent repeatedly at fixed intervals when a NETBLT\n      is waiting\
    \ for buffer space.  Since the death timer is reset\n      whenever a packet is\
    \ received, it will never expire as long as the\n      other end sends packets.\n\
    \      The frequency with which KEEPALIVE packets are transmitted is\n      computed\
    \ as follows: At connection startup, each NETBLT chooses a\n"
- title: RFC 969                                                    December 1985
  contents:
  - 'RFC 969                                                    December 1985

    '
- title: 'NETBLT: A Bulk Data Transfer Protocol'
  contents:
  - "NETBLT: A Bulk Data Transfer Protocol\n      death-timeout value and sends it\
    \ to the other end in either the\n      OPEN or the RESPONSE packet.  The other\
    \ end takes the\n      death-timeout value and uses it to compute a frequency\
    \ with which\n      to send KEEPALIVE packets.  The KEEPALIVE frequency should\
    \ be high\n      enough that several KEEPALIVE packets can be lost before the\
    \ other\n      end's death timer expires.\n      Both ends must have some way\
    \ of estimating the values of the death\n      timers, the control timers, and\
    \ the data timers.  The timer values\n      obviously cannot be specified in a\
    \ protocol document since they\n      are very machine- and network-load-dependent.\
    \  Instead they must\n      be computed on a per-connection basis.  The protocol\
    \ has been\n      designed to make such determination easy.\n      The death timer\
    \ value is relatively easy to estimate.  Since it is\n      continually reset,\
    \ it need not be based on the transfer size.\n      Instead, it should be based\
    \ at least in part on the type of\n      application using NETBLT.  User applications\
    \ should have smaller\n      death timeout values to avoid forcing humans to wait\
    \ long periods\n      of time for a death timeout to occur.  Machine applications\
    \ can\n      have longer timeout values.\n      The control timer must be more\
    \ carefully estimated.  It can have\n      as its initial value an arbitrary number;\
    \ this number can be used\n      to send the first control packet.  Subsequent\
    \ control packets can\n      have their timer values based on the network round-trip\
    \ transit\n      time (i.e.  the time between sending the control packet and\n\
    \      receiving the acknowledgment of the corresponding sequence number)\n  \
    \    plus a variance factor.  The timer value should be continually\n      updated,\
    \ based on a smoothed average of collected round-trip\n      transit times.\n\
    \      The data timer is dependent not on the network round-trip transit\n   \
    \   time, but on the amount of time required to transfer a buffer of\n      data.\
    \ The time value can be computed from the burst rate and the\n      number of\
    \ bursts per buffer, plus a variance value <1>. During the\n      RESENDing phase,\
    \ the data timer value should be set according to\n      the number of missing\
    \ packets.\n      The timers have been designed to permit reasonable estimation.\
    \  In\n      particular, in other protocols, determination of round-trip delay\n\
    \      has been a problem since the action performed by the other end on\n   \
    \   receipt of a particular packet can vary greatly depending on the\n      packet\
    \ type. In NETBLT, the action taken by the sender on receipt\n      of a control\
    \ message is by and large the same in all cases, making\n      the round-trip\
    \ delay relatively independent of the client.\n"
- title: RFC 969                                                    December 1985
  contents:
  - 'RFC 969                                                    December 1985

    '
- title: 'NETBLT: A Bulk Data Transfer Protocol'
  contents:
  - "NETBLT: A Bulk Data Transfer Protocol\n      Timer value estimation is extremely\
    \ important, especially in a\n      high-performance protocol like NETBLT.  If\
    \ the estimates are too\n      low, the protocol makes many unneeded retransmissions,\
    \ degrading\n      performance.  A short control timer value causes the sending\n\
    \      NETBLT to receive duplicate control messages (which it can reject,\n  \
    \    but which takes time).  A short data timer value causes the\n      receiving\
    \ NETBLT to send unnecessary RESEND packets.  This causes\n      considerably\
    \ greater performance degradation since the sending\n      NETBLT does not merely\
    \ throw away a duplicate packet, but instead\n      has to send a number of DATA\
    \ packets.  Because data timers are set\n      on each buffer transfer instead\
    \ of on each DATA packet transfer,\n      we afford to use a small variance value\
    \ without worrying about\n      performance degradation.\n   5.3. Closing the\
    \ Connection\n      There are three ways to close a connection: a connection close,\
    \ a\n      \"quit\", or an \"abort\".\n      The connection close occurs after\
    \ a successful data transfer.\n      When the sending NETBLT has received an OK\
    \ packet for the last\n      buffer in the transfer, it sends a DONE packet <2>.\
    \  On receipt of\n      the DONE packet, the receiving NETBLT can close its half\
    \ of the\n      connection.  The sending NETBLT dallies for a predetermined amount\n\
    \      of time after sending the DONE packet.  This allows for the\n      possibility\
    \ of the DONE packet's having been lost.  If the DONE\n      packet was lost,\
    \ the receiving NETBLT will continue to send the\n      final OK packet, which\
    \ will cause the sending end to resend the\n      DONE packet.  After the dally\
    \ period expires, the sending NETBLT\n      closes its half of the connection.\n\
    \      During the transfer, one client may send a QUIT packet to the\n      other\
    \ if it thinks that the other client is malfunctioning.  Since\n      the QUIT\
    \ occurs at a client level, the QUIT transmission can only\n      occur between\
    \ buffer transmissions.  The NETBLT receiving the QUIT\n      packet can take\
    \ no action other than to immediately notify its\n      client and transmit a\
    \ QUITACK packet.  The QUIT sender must time\n      out and retransmit until a\
    \ QUITACK has been received or a\n      predetermined number of resends have taken\
    \ place.  The sender of\n      the QUITACK dallies in the manner described above.\n\
    \      An ABORT takes place when a NETBLT layer thinks that it or its\n      opposite\
    \ is malfunctioning.  Since the ABORT originates in the\n      NETBLT layer, it\
    \ can be sent at any time.  Since the ABORT implies\n      that the NETBLT layer\
    \ is malfunctioning, no transmit reliability\n      is expected, and the sender\
    \ can immediately close it connection.\n"
- title: RFC 969                                                    December 1985
  contents:
  - 'RFC 969                                                    December 1985

    '
- title: 'NETBLT: A Bulk Data Transfer Protocol'
  contents:
  - 'NETBLT: A Bulk Data Transfer Protocol

    '
- title: 6. MULTIPLE BUFFERING
  contents:
  - "6. MULTIPLE BUFFERING\n   In order to increase performance, NETBLT has been designed\
    \ in a\n   manner that encourages a multiple buffering implementation.  Multiple\n\
    \   buffering is a technique in which the sender and receiver allocate\n   and\
    \ transmit buffers in a manner that allows error recovery of\n   previous buffers\
    \ to be concurrent with transmission of current\n   buffer.\n   During the connection\
    \ setup phase, one of the negotiated parameters\n   is the number of concurrent\
    \ buffers permitted during the transfer.\n   The simplest transfer allows for\
    \ a maximum of one buffer to be\n   transmitted at a time; this is effectively\
    \ a lock-step protocol and\n   causes time to be wasted while the sending NETBLT\
    \ receives permission\n   to send a new buffer.  If there are more than one buffer\
    \ available,\n   transfer of the next buffer may start right after the current\
    \ buffer\n   finishes.  For example, assume buffer A and B are allowed to transfer\n\
    \   concurrently, with A preceding B. As soon as A finishes transferring\n   its\
    \ data and is waiting for either an OK or a RESEND message, B can\n   start sending\
    \ immediately, keeping data flowing at a stable rate.  If\n   A receives an OK,\
    \ it is done; if it receives a RESEND, the missing\n   packets specified in the\
    \ RESEND message are retransmitted.  All\n   packets flow out through a priority\
    \ pipe, with the priority equal to\n   the buffer number, and with the transfer\
    \ rate specified by the burst\n   size and burst rate.  Since buffer numbers increase\
    \ monotonically,\n   packets from an earlier buffer in the pipe will always precede\
    \ those\n   of the later ones.  One necessary change to the timing algorithm is\n\
    \   that when the receiving NETBLT set data timer for a new buffer, the\n   timer\
    \ value should also take into consideration of the transfer time\n   for all missing\
    \ packets from the previous buffers.\n   Having several buffers transmitting concurrently\
    \ is actually not that\n   much more complicated than transmitting a single buffer\
    \ at a time.\n   The key is to visualize each buffer as a finite state machine;\n\
    \   several buffers are merely a group of finite state machines, each in\n   one\
    \ of several states.  The transfer process consists of moving\n   buffers through\
    \ various states until the entire transmission has\n   completed.\n   The state\
    \ sequence of a send-receive buffer pair is as follows: the\n   sending and receiving\
    \ buffers are created independently.  The\n   receiving NETBLT sends a GO message,\
    \ putting its buffer in a\n   \"receiving\" state, and sets its control timer;\
    \ the sending NETBLT\n   receives the GO message, putting its buffer into a \"\
    sending\" state.\n   The sending NETBLT sends data until the buffer has been transmitted.\n\
    \   If the receiving NETBLT's data timer goes off before it received the\n   last\
    \ (LDATA) packet, or it receives the LDATA packet in the buffer\n"
- title: RFC 969                                                    December 1985
  contents:
  - 'RFC 969                                                    December 1985

    '
- title: 'NETBLT: A Bulk Data Transfer Protocol'
  contents:
  - "NETBLT: A Bulk Data Transfer Protocol\n   and packets are missing, it sends a\
    \ RESEND packet and moves the\n   buffer into a \"resending\" state.  Once all\
    \ DATA packets in the buffer\n   and the LDATA packet have been received, the\
    \ receiving NETBLT enters\n   its buffer into a \"received\" state and sends an\
    \ OK packet.  The\n   sending NETBLT receives the OK packet and puts its buffer\
    \ into a\n   \"sent\" state.\n"
- title: 7. PROTOCOL LAYERING STRUCTURE
  contents:
  - "7. PROTOCOL LAYERING STRUCTURE\n   NETBLT is implemented directly on top of the\
    \ Internet Protocol (IP).\n   It has been assigned a temporary protocol number\
    \ of 255.  This number\n   will change as soon as the final protocol specification\
    \ has been\n   determined.\n"
- title: 8. PACKET FORMATS
  contents:
  - "8. PACKET FORMATS\n   NETBLT packets are divided into three categories, each\
    \ of which share\n   a common packet header.  First, there are those packets that\
    \ travel\n   only from sender to receiver; these contain the control message\n\
    \   sequence numbers which the receiver uses for reliability.  These\n   packets\
    \ are the NULL-ACK, DATA, and LDATA packets.  Second, there is\n   a packet that\
    \ travels only from receiver to sender.  This is the\n   CONTROL packet; each\
    \ CONTROL packet can contain an arbitrary number\n   of control messages (GO,\
    \ OK, or RESEND), each with its own sequence\n   number. Finally, there are those\
    \ packets which either have special\n   ways of insuring reliability, or are not\
    \ reliably transmitted.  These\n   are the QUIT, QUITACK, DONE, KEEPALIVE, and\
    \ ABORT packets.  Of these,\n   all save the DONE packet can be sent by both sending\
    \ and receiving\n   NETBLTs.\n   Packet type numbers:\n      OPEN:           0\n\
    \      RESPONSE:       1\n      KEEPALIVE:      2\n      DONE:           3\n \
    \     QUIT:           4\n      QUITACK:        5\n      ABORT:          6\n  \
    \    DATA:           7\n      LDATA:          8\n      NULL-ACK:       9\n   \
    \   CONTROL:        10\n"
- title: RFC 969                                                    December 1985
  contents:
  - 'RFC 969                                                    December 1985

    '
- title: 'NETBLT: A Bulk Data Transfer Protocol'
  contents:
  - "NETBLT: A Bulk Data Transfer Protocol\n   Standard header:\n      local port:\
    \       2 bytes\n      foreign port:     2 bytes\n      checksum:         2 bytes\n\
    \      version number:   1 byte\n      packet type:      1 byte\n      packet\
    \ length:    2 bytes\n   OPEN and RESPONSE packets:\n      connection unique ID:\
    \                   4 bytes\n      standard buffer size:                   4 bytes\n\
    \      transfer size:                          4 bytes\n      DATA packet data\
    \ segment size:          2 bytes\n      burst size:                          \
    \   2 bytes\n      burst rate:                             2 bytes\n      death\
    \ timeout value in seconds:         2 bytes\n      transfer mode (1 = SEND, 0\
    \ = RECEIVE):  1 byte\n      maximum number of concurrent buffers:   1 byte\n\
    \      checksum entire DATA packet / checksum\n      DATA packet data only (1/0):\
    \         1 byte\n      client-specific data:                   arbitrary\n  \
    \ DONE, QUITACK, KEEPALIVE:\n      standard header only\n   ABORT, QUIT:\n   \
    \   reason:       arbitrary bytes\n   CONTROL packet format:\n      CONTROL packets\
    \ consist of a standard NETBLT header of type\n      CONTROL, followed by an arbitrary\
    \ number of control messages with\n      the following formats:\n      Control\
    \ message numbers:\n         GO:             0\n         OK:             1\n \
    \        RESEND:         2\n"
- title: RFC 969                                                    December 1985
  contents:
  - 'RFC 969                                                    December 1985

    '
- title: 'NETBLT: A Bulk Data Transfer Protocol'
  contents:
  - "NETBLT: A Bulk Data Transfer Protocol\n         OK message:\n            message\
    \ type (OK):  1 byte\n            buffer number:      4 bytes\n            sequence\
    \ number:    2 bytes\n            new burst size:     2 bytes\n            new\
    \ burst interval: 2 bytes\n         GO message:\n            message type (GO):\
    \  1 byte\n            buffer number:      4 bytes\n            sequence number:\
    \    2 bytes\n         RESEND message:\n            message type (RESEND):   \
    \  1 byte\n            buffer number:             4 bytes\n            sequence\
    \ number:           2 bytes\n            number of missing packets: 2 bytes\n\
    \            packet numbers...:         n * 2 bytes\n   DATA, LDATA packet formats:\n\
    \      buffer number:                                4 bytes\n      highest consecutive\
    \ sequence number received: 2 bytes\n      packet number within buffer:      \
    \            2 bytes\n      data:                                         arbitrary\
    \ bytes\n   NULL-ACK packet format:\n      highest consecutive sequence number\
    \ received: 2 bytes\n      acknowledged new burst size:                  2 bytes\n\
    \      acknowledged new burst interval:              2 bytes\n"
- title: 'NOTES:'
  contents:
  - "NOTES:\n   <1>  When the buffer size is large, the variances in the round trip\n\
    \        delays of many packets may cancel each other out; this means the\n  \
    \      variance value need not be very big.  This expectation can be\n       \
    \ verified in further testing.\n   <2>  Since the receiving end may not know the\
    \ transfer size in\n        advance, it is possible that it may have allocated\
    \ buffer space\n        and sent GO messages for buffers beyond the actual last\
    \ buffer\n        sent by the sending end.  Care must be taken on the sending\n\
    \        end's part to ignore these extra GO messages.\n"
