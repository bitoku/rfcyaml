Abstract This document supports the solution put forth in "An Architecture for IP/LDP Fast Reroute Using Maximally Redundant Trees (MRT FRR)" (RFC 7812) by defining the associated MRT Lowpoint algorithm that is used in the Default MRT Profile to compute both the necessary Maximally Redundant Trees with their associated next hops and the alternates to select for MRT FRR.
Introduction MRT Fast Reroute requires that packets can be forwarded not only on the shortest path tree, but also on two Maximally Redundant Trees (MRTs), referred to as the MRT Blue and the MRT Red.
A router that experiences a local failure must also have predetermined which alternate to use.
This document defines how to compute these three things for use in MRT FRR and describes the algorithm design decisions and rationale.
The algorithm is based on those presented in [MRTLinear] and expanded in [EnyediThesis].
The MRT Lowpoint algorithm is required for implementation when the Default MRT Profile is implemented.
The MRT Lowpoint Algorithm defined in this document, when used for MRT Fast Reroute as described in [RFC7812], guarantees 100% recovery for single failures when the network is 2 connected.
This guaranteed coverage does not depend on the link metrics, which an operator may be using to traffic engineer the IP network.
Thus, the link metrics and general network topology are largely decoupled from the guaranteed coverage.
Just as packets routed on a hop by hop basis require that each router compute a shortest path tree that is consistent, it is necessary for each router to compute the MRT Blue next hops and MRT Red next hops in a consistent fashion.
This document defines the MRT Lowpoint algorithm to be used as a standard in the Default MRT Profile for MRT FRR.
A router's Forwarding Information Base (FIB) will continue to contain primary next hops for the current shortest path tree for forwarding traffic.
In addition, a router's FIB will contain primary next hops for the MRT Blue for forwarding received traffic on the MRT Blue and primary next hops for the MRT Red for forwarding received traffic on the MRT Red.
What alternate next hops a Point of Local Repair (PLR) selects need not be consistent   but loops must be prevented.
To reduce congestion, it is possible for multiple alternate next hops to be selected; in the context of MRT alternates, each of those alternate next hops would be equal cost paths.
This document defines an algorithm for selecting an appropriate MRT alternate for consideration.
Other alternates, e.g., Loop Free Alternates (LFAs) that are downstream paths, may be preferred when available.
See the "Operational Considerations" section of [RFC7812] for a more detailed discussion of combining MRT alternates with those produced by other FRR technologies.
The MRT Lowpoint algorithm can handle arbitrary network topologies where the whole network graph is not 2 connected, as in Figure 2, as well as the easier case where the network graph is 2 connected (Figure 1).
Each MRT is a spanning tree.
The pair of MRTs provide two paths from every node X to the root of the MRTs.
Those paths share the minimum number of nodes and the minimum number of links.
Each such shared node is a cut vertex.
Any shared links are cut  links.
MRT Red towards R Figure 2: A Network
That Is Not 2 Connected 2.
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC2119].
Terminology and Definitions Please see the Terminology section of [RFC7812] for a complete list of terminology relevant to this document.
The list below does not repeat terminology introduced in that RFC.
A tree that contains links and that connects all nodes in the network graph.
In the context of a spanning tree computed via a depth  first search, a back edge is a link that connects a descendant of a node x with an ancestor of x. partial ADAG:
A subset of an Almost Directed Acyclic Graph (ADAG) that doesn't yet contain all the nodes in the block.
A partial ADAG is created during the MRT Lowpoint algorithm and then expanded until all nodes in the block are included and it becomes an ADAG.
DFS:  Depth First Search DFS ancestor:
A node n is a DFS ancestor of x
if n is on the DFS  tree path from the DFS root to x. DFS descendant:
A node n is a DFS descendant of x
if x is on the DFS tree path from the DFS root to n. ear:
A path along nodes that are not yet included in the Generalized ADAG (GADAG) that starts at a node that is already included in the GADAG and that ends at a node that is already included in the GADAG.
The starting and ending nodes may be the same node if it is a cut vertex.
Indicates the relationship between X and Y in a partial order, such as found in a GADAG.
X>>Y means that X is higher in the partial order than Y.  Y<<X means that Y is lower in the partial order than X. X>Y or Y
Indicates the relationship between X and Y in the total order, such as found via a topological sort.
Y means that X is higher in the total order than Y.  Y
<X means that Y is lower in the total order than X. X ??
Indicates that X is unordered with respect to Y in the partial order.
In the GADAG, each link is marked as OUTGOING, INCOMING, or both.
Until the directionality of the link is determined, the link is marked as UNDIRECTED to indicate that its direction hasn't been determined.
A link marked as OUTGOING has direction in the GADAG from the interface's router to the remote end.
A link marked as INCOMING has direction in the GADAG from the remote end to the interface's router.
There are five key concepts that are critical for understanding the MRT Lowpoint algorithm.
The first is the idea of partially ordering the nodes in a network graph with regard to each other and to the GADAG root.
The second is the idea of finding an ear of nodes and adding them in the correct direction.
The third is the idea of a Lowpoint value and how it can be used to identify cut vertices and to find a second path towards the root.
The fourth is the idea that a non 2 connected graph is made up of blocks, where a block is a 2 connected cluster, a cut link or an isolated node.
The fifth is the idea of a localroot for each node; this is used to compute ADAGs in each block.
Partial Ordering for Disjoint Paths
Given any two nodes X and Y in a graph, a particular total order means that either X<Y or X
>Y in that total order.
An example would be a graph where the nodes are ranked based upon their unique IP loopback addresses.
In a partial order, there may be some nodes for which it can't be determined whether X<<Y or X>>Y.
A partial order can be captured in a directed graph, as shown in Figure 3.
In a graphical representation, a link directed from X to Y indicates that X is a neighbor of Y in the network graph and X<<Y.
<< A << B << C << D
< A << B << F
Directed Graph Showing a Partial Order To compute MRTs, the root of the MRTs is at both the very bottom and the very top of the partial ordering.
This means that from any node X, one can pick nodes higher in the order until the root is reached.
Similarly, from any node X, one can pick nodes lower in the order until the root is reached.
For instance, in Figure 4, from G the higher nodes picked can be traced by following the directed links and are H, D, E, and R.  Similarly, from G the lower nodes picked can be traced by reversing the directed links and are F, B, A, and R.
A graph that represents this modified partial order is no longer a DAG; it is termed an Almost DAG (ADAG) because if the links directed to the root were removed, it would be a DAG.
<< A << B << C << R
[H] Figure 4: ADAG Showing a Partial Order with R Lowest and Highest Most importantly, if a node Y>>X, then Y can only appear on the increasing path from X to the root and never on the decreasing path.
Similarly, if a node Z<<X, then Z can only appear on the decreasing path from X to the root and never on the increasing path.
When following the increasing paths, it is possible to pick multiple higher nodes and still have the certainty that those paths will be disjoint from the decreasing paths.
For example, in the previous example, node B has multiple possibilities to forward packets along an increasing path: it can either forward packets to C or F. 4.2.
Finding an Ear and the Correct Direction For simplicity, the basic idea of creating a GADAG by adding ears is described assuming that the network graph is a single 2 connected cluster so that an ADAG is sufficient.
Generalizing to multiple blocks is done by considering the block roots instead of the GADAG root   and the actual algorithm is given in Section 5.5.
In order to understand the basic idea of finding an ADAG, first suppose that we have already a partial ADAG, which doesn't contain all the nodes in the block yet, and we want to extend it to cover all the nodes.
Suppose that we find a path from a node X to Y such that X and Y are already contained by our partial ADAG, but all the remaining nodes along the path are not added to the ADAG yet.
We refer to such a path as an "ear".
Recall that our ADAG is closely related to a partial order.
More precisely, if we remove root R, the remaining DAG describes a partial order of the nodes.
If we suppose that neither X nor Y is the root, we may be able to compare them.
If one of them is definitely lesser with respect to our partial order (say X<<Y), we can add the new path to the ADAG in a direction from X to Y.
As an example, consider Figure 5.
A 2 connected graph (b)
Partial ADAG (C is not included)
(c) Resulting ADAG after adding path (or ear)
B C D Figure 5
In this partial ADAG, node C is not yet included.
However, we can find path B C D, where both endpoints are contained by this partial ADAG (we say those nodes are "ready" in the following text), and the remaining node (node C) is not contained yet.
If we remove R, the remaining DAG defines a partial order, and with respect to this partial order, we can say that B<<D; so, we can add the path to the ADAG in the direction from B to D (arcs B C and C D are added).
If B>>D, we would add the same path in reverse direction.
If, in the partial order where an ear's two ends are X and Y, X<<Y, then there must already be a directed path from X to Y in the ADAG.
The ear must be added in a direction such that it doesn't create a cycle; therefore, the ear must go from X to Y.
In the case when X and Y are not ordered with each other, we can select either direction for the ear.
We have no restriction since neither of the directions can result in a cycle.
In the corner case when one of the endpoints of an ear, say X, is the root (recall that the two endpoints must be different), we could use both directions again for the ear because the root can be considered both as smaller and as greater than Y.
However, we strictly pick that direction in which the root is lower than Y.
The logic for this decision is explained in Section 5.7
A partial ADAG is started by finding a cycle from the root R back to itself.
This can be done by selecting a non ready neighbor N of R and then finding a path from N to R that doesn't use any links between R and N.
The direction of the cycle can be assigned either way since it is starting the ordering.
Once a partial ADAG is already present, it will always have a node that is not the root R in it.
The following is a brief proof that a partial ADAG can always have ears added to it: just select a non  ready neighbor N of a ready node Q, such that Q is not the root R, find a path from N to the root R in the graph with Q removed.
This path is an ear where the first node of the ear is Q, the next is N, then the path until the first ready node the path reached (that ready node is the other endpoint of the path).
Since the graph is 2 connected, there must be a path from N to R without Q.
It is always possible to select a non ready neighbor N of a ready node Q so that Q is not the root R.
Because the network is 2 connected, N must be connected to two different nodes and only one can be R.  Because the initial cycle has already been added to the ADAG, there are ready nodes that are not R.
Since the graph is 2 connected, while there are non ready nodes, there must be a non  ready neighbor
N of a ready node that is not R. Generic
) Create an empty ADAG.
Add root to the ADAG.
Mark root as IN GADAG.
Select an arbitrary cycle containing root.
Add the arbitrary cycle to the ADAG.
Mark cycle's nodes as IN GADAG.
Add cycle's non root nodes to process list.
While there exist connected nodes in graph that are not IN GADAG Select
Let its endpoints be X and Y.
If Y is root or (Y<<X) Add the ear towards X to the ADAG
X is root, or (b) X<<Y, or (c)
X, Y not ordered Add the ear towards Y to the ADAG Figure 6:
Generic Algorithm to Find Ears and Their Direction in 2 Connected Graph
The algorithm in Figure 6 merely requires that a cycle or ear be selected without specifying how.
Regardless of the method for selecting the path, we will get an ADAG.
The method used for finding and selecting the ears is important; shorter ears result in shorter paths along the MRTs.
The MRT Lowpoint algorithm uses the Lowpoint Inheritance method for constructing an ADAG (and ultimately a GADAG).
This method is defined in Section 5.5.
Other methods for constructing GADAGs are described in Appendices B and C.
An evaluation of these different methods is given in Section 8.
As an example, consider Figure 5 again.
First, we select the shortest cycle containing R, which can be R A B F D E (uniform link costs were assumed), so we get to the situation depicted in Figure 5(b).
Finally, we find a node next to a ready node; that must be node C and assume we reached it from ready node
We search a path from C to R without B in the original graph.
The first ready node along this is node D, so the open ear is B C D.
Since B<<D, we add arc B C and C D to the ADAG.
Since all the nodes are ready, we stop at this point.
Lowpoint Values and Their Uses
A basic way of computing a spanning tree on a network graph is to run a DFS, such as given in Figure 7.
This tree has the important property that if there is a link (x, n), then either n is a DFS ancestor of x or
n is a DFS descendant of x.
In other words, either n is on the path from the root to x or x is on the path from the root to n. global variable:
Visit(node x, node parent) D(x)
dfs number dfs number    1 x.dfs parent   parent for each link (x, w) if D(w) is not set DFS Visit(w,
x, one can compute the minimal DFS number of the neighbors of x, i.e., min( D(w) if (x,w) is a link).
This gives the earliest attachment point neighboring x.
What is interesting, though, is the earliest attachment point from x and x's descendants.
This is what is determined by computing the Lowpoint value.
In order to compute the low point value, the network is traversed using DFS and the vertices are numbered based on the DFS walk.
Let this number be represented as DFS(x).
All the edges that lead to already visited nodes during DFS walk are back edges.
The back edges are important because they give information about reachability of a node via another path.
x n is a back edge), Lowest Low(n,
x n is tree edge in DFS walk) ).
A detailed algorithm for computing the lowpoint value is given in Figure 8.
Figure 9 illustrates how the Lowpoint algorithm applies to an example graph.
global variable: dfs number Lowpoint
Visit(node x, node parent, interface p to x) D(x)
dfs number    1 x.dfs parent
parent x.dfs parent intf   p to x.remote intf x.lowpoint parent   NONE for each ordered interface intf of x
if D(intf.remote node) is not set Lowpoint Visit(intf.remote node, x, intf) if L(intf.remote node)
intf.remote node x.lowpoint parent intf   intf else if intf.remote node is not parent if D(intf.remote node)
intf.remote node x.lowpoint parent intf   intf Run Lowpoint(node gadag root)
dfs number   0 Lowpoint Visit(gadag root, NONE, NONE
Example Lowpoint Value Computation From the lowpoint value and lowpoint parent
, there are three very useful things that motivate our computation.
In Figure 9, this can be seen by looking at the DFS children of C.  C has two children, D and F and L(F)
; so, it is clear that C is a cut vertex and F is in a block where C is the block's root.
, so D has a path to the ancestors of C; in this case, D can go via E to reach R.  Comparing the lowpoint values of all a node's DFS  children with the node's DFS value is very useful because it allows identification of the cut vertices and thus the blocks.
Second, by repeatedly following the path given by lowpoint parent, there is a path from x back to an ancestor of x
that does not use the link [x, x.dfs parent] in either direction.
The full path need not be taken, but this gives a way of finding an initial cycle and then ears.
Third, as seen in Figure 9, even if L(x)<D(x), there may be a block that contains both the root and a DFS child of a node while other DFS children might be in different blocks.
In this example, C's child D is in the same block as R while F is not.
It is important to realize that the root of a block may also be the root of another block.
Blocks in a Graph A key idea for the MRT Lowpoint algorithm is that any non 2 connected graph is made up by blocks (e.g., 2 connected clusters, cut links, and/or isolated nodes).
To compute GADAGs and thus MRTs, computation is done in each block to compute ADAGs or Redundant Trees and then those ADAGs or Redundant Trees are combined into a GADAG or MRT.
MRT Red for destination R Figure 10 Consider the example depicted in Figure 10 (a).
In this figure, a special graph is presented, showing us all the ways 2 connected clusters can be connected.
block 1 contains R, A, B, C, D, E; block 2 contains C, F, G, H, I, J; block 3 contains K, L, M, N, O, P; and block 4 is a cut link containing H and K.
As can be observed, the first two blocks have one common node (node C) and blocks 2 and 3
do not have any common node, but they are connected through a cut link that is block 4.
No two blocks can have more than one common node, since two blocks with at least two common nodes would qualify as a single 2 connected cluster.
Moreover, observe that if we want to get from one block to another, we must use a cut vertex (the cut vertices in this graph are C, H, K), regardless of the path selected, so we can say that all the paths from block 3 along the MRTs rooted at R will cross K first.
This observation means that if we want to find a pair of MRTs rooted at R, then we need to build up a pair of RTs in block 3 with K as a root.
Similarly, we need to find another pair of RTs in block 2 with C as a root, and finally, we need the last pair of RTs in block 1 with R as a root.
When all the trees are selected, we can simply combine them; when a block is a cut link (as in block 4), that cut link is added in the same direction to both of the trees.
The resulting trees are depicted in Figure 10 (b) and (c).
Similarly, to create a GADAG it is sufficient to compute ADAGs in each block and connect them.
It is necessary, therefore, to identify the cut vertices, the blocks and identify the appropriate localroot to use for each block.
Determining Localroot and Assigning Block ID
Each node in a network graph has a localroot, which is the cut vertex (or root) in the same block that is closest to the root.
The localroot is used to determine whether two nodes share a common block.
Compute Localroot(node x, node localroot)
x.localroot   localroot for each DFS child node c of x
//x is not a cut vertex Compute Localroot(c, x.localroot)
x as cut vertex Compute Localroot(c, x)
Compute Localroot(gadag root, gadag root)
Figure 11: A Method for Computing Localroots
There are two different ways of computing the localroot for each node.
The stand alone method is given in Figure 11 and better illustrates the concept; it is used by the GADAG construction methods given in Appendices B and C.
The MRT Lowpoint algorithm computes the localroot for a block as part of computing the GADAG using lowpoint inheritance; the essence of this computation is given in Figure 12.
Both methods for computing the localroot produce the same results.
Get the current node, s. Compute
an ear (either through lowpoint inheritance or by following dfs parents) from s to a ready node e.
(Thus, s is not e, if there is such ear.)
if s is e for each node
x in the ear that is not s
x.localroot   s else for each node
x in the ear that is not s or e x.localroot
Ear Based Method for Computing Localroots
Once the localroots are known, two nodes X and Y are in a common block if and only if one of the following three conditions apply.
Y's localroot is X's localroot : They are in the same block and neither is the cut vertex closest to the root.
X is the cut vertex closest to the root for Y's block
Y is the cut vertex closest to the root for X's block
Once we have computed the localroot for each node in the network graph, we can assign for each node, a Block ID that represents the block in which the node is present.
This computation is shown in Figure 13.
d Assign Block ID(x, cur block id)
cur block id foreach DFS child c of x
if (c.local root is x)
1 Assign Block ID(c, max block id)
else Assign Block ID(c, cur block i
Assigning Block ID to Identify Blocks 5.
The MRT Lowpoint algorithm computes one GADAG that is then used by a router to determine its MRT Blue and MRT Red
next hops to all destinations.
Finally, based upon that information, alternates are selected for each next hop to each destination.
The different parts of this algorithm are described below.
the interfaces in the network graph.
Compute the local MRT Island for the particular MRT Profile.
Select the root to use for the GADAG.
Initialize all interfaces to UNDIRECTED.
Compute the DFS value, e.g., D(x), and lowpoint value, L(x).
Assign directions to all interfaces that are still UNDIRECTED.
From the computing router x, compute the next hops for the MRT  Blue and MRT Red.
Identify alternates for each next hop to each destination by determining which one of the MRT Blue and the MRT Red the computing router x should select.
A Python implementation of this algorithm is given in Appendix A. 5.1.
Interface Ordering To ensure consistency in computation, all routers MUST order interfaces identically down to the set of links with the same metric to the same neighboring node.
This is necessary for the DFS in Lowpoint Visit in Section 4.3, where the selection order of the interfaces to explore results in different trees.
Consistent interface ordering is also necessary for computing the GADAG, where the selection order of the interfaces to use to form ears can result in different GADAGs.
It is also necessary for the topological sort described in Section 5.8, where different topological sort orderings can result in undirected links being added to the GADAG in different directions.
The required ordering between two interfaces from the same router x is given in Figure 14.
a, interface b) if a.metric
< b.metric return A LESS THAN B
return B LESS THAN A if a.neighbor.mrt node
id return A LESS THAN B
// Same metric to same node, so the order doesn't matter for // interoperability.
return A EQUAL TO B Figure 14: Rules for Ranking Multiple Interfaces
(Order Is from Low to High)
In Figure 14, if two interfaces on a router connect to the same remote router with the same metric, the Interface Compare function returns A EQUAL TO B.
This is because the order in which those interfaces are initially explored does not affect the final GADAG produced by the algorithm described here.
While only one of the links will be added to the GADAG in the initial traversal, the other parallel links will be added to the GADAG with the same direction assigned during the procedure for assigning direction to UNDIRECTED links described in Section 5.6.
An implementation is free to apply some additional criteria to break ties in interface ordering in this situation, but those criteria are not specified here since they will not affect the final GADAG produced by the algorithm.
The Interface Compare function in Figure 14 relies on the interface.metric and the interface.neighbor.mrt node
id values to order interfaces.
The exact source of these values for different IGPs and applications is specified in Figure 15.
The metric and mrt node
id values for OSPFv2, OSPFv3, and IS IS provided here is normative.
The metric and mrt node
id values for IS IS Path Control and Reservation (PCR) in this table should be considered informational.
The normative values are specified in [IEEE8021Qca].
IS IS PCR for  8
id and interface.metric to Be Used for Ranking Interfaces, for Different Flooding Protocols and Applications
The metrics are unsigned integers and MUST be compared as unsigned integers.
The results of mrt node
id comparisons MUST be the same as would be obtained by converting the mrt node ids to unsigned integers using network byte order and performing the comparison as unsigned integers.
In the case of IS IS for IP/LDP FRR with point to point links, the pseudonode number (the 7th octet) is zero.
Broadcast interfaces will be discussed in Section 7.
The local MRT Island for a particular MRT profile can be determined by starting from the computing router in the network graph and doing a breadth first search (BFS).
The BFS explores only links that are in the same area/level, are not IGP excluded, and are not MRT  ineligible.
The BFS explores only nodes that support the particular MRT profile.
See Section 7 of [RFC7812] for more precise definitions of these criteria.
MRT Island Identification(topology, computing rtr, profile id, area) for all routers in topology rtr.
IN MRT ISLAND   FALSE computing rtr.
next rtr   remove head(explore list) for each intf in next rtr if (not intf.
IN MRT ISLAND and not intf.
MRT ineligible and not intf.remote intf.
MRT ineligible and not intf.
IGP excluded and (intf in area) and (intf.remote node supports profile id) ) intf.
IN MRT ISLAND   TRUE intf.remote intf.
IN MRT ISLAND   TRUE if (not intf.remote node.
TRUE add to tail(explore list, intf.remote node)
Figure 16: MRT Island Identification 5.3.
In Section 8.3 of [RFC7812], the GADAG Root Selection Policy is described for the Default MRT Profile.
This selection policy allows routers to consistently select a common GADAG Root inside the local MRT Island, based on advertised priority values.
The MRT Lowpoint algorithm simply requires that all routers in the MRT Island MUST select the same GADAG Root; the mechanism can vary based upon the MRT profile description.
Before beginning computation, the network graph is reduced to contain only the set of routers that support the specific MRT profile whose MRTs are being computed.
As noted in Section 7, pseudonodes MUST NOT be considered for GADAG root selection.
It is expected that an operator will designate a set of routers as good choices for selection as GADAG root by setting the GADAG Root Selection Priority for that set of routers to lower (more preferred) numerical values.
For guidance on setting the GADAG Root Selection Priority values, refer to Section 9.1.
Before running the algorithm, there is the standard type of initialization to be done, such as clearing any computed DFS values, lowpoint values, DFS parents, lowpoint parents, any MRT computed next hops, and flags associated with algorithm.
It is assumed that a regular SPF computation has been run so that the primary next hops from the computing router to each destination are known.
This is required for determining alternates at the last step.
Initially, all interfaces MUST be initialized to UNDIRECTED.
Whether they are OUTGOING, INCOMING, or
both is determined when the GADAG is constructed and augmented.
It is possible that some links and nodes will be marked using standard IGP mechanisms to discourage or prevent transit traffic.
Section 7.3.1 of [RFC7812] describes how those links and nodes are excluded from MRT Island formation.
MRT FRR also has the ability to advertise links MRT Ineligible, as described in Section 7.3.2 of [RFC7812].
These links are excluded from the MRT Island and the GADAG.
Computation of MRT next hops will therefore not use any MRT ineligible links.
The MRT Lowpoint algorithm does still need to consider MRT ineligible links when computing FRR alternates, because an MRT ineligible link can still be the shortest path next hop to reach a destination.
When a broadcast interface is advertised as MRT ineligible, then the pseudonode representing the entire broadcast network MUST NOT be included in the MRT Island.
This is equivalent to excluding all of the broadcast
interfaces on that broadcast network from the MRT Island.
Constructing the GADAG Using Lowpoint Inheritance
As discussed in Section 4.2, it is necessary to find ears from a node
that is already in the GADAG (known as IN GADAG).
Two different methods are used to find ears in the algorithm.
The first is by going to a DFS child that is not IN GADAG and then following the chain of lowpoint parents until an IN GADAG node is found.
The second is by going to a neighbor that is not IN GADAG and then following the chain of DFS parents until an IN GADAG node is found.
As an ear is found, the associated interfaces are marked based on the direction taken.
The nodes in the ear are marked as IN GADAG.
In the algorithm, first the ears via DFS children are found and then the ears via DFS neighbors are found.
By adding both types of ears when an IN GADAG node is processed, all ears that connect to that node are found.
The order in which the IN GADAG nodes are processed is, of course, key to the algorithm.
The order is a stack of ears so the most recent ear is found at the top of the stack.
Of course, the stack stores nodes and not ears, so an ordered list of nodes, from the first node in the ear to the last node in the ear, is created as the ear is explored
and then that list is pushed onto the stack.
Each ear represents a partial order (see Figure 4) and processing the nodes in order along each ear ensures that all ears connecting to a node are found before a node higher in the partial order has its ears explored.
This means that the direction of the links in the ear is always from the node x being processed towards the other end of the ear.
Additionally, by using a stack of ears, this means that any unprocessed nodes in previous ears can only be ordered higher than nodes in the ears below it on the stack.
In this algorithm that depends upon Lowpoint inheritance, it is necessary that every node has a lowpoint parent that is not itself.
If a node is a cut vertex, that may not yet be the case.
Therefore, any nodes without a lowpoint parent will have their lowpoint parent set to their DFS parent and their lowpoint value set to the DFS value of their parent.
This assignment also properly allows an ear between two cut vertices.
Finally, the algorithm simultaneously computes each node's localroot, as described in Figure 12.
This is further elaborated as follows.
The localroot can be inherited from the node at the end of the ear unless the end of the ear is x itself, in which case the localroot for all the nodes in the ear would be x.
This is because whenever the first cycle is found in a block, or an ear involving a bridge is computed, the cut vertex closest to the root would be x itself.
In all other scenarios, the properties of lowpoint/dfs parents ensure that the end of the ear will be in the same block, and thus inheriting its localroot would be the correct localroot for all newly added nodes.
The pseudocode for the GADAG algorithm (assuming that the adjustment of lowpoint for cut vertices has been made) is shown in Figure 17.
Construct Ear(x, Stack, intf, ear type)
intf not done   true while not done cur intf.
IN GADAG is false cur node.
IN GADAG   true add to list end(ear list, cur node) if ear type is CHILD
ear type must be NEIGHBOR
node.dfs parent else not done   false if (ear type is CHILD)
and (cur node is x) //
x is a cut vertex and the local root for //
the block in which the ear is computed
Inherit localroot from the end of the ear localroot
while ear list is not empty y
remove end item from list(ear list)
y) Construct GADAG via Lowpoint(topology, gadag root) gadag root.
IN GADAG   true gadag root.localroot
None Initialize Stack to empty push gadag root onto Stack while (Stack is not empty)
foreach ordered interface intf of x
IN GADAG   false) and (intf.remote node.dfs parent is x))
Construct Ear(x, Stack, intf, CHILD)
foreach ordered interface intf of x
IN GADAG   false) and (intf.remote node.dfs parent is not x))
Construct Ear(x, Stack, intf, NEIGHBOR)
Construct GADAG via Lowpoint(topology, gadag root)
Figure 17: Lowpoint Inheritance GADAG Algorithm 5.6.
Augmenting the GADAG by Directing All Links The GADAG, regardless of the method used to construct it, at this point could be used to find MRTs, but the topology does not include all links in the network graph.
First, there might be shorter paths that respect the GADAG partial ordering and so
the alternate paths would not be as short as possible.
Second, there may be additional paths between a router x and the root that are not included in the GADAG.
Including those provides potentially more bandwidth to traffic flowing on the alternates and may reduce congestion compared to just using the GADAG as currently constructed.
The goal is thus to assign direction to every remaining link marked as UNDIRECTED to improve the paths and number of paths found when the MRTs are computed.
To do this, we need to establish a total order that respects the partial order described by the GADAG.
This can be done using Kahn's topological sort [Kahn 1962 topo sort], which essentially assigns a number to a node x only after all nodes before it (e.g., with a link incoming to x)
have had their numbers assigned.
The only issue with the topological sort is that it works on DAGs and not ADAGs or GADAGs.
To convert a GADAG to a DAG, it is necessary to remove all links that point to a root of block from within that block.
That provides the necessary conversion to a DAG and then a topological sort can be done.
When adding undirected links to the GADAG, links connecting the block root to other nodes in that block need special handling because the topological order will not always give the right answer for those links.
There are three cases to consider.
If the undirected link in question has another parallel link between the same two nodes that is already directed, then the direction of the undirected link can be inherited from the previously directed link.
In the case of parallel cut links, we set all of the parallel links to both INCOMING and OUTGOING.
Otherwise, the undirected link in question is set to OUTGOING from the block root node.
A cut link can then be identified by the fact that it will be directed both INCOMING and OUTGOING in the GADAG.
The exact details of this whole process are captured in Figure 18.
Add Undirected Block Root Links(topo, gadag root)
if x.IS CUT VERTEX or x is gadag root foreach interface
if (i.remote node.localroot is not x
PROCESSED ) continue Initialize bundle list to empty bundle.
INCOMING   false foreach interface i2 in x
node add to list end(bundle list, i2) if not i2.UNDIRECTED: bundle.
UNDIRECTED foreach interface i3 in bundle list
foreach interface i3 in bundle list
OUTGOING foreach interface i3 in bundle list
INCOMING foreach interface i3 in bundle list i3.UNDIRECTED
OUTGOING   true Modify Block Root Incoming Links(topo, gadag root)
if x.IS CUT VERTEX or x is gadag root foreach interface
true Revert Block Root Incoming Links(topo, gadag root)
if x.IS CUT VERTEX or x is gadag root foreach interface
OUTGOING STORED   false Run Topological Sort GADAG(topo, gadag root)
Modify Block Root Incoming Links(topo, gadag root)
1 Initialize working list to empty Initialize topo order list to empty add to list end(working list, gadag root) while working list is not empty y
remove start item from list(working list) add to list end(topo order list, y) foreach ordered interface i of y if intf.
if i.remote node.unvisited is 0 add to list end(working list,
next topo order   1 while topo order list is not empty y
remove start item from list(topo order list)
next topo order    1 Revert Block Root Incoming Links(topo, gadag root)
Based On Topo Order(topo) foreach node
x in topo foreach interface i of
< i.remote node.topo order i.
UNDIRECTED   false Add Undirected Links(topo, gadag root)
Add Undirected Block Root Links(topo, gadag root)
Run Topological Sort GADAG(topo, gadag root)
Set Other Undirected Links Based On Topo Order(topo)
Add Undirected Links(topo, gadag root)
Assigning Direction to UNDIRECTED Links Proxy nodes do not need to be added to the network graph.
They cannot be transited and do not affect the MRTs that are computed.
The details of how the MRT Blue and MRT Red
next hops are computed for proxy nodes and how the appropriate alternate next hops are selected is given in Section 5.9.
As was discussed in Section 4.1, once an ADAG is found, it is straightforward to find the next hops from any node X to the ADAG root.
However, in this algorithm, we will reuse the common GADAG and find not only the one pair of MRTs rooted at the GADAG root with it, but find a pair rooted at each node.
This is useful since it is significantly faster to compute.
The method for computing differently rooted MRTs from the common GADAG is based on two ideas.
First, if two nodes X and Y are ordered with respect to each other in the partial order, then an SPF along OUTGOING links (an increasing SPF) and an SPF along INCOMING links (a decreasing SPF) can be used to find the increasing and decreasing paths.
Second, if two nodes X and Y aren't ordered with respect to each other in the partial order, then intermediary nodes can be used to create the paths by increasing/decreasing to the intermediary and then decreasing/increasing to reach Y. As usual, the two basic ideas will be discussed assuming the network is 2 connected.
The generalization to multiple blocks is discussed in Section 5.7.4.
The full algorithm is given in Section 5.7.5.
Next Hops to All Nodes Ordered with Respect to the Computing Node Finding two node disjoint paths from the computing router X to any node Y depends upon whether Y>>X or Y<<X.
As shown in Figure 19, if Y>>X, then there is an increasing path that goes from X to Y without crossing R; this contains nodes in the interval [X,Y].
There is also a decreasing path that decreases towards R and then decreases from R to Y; this contains nodes in the interval [X,R small] or [R great,Y].
The two paths cannot have common nodes other than X and Y. [Y]
X Cloud 2 Y MRT Red path:
X Cloud 1 R Cloud 3 Y Figure 19:
Y>>X Similar logic applies if Y<<X, as shown in Figure 20.
In this case, the increasing path from X increases to R and then increases from R to Y to use nodes in the intervals [X,R great] and [R small, Y].
The decreasing path from X reaches Y without crossing R and uses nodes in the interval [Y,X].
X Cloud 3 R Cloud 1 Y MRT Red path:
X Cloud 2 Y Figure 20: Y<<X 5.7.2.
Next Hops to All Nodes
Not Ordered with Respect to the Computing Node
When X and Y are not ordered, the first path should increase until we get to a node G, where G>>Y.  At G, we need to decrease to Y.
The other path should be just the opposite: we must decrease until we get to a node H, where H<<Y, and then increase.
Since R is smaller and greater than Y, such G and H must exist.
It is also easy to see that these two paths must be node disjoint: the first path contains nodes in interval [X,G] and [Y,G], while the second path contains nodes in interval [H,X] and [H,Y].
This is illustrated in Figure 21.
It is necessary to decrease and then increase for the MRT Blue and increase and then decrease for the MRT Red; if one simply increased for one and decreased for the other, then both paths would go through the root R. (Cloud 6)
MRT Blue path: decrease to H and increase to Y X Cloud 2 H Cloud 5 Y MRT Red path:
increase to G and decrease to Y X Cloud 3 G Cloud 6 Y Figure 21:
This gives disjoint paths as long as G and H are not the same node.
Since G>>Y and H<<Y, if G and H could be the same node, that would have to be the root R.
This is not possible because there is only one incoming interface to the root R that is created when the initial cycle is found.
Recall from Figure 6 that whenever an ear was found to have an end that was the root R, the ear was directed from R so that the associated interface on R is outgoing and not incoming.
Therefore, there must be exactly one node M
that is the largest one before R
, so the MRT Red path will never reach R; it will turn at M and decrease to Y. 5.7.3.
Next Hops in a 2 Connected Graph
The basic ideas for computing RT next hops in a 2 connected graph were given in Sections 5.7.1 and 5.7.2.
Given these two ideas, how can we find the trees?
If some node X only wants to find the next hops (which is usually the case for IP networks), it is enough to find which nodes are greater and less than X, and which are not ordered; this can be done by running an increasing SPF and a decreasing SPF rooted at X and not exploring any links from the ADAG root.
In principle, a traversal method other than SPF could be used to traverse the GADAG in the process of determining blue and red next hops that result in maximally redundant trees.
This will be the case as long as one traversal uses the links in the direction specified by the GADAG and the other traversal uses the links in the direction opposite of that specified by the GADAG.
However, a different traversal algorithm will generally result in different blue and red next hops.
Therefore, the algorithm specified here requires the use of SPF to traverse the GADAG to generate MRT blue and red next hops, as described below.
An increasing SPF rooted at X and not exploring links from the root will find the increasing next hops to all Y>>X.
Those increasing next hops are
X's next hops on the MRT Blue to reach Y.  A decreasing SPF rooted at X and not exploring links from the root will find the decreasing next hops to all Z<<X.
Those decreasing next hops are X's next hops on the MRT Red to reach Z.
Since the root R is both greater than and less than X, after this increasing SPF and decreasing SPF, X's next hops on the MRT Blue and on the MRT Red to reach R are known.
X's next hops on the MRT Red to reach Y are set to those on the MRT Red to reach R.
For every node Z<<X, X's next hops on the MRT Blue to reach Z are set to those on the MRT Blue to reach R.
For those nodes that were not reached by either the increasing SPF or the decreasing SPF, we can determine the next hops as well.
The increasing MRT Blue next hop for a node that is not ordered with respect to X is the next hop along the decreasing MRT Red towards R, and the decreasing MRT Red next hop is the next hop along the increasing MRT Blue towards R.
Naturally, since R is ordered with respect to all the nodes, there will always be an increasing and a decreasing path towards it.
This algorithm does not provide the complete specific path taken but just the appropriate next hops to use.
The identities of G and H are not determined by the computing node X.
The final case to consider is when the GADAG root R computes its own next hops.
Since the GADAG root R is << all other nodes, running an increasing SPF rooted at R will reach all other nodes; the MRT Blue next hops are those found with this increasing SPF.
Similarly, since the GADAG root R is >>
all other nodes, running a decreasing SPF rooted at R will reach all other nodes; the MRT Red next hops are those found with this decreasing SPF.
A spanning ADAG rooted at R Figure 22
As an example, consider the situation depicted in Figure 22.
Node C runs an increasing SPF and a decreasing SPF on the ADAG.
The increasing SPF reaches D, E, and R; the decreasing SPF reaches B, A, and R.  E>>C.
So, towards E the MRT Blue next hop is D, since E was reached on the increasing path through D.
The MRT Red next hop towards E
is B, since R was reached on the decreasing path through B. Since E>>D
, D will similarly compute its MRT Blue next hop to be E, ensuring that a packet on MRT Blue will use path C D E.  B, A, and R will similarly compute the MRT Red next hops towards E (which is ordered less than B, A and R), ensuring that a packet on MRT Red will use path C B A R E. C can determine the next hops towards F as well.
Since F is not ordered with respect to C, the MRT Blue
next hop is the decreasing one towards R (which is B) and the MRT Red next hop
is the increasing one towards R (which is D).
Since F>>B, for its MRT Blue next hop towards F, B will use the real increasing next hop towards F.
So a packet forwarded to B on MRT Blue will get to F on path C B F. Similarly, D will use the real decreasing next hop towards F as its MRT Red next hop, a packet on MRT Red will use path C D F. 5.7.4.
If a graph isn't 2 connected, then the basic approach given in Section 5.7.3 needs some extensions to determine the appropriate MRT next hops to use for destinations outside the computing router X's blocks.
In order to find a pair of maximally redundant trees in that graph, we need to find a pair of RTs in each of the blocks (the root of these trees will be discussed later) and combine them.
When computing the MRT next hops from a router X, there are three basic differences: 1.
Only nodes in a common block with X should be explored in the increasing SPF and decreasing SPF.
Instead of using the GADAG root, X's localroot should be used.
This has the following implications: A.
The links from X's localroot should not be explored.
If a node is explored in the outgoing SPF so Y>>X, then X's MRT Red next hops to reach Y uses X's MRT Red
next hops to reach X's localroot and
if Z<<X, then X's MRT Blue next hops to reach Z uses X's MRT Blue next hops to reach X's localroot.
If a node W in a common block with X was not reached in the increasing SPF or decreasing SPF, then W is unordered with respect to X.  X's MRT Blue
next hops to W are X's decreasing (aka MRT Red)
next hops to X's localroot.
X's MRT Red next hops to W
are X's increasing (aka MRT Blue)
next hops to X's localroot.
For nodes in different blocks, the next hops must be inherited via the relevant cut vertex.
These are all captured in the detailed algorithm given in Section 5.7.5.
Complete Algorithm to Compute MRT
The complete algorithm to compute MRT Next Hops for a particular router X is given in Figure 23.
In addition to computing the MRT  Blue next hops and MRT Red
next hops used by X to reach each node Y, the algorithm also stores an "order proxy", which is the proper cut  vertex to reach Y if it is outside the block, and which is used later in deciding whether the MRT Blue or the MRT Red can provide an acceptable alternate for a particular primary next hop.
In Common Block(x, y) if ( (x.block id is y.block id)
or (x is y.localroot) or
(y is x.localroot) ) return true return false Store Results(y, direction) if direction is FORWARD
y.next hops if direction is REVERSE y.lower
No Traverse Block Root(spf root, block root, direction)
Initialize spf heap to empty Initialize nodes' spf metric to infinity and next hops to empty spf
insert(spf heap, spf root) while (spf heap is not empty)
if ((min node is spf root) or (min node is not block root))
foreach interface intf of min node
or ((direction is REVERSE) and intf.
and In Common Block(spf root, intf.remote node) ) path metric
intf.remote node.spf metric intf.remote node.spf
if min node is spf root
node.next hops insert or update(spf heap, intf.remote node) else if path metric
node.spf metric if min node is spf root add to list(intf.remote node.next hops, intf) else add list to list(intf.remote node.next hops, min node.next hops)
if y.blue next hops is empty and y.red next hops is empty
next hops y.red next hops
proxy Compute MRT NextHops(x, gadag root)
false clear y.red next hops and
SPF No Traverse Block Root(x
No Traverse Block Root(x, x.localroot, REVERSE)
red and blue next hops are stored to x.localroot as different // paths are found via the SPF and reverse SPF. //
Similarly, any node whose localroot is x will have its // red next hops and blue next hops already set.
Handle nodes in the same block that aren't the localroot foreach node
and (y is not x)
if y.higher y.red next hops   x.localroot.red
next hops else if y.lower y.blue next hops
next hops y.red next hops
Inherit next hops and order proxies to other components if (x is not gadag root)
and (x.localroot is not gadag root)
next hops gadag root.order proxy
if (y is not gadag root) and (y is not x)
Compute MRT NextHops(x, gadag root)
Complete Algorithm to Compute MRT
At this point, a computing router S knows its MRT Blue next hops and MRT Red
next hops for each destination in the MRT Island.
The primary next hops along the SPT are also known.
It remains to determine for each primary next hop to a destination D, which MRT avoids the primary next hop node F.
This computation depends upon data set in Compute MRT NextHops such as each node
next hops, y.red next hops,
y.order proxy, y.higher, y.lower, and topo orders.
Recall that any router knows only which are the nodes greater and lesser than itself, but it cannot decide the relation between any two given nodes easily
; that is why we need topological ordering.
For each primary next hop node F to each destination D, S can call Select Alternates(S, D, F, primary intf) to determine whether to use the MRT Blue or MRT Red next hops as the alternate next hop(s) for that primary next hop.
The algorithm is given in Figure 24 and discussed afterwards.
Select Alternates Internal(D, F, primary intf,
D lower, D higher, D topo order):
if D higher and D lower if F.HIGHER and F.LOWER
if F.topo order < D topo order return USE RED else
return USE BLUE if F.HIGHER return USE RED if F.LOWER return USE BLUE //F
wrt S return USE RED OR BLUE else if D higher if F.HIGHER and F.LOWER return
if F.LOWER return USE BLUE if F.HIGHER
if (F.topo order > D topo order) return USE BLUE if (F.topo order < D topo order) return USE RED //F
wrt S return USE RED OR BLUE else if D lower if F.HIGHER and F.LOWER return USE RED if F.HIGHER return USE RED if F.LOWER
if F.topo order > D topo order return USE BLUE if F.topo order < D topo order return USE RED //F
wrt S return USE RED OR BLUE else  //D
is unordered wrt S if F.HIGHER and F.LOWER if primary intf.
INCOMING return USE RED OR BLUE if primary intf.
OUTGOING return USE BLUE if primary intf.
INCOMING return USE RED //primary
intf not in GADAG return USE RED if F.LOWER return USE RED if F.HIGHER return USE BLUE //F
D topo order: return USE BLUE else: return USE RED Select Alternates(D, F, primary intf) if not In Common Block(F
, S) return PRIM NH IN DIFFERENT BLOCK if (D is F) or (D.order proxy is F) return
PRIM NH IS D OR OP
FOR D D lower   D.order proxy.
LOWER D higher   D.order proxy.
proxy.topo order return Select Alternates Internal(D, F, primary intf,
D lower, D higher, D topo order)
Select Alternates() and Select Alternates
() It is useful to first handle the case where F is also D, or F is the order proxy for D.
In this case, only link protection is possible.
The MRT that doesn't use the failed primary next hop is used.
If both MRTs use the primary next hop, then the primary next hop must be a cut link, so either MRT could be used but the set of MRT next hops must be pruned to avoid the failed primary next hop interface.
To indicate this case, Select Alternates returns PRIM NH
OP FOR D.  Explicit pseudocode to handle the three sub cases above is not provided.
The logic behind Select Alternates Internal() is described in Figure 25.
As an example, consider the first case described in the table, where the D>>S and D<<S.  If this is true, then either S or D must be the block root, R.
If F>>S and F<<S, then S is the block root.
So the blue path from S to D is the increasing path to D, and the red path S to D is the decreasing path to D.
If the F.topo order>D.topo order, then either F is ordered higher than D or F is unordered with respect to D.
Therefore, F is either on a decreasing path from S to D, or it is on neither an increasing nor a decreasing path from S to D.
In either case, it is safe to take an increasing path from S to D to avoid F.
We know that when S is R, the increasing path is the blue path, so it is safe to use the blue path to avoid F.
If instead F.topo order<D.topo order, then either F is ordered lower than D, or F is unordered with respect to D.
Therefore, F is either on an increasing path from S to D, or it is on neither an increasing nor a decreasing path from S to D.
In either case, it is safe to take a decreasing path from S to D to avoid F.
We know that when S is R, the decreasing path is the red path, so it is safe to use the red path to avoid F.
If F>>S or F<<S (but not both), then D is the block root.
We then know that the blue path from S to D is the increasing path to R, and the red path is the decreasing path to R.
When F>>S, we deduce that F is on an increasing path from S to R.
So in order to avoid F, we use a decreasing path from S to R, which is the red path.
Instead, when F<<S, we deduce that F is on a decreasing path from S to R.
So in order to avoid F, we use an increasing path from S to R, which is the blue path.
All possible cases are systematically described in the same manner in the rest of the table.
Can only occur    F is on
Can only occur    F is on
Can only occur    F is on
Determining MRT next hops and alternates based on the partial order and topological sort relationships between the source(S), destination(D), primary next hop(F), and block root(R).
topo(N) indicates the topological sort value of node N.
X??Y indicates that node X is unordered with respect to node Y.
It is assumed that the case where F is D, or where F is the order proxy for D, has already been handled.
Determining MRT Next Hops and Alternates
The last case in Figure 25 requires additional explanation.
The fact that the red path from S to D in this case avoids F relies on a special property of the GADAGs that we have constructed in this algorithm, a property not shared by all GADAGs in general.
When D is unordered with respect to S, and F is the localroot for S, it can occur that the link between S and F is not in the GADAG only when that link has been marked MRT INELIGIBLE.
For an arbitrary GADAG, S doesn't have enough information based on the computed order relationships to determine if the red path or blue path will hit F (which is also the localroot) before hitting K or L, and making it safely to D.
However, the GADAGs that we construct using the algorithm in this document are not arbitrary GADAGs.
They have the additional property that incoming links to a localroot come from only one other node in the same block.
This is a result of the method of construction.
This additional property guarantees that the red path from S to D will never pass through the localroot of S.
(That would require the localroot to play the role of L, the first node in the path ordered higher than D, which would in turn require the localroot to have two incoming links in the GADAG, which cannot happen.)
Therefore, it is safe to use the red path to avoid F with these specially constructed GADAGs.
As an example of how Select Alternates Internal() operates, consider the ADAG depicted in Figure 26 and first suppose that G is the source, D is the destination, and H is the failed next hop.
Since D>>G, we need to compare H.topo order and D.topo order.
>H.topo order, D must be either higher than H or unordered with respect to H, so we should select the decreasing path towards the root.
If, however, the destination were instead J, we must find that H.topo order>J.topo order, so we must choose the increasing Blue next hop to J, which is I.
In the case, when instead the destination is C, we find that we need to first decrease to avoid using H, so the Blue, first decreasing then increasing, path is selected.
ADAG Rooted at R for a 2 Connected Graph 5.9.
As discussed in Section 11.2 of [RFC7812], it is necessary to find MRT Blue and MRT Red
next hops and MRT FRR alternates for named proxy nodes.
An example use case is for a router that is not part of that local MRT Island, when there is only partial MRT support in the domain.
Determining Proxy Node Attachment Routers Section 11.2 of [RFC7812] discusses general considerations for determining the two proxy node attachment routers for a given proxy  node, corresponding to a prefix.
A router in the MRT Island that advertises the prefix is a candidate for being a proxy node attachment router, with the associated named proxy cost equal to the advertised cost to the prefix.
An Island Border Router (IBR) is a router in the MRT Island that is connected to an Island Neighbor (IN), which is a router not in the MRT Island but in the same area/level.
An (IBR,IN) pair is a candidate for being a proxy node attachment router, if the shortest path from the IN to the prefix does not enter the MRT Island.
A method for identifying such Loop Free Island Neighbors (LFINs) is given below.
The named proxy cost assigned to each (IBR, IN) pair is cost(IBR, IN)
From the set of prefix advertising routers and the set of IBRs with at least one LFIN, the two routers with the lowest named proxy cost are selected.
Ties are broken based upon the lowest Router ID.
For ease of discussion, the two selected routers will be referred to as proxy node attachment routers.
If an Island Neighbor (IN) Is Loop Free
As discussed above, the IN needs to be loop free with respect to the whole MRT Island for the destination.
This can be accomplished by running the usual SPF algorithm while keeping track of which shortest paths have passed through the MRT island.
Pseudocode for this is shown in Figure 27.
The Island Marking SPF() is run for each IN that needs to be evaluated for the loop free condition, with the IN as the spf root.
Whether or not an IN is loop free with respect to the MRT island can then be determined by evaluating node.
PATH HITS ISLAND for each destination of interest.
Initialize spf heap to empty Initialize nodes' spf metric to infinity and next hops to empty and PATH HITS ISLAND to false spf
insert(spf heap, spf root) while (spf heap is not empty)
foreach interface intf of min node path metric
intf.remote node.spf metric intf.remote node.spf
if min node is spf root
node.next hops if intf.remote node.
IN MRT ISLAND intf.remote node.
PATH HITS ISLAND insert or update(spf heap, intf.remote node)
node.spf metric if min node is spf root add to list(intf.remote node.next hops, intf) else add list to list(intf.remote node.next hops, min node.next hops) if intf.remote node.
IN MRT ISLAND intf.remote node.
PATH HITS ISLAND Figure 27:
Island Marking SPF() for Determining If an Island Neighbor Is Loop Free
It is also possible that a given prefix is originated by a combination of non island routers and island routers.
The results of the Island Marking SPF() computation can be used to determine if the shortest path from an IN to reach that prefix hits the MRT Island.
The shortest path for the IN to reach prefix P is determined by the total cost to reach prefix P, which is the sum of the cost for the IN to reach a prefix advertising node and the cost with which that node advertises the prefix.
The path with the minimum total cost to prefix P is chosen.
If the prefix advertising node for that minimum total cost path has PATH HITS ISLAND set to True, then the IN is not loop free with respect to the MRT Island for reaching prefix P.
If there are multiple minimum total cost paths to reach prefix P, then all of the prefix advertising routers involved in the minimum total cost paths MUST have PATH HITS ISLAND set to False for the IN to be considered loop free to reach P. Note that there are other computations that could be used to determine if paths from a given IN  might  pass through the MRT Island for a given prefix or destination.
For example, a previous draft version of this document specified running the SPF algorithm on modified topology that treats the MRT Island as a single node (with intra island links set to zero cost) in order to provide input to computations to determine if the path from IN to non island destination hits the MRT Island in this modified topology.
This computation is enough to guarantee that a path will not hit the MRT Island in the original topology.
However, it is possible that a path that is disqualified for hitting the MRT Island in the modified topology will not actually hit the MRT Island in the original topology.
The algorithm described in Island Marking SPF() above does not modify the original topology, and will only disqualify a path if the actual path does in fact hit the MRT Island.
Since all routers need to come to the same conclusion about which routers qualify as LFINs, this specification requires that all routers computing LFINs MUST use an algorithm whose result is identical to that of the Island Marking SPF() in Figure 27.
Next Hops for Proxy Nodes
Determining the MRT next hops for a proxy node in the degenerate case where the proxy node is attached to only one node in the GADAG is trivial, as all needed information can be derived from that proxy  node attachment router.
If there are multiple interfaces connecting the proxy node to the single proxy node attachment router, then some can be assigned to MRT Red and others to MRT Blue.
Now, consider the proxy node P that is attached to two proxy node attachment routers.
The pseudocode for Select Proxy Node NHs(P,S) in Figure 28 specifies how a computing router S MUST compute the MRT red and blue next hops to reach proxy node P.
The proxy node attachment router with the lower value of mrt node
id (as defined in Figure 15) is assigned to X, and the other proxy node attachment router is assigned to Y.
We will be using the relative order of X,Y, and S in the partial order defined by the GADAG to determine the MRT red and blue next hops to reach P, so we also define A and B as the order proxies for X and Y, respectively, with respect to S.
The order proxies for all nodes with respect to S were already computed in Compute MRT NextHops().
def Select Proxy Node NHs(P,S): if P.pnar1.node.node
Y A   X.order proxy B
next hops, X.blue next hops)
next hops, Y.red next hops)
return if (A is S.localroot and B is not S.localroot):
case 2.0 if B.LOWER: //
next hops, X.blue next hops)
next hops, Y.red next hops) return if B.HIGHER: //
case 2.2 Copy List Items(P.blue
next hops, X.red next hops)
next hops, X.red next hops)
next hops, Y.red next hops)
return if (A is not S.localroot and B is S.localroot):
Copy List Items(P.blue next hops, X.red next hops)
next hops, Y.blue next hops) return if A.HIGHER:
// case 3.2 Copy List Items(P.blue
next hops, X.blue next hops)
next hops, X.red next hops)
next hops, Y.red next hops)
return if (A is not S.localroot and B
if A.topo order < B.topo order:
next hops, X.blue next hops)
next hops, X.red next hops)
next hops, Y.blue next hops) return if A.LOWER: //
Copy List Items(P.blue next hops, X.red next hops)
next hops, Y.blue next hops) return if B.LOWER: //
4.1.2 if A.topo order < B.topo order: //
next hops, X.blue next hops)
next hops, X.red next hops)
next hops, Y.blue next hops) return else: //
case 4.1.3 Copy List Items(P.blue
next hops, X.red next hops)
next hops, Y.red next hops)
case 4.2 if B.HIGHER: //
if A.topo order < B.topo order: //
Copy List Items(P.blue next hops, X.blue next hops)
next hops, Y.red next hops) return else: //
Copy List Items(P.blue next hops, X.red next hops)
next hops, Y.blue next hops) return if B.LOWER: //
next hops, X.blue next hops)
next hops, Y.red next hops) return else: //
next hops, X.blue next hops)
next hops, Y.blue next hops) return else: //
next hops, X.red next hops)
next hops, X.blue next hops)
next hops, Y.blue next hops) return else: //
if A.topo order < B.topo order: //
next hops, X.blue next hops)
next hops, X.red next hops)
next hops, Y.blue next hops)
() It is useful to understand up front that the blue next hops to reach proxy node P produced by Select Proxy Node NHs() will always be the next hops that reach proxy node attachment router X, while the red next hops to reach proxy node P will always be the next hops that reach proxy node attachment router Y.
This is different from the red and blue next hops produced by Compute MRT NextHops() where, for example, blue next hops to a destination that is ordered with respect to the source will always correspond to an INCREASING next hop on the GADAG.
The exact choice of which next hops chosen by Select Proxy Node NHs() as the blue next hops to reach P (which will necessarily go through X on its way to P) does depend on the GADAG, but the relationship is more complex than was the case with Compute MRT NextHops().
There are 21 different relative order relationships between A, B, and S that Select Proxy Node NHs() uses to determine red and blue next hops to P.
This document does not attempt to provide an exhaustive description of each case considered in Select Proxy Node NHs().
Instead, we provide a high level overview of the different cases, and we consider a few cases in detail to give an example of the reasoning that can be used to understand each case.
At the highest level, Select Proxy Node NHs() distinguishes between four different cases depending on whether or not A or B is the localroot for S.
For example, for case 4.0, neither A nor B is the localroot for S.  Case 4.05 addresses the case where S is the localroot for either A or B, while cases 4.1, 4.2, and 4.3 address the cases where A is ordered lower than S, A is ordered higher than S, or A is unordered with respect to S on the GADAG.
In general, each of these cases is then further subdivided into whether or not B is ordered lower than S, B is ordered higher than S, or B is unordered with respect to S.
In some cases, we also need a further level of discrimination, where we use the topological sort order of A with respect to B.
As a detailed example, let's consider case 4.1 and all of its sub  cases, and explain why the red and blue next hops to reach P are chosen as they are in Select Proxy Node NHs().
In case 4.1, neither A nor B is the localroot for S, S is not the localroot for A or B, and A is ordered lower than S on the GADAG.
In this situation, we know that the red path to reach X (as computed in Compute MRT NextHops()) will follow DECREASING next hops towards A, while the blue path to reach X will follow INCREASING next hops to the localroot, and then INCREASING next hops to A. Now consider sub case
4.1.1 where B is ordered higher than S.
In this situation, we know that the blue path to reach Y will follow INCREASING next hops towards B, while the red next hops to reach Y will follow DECREASING next hops to the localroot, and then DECREASING next hops to B.
So, to reach X and Y by two disjoint paths, we can choose the red next hops to X and the blue next hops to Y.
We have chosen the convention that blue next hops to P are those that pass through X, and red next hops to P are those that pass through Y, so we can see that case 4.1.1 produces the desired result.
Choosing blue to X and red to Y does not produce disjoint paths because the paths intersect at least at the localroot.
Now consider sub case 4.1.2 where B is ordered lower than S.
In this situation, we know that the red path to reach Y will follow DECREASING next hops towards B, while the BLUE next hops to reach Y will follow INCREASING next hops to the localroot, and then INCREASING next hops to A.
The choice here is more difficult than in 4.1.1 because A and B are both on the DECREASING path from S towards the localroot.
We want to use the direct DECREASING(red) path to the one that is nearer to S on the GADAG.
We get this extra information by comparing the topological sort order of A and B.
If A.topo order<B.topo order, then we use red to Y and blue to X, since the red path to Y will DECREASE to B without hitting A, and the blue path to X will INCREASE to A without hitting B.  Instead, if A.topo order>B.topo order, then we use red to X and blue to Y. Note that when A is unordered with respect to B, the result of comparing A.topo order with B.topo order could be greater than or less than.
In this case, the result doesn't matter because either choice (red to Y and blue to X or red to X and blue to Y) would work.
What is required is that all nodes in the network give the same result when comparing A.topo order with B.topo order.
This is guaranteed by having all nodes run the same algorithm (Run Topological Sort GADAG()) to compute the topological sort order.
Finally, we consider case 4.1.3, where B is unordered with respect to S.
In this case, the blue path to reach Y will follow the DECREASING next hops towards the localroot until it reaches some node (K) which is ordered less than B, after which it will take INCREASING next hops to B.
The red path to reach Y will follow the INCREASING next hops towards the localroot until it reaches some node (L) which is ordered greater than B, after which it will take DECREASING next hops to B. Both K and A are reached by DECREASING from S, but we don't have information about whether or not that DECREASING path will hit K or A first.
Instead, we do know that the INCREASING path from S will hit L before reaching A.  Therefore
, we use the red path to reach Y and the red path to reach X. Similar reasoning
can be applied to understand the other 17 cases used in Select Proxy Node NHs().
However, cases 2.3 and 3.3 deserve special attention because the correctness of the solution for these two cases relies on a special property of the GADAGs that we have constructed in this algorithm, a property not shared by all GADAGs in general.
Focusing on case 2.3, we consider the case where A is the localroot for S, while B is not, and B is unordered with respect to S.
The red path to X DECREASES from S to the localroot A, while the blue path to X INCREASES from S to the localroot A.
The blue path to Y DECREASES towards the localroot A until it reaches some node (K) which is ordered less than B, after which the path INCREASES to B.
The red path to Y INCREASES towards the localroot A until it reaches some node (L) which is ordered greater than B, after which the path DECREASES to B.
It can be shown that for an arbitrary GADAG, with only the ordering relationships computed so far, we don't have enough information to choose a pair of paths to reach X and Y that are guaranteed to be disjoint.
In some topologies, A will play the role of K, the first node ordered less than B on the blue path to Y.
In other topologies, A will play the role of L, the first node ordered greater than B on the red path to Y.
The basic problem is that we cannot distinguish between these two cases based on the ordering relationships.
As discussed Section 5.8, the GADAGs that we construct using the algorithm in this document are not arbitrary GADAGs.
They have the additional property that incoming links to a localroot come from only one other node in the same block.
This is a result of the method of construction.
This additional property guarantees that localroot A will never play the role of L in the red path to Y, since L must have at least two incoming links from different nodes in the same block in the GADAG.
This, in turn, allows Select Proxy Node NHs() to choose the red path to Y and the red path to X as the disjoint MRT paths to reach P. 5.9.4.
Computing MRT Alternates for Proxy Nodes
After finding the red and the blue next hops for a given proxy node P, it is necessary to know which one of these to use in the case of failure.
This can be done by Select Alternates Proxy Node(), as shown in the pseudocode in Figure 29.
Select Alternates Proxy Node(P,F,primary intf):
Y A   X.order proxy B
Y.order proxy if F is A and F is B
: return 'PRIM NH IS OP FOR BOTH X AND Y'
: return 'USE RED' if F is B: return 'USE BLUE' if not In Common Block(A, B): if In Common Block(F, A): return 'USE RED' elif
In Common Block(F, B): return 'USE BLUE' else
: return 'USE RED OR BLUE' if (not In Common Block(F, A) and not In Common Block(F, A)
return 'USE RED OR BLUE' alt to X   Select Alternates(X, F, primary intf) alt to Y   Select Alternates(Y, F, primary intf)
if (alt to X   'USE RED OR BLUE' and alt to Y   'USE RED OR BLUE')
case 2.0 if B.LOWER: //
case 2.1 if (alt to X   'USE BLUE' and alt to Y   'USE RED')
case 2.3 if (alt to X   'USE RED' and alt to Y   'USE RED')
if (alt to X   'USE RED' and alt to Y   'USE BLUE')
: return 'USE RED OR BLUE' if alt to X   'USE BLUE': return 'USE BLUE' if alt to Y   'USE RED': return 'USE RED' assert(False) else: //
if A.topo order < B.topo order:
if (alt to X   'USE BLUE' and alt to Y   'USE RED'): return 'USE RED OR BLUE' if alt to X   'USE BLUE': return 'USE BLUE' if alt to Y   'USE RED': return 'USE RED' assert(False)
if (alt to X   'USE RED' and alt to Y   'USE BLUE')
4.1.1 if (alt to X   'USE RED' and alt to Y   'USE BLUE')
4.1.2 if A.topo order < B.topo order: //
if (alt to X   'USE BLUE' and alt to Y   'USE RED'): return 'USE RED OR BLUE' if alt to X   'USE BLUE': return 'USE BLUE' if alt to Y   'USE RED': return 'USE RED' assert(False) else: //
if (alt to X   'USE RED' and alt to Y   'USE BLUE')
if (F.LOWER and not F.HIGHER and F.topo order > A.topo order)
case 4.1.3.1 return 'USE RED' else: //
case 4.1.3.2 return 'USE BLUE'
if A.topo order < B.topo order: //
case 4.2.1.1 if (alt to X   'USE BLUE' and alt to Y   'USE RED')
: return 'USE RED OR BLUE' if alt to X   'USE BLUE': return 'USE BLUE' if alt to Y   'USE RED': return 'USE RED' assert(False) else: //
if (alt to X   'USE RED' and alt to Y   'USE BLUE')
not F.LOWER and F.topo order < A.topo order): return 'USE RED' else: return 'USE BLUE' else:
if (F.LOWER and not F.HIGHER and F.topo
order > B.topo order): return 'USE BLUE' else
: return 'USE RED' if B.HIGHER: //
case 4.3.2 if (F.HIGHER and
not F.LOWER and F.topo order < B.topo order): return 'USE BLUE' else:
return 'USE RED' else: //
if A.topo order < B.topo order: //
if (alt to X   'USE BLUE' and alt to Y   'USE RED'): return 'USE RED OR BLUE' if alt to X   'USE BLUE': return 'USE BLUE' if alt to Y   'USE RED': return 'USE RED' assert(False) else: //
if (alt to X   'USE RED' and alt to Y   'USE BLUE')
: return 'USE RED OR BLUE' if alt to X   'USE RED'
: return 'USE BLUE' if alt to Y   'USE BLUE': return 'USE RED' assert(False) assert(False) Figure 29:
Select Alternates Proxy Node(P,F,primary intf) determines whether it is safe to use the blue path to P (which goes through X), the red path to P (which goes through Y), or either, when the primary intf to node F (and possibly node F) fails.
The basic approach is to run Select Alternates(X,F,primary intf) and Select Alternates(Y,F,primary intf) to determine which of the two MRT paths to X and which of the two MRT paths to Y is safe to use in the event of the failure of F.
In general, we will find that if it is safe to use a particular path to X or Y when F fails, and Select Proxy Node NHs() used that path when constructing the red or blue path to reach P, then it will also be safe to use that path to reach P when F fails.
This rule has one exception which is covered below.
First, we give a concrete example of how Select Alternates Proxy Node() works in the common case.
The 21 ordering relationships used in Select Proxy Node NHs() are repeated in Select Alternates Proxy Node().
We focus on case 4.1.1 to give a detailed example of the reasoning used in Select Alternates Proxy Node().
In Select Proxy Node NHs
(), we determined for case 4.1.1 that the red next hops to X and the blue next hops to Y allow us to reach X and Y by disjoint paths, and are thus the blue and red next hops to reach P.  Therefore, if Select Alternates(X, F, primary intf) is run and we find that it is safe to USE RED to reach X, then we also conclude that it is safe to use the MRT path through X to reach P (the blue path to P) when F fails.
Similarly, if we run Select Alternates(Y, F, primary intf) and we find that it is safe to USE BLUE to reach Y, then we also conclude that it is safe to use the MRT path through Y to reach P (the red path to P) when F fails.
If both of the paths that were used in Select Proxy Node NHs() to construct the blue and red paths to P are found to be safe to use to use to reach X and Y, t then we conclude that we can use either the red or the blue path to P.
This simple reasoning gives the correct answer in most of the cases.
However, additional logic is needed when either A or B (but not both A and B) is unordered with respect to S.
This applies to cases 4.1.3, 4.2.3, 4.3.1, and 4.3.2.
Looking at case 4.1.3 in more detail, A is ordered less than S, but B is unordered with respect to S.
In the discussion of case 4.1.3 above, we saw that Select Proxy Node NHs() chose the red path to reach Y and the red path to reach X.
We also saw that the red path to reach Y will follow the INCREASING next hops towards the localroot until it reaches some node (L) which is ordered greater than B, after which it will take DECREASING next hops to B.
The problem is that the red path to reach P (the one that goes through Y) won't necessarily be the same as the red path to reach Y.  This is because the next hop that node
L computes for its red next hop to reach P may be different from the next hop
it computes for its red next hop to reach
Y.  This is because B is ordered lower than L
, so L applies case 4.1.2 of Select Proxy Node NHs() in order to determine its next hops to reach P.
If A.topo order<B.topo order (case 4.1.2.1), then L will choose DECREASING next hops directly to B, which is the same result that L computes in Compute MRT NextHops() to reach Y.
However, if A.topo order>B.topo order (case 4.1.2.2), then L will choose INCREASING next hops to reach B, which is different from what L computes in Compute MRT NextHops() to reach Y.  So, testing the safety of the path for S to reach Y on failure of F as a surrogate for the safety of using the red path to reach P is not reliable in this case.
It is possible construct topologies where the red path to P hits F even though the red path to Y does not hit F. Fortunately, there is enough information in the order relationships that we have already computed to still figure out which alternate to choose in these four cases.
The basic idea is to always choose the path involving the ordered node, unless that path would hit F. Returning to case 4.1.3, we see that since A is ordered lower than S, the only way for S to hit F using a simple DECREASING path to A is for F to lie between A and S on the GADAG.
This scenario is covered by requiring that F be lower than S (but not also higher than S) and that F.topo order>A.topo order in case 4.1.3.1.
We just need to confirm that it is safe to use the path involving B in this scenario.
In case 4.1.3.1, either F is between A and S on the GADAG, or F is unordered with respect to A and lies on the DECREASING path from S to the localroot.
When F is between A and S on the GADAG, then the path through B chosen to avoid A in Select Proxy Node NHs() will also avoid F.
When F is unordered with respect to A and lies on the DECREASING path from S to the localroot, then we consider two cases.
Either F.topo order<B.topo order or F.topo order>B.topo order.
In the first case, since F.topo order<B.topo order and F.topo order
>A.topo order, it must be the case that A.topo order<B.topo order.
Therefore, L will choose DECREASING next hops directly to B (case 4.1.2.1), which cannot hit F since F.topo order<B.topo order.
In the second case, where F.topo order>B.topo order, the only way for the path involving B to hit F is if it DECREASES from L to B through F, i.e., it must be that L>>F>>B.
However, since S>>F, this would imply that S>>B.
However, we know that S is unordered with respect to B, so the second case cannot occur.
So we have demonstrated that the red path to P (which goes via B and Y) is safe to use under the conditions of 4.1.3.1.
Similar reasoning can be applied to the other three special cases where either A or B is unordered with respect to S. 6.
This specification defines the MRT Lowpoint algorithm, which includes the construction of a common GADAG and the computation of MRT Red and MRT Blue
next hops to each node in the graph.
An implementation MAY select any subset of next hops for MRT Red and MRT Blue that respect the available nodes that are described in Section 5.7 for each of the MRT Red and MRT Blue and the selected next hops are further along in the interval of allowed nodes towards the destination.
For example, the MRT Blue next hops used when the destination Y >
X, the computing router, MUST be one or more nodes, T, whose topo order is in the interval [X.topo order, Y.topo order] and where Y >
T or Y is T.  Similarly, the MRT Red next hops MUST be have a topo order in the interval [R small.topo order, X.topo order] or [Y.topo order, R big.topo order].
Implementations SHOULD implement the Select Alternates() function to pick an MRT FRR alternate.
When broadcast interfaces are used to connect nodes, the broadcast network MUST be represented as a pseudonode, where each real node connects to the pseudonode.
The interface metric in the direction from real node to pseudonode is the non zero interface metric,
while the interface metric in the direction from the pseudonode to the real node is set to zero.
This is consistent with the way that broadcast interfaces are represented as pseudonodes in IS IS and OSPF.
Pseudonodes MUST be treated as equivalent to real nodes in the network graph used in the MRT Lowpoint algorithm with a few exceptions detailed below.
The pseudonodes MUST be included in the computation of the GADAG.
The neighbors of the pseudonode need to know the mrt node
id of the pseudonode in order to consistently order interfaces, which is needed to compute the GADAG.
id for IS IS is the 7 octet neighbor system ID and pseudonode number in TLV 22 or TLV 222.
id for OSPFv2 is the 4 octet interface address of the Designated Router found in the Link ID field for the link type 2 (transit network) in the Router LSA.
is the 4 octet interface address of the Designated Router found in the Neighbor Interface ID field for the link type 2 (transit network) in the Router LSA.
Note that this is different from the Neighbor Router ID field used for the mrt node id for point to point links in OSPFv3 Router LSAs given in Figure 15.
Pseudonodes MUST NOT be considered candidates for selection as GADAG root.
This rule is intended to result in a more stable network wide selection of GADAG root by removing the possibility that the change of Designated Router or Designated Intermediate System on a broadcast network can result in a change of GADAG root.
Next Hops on Broadcast Networks
The pseudonode does not correspond to a real node, so it is not actually involved in forwarding.
A real node on a broadcast network cannot simply forward traffic to the broadcast network.
It must specify another real node on the broadcast network as the next hop.
On a network graph where a broadcast network is represented by a pseudonode, this means that if a real node determines that the next hop to reach a given destination is a pseudonode, it must also determine the next next hop for that destination in the network graph, which corresponds to a real node attached to the broadcast network.
It is interesting to note that this issue is not unique to the MRT algorithm, but is also encountered in normal SPF computations for IGPs.
Section 16.1.1 of [RFC2328] describes how this is done for OSPF.
When OSPF runs its shortest path tree calculation, it deals with pseudonodes in the following manner.
Whenever the calculating router finds a shorter path to reach a real destination node and the shorter path to the destination is a single pseudonode hop, then the next hop for that destination is taken from the interface IP address in the Router LSA correspond to the link to the real destination node.
For IS IS, in the example pseudocode implementation of Dijkstra's algorithm in Annex C of [ISO10589 Second Edition], whenever the algorithm encounters an adjacency from a real node to a pseudonode, it gets converted to a set of adjacencies from the real node to the neighbors of the pseudonode.
In this way, the computed next hops point all the way to the real node, and not the pseudonode.
We could avoid the problem of determining next hops across pseudonodes in MRT by converting the pseudonode representation of broadcast networks to a full mesh of links between real nodes on the same network.
However, if we make that conversion before computing the GADAG, we lose information about which links actually correspond to a single physical interface into the broadcast network.
This could result computing red and blue next hops that use the same broadcast interface, in which case neither the red nor the blue next hop would be usable as an alternate on failure of the broadcast interface.
Instead, we take the following approach, which maintains the property that either the red and blue next hop will avoid the broadcast network, if topologically allowed.
We run the MRT Lowpoint algorithm treating the pseudonodes as equivalent to real nodes in the network graph, with the exceptions noted above.
In addition to running the MRT Lowpoint algorithm from the point of view of itself, a computing router connected to a pseudonode MUST also run the MRT Lowpoint algorithm from the point of view of each of its pseudonode neighbors.
For example, if a computing router S determines that its MRT red next hop to reach a destination D is a pseudonode P, S looks at its MRT Lowpoint algorithm computation from P's point of view to determine P's red next hop to reach D, say interface 1 on node
X.  S now knows that its real red next hop to reach D is interface 1 on node X on the broadcast network represented by P, and it can install the corresponding entry in its FIB.
Using MRT Next Hops as Alternates in the Event of Failures on Broadcast Networks
In the previous section, we specified how to compute MRT next hops when broadcast networks are involved.
In this section, we discuss how a PLR can use those MRT next hops in the event of failures involving broadcast networks.
A PLR attached to a broadcast network running only OSPF or IS IS with large Hello intervals has limited ability to quickly detect failures on a broadcast network.
The only failure mode that can be quickly detected is the failure of the physical interface connecting the PLR to the broadcast network.
For the failure of the interface connecting the PLR to the broadcast network, the alternate that avoids the broadcast network can be computed by using the broadcast network pseudonode as F, the primary next hop node, in Select Alternates().
This will choose an alternate path that avoids the broadcast network.
However, the alternate path will not necessarily avoid all of the real nodes connected to the broadcast network.
This is because we have used the pseudonode to represent the broadcast network.
And we have enforced the node protecting property of MRT on the pseudonode to provide protection against failure of the broadcast network, not the real next hop nodes on the broadcast network.
This is the best that we can hope to do if failure of the broadcast interface is the only failure mode that the PLR can respond to.
We can improve on this if the PLR also has the ability to quickly detect a lack of connectivity across the broadcast network to a given IP layer node.
This can be accomplished by running BFD between all pairs of IGP neighbors on the broadcast network.
Note that in the case of OSPF, this would require establishing BFD sessions between all pairs of neighbors in the 2 WAY state.
When the PLR can quickly detect the failure of a particular next hop across a broadcast network, the PLR can be more selective in its choice of alternates.
For example, when the PLR observes that connectivity to an IP layer node on a broadcast network has failed, the PLR may choose to still use the broadcast network to reach other IP layer nodes that are still reachable.
Or, if the PLR observes that connectivity has failed to several IP layer nodes on the same broadcast network, it may choose to treat the entire broadcast network as failed.
The choice of MRT alternates by a PLR for a particular set of failure conditions is a local decision, since it does not require coordination with other nodes.
Evaluation of Alternative Methods for Constructing GADAGs
This document specifies the MRT Lowpoint algorithm.
One component of the algorithm involves constructing a common GADAG based on the network topology.
The MRT Lowpoint algorithm computes the GADAG using the method described in Section 5.5.
This method aims to minimize the amount of computation required to compute the GADAG.
In the process of developing the MRT Lowpoint algorithm, two alternative methods for constructing GADAGs were also considered.
These alternative methods are described in Appendices B and C.
In general, these other two methods require more computation to compute the GADAG.
The analysis below was performed to determine if the alternative GADAG construction methods produce shorter MRT alternate paths in real network topologies, and if so, to what extent.
Figure 30 compares results obtained using the three different methods for constructing GADAGs on five different service provider network topologies.
MRT LOWPOINT indicates the method specified in Section 5.5, while MRT SPF and MRT HYBRID indicate the methods specified in Appendices B and C, respectively.
The columns on the right present the distribution of alternate path lengths for each GADAG construction method.
Each MRT computation was performed using a same GADAG root chosen based on centrality.
For three of the topologies analyzed (T201, T206, and T211), the use of MRT SPF or MRT HYBRID methods does not appear to provide a significantly shorter alternate path lengths compared to the MRT LOWPOINT method.
However, for two of the topologies (T216 and T219), the use of the MRT SPF method resulted in noticeably shorter alternate path lengths than the use of the MRT LOWPOINT or MRT HYBRID methods.
It was decided to use the MRT LOWPOINT method to construct the GADAG in the algorithm specified in this document, in order to initially offer an algorithm with lower computational requirements.
These results indicate that in the future it may be useful to evaluate and potentially specify other MRT Lowpoint algorithm variants that use different GADAG construction methods.
The Length of Alternate Paths for Various GADAG Construction Methods 9.
This section discusses operational considerations related to the MRT Lowpoint algorithm and other potential MRT algorithm variants.
For a discussion of operational considerations related to MRT FRR in general, see the "Operational Considerations" section of [RFC7812].
The Default MRT Profile uses the GADAG Root Selection Priority advertised by routers as the primary criterion for selecting the GADAG root.
It is RECOMMENDED that an operator designate a set of routers as good choices for selection as GADAG root by setting the GADAG Root Selection Priority for that set of routers to lower (more preferred) numerical values.
Criteria for making this designation are discussed below.
Analysis has shown that the centrality of a router can have a significant impact on the lengths of the alternate paths computed.
Therefore, it is RECOMMENDED that off line analysis that considers the centrality of a router be used to help determine how good a choice a particular router is for the role of GADAG root.
If the router currently selected as GADAG root becomes unreachable in the IGP topology, then a new GADAG root will be selected.
Changing the GADAG root can change the overall structure of the GADAG as well the paths of the red and MRT Blue trees built using that GADAG.
In order to minimize change in the associated red and
MRT Blue forwarding entries that can result from changing the GADAG root, it is RECOMMENDED that operators prioritize for selection as GADAG root those routers that are expected to consistently remain part of the IGP topology.
The MRT Lowpoint algorithm constructs a single GADAG rooted at a single node selected as the GADAG root.
It is also possible to construct a different GADAG for each destination, with the GADAG rooted at the destination.
A router can compute the MRT Red and MRT  Blue next hops for that destination based on the GADAG rooted at that destination.
Building a different GADAG for each destination is computationally more expensive, but it may give somewhat shorter alternate paths.
Using destination rooted GADAGs would require a new MRT profile to be created with a new MRT algorithm specification, since all routers in the MRT Island would need to use destination  rooted GADAGs.
The algorithm described in this document does not introduce new security concerns beyond those already discussed in the document describing the MRT FRR architecture [RFC7812].
Appendix A.  Python Implementation of MRT Lowpoint Algorithm Below is Python code implementing the MRT Lowpoint algorithm specified in this document.
The code is also posted on GitHub <https://github.com/cbowers/draft ietf rtgwg mrt frr
While this Python code is believed to correctly implement the pseudocode description of the algorithm, in the event of a difference, the pseudocode description should be considered normative.
This program has been tested to run on Python 2.6 and 2.7 # (specifically Python 2.6.6 and 2.7.8 were tested).
# The program has known incompatibilities with Python
3.X. # When executed, this program will generate a text file describing # an example topology.
It then reads that text file back in as input # to create the example topology, and runs the MRT Lowpoint algorithm.
# This was done to simplify the inclusion of the program as a single # text file that can be extracted from the RFC.
# The output of the program is four text files containing a description # of the GADAG, the blue and MRT Reds for all destinations, and the # MRT alternates for all failures.
import random import os.path import heapq # simple Class definitions allow structure like dot notation for # variables and a convenient place to initialize those variables.
class Topology: def  init (self): self.gadag root
{} class Node: def  init (self): self.node
IN MRT ISLAND   False self.
[] class Interface: def  init (self):
new computing router() def init new computing router(self): self.
IN MRT ISLAND   False self.
Bundle: def  init (self): self.
None self.red or blue   None self.nh list
' class Proxy Node Attachment Router:
[] class Named Proxy Node:
#this is the prefix id
} def Interface Compare(intf a, intf b):
if intf a.metric < intf
: return  1 if intf b.metric < intf a.metric:
return 1 if intf a.remote node.node
id: return  1 if intf
: return 1 return 0 def Sort Interfaces(topo): for node in topo.island node list:
node.island intf list.sort(Interface Compare) def Reset Computed Node and Intf Values(topo): topo.init new computing router() for node in topo.node list: node.init new computing router() for intf in node.intf list: intf.init new computing router()
# This function takes a file with links represented by 2 digit # numbers in the format: # 01,05,10
# 02,01,15 # which represents a triangle topology with nodes 01, 05, and 02 # and symmetric metrics of 10, 30, and 15.
# Inclusion of a fourth column makes the metrics for the link # asymmetric.
# 02,07,10,15 # creates a link from node 02 to 07 with metrics 10 and 15.
int(cols[1]) if (nodea node id
> 999): print("node id must be between 0 and 999.")
# on second pass create interfaces for cols in cols list: nodea node
d   int(cols[1]) metric   int(cols[2]) reverse metric
if len(cols) > 3: reverse metric int(cols[3])
intf.area   0 nodeb intf   Interface() nodeb intf.metric
nodeb intf nodeb intf.remote intf
intf.link data   len(nodea.intf list) nodeb intf.link data   len(nodeb.intf list)
) return topo def MRT Island Identification(topo, computing rtr, profile id, area): if profile id in computing
[computing rtr] else: return while explore list !
[]: next rtr   explore list.pop() for intf in next rtr.intf list: if ( (not intf.
IN MRT ISLAND) and (not intf.
MRT INELIGIBLE) and (not intf.
IGP EXCLUDED) and intf.area   area and (profile id
in intf.remote node.profile id list))
IN MRT ISLAND   True intf.remote intf.
IN MRT ISLAND): intf.remote INTF.IN MRT ISLAND
def Compute Island Node List For Test GR(topo, test gr):
Reset Computed Node and Intf Values(topo)
gr] MRT Island Identification(topo, topo.test gr, 0, 0) for node in topo.node list:
IN MRT ISLAND: topo.island node list for test gr.append(node)
def Set Island Intf and Node Lists(topo)
: for node in topo.node list: if node.
IN MRT ISLAND: topo.island node list.append(node) for intf in node.intf list: if intf.
IN MRT ISLAND: node.island intf list.append(intf)
None def Lowpoint Visit(x, parent, intf p to x): global global dfs number x.dfs number   global dfs number x.lowpoint number
x.dfs number global dfs number    1 x.dfs parent   parent if intf p to
None else: x.dfs parent intf   intf p to x.remote intf x.lowpoint parent   None if parent !
None: parent.dfs child list.append(x) for intf in x.island intf list: if intf.remote node.dfs number
if intf.remote node.lowpoint number < x.lowpoint number:
intf.remote node.lowpoint number x.lowpoint parent
intf.remote node x.lowpoint parent intf   intf else: if intf.remote node is not parent: if intf.remote node.dfs number < x.lowpoint number: x.lowpoint number   intf.remote
intf.remote node x.lowpoint parent intf   intf def Run Lowpoint(topo): global global dfs number global dfs number   0 Lowpoint Visit(topo.gadag root,
None, None) max block i
None def Assign Block ID(x, cur block id): global max block i
id for c in x.dfs child list: if (c.localroot is x)
1 Assign Block ID(c, max block id)
else: Assign Block ID(c, cur block id) def Run Assign Block ID(topo): global max block i
Construct Ear(x, stack, intf, ear type):
[] cur intf   intf not done   True while not done: cur intf.
IN GADAG   False: cur intf.remote node.
cur intf.remote node.lowpoint parent intf else: assert ear type   'NEIGHBOR'
cur intf.remote node.dfs parent intf else: not done   False
if ear type   'CHILD' and cur intf.remote node is x:
# x is a cut vertex and the local root for the block # in which the ear is computed
: # inherit local root from the end of the ear localroot
intf.remote node.localroot while ear list !
) def Construct GADAG via Lowpoint(topo):
gadag root   topo.gadag root gadag root.
IN GADAG   True gadag root.localroot
x   stack.pop() for intf in x.island intf list: if (
IN GADAG   False and intf.remote node.dfs parent is x ):
Construct Ear(x, stack, intf, 'CHILD' ) for intf in x.island intf list:
IN GADAG   False and intf.remote node.dfs parent is not x)
: Construct Ear(x, stack, intf, 'NEIGHBOR')
def Assign Remaining Lowpoint Parents(topo)
: for node in topo.island node list: if ( node is not topo.gadag root and node.lowpoint parent
node.lowpoint parent   node.dfs parent node.lowpoint parent intf
node.dfs parent intf node.lowpoint number
parent.dfs number def Add Undirected Block Root Links(topo)
: for node in topo.island node list: if node.
IS CUT VERTEX or node is topo.gadag root: for intf in node.island intf list:
if ( intf.remote node.localroot is not node or intf.
PROCESSED ): continue bundle list
[] bundle   Bundle() for intf2 in node.island intf list: if intf2.remote node is intf.remote node
UNDIRECTED: for intf3 in bundle list:
: for intf3 in bundle list: intf3.UNDIRECTED   False intf3.remote intf.
OUTGOING: for intf3 in bundle list:
INCOMING: for intf3 in bundle list:
True def Modify Block Root Incoming Links(topo): for node in topo.island node list: if ( node.
True or node is topo.gadag root ): for intf in node.island intf list:
if intf.remote node.localroot is node: if intf.
True def Revert Block Root Incoming Links(topo): for node in topo.island node list: if ( node.
True or node is topo.gadag root ): for intf in node.island intf list:
if intf.remote node.localroot is node: if intf.
False def Run Topological Sort GADAG(topo):
Modify Block Root Incoming Links(topo) for node in topo.island node list:
node.unvisited   0 for intf in node.island intf list:
topo order list.append(y) for intf in y.island intf list:
1 if intf.remote node.unvisited   0
next topo order   1 while topo order list !
next topo order    1 Revert Block Root Incoming Links(topo)
Based On Topo Order(topo): for node in topo.island node list: for intf in node.island intf list: if intf.
UNDIRECTED: if node.topo order < intf.remote node.topo order: intf.
False def Initialize Temporary Interface Flags(topo)
: for node in topo.island node list: for intf in node.island intf list: intf.
False def Add Undirected Links(topo)
: Initialize Temporary Interface Flags(topo)
Add Undirected Block Root Links(topo)
Set Other Undirected Links Based On Topo Order(topo) def
or ( x is y.localroot) or
False def Copy List Items(target list, source list): del target list[:]
# Python idiom to remove all elements of a list for element in source list:
To List If New(target list, item): if item not in target list: target list.append(item)
next hops, y.next hops) if direction   'DECREASING':
True Copy List Items(y.red next hops, y.next hops) if direction   'NORMAL SPF':
y.spf metric Copy List Items(y.primary
next hops, y.next hops) if direction   'MRT ISLAND SPF':
Copy List Items(y.mrt island next hops, y.next hops)
y.collapsed metric   y.spf metric Copy List Items(y.collapsed
that the Python heapq function allows for duplicate items, # so we use the 'spf visited' property to only consider a node # as min node the first time it gets removed from the heap.
Root(topo, spf root, block root, direction)
[] y.spf visited   False spf
metric   0 heapq.heappush(spf heap, (spf root.spf metric, spf root.node id,  spf root) ) while spf heap !
heapq.heappop(spf heap)[2] if min node.spf visited: continue min node.spf visited   True Store Results(min
if min node is spf root:
node.next hops, min node.next hops)
heapq.heappush(spf heap, ( intf.remote node.spf metric, intf.remote node.node id, intf.remote node ) )
if min node is spf root:
intf.remote node.next hops,intf) else: for nh intf in min
def Normal SPF(topo, spf root): spf heap
[] for y in topo.node list: y.spf metric   2147483647
# 2^31 1 as max metric y.next hops
[] y.spf visited   False spf
metric   0 heapq.heappush(spf heap, (spf root.spf metric,spf root.node id,spf root) )
heapq.heappop(spf heap)[2] if min node.spf visited: continue min node.spf visited   True Store Results(min
node, 'NORMAL SPF') for intf in min node.intf list:
if min node is spf root:
node.next hops, min node.next hops)
heapq.heappush(spf heap, ( intf.remote node.spf metric, intf.remote node.node id, intf.remote node ) )
if min node is spf root:
intf.remote node.next hops,intf) else: for nh intf in min
Copy List Items(y.red next hops ,y.localroot.red next hops)
proxy def Compute MRT NH
For One Src To Island Dests(topo,
: for y in topo.island node list: y.
LOWER   False y.red next hops
for y in topo.island node list: if ( y is not
): assert (not ( y is x.localroot or x is y.localroot) ) assert(not
: Copy List Items(y.red next hops, x.localroot.red next hops)
next hops, x.localroot.blue next hops) else
next hops, x.localroot.red next hops)
Copy List Items(y.red next hops, x.localroot.blue
Inherit x's MRT next hops to reach the GADAG root # from x's MRT
next hops to reach its local root,
# but first check if x is the gadag root (in which case # x does not have a local root) or if x's local root # is the gadag root (in which case we already have the # x's MRT
next hops to reach the gadag root)
if x is not topo.gadag root and x.localroot is not topo.gadag root:
root.red next hops, x.localroot.red next hops)
x.localroot # Inherit next hops and order proxies to other blocks for y in topo.island node list:
if (y is not topo.gadag root and
y is not x ):
Edge(y) def Store MRT Nexthops
For One Src To Island Dests(topo,
x): for y in topo.island node list: if y is x: continue x.blue
[] x.red next hops dict[y.node id]
next hops dict[y.node id], y.blue
next hops dict[y.node id], y.red next hops)
def Store Primary and Alts
For One Src To Island Dests(topo,
x): for y in topo.island node list: x.pnh dict[y.node id]
For One Source To Nodes(topo,
x): for y in topo.node list: x.pnh dict[y.node id]
For One Src To Named Proxy Nodes(topo,
: for prefix in topo.named proxy dict:
P   topo.named proxy dict[prefix] x.blue
[] x.red next hops dict[P.node id]
next hops dict[P.node id], P.blue next hops)
Copy List Items(x.red next hops dict[P.node id], P.red next hops)
: for prefix in topo.named proxy dict:
, P.alt list) def Store Primary NHs
For One Src To Named Proxy Nodes(topo,
: for prefix in topo.named proxy dict:
P   topo.named proxy dict[prefix] x.pnh
[] Copy List Items(x.pnh dict[P.node id], P.primary next hops)
def Select Alternates Internal(D, F, primary intf,
D lower, D higher, D topo order):
if D higher and D lower: if F.HIGHER and F.LOWER:
if F.topo order > D topo order: return 'USE BLUE' else: return 'USE RED' if F.HIGHER:
return 'USE RED' if F.LOWER: return 'USE BLUE' assert(primary intf.
MRT INELIGIBLE or primary intf.remote intf.
MRT INELIGIBLE) return 'USE RED OR BLUE'
if D higher: if F.HIGHER and F.LOWER: return 'USE BLUE' if F.LOWER:
return 'USE BLUE' if F.HIGHER:
if (F.topo order > D topo order): return 'USE BLUE'
if (F.topo order < D topo order): return 'USE RED' assert(False) assert(primary intf.
MRT INELIGIBLE or primary intf.remote intf.
MRT INELIGIBLE) return 'USE RED OR BLUE'
if D lower: if F.HIGHER and F.LOWER: return 'USE RED' if F.HIGHER:
return 'USE RED' if F.LOWER:
if F.topo order > D topo order: return 'USE BLUE' if F.topo order <
D topo order: return 'USE RED' assert(False)
MRT INELIGIBLE or primary intf.remote intf.
MRT INELIGIBLE) return 'USE RED OR BLUE' else:
# D is unordered wrt S if F.HIGHER and F.LOWER:
# This can happen when F and D are in different blocks return 'USE RED OR BLUE' if primary intf.
OUTGOING: return 'USE BLUE' if primary intf.
USE RED' #This can occur when primary intf is MRT INELIGIBLE.
#This appears to be a case where the special #construction of the GADAG allows us to choose red, #whereas with an arbitrary GADAG, neither red nor blue #is guaranteed to work.
MRT INELIGIBLE or primary intf.remote intf.
MRT INELIGIBLE) return 'USE RED'
if F.LOWER: return 'USE RED' if F.HIGHER:
return 'USE BLUE' assert(primary intf.
MRT INELIGIBLE or primary intf.remote intf.
> D topo order: return 'USE BLUE' else:
return 'USE RED' def Select Alternates(D, F, primary intf):
if not In Common Block(F, S)
: return 'PRIM NH IN DIFFERENT BLOCK' if (D is F) or (D.order proxy is F)
: return 'PRIM NH IS D OR OP FOR D' D lower   D.order proxy.
LOWER D higher   D.order proxy.
proxy.topo order return Select Alternates Internal(D, F, primary intf,
D lower, D higher, D topo order)
List(node, intf list): for intf in intf list: if node is intf.remote node: return
For One Src To Island Dests(topo,
): Normal SPF(topo, x) for D in topo.island node list: D.alt list
[] if D is x: continue for failed intf in D.primary next hops: alt   Alternate()
node #We need to test if F is in the island, as opposed #to just testing if failed intf is in island intf list, #because failed intf could be marked as MRT INELIGIBLE.
if F in topo.island node list:
alt.info   Select Alternates(D, F, failed intf) else:
#The primary next hop is not in the MRT Island.
Either red or blue will avoid the primary next hop, #because the primary next hop is not even in the #GADAG.
if (alt.info   'USE RED OR BLUE'): alt.red or blue   random.choice(['USE RED','USE BLUE'])
if (alt.info   'USE BLUE' or alt.red or blue   '
: Copy List Items(alt.nh list, D.blue next hops)
'NODE PROTECTION' if (alt.info   'USE RED' or alt.red or blue   'USE RED')
: Copy List Items(alt.nh list, D.red next hops)
if (alt.info   'PRIM NH IN DIFFERENT BLOCK')
: alt.fec   'NO ALTERNATE' alt.prot
'NO PROTECTION' if (alt.info   'PRIM NH IS D OR OP FOR D'): if failed intf.
# cut link: if there are parallel cut links, use # the link(s) with lowest metric that are not # primary intf or None cand alt list
[None] min metric   2147483647 for intf in x.island intf list: if ( intf is not failed intf and (intf.remote node is failed intf.remote node)): if intf.metric < min metric: cand alt list   [intf] min metric
if cand alt list !
'PARALLEL CUTLINK' else: alt.fec   'NO ALTERNATE'
'NO PROTECTION' Copy List Items(alt.nh list, cand alt list)
In NH List() is used, as opposed # to just checking if failed intf is in D.red next hops, # because failed intf could be marked as MRT INELIGIBLE.
In NH List(F, D.red next hops)
: Copy List Items(alt.nh list, D.blue next hops)
'LINK PROTECTION' elif Is Remote Node
In NH List(F, D.blue next hops)
Copy List Items(alt.nh list, D.red next hops)
'LINK PROTECTION' D.alt list.append(alt) def
for intf in node.intf list: if intf.
To File(topo, color, file prefix):
next hops dict elif color   'red':
next hops dict for dest node
in node next hops dict:
for intf in node next hops dict[dest node
: Write MRTs For All Dests To File(topo, 'blue', file prefix) Write MRTs For All Dests
def Write Alternates For All Dests
id] for alt in alt list: for alt intf in alt.nh list:
255 def Lower GADAG Root Selection Priority(topo,node id)
GADAG Root Compare(node a, node b):
: return 1 elif (node a.
GR sel priority < node b.
: return  1 else: if node
id: return 1 elif node
Set GADAG Root(topo,computing router): gadag root list
[] for node in topo.island node list: gadag root list.append(node)
gadag root list.sort(GADAG Root Compare)
topo.gadag root   gadag root list.pop() def Add Prefix Advertisements
[] if not os.path.exists(prefix filename)
: return with open(prefix filename) as prefix file: for line in prefix file: line   line.rstrip('\r\n')
]) if prefix id < 2000 or prefix id
print('skipping the following line of prefix file')
print('prefix id should be between 2000 and 2999')
Add Prefixes for Non Island Nodes(topo)
: for node in topo.node list: if node.
IN MRT ISLAND: continue prefix i
def Add Profile IDs from File(topo, filename)
else: for node in topo.node list:
[] y.spf visited   False spf
[] heapq.heappush(spf heap, (spf root.spf metric,spf root.node id,spf root) )
heapq.heappop(spf heap)[2] if min node.spf visited: continue min node.spf visited
min node.spf metric, min node.
PATH HITS ISLAND) for intf in min node.intf list:
if min node is spf root:
node.next hops, min node.next hops)
IN MRT ISLAND): intf.remote node.
PATH HITS ISLAND heapq.heappush(spf heap, ( intf.remote node.spf metric, intf.remote node.node id, intf.remote node ) )
if min node is spf root:
intf.remote node.next hops,intf) else: for nh intf in min
IN MRT ISLAND): intf.remote node.
PATH HITS ISLAND or min node.
True def Create Basic Named Proxy Nodes(topo)
: for node in topo.node list: for prefix in node.prefix cost dict: prefix cost
node.prefix cost dict[prefix] if prefix in topo.named proxy dict: P   topo.named proxy dict[prefix]
P.node prefix cost list.append((node,prefix cost))
else: P   Named Proxy Node() topo.named proxy dict[prefix]
P P.node id   prefix P.node prefix cost list
def Compute Loop Free Island Neighbors For Each Prefix(topo):
topo.island border set   set() for node in topo.node list:
IN MRT ISLAND: continue for intf in node.intf list: if intf.remote node.
topo.island border set.add(intf.remote node) for island nbr in topo.island nbr set:
2147483647 for (adv node, prefix cost) in P.node prefix cost list: (
adv node cost, path hits island)
id] isl nbr to pref cost
adv node cost   prefix cost if isl nbr to pref cost < min isl nbr to pref cost: min isl nbr to pref cost   isl nbr to pref cost min path hits island
path hits island elif isl nbr to pref cost
min isl nbr to pref cost: if min path hits island or path hits island: min path hits island
True if not min path hits island:
P.lfin list.append( (island nbr, min isl nbr to pref cost) )
def Compute Island Border Router LFIN Pairs For Each Prefix(topo): for ibr in topo.island border set:
: if not intf.remote node in topo.island nbr set: continue if not intf.remote node
in ibr.min intf metric dict:
ibr.min intf metric dict[intf.remote node]
intf.metric ibr.min intf list dict[intf.remote node]
[intf] else: if (intf.metric < ibr.min intf metric dict[intf.remote node]): ibr.min intf metric dict[intf.remote node]
intf.metric ibr.min intf list dict[intf.remote node]
[intf] elif (intf.metric < ibr.min intf metric dict[intf.remote node]): ibr.min intf list dict[intf.remote node].\ append(intf) for prefix in topo.named proxy dict: P   topo.named proxy dict[prefix] for ibr in topo.island border set: min ibr lfin pref cost   2147483647 min lfin
None for (lfin, lfin to pref cost) in P.lfin list: if not lfin in ibr.min
continue ibr lfin pref cost
lfin to pref cost if ibr lfin pref cost < min ibr lfin pref cost: min ibr lfin pref cost   ibr lfin pref cost min lfin   lfin
def Proxy Node Att Router Compare(pnar
if pnar a.named proxy cost < pnar b.named proxy cost: return  1
if pnar b.named proxy cost < pnar a.named proxy cost: return 1 if pnar
id: return  1 if pnar
: return 1 if pnar a.min lfin
IN MRT ISLAND: continue pnar   Proxy Node Attachment Router()
pnar.prefix   prefix pnar.named proxy cost   prefix cost
node pnar candidate list.append(pnar) for ibr in topo.island border set: (min lfin, prefix cost, min intf list)
if min lfin   None: continue pnar   Proxy Node Attachment Router()
pnar.named proxy cost   prefix cost
min lfin pnar.nh intf list
min intf list pnar candidate list.append(pnar) pnar candidate list.sort(cmp Proxy Node Att Router Compare)
#pop first element from list first pnar   pnar candidate list.pop(0)
None for next pnar in pnar candidate list: if next pnar.node is first pnar.node: continue second pnar   next pnar break P.pnar1
Attach Named Proxy Nodes(topo): Compute Loop Free Island Neighbors For Each Prefix(topo)
Compute Island Border Router LFIN Pairs For Each Prefix(topo)
Choose Proxy Node Attachment Routers(topo)
Y A   X.order proxy B
if (A is S.localroot and B is S.localroot):
Copy List Items(P.blue next hops, X.blue next hops)
next hops, Y.red next hops)
return if (A is S.localroot and B is not S.localroot):
Copy List Items(P.blue next hops, X.blue next hops)
next hops, Y.red next hops) return if B.HIGHER:
Copy List Items(P.blue next hops, X.red next hops)
next hops, Y.blue next hops) return else: #print("2.3")
Copy List Items(P.blue next hops, X.red next hops)
next hops, Y.red next hops)
return if (A is not S.localroot and B is S.localroot):
Copy List Items(P.blue next hops, X.red next hops)
next hops, Y.blue next hops) return if A.HIGHER:
Copy List Items(P.blue next hops, X.blue next hops)
next hops, Y.red next hops) return else: #print("3.3")
Copy List Items(P.blue next hops, X.red next hops)
next hops, Y.red next hops)
return if (A is not S.localroot and B
#print("4.0") if (S is A.localroot or S is B.localroot):
#print("4.05") if A.topo order < B.topo order:
Copy List Items(P.blue next hops, X.blue next hops)
next hops, Y.red next hops) return else: #print("4.05.2")
Copy List Items(P.blue next hops, X.red next hops)
next hops, Y.blue next hops) return if A.LOWER:
Copy List Items(P.blue next hops, X.red next hops)
next hops, Y.blue next hops) return if B.LOWER: #print("4.1.2") if A.topo order < B.topo order:
Copy List Items(P.blue next hops, X.blue next hops)
next hops, Y.red next hops) return else: #print("4.1.2.2")
Copy List Items(P.blue next hops, X.red next hops)
next hops, Y.blue next hops) return else: #print("4.1.3")
Copy List Items(P.blue next hops, X.red next hops)
next hops, Y.red next hops) return if A.HIGHER:
#print("4.2.1") if A.topo order < B.topo order: #print("4.2.1.1")
Copy List Items(P.blue next hops, X.blue next hops)
next hops, Y.red next hops) return else: #print("4.2.1.2")
Copy List Items(P.blue next hops, X.red next hops)
next hops, Y.blue next hops) return if B.LOWER: #print("4.2.2")
Copy List Items(P.blue next hops, X.blue next hops)
next hops, Y.red next hops) return else:
Copy List Items(P.blue next hops, X.blue next hops)
next hops, Y.blue next hops) return else: #print("4.3") if B.LOWER: #print("4.3.1")
Copy List Items(P.blue next hops, X.red next hops)
next hops, Y.red next hops) return if B.HIGHER:
Copy List Items(P.blue next hops, X.blue next hops)
next hops, Y.blue next hops) return else:
#print("4.3.3") if A.topo order < B.topo order: #print("4.3.3.1")
Copy List Items(P.blue next hops, X.blue next hops)
next hops, Y.red next hops) return else: #print("4.3.3.2")
Copy List Items(P.blue next hops, X.red next hops)
next hops, Y.blue next hops)
For One Src To Named Proxy Nodes(topo,S):
for prefix in topo.named proxy dict:
P   topo.named proxy dict[prefix] if P.pnar2
None: if S is P.pnar1.node: # set the MRT next hops for the PNAR to # reach the LFIN and change FEC to green Copy List Items(P.blue
next hops, P.pnar1.nh intf list)
next hops, P.pnar1.nh intf list) S.red to green nh
True else: # inherit MRT NHs for P from
else: Select Proxy Node NHs(P,S)
# set the MRT next hops for the PNAR to reach the LFIN # and change FEC to green
rely on the red or blue #
next hops being empty to figure out which one needs # to point to the LFIN.
if S is P.pnar1.node: this pnar
next hops, this pnar.nh intf list)
True if P.red next hops
next hops, this pnar.nh intf list) S.red to green nh
Select Alternates Proxy Node(P,F,primary intf):
Y A   X.order proxy B
Y.order proxy if F is A and F is B
: return 'PRIM NH IS OP FOR BOTH X AND Y'
: return 'USE RED' if F is B: return 'USE BLUE' if not In Common Block(A, B): if In Common Block(F, A): return 'USE RED' elif
In Common Block(F, B): return 'USE BLUE' else
: return 'USE RED OR BLUE' if (not In Common Block(F, A) and not In Common Block(F, A)
return 'USE RED OR BLUE' alt to X   Select Alternates(X, F, primary intf) alt to Y   Select Alternates(Y, F, primary intf)
if (alt to X   'USE RED OR BLUE' and alt to Y   'USE RED OR BLUE')
: return 'USE RED OR BLUE' if alt to X   'USE RED OR BLUE': return 'USE BLUE' if alt to Y   'USE RED OR BLUE': return 'USE RED' if (A is S.localroot and B is S.localroot):
#print("1.0") if (alt to X   'USE BLUE' and alt to Y   'USE RED'): return 'USE RED OR BLUE' if alt to X   'USE BLUE': return 'USE BLUE' if alt to Y   'USE RED': return 'USE RED' assert(False) if (A is S.localroot and B is not S.localroot): #print("2.0")
if B.LOWER: #print("2.1") if (alt to X   'USE BLUE' and alt to Y   'USE RED')
: return 'USE RED OR BLUE' if alt to X   'USE BLUE': return 'USE BLUE' if alt to Y   'USE RED': return 'USE RED' assert(False) if B.HIGHER:
#print("2.2") if (alt to X   'USE RED' and alt to Y   'USE BLUE'): return 'USE RED OR BLUE' if alt to X   'USE RED': return 'USE BLUE' if alt to Y   'USE BLUE'
: return 'USE RED' assert(False) else: #print("2.3") if (alt to X   'USE RED' and alt to Y   'USE RED'): return 'USE RED OR BLUE' if alt to X   'USE RED': return 'USE BLUE' if alt to Y   'USE RED': return 'USE RED' assert(False) if (A is not S.localroot and B is S.localroot):
#print("3.1") if (alt to X   'USE RED' and alt to Y   'USE BLUE'): return 'USE RED OR BLUE' if alt to X   'USE RED': return 'USE BLUE' if alt to Y   'USE BLUE': return 'USE RED' assert(False) if A.HIGHER:
#print("3.2") if (alt to X   'USE BLUE' and alt to Y   'USE RED'): return 'USE RED OR BLUE' if alt to X   'USE BLUE': return 'USE BLUE' if alt to Y   'USE RED': return 'USE RED' assert(False) else: #print("3.3") if (alt to X   'USE RED' and alt to Y   'USE RED'): return 'USE RED OR BLUE' if alt to X   'USE RED': return 'USE BLUE' if alt to Y   'USE RED': return 'USE RED' assert(False)
if (A is not S.localroot and B is not S.localroot):
#print("4.0") if (S is A.localroot or S is B.localroot):
#print("4.05") if A.topo order < B.topo order:
#print("4.05.1") if (alt to X   'USE BLUE' and alt to Y   'USE RED'): return 'USE RED OR BLUE' if alt to X   'USE BLUE': return 'USE BLUE' if alt to Y   'USE RED': return 'USE RED' assert(False) else: #print("4.05.2") if (alt to X   'USE RED' and alt to Y   'USE BLUE'): return 'USE RED OR BLUE' if alt to X   'USE RED': return 'USE BLUE' if alt to Y   'USE BLUE': return 'USE RED' assert(False) if A.LOWER: #print("4.1") if B.HIGHER: #print("4.1.1") if (alt to X   'USE RED' and alt to Y   'USE BLUE'): return 'USE RED OR BLUE' if alt to X   'USE RED': return 'USE BLUE' if alt to Y   'USE BLUE': return 'USE RED' assert(False)
#print("4.1.2") if A.topo order < B.topo order:
#print("4.1.2.1") if (alt to X   'USE BLUE' and alt to Y   'USE RED'): return 'USE RED OR BLUE' if alt to X   'USE BLUE': return 'USE BLUE' if alt to Y   'USE RED': return 'USE RED' assert(False) else: #print("4.1.2.2") if (alt to X   'USE RED' and alt to Y   'USE BLUE'): return 'USE RED OR BLUE' if alt to X   'USE RED': return 'USE BLUE' if alt to Y   'USE BLUE':
return 'USE RED' assert(False) else: #print("4.1.3") if (F.LOWER and not F.HIGHER and F.topo
#print("4.1.3.1") return 'USE RED' else: #print("4.1.3.2") return 'USE BLUE'
#print("4.2.1") if A.topo order < B.topo order: #print("4.2.1.1") if (alt to X   'USE BLUE' and alt to Y   'USE RED')
: return 'USE RED OR BLUE' if alt to X   'USE BLUE': return 'USE BLUE' if alt to Y   'USE RED': return 'USE RED' assert(False) else: #print("4.2.1.2") if (alt to X   'USE RED' and alt to Y   'USE BLUE'): return 'USE RED OR BLUE' if alt to X   'USE RED': return 'USE BLUE' if alt to Y   'USE BLUE': return 'USE RED' assert(False)
if B.LOWER: #print("4.2.2") if (alt to X   'USE BLUE' and alt to Y   'USE RED')
: return 'USE RED OR BLUE' if alt to X   'USE BLUE': return 'USE BLUE' if alt to Y   'USE RED': return 'USE RED' assert(False) else: #print("4.2.3") if (F.HIGHER and not F.LOWER and F.topo
order < A.topo order): return 'USE RED' else: return 'USE BLUE' else: #print("4.3")
if B.LOWER: #print("4.3.1") if (F.LOWER and not F.HIGHER and F.topo
order > B.topo order): return 'USE BLUE' else
: return 'USE RED' if B.HIGHER:
#print("4.3.2") if (F.HIGHER and not F.LOWER and F.topo order < B.topo order)
: return 'USE BLUE' else: return 'USE RED' else:
#print("4.3.3") if A.topo order < B.topo order: #print("4.3.3.1") if (alt to X   'USE BLUE' and alt to Y   'USE RED')
: return 'USE RED OR BLUE' if alt to X   'USE BLUE': return 'USE BLUE' if alt to Y   'USE RED': return 'USE RED' assert(False) else: #print("4.3.3.2") if (alt to X   'USE RED' and alt to Y   'USE BLUE'): return 'USE RED OR BLUE' if alt to X   'USE RED': return 'USE BLUE' if alt to Y   'USE BLUE': return 'USE RED' assert(False) assert(False)
For One Src To Named Proxy Nodes(topo,src): for prefix in topo.named proxy dict
: P   topo.named proxy dict[prefix] min total pref cost   2147483647 for (adv node, prefix cost) in P.node prefix cost list:
total pref cost   (adv node.primary spf metric   prefix cost)
if total pref cost < min total pref cost:
min total pref cost   total pref cost Copy List Items(P.primary
next hops, adv node.primary next hops)
min total pref cost: for nh intf in adv node.primary
If New(P.primary next hops, nh intf) def Select Alts
alt.failed intf   failed intf if failed intf not in src.island intf list:
alt.info   'PRIM NH FOR PROXY NODE
IN ISLAND' elif P.pnar1 is None:
alt.info   'NO PNARs EXIST FOR THIS PREFIX' elif src is P.pnar1.node:
PNAR' elif P.pnar2 is not None and src
PNAR' elif P.pnar2 is None: #inherit alternates from the only pnar.
Select Alternates(P.pnar1.node, failed intf.remote node, failed intf)
elif failed intf in src.island intf list:
alt.info   Select Alternates Proxy Node(P, failed intf.remote node, failed intf)
if alt.info   'USE RED OR BLUE':
if (alt.info   'USE BLUE' or alt.red or blue   '
: Copy List Items(alt.nh list, P.blue next hops)
'NODE PROTECTION' elif (alt.info   'USE RED' or alt.red or blue   '
: Copy List Items(alt.nh list, P.red next hops)
'NODE PROTECTION' elif (alt.info   'PRIM NH IS D OR OP FOR D' or
alt.info   'PRIM NH IS OP FOR BOTH X AND Y'): if failed intf.
# cut link: if there are parallel cut links, use # the link(s) with lowest metric that are not # primary intf or None cand alt list
[None] min metric   2147483647 for intf in src.island intf list: if ( intf is not failed intf and (intf.remote node is failed intf.remote node)): if intf.metric < min metric: cand alt list   [intf] min metric
if cand alt list !
'PARALLEL CUTLINK' else: alt.fec   'NO ALTERNATE'
'NO PROTECTION' Copy List Items(alt.nh list, cand alt list) else: # set Z as the node to inherit blue next hops from if alt.info   'PRIM NH IS D OR OP FOR D':
Z   P.pnar1.node else: Z   P if failed intf in Z.red next hops: Copy List Items(alt.nh list, Z.blue next hops)
'LINK PROTECTION' else: assert(failed intf in Z.blue next hops)
Copy List Items(alt.nh list, Z.red next hops)
'LINK PROTECTION' elif alt.info   'PRIM NH FOR PROXY NODE
None and src is P.pnar1.node):
#MRT Island is singly connected to non island dest alt.fec   'NO ALTERNATE'
'NO PROTECTION' elif P.node id in src.blue to green
# blue to P goes to failed LFIN so use red to
P Copy List Items(alt.nh list, P.red next hops)
'LINK PROTECTION' elif P.node id in src.red
# red to P goes to failed LFIN so use blue to
P Copy List Items(alt.nh list, P.blue next hops)
Copy List Items(alt.nh list, P.blue next hops)
LINK PROTECTION' elif alt.info   'TEMP NO ALTERNATE':
def Run Basic MRT for One Source(topo, src):
MRT Island Identification(topo, src, 0, 0)
Set Island Intf and Node Lists(topo)
For One Src To Island Dests(topo,src)
Store MRT Nexthops For One Src
For One Src To Island Dests(topo,src)
For One Src To Island Dests(topo,src)
def Store GADAG and Named Proxies
: for node in topo.node list: for intf in node.intf list: if intf.
SIMULATION OUTGOING   False for prefix in topo.named proxy dict:
P   topo.named proxy dict[prefix] topo.stored named proxy dict[prefix]
P def Run Basic MRT for All Sources(topo): for src in topo.node list: Reset Computed Node and Intf Values(topo)
Run Basic MRT for One Source(topo,src)
if src is topo.gadag root:
Store GADAG and Named Proxies Once(topo)
def Run MRT for One Source(topo, src):
MRT Island Identification(topo, src, 0, 0)
Set Island Intf and Node Lists(topo)
For One Src To Island Dests(topo,src)
Store MRT Nexthops For One Src
For One Src To Island Dests(topo,src)
For One Src To Island Dests(topo,src)
Create Basic Named Proxy Nodes(topo)
For One Src To Named Proxy Nodes(topo,src)
For One Src To Named Proxy Nodes(topo,src)
For One Src To Named Proxy Nodes(topo,src)
For One Src To Named Proxy Nodes(topo,src)
def Run Prim SPF for One Source(topo,src):
For One Source To Nodes(topo,src)
Create Basic Named Proxy Nodes(topo)
For One Src To Named Proxy Nodes(topo,src)
For One Src To Named Proxy Nodes(topo,src)
Run MRT for All Sources(topo): for src in topo.node list: Reset Computed Node and Intf Values(topo)
if src in topo.island node list for test gr:
# src runs MRT if it is in same MRT island as test gr Run MRT for One Source(topo,src)
if src is topo.gadag root:
Store GADAG and Named Proxies Once(topo) else:
# src still runs SPF if not in MRT island Run Prim SPF for One Source(topo,src)
Write Output To Files(topo,file prefix)
To File(topo,file prefix) Write Both MRTs For All Dests To File(topo,file prefix)
Write Alternates For All Dests
def Create Basic Topology Input
) def Generate Basic Topology and Run MRT
(): this gadag root   3 Create Basic Topology Input File('basic topo input')
Create Topology From File('basic topo input')
res file base   'basic topo' Compute Island Node List For Test GR(topo, this gadag root) Raise GADAG Root Selection Priority(topo,this gadag root)
Run Basic MRT for All Sources(topo)
Write Output To Files(topo, res file base)
def Generate Complex Topology and Run MRT
(): this gadag root   3 Create Complex Topology Input File('complex topo input')
Create Topology From File('complex topo input')
Add Profile IDs from File(topo,'complex topo input')
Compute Island Node List For Test GR(topo, this gadag root)
Add Prefixes for Non Island Nodes(topo)
'complex topo' Raise GADAG Root Selection Priority(topo,this gadag root)
Run MRT for All Sources(topo)
Write Output To Files(topo, res file base)
Generate Basic Topology and Run MRT
() Generate Complex Topology and Run MRT() <
Constructing a GADAG Using SPFs
The basic idea in this method for constructing a GADAG is to use slightly modified SPF computations to find ears.
In every block, an SPF computation is first done to find a cycle from the local root and then SPF computations in that block find ears until there are no more interfaces to be explored.
The used result from the SPF computation is the path of interfaces indicated by following the previous hops from the minimized IN GADAG node back to the SPF root.
To do this, first all cut vertices must be identified and localroots assigned as specified in Figure 12.
The slight modifications to the SPF are as follows.
The root of the block is referred to as the block root; it is either the GADAG root or a cut vertex.
The SPF is rooted at a neighbor
x of an IN GADAG node
All links between y and x are marked as TEMP UNUSABLE.
They should not be used during the SPF computation.
If y is not the block root, then it is marked TEMP UNUSABLE.
It should not be used during the SPF computation.
This prevents ears from starting and ending at the same node and avoids cycles; the exception is because cycles to/from the block root are acceptable and expected.
Do not explore links to nodes whose localroot is not the block  root.
This keeps the SPF confined to the particular block.
Terminate when the first IN GADAG node z is minimized.
the existing directions (e.g., INCOMING, OUTGOING, UNDIRECTED) already specified for each interface.
Mod SPF(spf root, block root)
Initialize spf heap to empty Initialize nodes' spf metric to infinity
insert(spf heap, spf root) found in gadag
(spf heap is not empty) and (found in gadag is false)
IN GADAG found in gadag   true else foreach interface intf of min node if ((intf.
and ((intf.remote node.localroot is block root) or (intf.remote node is block root)) and
(intf.remote node is not TEMP UNUSABLE) and (intf is not TEMP UNUSABLE))
intf.remote node.spf metric intf.remote node.spf
metric   path metric intf.remote node.spf prev intf
intf insert or update(spf heap, intf.remote node)
return min node SPF for Ear(cand
intf.local node,cand intf.remote node, block root, method)
Mark all interfaces between cand intf.remote node and cand
intf.local node as TEMP UNUSABLE if cand
intf.local node is not block root Mark cand
intf.local node as TEMP UNUSABLE Initialize
ear list to empty end
Mod SPF(spf root, block root)
y   end ear.spf prev hop
while y.local node is not spf root add to list start(ear
node.spf prev intf if(method is not hybrid)
Clear TEMP UNUSABLE from all interfaces between cand intf.remote node and cand
Clear TEMP UNUSABLE from cand
Modified SPF for GADAG Construction Assume that an ear is found by going from y to x and then running an SPF that terminates by minimizing z (e.g., y
Now it is necessary to determine the direction of the ear; if y<<z, then the path should be y x...
but if y>>z, then the path should be y
In Section 5.5, the same problem was handled by finding all ears that started at a node before looking at ears starting at nodes higher in the partial order.
In this GADAG construction method, using that approach could mean that new ears aren't added in order of their total cost since all ears connected to a node would need to be found before additional nodes could be found.
The alternative is to track the order relationship of each node with respect to every other node.
This can be accomplished by maintaining two sets of nodes at each node.
The first set, Higher Nodes, contains all nodes that are known to be ordered above the node.
The second set, Lower Nodes, contains all nodes that are known to be ordered below the node.
This is the approach used in this GADAG construction method.
Set Ear Direction(ear list, end a, end b, block root) //
Default of A TO B for the following cases: //
(a) end a and end b are the same (root) //
a is in end b's Lower Nodes // or (c) end a and end b were unordered with respect to each //
if (end b is block root) and (end a is not end b
if end a is in end b.
if direction is B TO A foreach interface
i in ear list i.
true else foreach interface i in ear
is end b return //
Next, update all nodes' Lower Nodes and Higher Nodes
if (end a is in end b.
x where x.localroot is block root if end
Lower Nodes foreach interface i in
if end b is in x.
Higher Nodes foreach interface i in ear list add i.local node to x.
x where x.localroot is block root if end b is in x.
Lower Nodes foreach interface i in ear list add i.local node to x.
Lower Nodes if end a is in x.
Higher Nodes foreach interface i in
Algorithm to Assign Links of an Ear Direction A goal of this GADAG construction method is to find the shortest cycles and ears.
An ear is started by going to a neighbor
x of an IN GADAG node
The path from x to an IN GADAG node is minimal, since it is computed via SPF.
Since a shortest path is made of shortest paths, to find the shortest ears requires reaching from the set of IN GADAG nodes to the closest node that isn't IN GADAG.
Therefore, an ordered tree is maintained of interfaces that could be explored from the IN GADAG nodes.
The interfaces are ordered by their characteristics of metric, local loopback address, remote loopback address, and ifindex, based on the Interface Compare function defined in Figure 14.
This GADAG construction method ignores interfaces picked from the ordered list that belong to the block root if the block in which the interface is present already has an ear that has been computed.
This is necessary since we allow at most one incoming interface to a block root in each block.
This requirement stems from the way next hops are computed as was seen in Section 5.7.
After any ear gets computed, we traverse the newly added nodes to the GADAG and insert interfaces whose far end is not yet on the GADAG to the ordered tree for later processing.
Finally, cut links are a special case because there is no point in doing an SPF on a block of two nodes.
The algorithm identifies cut  links simply as links where both ends of the link are cut vertices.
Cut links can simply be added to the GADAG with both OUTGOING and INCOMING specified on their interfaces.
add eligible interfaces of node(ordered intfs tree,node) for each interface of node if intf.remote node.
IN GADAG is false insert(intf
if block has ear(x,block id) block has ear   false for all interfaces of x if
IN GADAG ) block has ear
true return block has ear
Construct GADAG via SPF(topology, root) Compute Localroot (root,root)
IN GADAG   true add eligible interfaces of node(ordered intfs tree,root) while ordered intfs tree is not empty cand intf
IN GADAG is false if L(cand intf.remote node)
Special case for cut links cand intf.
UNDIRECTED   false cand intf.remote intf.
INCOMING   true cand intf.remote intf.
OUTGOING   true cand intf.remote intf.
IN GADAG   true add eligible interfaces of node( ordered intfs tree,cand intf.remote node) else
if (cand intf.remote node.local root   cand intf.local node)
&& check if block has ear(cand
intf.local node, cand intf.remote node.block id)) /
Skip the interface since the block root already has an incoming interface in the block  /
else ear end   SPF for Ear(cand
intf.local node, cand intf.remote node, cand
y   ear end.spf prev hop while y.local node is not cand
intf.local node add eligible interfaces of node
( ordered intfs tree, y.local node)
node.spf prev intf Figure 33:
SPF Based Method for GADAG Construction Appendix C.  Constructing a GADAG Using a Hybrid Method
The idea of this method is to combine the salient features of the lowpoint inheritance and SPF methods.
To this end, we process nodes as they get added to the GADAG just like in the lowpoint inheritance by maintaining a stack of nodes.
This ensures that we do not need to maintain lower and higher sets at each node to ascertain ear directions since the ears will always be directed from the node being processed towards the end of the ear.
To compute the ear however, we resort to an SPF to have the possibility of better ears (path lengths) thus giving more flexibility than the restricted use of lowpoint/dfs parents.
Regarding ears involving a block root, unlike the SPF method, which ignored interfaces of the block root after the first ear, in the hybrid method we would have to process all interfaces of the block root before moving on to other nodes in the block since the direction of an ear is predetermined.
Thus, whenever the block already has an ear computed, and we are processing an interface of the block root, we mark the block root as unusable before the SPF run that computes the ear.
This ensures that the SPF terminates at some node other than the block root.
This in turn guarantees that the block root has only one incoming interface in each block, which is necessary for correctly computing the next hops on the GADAG.
As in the SPF GADAG, bridge ears are handled as a special case.
The entire algorithm is shown below in Figure 34.
find spf stack ear(stack, x
, y, xy intf, block root)
Special case for cut links xy intf.
UNDIRECTED   false xy intf.remote intf.
ear   SPF for Ear(x,y,block root,hybrid)
If x was set as TEMP UNUSABLE, clear it
true push prev onto stack
UNDIRECTED   false xy intf.remote intf.
true return Construct GADAG via hybrid(topology,root)
IN GADAG   true Initialize Stack to empty push root onto Stack while (Stack is not empty)
x   pop(Stack) for each interface intf of x y
IN GADAG is false find spf stack ear(stack, x, y, intf, y.block root)
