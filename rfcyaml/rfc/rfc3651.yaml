- title: __initial_text__
  contents:
  - '            Handle System Namespace and Service Definition

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2003).  All Rights Reserved.\n"
- title: IESG Note
  contents:
  - "IESG Note\n   Several groups within the IETF and IRTF have discussed the Handle\n\
    \   System and it relationship to existing systems of identifiers.  The\n   IESG\
    \ wishes to point out that these discussions have not resulted in\n   IETF consensus\
    \ on the described Handle System nor on how it might fit\n   into the IETF architecture\
    \ for identifiers.  Though there has been\n   discussion of handles as a form\
    \ of URI, specifically as a URN, these\n   documents describe an alternate view\
    \ of how namespaces and\n   identifiers might work on the Internet and include\
    \ characterizations\n   of existing systems which may not match the IETF consensus\
    \ view.\n"
- title: Abstract
  contents:
  - "Abstract\n   The Handle System is a general-purpose global name service that\n\
    \   allows secured name resolution and administration over the public\n   Internet.\
    \  This document provides a detailed description of the\n   Handle System namespace,\
    \ and its data, service, and operation models.\n   The namespace definition specifies\
    \ the handle syntax and its semantic\n   structure.  The data model defines the\
    \ data structures used by the\n   Handle System protocol and any pre-defined data\
    \ types for carrying\n   out the handle service.  The service model provides definitions\
    \ of\n   various Handle System components and explains how they work together\n\
    \   over the network.  Finally, the Handle System operation model\n   describes\
    \ its service operation in terms of messages transmitted\n   between client and\
    \ server, and the client authentication process\n   based on the Handle System\
    \ authentication protocol.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  2\n   2.  Handle System Namespace. . . . . . . . . . . . . . .\
    \ . . . . .  3\n   3.  Handle System Data Model . . . . . . . . . . . . . . .\
    \ . . . .  4\n       3.1.  Handle Value Set . . . . . . . . . . . . . . . . .\
    \ . . .  4\n       3.2.  Pre-defined Handle Data Types. . . . . . . . . . . .\
    \ . .  9\n             3.2.1.  Handle Administrator: HS_ADMIN . . . . . . . .\
    \ . 10\n             3.2.2.  Service Site Information: HS_SITE. . . . . . . .\
    \ 14\n             3.2.3.  Naming Authority Delegation Service:\n            \
    \         HS_NA_DELEGATE . . . . . . . . . . . . . . . . . 19\n             3.2.4.\
    \  Service Handle: HS_SERV. . . . . . . . . . . . . 20\n             3.2.5.  Alias\
    \ Handle: HS_ALIAS . . . . . . . . . . . . . 21\n             3.2.6.  Primary\
    \ Site: HS_PRIMARY . . . . . . . . . . . . 21\n             3.2.7.  Handle Value\
    \ List: HS_VLIST. . . . . . . . . . . 22\n   4.  Handle System Service Model.\
    \ . . . . . . . . . . . . . . . . . 22\n       4.1.  Handle System Service Components\
    \ . . . . . . . . . . . . 23\n             4.1.1.  Global Handle Registry (GHR)\
    \ . . . . . . . . . . 23\n             4.1.2.  Local Handle Service (LHS) . .\
    \ . . . . . . . . . 26\n       4.2.  Handle System Middle-Ware Components . .\
    \ . . . . . . . . 27\n             4.2.1.  Handle System Caching Service. . .\
    \ . . . . . . . 27\n             4.2.2.  Handle System Proxy Server . . . . .\
    \ . . . . . . 28\n       4.3.  Handle System Client Components. . . . . . . .\
    \ . . . . . 28\n   5.  Handle System Operation Model. . . . . . . . . . . . .\
    \ . . . . 29\n       5.1.  Handle System Service Request and Response . . . .\
    \ . . . 30\n       5.2.  Handle System Authentication Protocol. . . . . . . .\
    \ . . 32\n   6.  Security Considerations. . . . . . . . . . . . . . . . . . .\
    \ . 37\n   7.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . .\
    \ 38\n   8.  References and Bibliography. . . . . . . . . . . . . . . . . . 38\n\
    \   9.  Authors' Addresses . . . . . . . . . . . . . . . . . . . . . . 40\n  \
    \ 10. Full Copyright Statement . . . . . . . . . . . . . . . . . . . 41\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The Handle System manages handles as globally unique names\
    \ for\n   Internet resources.  It was originally conceived and described in a\n\
    \   paper by Robert Kahn and Robert Wilensky [22] in 1995.  The Handle\n   System\
    \ provides a general-purpose global name service that allows\n   handles to be\
    \ resolved and administrated securely over the public\n   Internet.  The Handle\
    \ System categorizes its service into two\n   categories: the handle resolution\
    \ service and the handle\n   administration service.  Clients use handle resolution\
    \ service to\n   resolve handles into their values.  The handle administration\
    \ service\n   deals with client requests to manage these handles, including adding\n\
    \   and deleting handles, and updating handle values.\n   The document \"Handle\
    \ System Overview\" [1] provides an architectural\n   overview of the Handle System,\
    \ and its relationship to other Internet\n   services such as DNS [2,3] and LDAP[4].\
    \  This document provides a\n   detailed description of the Handle System namespace,\
    \ its data and\n   service model, and its operation model.  It assumes that readers\
    \ are\n   familiar with the basic concepts of the Handle System as described in\n\
    \   the overview document.\n   The namespace definition specifies the handle syntax\
    \ and its semantic\n   structure.  The data model defines the data structures\
    \ used by the\n   Handle System protocol and any pre-defined data types for carrying\n\
    \   out the handle service.  The service model provides definitions of\n   various\
    \ Handle System components and explains how they work together\n   over the network.\
    \  Finally, the Handle System operation model\n   describes its service operation\
    \ in terms of messages transmitted\n   between client and server, and the client\
    \ authentication process\n   based on the Handle System authentication protocol.\n"
- title: 2.  Handle System Namespace
  contents:
  - "2.  Handle System Namespace\n   Handles are character strings that may consist\
    \ of a wide range of\n   characters.  Every handle in the Handle System consists\
    \ of two parts:\n   its naming authority, followed by a unique local name under\
    \ the\n   naming authority.  The naming authority and the local name are\n   separated\
    \ by the ASCII character \"/\" (octet 0x2F).  The following\n   table provides\
    \ the handle syntax definition in ABNF [5] notation:\n       <Handle>        \
    \  = <NamingAuthority> \"/\" <LocalName>\n       <NamingAuthority> = *(<NamingAuthority>\
    \  \".\") <NAsegment>\n       <NAsegment>       = 1*(%x00-2D / %x30-3F / %x41-FF\
    \ )\n                         ; any octets that map to UTF-8 encoded\n       \
    \                  ; Unicode 2.0 characters except\n                         ;\
    \ octets '0x2E' and '0x2F' (which\n                         ; correspond to the\
    \ ASCII characters '.',\n                         ; and '/').\n       <LocalName>\
    \       = *(%x00-FF)\n                         ; any octets that map to UTF-8\
    \ encoded\n                         ; Unicode 2.0 characters\n               \
    \        Table 2.1: Handle syntax\n   As shown in Table 2.1, both <NamingAuthority>\
    \ and <LocalName> are\n   UTF-8 [6] encoded character strings.  The Handle System\
    \ protocol\n   mandates UTF-8 encoding for handles transferred over the wire.\
    \  The\n   <LocalName> may consist of any characters from the Unicode 2.0\n  \
    \ standard [7].  The <NamingAuthority> may use any characters from the\n   Unicode\
    \ 2.0 standard except the ASCII character '/' (0x2F), which is\n   reserved to\
    \ separate the <NamingAuthority> from the <LocalName>.  A\n   <NamingAuthority>\
    \ may consist of multiple non-empty <NAsegment>s,\n   each of which separated\
    \ by the ASCII character '.' (octet 0x2E).\n   Naming authorities are defined\
    \ in a hierarchical fashion resembling a\n   tree structure.  Each node and leaf\
    \ of the tree is given a label that\n   corresponds to a naming authority segment\
    \ (<NAsegment>).  The parent\n   node represents the parent naming authority.\
    \  Naming authorities are\n   constructed left to right, concatenating the labels\
    \ from the root of\n   the tree to the node that represents the naming authority.\
    \  Each\n   label (or its <NAsegment>) is separated by the character '.' (octet\n\
    \   0x2E).  For example, the naming authority for the Digital Object\n   Identifier\
    \ (DOI) project is \"10\".  It is a root-level naming\n   authority as it has\
    \ no parent naming authority for itself.  It can,\n   however, have many child\
    \ naming authorities.  For example, \"10.1045\"\n   is a child naming authority\
    \ of \"10\" for the D-Lib Magazine.\n   By default, handles are case sensitive.\
    \  However, a handle service,\n   global or local, may implement its namespace\
    \ so that ASCII characters\n   under the namespace are treated as case insensitive.\
    \  For example,\n   the global handle service, formally known as the Global Handle\n\
    \   Registry (GHR), is implemented such that ASCII characters are treated\n  \
    \ as case insensitive.  Since the GHR manages all handles for naming\n   authorities,\
    \ ASCII characters in naming authorities are treated as\n   case insensitive.\n"
- title: 3.  Handle System Data Model
  contents:
  - "3.  Handle System Data Model\n   The Handle System provides a name-to-value binding\
    \ service over the\n   public Internet.  Each handle may have a set of values\
    \ assigned to\n   it.  The Handle System maintains the value set of each handle\
    \ and\n   will return it in response to any handle resolution request.  The\n\
    \   Handle System data model defines the conceptual data structure for\n   these\
    \ values.  The data model used by the protocol may not be the\n   exact physical\
    \ data model used for storage in any specific\n   implementation.  Rather, it\
    \ is the data model followed by the Handle\n   System protocol as specified in\
    \ the \"Handle System Protocol\n   Specification\" [8].\n"
- title: 3.1.  Handle Value Set
  contents:
  - "3.1.  Handle Value Set\n   Each handle may have a set of values assigned to it.\
    \  These handle\n   values use a common data structure for its data.  For example,\
    \ each\n   handle value has a unique index number that distinguishes it from\n\
    \   other values in the value set.  It also has a specific data type that\n  \
    \ defines the syntax and semantics of the data in its data field.\n   Besides\
    \ these, each handle value contains a set of administrative\n   information such\
    \ as TTL and permissions.  Figure 3.1 shows the handle\n   \"10.1045/may99-payette\"\
    \ with a set of three handle values.  One of\n   these values (with index number\
    \ set to 1) is shown in detail.  (Note\n   that the encoding of the length for\
    \ each field is not shown in Figure\n   3.1.  Also, the empty <reference> field\
    \ consists of a 4-byte integer\n   whose value is zero.)\n                   Handle\
    \ \"10.1045/may99-payette\"\n                                |\n             \
    \                   |\n                                V\n        -------------------------------------------------------------\n\
    \       |        <index>:            3                                |\n    \
    \  -------------------------------------------------------------  |\n     |  \
    \      <index>:            2                                | |\n    -------------------------------------------------------------\
    \  | |\n   |                                                             | | |\n\
    \   |  <index>:           1                                       | | |\n   |\
    \  <type>:            URL                                     | | |\n   |  <data>:\
    \            http://www.dlib.org/dlib...             | | |\n   |  <TTL>:     \
    \        {Relative: 24 hours}                    | | |\n   |  <permission>:  \
    \    PUBLIC_READ, ADMIN_WRITE                | | |\n   |  <timestamp>:       927314334000\
    \                            | | |\n   |  <reference>:       {empty}         \
    \                        | |-\n   |                                          \
    \                   |-\n    -------------------------------------------------------------\n\
    \     Figure 3.1: Handle \"10.1045/may99-payette\" and its set of values\n   In\
    \ Figure 3.1, it shows a handle value whose its index is set to 1.\n   The data\
    \ type for the handle value is URL.  The URL data as stated in\n   the <data>\
    \ field is \"http://www.dlib.org/dlib...\".  The TTL (time to\n   live) entry\
    \ suggests that the value record should be cached no more\n   than 24 hours before\
    \ the source of the information to be consulted\n   again.  The <permission> field\
    \ grants anyone permission to read, but\n   only the administrator to update the\
    \ value.  The <reference> field is\n   empty.  It may contain a list of references\
    \ to other handle values as\n   credentials for this handle value.\n   Thus a\
    \ handle value may be thought of as a record that consists of a\n   group of data\
    \ fields.  Each of these data fields is defined as\n   follows:\n      <index>\n\
    \      An unsigned 32-bit integer that uniquely identifies a handle value\n  \
    \    from other handle values.\n      <type>\n      A UTF8-string that identifies\
    \ the data type for the value record.\n      Note that throughout this document,\
    \ a UTF8-string is defined as a\n      data structure that consists of a 4-byte\
    \ unsigned integer followed\n      by an UTF-8 encoded character string.  The\
    \ integer specifies the\n      number of octets in the character string.\n   \
    \   The <type> field identifies the data type that defines the syntax\n      and\
    \ semantics of data in the next <data> field.  The data type may\n      be registered\
    \ with the Handle System to avoid potential conflicts.\n      The Handle System\
    \ has a reserved naming authority \"0.TYPE\" for\n      registered data types.\
    \  For example, \"URL\" (as shown in Figure\n      3.1) is a registered data type.\
    \  It is registered as the handle\n      \"0.TYPE/URL\".  The handle may have\
    \ a value that explains the\n      syntax and semantics of the data type.\n  \
    \    Data types under the Handle System may be hierarchical.  Each\n      level\
    \ of the hierarchy may be named in terms of a UTF8-String with\n      no '.' (0x2E)\
    \ characters.  The '.' character is used to mark the\n      boundary between hierarchy\
    \ levels.  For example, the Handle System\n      data type \"a.b\" may be considered\
    \ as a sub-type \"b\" under the type\n      \"a\".  Similarly, handle values of\
    \ <type> \"a.b.x\", \"a.b.y\" and\n      \"a.b.z\" may be considered as handle\
    \ values under the common type\n      hierarchy \"a.b\".\n      For any handle\
    \ values, the UTF8-string in the <type> field may not\n      end with the '.'\
    \ character.  In other words, no Handle System data\n      type should end with\
    \ the '.' character.  However, the '.'\n      character may appear in the end\
    \ of the <type> parameter in a\n      handle query.  This is used to query for\
    \ all handle values under a\n      common type hierarchy.  For example, one may\
    \ query for all handle\n      values under the type hierarchy \"a.b\" (e.g., handle\
    \ values of\n      <type> \"a.b.x\", \"a.b.y\" and \"a.b.z\") by setting the <type>\n\
    \      parameter to \"a.b.\".  Note here that the <type> parameter ends\n    \
    \  with the '.' character.  Details of the handle query operation can\n      be\
    \ found in the Handle System protocol specification [8].\n      <data>\n     \
    \ A sequence of octets (preceded by its length in a 4-byte unsigned\n      integer)\
    \ that describes the resource identified by the handle. The\n      syntax and\
    \ semantics of these octets are identified by the <type>\n      field.\n     \
    \ <permission>\n      An eight-bit bit-mask for access control of the handle value.\n\
    \      Access control is defined in terms of read, write, and execute\n      permissions,\
    \ applicable to either general public or handle\n      administrator(s).  Each\
    \ handle value can have its permission field\n      specified as any combination\
    \ of the following bits:\n        PUBLIC_WRITE   (0x01)     permission that allows\
    \ anyone to\n                                  modify or delete the handle value.\n\
    \        PUBLIC_READ    (0x02)     permission that allows anyone to read\n   \
    \                               the handle value.\n        ADMIN_WRITE    (0x04)\
    \     permission that allows any handle\n                                  administrator\
    \ to update or delete the\n                                  handle value.\n \
    \       ADMIN_READ     (0x08)_    permission that allows the handle\n        \
    \                          value to be read by any handle\n                  \
    \                administrator with AUTHORITIVE_READ\n                       \
    \           privilege.\n        PUBLIC_EXECUTE (0x10)     permission that allows\
    \ anyone to\n                                  execute the program identified\
    \ by the\n                                  handle value on the handle host as\n\
    \                                  anonymous user.  Because of the\n         \
    \                         security risks this may have brought\n             \
    \                     up, implementations may choose not to\n                \
    \                  support such permission, or provide\n                     \
    \             options so that it can be disabled at\n                        \
    \          deployment.\n        ADMIN_EXECUTE  (0x20)     permission that allows\
    \ handle\n                                  administrator(s) to run the program\n\
    \                                  identified by the handle value on the\n   \
    \                               handle server.  The handle server must\n     \
    \                             authenticate the handle administrator\n        \
    \                          before executing the program.  The\n              \
    \                    handle administrator must have an\n                     \
    \             established account on the handle\n                            \
    \      server.  The execution of the handle\n                                \
    \  value should assume the same privilege\n                                  as\
    \ the one given to the account for\n                                  the handle\
    \ administrator.  Because of\n                                  the security risks\
    \ this may have\n                                  brought up, implementations\
    \ may choose\n                                  not to support such permission,\
    \ or\n                                  provide options so that it can be\n  \
    \                                disabled at deployment.\n      Note that a handle\
    \ value with no PUBLIC_READ nor ADMIN_READ\n      permission can not leave the\
    \ handle server.  It may be used, for\n      example, to store secret keys for\
    \ authentication purposes.  A\n      handle value with neither PUBLIC_WRITE nor\
    \ ADMIN_WRITE permission\n      makes the handle value immutable and cannot be\
    \ deleted by any\n      handle administrator (via the Handle System protocol).\n\
    \      The administrator for a given handle must specify the permission\n    \
    \  for each handle value.  Implementations may choose PUBLIC_READ and\n      ADMIN_WRITE\
    \ as the default permission for each handle value.\n      Handle servers must\
    \ check permissions before fulfilling any client\n      request.\n      <TTL>\n\
    \      An octet followed by a 4-byte integer that specifies the Time-To-\n   \
    \   Live of the value record.  It is used to describe how long the\n      value\
    \ record can be cached before the source of the information\n      should again\
    \ be consulted.  A zero value for a TTL indicates that\n      the value record\
    \ should only be used for the transaction in\n      progress and should not be\
    \ cached.  Any non-zero TTL is defined in\n      terms of a TTL type (specified\
    \ in the first octet), followed by\n      the TTL value (the 32-bit unsigned integer\
    \ that follows the TTL\n      type).  The TTL type indicates whether the TTL value\
    \ is absolute\n      or relative.  The absolute TTL value defines the time to\
    \ live in\n      terms of seconds since 00:00:00 UTC, January 1st 1970.  A relative\n\
    \      TTL specifies the time to live in terms of the number of seconds\n    \
    \  elapsed since the value was obtained by the client from any handle\n      server.\n\
    \      <timestamp>\n      An 8-byte (long) integer that records the last time\
    \ the value was\n      updated at the server.  The field contains elapsed time\
    \ since\n      00:00:00 UTC, January 1970 in milliseconds.  The choice of\n  \
    \    milliseconds is to avoid potential collision when updating the\n      value.\n\
    \      <reference>\n      A 4-byte integer followed by a list of references to\
    \ other handle\n      values.  The integer specifies the number of references\
    \ in the\n      list.  Each reference in the list refers to another handle value\n\
    \      in terms of a UTF8-string and a 4-byte integer (where the UTF8-\n     \
    \ string is the handle name and the integer is the value index).\n      References\
    \ are generally used to add credentials to the current\n      handle value.  For\
    \ example, a handle value may make itself more\n      trust-worthy by referring\
    \ to a digital signature issued by a\n      commonly trusted entity.\n   By default,\
    \ the Handle System returns all the handle values with\n   public-read permission\
    \ in response of any resolution request.  It is\n   possible for a client to ask\
    \ for a subset of those values with\n   specific data type (e.g., all URLs assigned\
    \ to the handle).  The\n   client may also ask for a specific handle value based\
    \ on a specific\n   value index.\n   Each handle value can be uniquely referenced\
    \ by the combination of\n   the handle and its value index.  Care must be taken\
    \ when changing the\n   value index as it may break an existing reference to the\
    \ handle\n   value.  For example, suppose the handle X/Y has a value whose index\n\
    \   is 1.  That value may be referred to as X/Y:1.  If the handle\n   administrator\
    \ changes the value index from 1 to 2, the reference to\n   X/Y:1 will become\
    \ obsolete.  Any reference to the handle value will\n   have to change to X/Y:2.\n\
    \   Value records assigned to any handle may or may not have continuous\n   index\
    \ numbers.  Nor can it be assumed that the index will start with\n   0 or 1. \
    \ A handle administrator may assign a handle value with any\n   index as long\
    \ as each index is unique within the value set.\n   A handle value may be \"privatized\"\
    \ or \"disabled\" by setting its\n   <permission> field as \"authorized-read\"\
    .  This limits read-access to\n   the handle administrator only.  The \"privatized\"\
    \ value can then be\n   used to keep any historical data (on behalf of the handle\n\
    \   administrator) without exposing it to public.  Such approach may also\n  \
    \ be used to keep any obsolete handle or naming authority from being\n   reused\
    \ accidentally.\n"
- title: 3.2.  Pre-defined Handle Data Types
  contents:
  - "3.2.  Pre-defined Handle Data Types\n   Every handle value must have a data type\
    \ specified in its <type>\n   field.  The Handle System provides a type registration\
    \ service that\n   allows organizations to register new data types for their\n\
    \   applications.  Data types can be registered as handles under the\n   naming\
    \ authority \"0.TYPE\".  For example, the URL data type is\n   registered under\
    \ the Handle System as the handle \"0.TYPE/URL\".  The\n   handle may have a handle\
    \ value that refers to RFC1738 [9], an IETF\n   standard document that defines\
    \ the syntax and semantics of URL.\n   The Handle System pre-defines a set of\
    \ data types to carry out the\n   handle service.  For example, HS_ADMIN is a\
    \ pre-defined data type\n   used to describe handle administrators or administrator\
    \ groups.\n   HS_SITE is a pre-defined data type to describe the service interface\n\
    \   of any Handle System service component.  The following sections\n   provide\
    \ detailed descriptions of these pre-defined data types under\n   the Handle System.\n"
- title: '3.2.1.  Handle Administrator: HS_ADMIN'
  contents:
  - "3.2.1.  Handle Administrator: HS_ADMIN\n   Each handle has one or more administrators.\
    \  Any administrative\n   operation (e.g., add, delete or modify handle values)\
    \ can only be\n   performed by the handle administrator with adequate privilege.\n\
    \   Handle administrators are defined in terms of HS_ADMIN values.  Every\n  \
    \ handle must have at least one HS_ ADMIN value that defines its\n   administrator.\
    \  Each HS_ADMIN value can be used to define a set of\n   handle administrators\
    \ sharing the same administration privilege.\n   Handles with multiple administrators\
    \ of different privileges may have\n   multiple HS_ADMIN values.  HS_ADMIN values\
    \ are used by the Handle\n   System to authenticate handle administrators before\
    \ fulfilling any\n   handle administration request.\n   Naming authorities, as\
    \ described above, are themselves registered as\n   handles under the reserved\
    \ naming authority \"0.NA\".  These handles\n   are referred to as naming authority\
    \ handles.  Administrators for any\n   naming authority are defined as the administrators\
    \ of the\n   corresponding naming authority handle.  For example, \"0.NA/10\"\
    \ is the\n   naming authority handle for the naming authority \"10\".  Hence any\n\
    \   administrator for the naming authority handle \"0.NA/10\" is also the\n  \
    \ administrator for the naming authority \"10\".  Naming authority\n   administrators\
    \ are the only ones who can create handles or sub-\n   naming authorities under\
    \ the naming authority.  A sub-naming\n   authority may define its own set of\
    \ administrators to create handles\n   or further levels of sub-naming authorities.\
    \  For example, the naming\n   authority \"10.1045\" may have a totally different\
    \ group of\n   administrators from its parent naming authority \"10\".\n   An\
    \ HS_ADMIN value is a handle value whose <type> field is HS_ADMIN\n   and whose\
    \ <data> field consists of the following entries:\n      <AdminRef>\n      A reference\
    \ to a handle value.  The reference consists of the\n      handle name (a UTF8-string)\
    \ followed by a 4-byte unsigned integer\n      for the handle value index.  The\
    \ handle value identifies the set\n      of administrators for the handle.\n \
    \     <AdminPermission>\n      A 16-bit bit-mask that defines the administration\
    \ privilege of the\n      set of handle administrators identified by the HS_ADMIN\
    \ value.\n   The <AdminRef> entry refers to a handle value that can be used to\n\
    \   authenticate the handle administrator.  Such handle value is called\n   the\
    \ handle administrator reference.  The handle administrator\n   reference may\
    \ contain the secret key, public key, or X.509\n   certificate [10] provided by\
    \ the handle administrator.  For example,\n   the <AdminRef> entry may contain\
    \ a handle administrator reference\n   whose <type> field is DSS_WITH_DES_CBC_SHA\
    \ and whose <data> field\n   contains a DES secret key [11], for use in the Cipher\
    \ Block Chaining\n   (CBC) mode of operation [12, 13].  The secret key can be\
    \ used by the\n   handle server to authenticate the handle administrator.  For\
    \ stronger\n   cryptographic algorithm, the handle administrator reference may\n\
    \   contain a set of Triple-DES keys [23] and set its <type> to be DES-\n   EDE3-WITH-CBC.\n\
    \   A single handle may be assigned with both the HS_ADMIN value and the\n   handle\
    \ administrator reference.  In other words, the <AdminRef> entry\n   may refer\
    \ to a handle value assigned to the same handle that has the\n   HS_ADMIN value.\
    \  In this case, authentication of the handle\n   administrator does not rely\
    \ on any other handles.  Alternatively, the\n   handle administrator reference\
    \ may be a handle value under a\n   different handle.  Thus HS_ADMIN values from\
    \ different handles may\n   share a common handle administrator reference.  This\
    \ feature allows\n   sharing of handle administrators among different handles.\
    \  The handle\n   administrator reference contains the secret key, public key,\
    \ or X.509\n   certificate provided by the administrator of these handles.\n \
    \  Handle administrator reference may be of type HS_VLIST and has its\n   <data>\
    \ field contain a list of references to other handle values.\n   Each of these\
    \ handle values defines a handle administrator reference.\n   The HS_VLIST value\
    \ defines an administrator group.  Each handle\n   administrator reference from\
    \ the HS_VLIST is a member of the\n   administrator group.  Each handle value\
    \ reference is defined in terms\n   of a <handle>:<index> pair.  An administrator\
    \ group may also contain\n   other administrator groups as its members.  This\
    \ allows administrator\n   groups to be defined in a hierarchical fashion.  Care\
    \ must be taken,\n   however, to avoid cyclic definition of administrators or\n\
    \   administrator groups.  Multiple levels of administrator groups should\n  \
    \ be avoided due to their lack of efficiency, but will not be signaled\n   as\
    \ an error.  Client software should be prepared to detect any\n   potential cyclic\
    \ definition of administrators or <AdminRef> entries\n   that point to non-existent\
    \ handle values and treat them as an error.\n   A handle can have multiple HS_ADMIN\
    \ values, each of which defines a\n   different handle administrator.  Different\
    \ administrators can play\n   different roles or be granted different permissions.\
    \  For example,\n   the naming authority handle \"0.NA/10\" may have two administrators,\n\
    \   one of which may only have permission to create new handles under the\n  \
    \ naming authority, while the other may have permission to create new\n   sub-naming\
    \ authorities (e.g., \"10.1045\").  The set of possible\n   permissions for a\
    \ handle administrator is defined as follows:\n     Add_Handle (0x0001)\n    \
    \ This permission allows naming authority administrator to create new\n     handles\
    \ under a given naming authority.\n     Delete_Handle (0x0002)\n     This permission\
    \ allows naming authority administrator to delete\n     handles under a given\
    \ naming authority.\n     Add_NA (0x0004)\n     This permission allows the naming\
    \ authority administrator to create\n     new sub-naming authorities.\n     Delete_NA\
    \ (0x0008)\n     This permission allows naming authority administrator to delete\
    \ an\n     existing sub-naming authority.\n     Modify_Value (0x0010)\n     This\
    \ permission allows handle administrator to modify any handle\n     values other\
    \ than HS_ADMIN values.  HS_ADMIN values are used to\n     define handle administrators\
    \ and are managed by a different set of\n     permissions.\n     Delete_Value\
    \ (0x0020)\n     This permission allows handle administrator to delete any handle\n\
    \     value other than the HS_ADMIN values.\n     Add_Value (0x0040)\n     This\
    \ permission allows handle administrator to add handle values\n     other than\
    \ the HS_ADMIN values.\n     Modify_Admin (0x0080)\n     This permission allows\
    \ handle administrator to modify HS_ADMIN\n     values.\n     Remove_Admin (0x0100)\n\
    \     This permission allows handle administrator to remove HS_ADMIN\n     values.\n\
    \     Add_Admin (0x0200)\n     This permission allows handle administrator to\
    \ add new HS_ADMIN\n     values.\n     Authorized_Read (0x0400)\n     This permission\
    \ grants handle administrator read-access to handle\n     values with the ADMIN_READ\
    \ permission.  Administrators without this\n     permission will not have access\
    \ to handle values that require\n     authentication for read access.\n     LIST_Handle\
    \ (0x0800)\n     This permission allows naming authority administrator to list\n\
    \     handles under a given naming authority.\n     LIST_NA (0x1000)\n     This\
    \ permission allows naming authority administrator to list\n     immediate sub-naming\
    \ authorities under a given naming authority.\n   Administrator permissions are\
    \ encoded in the <AdminPermission> entry\n   in the <data> field of any HS_ADMIN\
    \ value.  Each permission is\n   encoded as a bit flag.  The permission is granted\
    \ if the flag is set\n   to 1, otherwise it is set to 0.\n   Figure 3.2.1 shows\
    \ an example of HS_ADMIN value that defines an\n   administrator for the naming\
    \ authority handle \"0.NA/10\".  In figure\n   3.2.1, a naming authority administrator\
    \ is identified by an HS_ADMIN\n   value assigned to the naming authority handle\
    \ \"0.NA/10\".  The\n   administrator can be authenticated based on the handle\
    \ value\n   \"0.NA/10\":3, which is the handle value assigned to the naming\n\
    \   authority handle \"0.NA/10\" and has its index set to 3.  The handle\n   value\
    \ \"0.NA/10\":3 may contain the secret or public key used by the\n   administrator.\
    \  The administrator is granted permission to add,\n   delete, or modify sub-naming\
    \ authorities under \"10\", and add or\n   delete handles directly under the naming\
    \ authority.  The\n   administrator may also add, delete, or modify any handle\
    \ values\n   assigned to the naming authority handle except those HS_ADMIN values.\n\
    \   In other words, the administrator is not allowed to add, delete, or\n   modify\
    \ any administrators for the naming authority.\n        -------------------------------------------------------------\n\
    \      -------------------------------------------------------------  |\n    -------------------------------------------------------------\
    \  | |\n   |                                                             | | |\n\
    \   |  <index>:       2                                           | | |\n   |\
    \  <type>:        HS_ADMIN                                    | | |\n   |  <data>:\
    \                                                    | | |\n   |    <AdminRef>:\
    \    \"0.NA/10\": 3                              | | |\n   |    <AdminPerm>: \
    \  Add_NA,     Delete_NA,                    | | |\n   |                   Add\
    \ Handle, Delete_Handle,                | | |\n   |                   Add_Value,\
    \  Delete_Value,  Modify_Value,  | | |\n   |                   Authorized_Read,\
    \ List_Handle, List_NA     | | |\n   |                                       \
    \                      | | |\n   |  <TTL>:         24 hours                  \
    \                  | | |\n   |  <permission>:  PUBLIC_READ, ADMIN_WRITE      \
    \              | | |\n   |  <reference>:   {empty}                           \
    \          | |-\n   |                                                        \
    \     |-\n    -------------------------------------------------------------\n\
    \         Figure 3.2.1: Administrator for the naming authority\n             \
    \          handle \"0.NA/10\"\n   HS_ADMIN values are used by handle servers to\
    \ authenticate the handle\n   administrator before fulfilling any administrative\
    \ requests.  The\n   server authenticates a client by checking whether the client\
    \ has\n   possession of the secret key (or the private key) that matches the\n\
    \   one in any of the handle administrator references.  The\n   authentication\
    \ is carried out via the Handle System authentication\n   protocol as described\
    \ later in this document.\n   HS_ADMIN values may require authentication for read\
    \ access in order\n   to prevent public exposure of the data.  Additionally, the\
    \ handle\n   administrator reference that contains the administrator's secret\
    \ key\n   should have neither PUBLIC_READ nor ADMIN_READ permission to prevent\n\
    \   the key from leaving the server.\n"
- title: '3.2.2.  Service Site Information: HS_SITE'
  contents:
  - "3.2.2.  Service Site Information: HS_SITE\n   The Handle System consists of a\
    \ single distributed global handle\n   service, also known as the Global Handle\
    \ Registry (GHR), and\n   unlimited number of Local Handle Services (LHSs).  Each\
    \ handle\n   service, global or local, may be replicated into multiple service\n\
    \   sites.  Each service site may consist of multiple server computers.\n   Service\
    \ requests targeted at any handle service can be distributed\n   into different\
    \ service sites, and into different server computers\n   within any service site.\
    \  Such architecture assures that each handle\n   service could have the capacity\
    \ to manage any large number of handles\n   and handle requests.  It also provides\
    \ ways for each handle service\n   to avoid any single point of failure.\n   Each\
    \ handle service, global or local, may provide the same set of\n   functions for\
    \ resolving and administering its collection of handles.\n   Handle services differ\
    \ primarily in that each service is responsible\n   for a distinct set of handles.\
    \  They are also likely to differ in the\n   selection, number, and configuration\
    \ of their components such as the\n   servers used to provide handle resolution\
    \ and administration.\n   Different handle services may be created and managed\
    \ by different\n   organizations.  Each of them may have their own goals and policies.\n\
    \   A service site typically consists of a cluster of server computers\n   residing\
    \ within a local Internet domain.  These computers work\n   together to distribute\
    \ the data storage and processing load at the\n   site.  It is possible, although\
    \ not recommended, to compose a site\n   from servers at widely different locations.\
    \  Further, it is even\n   possible to compose two different sites from the same\
    \ set of servers.\n   Each service site is defined by an HS_SITE value.  HS_SITE\
    \ is a\n   pre-defined Handle System data type.  An HS_SITE value defines a\n\
    \   service site by identifying the server computers (e.g., IP addresses)\n  \
    \ that comprise the site along with their service configurations (e.g.,\n   port\
    \ numbers).  HS_SITE values are typically assigned to naming\n   authority handles.\
    \  The set of HS_SITE values assigned to a naming\n   authority handle is called\
    \ the service information for the naming\n   authority.\n   The service information\
    \ is managed by the naming authority\n   administrator.  It must reflect the configuration\
    \ of the handle\n   service for the naming authority.  Note that an additional\
    \ layer of\n   indirection, called a service handle, can be used to allow multiple\n\
    \   naming authorities to reference a single set of HS_SITE values, as\n   described\
    \ later in this document (see section 3.2.3).  Clients of the\n   Handle System\
    \ depend on the service information to locate the\n   responsible handle server\
    \ before they can send their service\n   requests.  The service information can\
    \ also be used by clients to\n   authenticate any service response from the handle\
    \ server.\n   An HS_SITE value is a handle value whose <type> field is HS_SITE\
    \ and\n   whose <data> field consists of the following entries:\n     <Version>\n\
    \     A 2-byte value that identifies the version number of the HS_SITE.\n    \
    \ The version number identifies the data format used by the HS_SITE\n     value.\
    \  It is defined to allow backward compatibility over time.\n     This document\
    \ defines the HS_SITE with version number 0.\n     <ProtocolVersion>\n     A 2-byte\
    \ integer value that identifies the handle protocol version.\n     The higher\
    \ byte of the value identifies the major version and the\n     lower byte the\
    \ minor version.  Details of the Handle System\n     protocol is specified in\
    \ [8].\n     <SerialNumber>\n     A 2-byte integer value that increases by 1 (and\
    \ may wrap around\n     through 0) each time the HS_SITE value gets changed. \
    \ It is used in\n     the Handle System protocol to synchronize the HS_SITE values\n\
    \     between client and server.\n     <PrimaryMask>\n     An 8-bit mask that\
    \ identifies the primary site(s) of the handle\n     service.  The first bit of\
    \ the octet is the <MultiPrimary> bit.  It\n     indicates whether the handle\
    \ service has multiple primary sites.\n     The second bit of the octet is the\
    \ <PrimarySite> bit.  It indicates\n     whether the HS_SITE value is a primary\
    \ site.  A primary site is the\n     one that supports administrative operations\
    \ for its handles.  A\n     <MultiPrimary> entry with zero value indicates that\
    \ the handle\n     service has a single primary site and all handle administration\
    \ has\n     to be done at that site.  A non-zero <MultiPrimary> entry indicates\n\
    \     that the handle service has multiple primary sites.  Each primary\n    \
    \ site may be used to administrate handles managed under the handle\n     service.\
    \  Handles managed by such service may identify its primary\n     sites using\
    \ an HS_PRIMARY value, as described in section 3.2.5.\n     <HashOption>\n   \
    \  An 8-bit octet that identifies the hash option used by the service\n     site\
    \ to distribute handles among its servers.  Valid options\n     include HASH_BY_NA\
    \ (0x00), HASH_BY_LOCAL (0x01), or HASH_BY_HANDLE\n     (0x02).  These options\
    \ indicate whether the hash operation should\n     only be applied to the naming\
    \ authority portion of the handle, or\n     only the local name portion of the\
    \ handle, or the entire handle,\n     respectively.  The standard MD5 hashing\
    \ algorithm [14] is used by\n     each service site to distribute handles among\
    \ its servers.\n     <HashFilter>\n     An UTF8-string entry reserved for future\
    \ use.\n     <AttributeList>\n     A 4-byte integer followed by a list of UTF8-string\
    \ pairs.  The\n     integer indicates the number of UTF8-string pairs that follow.\n\
    \     Each UTF8-string pair is an <attribute>:<value> pair.  They are\n     used\
    \ to add literal explanations of the service site.  For example,\n     if the\
    \ <attribute> is \"Organization\", the <value> should contain a\n     description\
    \ of the organization hosting the service site.  Other\n     <attribute>s may\
    \ be defined to help distinguish the service sites\n     from each other.\n  \
    \   <NumOfServer>\n     A 4-byte integer that defines the number of servers in\
    \ the service\n     site.  The entry is followed by a list of <ServerRecord>s.\
    \  Each\n     <ServerRecord> defines a handle server that is part of the service\n\
    \     site.  Each <ServerRecord> consists of the following data fields:\n    \
    \ <ServerRecord> ::= <ServerID>\n                        <Address> <PublicKeyRecord>\
    \ <ServiceInterface>\n     where each field is defined as follows:\n         <ServerID>\n\
    \         A 4-byte unsigned integer that uniquely identifies a server\n      \
    \   process under the service site.  <ServerID>s do not have to\n         begin\
    \ with 1 and they don't have be consecutive numbers.  They\n         are used\
    \ to distinguish servers under a service site from each\n         other.  Note\
    \ that there can be multiple servers residing on any\n         given computer,\
    \ each with a different <ServerID>.\n         <Address>\n         The 16-byte\
    \ IPv6 [15, 16] address of the handle server.  Any\n         IPv4 address should\
    \ be presented as :::::FFFF:xxxx:xxxx (where\n         xxxx:xxxx can be any 4-byte\
    \ IPv4 address).\n         <PublicKeyRecord>\n         A 4-byte integer followed\
    \ by a byte-array that contains the\n         server's public key.  The integer\
    \ specifies the size of the\n         byte-array.  The byte-array (for the publickey)\
    \ consists of\n         three parts: a UTF8-string that describes the key type,\
    \ a\n         two-byte option field reserved for future use, and a byte-array\n\
    \         that contains the public key itself.  For example, the UTF8-\n     \
    \    String \"DSA_PUB_KEY\" indicates that the <PublicKeyRecord>\n         contains\
    \ a DSA public key.  The storage format of the DSA key\n         in the byte-array\
    \ could then be found from the handle\n         \"0.type/DSA_PUB_KEY\".  Public\
    \ key in the <PublicKeyRecord> can\n         be used to authenticate any service\
    \ response from the handle\n         server.\n         The <PublicKeyRecord> may\
    \ also contain an X.509 certificate.\n         This happens if the key type field\
    \ contains the UTF8-String\n         \"CERT.X509\".  In this case, \"CERT.X509\"\
    \ will map to the handle\n         \"0.TYPE/CERT.X509\".  The handle may contain\
    \ information that\n         describes the syntax and semantics of the public\
    \ key or its\n         certificate.  Additional key type may also be registered\
    \ (as\n         handles under \"0.TYPE\") to further distinguish different kinds\n\
    \         of X.509 certificates.  For example, \"CERT.X509.DSA\" may be\n    \
    \     used to denote X.509 certificates that contain DSA public keys.\n      \
    \   If the key type field of a <PublicKeyRecord> declares\n         \"CERT.X509.DSA\"\
    , the <PublicKeyRecord> must contain a X.509\n         certificate with a DSA\
    \ public key in it.\"\n         <ServiceInterface> ::=    <InterfaceCounter>\n\
    \                                 * [  <ServiceType>\n                       \
    \               <TransmissionProtocol>\n                                     \
    \ <PortNumber>  ]\n         A 4-byte integer followed by an array of triplets\
    \ consisting of\n         <ServiceType, TransmissionProtocol, PortNumber>.  The\
    \ 4-byte\n         integer specifies the number of triplets.  Each triplet lists\
    \ a\n         service interface provided by the handle server.  For each\n   \
    \      triplet, the <ServiceType> is an octet (as a bit mask) that\n         specifies\
    \ whether the interface is for handle resolution\n         (0x01), handle administration\
    \ (0x02), or both.  The\n         <TransmissionProtocol> is also an octet (as\
    \ a bit mask) that\n         specifies the transmission protocol.  Possible transmission\n\
    \         protocols include TCP (0x01), UDP (0x02), and HTTP (0x04).  The\n  \
    \       <PortNumber> is a 4-byte unsigned integer that specifies the\n       \
    \  port number used by the interface.  The default port number is\n         2641.\n\
    \   Figure 3.2.2 shows an example of handle service site in terms of a\n   HS_SITE\
    \ value.  The HS_SITE value is assigned to the naming authority\n   handle \"\
    0.NA/10\".  The <PrimaryMask> indicates that it is the only\n   primary site of\
    \ the handle service.  The site consists of three\n   handle servers, as indicated\
    \ in the <NumOfServer>.  These servers\n   provide handle resolution and administration\
    \ service for every handle\n   under the naming authority \"10\".  The first server\
    \ record (ServerID\n   0) shows two service interfaces, one for handle resolution\
    \ and the\n   other for handle administration.  Each interface has its own port.\n\
    \   Each server within a service site is responsible for a subset of\n   handles\
    \ managed by the handle service.  Clients can find the\n   responsible server\
    \ by performing a common hash-operation.  The hash-\n   operation will first convert\
    \ all ASCII characters in the handle into\n   upper-case.  It then applies the\
    \ MD5 hashing upon the portion of the\n   converted handle string (according to\
    \ the <HashOption> entry).  The\n   result is a 16-byte integer.  The absolute\
    \ value of the integer will\n   be divided by the number of servers (specified\
    \ in the <NumOfServer>\n   entry).  The remainder is the sequence number (starting\
    \ with zero) of\n   the <ServerRecord> listed in the HS_SITE value.  From the\n\
    \   <ServerRecord>, clients can find the IP address of the handle server\n   for\
    \ their handle requests.\n       ------------------------------------------------------------\n\
    \     ------------------------------------------------------------  |\n    -----------------------------------------------------------\
    \  | |\n   |                                                           | | |\n\
    \   | <index>:       2                                          | | |\n   | <type>:\
    \        HS_SITE                                    | | |\n   | <data>:      \
    \                                             | | |\n   |    Version:        \
    \   0                                   | | |\n   |    ProtocolVersion:   2.1\
    \                                 | | |\n   |    SerialNumber:      1        \
    \                           | | |\n   |    PrimaryMask:                      \
    \                     | | |\n   |        MultiPrimary:    FALSE              \
    \               | | |\n   |        PrimarySite:     TRUE                     \
    \         | | |\n   |    HashOption:        HASH_BY_HANDLE                   \
    \   | | |\n   |    HashFilter:        {empty UTF8-String}                 | |\
    \ |\n   |    AttributeList:     0    {followed by no attributes}    | | |\n  \
    \ |    NumOfServer:       3                                   | | |\n   |    \
    \     {followed by a list of <ServerRecord>}            | | |\n   |          \
    \                                                 | | |\n   |         -----------------------------------------\
    \         | | |\n   |       ------------------------------------------ |     \
    \   | | |\n   |      ------------------------------------------ ||        | |\
    \ |\n   |     | ServerID:        1                       |||        | | |\n  \
    \ |     | Address:         :FFFF:132.151.1.155     |||        | | |\n   |    \
    \ | PublicKeyRecord: HS_DSAKEY, iQCuR2R...   |||        | | |\n   |     | ServiceInterface\
    \                         |||        | | |\n   |     |    ServiceType:       \
    \   Resolution_Only |||        | | |\n   |     |    TransmissionProtocol: TCP\
    \ & UDP       |||        | | |\n   |     |    PortNumber:           2641     \
    \       |||        | | |\n   |     |                                         \
    \ |||        | | |\n   |     |    ServiceType:          Admin only      |||  \
    \      | | |\n   |     |    TransmissionProtocol: TCP             ||         |\
    \ | |\n   |     |    PortNumber:           2642            |          | | |\n\
    \   |      ------------------------------------------           | | |\n   |  \
    \                                                         | | |\n   |  <TTL>:\
    \        24 hours                                   | | |\n   |  <permission>:\
    \ PUBLIC_READ, ADMIN_WRITE                   | | |\n   |  <reference>:  {empty}\
    \                                    | |-\n   |                              \
    \                             |-\n    -----------------------------------------------------------\n\
    \    Fig. 3.2.2: The primary service site for the naming authority \"10\"\n"
- title: '3.2.3.  Naming Authority Delegation Service: HS_NA_DELEGATE'
  contents:
  - "3.2.3.  Naming Authority Delegation Service: HS_NA_DELEGATE\n   The HS_NA_DELEGATE\
    \ is a pre-defined Handle System data type.  It has\n   the exact same format\
    \ as the HS_SITE value.  Like HS_SITE values,\n   HS_NA_DELEGATE values are used\
    \ to describe service sites of a LHS.\n   HS_NA_DELEGATE values may be assigned\
    \ to naming authority handles to\n   designate naming authority administration\
    \ to a LHS.  A naming\n   authority handle with a set of HS_NA_DELEGATE values\
    \ indicates that\n   all child naming authorities of the naming authority are\
    \ managed by\n   the LHS described by the HS_NA_DELEGATE values.\n   For example,\
    \ suppose the naming authority \"foo.bar\" decides to have\n   its child naming\
    \ authorities delegated to a LHS.  To achieve this,\n   one may assign the naming\
    \ authority handle \"0.NA/foo.bar\" with a set\n   of HS_NA_DELEGATE values that\
    \ describes the LHS.  The set of\n   HS_NA_DELEGATE values indicate that the service\
    \ information of any\n   child naming authority of the \"foo.bar\", such as \"\
    foo.bar.baz\", can\n   be found by querying the naming authority handle \"0.NA/foo.bar.baz\"\
    \n   from the LHS.\n"
- title: '3.2.4.  Service Handle: HS_SERV'
  contents:
  - "3.2.4.  Service Handle: HS_SERV\n   Any handle service, global or local, can\
    \ be defined in terms of a set\n   of HS_SITE values.  These HS_SITE values may\
    \ be assigned directly to\n   the relevant naming authority handle, or an additional\
    \ level of\n   indirection may be introduced through the use of service handles.\
    \  A\n   service handle may be thought of as a name for a handle service.  It\n\
    \   may be used to maintain the HS_SITE values for the handle service and\n  \
    \ referenced from a naming authority handle via a HS_SERV value.  A\n   HS_SERV\
    \ value is a handle value whose <type> field is HS_SERV and\n   whose <data> field\
    \ contains the reference to the service handle.\n   HS_SERV values are typically\
    \ assigned to naming authority handles to\n   refer clients to the responsible\
    \ handle service.\n   Use of service handle allows sharing of service information\
    \ among\n   multiple naming authorities.  It also allows changes to service\n\
    \   configuration (e.g., adding a new site) to be made in one place\n   rather\
    \ than in every naming authority handle involved.  The mechanism\n   may also\
    \ be used to support service referral from one handle service\n   to another for\
    \ whatever reason.\n   A naming authority handle may have no more than one HS_SERV\
    \ value\n   assigned to it, otherwise it is an error.  If a naming authority\n\
    \   handle has both a list of HS_SITE values and an HS_SERV value, the\n   HS_SITE\
    \ values should be used as the service information for the\n   naming authority.\n\
    \   Service handles can be registered under the reserved naming authority\n  \
    \ \"0.SERV\".  Handles under \"0.SERV\" are managed by the GHR. For\n   example,\
    \ the service handle \"0.SERV/123\" may be created to maintain\n   the service\
    \ information for the handle service that manages handles\n   under the naming\
    \ authority \"123\" and any of its sub-naming\n   authorities.\n   Similarly,\
    \ a service handle \"0.SERV/a.b.c\" may be created to host the\n   service information\
    \ for the handle service that manages handles under\n   the naming authority \"\
    a.b.c\".\n   The use of service handles raises several special considerations.\n\
    \   Multiple levels of service handle redirection should be avoided due\n   to\
    \ their lack of efficiency, but are not signaled as an error.\n   Looped reference\
    \ of service handles or HS_SERV values that point to\n   non-existent service\
    \ handles should be caught and error conditions\n   passed back to the user.\n"
- title: '3.2.5.  Alias Handle: HS_ALIAS'
  contents:
  - "3.2.5.  Alias Handle: HS_ALIAS\n   In practice, it is very possible that a digital\
    \ object may have\n   multiple names that will identify the object.  The Handle\
    \ System\n   supports such feature via the pre-defined data type HS_ALIAS.  An\n\
    \   HS_ALIAS value is a handle value whose <type> field is HS_ALIAS and\n   whose\
    \ <data> field contains a reference to another handle.  A handle\n   with a HS_ALIAS\
    \ value is an alias handle to the handle referenced in\n   the HS_ALIAS value.\
    \  An alias handle should not have any additional\n   handle values other than\
    \ HS_ALIAS or HS_ADMIN (for administration)\n   values.  This is necessary to\
    \ prevent any inconsistency between a\n   handle and its aliases.\n   During a\
    \ handle resolution, a client may get back an HS_ALIAS value.\n   This indicates\
    \ that the handle in question is an alias handle.  The\n   client may then retry\
    \ the query against the handle specified in the\n   HS_ALIAS value until final\
    \ results are obtained.\n   The use of alias handle introduces a number of special\n\
    \   considerations.  For example, multiple levels of aliases should be\n   avoided\
    \ for the sake of efficiency, but are not signaled as an error.\n   Alias loops\
    \ and aliases that point to non-existent handles should be\n   caught and error\
    \ conditions passed back to the user.\n   One potential use of alias handle would\
    \ be to support the transfer of\n   ownership of any named resource.  When a resource\
    \ identified by a\n   handle transfers from one organization to another, a new\
    \ handle for\n   the resource may be created.  To avoid inconsistency and any\
    \ broken\n   reference, the handle used before the ownership transfer may be\n\
    \   changed into an alias handle and point its HS_ALIAS value to the\n   newly\
    \ created handle.\n"
- title: '3.2.6.  Primary Site: HS_PRIMARY'
  contents:
  - "3.2.6.  Primary Site: HS_PRIMARY\n   HS_PRIMARY is a pre-defined data type used\
    \ to designate the primary\n   service sites for any given handle.  A handle service\
    \ with multiple\n   primary service sites is called a multi-primary service. \
    \ Otherwise\n   it is called a single-primary service.  Each handle managed by\
    \ a\n   multi-primary handle service may specify its primary service sites in\n\
    \   terms of an HS_PRIMARY value.  A HS_PRIMARY value is a handle value\n   whose\
    \ <type> field is HS_PRIMARY and whose <data> field contains a\n   list of references\
    \ to HS_SITE values.  Each of these HS_SITE defines\n   a primary service site\
    \ for the handle.\n   There can be at most one HS_PRIMARY value assigned to each\
    \ handle.\n   Otherwise it is an error.  A handle with no HS_PRIMARY value but\n\
    \   managed by a multi-primary handle service is not an error.  In this\n   case,\
    \ every primary service site of the handle service will also be\n   the primary\
    \ site for the handle.  Handles managed by a single-primary\n   handle service\
    \ do not need any HS_PRIMARY values and any such values\n   should be ignored.\n"
- title: '3.2.7.  Handle Value List: HS_VLIST'
  contents:
  - "3.2.7.  Handle Value List: HS_VLIST\n   HS_VLIST is a pre-defined data type that\
    \ allows a handle value to be\n   used as a reference to a list of other handle\
    \ values.  An HS_VLIST\n   value is a handle value whose <type> is HS_VLIST and\
    \ whose <data>\n   consists of a 4-byte unsigned integer followed by a list of\n\
    \   references to other handle values.  The integer specifies the number\n   of\
    \ references in the list.  The references may refer to handle values\n   under\
    \ the same handle or handle values from any other handles.  Each\n   reference\
    \ is encoded as an UTF8-string followed by a 4-byte unsigned\n   integer that\
    \ identifies the referenced handle and its value index.\n   HS_VLIST values may\
    \ be used to define administrator groups for\n   handles.  In this case, each\
    \ reference in the HS_VLIST defines a\n   member of the administrator group and\
    \ the HS_VLIST value identifies\n   the group as a whole.  Client software must\
    \ be careful, however, to\n   avoid cyclic definition of value references.\n"
- title: 4.  Handle System Service Model
  contents:
  - "4.  Handle System Service Model\n   The Handle System is a distributed global\
    \ name service.  It consists\n   of a single distributed Global Handle Registry\
    \ (GHR) and unlimited\n   number of Local Handle Services (LHS).  These service\
    \ components\n   provide the name service (both resolution and administration)\
    \ on\n   behalf of Handle System client components.  Handle System client\n  \
    \ components may also choose to use Handle System middle-ware\n   components (e.g.,\
    \ the Handle System caching service) for efficiency.\n   This section describes\
    \ these components and their relationships to\n   each other.\n"
- title: 4.1.  Handle System Service Components
  contents:
  - "4.1.  Handle System Service Components\n   The Handle System defines a hierarchical\
    \ service model.  At the top\n   level is the single distributed global handle\
    \ service, also known as\n   the Global Handle Registry (GHR).  Underneath the\
    \ GHR, there can be\n   any number of Local Handle Services (LHSs).  Each LHS\
    \ must be\n   registered with the GHR to manage handles under a distinct set of\n\
    \   naming authorities.  Naming authorities are managed by the GHR via\n   naming\
    \ authority handles (i.e., handles under the naming authority\n   \"0.NA\"). \
    \ A naming authority handle can also be used to locate the\n   service information\
    \ (in terms of HS_SITE values) that describes the\n   handle service responsible\
    \ for handles under the naming authority.\n   From the service information, clients\
    \ can choose a service site and\n   locate the responsible server for their handle\
    \ requests.\n   Handle System service components are scalable and extensible to\n\
    \   accommodate any large amount of service load.  A handle service,\n   global\
    \ or local, may consist of multiple service sites, replicating\n   each other.\
    \  Each service site may also consist of a cluster of\n   computers working together\
    \ to serve its respective namespace. Having\n   multiple service sites avoids\
    \ any single point of failure and allows\n   load balancing among these service\
    \ sites.  Using multiple servers at\n   any service site distributes the service\
    \ load into multiple server\n   processes and allows less powerful computers to\
    \ be utilized for the\n   name service.\n"
- title: 4.1.1.  Global Handle Registry (GHR)
  contents:
  - "4.1.1.  Global Handle Registry (GHR)\n   The Global Handle Registry (GHR) is\
    \ mainly used to manage naming\n   authority handles and to provide service information\
    \ for every naming\n   authority under the Handle System.  The GHR may also be\
    \ used to\n   manage and provide resolution and administration service to non-\n\
    \   naming-authority handles.  Unlike any LHS, which mostly manages\n   handles\
    \ under a few naming authorities, the GHR is primarily used to\n   register naming\
    \ authorities and provide service information for every\n   LHS.  In other words,\
    \ the GHR is the single root service that\n   registers every LHS and provides\
    \ their service information via the\n   use of naming authority handle(s).  Every\
    \ naming authority under the\n   Handle System must be registered under the GHR\
    \ as a naming authority\n   handle.  The naming authority handle provides the\
    \ service information\n   of the handle service that manages all the handles under\
    \ the naming\n   authority.  The service information may be provided in terms\
    \ of a set\n   of HS_SITE values, or an HS_SERV value that refers to a service\n\
    \   handle, as described earlier.\n   The GHR may consist of multiple service\
    \ sites, each described in a\n   HS_SITE value.  These HS_SITE values are assigned\
    \ to the designated\n   naming authority handle \"0.NA/0.NA\", also called the\
    \ root handle. The\n   root handle is the naming authority handle that maintains\
    \ the service\n   information for GHR.  Top level naming authorities can only\
    \ be\n   created by administrators of the root handle.\n   In order to communicate\
    \ with the GHR, client software needs the GHR\n   service information beforehand.\
    \  The service information may be\n   distributed initially with the client software,\
    \ or obtained from some\n   other secure sources (e.g., postal mail, secure web\
    \ site, etc.).\n   Client software may keep the service information to communicate\
    \ with\n   the GHR until the service information becomes expired (according to\n\
    \   its TTL).  The GHR must update its service information (assigned to\n   the\
    \ root handle) every time it changes its configuration.  Client\n   software with\
    \ out-dated service information will be notified of the\n   update every time\
    \ it communicates with the GHR.  The GHR must be\n   maintained in such a way\
    \ that any client software with out-dated GHR\n   service information can still\
    \ query the root handle for the latest\n   update.\n   Fig. 4.1.1 shows the GHR\
    \ service information in terms of a set of\n   HS_SITE values.  The GHR may consist\
    \ of a number of service sites,\n   each described in a HS_SITE value.  The figure\
    \ shows a GHR service\n   site located in US East Coast, as indicated in the <AttributeList>.\n\
    \       ------------------------------------------------------------\n     ------------------------------------------------------------\
    \  |\n    -----------------------------------------------------------  | |\n \
    \  |                                                           | | |\n   |  <index>:\
    \      3                                          | | |\n   |  <type>:       HS_SITE\
    \                                    | | |\n   |  <data>:                    \
    \                              | | |\n   |    Version:          1            \
    \                        | | |\n   |    ProtocolVersion:  2.1                \
    \                  | | |\n   |    SerialNumber:     1                        \
    \            | | |\n   |    PrimaryMask:                                     \
    \      | | |\n   |            MultiPrimary:    TRUE                          |\
    \ | |\n   |            PrimarySite:     TRUE                          | | |\n\
    \   |    HashOption:       HASH_BY_HANDLE                       | | |\n   |  \
    \  HashFilter:       {empty UTF8-String}                  | | |\n   |    AttributeList:\
    \    1                                    | | |\n   |        Description:  Service\
    \ site at US East Coast        | | |\n   |    NumOfServer:      3            \
    \                        | | |\n   |                                         \
    \                  | | |\n   |        ------------------------------------------\
    \         | | |\n   |       ------------------------------------------ |     \
    \   | | |\n   |      ------------------------------------------ ||        | |\
    \ |\n   |     | ServerID:        1                       |||        | | |\n  \
    \ |     | Address:         :FFFF:132.151.2.150     |||        | | |\n   |    \
    \ | PublicKeyRecord: HS_DSAKEY, iQCuR2Rnw... |||        | | |\n   |     | ServiceInterface\
    \                         |||        | | |\n   |     |    ServiceType:       Resolution\
    \ & Admin |||        | | |\n   |     |    TransmissionProtocol: TCP & UDP    \
    \   ||         | | |\n   |     |    PortNumber:           2641            |  \
    \        | | |\n   |      ------------------------------------------         \
    \  | | |\n   |                                                           | | |\n\
    \   |  <TTL>:        24 hours                                   | | |\n   |  <permission>:\
    \ PUBLIC_READ, ADMIN_WRITE                   | | |\n   |  <reference>:  {empty}\
    \                                    | |-\n   |                              \
    \                             |-\n    -----------------------------------------------------------\n\
    \          Figure 4.1.1: GHR service information\n   The GHR and its service information\
    \ provide an entry point for any\n   client software to communicate with the Handle\
    \ System.  For any given\n   handle, client software can query the GHR for its\
    \ naming authority\n   handle.  This will return the service information of the\
    \ LHS that\n   manages every handle under the naming authority.  The service\n\
    \   information will direct the client software to the handle server\n   within\
    \ the LHS that manages the handle.\n"
- title: 4.1.2.  Local Handle Service (LHS)
  contents:
  - "4.1.2.  Local Handle Service (LHS)\n   A Local Handle Services (LHS) manages\
    \ handles under given sets of\n   naming authorities.  Each naming authority defines\
    \ a \"local\"\n   namespace that consists of all of the handles under the naming\n\
    \   authority.  Note that a LHS is not a \"local\" service in terms of any\n \
    \  network topology.  It is called a \"Local\" Handle Service because it\n   typically\
    \ manages a restricted (local) namespace.\n   A naming authority is \"homed\"\
    \ at a LHS if all handles under the\n   naming authority are managed by the LHS.\
    \  A LHS may be home to\n   multiple naming authorities.  On the other hand, a\
    \ naming authority\n   may only be \"homed\" at one LHS.  Note that a naming authority\
    \ may\n   also be homed at the GHR.\n      ------------------------------------------------------------\n\
    \     ------------------------------------------------------------  |\n    -----------------------------------------------------------\
    \  | |\n   |  <index>:      3                                          | | |\n\
    \   |  <type>:       HS_SITE                                    | | |\n   |  <data>:\
    \                                                  | | |\n   |    Version:   \
    \       1                                    | | |\n   |    ProtocolVersion: \
    \ 2.1                                  | | |\n   |    SerialNumber:     1    \
    \                                | | |\n   |    PrimaryMask:                 \
    \                          | | |\n   |            MultiPrimary:   FALSE      \
    \                    | | |\n   |            PrimarySite:    TRUE             \
    \              | | |\n   |    HashOption:       HASH_BY_LOCALNAME            \
    \        | | |\n   |    HashFilter:       {empty UTF8-String}                \
    \  | | |\n   |    AttributeList:    1                                    | | |\n\
    \   |        Description:  Local Service for \"10\"               | | |\n   |\
    \    NumOfServer:      2                                    | | |\n   |      \
    \  -----------------------------------------          | | |\n   |       -----------------------------------------\
    \ |         | | |\n   |     | ServerID:        1                       ||    \
    \     | | |\n   |     | Address:         :FFFF:132.151.3.150     ||         |\
    \ | |\n   |     | PublicKeyRecord: HS_DSAKEY, iQCuR2R...   ||         | | |\n\
    \   |     | ServiceInteface:                         ||         | | |\n   |  \
    \   |    ServiceType:     Resolution & Admin   ||         | | |\n   |     |  \
    \  TransmissionProtocol:     TCP & UDP   ||         | | |\n   |     |    PortNumber:\
    \               2641        |'         | | |\n   |      -----------------------------------------'\
    \           | | |\n   |  <TTL>:        24 hours                              \
    \     | | |\n   |  <permission>: PUBLIC_READ, ADMIN_WRITE                   |\
    \ |-\n   |  <reference>:  {empty}                                    |-\n    -----------------------------------------------------------\n\
    \               Figure 4.1.2: LHS service information\n   Like the GHR, a LHS\
    \ may also consist of many service sites with each\n   site described by an HS_SITE\
    \ value.  The set of HS_SITE values for\n   any LHS may be assigned to a service\
    \ handle or to the relevant naming\n   authority handle(s).  Fig. 4.1.2 shows\
    \ an example of HS_SITE values\n   for a LHS.  These HS_SITE values are assigned\
    \ to the naming authority\n   handle \"0.NA/10\".  This suggests that the naming\
    \ authority \"10\" is\n   \"homed\" at the LHS specified in these HS_SITE values.\
    \ Clients may\n   query the GHR to obtain the service information in order to\n\
    \   communicate with the LHS.  Administrators of the naming authority\n   handle\
    \ are responsible for maintaining the service information and\n   keeping it up\
    \ to date.\n   Note that a LHS may refer its clients to another LHS in response\
    \ to a\n   service request.  This allows the LHS to further distribute its\n \
    \  service in a hierarchical fashion.\n"
- title: 4.2.  Handle System Middle-Ware Components
  contents:
  - "4.2.  Handle System Middle-Ware Components\n   Handle System middle-ware components\
    \ currently include Handle System\n   caching servers and Handle System proxy\
    \ servers.  These Handle System\n   middle-ware components are clients to Handle\
    \ System service\n   components, but servers to Handle System client software.\
    \ Handle\n   System middle-ware components are used to provide additional\n  \
    \ interfaces to the basic handle service.  For example, a Handle System\n   caching\
    \ server may be used to share resolution results within a local\n   community.\
    \  Additionally, a Handle System proxy server can be used to\n   bypass any organizational\
    \ firewall via HTTP tunneling.\n"
- title: 4.2.1.  Handle System Caching Service
  contents:
  - "4.2.1.  Handle System Caching Service\n   Handle System caching service can be\
    \ used to reduce the network\n   traffic between Handle System clients and servers.\
    \  Caching handle\n   data, including the service information of any LHS, allows\
    \ re-use of\n   information obtained from earlier queries.\n   Each handle value\
    \ contains a <TTL> (Time to Live) field that tells a\n   caching service how long\
    \ the cached value may be regarded as valid.\n   A zero-value TTL indicates that\
    \ the value can only be used for the\n   transaction in progress and should not\
    \ be cached.  A caching service\n   may obtain its data directly from a handle\
    \ service, or from another\n   caching service that eventually gets its data from\
    \ the handle\n   service.\n   A caching service may be defined in terms of an\
    \ HS_SITE value and may\n   consist of multiple caching servers.  For any given\
    \ handle, clients\n   can find the responsible caching server within the caching\
    \ service by\n   using the same hashing algorithm as used in locating the handle\n\
    \   server within any handle service.\n   Caching services are not part of any\
    \ Handle System administration or\n   authentication hierarchy.  The Handle System\
    \ protocol does not\n   authenticate any response from a caching service.  Clients\
    \ are\n   responsible to set up their trust relationship with the caching\n  \
    \ service that they select.  They will also rely on the caching service\n   to\
    \ properly authenticate any response from any handle server.\n"
- title: 4.2.2.  Handle System Proxy Server
  contents:
  - "4.2.2.  Handle System Proxy Server\n   Handle System proxy servers can be used\
    \ to enable handle resolution\n   via other Internet protocols.  For example,\
    \ CNRI has built and made\n   available a Handle System HTTP Proxy Server that\
    \ will process any\n   handle resolution in terms of HTTP protocol.  The current\
    \ DNS address\n   for the proxy server is at \"hdl.handle.net\".  The proxy server\
    \ allows\n   any handle to be resolved via a HTTP URL.  The URL can be constructed\n\
    \   as \"http://hdl.handle.net/<handle>\", where <handle> can be any handle\n\
    \   from the Handle System.  For example, the handle\n   \"ncstrl.vatech_cs/tr-93-35\"\
    \ can be resolved via the HTTP URL\n   \"http://hdl.handle.net/ncstrl.vatech_cs/tr-93-35\"\
    \ from any web\n   browser.  In this case, the URL is sent to the proxy server\
    \ in terms\n   of a HTTP request.  The proxy server will query the Handle System\
    \ for\n   the handle data and return the results in terms of HTTP response.\n\
    \   Using HTTP URLs allows handles to be resolved from standard web\n   browsers\
    \ without any additional client software.  However, such\n   reference to the\
    \ handle also ties itself to the proxy server.  If the\n   proxy server changes\
    \ its DNS name or otherwise becomes invalid, the\n   reference (i.e., the HTTP\
    \ URL) to the handle will break.  Thus the\n   selection or use of proxy server\
    \ should be carefully evaluated.\n   Proxy servers are not part of any Handle\
    \ System administration or\n   authentication hierarchy.  The Handle System protocol\
    \ does not\n   authenticate any response from a proxy server.  Clients are\n \
    \  responsible to set up their trust relationship with the proxy server\n   that\
    \ they select.  They will also rely on the proxy server to\n   properly authenticate\
    \ any response from any handle server.\n"
- title: 4.3.  Handle System Client Components
  contents:
  - "4.3.  Handle System Client Components\n   Handle System client components are\
    \ client software that communicates\n   with the Handle System service components.\
    \  Client software may speak\n   the Handle System protocol and send its request\
    \ directly to a service\n   component.  The response from the service component\
    \ may be the final\n   answer to the request, or a referral to another service\
    \ component.\n   The client software will have to follow the referral in order\
    \ to\n   complete the transaction.\n   Client software may also be configured\
    \ to tunnel its request via a\n   middle-ware component.  The middle-ware component\
    \ will thus be\n   responsible for obtaining the final result and returning it\
    \ to the\n   client.  Unlike service components, middle-ware components will only\n\
    \   return final results of client's request.  No service referral will\n   be\
    \ returned from middle-ware components.\n   Various Handle System client components\
    \ may be developed for various\n   applications.  The CNRI Handle System Resolver\
    \ [17] is one such\n   component.  The resolver extends web browsers (e.g., Netscape\
    \ or\n   Microsoft Internet Explorer) in such a way that handles can be\n   resolved\
    \ directly in terms of \"hdl:\" Uniform Resource Identifiers\n   (URIs).  The\
    \ Grail web browser [18], a freely downloadable software\n   developed in Python\
    \ [19], also supports the \"hdl:\" URI scheme and\n   will resolve handles accordingly.\
    \  For example, the handle\n   \"10.1045/july95-arms\" may be resolved by entering\
    \ its handle URI as\n   \"hdl:10.1045/july95-arms\" into any of these resolver-enabled\n\
    \   browsers.  Details of the handle URI syntax will be specified in a\n   separate\
    \ document.\n"
- title: 5.  Handle System Operation Model
  contents:
  - "5.  Handle System Operation Model\n   Handle System operations can be categorized\
    \ into resolution and\n   administration.  Clients use the handle resolution service\
    \ to query\n   for any handle values.  Handle administration allows clients to\n\
    \   manage handles, including adding and deleting handles, and updating\n   their\
    \ values.  It also deals with naming authority administration via\n   naming authority\
    \ handles.  This section explains how various Handle\n   System components work\
    \ together to accomplish these service\n   operations.\n   Both resolution and\
    \ administration may require authentication of the\n   client.  The authentication\
    \ can be done via the Handle System\n   authentication protocol described later\
    \ in this section.  Whether\n   authentication is required or not depends on the\
    \ kind of operation\n   involved and the permissions assigned to the relevant\
    \ handle value,\n   and policies deployed by the relevant service components.\n\
    \   The Handle System protocol specifies the syntax and semantics of each\n  \
    \ message exchanged between Handle System clients and its server\n   components.\
    \  This section provides a high level overview of the\n   protocol used to accomplish\
    \ any service operation.  The exact\n   programmatic detail of each message (i.e.,\
    \ their byte layout or\n   syntax) is specified in a separate document [8].\n"
- title: 5.1.  Handle System Service Request and Response
  contents:
  - "5.1.  Handle System Service Request and Response\n   The Handle System provides\
    \ its service in response to client\n   requests.  A client may send a request\
    \ to any handle server to\n   provoke a response.  The response either provides\
    \ an answer to the\n   request, or a status code with associated information that\
    \ either\n   refers the request to another service component, asks for client\n\
    \   authentication, or signals some error status.\n   Each handle under the Handle\
    \ System is managed by its home service.\n   The naming authority handle provides\
    \ the service information (in\n   terms of HS_SERV or HS_SITE values) of the handle\
    \ service that\n   manages all handles under the naming authority.  Any handle\
    \ request\n   must be directed to the home service of the handle in question.\n\
    \   Clients may find the home service by querying the corresponding\n   naming\
    \ authority handle against the GHR.  Alternatively, this\n   information may be\
    \ found in a local cache or even be part of a local\n   client configuration.\
    \  Given the service information, clients may\n   select a service site and locate\
    \ the responsible handle server within\n   the site.\n   To resolve the handle\
    \ \"ncstrl.vatech_cs/te-93-35\", for example,\n   client software needs to know\
    \ the home service for the naming\n   authority \"ncstrl.vatech_cs\".  The home\
    \ service can be obtained by\n   querying the naming authority handle \"0.NA/ncstrl.vatech_cs\"\
    \ against\n   the GHR.  The GHR will return the service information in terms of\
    \ the\n   HS_SITE values assigned to the naming authority handle.  From the\n\
    \   service information, clients can pick a service site, find the\n   responsible\
    \ handle server within the site, and send the resolution\n   request to the handle\
    \ server.\n   Clients may require digital signatures from a handle server in order\n\
    \   to authenticate any response from the server.  The signature can be\n   generated\
    \ using the server's private key.  Clients may verify the\n   signature using\
    \ the public key available from the service information\n   (refer to the <PublicKeyRecord>\
    \ entry discussed in 3.2.2).\n   A communication session may also be established\
    \ between any client\n   and handle server.  Each session is identified by a unique\
    \ session ID\n   managed by the server.  A session may be used to manage requests\
    \ that\n   require multiple interactions.  It may also be used to share any TCP\n\
    \   connection or authentication information among multiple service\n   transactions.\
    \  Each session may establish a session key and use it to\n   authenticate any\
    \ message exchanged within the session.  It may also\n   be used to encrypt any\
    \ message between the client and the server to\n   achieve data confidentiality.\n\
    \   The following diagram shows a handle resolution process in terms of\n   messages\
    \ exchanged between client software and Handle System service\n   components.\
    \  In this case, the client is trying to resolve the handle\n   \"ncstrl.vatech_cs/tr-93-35\"\
    .  It assumes that the client has yet\n   obtained the service information of\
    \ the LHS \"homed\" by the naming\n   authority \"ncstrl.vatech.cs\".  The client\
    \ has to get the service\n   information from the naming authority handle managed\
    \ by the GHR.  The\n   service information allows the client to locate the responsible\
    \ LHS\n   and query for the handle value.\n   [HS Client]  ---------------------------->\
    \ [Global Handle Registry]\n                 1. ask for the service\n        \
    \            information from the\n                    naming authority handle\n\
    \                    \"0.NA/ncstrl.vatech_cs\"\n   [HS Client]  <----------------------------\
    \ [Global Handle Registry]\n                 2. service information for\n    \
    \                the naming authority\n                    \"ncstrl.vatech_cs\"\
    \n   [HS Client]  ----------------------------> [Local Handle Service]\n     \
    \            3. query the handle\n                    \"ncstrl.vatech_cs/tr-93-35\"\
    \n                    against the responsible\n                    handle server\n\
    \     \\... ...\n    (optional client authentication, depending on the service\
    \ request)\n     \\... ...\n   [HS Client]  <---------------------------- [Local\
    \ Handle Service]\n                  4. query result from the handle\n       \
    \              server + (optional) server\n                     signature\n  \
    \             Figure 5.1: Handle resolution example\n   In Figure 5.1, the client\
    \ is configured to communicate with the GHR\n   for any handle service.  In this\
    \ case, the client first queries the\n   GHR to find the home service for the\
    \ handle's naming authority.  The\n   GHR returns the service information of the\
    \ LHS that manages every\n   handle under the naming authority.  From the service\
    \ information, the\n   client can find the responsible handle server and query\
    \ the server\n   for the handle.  The server may set up a session to authenticate\
    \ the\n   client if any of the handle value requires authentication.\n   Otherwise,\
    \ the server will simply return the handle value to the\n   client.  The server\
    \ may send a digital signature as part of its\n   response if required by the\
    \ client.\n   The above procedure assumes that the client software already has\
    \ the\n   GHR service information.  That information was likely obtained from\n\
    \   the client software distribution.  The GHR will notify the client\n   software\
    \ if it learns that the service information used by the client\n   software is\
    \ out of date.  Client software may retrieve the latest\n   service information\
    \ from the root handle \"0.NA/0.NA\". The root handle\n   also maintains the public\
    \ key that may be used to authenticate the\n   service information.\n   Note that\
    \ a client may cache the service information of any naming\n   authority so that\
    \ subsequent queries for handles under the same\n   naming authority may reuse\
    \ the service information and bypass the\n   first two steps shown in Figure 5.1.\
    \  Client software may also be\n   configured to query a caching or proxy server\
    \ directly for any\n   handle.  In this case, the caching or proxy server will\
    \ act as the\n   [HS Client] in Figure 5.1 before returning the query result to\
    \ the\n   client.\n   Client software under certain organization may also elect\
    \ to bypass\n   the GHR and communicate directly with a LHS managed by the\n \
    \  organization.  Doing so may achieve quicker response for handles\n   managed\
    \ under the LHS.  The client software will be referred to the\n   GHR for handles\
    \ not managed by the LHS.\n"
- title: 5.2.  Handle System Authentication Protocol
  contents:
  - "5.2.  Handle System Authentication Protocol\n   The Handle System supports handle\
    \ administration over the public\n   Internet.  Access controls can be defined\
    \ on each handle value.  The\n   Handle System authentication protocol is the\
    \ protocol used by any\n   handle server to authenticate handle administrator\
    \ upon any\n   administration request.  The authentication is also necessary when\n\
    \   clients query for handle values that are read-only by the handle\n   administrator.\
    \  Handle administration include adding, deleting or\n   modifying handle values,\
    \ and adding or deleting handles.  Naming\n   authority administrations are carried\
    \ out as handle administrations\n   over the corresponding naming authority handles.\n\
    \   The Handle System authentication protocol does not perform any server\n  \
    \ authentication.  However, a client may authenticate any server\n   response\
    \ by asking the server to sign its response with digital\n   signature.\n   By\
    \ default, the Handle System authenticates clients via a challenge-\n   response\
    \ protocol.  That is, after receiving a client's request, the\n   server issues\
    \ a challenge to the client if authentication is\n   necessary.  To be authenticated\
    \ as the administrator, the client has\n   to return a challenge-response, a message\
    \ that demonstrates\n   procession of the administrator's secret. The secret may\
    \ be the\n   private key or the secret key of the administrator.  This challenge-\n\
    \   response allows the server to authenticate the client as the handle\n   administrator.\
    \  Upon successful authentication, the server will\n   fulfill the client's request\
    \ if the administrator is given sufficient\n   permission.\n   For example, suppose\
    \ a client sends a request to the handle server to\n   add a new handle value.\
    \  The server will issue a challenge to the\n   client in order to authenticate\
    \ the client as one of the handle\n   administrators.  If the client possesses\
    \ the private key of the\n   administrator, she can use it to sign the server's\
    \ challenge and\n   return the signature as part of her challenge-response.  The\
    \ server\n   will validate the signature in order to authenticate the client.\
    \ The\n   client will be notified if the validation fails.  Otherwise, the\n \
    \  server will further check if the administrator has the permission to\n   add\
    \ the handle value.  If so, the server will add the handle value\n   and report\
    \ success to the client.  Otherwise, a permission-denied\n   message will be returned.\n\
    \   The following diagram shows a typical authentication process in terms\n  \
    \ of the messages exchanged between the client and the handle server.\n     [Client]\
    \  -------------------------------->  [Handle Server]\n                 1. client\
    \ request\n                  + (optional) client credential\n     [Client]  <--------------------------------\
    \  [Handle Server]\n                 2. server's challenge to client\n       \
    \           + (i.e., nonce + MD5 of client request)\n     [Client]  ------------------------------->\
    \   [Handle Server]\n                 3. reference to handle administrator\n \
    \                 + challenge-response from client\n     [Client]  <-------------------------------\
    \   [Handle Server]\n                 4. server acknowledgement\n           Figure\
    \ 5.2: Handle System authentication process\n   In Figure 5.2, the client sends\
    \ an administration request to the\n   handle server (along with optional credential\
    \ discussed later).  The\n   server decides that client authentication is required\
    \ and issues a\n   challenge to the client.  The client identifies itself as a\
    \ handle\n   administrator and returns the challenge-response to the server. \
    \ The\n   server authenticates the client as the administrator based on the\n\
    \   challenge-response.  It also checks to see if the administrator is\n   authorized\
    \ for the administration request.  If so, the server will\n   fulfill the request\
    \ and acknowledge the client.\n   Handle servers must authenticate the client\
    \ before fulfilling any\n   request that requires administrator privilege.  The\
    \ exact\n   authentication process varies depending on whether public key or\n\
    \   secret key is used by the administrator.  It also depends on whether\n   the\
    \ handle used to store the administrator's key is managed by the\n   same handle\
    \ server or not.\n   When public key is used, the challenge-response from the\
    \ client\n   contains its digital signature over the server's challenge.  The\n\
    \   server can authenticate the client by verifying the digital signature\n  \
    \ based on the administrator's public key.  If secret key is used, the\n   challenge-response\
    \ from the client carries the Message Authenticate\n   Code (MAC) generated using\
    \ the secret key.  The server may\n   authenticate the client by generating the\
    \ same MAC using the\n   administrator's secret key and comparing it against the\
    \ challenge-\n   response.\n   The reference to handle administrator in Fig 5.2\
    \ is also called a\n   key-reference.  It refers to a handle value that contains\
    \ the key\n   used by the administrator.  If the key-reference is managed by the\n\
    \   same handle server (e.g., a handle value assigned to the same\n   handle),\
    \ the server may use the key directly to do the\n   authentication.  If the key-reference\
    \ is managed by some other handle\n   server (whether or not within the same handle\
    \ service), the server\n   will have to send a verification-request to this other\
    \ handle server,\n   call it the key-server, in order to authenticate the client.\
    \  The\n   verification-request to the key-server carries both the server's\n\
    \   challenge and the client's challenge-response.  The key-server will\n   return\
    \ a verification-response, signed using the key-server's private\n   key.  The\
    \ content of the verification-response will depend on the\n   handle value referenced\
    \ by the key-reference.  If the key-reference\n   refers to a public key used\
    \ by the administrator, the verification-\n   response will contain the public\
    \ key of the administrator.\n   Otherwise, the key-server will verify the challenge-response\
    \ on\n   behalf of the requesting server and return the result in the\n   verification-response.\
    \  The following diagram shows the control flow\n   of the authentication process\
    \ where the key-reference refers to a\n   handle value that contains the administrator's\
    \ public (or secret) key\n   and the key-server is some other handle server.\n\
    \      --------                                     -------------\n     |    \
    \    |   1. client request.              |             |\n     |        | ------------------------------->\
    \  |             |\n     |        |                                   |      \
    \       |\n     |        |   2.  session ID                  |             |\n\
    \     |        |     + server's challenge          |             |\n     | Handle\
    \ | <-------------------------------  | Handle      |\n     | System |       \
    \                            | server      |\n     | client |   3.  session ID\
    \                  | receiving   |\n     |        |     + response to the challenge\
    \   | client      |\n     |        |     + administrator reference     | request\
    \     |\n     |        | --------------------------------> |             |\n \
    \    |        |                                   |             |\n     |    \
    \    |   6.  server acknowledgement      |             |\n     |        | <-------------------------------\
    \  |             |\n      --------                                     -------------\n\
    \                                                       |  ^\n               \
    \                        4. Verification |  | 5. verifi-\n                   \
    \                       request      |  |    cation\n                        \
    \                               |  |    response\n                           \
    \                            |  |    (signed)\n                              \
    \                         V  |\n                                            --------------------------\n\
    \                                           | The handle server (the   |\n   \
    \                                        | key-server) that manages |\n      \
    \                                     | the key referenced by    |\n         \
    \                                  | the key-reference        |\n            \
    \                                --------------------------\n          Figure\
    \ 5.3: Authentication process requiring verification\n                      from\
    \ a second handle server\n   Secret key based authentication via a second handle\
    \ server, i.e., the\n   key server, provides a convenient way to share a common\
    \ secret key\n   (e.g., pass phrase) among handles managed by different handle\n\
    \   servers.  However, it should not be used to manage highly sensitive\n   handles\
    \ or handle data.  The authentication process itself is\n   expensive and relies\
    \ on a third party, i.e., the key-server, for\n   proper operation.  Additionally,\
    \ the secret key itself is subject to\n   dictionary attack since the key-server\
    \ cannot determine whether the\n   verification-request comes from a legitimate\
    \ handle server.  A handle\n   service may set its local policy so that secret\
    \ key based\n   authentication can only be carried out if the handle server\n\
    \   (receiving the client request) is also the key-server.\n   Local handle services\
    \ may define additional local policies for\n   authentication and/or authorization.\
    \  Handle System service\n   components may also choose to use other Internet\
    \ authentication\n   mechanisms such as Kerberos [20] or some Transport Layer\
    \ Security\n   protocol [21].  Details of these will be addressed in a separate\n\
    \   document.\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   Handle System security considerations are discussed\
    \ in the \"Handle\n   System Overview\" [1] and that discussion applies equally\
    \ to this\n   document.\n   The Handle System delegates handle administration\
    \ to each handle\n   administrator who may or may not be the server administrator.\
    \  Handle\n   administrators are allowed to choose their own public/secret keys\n\
    \   used for authentication.  The security of Handle System\n   authentication\
    \ depends on the proper key selection and its\n   maintenance by the handle administrator.\
    \  Handle administrators must\n   choose and protect their authentication keys\
    \ carefully in order to\n   protect the handle data.  Handle server implementations\
    \ may deploy\n   policies that regulate the selection of public/secret keys used\
    \ for\n   authentication.  For example, a handle server may require that any\n\
    \   authentication key must be no less than certain number of bits.  It\n   may\
    \ also prohibit the use of secret keys because of the potential\n   dictionary\
    \ attack.\n   The Handle System data model supports execution permission\n   (PUBLIC_EXECUTE,\
    \ ADMIN_EXECUTE) for each handle value.  While this\n   allows better sharing\
    \ of network resources, it also raises many\n   security considerations.  Execution\
    \ privilege should be restricted\n   within the permissions of certain user account\
    \ (corresponding to the\n   handle administrator) on the server to prevent system-wide\n\
    \   disruption.  Switching between computing platforms for the server\n   should\
    \ also be careful to avoid any unexpected behavior.\n   Implementations may choose\
    \ not to support the execution permission,\n   or provide options so that it can\
    \ be disabled.\n   To protect against any irresponsible use of system resource,\
    \ handle\n   servers may implement quota control.  The quota control can be used\n\
    \   to put limits on the number of handles under a naming authority, the\n   number\
    \ of handle values allowed for any given handle, the maximum\n   size of any handle\
    \ value, and the number of sub-naming authorities\n   under a naming authority.\
    \  Handle servers must report error if the\n   result of a handle administration\
    \ violates any of these limits.\n"
- title: 7.  Acknowledgements
  contents:
  - "7.  Acknowledgements\n   This work is derived from the earlier versions of the\
    \ Handle System\n   implementation. The overall digital object architecture, including\n\
    \   the Handle System, was described in a paper by Robert Kahn and Robert\n  \
    \ Wilensky [22] in 1995. Development continued at CNRI as part of the\n   Computer\
    \ Science Technical Reports (CSTR) project, funded by the\n   Defense Advanced\
    \ Projects Agency (DARPA) under Grant Number MDA-972-\n   92-J-1029 and MDA-972-99-1-0018.\
    \  Design ideas are based on those\n   discussed within the Handle System development\
    \ team, including David\n   Ely, Charles Orth, Allison Yu, Sean Reilly, Jane Euler,\
    \ Catherine\n   Rey, Stephanie Nguyen, Jason Petrone, and Helen She.  Their\n\
    \   contributions to this work are gratefully acknowledged.\n   The authors also\
    \ thank Russ Housley (housley@vigilsec.com), Ted\n   Hardie (hardie@qualcomm.com),\
    \ and Mark Baugher (mbaugher@cisco.com)\n   for their extensive review and comments,\
    \ as well as recommendations\n   received from other members of the IETF/IRTF\
    \ community.\n"
- title: 8.  References and Bibliography
  contents:
  - "8.  References and Bibliography\n   [1]  Sun, S. and L. Lannom, \"Handle System\
    \ Overview\", RFC 3650,\n        November 2003.\n   [2]  Mockapetris, P., \"Domain\
    \ Names - Concepts and Facilities,\" STD\n        13, RFC 1034, November 1987.\n\
    \   [3]  Mockapetris, P., \"Domain Names - Implementation and\n        Specification\"\
    , STD 13, RFC 1035, November 1987.\n   [4]  Wahl, M., Howes, T. and S. Kille,\
    \ \"Lightweight Directory Access\n        Protocol (v3)\", RFC 2251, December\
    \ 1997.\n   [5]  Crocker, D., Ed. and  P. Overell, \"Augmented BNF for Syntax\n\
    \        Specifications: ABNF\", RFC 2234, November 1997.\n   [6]  Yergeau, F.,\
    \ \"UTF-8, A Transform Format for Unicode and\n        ISO10646\", RFC 2279, January\
    \ 1998.\n   [7]  The Unicode Consortium, \"The Unicode Standard, Version 2.0\"\
    ,\n        Addison-Wesley Developers Press, 1996.  ISBN 0-201-48345-9\n   [8]\
    \  Sun, S., Reilly, S. and L. Lannom, \"Handle System Protocol (ver\n        2.1)\
    \ Specification\", RFC 3652, November 2003.\n   [9]  Berners-Lee, T., Masinter,\
    \ L. and M. McCahill, \"Uniform Resource\n        Locators (URL)\", RFC 1738,\
    \ December 1994.\n   [10] Housley, R., Polk, W. Ford, W. and D. Solo, \"Internet\
    \ X.509\n        Public Key Infrastructure - Certificate and Certificate\n   \
    \     Revocation List (CRL) Profile\", RFC 3280, April 2002.\n   [11] Federal\
    \ Information Processing Standards Publication (FIPS PUB)\n        46-1, Data\
    \ Encryption Standard, Reaffirmed 1988 January 22\n        (supersedes FIPS PUB\
    \ 46, 1977 January 15).\n   [12] Federal Information Processing Standards Publication\
    \ (FIPS PUB)\n        81, DES Modes of Operation, 1980 December 2.\n   [13] Balenson,\
    \ D., \"Privacy Enhancement for Internet Electronic Mail:\n        Part III: Algorithms,\
    \ Modes, and Identifiers\", RFC 1423,\n        February 1993.\n   [14] Rivest,\
    \ R., \"The MD5 Message-Digest Algorithm\", RFC 1321, April\n        1992.\n \
    \  [15] Deering, S. and R. Hinden, \"Internet Protocol, Version 6 (IPv6)\n   \
    \     Specification\", RFC 1883, December 1995.\n   [16] Hinden, R. and S. Deering,\
    \ \"IP Version 6 Addressing\n        Architecture\", RFC 2373, July 1998.\n  \
    \ [17] CNRI Handle System Resolver, http://www.handle.net/resolver\n   [18] Grail\
    \ browser home page, http://grail.sourceforge.net/\n   [19] Python language website,\
    \ http://www.python.org/\n   [20] Kohl, J. and C. Neuman, \"The Kerberos Network\
    \ Authentication\n        Service (V5)\", RFC 1510, September 1993.\n   [21] Dierks,\
    \ T. and C. Allen, \"The TLS Protocol Version 1.0\", RFC\n        2246, January\
    \ 1999.\n   [22] R. Kahn, R. Wilensky, \"A Framework for Distributed Digital\n\
    \        Object Services, May 1995, http://www.cnri.reston.va.us/k-w.html\n  \
    \ [23] American National Standards Institute.  ANSI X9.52-1998, Triple\n     \
    \   Data Encryption Algorithm Modes of Operation. 1998.\n"
- title: 9.  Authors' Addresses
  contents:
  - "9.  Authors' Addresses\n   Sam X. Sun\n   Corporation for National Research Initiatives\
    \ (CNRI)\n   1895 Preston White Dr., Suite 100\n   Reston, VA 20191\n   Phone:\
    \ 703-262-5316\n   EMail: ssun@cnri.reston.va.us\n   Sean Reilly\n   Corporation\
    \ for National Research Initiatives (CNRI)\n   1895 Preston White Dr., Suite 100\n\
    \   Reston, VA 20191\n   Phone: 703-620-8990\n   EMail: sreilly@cnri.reston.va.us\n\
    \   Larry Lannom\n   Corporation for National Research Initiatives (CNRI)\n  \
    \ 1895 Preston White Dr., Suite 100\n   Reston, VA 20191\n   Phone: 703-620-8990\n\
    \   EMail: llannom@cnri.reston.va.us\n"
- title: 10.  Full Copyright Statement
  contents:
  - "10.  Full Copyright Statement\n   Copyright (C) The Internet Society (2003).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assignees.\n\
    \   This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
