- title: __initial_text__
  contents:
  - '     An Architecture for Network Management Using NETCONF and YANG

    '
- title: Abstract
  contents:
  - "Abstract\n   The Network Configuration Protocol (NETCONF) gives access to native\n\
    \   capabilities of the devices within a network, defining methods for\n   manipulating\
    \ configuration databases, retrieving operational data,\n   and invoking specific\
    \ operations.  YANG provides the means to define\n   the content carried via NETCONF,\
    \ both data and operations.  Using\n   both technologies, standard modules can\
    \ be defined to give\n   interoperability and commonality to devices, while still\
    \ allowing\n   devices to express their unique capabilities.\n   This document\
    \ describes how NETCONF and YANG help build network\n   management applications\
    \ that meet the needs of network operators.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc6244.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n   This document\
    \ may contain material from IETF Documents or IETF\n   Contributions published\
    \ or made publicly available before November\n   10, 2008.  The person(s) controlling\
    \ the copyright in some of this\n   material may not have granted the IETF Trust\
    \ the right to allow\n   modifications of such material outside the IETF Standards\
    \ Process.\n   Without obtaining an adequate license from the person(s) controlling\n\
    \   the copyright in such materials, this document may not be modified\n   outside\
    \ the IETF Standards Process, and derivative works of it may\n   not be created\
    \ outside the IETF Standards Process, except to format\n   it for publication\
    \ as an RFC or to translate it into languages other\n   than English.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Origins of NETCONF and YANG  . . . . . . . . . . .\
    \ . . . . . .  4\n   2.  Elements of the Architecture . . . . . . . . . . . .\
    \ . . . . .  5\n     2.1.  NETCONF  . . . . . . . . . . . . . . . . . . . . .\
    \ . . . .  5\n       2.1.1.  NETCONF Transport Mappings . . . . . . . . . . .\
    \ . . .  7\n     2.2.  YANG . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . .  8\n       2.2.1.  Constraints  . . . . . . . . . . . . . . . . . . . .\
    \ . 10\n       2.2.2.  Flexibility  . . . . . . . . . . . . . . . . . . . . .\
    \ 11\n       2.2.3.  Extensibility Model  . . . . . . . . . . . . . . . . . 12\n\
    \     2.3.  YANG Translations  . . . . . . . . . . . . . . . . . . . . 13\n  \
    \     2.3.1.  YIN  . . . . . . . . . . . . . . . . . . . . . . . . . 13\n    \
    \   2.3.2.  DSDL (RELAX NG)  . . . . . . . . . . . . . . . . . . . 14\n     2.4.\
    \  YANG Types . . . . . . . . . . . . . . . . . . . . . . . . 14\n     2.5.  IETF\
    \ Guidelines  . . . . . . . . . . . . . . . . . . . . . 14\n   3.  Working with\
    \ YANG  . . . . . . . . . . . . . . . . . . . . . . 14\n     3.1.  Building NETCONF-\
    \ and YANG-Based Solutions . . . . . . . . 14\n     3.2.  Addressing Operator\
    \ Requirements . . . . . . . . . . . . . 16\n     3.3.  Roles in Building Solutions\
    \  . . . . . . . . . . . . . . . 18\n       3.3.1.  Modeler  . . . . . . . . .\
    \ . . . . . . . . . . . . . . 19\n       3.3.2.  Reviewer . . . . . . . . . .\
    \ . . . . . . . . . . . . . 19\n       3.3.3.  Device Developer . . . . . . .\
    \ . . . . . . . . . . . . 19\n       3.3.4.  Application Developer  . . . . .\
    \ . . . . . . . . . . . 20\n   4.  Modeling Considerations  . . . . . . . . .\
    \ . . . . . . . . . . 22\n     4.1.  Default Values . . . . . . . . . . . . .\
    \ . . . . . . . . . 22\n     4.2.  Compliance . . . . . . . . . . . . . . . .\
    \ . . . . . . . . 23\n     4.3.  Data Distinctions  . . . . . . . . . . . . .\
    \ . . . . . . . 24\n       4.3.1.  Background . . . . . . . . . . . . . . . .\
    \ . . . . . . 24\n       4.3.2.  Definitions  . . . . . . . . . . . . . . . .\
    \ . . . . . 25\n       4.3.3.  Implications . . . . . . . . . . . . . . . . .\
    \ . . . . 27\n     4.4.  Direction  . . . . . . . . . . . . . . . . . . . . .\
    \ . . . 27\n   5.  Security Considerations  . . . . . . . . . . . . . . . . .\
    \ . . 28\n   6.  References . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . 28\n     6.1.  Normative References . . . . . . . . . . . . . . . . . . .\
    \ 28\n     6.2.  Informative References . . . . . . . . . . . . . . . . . . 29\n"
- title: 1.  Origins of NETCONF and YANG
  contents:
  - "1.  Origins of NETCONF and YANG\n   Networks are increasing in complexity and\
    \ capacity, as well as the\n   density of the services deployed upon them.  Uptime,\
    \ reliability, and\n   predictable latency requirements drive the need for automation.\
    \  The\n   problems with network management are not simple.  They are complex\n\
    \   and intricate.  But these problems must be solved for networks to\n   meet\
    \ the stability needs of existing services while incorporating new\n   services\
    \ in a world where the growth of networks is exhausting the\n   supply of qualified\
    \ networking engineers.\n   In June of 2002, the Internet Architecture Board (IAB)\
    \ held a\n   workshop on Network Management [RFC3535].  The members of this\n\
    \   workshop made a number of observations and recommendations for the\n   IETF's\
    \ consideration concerning the issues operators were facing in\n   their network\
    \ management-related work as well as issues they were\n   having with the direction\
    \ of the IETF activities in this area.\n   The output of this workshop was focused\
    \ on current problems.  The\n   observations were reasonable and straightforward,\
    \ including the need\n   for transactions, rollback, low implementation costs,\
    \ and the ability\n   to save and restore the device's configuration data.  Many\
    \ of the\n   observations give insight into the problems operators were having\n\
    \   with existing network management solutions, such as the lack of full\n   coverage\
    \ of device capabilities and the ability to distinguish\n   between configuration\
    \ data and other types of data.\n   Based on these directions, the NETCONF working\
    \ group was formed and\n   the Network Configuration (NETCONF) protocol was created.\
    \  This\n   protocol defines a simple mechanism where network management\n   applications,\
    \ acting as clients, can invoke operations on the\n   devices, which act as servers.\
    \  The NETCONF specification [RFC4741]\n   defines a small set of operations,\
    \ but goes out of its way to avoid\n   making any requirements on the data carried\
    \ in those operations,\n   preferring to allow the protocol to carry any data.\
    \  This \"data model\n   agnostic\" approach allows data models to be defined\
    \ independently.\n   But lacking a means of defining data models, the NETCONF\
    \ protocol was\n   not usable for standards-based work.  Existing data modeling\n\
    \   languages such as the XML Schema Definition (XSD) [W3CXSD] and the\n   Document\
    \ Schema Definition Languages (DSDL) [ISODSDL] were\n   considered, but were rejected\
    \ because of the problem that domains\n   have little natural overlap.  Defining\
    \ a data model or protocol that\n   is encoded in XML is a distinct problem from\
    \ defining an XML\n   document.  The use of NETCONF operations places requirements\
    \ on the\n   data content that are not shared with the static document problem\n\
    \   domain addressed by schema languages like XSD or RELAX NG.\n   In 2007 and\
    \ 2008, the issue of a data modeling language for NETCONF\n   was discussed in\
    \ the OPS and APP areas of IETF 70 and 71, and a\n   design team was tasked with\
    \ creating a requirements document [RCDML].\n   After discussing the available\
    \ options at the CANMOD BoF at IETF 71,\n   the community wrote a charter for\
    \ the NETMOD working group.  An\n   excellent description of this time period\
    \ is available at\n   <http://www.ietf.org/mail-archive/web/ietf/current/msg51644.html>.\n\
    \   In 2008 and 2009, the NETMOD working group produced a specification\n   for\
    \ YANG [RFC6020] as a means for defining data models for NETCONF,\n   allowing\
    \ both standard and proprietary data models to be published in\n   a form that\
    \ is easily digestible by human readers and satisfies many\n   of the issues raised\
    \ in the IAB NM workshop.  This brings NETCONF to\n   a point where is can be\
    \ used to develop standard data models within\n   the IETF.\n   YANG allows a\
    \ modeler to create a data model, to define the\n   organization of the data in\
    \ that model, and to define constraints on\n   that data.  Once published, the\
    \ YANG module acts as a contract\n   between the client and server, with both\
    \ parties understanding how\n   their peer will expect them to behave.  A client\
    \ knows how to create\n   valid data for the server, and knows what data will\
    \ be sent from the\n   server.  A server knows the rules that govern the data\
    \ and how it\n   should behave.\n   YANG also incorporates a level of extensibility\
    \ and flexibility not\n   present in other model languages.  New modules can augment\
    \ the data\n   hierarchies defined in other modules, seamlessly adding data at\n\
    \   appropriate places in the existing data organization.  YANG also\n   allows\
    \ new statements to be defined, allowing the language itself to\n   be expanded\
    \ in a consistent way.\n   This document presents an architecture for YANG, describing\
    \ how YANG-\n   related technologies work and how solutions built on them can\
    \ address\n   the network management problem domain.\n"
- title: 2.  Elements of the Architecture
  contents:
  - '2.  Elements of the Architecture

    '
- title: 2.1.  NETCONF
  contents:
  - "2.1.  NETCONF\n   NETCONF defines an XML-based remote procedure call (RPC) mechanism\n\
    \   that leverages the simplicity and availability of high-quality XML\n   parsers.\
    \  XML gives a rich, flexible, hierarchical, standard\n   representation of data\
    \ that matches the needs of networking devices.\n   NETCONF carries configuration\
    \ data and operations as requests and\n   replies using RPCs encoded in XML over\
    \ a connection-oriented\n   transport.\n   XML's hierarchical data representation\
    \ allows complex networking data\n   to be rendered in a natural way.  For example,\
    \ the following\n   configuration places interfaces in OSPF areas.  The <ospf>\
    \ element\n   contains a list of <area> elements, each of which contain a list\
    \ of\n   <interface> elements.  The <name> element identifies the specific\n \
    \  area or interface.  Additional configuration for each area or\n   interface\
    \ appears directly inside the appropriate element.\n         <ospf xmlns=\"http://example.org/netconf/ospf\"\
    >\n           <area>\n             <name>0.0.0.0</name>\n             <interface>\n\
    \               <name>ge-0/0/0.0</name>\n               <!-- The priority for\
    \ this interface -->\n               <priority>30</priority>\n               <metric>100</metric>\n\
    \               <dead-interval>120</dead-interval>\n             </interface>\n\
    \             <interface>\n               <name>ge-0/0/1.0</name>\n          \
    \     <metric>140</metric>\n             </interface>\n           </area>\n  \
    \         <area>\n             <name>10.1.2.0</name>\n             <interface>\n\
    \               <name>ge-0/0/2.0</name>\n               <metric>100</metric>\n\
    \             </interface>\n             <interface>\n               <name>ge-0/0/3.0</name>\n\
    \               <metric>140</metric>\n               <dead-interval>120</dead-interval>\n\
    \             </interface>\n           </area>\n         </ospf>\n   NETCONF includes\
    \ mechanisms for controlling configuration datastores.\n   Each datastore is a\
    \ specific collection of configuration data that\n   can be used as source or\
    \ target of the configuration-related\n   operations.  The device can indicate\
    \ whether it has a distinct\n   \"startup\" configuration datastore, whether the\
    \ current or \"running\"\n   datastore is directly writable, or whether there\
    \ is a \"candidate\"\n   configuration datastore where configuration changes can\
    \ be made that\n   will not affect the device until a \"commit-configuration\"\
    \ operation\n   is invoked.\n   NETCONF defines operations that are invoked as\
    \ RPCs from the client\n   (the application) to the server (running on the device).\
    \  The\n   following table lists some of these operations:\n   +---------------+---------------------------------------------------+\n\
    \   | Operation     | Description                                       |\n  \
    \ +---------------+---------------------------------------------------+\n   |\
    \ commit        | Commit the \"candidate\" configuration to \"running\" |\n  \
    \ | copy-config   | Copy one configuration datastore to another       |\n   |\
    \ delete-config | Delete a configuration datastore                  |\n   | edit-config\
    \   | Change the contents of a configuration datastore  |\n   | get-config   \
    \ | Retrieve all or part of a configuration datastore |\n   | lock          |\
    \ Prevent changes to a datastore from another party |\n   | unlock        | Release\
    \ a lock on a datastore                     |\n   +---------------+---------------------------------------------------+\n\
    \   NETCONF's \"capability\" mechanism allows the device to announce the\n   set\
    \ of capabilities that the device supports, including protocol\n   operations,\
    \ datastores, data models, and other abilities.  These are\n   announced during\
    \ session establishment as part of the <hello>\n   message.  A client can inspect\
    \ the hello message to determine what\n   the device is capable of and how to\
    \ interact with the device to\n   perform the desired tasks.\n   NETCONF also\
    \ defines a means of sending asynchronous notifications\n   from the server to\
    \ the client, described in [RFC5277].\n   In addition, NETCONF can fetch state\
    \ data, receive notifications, and\n   invoke additional RPC methods defined as\
    \ part of a capability.\n   Complete information about NETCONF can be found in\
    \ [RFC4741].\n"
- title: 2.1.1.  NETCONF Transport Mappings
  contents:
  - "2.1.1.  NETCONF Transport Mappings\n   NETCONF can run over any transport protocol\
    \ that meets the\n   requirements defined in RFC 4741, including\n   o  connection-oriented\
    \ operation\n   o  authentication\n   o  integrity\n   o  confidentiality\n  \
    \ [RFC4742] defines a mapping for the Secure Shell (SSH) [RFC4251]\n   protocol,\
    \ which is the mandatory transport protocol.  Others include\n   SOAP [RFC4743],\
    \ the Blocks Extensible Exchange Protocol (BEEP)\n   [RFC4744], and Transport\
    \ Layer Security (TLS) [RFC5539].\n"
- title: 2.2.  YANG
  contents:
  - "2.2.  YANG\n   YANG is a data modeling language for NETCONF.  It allows the\n\
    \   description of hierarchies of data nodes (\"nodes\") and the\n   constraints\
    \ that exist among them.  YANG defines data models and how\n   to manipulate those\
    \ models via NETCONF protocol operations.\n   Each YANG module defines a data\
    \ model, uniquely identified by a\n   namespace URI.  These data models are extensible\
    \ in a manner that\n   allows tight integration of standard data models and proprietary\
    \ data\n   models.  Models are built from organizational containers, lists of\n\
    \   data nodes, and data-node-forming leafs of the data tree.\n       module example-ospf\
    \ {\n           namespace \"http://example.org/netconf/ospf\";\n           prefix\
    \ ospf;\n           import network-types {  // Access another module's def'ns\n\
    \               prefix nett;\n           }\n           container ospf {   // Declare\
    \ the top-level tag\n               list area {    // Declare a list of \"area\"\
    \ nodes\n                   key name;  // The key \"name\" identifies list members\n\
    \                   leaf name {\n                       type nett:area-id;\n \
    \                  }\n                   list interface {\n                  \
    \     key name;\n                       leaf name {\n                        \
    \   type nett:interface-name;\n                       }\n                    \
    \   leaf priority {\n                           description \"Designated router\
    \ priority\";\n                           type uint8;  // The type is a constraint\
    \ on\n                                        // valid values for \"priority\"\
    .\n                       }\n                       leaf metric {\n          \
    \                 type uint16 {\n                               range 1..65535;\n\
    \                           }\n                       }\n                    \
    \   leaf dead-interval {\n                           units seconds;\n        \
    \                   type uint16 {\n                               range 1..65535;\n\
    \                           }\n                       }\n                   }\n\
    \               }\n           }\n       }\n   A YANG module defines a data model\
    \ in terms of the data, its\n   hierarchical organization, and the constraints\
    \ on that data.  YANG\n   defines how this data is represented in XML and how\
    \ that data is used\n   in NETCONF operations.\n   The following table briefly\
    \ describes some common YANG statements:\n   +--------------+----------------------------------------------------+\n\
    \   | Statement    | Description                                        |\n  \
    \ +--------------+----------------------------------------------------+\n   |\
    \ augment      | Extends existing data hierarchies                  |\n   | choice\
    \       | Defines mutually exclusive alternatives            |\n   | container\
    \    | Defines a layer of the data hierarchy              |\n   | extension  \
    \  | Allows new statements to be added to YANG          |\n   | feature      |\
    \ Indicates parts of the model that are optional     |\n   | grouping     | Groups\
    \ data definitions into reusable sets         |\n   | key          | Defines the\
    \ key leafs for lists                    |\n   | leaf         | Defines a leaf\
    \ node in the data hierarchy          |\n   | leaf-list    | A leaf node that\
    \ can appear multiple times         |\n   | list         | A hierarchy that can\
    \ appear multiple times         |\n   | notification | Defines notification  \
    \                             |\n   | rpc          | Defines input and output\
    \ parameters for an RPC     |\n   |              | operation                 \
    \                         |\n   | typedef      | Defines a new type          \
    \                       |\n   | uses         | Incorporates the contents of a\
    \ \"grouping\"          |\n   +--------------+----------------------------------------------------+\n"
- title: 2.2.1.  Constraints
  contents:
  - "2.2.1.  Constraints\n   YANG allows the modeler to add constraints to the data\
    \ model to\n   prevent impossible or illogical data.  These constraints give clients\n\
    \   information about the data being sent from the device, and also allow\n  \
    \ the client to know as much as possible about the data the device will\n   accept,\
    \ so the client can send correct data.  These constraints apply\n   to configuration\
    \ data, but can also be used for rpc and notification\n   data.\n   The principal\
    \ constraint is the \"type\" statement, which limits the\n   contents of a leaf\
    \ node to that of the named type.  The following\n   table briefly describes some\
    \ other common YANG constraints:\n   +--------------+----------------------------------------------------+\n\
    \   | Statement    | Description                                        |\n  \
    \ +--------------+----------------------------------------------------+\n   |\
    \ length       | Limits the length of a string                      |\n   | mandatory\
    \    | Requires the node appear                           |\n   | max-elements\
    \ | Limits the number of instances in a list           |\n   | min-elements |\
    \ Limits the number of instances in a list           |\n   | must         | XPath\
    \ expression must be true                      |\n   | pattern      | Regular\
    \ expression must be satisfied               |\n   | range        | Value must\
    \ appear in range                         |\n   | reference    | Value must appear\
    \ elsewhere in the data            |\n   | unique       | Value must be unique\
    \ within the data               |\n   | when         | Node is only present when\
    \ XPath expression is true |\n   +--------------+----------------------------------------------------+\n\
    \   The \"must\" and \"when\" statements use XPath [W3CXPATH] expressions to\n\
    \   specify conditions that are semantically evaluated against the data\n   hierarchy,\
    \ but neither the client nor the server are required to\n   implement the XPath\
    \ specification.  Instead they can use any means to\n   ensure these conditions\
    \ are met.\n"
- title: 2.2.2.  Flexibility
  contents:
  - "2.2.2.  Flexibility\n   YANG uses the \"union\" type and the \"choice\" and \"\
    feature\" statements\n   to give modelers flexibility in defining their data models.\
    \  The\n   \"union\" type allows a single leaf to accept multiple types, like\
    \ an\n   integer or the word \"unbounded\":\n     type union {\n         type\
    \ int32;\n         type enumeration {\n             enum \"unbounded\";\n    \
    \     }\n     }\n   The \"choice\" statement lists a set of mutually exclusive\
    \ nodes, so a\n   valid configuration can choose any one node (or case).  The\
    \ \"feature\"\n   statement allows the modeler to identify parts of the model\
    \ that can\n   be optional, and allows the device to indicate whether it implements\n\
    \   these optional portions.\n   The \"deviation\" statement allows the device\
    \ to indicate parts of a\n   YANG module that the device does not faithfully implement.\
    \  While\n   devices are encouraged to fully abide according to the contract\n\
    \   presented in the YANG module, real-world situations may force the\n   device\
    \ to break the contract.  Deviations give a means of declaring\n   this limitation,\
    \ rather than leaving it to be discovered via run-time\n   errors.\n"
- title: 2.2.3.  Extensibility Model
  contents:
  - "2.2.3.  Extensibility Model\n   XML includes the concept of namespaces, allowing\
    \ XML elements from\n   different sources to be combined in the same hierarchy\
    \ without\n   risking collision.  YANG modules define content for specific\n \
    \  namespaces, but one module may augment the definition of another\n   module,\
    \ introducing elements from that module's namespace into the\n   first module's\
    \ hierarchy.\n   Since one module can augment another module's definition, hierarchies\n\
    \   of definitions are allowed to grow, as definitions from multiple\n   sources\
    \ are added to the base hierarchy.  These augmentations are\n   qualified using\
    \ the namespace of the source module, helping to avoid\n   issues with name conflicts\
    \ as the modules change over time.\n   For example, if the above OSPF configuration\
    \ were the standard, a\n   vendor module may augment this with vendor-specific\
    \ extensions.\n       module vendorx-ospf {\n           namespace \"http://vendorx.example.com/ospf\"\
    ;\n           prefix vendorx;\n           import example-ospf {\n            \
    \   prefix ospf;\n           }\n           augment /ospf:ospf/ospf:area/ospf:interfaces\
    \ {\n               leaf no-neighbor-down-notification {\n                   type\
    \ empty;\n                   description \"Don't inform other protocols about\"\
    \n                             + \" neighbor down events\";\n               }\n\
    \           }\n       }\n   The <no-neighbor-down-notification> element is then\
    \ placed in the\n   vendorx namespace:\n       <ospf xmlns=\"http://example.org/netconf/ospf\"\
    \n             xmlns:vendorx=\"http://vendorx.example.com/ospf\">\n         <area>\n\
    \           <name>0.0.0.0</name>\n           <interface>\n             <name>ge-0/0/0.0</name>\n\
    \             <priority>30</priority>\n             <vendorx:no-neighbor-down-notification/>\n\
    \           </interface>\n         </area>\n       </ospf>\n   Augmentations are\
    \ seamlessly integrated with base modules, allowing\n   them to be fetched, archived,\
    \ loaded, and deleted within their\n   natural hierarchy.  If a client application\
    \ asks for the\n   configuration for a specific OSPF area, it will receive the\
    \ sub-\n   hierarchy for that area, complete with any augmented data.\n"
- title: 2.3.  YANG Translations
  contents:
  - "2.3.  YANG Translations\n   The YANG data modeling language is the central piece\
    \ of a group of\n   related technologies.  The YANG language itself, described\
    \ in\n   [RFC6020], defines the syntax of the language and its statements, the\n\
    \   meaning of those statements, and how to combine them to build the\n   hierarchy\
    \ of nodes that describe a data model.\n   That document also defines the \"on\
    \ the wire\" XML content for NETCONF\n   operations on data models defined in\
    \ YANG modules.  This includes the\n   basic mapping between YANG data tree nodes\
    \ and XML elements, as well\n   as mechanisms used in <edit-config> content to\
    \ manipulate that data,\n   such as arranging the order of nodes within a list.\n\
    \   YANG uses a syntax that is regular and easily described, primarily\n   designed\
    \ for human readability.  YANG's syntax is friendly to email,\n   diff, patch,\
    \ and the constraints of RFC formatting.\n"
- title: 2.3.1.  YIN
  contents:
  - "2.3.1.  YIN\n   In some environments, incorporating a YANG parser may not be\
    \ an\n   acceptable option.  For those scenarios, an XML grammar for YANG is\n\
    \   defined as YIN (YANG Independent Notation).  YIN allows the use of\n   XML\
    \ parsers that are readily available in both open source and\n   commercial versions.\
    \  Conversion between YANG and YIN is direct,\n   loss-less, and reversible. \
    \ YANG statements are converted to XML\n   elements, preserving the structure\
    \ and content of YANG, but enabling\n   the use of off-the-shelf XML parsers rather\
    \ than requiring the\n   integration of a YANG parser.  YIN maintains complete\
    \ semantic\n   equivalence with YANG.\n"
- title: 2.3.2.  DSDL (RELAX NG)
  contents:
  - "2.3.2.  DSDL (RELAX NG)\n   Since NETCONF content is encoded in XML, it is natural\
    \ to use XML\n   schema languages for their validation.  To facilitate this, YANG\n\
    \   offers a standardized mapping of YANG modules into Document Schema\n   Definition\
    \ Languages [RFC6110], of which RELAX NG is a major\n   component.\n   DSDL is\
    \ considered to be the best choice as a standard schema\n   language because it\
    \ addresses not only grammar and datatypes of XML\n   documents but also semantic\
    \ constraints and rules for modifying the\n   information set of the document.\n\
    \   In addition, DSDL offers formal means for coordinating multiple\n   independent\
    \ schemas and specifying how to apply the schemas to the\n   various parts of\
    \ the document.  This is useful since YANG content is\n   typically composed of\
    \ multiple vocabularies.\n"
- title: 2.4.  YANG Types
  contents:
  - "2.4.  YANG Types\n   YANG supports a number of builtin types, and allows additional\
    \ types\n   to be derived from those types in an extensible manner.  New types\n\
    \   can add additional restrictions to allowable data values.\n   A standard type\
    \ library for use by YANG is available [RFC6021].\n   These YANG modules define\
    \ commonly used data types for IETF-related\n   standards.\n"
- title: 2.5.  IETF Guidelines
  contents:
  - "2.5.  IETF Guidelines\n   A set of additional guidelines is defined that indicate\
    \ desirable\n   usage for authors and reviewers of Standards-Track specifications\n\
    \   containing YANG data model modules [RFC6087].  These guidelines\n   should\
    \ be used as a basis for reviews of other YANG data model\n   documents.\n"
- title: 3.  Working with YANG
  contents:
  - '3.  Working with YANG

    '
- title: 3.1.  Building NETCONF- and YANG-Based Solutions
  contents:
  - "3.1.  Building NETCONF- and YANG-Based Solutions\n   In the typical YANG-based\
    \ solution, the client and server are driven\n   by the content of YANG modules.\
    \  The server includes the definitions\n   of the modules as meta-data that is\
    \ available to the NETCONF engine.\n   This engine processes incoming requests,\
    \ uses the meta-data to parse\n   and verify the request, performs the requested\
    \ operation, and returns\n   the results to the client.\n                    \
    \   +----------------------------+\n                       |Server (device)  \
    \           |\n                       |    +--------------------+  |\n       \
    \                |    |      configuration |  |\n            +----+     |    |\
    \     ---------------|  |\n            |YANG|+    |    | m d  state data    |\
    \  |\n            |mods||+   |    | e a ---------------|  |\n            +----+||\
    \ -----> | t t  notifications |  |\n             +----+|   |    | a a ---------------|\
    \  |\n              +----+   |    |      operations    |  |\n                \
    \       |    +--------------------+  |\n                       |           ^ \
    \               |\n                       |           |                |\n   \
    \                    |           v                |\n     +------+          |\
    \     +-------------+        |\n     |      | -------------> |             | \
    \       |\n     |Client| <rpc>    |     |  NETCONF    |        |\n     | (app)|\
    \          |     |   engine    |        |\n     |      | <------------  |    \
    \         |        |\n     +------+ <rpc-reply>    +-------------+        |\n\
    \                       |       /        \\           |\n                    \
    \   |      /          \\          |\n                       |     /          \
    \  \\         |\n                       | +--------+   +---------+   |\n     \
    \                  | | config |   |system   |+  |\n                       | |\
    \  data- |   |software ||+ |\n                       | |   base |   |component|||\
    \ |\n                       | +--------+   +---------+|| |\n                 \
    \      |               +---------+| |\n                       |              \
    \  +---------+ |\n                       +----------------------------+\n   To\
    \ use YANG, YANG modules must be defined to model the specific\n   problem domain.\
    \  These modules are then loaded, compiled, or coded\n   into the server.\n  \
    \ The sequence of events for the typical client/server interaction may\n   be\
    \ as follows:\n   o  A client application ([C]) opens a NETCONF session to the\
    \ server\n      (device) ([S])\n   o  [C] and [S] exchange <hello> messages containing\
    \ the list of\n      capabilities supported by each side, allowing [C] to learn\
    \ the\n      modules supported by [S]\n   o  [C] builds and sends an operation\
    \ defined in the YANG module,\n      encoded in XML, within NETCONF's <rpc> element\n\
    \   o  [S] receives and parses the <rpc> element\n   o  [S] verifies the contents\
    \ of the request against the data model\n      defined in the YANG module\n  \
    \ o  [S] performs the requested operation, possibly changing the\n      configuration\
    \ datastore\n   o  [S] builds the response, containing the response, any requested\n\
    \      data, and any errors\n   o  [S] sends the response, encoded in XML, within\
    \ NETCONF's\n      <rpc-reply> element\n   o  [C] receives and parses the <rpc-reply>\
    \ element\n   o  [C] inspects the response and processes it as needed\n   Note\
    \ that there is no requirement for the client or server to process\n   the YANG\
    \ modules in this way.  The server may hard code the contents\n   of the data\
    \ model, rather than handle the content via a generic\n   engine.  Or the client\
    \ may be targeted at the specific YANG model,\n   rather than being driven generically.\
    \  Such a client might be a\n   simple shell script that stuffs arguments into\
    \ an XML payload\n   template and sends it to the server.\n"
- title: 3.2.  Addressing Operator Requirements
  contents:
  - "3.2.  Addressing Operator Requirements\n   NETCONF and YANG address many of the\
    \ issues raised in the IAB NM\n   workshop.\n   o  Ease of use: YANG is designed\
    \ to be human friendly, simple, and\n      readable.  Many tricky issues remain\
    \ due to the complexity of the\n      problem domain, but YANG strives to make\
    \ them more visible and\n      easier to deal with.\n   o  Configuration and state\
    \ data: YANG clearly divides configuration\n      data from other types of data.\n\
    \   o  Transactions: NETCONF provides a simple transaction mechanism.\n   o  Generation\
    \ of deltas: A YANG module gives enough information to\n      generate the delta\
    \ needed to change between two configuration data\n      sets.\n   o  Dump and\
    \ restore: NETCONF gives the ability to save and restore\n      configuration\
    \ data.  This can also be performed for a specific\n      YANG module.\n   o \
    \ Network-wide configuration: NETCONF supports robust network-wide\n      configuration\
    \ transactions via the commit and confirmed-commit\n      capabilities.  When\
    \ a change is attempted that affects multiple\n      devices, these capabilities\
    \ simplify the management of failure\n      scenarios, resulting in the ability\
    \ to have transactions that will\n      dependably succeed or fail atomically.\n\
    \   o  Text-friendly: YANG modules are very text friendly, as is the data\n  \
    \    they define.\n   o  Configuration handling: NETCONF addresses the ability\
    \ to\n      distinguish between distributing configuration data and activating\n\
    \      it.\n   o  Task-oriented: A YANG module can define specific tasks as RPC\n\
    \      operations.  A client can choose to invoke the RPC operation or to\n  \
    \    access any underlying data directly.\n   o  Full coverage: YANG modules can\
    \ be defined that give full coverage\n      to all the native abilities of the\
    \ device.  Giving this access\n      avoids the need to resort to the command\
    \ line interface (CLI)\n      using tools such as Expect [SWEXPECT].\n   o  Timeliness:\
    \ YANG modules can be tied to CLI operations, so all\n      native operations\
    \ and data are immediately available.\n   o  Implementation difficulty: YANG's\
    \ flexibility enables modules that\n      can be more easily implemented.  Adding\
    \ \"features\" and replacing\n      \"third normal form\" with a natural data\
    \ hierarchy should reduce\n      complexity.\n   o  Simple data modeling language:\
    \ YANG has sufficient power to be\n      usable in other situations.  In particular,\
    \ on-box API and native\n      CLI can be integrated to achieve simplification\
    \ of the\n      infrastructure.\n   o  Internationalization: YANG uses UTF-8 [RFC3629]\
    \ encoded Unicode\n      characters.\n   o  Event correlation: YANG integrates\
    \ RPC operations, notification,\n      configuration, and state data, enabling\
    \ internal references.  For\n      example, a field in a notification can be tagged\
    \ as pointing to a\n      BGP peer, and the client application can easily find\
    \ that peer in\n      the configuration data.\n   o  Implementation costs: Significant\
    \ effort has been made to keep\n      implementation costs as low as possible.\n\
    \   o  Human-friendly syntax: YANG's syntax is optimized for the reader,\n   \
    \   specifically the reviewer on the basis that this is the most\n      common\
    \ human interaction.\n   o  Post-processing: Use of XML will maximize the opportunities\
    \ for\n      post-processing of data, possibly using XML-based technologies\n\
    \      like XPath [W3CXPATH], XQuery [W3CXQUERY], and XSLT [W3CXSLT].\n   o  Semantic\
    \ mismatch: Richer, more descriptive data models will\n      reduce the possibility\
    \ of semantic mismatch.  With the ability to\n      define new primitives, YANG\
    \ modules will be more specific in\n      content, allowing more enforcement of\
    \ rules and constraints.\n   o  Security: NETCONF runs over transport protocols\
    \ secured by SSH or\n      TLS, allowing secure communications and authentication\
    \ using well-\n      trusted technology.  The secure transport can use existing\
    \ key and\n      credential management infrastructure, reducing deployment costs.\n\
    \   o  Reliable: NETCONF and YANG are solid and reliable technologies.\n     \
    \ NETCONF is connection based, and includes automatic recovery\n      mechanisms\
    \ when the connection is lost.\n   o  Delta friendly: YANG-based models support\
    \ operations that are\n      delta friendly.  Add, change, insert, and delete\
    \ operations are\n      all well defined.\n   o  Method-oriented: YANG allows\
    \ new RPC operations to be defined,\n      including an operation name, which\
    \ is essentially a method.  The\n      input and output parameters of the RPC\
    \ operations are also defined\n      in the YANG module.\n"
- title: 3.3.  Roles in Building Solutions
  contents:
  - "3.3.  Roles in Building Solutions\n   Building NETCONF- and YANG-based solutions\
    \ requires interacting with\n   many distinct groups.  Modelers must understand\
    \ how to build useful\n   models that give structure and meaning to data while\
    \ maximizing the\n   flexibility of that data to \"future proof\" their work.\
    \  Reviewers\n   need to quickly determine if that structure is accurate.  Device\n\
    \   developers need to code that data model into their devices, and\n   application\
    \ developers need to code their applications to take\n   advantage of that data\
    \ model.  There are a variety of strategies for\n   performing each piece of this\
    \ work.  This section discusses some of\n   those strategies.\n"
- title: 3.3.1.  Modeler
  contents:
  - "3.3.1.  Modeler\n   The modeler defines a data model based on their in-depth\
    \ knowledge of\n   the problem domain being modeled.  This model should be as\
    \ simple as\n   possible, but should balance complexity with expressiveness. \
    \ The\n   organization of the model not only should target the current model\n\
    \   but also should allow for extensibility from other modules and for\n   adaptability\
    \ to future changes.\n   Additional modeling issues are discussed in Section 4.\n"
- title: 3.3.2.  Reviewer
  contents:
  - "3.3.2.  Reviewer\n   The reviewer role is perhaps the most important and the\
    \ time\n   reviewers are willing to give is precious.  To help the reviewer,\n\
    \   YANG stresses readability, with a human-friendly syntax, natural data\n  \
    \ hierarchy, and simple, concise statements.\n"
- title: 3.3.3.  Device Developer
  contents:
  - "3.3.3.  Device Developer\n   The YANG model tells the device developer what data\
    \ is being modeled.\n   The developer reads the YANG models and writes code that\
    \ supports the\n   model.  The model describes the data hierarchy and associated\n\
    \   constraints, and the description and reference material helps the\n   developer\
    \ understand how to transform the model's view into the\n   device's native implementation.\n"
- title: 3.3.3.1.  Generic Content Support
  contents:
  - "3.3.3.1.  Generic Content Support\n   The YANG model can be compiled into a YANG-based\
    \ engine for either\n   the client or server side.  Incoming data can be validated,\
    \ as can\n   outgoing data.  The complete configuration datastore may be validated\n\
    \   in accordance with the constraints described in the data model.\n   Serializers\
    \ and de-serializers for generating and receiving NETCONF\n   content can be driven\
    \ by the meta-data in the model.  As data is\n   received, the meta-data is consulted\
    \ to ensure the validity of\n   incoming XML elements.\n"
- title: 3.3.3.2.  XML Definitions
  contents:
  - "3.3.3.2.  XML Definitions\n   The YANG module dictates the XML encoding for data\
    \ sent via NETCONF.\n   The rules that define the encoding are fixed, so the YANG\
    \ module can\n   be used to ascertain whether a specific NETCONF payload is obeying\n\
    \   the rules.\n"
- title: 3.3.4.  Application Developer
  contents:
  - "3.3.4.  Application Developer\n   The YANG module tells the application developer\
    \ what data can be\n   modeled.  Developers can inspect the modules and take one\
    \ of three\n   distinct views.  In this section, we will consider them and the\n\
    \   impact of YANG on their design.  In the real world, most applications\n  \
    \ are a mixture of these approaches.\n"
- title: 3.3.4.1.  Hard Coded
  contents:
  - "3.3.4.1.  Hard Coded\n   An application can be coded against the specific, well-known\
    \ contents\n   of YANG modules, implementing their organization, rules, and logic\n\
    \   directly with explicit knowledge.  For example, a script could be\n   written\
    \ to change the domain name of a set of devices using a\n   standard YANG module\
    \ that includes such a leaf node.  This script\n   takes the new domain name as\
    \ an argument and inserts it into a string\n   containing the rest of the XML\
    \ encoding as required by the YANG\n   module.  This content is then sent via\
    \ NETCONF to each of the\n   devices.\n   This type of application is useful for\
    \ small, fixed problems where\n   the cost and complexity of flexibility are overwhelmed\
    \ by the ease of\n   hard coding direct knowledge into the application.\n"
- title: 3.3.4.2.  Bottom Up
  contents:
  - "3.3.4.2.  Bottom Up\n   An application may take a generic, bottom-up approach\
    \ to\n   configuration, concentrating on the device's data directly and\n   treating\
    \ that data without specific understanding.\n   YANG modules may be used to drive\
    \ the operation of the YANG\n   equivalent of a \"MIB browser\".  Such an application\
    \ manipulates the\n   device's configuration data based on the data organization\
    \ contained\n   in the YANG module.  For example, a GUI may present a straightforward\n\
    \   visualization where elements of the YANG hierarchy are depicted in a\n   hierarchy\
    \ of folders or GUI panels.  Clicking on a line expands to\n   the contents of\
    \ the matching XML hierarchy.\n   This type of GUI can easily be built by generating\
    \ XSLT stylesheets\n   from the YANG data models.  An XSLT engine can then be\
    \ used to turn\n   configuration data into a set of web pages.\n   The YANG modules\
    \ allow the application to enforce a set of\n   constraints without understanding\
    \ the semantics of the YANG module.\n"
- title: 3.3.4.3.  Top Down
  contents:
  - "3.3.4.3.  Top Down\n   In contrast to the bottom-up approach, the top-down approach\
    \ allows\n   the application to take a view of the configuration data that is\n\
    \   distinct from the standard and/or proprietary YANG modules.  The\n   application\
    \ is free to construct its own model for data organization\n   and to present\
    \ this model to the user.  When the application needs to\n   transmit data to\
    \ a device, the application transforms its data from\n   the problem-oriented\
    \ view of the world into the data needed for that\n   particular device.  This\
    \ transformation is under the control and\n   maintenance of the application,\
    \ allowing the transformation to be\n   changed and updated without affecting\
    \ the device.\n   For example, an application could be written that models VPNs\
    \ in a\n   network-oriented view.  The application would need to transform these\n\
    \   high-level VPN definitions into the configuration data that would be\n   handed\
    \ to any particular device within a VPN.\n   Even in this approach, YANG is useful\
    \ since it can be used to model\n   the VPN.  For example, the following VPN straw-man\
    \ models a list of\n   VPNs, each with a protocol, a topology, a list of member\
    \ interfaces,\n   and a list of classifiers.\n       list example-bgpvpn {\n \
    \          key name;\n           leaf name { ... }\n           leaf protocol {\n\
    \               type enumeration {\n                   enum bgpvpn;\n        \
    \           enum l2vpn;\n               }\n           }\n           leaf topology\
    \ {\n               type enumeration {\n                   enum hub-n-spoke;\n\
    \                   enum mesh;\n               }\n           }\n           list\
    \ members {\n               key \"device interface\";\n               leaf device\
    \ { ... }\n               leaf interface { ... }\n           }\n           list\
    \ classifiers {\n               ...\n           }\n       }\n   The application\
    \ can use such a YANG module to drive its operation,\n   building VPN instances\
    \ in a database and then pushing the\n   configuration for those VPNs to individual\
    \ devices either using a\n   standard device model (e.g., example-bgpvpn.yang)\
    \ or by transforming\n   that standard device content into some proprietary format\
    \ for devices\n   that do not support that standard.\n"
- title: 4.  Modeling Considerations
  contents:
  - "4.  Modeling Considerations\n   This section discusses considerations the modeler\
    \ should be aware of\n   while developing models in YANG.\n"
- title: 4.1.  Default Values
  contents:
  - "4.1.  Default Values\n   The concept of default values is simple, but their details,\n\
    \   representation, and interaction with configuration data can be\n   difficult\
    \ issues.  NETCONF leaves default values as a data model\n   issue, and YANG gives\
    \ flexibility to the device implementation in\n   terms of how default values\
    \ are handled.  The requirement is that the\n   device \"MUST operationally behave\
    \ as if the leaf was present in the\n   data tree with the default value as its\
    \ value\".  This gives the\n   device implementation choices in how default values\
    \ are handled.\n   One choice is to view the configuration as a set of instructions\
    \ for\n   how the device should be configured.  If a data value that is given\n\
    \   as part of those instructions is the default value, then it should be\n  \
    \ retained as part of the configuration, but if it is not explicitly\n   given,\
    \ then the value is not considered to be part of the\n   configuration.\n   Another\
    \ choice is to trim values that are identical to the default\n   values, implicitly\
    \ removing them from the configuration datastore.\n   The act of setting a leaf\
    \ to its default value effectively deletes\n   that leaf.\n   The device could\
    \ also choose to report all default values, regardless\n   of whether they were\
    \ explicitly set.  This choice eases the work of a\n   client that needs default\
    \ values, but may significantly increase the\n   size of the configuration data.\n\
    \   These choices reflect the default handling schemes of widely deployed\n  \
    \ networking devices and supporting them allows YANG to reduce\n   implementation\
    \ and deployment costs of YANG-based models.\n   When the client retrieves data\
    \ from the device, it must be prepared\n   to handle the absence of leaf nodes\
    \ with the default value, since the\n   server is not required to send such leaf\
    \ elements.  This permits the\n   device to implement either of the first two\
    \ default handling schemes\n   given above.\n   Regardless of the implementation\
    \ choice, the device can support the\n   \"with-defaults\" capability [RFC6243]\
    \ and give the client the ability\n   to select the desired handling of default\
    \ values.\n   When evaluating the XPath expressions for constraints like \"must\"\
    \ and\n   \"when\", the evaluation context for the expressions will include any\n\
    \   appropriate default values, so the modeler can depend on consistent\n   behavior\
    \ from all devices.\n"
- title: 4.2.  Compliance
  contents:
  - "4.2.  Compliance\n   In developing good data models, there are many conflicting\
    \ interests\n   the data modeler must keep in mind.  Modelers need to be aware\
    \ of\n   five issues with models and devices:\n   o  usefulness\n   o  compliance\n\
    \   o  flexibility\n   o  extensibility\n   o  deviations\n   For a model to be\
    \ interesting, it must be useful, solving a problem\n   in a more direct or more\
    \ powerful way than can be accomplished\n   without the model.  The model should\
    \ maximize the usefulness of the\n   model within the problem domain.\n   Modelers\
    \ should build models that maximize the number of devices that\n   can faithfully\
    \ implement the model.  If the model is drawn too\n   narrowly, or includes too\
    \ many assumptions about the device, then the\n   difficulty and cost of accurately\
    \ implementing the model will lead to\n   low-quality implementations and interoperability\
    \ issues, and will\n   reduce the value of the model.\n   Modelers can use the\
    \ \"feature\" statement in their models to give the\n   device some flexibility\
    \ by partitioning their model and allowing the\n   device to indicate which portions\
    \ of the model are implemented on the\n   device.  For example, if the model includes\
    \ some \"logging\" feature, a\n   device with no storage facilities for the log\
    \ can tell the client\n   that it does not support this feature of the model.\n\
    \   Models can be extended via the \"augment\" statement, and the modeler\n  \
    \ should consider how their model is likely to be extended.  These\n   augmentations\
    \ can be defined by vendors, applications, or standards\n   bodies.\n   Deviations\
    \ are a means of allowing the devices to indicate where its\n   implementation\
    \ is not in full compliance with the model.  For\n   example, once a model is\
    \ published, an implementer may decide to make\n   a particular node configurable,\
    \ where the standard model describes it\n   as state data.  The implementation\
    \ reports the value normally and may\n   declare a deviation that this device\
    \ behaves in a different manner\n   than the standard.  Applications capable of\
    \ discovering this\n   deviation can make allowances, but applications that do\
    \ not discover\n   the deviation can continue treating the implementation as if\
    \ it were\n   compliant.\n   Rarely, implementations may make decisions that prevent\
    \ compliance\n   with the standard.  Such occasions are regrettable, but they\
    \ remain a\n   part of reality, and modelers and application writers ignore them\
    \ at\n   their own risk.  An implementation that emits an integer leaf as\n  \
    \ \"cow\" would be difficult to manage, but applications should expect to\n  \
    \ encounter such misbehaving devices in the field.\n   Despite this, both client\
    \ and server should view the YANG module as a\n   contract, with both sides agreeing\
    \ to abide by the terms.  The\n   modeler should be explicit about the terms of\
    \ such a contract, and\n   both client and server implementations should strive\
    \ to faithfully\n   and accurately implement the data model described in the YANG\
    \ module.\n"
- title: 4.3.  Data Distinctions
  contents:
  - "4.3.  Data Distinctions\n   The distinction between configuration data, operational\
    \ state data,\n   and statistics is important to understand for data model writers\
    \ and\n   people who plan to extend the NETCONF protocol.  This section first\n\
    \   discusses some background and then provides a definition and some\n   examples.\n"
- title: 4.3.1.  Background
  contents:
  - "4.3.1.  Background\n   During the IAB NM workshop, operators did formulate the\
    \ following two\n   requirements, as listed in [RFC3535]:\n    2.  It is necessary\
    \ to make a clear distinction between\n        configuration data, data that describes\
    \ operational state,\n        and statistics.  Some devices make it very hard\
    \ to determine\n        which parameters were administratively configured and\
    \ which\n        were obtained via other mechanisms such as routing\n        protocols.\n\
    \    3.  It is required to be able to fetch separately configuration\n       \
    \ data, operational state data, and statistics from devices,\n        and to be\
    \ able to compare these between devices.\n   The NETCONF protocol defined in RFC\
    \ 4741 distinguishes two types of\n   data -- namely, configuration data and state\
    \ data:\n      Configuration data is the set of writable data that is\n      required\
    \ to transform a system from its initial default state\n      into its current\
    \ state.\n      State data is the additional data on a system that is not\n  \
    \    configuration data such as read-only status information and\n      collected\
    \ statistics.\n   NETCONF does not follow the distinction formulated by the operators\n\
    \   between configuration data, operational state data, and statistical\n   data,\
    \ since it considers state data to include both statistics and\n   operational\
    \ state data.\n"
- title: 4.3.2.  Definitions
  contents:
  - "4.3.2.  Definitions\n   Below is a definition for configuration data, operational\
    \ state data,\n   and statistical data.  The definition borrows from previous\
    \ work.\n   o  Configuration data is the set of writable data that is required\
    \ to\n      transform a system from its initial default state into its current\n\
    \      state [RFC4741].\n   o  Operational state data is a set of data that has\
    \ been obtained by\n      the system at runtime and influences the system's behavior\
    \ similar\n      to configuration data.  In contrast to configuration data,\n\
    \      operational state is transient and modified by interactions with\n    \
    \  internal components or other systems via specialized protocols.\n   o  Statistical\
    \ data is the set of read-only data created by a system\n      itself.  It describes\
    \ the performance of the system and its\n      components.\n   The following examples\
    \ help to clarify the difference between\n   configuration data, operational state\
    \ data, and statistical data.\n"
- title: '4.3.2.1.  Example 1: IP Routing Table'
  contents:
  - "4.3.2.1.  Example 1: IP Routing Table\n   IP routing tables can contain entries\
    \ that are statically configured\n   (configuration data) as well as entries obtained\
    \ from routing\n   protocols such as OSPF (operational state data).  In addition,\
    \ a\n   routing engine might collect statistics like how often a particular\n\
    \   routing table entry has been used.\n"
- title: '4.3.2.2.  Example 2: Interfaces'
  contents:
  - "4.3.2.2.  Example 2: Interfaces\n   Network interfaces usually come with a large\
    \ number of attributes\n   that are specific to the interface type and in some\
    \ cases specific to\n   the cable plugged into an interface.  Examples are the\
    \ maximum\n   transmission unit of an interface or the speed detected by an\n\
    \   Ethernet interface.\n   In many deployments, systems use the interface attributes\
    \ detected\n   when an interface is initialized.  As such, these attributes\n\
    \   constitute operational state.  However, there are usually provisions\n   to\
    \ overwrite the discovered attributes with static configuration\n   data, like\
    \ for example configuring the interface MTU to use a\n   specific value or forcing\
    \ an Ethernet interface to run at a given\n   speed.\n   The system will record\
    \ statistics (counters) measuring the number of\n   packets, bytes, and errors\
    \ received and transmitted on each\n   interface.\n"
- title: '4.3.2.3.  Example 3: Account Information'
  contents:
  - "4.3.2.3.  Example 3: Account Information\n   Systems usually maintain static\
    \ configuration information about the\n   accounts on the system.  In addition,\
    \ systems can obtain information\n   about accounts from other sources (e.g.,\
    \ Lightweight Directory Access\n   Protocol (LDAP), Network Information Service\
    \ (NIS)) dynamically,\n   leading to operational state data.  Information about\
    \ account usage\n   is an example of statistical data.\n   Note that configuration\
    \ data supplied to a system in order to create\n   a new account might be supplemented\
    \ with additional configuration\n   information determined by the system when\
    \ the account is being\n   created (such as a unique account id).  Even though\
    \ the system might\n   create such information, it usually becomes part of the\
    \ static\n   configuration of the system since this data is not transient.\n"
- title: 4.3.3.  Implications
  contents:
  - "4.3.3.  Implications\n   The primary focus of YANG is configuration data.  There\
    \ is no single\n   mechanism defined for the separation of operational state data\
    \ and\n   statistics since NETCONF treats them both as state data.  This\n   section\
    \ describes several different options for addressing this\n   issue.\n"
- title: 4.3.3.1.  Data Models
  contents:
  - "4.3.3.1.  Data Models\n   The first option is to have data models that explicitly\
    \ differentiate\n   between configuration data and operational state data.  This\
    \ leads to\n   duplication of data structures and might not scale well from a\n\
    \   modeling perspective.\n   For example, the configured duplex value and the\
    \ operational duplex\n   value would be distinct leafs in the data model.\n"
- title: 4.3.3.2.  Additional Operations to Retrieve Operational State
  contents:
  - "4.3.3.2.  Additional Operations to Retrieve Operational State\n   The NETCONF\
    \ protocol can be extended with new protocol operations\n   that specifically\
    \ allow the retrieval of all operational state, e.g.,\n   by introducing a <get-ops>\
    \ operation (and perhaps also a <get-stats>\n   operation).\n"
- title: 4.3.3.3.  Introduction of an Operational State Datastore
  contents:
  - "4.3.3.3.  Introduction of an Operational State Datastore\n   Another option could\
    \ be to introduce a new \"configuration\" data store\n   that represents the operational\
    \ state.  A <get-config> operation on\n   the <operational> data store would then\
    \ return the operational state\n   determining the behavior of the box instead\
    \ of its static and\n   explicit configuration state.\n"
- title: 4.4.  Direction
  contents:
  - "4.4.  Direction\n   At this time, the only viable solution is to distinctly model\
    \ the\n   configuration and operational values.  The configuration leaf would\n\
    \   indicate the desired value, as given by the user, and the operational\n  \
    \ leaf would indicate the current value, as observed on the device.\n   In the\
    \ duplex example, this would result in two distinct leafs being\n   defined, \"\
    duplex\" and \"op-duplex\", one with \"config true\" and one\n   with \"config\
    \ false\".\n   In some cases, distinct leafs would be used, but in others, distinct\n\
    \   lists might be used.  Distinct lists allows the list to be organized\n   in\
    \ different ways, with different constraints.  Keys, sorting, and\n   constraint\
    \ statements like must, unique, or when may differ between\n   configuration data\
    \ and operational data.\n   For example, configured static routes might be a distinct\
    \ list from\n   the operational routing table, since the use of keys and sorting\n\
    \   might differ.\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   This document discusses an architecture for network\
    \ management using\n   NETCONF and YANG.  It has no security impact on the Internet.\n"
- title: 6.  References
  contents:
  - '6.  References

    '
- title: 6.1.  Normative References
  contents:
  - "6.1.  Normative References\n   [ISODSDL]    International Organization for Standardization,\n\
    \                \"Document Schema Definition Languages (DSDL) - Part 1:\n   \
    \             Overview\", ISO/IEC 19757-1, November 2004.\n   [RFC3535]    Schoenwaelder,\
    \ J., \"Overview of the 2002 IAB Network\n                Management Workshop\"\
    , RFC 3535, May 2003.\n   [RFC3629]    Yergeau, F., \"UTF-8, a transformation\
    \ format of ISO\n                10646\", STD 63, RFC 3629, November 2003.\n \
    \  [RFC4251]    Ylonen, T. and C. Lonvick, \"The Secure Shell (SSH)\n        \
    \        Protocol Architecture\", RFC 4251, January 2006.\n   [RFC4741]    Enns,\
    \ R., \"NETCONF Configuration Protocol\", RFC 4741,\n                December\
    \ 2006.\n   [RFC4742]    Wasserman, M. and T. Goddard, \"Using the NETCONF\n \
    \               Configuration Protocol over Secure SHell (SSH)\",\n          \
    \      RFC 4742, December 2006.\n   [RFC4743]    Goddard, T., \"Using NETCONF\
    \ over the Simple Object\n                Access Protocol (SOAP)\", RFC 4743,\
    \ December 2006.\n   [RFC4744]    Lear, E. and K. Crozier, \"Using the NETCONF\
    \ Protocol\n                over the Blocks Extensible Exchange Protocol (BEEP)\"\
    ,\n                RFC 4744, December 2006.\n   [RFC5277]    Chisholm, S. and\
    \ H. Trevino, \"NETCONF Event\n                Notifications\", RFC 5277, July\
    \ 2008.\n   [RFC5539]    Badra, M., \"NETCONF over Transport Layer Security\n\
    \                (TLS)\", RFC 5539, May 2009.\n   [RFC6020]    Bjorklund, M.,\
    \ \"YANG - A Data Modeling Language for the\n                Network Configuration\
    \ Protocol (NETCONF)\", RFC 6020,\n                October 2010.\n   [RFC6021]\
    \    Schoenwaelder, J., \"Common YANG Data Types\", RFC 6021,\n              \
    \  October 2010.\n   [RFC6087]    Bierman, A., \"Guidelines for Authors and Reviewers\
    \ of\n                YANG Data Model Documents\", RFC 6087, January 2011.\n \
    \  [RFC6110]    Lhotka, L., \"Mapping YANG to Document Schema Definition\n   \
    \             Languages and Validating NETCONF Content\", RFC 6110,\n        \
    \        February 2011.\n   [RFC6243]    Bierman, A. and B. Lengyel, \"With-defaults\
    \ Capability\n                for NETCONF\", RFC 6243, June 2011.\n   [SWEXPECT]\
    \   \"The Expect Home Page\",\n                <http://expect.sourceforge.net/>.\n\
    \   [W3CXPATH]   DeRose, S. and J. Clark, \"XML Path Language (XPath)\n      \
    \          Version 1.0\", World Wide Web Consortium\n                Recommendation\
    \ REC-xpath-19991116, November 1999,\n                <http://www.w3.org/TR/1999/REC-xpath-19991116>.\n\
    \   [W3CXQUERY]  Boag, S., \"XQuery 1.0: An XML Query Language\", W3C\n      \
    \          WD WD-xquery-20050915, September 2005.\n   [W3CXSD]     Walmsley, P.\
    \ and D. Fallside, \"XML Schema Part 0: Primer\n                Second Edition\"\
    , World Wide Web Consortium\n                Recommendation REC-xmlschema-0-20041028,\
    \ October 2004,\n                <http://www.w3.org/TR/2004/REC-xmlschema-0-20041028>.\n\
    \   [W3CXSLT]    Clark, J., \"XSL Transformations (XSLT) Version 1.0\",\n    \
    \            World Wide Web Consortium Recommendation REC-xslt-\n            \
    \    19991116, November 1999,\n                <http://www.w3.org/TR/1999/REC-xslt-19991116>.\n"
- title: 6.2.  Informative References
  contents:
  - "6.2.  Informative References\n   [RCDML]      Presuhn, R., Ed., \"Requirements\
    \ for a Configuration Data\n                Modeling Language\", Work in Progress,\
    \ February 2008.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Phil Shafer\n   Juniper Networks\n   EMail: phil@juniper.net\n"
