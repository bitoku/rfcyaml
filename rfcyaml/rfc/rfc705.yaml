- title: __initial_text__
  contents:
  - "                         FRONT - END PROTOCOL\n                            B6700\
    \ VERSION\n                           2 September 1975\nThis is a working document\
    \ which has been developed as the specification \nand guideline for design of\
    \ a Burroughs B6700 attachment to an ARPA-Style\nnetwork.\nThe approach is to\
    \ utilize a front-end processor with a new protocol for \nnetwork operation. \
    \ That protocol, described herein, has been built upon\nthe concepts expressed\
    \ by M.A. Padlipsky, et al, in NIC# 31117, RFC# 647.\nThis proposed, site-specific,\
    \ FEP implementation is the work of Gerald \nBailey and Keith McCloghrie of NSA\
    \ and of David Grothe of ACC.  It has \nalready sustained some corrections provided\
    \ by MAP.  It will be helpful\nif interested networkers will review and provide\
    \ comments to us.\nComments to BRYAN@ISI.\nRoland Bryan - ACC\t\t\t\t\t\t\t1\f\
    Front-End Protocol: B6700 Version\n                        ***WORKING DOCUMENT***\n\
    \                          FRONT-END PROTOCOL\n                              \
    \ PREFACE\nThis document describes the protocol to be used for connecting a general-\n\
    purpose computer system (host) to an ARPANET-like network via a \"front-end\"\
    \ \ncomputer.  The main body of the document is aimed at a reader who is not \n\
    conversant with all the details of network protocols.  However, a paragraph\n\
    marked with [n], refers a reader familiar with network protocols to the\nn-th\
    \ item of Appendix A which will amplify that particular paragraph.  \nFurther\
    \ information on the network protocols referred to in this document \ncan be obtained\
    \ from the Network Information Center.\nAppendix B contains diagrams showing the\
    \ transitions between the different\nconnection states.  Appendices C and D give\
    \ the implementation details of \nthis protocol in the Front-End and the Hosts.\n\
    This protocol is predicated upon the assumption that for each host, a line\nprotocol,\
    \ at a lower level, will be established between the device-driver\nmodules in\
    \ the Host and the Front-End, and that this line protocol provides\nFront-End\
    \ Protocol with error-free transmissions.\n                             INTRODUCTION\t\
    \t\t\t2\nA host computer may be connected to a network for a variety of reasons.\
    \  \nNetwork connection may be an attempt to expand the usefulness of the\nHost\
    \ to the community of users which it serves by making network resources\navailable\
    \ to them.  Conversely, the services which the Host provides may \nbe made available\
    \ to a larger community of users, with the network providing \nthe method of access\
    \ to those services.\nIn order for members of a network community to communicate\
    \ in an intelligent \nway, there must exist a set of protocols.  The implementation\
    \ of these \nprotocols in a host computer is typically called the Network Control\
    \ Program\n(NCP).  The size and complexity of the NCP is proportional to the number\
    \ and \ncomplexity of protocols which it implements.  For an ARPANET like network,\n\
    both the number and complexity are substantial.\n                       ***WORKING\
    \ DOCUMENT***\nFront-End Protocol\n                        ***WORKING DOCUMENT***\n\
    A host which directly connects into the network must assume the responsibility\n\
    for implementing this set of protocols.  That is the \"price of admission\"\n\
    to become a network host.  It is not necessary to implement every protocol\nand\
    \ every option in every host, but even in the simplest case -- implementation\n\
    of an NCP is not a small task.  The intrusion into the normal operating\nenvironment\
    \ of the host is also not small.\nAn alternative method for network connection\
    \ is to connect the host to some\nintermediate processor, and in turn, directly\
    \ connect that processor to the\nnetwork.  This approach is called \"Front-Ending.\"\
    \  There are many arguments\nwhich may be posed to justify a host connection to\
    \ a network through a front-\nend processor.  The most obvious being that the\
    \ responsibility for \nimplementation of the network protocols (the NCP) can be\
    \ delegated to the\nfront-end (FE), thereby reducing the impact on the host.\n\
    The purpose of this document is not to justify Front-Ending as a philosophy,\n\
    but rather, to introduce a protocol for communications between a host and\na front-end\
    \ processor which is providing it network access.  The Front End\nProtocol (FEP)\
    \ is intended to permit the host to make use of the network \nthrough existing\
    \ protocols, without requiring that it be cognizant of the \ncomplexities and\
    \ implementation detail inherent in their execution.\nThe FEP is sufficiently\
    \ general to permit its implementation in the host \nto be in terms of the function\
    \ the host is performing, or the services\nwhich it is providing.  Of primary\
    \ consideration in specification of FEP\nwas that it must provide the host with\
    \ a sufficiently robust command \nrepertoire to perform its network tasks, while\
    \ buffering it from the\ndetails of network protocols.\n                     \
    \          CONCEPTS\t\t\t\t\t3\nIntroduction\t\t\t\t\t\t\t\t3a\nBefore a detailed\
    \ description of the command structures is undertaken it \nseems appropriate to\
    \ introduce several of the concepts upon which the FEP\nis predicated.\nThe following\
    \ section serves to briefly describe the FEP commands, and to\nelaborate on the\
    \ concepts of addressing and types of connections provided.\n                \
    \       ***WORKING DOCUMENT***\nFront-End Protocol\n                        ***WORKING\
    \ DOCUMENT***\nCommands  (General)\t\t\t\t\t\t\t3b\n1.  BEGIN Command\nThis command\
    \ is sent from the host to the front-end processor.  Its function\nis to direct\
    \ the establishment of one or more network connections.  The type\nand number\
    \ of connections is specified in the BEGIN command string.\n2.  LISTEN Command\n\
    Through this command the host indicates its willingness to accept requests\nfor\
    \ connection arriving from other hosts.  It directs the front-end processor\n\
    to LISTEN for any such connection requests.  The number and type of \nconnections\
    \ are specified in the command string.\n3.  RESPONSE Command\nThe front-end processor\
    \ uses the RESPONSE command to indicate to the host that\na particular path specified\
    \ in a BEGIN or LISTEN command is now open or that\nthe open attempt failed.\n\
    4.  MESSAGE Command\nMessage text passing between the host and its front-end processor\
    \ is sent in\nthis command string.  The MESSAGE command is bi-directional, and\
    \ is the same \nfor host or front-end.\n5.  INTERRUPT Command\nThe INTERRUPT command\
    \ is sent by either the host of FE.  Its most common use is\nto convey that the\
    \ user wishes to terminate what he is doing - i.e., he has \ndepressed the Control-C,\
    \ ATTN, or INT key.\n6.  END Command\nOne or more connections may be closed by\
    \ either the FE or the host issuing\nthis command.  The connection(s) which are\
    \ affected by the action of the END  \nare specified in the command string.\n\
    7.  REPLY Command\nThis command is required to be sent by both the host and FE\
    \ to acknowledge\nreceipt of all command types (except REPLY).  The success or\
    \ failure of the\ncommand being acknowledged is conveyed in the REPLY command\
    \ string.\n                       ***WORKING DOCUMENT***\nFront-End Protocol\n\
    \                        ***WORKING DOCUMENT***\nConnections\t\t\t\t\t\t\t\t \
    \ 3c\nIn order to engage in a meaningful conversation, the parties involved must\n\
    be connected.  A network connection is defined by the ARPA Host-Host Protocol\n\
    document (Nic #8246) as follows : \"A connection couples two processes so\nthat\
    \ output from one process is input to the other.  Connections are defined\nto\
    \ be unidirectional, so two connections are necessary if a pair of processes\n\
    are to converse in both directions.\"  The components of a connection, the\nsockets,\
    \ are defined: \"... a socket forms the  reference for one end of a\nconnection,\
    \ and a connection is fully specified by a pair of sockets.  A \nsocket is identified\
    \ by a Host number and a 32-bit socket number.  The same\nnumber in different\
    \ Hosts represents different sockets.\"\nThe existing network protocols incorporate\
    \ prescribed strategies for \nselecting socket assignments, pairing sockets to\
    \ form connections, and in \nthe number of connections required to implement the\
    \ protocol.\nConversations, in most cases, are bi-directional.  Thus to simplify\
    \ the\nHost's procedures in these cases, FEP permits duplex connections on which\n\
    the Host can both send and receive.  Send only and Receive only connections \n\
    are also available for those situations where communication is one-way.\nThus,\
    \ FEP provides the flexibility to reduce complexity in the Host, in\naddition\
    \ to accommodating existing protocols and allowing for the \ndevelopment of new\
    \ protocols.\nAddressing\t\t\t\t\t\t\t\t3d\nConversations in FEP are uniquely\
    \ identified at initiation by some combination\nof Host address, Index number,\
    \ Path number and Socket assignment.  The Host \naddress and Socket assignment\
    \ are required to form the connection(s); there-\nafter the Index and Path are\
    \ sufficient to identify the conversation.\nHost Address\nIf, through the BEGIN\
    \ command, the local Host explicitly directs the creation\nof network connection(s),\
    \ it must specify the address of the foreign host to\nwhich it desires communication.\
    \  If the local host indicates a willingness to\ncommunicate, through the LISTEN\
    \ command, the Front-End processor will supply \nthe address of the connecting\
    \ foreign host(s) in its RESPONSE command(s).\n                     ***WORKING\
    \ DOCUMENT***\nFront-End Protocol\n                     ***WORKING DOCUMENT***\n\
    Socket\nA socket is either a send socket or a receive socket.  This property is\
    \ \ncalled the socket's gender.  The sockets at either end of a network \nconnection\
    \ must be of opposite gender.  As previously defined a socket\nforms the reference\
    \ for one end of a network connection.  To the extent\npossible, the FEP shields\
    \ the Host from the responsibility of assigning\nsockets for individual conversations.\
    \  However, because the \nsocket is a fundamental part of the addressing mechanism\
    \ of the network,\nthe Host may need to be aware of socket assignments when establishing\n\
    connections.\nIt is through a \"well-advertised\" socket that a host provides\
    \ services\nto other members of the network community.  The Initial Connection\
    \ \nProtocol (ICP) [1] is used to first connect to the well-advertised socket\n\
    in order to exchange the number of a presently unused socket which is then\nused\
    \ for the connections required so that the well-advertised socket can\nbe freed\
    \ for others attempting to connect.\nWhen establishing a conversation (with a\
    \ BEGIN or LISTEN command) the \nHost indicates in the value of the CONN-TYPE\
    \ field whether the socket \nspecified is to be employed directly, or to be used\
    \ as an initial \nconnection socket.\nIndex/Path Addressing\t\t\t\t\t\t\t3e\n\
    Indexes are values assigned by the local Host to identify network con-\nversations.\
    \  When conversations are established (with the BEGIN or LISTEN \ncommands) the\
    \ Host must specify an index value.  This value will be\nassociated with the resultant\
    \ conversations for their duration.\nIt is often necessary to affiliate conversations\
    \ [2].  To accommodate this, \ndata paths are defined such that each index has\
    \ one or more path(s) \nassociated with it (a path can not exist except as a subordinate\
    \ to an\nindex) and all network communication is transmitted on some path.\nThe\
    \ maximum number of indexes which may be in use at any one time, and the\nmaximum\
    \ number of paths within one index are installation parameters.\nIndex 0 is reserved\
    \ for controlling other indexes, and logically represent the\n\"pipe\" through\
    \ which all other indexes \"flow.\"\n                       ***WORKING DOCUMENT***\n\
    Front-End Protocol\n                        ***WORKING DOCUMENT***\nAddresses\
    \ in FEP command strings are conveyed by the pair of fields \"INDEX\"\nand \"\
    PATH.\"  In commands which cause new indexes to be opened, or new data \npaths\
    \ to be added to an existing index (BEGIN or LISTEN), the PATH field \nindicates\
    \ the first path to be acted upon by this command.  For those\ncommands which\
    \ do not create new paths or indexes, if PATH is 0, then all\npaths associated\
    \ with this INDEX are addressed; if PATH is non-zero, only the \nspecific path\
    \ within the specified INDEX is addressed.\nPath Types\t\t\t\t\t\t\t\t3f\nA path\
    \ can be one of three types:\n\ta.  DUPLEX - both the Host and the FE can issue\
    \ MESSAGE commands\n\t    on the path.\n\tb.  SEND - only the Host can issue MESSAGE\
    \ commands on the path.\n\tc.  RECEIVE - only the FE can issue MESSAGE commands\
    \ on the path.\nThe paths within an index may be a mixture of path types but one\
    \ BEGIN/\nLISTEN must be used for each contiguous set of the same type.\nAn FEP\
    \ path is analogous to a network connection with the following exception.\nNetwork\
    \ connections are always simplex.  This is true for paths of type SEND\nor RECEIVE.\
    \  However, a DUPLEX path is formed by the FE connecting two local\nsockets to\
    \ two foreign sockets.  This is a \"duplex connection\" which is\ncomposed of\
    \ two network (simplex) connections.\nModes of Establishing a Path\t\t\t\t\t\t\
    3g\nOne or more paths are established by the action of a single BEGIN or LISTEN\n\
    command, with the mode specified in the CONN-TYPE field of the command.\nEach\
    \ of the path types is established in one of two modes - directly or via \nICP.\
    \  The gender of the path (its ability to receive or send or both) is not\naffected\
    \ by the mode.\nWhen any of the path types is specified with the ICP mode, the\
    \ socket value\nin the SOCKET field is used as the \"well-advertised\" socket\
    \ and an actual\nworking socket will be exchanged according to the Initial Connection\
    \ Protocol.\nWhen the direct mode is indicated, the specified socket is used as\
    \ the working\nsocket.\n                        ***WORKING DOCUMENT***\nFront-End\
    \ Protocol\n                        ***WORKING DOCUMENT***\nIn either mode, when\
    \ multiple paths are indicated, the next higher socket\nnumber values of the appropriate\
    \ gender are selected for each path. [3]\nTranslation\t\t\t\t\t\t\t\t3h\nWhen\
    \ the Host sets up a path(s) (with a BEGIN or LISTEN command) it identifies\n\
    what type of translation or data-mapping it requires the FE to perform on all\n\
    data transmitted on this path(s).  This is specified by two values - one\ngiving\
    \ the format of the data transmitted between the FE and the network,\nthe other\
    \ giving the format of the data between the Host and the FE. [4]\nFlow Control\t\
    \t\t\t\t\t\t\t3i\nAll commands (except REPLYs) must be REPLYED to by the receiver.\
    \  The sender\nis blocked from sending more commands on the same path until a\
    \ REPLY has been\nreceived.  The REPLY command serves two functions:  it indicates\
    \ the\nsuccess/failure of the last transmission on the path, and it also indicates\n\
    a willingness of the receiver to accept more data on that path.  Receipt of\n\
    any valid REPLY on an open path is sufficient to unblock it for END or\nINTERRUPT\
    \ commands.  Thus a receiver who will not (or can not) accept more\ndata (MESSAGE\
    \ commands) on a given path need not block the sender from\nENDing the path if\
    \ he desires.  An indication of \"READY\" in the reply serves\nto unblock the\
    \ path for MESSAGE commands also.\nIn the normal case, the REPLY performs both\
    \ functions concurrently.  However,\nwhen the receiver is not ready to accept\
    \ more data, he can REPLY indicating\nonly success/failure of the last command\
    \ which should be sufficient to\nallow the sender to free the transmission buffer,\
    \ requeue the command for\nretransmission if necessary, etc. and wait for another\
    \ REPLY command \nannouncing the receiver's ability to accept more data.\nExceptional\
    \ Conditions\t\t\t\t\t\t\t3j\nWhen a command is received and can not be executed,\
    \ the REPLY command is used\nto notify the sender of the command.  To do this,\
    \ the bits of CODE field of\nthe REPLY are set to show the CATEGORY of the error\
    \ and its TYPE within that\ncategory (see Section 3h).\n                     \
    \   ***WORKING DOCUMENT***\nFront-End Protocol\n                        ***WORKING\
    \ DOCUMENT***\n                               COMMANDS\t\t\t\t\t4\nIntroduction\t\
    \t\t\t\t\t\t\t4a\nAll communications between the Host and the FE is performed\
    \ by means of\ncommands.  The commands are given names for documentation purposes\
    \ but are\ndistinguished by the binary value of the first field of the command\
    \ string.\nCommand strings will be padded with zeros up to the next multiple of\
    \ an\ninstallation defined parameter.  (This value will be dependent on the \n\
    capabilities of the hardware interface between the Host and the FE.)\nField lengths\
    \ within a command string are specified as some number of bits.\nThese information\
    \ bits will be right-justified within the least number of\nbytes needed to hold\
    \ them.  The size of a byte will be an installation\nparameter which will normally\
    \ be 8 bits but other values will be accommodated\nas necessary.\nThe values and\
    \ meanings of the CODE field of the REPLY command are given for\neach command\
    \ within the following descriptions:\n1:  BEGIN\t\t\t\t\t\t\t\t4b\nFormat\n  \
    \     \tBEGIN INDEX PATH HOST SOCKET TRANS-TYPE CONN-TYPE NPATHS\nUse\nThis command\
    \ is sent only from the Host to the FE.  Its function is to direct\nthe FE to\
    \ establish one or more logical connections (paths) on the specified\nindex between\
    \ the Host and the FE.\nIts use has three different modes (depending on the value\
    \ of the PATH field) :\n\tmode (a) - to set up a new index and to direct the FE\
    \ to attempt\n\tto establish network connections for the one or more paths\n\t\
    specified within this index.\n                       ***WORKING DOCUMENTS***\n\
    Front-End Protocol\n                        ***WORKING DOCUMENT***\n\tmode (b)\
    \ - to attempt to establish network connections for an\n\texisting (but at present\
    \ closed) path within the already set-up\n\tindex.\n\tMode (c) - to attempt to\
    \ establish network connections for\n\tone or more new paths within the already\
    \ set-up index.\nParameters\n\ta)  BEGIN is an 8-bit field with the value 1.\n\
    \tb)  INDEX is a 16-bit field, specifying the index.  Note that\n            the\
    \ value 0 is reserved for special use (see Section 4).\n\tc)  PATH is an 8-bit\
    \ field, specifying the path(s) which are\n\t    to be established.  Its value\
    \ identifies the mode of the\n\t    BEGIN (see above) :\n\t\tmode (a) - its value\
    \ must be 1.\n\t\tmode (b) - its value must be that of the path to be\n\t\t\"\
    re-opened.\"\n\t\tmode (c) - its value must be exactly one greater than\n\t\t\
    the current number of paths defined within this index.\n\td)  HOST is a 32-bit\
    \ field specifying the foreign host with\n\t    which connections are to be established.\n\
    \te)  SOCKET is a 32-bit field, specifying the first or only\n\t    socket at\
    \ the foreign host to which connections are to \n\t    be made.\n      \tf)  TRANS-TYPE\
    \ is a 16-bit field which directs the FE to\n\t    perform this type of translation\
    \ on all data (i.e. TEXT\n\t    in the MESSAGE command string) sent on every path\
    \ being\n\t    established by this command.  The first 8 bits specify\n\t    the\
    \ format of the data on the network side; the second \n\t    8 bits specify the\
    \ format of the data on the Host side.\t \n\t    The values assigned to the particular\
    \ formats (eq. ASCII,\n\t    EBCDIC etc.) are installation parameters; however,\
    \ the\n                        ***WORKING DOCUMENT***\nFront-End Protocol\n  \
    \                      ***WORKING DOCUMENT***\n\t    value 0 will always mean\
    \ \"bit string\" and thus if either\n\t    of the 8-bit sub-fields contains 0,\
    \ then no mapping will\n\t    be performed.\n        g)  CONN-TYPE is an 16-bit\
    \ field, specifying the type and mode\n\t    of connection(s) to be established\
    \ for the specified path(s).\n\t    Its value informs the FE how to associate\
    \ sockets with\n\t    indexes/paths (see Sections 2f and 2g).\n\t\tValue\t\t Type\t\
    \t Mode\n\t\t  7\t\tDuplex\t\tvia ICP\n\t\t  6\t\tDuplex\t\tdirect\n\t\t  5\t\t\
    Receive\t\tvia ICP\n\t\t  4\t\tReceive\t\tdirect\n\t\t  3\t\tSend\t\tvia ICP\n\
    \t\t  2\t\tSend\t\tdirect\n        h)  NPATHS is an 8-bit field, specifying the\
    \ number of paths which\n\tthis command directs the FE to attempt to establish\
    \ connections\n\tfor.  If the BEGIN is of mode (b) then its value must be 1.\n\
    \tOtherwise the sum of its value and the value of the PATH field\n\tis the new\
    \ current number of paths plus one.\nError CODES in REPLY\n\tCategory   Type\t\
    \t\tMeaning\n\t   3\t     1\t\tPATH invalid for new index\n\t   3\t     2\t\t\
    PATH invalid for old index\n\t   3\t     3\t\tPATH already open\n\t   3\t    \
    \ 4\t\tHOST unknown\n\t   3\t     5  \tTRANSLATION-TYPE invalid\n\t   3\t    \
    \ 6\t\tCONNECTION-TYPE invalid\n\t   3\t     7\t\tNPATHS invalid for old path\
    \ on old index\n\t   3\t     8\t\tSpecified socket inconsistent with CONN-TYPE\n\
    \t   3\t     9\t\tINDEX invalid, not ready for business\n\t   4\t     1\t\tNo\
    \ new connections - FE full\n\t   4\t     2\t\tNo new connections - closing down\
    \ soon\n                        ***WORKING DOCUMENT***\nFront-End Protocol\n \
    \                       ***WORKING DOCUMENT***\n2:  LISTEN\t\t\t\t\t\t\t\t4c\n\
    Format\n\tLISTEN INDEX PATH HOST SOCKET TRANS-TYPE CONN-TYPE NPATHS\nUse\nThis\
    \ command is sent only from the Host to the FE.\nIts function is to direct the\
    \ FE to \"listen,\" i.e., to hold the specified paths\npending until such time\
    \ as a request for connection (RFC) is received from the \nnetwork to the specified\
    \ local socket. then to set up connections and to \nrespond with a RESPONSE command\
    \ for each path.\nIts use has three different modes (depending on the value of\
    \ the PATH field) :\n\tmode (a) - to set up a new index and to listen on the specified\
    \ local\n\tsocket in order to establish connections for the specified paths.\n\
    \tmode (b) - to listen on the specified socket in order to establish\n\tconnections\
    \ for the specified, existing (but at present closed)\n\tpath within the already\
    \ set-up index.\n\tmode (c) - to listen on the specified socket in order to establish\n\
    \tconnections for the specified new path(s) within the already set-up\n\tindex.\n\
    By use of the HOST parameter, the FE can be directed to accept RFCs from any\n\
    host or only from the specified host.\nParameters\n\ta)  LISTEN is an 8-bit field\
    \ with value 2.\n\tb)  INDEX is a 16-bit field specifying the index.\n\tc)  PATH\
    \ is an 8-bit field specifying the first of the one or more\n\t    paths which\
    \ are to be held pending receipt of a RFC.  Its \n\t    value identifies the mode\
    \ of the LISTEN (see above) :\n                        ***WORKING DOCUMENT***\n\
    Front-End Protocol\n                        ***WORKING DOCUMENT***\n\t\tmode (a)\
    \ - its value must be 1.\n\t\tmode (b) - its value must be that of the existing\
    \ path.\n\t\tmode (c) - its value must be exactly one greater than\n\t\tthe current\
    \ number of paths within this index.\n\td)  HOST is a 32-bit field specifying\
    \ the host from which RFCs\n\t    are to be accepted; a value of 0 implies from\
    \ any host.\n\te)  SOCKET is a 32-bit field specifying the local socket on which\n\
    \t    the FE is to listen for RFCs.\n\tf)  TRANS-TYPE is a 16-bit field specifying\
    \ the type of translation\n\t    the FE is to perform on all data sent on every\
    \ path established\n\t    as a result of this command.  Its values are the same\
    \ as in the\n\t    BEGIN command.\n\tg)  CONN-TYPE is an 16-bit field specifying\
    \ the type and mode of the\n\t    connection(s) to be established for the specified\
    \ path(s) when\n\t    an RFC is received.  Its values are the same as in the BEGIN\n\
    \t    command.\n\th)  NPATHS is an 8-bit field specifying the number of paths\
    \ which\n\t    this command associates with the specified index and which are\n\
    \t    to be established.  If the LISTEN is of mode (b) then its value \n\t   \
    \ must be 1.  Otherwise the sum of its value and the value of the\n\t    PATH\
    \ field is the new current number of paths plus one, within\n\t    this index.\
    \  Thus its value is the number of extra RFCs for\n\t    which the FE is listening\
    \ on this socket.\nError CODEs in REPLY\n\tCategory      Type\t\t\tMeaning\n\t\
    \   3\t\t1\tPATH invalid for new index\n\t   3\t\t2\tPATH invalid for old index\n\
    \t   3\t\t3\tPATH already open\n\t   3\t\t4\tHOST unknown\n\t   3\t        5\t\
    TRANSLATION-TYPE invalid\n                        ***WORKING DOCUMENT***\nFront-End\
    \ Protocol\n                        ***WORKING DOCUMENT***\n\t   3\t\t6\tCONNECTION-TYPE\
    \ INVALID\n\t   3\t\t7\tNPATHS invalid for old path on old index\n\t   3\t\t8\t\
    Specified socket inconsistent with CONN-TYPE\n\t   3\t\t9\tINDEX invalid, not\
    \ ready for business\n\t   3\t       10\tSocket already in use.\n\t   4\t\t1\t\
    No new listens - FE full\n\t   4\t\t2\tNo new listens - closing down soon\n3:\
    \  RESPONSE\t\t\t\t\t\t\t\t4d\nFormat\n\tRESPONSE INDEX PATH CODE HOST SOCKET\n\
    Use\nThis command is sent only from the FE to the Host - once per path specified\
    \ in\na BEGIN or a LISTEN command.\nFor paths specified in a BEGIN, it is sent\
    \ to indicate the success or failure\nof the connection attempt.  For paths specified\
    \ in a LISTEN, it is sent at\nthe time when the FE has received a matching RFC\
    \ and has established the\nconnection.\nThe HOST and SOCKET parameters are purely\
    \ informational which the Host can \nignore if it so desires.  Their contents\
    \ are only guaranteed if the connection\nattempt succeeded.\nParameters\n\ta)\
    \  RESPONSE is an 8-bit field with value 3.\n\tb)  INDEX is a 16-bit field specifying\
    \ the index.\n\tc)  PATH is an 8-bit field specifying the particular path.\n\t\
    d)  CODE is a 16-bit field indicating the outcome of the\n\t    connection attempt:\n\
    \                        ***WORKING DOCUMENT***\nFront-End Protocol\n        \
    \                ***WORKING DOCUMENT***\n\t\tValue\t\t\tMeaning\n\t\t  0\t\tPath\
    \ successfully established.\n\t\t  1\t\tLocal IMP dead.\n\t\t  2\t\tForeign IMP\
    \ inaccessible.\n\t\t  3\t\tForeign Host dead.\n\t\t  4\t\tForeign Host not responding.\n\
    \t\t  5\t\tConnection refused.\n\te)  HOST is a 32-bit field specifying the foreign\
    \ host to which the\n\t    connection has been made.\n\tf)  SOCKET is a 32-bit\
    \ field specifying the socket at the foreign\n\t    host.  If the connection type\
    \ is simplex, then it is the only\n\t    foreign socket for this path; if duplex,\
    \ then it is the lower\n\t    of the two foreign sockets.\nError CODES in REPLY\n\
    \t\tCategory\tType\t   Meaning\n\t\t   3\t\t 11\tINDEX unknown\n\t\t   3\t\t 12\t\
    PATH unknown\n\t\t   3\t\t 13\tCODE invalid\n4:  MESSAGE\t\t\t\t\t\t\t\t4e\nFormat\n\
    \tMESSAGE INDEX PATH COUNT PAD TEXT\nUse\nThis command is sent by either the Host\
    \ or the FE to transmit data on the\nspecified path and index.\nParameters\n\t\
    a)  MESSAGE is an 8-bit field with value 4.\n\tb)  INDEX is a 16-bit field specifying\
    \ the index.\n                        ***WORKING DOCUMENT***\nFront-End Protocol\n\
    \                        ***WORKING DOCUMENT***\n\tc)  PATH is an 8-bit field\
    \ specifying the path.  Note that the value\n\t    0 is used in the broadcast\
    \ option (see Section 3j).\n\td)  COUNT is a 16-bit field specifying the number\
    \ of bits of data\n\t    in the TEXT field.\n\te)  PAD is an n-bit field, where\
    \ n is an installation parameter.\n\t    It contains only padding (in the present\
    \ protocol specification)\n\t    and can be used to enable the host to have the\
    \ TEXT field start\n\t    on a convenient boundary.\n\tf)  TEXT is a field containing\
    \ COUNT bits of data being transmitted\n\t    on this path.\nError CODES in REPLY\n\
    \tCategory\tType\t\tMeaning\n\t   2\t\t  1\tThis option not implemented\t   \n\
    \           3\t\t 12\tPATH unknown\n\t   3\t\t 14\tNo connection opened in this\
    \ direction\n\t   3\t\t 15\tPATH blocked at this time, resent later\n\t   3\t\t\
    \ 16\tPATH suspended at this time, resent later\n\t   3\t\t 17\tPATH closed\n\t\
    \   3\t\t 17\tCOUNT too large\n\t   4\t\t  3\tError in transmitting data, resend\
    \ command\n\t   4\t\t  4\tData lost, resent command.\n5:  INTERRUPT\t\t\t\t\t\t\
    \t\t4f\nFormat\n\tINTERRUPT INDEX PATH CODE\nUse\nThis command is sent by either\
    \ the Host or the FE.\nIts most common use is to pass the information that a terminal\
    \ user has\npressed his INT (or ATTN or Control-C) key, thereby requesting his\
    \ \napplications program to quit what it is doing for him.[5]\n              \
    \          ***WORKING DOCUMENT***\nFront-End Protocol\n                      \
    \  ***WORKING DOCUMENT***\nParameters\n\ta)  INTERRUPT is a 8-bit field with value\
    \ 5.\n\tb)  INDEX is a 16-bit field specifying the index.\n\tc)  PATH is an 8-bit\
    \ field specifying the path on which the\n\t    INTERRUPT is transmitted.  Note\
    \ that the value 0 is used in\n\t    the broadcast option (see Section 3j).\n\t\
    d)  CODE is a 16-bit field.  It has no defined meanings as yet\n\t    and should\
    \ contain 0.\nError CODES in REPLY\n\tCategory\tType\t\tMeaning\n\t   2\t\t  1\t\
    This option not implemented\n\t   3\t\t 11\tINDEX unknown\n\t   3\t\t 12\tPATH\
    \ unknown\n\t   3\t\t 14\tNo connection opened in this direction\n\t   3\t\t 15\
    \     PATH blocked at this time, resend later\n\t   3\t\t 17\tPATH closed.\n6:\
    \  END\t\t\t\t\t\t\t\t\t  4g\nFormat\n\tEND INDEX PATH CODE\nUse\nThis command\
    \ is sent by either the Host or the FE, to terminate a connection.\nIf PATH is\
    \ 0, then the index and all its paths are terminated, otherwise just\nthe specified\
    \ path of the index is terminated.\nParameters\n\ta)  END is an 8-bit field with\
    \ value 6.\n\tb)  INDEX is a 16-bit field specifying the index.\n            \
    \           ***WORKING PARAMETER***\nFront-End Protocol\n                    \
    \    ***WORKING DOCUMENT***\n\tc)  PATH is an 8-bit field containing the path\
    \ to be closed, or 0 if\n\t    the whole index is to be closed.\n\td)  CODE is\
    \ a 16-bit field indicating the reason for the closure:\n\t\tValue\t     Meaning\n\
    \t\t  0\tNormal close\n\t\t  1\tRetries exhausted\n\t\t  2\tForeign Host failure\n\
    \t\t  3\tForeign IMP failure\n\t\t  4\tNetwork failure\n\t\t  5\tLocal IMP failure.\n\
    \t    The \"Retries exhausted\" code indicates that the FE has been \n\t    retrying\
    \ a transmission to the foreign host without success.\nError CODES in REPLY\n\t\
    Category\tType\t\tMeaning\n\t   3\t\t 11\tINDEX unknown\n\t   3\t\t 12\tPATH unknown\n\
    \t   3\t\t 13\tCODE unknown\n\t   3\t\t 15\tPATH blocked at this time, resend\
    \ later\n\t   3\t\t 17\tPATH closed.\n7:  REPLY\t\t\t\t\t\t\t\t   4h\nFormat\n\
    \tREPLY INDEX PATH CODE\nUse\nThis command is sent by both the Host and the FE\
    \ to acknowledge receipt of \nevery other type of command (including those on\
    \ index 0, see Section 4) and/or\nto unblock that particular direction of an opened\
    \ path for the transmission\nof another command.\nNote that the INDEX and PATH\
    \ fields contain exactly the same as those of the\ncommand being replied to.\n\
    \                        ***WORKING DOCUMENT***\nFront-End Protocol\n        \
    \                ***WORKING DOCUMENT***\nParameters\n\ta)  REPLY is an 8-bit field\
    \ with value 7.\n\tb)  INDEX is a 16-bit field specifying the index.\n\tc)  PATH\
    \ is a 8-bit field specifying the path.\n\td)  CODE is a 16-bit field indicating\
    \ the success/failure of the\n\t    command being REPLYed to, and the sender's\
    \ readiness for more\n\t    commands on the same path.  It is divided into four\
    \ subfields -\n\t    STATUS, COMMAND, CATEGORY, and TYPE.\t\n\t\t1)  STATUS is\
    \ 4 bits wide\n\t\t    bit 0 (right-most) - READY\n\t\t    bit 1\t       - NOT-READY\n\
    \t\t    bit 2              - ACK\n\t\t    bit 3\t       - NAK\n\t        ACK=1\
    \ indicates that the sender (of the REPLY) has accepted\n\t\tthe command (being\
    \ REPLYed to).  NAK=1 indicates that the\n\t\tsender has discarded the command\
    \ (with the reason given by\n\t\tthe settings of the other bits of the CODE field).\n\
    \t\tNOT-READY=1 indicates that the sender (of the REPLY) is\n\t\twilling to receive\
    \ an END or INTERRUPT on this path.  \n\t\tREADY=1 indicates that MESSAGE commands\
    \ will also be received.\n\t\tNormally only one REPLY command will be sent for\
    \ each\n\t\tother command.  However MESSAGE, INTERRUPT, RESPONSE and\n\t\tinvalid\
    \ END commands can be replied to by a REPLY with\n\t\tACK (or NAK)=1 and NOT-READY=1\
    \ and another REPLY, some\n\t\ttime later, with READY=1. [6]\n\t\tThe ACK and\
    \ NAK bits are mutually exclusive and should\n\t\tnever both be on simultaneously,\
    \ and similarly the READY\n\t\tand NOT-READY bits.\n\t\tNote that the READY/NOT-READY\
    \ bit settings are only\n \t\trelevant when a path is open.\n                \
    \        ***WORKING DOCUMENT***\nFront-End Protocol\n                        ***WORKING\
    \ DOCUMENT***\n\t\t2)  COMMAND is 4 bits wide.  It indicates the command for\n\
    \                    which this is a REPLY :\n\t\t\tValue\t     Meaning\n\t\t\t\
    \  0\tany of the following\n\t\t\t  1\tBEGIN\n\t\t\t  2\tLISTEN\n\t\t\t  3\tRESPONSE\n\
    \t\t\t  4\tMESSAGE\n\t\t\t  5\tINTERRUPT\n\t\t\t  6\tEND\n\t\t    The value 0\
    \ is defined for cases where a Host does not\n\t\t    wish to incur any overhead\
    \ required to fill in the\n\t\t    non-zero value.\n    \t\t3)  CATEGORY is 3\
    \ bits wide.  It specifies the category of \n\t\t    the error indicated by the\
    \ ACK bit being off :\n\t\t\tValue\t     Meaning\n\t\t\t  1\tCommand not recognized\n\
    \t\t\t  2\tOption not implemented\n\t\t\t  3\tInvalid\n\t\t\t  4\tAction failed.\n\
    \t\t    Its value is relevant only when NAK=1.\n\t\t4)  TYPE is 5 bits wide. \
    \ It specifies which error occurred.\n\t\t    Its value is relevant only when\
    \ NAK=1.  The possible values\n\t\t    and meanings for the various errors and\
    \ their corresponding\n\t\t    CATEGORY subfield values are given under the description\n\
    \t\t    of each command.\nSequencing\t\t\t\t\t\t\t\t  4i\nOnce communication between\
    \ the Host and the FE has been established and each \nside is \"Ready for Business\"\
    \ (see Section 4b) the Host may at any time send\nBEGIN or LISTEN commands for\
    \ new indexes.  The FE will acknowledge a BEGIN or\n                        ***WORKING\
    \ DOCUMENT***\nFront-End Protocol\n                        ***WORKING DOCUMENT***\n\
    LISTEN with a REPLY and the index is then set-up providing that the REPLY\nindicates\
    \ no errors.  Other BEGIN or LISTEN commands for the new paths on the\nsame index\
    \ may be sent at any time after the index is set-up.\nThe FE will send a RESPONSE\
    \ command for each path on completion of its attempts\nto fulfill the Host's instructions.\
    \  If an attempt failed (indicated by the\nCODE field) then the path remains closed\
    \ and another BEGIN or LISTEN for that \npath can be sent.  If the attempt was\
    \ successful, then MESSAGE or INTERRUPT \ncommands can be sent after the Host\
    \ has REPLYED to the RESPONSE.\nAn INTERRUPT or END command may be sent on any\
    \ opened path after receiving\na REPLY for the previous command on the same path\
    \ in the same direction.  A\nMESSAGE command may be sent if in addition the READY\
    \ bit was on in the last\nREPLY command.\nNew paths on the same index may be opened\
    \ at any time after the index has\nbeen set-up, or particular paths may be ENDed\
    \ and then have new BEGINs or\nLISTENs for them issued.  An index remains set-up,\
    \ even if all its paths are\nclosed, until an END command with PATH=0 is issued\
    \ for the index.\nCommunication between the Host and the FE is terminated by an\
    \ END with INDEX=0\nand this will abort any remaining open paths and indexes.\n\
    Broadcasting\t\t\t\t\t\t\t\t  4j\nBroadcasting is an optional feature of the protocol.\
    \  If it has been enabled\nby the installation parameter, then the Host may send\
    \ a MESSAGE or INTERRUPT \ncommand on a particular index with PATH=0.  This instructs\
    \ the FE to send the \ndata contained in the TEXT field of the MESSAGE command\
    \ (or an interrupt) on\nevery network connection corresponding to an open path\
    \ of the specified index.\nThis feature will only occur on MESSAGEs from the Host\
    \ to the FE (since no\nutilization of it in the other direction is envisaged).\n\
    A broadcast MESSAGE is replied to with one or two REPLYs in the same way\nas any\
    \ other MESSAGE command.  Flow control within the index is maintained\nas if broadcast\
    \ MESSAGEs were sent on a separate path, i.e., flow control\non other paths is\
    \ not directly affected.\n                        ***WORKING DOCUMENT***\nFront-End\
    \ Protocol\n                        ***WORKING DOCUMENT***\nNote that for a broadcast\
    \ MESSAGE command the FE will perform translation\non the data for each path in\
    \ accordance with the BEGIN or LISTEN which\ninitiated that path.  Thus, care\
    \ must be taken when all paths of the\nparticular index do not have the same format\
    \ on the Host side specified in \ntheir TRANS-TYPE (see Section 6b).\nIndex 0\t\
    \t\t\t\t\t\t\t\t  5\nIntroduction\t\t\t\t\t\t\t\t  5a\nIndex 0 provides a control\
    \ link between the Host and the FE, and thus has no\nnetwork connections directly\
    \ associated with it.  The commands on this index\nare used to establish and terminate\
    \ the connection between Host and FE and to\ncontrol other indexes.\nPath 0\t\t\
    \t\t\t\t\t\t\t  5b\nPath 0 of Index 0 is used to pass global commands - i.e.,\
    \ those which do not\nrefer to any particular index or path.  The currently defined\
    \ commands are :\n\tMESSAGE INDEX=0 COUNT PAD TEXT\n\t    where TEXT = COMMAND\
    \ [PARM1] [PARM2]\n\t    COMMAND is 8 bits long\n\t    PARM1 and PARM2 are 16\
    \ bits long\n\ta)  COMMAND=1 , PARM1=Hostid\n\tThis is the \"Ready for Business\"\
    \ command which must be sent by both \n\tHost and FE to establish communication\
    \ between them.  Count gives the\n\tlength of the TEXT field as usual.  If COUNT=8,\
    \ then just the COMMAND\n\tfield is present.  If COUNT=24, then both the COMMAND\
    \ and Hostid are\n\tpresent.\n\tThe FE will never send a Hostid.  The Host may\
    \ send its Hostid in the\n\tevent that the FE is connected to more than one IMP\
    \ or if alternate\n\troutes to the network exist (e.g., via patch panels).\n\t\
    Until both sides have sent this command no other command is valid.\n\tb)  COMMAND=2\
    \ , PARM1=M , PARM2=N\n                        ***WORKING DOCUMENT***\nFront-End\
    \ Protocol\n                        ***WORKING DOCUMENT***\n\tThis is the \"CLOSING\"\
    \ command which is a purely information indication\n\tthat the sender's FEP module\
    \ has been told that communication will be\n\tterminated in M minutes for a period\
    \ of N minutes (N=0 implies\n\tunknown).\n\tNo action is required of the receiver,\
    \ however he may be able to\n\tdistribute the information to his users.\n\tc)\
    \  COMMAND=3\n\tThis is the \"CONTINUE\" command which indicates that any previous\n\
    \tCLOSING command is now no longer true.\n\t\tEND INDEX=0 PATH+0 CODE\n\tThis\
    \ command terminates the connection between the HOST and FE.  All\n\tother paths/indexes\
    \ are automatically aborted and the FE will close\n\tall network connections.\
    \  The values of the CODE field are the same\n\tas in the general END command.\n\
    Path 1\t\t\t\t\t\t\t\t\t  5c\nPath 1 is reserved for commands specific to a particular\
    \ path or index.  No\ncommands are presently defined; they will be at a later\
    \ date when more\nexperience has been gained on the need for them.\nPath 2\t\t\
    \t\t\t\t\t\t\t  5d\nPath 2 of Index 0 is used for Operator-to-Operator communication\
    \ between the\nHost and the FE.  It is an optional feature which is enabled by\
    \ an installation\nparameter.\nMESSAGE commands are formatted in the normal manner\
    \ with the sender requesting\nthat the TEXT field be displayed to the receiver's\
    \ system operator.\nScenarios\t\t\t\t\t\t\t\t    6\t\nThe following scenarios\
    \ are included to provide the reader with a \"feeling\" for\nFEP in a varied set\
    \ of applications.  The examples selected relate to existing\nARPANET protocols\
    \ or other networking applications, and do not represent an\nexhaustive list of\
    \ capabilities.\t\t\t\t\t    6a\n                       ***WORKING DOCUMENT***\n\
    Front-End Protocol\n                        ***WORKING DOCUMENT***\nFields which\
    \ are variable or not relevant are not shown (for purposes of \nclarity) in the\
    \ command strings in the following examples.\t\t  6b\nHost Implementation of User\
    \ TELNET\t\t\t\t\t  6c\n\tBEGIN ndxa,PATH=1,host,SKT=1,,CONN-TYPE=duplex+ICP,NPATHS=1\n\
    The User TELNET process in the Host causes the BEGIN command to be issued.  \n\
    When a successful RESPONSE has been returned by the FE, a typical duplex\nTELNET\
    \ connection will have been made to the Host specified in the BEGIN.\nHost is\
    \ Providing Server TELNET\t\t\t\t\t\t  6d\n\tLISTEN ndxa,PATH-1,HOST=0,SKT=1,,CONN-TYPE=duplex+ICP,NPATHS=32\n\
    With this one command the Server TELNET process in the Host has conditioned\n\
    the FE to LISTEN on Socket 1 (the well-advertised TELNET socket) and to\nestablish\
    \ as many as 32 duplex data paths.  The FE, through the RESPONSE\ncommand, will\
    \ report each connection as it occurs.  Path 1 will represent\nthe first such\
    \ duplex connection, etc.  The Host may then manage the data\npaths individually.\
    \  Individual paths may be ended and placed back into a\nLISTENing state by the\
    \ Host.  If at any time an END command specifying this\nINDEX with a PATH of 0\
    \ were to be sent by the Host, all connections would\nbe dissolved, and for all\
    \ practical purposes, the Host is no longer willing\nto provide Server TELNET\
    \ services.\nHost is Providing Server FTP\t\t\t\t\t\t  6e\n\tLISTEN ndxa,PATH=1,HOST=0,SKT=3,,CONN-TYPE=duplex+ICP,NPATH=1\n\
    As soon as a RESPONSE for this LISTEN comes from the FE, the Host Server FTP\n\
    process should select a new INDEX and issue a new LISTEN for ndxb on socket 3.\n\
    The duplex connection which has been made is the control path for the file\ntransfer.\
    \  Based upon control information passed between server and user on\nndxa (path\
    \ 1) the server FTP will either:\n\tBEGIN ndxa,PATH=2,(hostid etc. from response),NPATHS=1\n\
    \    OR\n\tLISTEN ndxa,PATH=2,(hostid etc. from response),NPATHS=1\n         \
    \               ***WORKING DOCUMENT***\nFront-End Protocol\n                 \
    \       ***WORKING DOCUMENT***\nWhen a RESPONSE command has been received to the\
    \ previous command, the data\nconnection (PATH 2) will have been made and transfer\
    \ of data may begin.  The\nvalues for TRANS-TYPE and CONN-TYPE for the LISTEN\
    \ or BEGIN will be derived\nfrom the exchange of information on the control path.\n\
    Host Is User FTP\t\t\t\t\t\t\t  6f\n\tBEGIN NDXA,PATH=1,HOSTID,SKT-3,,CONN-TYPE-duplex+ICP,NPATH=1\n\
    when a RESPONSE to this command has been returned by the FE the control path\n\
    will have been connected.  The Host, after exchanging information on the \ncontrol\
    \ path, may then proceed by issuing a BEGIN or LISTEN as in the Server \nFTP example.\n\
    Teleconferencing\t\t\t\t\t\t\t  6g\nAn INDEX with n PATHs permits up to n otherwise\
    \ disassociated conversations\nto be affiliated.  Each path can be manipulated\
    \ individually, or all paths as\na group.  With the broadcast option -- a MESSAGE\
    \ command specifying INDEX but\nnot specifying PATH will be broadcast to all open\
    \ paths on that index.  Thus\neach host may direct its messages to any or all\
    \ parties.\nA \"conference\" may be initiated by any host who issues a LISTEN\
    \ with multiple\nduplex paths on an agreed upon (but not necessarily well advertised)\
    \ socket. \nWhen some foreign host connects, an ordinary TELNET connection exists.\
    \  If,\nhowever, a third or forth or more parties connect, the hosts already engaged\n\
    in the conversation may elect to inform the late comers of the members already\n\
    involved.  Each host may then elect to connect to as many other hosts as he \n\
    desires.  (The parties could agree as to who would BEGIN and who would LISTEN).\n\
    Following this scheme [it is not a protocol] all parties participate equally,\n\
    there is no moderator.  Each host decides to whom he will speak.  Using the \n\
    initial LISTEN, a variation on this would permit the LISTENer to be moderator\
    \ \nand require that he relay messages to other parties, as desired.\nIn summary,\
    \ the data path mechanism permits a group of users to select an\nagreed upon socket,\
    \ appoint a \"moderator,\" and at a prescribed time engage in\na conference without\
    \ benefit of special protocol implementations in the FE\nor in any of the hosts\
    \ (except possibly the moderator).\n                        ***WORKING DOCUMENT***\n\
    Front-End Protocol\n                        ***WORKING DOCUMENT***\nExample of\
    \ the Use of Simplex Connections\t\t\t\t    6h\nThe Simplex connection types permits\
    \ a host to LISTEN on a group of simplex\nsockets of a particular gender.  If\
    \ the host supported a group of line \nprinters, for example, the Line Printer\
    \ Applications Program could perform a \nLISTEN on a socket advertised to be his\
    \ \"Printing Socket,\" specifying as many\nreceive paths as he had printers. \
    \ Foreign hosts could then connect (via ICP) \nto his print socket.  They would\
    \ be given an appropriate working socket value\nand then connect to an available\
    \ printer.  In this way up to n foreign hosts\nmay be connected to his n printers\
    \ at all times.  All that any needs to know\nto avail themselves of printing services\
    \ is the server host's print socket.\n[1]\nHost Implementation\t\t\t\t\t\t\t \
    \ 7\nConcepts\t\t\t\t\t\t\t\t  7a\nThe Front-End Protocol permits a Host to make\
    \ use of the network through\nexisting low-level protocols, without requiring\
    \ that it be cognizant of the\nimplementation details of those protocols.\nImplementation\
    \ of FEP in the Host is in terms of the function it is performing\nor the service\
    \ it is providing.  Information regarding sockets is available\nto the sophisticated\
    \ user, but can be ignored if not relevant to the problem\nat hand.\nThe Host\
    \ should provide the equivalent of a BEGIN, LISTEN, MESSAGE, INTERRUPT,\nand END\
    \ command.  In other words, the human user or applications level process\nhas\
    \ at its disposal the full power of FEP.\nThe FEP module in the Host serves as\
    \ a control mechanism to multiplex/\ndemultiplex traffic between itself and the\
    \ FE.  In appearance and function it \nis much like any multi-line interface driver.\
    \  It handles REPLYS, reports \nerrors, etc.  The FEP module must also assume\
    \ the responsibility for assignment\nof indexes.  This could easily be implemented\
    \ as a \"GETINDEX\" subroutine\nwhich would allow a user to ask for an index to\
    \ be assigned to him.  The\nuser could then proceed to do BEGINs, LISTENs, etc.\
    \ on that index.\nA server process makes itself available to the network at large\
    \ by issuing an \nappropriate LISTEN.  The Host FEP module would not have to be\
    \ aware of what\nservers were implemented or in operation.  The server process,\
    \ when it was \n                        ***WORKING DOCUMENT***\nFront-End Protocol\n\
    \                        ***WORKING DOCUMENT***\nactivated, could do a \"GETINDEX,\"\
    \ followed by a LISTEN on its well-advertised\nsocket, and then proceed from there.\
    \  The Host FEP module simply associates\nindexes to processes and passes the\
    \ incoming traffic to the appropriate process\nfor analysis and response.  It\
    \ maintains flow between itself and the FE through\nthe generation and receipt\
    \ of REPLYs.\nThe type of data structures, or format of information employed in\
    \ the \nimplementation of the FEP commands in the Host is, of course, up to the\n\
    implementor.  BEGIN could be a macro call, with the various information\npassed\
    \ as parameters to the Host FEP module -- which would then arrange it\ninto a\
    \ command for delivery to the Front-End processor.  The important\nconsideration\
    \ is not how the commands are implemented, but simply that their \nfunction is\
    \ provided.  It might be desirable, for instance, to implement the\nHost such\
    \ that the front-end processor looks like a special I/O device.  In\nthis case,\
    \ it may be appropriate to implement a form of OPEN [for BEGIN or \nLISTEN], a\
    \ GET or PUT [for MESSAGE], CLOSE [for END], etc...\nRegardless of the implementation\
    \ details, it appears that, while it is the\nresponsibility of one control module\
    \ to assign and manage INDEXes, data paths\nare entirely the responsibility of\
    \ the process which \"owns\" the INDEX.\nInstallation Parameters\t\t\t\t\t\t\t\
    \  7b\nTo package the software for the FE for a given Host, that Host supplies\
    \ a\nnumber of parameters defining what FE capabilities it requires.  These\n\
    parameters are input to a system-generation procedure to produce the particular\n\
    FE code.\nThe parameters are:\n\tByte Size\n\tThis gives the size in bits, into\
    \ a multiple of which each and every\n\tfield of a command string will be right-justified\
    \ (i.e., the\n\tinformation bits come last, preceded by as many padding bits as\
    \ are\n\tneeded to complete the least integral number of bytes).\n\tIts value\
    \ will normally be 8 but other values will be accommodated\n\tas necessary.\n\
    \                        ***WORKING DOCUMENT***\nFront-End Protocol\n        \
    \                ***WORKING DOCUMENT***\n\tCommand String Padding\n\tThis gives\
    \ the size in bits of the width of the hardware interface\n\tbetween the Host\
    \ and the FE, such that every command string\n\ttransmitted in either direction\
    \ will have padding appended to\n\tcomplete the least multiple of this width.\n\
    \tIn the typical implementation, this parameter will be 0 and any\n\tpadding required\
    \ will be appended/discarded by the line protocol\n\tunderlying FEP.\n\tPad Field\
    \ Length\n\tThis gives the size in bits of the PAD field in the MESSAGE command.\n\
    \tThis enable a Host to have the TEXT field start on a convenient\n\tboundary.\n\
    \tIts value can be anywhere in the range 0 to 64.\n\tMaximum of MESSAGE\n\tThis\
    \ gives the maximum length of a MESSAGE command string.\n\tBecause buffer allocation\
    \ in the FE is based on this parameter,\n\tits value should be chosen with care.\n\
    \tMaximum number of Indexes\n\tThis gives the maximum number of indexes which\
    \ may be set-up at any one\n\ttime.\n\tMaximum Number of Paths\n\tThis gives the\
    \ maximum number of paths within one index which may be\n\topen at any one time.\n\
    \tTranslation Types\n\tThis gives the set of required values and meanings of the\
    \ TRANS-TYPE\n\tfield of the BEGIN/LISTEN commands.  The TRANS-TYPE field is divided\n\
    \tinto two 8-bit subfields; the first giving the format of data on the\n     \
    \                   ***WORKING DOCUMENT***\nFront-End Protocol\n             \
    \           ***WORKING DOCUMENT***\n\tnetwork side; the second giving the format\
    \ of data on the Host side.\n\tThe FE is required to translate between these formats\
    \ all data\n\tcontained in the TEXT field of MESSAGE commands.\n\tThis parameter\
    \ specifies the required formats and their values in the\n\t8-bit subfields. \
    \ The value 0 is reserved to mean \"bit-string\" and\n\twhen it appears as either\
    \ (or both) of the subfields it implies no \n\ttranslation is to be done.\n\t\
    Broadcast Option\n\tThis specifies whether the Host wants to be able to use the\
    \ Broadcast\n\tfeature (see Section 3j).\n\tOperator-to-Operator Communication\
    \ Option\n\tThis specifies whether the Host wants the ability to send messages\n\
    \tto the FE operator or to have the Host's operator receive messages\n\tfrom the\
    \ FE.\nOther options may be included in the protocol at some later date and these\
    \ will\nbe available through installation parameters similar to the Broadcast\
    \ option.\nNote that all of these parameters affect the size and complexity of\
    \ the FE \ncode.  Thus it is important that their values be chosen carefully so\
    \ as to \nmaximize FE efficiency while minimizing Host implementation effort.\n\
    For descriptions of individual Host implementations and a list of the options\n\
    available so far, see Appendix D.\nFE Implementation\t\t\t\t\t\t\t  8\nFEP is\
    \ device independent.  For the present however, an initial implementation\nwill\
    \ be accomplished using the DEC PDP/11 computer as the FE device and the\nfront-end\
    \ software is to be based upon an extended version of the original ELF\nsystem\
    \ developed at SCRL.\nFor more detailed information, see Appendix C.\n\tby :\t\
    \t\t\t\t\t\t\t  9\n\t\tG. W. Bailey\t(BAILEY@OFFICE-1)\n\t\tK. McCloghrie   (MCCLOGHRIE@OFFICE-1)\n\
    \                        ***WORKING DOCUMENT***\nFront-End Protocol\n        \
    \                ***WORKING DOCUMENT***\n                              APPENDIX\
    \ A\t\t\t\t  10\n                              References\n[1]\tICP is used in\
    \ this document in a less strict manner than specified\n\tin NIC 7101, in that\
    \ it is not necessarily two simplex connections\n\tthat are set up as the result\
    \ of the exchange of the socket number\n\ton the initial connection.\n[2]\tAn\
    \ example of connections needing to be affiliated, is in the\n\timplementation\
    \ of FTP, where the control connection and the data\n\tconnection have a defined\
    \ relationship in their socket assignments.\n[3]\tNote that a range of socket\
    \ numbers is reserved for use by an index\n\twhen it is set-up (cf. AEN).\n\t\
    However, socket numbers for the paths of an index are not necessarily\n\tcontiguous.\
    \  For instance, when the next path opened after a SEND\n\tpath is another SEND\
    \ path, or when a path other than the first of an\n\tindex is opened with ICP\
    \ specified.  Nevertheless, if a protocol\n\trequires contiguous sockets, then\
    \ the opening of the paths in a logical\n\tmanner will provide the contiguity.\n\
    [4]\tOne possible translation will be from a Network Virtual Terminal on\n\tthe\
    \ network side to a local terminal type on the Host side.\n[5]\tThe FE will directly\
    \ equate the INTERRUPT command with the Host-Host\n\tprotocol INR/INS commands.\n\
    [6]\tNote that the READY indication in a REPLY is, in the general case,\n\tnot\
    \ directly related to a network RFNM; unless it is heavily loaded, \n\tthe FE\
    \ will be buffering possibly more than one message (in either\n\tdirection) until\
    \ flow control mechanism allow the messages to be sent\n\ton.\n\tHowever, it is\
    \ possible that a particular Host might wish to have\n\tknowledge of receipt of\
    \ a previous message before transmitting the\n\tnext.  In this case, the FEP implementation\
    \ could be set up to only\n\tindicate READY after receiving the RFNM and possibly\
    \ only send RFNMs\n\tafter receiving a REPLY containing an ACK.\n            \
    \            ***WORKING DOCUMENT***\nFront-End Protocol\n                    \
    \    ***WORKING DOCUMENT***\n                              APPENDIX B\t\t\t\t\
    \  11\n                            State Diagrams\nIn the state diagrams below\
    \ the following notation is used:\n\tREPLY(A)    - REPLY with ACK=1, READY/NOT-READY\
    \ irrelevant\n\tREPLY(N)    - REPLY with NAK=1, READY/NOT-READY irrelevant\n\t\
    REPLY(R)    - REPLY with ACK=0, NAK=0, READY=1\n\tREPLY(A+R)  - REPLY with ACK=1,\
    \ READY=1\n\tREPLY(N+R)  - REPLY with NAK=1, READY=1\n\tREPLY(A+NR) - REPLY with\
    \ ACK=1, NOT-READY=1\n\tREPLY(N+NR) - REPLY with NAK=1, NOT-READY=1\n        \
    \               State Diagram for INDEX\n\t!       !BEGIN(new index)   !     \
    \  !           !     !\n\t!       !->--------------->-!Index  !           !  \
    \   !\n\t!Index  !LISTEN(new index)  !Open   !           !     !\n\t!Closed !\
    \                   !Pending!           !Index!\n\t!       !           REPLY(N)!\
    \       !REPLY(A)   !Open !\n\t!       !     REPLY(A)!Index  !               \
    \  !     !\n\t!       !-<---------<-!Close  !REPLY(N)         !     !\n\t!   \
    \    !             !Pending!->------------->-!     !\n                       \
    \ ***WORKING DOCUMENT***\nFront-End Protocol\n                        ***WORKING\
    \ DOCUMENT***\n                        APPENDIX B (continued)\n              \
    \       State Diagram for Whole Path\n\t/------\\BEGIN       /----------\\\n\t\
    !      !LISTEN      !Connection!               \n\t!Path  !            !Pending\
    \   !REPLY(A)        /-------\\\n\t!Closed!    REPLY(N)!          !->------------>-!\
    \       !\n\t!      !            !Path !                     !       !\n\t!  \
    \    !    REPLY(A)!Abort!          END(PATH>0)!       !\n\t!      !-<--------<-!Pend-!-<-----------------<-!\
    \       !\n\t!      !            ! ing !                     !       !\n\t!  \
    \    !            !     !REPLY(N)             !       !\n           /----\\  \
    \          !Path   !-<--------------<-!       !\n\t   !    !            !Open\
    \   !                  !       !\n\t   !Path!            !Pending!REPLY(N)   \
    \       !       !\n           !Open!    REPLY(A)!       !->-------------->-! \
    \      !\n                        ***WORKING DOCUMENT***\nFront-End protocol\n\
    \                        ***WORKING DOCUMENT***\n                        APPENDIX\
    \ B (continued)\n               State Diagram for Each Direction of Path\n\t/----\\\
    MESSAGE             /-------\\             /-------\\\n\t!Path!INTERRUPT     \
    \      !Command!->--------->-!Message!\n\t!Open!                    !Blocked!REPLY(N+NR)\
    \  !Blocked!\n\t!    !          REPLY(A+R)!       !    INTERRUPT!       !\n\t\
    !    !          REPLY(N+R)\\-------/             !       !\n\t!    !END(PATH>0)\
    \         /-------\\  END(PATH>0)!       !\n\t!    !          REPLY(N+R)!Path\
    \   !REPLY(N)     !       !\n\t!    !-<----------------<-!Close  !->--------->-!\
    \       !\n\t\\----/                    !Pending!             \\-------/\n\t/------\\\
    \          REPLY(A)!       !\n\t!Path  !-<--------------<-!       !\n\t!Closed!\
    \                  !       !\n\t\\------/\n                        ***WORKING\
    \ DOCUMENT***\nFront-End Protocol\n                        ***WORKING DOCUMENT***\n\
    \                              APPENDIX C\n                       Front-End Implementation\n\
    Introduction\nA Network Access System (NAS), developed for a DEC PDP/11 computer,\
    \ supports\nthe current Imp-Host, Host-Host and ICP protocols.  The implementation\
    \ of\nthese protocols facilitate process-process communications across the network\n\
    and multi-user TELNET access to foreign hosts.  This NAS provides the FE \nenvironment\
    \ in which FEP is implemented.\nThe NAS system is comprised of a Kernel or executive\
    \ section and a Network\nControl Program (NCP) plus a collection of modules to\
    \ support device\ninterfaces, handle terminals, and implement applications, as\
    \ appropriate.  The\nsoftware is modular and extensible.\nThe KERNEL\nThe Kernel\
    \ of the system consists of a set of functional modules which perform\nthe task\
    \ of resource management in a multiprocessing environment.  This allows\nprocesses\
    \ to be created, vie for processor service according to priority, \nintercommunicate,\
    \ and be terminated.  System primitives exist for various\ntasks such as process\
    \ creation and synchronization, storage allocation, and\nsharing of the interval\
    \ timer.\nThe term process used here describes an autonomous sequence of states\
    \ brought\nabout by the PDP-11 processor; a process' state is characterized by\
    \ the set of\nprocessor registers, a stock, and process-owned storage areas. \
    \ Process share \nstorage areas which are accessed only (eq. pure code).  Processes\
    \ also share\nstorage areas which may be updated (eq. control tables).  In this\
    \ case an\nallocation mechanism is utilized to prevent simultaneous ownership\
    \ of an \nupdatable storage area.  The storage area is thus viewed as a sequentially\
    \ \nsharable resource which is allocated by the process, modified, and then\n\
    released.\nProcesses are given control of the processor by a single procedure\
    \ called the\nDispatcher.  Processes are said to be in a ready state or in a waiting\
    \ state.\nWhen a process blocks itself, control is given to the highest priority\
    \ ready\nprocess.\n                        ***WORKING DOCUMENT***\nFront-End Protocol\n\
    \                        ***WORKING DOCUMENT***\nEach process has an associated\
    \ input message queue.  This queue is the vehicle\nfor interprocess communication.\
    \  A process is blocked (put into a wait state)\nwhen its input message queue\
    \ becomes empty (voluntary wait), or when an \ninterrupt occurs (involuntary wait)\
    \ because a higher priority process is to\nreceive control of the processor. \
    \ A process may voluntarily block itself\nwaiting for any signal, or it may block\
    \ itself for a specific event to be\nposted to its input message queue.\nThe Network\
    \ Control Program\nThe NCP provides \"third level\" protocol functions to local\
    \ processes.  It\ncontains a process which decodes and passes messages which have\
    \ been received\nfrom the IMP and placed on the IMP-Host queue.  This process\
    \ interacts with\nother processes which call the NCP to establish connections\
    \ or to transmit\ndata.  Thus the NCP is essentially divided into two parts:\n\
    \    1)\ta process which handles incoming messages from the network,\n\tinterprets\
    \ IMP-Host and Host-Host control messages, and forwards\n\tregular messages on\
    \ established connections; and \n    2)\ta set of primitives which allow local\
    \ processes to establish\n\tconnections to other processes across the network,\
    \ and to perform\n\trequests for data to be transferred on these connections.\n\
    There are two primary data structures used by the NCP to monitor the status\n\
    of network connections.  The first is called the Host Table, and describes\nthat\
    \ which is peculiar to each given host; the second is referred to as a\nConnection\
    \ Table and contains all information on the state of a local NCP \nsocket (connection).\
    \  Connection Tables may be created either through\nexternal requests (e.q., an\
    \ RFC is received from a remote host) or through\ninternal requests (e.g., a local\
    \ process performs a LISTEN).\nFlow control is that portion of the NCP which governs\
    \ the flow of data on\nconnections.  There are two procedures which perform this\
    \ task; one which \nhandles receive connections and one which handles send connections.\
    \  These\nprocedures receive control when an event has occurred which may now\
    \ make it \npossible to transfer data on a connection.\nBoth send and receive\
    \ flow control procedures have the responsibility of moving\ndata between local\
    \ process buffers and messages being received or transmitted\nover the network.\
    \  In addition, they handle the formatting and unpacking of\n                \
    \        ***WORKING DOCUMENT***\nFront-End Protocol\n                        ***WORKING\
    \ DOCUMENT***\nmessages received.  Local processes are unaware that data is being\
    \ transmitted\nas discrete messages.\nThe NCP watchdog process monitors the state\
    \ of network connections, checking\nfor error conditions and performing garbage\
    \ collection tasks.  It receives \ncontrol at periodic intervals and scans the\
    \ list of known hosts, looking for\nexisting connections.  For each host to which\
    \ an input or output connection\nexists, the Watchdog causes a Host-Host NOP message\
    \ to be sent.  Thus if a\nremote Host crashes while data is being awaited, local\
    \ processes are informed\nof the error condition.  The NCP takes notice of the\
    \ remote crash when it\nreceives a IMP--Host type 7 control message (Destination\
    \ Host Dead).  It then\nautomatically closes all connections to that Host, and\
    \ notifies using processes\nof that fact.\nA second function of the NCP Watchdog\
    \ is to check for connections hung because\nof an outstanding RFNM.  If a RFNM\
    \ is not received for a specified interval,\nthe message is discarded, and the\
    \ associated connection closed.\nThe FEP Handler\nThe Front-End Protocol is implemented\
    \ as a collection of related, but\nspecialized processes which manage network\
    \ connections on the one side, and\nmanage FEP paths and indexes on the other.\
    \  Some FEP processes are NCP users.\nThey cause network connections to be made,\
    \ rule on incoming RFCs, and both\naccept and generate network data.  Other FEP\
    \ processes support the Host.\nThese processes parse incoming commands, create\
    \ indexes and paths, control\nthe generation of replies and generally manage the\
    \ paths.  Certain FEP \nprocesses control specialized tasks such as translation\
    \ of data, servicing of \nLISTEN commands and generation of RESPONSE commands.\n\
    Two data structures provide control information for FEP activities.  An Index\n\
    Table exists for each active index.  Each Index Table associates one or more\n\
    Path Table entries.  Information in the Path Table reflects the state of the\n\
    path, the translation type specified for data on this path, and necessary\ninformation\
    \ to associate the path to any appropriate NCP Connection Tables.\nThe Path Table\
    \ is the common interface for all of the FEP modules.  Most FEP\nprocesses are\
    \ activated to service some event which is usually associated to\na path.  The\
    \ action of the process will likely be dictated by the state of the\npath as indicated\
    \ by the Path Table entry, and may result in altering the state\nof the path or\
    \ the activation of one or more other FEP processes.\n                       \
    \ ***WORKING DOCUMENT***\nFront-End Protocol\n                        ***WORKING\
    \ DOCUMENT***\nTwo message queues provide Host input and output to the FEP modules.\
    \  A line\nprotocol mechanism services these queues.  Commands from the Host are\
    \ placed\non the FEP Input queue by the line protocol process and the FEP Host\
    \ Input \nprocess is signaled. When an FEP Host Output module places a Command\
    \ for the\nHost on the host Output queue it signals the line protocol process.\n\
    The FEP implementation is basically Host independent down to the level of the\n\
    Host Input and Host Output queues.\nThe Line Protocol Mechanism\nThe device interface\
    \ and the line protocol between the FE and the Host are\ninstallation dependent.\
    \  Because of this dependency, only a general discussion\nof the Line Protocol\
    \ Mechanism is possible in this context.  Detailed \ndescriptions of the specific\
    \ line protocols are included in the section for\neach Host.\nThe communications\
    \ discipline and physical device characteristics may vary\nconsiderably from host\
    \ to host.  All FEP line protocols, however, will show\ncertain common characteristics.\
    \  The interface between the FEP handler and the\nLine Protocol Mechanism will\
    \ always be Host Input and Host Output queues.  All\nline protocol mechanisms\
    \ will be expected to guarantee the integrity of the\ndata.  This implies some\
    \ form of flow control, error detection/correction and\nretransmission capability,\
    \ as well as normal transmit/receive responsibilities.\nThe Line Protocol Mechanism\
    \ will be expected to report failure after\nunsuccessfully attempting to perform\
    \ an I/O operation.  The number of retries\netc. before reporting failure is an\
    \ installation parameter.  The FEP Handler\nworks only in terms of FEP commands.\
    \  The line protocol may provide for block\ntransfers where each physical block\
    \ is comprised of one or more FEP commands.\nIf such is the case, it is encumbent\
    \ upon the Line Protocol Mechanism to \ndeblock the incoming Host commands before\
    \ placing them in the Host Input queue.\nThe Line Protocol Mechanism will, in\
    \ the general case, not manage any buffers. \nAfter successfully transmitting\
    \ a command to the Host it is responsible for \nreporting the I/O complete, but\
    \ the buffer space is freed or reused only by\nthe FEP process which \"owns\"\
    \ that space.  The FEP Handler might use buffer\nassignment to control the rate\
    \ of incoming traffic.  When the FEP Host Input \nqueue is ready to accept an\
    \ additional command, it would acquire a buffer and\nsignal the Line Protocol\
    \ Mechanism, passing it a pointer to a buffer.  This\n                       \
    \ ***WORKING DOCUMENT***\nFront-End Protocol\n                        ***WORKING\
    \ DOCUMENT***\nis effectively a \"read\" request.  When the line protocol handler\
    \ has filled\nthe buffer, it adds it to the Host Input queue and signals I/O complete\
    \ to \nthe appropriate FEP process.\nIf the nature of the physical connection\
    \ is such that the FE must accept \nunsolicited input, it may be necessary for\
    \ the Line Protocol Mechanism to\nhave its own buffer pool, in addition.  If this\
    \ is the case, it must be \nentirely managed by the line handler and transparent\
    \ to the FEP Handler.\nData Translations\nThe TRANS-TYPE provisions in FeP may\
    \ be employed for at least two general\nservices.  First, it can be used for normal\
    \ character set substitutions.  This\nis where, in the general case, there is\
    \ a one-to-one relationship between the\ntwo character sets.\nThe second service\
    \ addresses the problem of data transformation.  In this case,\nthere need not\
    \ be a one-to-one relationship between incoming data and outgoing\ndata.\nThe\
    \ translation mechanism uses a token (e.g., a character) from the incoming\ndata\
    \ stream to index into a translation table.  The result may be one of the\nfollowing:\n\
    \ta)  do nothing, drop the character\n\tb)  output the character unchanged\n\t\
    c)  substitute input character by output character\n\td)  substitute input character\
    \ by output string\n\te)  activate a procedure indicated by the table\n\tf)  change\
    \ the translation \n\tg)  test the translation mode and do any of the above depending\
    \ \n\t    on the result.\nFor each translation/transformation required by the\
    \ Host a translation table \nmust be defined.  For simplicity and clarity the\
    \ TRANS-TYPE field in the FEP\ncommands allows the user to specify Host side and\
    \ Network side as independent\nentities.  In actual execution the Host/Network\
    \ pair addresses a translation\ntable which must have been previously defined.\
    \  Note that for a duplex path\ntwo translation tables are necessary (A->B is\
    \ not the same as A<-B).\nA collection of \"standard\" character sets will be\
    \ addressed initially (EBCDIC,\nASC117, ASCII8, BCD, etc.) and at least NVT. \
    \ As new requirements are defined\nthese will be added to a library which will\
    \ then be available to subsequent\nusers.\n                        ***WORKING\
    \ DOCUMENT***\nFront-End Protocol\n***WORKING DOCUMENT***\n                  \
    \            APPENDIX D\n                         Host Implementations\nTo be\
    \ written at a later date.\n                        ***WORKING DOCUMENT***\n"
