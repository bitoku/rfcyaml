- contents:
  - '                 Unicode Format for Network Interchange

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Abstract\n   The Internet today is in need of a standardized form for the\n   transmission
    of internationalized \"text\" information, paralleling the\n   specifications
    for the use of ASCII that date from the early days of\n   the ARPANET.  This document
    specifies that format, using UTF-8 with\n   normalization and specific line-ending
    sequences.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  2\n     1.1.  Requirement for a Standardized Text Stream Format  .
    . . .  2\n     1.2.  Terminology  . . . . . . . . . . . . . . . . . . . . . .
    .  3\n   2.  Net-Unicode Definition . . . . . . . . . . . . . . . . . . . .  3\n
    \  3.  Normalization  . . . . . . . . . . . . . . . . . . . . . . . .  5\n   4.
    \ Versions of Unicode  . . . . . . . . . . . . . . . . . . . . .  5\n   5.  Applicability
    and Stability of this Specification  . . . . . .  7\n     5.1.  Use in IETF Applications
    Specifications  . . . . . . . . .  7\n     5.2.  Unicode Versions and Applicability
    . . . . . . . . . . . .  7\n   6.  Security Considerations  . . . . . . . . .
    . . . . . . . . . .  9\n   7.  Acknowledgments  . . . . . . . . . . . . . . .
    . . . . . . . . 10\n   Appendix A.  History and Context . . . . . . . . . . .
    . . . . . . 11\n   Appendix B.  The ASCII NVT Definition  . . . . . . . . . .
    . . . . 12\n   Appendix C.  The Line-Ending Problem . . . . . . . . . . . . .
    . . 14\n   Appendix D.  A Note about Related Future Work  . . . . . . . . . .
    14\n   References . . . . . . . . . . . . . . . . . . . . . . . . . . . . 15\n
    \    Normative References . . . . . . . . . . . . . . . . . . . . . . 15\n     Informative
    References . . . . . . . . . . . . . . . . . . . . . 16\n"
  title: Table of Contents
- contents:
  - '1.  Introduction

    '
  - contents:
    - "1.1.  Requirement for a Standardized Text Stream Format\n   Historically, Internet
      protocols have been largely ASCII-based and\n   references to \"text\" in protocols
      have assumed ASCII text and\n   specifically text in Network Virtual Terminal
      (\"NVT\") or \"Network\n   ASCII\" form (see Appendix A and Appendix B).  Protocols
      and formats\n   that have moved beyond ASCII have included arrangements to\n
      \  specifically identify the character set and often the language being\n   used.\n
      \  In our more internationalized world, \"text\" clearly no longer equates\n
      \  unambiguously to \"network ASCII\".  Fortunately, however, we are\n   converging
      on Unicode [Unicode] [ISO10646] as a single international\n   interchange character
      coding and no longer need to deal with per-\n   script standards for character
      sets (e.g., one standard for each of\n   Arabic, Cyrillic, Devanagari, etc.,
      or even standards keyed to\n   languages that are usually considered to share
      a script, such as\n   French, German, or Swedish).  Unfortunately, though, while
      it is\n   certainly time to define a Unicode-based text type for use as a\n
      \  common text interchange format, \"use Unicode\" involves even more\n   ambiguity
      than \"use ASCII\" did decades ago.\n   Unicode identifies each character by
      an integer, called its \"code\n   point\", in the range 0-0x10ffff.  These integers
      can be encoded into\n   byte sequences for transmission in at least three standard
      and\n   generally-recognized encoding forms, all of which are completely\n   defined
      in The Unicode Standard and the documents cited below:\n   o  UTF-8 [RFC3629]
      defines a variable-length encoding that may be\n      applied uniformly to all
      code points.\n   o  UTF-16 [RFC2781] encodes the range of Unicode characters
      whose\n      code points are less than 65536 straightforwardly as 16-bit\n      integers,
      and provides a \"surrogate\" mechanism for encoding larger\n      code points
      in 32 bits.\n   o  UTF-32 (also known as UCS-4) simply encodes each code point
      as a\n      32-bit integer.\n   Older forms and nomenclature, such as the 16-bit
      UCS-2, are now\n   strongly discouraged.\n   As with ASCII, any of these forms
      may be used with different line-\n   ending conventions.  That flexibility can
      be an additional source of\n   confusion with, e.g., index (offset) references
      into documents based\n   on character counts.\n   This document proposes to
      establish \"Net-Unicode\" as a new\n   standardized text transmission form for
      the Internet, to serve as an\n   internationalized alternative for NVT ASCII
      when specified in new --\n   and, where appropriate, updated -- protocols.  UTF-8
      [RFC3629] is\n   chosen for the coding because it has good compatibility properties\n
      \  with ASCII and for other reasons discussed in the existing IETF\n   character
      set policy [RFC2277].  \"Net-Unicode\" is specified in\n   Section 2; the subsequent
      sections of the document provide background\n   and explanation.\n   Whenever
      there is a choice, Unicode SHOULD be used with the text\n   encoding specified
      here.  This combination is preferred to the\n   double-byte encoding of \"extended
      ASCII\" [RFC0698] or the assorted\n   per-language or per-country character
      coding systems.\n"
    title: 1.1.  Requirement for a Standardized Text Stream Format
  - contents:
    - "1.2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
      \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and
      \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n"
    title: 1.2.  Terminology
  title: 1.  Introduction
- contents:
  - "2.  Net-Unicode Definition\n   The Network Unicode format (Net-Unicode) is defined
    as follows.\n   Parts of this definition are deliberately informal, providing\n
    \  guidance for specific profiles or rules in the protocols that\n   reference
    this one rather than firm rules that apply globally.\n   1.  Characters MUST be
    encoded in UTF-8 as defined in [RFC3629].\n   2.  If the protocol has the concept
    of \"lines\", line-endings MUST be\n       indicated by the sequence Carriage-Return
    (CR, U+000D) followed\n       by Line-Feed (LF, U+000A), often known just as CRLF.
    \ CR SHOULD\n       NOT appear except when followed by LF.  The only other allowed\n
    \      context in which CR is permitted is in the combination CR NUL,\n       which
    is not recommended (see the note at the end of this\n       section).\n   3.  The
    control characters in the ASCII range (U+0000 to U+001F and\n       U+007F to
    U+009F) SHOULD generally be avoided.  Space (SP,\n       U+0020), CR, LF, and
    Form Feed (FF, U+000C) are exceptions to\n       this principle, but use of all
    but the first requires care as\n       discussed elsewhere in this document.  The
    so-called \"C1\n       Controls\" (U+0080 through U+009F), which did not appear
    in ASCII,\n       MUST NOT appear.\n       FF should be used only with caution:
    it does not have a standard\n       and universal interpretation and, in particular,
    if its use\n       assumes a page length, such assumptions may not be appropriate
    in\n       international contexts (e.g., considering 8.5x11 inch paper\n       versus
    A4).  Other control characters are used to affect display\n       format, control
    devices, or to structure files.  None of those\n       uses is appropriate for
    streams of plain text.\n   4.  Before transmission, all character sequences SHOULD
    be normalized\n       according to Unicode normalization form \"NFC\" (see Section
    3).\n   5.  As suggested in Section 6 of RFC 3629, the Byte Order Mark\n       (\"BOM\")
    signature MUST NOT appear at the beginning of these text\n       strings.\n   6.
    \ Systems conforming to this specification MUST NOT transmit any\n       string
    containing any code point that is unassigned in the\n       version of Unicode
    on which they are dependent.  The version of\n       NFC and the version of Unicode
    used by that system MUST be\n       consistent.\n   The use of LF without CR is
    questionable; see Appendix B for more\n   discussion.  The newer control characters
    IND (U+0084) and NEL (\"Next\n   Line\", U+0085) might have been used to disambiguate
    the various line-\n   ending situations, but, because their use has not been established
    on\n   the Internet, because many protocols require CRLF, and because IND\n   and
    NEL fall within the \"C1 Controls\" group (see below), they MUST\n   NOT be used.
    \ Similar observations apply to the yet newer line and\n   paragraph separators
    at U+2028 and U+2029 and any future characters\n   that might be defined to serve
    these functions.  For this\n   specification and protocols that depend on it,
    lines end in CRLF and\n   only in CRLF.  Anything that does not end in CRLF is
    either not a\n   line or is severely malformed.\n   The NVT specification contained
    a number of additional provisions,\n   e.g., for the optional use of backspacing
    and \"bare CR\" (sent as CR\n   NUL) to generate overstruck character sequences.
    \ The much greater\n   number of precomposed characters in Unicode, the availability
    of\n   combining characters, and the growing use of markup conventions of\n   various
    types to show, e.g., emphasis (rather than attempting to do\n   that via the use
    of special characters), should make such sequences\n   largely unnecessary.  These
    sequences SHOULD be avoided if at all\n   possible.  However, because they were
    optional in NVT applications\n   and this specification is an NVT superset, they
    cannot be prohibited\n   entirely.  The most important of these rules is that
    CR MUST NOT\n   appear unless it is immediately followed by LF (indicating end
    of\n   line) or NUL.  Because NUL (an octet whose value is all zeros, i.e.,\n
    \  %x00 in the notation of [RFC5234]) is hostile to programming\n   languages
    that use that character as a string delimiter, the CR NUL\n   sequence SHOULD
    be avoided for that reason as well.\n"
  title: 2.  Net-Unicode Definition
- contents:
  - "3.  Normalization\n   There are cases where strings of Unicode are fundamentally\n
    \  equivalent, essentially representing the same text.  These are called\n   \"canonical
    equivalents\" in the Unicode Standard.  For example, the\n   following pairs of
    strings are canonically equivalent:\n   U+2126 OHM SIGN\n   U+03A9 GREEK CAPITAL
    LETTER OMEGA\n   U+0061 LATIN SMALL LETTER A, U+0300 COMBINING GRAVE ACCENT\n
    \  U+00E0 LATIN SMALL LETTER A WITH GRAVE\n   Comparison of strings becomes much
    easier if any such cases are\n   always represented by a single unique form.  The
    Unicode Consortium\n   specifies a normalization form, known as NFC [NFC], which
    provides\n   the necessary mappings and mechanisms to convert all canonically\n
    \  equivalent sequences to a single unique form.  Typically, this form\n   produces
    precomposed characters for any sequences that can be\n   represented in that fashion.
    \ It also reorders other combining marks\n   so that they have a unique and unambiguous
    order.\n   Of the various normalization forms defined as part of Unicode, NFC
    is\n   closest to actual use in practice, minimizes side-effects due to\n   considering
    characters equivalent that may not be equivalent in all\n   situations, and typically
    requires the least work when converting\n   from non-Unicode encodings.\n   The
    section above requires that, except in very unusual\n   circumstances, all Net-Unicode
    strings be transmitted in normalized\n   form.  Recognition of the fact that some
    implementations of\n   applications may rely on operating system libraries over
    which they\n   have little control and adherence to the robustness principle\n
    \  suggests that receivers of such strings should be prepared to receive\n   unnormalized
    ones and to not react to that in excessive ways.\n"
  title: 3.  Normalization
- contents:
  - "4.  Versions of Unicode\n   Unicode changes and expands over time.  Large blocks
    of space are\n   reserved for future expansion.  New versions, which appear at
    regular\n   intervals, add new scripts and characters.  Occasionally they also\n
    \  change some property definitions.  In retrospect, one of the\n   advantages
    of ASCII [ASCII] when it was chosen was that the code\n   space was full when
    the Standard was first published.  There was no\n   practical way to add characters
    or change code point assignments\n   without being obviously incompatible.\n   While
    there are some security issues if people deliberately try to\n   trick the system
    (see Section 6), Unicode version changes should not\n   have a significant impact
    on the text stream specification of this\n   document for the following reasons:\n
    \  o  The transformation between Unicode code table positions and the\n      corresponding
    UTF-8 code is algorithmic; it does not depend on\n      whether a code point has
    been assigned or not.\n   o  The normalization recommended here, NFC (see Section
    3), performs\n      a very limited set of mappings, much more limited than those
    of\n      the more extensive NFKC used in, e.g., Nameprep [RFC3491].\n   The NFC
    tables may be updated over time as new characters are added,\n   but the Unicode
    Consortium has guaranteed the stability of all NFC\n   strings.  That is, if a
    string does not contain any unassigned\n   characters, and it is normalized according
    to NFC, it will always be\n   normalized according to all future versions of the
    Unicode Standard.\n   The stability of the Net-Unicode format is thus guaranteed
    when any\n   implementation that converts text into Net-Unicode format does not\n
    \  permit unassigned characters.\n   Because Unicode code points that are reserved
    for private use do not\n   have standard definitions or normalization interpretations,
    they\n   SHOULD be avoided in strings intended for Internet interchange.\n   Were
    Unicode to be changed in a way that violated these assumptions,\n   i.e., that
    either invalidated the byte string order specified in RFC\n   3629 or that changed
    the stability of NFC as stated above, this\n   specification would not apply.
    \ Put differently, this specification\n   applies only to versions of Unicode
    starting with version 5.0 and\n   extending to, but not including, any version
    for which changes are\n   made in either the UTF-8 definition or to NFC stability.
    \ Such\n   changes would violate established Unicode policies and are hence\n
    \  unlikely, but, should they occur, it would be necessary to evaluate\n   them
    for compatibility with this specification and other Internet\n   uses of NFC.\n
    \  If the specification of a protocol references this one, strings that\n   are
    received by that protocol and that appear to be UTF-8 and are not\n   otherwise
    identified (e.g., by charset labeling) SHOULD be treated as\n   using UTF-8 in
    conformance with this specification.\n"
  title: 4.  Versions of Unicode
- contents:
  - '5.  Applicability and Stability of this Specification

    '
  - contents:
    - "5.1.  Use in IETF Applications Specifications\n   During the development of
      this specification, there was some\n   confusion about where it would be useful
      given that, e.g., the\n   individual MIME media types used in email and with
      HTTP have their\n   own rules about UTF-8 character types and normalization,
      and the\n   application transport protocols impose their own conventions about\n
      \  line endings.  There are three answers.  The first is that, in\n   retrospect,
      it would have been better to have those protocols and\n   content types standardized
      in the way specified here, even though it\n   is certainly too late to change
      them at this time.  The second is\n   that we have several protocols that are
      dependent on either the\n   original Telnet design or other arrangements requiring
      a standard,\n   interoperable, string definition without specific content-labels
      of\n   one sort or another.  Whois [RFC3912] is an example member of this\n
      \  group.  As consideration is given to upgrading them for non-ASCII\n   use,
      this specification provides a normative reference that provides\n   the same
      stability that NVT has provided the ASCII forms.  This\n   specification is
      intended for use by other specifications that have\n   not yet defined how to
      use Unicode.  Having a preferred standard\n   Internet definition for Unicode
      text streams -- rather than just one\n   for transmission codings -- may help
      improve the specification and\n   interoperability of protocols to be developed
      in the future.  This\n   specification is not intended for use with specifications
      that\n   already allow the use of UTF-8 and precisely define that use.\n"
    title: 5.1.  Use in IETF Applications Specifications
  - contents:
    - "5.2.  Unicode Versions and Applicability\n   The IETF faces a practical dilemma
      with regard to versions of\n   Unicode.  Each new version brings with it new
      characters and\n   sometimes new combining characters.  Version 5.0 introduces
      the new\n   concept of sequences of characters named as if they were individual\n
      \  characters (see [NamedSequences]).  The normalization represented by\n   NFC
      is stable if all strings are transmitted and stored in normalized\n   form if
      corrections are never made to character definitions or\n   normalization tables
      and if unassigned code points are never used.\n   The latter is important because
      an unassigned code point always\n   normalizes to itself.  However, if the same
      code point is assigned to\n   a character in a future version, it may participate
      in some other\n   normalization mapping (some specific difficulties in this
      regard are\n   discussed in [RFC4690]).  It is worth noting that transmission
      in\n   normalized form is not required by either the IETF's UTF-8 Standard\n
      \  [RFC3629] or by standards dependent on the current version of\n   Stringprep
      [RFC3454].\n   All would be well with this as described in Section 4 except
      for one\n   problem: Applications typically do not perform their own conversions\n
      \  to Unicode and may not perform their own normalizations but instead\n   rely
      on operating system or language library functions -- functions\n   that may
      be upgraded or otherwise changed without changes to the\n   application code
      itself.  Consequently, there may be no plausible way\n   for an application
      to know which version of Unicode, or which version\n   of the normalization
      procedures, it is utilizing, nor is there any\n   way by which it can guarantee
      that the two will be consistent.\n   Because of per-version changes in definitions
      and tables, Stringprep\n   and documents depending on it are now tied to Unicode
      Version 3.2\n   [Unicode32] and full interoperability of Internet Standard UTF-8\n
      \  [RFC3629], when used with normalization as specified here, is\n   dependent
      on normalization definitions and the definition of UTF-8\n   itself not changing
      after Unicode Version 5.0.  These assumptions\n   seem fairly safe, but they
      are still assumptions.  Rather than being\n   linked to the latest available
      version of Unicode, version 5.0\n   [Unicode] or broader concepts of version
      independence based on\n   specific assumptions and conditions, this specification
      could\n   reasonably have been tied, like Stringprep and Nameprep to Unicode\n
      \  3.2 [Unicode32] or some more recent intermediate version, but, in\n   addition
      to the obvious disadvantages of having different IETF\n   standards tied to
      different versions of Unicode, the library-based\n   application implementation
      behavior described above makes these\n   version linkages nearly meaningless
      in practice.\n   In theory, one can get around this problem in four ways:\n
      \  1.  Freeze on a particular version of Unicode and try to insist that\n       applications
      enforce that version by, e.g., containing lists of\n       unassigned characters
      and prohibiting their use.  Of course, this\n       would prohibit evolution
      to include newly-added scripts and the\n       tables of unassigned code points
      would be cumbersome.\n   2.  Require that every Unicode \"text\" string or file
      start with a\n       version indication, somewhat akin to the \"byte order mark\"\n
      \      indicator.  It is unlikely that this provision would be\n       practical.
      \ More important, it would require that each\n       application implementation
      be prepared to either support multiple\n       normalization tables and versions
      or that it reject text from\n       Unicode versions with which it was not prepared
      to deal.\n   3.  Devise a different set of normalization rules that would, e.g.,\n
      \      guarantee that no character assigned to a previously-unassigned\n       code
      point in Unicode was ever normalized to anything but itself\n       and use
      those rules instead of NFC.  It is not clear whether or\n       not such a set
      of rules is possible or whether some other\n       completely stable set of
      rules could be devised, perhaps in\n       combination with restrictions on
      the ways in which characters\n       were added in future versions of Unicode.\n
      \  4.  Devise a normalization process that is otherwise equivalent to\n       NFC
      but that rejects code points that are unassigned in the\n       current version
      of Unicode, rather than mapping those code points\n       to themselves.  This
      would still leave some risk of incompatible\n       corrections in Unicode and
      possibly a few edge cases, but it is\n       probably stable enough for Internet
      use in the overwhelming\n       number of cases.  This process has been discussed
      in the Unicode\n       Consortium under the name \"Stable NFC\".\n   None of
      these approaches seems ideal: the ideal procedure would be as\n   stable and
      predictable as ASCII has been.  But that level is simply\n   not feasible as
      long as Unicode continues to evolve by the addition\n   of new code points and
      scripts.  The fourth option listed above\n   appears to be a reasonable compromise.\n"
    title: 5.2.  Unicode Versions and Applicability
  title: 5.  Applicability and Stability of this Specification
- contents:
  - "6.  Security Considerations\n   This specification provides a standard form for
    the use of Unicode as\n   \"network text\".  Most of the same security issues
    that apply to\n   UTF-8, as discussed in [RFC3629], apply to it, although it should
    be\n   slightly less subject to some risks by virtue of requiring NFC\n   normalization
    and generally being somewhat more restrictive.\n   However, shifts in Unicode
    versions, as discussed in Section 5.2, may\n   introduce other security issues.\n
    \  Programs that receive these streams should use extreme caution about\n   assuming
    that incoming data are normalized, since it might be\n   possible to use unnormalized
    forms, as well as invalid UTF-8, as part\n   of an attack.  In particular, firewalls
    and other systems that\n   interpret UTF-8 streams should be developed with the
    clear knowledge\n   that an attacker may deliberately send unnormalized text,
    for\n   instance, to avoid detection by naive text-matching systems.\n   NVT contains
    a requirement, of necessity repeated here (see\n   Section 2), that the CR character
    be immediately followed by either\n   LF or ASCII NUL (an octet with all bits
    zero).  NUL may be\n   problematic for some programming languages that use it
    as a string\n   terminator, and hence a trap for the unwary, unless caution is
    used.\n   This may be an additional reason to avoid the use of CR entirely,\n
    \  except in sequence with LF, as suggested above.\n   The discussion about Unicode
    versions above (see Section 4 and\n   Section 5.2) makes several assumptions about
    future versions of\n   Unicode, about NFC normalization being applied properly,
    and about\n   UTF-8 being processed and transmitted exactly as specified in RFC\n
    \  3629.  If any of those assumptions are not correct, then there are\n   cases
    in which strings that would be considered equivalent do not\n   compare equal.
    \ Robust code should be prepared for those\n   possibilities.\n"
  title: 6.  Security Considerations
- contents:
  - "7.  Acknowledgments\n   Many thanks to Mark Davis, Martin Duerst, and Michel
    Suignard for\n   suggestions about Unicode normalization that led to the format\n
    \  described here, and especially to Mark for providing the paragraphs\n   that
    describe the role of NFC.  Thanks also to Mark, Doug Ewell,\n   Asmus Freytag
    for corrected text describing Unicode transmission\n   forms, and to Tim Bray,
    Carsten Bormann, Stephane Bortzmeyer, Martin\n   Duerst, Frank Ellermann, Clive
    D.W. Feather, Ted Hardie, Bjoern\n   Hoehrmann, Alfred Hoenes, Kent Karlsson,
    Bill McQuillan, George\n   Michaelson, Chris Newman, and Marcos Sanz for a number
    of helpful\n   comments and clarification requests.\n"
  title: 7.  Acknowledgments
- contents:
  - "Appendix A.  History and Context\n   This subsection contains a review of prior
    work in the ARPANET and\n   Internet to establish a standard text type, work that
    establishes the\n   context and motivation for the approach taken in this document.
    \ The\n   text is explanatory rather than normative: nothing in this section is\n
    \  intended to change or update any current specification.  Those who\n   are
    uninterested in this review and analysis can safely skip this\n   section.\n   One
    of the earlier application design decisions made in the\n   development of ARPANET,
    a decision that was carried forward into the\n   Internet, was the decision to
    standardize on a single and very\n   specific coding for \"text\" to be passed
    across the network [RFC0020].\n   Hosts on the network were then responsible for
    translating or mapping\n   from whatever character coding conventions were used
    locally to that\n   common intermediate representation, with sending hosts mapping
    to it\n   and receiving ones mapping from it to their local forms as needed.\n
    \  It is interesting to note that at the time the ARPANET was being\n   developed,
    participating host operating systems used at least three\n   different character
    coding standards: the antiquated BCD (Binary\n   Coded Decimal), the then-dominant
    major manufacturer-backed EBCDIC\n   (Extended BCD Interchange Code), and the
    then-still emerging ASCII\n   (American Standard Code for Information Interchange).
    \ Since the\n   ARPANET was an \"open\" project and EBCDIC was intimately linked
    to a\n   particular hardware vendor, the original Network Working Group agreed\n
    \  that its standard should be ASCII.  That ASCII form was precisely\n   \"7-bit
    ASCII in an 8-bit field\", which was in effect a compromise\n   between hosts
    that were natively 7-bit oriented (e.g., with five\n   seven-bit characters in
    a 36-bit word), those that were 8-bit\n   oriented (using eight-bit characters)
    and those that placed the\n   seven-bit ASCII characters in 9-bit fields with
    two leading zero bits\n   (four characters in a 36-bit word).\n   More standardization
    was suggested in the first preliminary\n   description of the Telnet protocol
    [RFC0097].  With the iterations of\n   that protocol [RFC0137] [RFC0139] and the
    drawing together of an\n   essentially formal definition somewhat later [RFC0318],
    a standard\n   abstraction, the Network Virtual Terminal (NVT) was established.
    \ NVT\n   character-coding conventions (initially called \"Telnet ASCII\" and\n
    \  later called \"NVT ASCII\", or, more casually, \"network ASCII\")\n   included
    the requirement that Carriage Return followed by Line Feed\n   (CRLF) be the common
    representation for ending lines of text (given\n   that some participating \"Host\"
    operating systems used the one\n   natively, some the other, at least one used
    both, and a few used\n   neither (preferring variable-length lines with counts
    or special\n   delimiters or markers instead) and specified conventions for some\n
    \  other characters.  Also, since NVT ASCII was restricted to seven-bit\n   characters,
    use of the high-order bit in octets was reserved for the\n   transmission of control
    signaling information.\n   At a very high level, the concept was that a system
    could use\n   whatever character coding and line representations were appropriate\n
    \  locally, but text transmitted over the network as text must conform\n   to
    the single \"network virtual terminal\" convention.  Virtually all\n   early Internet
    protocols that presume transfer of \"text\" assume this\n   virtual terminal model,
    although different ones assume or limit it in\n   different ways.  Telnet, the
    command stream and ASCII Type in FTP\n   [RFC0542], the message stream in SMTP
    transfer [RFC2821], and the\n   strings passed to finger [RFC0742] and whois [RFC0954]
    are the\n   classic examples.  More recently, HTTP [RFC1945] [RFC2616] follows\n
    \  the same general model but permits 8-bit data and leaves the line end\n   sequence
    unspecified (the latter has been the source of a significant\n   number of problems).\n"
  title: Appendix A.  History and Context
- contents:
  - "Appendix B.  The ASCII NVT Definition\n   The main body of this specification
    is intended as an update to, and\n   internationalized version of, the Net-ASCII
    definition.  The\n   specification is self-contained in that parts of the Net-ASCII\n
    \  definition that are no longer recommended are not included above.\n   Because
    Net-ASCII evolved somewhat over time and there has been\n   debate about which
    specification is the \"official\" Net-ASCII, it is\n   appropriate to review the
    key elements of that definition here.  This\n   review is informal with regard
    to the contents of Net-ASCII and\n   should not be considered as a normative update
    or summary of the\n   earlier specifications (Section 2 does specify some normative
    updates\n   to those specifications and some comments below are consistent with\n
    \  it).\n   The first part of the section titled \"THE NVT PRINTER AND KEYBOARD\"\n
    \  in RFC 854 [RFC0854] is generally, although not universally,\n   considered
    to be the normative definition of the (ASCII) Network\n   Virtual Terminal and
    hence of Net-ASCII.  It includes not only the\n   graphic ASCII characters but
    a number of control characters.  The\n   latter are given Internet-specific meanings
    that are often more\n   specific than the definitions in the ASCII specification.
    \ In today's\n   usage, and for the present specification, the following\n   clarifications
    and updates to that list should be noted.  Each one is\n   accompanied by a brief
    explanation of the reason why the original\n   specification is no longer appropriate.\n
    \  1.  The \"defined but not required\" codes -- BEL (U+0007), BS\n       (U+0008),
    HT (U+0009), VT (U+000B), and FF (U+000C) -- and the\n       undefined control
    codes (\"C0\") SHOULD NOT be used unless required\n       by exceptional circumstances.
    \ Either their original \"network\n       printer\" definitions are no longer
    in general use, common\n       practice has evolved away from the formats specified
    there, or\n       their use to simulate characters that are better handled by\n
    \      Unicode is no longer appropriate.  While the appearance of some\n       of
    these characters on the list may seem surprising, BS now has\n       an ambiguous
    interpretation in practice (erasing in some systems\n       but not in others),
    the width associated with HT varies with the\n       environment, and VT and FF
    do not have a uniform effect with\n       regard to either vertical positioning
    or the associated\n       horizontal position result.  Of course, telnet escapes
    are not\n       considered part of the data stream and hence are unaffected by\n
    \      this provision.\n   2.  In Net-ASCII, CR MUST NOT appear except when immediately
    followed\n       by either NUL or LF, with the latter (CR LF) designating the
    \"new\n       line\" function.  Today and as specified above, CR should\n       generally
    appear only when followed by LF.  Because page layout\n       is better done in
    other ways, because NUL has a special\n       interpretation in some programming
    languages, and to avoid other\n       types of confusion, CR NUL should preferably
    be avoided as\n       specified above.\n   3.  LF CR SHOULD NOT appear except
    as a side-effect of multiple CR LF\n       sequences (e.g., CR LF CR LF).\n   4.
    \ The historical NVT documents do not call out either \"bare LF\" (LF\n       without
    CR) or HT for special treatment.  Both have generally\n       been understood
    to be problematic.  In the case of LF, there is a\n       difference in interpretation
    as to whether its semantics imply\n       \"go to same position on the next line\"
    or \"go to the first\n       position on the next line\" and interoperability
    considerations\n       suggest not depending on which interpretation the receiver\n
    \      applies.  At the same time, misinterpretation of LF is less\n       harmful
    than misinterpretation of \"bare\" CR: in the CR case, text\n       may be erased
    or made completely unreadable; in the LF one, the\n       worst consequence is
    a very funny-looking display.  Obviously, HT\n       is problematic because there
    is no standard way to transmit\n       intended tab position or width information
    in running text.\n       Again, the harm is unlikely to be great if HT is simply\n
    \      interpreted as one or more spaces, but, in general, it cannot be\n       relied
    upon to format information.\n   It is worth noting that the telnet IAC character
    (an octet consisting\n   of all ones, i.e., %xFF) itself is not a problem for
    UTF-8 since that\n   particular octet cannot appear in a valid UTF-8 string.  However,\n
    \  while few of them have been used, telnet permits other command-\n   introducer
    characters whose bit sequences in an octet may be part of\n   valid UTF-8 characters.
    \ While it causes no ambiguity in UTF-8,\n   Unicode assigns a graphic character
    (\"Latin Small Letter Y with\n   Diaeresis\") to U+00FF (octets C3 B0 in UTF-8).
    \ Some caution is\n   clearly in order in this area.\n"
  title: Appendix B.  The ASCII NVT Definition
- contents:
  - "Appendix C.  The Line-Ending Problem\n   The definition of how a line ending
    should be denoted in plain text\n   strings on the wire for the Internet has been
    controversial from even\n   before the introduction of NVT.  Some have argued
    that recipients\n   should be required to interpret almost anything that a sender
    might\n   intend as a line ending as actually a line ending.  Others have\n   pointed
    out that this would lead to some ambiguities of\n   interpretation and presentation
    and would violate the principle that\n   we should minimize the number of forms
    that are permitted on the wire\n   in order to promote interoperability and eliminate
    the \"every\n   recipient needs to understand every sender format\" problem.  The\n
    \  design of this specification, like that of NVT, takes the latter\n   approach.
    \ Its designers believe that there is little point in a\n   standard if it is
    to specify \"anyone can do whatever they like and\n   the receiver just needs
    to cope\".\n   A further discussion of the nature and evolution of the line-ending\n
    \  problem appears in Section 5.8 of the Unicode Standard [Unicode] and\n   is
    suggested for additional reading.  If we were starting with the\n   Internet today,
    it would probably be sensible to follow the\n   recommendation there and use LS
    (U+2028) exclusively, in preference\n   to CRLF.  However, the installed base
    of use of CRLF and the\n   importance of forward compatibility with NVT and protocols
    that\n   assume it makes that impossible, so it is necessary to continue using\n
    \  CRLF as the \"New Line Function\" (\"NLF\", see the terminology section\n   in
    that reference).\n"
  title: Appendix C.  The Line-Ending Problem
- contents:
  - "Appendix D.  A Note about Related Future Work\n   Consideration should be given
    to a Telnet (or SSH [RFC4251]) option\n   to specify this type of stream and an
    FTP extension [RFC0959] to\n   permit a new \"Unicode text\" data TYPE.\n"
  title: Appendix D.  A Note about Related Future Work
- contents:
  - 'References

    '
  title: References
- contents:
  - "Normative References\n   [ISO10646]        International Organization for Standardization,\n
    \                    \"Information Technology - Universal Multiple-Octet\n                     Coded
    Character Set (UCS) - Part 1: Architecture\n                     and Basic Multilingual
    Plane\", ISO/\n                     IEC 10646-1:2000, October 2000.\n   [NFC]
    \            Davis, M. and M. Duerst, \"Unicode Standard Annex\n                     #15:
    Unicode Normalization Forms\", October 2006,\n                     <http://www.unicode.org/reports/tr15/>.\n
    \  [RFC2119]         Bradner, S., \"Key words for use in RFCs to Indicate\n                     Requirement
    Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC3629]         Yergeau, F., \"UTF-8,
    a transformation format of ISO\n                     10646\", STD 63, RFC 3629,
    November 2003.\n   [RFC5234]         Crocker, D. and P. Overell, \"Augmented BNF
    for\n                     Syntax Specifications: ABNF\", STD 68, RFC 5234,\n                     January
    2008.\n   [Unicode]         The Unicode Consortium, \"The Unicode Standard,\n
    \                    Version 5.0\", 2007.\n                     Boston, MA, USA:
    Addison-Wesley.  ISBN\n                     0-321-48091-0\n   [Unicode32]       The
    Unicode Consortium, \"The Unicode Standard,\n                     Version 3.0\",
    2000.\n                     (Reading, MA, Addison-Wesley, 2000.  ISBN 0-201-\n
    \                    61633-5).  Version 3.2 consists of the definition\n                     in
    that book as amended by the Unicode Standard\n                     Annex #27:
    Unicode 3.1\n                     (http://www.unicode.org/reports/tr27/) and by
    the\n                     Unicode Standard Annex #28: Unicode 3.2\n                     (http://www.unicode.org/reports/tr28/).\n"
  title: Normative References
- contents:
  - "Informative References\n   [ASCII]           American National Standards Institute
    (formerly\n                     United States of America Standards Institute),
    \"USA\n                     Code for Information Interchange\", ANSI X3.4-1968,\n
    \                    1968.\n                     ANSI X3.4-1968 has been replaced
    by newer versions\n                     with slight modifications, but the 1968
    version\n                     remains definitive for the Internet.  ISO 646\n
    \                    International Reverence Version (IRV)\n                     [ISO.646.1991]
    is usually considered equivalent to\n                     ASCII.\n   [ISO.646.1991]
    \   International Organization for Standardization,\n                     \"Information
    technology - ISO 7-bit coded character\n                     set for information
    interchange\", ISO Standard 646,\n                     1991.\n   [NamedSequences]
    \ The Unicode Consortium, \"NamedSequences-4.1.0.txt\",\n                     2005,
    <http://www.unicode.org/Public/UNIDATA/\n                     NamedSequences.txt>.\n
    \  [RFC0020]         Cerf, V., \"ASCII format for network interchange\",\n                     RFC
    20, October 1969.\n   [RFC0097]         Melvin, J. and R. Watson, \"First Cut
    at a Proposed\n                     Telnet Protocol\", RFC 97, February 1971.\n
    \  [RFC0137]         O'Sullivan, T., \"Telnet Protocol - a proposed\n                     document\",
    RFC 137, April 1971.\n   [RFC0139]         O'Sullivan, T., \"Discussion of Telnet
    Protocol\",\n                     RFC 139, May 1971.\n   [RFC0318]         Postel,
    J., \"Telnet Protocols\", RFC 318,\n                     April 1972.\n   [RFC0542]
    \        Neigus, N., \"File Transfer Protocol\", RFC 542,\n                     August
    1973.\n   [RFC0698]         Mock, T., \"Telnet extended ASCII option\", RFC 698,\n
    \                    July 1975.\n   [RFC0742]         Harrenstien, K., \"NAME/FINGER
    Protocol\", RFC 742,\n                     December 1977.\n   [RFC0854]         Postel,
    J. and J. Reynolds, \"Telnet Protocol\n                     Specification\", STD
    8, RFC 854, May 1983.\n   [RFC0954]         Harrenstien, K., Stahl, M., and E.
    Feinler,\n                     \"NICNAME/WHOIS\", RFC 954, October 1985.\n   [RFC0959]
    \        Postel, J. and J. Reynolds, \"File Transfer\n                     Protocol\",
    STD 9, RFC 959, October 1985.\n   [RFC1945]         Berners-Lee, T., Fielding,
    R., and H. Nielsen,\n                     \"Hypertext Transfer Protocol -- HTTP/1.0\",\n
    \                    RFC 1945, May 1996.\n   [RFC2277]         Alvestrand, H.,
    \"IETF Policy on Character Sets and\n                     Languages\", BCP 18,
    RFC 2277, January 1998.\n   [RFC2616]         Fielding, R., Gettys, J., Mogul,
    J., Frystyk, H.,\n                     Masinter, L., Leach, P., and T. Berners-Lee,\n
    \                    \"Hypertext Transfer Protocol -- HTTP/1.1\",\n                     RFC
    2616, June 1999.\n   [RFC2781]         Hoffman, P. and F. Yergeau, \"UTF-16, an
    encoding of\n                     ISO 10646\", RFC 2781, February 2000.\n   [RFC2821]
    \        Klensin, J., \"Simple Mail Transfer Protocol\",\n                     RFC
    2821, April 2001.\n   [RFC3454]         Hoffman, P. and M. Blanchet, \"Preparation
    of\n                     Internationalized Strings (\"stringprep\")\",\n                     RFC
    3454, December 2002.\n   [RFC3491]         Hoffman, P. and M. Blanchet, \"Nameprep:
    A\n                     Stringprep Profile for Internationalized Domain\n                     Names
    (IDN)\", RFC 3491, March 2003.\n   [RFC3912]         Daigle, L., \"WHOIS Protocol
    Specification\",\n                     RFC 3912, September 2004.\n   [RFC4251]
    \        Ylonen, T. and C. Lonvick, \"The Secure Shell (SSH)\n                     Protocol
    Architecture\", RFC 4251, January 2006.\n   [RFC4690]         Klensin, J., Faltstrom,
    P., Karp, C., and IAB,\n                     \"Review and Recommendations for
    Internationalized\n                     Domain Names (IDNs)\", RFC 4690, September
    2006.\n"
  title: Informative References
- contents:
  - "Authors' Addresses\n   John C Klensin\n   1770 Massachusetts Ave, #322\n   Cambridge,
    MA  02140\n   USA\n   Phone: +1 617 491 5735\n   EMail: john-ietf@jck.com\n   Michael
    A. Padlipsky\n   8011 Stewart Ave.\n   Los Angeles, CA  90045\n   USA\n   Phone:
    +1 310-670-4288\n   EMail: the.map@alum.mit.edu\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2008).\n   This document
    is subject to the rights, licenses and restrictions\n   contained in BCP 78, and
    except as set forth therein, the authors\n   retain all their rights.\n   This
    document and the information contained herein are provided on an\n   \"AS IS\"
    basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE INTERNET ENGINEERING
    TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT
    LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION HEREIN WILL NOT INFRINGE
    ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at\n   ietf-ipr@ietf.org.\n"
  title: Intellectual Property
