- title: __initial_text__
  contents:
  - "            A Host/Host Protocol for an ARPANET-Type Network\n   Recently we\
    \ have been involved in the planning of a network, which,\n   if implemented,\
    \ would use ARPANET IMPs without modification, but\n   would allow re-specification\
    \ of Host/Host (and higher level)\n   Protocol.  The remainder of this document\
    \ is a slightly edited\n   version of our recommendation for Host/Host protocol;\
    \ we thought that\n   it might be of interest to the ARPANET Community.\n"
- title: I.  INTRODUCTION
  contents:
  - "I.  INTRODUCTION\n   The Host/Host Protocol for the ARPANET was the first such\
    \ protocol\n   designed for use over a packet-switched network.  The current version\n\
    \   has been in existence since early 1972 and has provided for the\n   transportation\
    \ of billions of bits over tens or hundreds of thousands\n   of connections. \
    \ Clearly, the protocol is adequate for the job; this\n   does not mean that it\
    \ is ideal, however.  In particular, the ARPANET\n   Host/Host protocol has been\
    \ criticized on the following grounds\n   (among others):\n   (1) It is specified\
    \ as a simplex protocol.  Each established\n       connection is a simplex entity,\
    \ thus two connections (one in each\n       direction) must be established in\
    \ order to carry out an exchange\n       of messages.  This provides great generality\
    \ but at a perhaps\n       unacceptable cost in complexity.\n   (2) It is not\
    \ particularly robust, in that it cannot continue to\n       operate correctly\
    \ in the face of several types of message loss.\n       While it is true that\
    \ the ARPANET itself rarely loses messages,\n       messages are occasionally\
    \ lost, both by the network and by the\n       Hosts.\n   (3) Partly because of\
    \ the simplex nature of connections, the flow\n       control mechanisms defined\
    \ in the ARPANET protocol do not make\n       efficient use of the transactional\
    \ nature of much of data\n       processing.  Rather than carrying flow control\
    \ information (in\n       the form of permits, or requests for more information)\
    \ in the\n       reverse traffic, a separate channel is set up to convey this\n\
    \       information.  Thus, for transactional systems, up to twice as\n      \
    \ many messages are exchanged (half for flow control information\n       and half\
    \ for data) as would be needed for data alone.\n   (4) Prohibition against the\
    \ multiple use of a connection termination\n       point makes the establishment\
    \ of communication with service\n       facilities extremely cumbersome.\n   The\
    \ International Federation for Information Processing (IFIP)\n   Working Group\
    \ 6.1 (Packet-switched Network Internetworking) has\n   recently approved a proposal\
    \ for an internetwork end-to-end protocol.\n   The IFIP Protocol is based on experience\
    \ from the ARPANET, the\n   (French) Cyclade Network, and the (British) NPL Network,\
    \ as well as\n   the plans of other networks.  Thus, one would expect that it\
    \ would\n   have all of the strengths and few (or none) of the weaknesses of the\n\
    \   protocols which are in use on, or planned for, these networks.\n   In fact,\
    \ the IFIP Protocol avoids the deficiencies of the ARPANET\n   protocol mentioned\
    \ above.  Connections are treated as full-duplex\n   entities, and this decision\
    \ permits flow control information to be\n   carried on the reverse channel in\
    \ transaction-oriented systems where\n   there is reverse channel traffic occurring\
    \ naturally.  In addition,\n   the IFIP Protocol is to some extent self synchronizing;\
    \ in\n   particular, there is no type of message loss from which the Protocol\n\
    \   does not permit recovery in a graceful way.\n   The IFIP Protocol makes a\
    \ minimal number of assumptions about the\n   network over which it will operate.\
    \  It is designed to permit\n   fragmentation, as a message crosses from one network\
    \ to another,\n   without network reassembly.  It anticipates duplication, or\
    \ non-\n   delivery, of messages or message fragments and provides ways to\n \
    \  recover from these conditions.  Finally, it permits delivery of\n   messages\
    \ at their destination Host in a completely different order\n   from the order\
    \ in which they were input by the source Host.\n   Unfortunately, it achieves\
    \ these advantages at a relatively high\n   overhead cost in terms of transferred\
    \ bits.  The complete source and\n   destination process addresses are carried\
    \ in every message, 24-bits\n   of fragment identification are carried with each\
    \ fragment and 16-bits\n   of acknowledgement information are else carried in\
    \ every message.\n   When considering channel capacities of hundreds of kilobits\
    \ (or\n   more), message overhead of a few hundred bits is a modest price to\n\
    \   pay in order to achieve great flexibility and generality.  However,\n   for\
    \ a stand-alone network of the type under consideration, and\n   especially in\
    \ view of the anticipated use of many circuits of 10kbs\n   capacity, the IFIP\
    \ Protocol offers far more generality than is\n   needed, for which a fairly severe\
    \ overhead price is paid.\n   The virtual circuit protocols currently being debated\
    \ within the\n   International Telegraph and Telephone Consultative Committee\
    \ (CCITT)\n   are a step in the opposite direction.  Virtual circuit protocols\n\
    \   attempt to make a packet switching network indistinguishable (from a\n   customer's\
    \ point of view) from a switched circuit network, except\n   possibly in regard\
    \ to error or delay characteristics.  Thus, virtual\n   circuit protocols generally\
    \ place responsibility for end-to-end\n   communications control within the network\
    \ rather than within the\n   Hosts.  For example, when a receiving Host limits\
    \ the rate at which\n   it accepts data from the network, the network in turn\
    \ limits the rate\n   of input from the Host which is transmitting this data stream.\
    \  Host\n   protocols which are designed for virtual circuit networks can be\n\
    \   quite simple, if somewhat inflexible.  For example, the Host might\n   give\
    \ the network a \"link number\" or \"index\" and ask the network to\n   set up\
    \ a virtual circuit to some other Host to be associated with\n   this number,\
    \ and report back if and when the circuit is established.\n   However, significant\
    \ development would be required to add a virtual\n   circuit capability to the\
    \ ARPANET IMP software; the required changes\n   would seem to be more expensive\
    \ and carry greater uncertainty than\n   they are worth.\n   In light of the above,\
    \ our approach in defining this proposed\n   protocol has been to start with the\
    \ ARPANET Host/Host Protocol and\n   modify it according to some of the concepts\
    \ of the IFIP Protocol in\n   order to remedy its major deficiencies.  The remainder\
    \ of this\n   document specifies the protocol, which we have designed for this\n\
    \   purpose.\n"
- title: II.  COMMUNICATION CONCEPTS
  contents:
  - "II.  COMMUNICATION CONCEPTS\n   The IMP subnetwork imposes a number of physical\
    \ restrictions on\n   communications between Hosts.  These restrictions are presented\
    \ in\n   BBN Report No. 1822.  In particular, the concepts of leaders,\n   messages,\
    \ padding, message ID's and message types are of interest to\n   the design of\
    \ Host/Host Protocol.  The following discussion assumes\n   that the reader is\
    \ familiar with these concepts.\n   The IMP subnetwork takes cognizance only of\
    \ Hosts, but in general a\n   Host connected to the network can support several\
    \ users, several\n   terminals, or several independent processes.  Since many\
    \ or all of\n   these users, terminals, or processes will need to use the network\n\
    \   concurrently, a fundamental requirement of the Host/Host Protocol is\n   to\
    \ provide process-to-process communication over the network.  Thus,\n   it is\
    \ necessary for the Host/Host Protocol to provide a richer\n   addressing structure\
    \ than is required by the IMP subnetwork.\n   Processes within a Host are envisioned\
    \ as communicating with the rest\n   of the network through a network control\
    \ program (NCP) resident in\n   that Host, which implements the Host/Host protocol.\
    \  The primary\n   functions of an NCP are to establish connections, break connections,\n\
    \   and control data flow over connections.  A connection couples two\n   processes\
    \ so that the output from one process is input to the other\n   and vice versa.\
    \  The NCP may be implemented either as part of the\n   Host's operating system\
    \ or a separate user process, although it must\n   have the capability of communicating\
    \ with all of the processes or\n   routines which are attempting to use the network.\n\
    \   In order to accomplish its tasks, the NCP of one Host must\n   communicate\
    \ with the NCPs of other Hosts.  To this end, a particular\n   communication path\
    \ between each pair of Hosts has been designated as\n   the control connection.\
    \  Messages transmitted over the control\n   connection are called control messages,\
    \ and must always be\n   interpreted by an NCP as a sequence of one or more control\
    \ commands.\n   For example, one kind of control command is used to initiate a\n\
    \   connection while another kind carries notification that a connection\n   has\
    \ been terminated.*\n      * Note that in BBN Report No. 1822, messages of non-zero\
    \ type are\n        called control messages, and are used to control the flow\
    \ of\n        information between a Host and its IMP.  In this document the\n\
    \        term \"control message\" is used for a message of type zero\n       \
    \ transmitted over the control connection.  The IMPs take no\n        special\
    \ notice of these messages.\n   The maximum size of a message is limited by the\
    \ IMP subnetwork to\n   approximately 1000 8-bit bytes, and in fact may be further\
    \ limited by\n   the receiving Host for flow control reasons, as described later.\n\
    \   Accordingly, the transmitting process, or its Network Control\n   Program,\
    \ must take responsibility for fragmenting long interprocess\n   messages into\
    \ messages of a size conforming to the Host/Host and\n   Host/IMP protocols. \
    \ For this reason, it is impossible for a sending\n   Host to guarantee that any\
    \ significance should be attached to message\n   boundaries by receiving processes.\
    \  Nevertheless, message boundaries\n   will occur naturally, and should be used\
    \ in a reasonable way wherever\n   possible; that is, a sending process or its\
    \ NCP should not act\n   arbitrarily in deciding to fragment messages.  For example,\
    \ this\n   protocol specifies that each control message must contain an integral\n\
    \   number of control commands and no single control command will be\n   split\
    \ into two pieces which are carried through the network in\n   separate messages.\n\
    \   A major concern of the Host/Host Protocol is the definition of the\n   method\
    \ for references to processes in other Hosts.  In order to\n   facilitate this,\
    \ a standard name space is used, with a separate\n   portion of the name space\
    \ allocated to each Host.  Each Host\n   therefore must map internal process identifiers\
    \ into its portion of\n   this name space.  The elements of the name space are\
    \ called sockets.\n   A socket forms one end of a connection and a connection\
    \ is fully\n   specified by a pair of sockets, one in each Host.  A socket is\n\
    \   identified by a Host number and a 16-bit socket number.  The same\n   16-bit\
    \ socket number in different Hosts represents difference\n   sockets.  In order\
    \ to avoid the transmission of a pair of 16-bit\n   socket numbers in each message\
    \ between these sockets, the process of\n   connection establishment allows each\
    \ Host to define a mapping, valid\n   for the lifetime of the connection being\
    \ established, from the 32\n   bits which specify the socket pair to an 8-bit\
    \ number.\n   No constraints are placed on the assignment of socket numbers;\n\
    \   however, since a pair of socket numbers defines a unique connection,\n   it\
    \ is clear that in assigning socket numbers, a Host must ensure that\n   for each\
    \ new connection at least one of the socket numbers is unique.\n   For example,\
    \ a Host which supports many terminals might choose to use\n   a terminal's physical\
    \ interface number as a portion of the socket\n   number involved in any connection\
    \ established on behalf of that\n   terminal.  This would insure uniqueness at\
    \ the terminal end.  Thus,\n   no conflict would occur if several terminals attempted\
    \ to access a\n   common resource (identified by its own unique socket number).\n\
    \   From the foregoing it should be clear that the Host/Host protocol\n   allows\
    \ a single socket to participate in several connections\n   simultaneously.  This\
    \ is quite similar to what happens in the\n   telephone system, where a company,\
    \ as well as an individual, can be\n   identified with a phone number.  As seen\
    \ from the outside, the phone\n   number of a company is sharable, since several\
    \ conversations can\n   proceed at the same time and the caller does not have\
    \ to worry about\n   the already existing conversations.  Conversely, the phone\
    \ number of\n   an individual is not sharable, since he can process only one\n\
    \   conversation at a time; the same is generally true of a connection to\n  \
    \ a terminal which might be using the network.\n   A final major concept which\
    \ should be explained is the \"windowing\"\n   concept, which is used for flow\
    \ control.  This concept is adapted\n   from the IFIP protocol with some appropriate\
    \ modifications for use in\n   an ARPANET-type network.  When a connection is\
    \ established, a\n   sequence number is initialized to some specified starting\
    \ point and\n   the receiver allocates a certain number of credits to the sender.\n\
    \   Each credit entitles the sender to transmit one message; that is, the\n  \
    \ receiver agrees to provide buffering for the number of messages\n   specified\
    \ by the number of credits granted.  If one thinks of\n   sequence numbers advancing\
    \ from left to right, the initial sequence\n   number defines the left edge of\
    \ a window into the entire sequence\n   number space and the credit, when added\
    \ to the initial sequence\n   number, defines the right edge of the window.  The\
    \ transmitting\n   process is permitted to send as many messages and as would\
    \ fill the\n   window, but not more.\n   When a receiver receives a message whose\
    \ sequence number is at the\n   left window edge (or several consecutive messages\
    \ extending rightward\n   from the left window edge) the receiver returns an acknowledgement\n\
    \   for the rightmost such message, along with a new credit, and advances\n  \
    \ his own window; its new left edge immediately follows the last\n   acknowledged\
    \ message and it's new right edge is at the location\n   defined by adding the\
    \ new credit to the new left window edge.\n   Similarly, when a sender receives\
    \ an acknowledgement he advances his\n   own left window edge to the location\
    \ in the sequence number space\n   specified by the acknowledgement and his own\
    \ right window edge to the\n   location specified by adding the new credit allocation\
    \ to the left\n   window edge.  Fields are reserved in each data message to carry\
    \ an\n   acknowledgement and a credit for traffic flowing in the reverse\n   direction.\
    \  Thus, in the case of interactive or transactional\n   exchanges, no control\
    \ messages need to be sent.\n   In the event that a sender does not receive acknowledgements\
    \ for\n   previously transmitted messages within some timeout period, the\n  \
    \ messages are transmitted again, using the same sequence number as was\n   previously\
    \ assigned.  This allows straightforward recovery from the\n   situation of lost\
    \ messages.  On the other hand, if it is the\n   returning acknowledgement which\
    \ is lost, the fact that the\n   retransmitted message carries an identical sequence\
    \ number allows the\n   receiver to discard it.  However, the receiver should\
    \ notice that at\n   the time of retransmission the sender had not received an\n\
    \   acknowledgement; therefore, the receiver should re-acknowledge this\n   (and\
    \ any subsequently received messages) by transmitting an\n   acknowledgement bearing\
    \ the current left window edge.  Thus, in both\n   the case of lost data messages\
    \ and the case of lost acknowledgements\n   the protocol remains synchronized.\n\
    \   The primary difference between this protocol and the IFIP Protocol is\n  \
    \ in the size of the sequence number field.  The IFIP Protocol is\n   designed\
    \ for interconnections of many networks with huge\n   variabilities in delay and\
    \ with a strong possibility that messages\n   will not be delivered at the destination\
    \ in the same order in which\n   they were transmitted by the source.  Thus, the\
    \ IFIP Protocol uses a\n   16-bit sequence number field which, even at megabit\
    \ per second rates\n   cannot be completely cycled through in less than several\
    \ hours.\n   However, the proposed ARPANET-type network has the characteristic\n\
    \   that delays are typically short, messages are rarely lost, and they\n   are\
    \ always delivered in the same order in which they were sent if\n   they are delivered\
    \ at all.  Therefore, this Host/Host Protocol uses\n   only a 4-bit sequence number\
    \ field which, of course, is cycled\n   through every 16 messages.  This imposes\
    \ the constraint that a window\n   may never be larger than eight messages.  Since\
    \ the sequence number\n   is contained in a 4-bit field, it is also possible to\
    \ use only four\n   bits for each of the credit and acknowledgement fields; thus,\
    \ this\n   protocol uses only 12 bits in each message header rather than 40 bits\n\
    \   used under the IFIP Protocol.\n"
- title: III.  NCP FUNCTIONS
  contents:
  - "III.  NCP FUNCTIONS\n   The functions of the NCP are to establish connections,\
    \ terminate\n   connections, control flow, transmit interrupts, and respond to\
    \ test\n   inquiries.  These functions are explained in this section, and\n  \
    \ control commands are introduced as needed.  In Section IV the formats\n   of\
    \ all control commands are presented together.\n   Connection Establishment\n\
    \      The command used to establish the connection is the RFC (request\n    \
    \  for connection).\n          8*       16           16           8        16\
    \       8\n      ----------------------------------------------------------------\n\
    \      !  RFC  ! my-socket ! your-socket !  Index  !  size  ! credit  !\n    \
    \  ----------------------------------------------------------------\n        \
    \ * The number shown above each control command field is the\n           length\
    \ of that field in bits.\n      The RFC command either requests the establishment\
    \ of a connection\n      between a pair of sockets or accepts a previously received\
    \ request\n      for connection.  Since the RFC command is used both for requesting\n\
    \      and accepting the establishment of a connection, it is possible\n     \
    \ for either of two cooperating processes to initiate connection\n      establishment.\
    \  Even if both processes were to simultaneously\n      request the establishment\
    \ of a connection, each would interpret\n      receipt of the RFC sent by the\
    \ other as an acceptance of its own\n      RFC, and thus the connection would\
    \ be established without\n      difficulty.  The my-socket and your-socket fields\
    \ in the RFC\n      identify the sockets which terminate the ends of the connection\
    \ at\n      each Host.  The index field of the RFC specifies an index number\n\
    \      which will be contained in each data transmission sent over this\n    \
    \  connection from the \"my-socket\" to the \"your-socket\" end of the\n     \
    \ connection.  The size field of the RFC specifies the maximum\n      number of\
    \ 8-bit bytes which are permitted to be sent from the\n      \"your-socket\" to\
    \ the \"my-socket\" end of the connection in any one\n      message.  The credit\
    \ field of the RFC specifies the initial size\n      (in the range 0-7) of the\
    \ window in the \"your-socket\" to the \"my-\n      socket\" direction of the\
    \ connection.  A pair of RFCs exchanged\n      between two Hosts matches when\
    \ the my-socket field of one equals\n      your-socket field of the other, and\
    \ vice versa.  The connection is\n      established when a matching pair of RFCs\
    \ has been exchanged.\n      Connections are uniquely specified by the sockets\
    \ which terminate\n      the connection; thus, a pair of socket numbers cannot\
    \ be used to\n      identify two different connections simultaneously.  Similarly,\
    \ the\n      index is used to specify which connection a data message pertains\n\
    \      to; thus, an index value cannot be reused while the connection to\n   \
    \   which it was first assigned is still active or in the process of\n      being\
    \ established.  For example, consider an RFC sent from Host A\n      to Host B\
    \ whose my-socket field contains the value X, your-socket\n      field contains\
    \ the value Y, and index contains the value Z.  Until\n      the requested connection\
    \ has been closed (even if it is never\n      established) or reinitialized, Host\
    \ A is prohibited from sending a\n      different RFC to Host B whose my-socket\
    \ field and your-socket\n      fields are X and Y, or whose index field is Z.\
    \  Note that the\n      prohibition against the reuse of the values X and Y treats\
    \ them as\n      a pair; that is, another RFC may be sent from Host A to Host\
    \ B,\n      whose my-socket field contains the value X so long as the your-\n\
    \      socket field contains some value other than Y.\n      In general there\
    \ is no prescribed lifetime for an RFC.  A Host is\n      permitted to queue incoming\
    \ RFCs and withhold a response for an\n      arbitrarily long time, or, alternatively,\
    \ to reject requests\n      immediately if it has not already sent a matching\
    \ RFC.  Of course,\n      the Host which originally sent the RFC may be unwilling\
    \ to wait\n      for an arbitrarily long time so it may abort the request.\n \
    \     The decision to queue or not to queue incoming RFCs has important\n    \
    \  implications which must not be ignored.  Each RFC which is queued,\n      of\
    \ course, requires a small amount of memory in the Host doing the\n      queuing.\
    \  If the incoming RFC is queued until a local process\n      takes control of\
    \ the local socket and accepts (or rejects) the\n      RFC, but no local process\
    \ ever takes control of the socket, the\n      RFC must be queued \"forever\"\
    .  On the other hand, if no queuing is\n      performed, the cooperating processes\
    \ which may be attempting to\n      establish communication may be able to establish\
    \ this\n      communication only by accident.\n      The most reasonable solution\
    \ to the problems posed above is for\n      each NCP to give processes running\
    \ in its own Host two options for\n      attempting to initiate connections. \
    \ The first option would allow\n      a process to cause an RFC to be sent to\
    \ a specified remote socket,\n      with the NCP notifying the process as to whether\
    \ this RFC was\n      accepted or rejected by the remote Host.  The second option\
    \ would\n      allow a process to tell its own NCP to \"listen\" for an RFC to\
    \ a\n      specified local socket from some remote socket (the process might\n\
    \      also specify the particular remote socket and/or Host it wishes to\n  \
    \    communicate with) and to accept the RFC (i.e., return a matching\n      RFC)\
    \ if and when it arrives.  Note that this also involves queuing\n      (of \"\
    listen\" requests) but it is internal queuing, which is\n      susceptible to\
    \ reasonable management by the local Host.\n   Connection Termination\n      The\
    \ command used to terminate a connection is CLS (close).\n              8    \
    \     16          16\n          -----------------------------------\n        \
    \  !  CLS  ! my-socket ! your-socket !\n          -----------------------------------\n\
    \      The my-socket field and your-socket field of the CLS command\n      identify\
    \ the sockets which terminate the connection being closed.\n      Each side must\
    \ send and receive a CLS command before the\n      connection termination is completed\
    \ and prohibitions on the reuse\n      of the socket pair and index value are\
    \ ended.\n      It is not necessary for connection to be established (i.e., for\n\
    \      both RFCs to be exchanged) before connection termination begins.\n    \
    \  For example, if a Host wishes to refuse a request for connection\n      it\
    \ sends back a CLS instead of a matching RFC.  The refusing Host\n      then waits\
    \ for the initiating Host to acknowledge the refusal by\n      returning a CLS.\
    \  Similarly, if a Host wishes to abort its\n      outstanding request for connection\
    \ it sends a CLS command.  The\n      foreign Host is obliged to acknowledge the\
    \ CLS with its own CLS.\n      Note that even though the connection was never\
    \ established, CLS\n      commands must be exchanged before the prohibition on\
    \ the reuse of\n      the socket pair or the index is completely ended.  Under\
    \ normal\n      circumstances a Host should not send a CLS command for a\n   \
    \   connection on which that Host has unacknowledged data outstanding.\n     \
    \ Of course, the other Host may have just transmitted data so the\n      sender\
    \ of the CLS command may expect to receive additional data\n      from the other\
    \ Host.\n      The Host should quickly acknowledge an incoming CLS so that the\n\
    \      foreign Host can purge its tables.  In particular, in the absence\n   \
    \   of outstanding unacknowledged data a Host must acknowledge an\n      incoming\
    \ close within 60 seconds.  Following a 60 second period,\n      the Host transmitting\
    \ a CLS may regard the socket pair and the\n      index as \"unused\" and it may\
    \ delete the values from any tables\n      describing active connections.  Of\
    \ course, if the foreign Host\n      malfunctions in such a way that the CLS is\
    \ ignored for longer than\n      60 seconds, subsequent attempts to establish\
    \ connections or\n      transmit data may lead to ambiguous results.  To deal\
    \ with this\n      possibility, a Host should in general \"reinitialize\" its\
    \ use of\n      connection parameters before attempting to establish a new\n \
    \     connection to any Host which has failed to respond to CLS\n      commands.\
    \  Methods for reinitializing connection parameter tables\n      are described\
    \ below.\n   Acknowledgement\n      As described in the previous section, flow\
    \ control is handled by a\n      windowing scheme, based on sequence numbers.\
    \  Credits and\n      acknowledgements can be piggybacked on data traveling over\
    \ the\n      reverse channel.  Thus, in general, acknowledgement of the receipt\n\
    \      of messages will take place over the data connection rather than\n    \
    \  over the control connection.  However, there are some cases when\n      it\
    \ may be desirable to pass acknowledgements over the control\n      connection\
    \ (for example, when there is no data to be returned in\n      the reverse direction).\
    \  In addition, for efficiency it may be\n      desirable to negatively acknowledge\
    \ data transmissions known not\n      to have been delivered, rather than waiting\
    \ for the timeout and\n      retransmission mechanism to cause such messages to\
    \ be\n      retransmitted. [Note that such negative acknowledgement is not\n \
    \     required, since timeout and retransmission is always sufficient to\n   \
    \   guarantee eventual delivery of all data, but may be used to\n      increase\
    \ the efficiency of communication.]  Since the frequency of\n      use of the\
    \ negative acknowledgement system over an ARPANET-type\n      network will be\
    \ extremely low, it is undesirable to leave space\n      for negative acknowledgements\
    \ in the header of every data message.\n      Thus, negative acknowledgement can\
    \ be most conveniently handled by\n      control messages.\n      There are two\
    \ commands dealing with acknowledgements.\n              8       8       4   \
    \    4\n          ---------------------------------\n          !  ACK  ! index\
    \ !  seq  !  crd  !\n          ---------------------------------\n      The ACK\
    \ (acknowledgement) command carries three data fields.  The\n      index value\
    \ is the index used by the sender of the acknowledgement\n      to identify the\
    \ connection.  The sequence (\"seq\") field contains\n      the sequence number\
    \ of the highest-numbered sequential data\n      message correctly received over\
    \ the connection.  [The very first\n      data message to be transmitted over\
    \ a newly established connection\n      will have the sequence number one; until\
    \ this data message is\n      correctly received, any acknowledgement commands\
    \ transmitted for\n      this connection (for example, to change the credit value)\
    \ will\n      have the sequence field set to zero.  This applies whether the\n\
    \      \"acknowledgement\" is carried by an ACK command or is contained in\n \
    \     data messages being sent to the foreign Host over the connection.]\n   \
    \   The credit (\"crd\") field contains a number, in the range 0-7,\n      which\
    \ gives the size of the receive window.  This number, when\n      added to the\
    \ \"seq\", gives the sequence number of the highest\n      numbered message which\
    \ is permitted to be transmitted by the\n      foreign Host.  Thus, a credit of\
    \ zero says that the Host\n      transmitting the ACK command is currently not\
    \ prepared to accept\n      any messages over the connection; and a credit of\
    \ 7 says the Host\n      is prepared to accept up to 7 messages over the connection.\
    \  Of\n      course, since the sequence number is contained in a 4-bit field,\n\
    \      the addition of the sequence number and the credit value must be\n    \
    \  performed modulo 16 (sequence number zero immediately follows\n      sequence\
    \ number 15).\n      As noted above, the ACK command is intended for use with\
    \ data\n      connections where there is no data flow in one direction, for\n\
    \      example, the transmission of a file to a line printer.  In fact it\n  \
    \    should be clear that, since transmission of control messages is\n      not\
    \ synchronized with transmission of data messages (either in the\n      network\
    \ or, more importantly, in the transmitting NCP), ACK\n      commands should not\
    \ be sent for any connection over which data is\n      flowing in the same direction.\
    \  Thus, if an ACK command is\n      generated, the NCP which transmits it must\
    \ insure that the control\n      message which contains it is transmitted prior\
    \ to the transmission\n      of new data messages for the same connection.\n \
    \             8        8       8\n          --------------------------\n     \
    \     !  NACK  ! index !  seq  !\n          --------------------------\n     \
    \ The NACK (negative acknowledgement) command contains two data\n      fields.\
    \  As with the positive acknowledgement command described\n      above, the first\
    \ field is the index number assigned to this\n      connection by the sender of\
    \ the NACK.  However, the second field\n      contains only the 4-bit sequence\
    \ number, right justified in an 8-\n      bit field, of the data message for the\
    \ connection in question\n      which is being negatively acknowledged.  As previously\
    \ noted, the\n      NACK serves no vital function in the protocol but may occasionally\n\
    \      allow more efficient communication.  The NACK is intended to be\n     \
    \ used when the window width is greater than one, the message at the\n      left\
    \ window edge has not been correctly received, and messages\n      toward the\
    \ right of the window have been correctly received.  A\n      timeout will eventually\
    \ cause the retransmission of the missing\n      message, at which point the left\
    \ window edge can be moved forward\n      several messages.  Use of the NACK,\
    \ however, could trigger the\n      immediate retransmission of the missing message\
    \ and thus reduce\n      the delay.  Of course, if more than one message is missing\
    \ it may\n      be desirable to send several NACKs for one index in a single\n\
    \      control message; the protocol permits this, although it is\n      extremely\
    \ unlikely to occur.\n   Re-initialization\n      Occasionally, due to lost control\
    \ messages, system crashes, NCP\n      errors, or other factors, communication\
    \ between two NCPs will be\n      disrupted.  One possible effect of any such\
    \ disruption might be\n      that neither of the involved NCPs could be sure that\
    \ its stored\n      information regarding connections with the other Host matched\
    \ the\n      information stored by the NCP of the other Host.  In this\n     \
    \ situation, an NCP may wish to reinitialize its tables and request\n      that\
    \ the other Host do likewise.  This re-initialization may be\n      requested\
    \ for a particular index and/or socket pair, or globally\n      for all connections\
    \ possibly established with the other Host.  For\n      these purposes, the protocol\
    \ provides three control commands as\n      described below:\n              8\
    \        16           16          8\n          -------------------------------------------\n\
    \          !  RCP  ! my-socket ! your-socket ! index !\n          -------------------------------------------\n\
    \      The RCP (reinitialize connection parameters) command contains\n      three\
    \ data fields.  The my-socket and your-socket fields contain a\n      pair of\
    \ socket numbers, which define a connection; the index field\n      contains a\
    \ value which would identify data messages over a\n      connection.  When this\
    \ command is received by an NCP it should\n      purge its tables of any reference\
    \ to a connection identified by\n      the socket pair or any reference to a connection\
    \ for which\n      received data would be identified by the specified index value;\
    \ of\n      course, only connections using these values with the Host sending\n\
    \      the RCP would be purged.  In effect, the Host sending the RCP\n      command\
    \ is saying: \"I am about to send you an RFC using this\n      socket pair and\
    \ this index to identify a data connection, which I\n      hope we can agree to\
    \ establish.  I do not believe that any use of\n      this socket pair or this\
    \ index conflicts with any previous use,\n      but if you believe it does, please\
    \ record the fact (for later\n      examination) as an error and then delete from\
    \ your tables the\n      conflicting information so that we may proceed to establish\
    \ the\n      connection.\"\n      In case more global difficulties or loss of\
    \ state information are\n      suspected, the protocol provides the pair of control\
    \ commands RST\n      (reset) and RRP (reset reply).\n              8\n      \
    \    ---------\n          !  RST  !\n          ---------\n              8\n  \
    \        ---------\n          !  RRP  !\n          ---------\n      The RST command\
    \ is to be interpreted by the Host receiving it as a\n      signal to purge its\
    \ tables of any entries which arose from\n      communication with the Host which\
    \ sent the RST.  The Host sending\n      the RST should likewise purge its tables\
    \ of any entries which\n      arose from communication with the Host to which\
    \ the RST was sent.\n      The Host receiving the RST should acknowledge receipt\
    \ by returning\n      an RRP.  Once the first Host has sent an RST to the second\
    \ Host,\n      the first Host should not communicate with the second Host (except\n\
    \      for responding to RST) until the second Host returns an RRP.  If\n    \
    \  both NCPs decide to send RSTs at approximately the same time, each\n      Host\
    \ will receive an RST and each must answer with an RRP even\n      though its\
    \ own RST has not been answered.\n      A Host should not send an RRP when an\
    \ RST has not been received.\n      Further, a Host should send only one RST (and\
    \ no other commands)\n      in a single control message and should not send another\
    \ RST to the\n      same Host until either 60 seconds have elapsed or a command\
    \ which\n      is not an RST or RRP has been received from that Host.  Under\n\
    \      these conditions, a single RRP constitutes an answer to all RSTs\n    \
    \  sent to that Host and any other RRPs arriving from that Host\n      should\
    \ be discarded.\n   Interrupts\n      It is sometimes necessary in a communication\
    \ system to circumvent\n      flow control mechanisms when serious errors or other\
    \ important\n      conditions are detected.  For example, the user of a time sharing\n\
    \      terminal who creates and begins the execution of a program which\n    \
    \  contains an erroneous infinite loop may need to \"attract the\n      attention\"\
    \ of the operating system to ask it to cancel the\n      execution of his program,\
    \ even though the operating system may\n      normally \"listen\" to the terminal\
    \ only when the program in\n      execution asks for input.  Similarly, in a computer\
    \ communication\n      network, where flow control may prevent the transmission\
    \ of data\n      from one process to another, under certain extraordinary\n  \
    \    conditions it may be necessary to pass a signal from one process\n      to\
    \ another.  Since the channel between the NCPs of two Hosts is\n      not subject\
    \ to the flow control mechanisms imposed on the data\n      connections, it is\
    \ possible to transmit such an \"out-of-band\"\n      signal over the control\
    \ connection, and for this purpose the INT\n      (interrupt) command is provided.\n\
    \              8       8       8\n          -------------------------\n      \
    \    !  INT  ! index !  seq  !\n          -------------------------\n      The\
    \ INT command contains two data fields.  The index field\n      identifies the\
    \ data connection to which the \"interrupt\" pertains;\n      the sequence number\
    \ (\"seq\"), which is four bits right-justified in\n      an eight-bit field,\
    \ gives the sequence number of the first data\n      message which should \"come\
    \ after\" the interrupt.  In other words,\n      the INT command notifies the\
    \ receiving NCP of an exception\n      condition which must be synchronized with\
    \ the data stream, and the\n      sequence number provides the necessary synchronization.\
    \  Any data\n      messages with sequence numbers to the left of the specified\n\
    \      sequence number were generated before the exception condition\n      arose.\n\
    \      An NCP which receives an INT command should advance the right\n      window\
    \ edge of the specified data connection so that the window\n      contains at\
    \ least the sequence number specified in the interrupt\n      command.  (It may\
    \ be necessary to acknowledge data messages which\n      were not correctly received\
    \ or were not buffered in order to be\n      able to advance the window to this\
    \ point; justification is\n      provided by the assumption that the INT was sent\
    \ only because the\n      flow control mechanisms were preventing the transmission\
    \ of\n      important information.)  Of course, the interrupt or exception\n \
    \     signal itself is subject to the interpretation of the Host\n      receiving\
    \ the signal, but should have a meaning equivalent to:\n      \"notify the process\
    \ in execution, or that process' superior, that\n      something exceptional has\
    \ happened and that the data now buffered\n      is an important message.\"\n\
    \   Test Inquiry\n      It may sometimes be useful for one Host to determine if\
    \ some other\n      Host is carrying on network conversations.  The control command\
    \ to\n      be used for this purpose is ECO (echo).\n              8       8\n\
    \          ------------------\n          !  ECO  !  data  !\n          ------------------\n\
    \      The data field of the ECO command may contain any bit\n      configuration\
    \ chosen by the Host sending the ECO.  Upon receiving\n      an ECO command, an\
    \ NCP should respond by returning the data to the\n      sender in an ERP (echo\
    \ reply) command.\n              8       8\n          ------------------\n   \
    \       !  ERP  !  data  !\n          ------------------\n      A Host should\
    \ respond (with an ERP command) to an incoming ECO\n      command within a reasonable\
    \ time, here defined as sixty seconds or\n      less.  A Host should not send\
    \ an ERP when no ECO has been\n      received.\n   IV.  DECLARATIVE SPECIFICATIONS\n\
    \   Message Format\n      All Host-to-Host messages which conform to this protocol\
    \ shall be\n      constructed as follows:\n      Bits 1-96: Leader - This field\
    \ is as specified in BBN Report No.\n      1822, with the following additional\
    \ specifications.\n      Bits 38-40: Maximum Message Size - This field should\
    \ be zero for\n      all control messages.  For messages sent over data connections,\n\
    \      the value of this field should be calculated from the size\n      received\
    \ in the RFC which established the connection.\n      Bits 65-76: Message-id -\
    \ This field is subdivided into eight bits\n      giving the index of the connection\
    \ of which the message is a part,\n      and four bits giving the sequence number\
    \ of the message.  The\n      index is contained in bits 65-72, and the sequence\
    \ number in bits\n      73-76.\n      Bits 97-100: Acknowledgement - This field\
    \ contains the four-bit\n      sequence number of the highest-numbered data message\
    \ to the left\n      of the window for this connection; that is, the sequence\
    \ number\n      identifying the highest-numbered of the sequence of consecutively\n\
    \      numbered (none missing) data messages which have been correctly\n     \
    \ received over this connection.  If no data messages have been\n      received\
    \ since the connection was established, this field must\n      contain the value\
    \ zero.  This field is not used (i.e., may have\n      any value) in control messages.\n\
    \      Bits 101-104: Credit - This field contains a number in the range\n    \
    \  0-7.  Adding this number (modulo 16) to the sequence number in the\n      acknowledgement\
    \ field (bits 97-100) gives the highest sequence\n      number which the foreign\
    \ Host is permitted to send over this data\n      connection.  Thus, a value of\
    \ zero in this field indicates that no\n      new data messages should be sent,\
    \ and a value of seven indicates\n      that the foreign Host may send up to seven\
    \ messages beyond the\n      message whose sequence number is specified by the\
    \ acknowledgement\n      bits.  Since flow control does not apply to messages\
    \ sent over the\n      control connection, this field may have any value in control\n\
    \      messages.\n      Bits 105 - ... : Text and padding - A sequence of 8-bit\
    \ bytes of\n      text, followed by padding, as specified in BBN Report No. 1822.\n\
    \   Index Assignment\n      Index values must be assigned (in bits 65-72) as follows:\n\
    \       Number     Assignment\n            0     Identifies a control connection\n\
    \            1     Reserved for revisions to this protocol\n        2-191    \
    \ Identify data connections\n      192-255     Reserved for expansion or for other\
    \ protocols\n   Sequence Number Assignment\n      Every data message contains\
    \ a sequence number in bits 73-76.  The\n      sequence number is used by the\
    \ receiver to detect the fact that a\n      transmitted message has been lost,\
    \ to identify the correct\n      location in the data stream to insert a retransmitted\
    \ (and\n      therefore probably out of order) message which was previously lost\n\
    \      (or to detect the retransmitted message as a duplicate) and to\n      identify\
    \ acknowledged messages (or sequences of messages) to the\n      sender.  The\
    \ sequence number is also used by the flow control\n      mechanism.  Since the\
    \ IMP subnetwork itself contains elaborate\n      mechanisms to achieve these\
    \ same goals, it is not anticipated that\n      the error-recovery mechanisms\
    \ based on the sequence numbers will\n      be called into play frequently, and\
    \ thus their efficiency is not\n      of primary importance.\n      Sequence numbers\
    \ are assigned to the two directions of a\n      connection independently.  For\
    \ a given direction of a connection,\n      the first data message transmitted\
    \ after the connection is\n      established must have sequence number one.  Subsequent\
    \ messages\n      are assigned sequentially increasing (modulo 16) sequence numbers;\n\
    \      that is, sequence number zero is assigned to the message following\n  \
    \    message number 15.\n      Sequence numbers are not assigned to control messages,\
    \ since the\n      protocol is designed to permit these messages to be delivered\n\
    \      out-of-sequence without ill effect, and since flow control cannot\n   \
    \   be applied to the control link.\n   Control Messages\n      Messages sent\
    \ over the control connection have the same format as\n      other Host-to-Host\
    \ messages, with the exceptions noted above.\n      However, control messages\
    \ may not contain more than 120 8-bit\n      bytes of text.  Further, control\
    \ messages must contain an integral\n      number of control commands; a single\
    \ control command must not be\n      split into parts which are transmitted in\
    \ different control\n      messages.\n   Message Transmission and Retransmission\n\
    \      Control messages may be transmitted whenever they are required.\n     \
    \ Data messages, however, may be transmitted only when permitted by\n      the\
    \ flow control mechanism; that is, whenever the sequence number\n      assigned\
    \ to the message is within the \"window\" for the appropriate\n      direction\
    \ of the given connection.  The \"left window edge\" (LWE)\n      is defined by\
    \ the highest sequence number (modulo 16) which has\n      been acknowledged (or\
    \ zero, if no messages have been\n      acknowledged).  The \"right window edge\"\
    \ (RWE) is defined by adding\n      (modulo 16) the most recently received credit\
    \ to the left window\n      edge. [Note that LWE=RWE if the most recently received\
    \ credit is\n      zero.]  A message with sequence number SEQ may be transmitted\
    \ only\n      if, prior to the (possible) reduction modulo 16 of the SEQ and/or\n\
    \      RWE, it is true that\n         LWE less-than SEQ less-than-or-equal RWE\n\
    \      Messages should be retransmitted whenever any of the following\n      conditions\
    \ occur:\n      - The IMP subnetwork has returned an \"Incomplete transmission\"\
    \n        (type 9) or \"Error in Data\" (type 8) response to the message\n   \
    \     (identified by having bits 41-76 of the response equal to those\n      \
    \  bits of the transmitted message).  Note that this condition\n        applies\
    \ to control messages as well as data messages.\n      - The sequence number of\
    \ this message is equal to (LWE + 1), and\n        it has been more than 30 seconds\
    \ since the message was last\n        transmitted.\n      - The sequence number\
    \ of the message is specifically identified in\n        a NACK command for this\
    \ connection from the foreign Host.\n      Since messages may occasionally have\
    \ to be retransmitted, it is\n      clear that they should not be discarded by\
    \ the transmitting NCP\n      until they have been acknowledged.  A message is\
    \ considered to be\n      acknowledged when its sequence number, or the sequence\
    \ number of\n      any message to the right of it in the same direction of the\
    \ given\n      connection, is returned in the acknowledgement field of a data\n\
    \      message transmitted in the other direction over this connection,\n    \
    \  or is returned in an ACK command for this connection from the\n      foreign\
    \ Host.\n   Control Commands\n      Control commands are formatted in terms of\
    \ 8-bit bytes.  Each\n      command begins with a one byte opcode.  Opcodes are\
    \ assigned the\n      sequential values 0, 1, 2, ...  to permit table lookup upon\n\
    \      receipt.  The conditions underlying the design and anticipated use\n  \
    \    of the control commands are described in Section III.\n   NOP - No Operation\n\
    \              8\n          ---------\n          !  NOP  !\n          ---------\n\
    \      The NOP command may be sent at any time and should be discarded by\n  \
    \    the receiver.  It may be useful for formatting control messages.\n   RST\
    \ - Reset\n              8\n          ---------\n          !  RST  !\n       \
    \   ---------\n      The RST command is used by one Host to inform another that\
    \ all\n      information regarding any previously existing connections between\n\
    \      the two Hosts should be purged from the NCP tables of the Host\n      receiving\
    \ the RST.  Except for responding to RSTs, the Host which\n      sent the RST\
    \ should not communicate further with the other Host\n      until an RRP is received\
    \ in response.  When a Host is about to\n      begin communicating (e.g., send\
    \ an RFC command) to another Host\n      with which it has no open connections,\
    \ it is good practice to\n      first send an RST command and wait for an RRP\
    \ command.\n   RRP - Reset Reply\n              8\n          ---------\n     \
    \     !  RRP  !\n          ---------\n      The RRP command must be sent in reply\
    \ to an RST command.\n   RFC - Request for Connection\n         8       16   \
    \        16          8      16      8\n      ---------------------------------------------------------\n\
    \      ! RFC ! my-socket ! your-socket ! index ! size ! credit !\n      ---------------------------------------------------------\n\
    \      The RFC command is used to establish a connection.  The \"my-\n      socket\"\
    \ field specifies the socket local to the Host transmitting\n      the RFC; the\
    \ \"your-socket\" field specifies the socket local to the\n      Host to which\
    \ the RFC is transmitted.  The \"index\" field specifies\n      the index value\
    \ which will be given in bits 65-72 of each data\n      message sent from \"my-socket\"\
    \ to \"your-socket\".  The \"size\" field\n      specifies the maximum number\
    \ of 8-bit bytes which may be\n      transmitted in any single message from \"\
    your-socket\" to \"my-\n      socket\".  The \"credit\" field specifies the size\
    \ of the initial\n      sequence number window (in the range 0-7) in the \"your-socket\"\
    \ to\n      \"my-socket\" direction.\n   CLS - Close\n              8        16\
    \           16\n          -----------------------------------\n          !  CLS\
    \  ! my-socket ! your-socket !\n          -----------------------------------\n\
    \      The CLS command is used to terminate a connection.  The connection\n  \
    \    need not be completely established before CLS is sent.\n   RCP - Re-Initialize\
    \ Connection Parameters\n              8        16           16          8\n \
    \         -------------------------------------------\n          !  RCP  ! my-socket\
    \ ! your-socket ! index !\n          -------------------------------------------\n\
    \      The RCP command is used by one Host to inform another that all\n      information\
    \ regarding a possibly previously-existing connection\n      between \"my-socket\"\
    \ and \"your-socket\" AND all information\n      regarding a possibly previously-existing\
    \ connection identified by\n      \"index\" (between these Hosts) should be purged\
    \ from the tables of\n      the Host receiving the RCP.  The \"my-socket\", \"\
    your-socket\", and\n      \"index\" fields are defined as in the RFC command.\n\
    \   ACK - Acknowledgement\n              8       8       4       4\n         \
    \ ---------------------------------\n          !  ACK  ! index !  seq  !  crd\
    \  !\n          ---------------------------------\n      The ACK command may be\
    \ used to acknowledge received data, or to\n      assign credit, without sending\
    \ a data message.  The value in the\n      index field identifies the data connection\
    \ which uses the same\n      index value (in the direction from the sender of\
    \ the ACK to the\n      receiver of the ACK).  The eight bits following the index\
    \ field\n      (the \"seq\" and \"crd\" field) have the same meaning as bits 97-104\n\
    \      of the data message identified by the index value.\n   NACK -- Negative\
    \ Acknowledgement\n              8        8       8\n          --------------------------\n\
    \          !  NACK  ! index !  seq  !\n          --------------------------\n\
    \      The NACK command informs the receiver of the NACK that it should\n    \
    \  immediately retransmit the data message identified by the\n      remaining\
    \ fields.  The index field is defined exactly as for the\n      ACK command. \
    \ The \"seq\" field gives the 4-bit sequence number\n      (right-justified) which\
    \ should be immediately retransmitted.  Note\n      that the data message to be\
    \ retransmitted does not have an index\n      value equal to \"index\", but instead\
    \ is transmitted over the other\n      direction of the data connection which\
    \ the Host sending the NACK\n      identifies by \"index\".  No Host is ever required\
    \ to transmit or\n      act upon a NACK command; however, use of the NACK may\
    \ occasionally\n      permit a decrease in retransmission delay.\n   INT - Interrupt\n\
    \              8       8       8\n          -------------------------\n      \
    \    !  INT  ! index !  seq  !\n          -------------------------\n      The\
    \ INT command is sent over the control link to provide an \"out-\n      of-band\"\
    \ (and hence not subject to flow control) signal for the\n      data connection\
    \ denoted by the index field.  The index value is\n      the value which would\
    \ appear in bits 65-72 of a data message sent\n      from the sender of the INT\
    \ command to the receiver of the INT\n      command.  The means of synchronizing\
    \ this signal with the data\n      being transmitted over the data connection\
    \ is the inclusion of a\n      4-bit sequence number (right-justified) in the\
    \ \"seq\" field.  The\n      number specified by this field denotes the first\
    \ data message\n      which \"follows\" the out-of-band signal.\n   ECO - Echo\
    \ Request\n              8       8\n          ------------------\n          !\
    \  ECO  !  data  !\n          ------------------\n      The ECO command is used\
    \ only for test purposes.  The data field\n      may be any bit configuration\
    \ convenient to the Host sending the\n      ECO command.\n   ERP - Echo Reply\n\
    \              8       8\n          ------------------\n          !  ERP  !  data\
    \  !\n          ------------------\n      The ERP command must be sent in reply\
    \ to an ECO command.  The data\n      field must be identical to the data field\
    \ in the incoming ECO\n      command.\n   Opcode Assignment\n      Opcodes are\
    \ defined to be 8-bit unsigned binary numbers.  The\n      values assigned to\
    \ opcodes are:\n          NOP  =  0\n          INT  =  1\n          RFC  =  2\n\
    \          CLS  =  3\n          ACK  =  4\n          NACK =  5\n          RCP\
    \  =  6\n          RST  =  7\n          RRP  =  8\n          ECO  =  9\n     \
    \     ERP  = 10\n         [ This RFC was put into machine readable form for entry\
    \ ]\n         [ into the online RFC archives by Alex McKenzie with    ]\n    \
    \     [ support from BBN Corp. and its successors.     7/2000 ]\n"
