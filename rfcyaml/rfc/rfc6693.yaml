- title: __initial_text__
  contents:
  - ''
- title: Internet Research Task Force (IRTF)                          A. Lindgren
  contents:
  - "Internet Research Task Force (IRTF)                          A. Lindgren\n  Probabilistic\
    \ Routing Protocol for Intermittently Connected Networks\n"
- title: Abstract
  contents:
  - "Abstract\n   This document is a product of the Delay Tolerant Networking Research\n\
    \   Group and has been reviewed by that group.  No objections to its\n   publication\
    \ as an RFC were raised.\n   This document defines PRoPHET, a Probabilistic Routing\
    \ Protocol using\n   History of Encounters and Transitivity.  PRoPHET is a variant\
    \ of the\n   epidemic routing protocol for intermittently connected networks that\n\
    \   operates by pruning the epidemic distribution tree to minimize\n   resource\
    \ usage while still attempting to achieve the best-case\n   routing capabilities\
    \ of epidemic routing.  It is intended for use in\n   sparse mesh networks where\
    \ there is no guarantee that a fully\n   connected path between the source and\
    \ destination exists at any time,\n   rendering traditional routing protocols\
    \ unable to deliver messages\n   between hosts.  These networks are examples of\
    \ networks where there\n   is a disparity between the latency requirements of\
    \ applications and\n   the capabilities of the underlying network (networks often\
    \ referred\n   to as delay and disruption tolerant).  The document presents an\n\
    \   architectural overview followed by the protocol specification.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This document is a product of the Internet Research Task\n   Force (IRTF).\
    \  The IRTF publishes the results of Internet-related\n   research and development\
    \ activities.  These results might not be\n   suitable for deployment.  This RFC\
    \ represents the consensus of the\n   Delay Tolerant Networking Research Group\
    \ of the Internet Research\n   Task Force (IRTF).  Documents approved for publication\
    \ by the IRSG\n   are not a candidate for any level of Internet Standard; see\
    \ Section 2\n   of RFC 5741.\n   Information about the current status of this\
    \ document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc6693.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2012 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   4\n     1.1.  Relation to the Delay-Tolerant Networking Architecture\
    \  .   7\n     1.2.  Applicability of the Protocol . . . . . . . . . . . . . .\
    \   8\n     1.3.  PRoPHET as Compared to Regular Routing Protocols  . . . .  10\n\
    \     1.4.  Requirements Notation . . . . . . . . . . . . . . . . . .  11\n  \
    \ 2.  Architecture  . . . . . . . . . . . . . . . . . . . . . . . .  11\n    \
    \ 2.1.  PRoPHET . . . . . . . . . . . . . . . . . . . . . . . . .  11\n      \
    \ 2.1.1.  Characteristic Time Interval  . . . . . . . . . . . .  12\n       2.1.2.\
    \  Delivery Predictability Calculation . . . . . . . . .  12\n       2.1.3.  Optional\
    \ Delivery Predictability Optimizations  . . .  17\n       2.1.4.  Forwarding\
    \ Strategies and Queueing Policies . . . . .  18\n     2.2.  Bundle Protocol Agent\
    \ to Routing Agent Interface  . . . .  19\n     2.3.  PRoPHET Zone Gateways .\
    \ . . . . . . . . . . . . . . . . .  20\n     2.4.  Lower-Layer Requirements and\
    \ Interface  . . . . . . . . .  21\n   3.  Protocol Overview . . . . . . . . .\
    \ . . . . . . . . . . . . .  22\n     3.1.  Neighbor Awareness  . . . . . . .\
    \ . . . . . . . . . . . .  22\n     3.2.  Information Exchange Phase  . . . .\
    \ . . . . . . . . . . .  23\n       3.2.1.  Routing Information Base Dictionary\
    \ . . . . . . . . .  25\n       3.2.2.  Handling Multiple Simultaneous Contacts\
    \ . . . . . . .  26\n     3.3.  Routing Algorithm . . . . . . . . . . . . . .\
    \ . . . . . .  28\n     3.4.  Bundle Passing  . . . . . . . . . . . . . . . .\
    \ . . . . .  32\n       3.4.1.  Custody . . . . . . . . . . . . . . . . . . .\
    \ . . . .  33\n     3.5.  When a Bundle Reaches Its Destination . . . . . . .\
    \ . . .  33\n     3.6.  Forwarding Strategies . . . . . . . . . . . . . . . .\
    \ . .  34\n     3.7.  Queueing Policies . . . . . . . . . . . . . . . . . . .\
    \ .  36\n   4.  Message Formats . . . . . . . . . . . . . . . . . . . . . . .\
    \  38\n     4.1.  Header  . . . . . . . . . . . . . . . . . . . . . . . . .  39\n\
    \     4.2.  TLV Structure . . . . . . . . . . . . . . . . . . . . . .  44\n  \
    \   4.3.  TLVs  . . . . . . . . . . . . . . . . . . . . . . . . . .  45\n    \
    \   4.3.1.  Hello TLV . . . . . . . . . . . . . . . . . . . . . .  45\n      \
    \ 4.3.2.  Error TLV . . . . . . . . . . . . . . . . . . . . . .  47\n       4.3.3.\
    \  Routing Information Base Dictionary TLV . . . . . . .  48\n       4.3.4.  Routing\
    \ Information Base TLV  . . . . . . . . . . . .  50\n       4.3.5.  Bundle Offer\
    \ and Response TLVs (Version 2)  . . . . .  51\n   5.  Detailed Operation  . .\
    \ . . . . . . . . . . . . . . . . . . .  55\n     5.1.  High-Level State Tables\
    \ . . . . . . . . . . . . . . . . .  56\n     5.2.  Hello Procedure . . . . .\
    \ . . . . . . . . . . . . . . . .  59\n       5.2.1.  Hello Procedure State Tables\
    \  . . . . . . . . . . . .  61\n     5.3.  Information Exchange Phase  . . . .\
    \ . . . . . . . . . . .  62\n       5.3.1.  State Definitions for the Initiator\
    \ Role  . . . . . .  66\n       5.3.2.  State Definitions for the Listener Role\
    \ . . . . . . .  71\n       5.3.3.  Recommendations for Information Exchange Timer\n\
    \               Periods . . . . . . . . . . . . . . . . . . . . . . .  77\n  \
    \     5.3.4.  State Tables for Information Exchange . . . . . . . .  78\n    \
    \ 5.4.  Interaction with Nodes Using Version 1 of PRoPHET . . . .  92\n   6. \
    \ Security Considerations . . . . . . . . . . . . . . . . . . .  93\n     6.1.\
    \  Attacks on the Operation of the Protocol  . . . . . . . .  94\n       6.1.1.\
    \  Black-Hole Attack . . . . . . . . . . . . . . . . . .  94\n       6.1.2.  Limited\
    \ Black-Hole Attack / Identity Spoofing . . . .  95\n       6.1.3.  Fake PRoPHET\
    \ ACKs . . . . . . . . . . . . . . . . . .  95\n       6.1.4.  Bundle Store Overflow\
    \ . . . . . . . . . . . . . . . .  96\n       6.1.5.  Bundle Store Overflow with\
    \ Delivery Predictability\n               Manipulation  . . . . . . . . . . .\
    \ . . . . . . . . .  96\n     6.2.  Interactions with External Routing Domains\
    \  . . . . . . .  97\n   7.  IANA Considerations . . . . . . . . . . . . . . .\
    \ . . . . . .  97\n     7.1.  DTN Routing Protocol Number . . . . . . . . . .\
    \ . . . . .  98\n     7.2.  PRoPHET Protocol Version  . . . . . . . . . . . .\
    \ . . . .  98\n     7.3.  PRoPHET Header Flags  . . . . . . . . . . . . . . .\
    \ . . .  99\n     7.4.  PRoPHET Result Field  . . . . . . . . . . . . . . . .\
    \ . .  99\n     7.5.  PRoPHET Codes for Success and Codes for Failure . . . .\
    \ .  99\n     7.6.  PRoPHET TLV Type  . . . . . . . . . . . . . . . . . . . .\
    \ 100\n     7.7.  Hello TLV Flags . . . . . . . . . . . . . . . . . . . . . 101\n\
    \     7.8.  Error TLV Flags . . . . . . . . . . . . . . . . . . . . . 101\n  \
    \   7.9.  RIB Dictionary TLV Flags  . . . . . . . . . . . . . . . . 102\n    \
    \ 7.10. RIB TLV Flags . . . . . . . . . . . . . . . . . . . . . . 102\n     7.11.\
    \ RIB Flags . . . . . . . . . . . . . . . . . . . . . . . . 103\n     7.12. Bundle\
    \ Offer and Response TLV Flags . . . . . . . . . . . 103\n     7.13. Bundle Offer\
    \ and Response B Flags . . . . . . . . . . . . 104\n   8.  Implementation Experience\
    \ . . . . . . . . . . . . . . . . . . 104\n   9.  Deployment Experience . . .\
    \ . . . . . . . . . . . . . . . . . 105\n   10. Acknowledgements  . . . . . .\
    \ . . . . . . . . . . . . . . . . 105\n   11. References  . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . 105\n     11.1. Normative References  . . . .\
    \ . . . . . . . . . . . . . . 105\n     11.2. Informative References  . . . .\
    \ . . . . . . . . . . . . . 106\n   Appendix A.  PRoPHET Example  . . . . . .\
    \ . . . . . . . . . . . . 108\n   Appendix B.  Neighbor Discovery Example . .\
    \ . . . . . . . . . . . 110\n   Appendix C.  PRoPHET Parameter Calculation Example\
    \  . . . . . . . 110\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The Probabilistic Routing Protocol using History of Encounters\
    \ and\n   Transitivity (PRoPHET) algorithm enables communication between\n   participating\
    \ nodes wishing to communicate in an intermittently\n   connected network where\
    \ at least some of the nodes are mobile.\n   One of the most basic requirements\
    \ for \"traditional\" (IP) networking\n   is that there must exist a fully connected\
    \ path between communication\n   endpoints for the duration of a communication\
    \ session in order for\n   communication to be possible.  There are, however,\
    \ a number of\n   scenarios where connectivity is intermittent so that this is\
    \ not the\n   case (thus rendering the end-to-end use of traditional networking\n\
    \   protocols impossible), but where it still is desirable to allow\n   communication\
    \ between nodes.\n   Consider a network of mobile nodes using wireless communication\
    \ with\n   a limited range that is less than the typical excursion distances\n\
    \   over which the nodes travel.  Communication between a pair of nodes\n   at\
    \ a particular instant is only possible when the distance between\n   the nodes\
    \ is less than the range of the wireless communication.  This\n   means that,\
    \ even if messages are forwarded through other nodes acting\n   as intermediate\
    \ routes, there is no guarantee of finding a viable\n   continuous path when it\
    \ is needed to transmit a message.\n   One way to enable communication in such\
    \ scenarios is by allowing\n   messages to be buffered at intermediate nodes for\
    \ a longer time than\n   normally occurs in the queues of conventional routers\
    \ (cf. Delay-\n   Tolerant Networking [RFC4838]).  It would then be possible to\
    \ exploit\n   the mobility of a subset of the nodes to bring messages closer to\n\
    \   their destination by transferring them to other nodes as they meet.\n   Figure\
    \ 1 shows how the mobility of nodes in such a scenario can be\n   used to eventually\
    \ deliver a message to its destination.  In this\n   figure, the four sub-figures\
    \ (a) - (d) represent the physical\n   positions of four nodes (A, B, C, and D)\
    \ at four time instants,\n   increasing from (a) to (d).  The outline around each\
    \ letter\n   represents the range of the radio communication used for\n   communication\
    \ by the nodes: communication is only possible when the\n   ranges overlap.  At\
    \ the start time, node A has a message -- indicated\n   by an asterisk (*) next\
    \ to that node -- to be delivered to node D,\n   but there does not exist a path\
    \ between nodes A and D because of the\n   limited range of available wireless\
    \ connections.  As shown in sub-\n   figures (a) - (d), the mobility of the nodes\
    \ allows the message to\n   first be transferred to node B, then to node C, and\
    \ when finally node\n   C moves within range of node D, it can deliver the message\
    \ to its\n   final destination.  This technique is known as \"transitive\n   networking\"\
    .\n   Mobility and contact patterns in real application scenarios are\n   likely\
    \ to be non-random, but rather be predictable, based on the\n   underlying activities\
    \ of the higher-level application (this could,\n   for example, stem from human\
    \ mobility having regular traffic patterns\n   based on repeating behavioral patterns\
    \ (e.g., going to work or the\n   market and returning home) and social interactions,\
    \ or from any\n   number of other node mobility situations where a proportion\
    \ of nodes\n   are mobile and move in ways that are not completely random over\
    \ time\n   but have a degree of predictability over time).  This means that if\
    \ a\n   node has visited a location or been in contact with a certain node\n \
    \  several times before, it is likely that it will visit that location\n   or\
    \ meet that node again.\n   PRoPHET can also be used in some networks where such\
    \ mobility as\n   described above does not take place.  Predictable patterns in\
    \ node\n   contacts can also occur among static nodes where varying radio\n  \
    \ conditions or power-saving sleeping schedules cause connection\n   between nodes\
    \ to be intermittent.\n   In previously discussed mechanisms to enable communication\
    \ in\n   intermittently connected networks, such as Epidemic Routing\n   [vahdat_00],\
    \ very general approaches have been taken to the problem\n   at hand.  In an environment\
    \ where buffer space and bandwidth are\n   infinite, epidemic routing will give\
    \ an optimal solution to the\n   problem of routing in an intermittently connected\
    \ network with regard\n   to message delivery ratio and latency.  However, in\
    \ most cases,\n   neither bandwidth nor buffer space is infinite, but instead\
    \ they are\n   rather scarce resources, especially in the case of sensor networks.\n\
    \   PRoPHET is fundamentally an epidemic protocol with strict pruning.\n   An\
    \ epidemic protocol works by transferring its data to each and every\n   node\
    \ it meets.  As data is passed from node to node, it is eventually\n   passed\
    \ to all nodes, including the target node.  One of the\n   advantages of an epidemic\
    \ protocol is that by trying every path, it\n   is guaranteed to try the best\
    \ path.  One of the disadvantages of an\n   epidemic protocol is the extensive\
    \ use of resources with every node\n   needing to carry every packet and the associated\
    \ transmission costs.\n   PRoPHET's goal is to gain the advantages of an epidemic\
    \ protocol\n   without paying the price in storage and communication resources\n\
    \   incurred by the basic epidemic protocol.  That is, PRoPHET offers an\n   alternative\
    \ to basic epidemic routing, with lower demands on buffer\n   space and bandwidth,\
    \ with equal or better performance in cases where\n   those resources are limited,\
    \ and without loss of generality in\n   scenarios where it is suitable to use\
    \ PRoPHET.\n   In a situation where PRoPHET is applicable, the patterns are expected\n\
    \   to have a characteristic time (such as the expected time between\n   encounters\
    \ between mobile stations) that is in turn related to the\n   expected time that\
    \ traffic will take to reach its destination in the\n   part of the network that\
    \ is using PRoPHET.  This characteristic time\n   provides guidance for configuration\
    \ of the PRoPHET protocol in a\n   network.  When appropriately configured, the\
    \ PRoPHET protocol\n   effectively builds a local model of the expected patterns\
    \ in the\n   network that can be used to optimize the usage of resources by\n\
    \   reducing the amount of traffic sent to nodes that are unlikely to\n   lead\
    \ to eventual delivery of the traffic to its destination.\n     +----------------------------+\
    \   +----------------------------+\n     |                      ___   |   |  \
    \                    ___   |\n     |      ___            /   \\  |   |       \
    \              /   \\  |\n     |     /   \\          (  D  ) |   |           \
    \         (  D  ) |\n     |    (  B  )          \\___/  |   |     ___        \
    \     \\___/  |\n     |     \\___/    ___           |   |    /___\\    ___   \
    \         |\n     |___          /   \\          |   |   (/ B*\\)  /   \\     \
    \      |\n     |   \\        (  C  )         |   |   (\\_A_/) (  C  )        \
    \  |\n     | A* )        \\___/          |   |    \\___/   \\___/           |\n\
    \     |___/                        |   |                            |\n     +----------------------------+\
    \   +----------------------------+\n              (a) Time t                 \
    \    (b) Time (t + dt)\n     +----------------------------+   +----------------------------+\n\
    \     |        _____         ___   |   |        ___           ___   |\n     |\
    \       / / \\ \\       /   \\  |   |       /   \\         /___\\  |\n     | \
    \     ( (B C* )     (  D  ) |   |      (  B  )       (/ D*\\) |\n     |      \
    \ \\_\\_/_/       \\___/  |   |       \\___/        (\\_C_/) |\n     |     ___\
    \                    |   |     ___             \\___/  |\n     |    /   \\   \
    \                |   |    /   \\                   |\n     |   (  A  )       \
    \           |   |   (  A  )                  |\n     |    \\___/             \
    \      |   |    \\___/                   |\n     |                           \
    \ |   |                            |\n     +----------------------------+   +----------------------------+\n\
    \          (c) Time (t + 2*dt)               (d) Time (t + 3*dt)\n           \
    \    Figure 1: Example of transitive communication\n   This document presents\
    \ a framework for probabilistic routing in\n   intermittently connected networks,\
    \ using an assumption of non-random\n   mobility of nodes to improve the delivery\
    \ rate of messages while\n   keeping buffer usage and communication overhead at\
    \ a low level.\n   First, a probabilistic metric called delivery predictability\
    \ is\n   defined.  The document then goes on to define a probabilistic routing\n\
    \   protocol using this metric.\n"
- title: 1.1.  Relation to the Delay-Tolerant Networking Architecture
  contents:
  - "1.1.  Relation to the Delay-Tolerant Networking Architecture\n   The Delay-Tolerant\
    \ Networking (DTN) architecture [RFC4838] defines an\n   architecture for communication\
    \ in environments where traditional\n   communication protocols cannot be used\
    \ due to excessive delays, link\n   outages, and other extreme conditions.  The\
    \ intermittently connected\n   networks considered here are a subset of those\
    \ covered by the DTN\n   architecture.  The DTN architecture defines routes to\
    \ be computed\n   based on a collection of \"contacts\" indicating the start time,\n\
    \   duration, endpoints, forwarding capacity, and latency of a link in\n   the\
    \ topology graph.  These contacts may be deterministic or may be\n   derived from\
    \ estimates.  The architecture defines some different\n   types of intermittent\
    \ contacts.  The ones called \"opportunistic\" and\n   \"predicted\" are the ones\
    \ addressed by this protocol.\n   Opportunistic contacts are those that are not\
    \ scheduled, but rather\n   present themselves unexpectedly and frequently arise\
    \ due to node\n   mobility.  Predicted contacts are like opportunistic contacts,\
    \ but,\n   based on some information, it might be possible to draw some\n   statistical\
    \ conclusion as to whether or not a contact will be present\n   soon.\n   The\
    \ DTN architecture also introduces the bundle protocol [RFC5050],\n   which provides\
    \ a way for applications to \"bundle\" an entire session,\n   including both data\
    \ and metadata, into a single message, or bundle,\n   that can be sent as a unit.\
    \  The bundle protocol also provides end-\n   to-end addressing and acknowledgments.\
    \  PRoPHET is specifically\n   intended to provide routing services in a network\
    \ environment that\n   uses bundles as its data transfer mechanism but could be\
    \ also be used\n   in other intermittent environments.\n"
- title: 1.2.  Applicability of the Protocol
  contents:
  - "1.2.  Applicability of the Protocol\n   The PRoPHET routing protocol is mainly\
    \ targeted at situations where\n   at least some of the nodes are mobile in a\
    \ way that creates\n   connectivity patterns that are not completely random over\
    \ time but\n   have a degree of predictability.  Such connectivity patterns can\
    \ also\n   occur in networks where nodes switch off radios to preserve power.\n\
    \   Human mobility patterns (often containing daily or weekly periodic\n   activities)\
    \ provide one such example where PRoPHET is expected to be\n   applicable, but\
    \ the applicability is not limited to scenarios\n   including humans.\n   In order\
    \ for PRoPHET to benefit from such predictability in the\n   contact patterns\
    \ between nodes, it is expected that the network exist\n   under similar circumstances\
    \ over a longer timescale (in terms of node\n   encounters) so that the predictability\
    \ can be accurately estimated.\n   The PRoPHET protocol expects nodes to be able\
    \ to establish a local\n   TCP link in order to exchange the information needed\
    \ by the PRoPHET\n   protocol.  Protocol signaling is done out-of-band over this\
    \ TCP link,\n   without involving the bundle protocol agent [RFC5050].  However,\
    \ the\n   PRoPHET protocol is expected to interact with the bundle protocol\n\
    \   agent to retrieve information about available bundles as well as to\n   request\
    \ that a bundle be sent to another node (it is expected that\n   the associated\
    \ bundle protocol agents are then able to establish a\n   link (probably over\
    \ the TCP convergence layer [CLAYER]) to perform\n   this bundle transfer).\n\
    \   TCP provides a reliable bidirectional channel between two peers and\n   guarantees\
    \ in-order delivery of transmitted data.  When using TCP,\n   the guarantee of\
    \ reliable, in-order delivery allows information\n   exchanges of each category\
    \ of information to be distributed across\n   several messages without requiring\
    \ the PRoPHET protocol layer to be\n   concerned that all messages have been received\
    \ before starting the\n   exchange of the next category of information.  At most,\
    \ the last\n   message of the category needs to be marked as such.  This allows\
    \ the\n   receiver to process earlier messages while waiting for additional\n\
    \   information and allows implementations to limit the size of messages\n   so\
    \ that IP fragmentation will be avoided and memory usage can be\n   optimized\
    \ if necessary.  However, implementations MAY choose to build\n   a single message\
    \ for each category of information that is as large as\n   necessary and rely\
    \ on TCP to segment the message.\n   While PRoPHET is currently defined to run\
    \ over TCP, in future\n   versions the information exchange may take place over\
    \ other transport\n   protocols, and these may not provide message segmentation\
    \ or\n   reliable, in-order delivery.  The simple message division used with\n\
    \   TCP MUST NOT be used when the underlying transport does not offer\n   reliable,\
    \ in-order delivery, as it would be impossible to verify that\n   all the messages\
    \ had arrived.  Hence, the capability is provided to\n   segment protocol messages\
    \ into submessages directly in the PRoPHET\n   layer.  Submessages are provided\
    \ with sequence numbers, and this,\n   together with a capability for positive\
    \ acknowledgements, would allow\n   PRoPHET to operate over an unreliable protocol\
    \ such as UDP or\n   potentially directly over IP.\n   Since TCP offers reliable\
    \ delivery, it is RECOMMENDED that the\n   positive acknowledgment capability\
    \ is not used when PRoPHET is run\n   over a TCP transport or similar protocol.\
    \  When running over TCP,\n   implementations MAY safely ignore positive acknowledgments.\n\
    \   Whatever transport protocol is used, PRoPHET expects to use a\n   bidirectional\
    \ link for the information exchange; this allows for the\n   information exchange\
    \ to take place in both directions over the same\n   link avoiding the need to\
    \ establish a second link for information\n   exchange in the reverse direction.\n\
    \   In a large Delay- and Disruption-Tolerant Network (DTN), network\n   conditions\
    \ may vary widely, and in different parts of the network,\n   different routing\
    \ protocols may be appropriate.  In this\n   specification, we consider routing\
    \ within a single \"PRoPHET zone\",\n   which is a set of nodes among which messages\
    \ are routed using\n   PRoPHET.  In many cases, a PRoPHET zone will not span the\
    \ entire DTN,\n   but there will be other parts of the network with other\n  \
    \ characteristics that run other routing protocols.  To handle this,\n   there\
    \ may be nodes within the zone that act as gateways to other\n   nodes that are\
    \ the destinations for bundles generated within the zone\n   or that insert bundles\
    \ into the zone.  Thus, PRoPHET is not\n   necessarily used end-to-end, but only\
    \ within regions of the network\n   where its use is appropriate.\n"
- title: 1.3.  PRoPHET as Compared to Regular Routing Protocols
  contents:
  - "1.3.  PRoPHET as Compared to Regular Routing Protocols\n   While PRoPHET uses\
    \ a mechanism for pruning the epidemic forwarding\n   tree that is similar to\
    \ the mechanism used in metric-based vector\n   routing protocols (where the metric\
    \ might be distance or cost), it\n   should not be confused with a metric vector\
    \ protocol.\n   In a traditional metric-based vector routing protocol, the\n \
    \  information passed from node to node is used to create a single non-\n   looping\
    \ path from source to destination that is optimal given the\n   metric used. \
    \ The path consists of a set of directed edges selected\n   from the complete\
    \ graph of communications links between the network\n   nodes.\n   In PRoPHET,\
    \ that information is used to prune the epidemic tree of\n   paths by removing\
    \ paths that look less likely to provide an effective\n   route for delivery of\
    \ data to its intended destination.  One of the\n   effects of this difference\
    \ is that the regular notions of split\n   horizon, as described in [RFC1058],\
    \ do not apply to PRoPHET.  The\n   purpose of split horizon is to prevent a distance\
    \ vector protocol\n   from ever passing a packet back to the node that sent it\
    \ the packet\n   because it is well known that the source does not lie in that\n\
    \   direction as determined when the directed path was computed.\n   In an epidemic\
    \ protocol, where that previous system already has the\n   data, the notion of\
    \ passing the data back to the node is redundant:\n   the protocol can readily\
    \ determine that such a transfer is not\n   required.  Further, given the mobility\
    \ and constant churn of\n   encounters possible in a DTN that is dominated by\
    \ opportunistic\n   encounters, it is quite possible that, on a future encounter,\
    \ the\n   node might have become a better option for reaching the destination.\n\
    \   Such a later encounter may require a re-transfer of the data if\n   resource\
    \ constraints have resulted in the data being deleted from the\n   original carrier\
    \ between the encounters.\n   The logic of metric routing protocols does not map\
    \ directly onto the\n   family of epidemic protocols.  In particular, it is inappropriate\
    \ to\n   try to assess such protocols against the criteria used to assess\n  \
    \ conventional routing protocols such as the metric vector protocols;\n   this\
    \ is not to say that the family of epidemic protocols do not have\n   weaknesses\
    \ but they have to be considered independently of\n   traditional protocols.\n"
- title: 1.4.  Requirements Notation
  contents:
  - "1.4.  Requirements Notation\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [RFC2119].\n"
- title: 2.  Architecture
  contents:
  - '2.  Architecture

    '
- title: 2.1.  PRoPHET
  contents:
  - "2.1.  PRoPHET\n   This section presents an overview of the main architecture\
    \ of\n   PRoPHET, a Probabilistic Routing Protocol using History of Encounters\n\
    \   and Transitivity.  The protocol leverages the observations made on\n   the\
    \ non-randomness of mobility patterns present in many application\n   scenarios\
    \ to improve routing performance.  Instead of doing blind\n   epidemic replication\
    \ of bundles through the network as previous\n   protocols have done, it applies\
    \ \"probabilistic routing\".\n   To accomplish this, a metric called \"delivery\
    \ predictability\",\n   0 <= P_(A,B) <= 1, is established at every node A for\
    \ each known\n   destination B.  This metric is calculated so that a node with\
    \ a\n   higher value for a certain destination is estimated to be a better\n \
    \  candidate for delivering a bundle to that destination (i.e., if\n   P_(A,B)>P_(C,B),\
    \ bundles for destination B are preferable to forward\n   to A rather than C).\
    \  It is later used when making forwarding\n   decisions.  As routes in a DTN\
    \ are likely to be asymmetric, the\n   calculation of the delivery predictability\
    \ reflects this, and P_(A,B)\n   may be different from P_(B,A).\n   The delivery\
    \ predictability values in each node evolve over time both\n   as a result of\
    \ decay of the metrics between encounters between nodes\n   and due to changes\
    \ resulting from encounters when metric information\n   for the encountered node\
    \ is updated to reflect the encounter and\n   metric information about other nodes\
    \ is exchanged.\n   When two PRoPHET nodes have a communication opportunity, they\n\
    \   initially enter a two-part Information Exchange Phase (IEP).  In the\n   first\
    \ part of the exchange, the delivery predictabilities for all\n   destinations\
    \ known by each node are shared with the encountered node.\n   The exchanged information\
    \ is used by each node to update the internal\n   delivery predictability vector\
    \ as described below.  After that, the\n   nodes exchange information (including\
    \ destination and size) about the\n   bundles each node carries, and the information\
    \ is used in conjunction\n   with the updated delivery predictabilities to decide\
    \ which bundles to\n   request to be forwarded from the other node based on the\
    \ forwarding\n   strategy used (as discussed in Section 2.1.4).  The forwarding\
    \ of\n   bundles is carried out in the latter part of the Information Exchange\n\
    \   Phase.\n"
- title: 2.1.1.  Characteristic Time Interval
  contents:
  - "2.1.1.  Characteristic Time Interval\n   When an application scenario makes PRoPHET\
    \ applicable, the mobility\n   pattern will exhibit a characteristic time interval\
    \ that reflects the\n   distribution of time intervals between encounters between\
    \ nodes.  The\n   evolution of the delivery predictabilities, which reflects this\n\
    \   mobility pattern, should reflect this same characteristic time\n   interval.\
    \  Accordingly, the parameters used in the equations that\n   specify the evolution\
    \ of delivery predictability (see Section 2.1.2)\n   need to be configured appropriately\
    \ so that the evolution reflects a\n   model of the mobility pattern.\n"
- title: 2.1.2.  Delivery Predictability Calculation
  contents:
  - "2.1.2.  Delivery Predictability Calculation\n   As stated above, PRoPHET relies\
    \ on calculating a metric based on the\n   probability of encountering a certain\
    \ node, and using that to support\n   the decision of whether or not to forward\
    \ a bundle to a certain node.\n   This section describes the operations performed\
    \ on the metrics stored\n   in a node when it encounters another node and a communications\n\
    \   opportunity arises.  In the operations described by the equations\n   that\
    \ follow, the updates are being performed by node A, P_(A,B) is\n   the delivery\
    \ predictability value that node A will have stored for\n   the destination B\
    \ after the encounter, and P_(A,B)_old is the\n   corresponding value that was\
    \ stored before the encounter.  If no\n   delivery predictability value is stored\
    \ for a particular destination\n   B, P_(A,B) is considered to be zero.\n   As\
    \ a special case, the metric value for a node itself is always\n   defined to\
    \ be 1 (i.e., P_(A,A)=1).\n   The equations use a number of parameters that can\
    \ be selected to\n   match the characteristics of the mobility pattern in the\
    \ PRoPHET zone\n   where the node is located (see Section 2.1.1).  Recommended\
    \ settings\n   for the various parameters are given in Section 3.3.  The impact\
    \ on\n   the evolution of delivery predictabilities if encountering nodes have\n\
    \   different parameter setting is discussed in Section 2.1.2.1.\n   The calculation\
    \ of the updates to the delivery predictabilities\n   during an encounter has\
    \ three parts.\n   When two nodes meet, the first thing they do is to update the\n\
    \   delivery predictability for each other, so that nodes that are often\n   encountered\
    \ have a high delivery predictability.  If node B has not\n   met node A for a\
    \ long time or has never met node B, such that\n   P_(A,B) < P_first_threshold,\
    \ then P_(A,B) should be set to\n   P_encounter_first.  Because PRoPHET generally\
    \ has no prior knowledge\n   about whether this is an encounter that will be repeated\
    \ relatively\n   frequently or one that will be a rare event, P_encounter_first\
    \ SHOULD\n   be set to 0.5 unless the node has extra information obtained other\n\
    \   than through the PRoPHET protocol about the likelihood of future\n   encounters.\
    \  Otherwise, P_(A,B) should be calculated as shown in\n   Equation 1, where 0\
    \ <= P_encounter <= 1 is a scaling factor setting\n   the rate at which the predictability\
    \ increases on encounters after\n   the first, and delta is a small positive number\
    \ that effectively sets\n   an upper bound for P_(A,B).  The limit is set so that\n\
    \   predictabilities between different nodes stay strictly less than 1.\n   The\
    \ value of delta should normally be very small (e.g., 0.01) so as\n   not to significantly\
    \ restrict the range of available\n   predictabilities, but it can be chosen to\
    \ make calculations efficient\n   where this is important.\n   P_(A,B) =\n   P_(A,B)_old\
    \ + ( 1 - delta - P_(A,B)_old ) * P_encounter  (Eq. 1)\n   There are practical\
    \ circumstances where an encounter that is\n   logically a single encounter in\
    \ terms of the proximity of the node\n   hardware and/or from the point of view\
    \ of the human users of the\n   nodes results in several communication opportunities\
    \ closely spaced\n   in time.  For example, mobile nodes communicating with each\
    \ other\n   using Wi-Fi ad hoc mode may produce apparent multiple encounters with\n\
    \   a short interval between them but these are frequently due to\n   artifacts\
    \ of the underlying physical network when using wireless\n   connections, where\
    \ transmission problems or small changes in location\n   may result in repeated\
    \ reconnections.  In this case, it would be\n   inappropriate to increase the\
    \ delivery predictability by the same\n   amount for each opportunity as it would\
    \ be increased when encounters\n   occur at longer intervals in the normal mobility\
    \ pattern.\n   In order to reduce the distortion of the delivery predictability\
    \ in\n   these circumstances, P_encounter is a function of the interval since\n\
    \   the last encounter resulted in an update of the delivery\n   predictabilities.\
    \  The form of the function is as shown in Figure 2.\n              P_encounter\n\
    \                   ^\n                   |\n   P_encounter_max +  -  - .-------------------------------------\n\
    \                   |      /\n                   |     / .\n                 \
    \  |    /\n                   |   /   .\n                   |  /\n           \
    \        | /     .\n                   |/\n                   +-------+------------------------------------->\
    \ I\n                          I_typ\n          Figure 2: P_encounter as function\
    \ of time interval, I,\n                              between updates\n   The\
    \ form of the function is chosen so that both the increase of\n   P_(A,B) resulting\
    \ from Equation 1 and the decrease that results from\n   Equation 2 are related\
    \ to the interval between updates for short\n   intervals.  For intervals longer\
    \ than the \"typical\" time (I_typ)\n   between encounters, P_encounter is set\
    \ to a fixed value\n   P_encounter_max.  The break point reflects the transition\
    \ between the\n   \"normal\" communication opportunity regime (where opportunities\
    \ result\n   from the overall mobility pattern) and the closely spaced\n   opportunities\
    \ that result from what are effectively local artifacts\n   of the wireless technology\
    \ used to deliver those opportunities.\n   P_encounter_max is chosen so that the\
    \ increment in P_(A,B) provided\n   by Equation 1 significantly exceeds the decay\
    \ of the delivery\n   predictability over the typical interval between encounters\
    \ resulting\n   from Equation 2.\n   Making P_encounter dependent on the interval\
    \ time also avoids\n   inappropriate extra increments of P_(A,B) in situations\
    \ where node A\n   is in communication with several other nodes simultaneously.\
    \  In this\n   case, updates from each of the communicating nodes have to be\n\
    \   distributed to the other nodes, possibly leading to several updates\n   being\
    \ carried out in a short period.  This situation is discussed in\n   more detail\
    \ in Section 3.2.2.\n   If a pair of nodes do not encounter each other during\
    \ an interval,\n   they are less likely to be good forwarders of bundles to each\
    \ other,\n   thus the delivery predictability values must age, being reduced in\n\
    \   the process.  The second part of the updates of the metric values is\n   application\
    \ of the aging equation shown in Equation 2, where\n   0 <= gamma <= 1 is the\
    \ aging constant, and K is the number of time\n   units that have elapsed since\
    \ the last time the metric was aged.  The\n   time unit used can differ and should\
    \ be defined based on the\n   application and the expected delays in the targeted\
    \ network.\n   P_(A,B) = P_(A,B)_old * gamma^K  (Eq. 2)\n   The delivery predictabilities\
    \ are aged according to Equation 2 before\n   being passed to an encountered node\
    \ so that they reflect the time\n   that has passed since the node had its last\
    \ encounter with any other\n   node.  The results of the aging process are sent\
    \ to the encountered\n   peer for use in the next stage of the process.  The aged\
    \ results\n   received from node B in node A are referenced as P_(B,x)_recv.\n\
    \   The delivery predictability also has a transitive property that is\n   based\
    \ on the observation that if node A frequently encounters node B,\n   and node\
    \ B frequently encounters node C, then node C probably is a\n   good node to which\
    \ to forward bundles destined for node A.\n    Equation 3 shows how this transitivity\
    \ affects the delivery\n   predictability, where 0 <= beta <= 1 is a scaling constant\
    \ that\n   controls how large an impact the transitivity should have on the\n\
    \   delivery predictability.\n   P_(A,C) = MAX( P_(A,C)_old, P_(A,B) * P_(B,C)_recv\
    \ * beta )  (Eq. 3)\n   Node A uses Equation 3 and the metric values received\
    \ from the\n   encountered node B (e.g., P_(B,C)_recv) in the third part of updating\n\
    \   the metric values stored in node A.\n"
- title: 2.1.2.1.  Impact of Encounters between Nodes with Different Parameter
  contents:
  - "2.1.2.1.  Impact of Encounters between Nodes with Different Parameter\n     \
    \     Settings\n   The various parameters used in the three equations described\
    \ in\n   Section 2.1.2 are set independently in each node, and it is therefore\n\
    \   possible that encounters may take place between nodes that have been\n   configured\
    \ with different values of the parameters.  This section\n   considers whether\
    \ this could be problematic for the operation of\n   PRoPHET in that zone.\n \
    \  It is desirable that all the nodes operating in a PRoPHET zone should\n   use\
    \ closely matched values of the parameters and that the parameters\n   should\
    \ be set to values that are appropriate for the operating zone.\n   More details\
    \ of how to select appropriate values are given in\n   Section 3.3.  Using closely\
    \ matched values means that delivery\n   predictabilities will evolve in the same\
    \ way in each node, leading to\n   consistent decision making about the bundles\
    \ that should be exchanged\n   during encounters.\n   Before going on to consider\
    \ the impact of reasonable but different\n   settings, it should be noted that\
    \ malicious nodes can use\n   inappropriate settings of the parameters to disrupt\
    \ delivery of\n   bundles in a PRoPHET zone as described in Section 6.\n   Firstly\
    \ and importantly, use of different, but legitimate, settings\n   in encountering\
    \ nodes will not cause problems in the protocol itself.\n   Apart from P_encounter_first,\
    \ the other parameters control the rate\n   of change of the metric values or\
    \ limit the range of valid values\n   that will be stored in a node.  None of\
    \ the calculations in a node\n   will be invalidated or result in illegal values\
    \ if the metric values\n   received from another node were calculated using different\n\
    \   parameters.  Furthermore, the protocol is designed so that it is not\n   possible\
    \ to carry delivery predictabilities outside the permissible\n   range of 0 to\
    \ 1.\n   A node MAY consider setting received values greater than (1 - delta)\n\
    \   to (1 - delta) if this would simplify operations.  However, there are\n  \
    \ some special situations where it may be appropriate for the delivery\n   predictability\
    \ for another node to be 1.  For example, if a DTN using\n   PRoPHET has multiple\
    \ gateways to the continuously connected Internet,\n   the delivery predictability\
    \ seen from PRoPHET in one gateway for the\n   other gateway nodes can be taken\
    \ as 1 since they are permanently\n   connected through the Internet.  This would\
    \ allow traffic to be\n   forwarded into the DTN through the most advantageous\
    \ gateway even if\n   it initially arrives at another gateway.\n   Simulation\
    \ work indicates that the update calculations are quite\n   stable in the face\
    \ of changes to the rate parameters, so that minor\n   discrepancies will not\
    \ have a major impact on the performance of the\n   protocol.  The protocol is\
    \ explicitly designed to deal with\n   situations where there are random factors\
    \ in the opportunistic nature\n   of node encounters, and this randomness dominates\
    \ over the\n   discrepancies in the parameters.\n   More major discrepancies may\
    \ lead to suboptimal behavior of the\n   protocol, as certain paths might be more\
    \ preferred or more deprecated\n   inappropriately.  However, since the protocol\
    \ overall is epidemic in\n   nature, this would not generally lead to non-delivery\
    \ of bundles, as\n   they would also be passed to other nodes and would still\
    \ be\n   delivered, though possibly not on the optimal path.\n"
- title: 2.1.3.  Optional Delivery Predictability Optimizations
  contents:
  - '2.1.3.  Optional Delivery Predictability Optimizations

    '
- title: 2.1.3.1.  Smoothing
  contents:
  - "2.1.3.1.  Smoothing\n   To give the delivery predictability a smoother rate of\
    \ change, a node\n   MAY apply one of the following methods:\n   1.  Keep a list\
    \ of NUM_P values for each destination instead of only\n       a single value.\
    \  (The recommended value is 4, which has been\n       shown in simulations to\
    \ give a good trade-off between smoothness\n       and rate of response to changes.)\
    \  The list is held in order of\n       acquisition.  When a delivery predictability\
    \ is updated, the\n       value at the \"newest\" position in the list is used\
    \ as input to\n       the equations in Section 2.1.2.  The oldest value in the\
    \ list is\n       then discarded and the new value is written in the \"newest\"\
    \n       position of the list.  When a delivery predictability value is\n    \
    \   needed (either for sending to a peering PRoPHET node, or for\n       making\
    \ a forwarding decision), the average of the values in the\n       list is calculated,\
    \ and that value is then used.  If less than\n       NUM_P values have been entered\
    \ into the list, only the positions\n       that have been filled should be used\
    \ for the averaging.\n   2.  In addition to keeping the delivery predictability\
    \ as described\n       in Section 2.1.2, a node MAY also keep an exponential weighted\n\
    \       moving average (EWMA) of the delivery predictability.  The EWMA\n    \
    \   is then used to make forwarding decisions and to report to\n       peering\
    \ nodes, but the value calculated according to\n       Section 2.1.2 is still\
    \ used as input to the calculations of new\n       delivery predictabilities.\
    \  The EWMA is calculated according to\n       Equation 4, where 0 <= alpha <=\
    \ 1 is the weight of the most\n       current value.\n   P_ewma = P_ewma_old *\
    \ (1 - alpha) + P * alpha  (Eq. 4)\n   The appropriate choice of alpha may vary\
    \ depending on application\n   scenario circumstances.  Unless prior knowledge\
    \ of the scenario is\n   available, it is suggested that alpha is set to 0.5.\n"
- title: 2.1.3.2.  Removal of Low Delivery Predictabilities
  contents:
  - "2.1.3.2.  Removal of Low Delivery Predictabilities\n   To reduce the data to\
    \ be transferred between two nodes, a node MAY\n   treat delivery predictabilities\
    \ smaller than P_first_threshold, where\n   P_first_threshold is a small number,\
    \ as if they were zero, and thus\n   they do not need to be stored or included\
    \ in the list sent during the\n   Information Exchange Phase.  If this optimization\
    \ is used, care must\n   be taken to select P_first_threshold to be smaller than\
    \ delivery\n   predictability values normally present in the network for\n   destinations\
    \ for which this node is a forwarder.  It is possible that\n   P_first_threshold\
    \ could be calculated based on delivery\n   predictability ranges and the amount\
    \ they change historically, but\n   this has not been investigated yet.\n"
- title: 2.1.4.  Forwarding Strategies and Queueing Policies
  contents:
  - "2.1.4.  Forwarding Strategies and Queueing Policies\n   In traditional routing\
    \ protocols, choosing where to forward a message\n   is usually a simple task;\
    \ the message is sent to the neighbor that\n   has the path to the destination\
    \ with the lowest cost (often the\n   shortest path).  Normally, the message is\
    \ also sent to only a single\n   node since the reliability of paths is relatively\
    \ high.  However, in\n   the settings we envision here, things are radically different.\
    \  The\n   first possibility that must be considered when a bundle arrives at\
    \ a\n   node is that there might not be a path to the destination available,\n\
    \   so the node has to buffer the bundle, and upon each encounter with\n   another\
    \ node, the decision must be made whether or not to transfer a\n   particular\
    \ bundle.  Furthermore, having duplicates of messages (on\n   different nodes,\
    \ as the bundle offer/request mechanism described in\n   Section 4.3.5 ensures\
    \ that a node does not receive a bundle it\n   already carries) may also be sensible,\
    \ as forwarding a bundle to\n   multiple nodes can increase the delivery probability\
    \ of that bundle.\n   Unfortunately, these decisions are not trivial to make.\
    \  In some\n   cases, it might be sensible to select a fixed threshold and only\
    \ give\n   a bundle to nodes that have a delivery predictability over that\n \
    \  threshold for the destination of the bundle.  On the other hand, when\n   encountering\
    \ a node with a low delivery predictability, it is not\n   certain that a node\
    \ with a higher metric will be encountered within a\n   reasonable time.  Thus,\
    \ there can also be situations where we might\n   want to be less strict in deciding\
    \ who to give bundles to.\n   Furthermore, there is the problem of deciding how\
    \ many nodes to give\n   a certain bundle to.  Distributing a bundle to a large\
    \ number of\n   nodes will of course increase the probability of delivering that\n\
    \   particular bundle to its destination, but this comes at the cost of\n   consuming\
    \ more system resources for bundle storage and possibly\n   reducing the probability\
    \ of other bundles being delivered.  On the\n   other hand, giving a bundle to\
    \ only a few nodes (maybe even just a\n   single node) will use less system resources,\
    \ but the probability of\n   delivering a bundle is lower, and the delay incurred\
    \ is high.\n   When resources are constrained, nodes may suffer from storage\n\
    \   shortage, and may have to drop bundles before they have been\n   delivered\
    \ to their destinations.  They may also wish to consider the\n   length of bundles\
    \ being offered by an encountered node before\n   accepting transfer of the bundle\
    \ in order to avoid the need to drop\n   the new bundle immediately or to ensure\
    \ that there is adequate space\n   to hold the bundle offered, which might require\
    \ other bundles to be\n   dropped.  As with the decision as to whether or not\
    \ to forward a\n   bundle, deciding which bundles to accept and/or drop to still\n\
    \   maintain good performance might require different policies in\n   different\
    \ scenarios.\n   Nodes MAY define their own forwarding strategies and queueing\n\
    \   policies that take into account the special conditions applicable to\n   the\
    \ nodes, and local resource constraints.  Some default strategies\n   and policies\
    \ that should be suitable for most normal operations are\n   defined in Section\
    \ 3.6 and Section 3.7.\n"
- title: 2.2.  Bundle Protocol Agent to Routing Agent Interface
  contents:
  - "2.2.  Bundle Protocol Agent to Routing Agent Interface\n   The bundle protocol\
    \ [RFC5050] introduces the concept of a \"bundle\n   protocol agent\" that manages\
    \ the interface between applications and\n   the \"convergence layers\" that provide\
    \ the transport of bundles\n   between nodes during communication opportunities.\
    \  This specification\n   extends the bundle protocol agent with a routing agent\
    \ that controls\n   the actions of the bundle protocol agent during an (opportunistic)\n\
    \   communications opportunity.\n   This specification defines the details of\
    \ the PRoPHET routing agent,\n   but the interface defines a more general interface\
    \ that is also\n   applicable to alternative routing protocols.\n   To enable\
    \ the PRoPHET routing agent to operate properly, it must be\n   aware of the bundles\
    \ stored at the node, and it must also be able to\n   tell the bundle protocol\
    \ agent of that node to send a bundle to a\n   peering node.  Therefore, the bundle\
    \ protocol agent needs to provide\n   the following interface/functionality to\
    \ the routing agent:\n   Get Bundle List\n        Returns a list of the stored\
    \ bundles and their attributes to the\n        routing agent.\n   Send Bundle\n\
    \        Makes the bundle protocol agent send a specified bundle.\n   Accept Bundle\n\
    \        Gives the bundle protocol agent a new bundle to store.\n   Bundle Delivered\n\
    \        Tells the bundle protocol agent that a bundle was delivered to\n    \
    \    its destination.\n   Drop Bundle Advice\n        Advises the bundle protocol\
    \ agent that a specified bundle should\n        not be offered for forwarding\
    \ in future and may be dropped by\n        the bundle protocol agent if appropriate.\n\
    \   Route Import\n        Can be used by a gateway node in a PRoPHET zone to import\n\
    \        reachability information about endpoint IDs (EIDs) that are\n       \
    \ external to the PRoPHET zone.  Translation functions dependent\n        on the\
    \ external routing protocol will be used to set the\n        appropriate delivery\
    \ predictabilities for imported destinations\n        as described in Section\
    \ 2.3.\n   Route Export\n        Can be used by a gateway node in a PRoPHET zone\
    \ to export\n        reachability information (destination EIDs and corresponding\n\
    \        delivery predictabilities) for use by routing protocols in other\n  \
    \      parts of the DTN.\n      Implementation Note: Depending on the distribution\
    \ of functions in\n      a complete bundle protocol agent supporting PRoPHET,\
    \ reception and\n      delivery of bundles may not be carried out directly by\
    \ the PRoPHET\n      module.  In this case, PRoPHET can inform the bundle protocol\n\
    \      agent about bundles that have been requested from communicating\n     \
    \ nodes.  Then, the Accept Bundle and Bundle Delivered functions can\n      be\
    \ implemented as notifications of the PRoPHET module when the\n      relevant\
    \ bundles arrive at the node or are delivered to local\n      applications.\n"
- title: 2.3.  PRoPHET Zone Gateways
  contents:
  - "2.3.  PRoPHET Zone Gateways\n   PRoPHET is designed to handle routing primarily\
    \ within a \"PRoPHET\n   zone\", i.e., a set of nodes that all implement the PRoPHET\
    \ routing\n   scheme.  However, since we recognize that a PRoPHET routing zone\
    \ is\n   unlikely to encompass an entire DTN, there may be nodes within the\n\
    \   zone that act as gateways to other nodes that are the destinations\n   for\
    \ bundles generated within the zone or that insert bundles into the\n   zone.\n\
    \   PRoPHET MAY elect to export and import routes across a bundle\n   protocol\
    \ agent interface.  The delivery predictability to use for\n   routes that are\
    \ imported depends on the routing protocol used to\n   manage those routes.  If\
    \ a translation function between the external\n   routing protocol and PRoPHET\
    \ exists, it SHOULD be used to set the\n   delivery predictability.  If no such\
    \ translation function exists, the\n   delivery predictability SHOULD be set to\
    \ 1.  For those routes that\n   are exported, the current delivery predictability\
    \ will be exported\n   with the route.\n"
- title: 2.4.  Lower-Layer Requirements and Interface
  contents:
  - "2.4.  Lower-Layer Requirements and Interface\n   PRoPHET can be run on a large\
    \ number of underlying networking\n   technologies.  To accommodate its operation\
    \ on all kinds of lower\n   layers, it requires the lower layers to provide the\
    \ following\n   functionality and interfaces.\n   Neighbor discovery and maintenance\n\
    \        A PRoPHET node needs to know the identity of its neighbors and\n    \
    \    when new neighbors appear and old neighbors disappear.  Some\n        wireless\
    \ networking technologies might already contain\n        mechanisms for detecting\
    \ neighbors and maintaining this state.\n        To avoid redundancies and inefficiencies,\
    \ neighbor discovery is\n        thus not included as a part of PRoPHET, but PRoPHET\
    \ relies on\n        such a mechanism in lower layers.  The lower layers MUST\
    \ provide\n        the two functions listed below.  If the underlying networking\n\
    \        technology does not support such services, a simple neighbor\n      \
    \  discovery scheme using local broadcasts of beacon messages could\n        be\
    \ run in between PRoPHET and the underlying layer.  An example\n        of a simple\
    \ neighbor discovery mechanism that could be used is\n        in Appendix B.\n\
    \        New Neighbor\n             Signals to the PRoPHET agent that a new node\
    \ has become a\n             neighbor.  A neighbor is defined here as another\
    \ node that\n             is currently within communication range of the wireless\n\
    \             networking technology in use.  The PRoPHET agent should now\n  \
    \           start the Hello procedure as described in Section 5.2.\n        Neighbor\
    \ Gone\n             Signals to the PRoPHET agent that one of its neighbors has\n\
    \             left.\n   Local Address\n        An address used by the underlying\
    \ communication layer (e.g., an\n        IP or Media Access Control (MAC) address)\
    \ that identifies the\n        sender address of the current message.  This address\
    \ must be\n        unique among the nodes that can currently communicate and is\n\
    \        only used in conjunction with an Instance Number to identify a\n    \
    \    communicating pair of nodes as described in Section 4.1.  This\n        address\
    \ and its format is dependent on the communication layer\n        that is being\
    \ used by the PRoPHET layer.\n"
- title: 3.  Protocol Overview
  contents:
  - "3.  Protocol Overview\n   The PRoPHET protocol involves two principal phases:\n\
    \   o  becoming aware of new neighbors that implement the protocol and\n     \
    \ establishing a point-to-point connection between each pair of\n      encountering\
    \ nodes, and\n   o  using the connection for information exchange needed to establish\n\
    \      PRoPHET routing and to exchange bundles.\n"
- title: 3.1.  Neighbor Awareness
  contents:
  - "3.1.  Neighbor Awareness\n   Since the operation of the protocol is dependent\
    \ on the encounters of\n   nodes running PRoPHET, the nodes must be able to detect\
    \ when a new\n   neighbor is present.  The protocol may be run on several different\n\
    \   networking technologies, and as some of them might already have\n   methods\
    \ available for detecting neighbors, PRoPHET does not include a\n   mechanism\
    \ for neighbor discovery.  Instead, it requires the\n   underlying layer to provide\
    \ a mechanism to notify the protocol of\n   when neighbors appear and disappear\
    \ as described in Section 2.4.\n   When a new neighbor has been detected, the\
    \ protocol starts to set up\n   a link with that node through the Hello message\
    \ exchange as described\n   in Section 5.2.  The Hello message exchange allows\
    \ for negotiation of\n   capabilities between neighbors.  At present, the only\
    \ capability is a\n   request that the offering node should or should not include\
    \ bundle\n   payload lengths with all offered bundles rather than just for\n \
    \  fragments.  Once the link has been set up, the protocol may continue\n   to\
    \ the Information Exchange Phase (see Section 3.2).  Once this has\n   been completed,\
    \ the nodes will normally recalculate the delivery\n   predictabilities using\
    \ the equations and mechanisms described in\n   Sections 2.1.2 and 2.1.3.\n  \
    \ As described in Section 2.1.2, there are some circumstances in which\n   a single\
    \ logical encounter may result in several actual communication\n   opportunities.\
    \  To avoid the delivery predictability of the\n   encountered node being increased\
    \ excessively under these\n   circumstances, the value of P_encounter is made\
    \ dependent on the\n   interval time between delivery predictability updates when\
    \ the\n   interval is less than the typical interval between encounters, but it\n\
    \   is a constant for longer intervals.\n   In order to make use of this time\
    \ dependence, PRoPHET maintains a\n   list of recently encountered nodes identified\
    \ by the Endpoint\n   Identifier (EID) that the node uses to identify the communication\n\
    \   session and containing the start time of the last communication\n   session\
    \ with that node.  The size of this list is controlled because\n   nodes that\
    \ are not in contact and that started their last connection\n   more than a time\
    \ I_typ before the present can be dropped from the\n   list.  It also maintains\
    \ a record of the time at which the decay\n   function (Equation 2) was last applied\
    \ to the delivery\n   predictabilities in the node.\n"
- title: 3.2.  Information Exchange Phase
  contents:
  - "3.2.  Information Exchange Phase\n   The Information Exchange Phase involves\
    \ two parts:\n   o  establishing the Router Information Base (RIB Exchange Sub-Phase),\n\
    \      and\n   o  exchanging bundles using this information (Bundle Passing Sub-\n\
    \      Phase).\n   Four types of information are exchanged during this process:\n\
    \   o  Routing Information Base Dictionary (RIB Dictionary or RIBD),\n   o  Routing\
    \ Information Base (RIB),\n   o  Bundle Offers, and\n   o  Bundle Responses.\n\
    \   During a communication opportunity, several sets of each type of\n   information\
    \ may be transferred in each direction as explained in the\n   rest of this section.\
    \  Each set can be transferred in one or more\n   messages.  When (and only when)\
    \ using a connection-oriented reliable\n   transport protocol such as TCP as envisaged\
    \ in this document, a set\n   can be partitioned across messages by the software\
    \ layer above the\n   PRoPHET protocol engine.\n   In this case, the last message\
    \ in a set is flagged in the protocol.\n   This allows the higher-level software\
    \ to minimize the buffer memory\n   requirements by avoiding the need to build\
    \ very large messages in one\n   go and allows the message size to be controlled\
    \ outside of PRoPHET.\n   However, this scheme is only usable if the transport\
    \ protocol\n   provides reliable, in-order delivery of messages, as the messages\
    \ are\n   not explicitly sequence numbered and the overall size of the set is\n\
    \   not passed explicitly.\n   The specification of PRoPHET also provides a submessage\
    \ mechanism and\n   retransmission that allows large messages specified by the\
    \ higher\n   level to be transmitted in smaller chunks.  This mechanism was\n\
    \   originally provided to allow PRoPHET to operate over unreliable\n   transport\
    \ protocols such as UDP, but can also be used with reliable\n   transports if\
    \ the higher-level software does not want to handle\n   message fragmentation.\
    \  However, the sequencing and length adds\n   overhead that is redundant if the\
    \ transport protocol already provides\n   reliable, in-order delivery.\n   The\
    \ first step in the Information Exchange Phase is for the protocol\n   to send\
    \ one or more messages containing a RIB Dictionary TLV (Type-\n   Length-Value\
    \ message component) to the node with which it is peering.\n   This set of messages\
    \ contain a dictionary of the Endpoint Identifiers\n   (EIDs) of the nodes that\
    \ will be listed in the Routing Information\n   Base (RIB); see Section 3.2.1\
    \ for more information about this\n   dictionary.  After this, one or more messages\
    \ containing a Routing\n   Information Base TLV are sent.  This TLV contains a\
    \ list of the EIDs\n   that the node has knowledge of, and the corresponding delivery\n\
    \   predictabilities for those nodes, together with flags describing the\n   capabilities\
    \ of the sending node.  Upon reception of a complete set\n   of these messages,\
    \ the peer node updates its delivery predictability\n   table according to the\
    \ equations in Section 2.1.2.  The peer node\n   then applies its forwarding strategy\
    \ (see Section 2.1.4) to determine\n   which of its stored bundles it wishes to\
    \ offer the node that sent the\n   RIB; that node will then be the receiver for\
    \ any bundles to be\n   transferred.\n   After making this decision, one or more\
    \ Bundle Offer TLVs are\n   prepared, listing the bundle identifiers and their\
    \ destinations for\n   all bundles the peer node wishes to offer to the receiver\
    \ node that\n   sent the RIB.  As described in [RFC5050], a bundle identifier\n\
    \   consists of up to five component parts.  For a complete bundle, the\n   identifier\
    \ consists of\n   o  source EID,\n   o  creation timestamp - time of creation,\
    \ and\n   o  creation timestamp - sequence number.\n   Additionally, for a bundle\
    \ fragment, the identifier also contains\n   o  offset within the payload at which\
    \ the fragment payload data\n      starts, and\n   o  length of the fragment payload\
    \ data.\n   If any of the Bundle Offer TLVs lists a bundle for which the source\n\
    \   or destination EID was not included in the previous set of RIBD\n   information\
    \ sent, one or more new RIBD TLVs are sent next with an\n   incremental update\
    \ of the dictionary.  When the receiver node has a\n   dictionary with all necessary\
    \ EIDs, the Bundle Offer TLVs are sent to\n   it.  The Bundle Offer TLVs also\
    \ contain a list of PRoPHET ACKs (see\n   Section 3.5).  If requested by the receiver\
    \ node during the Hello\n   phase, the Bundle Offer TLV will also specify the\
    \ payload length for\n   all bundles rather than for just fragments.  This information\
    \ can be\n   used by the receiving node to assist with the selection of bundles\
    \ to\n   be accepted from the offered list, especially if the available bundle\n\
    \   storage capacity is limited.\n   The receiving node then examines the list\
    \ of offered bundles and\n   selects bundles that it will accept according to\
    \ its own policies,\n   considering the bundles already present in the node and\
    \ the current\n   availability of resources in the node.  The list is sorted according\n\
    \   to the priority that the policies apply to the selected bundles, with\n  \
    \ the highest priority bundle first in the list.  The offering node\n   will forward\
    \ the selected bundles in this order.  The prioritized\n   list is sent to the\
    \ offering node in one or more Bundle Response TLVs\n   using the same EID dictionary\
    \ as was used for the Bundle Offer TLV.\n   When a new bundle arrives at a node,\
    \ the node MAY inspect its list of\n   available neighbors, and if one of them\
    \ is a candidate to forward the\n   bundle, a new Bundle Offer TLV MAY be sent\
    \ to that node.  If two\n   nodes remain connected over a longer period of time,\
    \ the Information\n   Exchange Phase will be periodically re-initiated to allow\
    \ new\n   delivery predictability information to be spread through the network\n\
    \   and new bundle exchanges to take place.\n   The Information Exchange Phase\
    \ of the protocol is described in more\n   detail in Section 5.3.\n"
- title: 3.2.1.  Routing Information Base Dictionary
  contents:
  - "3.2.1.  Routing Information Base Dictionary\n   To reduce the overhead of the\
    \ protocol, the Routing Information Base\n   and Bundle Offer/Response TLVs utilize\
    \ an EID dictionary.  This\n   dictionary maps variable-length EIDs (as defined\
    \ in [RFC4838]), which\n   may potentially be quite long, to shorter numerical\
    \ identifiers,\n   coded as Self-Delimiting Numeric Values (SDNVs -- see Section\
    \ 4.1. of\n   RFC 5050 [RFC5050]), which are used in place of the EIDs in\n  \
    \ subsequent TLVs.\n   This dictionary is a shared resource between the two peering\
    \ nodes.\n   Each can add to the dictionary by sending a RIB Dictionary TLV to\
    \ its\n   peer.  To allow either node to add to the dictionary at any time, the\n\
    \   identifiers used by each node are taken from disjoint sets:\n   identifiers\
    \ originated by the node that started the Hello procedure\n   have the least significant\
    \ bit set to 0 (i.e., are even numbers)\n   whereas those originated by the other\
    \ peer have the least significant\n   bit set to 1 (i.e., are odd numbers).  This\
    \ means that the dictionary\n   can be expanded by either node at any point in\
    \ the Information\n   Exchange Phase and the new identifiers can then be used\
    \ in subsequent\n   TLVs until the dictionary is re-initialized.\n   The dictionary\
    \ that is established only persists through a single\n   encounter with a node\
    \ (i.e., while the same link set up by the Hello\n   procedure, with the same\
    \ instance numbers, remains open).\n   Having more then one identifier for the\
    \ same EID does not cause any\n   problems.  This means that it is possible for\
    \ the peers to create\n   their dictionary entries independently if required by\
    \ an\n   implementation, but this may be inefficient as a dictionary entry for\n\
    \   an EID might be sent in both directions between the peers.\n   Implementers\
    \ can choose to inspect entries sent by the node that\n   started the Hello procedure\
    \ and thereby eliminate any duplicates\n   before sending the dictionary entries\
    \ from the other peer.  Whether\n   postponing sending the other peer's entries\
    \ is more efficient depends\n   on the nature of the physical link technology\
    \ and the transport\n   protocol used.  With a genuinely full-duplex link, it\
    \ may be faster\n   to accept possible duplication and send dictionary entries\n\
    \   concurrently in both directions.  If the link is effectively half-\n   duplex\
    \ (e.g., Wi-Fi), then it will generally be more efficient to\n   wait and eliminate\
    \ duplicates.\n   If a node receives a RIB Dictionary TLV containing an identifier\
    \ that\n   is already in use, the node MUST confirm that the EID referred to is\n\
    \   identical to the EID in the existing entry.  Otherwise, the node must\n  \
    \ send an error response to the message with the TLV containing the\n   error\
    \ and ignore the TLV containing the error.  If a node receives a\n   RIB, Bundle\
    \ Offer, or Bundle Response TLV that uses an identifier\n   that is not in its\
    \ dictionary, the node MUST send an error response\n   and ignore the TLV containing\
    \ the error.\n"
- title: 3.2.2.  Handling Multiple Simultaneous Contacts
  contents:
  - "3.2.2.  Handling Multiple Simultaneous Contacts\n   From time to time, a mobile\
    \ node may, for example, be in wireless\n   range of more than one other mobile\
    \ node.  The PRoPHET neighbor\n   awareness protocol will establish multiple simultaneous\
    \ contacts with\n   these nodes and commence information exchanges with each of\
    \ them.\n   When updating the delivery predictabilities as described in\n   Section\
    \ 2.1.2 using the values passed from each of the contacts in\n   turn, some special\
    \ considerations apply when multiple contacts are in\n   progress:\n   SC1  When\
    \ aging the delivery predictabilities according to\n        Equation 2, the value\
    \ of K to be used in each set of\n        calculations is always the amount of\
    \ time since the last aging\n        was done.  For example, if node Z makes contact\
    \ with node A and\n        then with node B, the value of K used when the delivery\n\
    \        predictabilities are aged in node Z for the contact with node B\n   \
    \     will be the time since the delivery predictabilities were aged\n       \
    \ for the contact with node A.\n   SC2  When a new contact starts, the value of\
    \ P_encounter used when\n        applying Equation 1 for the newly contacted node\
    \ is always\n        selected according to the time since the last encounter with\n\
    \        that node.  Thus, the application of Equation 1 to update\n        P_(Z,A)\
    \ when the contact of nodes Z and A starts (in the aging\n        example just\
    \ given) and the updating of P_(Z,B) when the contact\n        of nodes Z and\
    \ B starts will use the appropriate value of\n        P_encounter according to\
    \ how long it is since node Z previously\n        encountered node A and node\
    \ B, respectively.\n   SC3  If, as with the contact between nodes Z and B, there\
    \ is another\n        active contact in progress, such as with node A when the\
    \ contact\n        with node B starts, Equation 1 should *also* be applied to\n\
    \        P_(z,x) for all the nodes \"x\" that have ongoing contacts with\n   \
    \     node Z (i.e., node A in the example given).  However, the value\n      \
    \  of P_encounter used will be selected according to the time since\n        the\
    \ previous update of the delivery predictabilities as a result\n        of information\
    \ received from any other node.  In the example\n        given here, P_(Z,A) would\
    \ also have Equation 1 applied when the\n        delivery predictabilities are\
    \ received from node B, but the\n        value of P_encounter used would be selected\
    \ according to the\n        time since the updates done when the encounter between\
    \ nodes Z\n        and A started rather than the time since the previous encounter\n\
    \        between nodes A and Z.\n   If these simultaneous contacts persist for\
    \ some time, then, as\n   described in Section 3.2, the Information Exchange Phase\
    \ will be\n   periodically rerun for each contact according to the configured\
    \ timer\n   interval.  When the delivery predictability values are recalculated\n\
    \   during each rerun, Equation 1 will be applied as in special\n   consideration\
    \ SC3 above, but it will be applied to the delivery\n   predictability for each\
    \ active contact using the P_encounter value\n   selected according to the time\
    \ since the last set of updates were\n   performed on the delivery predictabilities,\
    \ irrespective of which\n   nodes triggered either the previous or current updates.\
    \  This means\n   that, in the example discussed here, P_(Z,A) and P_(Z,B) will\
    \ be\n   updated using the same value of P_encounter whether node A or node B\n\
    \   initiated the update while the three nodes remain connected.\n   The interval\
    \ between reruns of the information exchange will\n   generally be set to a small\
    \ fraction of the expected time between\n   independent encounters of pairs of\
    \ nodes.  This ensures that, for\n   example, the delivery predictability information\
    \ obtained by node Z\n   from node A will be passed on to node B whether or not\
    \ nodes A and B\n   can communicate directly during this encounter.  This avoids\
    \ problems\n   that may arise from peculiarities of radio propagation during this\n\
    \   sort of encounter, but the scaling of the P_encounter factor\n   according\
    \ to the time between updates of the delivery\n   predictabilities means that\
    \ the predictabilities for the nodes that\n   are in contact are not increased\
    \ excessively as would be the case if\n   each information exchange were treated\
    \ as a separate encounter with\n   the value of P_encounter_max used each time.\
    \  When several nodes are\n   in mutual contact, the delivery predictabilities\
    \ in each node\n   stabilize after a few exchanges due to the scaling of P_encounter\
    \ as\n   well as the form of Equation 3 where a \"max\" function is used.  This\n\
    \   has been demonstrated by simulation.\n   The effect of the updates of the\
    \ delivery predictabilities when there\n   are multiple simultaneous contacts\
    \ is that the information about good\n   routes on which to forward bundles is\
    \ correctly passed between sets\n   of nodes that are simultaneously in contact\
    \ through the transitive\n   update of Equation 3 during each information exchange,\
    \ but the\n   delivery predictabilities for the direct contacts are not\n   exaggerated.\n"
- title: 3.3.  Routing Algorithm
  contents:
  - "3.3.  Routing Algorithm\n   The basic routing algorithm of the protocol is described\
    \ in\n   Section 2.1.  The algorithm uses some parameter values in the\n   calculation\
    \ of the delivery predictability metric.  These parameters\n   are configurable\
    \ depending on the usage scenario, but Figure 3\n   provides some recommended\
    \ default values.  A brief explanation of the\n   parameters and some advice on\
    \ setting appropriate values is given\n   below.\n   I_typ\n        I_typ provides\
    \ a fundamental timescale for the mobility pattern\n        in the PRoPHET scenario\
    \ where the protocol is being applied.  It\n        represents the typical or\
    \ mean time interval between encounters\n        between a given pair of nodes\
    \ in the normal course of mobility.\n        The interval should reflect the \"\
    logical\" time between\n        encounters and should not give significant weight\
    \ to multiple\n        connection events as explained in Section 2.1.2.  This\
    \ time\n        interval informs the settings of many of the other parameters\n\
    \        but is not necessarily directly used as a parameter.\n        Consideration\
    \ needs to be given to the higher statistical\n        moments (e.g., standard\
    \ deviation) as well as the mean (first\n        moment) of the distribution of\
    \ intervals between encounters and\n        the nature of that distribution (e.g.,\
    \ how close to a normal\n        distribution it is).  There is further discussion\
    \ of this point\n        later in this section and in Appendix C.\n   P_encounter_max\n\
    \        P_encounter_max is used as the upper limit of a scaling factor\n    \
    \    that increases the delivery predictability for a destination\n        when\
    \ the destination node is encountered.  A larger value of\n        P_encounter_max\
    \ will increase the delivery predictability\n        faster, and fewer encounters\
    \ will be required for the delivery\n        predictability to reach a certain\
    \ level.  Given that relative\n        rather than absolute delivery predictability\
    \ values are what is\n        interesting for the forwarding mechanisms defined,\
    \ the protocol\n        is very robust to different values of P_encounter as long\
    \ as the\n        same value is chosen for all nodes.  The value should be chosen\n\
    \        so that the increase in the delivery predictability resulting\n     \
    \   from using P_encounter_max in Equation 1 more than compensates\n        for\
    \ the decay of the delivery predictability resulting from\n        Equation 3\
    \ with a time interval of I_typ.\n   P_encounter(intvl)\n        As explained\
    \ in Section 2.1.2, the parameter P_encounter used in\n        Equation 1 is a\
    \ function of the time interval \"intvl\".  The\n        function should be an\
    \ approximation to\n             P_encounter(intvl) =\n             P_encounter_max\
    \ * (intvl / I_typ) for 0<= intvl <= I_typ\n             P_encounter_max for intvl\
    \ > I_typ\n        The function can be quantized and adapted to suit the mobility\n\
    \        pattern and to make implementation easier.  The overall effect\n    \
    \    should be that be that if Equation 1 is applied a number of\n        times\
    \ during a long-lived communication opportunity lasting\n        I_typ, the overall\
    \ increase in the delivery predictability\n        should be approximately the\
    \ same as if there had been two\n        distinct encounters spaced I_typ apart.\
    \  This second case would\n        result in one application of Equation 1 using\
    \ P_encounter_max.\n   P_first_threshold\n        As described in Section 2.1.2,\
    \ the delivery predictability for a\n        destination is gradually reduced\
    \ over time unless increased as a\n        result of direct encounters or through\
    \ the transitive property.\n        If the delivery predictability falls below\
    \ the value\n        P_first_threshold, then the node MAY discard the delivery\n\
    \        predictability information for the destination and treat\n        subsequent\
    \ encounters as if they had never encountered the node\n        previously.  This\
    \ allows the node to reduce the storage needed\n        for delivery predictabilities\
    \ and decreases the amount of\n        information that has to be exchanged between\
    \ nodes; otherwise,\n        the reduction algorithm would result in very small\
    \ but non-zero\n        predictabilities being maintained for nodes that were\
    \ last\n        encountered a long time ago.\n   P_encounter_first\n        As\
    \ described in Section 2.1.2, PRoPHET does not, by default,\n        make any\
    \ assumptions about the likelihood that an encountered\n        node will be encountered\
    \ repeatedly in the future or,\n        alternatively, that this is a one-off\
    \ chance encounter that is\n        unlikely to be repeated.  During an encounter\
    \ where the\n        encountering node has no delivery predictability information\
    \ for\n        the encountered destination node, either because this is really\n\
    \        the first encounter between the nodes or because the previous\n     \
    \   encounter was so long ago that the predictability had fallen\n        below\
    \ P_first_threshold and therefore had been discarded, the\n        encountering\
    \ node sets the delivery predictability for the\n        destination node to P_encounter_first.\
    \  The suggested value for\n        P_encounter_first is 0.5: this value is RECOMMENDED\
    \ as\n        appropriate in the usual case where PRoPHET has no extra (e.g.,\n\
    \        out-of-band) information about whether future encounters with\n     \
    \   this node will be regular or otherwise.\n   alpha\n        The alpha parameter\
    \ is used in the optional smoothing of the\n        delivery predictabilities\
    \ described in Section 2.1.3.1.  It is\n        used to determine the weight of\
    \ the most current P-value in the\n        calculation of an EWMA.\n   beta\n\
    \        The beta parameter adjusts the weight of the transitive property\n  \
    \      of PRoPHET, that is, how much consideration should be given to\n      \
    \  information about destinations that is received from encountered\n        nodes.\
    \  If beta is set to zero, the transitive property of\n        PRoPHET will not\
    \ be active, and only direct encounters will be\n        used in the calculation\
    \ of the delivery predictability.  The\n        higher the value of beta, the\
    \ more rapidly encounters will\n        increase predictabilities through the\
    \ transitive rule.\n   gamma\n        The gamma parameter determines how quickly\
    \ delivery\n        predictabilities age.  A lower value of gamma will cause the\n\
    \        delivery predictability to age faster.  The value of gamma\n        should\
    \ be chosen according to the scenario and environment in\n        which the protocol\
    \ will be used.  If encounters are expected to\n        be very frequent, a lower\
    \ value should be chosen for gamma than\n        if encounters are expected to\
    \ be rare.\n   delta\n        The delta parameter sets the maximum value of the\
    \ delivery\n        predictability for a destination other than for the node itself\n\
    \        (i.e., P_(A,B) for all cases except P_(A,A)) as (1 - delta).\n      \
    \  Delta should be set to a small value to allow the maximum\n        possible\
    \ range for predictabilities but can be configured to\n        make the calculation\
    \ efficient if needed.\n   To set an appropriate gamma value, one should consider\
    \ the \"average\n   expected delivery\" time I_aed in the PRoPHET zone where the\
    \ protocol\n   is to be used, and the time unit used (the resolution with which\
    \ the\n   delivery predictability is being updated).  The I_aed time interval\n\
    \   can be estimated according to the average number of hops that bundles\n  \
    \ have to pass and the average interval between encounters I_typ.\n   Clearly,\
    \ if bundles have a Time To Live (TTL), i.e., the time left\n   until the expiry\
    \ time stored in the bundle occurs, that is less than\n   I_aed, they are unlikely\
    \ to survive in the network to be delivered to\n   a node in this PRoPHET zone.\
    \  However, the TTL for bundles created in\n   nodes in this zone should not be\
    \ chosen solely on this basis because\n   they may pass through other networks.\n\
    \   After estimating I_aed and selecting how much we want the delivery\n   predictability\
    \ to age in one I_aed time period (call this A), we can\n   calculate K, the number\
    \ of time units in one I_aed, using\n   K = (I_aed / time unit).  This can then\
    \ be used to calculate gamma as\n   gamma = K'th-root( A ).\n   I_typ, I_aed,\
    \ K, and gamma can then be used to inform the settings of\n   P_encounter_first,\
    \ P_encounter_max, P_first_threshold, delta, and the\n   detailed form of the\
    \ function P_encounter(intvl).\n   First, considering the evolution of the delivery\
    \ predictability\n   P_(A,B) after a single encounter between nodes A and B, P_(A,B)\
    \ is\n   initially set to P_encounter_first and will then steadily decay until\n\
    \   it reaches P_first_threshold.  The ratio between P_encounter_first\n   and\
    \ P_first_threshold should be set so that P_first_threshold is\n   reached after\
    \ a small multiple (e.g., 3 to 5) of I_aed has elapsed,\n   making it likely that\
    \ any subsequent encounter between the nodes\n   would have occurred before P_(A,B)\
    \ decays below P_first_threshold.\n   If the statistics of the distribution of\
    \ times between encounters is\n   known, then a small multiple of the standard\
    \ deviation of the\n   distribution would be a possible period instead of using\
    \ a multiple\n   of I_aed.\n   Second, if a second encounter between A and B occurs,\
    \ the setting of\n   P_encounter_max should be sufficiently high to reverse the\
    \ decay that\n   would have occurred during I_typ and to increase P_(A,B) above\
    \ the\n   value of P_encounter_first.  After several further encounters,\n   P_(A,B)\
    \ will reach (1 - delta), its upper limit.  As with setting up\n   P_first_threshold,\
    \ P_encounter_max should be set so that the upper\n   limit is reached after a\
    \ small number of encounters spaced apart by\n   I_typ have occurred, but this\
    \ should generally be more than 2 or 3.\n   Finally, beta can be chosen to give\
    \ some smoothing of the influence\n   of transitivity.\n   These instructions\
    \ on how to set the parameters are only given as a\n   possible method for selecting\
    \ appropriate values, but network\n   operators are free to set parameters as\
    \ they choose.  Appendix C goes\n   into some more detail on linking the parameters\
    \ defined here and the\n   more conventional ways of expressing the mobility model\
    \ in terms of\n   distributions of times between events of various types.\n  \
    \ Recommended starting parameter values when specific network\n   measurements\
    \ have not been done are below.  Note: There are no \"one\n   size fits all\"\
    \ default values, and the ideal values vary based on\n   network characteristics.\
    \  It is not inherently necessary for the\n   parameter values to be identical\
    \ at all nodes, but it is recommended\n   that similar values are used at all\
    \ nodes within a PRoPHET zone as\n   discussed in Section 2.1.2.1.\n     +========================================+\n\
    \     |      Parameter     | Recommended value |\n     +========================================+\n\
    \     |   P_encounter_max  |       0.7         |\n     +----------------------------------------+\n\
    \     |  P_encounter_first |       0.5         |\n     +----------------------------------------+\n\
    \     |  P_first_threshold |       0.1         |\n     +----------------------------------------+\n\
    \     |        alpha       |       0.5         |\n     +----------------------------------------+\n\
    \     |        beta        |       0.9         |\n     +----------------------------------------+\n\
    \     |        gamma       |       0.999       |\n     +----------------------------------------+\n\
    \     |        delta       |       0.01        |\n     +========================================+\n\
    \                   Figure 3: Default parameter settings\n"
- title: 3.4.  Bundle Passing
  contents:
  - "3.4.  Bundle Passing\n   Upon reception of the Bundle Offer TLV, the node inspects\
    \ the list of\n   bundles and decides which bundles it is willing to store for\
    \ future\n   forwarding or that it is able to deliver to their destinations. \
    \ This\n   decision has to be made using local policies and considering\n   parameters\
    \ such as available buffer space and, if the node requested\n   bundle lengths,\
    \ the lengths of the offered bundles.  For each such\n   acceptable bundle, the\
    \ node sends a Bundle Response TLV to its\n   peering node, which responds by\
    \ sending the requested bundle.  If a\n   node has some bundles it would prefer\
    \ to receive ahead of others\n   offered (e.g., bundles that it can deliver to\
    \ their final\n   destination), it MAY request the bundles in that priority order.\n\
    \   This is often desirable as there is no guarantee that the nodes will\n   remain\
    \ in contact with each other for long enough to transfer all the\n   acceptable\
    \ bundles.  Otherwise, the node SHOULD assume that the\n   bundles are listed\
    \ in a priority order determined by the peering\n   node's forwarding strategy\
    \ and request bundles in that order.\n"
- title: 3.4.1.  Custody
  contents:
  - "3.4.1.  Custody\n   To free up local resources, a node may give custody of a\
    \ bundle to\n   another node that offers custody.  This is done to move the\n\
    \   retransmission requirement further toward the destination.  The\n   concept\
    \ of custody transfer, and more details on the motivation for\n   its use can\
    \ be found in [RFC4838].  PRoPHET takes no responsibilities\n   for making custody\
    \ decisions.  Such decisions should be made by a\n   higher layer.\n"
- title: 3.5.  When a Bundle Reaches Its Destination
  contents:
  - "3.5.  When a Bundle Reaches Its Destination\n   A PRoPHET ACK is only a confirmation\
    \ that a bundle has been delivered\n   to its destination in the PRoPHET zone\
    \ (within the part of the\n   network where PRoPHET is used for routing, bundles\
    \ might traverse\n   several different types of networks using different routing\n\
    \   protocols; thus, this might not be the final destination of the\n   bundle).\
    \  When nodes exchange Bundle Offer TLVs, bundles that have\n   been ACKed are\
    \ also listed, having the \"PRoPHET ACK\" flag set.  The\n   node that receives\
    \ this list updates its own list of ACKed bundles to\n   be the union of its previous\
    \ list and the received list.  To prevent\n   the list of ACKed bundles growing\
    \ indefinitely, each PRoPHET ACK\n   should have a timeout that MUST NOT be longer\
    \ than the timeout of the\n   bundle to which the ACK corresponds.\n   When a\
    \ node receives a PRoPHET ACK for a bundle it is carrying, it\n   MAY delete that\
    \ bundle from its storage, unless the node holds\n   custody of that bundle. \
    \ The PRoPHET ACK only indicates that a bundle\n   has been delivered to its destination\
    \ within the PRoPHET zone, so the\n   reception of a PRoPHET ACK is not a guarantee\
    \ that the bundle has\n   been delivered to its final destination.\n   Nodes MAY\
    \ track to which nodes they have sent PRoPHET ACKs for\n   certain bundles, and\
    \ MAY in that case refrain from sending multiple\n   PRoPHET ACKs for the same\
    \ bundle to the same node.\n   If necessary in order to preserve system resources,\
    \ nodes MAY drop\n   PRoPHET ACKs prematurely but SHOULD refrain from doing so\
    \ if\n   possible.\n   It is important to keep in mind that PRoPHET ACKs and bundle\
    \ ACKs\n   [RFC5050] are different things.  PRoPHET ACKs are only valid within\n\
    \   the PRoPHET part of the network, while bundle ACKs are end-to-end\n   acknowledgments\
    \ that may go outside of the PRoPHET zone.\n"
- title: 3.6.  Forwarding Strategies
  contents:
  - "3.6.  Forwarding Strategies\n   During the Information Exchange Phase, nodes\
    \ need to decide on which\n   bundles they wish to exchange with the peering node.\
    \  Because of the\n   large number of scenarios and environments that PRoPHET\
    \ can be used\n   in, and because of the wide range of devices that may be used,\
    \ it is\n   not certain that this decision will be based on the same strategy\
    \ in\n   every case.  Therefore, each node MUST operate a _forwarding\n   strategy_\
    \ to make this decision.  Nodes may define their own\n   strategies, but this\
    \ section defines a few basic forwarding\n   strategies that nodes can use.  Note:\
    \ If the node being encountered\n   is the destination of any of the bundles being\
    \ carried, those bundles\n   SHOULD be offered to the destination, even if that\
    \ would violate the\n   forwarding strategy.  Some of the forwarding strategies\
    \ listed here\n   have been evaluated (together with a number of queueing policies)\n\
    \   through simulations, and more information about that and\n   recommendations\
    \ on which strategies to use in different situations\n   can be found in [lindgren_06].\
    \  If not chosen differently due to the\n   characteristics of the deployment\
    \ scenario, nodes SHOULD choose GRTR\n   as the default forwarding strategy.\n\
    \   The short names applied to the forwarding strategies should be read\n   as\
    \ mnemonic handles rather than as specific acronyms for any set of\n   words in\
    \ the specification.\n   We use the following notation in our descriptions below.\
    \  A and B are\n   the nodes that encounter each other, and the strategies are\
    \ described\n   as they would be applied by node A.  The destination node is D.\n\
    \   P_(X,Y) denotes the delivery predictability stored at node X for\n   destination\
    \ Y, and NF is the number of times node A has given the\n   bundle to some other\
    \ node.\n   GRTR\n        Forward the bundle only if P_(B,D) > P_(A,D).\n    \
    \    When two nodes meet, a bundle is sent to the other node if the\n        delivery\
    \ predictability of the destination of the bundle is\n        higher at the other\
    \ node.  The first node does not delete the\n        bundle after sending it as\
    \ long as there is sufficient buffer\n        space available (since it might\
    \ encounter a better node, or even\n        the final destination of the bundle\
    \ in the future).\n   GTMX\n        Forward the bundle only if P_(B,D) > P_(A,D)\
    \ && NF < NF_max.\n        This strategy is like the previous one, but each bundle\
    \ is given\n        to at most NF_max other nodes in addition to the destination.\n\
    \   GTHR\n        Forward the bundle only if\n        P_(B,D) > P_(A,D) OR P_(B,D)\
    \ > FORW_thres,\n        where FORW_thres is a threshold value above which a bundle\n\
    \        should always be given to the node unless it is already present\n   \
    \     at the other node.\n        This strategy is similar to GRTR, but among\
    \ nodes with very high\n        delivery predictability, bundles for that particular\
    \ destination\n        are spread epidemically.\n   GRTR+\n        Forward the\
    \ bundle only if Equation 5 holds, where P_max is the\n        largest delivery\
    \ predictability reported by a node to which the\n        bundle has been sent\
    \ so far.\n             P_(B,D) > P_(A,D) && P_(B,D) > P_max  (Eq. 5)\n      \
    \  This strategy is like GRTR, but each node forwarding a bundle\n        keeps\
    \ track of the largest delivery predictability of any node\n        it has forwarded\
    \ this bundle to, and only forwards the bundle\n        again if the currently\
    \ encountered node has a greater delivery\n        predictability than the maximum\
    \ previously encountered.\n   GTMX+\n        Forward the bundle only if Equation\
    \ 6 holds.\n            P_(B,D) > P_(A,D) && P_(B,D) > P_max && NF < NF_max  (Eq.\
    \ 6)\n        This strategy is like GTMX, but nodes keep track of P_max as in\n\
    \        GRTR+.\n   GRTRSort\n        Select bundles in descending order of the\
    \ value of\n        P_(B,D) - P_(A,D).\n        Forward the bundle only if P_(B,D)\
    \ > P_(A,D).\n        This strategy is like GRTR, but instead of just going through\n\
    \        the bundle queue linearly, this strategy looks at the difference\n  \
    \      in delivery predictabilities for each bundle between the two\n        nodes\
    \ and forwards the bundles with the largest difference\n        first.  As bandwidth\
    \ limitations or disrupted connections may\n        result in not all bundles\
    \ that would be desirable being\n        exchanged, it could be desirable to first\
    \ send bundles that get\n        a large improvement in delivery predictability.\n\
    \   GRTRMax\n        Select bundles in descending order of P_(B,D).\n        Forward\
    \ the bundle only if P_(B,D) > P_(A,D).\n        This strategy begins by considering\
    \ the bundles for which the\n        encountered node has the highest delivery\
    \ predictability.  The\n        motivation for doing this is the same as in GRTRSort,\
    \ but based\n        on the idea that it is better to give bundles to nodes with\
    \ high\n        absolute delivery predictabilities, instead of trying to\n   \
    \     maximize the improvement.\n"
- title: 3.7.  Queueing Policies
  contents:
  - "3.7.  Queueing Policies\n   Because of limited buffer resources, nodes may need\
    \ to drop some\n   bundles.  As is the case with the forwarding strategies, which\
    \ bundle\n   to drop is also dependent on the scenario.  Therefore, each node\
    \ MUST\n   also operate a queueing policy that determines how its bundle queue\n\
    \   is handled.  This section defines a few basic queueing policies, but\n   nodes\
    \ MAY use other policies if desired.  Some of the queueing\n   policies listed\
    \ here have been evaluated (together with a number of\n   forwarding strategies)\
    \ through simulations.  More information about\n   that and recommendations on\
    \ which policies to use in different\n   situations can be found in [lindgren_06].\
    \  If not chosen differently\n   due to the characteristics of the deployment\
    \ scenario, nodes SHOULD\n   choose FIFO as the default queueing policy.\n   The\
    \ short names applied to the queueing policies should be read as\n   mnemonic\
    \ handles rather than as specific acronyms for any set of\n   words in the specification.\n\
    \   FIFO - First In First Out.\n        The bundle that was first entered into\
    \ the queue is the first\n        bundle to be dropped.\n   MOFO - Evict most\
    \ forwarded first.\n        In an attempt to maximize the delivery rate of bundles,\
    \ this\n        policy requires that the routing agent keep track of the number\n\
    \        of times each bundle has been forwarded to some other node.  The\n  \
    \      bundle that has been forwarded the largest number of times is\n       \
    \ the first to be dropped.\n   MOPR - Evict most favorably forwarded first.\n\
    \        Keep a variable FAV for each bundle in the queue, initialized to\n  \
    \      zero.  Each time the bundle is forwarded, update FAV according\n      \
    \  to Equation 7, where P is the predictability metric that the\n        node\
    \ the bundle is forwarded to has for its destination.\n             FAV_new =\
    \ FAV_old + ( 1 - FAV_old ) * P  (Eq. 7)\n        The bundle with the highest\
    \ FAV value is the first to be\n        dropped.\n   Linear MOPR - Evict most\
    \ favorably forwarded first; linear increase.\n        Keep a variable FAV for\
    \ each bundle in the queue, initialized to\n        zero.  Each time the bundle\
    \ is forwarded, update FAV according\n        to Equation 8, where P is the predictability\
    \ metric that the\n        node the bundle is forwarded to has for its destination.\n\
    \             FAV_new = FAV_old + P  (Eq. 8)\n        The bundle with the highest\
    \ FAV value is the first to be\n        dropped.\n   SHLI - Evict shortest life\
    \ time first.\n        As described in [RFC5050], each bundle has a timeout value\n\
    \        specifying when it no longer is meaningful to its application\n     \
    \   and should be deleted.  Since bundles with short remaining Time\n        To\
    \ Live will soon be dropped anyway, this policy decides to drop\n        the bundle\
    \ with the shortest remaining lifetime first.  To\n        successfully use a\
    \ policy like this, there needs to be some form\n        of time synchronization\
    \ between nodes so that it is possible to\n        know the exact lifetimes of\
    \ bundles.  However, this is not\n        specific to this routing protocol, but\
    \ a more general DTN\n        problem.\n   LEPR - Evict least probable first.\n\
    \        Since the node is least likely to deliver a bundle for which it\n   \
    \     has a low delivery predictability, drop the bundle for which the\n     \
    \   node has the lowest delivery predictability, and that has been\n        forwarded\
    \ at least MF times, where MF is a minimum number of\n        forwards that a\
    \ bundle must have been forwarded before being\n        dropped (if such a bundle\
    \ exists).\n   More than one queueing policy MAY be combined in an ordered set,\n\
    \   where the first policy is used primarily, the second only being used\n   if\
    \ there is a need to tie-break between bundles given the same\n   eviction priority\
    \ by the primary policy, and so on.  As an example,\n   one could select the queueing\
    \ policy to be {MOFO; SHLI; FIFO}, which\n   would start by dropping the bundle\
    \ that has been forwarded the\n   largest number of times.  If more than one bundle\
    \ has been forwarded\n   the same number of times, the one with the shortest remaining\n\
    \   lifetime will be dropped, and if that also is the same, the FIFO\n   policy\
    \ will be used to drop the bundle first received.\n   It is worth noting that\
    \ a node MUST NOT drop bundles for which it has\n   custody unless the bundle's\
    \ lifetime expires.\n"
- title: 4.  Message Formats
  contents:
  - "4.  Message Formats\n   This section defines the message formats of the PRoPHET\
    \ routing\n   protocol.  In order to allow for variable-length fields, many numeric\n\
    \   fields are encoded as Self-Delimiting Numeric Values (SDNVs).  The\n   format\
    \ of SDNVs is defined in [RFC5050].  Since many of the fields\n   are coded as\
    \ SDNVs, the size and alignment of fields indicated in\n   many of the specification\
    \ diagrams below are indicative rather than\n   prescriptive.  Where SDNVs and/or\
    \ text strings are used, the octets\n   of the fields will be packed as closely\
    \ as possible with no\n   intervening padding between fields.\n   Explicit-length\
    \ fields are specified for all variable-length string\n   fields.  Accordingly,\
    \ strings are not null terminated and just\n   contain the exact set of octets\
    \ in the string.\n   The basic message format shown in Figure 4 consists of a\
    \ header (see\n   Section 4.1) followed by a sequence of one or more Type-Length-Value\n\
    \   components (TLVs) taken from the specifications in Section 4.2.\n       0\
    \                   1                   2                   3\n       0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   ~                            Header                             ~\n      |\
    \                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   ~                             TLV 1                             ~\n      |\
    \                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                .                              |\n   \
    \   ~                                .                              ~\n      |\
    \                                .                              |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   ~                             TLV n                             ~\n      |\
    \                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                  Figure 4: Basic PRoPHET Message Format\n"
- title: 4.1.  Header
  contents:
  - "4.1.  Header\n       0                   1                   2              \
    \     3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |Protocol Number|Version| Flags |     Result    |     Code      |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \      Receiver Instance        |      Sender Instance          |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                    Transaction Identifier                     |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |S|\
    \      SubMessage Number      |         Length (SDNV)         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                                                               |\n   \
    \   ~                          Message Body                         ~\n      |\
    \                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                     Figure 5: PRoPHET Message Header\n   Protocol Number\n \
    \       The DTN Routing Protocol Number encoded as 8-bit unsigned\n        integer\
    \ in network bit order.  The value of this field is 0.\n        The PRoPHET header\
    \ is organized in this way so that in principle\n        PRoPHET messages could\
    \ be sent as the Protocol Data Unit of an\n        IP packet if an IP protocol\
    \ number was allocated for PRoPHET.\n        At present, PRoPHET is only specified\
    \ to use a TCP transport for\n        carriage of PRoPHET packets, so that the\
    \ protocol number serves\n        only to identify the PRoPHET protocol within\
    \ DTN.  Transmitting\n        PRoPHET packets directly as an IP protocol on a\
    \ public IP\n        network such as the Internet would generally not work well\n\
    \        because middleboxes (such as firewalls and NAT boxes) would be\n    \
    \    unlikely to allow the protocol to pass through, and the protocol\n      \
    \  does not provide any congestion control.  However, it could be\n        so\
    \ used on private networks for experimentation or in situations\n        where\
    \ all communications are between isolated pairs of nodes.\n        Also, in the\
    \ future, other protocols that require transmission\n        of metadata between\
    \ DTN nodes could potentially use the same\n        format and protocol state\
    \ machinery but with a different\n        Protocol Number.\n   Version\n     \
    \   The version of the PRoPHET Protocol.  Encoded as a 4-bit\n        unsigned\
    \ integer in network bit order.  This document defines\n        version 2.\n \
    \  Flags\n        Reserved field of 4 bits.\n   Result\n        Field that is\
    \ used to indicate whether a response is required to\n        the request message\
    \ if the outcome is successful.  A value of\n        \"NoSuccessAck\" indicates\
    \ that the request message does not\n        expect a response if the outcome\
    \ is successful, and a value of\n        \"AckAll\" indicates that a response\
    \ is expected if the outcome is\n        successful.  In both cases, a failure\
    \ response MUST be generated\n        if the request fails.  If running over a\
    \ TCP transport or\n        similar protocol that offers reliable in order delivery,\n\
    \        deployments MAY choose not to send \"Success\" responses when an\n  \
    \      outcome is successful.  To achieve this, the Result field is set\n    \
    \    to the \"NoSuccessAck\" value in all request messages.\n        In a response\
    \ message, the result field can have two values:\n        \"Success\" and \"Failure\"\
    .  The \"Success\" result indicates a\n        success response.  All messages\
    \ that belong to the same success\n        response will have the same Transaction\
    \ Identifier.  The\n        \"Success\" result indicates a success response that\
    \ may be\n        contained in a single message or the final message of a success\n\
    \        response spanning multiple messages.\n        ReturnReceipt is a value\
    \ of the result field used to indicate\n        that an acknowledgement is required\
    \ for the message.  The\n        default for messages is that the controller will\
    \ not acknowledge\n        responses.  In the case where an acknowledgement is\
    \ required, it\n        will set the Result Field to ReturnReceipt in the header\
    \ of the\n        Message.\n        The result field is encoded as an 8-bit unsigned\
    \ integer in\n        network bit order.  The following values are currently defined:\n\
    \           NoSuccessAck:       Result = 1\n           AckAll:             Result\
    \ = 2\n           Success:            Result = 3\n           Failure:        \
    \    Result = 4\n           ReturnReceipt       Result = 5\n   Code\n        This\
    \ field gives further information concerning the result in a\n        response\
    \ message.  It is mostly used to pass an error code in a\n        failure response\
    \ but can also be used to give further\n        information in a success response\
    \ message or an event message.\n        In a request message, the code field is\
    \ not used and is set to\n        zero.\n        If the Code field indicates that\
    \ the Error TLV is included in\n        the message, further information on the\
    \ error will be found in\n        the Error TLV, which MUST be the first TLV after\
    \ the header.\n        The Code field is encoded as an 8-bit unsigned integer\
    \ in\n        network bit order.  Separate number code spaces are used for\n \
    \       success and failure response messages.  In each case, a range of\n   \
    \     values is reserved for use in specifications and another range\n       \
    \ for private and experimental use.  For success messages, the\n        following\
    \ values are defined:\n                  Generic Success                  0x00\n\
    \                  Submessage Received              0x01\n                  Unassigned\
    \                   0x02 - 0x7F\n                  Private/Experimental Use  \
    \   0x80 - 0xFF\n        The Submessage Received code is used to acknowledge reception\
    \ of\n        a message segment.  The Generic Success code is used to\n      \
    \  acknowledge receipt of a complete message and successful\n        processing\
    \ of the contents.\n        For failure messages, the following values are defined:\n\
    \                  Reserved                     0x00 - 0x01\n                \
    \  Unspecified Failure              0x02\n                  Unassigned       \
    \            0x03 - 0x7F\n                  Private/Experimental Use     0x80\
    \ - 0xFE\n                  Error TLV in message             0xFF\n        The\
    \ Unspecified Failure code can be used to report a failure for\n        which\
    \ there is no more specific code or Error TLV value defined.\n   Sender Instance\n\
    \        For messages during the Hello phase with the Hello SYN, Hello\n     \
    \   SYNACK, and Hello ACK functions (which are explained in\n        Section 5.2),\
    \ it is the sender's instance number for the link.\n        It is used to detect\
    \ when the link comes back up after going\n        down or when the identity of\
    \ the entity at the other end of the\n        link changes.  The instance number\
    \ is a 16-bit number that is\n        guaranteed to be unique within the recent\
    \ past and to change\n        when the link or node comes back up after going\
    \ down.  Zero is\n        not a valid instance number.  For the RSTACK function\
    \ (also\n        explained in detail in Section 5.2), the Sender Instance field\n\
    \        is set to the value of the Receiver Instance field from the\n       \
    \ incoming message that caused the RSTACK function to be\n        generated. \
    \ Messages sent after the Hello phase is completed\n        should use the sender's\
    \ instance number for the link.  The\n        Sender Instance is encoded as a\
    \ 16-bit unsigned integer in\n        network bit order.\n   Receiver Instance\n\
    \        For messages during the Hello phase with the Hello SYN, Hello\n     \
    \   SYNACK, and Hello ACK functions, it is what the sender believes\n        is\
    \ the current instance number for the link, allocated by the\n        entity at\
    \ the far end of the link.  If the sender of the message\n        does not know\
    \ the current instance number at the far end of the\n        link, this field\
    \ MUST be set to zero.  For the RSTACK message,\n        the Receiver Instance\
    \ field is set to the value of the Sender\n        Instance field from the incoming\
    \ message that caused the RSTACK\n        message to be generated.  Messages sent\
    \ after the Hello phase is\n        completed should use what the sender believes\
    \ is the current\n        instance number for the link, allocated by the entity\
    \ at the far\n        end of the link.  The Sender Instance is encoded as a 16-bit\n\
    \        unsigned integer in network bit order.\n   Transaction Identifier\n \
    \       Used to associate a message with its response message.  This\n       \
    \ should be set in request messages to a value that is unique for\n        the\
    \ sending host within the recent past.  Reply messages contain\n        the Transaction\
    \ Identifier of the request to which they are\n        responding.  The Transaction\
    \ Identifier is a bit pattern of 32\n        bits.\n   S-flag\n        If S is\
    \ set (value 1), then the SubMessage Number field\n        indicates the total\
    \ number of SubMessage segments that compose\n        the entire message.  If\
    \ it is not set (value 0), then the\n        SubMessage Number field indicates\
    \ the sequence number of this\n        SubMessage segment within the whole message.\
    \  The S field will\n        only be set in the first submessage of a sequence.\n\
    \   SubMessage Number\n        When a message is segmented because it exceeds\
    \ the MTU of the\n        link layer or otherwise, each segment will include a\
    \ SubMessage\n        Number to indicate its position.  Alternatively, if it is\
    \ the\n        first submessage in a sequence of submessages, the S-flag will\n\
    \        be set, and this field will contain the total count of\n        SubMessage\
    \ segments.  The SubMessage Number is encoded as a\n        15-bit unsigned integer\
    \ in network bit order.  The SubMessage\n        number is zero-based, i.e., for\
    \ a message divided into n\n        submessages, they are numbered from 0 to (n\
    \ - 1).  For a message\n        that is not divided into submessages, the single\
    \ message has the\n        S-flag cleared (value 0), and the SubMessage Number\
    \ is set to 0\n        (zero).\n   Length\n        Length in octets of this message\
    \ including headers and message\n        body.  If the message is fragmented,\
    \ this field contains the\n        length of this SubMessage.  The Length is encoded\
    \ as an SDNV.\n   Message Body\n        As specified in Section 4, the Message\
    \ Body consists of a\n        sequence of one or more of the TLVs specified in\
    \ Section 4.2.\n   The protocol also requires extra information about the link\
    \ that the\n   underlying communication layer MUST provide.  This information\
    \ is\n   used in the Hello procedure described in more detail in Section 5.2.\n\
    \   Since this information is available from the underlying layer, there\n   is\
    \ no need to carry it in PRoPHET messages.  The following values are\n   defined\
    \ to be provided by the underlying layer:\n   Sender Local Address\n        An\
    \ address that is used by the underlying communication layer as\n        described\
    \ in Section 2.4 and identifies the sender address of\n        the current message.\
    \  This address must be unique among the\n        nodes that can currently communicate,\
    \ and it is only used in\n        conjunction with the Receiver Local Address,\
    \ Receiver Instance,\n        and Sender Instance to identify a communicating\
    \ pair of nodes.\n   Receiver Local Address\n        An address that is used by\
    \ the underlying communication layer as\n        described in Section 2.4 and\
    \ identifies the receiver address of\n        the current message.  This address\
    \ must be unique among the\n        nodes that can currently communicate, and\
    \ is only used in\n        conjunction with the Sender Local Address, Receiver\
    \ Instance,\n        and Sender Instance to identify a communicating pair of nodes.\n\
    \   When PRoPHET is run over TCP, the IP addresses of the communicating\n   nodes\
    \ are used as Sender and Receiver Local Addresses.\n"
- title: 4.2.  TLV Structure
  contents:
  - "4.2.  TLV Structure\n   All TLVs have the following format, and can be nested.\n\
    \       0                   1                   2                   3\n      \
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |    TLV Type   |   TLV Flags   |       TLV Length (SDNV)       |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                                                               |\n      ~   \
    \                        TLV Data                            ~\n      |      \
    \                                                         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                           Figure 6: TLV Format\n   TLV Type\n        Specific\
    \ TLVs are defined in Section 4.3.  The TLV Type is\n        encoded as an 8-bit\
    \ unsigned integer in network bit order.  Each\n        TLV will have fields defined\
    \ that are specific to the function\n        of that TLV.\n   TLV Flags\n    \
    \    These are defined per TLV type.  Flag n corresponds to bit 15-n\n       \
    \ in the TLV.  Any flags that are specified as reserved in\n        specific TLVs\
    \ SHOULD be transmitted as 0 and ignored on receipt.\n   TLV Length\n        Length\
    \ of the TLV in octets, including the TLV header and any\n        nested TLVs.\
    \  Encoded as an SDNV.  Note that TLVs are not padded\n        to any specific\
    \ alignment unless explicitly required in the\n        description of the TLV.\
    \  No TLVs in this document specify any\n        padding.\n"
- title: 4.3.  TLVs
  contents:
  - "4.3.  TLVs\n   This section describes the various TLVs that can be used in PRoPHET\n\
    \   messages.\n"
- title: 4.3.1.  Hello TLV
  contents:
  - "4.3.1.  Hello TLV\n   The Hello TLV is used to set up and maintain a link between\
    \ two\n   PRoPHET nodes.  Hello messages with the SYN function are transmitted\n\
    \   periodically as beacons or keep-alives.  The Hello TLV is the first\n   TLV\
    \ exchanged between two PRoPHET nodes when they encounter each\n   other.  No\
    \ other TLVs can be exchanged until the first Hello sequence\n   is completed.\n\
    \   Once a communication link is established between two PRoPHET nodes,\n   the\
    \ Hello TLV will be sent once for each interval as defined in the\n   interval\
    \ timer.  If a node experiences the lapse of HELLO_DEAD Hello\n   intervals without\
    \ receiving a Hello TLV on a connection in the\n   INFO_EXCH state (as defined\
    \ in the state machine in Section 5.1), the\n   connection SHOULD be assumed broken.\n\
    \       0                   1                   2                   3\n      \
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      | TLV Type=0x01 |L|  Resv | HF  |       TLV Length (SDNV)       |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \ Timer (SDNV)  |EID Length,SDNV|  Sender EID (variable length) |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                        Figure 7: Hello TLV Format\n   TLV Flags\n        The\
    \ TLV Flags field contains two 1-bit flags (S and L) and a\n        3-bit Hello\
    \ Function (HF) number that specifies one of four\n        functions for the Hello\
    \ TLV.  The remaining 3 bits (Resv) are\n        unused and reserved:\n      \
    \  HF\n             TLV Flags bits 0, 1, and 2 are treated as an unsigned 3-bit\n\
    \             integer coded in network bit order.  The value of the\n        \
    \     integer specifies the Hello Function (HF) of the Hello TLV.\n          \
    \   Four functions are specified for the Hello TLV.\n             The encoding\
    \ of the Hello Function is:\n                  SYN:     HF = 1\n             \
    \     SYNACK:  HF = 2\n                  ACK:     HF = 3\n                  RSTACK:\
    \  HF = 4\n   The remaining values (0, 5, 6 and 7) are unused and reserved.  If\
    \ a\n   Hello TLV with any of these values is received, the link should be\n \
    \  reset.\n        Resv\n             TLV Flags bits 3, 4, 5, and 6 are reserved.\
    \  They SHOULD be\n             set to 0 on transmission and ignored on reception.\n\
    \        L\n             The L bit flag (TLV Flags bit 7) is set (value 1) to\n\
    \             request that the Bundle Offer TLV sent during the\n            \
    \ Information Exchange Phase contains bundle payload lengths\n             for\
    \ all bundles, rather than only for bundle fragments as\n             when the\
    \ L flag is cleared (value 0), when carried in a\n             Hello TLV with\
    \ Hello Function SYN or SYNACK.  The flag is\n             ignored for other Hello\
    \ Function values.\n   TLV Data\n        Timer\n             The Timer field is\
    \ used to inform the receiver of the timer\n             value used in the Hello\
    \ processing of the sender.  The\n             timer specifies the nominal time\
    \ between periodic Hello\n             messages.  It is a constant for the duration\
    \ of a session.\n             The timer field is specified in units of 100 ms\
    \ and is\n             encoded as an SDNV.\n        EID Length\n             The\
    \ EID Length field is used to specify the length of the\n             Sender EID\
    \ field in octets.  If the Endpoint Identifier\n             (EID) has already\
    \ been sent at least once in a message with\n             the current Sender Instance,\
    \ a node MAY choose to set this\n             field to zero, omitting the Sender\
    \ EID from the Hello TLV.\n             The EID Length is encoded as an SDNV,\
    \ and the field is thus\n             of variable length.\n        Sender EID\n\
    \             The Sender EID field specifies the DTN endpoint identifier\n   \
    \          (EID) of the sender that is to be used in updating routing\n      \
    \       information and making forwarding decisions.  If a node has\n        \
    \     multiple EIDs, one should be chosen for PRoPHET routing.\n             This\
    \ field is of variable length.\n"
- title: 4.3.2.  Error TLV
  contents:
  - "4.3.2.  Error TLV\n       0                   1                   2         \
    \          3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      | TLV type=0x02 |   TLV Flags |         TLV Length (SDNV)       |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                                                               |\n      ~   \
    \                       TLV Data                            ~\n      |       \
    \                                                        |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                        Figure 8: Error TLV Format\n   TLV Flags\n        For\
    \ Error TLVs, the TLV Flags field carries an identifier for\n        the Error\
    \ TLV type as an 8-bit unsigned integer encoded in\n        network bit order.\
    \  A range of values is available for private\n        and experimental use in\
    \ addition to the values defined here.\n        The following Error TLV types\
    \ are defined:\n                  Dictionary Conflict               0x00\n   \
    \               Bad String ID                     0x01\n                  Reserved\
    \                       0x02 - 0x7F\n                  Private/Experimental Use\
    \       0x80 - 0xFF\n   TLV Data\n        The contents and interpretation of the\
    \ TLV Data field are\n        specific to the type of Error TLV.  For the Error\
    \ TLVs defined\n        in this document, the TLV Data is defined as follows:\n\
    \        Dictionary Conflict\n             The TLV Data consists of the String\
    \ ID that is causing the\n             conflict encoded as an SDNV followed by\
    \ the EID string that\n             conflicts with the previously installed value.\
    \  The\n             Endpoint Identifier is NOT null terminated.  The length of\n\
    \             the EID can be determined by subtracting the length of the\n   \
    \          TLV Header and the length of the SDNV containing the String\n     \
    \        ID from the TLV Length.\n        Bad String ID\n             The TLV\
    \ Data consists of the String ID that is not found in\n             the dictionary\
    \ encoded as an SDNV.\n"
- title: 4.3.3.  Routing Information Base Dictionary TLV
  contents:
  - "4.3.3.  Routing Information Base Dictionary TLV\n   The Routing Information Base\
    \ Dictionary includes the list of endpoint\n   identifiers used in making routing\
    \ decisions.  The referents remain\n   constant for the duration of a session\
    \ over a link where the instance\n   numbers remain the same and can be used by\
    \ both the Routing\n   Information Base messages and the bundle offer/response\
    \ messages.\n   The dictionary is a shared resource (see Section 3.2.1) built\
    \ in each\n   of the paired peers from the contents of one or more incoming TLVs\
    \ of\n   this type and from the information used to create outgoing TLVs of\n\
    \   this type.\n       0                   1                   2             \
    \      3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0\
    \ 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      | TLV type=0xA0 |   TLV Flags   |       TLV Length (SDNV)       |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                     RIBD Entry Count (SDNV)                   |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      ~                                                               ~\n   \
    \   ~           Variable-Length Routing Address Strings             ~\n      ~\
    \                                                               ~\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      ~ Routing Address String 1                                      ~\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \        String ID 1 (SDNV)     |         Length (SDNV)         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      ~            Endpoint Identifier 1 (variable length)            ~\n   \
    \   |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                               .                               |\n   \
    \   ~ Routing Address String n      .                               ~\n      |\
    \                               .                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |        String ID n (SDNV)     |         Length (SDNV)         |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                                                               |\n      ~   \
    \         Endpoint Identifier n (variable length)            ~\n      |      \
    \                                                         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \         Figure 9: Routing Information Base Dictionary TLV Format\n   TLV Flags\n\
    \        The encoding of the Header flag field relates to the\n        capabilities\
    \ of the source node sending the RIB Dictionary:\n             Flag 0: Sent by\
    \ Listener    0b1\n             Flag 1: Reserved            0b1\n            \
    \ Flag 2: Reserved            0b1\n             Flag 3: Unassigned          0b1\n\
    \             Flag 4: Unassigned          0b1\n             Flag 5: Unassigned\
    \          0b1\n             Flag 6: Unassigned          0b1\n             Flag\
    \ 7: Unassigned          0b1\n        The \"Sent by Listener\" flag is set to\
    \ 0 if this TLV was sent by\n        a node in the Initiator role and set to 1\
    \ if this TLV was sent\n        by a node in the Listener role (see Section 3.2\
    \ for explanations\n        of these roles).\n   TLV Data\n        RIBD Entry\
    \ Count\n             Number of entries in the database.  Encoded as SDNV.\n \
    \       String ID\n             SDNV identifier that is constant for the duration\
    \ of a\n             session.  String ID zero is predefined as the node that\n\
    \             initiates the session through sending the Hello SYN\n          \
    \   message, and String ID one is predefined as the node that\n             responds\
    \ with the Hello SYNACK message.  These entries do\n             not need to be\
    \ sent explicitly as the EIDs are exchanged\n             during the Hello procedure.\n\
    \             In order to ensure that the String IDs originated by the\n     \
    \        two peers do not conflict, the String IDs generated in the\n        \
    \     node that sent the Hello SYN message MUST have their least\n           \
    \  significant bit set to 0 (i.e., are even numbers), and the\n             String\
    \ IDs generated in the node that responded with the\n             Hello SYNACK\
    \ message MUST have their least significant bit\n             set to 1 (i.e.,\
    \ they are odd numbers).\n        Length\n             Length of Endpoint Identifier\
    \ in this entry.  Encoded as\n             SDNV.\n        Endpoint Identifier\n\
    \             Text string representing the Endpoint Identifier.  Note\n      \
    \       that it is NOT null terminated as the entry contains the\n           \
    \  length of the identifier.\n"
- title: 4.3.4.  Routing Information Base TLV
  contents:
  - "4.3.4.  Routing Information Base TLV\n   The Routing Information Base lists the\
    \ destinations (endpoints) a\n   node knows of and the delivery predictabilities\
    \ it has associated\n   with them.  This information is needed by the PRoPHET\
    \ algorithm to\n   make decisions on routing and forwarding.\n       0       \
    \            1                   2                   3\n       0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      | TLV Type=0xA1 |   TLV Flags   |       TLV Length (SDNV)       |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                     RIB String Count (SDNV)                   |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |     RIBD String ID 1 (SDNV)   |            P-value            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \  RIB Flags 1  |               .                               ~\n      +-+-+-+-+-+-+-+-+\
    \               .                               ~\n      ~                   \
    \            .                               ~\n      ~                      \
    \         .                               ~\n      ~                         \
    \      .                               ~\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |     RIBD String ID n (SDNV)   |            P-value            |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \  RIB Flags n  |\n      +-+-+-+-+-+-+-+-+\n              Figure 10: Routing Information\
    \ Base TLV Format\n   TLV Flags\n        The encoding of the Header flag field\
    \ relates to the\n        capabilities of the Source node sending the RIB:\n \
    \            Flag 0: More RIB TLVs       0b1\n             Flag 1: Reserved  \
    \          0b1\n             Flag 2: Reserved            0b1\n             Flag\
    \ 3: Unassigned          0b1\n             Flag 4: Unassigned          0b1\n \
    \            Flag 5: Unassigned          0b1\n             Flag 6: Unassigned\
    \          0b1\n             Flag 7: Unassigned          0b1\n        The \"More\
    \ RIB TLVs\" flag is set to 1 if the RIB requires more\n        TLVs to be sent\
    \ in order to be fully transferred.  This flag is\n        set to 0 if this is\
    \ the final TLV of this RIB.\n   TLV Data\n        RIB String Count\n        \
    \     Number of routing entries in the TLV.  Encoded as an SDNV.\n        RIBD\
    \ String ID\n             String ID of the endpoint identifier of the destination\
    \ for\n             which this entry specifies the delivery predictability as\n\
    \             predefined in a dictionary TLV.  Encoded as an SDNV.\n        P-value\n\
    \             Delivery predictability for the destination of this entry\n    \
    \         as calculated from previous encounters according to the\n          \
    \   equations in Section 2.1.2, encoded as a 16-bit unsigned\n             integer.\
    \  The encoding of this field is a linear mapping\n             from [0,1] to\
    \ [0, 0xFFFF] (e.g., for a P-value of 0.75, the\n             mapping would be\
    \ 0.75*65535=49151=0xBFFF; thus, the P-value\n             would be encoded as\
    \ 0xBFFF).\n        RIB Flag\n             The encoding of the 8-bit RIB Flag\
    \ field is:\n             Flag 0: Unassigned          0b1\n             Flag 1:\
    \ Unassigned          0b1\n             Flag 2: Unassigned          0b1\n    \
    \         Flag 3: Unassigned          0b1\n             Flag 4: Unassigned   \
    \       0b1\n             Flag 5: Unassigned          0b1\n             Flag 6:\
    \ Unassigned          0b1\n             Flag 7: Unassigned          0b1\n"
- title: 4.3.5.  Bundle Offer and Response TLVs (Version 2)
  contents:
  - "4.3.5.  Bundle Offer and Response TLVs (Version 2)\n   After the routing information\
    \ has been passed, the node will ask the\n   other node to review available bundles\
    \ and determine which bundles it\n   will accept for relay.  The source relay\
    \ will determine which bundles\n   to offer based on relative delivery predictabilities\
    \ as explained in\n   Section 3.6.\n        Note: The original versions of these\
    \ TLVs (TLV Types 0xA2 and\n        0xA3) used in version 1 of the PRoPHET protocol\
    \ have been\n        deprecated, as they did not contain the complete information\n\
    \        needed to uniquely identify bundles and could not handle bundle\n   \
    \     fragments.\n   Depending on the bundles stored in the offering node, the\
    \ Bundle\n   Offer TLV might contain descriptions of both complete bundles and\n\
    \   bundle fragments.  In order to correctly identify bundle fragments, a\n  \
    \ bundle fragment descriptor MUST contain the offset of the payload\n   fragment\
    \ in the bundle payload and the length of the payload\n   fragment.  If requested\
    \ by the receiving node by setting the L flag\n   in the SYN or SYNACK message\
    \ during the neighbor awareness phase, the\n   offering node MUST include the\
    \ length of the payload in the\n   descriptor for complete bundles.  The appropriate\
    \ flags MUST be set\n   in the B_flags for the descriptor to indicate if the descriptor\n\
    \   contains the payload length field (set for fragments in all cases and\n  \
    \ for complete bundles if the L flag was set) and if the descriptor\n   contains\
    \ a payload offset field (fragments only).\n   The Bundle Offer TLV also lists\
    \ the bundles for which a PRoPHET\n   acknowledgement has been issued.  Those\
    \ bundles have the PRoPHET ACK\n   flag set in their entry in the list.  When\
    \ a node receives a PRoPHET\n   ACK for a bundle, it SHOULD, if possible, signal\
    \ to the bundle\n   protocol agent that this bundle is no longer required for\n\
    \   transmission by PRoPHET.  Despite no longer transmitting the bundle,\n   it\
    \ SHOULD keep an entry for the acknowledged bundle to be able to\n   further propagate\
    \ the PRoPHET ACK.\n   The Response TLV format is identical to the Offer TLV with\
    \ the\n   exception of the TLV Type field.  Bundles that are being accepted\n\
    \   from the corresponding Offer are explicitly marked with a B_flag.\n   Specifications\
    \ for bundles that are not being accepted MAY either be\n   omitted or left in\
    \ but not marked as accepted.  The payload length\n   field MAY be omitted for\
    \ complete bundles in the Response message\n   even if it was included in the\
    \ Offer message.  The B_flags payload\n   length flag MUST be set correctly to\
    \ indicate if the length field is\n   included or not.  The Response message MUST\
    \ include both payload\n   offset and payload length fields for bundle fragments,\
    \ and the\n   B_flags MUST be set to indicate that both are present.\n       0\
    \                   1                   2                   3\n       0 1 2 3\
    \ 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |    TLV Type   |   TLV Flags   |       TLV Length (SDNV)       |\n   \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |\
    \                    Bundle Offer Count (SDNV)                  |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |    B_flags    |       Bundle Source     |  Bundle Destination |\n   \
    \   |               |     String ID 1 (SDNV)  |  String ID 1 (SDNV) |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                 Bundle 1 Creation Timestamp Time              |\n   \
    \   |                             (SDNV)                            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |           Bundle 1 Creation Timestamp Sequence Number         |\n   \
    \   |                             (SDNV)                            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      | Bundle 1 Payload Offset - only present if bundle is a fragment|\n   \
    \   |                             (SDNV)                            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      | Bundle 1 Payload Length - only present if bundle is a fragment|\n   \
    \   |         or transmission of length requested (SDNV)            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      ~                               .                               ~\n   \
    \   ~                               .                               ~\n      ~\
    \                               .                               ~\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |    B_flags    |       Bundle Source     |  Bundle Destination |\n   \
    \   |               |     String ID n (SDNV)  |  String ID n (SDNV) |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |                 Bundle n Creation Timestamp Time              |\n   \
    \   |                             (SDNV)                            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |           Bundle n Creation Timestamp Sequence Number         |\n   \
    \   |                             (SDNV)                            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      | Bundle n Payload Offset - only present if bundle is a fragment|\n   \
    \   |                             (SDNV)                            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      | Bundle n Payload Length - only present if bundle is a fragment|\n   \
    \   |         or transmission of length requested (SDNV)            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \              Figure 11: Bundle Offer and Response TLV Format\n   TLV Type\n\
    \        The TLV Type for a Bundle Offer is 0xA4.  The TLV Type for a\n      \
    \  Bundle Response is 0xA5.\n   TLV Flags\n        The encoding of the Header\
    \ flag field relates to the\n        capabilities of the source node sending the\
    \ RIB:\n             Flag 0: More Offer/Response\n                     TLVs Following\
    \      0b1\n             Flag 1: Unassigned          0b1\n             Flag 2:\
    \ Unassigned          0b1\n             Flag 3: Unassigned          0b1\n    \
    \         Flag 4: Unassigned          0b1\n             Flag 5: Unassigned   \
    \       0b1\n             Flag 6: Unassigned          0b1\n             Flag 7:\
    \ Unassigned          0b1\n        If the Bundle Offers or Bundle Responses are\
    \ divided between\n        several TLVs, the \"More Offer/Response TLVs Following\"\
    \ flag MUST\n        be set to 1 in all but the last TLV in the sequence where\
    \ it\n        MUST be set to 0.\n   TLV Data\n        Bundle Offer Count\n   \
    \          Number of bundle offer/response entries.  Encoded as an\n         \
    \    SDNV.  Note that 0 is an acceptable value.  In particular,\n            \
    \ a Bundle Response TLV with 0 entries is used to signal that\n             a\
    \ cycle of information exchange and bundle passing is\n             completed.\n\
    \        B Flags\n             The encoding of the B Flags is:\n             Flag\
    \ 0: Bundle Accepted       0b1\n             Flag 1: Bundle is a Fragment  0b1\n\
    \             Flag 2: Bundle Payload Length\n                     included in\
    \ TLV       0b1\n             Flag 3: Unassigned            0b1\n            \
    \ Flag 4: Unassigned            0b1\n             Flag 5: Unassigned         \
    \   0b1\n             Flag 6: Unassigned            0b1\n             Flag 7:\
    \ PRoPHET ACK           0b1\n        Bundle Source String ID\n             String\
    \ ID of the source EID of the bundle as predefined in\n             a dictionary\
    \ TLV.  Encoded as an SDNV.\n        Bundle Destination String ID\n          \
    \   String ID of the destination EID of the bundle as\n             predefined\
    \ in a dictionary TLV.  Encoded as an SDNV.\n        Bundle Creation Timestamp\
    \ Time\n             Time component of the Bundle Creation Timestamp for the\n\
    \             bundle.  Encoded as an SDNV.\n        Bundle Creation Timestamp\
    \ Sequence Number\n             Sequence Number component of the Bundle Creation\
    \ Timestamp\n             for the bundle.  Encoded as an SDNV.\n        Bundle\
    \ Payload Offset\n             Only included if the bundle is a fragment and the\
    \ fragment\n             bit is set (value 1) in the bundle B Flags.  Offset of\
    \ the\n             start of the fragment payload in the complete bundle\n   \
    \          payload.  Encoded as an SDNV.\n        Bundle Payload Length\n    \
    \         Only included if the bundle length included bit is set\n           \
    \  (value 1) in the bundle B Flags.  Length of the payload in\n             the\
    \ bundle specified.  This is either the total payload\n             length if\
    \ the bundle is a complete bundle or the bundle\n             fragment payload\
    \ length if the bundle is a fragment.\n             Encoded as an SDNV.\n"
- title: 5.  Detailed Operation
  contents:
  - "5.  Detailed Operation\n   In this section, some more details on the operation\
    \ of PRoPHET are\n   given along with state tables to help in implementing the\
    \ protocol.\n   As explained in Section 1.2, it is RECOMMENDED that \"Success\"\
    \n   responses should not be requested or sent when operating over a\n   reliable,\
    \ in-order transport protocol such as TCP.  If in the future\n   PRoPHET were\
    \ operated over an unreliable transport protocol, positive\n   acknowledgements\
    \ would be necessary to signal successful delivery of\n   (sub)messages.  In this\
    \ section, the phrase \"send a message\" should\n   be read as *successful* sending\
    \ of a message, signaled by receipt of\n   the appropriate \"Success\" response\
    \ if running over an unreliable\n   protocol, but guaranteed by TCP or another\
    \ reliable protocol\n   otherwise.  Hence, the state descriptions below do not\
    \ explicitly\n   mention positive acknowledgements, whether they are being sent\
    \ or\n   not.\n"
- title: 5.1.  High-Level State Tables
  contents:
  - "5.1.  High-Level State Tables\n   This section gives high-level state tables\
    \ for the operation of\n   PRoPHET.  The following sections will describe each\
    \ part of the\n   operation in more detail (including state tables for the internal\n\
    \   states of those procedures).\n   The following main or high-level states are\
    \ used in the state tables:\n   WAIT_NB  This is the state all nodes start in.\
    \  Nodes remain in this\n         state until they are notified that a new neighbor\
    \ is available.\n         At that point, the Hello procedure should be started\
    \ with the\n         new neighbor, and the node transitions into the HELLO state.\n\
    \         Nodes SHOULD be able to handle multiple neighbors in parallel,\n   \
    \      maintaining separate state machines for each neighbor.  This\n        \
    \ could be handled by creating a new thread or process during the\n         transition\
    \ to the HELLO state that then takes care of the\n         communication with\
    \ the new neighbor while the parent remains in\n         state WAIT_NB waiting\
    \ for additional neighbors to communicate.\n         In this case, when the neighbor\
    \ can no longer be communicated\n         with (described as \"Neighbor Gone\"\
    \ in the tables below), the\n         thread or process created is destroyed and,\
    \ when a connection-\n         oriented protocol is being used to communicate\
    \ with the\n         neighbor, the connection is closed.  The current version\
    \ of the\n         protocol is specified to use TCP for neighbor connections so\n\
    \         that these will be closed when the neighbor is no longer\n         accessible.\n\
    \   HELLO Nodes are in the HELLO state from when a new neighbor is\n         detected\
    \ until the Hello procedure is completed and a link is\n         established (which\
    \ happens when the Hello procedure enters the\n         ESTAB state as described\
    \ in Section 5.2; during this procedure,\n         the states ESTAB, SYNSENT,\
    \ and SYNRCVD will be used, but these\n         are internal to the Hello procedure\
    \ and are not listed here).\n         If the node is notified that the neighbor\
    \ is no longer in range\n         before a link has been established, it returns\
    \ to the WAIT_NB\n         state, and, if appropriate, any additional process\
    \ or thread\n         created to handle the neighbor MAY be destroyed.\n   INFO_EXCH\
    \  After a link has been set up by the Hello procedure, the\n         node transitions\
    \ to the INFO_EXCH state in which the\n         Information Exchange Phase is\
    \ done.  The node remains in this\n         state as long as Information Exchange\
    \ Phase TLVs (Routing RIB,\n         Routing RIB Dictionary, Bundle Offer, Bundle\
    \ Response) are\n         being received.  If the node is notified that the neighbor\
    \ is\n         no longer in range before all information and bundles have been\n\
    \         exchanged, any associated connection is closed and the node\n      \
    \   returns to the WAIT_NB state to await new neighbors.  The\n         Timer(keep_alive)\
    \ is used to ensure that the connection remains\n         active.\n         In\
    \ the INFO_EXCH state, the nodes at both ends of the\n         established link\
    \ are able to update their delivery\n         predictability information using\
    \ data from the connected peer\n         and then make offers of bundles for exchange\
    \ which may be\n         accepted or not by the peer.  To manage these processes,\
    \ each\n         node acts both as an Initiator and a Listener for the\n     \
    \    Information Exchange Phase processes, maintaining subsidiary\n         state\
    \ machines for the two roles.  The Initiator and Listener\n         terms refer\
    \ to the sending of the Routing RIB information: it\n         is perhaps counterintuitive\
    \ that the Listener becomes the\n         bundle offeror and the Initiator the\
    \ bundle acceptor during the\n         bundling passing part.\n         The protocol\
    \ is designed so that the two exchanges MAY be\n         carried out independently\
    \ but concurrently, with the messages\n         multiplexed onto on a single bidirectional\
    \ link (such as is\n         provided by the TCP connection).  Alternatively,\
    \ the exchanges\n         MAY be carried out partially or wholly sequentially\
    \ if\n         appropriate for the implementation.  The Information Exchange\n\
    \         Phase is explained in more detail in Section 3.2.\n         When an\
    \ empty Bundle Response TLV (i.e., no more bundles to\n         send) is received,\
    \ the node starts the Timer(next_exchange).\n         When this timer expires,\
    \ assuming that the neighbor is still\n         connected, the Initiator reruns\
    \ the Information Exchange Phase.\n         If there is only one neighbor connected\
    \ at this time, this will\n         have the effect of further increasing the\
    \ delivery\n         predictability for this node in the neighbor, and changing\
    \ the\n         delivery predictabilities as a result of the transitive\n    \
    \     property (Equation 3).  If there is more than one neighbor\n         connected\
    \ or other communication opportunities have happened\n         since the previous\
    \ information exchange occurred, then the\n         changes resulting from these\
    \ other encounters will be passed on\n         to the connected neighbor.  The\
    \ next_exchange timer is\n         restarted once the information exchange has\
    \ completed again.\n         If one or more new bundles are received by this node\
    \ while\n         waiting for the Timer(next_exchange) to expire and the delivery\n\
    \         predictabilities indicate that it would be appropriate to\n        \
    \ forward some or all of the bundles to the connected node, the\n         bundles\
    \ SHOULD be immediately offered to the connected neighbor\n         and transferred\
    \ if accepted.\n    State: WAIT_NB\n    +==================================================================+\n\
    \    |     Condition    |               Action              | New State |\n  \
    \  +==================+===================================+===========+\n    |\
    \   New Neighbor   | Start Hello procedure for neighbor|   HELLO   |\n    |  \
    \                |  Keep waiting for more neighbors  |  WAIT_NB  |\n    +==================================================================+\n\
    \    State: HELLO\n    +==================================================================+\n\
    \    |    Condition     |               Action              | New State |\n  \
    \  +==================+===================================+===========+\n    |\
    \  Hello TLV rcvd  |                                   |   HELLO   |\n    +------------------+-----------------------------------+-----------+\n\
    \    | Enter ESTAB state|  Start Information Exchange Phase | INFO_EXCH |\n  \
    \  +------------------+-----------------------------------+-----------+\n    |\
    \  Neighbor Gone   |                                   |  WAIT_NB  |\n    +==================================================================+\n\
    \    State: INFO_EXCH\n    +==================================================================+\n\
    \    |    Condition     |               Action              | New State |\n  \
    \  +==================+===================================+===========+\n    |\
    \     On entry     |     Start Timer(keep-alive)       |           |\n    |  \
    \                |        Uses Hello Timer interval  | INFO_EXCH |\n    +------------------+-----------------------------------+-----------+\n\
    \    |Info Exch TLV rcvd| (processed by subsidiary state    |           |\n  \
    \  |                  |                         machines) | INFO_EXCH |\n    +------------------+-----------------------------------+-----------+\n\
    \    | No more bundles  |     Start Timer(next_exchange)    | INFO_EXCH |\n  \
    \  +------------------+-----------------------------------+-----------+\n    |\
    \ Keep-alive expiry|     Send Hello SYN message        | INFO_EXCH |\n    +------------------+-----------------------------------+-----------+\n\
    \    |  Hello SYN rcvd  |     Record reception              |           |\n  \
    \  |                  |     Restart Timer(keep-alive)     | INFO_EXCH |\n    +------------------+-----------------------------------+-----------+\n\
    \    |  Neighbor Gone   |                                   |  WAIT_NB  |\n  \
    \  +==================================================================+\n   The\
    \ keep-alive messages (messages with Hello SYN TLV) are processed\n   by the high-level\
    \ state machine in the INFO_EXCH state.  All other\n   messages are delegated\
    \ to the subsidiary state machines of the\n   Information Exchange Phase described\
    \ in Section 5.3.  The receipt of\n   keep-alive messages is recorded and may\
    \ be used by the subsidiary\n   machines to check if the peer is still functioning.\
    \  The connection\n   will be aborted (as described in Section 4.3.1) if several\
    \ keep-alive\n   messages are not received.\n"
- title: 5.2.  Hello Procedure
  contents:
  - "5.2.  Hello Procedure\n   The Hello procedure is described by the following rules\
    \ and state\n   tables.  In this section, the messages sent consist of the PRoPHET\n\
    \   header and a single Hello TLV (see Figure 4 and Section 4.3.1) with\n   the\
    \ HF (Hello Function) field set to the specified value (SYN,\n   SYNACK, ACK or\
    \ RSTACK).\n   The state of the L flag in the latest SYN or SYNACK message is\n\
    \   recorded in the node that receives the message.  If the L flag is set\n  \
    \ (value 1), the receiving node MUST send the payload length for each\n   bundle\
    \ that it offers to the peer during the Information Exchange\n   Phase.\n   The\
    \ rules and state tables use the following operations:\n   o  The \"Update Peer\
    \ Verifier\" operation is defined as storing the\n      values of the Sender Instance\
    \ and Sender Local Address fields from\n      a Hello SYN or Hello SYNACK function\
    \ message received from the\n      entity at the far end of the link.\n   o  The\
    \ procedure \"Reset the link\" is defined as:\n      When using TCP or other reliable\
    \ connection-oriented transport:\n           Close the connection and terminate\
    \ any separate thread or\n           process managing the connection.\n      Otherwise:\n\
    \           1.   Generate a new instance number for the link.\n           2. \
    \  Delete the peer verifier (set to zero the values of\n                Sender\
    \ Instance and Sender Local Address previously\n                stored by the\
    \ Update Peer Verifier operation).\n           3.   Send a SYN message.\n    \
    \       4.   Transition to the SYNSENT state.\n   o  The state tables use the\
    \ following Boolean terms and operators:\n      A    The Sender Instance in the\
    \ incoming message matches the value\n           stored from a previous message\
    \ by the \"Update Peer Verifier\"\n           operation.\n      B    The Sender\
    \ Instance and Sender Local Address fields in the\n           incoming message\
    \ match the values stored from a previous\n           message by the \"Update\
    \ Peer Verifier\" operation.\n      C    The Receiver Instance and Receiver Local\
    \ Address fields in\n           the incoming message match the values of the Sender\
    \ Instance\n           and Sender Local Address used in outgoing Hello SYN, Hello\n\
    \           SYNACK, and Hello ACK messages.\n      SYN    A Hello SYN message\
    \ has been received.\n      SYNACK A Hello SYNACK message has been received.\n\
    \      ACK    A Hello ACK message has been received.\n      &&     Represents\
    \ the logical AND operation\n      ||     Represents the logical OR operation\n\
    \      !      Represents the logical negation (NOT) operation.\n   o  A timer\
    \ is required for the periodic generation of Hello SYN,\n      Hello SYNACK, and\
    \ Hello ACK messages.  The value of the timer is\n      announced in the Timer\
    \ field.  To avoid synchronization effects,\n      uniformly distributed random\
    \ jitter of +/-5% of the Timer field\n      SHOULD be added to the actual interval\
    \ used for the timer.\n      There are two independent events: the timer expires,\
    \ and a packet\n      arrives.  The processing rules for these events are:\n \
    \            Timer Expires:  Reset Timer\n                             If state\
    \ = SYNSENT Send SYN message\n                             If state = SYNRCVD\
    \ Send SYNACK message\n                             If state = ESTAB   Send ACK\
    \ message\n             Packet Arrives:\n                 If incoming message\
    \ is an RSTACK message:\n                     If (A && C && !SYNSENT) Reset the\
    \ link\n                     Else discard the message.\n                 If incoming\
    \ message is a SYN, SYNACK, or ACK message:\n                     Response defined\
    \ by the following State Tables.\n                 If incoming message is any\
    \ other PRoPHET TLV and\n                     state != ESTAB:\n              \
    \       Discard incoming message.\n                     If state = SYNSENT Send\
    \ SYN message(Note 1)\n                     If state = SYNRCVD Send SYNACK message(Note\
    \ 1)\n            Note 1: No more than two SYN or SYNACK messages should be\n\
    \            sent within any time period of length defined by the timer.\n   o\
    \  A connection across a link is considered to be achieved when the\n      protocol\
    \ reaches the ESTAB state.  All TLVs, other than Hello\n      TLVs, that are received\
    \ before synchronization is achieved will be\n      discarded.\n"
- title: 5.2.1.  Hello Procedure State Tables
  contents:
  - "5.2.1.  Hello Procedure State Tables\n    State: SYNSENT\n    +==================================================================+\n\
    \    |     Condition    |               Action              | New State |\n  \
    \  +==================+===================================+===========+\n    |\
    \   SYNACK && C    |       Update Peer Verifier;       |   ESTAB   |\n    |  \
    \                |       Send ACK message            |           |\n    +------------------+-----------------------------------+-----------+\n\
    \    |   SYNACK && !C   |       Send RSTACK message         |  SYNSENT  |\n  \
    \  +------------------+-----------------------------------+-----------+\n    |\
    \       SYN        |       Update Peer Verifier;       |  SYNRCVD  |\n    |  \
    \                |       Send SYNACK message         |           |\n    +------------------+-----------------------------------+-----------+\n\
    \    |       ACK        |       Send RSTACK message         |  SYNSENT  |\n  \
    \  +==================================================================+\n    State:\
    \ SYNRCVD\n    +==================================================================+\n\
    \    |    Condition     |               Action              | New State |\n  \
    \  +==================+===================================+===========+\n    |\
    \   SYNACK && C    |       Update Peer Verifier;       |   ESTAB   |\n    |  \
    \                |       Send ACK message            |           |\n    +------------------+-----------------------------------+-----------+\n\
    \    |   SYNACK && !C   |       Send RSTACK message         |  SYNRCVD  |\n  \
    \  +------------------+-----------------------------------+-----------+\n    |\
    \       SYN        |       Update Peer Verifier;       |  SYNRCVD  |\n    |  \
    \                |       Send SYNACK message         |           |\n    +------------------+-----------------------------------+-----------+\n\
    \    |  ACK && B && C   |       Send ACK message            |   ESTAB   |\n  \
    \  +------------------+-----------------------------------+-----------+\n    |\
    \ ACK && !(B && C) |       Send RSTACK message         |  SYNRCVD  |\n    +==================================================================+\n\
    \    State: ESTAB\n    +==================================================================+\n\
    \    |    Condition    |               Action               | New State |\n  \
    \  +=================+====================================+===========+\n    |\
    \  SYN || SYNACK  | Send ACK message (notes 2 and 3)  |   ESTAB   |\n    +-----------------+------------------------------------+-----------+\n\
    \    |  ACK && B && C  | Send ACK message (note 3)          |   ESTAB   |\n  \
    \  +-----------------+------------------------------------+-----------+\n    |\
    \ ACK && !(B && C)|          Send RSTACK message       |   ESTAB   |\n    +==================================================================+\n\
    \      Note 2: No more than two ACK messages should be sent within any\n     \
    \ time period of length defined by the timer.  Thus, one ACK message\n      MUST\
    \ be sent every time the timer expires.  In addition, one\n      further ACK message\
    \ may be sent between timer expirations if the\n      incoming message is a SYN\
    \ or SYNACK.  This additional ACK allows\n      the Hello functions to reach synchronization\
    \ more quickly.\n      Note 3: No more than one ACK message should be sent within\
    \ any\n      time period of length defined by the timer.\n"
- title: 5.3.  Information Exchange Phase
  contents:
  - "5.3.  Information Exchange Phase\n   After the Hello messages have been exchanged,\
    \ and the nodes are in\n   the ESTAB state, the Information Exchange Phase, consisting\
    \ of the\n   RIB Exchange and Bundle Passing Sub-Phases, is initiated.  This\n\
    \   section describes the procedure and shows the state transitions\n   necessary\
    \ in these sub-phases; the following sections describe in\n   detail the various\
    \ TLVs passed in these phases.  On reaching the\n   ESTAB state in the high-level\
    \ HELLO state, there is an automatic\n   transition to the INFO_EXCH high-level\
    \ state.\n   PRoPHET runs over a bidirectional transport as documented in\n  \
    \ Section 1.2 so that when a pair of nodes (A and B) have reached the\n   ESTAB\
    \ state, they are able to perform the Information Exchange Phase\n   processes\
    \ for both the A-to-B and B-to-A directions over the link\n   that has just been\
    \ established.  In principle, these two processes\n   are independent of each\
    \ other and can be performed concurrently.\n   However, complete concurrency may\
    \ not be the most efficient way to\n   implement the complete process.  As explained\
    \ in Section 3.2.1, the\n   Routing Information Base Dictionary is a shared resource\
    \ assembled\n   from a combination of information generated locally on each node\
    \ and\n   information passed from the peer node.  Overlaps in this information,\n\
    \   and hence the amount of information that has to be passed between the\n  \
    \ nodes, can be minimized by sequential rather than concurrent\n   operation of\
    \ the dictionary generation and update processes.  It may\n   also be possible\
    \ to reduce the number of bundles that need to be\n   offered by the second offeror\
    \ by examining the offers received from\n   the first offeror -- there is no need\
    \ for the second offeror to offer\n   a bundle that is already present in the\
    \ first offeror's offer list,\n   as it will inevitably be refused.\n   All implementations\
    \ MUST be capable of operating in a fully\n   concurrent manner.  Each implementation\
    \ needs to define a policy,\n   which SHOULD be configurable, as to whether it\
    \ will operate in a\n   concurrent or sequential manner during the Information\
    \ Exchange\n   Phase.  If it is to operate sequentially, then further choices\
    \ can be\n   made as to whether to interleave dictionary, offer, and response\n\
    \   exchange parts, or to complete all parts in one direction before\n   initiating\
    \ the other direction.\n   Sequential operation will generally minimize the amount\
    \ of data\n   transferred across the PRoPHET link and is especially appropriate\
    \ if\n   the link is half-duplex.  However it is probably not desirable to\n \
    \  postpone starting the information exchange in the second direction\n   until\
    \ the exchange of bundles has completed.  If the contact between\n   the nodes\
    \ ends before all possible bundles have been exchanged, it is\n   possible that\
    \ postponing the start of bundle exchange in the second\n   direction can lead\
    \ to bundle exchange being skewed in favor of one\n   direction over the other.\
    \  It may be preferable to share the\n   available contact time and bandwidth\
    \ between directions by\n   overlapping the Information Exchange Phases and running\
    \ the actual\n   bundle exchanges concurrently if possible.  Also, if encounters\n\
    \   expected in the current PRoPHET zone are expected to be relatively\n   short,\
    \ it MAY not be appropriate to use sequential operation.\n   One possible interleaving\
    \ strategy is to alternate between sending\n   from the two nodes.  For example,\
    \ if the Hello SYN node sends its\n   initial dictionary entries while the Hello\
    \ SYNACK node waits until\n   this is complete, the Hello SYNACK node can then\
    \ prune its proposed\n   dictionary entries before sending in order to avoid duplication.\n\
    \   This approach can be repeated for the second tranche of dictionary\n   entries\
    \ needed for the Bundle Offers and Responses, and also for the\n   Bundle Offers,\
    \ where any bundles that are offered by the Hello SYN\n   node that are already\
    \ present in the Hello SYNACK node need not be\n   offered to the Hello SYN node.\
    \  This approach is well suited to a\n   transport protocol and physical medium\
    \ that is effectively half-\n   duplex.\n   At present, the decision to operate\
    \ concurrently or sequentially is\n   purely a matter of local policy in each\
    \ node.  If nodes have\n   inconsistent policies, the behavior at each encounter\
    \ will depend on\n   which node takes the SYN role; this is a matter of chance\
    \ depending\n   on random timing of the start of communications during the encounter.\n\
    \   To manage the information transfer, two subsidiary state machines are\n  \
    \ created in each node to control the stages of the RIB Exchange Sub-\n   Phase\
    \ and Bundle Passing Sub-Phase processes within the INFO_EXCH\n   high-level state\
    \ as shown in Figure 12.  Each subsidiary state\n   machine consists of two essentially\
    \ independent components known as\n   the \"Initiator role\" and the \"Listener\
    \ role\".  One of these\n   components is instantiated in each node.  The Initiator\
    \ role starts\n   the Information Exchange Phase in each node and the Listener\
    \ role\n   responds to the initial messages, but it is not a passive listener\
    \ as\n   it also originates messages.  The transition from the ESTAB state is\n\
    \   a \"forking\" transition in that it starts both subsidiary state\n   machines.\
    \  The two subsidiary state machines operate in parallel for\n   as long as the\
    \ neighbor remains in range and connected.\n   + - - - - - - - - +           \
    \                   + - - - - - - - - +\n   |    SYN node     |    PRoPHET messages\
    \ with:    |   SYNACK node   |\n   | +-------------+ | A. Delivery Predictabilities\
    \ | +-------------+ |\n     | Subsidiary  |--->---->---->---->---->---->---->|\
    \ Subsidiary  |\n   | |   State     | | C. Bundle Responses          | |   State\
    \     | |\n     | Machine 1:  |                                  | Machine 1:\
    \  |\n   | |  Initiator  | | B. Bundle Offers             | |  Listener   | |\n\
    \     |    Role     |<----<----<----<----<----<----<---|    Role     |\n   | +-------------+\
    \ | D. Requested Bundles         | +-------------+ |\n   | +-------------+ | A.\
    \ Delivery Predictabilities | +-------------+ |\n     | Subsidiary  |<----<----<----<----<----<----<---|\
    \ Subsidiary  |\n   | |   State     | | C. Bundle Responses          | |   State\
    \     | |\n     | Machine 2:  |                                  | Machine 2:\
    \  |\n   | |  Listener   | | B. Bundle Offers             | |  Initiator  | |\n\
    \     |    Role     |--->---->---->---->---->---->---->|    Role     |\n   | +-------------+\
    \ | D. Requested Bundles         | +-------------+ |\n   + - - - - - - - - + \
    \                             + - - - - - - - - +\n         The letters (A - D)\
    \ indicate the sequencing of messages.\n      Figure 12: Information Exchange\
    \ Phase Subsidiary State Machines\n   These subsidiary state machines can be thought\
    \ of as mirror images:\n   for each state machine, one node takes on the Initiator\
    \ role while\n   the other node takes on the Listener role.  TLVs sent by a node\
    \ from\n   the Initiator role will be processed by the peer node in the Listener\n\
    \   role and vice versa.  As indicated in Figure 12, the Initiator role\n   handles\
    \ sending that node's current set of delivery predictabilities\n   for known destinations\
    \ to the Listener role node.  The Listener role\n   node uses the supplied values\
    \ to update its delivery predictabilities\n   according to the update algorithms\
    \ described in Section 2.1.2.  It\n   then decides which bundles that it has in\
    \ store should be offered for\n   transfer to the Initiator role node as a result\
    \ of comparing the\n   local predictabilities and those supplied by the Initiator\
    \ node.\n   When these offers are delivered to the Initiator role node, it\n \
    \  decides which ones to accept and supplies the Listener role node with\n   a\
    \ prioritized list of bundles that it wishes to accept.  The Listener\n   role\
    \ node then sends the requested bundles.\n   These exchanges are repeated periodically\
    \ for as long as the nodes\n   remain in contact.  Additionally, if new bundles\
    \ arrive from other\n   sources, they may be offered, accepted, and sent in between\
    \ these\n   exchanges.\n   The PRoPHET protocol is designed so that in most cases\
    \ the TLV type\n   determines the role in which it will be processed on reception.\
    \  The\n   only exception to this is that both roles may send RIB Dictionary\n\
    \   TLVs: the Initiator role sends dictionary entries for use in the\n   subsequent\
    \ RIB TLV(s), and the Listener role may send additional\n   dictionary entries\
    \ for use in subsequent Bundle Offer TLVs.  The two\n   cases are distinguished\
    \ by a TLV flag to ensure that they are\n   processed in the right role context\
    \ on reception.  If this flag was\n   not provided, there are states where both\
    \ roles could accept the RIB\n   Dictionary TLV, making it impossible to ensure\
    \ that the correct role\n   state machine accepts the RIB Dictionary TLV.  Note\
    \ that the correct\n   updates would be made to the dictionary whichever role\
    \ processed the\n   TLV and that the ambiguity would not arise if the roles are\
    \ adopted\n   completely sequentially, i.e., if the RIB Exchange Sub-Phase and\n\
    \   associated Bundle Passing Sub-Phase run to completion in one\n   direction\
    \ before the process for the reverse direction is started.\n   If sequential operation\
    \ is selected, the node that sent the Hello SYN\n   function message MUST be the\
    \ node that sends the first message in the\n   Information Exchange Phase process.\
    \  This ensures that there is a\n   well-defined order of events with the Initiator\
    \ role in the Hello SYN\n   node (i.e., the node identified by String ID 0) starting\
    \ first.  The\n   Hello SYNACK node MAY then postpone sending its first message\
    \ until\n   the Listener role state machine in the Hello SYNACK node has reached\n\
    \   any of a number of points in its state progression according to\n   locally\
    \ configured policy and the nature of the physical link for the\n   current encounter\
    \ between the nodes as described above.  If\n   concurrent operation is selected,\
    \ the Hello SYNACK node can start\n   sending messages immediately without waiting\
    \ to receive messages from\n   the peer.\n   The original design of the PRoPHET\
    \ protocol allowed it to operate\n   over unreliable datagram-type transports\
    \ as well as the reliable, in-\n   order delivery transport of TCP that is currently\
    \ specified.  When\n   running over TCP, protocol errors and repeated timeouts\
    \ during the\n   Information Exchange Phase SHOULD result in the connection being\n\
    \   terminated.\n"
- title: 5.3.1.  State Definitions for the Initiator Role
  contents:
  - "5.3.1.  State Definitions for the Initiator Role\n   The state machine component\
    \ with the Initiator role in each node\n   starts the transfer of information\
    \ from one node to its peer during\n   the Information Exchange Phase.  The process\
    \ from the Initiator's\n   point of view does the following:\n   o  The Initiator\
    \ role determines the set of delivery predictabilities\n      to be sent to the\
    \ peer node and sends RIB dictionary entries\n      necessary to interpret the\
    \ set of RIB predictability values that\n      are sent after the dictionary updates.\
    \  On second and subsequent\n      executions of this state machine during a single\
    \ session with the\n      same peer, there may be no RIB Dictionary entries to\
    \ send.  Either\n      an empty TLV can be sent or the TLV can be omitted.\n \
    \  o  The Initiator then waits to receive any RIB Dictionary updates\n      followed\
    \ by bundle offers from the Listener role on the peer node.\n   o  The Initiator\
    \ determines which of the bundle offers should be\n      accepted and, if necessary,\
    \ reorders the offers to suit its own\n      priorities.  The possibly reordered\
    \ list of accepted bundles is\n      sent to the peer node using one or more bundle\
    \ responses.\n   o  The peer then sends the accepted bundles to the Initiator\
    \ in turn.\n   o  Assuming that the link remains open during the bundle sending\n\
    \      process, the Initiator signals that the Bundle Passing Sub-Phase\n    \
    \  is complete by sending a message with an empty Bundle Response TLV\n      (i.e,\
    \ with the Bundle Offer Count set to 0 and no bundle offers\n      following the\
    \ TLV header).\n   o  When the bundle transfer is complete, the Initiator starts\
    \ the\n      Timer(next_exchange).  Assuming that the connection to the\n    \
    \  neighbor remains open, when the timer expires, the Initiator\n      restarts\
    \ the Information Exchange Phase.  During this period,\n      Hello SYN messages\
    \ are exchanged as keep-alives to check that the\n      neighbor is still present.\
    \  The keep-alive mechanism is common to\n      the Initiator and Listener machines\
    \ and is handled in the high-\n      level state machine (see Section 5.1.\n \
    \  A timer is provided that restarts the Initiator role state machine if\n   Bundle\
    \ Offers are not received after sending the RIB.  If this node\n   receives a\
    \ Hello ACK message containing an Error TLV indicating there\n   has been a protocol\
    \ problem, then the connection MUST be terminated.\n   The following states are\
    \ used:\n   CREATE_DR\n      The initial transition to this state from the ESTAB\
    \ state is\n      immediate and automatic for the node that sent the Hello SYN\n\
    \      message.  For the peer (Hello SYNACK sender) node, it may be\n      immediate\
    \ for nodes implementing a fully concurrent process or may\n      be postponed\
    \ until the corresponding Listener has reached a\n      specified state if a sequential\
    \ process is configured in the node\n      policy.\n      The local dictionary\
    \ is initialized when this state is entered for\n      the first time from the\
    \ ESTAB state.  The initial state of the\n      dictionary contains two entries:\
    \ the EID of the node that sent the\n      Hello SYN (String ID 0) and the EID\
    \ of the node that sent the\n      Hello SYNACK (String ID 1).  If the peer reports\
    \ via a Hello ACK\n      message containing an Error TLV reporting a Dictionary\
    \ Conflict or\n      Bad String ID error, then the connection MUST be terminated.\n\
    \      The CREATE_DR state will be entered in the same way from the\n      REQUEST\
    \ state when the Timer(next_exchange) expires, signaling the\n      start of a\
    \ new round of information exchange and bundle passing.\n      When in this state:\n\
    \      *  Determine the destination EIDs for which delivery\n         predictabilities\
    \ will be sent to the peer in a RIB TLV, if any.\n         Record the prior state\
    \ of the local dictionary (assuming that\n         String IDs are numbers allocated\
    \ sequentially, the state\n         information needed is just the highest ID\
    \ used before this\n         process started) so that the process can be restarted\
    \ if\n         necessary.  Update the local dictionary if any new EIDS are\n \
    \        required; format one or more RIB Dictionary TLVs and one or\n       \
    \  more RIB TLVs and send them to the peer.  If there are no\n         dictionary\
    \ entries to send, TLVs with zero entries MAY be sent,\n         or the TLV can\
    \ be omitted, but an empty RIB TLV MUST be sent if\n         there is no data\
    \ to send.  The RIB Dictionary TLVs generated\n         here MUST have the Sent\
    \ by Listener flag set to 0 to indicate\n         that they were sent by the Initiator.\n\
    \      *  If an Error TLV indicating a Dictionary Conflict or\n         Bad String\
    \ ID is received during or after sending the RIB\n         Dictionary TLVs and/or\
    \ the RIB TLVs, abort any in-progress\n         Initiator or Listener process,\
    \ and terminate the connection to\n         the peer.\n      *  Start a timer\
    \ (known as Timer(info)) and transition to the\n         SEND_DR state.\n    \
    \  Note that when (and only when) running over a transport protocol\n      such\
    \ as TCP, both the RIB Dictionary and RIB information MAY be\n      spread across\
    \ multiple TLVs and messages if required by known\n      constraints of the transport\
    \ protocol or to reduce the size of\n      memory buffers.  Alternatively, the\
    \ information can be formatted\n      using a single RIB Dictionary TLV and a\
    \ single RIB TLV.  These\n      TLVs may be quite large, so it may be necessary\
    \ to segment the\n      message either using the PRoPHET submessage capability\
    \ or, if the\n      transport protocol has appropriate capabilities, using those\n\
    \      inherent capabilities.  This discussion of segmentation applies to\n  \
    \    the other states and the bundle offer and bundle response messages\n    \
    \  and will not be repeated.\n      If more than one RIB TLV is to be used, all\
    \ but the last one have\n      the \"More RIB TLVs\" flag set to 1 in the TLV\
    \ flags.  It is not\n      necessary to distinguish the last RIB Dictionary TLV\
    \ because the\n      actions taken at the receiver are essentially passive (recording\n\
    \      the contents), and the sequence is ended by the sending of the\n      first\
    \ RIB TLV.\n   SEND_DR\n      In this state, the Initiator node expects to be\
    \ receiving Bundle\n      Offers and sending Bundle Responses.  The Initiator\
    \ node builds a\n      list of bundles offered by the peer while in this state:\n\
    \      *  Clear the set of bundles offered by the peer on entry to the\n     \
    \    state.\n      *  If the Timer(info) expires, re-send the RIB Dictionary and\
    \ RIB\n         information sent in the previous CREATE_DR state using the\n \
    \        stored state to re-create the information.  The RIB dictionary\n    \
    \     update process in the peer is idempotent provided that the\n         mappings\
    \ between the EID and the String ID in the re-sent RIB\n         Dictionary TLVs\
    \ are the same as in the original.  This means\n         that it does not matter\
    \ if some of the RIB Dictionary TLVs had\n         already been processed in the\
    \ peer.  Similarly, re-sending RIB\n         TLVs will not cause a problem.\n\
    \      *  If a message with a RIB Dictionary TLV marked as sent by a\n       \
    \  Listener is received, update the local dictionary based on the\n         received\
    \ TLV.  If any of the entries in the RIB Dictionary TLV\n         conflict with\
    \ existing entries (i.e., an entry is received that\n         uses the same String\
    \ ID as some previously received entry but\n         the EID in the entry is different),\
    \ send a Response message\n         with an Error TLV containing a Dictionary\
    \ Conflict indicator,\n         abort any in-progress Initiator or Listener process,\
    \ and\n         terminate the connection to the peer.  Note that in some\n   \
    \      circumstances no dictionary updates are needed, and the first\n       \
    \  message received in this state will carry a Bundle Offer TLV.\n      *  If\
    \ a message with a Bundle Offer TLV is received, restart the\n         Timer(info)\
    \ if the \"More Offer/Response TLVs Following\" flag is\n         set in the TLV;\
    \ otherwise, stop the Timer(info).  Then process\n         any PRoPHET ACKs in\
    \ the TLV by informing the bundle protocol\n         agent, and add the bundles\
    \ offered in the TLV to the set of\n         bundles offered.  If the \"More Offer/Response\
    \ TLVs Following\"\n         flag is set in the TLV, wait for further Bundle Offer\
    \ TLVs.  If\n         a Bundle Offer TLV is received with a String ID that is\
    \ not in\n         the dictionary, send a message with an Error TLV containing\
    \ a\n         Bad String ID indicator, abort any in-progress Initiator or\n  \
    \       Listener process, and terminate the connection to the peer.\n      * \
    \ If the \"More Offer/Response TLVs Following\" flag is clear in\n         the\
    \ last Bundle Offer TLV received, inspect the set of bundles\n         offered\
    \ to determine the set of bundles that are to be accepted\n         using the\
    \ configured queueing policy.  Record the set of\n         bundles accepted so\
    \ that reception can be checked in the Bundle\n         Passing Sub-Phase.  Format\
    \ one or more Bundle Response TLVs\n         flagging the accepted offers and\
    \ send them to the peer.  If\n         more than one Bundle Response TLV is sent,\
    \ all but the last one\n         should have the \"More Offer/Response TLVs Following\"\
    \ flag set\n         to 1.  At least one Bundle Response TLV MUST be sent even\
    \ if\n         the node does not wish to accept any of the offers.  In this\n\
    \         case, the Bundle Response TLV contains an empty set of\n         acceptances.\n\
    \      *  If an Error TLV indicating a Bad String ID is received during\n    \
    \     or after sending the Bundle Response TLVs, abort any in-\n         progress\
    \ Initiator or Listener process, re-initialize the local\n         dictionary,\
    \ and terminate the connection to the peer.\n      *  Restart the Timer(info)\
    \ timer in case the peer does not start\n         sending the requested bundles.\n\
    \      *  Transition to state REQUEST.\n   REQUEST\n      In this state, the Initiator\
    \ node expects to be receiving the\n      bundles accepted in the Bundle Response\
    \ TLV(s):\n      *  Keep track of the bundles received and delete them from the\
    \ set\n         of bundles accepted.\n      *  If the Timer(info) expires while\
    \ waiting for bundles, format\n         and send one or more Bundle Response TLVs\
    \ listing the bundles\n         previously accepted but not yet received.  If\
    \ more than one\n         Bundle Response TLV is sent, all but the last one should\
    \ have\n         the \"More Offer/Response TLVs Following\" flag set to 1.\n \
    \     *  If an Error TLV indicating a Bad String ID is received during\n     \
    \    or after sending the Bundle Response TLVs, abort any in-\n         progress\
    \ Initiator or Listener process, re-initialize the local\n         dictionary,\
    \ and terminate the connection to the peer.\n      *  Restart the Timer(info)\
    \ timer after each bundle is received in\n         case the peer does not continue\
    \ sending the requested bundles.\n      *  When all the requested bundles have\
    \ been received, format a\n         Bundle Response TLV with the Bundle Offer\
    \ Count set to zero and\n         with the \"More Offer/Response TLVs Following\"\
    \ flag cleared to 0\n         to signal completion to the peer node.  Also, signal\
    \ the\n         Listener in this node that the Initiator has completed.  If the\n\
    \         peer node is using a sequential policy, the Listener may still\n   \
    \      be in the initial state, in which case, it needs to start a\n         timer\
    \ to ensure that it detects if the peer fails to start the\n         Initiator\
    \ state machine.  Thereafter, coordinate with the\n         Listener state machine\
    \ in the same node: when the Listener has\n         received the completion notification\
    \ from the peer node and\n         this Initiator has sent its completion notification,\
    \ start\n         Timer(next_exchange).\n      *  If the Timer(next_exchange)\
    \ expires, transition to state\n         CREATE_DR to restart the Information\
    \ Exchange Phase.\n      Note that if Timer(info) timeout occurs a number of times\n\
    \      (configurable, typically 3) without any bundles being received,\n     \
    \ then this SHOULD generally be interpreted as the problem that the\n      link\
    \ to the peer is no longer functional and the session should be\n      terminated.\
    \  However, some bundles may be very large and take a\n      long time to transmit.\
    \  Before terminating the session, this state\n      machine needs to check if\
    \ a large bundle is actually being\n      received although no new completed bundles\
    \ have been received\n      since the last expiry of the timer.  In this case\
    \ the timer should\n      be restarted without sending the Bundle Response TLV.\
    \  Also, if\n      the bundles are being exchanged over a transport protocol that\
    \ can\n      detect link failure, then the session MUST be terminated if the\n\
    \      bundle exchange link is shut down because it has failed.\n"
- title: 5.3.2.  State Definitions for the Listener Role
  contents:
  - "5.3.2.  State Definitions for the Listener Role\n   The state machine component\
    \ with the Listener role in each node\n   initially waits to receive a RIB Dictionary\
    \ update followed by a set\n   of RIB delivery predictabilities during the Information\
    \ Exchange\n   Phase.  The process from the point of view of the Listener does\
    \ the\n   following:\n   o  Receive RIB Dictionary updates and RIB values from\
    \ the peer.  Note\n      that in some circumstances no dictionary updates are\
    \ needed, and\n      the RIBD TLV will contain no entries or may be omitted completely.\n\
    \   o  When all RIB messages have been received, the delivery\n      predictability\
    \ update algorithms are run (see Section 2.1.2) using\n      the values received\
    \ from the Initiator node and applying any of\n      the optional optimizations\
    \ configured for this node (see\n      Section 2.1.3).\n   o  Using the updated\
    \ delivery predictabilities and the queueing\n      policy and forwarding strategy\
    \ configured for this node (see\n      Section 2.1.4) examine the set of bundles\
    \ currently stored in the\n      Listener node to determine the set of bundles\
    \ to be offered to the\n      Initiator and order the list according to the forwarding\
    \ strategy\n      in use.  The Bundle Offer TLVs are also used to notify the peer\
    \ of\n      any PRoPHET ACKs that have been received by the Listener role\n  \
    \    node.\n   o  Send the list of bundles in one or more bundle offers, preceded\
    \ if\n      necessary by one or more RIB dictionary updates to add any EIDs\n\
    \      required for the source or destination EIDs of the offered\n      bundles.\
    \  These updates MUST be marked as being sent by the\n      Listener role so that\
    \ they will be processed by the Initiator role\n      in the peer.\n   o  Wait\
    \ for the Initiator to send bundle responses indicating which\n      bundles should\
    \ be sent and possibly a modified order for the\n      sending.  Send the accepted\
    \ bundles in the specified order.  The\n      bundle sending will normally be\
    \ carried out over a separate\n      connection using a suitable DTN convergence\
    \ layer.\n   o  On completion of the sending, wait for a message with an empty\n\
    \      Bundle Response TLV indicating correct completion of the process.\n   o\
    \  The Listener process will be notified if any new bundles or\n      PRoPHET\
    \ ACKs are received by the node after the completion of the\n      bundle sending\
    \ that results from this information exchange.  The\n      forwarding policy and\
    \ the current delivery predictabilities will\n      then be applied to determine\
    \ if this information should be sent to\n      the peer.  If it is determined\
    \ that one or more bundles and/or\n      ACKs ought to be forwarded, a new set\
    \ of bundle offers are sent to\n      the peer.  If the peer accepts them by sending\
    \ bundle responses,\n      the bundles and/or ACKS are transferred as previously.\n\
    \   o  Periodically, the Initiator in the peer will restart the complete\n   \
    \   information exchange by sending a RIB TLV that may be, optionally,\n     \
    \ preceded by RIB Dictionary entries if they are required for the\n      updated\
    \ RIB.\n   Timers are used to ensure that the Listener does not lock up if\n \
    \  messages are not received from the Initiator in a timely fashion.\n   The Listener\
    \ is restarted if the RIB is not received, and a Hello ACK\n   message is sent\
    \ to force the Initiator to restart.  If bundle\n   response messages are not\
    \ received in a timely fashion, the Listener\n   re-sends the bundle offers and\
    \ associated dictionary updates.  The\n   following states are used:\n   WAIT_DICT\n\
    \      The Listener subsidiary state machine transitions to this state\n     \
    \ automatically and immediately from the state ESTAB in both peers.\n      This\
    \ state will be entered in the same way if the\n      Timer(next_exchange) expires\
    \ in the peer, signaling the start of a\n      new round of information exchange\
    \ and bundle passing.  This will\n      result in one or more RIB TLVs being sent\
    \ to the Listener by the\n      peer node's Initiator.\n      *  When a RIB Dictionary\
    \ TLV is received, use the TLV to update\n         the local dictionary, start\
    \ or (if it is running) restart the\n         Timer(peer) and transition to state\
    \ WAIT_RIB.  If any of the\n         entries in the RIB Dictionary TLV conflict\
    \ with existing\n         entries (i.e., an entry is received that uses the same\
    \ String\n         ID as some previously received entry, but the EID in the entry\n\
    \         is different), send a Response message with an Error TLV\n         containing\
    \ a Dictionary Conflict indicator, abort any in-\n         progress Initiator\
    \ or Listener process, and terminate the\n         connection to the peer.\n \
    \     *  If a Hello ACK message is received from the peer node,\n         transition\
    \ to state WAIT_DICT and restart the process.\n      If multiple timeouts occur\
    \ (configurable, typically 3), assume\n      that the link is broken and terminate\
    \ the session.  Note that the\n      RIB Dictionary and RIB TLVs may be combined\
    \ into a single message.\n      The RIB TLV should be passed on to be processed\
    \ in the WAIT_RIB\n      state.\n   WAIT_RIB\n      In this state, the Listener\
    \ expects to be receiving one or more\n      RIB TLVs and possibly additional\
    \ RIB Dictionary TLVs.\n      *  On entry to this state, clear the set of received\
    \ delivery\n         predictabilities.\n      *  Whenever a new message is received,\
    \ restart the Timer(peer)\n         timer.\n      *  If a RIB dictionary TLV is\
    \ received, use it to update the local\n         dictionary and remain in this\
    \ state.  If any of the entries in\n         the RIB Dictionary TLV conflict with\
    \ existing entries (i.e., an\n         entry is received that uses the same String\
    \ ID as some\n         previously received entry, but the EID in the entry is\n\
    \         different), send a message with an Error TLV containing a\n        \
    \ Dictionary Conflict indicator, abort any in-progress Initiator\n         or\
    \ Listener process, and terminate the connection to the peer.\n      *  If a RIB\
    \ TLV is received, record the received delivery\n         predictabilities for\
    \ use in recalculating the local delivery\n         predictabilities.  If a delivery\
    \ predictability value is\n         received for an EID that is already in the\
    \ set of received\n         delivery predictabilities, overwrite the previously\
    \ received\n         value with the latest value.  If a delivery predictability\n\
    \         value is received with a String ID that is not in the\n         dictionary,\
    \ send a message with an Error TLV containing a\n         Bad String ID indicator,\
    \ abort any in-progress Initiator or\n         Listener process, and terminate\
    \ the connection to the peer.\n      *  When a RIB TLV is received with the \"\
    More RIB TLVs\" flag\n         cleared, initiate the recalculation of delivery\n\
    \         predictabilities and stop the Timer(peer).  Use the revised\n      \
    \   delivery predictabilities and the configured queueing and\n         forwarding\
    \ strategies to create a list of bundles to be offered\n         to the peer node.\n\
    \      *  Record the state of the local dictionary in case the offer\n       \
    \  procedure has to be restarted.  Determine if any new dictionary\n         entries\
    \ are required for use in the Bundle Offer TLV(s).  If\n         so, record them\
    \ in the local dictionary, then format and send\n         RIB Dictionary entries\
    \ in zero or more RIB Dictionary TLV\n         messages to update the dictionary\
    \ in the peer if necessary.\n      *  Format and send Bundle Offer TLV(s) carrying\
    \ the identifiers of\n         the bundles to be offered together with any PRoPHET\
    \ ACKs\n         received or generated by this node.  If more than one Bundle\n\
    \         Offer TLV is sent, all but the last Bundle Offer TLV sent MUST\n   \
    \      have the \"More Offer/Response TLVs Following\" flag set to 1.\n      *\
    \  When all Bundle Offer TLVs have been sent, start the\n         Timer(info)\
    \ and transition to state OFFER.\n      *  If the Timer(peer) expires, send a\
    \ Hello ACK TLV to the peer,\n         restart the timer, and transition to state\
    \ WAIT_DICT.\n      *  If an Error TLV indicating a Dictionary Conflict or\n \
    \        Bad String ID is received during or after sending the RIB\n         Dictionary\
    \ TLVs and/or the Bundle Offer TLVs, abort any in-\n         progress Initiator\
    \ or Listener process, and terminate the\n         connection to the peer.\n \
    \     *  If a Hello ACK message is received from the peer node,\n         transition\
    \ to state WAIT_DICT and restart the process.\n   OFFER\n      In this state,\
    \ the Listener expects to be receiving one or more\n      Bundle Response TLVs\
    \ detailing the bundles accepted by the\n      Initiator node.  The ordered list\
    \ of accepted bundles is\n      communicated to the bundle protocol agent, which\
    \ controls sending\n      them to the peer node over a separate connection.\n\
    \      *  When a Bundle Response TLV is received with a non-zero count of\n  \
    \       Bundle Offers, extract the list of accepted bundles and send\n       \
    \  the list to the bundle protocol agent so that it can start\n         transmission\
    \ to the peer node.  Ensure that the order of offers\n         from the TLV is\
    \ maintained.  Restart the Timer(info) unless the\n         last Bundle Response\
    \ TLV received has the \"More Offer/\n         Response TLVs Following\" flag\
    \ set to 0.  If a Bundle Response\n         TLV is received with a String ID that\
    \ is not in the dictionary,\n         send a message with an Error TLV containing\
    \ a Bad String ID\n         indicator, abort any in-progress Initiator or Listener\
    \ process,\n         and terminate the connection to the peer.\n      *  After\
    \ receiving a Bundle Response TLV with the \"More Offer/\n         Response TLVs\
    \ Following\" flag set to 0 stop the Timer(info) and\n         transition to state\
    \ SND_BUNDLE.\n      *  If the Timer(info) expires, send a Hello ACK TLV to the\
    \ peer,\n         restart the timer and transition to state WAIT_DICT.\n     \
    \ *  If a Hello ACK message is received from the peer node,\n         transition\
    \ to state WAIT_DICT and restart the process.\n   SND_BUNDLE\n      In this state\
    \ the Listener monitors the sending of bundles to the\n      Initiator peer node.\
    \  In the event of disruption in transmission,\n      the Initiator node will,\
    \ if possible, re-send the list of bundles\n      that were accepted but have\
    \ not yet been received.  The bundle\n      protocol agent has to be informed\
    \ of any updates to the list of\n      bundles to send (this is likely to involve\
    \ re-sending one or more\n      bundles).  Otherwise, the Listener is quiescent\
    \ in this state.\n      *  When a Bundle Response TLV is received with a non-zero\
    \ count of\n         Bundle Offers, extract the list of accepted bundles and update\n\
    \         the list previously passed to the bundle protocol agent so that\n  \
    \       it can (re)start transmission to the peer node.  Ensure that\n       \
    \  the order of offers from the TLV is maintained so far as is\n         possible.\
    \  Restart the Timer(info) unless the last Bundle\n         Response TLV received\
    \ has the \"More Offer/Response TLVs\n         Following\" flag set to 0.  If\
    \ a Bundle Response TLV is received\n         with a String ID that is not in\
    \ the dictionary, send a message\n         with an Error TLV containing a Bad\
    \ String ID indicator, abort\n         any in-progress Initiator or Listener process,\
    \ re-initialize\n         the local dictionary, and restart the Information Exchange\n\
    \         Phase as if the ESTAB state had just been reached.\n      *  After receiving\
    \ a Bundle Response TLV with the \"More Offer/\n         Response TLVs Following\"\
    \ flag set to 0, stop the Timer(info)\n         and wait for completion of bundle\
    \ sending.\n      *  If the Timer(info) expires, send a Hello ACK TLV to the peer,\n\
    \         restart the timer, and transition to state WAIT_DICT.\n      *  If a\
    \ Hello ACK message is received from the peer node,\n         transition to state\
    \ WAIT_DICT and restart the process.\n      *  When a Bundle Response TLV is received\
    \ with a zero count of\n         Bundle Offers, the Bundle Passing Sub-Phase is\
    \ complete.\n         Notify the Initiator that the Listener process is complete\
    \ and\n         transition to state WAIT_MORE.\n      As explained in the Initiator\
    \ state REQUEST description, depending\n      on the transport protocol (convergence\
    \ layer) used to send the\n      bundles to the peer node, it may be necessary\
    \ during the bundle\n      sending process to monitor the liveness of the connection\
    \ to the\n      peer node in the Initiator process using a timer.\n   WAIT_MORE\n\
    \      In this state, the Listener monitors the reception of new bundles\n   \
    \   that might be received from a number of sources, including\n      *  local\
    \ applications on the node,\n      *  other mobile nodes that connect to the node\
    \ while this\n         connection is open, and\n      *  permanent connections\
    \ such as might occur at an Internet\n         gateway.\n      When the Listener\
    \ is notified of received bundles, it determines\n      if they should be offered\
    \ to the peer.  The peer may also re-\n      initiate the Information Exchange\
    \ Phase periodically.\n      *  When the bundle protocol agent notifies the Listener\
    \ that new\n         bundles and/or new PRoPHET ACKs have been received, the\n\
    \         Listener applies the selected forwarding policy and the current\n  \
    \       delivery predictabilities to determine if any of the items\n         ought\
    \ to be offered to the connected peer.  If so, it carries\n         out the same\
    \ operations as are described in the WAIT_RIB state\n         to build and send\
    \ any necessary RIB Dictionary TLVs and RIB\n         TLVs to the Initiator in\
    \ the peer.\n      *  When all Bundle Offer TLVs have been sent, start the\n \
    \        Timer(info) and transition to state OFFER.\n      *  If a RIB dictionary\
    \ TLV is received, use it to update the local\n         dictionary and transition\
    \ to state WAIT_RIB.  If any of the\n         entries in the RIB Dictionary TLV\
    \ conflict with existing\n         entries (i.e., an entry is received that uses\
    \ the same String\n         ID as some previously received entry, but the EID\
    \ in the entry\n         is different), send a message with an Error TLV containing\
    \ a\n         Dictionary Conflict indicator, abort any in-progress Initiator\n\
    \         or Listener process, and terminate the connection to the peer.\n   \
    \   Note that the RIB Dictionary and RIB TLVs may be combined into a\n      single\
    \ message.  The RIB TLV should be passed on to be processed\n      in the WAIT_RIB\
    \ state.\n"
- title: 5.3.3.  Recommendations for Information Exchange Timer Periods
  contents:
  - "5.3.3.  Recommendations for Information Exchange Timer Periods\n   The Information\
    \ Exchange Phase (IEP) state definitions include a\n   number of timers.  This\
    \ section provides advice and recommendations\n   for the periods that are appropriate\
    \ for these timers.\n   Both Timer(info) and Timer(peer) are used to ensure that\
    \ the state\n   machines do not become locked into inappropriate states if the\
    \ peer\n   node does not apparently respond to messages sent in a timely fashion\n\
    \   either because of message loss in the network or unresponsiveness\n   from\
    \ the peer.  The appropriate values are to some extent dependent\n   on the speed\
    \ of the network connection between the nodes and the\n   capabilities of the\
    \ nodes executing the PRoPHET implementations.\n   Values in the range 1 to 10\
    \ seconds SHOULD be used, with a value of 5\n   seconds RECOMMENDED as default.\
    \  The period should not be set to too\n   low a value, as this might lead to\
    \ inappropriate restarts if the\n   hardware is relatively slow or there are large\
    \ numbers of pieces of\n   information to process before responding.  When using\
    \ a reliable\n   transport protocol such as TCP, these timers effectively provide\
    \ a\n   keep-alive mechanism and ensure that a failed connection is detected\n\
    \   as rapidly as possible so that remedial action can be taken (if\n   possible)\
    \ or the connection shut down tidily if the peer node has\n   moved out of range.\n\
    \   Timer(next_exchange) is used to determine the maximum frequency of\n   (i.e.,\
    \ minimum period between) successive re-executions of the\n   information exchange\
    \ state machines during a single session between a\n   pair of nodes.  Selection\
    \ of the timer period SHOULD reflect the\n   trade-off between load on the node\
    \ processor and desire for timely\n   forwarding of bundles received from other\
    \ nodes.  It is RECOMMENDED\n   that the timer periods used should be randomized\
    \ over a range from\n   50% to 150% of the base value in order to avoid synchronization\n\
    \   between multiple nodes.  Consideration SHOULD be given to the\n   expected\
    \ length of typical encounters and the likelihood of\n   encounters between groups\
    \ of nodes when setting this period.  Base\n   values in the range of 20 to 60\
    \ seconds are RECOMMENDED.\n"
- title: 5.3.4.  State Tables for Information Exchange
  contents:
  - "5.3.4.  State Tables for Information Exchange\n   This section shows the state\
    \ transitions that nodes go through during\n   the Information Exchange Phase.\
    \  State tables are given for the\n   Initiator role and for the Listener role\
    \ of the subsidiary state\n   machines.  Both nodes will be running machines in\
    \ each role during\n   the Information Exchange Phase, and this can be done either\n\
    \   concurrently or sequentially, depending on the implementation, as\n   explained\
    \ in Section 5.3.  The state tables in this section should be\n   read in conjunction\
    \ with the state descriptions in Sections 5.3.1 and\n   5.3.2.\n"
- title: 5.3.4.1.  Common Notation, Operations and Events
  contents:
  - "5.3.4.1.  Common Notation, Operations and Events\n   The following notation is\
    \ used:\n   nS            Node that sent the Hello SYN message.\n   nA       \
    \     Node that sent the Hello SYNACK message.\n   The following events are common\
    \ to the Initiator and Listener state\n   tables:\n   ErrDC         Dictionary\
    \ Conflict Error TLV received.\n   ErrBadSI      Bad String ID Error TLV received.\n\
    \   HelloAck      Hello ACK TLV received.  This message is delivered to\n    \
    \             both Initiator and Listener roles in order to cause a\n        \
    \         restart of the Information Exchange Phase in the event\n           \
    \      of message loss or protocol problems.\n   InitStart     Sent by Listener\
    \ role to Initiator role to signal the\n                 Initiator role to commence\
    \ sending messages to peer.\n                 If the Listener instance is running\
    \ in the node that\n                 sent the Hello SYN (nS), then InitStart is\
    \ signaled\n                 immediately when the state is entered.  For the node\n\
    \                 that sent the Hello SYNACK (nA), InitStart may be\n        \
    \         signaled immediately if the operational policy requires\n          \
    \       concurrent operation of the Initiator and Listener\n                 roles\
    \ or postponed until the Listener role state\n                 machine has reached\
    \ a state defined by the configured\n                 policy.\n   RIBnotlast \
    \   RIB TLV received with \"More RIB TLVs\" flag set to 1.\n   RIBlast       RIB\
    \ TLV received with \"More RIB TLVs\" flag set to 0.\n   REQnotlast    Bundle\
    \ Response TLV received with More Offer/Response\n                 TLVs Following\
    \ flag set to 1.\n   REQlast       Bundle Response TLV received with More Offer/Response\n\
    \                 TLVs Following flag set to 0.\n   RIBDi         RIBD TLV received\
    \ with Sent by Listener flag set to 0\n                 (i.e., it was sent by\
    \ Initiator role).\n   RIBDl         RIBD TLV received with Sent by Listener flag\
    \ set to 1\n                 (i.e., it was sent by Listener role).\n   Timeout(info)\
    \ The Timer(info) has expired.\n   Timeout(peer) The Timer(peer) has expired.\n\
    \   Both the Initiator and Listener state tables use the following common\n  \
    \ operations:\n   o  The \"Initialize Dictionary\" operation is defined as emptying\
    \ any\n      existing local dictionary and inserting the two initial entries:\n\
    \      the EID of the node that sent the Hello SYN (String ID 0) and the\n   \
    \   EID of the node that sent the Hello SYNACK (String ID 1).\n   o  The \"Send\
    \ RIB Dictionary Updates\" operation is defined as:\n      1.  Determining what\
    \ dictionary updates will be needed for any\n          extra EIDs in the previously\
    \ selected RIB entries set that are\n          not already in the dictionary and\
    \ updating the local\n          dictionary with these EIDs.  The set of dictionary\
    \ updates may\n          be empty if no extra EIDs are needed.  The set may be\
    \ empty\n          even on the first execution if sequential operation has been\n\
    \          selected, this is the second node to start and the necessary\n    \
    \      EIDs were in the set previously sent by the first node to\n          start.\n\
    \      2.  Formatting zero or more RIBD TLVs for the set of dictionary\n     \
    \     updates identified in the \"Build RIB Entries\" operation and\n        \
    \  sends them to the peer.  The RIBD TLVs MUST have the \"Sent by\n          Listener\"\
    \ flag set to 0 if the updates are sent by the\n          Initiator role and to\
    \ 1 if sent by the Listener role.  In the\n          case of the Initiator role,\
    \ an empty RIBD TLV MUST be sent\n          even if the set of updates is empty\
    \ in order to trigger the\n          Listener state machine.\n   o  The \"Update\
    \ Dictionary\" operation uses received RIBD TLV entries\n      to update the local\
    \ dictionary.  The received entries are checked\n      against the existing dictionary.\
    \  If the String ID in the entry is\n      already in use, the entry is accepted\
    \ if the EID in the received\n      entry is identical to that stored in the dictionary\
    \ previously.\n      If it is identical, the entry is unchanged, but if it is\
    \ not a\n      Response message with an Error TLV indicating Dictionary Conflict\n\
    \      is sent to the peer in an Error Response message, the whole\n      received\
    \ RIBD TLV is ignored, and the Initiator and Listener\n      processes are restarted\
    \ as if the ESTAB state has just been\n      reached.\n   o  The \"Abort Exchange\"\
    \ operation is defined as aborting any in-\n      progress information exchange\
    \ state machines and terminating the\n      connection to the peer.\n   o  The\
    \ \"Start TI\" operation is defined as (re)starting the\n      Timer(info) timer.\n\
    \   o  The \"Start TP\" operation is defined as (re)starting the\n      Timer(peer)\
    \ timer.\n   o  The \"Cancel TI\" operation is defined as canceling the Timer(info)\n\
    \      timer.\n   o  The \"Cancel TP\" operation is defined as canceling the Timer(info)\n\
    \      timer.\n"
- title: 5.3.4.2.  State Tables for the Initiator Role
  contents:
  - "5.3.4.2.  State Tables for the Initiator Role\n   The rules and state tables\
    \ for the Initiator role use the following\n   operations:\n   o  The \"Build\
    \ RIB Entries\" operation is defined as:\n      1.  Recording the state of the\
    \ local dictionary.\n      2.  Determining the set of EIDs for which RIB entries\
    \ should be\n          sent during this execution of the Initiator role state\
    \ machine\n          component.  If this is a second or subsequent run of the\
    \ state\n          machine in this node during the current session with the\n\
    \          connected peer, then the set of EIDs may be empty if no\n         \
    \ changes have occurred since the previous run of the state\n          machine.\n\
    \      3.  Determining and extracting the current delivery predictability\n  \
    \        information for the set of EIDs selected.\n   o  The \"Send RIB Entries\"\
    \ operation formats one or more RIB TLVs with\n      the set of RIB entries identified\
    \ in the \"Build RIB Entries\"\n      operation and sends them to the peer.  If\
    \ the set is empty, a\n      single RIB TLV with zero entries is sent.  If more\
    \ than one RIB\n      TLV is sent, all but the last one MUST have the \"More RIB\
    \ TLVs\"\n      flag set to 1; the last or only one MUST have the flag set to\
    \ 0.\n   o  The \"Clear Bundle Lists\" operation is defined as emptying the\n\
    \      lists of bundles offered by the peer and bundles requested from\n     \
    \ the peer.\n   o  The \"Notify ACKs\" operation is defined as informing the bundle\n\
    \      protocol agent that PRoPHET ACKs has been received for one or more\n  \
    \    bundles in a Bundle Offer TLV using the Bundle Delivered interface\n    \
    \  (see Section 2.2).\n   o  The \"Record Offers\" operation is defined as recording\
    \ all the\n      bundles offered in a Bundle Offer TLV in the list of bundles\n\
    \      offers.\n   o  The \"Select for Request\" operation prunes and sorts the\
    \ list of\n      offered bundles held into the list of requested bundles according\n\
    \      to policy and the available resources ready for sending to the\n      offering\
    \ node.\n   o  The \"Send Requests\" operation is defined as formatting one or\
    \ more\n      non-empty Bundle Response TLVs and sending them to the offering\n\
    \      node.  If more than one Bundle Offer TLV is sent, all but the last\n  \
    \    one MUST have the \"More Offer/Response TLVs Following\" flag set to\n  \
    \    1; the last or only one MUST have the flag set to 0.\n   o  The \"Record\
    \ Bundle Received\" operation deletes a successfully\n      received bundle from\
    \ the list of requests.\n   o  The \"All Requests Done\" operation is defined\
    \ as formatting and\n      sending an empty Bundle Offer TLV, with the \"More\
    \ Offer/Response\n      TLVs Following\" flag set to 0, to the offering node.\n\
    \   o  The \"Check Receiving\" operation is defined as checking with the\n   \
    \   node bundle protocol agent if bundle reception from the peer node\n      is\
    \ currently in progress.  This is needed in case a timeout occurs\n      while\
    \ waiting for bundle reception and a very large bundle is\n      being processed.\n\
    \   o  The \"Start NE\" operation is defined as (re)starting the\n      Timer(next_exchange).\n\
    \   The following events are specific to the Initiator role state\n   machine:\n\
    \   LastBndlRcvd  Bundle received from peer that is the only remaining\n     \
    \            bundle in Bundle Requests List.\n   NotLastBndlRcvd  Bundle received\
    \ from peer that is not the only\n                 remaining bundle in Bundle\
    \ Requests List.\n   OFRnotlast    Bundle Offer TLV received with \"More Offer/Response\n\
    \                 TLVs Following\" flag set to 1.\n   OFRlast       Bundle Offer\
    \ TLV received with \"More Offer/Response\n                 TLVs Following\" flag\
    \ set to 0\n   Timeout(next_exch)  The Timer(next_exchange) has expired\n    State:\
    \ CREATE_DR\n    +==================================================================+\n\
    \    |     Condition    |               Action              | New State |\n  \
    \  +==================+===================================+===========+\n    |\
    \     On Entry     |    If previous state was ESTAB:   |           |\n    |  \
    \                |         Initialize Dictionary     |           |\n    |    \
    \              |    Always:                        |           |\n    |      \
    \            |         Build RIB Entries         |           |\n    |        \
    \          |         Wait for Init Start       | CREATE_DR |\n    +------------------+-----------------------------------+-----------+\n\
    \    |    InitStart     |    Send RIB Dictionary Updates    |           |\n  \
    \  |                  |    Send RIB Entries               |           |\n    |\
    \                  |    Start TI                       |  SEND_DR  |\n    +------------------+-----------------------------------+-----------+\n\
    \    |      ErrDC       |           Abort Exchange          |(finished) |\n  \
    \  +------------------+-----------------------------------+-----------+\n    |\
    \     ErrBadSI     |           Abort Exchange          |(finished) |\n    +------------------+-----------------------------------+-----------+\n\
    \    |     HelloAck     |           Abort Exchange          | CREATE_DR |\n  \
    \  +==================================================================+\n    State:\
    \ SEND_DR\n    +==================================================================+\n\
    \    |     Condition    |               Action              | New State |\n  \
    \  +==================+===================================+===========+\n    |\
    \     On Entry     |         Clear Bundle Lists        |  SEND_DR  |\n    +------------------+-----------------------------------+-----------+\n\
    \    |  Timeout(info)   |   Send RIB Dictionary Updates     |           |\n  \
    \  |                  |   Send RIB Entries (note 1)       |  SEND_DR  |\n    +------------------+-----------------------------------+-----------+\n\
    \    |  RIBDl received  |   Update Dictionary (note 2)      |           |\n  \
    \  |                  |   If Dictionary Conflict found:   |           |\n    |\
    \                  |           Abort Exchange          | CREATE_DR |\n    |  \
    \                |   Else:                           |           |\n    |    \
    \              |           Start TI                |  SEND_DR  |\n    +------------------+-----------------------------------+-----------+\n\
    \    |    OFRnotlast    |           Notify ACKs             |           |\n  \
    \  |                  |           Record Offers           |           |\n    |\
    \                  |           Start TI                |  SEND_DR  |\n    +------------------+-----------------------------------+-----------+\n\
    \    |     OFRlast      |           Cancel TI               |           |\n  \
    \  |                  |           Notify ACKs             |           |\n    |\
    \                  |           Record Offers           |           |\n    |  \
    \                |           Select for Request      |           |\n    |    \
    \              |           Send Requests           |           |\n    |      \
    \            |           Start TI                |  REQUEST  |\n    +------------------+-----------------------------------+-----------+\n\
    \    |      ErrDC       |           Abort Exchange          |(finished) |\n  \
    \  +------------------+-----------------------------------+-----------+\n    |\
    \     ErrBadSI     |           Abort Exchange          |(finished) |\n    +------------------+-----------------------------------+-----------+\n\
    \    |     HelloAck     |           Abort Exchange          | CREATE_DR |\n  \
    \  +==================================================================+\n    State:\
    \ REQUEST\n    +==================================================================+\n\
    \    |     Condition    |               Action              | New State |\n  \
    \  +==================+===================================+===========+\n    |\
    \  Timeout(info)   |  Check Receiving                  |           |\n    |  \
    \                |  If bundle reception in progress: |           |\n    |    \
    \              |         Start TI                  |  REQUEST  |\n    |      \
    \            |  Otherwise:                       |           |\n    |        \
    \          |         Send Requests             |           |\n    |          \
    \        |         Start TI (note 3)         |  REQUEST  |\n    +------------------+-----------------------------------+-----------+\n\
    \    | NotLastBndlRcvd  |     Record Bundle Received        |           |\n  \
    \  |                  |     Start TI                      |  REQUEST  |\n    +------------------+-----------------------------------+-----------+\n\
    \    |   LastBndlRcvd   |     Cancel TI                     |           |\n  \
    \  |                  |     All Requests Done             |           |\n    |\
    \                  |     Start NE                      |  REQUEST  |\n    +------------------+-----------------------------------+-----------+\n\
    \    |Timeout(next_exch)|                                   | CREATE_DR |\n  \
    \  +------------------+-----------------------------------+-----------+\n    |\
    \     HelloAck     |     Abort Exchange                | CREATE_DR |\n    +==================================================================+\n\
    \   Note 1:\n      No response to the RIB has been received before the timer expired,\n\
    \      so we re-send the dictionary and RIB TLVs.  If the timeout occurs\n   \
    \   repeatedly, it is likely that communication has failed and the\n      connection\
    \ MUST be terminated.\n   Note 2:\n      If a Dictionary Conflict error has to\
    \ be sent, the state machine\n      will be aborted.  If this event occurs repeatedly,\
    \ it is likely\n      that there is either a serious software problem or a security\n\
    \      issue.  The connection MUST be terminated.\n   Note 3:\n      Remaining\
    \ requested bundles have not arrived before the timer\n      expired, so we re-send\
    \ the list of outstanding requests.  If the\n      timeout occurs repeatedly,\
    \ it is likely that communication has\n      failed and the connection MUST be\
    \ terminated.\n"
- title: 5.3.4.3.  State Tables for the Listener Role
  contents:
  - "5.3.4.3.  State Tables for the Listener Role\n   The rules and state tables for\
    \ the Listener role use the following\n   operations:\n   o  The \"Clear Supplied\
    \ RIBs\" operation is defined as setting up an\n      empty container to hold\
    \ the set of RIBs supplied by the peer node.\n   o  The \"Record RIBs Supplied\"\
    \ operation is defined as:\n      1.  Taking the RIB entries from a received RIB\
    \ TLV.\n      2.  Verifying that the String ID used in each entry is present in\n\
    \          the dictionary.  If not, an Error TLV containing the offending\n  \
    \        String ID is sent to the peer, and the Initiator and Listener\n     \
    \     processes are aborted and restarted as if the ESTAB state had\n        \
    \  just been reached.\n      3.  If all the String IDs are present in the dictionary,\
    \ record\n          the delivery predictabilities for each EID in the entries.\n\
    \   o  The \"Recalc Dlvy Predictabilities\" operation uses the algorithms\n  \
    \    defined in Section 2.1.2 to update the local set of delivery\n      predictabilities\
    \ using the using the set of delivery\n      predictabilities supplied by the\
    \ peer in RIB TLVs.\n   o  The \"Determine Offers\" operation determines the set\
    \ of bundles to\n      be offered to the peer.  The local delivery predictabilities\
    \ and\n      the delivery predictabilities supplied by the peer are compared,\n\
    \      and a prioritized choice of the bundles stored in this node to be\n   \
    \   offered to the peer is made according to the configured queueing\n      policy\
    \ and forwarding strategy.\n   o  The \"Determine ACKs\" operation is defined\
    \ as obtaining the set of\n      PRoPHET ACKs recorded by the bundle protocol\
    \ agent that need to be\n      forwarded to the peer.  The list of PRoPHET ACKs\
    \ is maintained\n      internally by the PRoPHET protocol implementation rather\
    \ than the\n      main bundle protocol agent (see Section 3.5).\n   o  The \"\
    Determine Offer Dict Updates\" operation is defined as\n      determining any\
    \ extra EIDs that are not already in the dictionary,\n      recording the previous\
    \ state of the local dictionary, and then\n      adding the required extra entries\
    \ to the dictionary.\n   o  The \"Send Offers\" operation is defined as formatting\
    \ one or more\n      non-empty Bundle Offer TLVs, incorporating the sets of Offers\
    \ and\n      PRoPHET ACKs previously determined, and sending them to the peer\n\
    \      node.  If more than one Bundle Offer TLV is sent, all but the last\n  \
    \    one MUST have the \"More Offer/Response TLVs Following\" flag set to\n  \
    \    1; the last or only one MUST have the flag set to 0.\n   o  The \"Record\
    \ Requests\" operation is defined as recording all the\n      bundles offered\
    \ in a Bundle Offer TLV in the list of bundles\n      offers.  Duplicates MUST\
    \ be ignored.  The order of requests in the\n      TLVs MUST be maintained so\
    \ far as is possible (it is possible that\n      a bundle has to be re-sent, and\
    \ this may result in out-of-order\n      delivery).\n   o  The \"Send Bundles\"\
    \ operation is defined as sending, in the order\n      requested, the bundles\
    \ in the requested list.  This requires the\n      list to be communicated to\
    \ the bundle protocol agent (see\n      Section 2.2).\n   o  The \"Check Initiator\
    \ Start Point\" operation is defined as checking\n      the configured sequential\
    \ operation policy to determine if the\n      Listener role has reached the point\
    \ where the Initiator role\n      should be started.  If so, the InitStart notification\
    \ is sent to\n      the Initiator role in the same node.\n   The following events\
    \ are specific to the Listener role state machine:\n   RIBnotlast    RIB TLV received\
    \ with \"More RIB TLVs\" flag set to 1.\n   RIBlast       RIB TLV received with\
    \ \"More RIB TLVs\" flag set to 0 and\n                 a non-zero count of RIB\
    \ Entries.\n   REQnotlast    Bundle Response TLV received with More Offer/Response\n\
    \                 TLVs Following flag set to 1.\n   REQlast       Bundle Response\
    \ TLV received with More Offer/Response\n                 TLVs Following flag\
    \ set to 0 and a non-zero count of\n                 bundle offers.\n   REQempty\
    \      Bundle Response TLV received with More Offer/Response\n               \
    \  TLVs Following flag set to 0 and a zero count of bundle\n                 offers.\n\
    \    State: WAIT_DICT\n    +==================================================================+\n\
    \    |     Condition    |               Action              | New State |\n  \
    \  +==================+===================================+===========+\n    |\
    \     On Entry     |     Check Initiator Start Point   | WAIT_DICT |\n    +------------------+-----------------------------------+-----------+\n\
    \    |       RIBDi      |     Update Dictionary (note 1)    |           |\n  \
    \  |                  |     If Dictionary Conflict found: |           |\n    |\
    \                  |           Abort Exchange          |(finished) |\n    |  \
    \                |     Else:                         |           |\n    |    \
    \              |           Start TP                | WAIT_RIB  |\n    +------------------+-----------------------------------+-----------+\n\
    \    |     HelloAck     |     Abort Exchange                | WAIT_DICT |\n  \
    \  +==================================================================+\n    State:\
    \ WAIT_RIB\n    +==================================================================+\n\
    \    |     Condition    |               Action              | New State |\n  \
    \  +==================+===================================+===========+\n    |\
    \     On Entry     |   Clear Supplied RIBS             | WAIT_RIB  |\n    +------------------+-----------------------------------+-----------+\n\
    \    |       RIBDi      |   Update Dictionary (note 1)      |           |\n  \
    \  |                  |   If Dictionary Conflict found:   |           |\n    |\
    \                  |         Abort Exchange            |(finished) |\n    |  \
    \                |   Else:                           |           |\n    |    \
    \              |         Start TP                  | WAIT_RIB  |\n    +------------------+-----------------------------------+-----------+\n\
    \    |    RIBnotlast    |   Record RIBS Supplied (note 2)   |           |\n  \
    \  |                  |   If EID missing in dictionary:   |           |\n    |\
    \                  |         Abort Exchange            |(finished) |\n    |  \
    \                |   Else:                           |           |\n    |    \
    \              |         Start TP                  | WAIT_RIB  |\n    +------------------+-----------------------------------+-----------\n\
    \    |     RIBlast      |   Check Initiator Start Point     |           |\n  \
    \  |                  |   Record RIBS Supplied (note 2)   |           |\n    |\
    \                  |   If EID missing in dictionary:   |           |\n    |  \
    \                |         Abort Exchange            |(finished) |\n    |    \
    \              |   Otherwise                       |           |\n    |      \
    \            |         Recalc Dlvy               |           |\n    |        \
    \          |               Predictabilities    |           |\n    |          \
    \        |         Cancel TP                 |           |\n    |            \
    \      |         Determine Offers          |           |\n    |              \
    \    |         Determine ACKs            |           |\n    |                \
    \  |         Determine Offer           |           |\n    |                  |\
    \               Dict Updates        |           |\n    |                  |  \
    \       Send RIB Dictionary       |           |\n    |                  |    \
    \           Updates             |           |\n    |                  |      \
    \   Send Offers               |           |\n    |                  |        \
    \ Start TI                  |   OFFER   |\n    +------------------+-----------------------------------+-----------+\n\
    \    |     HelloAck     |     Abort Exchange                | WAIT_DICT |\n  \
    \  +------------------+-----------------------------------+-----------+\n    |Any\
    \ Other TLV rcvd|     Abort Exchange                |(finished) |\n    +------------------+-----------------------------------+-----------+\n\
    \    |  Timeout(peer)   |     Send RIB Dictionary Updates   |           |\n  \
    \  |                  |     Send Offers                   |           |\n    |\
    \                  |     Start TI (note 3)             |   OFFER   |\n    +==================================================================+\n\
    \    State: OFFER\n    +==================================================================+\n\
    \    |     Condition    |               Action              | New State |\n  \
    \  +==================+===================================+===========+\n    |\
    \    REQnotlast    |      Send Bundles                 |           |\n    |  \
    \                |      Start TI                     |   OFFER   |\n    +------------------+-----------------------------------+-----------+\n\
    \    |     REQlast      |      Cancel TI                    |           |\n  \
    \  |                  |      Check Initiator Start Point  |           |\n    |\
    \                  |      Send Bundles                 | SND_BUNDLE|\n    +------------------+-----------------------------------+-----------+\n\
    \    |     REQempty     |      Cancel TI                    |           |\n  \
    \  |                  |      Check Initiator Start Point  | WAIT_MORE|\n    +------------------+-----------------------------------+-----------+\n\
    \    |     HelloAck     |      Abort Exchange               | WAIT_DICT |\n  \
    \  +------------------+-----------------------------------+-----------+\n    |\
    \  Timeout(info)   |      Send RIB Dictionary Updates  |           |\n    |  \
    \                |      Send Offers                  |           |\n    |    \
    \              |      Start TI (note 3)            |   OFFER   |\n    +==================================================================+\n\
    \    State: SND_BUNDLE\n    +==================================================================+\n\
    \    |     Condition    |               Action              | New State |\n  \
    \  +==================+===================================+===========+\n    |\
    \    REQnotlast    |      Send Bundles                 |           |\n    |  \
    \                |      Start TI                     | SND_BUNDLE|\n    +------------------+-----------------------------------+-----------+\n\
    \    |     REQlast      |      Cancel TI                    |           |\n  \
    \  |                  |      Send Bundles                 | SND_BUNDLE|\n    +------------------+-----------------------------------+-----------+\n\
    \    |     REQempty     |      Cancel TI                    |           |\n  \
    \  |                  |      Check Initiator Start Point  | WAIT_MORE|\n    +------------------+-----------------------------------+-----------+\n\
    \    |     HelloAck     |      Abort Exchange               | WAIT_DICT |\n  \
    \  +------------------+-----------------------------------+-----------+\n    |\
    \  Timeout(info)   |      Send RIB Dictionary Updates  |           |\n    |  \
    \                |      Send Offers                  |           |\n    |    \
    \              |      Start TI (note 3)            |   OFFER   |\n    +==================================================================+\n\
    \    State: WAIT_MORE\n    +==================================================================+\n\
    \    |     Condition    |               Action              | New State |\n  \
    \  +==================+===================================+===========+\n    |\
    \ More Bundles     |         Determine Offers          |           |\n    |  \
    \                |         Determine ACKs            |           |\n    |    \
    \              |         Determine Offer           |           |\n    |      \
    \            |               Dict Updates        |           |\n    |        \
    \          |         Send RIB Dictionary       |           |\n    |          \
    \        |               Updates             |           |\n    |            \
    \      |         Send Offers               |           |\n    |              \
    \    |         Start TI                  |   OFFER   |\n    +------------------+-----------------------------------+-----------+\n\
    \    |       RIBDi      |   Update Dictionary (note 1)      |           |\n  \
    \  |                  |   If Dictionary Conflict found:   |           |\n    |\
    \                  |         Abort Exchange            |(finished) |\n    |  \
    \                |   Else:                           |           |\n    |    \
    \              |         Start TP                  | WAIT_RIB  |\n    +------------------+-----------------------------------+-----------+\n\
    \    |    REQnotlast    |      Send Bundles                 |           |\n  \
    \  |                  |      Start TI                     | SND_BUNDLE|\n    +------------------+-----------------------------------+-----------+\n\
    \    |     REQlast      |      Cancel TI                    |           |\n  \
    \  |                  |      Send Bundles                 | SND_BUNDLE|\n    +------------------+-----------------------------------+-----------+\n\
    \    |     REQempty     |      Cancel TI                    |           |\n  \
    \  |                  |      Check Initiator Start Point  | SND_BUNDLE|\n    +------------------+-----------------------------------+-----------+\n\
    \    |     HelloAck     |      Abort Exchange               | WAIT_DICT |\n  \
    \  +------------------+-----------------------------------+-----------+\n    |\
    \  Timeout(info)   |      Send RIB Dictionary Updates  |           |\n    |  \
    \                |      Send Offers                  |           |\n    |    \
    \              |      Start TI (note 3)            |   OFFER   |\n    +==================================================================+\n\
    \   Note 1:\n      Both the dictionary and the RIB TLVs may come in the same PRoPHET\n\
    \      message.  In that case, the state will change to WAIT_RIB, and the\n  \
    \    RIB will then immediately be processed.\n   Note 2:\n      Send an ACK if\
    \ the timer for the peering node expires.  Either the\n      link has been broken,\
    \ and then the link setup will restart, or it\n      will trigger the Information\
    \ Exchange Phase to restart.\n   Note 3:\n      When the RIB is received, it is\
    \ possible for the PRoPHET agent to\n      update its delivery predictabilities\
    \ according to Section 2.1.2.\n      The delivery predictabilities and the RIB\
    \ is then used together\n      with the forwarding strategy in use to create a\
    \ bundle offer TLV.\n      This is sent to the peering node.\n   Note 4:\n   \
    \   No more bundles are requested by the other node; transfer is\n      complete.\n\
    \   Note 5:\n      No response to the bundle offer has been received before the\
    \ timer\n      expired, so we re-send the bundle offer.\n"
- title: 5.4.  Interaction with Nodes Using Version 1 of PRoPHET
  contents:
  - "5.4.  Interaction with Nodes Using Version 1 of PRoPHET\n   There are existing\
    \ implementations of PRoPHET based on draft versions\n   of this specification\
    \ that use version 1 of the protocol.  There are\n   a number of significant areas\
    \ of difference between version 1 and\n   version 2 as described in this document:\n\
    \   o  In version 1, the delivery predictability update equations were\n     \
    \ significantly different, and in the case of the transitivity\n      equation\
    \ (Equation 3) could lead to degraded performance or non-\n      delivery of bundles\
    \ in some circumstances.\n   o  In the current version , constraints were placed\
    \ on the String IDs\n      generated by each node to ensure that it was not possible\
    \ for\n      there to be a conflict if the IDs were generated concurrently and\n\
    \      independently in the two nodes.\n   o  In the current version, a flag has\
    \ been added to the Routing\n      Information Base Dictionary TLV to distinguish\
    \ dictionary updates\n      sent by the Initiator role and by the Listener role.\n\
    \   o  In the current version, the Bundle Offer and Response TLVs have\n     \
    \ been significantly revised.  The version 2 TLVs have been\n      allocated new\
    \ TLV Type numbers, and the version 1 TLVs (types 0xA2\n      and 0xA3) are now\
    \ deprecated.  For each bundle specifier, the\n      source EID is transmitted\
    \ in addition to the creation timestamp by\n      version 2 to ensure that the\
    \ bundle is uniquely identified.\n      Version 2 also transmits the fragment\
    \ payload offset and length\n      when the offered bundle is a bundle fragment.\
    \  The payload length\n      can optionally be transmitted for each bundle (whether\
    \ or not it\n      is a fragment) to give the receiver additional information\
    \ that\n      can be useful when determining which bundle offers to accept.\n\
    \   o  The behavior of the system after the first Information Exchange\n     \
    \ Phase has been better defined.  The state machine has been altered\n      to\
    \ better describe how the ongoing operations work.  This has\n      involved the\
    \ removal of the high-level state WAIT_INFO and the\n      addition of two states\
    \ in the Listener role subsidiary state\n      machine (SND_BUNDLE and WAIT_MORE).\
    \  The protocol on the wire has\n      not been altered by this change to the\
    \ description of the state\n      machine.  However, the specification of the\
    \ later stages of\n      operation was slightly vague and might have been interpreted\n\
    \      differently by various implementers.\n   A node implementing version 2\
    \ of the PRoPHET protocol as defined in\n   this document MAY ignore a communication\
    \ opportunity with a node that\n   sends a HELLO message indicating that it uses\
    \ version 1, or it MAY\n   partially downgrade and respond to messages as if it\
    \ were a version 1\n   node.  This means that the version field in all message\
    \ headers MUST\n   contain 1.\n   It is RECOMMENDED that the version 2 node use\
    \ the metric update\n   equations defined in this document even when communicating\
    \ with a\n   version 1 node as this will partially inhibit the problems with the\n\
    \   transitivity equation in version 1, and that the version 2 node\n   modify\
    \ any received metrics that are greater than (1 - delta) to be\n   (1 - delta)\
    \ to avoid becoming a \"sink\" for bundles that are not\n   destined for this\
    \ node.  Also version 1 nodes cannot be explicitly\n   offered bundle fragments,\
    \ and an exchange with a node supporting\n   version 1 MUST use the, now deprecated,\
    \ previous versions of the\n   Bundle Offer and Response TLVs.\n   Generally,\
    \ nodes using version 1 should be upgraded if at all\n   possible because of problems\
    \ that have been identified.\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   Currently, PRoPHET does not specify any special\
    \ security measures.\n   As a routing protocol for intermittently connected networks,\
    \ PRoPHET\n   is a target for various attacks.  The various known possible\n \
    \  vulnerabilities are discussed in this section.\n   The attacks described here\
    \ are not problematic if all nodes in the\n   network can be trusted and are working\
    \ towards a common goal.  If\n   there exist such a set of nodes, but there also\
    \ exist malicious\n   nodes, these security problems can be solved by introducing\
    \ an\n   authentication mechanism when two nodes meet, for example, using a\n\
    \   public key system.  Thus, only nodes that are known to be members of\n   the\
    \ trusted group of nodes are allowed to participate in the routing.\n   This of\
    \ course introduces the additional problem of key distribution,\n   but that is\
    \ not addressed here.\n   Where suitable, the mechanisms (such as key management\
    \ and bundle\n   authentication or integrity checks) and terminology specified\
    \ by the\n   Bundle Security Protocol [RFC6257] are to be used.\n"
- title: 6.1.  Attacks on the Operation of the Protocol
  contents:
  - "6.1.  Attacks on the Operation of the Protocol\n   There are a number of kinds\
    \ of attacks on the operation of the\n   protocol that it would be possible to\
    \ stage on a PRoPHET network.\n   The attacks and possible remedies are listed\
    \ here.\n"
- title: 6.1.1.  Black-Hole Attack
  contents:
  - "6.1.1.  Black-Hole Attack\n   A malicious node sets its delivery predictabilities\
    \ for all\n   destinations to a value close to or exactly equal to 1 and/or\n\
    \   requests all bundles from nodes it meets, and does not forward any\n   bundles.\
    \  This has two effects, both causing messages to be drawn\n   towards the black\
    \ hole instead of to their correct destinations.\n   1.  A node encountering a\
    \ malicious node will try to forward all its\n       bundles to the malicious\
    \ node, creating the belief that the\n       bundle has been very favorably forwarded.\
    \  Depending on the\n       forwarding strategy and queueing policy in use, this\
    \ might hamper\n       future forwarding of the bundle and/or lead to premature\
    \ dropping\n       of the bundle.\n   2.  Due to the transitivity, the delivery\
    \ predictabilities reported\n       by the malicious node will affect the delivery\
    \ predictabilities\n       of other nodes.  This will create a gradient for all\
    \ destinations\n       with the black hole as the \"center of gravity\" towards\
    \ which all\n       bundles traverse.  This should be particularly severe in\n\
    \       connected parts of the network.\n"
- title: 6.1.1.1.  Attack Detection
  contents:
  - "6.1.1.1.  Attack Detection\n   A node receiving a set of delivery predictabilities\
    \ that are all at\n   or close to 1 should be suspicious.  Similarly, a node that\
    \ accepts\n   all bundles and offers none might be considered suspicious.  However,\n\
    \   these conditions are not impossible in normal operation.\n"
- title: 6.1.1.2.  Attack Prevention/Solution
  contents:
  - "6.1.1.2.  Attack Prevention/Solution\n   To prevent this attack, authentication\
    \ between nodes that meet needs\n   to be present.  Nodes can also inspect the\
    \ received metrics and\n   bundle acceptances/offers for suspicious patterns and\
    \ terminate\n   communications with nodes that appear suspicious.  The natural\n\
    \   evolution of delivery predictabilities should mean that a genuine\n   node\
    \ would not be permanently ostracized even if the values lead to\n   termination\
    \ of a communication opportunity on one occasion.  The\n   epidemic nature of\
    \ PRoPHET would mean that such a termination rarely\n   leads to non-delivery\
    \ of bundles.\n"
- title: 6.1.2.  Limited Black-Hole Attack / Identity Spoofing
  contents:
  - "6.1.2.  Limited Black-Hole Attack / Identity Spoofing\n   A malicious node misrepresents\
    \ itself by claiming to be someone else.\n   The effects of this attack are:\n\
    \   1.  The effects of the black-hole attack listed above hold for this\n    \
    \   attack as well, with the exception that only the delivery\n       predictabilities\
    \ and bundles for one particular destination are\n       affected.  This could\
    \ be used to \"steal\" the data that should be\n       going to a particular node.\n\
    \   2.  In addition to the above problems, PRoPHET ACKs will be issued\n     \
    \  for the bundles that are delivered to the malicious node.  This\n       will\
    \ cause these bundles to be removed from the network, reducing\n       the chance\
    \ that they will reach their real destination.\n"
- title: 6.1.2.1.  Attack Detection
  contents:
  - "6.1.2.1.  Attack Detection\n   The destination can detect that this kind of attack\
    \ has occurred (but\n   it cannot prevent the attack) when it receives a PRoPHET\
    \ ACK for a\n   bundle destined to itself but for which it did not receive the\n\
    \   corresponding bundle.\n"
- title: 6.1.2.2.  Attack Prevention/Solution
  contents:
  - "6.1.2.2.  Attack Prevention/Solution\n   To prevent this attack, authentication\
    \ between nodes that meet needs\n   to be present.\n"
- title: 6.1.3.  Fake PRoPHET ACKs
  contents:
  - "6.1.3.  Fake PRoPHET ACKs\n   A malicious node may issue fake PRoPHET ACKs for\
    \ all bundles (or only\n   bundles for a certain destination if the attack is\
    \ targeted at a\n   single node) carried by nodes it met.  The affected bundles\
    \ will be\n   deleted from the network, greatly reducing their probability of\
    \ being\n   delivered to the destination.\n"
- title: 6.1.3.1.  Attack Prevention/Solution
  contents:
  - "6.1.3.1.  Attack Prevention/Solution\n   If a public key cryptography system\
    \ is in place, this attack can be\n   prevented by mandating that all PRoPHET\
    \ ACKs be signed by the\n   destination.  Similarly to other solutions using public\
    \ key\n   cryptography, this introduces the problem of key distribution.\n"
- title: 6.1.4.  Bundle Store Overflow
  contents:
  - "6.1.4.  Bundle Store Overflow\n   After encountering and receiving the delivery\
    \ predictability\n   information from the victim, a malicious node may generate\
    \ a large\n   number of fake bundles for the destination for which the victim\
    \ has\n   the highest delivery predictability.  This will cause the victim to\n\
    \   most likely accept these bundles, filling up its bundle storage,\n   possibly\
    \ at the expense of other, legitimate, bundles.  This problem\n   is transient\
    \ as the messages will be removed when the victim meets\n   the destination and\
    \ delivers the messages.\n"
- title: 6.1.4.1.  Attack Detection
  contents:
  - "6.1.4.1.  Attack Detection\n   If it is possible for the destination to figure\
    \ out that the bundles\n   it is receiving are fake, it could report that malicious\
    \ actions are\n   underway.\n"
- title: 6.1.4.2.  Attack Prevention/Solution
  contents:
  - "6.1.4.2.  Attack Prevention/Solution\n   This attack could be prevented by requiring\
    \ sending nodes to sign all\n   bundles they send.  By doing this, intermediate\
    \ nodes could verify\n   the integrity of the messages before accepting them for\
    \ forwarding.\n"
- title: 6.1.5.  Bundle Store Overflow with Delivery Predictability Manipulation
  contents:
  - "6.1.5.  Bundle Store Overflow with Delivery Predictability Manipulation\n   A\
    \ more sophisticated version of the attack in the previous section\n   can be\
    \ attempted.  The effect of the previous attack was lessened\n   since the destination\
    \ node of the fake bundles existed.  This caused\n   fake bundles to be purged\
    \ from the network when the destination was\n   encountered.  The malicious node\
    \ may now use the transitive property\n   of the protocol to boost the victim's\
    \ delivery predictabilities for a\n   non-existent destination.  After this, it\
    \ creates a large number of\n   fake bundles for this non-existent destination\
    \ and offers them to the\n   victim.  As before, these bundles will fill up the\
    \ bundle storage of\n   the victim.  The impact of this attack will be greater\
    \ as there is no\n   probability of the destination being encountered and the\
    \ bundles\n   being acknowledged.  Thus, they will remain in the bundle storage\n\
    \   until they time out (the malicious node may set the timeout to a\n   large\
    \ value) or until they are evicted by the queueing policy.\n   The delivery predictability\
    \ for the fake destination may spread in\n   the network due to the transitivity,\
    \ but this is not a problem, as it\n   will eventually age and fade away.\n  \
    \ The impact of this attack could be increased if multiple malicious\n   nodes\
    \ collude, as network resources can be consumed at a greater\n   speed and at\
    \ many different places in the network simultaneously.\n"
- title: 6.2.  Interactions with External Routing Domains
  contents:
  - "6.2.  Interactions with External Routing Domains\n   Users may opt to connect\
    \ two regions of sparsely connected nodes\n   through a connected network such\
    \ as the Internet where another\n   routing protocol is running.  To this network,\
    \ PRoPHET traffic would\n   look like any other application-layer data.  Extra\
    \ care must be taken\n   in setting up these gateway nodes and their interconnections\
    \ to make\n   sure that malicious nodes cannot use them to launch attacks on the\n\
    \   infrastructure of the connected network.  In particular, the traffic\n   generated\
    \ should not be significantly more than what a single regular\n   user end host\
    \ could create on the network.\n"
- title: 7.  IANA Considerations
  contents:
  - "7.  IANA Considerations\n   Following the policies outlined in \"Guidelines for\
    \ Writing an IANA\n   Considerations Section in RFCs\" (RFC 5226 [RFC5226]), the\
    \ following\n   name spaces are defined in PRoPHET.\n   o  For fields in the PRoPHET\
    \ message header (Section 4.1):\n      *  DTN Routing Protocol Number\n      *\
    \  PRoPHET Protocol Version\n      *  PRoPHET Header Flags\n      *  PRoPHET Result\
    \ Field\n      *  PRoPHET Codes for Success and Codes for Failure\n   o  Identifiers\
    \ for TLVs carried in PRoPHET messages:\n      *  PRoPHET TLV Type (Section 4.2)\n\
    \   o  Definitions of TLV Flags and other flag fields in TLVs:\n      *  Hello\
    \ TLV Flags (Section 4.3.1)\n      *  Error TLV Flags (Section 4.3.2)\n      *\
    \  Routing Information Base (RIB) Dictionary TLV Flags\n         (Section 4.3.3)\n\
    \      *  Routing Information Base (RIB) TLV Flags (Section 4.3.4)\n      *  Routing\
    \ Information Base (RIB) Flags per entry (Section 4.3.4)\n      *  Bundle Offer\
    \ and Response TLV Flags (Section 4.3.5)\n      *  Bundle Offer and Response B\
    \ Flags per offer or response\n         (Section 4.3.5)\n   The following subsections\
    \ list the registries that have been created.\n   Initial values for the registries\
    \ are given below; future assignments\n   for unassigned values are to be made\
    \ through the Specification\n   Required policy.  Where specific values are defined\
    \ in the IANA\n   registries according to the specifications in the subsections\
    \ below,\n   the registry refers to this document as defining the allocation.\n"
- title: 7.1.  DTN Routing Protocol Number
  contents:
  - "7.1.  DTN Routing Protocol Number\n   The encoding of the Protocol Number field\
    \ in the PRoPHET header\n   (Section 4.1) is:\n         +--------------------------+-----------+---------------+\n\
    \         |         Protocol         |   Value   |   Reference   |\n         +--------------------------+-----------+---------------+\n\
    \         |     PRoPHET Protocol     |    0x00   | This document |\n         |\
    \        Unassigned        | 0x01-0xEF |               |\n         | Private/Experimental\
    \ Use | 0xF0-0xFF | This document |\n         +--------------------------+-----------+---------------+\n"
- title: 7.2.  PRoPHET Protocol Version
  contents:
  - "7.2.  PRoPHET Protocol Version\n   The encoding of the PRoPHET Version field\
    \ in the PRoPHET header\n   (Section 4.1) is:\n        +----------------------------+-----------+---------------+\n\
    \        |           Version          |   Value   |   Reference   |\n        +----------------------------+-----------+---------------+\n\
    \        | Reserved (do not allocate) |    0x00   | This document |\n        |\
    \         PRoPHET v1         |    0x01   | This document |\n        |        \
    \ PRoPHET v2         |    0x02   | This document |\n        |         Unassigned\
    \         | 0x03-0xEF |               |\n        |  Private/Experimental Use \
    \ | 0xF0-0xFE | This document |\n        |          Reserved          |    0xFF\
    \   |               |\n        +----------------------------+-----------+---------------+\n"
- title: 7.3.  PRoPHET Header Flags
  contents:
  - "7.3.  PRoPHET Header Flags\n   The following Flags are defined for the PRoPHET\
    \ Header (Section 4.1):\n                 +------------+--------------+-----------+\n\
    \                 |   Meaning  | Bit Position | Reference |\n                \
    \ +------------+--------------+-----------+\n                 | Unassigned | \
    \    Bit 0    |           |\n                 | Unassigned |     Bit 1    |  \
    \         |\n                 | Unassigned |     Bit 2    |           |\n    \
    \             | Unassigned |     Bit 3    |           |\n                 +------------+--------------+-----------+\n"
- title: 7.4.  PRoPHET Result Field
  contents:
  - "7.4.  PRoPHET Result Field\n   The encoding of the Result field in the PRoPHET\
    \ header (Section 4.1)\n   is:\n        +--------------------------+-------------+---------------+\n\
    \        |       Result Value       |    Value    |   Reference   |\n        +--------------------------+-------------+---------------+\n\
    \        |         Reserved         |     0x00    | This document |\n        |\
    \       NoSuccessAck       |     0x01    | This document |\n        |        \
    \  AckAll          |     0x02    | This document |\n        |          Success\
    \         |     0x03    | This document |\n        |          Failure        \
    \ |     0x04    | This document |\n        |       ReturnReceipt      |     0x05\
    \    | This document |\n        |        Unassigned        | 0x06 - 0x7F |   \
    \            |\n        | Private/Experimental Use | 0x80 - 0xFF | This document\
    \ |\n        +--------------------------+-------------+---------------+\n"
- title: 7.5.  PRoPHET Codes for Success and Codes for Failure
  contents:
  - "7.5.  PRoPHET Codes for Success and Codes for Failure\n   The encoding for Code\
    \ field in the PRoPHET header (Section 4.1) for\n   \"Success\" messages is:\n\
    \        +--------------------------+-------------+---------------+\n        |\
    \         Code Name        |    Values   |   Reference   |\n        +--------------------------+-------------+---------------+\n\
    \        |      Generic Success     |     0x00    | This document |\n        |\
    \    Submessage Received   |     0x01    | This document |\n        |        Unassigned\
    \        | 0x02 - 0x7F |               |\n        | Private/Experimental Use |\
    \ 0x80 - 0xFF | This document |\n        +--------------------------+-------------+---------------+\n\
    \   The encoding for Code in the PRoPHET header (Section 4.1) for\n   \"Failure\"\
    \ messages is:\n       +----------------------------+-------------+---------------+\n\
    \       |          Code Name         |    Values   |   Reference   |\n       +----------------------------+-------------+---------------+\n\
    \       | Reserved (do not allocate) | 0x00 - 0x01 | This document |\n       |\
    \     Unspecified Failure    |     0x02    | This document |\n       |       \
    \  Unassigned         | 0x03 - 0x7F |               |\n       |  Private/Experimental\
    \ Use  | 0x80 - 0xFE | This document |\n       |    Error TLV in Message    |\
    \     0xFF    | This document |\n       +----------------------------+-------------+---------------+\n"
- title: 7.6.  PRoPHET TLV Type
  contents:
  - "7.6.  PRoPHET TLV Type\n   The TLV Types defined for PRoPHET (Section 4.2) are:\n\
    \      +------------------------------+-------------+---------------+\n      |\
    \             Type             |    Value    |   Reference   |\n      +------------------------------+-------------+---------------+\n\
    \      |  Reserved (do not allocate)  |     0x00    | This document |\n      |\
    \           Hello TLV          |     0x01    | This document |\n      |      \
    \     Error TLV          |     0x02    | This document |\n      |          Unsassigned\
    \         | 0x03 - 0x9F |               |\n      |      RIB dictionary TLV   \
    \   |     0xA0    | This document |\n      |            RIB TLV           |  \
    \   0xA1    | This document |\n      |   Bundle Offer (deprecated)  |     0xA2\
    \    | This document |\n      | Bundle Response (deprecated) |     0xA3    | This\
    \ document |\n      |       Bundle Offer (v2)      |     0xA4    | This document\
    \ |\n      |     Bundle Response (v2)     |     0xA5    | This document |\n  \
    \    |          Unassigned          | 0xA6 - 0xCF |               |\n      | \
    \  Private/Experimental Use   | 0xD0 - 0xFF | This document |\n      +------------------------------+-------------+---------------+\n"
- title: 7.7.  Hello TLV Flags
  contents:
  - "7.7.  Hello TLV Flags\n   The following TLV Flags are defined for the Hello TLV\n\
    \   (Section 4.3.1).  Flag numbers 0, 1, and 2 are treated as a 3-bit\n   unsigned\
    \ integer with 5 of the 8 possible values allocated, and the\n   other 3 reserved.\
    \  The remaining bits are treated individually:\n   +----------------------------+---------------------+---------------+\n\
    \   |           Meaning          |        Value        |   Reference   |\n   +----------------------------+---------------------+---------------+\n\
    \   |                            | (Flags 0, 1, and 2) |               |\n   |\
    \ Reserved (do not allocate) |        0b000        | This document |\n   |   \
    \          SYN            |        0b001        | This document |\n   |      \
    \     SYNACK           |        0b010        | This document |\n   |         \
    \    ACK            |        0b011        | This document |\n   |           RSTACK\
    \           |        0b100        | This document |\n   |         Unassigned \
    \        |    0b101 - 0b111    |               |\n   |                       \
    \     |    (Flags 3 - 7)    |               |\n   |         Unassigned       \
    \  |        Flag 3       |               |\n   |         Unassigned         |\
    \        Flag 4       |               |\n   |         Unassigned         |   \
    \     Flag 5       |               |\n   |         Unassigned         |      \
    \  Flag 6       |               |\n   |           L Flag           |        Flag\
    \ 7       | This document |\n   +----------------------------+---------------------+---------------+\n"
- title: 7.8.  Error TLV Flags
  contents:
  - "7.8.  Error TLV Flags\n   The TLV Flags field in the Error TLV (Section 4.3.2)\
    \ is treated as an\n   unsigned 8-bit integer encoding the Error TLV number. \
    \ The following\n   values are defined:\n      +--------------------------+------------------+---------------+\n\
    \      |      Error TLV Name      | Error TLV Number |   Reference   |\n     \
    \ +--------------------------+------------------+---------------+\n      |   \
    \ Dictionary Conflict   |       0x00       | This document |\n      |       Bad\
    \ String ID      |       0x01       | This document |\n      |        Unassigned\
    \        |    0x02 - 0x7F   |               |\n      | Private/Experimental Use\
    \ |    0x80 - 0xFF   | This document |\n      +--------------------------+------------------+---------------+\n"
- title: 7.9.  RIB Dictionary TLV Flags
  contents:
  - "7.9.  RIB Dictionary TLV Flags\n   The following TLV Flags are defined for the\
    \ RIB Base Dictionary TLV\n   (Section 4.3.3):\n       +----------------------------+--------------+---------------+\n\
    \       |           Meaning          | Bit Position |   Reference   |\n      \
    \ +----------------------------+--------------+---------------+\n       |    \
    \  Sent by Listener      |    Flag 0    | This document |\n       | Reserved (do\
    \ not allocate) |    Flag 1    | This document |\n       | Reserved (do not allocate)\
    \ |    Flag 2    | This document |\n       |         Unassigned         |    Flag\
    \ 3    |               |\n       |         Unassigned         |    Flag 4    |\
    \               |\n       |         Unassigned         |    Flag 5    |      \
    \         |\n       |         Unassigned         |    Flag 6    |            \
    \   |\n       |         Unassigned         |    Flag 7    |               |\n\
    \       +----------------------------+--------------+---------------+\n"
- title: 7.10.  RIB TLV Flags
  contents:
  - "7.10.  RIB TLV Flags\n   The following TLV Flags are defined for the RIB TLV\
    \ (Section 4.3.4):\n       +----------------------------+--------------+---------------+\n\
    \       |           Meaning          | Bit Position |   Reference   |\n      \
    \ +----------------------------+--------------+---------------+\n       |    \
    \    More RIB TLVs       |    Flag 0    | This document |\n       | Reserved (do\
    \ not allocate) |    Flag 1    | This document |\n       | Reserved (do not allocate)\
    \ |    Flag 2    | This document |\n       |         Unassigned         |    Flag\
    \ 3    |               |\n       |         Unassigned         |    Flag 4    |\
    \               |\n       |         Unassigned         |    Flag 5    |      \
    \         |\n       |         Unassigned         |    Flag 6    |            \
    \   |\n       |         Unassigned         |    Flag 7    |               |\n\
    \       +----------------------------+--------------+---------------+\n"
- title: 7.11.  RIB Flags
  contents:
  - "7.11.  RIB Flags\n   The following RIB Flags are defined for the individual entries\
    \ in the\n   RIB TLV (Section 4.3.4):\n                 +------------+--------------+-----------+\n\
    \                 |   Meaning  | Bit Position | Reference |\n                \
    \ +------------+--------------+-----------+\n                 | Unassigned | \
    \   Flag 0    |           |\n                 | Unassigned |    Flag 1    |  \
    \         |\n                 | Unassigned |    Flag 2    |           |\n    \
    \             | Unassigned |    Flag 3    |           |\n                 | Unassigned\
    \ |    Flag 4    |           |\n                 | Unassigned |    Flag 5    |\
    \           |\n                 | Unassigned |    Flag 6    |           |\n  \
    \               | Unassigned |    Flag 7    |           |\n                 +------------+--------------+-----------+\n"
- title: 7.12.  Bundle Offer and Response TLV Flags
  contents:
  - "7.12.  Bundle Offer and Response TLV Flags\n   The following TLV Flags are defined\
    \ for the Bundle Offer and Response\n   TLV (Section 4.3.5):\n   +------------------------------------+--------------+---------------+\n\
    \   |               Meaning              | Bit Position |   Reference   |\n  \
    \ +------------------------------------+--------------+---------------+\n   |\
    \ More Offer/Response TLVs Following |    Flag 0    | This document |\n   |  \
    \           Unassigned             |    Flag 1    |               |\n   |    \
    \         Unassigned             |    Flag 2    |               |\n   |      \
    \       Unassigned             |    Flag 3    |               |\n   |        \
    \     Unassigned             |    Flag 4    |               |\n   |          \
    \   Unassigned             |    Flag 5    |               |\n   |            \
    \ Unassigned             |    Flag 6    |               |\n   |             Unassigned\
    \             |    Flag 7    |               |\n   +------------------------------------+--------------+---------------+\n"
- title: 7.13.  Bundle Offer and Response B Flags
  contents:
  - "7.13.  Bundle Offer and Response B Flags\n   The following B Flags are defined\
    \ for each Bundle Offer in the Bundle\n   Offer and Response TLV (Section 4.3.5):\n\
    \   +------------------------------------+--------------+---------------+\n  \
    \ |               Meaning              | Bit Position |   Reference   |\n   +------------------------------------+--------------+---------------+\n\
    \   |           Bundle Accepted          |    Flag 0    | This document |\n  \
    \ |        Bundle is a Fragment        |    Flag 1    | This document |\n   |\
    \  Bundle Payload Length Included in |    Flag 2    | This document |\n   |  \
    \               TLV                |              |               |\n   |    \
    \         Unassigned             |    Flag 3    |               |\n   |      \
    \       Unassigned             |    Flag 4    |               |\n   |        \
    \     Unassigned             |    Flag 5    |               |\n   |          \
    \   Unassigned             |    Flag 6    |               |\n   |            \
    \ PRoPHET ACK            |    Flag 7    | This document |\n   +------------------------------------+--------------+---------------+\n"
- title: 8.  Implementation Experience
  contents:
  - "8.  Implementation Experience\n   Multiple independent implementations of the\
    \ PRoPHET protocol exist.\n   The first implementation is written in Java, and\
    \ has been optimized\n   to run on the Lego MindStorms platform that has very\
    \ limited\n   resources.  Due to the resource constraints, some parts of the\n\
    \   protocol have been simplified or omitted, but the implementation\n   contains\
    \ all the important mechanisms to ensure proper protocol\n   operation.  The implementation\
    \ is also highly modular and can be run\n   on another system with only minor\
    \ modifications (it has currently\n   been shown to run on the Lego MindStorms\
    \ platform and on regular\n   laptops).\n   Another implementation is written\
    \ in C++ and runs in the OmNet++\n   simulator to enable testing and evaluation\
    \ of the protocol and new\n   features.  Experience and feedback from the implementers\
    \ on early\n   versions of the protocol have been incorporated into the current\n\
    \   version.\n   An implementation compliant to an Internet-Draft (which was posted\
    \ in\n   2006 and eventually evolved into this RFC) has been written at Baylor\n\
    \   University.  This implementation has been integrated into the DTN2\n   reference\
    \ implementation.\n   An implementation of the protocol in C++ was developed by\
    \ one of the\n   authors (Samo Grasic) at Lulea University of Technology (LTU)\
    \ as part\n   of the Saami Networking Connectivity project (see Section 9) and\n\
    \   continues to track the development of the protocol.  This work is now\n  \
    \ part of the Networking for Communications Challenged Communities\n   (N4C) project\
    \ and is used in N4C testbeds.\n"
- title: 9.  Deployment Experience
  contents:
  - "9.  Deployment Experience\n   During a week in August 2006, a proof-of-concept\
    \ deployment of a DTN\n   system, using the LTU PRoPHET implementation for routing\
    \ was made in\n   the Swedish mountains -- the target area for the Saami Network\n\
    \   Connectivity project [ccnc07] [doria_02].  Four fixed camps with\n   application\
    \ gateways, one Internet gateway, and seven mobile relays\n   were deployed. \
    \ The deployment showed PRoPHET to be able to route\n   bundles generated by different\
    \ applications such as email and web\n   caching.\n   Within the realms of the\
    \ SNC and N4C projects, multiple other\n   deployments, both during summer and\
    \ winter conditions, have been done\n   at various scales during 2007-2010 [winsdr08].\n\
    \   An implementation has been made for Android-based mobile telephones\n   in\
    \ the Bytewalla project [bytewalla].\n"
- title: 10.  Acknowledgements
  contents:
  - "10.  Acknowledgements\n   The authors would like to thank Olov Schelen and Kaustubh\
    \ S. Phanse\n   for contributing valuable feedback regarding various aspects of\
    \ the\n   protocol.  We would also like to thank all other reviewers and the\n\
    \   DTNRG chairs for the feedback in the process of developing the\n   protocol.\
    \  The Hello TLV mechanism is loosely based on the Adjacency\n   message developed\
    \ for RFC 3292.  Luka Birsa and Jeff Wilson have\n   provided us with feedback\
    \ from doing implementations of the protocol\n   based on various preliminary\
    \ versions of the document.  Their\n   feedback has helped us make the document\
    \ easier to read for an\n   implementer and has improved the protocol.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [RFC2119]      Bradner, S., \"Key words for use\
    \ in RFCs to Indicate\n                  Requirement Levels\", BCP 14, RFC 2119,\
    \ March 1997.\n   [RFC5050]      Scott, K. and S. Burleigh, \"Bundle Protocol\n\
    \                  Specification\", RFC 5050, November 2007.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [CLAYER]       Demmer, M., Ott, J., and S.\
    \ Perreault, \"Delay Tolerant\n                  Networking TCP Convergence Layer\
    \ Protocol\", Work\n                  in Progress, August 2012.\n   [RFC1058]\
    \      Hedrick, C., \"Routing Information Protocol\", RFC 1058,\n            \
    \      June 1988.\n   [RFC4838]      Cerf, V., Burleigh, S., Hooke, A., Torgerson,\
    \ L.,\n                  Durst, R., Scott, K., Fall, K., and H. Weiss, \"Delay-\n\
    \                  Tolerant Networking Architecture\", RFC 4838,\n           \
    \       April 2007.\n   [RFC5226]      Narten, T. and H. Alvestrand, \"Guidelines\
    \ for Writing\n                  an IANA Considerations Section in RFCs\", BCP\
    \ 26,\n                  RFC 5226, May 2008.\n   [RFC6257]      Symington, S.,\
    \ Farrell, S., Weiss, H., and P. Lovell,\n                  \"Bundle Security\
    \ Protocol Specification\", RFC 6257,\n                  May 2011.\n   [bytewalla]\
    \    Prasad, M., \"Bytewalla 3: Network architecture and\n                  PRoPHET\
    \ implementation\", Bytewalla Project, KTH Royal\n                  Institute\
    \ of Technology, Stockholm, Sweden, October\n                   2010,\n      \
    \            <http://www.bytewalla.org/sites/bytewalla.org/files/\n          \
    \        Bytewalla3_Network_architecture_and_PRoPHET_v1.0.pdf>.\n   [ccnc07] \
    \      Lindgren, A. and A. Doria, \"Experiences from Deploying\n             \
    \     a Real-life DTN System\", Proceedings of the 4th Annual\n              \
    \    IEEE Consumer Communications and Networking Conference\n                \
    \  (CCNC 2007), Las Vegas, Nevada, USA, January 2007.\n   [doria_02]     Doria,\
    \ A., Uden, M., and D. Pandey, \"Providing\n                  connectivity to\
    \ the Saami nomadic community\",\n                  Proceedings of the 2nd International\
    \ Conference on\n                  Open Collaborative Design for Sustainable Innovation\n\
    \                  (dyd 02), Bangalore, India, December 2002.\n   [lindgren_06]\
    \  Lindgren, A. and K. Phanse, \"Evaluation of Queueing\n                  Policies\
    \ and Forwarding Strategies for Routing in\n                  Intermittently Connected\
    \ Networks\", Proceedings of\n                  COMSWARE 2006, January 2006.\n\
    \   [vahdat_00]    Vahdat, A. and D. Becker, \"Epidemic Routing for\n        \
    \          Partially Connected Ad Hoc Networks\", Duke University\n          \
    \        Technical Report CS-200006, April 2000.\n   [winsdr08]     Lindgren,\
    \ A., Doria, A., Lindblom, J., and M. Ek,\n                  \"Networking in the\
    \ Land of Northern Lights - Two Years\n                  of Experiences from DTN\
    \ System Deployments\",\n                  Proceedings of the ACM Wireless Networks\
    \ and Systems\n                  for Developing Regions Workshop (WiNS-DR), San\n\
    \                  Francisco, California, USA, September 2008.\n"
- title: Appendix A.  PRoPHET Example
  contents:
  - "Appendix A.  PRoPHET Example\n   To help grasp the concepts of PRoPHET, an example\
    \ is provided to give\n   an understanding of the transitive property of the delivery\n\
    \   predictability and the basic operation of PRoPHET.  In Figure 13, we\n   revisit\
    \ the scenario where node A has a message it wants to send to\n   node D.  In\
    \ the bottom right corner of subfigures a-c, the delivery\n   predictability tables\
    \ for the nodes are shown.  Assume that nodes C\n   and D encounter each other\
    \ frequently (Figure 13a), making the\n   delivery predictability values they\
    \ have for each other high.  Now\n   assume that node C also frequently encounters\
    \ node B (Figure 13b).\n   Nodes B and C will get high delivery predictability\
    \ values for each\n   other, and the transitive property will also increase the\
    \ value B has\n   for D to a medium level.  Finally, node B meets node A (Figure\
    \ 13c),\n   which has a message for node D.  Figure 13d shows the message\n  \
    \ exchange between node A and node B.  Summary vectors and delivery\n   predictability\
    \ information is exchanged, delivery predictabilities\n   are updated, and node\
    \ A then realizes that P_(b,d) > P_(a,d), and\n   thus forwards the message for\
    \ node D to node B.\n   +----------------------------+   +----------------------------+\n\
    \   |                            |   |                            |\n   |    \
    \              C         |   |                       D    |\n   |            \
    \       D        |   |                            |\n   |       B            \
    \        |   |       B C                  |\n   |                            |\
    \   |                            |\n   |                            |   |    \
    \                        |\n   |                            |   |            \
    \                |\n   |                            |   |                    \
    \        |\n   | A*                         |   | A*                         |\n\
    \   +-------------+--------------+   +-------------+--------------+\n   |   A\
    \  |   B  |   C   |  D   |   |   A  |   B  |   C   |  D   |\n   |B:low |A:low\
    \ |A:low  |A:low |   |B:low |A:low |A:low  |A:low |\n   |C:low |C:low |B:low \
    \ |B:low |   |C:low |C:high|B:high |B:low |\n   |D:low |D:low |D:high |C:high|\
    \   |D:low |D:med |D:high |C:high|\n   +-------------+--------------+   +-------------+--------------+\n\
    \                (a)                              (b)\n   +----------------------------+\
    \   A                            B\n   |                            |   |    \
    \                        |\n   |                       D    |   |Summary vector&delivery\
    \ pred|\n   |                            |   |--------------------------->|\n\
    \   |         C                  |   |Summary vector&delivery pred|\n   |    \
    \                        |   |<---------------------------|\n   |            \
    \                |   |                            |\n   |   B*               \
    \        |  Update delivery predictabilities\n   |  A                        \
    \ |   |                            |\n   |                            |  Packet\
    \ for D not in SV        |\n   +-------------+--------------+  P(b,d)>P(a,d) \
    \                |\n   |   A  |   B  |   C   |  D   |  Thus, send            \
    \        |\n   |B:low |A:low |A:low  |A:low |   |                            |\n\
    \   |C:med |C:high|B:high |B:low |   |      Packet for D          |\n   |D:low+|D:med\
    \ |D:high |C:high|   |--------------------------->|\n   +-------------+--------------+\
    \   |                            |\n                (c)                      \
    \        (d)\n                        Figure 13: PRoPHET example\n"
- title: Appendix B.  Neighbor Discovery Example
  contents:
  - "Appendix B.  Neighbor Discovery Example\n   This section outlines an example\
    \ of a simple neighbor discovery\n   protocol that can be run in-between PRoPHET\
    \ and the underlying layer\n   in case lower layers do not provide methods for\
    \ neighbor discovery.\n   It assumes that the underlying layer supports broadcast\
    \ messages as\n   would be the case if a wireless infrastructure was involved.\n\
    \   Each node needs to maintain a list of its active neighbors.  The\n   operation\
    \ of the protocol is as follows:\n   1.  Every BEACON_INTERVAL milliseconds, the\
    \ node does a local\n       broadcast of a beacon that contains its identity and\
    \ address, as\n       well as the BEACON_INTERVAL value used by the node.\n  \
    \ 2.  Upon reception of a beacon, the following can happen:\n       A.  The sending\
    \ node is already in the list of active neighbors.\n           Update its entry\
    \ in the list with the current time, and\n           update the node's BEACON_INTERVAL\
    \ if it has changed.\n       B.  The sending node is not in the list of active\
    \ neighbors.  Add\n           the node to the list of active neighbors and record\
    \ the\n           current time and the node's BEACON_INTERVAL.  Notify the\n \
    \          PRoPHET agent that a new neighbor is available (\"New\n           Neighbor\"\
    , as described in Section 2.4).\n   3.  If a beacon has not been received from\
    \ a node in the list of\n       active neighbors within a time period of NUM_ACCEPTED_LOSSES\
    \ *\n       BEACON_INTERVAL (for the BEACON_INTERVAL used by that node), it\n\
    \       should be assumed that this node is no longer a neighbor.  The\n     \
    \  entry for this node should be removed from the list of active\n       neighbors,\
    \ and the PRoPHET agent should be notified that a\n       neighbor has left (\"\
    Neighbor Gone\", as described in Section 2.4).\n"
- title: Appendix C.  PRoPHET Parameter Calculation Example
  contents:
  - "Appendix C.  PRoPHET Parameter Calculation Example\n   The evolution of the delivery\
    \ predictabilities in a PRoPHET node is\n   controlled by three main equations\
    \ defined in Section 2.1.2.  These\n   equations use a number of parameters that\
    \ need to be appropriately\n   configured to ensure that the delivery predictabilities\
    \ evolve in a\n   way that mirrors the mobility model that applies in the PRoPHET\
    \ zone\n   where the node is operating.\n   When trying to describe the mobility\
    \ model, it is more likely that\n   the model will be couched in terms of statistical\
    \ distribution of\n   times between encounters and times to deliver a bundle in\
    \ the zone.\n   In this section, one possible way of deriving the PRoPHET parameters\n\
    \   from a more usual description of the model is presented.  It should\n   be\
    \ remembered that this may not be the only solution, and its\n   appropriateness\
    \ will depend both on the overall mobility model and\n   the distribution of the\
    \ times involved.  There is an implicit\n   assumption in this work that these\
    \ distributions can be characterized\n   by a normal-type distribution with a\
    \ well-defined first moment\n   (mean).  The exact form of the distribution is\
    \ not considered here,\n   but more detailed models may wish to use more specific\
    \ knowledge\n   about the distributions to refine the derivation of the parameters.\n\
    \   To characterize the model, we consider the following parameters:\n   P1  The\
    \ time resolution of the model.\n   P2  The average time between encounters between\
    \ nodes, I_typ, where\n       the identity of the nodes is not taken into account.\n\
    \   P3  The average number of encounters that a node has between meeting\n   \
    \    a particular node and meeting the same node again.\n   P4  The average number\
    \ of encounters needed to deliver a bundle in\n       this zone.\n   P5  The multiple\
    \ of the average number of encounters needed to\n       deliver a bundle (P4)\
    \ after which it can be assumed that a node\n       is not going to encounter\
    \ a particular node again in the\n       foreseeable future so that the delivery\
    \ predictability ought to\n       be decayed below P_first_threshold.\n   P6 \
    \ The number of encounters between a particular pair of nodes that\n       should\
    \ result in the delivery predictability of the encountered\n       node getting\
    \ close to the maximum possible delivery\n       predictability (1 - delta).\n\
    \   We can use these parameters to derive appropriate values for gamma\n   and\
    \ P_encounter_max, which are the key parameters in the evolution of\n   the delivery\
    \ predictabilities.  The values of the other parameters\n   P_encounter_first\
    \ (0.5), P_first_threshold (0.1), and delta (0.01),\n   with the default values\
    \ suggested in Figure 3, generally are not\n   specific to the mobility model,\
    \ although in special cases\n   P_encounter_first may be different if extra information\
    \ is available.\n   To select a value for gamma:\n   After a single, unrepeated\
    \ encounter, the delivery predictability of\n   the encountered node should decay\
    \ from P_encounter_first to\n   P_first_threshold in the expected time for P4\
    \ * P5 encounters.  Thus:\n   P_first_threshold = P_encounter_first * gamma ^\
    \ ((P2 * P4 * P5)/P1)\n   which can be rearranged as\n   gamma =\n   exp(ln(P_first_threshold/P_encounter_first)\
    \ * P1 / (P2* P4 * P5)).\n   Typical values of gamma will be less than 1, but\
    \ very close to 1\n   (usually greater than 0.99).  The value has to be stored\
    \ to several\n   decimal places of accuracy, but implementations can create a\
    \ table of\n   values for specific intervals to reduce the amount of on-the-fly\n\
    \   calculation required.\n   Selecting a value for P_encounter_max:\n   Once\
    \ gamma has been determined, the decay factor for the average time\n   between\
    \ encounters between a specific pair of nodes can be\n   calculated:\n   Decay_typ\
    \ = gamma ^ ((P2 * P3)/P1)\n   Starting with P_encounter_first, using Decay_typ\
    \ and applying\n   Equation 1 from Section 2.1.2 (P6 - 1) times, we can calculate\
    \ the\n   typical delivery predictability for the encountered node after P6\n\
    \   encounters.  The nature of Equation 1 is such that it is not easy to\n   produce\
    \ a closed form that generates a value of P_encounter_max from\n   the parameter\
    \ values, but using a spreadsheet to apply the equation\n   repeatedly and tabulate\
    \ the results will allow a suitable value of\n   P_encounter_max to be chosen\
    \ very simply.  The evolution is not very\n   sensitive to the value of P_encounter_max,\
    \ and values in the range\n   0.4 to 0.8 will generally be appropriate.  A value\
    \ of 0.7 is\n   recommended as a default.\n   Once a PRoPHET zone has been in\
    \ operation for some time, the logs of\n   the actual encounters can and should\
    \ be used to check that the\n   selected parameters were appropriate and to tune\
    \ them as necessary.\n   In the longer term, it may prove possible to install\
    \ a learning mode\n   in nodes so that the parameters can be adjusted dynamically\
    \ to\n   maintain best congruence with the mobility model that may itself\n  \
    \ change over time.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Anders F. Lindgren\n   Swedish Institute of Computer Science\n\
    \   Box 1263\n   Kista  SE-164 29\n   SE\n   Phone: +46707177269\n   EMail: andersl@sics.se\n\
    \   URI:   http://www.sics.se/~andersl\n   Avri Doria\n   Technicalities\n   Providence\
    \  RI\n   US\n   EMail: avri@acm.org\n   URI:   http://psg.com/~avri\n   Elwyn\
    \ Davies\n   Folly Consulting\n   Soham\n   UK\n   EMail: elwynd@folly.org.uk\n\
    \   Samo Grasic\n   Lulea University of Technology\n   Lulea  SE-971 87\n   SE\n\
    \   EMail: samo.grasic@ltu.se\n"
