- title: __initial_text__
  contents:
  - ''
- title: Internet Architecture Board (IAB)                              D. Thaler
  contents:
  - "Internet Architecture Board (IAB)                              D. Thaler\n  \
    \    IAB Thoughts on Encodings for Internationalized Domain Names\n"
- title: Abstract
  contents:
  - "Abstract\n   This document explores issues with Internationalized Domain Names\n\
    \   (IDNs) that result from the use of various encoding schemes such as\n   UTF-8\
    \ and the ASCII-Compatible Encoding produced by the Punycode\n   algorithm.  It\
    \ focuses on the importance of agreeing on a single\n   encoding and how complicated\
    \ the state of affairs ends up being as a\n   result of using different encodings\
    \ today.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Architecture Board (IAB)\n   and represents information that\
    \ the IAB has deemed valuable to\n   provide for permanent record.  Documents\
    \ approved for publication by\n   the IAB are not a candidate for any level of\
    \ Internet Standard; see\n   Section 2 of RFC 5741.\n   Information about the\
    \ current status of this document, any errata,\n   and how to provide feedback\
    \ on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6055.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  2\n     1.1.  APIs . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  8\n   2.  Use of Non-DNS Protocols . . . . . . . . . . . . . . .\
    \ . . . .  9\n   3.  Use of Non-ASCII in DNS  . . . . . . . . . . . . . . . .\
    \ . . . 10\n     3.1.  Examples . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . 14\n   4.  Recommendations  . . . . . . . . . . . . . . . . . . . . . .\
    \ . 16\n   5.  Security Considerations  . . . . . . . . . . . . . . . . . . .\
    \ 18\n   6.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 19\n\
    \   7.  IAB Members at the Time of Approval  . . . . . . . . . . . . . 19\n  \
    \ 8.  References . . . . . . . . . . . . . . . . . . . . . . . . . . 20\n    \
    \ 8.1.  Normative References . . . . . . . . . . . . . . . . . . . 20\n     8.2.\
    \  Informative References . . . . . . . . . . . . . . . . . . 20\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The goal of this document is to explore what can be learned\
    \ from some\n   current difficulties in implementing Internationalized Domain\
    \ Names\n   (IDNs).\n   A domain name consists of a sequence of labels, conventionally\n\
    \   written separated by dots.  An IDN is a domain name that contains one\n  \
    \ or more labels that, in turn, contain one or more non-ASCII\n   characters.\
    \  Just as with plain ASCII domain names, each IDN label\n   must be encoded using\
    \ some mechanism before it can be transmitted in\n   network packets, stored in\
    \ memory, stored on disk, etc.  These\n   encodings need to be reversible, but\
    \ they need not store domain names\n   the same way humans conventionally write\
    \ them on paper.  For example,\n   when transmitted over the network in DNS packets,\
    \ domain name labels\n   are *not* separated with dots.\n   Internationalized\
    \ Domain Names for Applications (IDNA), discussed\n   later in this document,\
    \ is the standard that defines the use and\n   coding of internationalized domain\
    \ names for use on the public\n   Internet [RFC5890].  An earlier version of IDNA\
    \ [RFC3490] is now\n   being phased out.  Except where noted, the two versions\
    \ are\n   approximately the same with regard to the issues discussed in this\n\
    \   document.  However, some explanations appeared in the earlier\n   documents\
    \ that were no longer considered useful when the later\n   revision was created;\
    \ they are quoted here from the documents in\n   which they appear.  In addition,\
    \ the terminology of the two versions\n   differ somewhat; this document reflects\
    \ the terminology of the\n   current version.\n   Unicode [Unicode] is a list\
    \ of characters (including non-spacing\n   marks that are used to form some other\
    \ characters), where each\n   character is assigned an integer value, called a\
    \ code point.  In\n   simple terms a Unicode string is a string of integer code\
    \ point\n   values in the range 0 to 1,114,111 (10FFFF in base 16).  These\n \
    \  integer code points must be encoded using some mechanism before they\n   can\
    \ be transmitted in network packets, stored in memory, stored on\n   disk, etc.\
    \  Some common ways of encoding these integer code point\n   values in computer\
    \ systems include UTF-8, UTF-16, and UTF-32.  In\n   addition to the material\
    \ below, those forms and the tradeoffs among\n   them are discussed in Chapter\
    \ 2 of The Unicode Standard [Unicode].\n   UTF-8 is a mechanism for encoding a\
    \ Unicode code point in a variable\n   number of 8-bit octets, where an ASCII\
    \ code point is preserved as-is.\n   Those octets encode a string of integer code\
    \ point values, which\n   represent a string of Unicode characters.  The authoritative\n\
    \   definition of UTF-8 is in Sections 3.9 and 3.10 of The Unicode\n   Standard\
    \ [Unicode], but a description of UTF-8 encoding can also be\n   found in RFC\
    \ 3629 [RFC3629].  Descriptions and formulae can also be\n   found in Annex D\
    \ of ISO/IEC 10646-1 [10646].\n   UTF-16 is a mechanism for encoding a Unicode\
    \ code point in one or two\n   16-bit integers, described in detail in Sections\
    \ 3.9 and 3.10 of The\n   Unicode Standard [Unicode].  A UTF-16 string encodes\
    \ a string of\n   integer code point values that represent a string of Unicode\n\
    \   characters.\n   UTF-32 (formerly UCS-4), also described in Sections 3.9 and\
    \ 3.10 of\n   The Unicode Standard [Unicode], is a mechanism for encoding a Unicode\n\
    \   code point in a single 32-bit integer.  A UTF-32 string is thus a\n   string\
    \ of 32-bit integer code point values, which represent a string\n   of Unicode\
    \ characters.\n   Note that UTF-16 results in some all-zero octets when code points\n\
    \   occur early in the Unicode sequence, and UTF-32 always has all-zero\n   octets.\n\
    \   IDNA specifies validity of a label, such as what characters it can\n   contain,\
    \ relationships among them, and so on, in Unicode terms.\n   Valid labels can\
    \ be in either \"U-label\" or \"A-label\" form, with the\n   appropriate one determined\
    \ by particular protocols or by context.\n   U-label form is a direct representation\
    \ of the Unicode characters\n   using one of the encoding forms discussed above.\
    \  This document\n   discusses UTF-8 strings in many places.  While all U-labels\
    \ can be\n   represented by UTF-8 strings, not all UTF-8 strings are valid\n \
    \  U-labels (see Section 2.3.2 of the IDNA Definitions document\n   [RFC5890]\
    \ for a discussion of these distinctions).  A-label form uses\n   a compressed,\
    \ ASCII-compatible encoding (an \"ACE\" in IDNA and other\n   terminology) produced\
    \ by an algorithm called Punycode.  U-labels and\n   A-labels are duals of each\
    \ other: transformations from one to the\n   other do not lose information.  The\
    \ transformation mechanisms are\n   specified in the IDNA Protocol document [RFC5891].\n\
    \   Punycode [RFC3492] is thus a mechanism for encoding a Unicode string\n   in\
    \ an ASCII-compatible encoding, i.e., using only letters, digits,\n   and hyphens\
    \ from the ASCII character set.  When a Unicode label that\n   is valid under\
    \ the IDNA rules (a U-label) is encoded with Punycode\n   for IDNA purposes, it\
    \ is prefixed with \"xn--\"; the result is called\n   an A-label.  The prefix\
    \ convention assumes that no other DNS labels\n   (at least no other DNS labels\
    \ in IDNA-aware applications) are allowed\n   to start with these four characters.\
    \  Consequently, when A-label\n   encoding is assumed, any DNS labels beginning\
    \ with \"xn--\" now have a\n   different meaning (the Punycode encoding of a label\
    \ containing one or\n   more non-ASCII characters) or no defined meaning at all\
    \ (in the case\n   of labels that are not IDNA-compliant, i.e., are not well-formed\n\
    \   A-labels).\n   ISO-2022-JP [RFC1468] is a mechanism for encoding a string\
    \ of ASCII\n   and Japanese characters, where an ASCII character is preserved\
    \ as-is.\n   ISO-2022-JP is stateful: special sequences are used to switch between\n\
    \   character coding tables.  As a result, if there are lost or mangled\n   characters\
    \ in a character stream, it is extremely difficult to\n   recover the original\
    \ stream after such a lost character encoding\n   shift.\n   Comparison of Unicode\
    \ strings is not as easy as comparing ASCII\n   strings.  First, there are a multitude\
    \ of ways to represent a string\n   of Unicode characters.  Second, in many languages\
    \ and scripts, the\n   actual definition of \"same\" is very context-dependent.\
    \  Because of\n   this, comparison of two Unicode strings must take into account\
    \ how\n   the Unicode strings are encoded.  Regardless of the encoding,\n   however,\
    \ comparison cannot simply be done by comparing the encoded\n   Unicode strings\
    \ byte by byte.  The only time that is possible is when\n   the strings are both\
    \ mapped into some canonical form and encoded the\n   same way.\n   In 1996 the\
    \ IAB sponsored a workshop on character sets and encodings\n   [RFC2130].  This\
    \ document adds to that discussion and focuses on the\n   importance of agreeing\
    \ on a single encoding and how complicated the\n   state of affairs ends up being\
    \ as a result of using different\n   encodings today.\n   Different applications,\
    \ APIs, and protocols use different encoding\n   schemes today.  Many of them\
    \ were originally defined to use only\n   ASCII.  Internationalizing Domain Names\
    \ in Applications (IDNA)\n   [RFC5890] defines a mechanism that requires changes\
    \ to applications,\n   but in an attempt not to change APIs or servers, specifies\
    \ that the\n   A-label format is to be used in many contexts.  In some ways this\n\
    \   could be seen as not changing the existing APIs, in the sense that\n   the\
    \ strings being passed to and from the APIs are still apparently\n   ASCII strings.\
    \  In other ways it is a very profound change to the\n   existing APIs, because\
    \ while those strings are still syntactically\n   valid ASCII strings, they no\
    \ longer mean the same thing that they\n   used to.  What looks like a plain ASCII\
    \ string to one piece of\n   software or library could be seen by another piece\
    \ of software or\n   library (with the application of out-of-band information)\
    \ to be in\n   fact an encoding of a Unicode string.\n   Section 1.3 of the original\
    \ IDNA specification [RFC3490] states:\n      The IDNA protocol is contained completely\
    \ within applications.  It\n      is not a client-server or peer-to-peer protocol:\
    \ everything is\n      done inside the application itself.  When used with a DNS\
    \ resolver\n      library, IDNA is inserted as a \"shim\" between the application\
    \ and\n      the resolver library.  When used for writing names into a DNS\n \
    \     zone, IDNA is used just before the name is committed to the zone.\n   Figure\
    \ 1 depicts a simplistic architecture that a naive reader might\n   assume from\
    \ the paragraph quoted above.  (A variant of this same\n   picture appears in\
    \ Section 6 of the original IDNA specification\n   [RFC3490], further strengthening\
    \ this assumption.)\n                +-----------------------------------------+\n\
    \                |Host                                     |\n               \
    \ |             +-------------+             |\n                |             |\
    \ Application |             |\n                |             +------+------+ \
    \            |\n                |                    |                    |\n\
    \                |               +----+----+               |\n               \
    \ |               |   DNS   |               |\n                |             \
    \  | Resolver|               |\n                |               | Library |  \
    \             |\n                |               +----+----+               |\n\
    \                |                    |                    |\n               \
    \ +-----------------------------------------+\n                              \
    \       |\n                            _________|_________\n                 \
    \          /                   \\\n                          /               \
    \      \\\n                         /                       \\\n             \
    \           |         Internet        |\n                         \\         \
    \              /\n                          \\                     /\n       \
    \                    \\___________________/\n                          Simplistic\
    \ Architecture\n                                 Figure 1\n   There are, however,\
    \ two problems with this simplistic architecture\n   that cause it to differ from\
    \ reality.\n   First, resolver APIs on Operating Systems (OSs) today (Mac OS,\n\
    \   Windows, Linux, etc.) are not DNS-specific.  They typically provide a\n  \
    \ layer of indirection so that the application can work independent of\n   the\
    \ name resolution mechanism, which could be DNS, mDNS\n   [DNS-MULTICAST], LLMNR\
    \ [RFC4795], NetBIOS-over-TCP\n   [RFC1001][RFC1002], hosts table [RFC0952], NIS\
    \ [NIS], or anything\n   else.  For example, \"Basic Socket Interface Extensions\
    \ for IPv6\"\n   [RFC3493] specifies the getaddrinfo() API and contains many phrases\n\
    \   like \"For example, when using the DNS\" and \"any type of name\n   resolution\
    \ service (for example, the DNS)\".  Importantly, DNS is\n   mentioned only as\
    \ an example, and the application has no knowledge as\n   to whether DNS or some\
    \ other protocol will be used.\n   Second, even with the DNS protocol, private\
    \ namespaces (sometimes\n   including private uses of the DNS) do not necessarily\
    \ use the same\n   character set encoding scheme as the public Internet namespace.\n\
    \   We will discuss each of the above issues in subsequent sections.  For\n  \
    \ reference, Figure 2 depicts a more realistic architecture on typical\n   hosts\
    \ today (which don't have IDNA inserted as a shim immediately\n   above the DNS\
    \ resolver library).  More generally, the host may be\n   attached to one or more\
    \ local networks, each of which may or may not\n   be connected to the public\
    \ Internet and may or may not have a private\n   namespace.\n                +-----------------------------------------+\n\
    \                |Host                                     |\n               \
    \ |             +-------------+             |\n                |             |\
    \ Application |             |\n                |             +------+------+ \
    \            |\n                |                    |                    |\n\
    \                |             +------+------+             |\n               \
    \ |             |   Generic   |             |\n                |             |\
    \    Name     |             |\n                |             |  Resolution | \
    \            |\n                |             |     API     |             |\n\
    \                |             +------+------+             |\n               \
    \ |                    |                    |\n                |   +-----+------+---+--+-------+-----+\
    \   |\n                |   |     |      |      |       |     |   |\n         \
    \       | +-+-++--+--++--+-++---+---++--+--++-+-+ |\n                | |DNS||LLMNR||mDNS||NetBIOS||hosts||...|\
    \ |\n                | +---++-----++----++-------++-----++---+ |\n           \
    \     |                                         |\n                +-----------------------------------------+\n\
    \                                     |\n                               ______|______\n\
    \                              /             \\\n                            \
    \ /               \\\n                            /      local      \\\n     \
    \                       \\     network     /\n                             \\\
    \               /\n                              \\_____________/\n          \
    \                           |\n                            _________|_________\n\
    \                           /                   \\\n                         \
    \ /                     \\\n                         /                       \\\
    \n                        |         Internet        |\n                      \
    \   \\                       /\n                          \\                 \
    \    /\n                           \\___________________/\n                  \
    \        Realistic Architecture\n                                 Figure 2\n"
- title: 1.1.  APIs
  contents:
  - "1.1.  APIs\n   Section 6.2 of the original IDNA specification [RFC3490] states\n\
    \   (where ToASCII and ToUnicode below refer to conversions using the\n   Punycode\
    \ algorithm):\n      It is expected that new versions of the resolver libraries\
    \ in the\n      future will be able to accept domain names in other charsets than\n\
    \      ASCII, and application developers might one day pass not only\n      domain\
    \ names in Unicode, but also in local script to a new API for\n      the resolver\
    \ libraries in the operating system.  Thus the ToASCII\n      and ToUnicode operations\
    \ might be performed inside these new\n      versions of the resolver libraries.\n\
    \   Resolver APIs such as getaddrinfo() and its predecessor\n   gethostbyname()\
    \ were defined to accept C-Language \"char *\" arguments,\n   meaning they accept\
    \ a string of bytes, terminated with a NULL (0)\n   byte.  Because of the use\
    \ of a NULL octet as a string terminator,\n   this is sufficient for ASCII strings\
    \ (including A-labels) and even\n   ISO-2022-JP [RFC1468] and UTF-8 strings (unless\
    \ an implementation\n   artificially precludes them), but not UTF-16 or UTF-32\
    \ strings\n   because a NULL octet could appear in the middle of strings using\n\
    \   these encodings.  Several operating systems historically used in\n   Japan\
    \ will accept (and expect) ISO-2022-JP strings in such APIs.\n   Some platforms\
    \ used worldwide also have new versions of the APIs\n   (e.g., GetAddrInfoW()\
    \ on Windows) that accept other encoding schemes\n   such as UTF-16.\n   It is\
    \ worth noting that an API using C-Language \"char *\" arguments\n   can distinguish\
    \ between conventional ASCII \"hostname\" labels,\n   A-labels, ISO-2022-JP, and\
    \ UTF-8 labels in names if the coding is\n   known to be one of those four, and\
    \ the label is intact (no lost or\n   mangled characters).  If a stateful encoding\
    \ like ISO-2022-JP is\n   used, applications extracting labels from text must\
    \ take special\n   precautions to be sure that the appropriate state-setting characters\n\
    \   are included in the string passed to the API.\n   An example method for distinguishing\
    \ among such codings is as\n   follows:\n   o  if the label contains an ESC (0x1B)\
    \ byte, the label is\n      ISO-2022-JP; otherwise,\n   o  if any byte in the\
    \ label has the high bit set, the label is UTF-8;\n      otherwise,\n   o  if\
    \ the label starts with \"xn--\", then it is presumed to be an\n      A-label;\
    \ otherwise,\n   o  the label is ASCII (and therefore, by definition, the label\
    \ is\n      also UTF-8, since ASCII is a subset of UTF-8).\n   Again this assumes\
    \ that ASCII labels never start with \"xn--\", and\n   also that UTF-8 strings\
    \ never contain an ESC character.  Also the\n   above is merely an illustration;\
    \ UTF-8 can be detected and\n   distinguished from other 8-bit encodings with\
    \ good accuracy [MJD].\n   It is more difficult or impossible to distinguish the\
    \ ISO 8859\n   character sets [ISO8859] from each other, because they differ in\
    \ up\n   to about 90 characters that have exactly the same encodings, and a\n\
    \   short string is very unlikely to contain enough characters to allow a\n  \
    \ receiver to deduce the character set.  Similarly, it is not possible\n   in\
    \ general to distinguish between ISO-2022-JP and any other encoding\n   based\
    \ on ISO 2022 code table switching.\n   Although it is possible (as in the example\
    \ above) to distinguish some\n   encodings when not explicitly specified, it is\
    \ cleaner to have the\n   encodings specified explicitly, such as specifying UTF-16\
    \ for\n   GetAddrInfoW(), or specifying explicitly which APIs expect UTF-8\n \
    \  strings.\n"
- title: 2.  Use of Non-DNS Protocols
  contents:
  - "2.  Use of Non-DNS Protocols\n   As noted earlier, typical name resolution libraries\
    \ are not\n   DNS-specific.  Furthermore, some protocols are defined to use\n\
    \   encoding forms other than IDNA A-labels.  For example, mDNS\n   [DNS-MULTICAST]\
    \ specifies that UTF-8 be used.  Indeed, the IETF\n   policy on character sets\
    \ and languages [RFC2277] (which followed the\n   1996 IAB-sponsored workshop\
    \ [RFC2130]) states:\n      Protocols MUST be able to use the UTF-8 charset, which\
    \ consists of\n      the ISO 10646 coded character set combined with the UTF-8\n\
    \      character encoding scheme, as defined in [10646] Annex R\n      (published\
    \ in Amendment 2), for all text.\n      Protocols MAY specify, in addition, how\
    \ to use other charsets or\n      other character encoding schemes for ISO 10646,\
    \ such as UTF-16,\n      but lack of an ability to use UTF-8 is a violation of\
    \ this policy;\n      such a violation would need a variance procedure ([BCP9]\
    \ section\n      9) with clear and solid justification in the protocol\n     \
    \ specification document before being entered into or advanced upon\n      the\
    \ standards track.\n      For existing protocols or protocols that move data from\
    \ existing\n      datastores, support of other charsets, or even using a default\n\
    \      other than UTF-8, may be a requirement.  This is acceptable, but\n    \
    \  UTF-8 support MUST be possible.\n   Applications that convert an IDN to A-label\
    \ form before calling\n   getaddrinfo() will result in name resolution failures\
    \ if the Punycode\n   name is directly used in such protocols.  Having libraries\
    \ or\n   protocols to convert from A-labels to the encoding scheme defined by\n\
    \   the protocol (e.g., UTF-8) would require changes to APIs and/or\n   servers,\
    \ which IDNA was intended to avoid.\n   As a result, applications that assume\
    \ that non-ASCII names are\n   resolved using the public DNS and blindly convert\
    \ them to A-labels\n   without knowledge of what protocol will be selected by\
    \ the name\n   resolution library, have problems.  Furthermore, name resolution\n\
    \   libraries often try multiple protocols until one succeeds, because\n   they\
    \ are defined to use a common namespace.  For example, the hosts\n   file [RFC0952],\
    \ NetBIOS-over-TCP [RFC1001], and DNS [RFC1034], are\n   all defined to be able\
    \ to share a common syntax.  This means that\n   when an application passes a\
    \ name to be resolved, resolution may in\n   fact be attempted using multiple\
    \ protocols, each with a potentially\n   different encoding scheme.  For this\
    \ to work successfully, the name\n   must be converted to the appropriate encoding\
    \ scheme only after the\n   choice is made to use that protocol.  In general,\
    \ this cannot be done\n   by the application since the choice of protocol is not\
    \ made by the\n   application.\n"
- title: 3.  Use of Non-ASCII in DNS
  contents:
  - "3.  Use of Non-ASCII in DNS\n   A common misconception is that DNS only supports\
    \ names that can be\n   expressed using letters, digits, and hyphens.\n   This\
    \ misconception originally stems from the 1985 definition of an\n   \"Internet\
    \ hostname\" (and net, gateway, and domain name) for use in\n   the \"hosts\"\
    \ file [RFC0952].  An Internet hostname was defined therein\n   as including only\
    \ letters, digits, and hyphens, where uppercase and\n   lowercase letters were\
    \ to be treated as identical.  The DNS\n   specification [RFC1034], Section 3.5\
    \ entitled \"Preferred name syntax\"\n   then repeated this definition in 1987,\
    \ saying that this \"syntax will\n   result in fewer problems with many applications\
    \ that use domain names\n   (e.g., mail, TELNET)\".\n   The confusion was thus\
    \ left as to whether the \"preferred\" name syntax\n   was a mandatory restriction\
    \ in DNS, or merely \"preferred\".\n   The definition of an Internet hostname\
    \ was updated in 1989\n   ([RFC1123], Section 2.1) to allow names starting with\
    \ a digit.\n   However, it did not address the increasing confusion as to whether\n\
    \   all names in DNS are \"hostnames\", or whether a \"hostname\" is merely a\n\
    \   special case of a DNS name.\n   By 1997, things had progressed to a state\
    \ where it was necessary to\n   clarify these areas of confusion.  \"Clarifications\
    \ to the DNS\n   Specification\" [RFC2181], Section 11 states:\n      The DNS\
    \ itself places only one restriction on the particular\n      labels that can\
    \ be used to identify resource records.  That one\n      restriction relates to\
    \ the length of the label and the full name.\n      The length of any one label\
    \ is limited to between 1 and 63 octets.\n      A full domain name is limited\
    \ to 255 octets (including the\n      separators).  The zero length full name\
    \ is defined as representing\n      the root of the DNS tree, and is typically\
    \ written and displayed\n      as \".\".  Those restrictions aside, any binary\
    \ string whatever can\n      be used as the label of any resource record.  Similarly,\
    \ any\n      binary string can serve as the value of any record that includes\
    \ a\n      domain name as some or all of its value (SOA, NS, MX, PTR, CNAME,\n\
    \      and any others that may be added).  Implementations of the DNS\n      protocols\
    \ must not place any restrictions on the labels that can\n      be used.\n   Hence,\
    \ it clarified that the restriction to letters, digits, and\n   hyphens does not\
    \ apply to DNS names in general, nor to records that\n   include \"domain names\"\
    .  Hence, the \"preferred\" name syntax described\n   in the original DNS specification\
    \ [RFC1034] is indeed merely\n   \"preferred\", not mandatory.\n   Since there\
    \ is no restriction even to ASCII, let alone letter-digit-\n   hyphen use, DNS\
    \ does not violate the subsequent IETF requirement to\n   allow UTF-8 [RFC2277].\n\
    \   Using UTF-16 or UTF-32 encoding, however, would not be ideal for use\n   in\
    \ DNS packets or C-Language \"char *\" APIs because existing software\n   already\
    \ uses ASCII, and UTF-16 and UTF-32 strings can contain\n   all-zero octets that\
    \ existing software will interpret as the end of\n   the string.  To use UTF-16\
    \ or UTF-32, one would need some way of\n   knowing whether the string was encoded\
    \ using ASCII, UTF-16, or\n   UTF-32, and indeed for UTF-16 or UTF-32 whether\
    \ it was big-endian or\n   little-endian encoding.  In contrast, UTF-8 works well\
    \ because any\n   7-bit ASCII string is also a UTF-8 string representing the same\n\
    \   characters.\n   If a private namespace is defined to use UTF-8 (and not other\n\
    \   encodings such as UTF-16 or UTF-32), there's no need for a mechanism\n   to\
    \ know whether a string was encoded using ASCII or UTF-8, because\n   (for any\
    \ string that can be represented using ASCII) the\n   representations are exactly\
    \ the same.  In other words, for any string\n   that can be represented using\
    \ ASCII, it doesn't matter whether it is\n   interpreted as ASCII or UTF-8 because\
    \ both encodings are the same,\n   and for any string that can't be represented\
    \ using ASCII, it's\n   obviously UTF-8.  In addition, unlike UTF-16 and UTF-32,\
    \ ASCII and\n   UTF-8 are both byte-oriented encodings so the question of big-endian\n\
    \   or little-endian encoding doesn't apply.\n   While implementations of the\
    \ DNS protocol must not place any\n   restrictions on the labels that can be used,\
    \ applications that use\n   the DNS are free to impose whatever restrictions they\
    \ like, and many\n   have.  The above rules permit a domain name label that contains\n\
    \   unusual characters, such as embedded spaces, which many applications\n   consider\
    \ a bad idea.  For example, the original specification\n   [RFC0821] of the SMTP\
    \ protocol [RFC5321] constrains the character set\n   usable in email addresses.\
    \  There is now an effort underway to define\n   an extension to SMTP to support\
    \ internationalized email addresses and\n   headers.  See the EAI framework [RFC4952]\
    \ for more discussion on this\n   topic.\n   Shortly after the DNS Clarifications\
    \ [RFC2181] and IETF character\n   sets and languages policy [RFC2277] were published,\
    \ the need for\n   internationalized names within private namespaces (i.e., within\n\
    \   enterprises) arose.  The current (and past, predating IDNA and the\n   prefixed\
    \ ACE conventions) practice within enterprises that support\n   other languages\
    \ is to put UTF-8 names in their internal DNS servers\n   in a private namespace.\
    \  For example, \"Using the UTF-8 Character Set\n   in the Domain Name System\"\
    \ [UTF8-DNS] was first written in 1997, and\n   was then widely deployed in Windows.\
    \  The use of UTF-8 names in DNS\n   was similarly implemented and deployed in\
    \ Mac OS, simply by virtue of\n   the fact that applications blindly passed UTF-8\
    \ strings to the name\n   resolution APIs, the name resolution APIs blindly passed\
    \ those UTF-8\n   strings to the DNS servers, and the DNS servers correctly answered\n\
    \   those queries.  From the user's point of view, everything worked\n   properly\
    \ without any special new code being written, except that\n   ASCII is matched\
    \ case-insensitively whereas UTF-8 is not (although\n   some enterprise DNS servers\
    \ reportedly attempt to do case-insensitive\n   matching on UTF-8 within private\
    \ namespaces, an action that causes\n   other problems and violates a subsequent\
    \ prohibition [RFC4343]).\n   Within a private namespace, and especially in light\
    \ of the IETF UTF-8\n   policy [RFC2277], it was reasonable to assume that binary\
    \ strings\n   were encoded in UTF-8.\n   As implied earlier, there are also issues\
    \ with mapping strings to\n   some canonical form, independent of the encoding.\
    \  Such issues are\n   not discussed in detail in this document.  They are discussed\
    \ to some\n   extent in, for example, Section 3 of \"Unicode Format for Network\n\
    \   Interchange\" [RFC5198], and are left as opportunities for elaboration\n \
    \  in other documents.\n   A few years after UTF-8 was already in use in private\
    \ namespaces in\n   DNS, the strategy of using a reserved prefix and an ASCII-compatible\n\
    \   encoding (ACE) was developed for IDNA.  That strategy included the\n   Punycode\
    \ algorithm, which began to be developed (during the period\n   from 2002 [IDN-PUNYCODE]\
    \ to 2003 [RFC3492]) for use in the public DNS\n   namespace.  There were a number\
    \ of reasons for this.  One such reason\n   the prefixed ACE strategy was selected\
    \ for the public DNS namespace\n   had to do with the fact that other encodings\
    \ such as ISO 8859-1 were\n   also in use in DNS and the various encodings were\
    \ not necessarily\n   distinguishable from each other.  Another reason had to\
    \ do with\n   concerns about whether the details of IDNA, including the use of\
    \ the\n   Punycode algorithm, were an adequate solution to the problems that\n\
    \   were posed.  If either the Punycode algorithm or fundamental aspects\n   of\
    \ character handling were wrong, and had to be changed to something\n   incompatible,\
    \ it would be possible to switch to a new prefix or adopt\n   another model entirely.\
    \  Only the part of the public DNS namespace\n   that starts a label with \"xn--\"\
    \ would be polluted.\n   Today the algorithm is seen as being about as good as\
    \ it can\n   realistically be, so moving to a different encoding (UTF-8 as\n \
    \  suggested in this document) that can be viewed as \"native\" would not\n  \
    \ be as risky as it would have been in 2002.\n   In any case, the publication\
    \ of Punycode [RFC3492] and the\n   dependencies on it in the IDNA Protocol document\
    \ [RFC5891] and the\n   earlier IDNA specification [RFC3490] thus resulted in\
    \ having to use\n   different encodings for different namespaces (where UTF-8\
    \ for private\n   namespaces was already deployed).  Hence, referring back to\
    \ Figure 2,\n   a different encoding scheme may be in use on the Internet vs.\
    \ a local\n   network.\n   In general, a host may be connected to zero or more\
    \ networks using\n   private namespaces, plus potentially the public namespace.\n\
    \   Applications that convert a U-label form IDN to an A-label before\n   calling\
    \ getaddrinfo() will incur name resolution failures if the name\n   is actually\
    \ registered in a private namespace in some other encoding\n   (e.g., UTF-8).\
    \  Having libraries or protocols convert from A-labels\n   to the encoding used\
    \ by a private namespace (e.g., UTF-8) would\n   require changes to APIs and/or\
    \ servers, which IDNA was intended to\n   avoid.\n   Also, a fully-qualified domain\
    \ name (FQDN) to be resolved may be\n   obtained directly from an application,\
    \ or it may be composed by the\n   DNS resolver itself from a single label obtained\
    \ from an application\n   by using a configured suffix search list, and the resulting\
    \ FQDN may\n   use multiple encodings in different labels.  For more information\
    \ on\n   the suffix search list, see Section 6 of \"Common DNS Implementation\n\
    \   Errors and Suggested Fixes\" [RFC1536], the DHCP Domain Search Option\n  \
    \ [RFC3397], and Section 4 of \"DNS Configuration options for DHCPv6\"\n   [RFC3646].\n\
    \   As noted in Section 6 of \"Common DNS Implementation Errors and\n   Suggested\
    \ Fixes\" [RFC1536], the community has had bad experiences\n   (e.g., security\
    \ problems [RFC1535]) with \"searching\" for domain names\n   by trying multiple\
    \ variations or appending different suffixes.  Such\n   searching can yield inconsistent\
    \ results depending on the order in\n   which alternatives are tried.  Nonetheless,\
    \ the practice is\n   widespread and must be considered.\n   The practice of searching\
    \ for names, whether by the use of a suffix\n   search list or by searching in\
    \ different namespaces, can yield\n   inconsistent results.  For example, even\
    \ when a suffix search list is\n   only used when an application provides a name\
    \ containing no dots, two\n   clients with different configured suffix search\
    \ lists can get\n   different answers, and the same client could get different\
    \ answers at\n   different times if it changes its configuration (e.g., when moving\
    \ to\n   another network).  A deeper discussion of this topic is outside the\n\
    \   scope of this document.\n"
- title: 3.1.  Examples
  contents:
  - "3.1.  Examples\n   Some examples of cases that can happen in existing implementations\n\
    \   today (where {non-ASCII} below represents some user-entered non-ASCII\n  \
    \ string) are:\n   o  User types in {non-ASCII}.{non-ASCII}.com, and the application\n\
    \      passes it, in the form of a UTF-8 string, to getaddrinfo() or\n      gethostbyname()\
    \ or equivalent.\n      1.  The DNS resolver passes the (UTF-8) string unmodified\
    \ to a DNS\n          server.\n   o  User types in {non-ASCII}.{non-ASCII}.com,\
    \ and the application\n      passes it to a name resolution API that accepts strings\
    \ in some\n      other encoding such as UTF-16, e.g., GetAddrInfoW() on Windows.\n\
    \      1.  The name resolution API decides to pass the string to DNS (and\n  \
    \        possibly other protocols).\n      2.  The DNS resolver converts the name\
    \ from UTF-16 to UTF-8 and\n          passes the query to a DNS server.\n   o\
    \  User types in {non-ASCII}.{non-ASCII}.com, but the application\n      first\
    \ converts it to A-label form such that the name that is\n      passed to name\
    \ resolution APIs is (say)\n      xn--e1afmkfd.xn--80akhbyknj4f.com.\n      1.\
    \  The name resolution API decides to pass the string to DNS (and\n          possibly\
    \ other protocols).\n      2.  The DNS resolver passes the string unmodified to\
    \ a DNS server.\n      3.  If the name is not found in DNS, the name resolution\
    \ API\n          decides to try another protocol, say mDNS.\n      4.  The query\
    \ goes out in mDNS, but since mDNS specified that\n          names are to be registered\
    \ in UTF-8, the name isn't found\n          since it was encoded as an A-label\
    \ in the query.\n   o  User types in {non-ASCII}, and the application passes it,\
    \ in the\n      form of a UTF-8 string, to getaddrinfo() or equivalent.\n    \
    \  1.  The name resolution API decides to pass the string to DNS (and\n      \
    \    possibly other protocols).\n      2.  The DNS resolver will append suffixes\
    \ in the suffix search\n          list, which may contain UTF-8 characters if\
    \ the local network\n          uses a private namespace.\n      3.  Each FQDN\
    \ in turn will then be sent in a query to a DNS\n          server, until one succeeds.\n\
    \   o  User types in {non-ASCII}, but the application first converts it\n    \
    \  to an A-label, such that the name that is passed to getaddrinfo()\n      or\
    \ equivalent is (say) xn--e1afmkfd.\n      1.  The name resolution API decides\
    \ to pass the string to DNS (and\n          possibly other protocols).\n     \
    \ 2.  The DNS stub resolver will append suffixes in the suffix\n          search\
    \ list, which may contain UTF-8 characters if the local\n          network uses\
    \ a private namespace, resulting in (say)\n          xn--e1afmkfd.{non-ASCII}.com\n\
    \      3.  Each FQDN in turn will then be sent in a query to a DNS\n         \
    \ server, until one succeeds.\n      4.  Since the private namespace in this case\
    \ uses UTF-8, the above\n          queries fail, since the A-label version of\
    \ the name was not\n          registered in that namespace.\n   o  User types\
    \ in {non-ASCII1}.{non-ASCII2}.{non-ASCII3}.com, where\n      {non-ASCII3}.com\
    \ is a public namespace using IDNA and A-labels,\n      but {non-ASCII2}.{non-ASCII3}.com\
    \ is a private namespace using\n      UTF-8, which is accessible to the user.\
    \  The application passes\n      the name, in the form of a UTF-8 string, to getaddrinfo()\
    \ or\n      equivalent.\n      1.  The name resolution API decides to pass the\
    \ string to DNS (and\n          possibly other protocols).\n      2.  The DNS\
    \ resolver tries to locate the authoritative server, but\n          fails the\
    \ lookup because it cannot find a server for the UTF-8\n          encoding of\
    \ {non-ASCII3}.com, even though it would have access\n          to the private\
    \ namespace.  (To make this work, the private\n          namespace would need\
    \ to include the UTF-8 encoding of\n          {non-ASCII3}.com.)\n   When users\
    \ use multiple applications, some of which do A-label\n   conversion prior to\
    \ passing a name to name resolution APIs, and some\n   of which do not, odd behavior\
    \ can result which at best violates the\n   Principle of Least Surprise, and at\
    \ worst can result in security\n   vulnerabilities.\n   First consider two competing\
    \ applications, such as web browsers, that\n   are designed to achieve the same\
    \ task.  If the user types the same\n   name into each browser, one may successfully\
    \ resolve the name (and\n   hence access the desired content) because the encoding\
    \ scheme is\n   correct, while the other may fail name resolution because the\n\
    \   encoding scheme is incorrect.  Hence the issue can incent users to\n   switch\
    \ to another application (which in some cases means switching to\n   an IDNA application,\
    \ and in other cases means switching away from an\n   IDNA application).\n   Next\
    \ consider two separate applications where one is designed to be\n   launched\
    \ from the other, for example a web browser launching a media\n   player application\
    \ when the link to a media file is clicked.  If both\n   types of content (web\
    \ pages and media files in this example) are\n   hosted at the same IDN in a private\
    \ namespace, but one application\n   converts to A-labels before calling name\
    \ resolution APIs and the\n   other does not, the user may be able to access a\
    \ web page, click on\n   the media file causing the media player to launch and\
    \ attempt to\n   retrieve the media file, which will then fail because the IDN\n\
    \   encoding scheme was incorrect.  Or even worse, if an attacker is able\n  \
    \ to register the same name in the other encoding scheme, the user may\n   get\
    \ the content from the attacker's machine.  This is similar to a\n   normal phishing\
    \ attack, except that the two names represent exactly\n   the same Unicode characters.\n"
- title: 4.  Recommendations
  contents:
  - "4.  Recommendations\n   On many platforms, the name resolution library will automatically\
    \ use\n   a variety of protocols to search a variety of namespaces, which might\n\
    \   be using UTF-8 or other encodings.  In addition, even when only the\n   DNS\
    \ protocol is used, in many operational environments, a private DNS\n   namespace\
    \ using UTF-8 is also deployed and is automatically searched\n   by the name resolution\
    \ library.\n   As explained earlier, using multiple canonical formats, and multiple\n\
    \   encodings in different protocols or even in different places in the\n   same\
    \ namespace creates problems.  Because of this, and the fact that\n   both IDNA\
    \ A-labels and UTF-8 are in use as encoding mechanisms for\n   domain names today,\
    \ we make the recommendations described below.\n   It is inappropriate for an\
    \ application that calls a general-purpose\n   name resolution library to convert\
    \ a name to an A-label unless the\n   application is absolutely certain that,\
    \ in all environments where the\n   application might be used, only the global\
    \ DNS that uses IDNA\n   A-labels actually will be used to resolve the name.\n\
    \   Instead, conversion to A-label form, or any other special encoding\n   required\
    \ by a particular name-lookup protocol, should be done only by\n   an entity that\
    \ knows which protocol will be used (e.g., the DNS\n   resolver, or getaddrinfo()\
    \ upon deciding to pass the name to DNS),\n   rather than by general applications\
    \ that call protocol-independent\n   name resolution APIs.  (Of course, applications\
    \ that store strings\n   internally in a different format than that required by\
    \ those APIs,\n   need to convert strings from their own internal format to the\
    \ format\n   required by the API.)  Similarly, even if an application can know\n\
    \   that DNS is to be used, the conversion to A-labels should be done\n   only\
    \ by an entity that knows which part of the DNS namespace will be\n   used.\n\
    \   That is, a more intelligent DNS resolver would be more liberal in\n   what\
    \ it would accept from an application and be able to query for\n   both a name\
    \ in A-label form (e.g., over the Internet) and a UTF-8\n   name (e.g., over a\
    \ corporate network with a private namespace) in\n   case the server only recognizes\
    \ one.  However, we might also take\n   into account that the various resolution\
    \ behaviors discussed earlier\n   could also occur with record updates (e.g.,\
    \ with Dynamic Update\n   [RFC2136]), resulting in some names being registered\
    \ in a local\n   network's private namespace by applications doing conversion\
    \ to\n   A-labels, and other names being registered using UTF-8.  Hence, a\n \
    \  name might have to be queried with both encodings to be sure to\n   succeed\
    \ without changes to DNS servers.\n   Similarly, a more intelligent stub resolver\
    \ would also be more\n   liberal in what it would accept from a response as the\
    \ value of a\n   record (e.g., PTR) in that it would accept either UTF-8 (U-labels\
    \ in\n   the case of IDNA) or A-labels and convert them to whatever encoding\n\
    \   is used by the application APIs to return strings to applications.\n   Indeed\
    \ the choice of conversion within the resolver libraries is\n   consistent with\
    \ the quote from Section 6.2 of the original IDNA\n   specification [RFC3490]\
    \ stating that conversion using the Punycode\n   algorithm (i.e., to A-labels)\
    \ \"might be performed inside these new\n   versions of the resolver libraries\"\
    .\n   That said, some application-layer protocols (e.g., EPP Domain Name\n   Mapping\
    \ [RFC5731]) are defined to use A-labels rather than simply\n   using UTF-8 as\
    \ recommended by the IETF character sets and languages\n   policy [RFC2277]. \
    \ In this case, an application may receive a string\n   containing A-labels and\
    \ want to pass it to name resolution APIs.\n   Again the recommendation that a\
    \ resolver library be more liberal in\n   what it would accept from an application\
    \ would mean that such a name\n   would be accepted and re-encoded as needed,\
    \ rather than requiring the\n   application to do so.\n   It is important that\
    \ any APIs used by applications to pass names\n   specify what encoding(s) the\
    \ API uses.  For example, GetAddrInfoW()\n   on Windows specifies that it accepts\
    \ UTF-16 and only UTF-16.  In\n   contrast, the original specification of getaddrinfo()\
    \ [RFC3493] does\n   not, and hence platforms vary in what they use (e.g., Mac\
    \ OS uses\n   UTF-8 whereas Windows uses Windows code pages).\n   Finally, the\
    \ question remains about what, if anything, a DNS server\n   should do to handle\
    \ cases where some existing applications or hosts\n   do IDNA queries using A-labels\
    \ within the local network using a\n   private namespace, and other existing applications\
    \ or hosts send\n   UTF-8 queries.  It is undesirable to store different records\
    \ for\n   different encodings of the same name, since this introduces the\n  \
    \ possibility for inconsistency between them.  Instead, a new DNS\n   server serving\
    \ a private namespace using UTF-8 could potentially\n   treat encoding-conversion\
    \ in the same way as case-insensitive\n   comparison which a DNS server is already\
    \ required to do, as long the\n   DNS server has some way to know what the encoding\
    \ is.  Two encodings\n   are, in this sense, two representations of the same name,\
    \ just as two\n   case-different strings are.  However, whereas case comparison\
    \ of\n   non-ASCII characters is complicated by ambiguities (as explained in\n\
    \   the IAB's Review and Recommendations for Internationalized Domain\n   Names\
    \ [RFC4690]), encoding conversion between A-labels and U-labels\n   is unambiguous.\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   Having applications convert names to prefixed\
    \ ACE format (A-labels)\n   before calling name resolution can result in security\n\
    \   vulnerabilities.  If the name is resolved by protocols or in zones\n   for\
    \ which records are registered using other encoding schemes, an\n   attacker can\
    \ claim the A-label version of the same name and hence\n   trick the victim into\
    \ accessing a different destination.  This can be\n   done for any non-ASCII name,\
    \ even when there is no possible confusion\n   due to case, language, or other\
    \ issues.  Other types of confusion\n   beyond those resulting simply from the\
    \ choice of encoding scheme are\n   discussed in \"Review and Recommendations\
    \ for IDNs\" [RFC4690].\n   Designers and users of encodings that represent Unicode\
    \ strings in\n   terms of ASCII should also consider whether trademark protection\
    \ or\n   phishing are issues, e.g., if one name would be encoded in a way that\n\
    \   would be naturally associated with another organization or product.\n"
- title: 6.  Acknowledgements
  contents:
  - "6.  Acknowledgements\n   The authors wish to thank Patrik Faltstrom, Martin Duerst,\
    \ JFC\n   Morfin, Ran Atkinson, S. Moonesamy, Paul Hoffman, and Stephane\n   Bortzmeyer\
    \ for their careful review and helpful suggestions.  It is\n   also interesting\
    \ to note that none of the first three individuals'\n   names above can be spelled\
    \ out and written correctly in ASCII text.\n   Furthermore, one of the IAB member's\
    \ names below (Andrei Robachevsky)\n   cannot be written in the script as it appears\
    \ on his birth\n   certificate.\n"
- title: 7.  IAB Members at the Time of Approval
  contents:
  - "7.  IAB Members at the Time of Approval\n   Bernard Aboba\n   Marcelo Bagnulo\n\
    \   Ross Callon\n   Spencer Dawkins\n   Vijay Gill\n   Russ Housley\n   John Klensin\n\
    \   Olaf Kolkman\n   Danny McPherson\n   Jon Peterson\n   Andrei Robachevsky\n\
    \   Dave Thaler\n   Hannes Tschofenig\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [10646]          International Organization for\
    \ Standardization,\n                    \"Information Technology - Universal Multiple-octet\n\
    \                    coded Character Set (UCS)\".\n                    ISO/IEC\
    \ Standard 10646, comprised of ISO/IEC 10646-\n                    1:2000, \"\
    Information technology -- Universal\n                    Multiple-Octet Coded\
    \ Character Set (UCS) -- Part 1:\n                    Architecture and Basic Multilingual\
    \ Plane\", ISO/IEC\n                    10646-2:2001, \"Information technology\
    \ -- Universal\n                    Multiple-Octet Coded Character Set (UCS) --\
    \ Part 2:\n                    Supplementary Planes\" and ISO/IEC 10646- 1:2000/Amd\n\
    \                    1:2002, \"Mathematical symbols and other characters\".\n\
    \   [Unicode]        The Unicode Consortium.  The Unicode Standard,\n        \
    \            Version 5.1.0, defined by: \"The Unicode Standard,\n            \
    \        Version 5.0\", Boston, MA, Addison-Wesley, 2007, ISBN\n             \
    \       0-321-48091-0, as amended by Unicode 5.1.0\n                    (http://www.unicode.org/versions/Unicode5.1.0/).\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [DNS-MULTICAST]  Cheshire, S. and M. Krochmal,\
    \ \"Multicast DNS\", Work\n                    in Progress, February 2011.\n \
    \  [IDN-PUNYCODE]   Costello, A., \"Punycode version 0.3.3\", Work\n         \
    \           in Progress, January 2002.\n   [ISO8859]        International Organization\
    \ for Standardization,\n                    \"Information technology -- 8-bit\
    \ single-byte coded\n                    graphic character sets\".\n         \
    \           ISO/IEC Standard 8859, comprised of ISO/IEC 8859-\n              \
    \      1:1998, Part 1: Latin alphabet No. 1 - ISO/IEC 8859-\n                \
    \    2:1999, Part 2: Latin alphabet No. 2 - ISO/IEC 8859-\n                  \
    \  3:1999, Part 3: Latin alphabet No. 3 - ISO/IEC 8859-\n                    4:1998,\
    \ Part 4: Latin alphabet No. 4 - ISO/IEC 8859-\n                    5:1999, Part\
    \ 5: Latin/Cyrillic alphabet - ISO/IEC\n                    8859-6:1999, Part\
    \ 6: Latin/Arabic alphabet - ISO/IEC\n                    8859-7:2003, Part 7:\
    \ Latin/Greek alphabet - ISO/IEC\n                    8859-8:1999, Part 8: Latin/Hebrew\
    \ alphabet - ISO/IEC\n                    8859-9:1999, Part 9: Latin alphabet\
    \ No. 5 - ISO/IEC\n                    8859-10:1998, Part 10: Latin alphabet No.\
    \ 6 - ISO/\n                    IEC 8859-11:2001, Part 11: Latin/Thai alphabet\
    \ -\n                    ISO/IEC 8859-13:1998, Part 13: Latin alphabet No. 7\n\
    \                    - ISO/IEC 8859-14:1998, Part 14: Latin alphabet No.\n   \
    \                 8 (Celtic) - ISO/IEC 8859-15:1999, Part 15: Latin\n        \
    \            alphabet No. 9 - ISO/IEC 8859-16:2001, Part 16:\n               \
    \     Latin alphabet No. 10.\n   [MJD]            Duerst, M., \"The Properties\
    \ and Promizes of UTF-8\",\n                    11th International Unicode Conference,\
    \ San Jose ,\n                    September 1997, <http://www.ifi.unizh.ch/mml/\n\
    \                    mduerst/papers/PDF/IUC11-UTF-8.pdf>.\n   [NIS]          \
    \  Sun Microsystems, \"System and Network\n                    Administration\"\
    , March 1990.\n   [RFC0821]        Postel, J., \"Simple Mail Transfer Protocol\"\
    , STD 10,\n                    RFC 821, August 1982.\n   [RFC0952]        Harrenstien,\
    \ K., Stahl, M., and E. Feinler, \"DoD\n                    Internet host table\
    \ specification\", RFC 952,\n                    October 1985.\n   [RFC1001] \
    \       NetBIOS Working Group, \"Protocol standard for a\n                   \
    \ NetBIOS service on a TCP/UDP transport: Concepts and\n                    methods\"\
    , STD 19, RFC 1001, March 1987.\n   [RFC1002]        NetBIOS Working Group, \"\
    Protocol standard for a\n                    NetBIOS service on a TCP/UDP transport:\
    \ Detailed\n                    specifications\", STD 19, RFC 1002, March 1987.\n\
    \   [RFC1034]        Mockapetris, P., \"Domain names - concepts and\n        \
    \            facilities\", STD 13, RFC 1034, November 1987.\n   [RFC1123]    \
    \    Braden, R., \"Requirements for Internet Hosts -\n                    Application\
    \ and Support\", STD 3, RFC 1123,\n                    October 1989.\n   [RFC1468]\
    \        Murai, J., Crispin, M., and E. van der Poel,\n                    \"\
    Japanese Character Encoding for Internet Messages\",\n                    RFC\
    \ 1468, June 1993.\n   [RFC1535]        Gavron, E., \"A Security Problem and Proposed\n\
    \                    Correction With Widely Deployed DNS Software\",\n       \
    \             RFC 1535, October 1993.\n   [RFC1536]        Kumar, A., Postel,\
    \ J., Neuman, C., Danzig, P., and\n                    S. Miller, \"Common DNS\
    \ Implementation Errors and\n                    Suggested Fixes\", RFC 1536,\
    \ October 1993.\n   [RFC2130]        Weider, C., Preston, C., Simonsen, K., Alvestrand,\n\
    \                    H., Atkinson, R., Crispin, M., and P. Svanberg, \"The\n \
    \                   Report of the IAB Character Set Workshop held 29\n       \
    \             February - 1 March, 1996\", RFC 2130, April 1997.\n   [RFC2136]\
    \        Vixie, P., Thomson, S., Rekhter, Y., and J. Bound,\n                \
    \    \"Dynamic Updates in the Domain Name System (DNS\n                    UPDATE)\"\
    , RFC 2136, April 1997.\n   [RFC2181]        Elz, R. and R. Bush, \"Clarifications\
    \ to the DNS\n                    Specification\", RFC 2181, July 1997.\n   [RFC2277]\
    \        Alvestrand, H., \"IETF Policy on Character Sets and\n               \
    \     Languages\", BCP 18, RFC 2277, January 1998.\n   [RFC3397]        Aboba,\
    \ B. and S. Cheshire, \"Dynamic Host\n                    Configuration Protocol\
    \ (DHCP) Domain Search Option\",\n                    RFC 3397, November 2002.\n\
    \   [RFC3490]        Faltstrom, P., Hoffman, P., and A. Costello,\n          \
    \          \"Internationalizing Domain Names in Applications\n               \
    \     (IDNA)\", RFC 3490, March 2003.\n   [RFC3492]        Costello, A., \"Punycode:\
    \ A Bootstring encoding of\n                    Unicode for Internationalized\
    \ Domain Names in\n                    Applications (IDNA)\", RFC 3492, March\
    \ 2003.\n   [RFC3493]        Gilligan, R., Thomson, S., Bound, J., McCann, J.,\n\
    \                    and W. Stevens, \"Basic Socket Interface Extensions\n   \
    \                 for IPv6\", RFC 3493, February 2003.\n   [RFC3629]        Yergeau,\
    \ F., \"UTF-8, a transformation format of ISO\n                    10646\", STD\
    \ 63, RFC 3629, November 2003.\n   [RFC3646]        Droms, R., \"DNS Configuration\
    \ options for Dynamic\n                    Host Configuration Protocol for IPv6\
    \ (DHCPv6)\",\n                    RFC 3646, December 2003.\n   [RFC4343]    \
    \    Eastlake, D., \"Domain Name System (DNS) Case\n                    Insensitivity\
    \ Clarification\", RFC 4343,\n                    January 2006.\n   [RFC4690]\
    \        Klensin, J., Faltstrom, P., Karp, C., and IAB,\n                    \"\
    Review and Recommendations for Internationalized\n                    Domain Names\
    \ (IDNs)\", RFC 4690, September 2006.\n   [RFC4795]        Aboba, B., Thaler,\
    \ D., and L. Esibov, \"Link-local\n                    Multicast Name Resolution\
    \ (LLMNR)\", RFC 4795,\n                    January 2007.\n   [RFC4952]      \
    \  Klensin, J. and Y. Ko, \"Overview and Framework for\n                    Internationalized\
    \ Email\", RFC 4952, July 2007.\n   [RFC5198]        Klensin, J. and M. Padlipsky,\
    \ \"Unicode Format for\n                    Network Interchange\", RFC 5198, March\
    \ 2008.\n   [RFC5321]        Klensin, J., \"Simple Mail Transfer Protocol\",\n\
    \                    RFC 5321, October 2008.\n   [RFC5731]        Hollenbeck,\
    \ S., \"Extensible Provisioning Protocol\n                    (EPP) Domain Name\
    \ Mapping\", STD 69, RFC 5731,\n                    August 2009.\n   [RFC5890]\
    \        Klensin, J., \"Internationalized Domain Names for\n                 \
    \   Applications (IDNA): Definitions and Document\n                    Framework\"\
    , RFC 5890, August 2010.\n   [RFC5891]        Klensin, J., \"Internationalized\
    \ Domain Names in\n                    Applications (IDNA): Protocol\", RFC 5891,\n\
    \                    August 2010.\n   [UTF8-DNS]       Kwan, S. and J. Gilroy,\
    \ \"Using the UTF-8 Character\n                    Set in the Domain Name System\"\
    , Work in Progress,\n                    November 1997.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Dave Thaler\n   Microsoft Corporation\n   One Microsoft\
    \ Way\n   Redmond, WA  98052\n   USA\n   Phone: +1 425 703 8835\n   EMail: dthaler@microsoft.com\n\
    \   John C Klensin\n   1770 Massachusetts Ave, Ste 322\n   Cambridge, MA  02140\n\
    \   Phone: +1 617 245 1457\n   EMail: john+ietf@jck.com\n   Stuart Cheshire\n\
    \   Apple Inc.\n   1 Infinite Loop\n   Cupertino, CA  95014\n   Phone: +1 408\
    \ 974 3207\n   EMail: cheshire@apple.com\n"
