- title: __initial_text__
  contents:
  - "          TCP-Friendly Multicast Congestion Control (TFMCC):\n              \
    \           Protocol Specification\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard of any kind.\n   Discussion\
    \ and suggestions for improvement are requested.\n   Distribution of this memo\
    \ is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies TCP-Friendly Multicast Congestion Control\n\
    \   (TFMCC).  TFMCC is a congestion control mechanism for multicast\n   transmissions\
    \ in a best-effort Internet environment.  It is a\n   single-rate congestion control\
    \ scheme, where the sending rate is\n   adapted to the receiver experiencing the\
    \ worst network conditions.\n   TFMCC is reasonably fair when competing for bandwidth\
    \ with TCP flows\n   and has a relatively low variation of throughput over time,\
    \ making it\n   suitable for applications where a relatively smooth sending rate\
    \ is\n   of importance, such as streaming media.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \      1.1. Related Documents ..........................................4\n  \
    \    1.2. Environmental Requirements and Considerations ..............4\n   2.\
    \ Protocol Overview ...............................................5\n      2.1.\
    \ TCP Throughput Equation ....................................6\n      2.2. Packet\
    \ Contents ............................................7\n           2.2.1. Sender\
    \ Packets ......................................8\n           2.2.2. Feedback\
    \ Packets ....................................9\n   3. Data Sender Protocol ...........................................10\n\
    \      3.1. Sender Initialization .....................................10\n  \
    \    3.2. Determining the Maximum RTT ...............................10\n    \
    \  3.3. Adjusting the Sending Rate ................................11\n      3.4.\
    \ Controlling Receiver Feedback .............................12\n      3.5. Assisting\
    \ Receiver-Side RTT Measurements ..................14\n      3.6. Slowstart .................................................15\n\
    \      3.7. Scheduling of Packet Transmissions ........................15\n  \
    \ 4. Data Receiver Protocol .........................................16\n    \
    \  4.1. Receiver Initialization ...................................17\n      4.2.\
    \ Receiver Leave ............................................17\n      4.3. Measurement\
    \ of the Network Conditions .....................17\n           4.3.1. Updating\
    \ the Loss Event Rate .......................17\n           4.3.2. Basic Round-Trip\
    \ Time Measurement ..................17\n           4.3.3. One-Way Delay Adjustments\
    \ ..........................18\n           4.3.4. Receive Rate Measurements ..........................19\n\
    \      4.4. Setting the Desired Rate ..................................19\n  \
    \    4.5. Feedback and Feedback Suppression .........................20\n   5.\
    \ Calculation of the Loss Event Rate .............................22\n      5.1.\
    \ Detection of Lost or Marked Packets .......................22\n      5.2. Translation\
    \ from Loss History to Loss Events ..............23\n      5.3. Inter-Loss Event\
    \ Interval .................................24\n      5.4. Average Loss Interval\
    \ .....................................24\n      5.5. History Discounting .......................................25\n\
    \      5.6. Initializing the Loss History after the First Loss Event ..27\n  \
    \ 6. Security Considerations ........................................28\n   7.\
    \ Acknowledgments ................................................29\n   8. References\
    \ .....................................................29\n      8.1. Normative\
    \ References ......................................29\n      8.2. Informative\
    \ References ....................................29\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document specifies TCP-Friendly Multicast Congestion\
    \ Control\n   (TFMCC) [3].  TFMCC is a source-based, single-rate congestion control\n\
    \   scheme that builds upon the unicast TCP-Friendly Rate Control\n   mechanism\
    \ (TFRC) [4].  TFMCC is stable and responsive under a wide\n   range of network\
    \ conditions and scales to receiver sets on the order\n   of several thousand\
    \ receivers.  To support scalability, as much\n   congestion control functionality\
    \ as possible is located at the\n   receivers.  Each receiver continuously determines\
    \ a desired receive\n   rate that is TCP-friendly for the path from the sender\
    \ to this\n   receiver.  Selected receivers then report the rate to the sender\
    \ in\n   feedback packets.\n   TFMCC is a building block as defined in RFC 3048\
    \ [1].  Instead of\n   specifying a complete protocol, this document simply specifies\
    \ a\n   congestion control mechanism that could be used in a transport\n   protocol\
    \ such as RTP [11], in an application incorporating end-to-end\n   congestion\
    \ control at the application level.  This document does not\n   discuss packet\
    \ formats, reliability, or implementation-related\n   issues.\n   TFMCC is designed\
    \ to be reasonably fair when competing for bandwidth\n   with TCP flows.  A multicast\
    \ flow is \"reasonably fair\" if its sending\n   rate is generally within a factor\
    \ of two of the sending rate of a TCP\n   flow from the sender to the slowest\
    \ receiver of the multicast group\n   under the same network conditions.\n   In\
    \ general, TFMCC has a low variation of throughput, which makes it\n   suitable\
    \ for applications where a relatively smooth sending rate is\n   of importance,\
    \ such as streaming media.  The penalty of having smooth\n   throughput while\
    \ competing fairly for bandwidth is a reduced\n   responsiveness to changes in\
    \ available bandwidth.  Thus TFMCC should\n   be used when the application has\
    \ a requirement for smooth throughput,\n   in particular, avoiding halving of\
    \ the sending rate in response to a\n   single packet drop.  For applications\
    \ that simply need to multicast\n   as much data as possible in as short a time\
    \ as possible, PGMCC [10]\n   may be more suitable.\n   This memo contains part\
    \ of the definitions necessary to fully specify\n   a Reliable Multicast Transport\
    \ protocol in accordance with RFC 2357.\n   As per RFC 2357, the use of any reliable\
    \ multicast protocol in the\n   Internet requires an adequate congestion control\
    \ scheme.  This\n   document specifies an experimental congestion control scheme.\
    \  While\n   waiting for initial deployment and experience to show this scheme\
    \ to\n   be effective and scalable, the IETF publishes this scheme in the\n  \
    \ \"Experimental\" category.\n   It is the intent of the Reliable Multicast Transport\
    \ (RMT) Working\n   Group to re-submit the specification as an IETF Proposed Standard\
    \ as\n   soon as the scheme is deemed adequate.\n"
- title: 1.1.  Related Documents
  contents:
  - "1.1.  Related Documents\n   As described in RFC 3048 [1], TFMCC is a building\
    \ block that is\n   intended to be used, in conjunction with other building blocks,\
    \ to\n   help specify a protocol instantiation.  It follows the general\n   guidelines\
    \ provided in RFC 3269 [2].  In particular, TFMCC is a\n   suitable congestion\
    \ control building block for NACK-Oriented Reliable\n   Multicast (NORM) [5].\n"
- title: 1.2.  Environmental Requirements and Considerations
  contents:
  - "1.2.  Environmental Requirements and Considerations\n   TFMCC is intended to\
    \ be a congestion control scheme that can be used\n   in a complete protocol instantiation\
    \ that delivers objects and\n   streams (both reliable content delivery and streaming\
    \ of multimedia\n   information).\n   TFMCC is most applicable for sessions that\
    \ deliver a substantial\n   amount of data (i.e., in length from hundreds of kilobytes\
    \ to many\n   gigabytes) and whose duration is on the order of tens of seconds\
    \ or\n   more.\n   TFMCC is intended for multicast delivery.  There are currently\
    \ two\n   models of multicast delivery: the Any-Source Multicast (ASM) model as\n\
    \   defined in [6] and the Source-Specific Multicast (SSM) model as\n   defined\
    \ in [7].  TFMCC works with both multicast models, but in a\n   slightly different\
    \ way.  When ASM is used, feedback from the\n   receivers is multicast to the\
    \ sender, as well as to all other\n   receivers.  Feedback can be either multicast\
    \ on the same group\n   address used for sending data or on a separate multicast\
    \ feedback\n   group address.  For SSM, the receivers must unicast the feedback\n\
    \   directly to the sender.  Hence, feedback from a receiver will not be\n   received\
    \ by other receivers.\n   TFMCC inherently works with all types of networks that\
    \ allow bi-\n   directional communication, including LANs, WANs, Intranets, the\n\
    \   Internet, asymmetric networks, wireless networks, and satellite\n   networks.\
    \  However, in some network environments varying the sending\n   rate to the receivers\
    \ may not be advantageous (e.g., for a satellite\n   or wireless network, there\
    \ may be no mechanism for receivers to\n   effectively reduce their reception\
    \ rate since there may be a fixed\n   transmission rate allocated to the session).\n\
    \   The difference in responsiveness of TFMCC and TCP may result in\n   significant\
    \ throughput differences in case of a very low bitrate.\n   TFMCC requires an\
    \ estimate of the loss event rate to calculate a fair\n   sending rate.  This\
    \ estimate may be inaccurate in case TFMCC receives\n   only very few packets\
    \ per RTT.  TFMCC should not be used together\n   with TCP if the capacity of\
    \ the bottleneck link is less than 30KBit/s\n   (e.g., a very slow modem connection).\
    \  TFMCC may also achieve a rate\n   that is very different from the average TCP\
    \ rate in case buffer space\n   at the bottleneck is severely underprovisioned.\
    \  In particular, TFMCC\n   is less susceptible to small buffer sizes since TFMCC\
    \ spaces out\n   packets in time, whereas TCP sends them back to back.  Thus TCP\
    \ is\n   much more likely to see a packet loss if buffer space is scarce.\n  \
    \ TFMCC is designed for applications that use a fixed packet size and\n   vary\
    \ their sending rate in packets per second in response to\n   congestion.  Some\
    \ applications (e.g., those using audio) require a\n   fixed interval of time\
    \ between packets and vary their packet size\n   instead of their packet rate\
    \ in response to congestion.  The\n   congestion control mechanism in this document\
    \ cannot be used by those\n   applications.\n"
- title: 2.  Protocol Overview
  contents:
  - "2.  Protocol Overview\n   TFMCC extends the basic mechanisms of TFRC into the\
    \ multicast domain.\n   In order to compete fairly with TCP, TFMCC receivers individually\n\
    \   measure the prevalent network conditions and calculate a rate that is\n  \
    \ TCP-friendly on the path from the sender to themselves.  The rate is\n   determined\
    \ using an equation for TCP throughput, which roughly\n   describes TCP's sending\
    \ rate as a function of the loss event rate,\n   round-trip time (RTT), and packet\
    \ size.  We define a loss event as\n   one or more lost or marked packets from\
    \ the packets received during\n   one RTT, where a marked packet refers to a congestion\
    \ indication from\n   Explicit Congestion Notification (ECN) [9].  The sending\
    \ rate of the\n   multicast transmission is adapted to the receiver experiencing\
    \ the\n   worst network conditions.\n   Basically, TFMCC's congestion control\
    \ mechanism works as follows:\n   o Each receiver measures the loss event rate\
    \ and its RTT to the\n     sender.\n   o Each receiver then uses this information,\
    \ together with an equation\n     for TCP throughput, to derive a TCP-friendly\
    \ sending rate.\n   o Through a distributed feedback suppression mechanism, only\
    \ a subset\n     of the receivers are allowed to give feedback to prevent a feedback\n\
    \     implosion at the sender.  The feedback mechanism ensures that\n     receivers\
    \ reporting a low desired transmission rate have a high\n     probability of sending\
    \ feedback.\n   o Receivers whose feedback is not suppressed report the calculated\n\
    \     transmission rate back to the sender in so-called receiver reports.\n  \
    \   The receiver reports serve two purposes: they inform the sender\n     about\
    \ the appropriate transmit rate, and they allow the receivers\n     to measure\
    \ their RTT.\n   o The sender selects the receiver that reports the lowest rate\
    \ as\n     current limiting receiver (CLR).  Whenever feedback with an even\n\
    \     lower rate reaches the sender, the corresponding receiver becomes\n    \
    \ CLR and the sending rate is reduced to match that receiver's\n     calculated\
    \ rate.  The sending rate increases when the CLR reports a\n     calculated rate\
    \ higher than the current sending rate.\n   The dynamics of TFMCC are sensitive\
    \ to how the measurements are\n   performed and applied and to what feedback suppression\
    \ mechanism is\n   chosen.  We recommend specific mechanisms below to perform\
    \ and apply\n   these measurements.  Other mechanisms are possible, but it is\n\
    \   important to understand how the interactions between mechanisms\n   affect\
    \ the dynamics of TFMCC.\n"
- title: 2.1.  TCP Throughput Equation
  contents:
  - "2.1.  TCP Throughput Equation\n   Any realistic equation giving TCP throughput\
    \ as a function of loss\n   event rate and RTT should be suitable for use in TFMCC.\
    \  However, we\n   note that the TCP throughput equation used must reflect TCP's\n\
    \   retransmit timeout behavior, as this dominates TCP throughput at\n   higher\
    \ loss rates.  We also note that the assumptions implicit in the\n   throughput\
    \ equation about the loss event rate parameter have to be a\n   reasonable match\
    \ to how the loss rate or loss event rate is actually\n   measured.  While this\
    \ match is not perfect for the throughput\n   equation and loss rate measurement\
    \ mechanisms given below, in\n   practice the assumptions turn out to be close\
    \ enough.\n   The throughput equation we currently recommend for TFMCC is a\n\
    \   slightly simplified version of the throughput equation for Reno TCP\n   from\
    \ [8]:\n                                  8 s\n   X =  ---------------------------------------------------------\
    \   (1)\n         R * (sqrt(2*p/3) + (12*sqrt(3*p/8) * p * (1+32*p^2)))\n   where\n\
    \      X is the transmit rate in bits/second.\n      s is the packet size in bytes.\n\
    \      R is the round-trip time in seconds.\n      p is the loss event rate, between\
    \ 0.0 and 1.0, of the number of\n        loss events as a fraction of the number\
    \ of packets transmitted.\n   In the future, different TCP equations may be substituted\
    \ for this\n   equation.  The requirement is that the throughput equation be a\n\
    \   reasonable approximation of the sending rate of TCP for conformant\n   TCP\
    \ congestion control.\n   The parameters s (packet size), p (loss event rate),\
    \ and R (RTT) need\n   to be measured or calculated by a TFMCC implementation.\
    \  The\n   measurement of R is specified in Section 4.3.2, and the measurement\n\
    \   of p is specified in Section 5.  The parameter s (packet size) is\n   normally\
    \ known to an application.  This may not be so in two cases:\n   o The packet\
    \ size naturally varies depending on the data.  In this\n     case, although the\
    \ packet size varies, that variation is not\n     coupled to the transmit rate.\
    \  It should normally be safe to use an\n     estimate of the mean packet size\
    \ for s.\n   o The application needs to change the packet size rather than the\n\
    \     number of packets per second to perform congestion control.  This\n    \
    \ would normally be the case with packet audio applications where a\n     fixed\
    \ interval of time needs to be represented by each packet.\n     Such applications\
    \ need to have a different way of measuring\n     parameters.\n   Currently, TFMCC\
    \ cannot be used for the second class of applications.\n"
- title: 2.2.  Packet Contents
  contents:
  - "2.2.  Packet Contents\n   Before specifying the sender and receiver functionality,\
    \ we describe\n   the congestion control information contained in packets sent\
    \ by the\n   sender and feedback packets from the receivers.  Information from\
    \ the\n   sender can either be sent in separate congestion control messages or\n\
    \   piggybacked onto data packets.  If separate congestion control\n   messages\
    \ are sent at time intervals larger than the time interval\n   between data packets\
    \ (e.g., once per feedback round), it is necessary\n   to be able to include timestamp\
    \ information destined for more than\n   one receiver to allow a sufficient number\
    \ of receivers to measure\n   their RTT.\n   As TFMCC will be used along with\
    \ a transport protocol, we do not\n   specify packet formats, since these depend\
    \ on the details of the\n   transport protocol used.  The recommended representation\
    \ of the\n   header fields is given below.  Alternatively, if the computational\n\
    \   overhead of a floating point representation is prohibitive, fixed\n   point\
    \ arithmetic can be used at the expense of larger packet headers.\n   Sender and\
    \ receivers of a specific TFMCC instance need to agree on a\n   common encoding\
    \ for the header fields.\n"
- title: 2.2.1.  Sender Packets
  contents:
  - "2.2.1.  Sender Packets\n   Each packet sent by the data sender contains the following\n\
    \   information:\n   o A sequence number i.  This number is incremented by one\
    \ for each\n     data packet transmitted.  The field must be sufficiently large\
    \ that\n     it does not wrap, causing two different packets with the same\n \
    \    sequence number to be in the receiver's recent packet history at\n     the\
    \ same time.  In most cases, the sequence number will be supplied\n     by the\
    \ transport protocol used along with TFMCC.\n   o A suppression rate X_supp in\
    \ bits/s.  Only receivers with a\n     calculated rate lower than the suppression\
    \ rate are eligible to\n     give feedback, unless their RTT is higher than the\
    \ maximum RTT\n     described below, in which case they are also eligible to give\n\
    \     feedback.  The suppression rate should be represented as a 12-bit\n    \
    \ floating point value with 5 bits for the unsigned exponent and 7\n     bits\
    \ for the unsigned mantissa (to represent rates from 100 bit/s\n     to 400 Gbit/s\
    \ with an error of less than 1%).\n   o A timestamp ts_i indicating when the packet\
    \ is sent.  The\n     resolution of the timestamp should typically be milliseconds,\
    \ and\n     the timestamp should be an unsigned integer value no less than 16\n\
    \     bits wide.\n   o A receiver ID r and a copy of the timestamp tr_r' = tr_r\
    \ of that\n     receiver's last report, which allows the receiver to measure its\n\
    \     RTT.  If there is a delay ts_d between receiving the report from\n     receiver\
    \ r and sending the data packet, then tr_r' = tr_r + ts_d is\n     included in\
    \ the packet instead.  The receiver ID is described in\n     the next section.\
    \  The resolution of the timestamp echo should be\n     milliseconds, and the\
    \ timestamp should be an unsigned integer value\n     no less than 16 bits wide.\
    \  If separate congestion control messages\n     are used instead of piggybacked\
    \ ones, the packet needs to contain a\n     list of receiver IDs with corresponding\
    \ timestamps to allow a\n     sufficient number of receivers to simultaneously\
    \ measure their RTT.\n     For the default values used for the feedback process,\
    \ this\n     corresponds to a list size on the order of 10 to 20 entries.\n  \
    \ o A flag is_CLR indicating whether the receiver with ID r is the CLR.\n   o\
    \ A feedback round counter fb_nr.  This counter is incremented by the\n     sender\
    \ at the beginning of a new feedback round to notify the\n     receivers that\
    \ all feedback for older rounds should be suppressed.\n     The feedback round\
    \ counter should be at least 4 bits wide.\n   o A maximum RTT value R_max, representing\
    \ the maximum of the RTTs of\n     all receivers.  The RTT should be measured\
    \ in milliseconds.  An\n     8-bit floating point value with 4 bits for the unsigned\
    \ exponent\n     and 4 bits for the unsigned mantissa (to represent RTTs from\
    \ 1\n     millisecond to 64 seconds with an error of ca. 6%) should be used\n\
    \     for the representation.\n"
- title: 2.2.2.  Feedback Packets
  contents:
  - "2.2.2.  Feedback Packets\n     Each feedback packet sent by a data receiver contains\
    \ the following\n     information:\n   o A unique receiver ID r.  In most cases,\
    \ the receiver ID will be\n     supplied by the transport protocol, but it may\
    \ simply be the IP\n     address of the receiver.\n   o A flag have_RTT indicating\
    \ whether the receiver has made at least\n     one RTT measurement since it joined\
    \ the session.\n   o A flag have_loss indicating whether the receiver experienced\
    \ at\n     least one loss event since it joined the session.\n   o A flag receiver_leave\
    \ indicating that the receiver will leave the\n     session (and should therefore\
    \ not be CLR).\n   o A timestamp tr_r indicating when the feedback packet is sent.\
    \  The\n     representation of the timestamp should be the same as that of the\n\
    \     timestamp echo in the data packets.\n   o An echo ts_i' of the timestamp\
    \ of the last data packet received.\n     If the last packet received at the receiver\
    \ has sequence number i,\n     then ts_i' = ts_i is included in the feedback.\
    \  If there is a delay\n     tr_d between receiving that last data packet and\
    \ sending feedback,\n     then ts_i' = ts_i + tr_d is included in the feedback\
    \ instead.  The\n     representation of the timestamp echo should be the same\
    \ as that of\n     the timestamp in the data packets.\n   o A feedback round echo\
    \ fb_nr, reflecting the highest feedback round\n     counter value received so\
    \ far.  The representation of the feedback\n     round echo should be the same\
    \ as the one used for the feedback\n     round counter in the data packets.\n\
    \   o The desired sending rate X_r.  This is the rate calculated by the\n    \
    \ receiver to be TCP-friendly on the path from the sender to this\n     receiver.\
    \  The representation of the desired sending rate should be\n     the same as\
    \ that of the suppression rate in the data packets.\n"
- title: 3.  Data Sender Protocol
  contents:
  - "3.  Data Sender Protocol\n   The data sender multicasts a stream of data packets\
    \ to the data\n   receivers at a controlled rate.  Whenever feedback is received,\
    \ the\n   sender checks if it is necessary to switch CLRs and to readjust the\n\
    \   sending rate.\n   The main tasks that have to be provided by a TFMCC sender\
    \ are:\n   o adjusting the sending rate,\n   o controlling receiver feedback,\
    \ and\n   o assisting receiver-side RTT measurements.\n"
- title: 3.1.  Sender Initialization
  contents:
  - "3.1.  Sender Initialization\n   At initialization of the sender, the maximum\
    \ RTT is set to a value\n   that should be larger than the highest RTT to any\
    \ of the receivers.\n   It should not be smaller than 500 milliseconds for operation\
    \ in the\n   public Internet.  The sending rate X is initialized to 1 packet per\n\
    \   maximum RTT.\n"
- title: 3.2.  Determining the Maximum RTT
  contents:
  - "3.2.  Determining the Maximum RTT\n   For each feedback packet that arrives at\
    \ the sender, the sender\n   computes the instantaneous RTT to the receiver as\n\
    \      R_r = ts_now - ts_i'\n   where ts_now is the time the feedback packet arrived.\
    \  Receivers will\n   have adjusted ts_i' for the time interval between receiving\
    \ the last\n   data packet and sending the corresponding report so that this\n\
    \   interval will not be included in R_r.  If the actual RTT is smaller\n   than\
    \ the resolution of the timestamps and ts_now equals ts_i', then\n   R_r is set\
    \ to the smallest positive RTT value larger than 0 (i.e., 1\n   millisecond in\
    \ our case).  If the instantaneous RTT is larger than\n   the current maximum\
    \ RTT, the maximum RTT is increased to that value:\n      R_max = R_r\n   Otherwise,\
    \ if no feedback with a higher instantaneous RTT than the\n   maximum RTT is received\
    \ during a feedback round (see Section 3.4),\n   the maximum RTT is reduced to\n\
    \      R_max = MAX(R_max * 0.9, R_peak)\n   where R_peak is the peak receiver\
    \ RTT measured during the feedback\n   round.\n   The maximum RTT is mainly used\
    \ for feedback suppression among\n   receivers with heterogeneous RTTs.  Feedback\
    \ suppression is closely\n   coupled to the sending of data packets, and for this\
    \ reason, the\n   maximum RTT must not decrease below the maximum time interval\
    \ between\n   consecutive data packets:\n      R_max = max(R_max, 8s/X + ts_gran)\n\
    \   where ts_gran is the granularity of the sender's system clock (see\n   Section\
    \ 3.7).\n"
- title: 3.3.  Adjusting the Sending Rate
  contents:
  - "3.3.  Adjusting the Sending Rate\n   When a feedback packet from receiver r arrives\
    \ at the sender, the\n   sender has to check whether it is necessary to adjust\
    \ the\n   transmission rate and to switch to a new CLR.\n   How the rate is adjusted\
    \ depends on the desired rate X_r of the\n   receiver report.  We distinguish\
    \ four cases:\n   1.  If no CLR is present, receiver r becomes the current limiting\n\
    \       receiver.  The sending rate X is directly set to X_r, so long as\n   \
    \    this would result in a rate increase of less than 8s/R_max bits/s\n     \
    \  (i.e., 1 packet per R_max).  Otherwise X is gradually increased\n       to\
    \ X_r at an increase rate of no more than 8s/R_max bits/s every\n       R_max\
    \ seconds.\n   2.  If receiver r is not the CLR but a CLR is present, then receiver\n\
    \       r becomes the current limiting receiver if X_r is less than the\n    \
    \   current sending rate X and the receiver_leave flag of that\n       receiver's\
    \ report is not set.  Furthermore, the sending rate is\n       reduced to X_r.\n\
    \   3.  If receiver r is not the CLR but a CLR is present and the\n       receiver_leave\
    \ flag of the CLR's last report was set, then\n       receiver r becomes the current\
    \ limiting receiver.  However, if\n       X_r > X, the sending rate is not increased\
    \ to X_r for the\n       duration of a feedback round to allow other (lower rate)\n\
    \       receivers to give feedback and be selected as CLR.\n   4.  If receiver\
    \ r is the CLR, the sending rate is set to the minimum\n       of X_r and X +\
    \ 8s/R_max bits/s.\n   If the receiver has not yet measured its RTT but already\
    \ experienced\n   packet loss (indicated by the corresponding flags in the receiver\n\
    \   report), the receiver report will include a desired rate that is\n   based\
    \ on the maximum RTT rather than the actual RTT to that receiver.\n   In this\
    \ case, the sender adjusts the desired rate using its\n   measurement of the instantaneous\
    \ RTT R_r to that receiver:\n      X_r' = X_r * R_max / R_r\n   X_r' is then used\
    \ instead of X_r to detect whether to switch to a new\n   CLR.\n   If the TFMCC\
    \ sender receives no reports from the CLR for 4 RTTs, the\n   sending rate is\
    \ cut in half unless the CLR was selected less than 10\n   RTTs ago.  In addition,\
    \ if the sender receives no reports from the\n   CLR for at least 10 RTTs, it\
    \ assumes that the CLR crashed or left the\n   group.  A new CLR is selected from\
    \ the feedback that subsequently\n   arrives at the sender, and we increase as\
    \ in case 3, above.\n   If no new CLR can be selected (i.e., in the absence of\
    \ any feedback\n   from any of the receivers) it is necessary to reduce the sending\
    \ rate\n   further.  For every 10 consecutive RTTs without feedback, the sending\n\
    \   rate is cut in half.  The rate is at most reduced to one packet every\n  \
    \ 8 seconds.\n   Note that when receivers stop receiving data packets, they will\
    \ stop\n   sending feedback.  This eventually causes the sending rate to be\n\
    \   reduced in the case of network failure.  If the network subsequently\n   recovers,\
    \ a linear increase to the calculated rate of the CLR will\n   occur at 8s/R_max\
    \ bits/s every R_max.\n   An application using TFMCC may have a minimum sending\
    \ rate\n   requirement, where the application becomes unusable if the sending\n\
    \   rate continuously falls below this minimum rate.  The application\n   should\
    \ exclude receivers that report such a low rate from the\n   multicast group.\
    \  The specific mechanism to do this is application\n   dependent and beyond the\
    \ scope of this document.\n"
- title: 3.4.  Controlling Receiver Feedback
  contents:
  - "3.4.  Controlling Receiver Feedback\n   The receivers allowed to send a receiver\
    \ report are determined in so-\n   called feedback rounds.  Feedback rounds have\
    \ a duration T of six\n   times the maximum RTT.  In case the multicast model\
    \ is ASM (i.e.,\n   receiver feedback is multicast to the whole group) the duration\
    \ of a\n   feedback round may be reduced to four times the maximum RTT.\n   Only\
    \ receivers wishing to report a rate that is lower than the\n   suppression rate\
    \ X_supp or those with a higher RTT than R_max may\n   send feedback.  At the\
    \ beginning of each feedback round, X_supp is\n   set to the highest possible\
    \ value that can be represented.  When\n   feedback arrives at the sender over\
    \ the course of a feedback round,\n   X_supp is decreased such that more and more\
    \ feedback is suppressed\n   towards the end of the round.  How receiver feedback\
    \ is spread out\n   over the feedback round is discussed in Section 4.5.\n   Whenever\
    \ non-CLR feedback for the current round arrives at the\n   sender, X_supp is\
    \ reduced to\n      X_supp = (1-g) * X_r\n   if X_supp > X_r.  Feedback that causes\
    \ the corresponding receiver to\n   be selected as CLR, but that was from a non-CLR\
    \ receiver at the time\n   of sending, also contributes to the feedback suppression.\
    \  Note that\n   X_r must not be adjusted by the sender to reflect the receiver's\
    \ real\n   RTT in case X_r was calculated using the maximum RTT, as is done for\n\
    \   setting the sending rate (Section 3.3); otherwise, a feedback\n   implosion\
    \ is possible.  The parameter g determines to what extent\n   higher rate feedback\
    \ can suppress lower rate feedback.  This\n   mechanism guarantees that the lowest\
    \ calculated rate reported lies\n   within a factor of g of the actual lowest\
    \ calculated rate of the\n   receiver set (see [13]).  A value of g of 0.1 is\
    \ recommended.\n   To allow receivers to suppress their feedback, the sender's\n\
    \   suppression rate needs to be updated whenever feedback is received.\n   This\
    \ suppression rate has to be communicated to the receivers in a\n   timely manner,\
    \ either by including it in the data packet header or,\n   if separate congestion\
    \ control messages are used, by sending a\n   message with the suppression rate\
    \ whenever the rate changes\n   significantly (i.e., when it is reduced to less\
    \ than (1-g) times the\n   previously advertised suppression rate).\n   After\
    \ a time span of T, the feedback round ends if non-CLR feedback\n   was received\
    \ during that time.  Otherwise, the feedback round ends as\n   soon as the first\
    \ non-CLR feedback message arrives at the sender but\n   at most after 2T.  The\
    \ feedback round counter is incremented by one,\n   and the suppression rate X_supp\
    \ is reset to the highest representable\n   value.  The feedback round counter\
    \ restarts with round 0 after a\n   wrap-around.\n"
- title: 3.5.  Assisting Receiver-Side RTT Measurements
  contents:
  - "3.5.  Assisting Receiver-Side RTT Measurements\n   Receivers measure their RTT\
    \ by sending a timestamp with a receiver\n   report, which is echoed by the sender.\
    \  If congestion control\n   information is piggybacked onto data packets, usually\
    \ only one\n   receiver ID and timestamp can be included.  If multiple feedback\n\
    \   messages from different receivers arrive at the sender during the\n   time\
    \ interval between two data packets, the sender has to decide\n   which receiver\
    \ to allow to measure the RTT.  The same applies if\n   separate congestion control\
    \ messages allow echoing multiple receiver\n   timestamps simultaneously, but\
    \ the number of receivers that gave\n   feedback since the last congestion control\
    \ message exceeds the list\n   size.\n   The sender's timestamp echoes are prioritized\
    \ in the following order:\n   1.  a new CLR (after a change of CLR's) or a CLR\
    \ without any previous\n       RTT measurements\n   2.  receivers without any\
    \ previous RTT measurements in the order of\n       the feedback round echo of\
    \ the corresponding receiver report\n       (i.e., older feedback first)\n   3.\
    \  non-CLR receivers with previous RTT measurements, again in\n       ascending\
    \ order of the feedback round echo of the report\n   4.  the CLR\n   Ties are\
    \ broken in favor of the receiver with the lowest reported\n   rate.\n   It is\
    \ necessary to account for the time that elapses between\n   receiving a report\
    \ and sending the next data packet.  This time needs\n   to be deducted from the\
    \ RTT and thus has to be added to the\n   receiver's timestamp value.\n   Whenever\
    \ no feedback packets arrive in the interval between two data\n   packets, the\
    \ CLR's last timestamp, adjusted by the appropriate\n   offset, is echoed.  When\
    \ the number of packets per RTT is so low that\n   all packets carry a non-CLR\
    \ receiver's timestamp, the CLR's timestamp\n   and ID are included in a data\
    \ packet at least once per feedback\n   round.\n"
- title: 3.6.  Slowstart
  contents:
  - "3.6.  Slowstart\n   TFMCC uses a slowstart mechanism to quickly approach its\
    \ fair\n   bandwidth share at the start of a session.  During slowstart, the\n\
    \   sending rate increases exponentially.  The rate increase is limited\n   to\
    \ the minimum of the rates included in the receiver reports, and\n   receivers\
    \ report twice the rate at which they currently receive data.\n   As in normal\
    \ congestion control mode, the receiver with the smallest\n   reported rate becomes\
    \ CLR.  Since a receiver can never receive data\n   at a rate higher than its\
    \ link bandwidth, this effectively limits the\n   overshoot to twice this bandwidth.\
    \  In case the resulting increase\n   over R_max is less than 8s/R_max bits/s,\
    \ the sender may choose to\n   increase the rate by up to 8s/R_max bits/s every\
    \ R_max.  The current\n   sending rate is gradually adjusted to the target rate\
    \ reported in the\n   receiver reports over the course of an RTT.  Slowstart is\
    \ terminated\n   as soon as any one of the receivers experiences its first packet\n\
    \   loss.  Since that receiver's calculated rate will be lower than the\n   current\
    \ sending rate, the receiver will be selected as CLR.\n   During slowstart, the\
    \ upper bound on the rate increase of 8s/R_max\n   bits/s every RTT does not apply.\
    \  Only after the TFMCC sender\n   receives the first report with the have_loss\
    \ flag set is the rate\n   increase limited in this way.\n   Slowstart may also\
    \ be used after the sender has been idle for some\n   time, to quickly reach the\
    \ previous sending rate.  When the sender\n   stops sending data packets, it records\
    \ the current sending rate X' =\n   X.  Every 10 RTTs, the allowed sending rate\
    \ will be halved due to\n   lack of receiver feedback, as specified in Section\
    \ 3.3.  This halving\n   may take place multiple times.  When the sender resumes,\
    \ it may\n   perform a slowstart from the current allowed rate up to the recorded\n\
    \   rate X'.  Slowstart ends after the first packet loss by any of the\n   receivers\
    \ or as soon as X' is reached.\n   To this end, receivers have to clear the have_loss\
    \ flag after 10 RTTs\n   without data packets as specified in Section 4.3.1. \
    \ The have_loss\n   flag is only used during slowstart.  Therefore, clearing the\
    \ flag has\n   no effect if no packets arrived due to network partitioning or\
    \ packet\n   loss.\n"
- title: 3.7.  Scheduling of Packet Transmissions
  contents:
  - "3.7.  Scheduling of Packet Transmissions\n   As TFMCC is rate-based, and as operating\
    \ systems typically cannot\n   schedule events precisely, it is necessary to be\
    \ opportunistic about\n   sending data packets so that the correct average rate\
    \ is maintained\n   despite the coarse-grain or irregular scheduling of the operating\n\
    \   system.  Thus, a typical sending loop will calculate the correct\n   inter-packet\
    \ interval, ts_ipi, as follows:\n      ts_ipi = 8s/X\n   When a sender first starts\
    \ sending at time t_0, it calculates ts_ipi\n   and calculates a nominal send\
    \ time, t_1 = t_0 + ts_ipi, for packet 1.\n   When the application becomes idle,\
    \ it checks the current time,\n   ts_now, and then requests re-scheduling after\
    \ (ts_ipi - (ts_now -\n   t_0)) seconds.  When the application is re-scheduled,\
    \ it checks the\n   current time, ts_now, again.  If (ts_now > t_1 - delta) then\
    \ packet 1\n   is sent (see below for delta).\n   Now, a new ts_ipi may be calculated\
    \ and used to calculate a nominal\n   send time, t_2, for packet 2: t_2 = t_1\
    \ + ts_ipi.  The process then\n   repeats with each successive packet's send time\
    \ being calculated from\n   the nominal send time of the previous packet.  Note\
    \ that the actual\n   send time ts_i, and not the nominal send time, is included\
    \ as\n   timestamp in the packet header.\n   In some cases, when the nominal send\
    \ time, t_i, of the next packet is\n   calculated, it may already be the case\
    \ that ts_now > t_i - delta.  In\n   such a case, the packet should be sent immediately.\
    \  Thus, if the\n   operating system has coarse timer granularity and the transmit\
    \ rate\n   is high, then TFMCC may send short bursts of several packets\n   separated\
    \ by intervals of the OS timer granularity.\n   The parameter delta is to allow\
    \ a degree of flexibility in the send\n   time of a packet.  If the operating\
    \ system has a scheduling timer\n   granularity of ts_gran seconds, then delta\
    \ would typically be set to:\n      delta = min(ts_ipi/2, ts_gran/2)\n   ts_gran\
    \ is 10 milliseconds on many Unix systems.  If ts_gran is not\n   known, a value\
    \ of 10 milliseconds can be safely assumed.\n"
- title: 4.  Data Receiver Protocol
  contents:
  - "4.  Data Receiver Protocol\n   Receivers measure the current network conditions\
    \ (namely, RTT and\n   loss event rate) and use this information to calculate\
    \ a rate that is\n   fair to competing traffic.  The rate is then communicated\
    \ to the\n   sender in receiver reports.  Due to the potentially large number\
    \ of\n   receivers, it is undesirable that all receivers send reports,\n   especially\
    \ not at the same time.\n   In the description of the receiver functionality,\
    \ we will first\n   address how the receivers measure the network parameters and\
    \ then\n   discuss the feedback process.\n"
- title: 4.1.  Receiver Initialization
  contents:
  - "4.1.  Receiver Initialization\n   The receiver is initialized when it receives\
    \ the first data packet.\n   The RTT is set to the maximum RTT value contained\
    \ in the data packet.\n   This initial value is used as the receiver's RTT until\
    \ the first real\n   RTT measurement is made.  The loss event rate is initialized\
    \ to 0.\n   Also, the flags receiver_leave, have_RTT, and have_loss are cleared.\n"
- title: 4.2.  Receiver Leave
  contents:
  - "4.2.  Receiver Leave\n   A receiver that sends feedback but wishes to leave the\
    \ TFMCC session\n   within the next feedback round may indicate the pending leave\
    \ by\n   setting the receiver_leave flag in its report.  If the leaving\n   receiver\
    \ is the CLR, the receiver_leave flag should be set for all\n   the reports within\
    \ the feedback round before the leave takes effect.\n"
- title: 4.3.  Measurement of the Network Conditions
  contents:
  - "4.3.  Measurement of the Network Conditions\n   Receivers have to update their\
    \ estimate of the network parameters\n   with each new data packet they receive.\n"
- title: 4.3.1.  Updating the Loss Event Rate
  contents:
  - "4.3.1.  Updating the Loss Event Rate\n   When a data packet is received, the\
    \ receiver adds the packet to the\n   packet history.  It then recalculates the\
    \ new value of the loss event\n   rate p.  The loss event rate measurement mechanism\
    \ is described\n   separately in Section 5.\n   When a loss event is detected,\
    \ the flag have_loss is set.  In case no\n   data packets are received for 10\
    \ consecutive RTTs, the flag is\n   cleared to allow the sender to slowstart.\
    \  It is set again when new\n   data packets arrive and a loss event is detected.\n"
- title: 4.3.2.  Basic Round-Trip Time Measurement
  contents:
  - "4.3.2.  Basic Round-Trip Time Measurement\n   When a receiver gets a data packet\
    \ that carries the receiver's own ID\n   in the r field, the receiver updates\
    \ its RTT estimate.\n   1.  The current RTT is calculated as:\n       R_sample\
    \ = tr_now - tr_r'\n       where tr_now is the time the data packet arrives at\
    \ the receiver\n       and tr_r' is the receiver report timestamp echoed in the\
    \ data\n       packet.  If the actual RTT is smaller than the resolution of the\n\
    \       timestamps and tr_now equals tr_r', then R_sample is set to the\n    \
    \   smallest positive RTT value larger than 0 (i.e., 1 millisecond in\n      \
    \ our case).\n   2.  The smoothed RTT estimate R is updated:\n       If no feedback\
    \ has been received before\n           R = R_sample\n       Else\n           R\
    \ = q*R + (1-q)*R_sample\n       A filter parameter q of 0.5 is recommended for\
    \ non-CLR receivers.\n       The CLR performs RTT measurements much more frequently\
    \ and hence\n       should use a higher filter value.  We recommend using q=0.9.\n\
    \       Note that TFMCC is not sensitive to the precise value for the\n      \
    \ filter constant.\n   Optionally, sender-based RTT measurements may be used instead\
    \ of\n   receiver-based ones.  The sender already determines the RTT to a\n  \
    \ receiver from the receiver's echo of the sender's own timestamp for\n   the\
    \ calculation of the maximum RTT.  For sender-based RTT\n   measurements, this\
    \ RTT measurement needs to be communicated to the\n   receiver.  Instead of including\
    \ an echo of the receiver's timestamp,\n   the sender includes the receiver's\
    \ RTT in the next data packet, using\n   the prioritization rules described in\
    \ Section 3.5.\n   To simplify sender operation, smoothing of RTT samples as described\n\
    \   above should still be done at the receiver.\n"
- title: 4.3.3.  One-Way Delay Adjustments
  contents:
  - "4.3.3.  One-Way Delay Adjustments\n   When an RTT measurement is performed, the\
    \ receiver also determines\n   the one-way delay D_r from itself to the sender:\n\
    \      D_r = tr_r' - ts_i\n   where ts_i and tr_r' are the timestamp and receiver\
    \ report timestamp\n   echo contained in the data packet.  With each new data\
    \ packet j, the\n   receiver can now calculate an updated RTT estimate as:\n \
    \     R' = max(D_r + tr_now - ts_j, 1 millisecond)\n   In between RTT measurements,\
    \ the updated R' is used instead of the\n   smoothed RTT R.  Like the RTT samples,\
    \ R' must be strictly positive.\n   When a new measurement is made, all interim\
    \ one-way delay\n   measurements are discarded (i.e., the smoothed RTT is updated\n\
    \   according to Section 4.3.2 without taking the interim one-way delay\n   adjustments\
    \ into account).\n   For the one-way delay measurements, the clocks of sender\
    \ and\n   receivers need not be synchronized.  Clock skew will cancel itself\n\
    \   out when both one-way measurements are added to form an RTT estimate,\n  \
    \ as long as clock drift between real RTT measurements is negligible.\n   The\
    \ same one-way delay adjustments should be applied to the RTT\n   supplied by\
    \ the sender when using sender-based RTT measurements.\n"
- title: 4.3.4.  Receive Rate Measurements
  contents:
  - "4.3.4.  Receive Rate Measurements\n   When a receiver has not experienced any\
    \ loss events, it cannot\n   calculate a TCP-friendly rate to include in the receiver\
    \ reports.\n   Instead, the receiver measures the current receive rate and sets\
    \ the\n   desired rate X_r to twice the receive rate.\n   The receive rate in\
    \ bits/s is measured as the number of bits received\n   over the last k RTTs,\
    \ taking into account the IP and transport packet\n   headers, but excluding the\
    \ link-layer packet headers.  A value for k\n   between 2 and 4 is recommended.\n"
- title: 4.4.  Setting the Desired Rate
  contents:
  - "4.4.  Setting the Desired Rate\n   When a receiver measures a non-zero loss event\
    \ rate, it calculates\n   the desired rate using Equation (1).  In case no RTT\
    \ measurement is\n   available yet, the maximum RTT is used instead of the receiver's\
    \ RTT.\n   The desired rate X_r is updated whenever the loss event rate or the\n\
    \   RTT changes.\n   A receiver may decide not to report desired rates that are\
    \ below 1\n   packet per 8 seconds, since a sender is very slow to recover from\n\
    \   such low sending rates.  In this case, the receiver reports a desired\n  \
    \ rate of 1 packet per 8 seconds.  However, it must leave the multicast\n   group\
    \ if for more than 120 seconds, the calculated rate falls below\n   the reported\
    \ rate and the current sending rate is higher than the\n   receiver's calculated\
    \ rate.\n   As mentioned above, calculation of the desired rate is not possible\n\
    \   before the receiver experiences the first loss event.  In that case,\n   twice\
    \ the rate at which data is received is included in the receiver\n   reports as\
    \ X_r to allow the sender to slowstart as described in\n   Section 3.6.  This\
    \ is also done when the sender resumes sending data\n   packets after the have_loss\
    \ flag was cleared due to the sender being\n   idle.\n"
- title: 4.5.  Feedback and Feedback Suppression
  contents:
  - "4.5.  Feedback and Feedback Suppression\n   Let fb_nr be the highest feedback\
    \ round counter value received by a\n   receiver.  When a new data packet arrives\
    \ with a higher feedback\n   round counter than fb_nr, a new feedback round begins\
    \ and fb_nr is\n   updated.  Outstanding feedback for the old round is canceled.\
    \  In\n   case a feedback number with a value that is more than half the\n   feedback\
    \ number space lower than fb_nr is received, the receiver\n   assumes that the\
    \ feedback round counter wrapped and also cancels the\n   feedback timer and updates\
    \ fb_nr.\n   The CLR sends its feedback independently from all the other receivers\n\
    \   once per RTT.  Its feedback does not suppress other feedback and\n   cannot\
    \ be suppressed by other receiver's feedback.\n   Non-CLR receivers set a feedback\
    \ timer at the beginning of a feedback\n   round.  Using an exponentially weighted\
    \ random timer mechanism, the\n   feedback timer is set to expire after\n    \
    \  t = max(T * (1 + log(x)/log(N)), 0)\n   where\n      x is a random variable\
    \ uniformly distributed in (0,1],\n      T is the duration of a feedback round\
    \ (i.e., 6 * R_max),\n      N is an estimated upper bound on the number of receivers.\n\
    \   N is a constant specific to the TFMCC protocol.  Since TFMCC scales\n   to\
    \ up to thousands of receivers, setting N to 10,000 for all\n   receivers (and\
    \ limiting the TFMCC session to at most 10,000\n   receivers) is recommended.\n\
    \   A feedback packet is sent when the feedback timer expires, unless the\n  \
    \ timer is canceled beforehand.  When the multicast model is ASM,\n   feedback\
    \ is multicast to the whole group; otherwise, the feedback is\n   unicast to the\
    \ sender.  The feedback packet includes the calculated\n   rate valid at the time\
    \ the feedback packet is sent (not the rate at\n   the point of time when the\
    \ feedback timer is set).  The copy of the\n   timestamp ts_i of the last data\
    \ packet received, which is included in\n   the feedback packet, needs to be adjusted\
    \ by the time interval\n   between receiving the data packet and sending the report\
    \ to allow the\n   sender to correctly infer the instantaneous RTT (i.e., that\
    \ time\n   interval has to be added to the timestamp value).\n   The timer is\
    \ canceled if a data packet is received that has a lower\n   suppression rate\
    \ than the receiver's calculated rate and a higher or\n   equal maximum RTT than\
    \ the receiver's RTT.  Likewise, a data packet\n   indicating the beginning of\
    \ a new feedback round cancels all feedback\n   for older rounds.  In case of\
    \ ASM, the timer is also canceled if a\n   feedback packet is received from another\
    \ non-CLR receiver reporting a\n   lower rate.\n   The feedback suppression process\
    \ is complicated by the fact that the\n   calculated rates of the receivers will\
    \ change during a feedback\n   round.  If the calculated rates decrease rapidly\
    \ for all receivers,\n   feedback suppression can no longer prevent a feedback\
    \ implosion,\n   since earlier feedback will always report a higher rate than\
    \ current\n   feedback.  To make the feedback suppression mechanism robust in\
    \ the\n   face of changing rates, it is necessary to introduce X_fbr, the\n  \
    \ calculated rate of a receiver at the beginning of a feedback round.\n   A receiver\
    \ needs to suppress its feedback not only when the\n   suppression rate is less\
    \ than the receiver's current calculated rate\n   but also in the case that the\
    \ suppression rate falls below X_fbr.\n   When the maximum RTT changes significantly\
    \ during one feedback round,\n   it is necessary to reschedule the feedback timer\
    \ in proportion to the\n   change.\n      t = t * R_max / R_max'\n   where R_max\
    \ is the new maximum RTT and R_max' is the previous maximum\n   RTT.  The same\
    \ considerations hold when the last data packets were\n   received more than a\
    \ time interval of R_max ago.  In this case, it is\n   necessary to add the difference\
    \ of the inter-packet gap and the\n   maximum RTT to the feedback time to prevent\
    \ a feedback implosion\n   (e.g., in case the sender crashed).\n      t = t +\
    \ max(tr_now - tr_i - R_max, 0)\n   where tr_i is the time when the last data\
    \ packet arrived at the\n   receiver.\n   More details on the characteristics\
    \ of the feedback suppression\n   mechanism can be found in [13] and [3].\n"
- title: 5.  Calculation of the Loss Event Rate
  contents:
  - "5.  Calculation of the Loss Event Rate\n   Obtaining an accurate and stable measurement\
    \ of the loss event rate\n   is of primary importance for TFMCC.  Loss rate measurement\
    \ is\n   performed at the receiver, based on the detection of lost or marked\n\
    \   packets from the sequence numbers of arriving packets.\n"
- title: 5.1.  Detection of Lost or Marked Packets
  contents:
  - "5.1.  Detection of Lost or Marked Packets\n   TFMCC assumes that all packets\
    \ contain a sequence number that is\n   incremented by one for each packet that\
    \ is sent.  For the purposes of\n   this specification, we require that if a lost\
    \ packet is\n   retransmitted, the retransmission is given a new sequence number\
    \ that\n   is the latest in the transmission sequence, and not the same sequence\n\
    \   number as the packet that was lost.  If a transport protocol has the\n   requirement\
    \ that it must retransmit with the original sequence\n   number, then the transport\
    \ protocol designer must figure out how to\n   distinguish delayed from retransmitted\
    \ packets and how to detect lost\n   retransmissions.\n   The receivers each maintain\
    \ a data structure that keeps track of\n   which packets have arrived and which\
    \ are missing.  For the purposes\n   of specification, we assume that the data\
    \ structure consists of a\n   list of packets that have arrived along with the\
    \ timestamp when each\n   packet was received.  In practice, this data structure\
    \ will normally\n   be stored in a more compact representation, but this is\n\
    \   implementation-specific.\n   The loss of a packet is detected by the arrival\
    \ of at least three\n   packets with a higher sequence number than the lost packet.\
    \  The\n   requirement for three subsequent packets is the same as with TCP, and\n\
    \   it is to make TFMCC more robust in the presence of reordering.  In\n   contrast\
    \ to TCP, if a packet arrives late (after 3 subsequent packets\n   arrived) at\
    \ a receiver, the late packet can fill the hole in the\n   reception record, and\
    \ the receiver can recalculate the loss event\n   rate.  Future versions of TFMCC\
    \ might make the requirement for three\n   subsequent packets adaptive based on\
    \ experienced packet reordering,\n   but we do not specify such a mechanism here.\n\
    \   For an ECN-capable connection, a marked packet is detected as a\n   congestion\
    \ event as soon as it arrives, without having to wait for\n   the arrival of subsequent\
    \ packets.\n"
- title: 5.2.  Translation from Loss History to Loss Events
  contents:
  - "5.2.  Translation from Loss History to Loss Events\n   TFMCC requires that the\
    \ loss event rate be robust to several\n   consecutive packets lost where those\
    \ packets are part of the same\n   loss event.  This is similar to TCP, which\
    \ (typically) only performs\n   one halving of the congestion window during any\
    \ single RTT.  Thus the\n   receivers need to map the packet loss history into\
    \ a loss event\n   record, where a loss event is one or more packets lost in an\
    \ RTT.\n   To determine whether a lost or marked packet should start a new loss\n\
    \   event or be counted as part of an existing loss event, we need to\n   compare\
    \ the sequence numbers and timestamps of the packets that\n   arrived at the receiver.\
    \  For a marked packet S_new, its reception\n   time T_new can be noted directly.\
    \  For a lost packet, we can\n   interpolate to infer the nominal \"arrival time\"\
    .  Assume:\n   S_loss is the sequence number of a lost packet.\n   S_before is\
    \ the sequence number of the last packet to arrive with\n      sequence number\
    \ before S_loss.\n   S_after is the sequence number of the first packet to arrive\
    \ with\n      sequence number after S_loss.\n   T_before is the reception time\
    \ of S_before.\n   T_after is the reception time of S_after.\n   Note that T_before\
    \ can be either before or after T_after due to\n   reordering.\n   For a lost\
    \ packet S_loss, we can interpolate its nominal \"arrival\n   time\" at the receiver\
    \ from the arrival times of S_before and S_after.\n   Thus\n      T_loss = T_before\
    \ + ( (T_after - T_before)\n                  * (S_loss - S_before)/(S_after -\
    \ S_before) );\n   Note that if the sequence space wrapped between S_before and\
    \ S_after,\n   the sequence numbers must be modified to take this into account\n\
    \   before the calculation is performed.  If the largest possible\n   sequence\
    \ number is S_max, and S_before > S_after, then modifying each\n   sequence number\
    \ S by S' = (S + (S_max + 1)/2) mod (S_max + 1) would\n   normally be sufficient.\n\
    \   If the lost packet S_old was determined to have started the previous\n   loss\
    \ event, and if we have just determined that S_new has been lost,\n   then we\
    \ interpolate the nominal arrival times of S_old and S_new,\n   called T_old and\
    \ T_new, respectively.\n   If T_old + R >= T_new, then S_new is part of the existing\
    \ loss event.\n   Otherwise, S_new is the first packet of a new loss event.\n"
- title: 5.3.  Inter-Loss Event Interval
  contents:
  - "5.3.  Inter-Loss Event Interval\n   If a loss interval, A, is determined to have\
    \ started with packet\n   sequence number S_A and the next loss interval, B, started\
    \ with\n   packet sequence number S_B, then the number of packets in loss\n  \
    \ interval A is given by (S_B - S_A).\n"
- title: 5.4.  Average Loss Interval
  contents:
  - "5.4.  Average Loss Interval\n   To calculate the loss event rate p, we first\
    \ calculate the average\n   loss interval.  This is done using a filter that weights\
    \ the n most\n   recent loss event intervals in such a way that the measured loss\n\
    \   event rate changes smoothly.\n   Weights w_0 to w_(n-1) are calculated as:\n\
    \        If (i < n/2)\n           w_i = 1;\n        Else\n           w_i = 1 -\
    \ (i - (n/2 - 1))/(n/2 + 1);\n   Thus if n=8, the values of w_0 to w_7 are:\n\
    \        1.0, 1.0, 1.0, 1.0, 0.8, 0.6, 0.4, 0.2\n   The value n for the number\
    \ of loss intervals used in calculating the\n   loss event rate determines TFMCC's\
    \ speed in responding to changes in\n   the level of congestion.  As currently\
    \ specified, TFMCC should not be\n   used for values of n significantly greater\
    \ than 8, for traffic that\n   might compete in the global Internet with TCP.\
    \  At the very least,\n   safe operation with values of n greater than 8 would\
    \ require a slight\n   change to TFMCC's mechanisms to include a more severe response\
    \ to two\n   or more round-trip times with heavy packet loss.\n   When calculating\
    \ the average loss interval, we need to decide whether\n   to include the interval\
    \ since the most recent packet loss event.  We\n   only do this if it is sufficiently\
    \ large to increase the average loss\n   interval.\n   Thus, if the most recent\
    \ loss intervals are I_0 to I_n, with I_0\n   being the interval since the most\
    \ recent loss event, then we\n   calculate the average loss interval I_mean as:\n\
    \     I_tot0 = 0;\n     I_tot1 = 0;\n     W_tot = 0;\n     for (i = 0 to n-1)\
    \ {\n       I_tot0 = I_tot0 + (I_i * w_i);\n       W_tot = W_tot + w_i;\n    \
    \ }\n     for (i = 1 to n) {\n       I_tot1 = I_tot1 + (I_i * w_(i-1));\n    \
    \ }\n     I_tot = max(I_tot0, I_tot1);\n     I_mean = I_tot/W_tot;\n   The loss\
    \ event rate, p is simply:\n     p = 1 / I_mean;\n"
- title: 5.5.  History Discounting
  contents:
  - "5.5.  History Discounting\n   As described in Section 5.4, the most recent loss\
    \ interval is only\n   assigned 4/(3*n) of the total weight in calculating the\
    \ average loss\n   interval, regardless of the size of the most recent loss interval.\n\
    \   This section describes an optional history discounting mechanism that\n  \
    \ allows the TFMCC receivers to adjust the weights, concentrating more\n   of\
    \ the relative weight on the most recent loss interval, when the\n   most recent\
    \ loss interval is more than twice as large as the computed\n   average loss interval.\n\
    \   To carry out history discounting, we associate a discount factor DF_i\n  \
    \ with each loss interval L_i, where each discount factor is a floating\n   point\
    \ number.  The discount array maintains the cumulative history of\n   discounting\
    \ for each loss interval.  At the beginning, the values of\n   DF_i in the discount\
    \ array are initialized to 1:\n     for (i = 0 to n) {\n       DF_i = 1;\n   \
    \  }\n   History discounting also uses a general discount factor DF, also a\n\
    \   floating point number, that is also initialized to 1.  First, we show\n  \
    \ how the discount factors are used in calculating the average loss\n   interval,\
    \ and then we describe later in this section how the discount\n   factors are\
    \ modified over time.\n   As described in Section 5.4, the average loss interval\
    \ is calculated\n   using the n previous loss intervals I_1, ..., I_n, and the\
    \ interval\n   I_0 that represents the number of packets received since the last\n\
    \   loss event.  The computation of the average loss interval using the\n   discount\
    \ factors is a simple modification of the procedure in Section\n   5.4, as follows:\n\
    \     I_tot0 = I_0 * w_0\n     I_tot1 = 0;\n     W_tot0 = w_0\n     W_tot1 = 0;\n\
    \     for (i = 1 to n-1) {\n       I_tot0 = I_tot0 + (I_i * w_i * DF_i * DF);\n\
    \       W_tot0 = W_tot0 + w_i * DF_i * DF;\n     }\n     for (i = 1 to n) {\n\
    \       I_tot1 = I_tot1 + (I_i * w_(i-1) * DF_i);\n       W_tot1 = W_tot1 + w_(i-1)\
    \ * DF_i;\n     }\n     p = min(W_tot0/I_tot0, W_tot1/I_tot1);\n   The general\
    \ discounting factor DF is updated on every packet arrival\n   as follows.  First,\
    \ a receiver computes the weighted average I_mean\n   of the loss intervals I_1,\
    \ ..., I_n:\n     I_tot = 0;\n     W_tot = 0;\n     for (i = 1 to n) {\n     \
    \  W_tot = w_(i-1) * DF_i;\n       I_tot = I_tot + (I_i * w_(i-1) * DF_i);\n \
    \    }\n     I_mean = I_tot / W_tot;\n   This weighted average I_mean is compared\
    \ to I_0, the number of\n   packets received since the last loss event.  If I_0\
    \ is greater than\n   twice I_mean, then the new loss interval is considerably\
    \ larger than\n   the old ones, and the general discount factor DF is updated\
    \ to\n   decrease the relative weight on the older intervals, as follows:\n  \
    \   if (I_0 > 2 * I_mean) {\n       DF = 2 * I_mean/I_0;\n       if (DF < THRESHOLD)\n\
    \         DF = THRESHOLD;\n     } else\n       DF = 1;\n   A nonzero value for\
    \ THRESHOLD ensures that older loss intervals from\n   an earlier time of high\
    \ congestion are not discounted entirely.  We\n   recommend a THRESHOLD of 0.5.\
    \  Note that with each new packet\n   arrival, I_0 will increase further, and\
    \ the discount factor DF will\n   be updated.\n   When a new loss event occurs,\
    \ the current interval shifts from I_0 to\n   I_1, loss interval I_i shifts to\
    \ interval I_(i+1), and the loss\n   interval I_n is forgotten.  The previous\
    \ discount factor DF has to be\n   incorporated into the discount array.  Because\
    \ DF_i carries the\n   discount factor associated with loss interval I_i, the\
    \ DF_i array has\n   to be shifted as well.  This is done as follows:\n     for\
    \ (i = 1 to n) {\n       DF_i = DF * DF_i;\n     }\n     for (i = n-1 to 0 step\
    \ -1) {\n       DF_(i+1) = DF_i;\n     }\n     I_0 = 1;\n     DF_0 = 1;\n    \
    \ DF = 1;\n   This completes the description of the optional history discounting\n\
    \   mechanism.  We emphasize that this is an optional mechanism whose\n   sole\
    \ purpose is to allow TFMCC to respond more quickly to the sudden\n   absence\
    \ of congestion, as represented by a long current loss\n   interval.\n"
- title: 5.6.  Initializing the Loss History after the First Loss Event
  contents:
  - "5.6.  Initializing the Loss History after the First Loss Event\n   The number\
    \ of packets received before the first loss event usually\n   does not reflect\
    \ the current loss event rate.  When the first loss\n   event occurs, a TFMCC\
    \ receiver assumes that the correct data rate is\n   the rate at which data was\
    \ received during the last RTT when the loss\n   occurred.  Instead of initializing\
    \ the first loss interval to the\n   number of packets sent until the first loss\
    \ event, the TFMCC receiver\n   calculates the loss interval that would be required\
    \ to produce the\n   receive rate X_recv, and it uses this synthetic loss interval\
    \ l_0 to\n   seed the loss history mechanism.\n   The initial loss interval is\
    \ calculated by inverting a simplified\n   version of the TCP Equation (1).\n\
    \                                  8s\n      X_recv = sqrt(3/2) * -----------------\n\
    \                            R * sqrt(1/l_0)\n                    X_recv * R\n\
    \      ==> l_0 = (----------------)^2\n                  sqrt(3/2) * 8s\n   The\
    \ resulting initial loss interval is too small at higher loss rates\n   compared\
    \ to using the more accurate Equation (1), which leads to a\n   more conservative\
    \ initial loss event rate.\n   If a receiver still uses the initial RTT R_max\
    \ instead of its real\n   RTT, the initial loss interval is too large in case\
    \ the initial RTT\n   is higher than the actual RTT.  As a consequence, the receiver\
    \ will\n   calculate too high a desired rate when the first RTT measurement R\
    \ is\n   made and the initial loss interval is still in the loss history.  The\n\
    \   receiver has to adjust l_0 as follows:\n      l_0 = l_0 * (R/R_max)^2\n  \
    \ No action needs to be taken when the first RTT measurement is made\n   after\
    \ the initial loss interval left the loss history.\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   TFMCC is not a transport protocol in its own\
    \ right, but a congestion\n   control mechanism that is intended to be used in\
    \ conjunction with a\n   transport protocol.  Therefore, security primarily needs\
    \ to be\n   considered in the context of a specific transport protocol and its\n\
    \   authentication mechanisms.\n   Congestion control mechanisms can potentially\
    \ be exploited to create\n   denial of service.  This may occur through spoofed\
    \ feedback.  Thus,\n   any transport protocol that uses TFMCC should take care\
    \ to ensure\n   that feedback is only accepted from valid receivers of the data.\n\
    \   However, the precise mechanism to achieve this will depend on the\n   transport\
    \ protocol itself.\n   Congestion control mechanisms may potentially be manipulated\
    \ by a\n   greedy receiver that wishes to receive more than its fair share of\n\
    \   network bandwidth.  However, in TFMCC a receiver can only influence\n   the\
    \ sending rate if it is the CLR and thus has the lowest calculated\n   rate of\
    \ all receivers.  If the calculated rate is then manipulated\n   such that it\
    \ exceeds the calculated rate of the second to lowest\n   receiver, it will cease\
    \ to be CLR.  A greedy receiver can only\n   significantly increase the transmission\
    \ rate if it is the only\n   participant in the session.  If such scenarios are\
    \ of concern,\n   possible defenses against such a receiver would normally include\
    \ some\n   form of nonce that the receiver must feed back to the sender to prove\n\
    \   receipt.  However, the details of such a nonce would depend on the\n   transport\
    \ protocol and, in particular, on whether the transport\n   protocol is reliable\
    \ or unreliable.\n   It is possible that a receiver sends feedback claiming that\
    \ it has a\n   very low calculated rate.  This will reduce the rate of the multicast\n\
    \   session and might render it useless but obviously cannot hurt the\n   network\
    \ itself.\n   We expect that protocols incorporating ECN with TFMCC will also\
    \ want\n   to incorporate feedback from the receiver to the sender using the ECN\n\
    \   nonce [12].  The ECN nonce is a modification to ECN that protects the\n  \
    \ sender from the accidental or malicious concealment of marked\n   packets. \
    \ Again, the details of such a nonce would depend on the\n   transport protocol\
    \ and are not addressed in this document.\n"
- title: 7.  Acknowledgments
  contents:
  - "7.  Acknowledgments\n   We would like to acknowledge feedback and discussions\
    \ on equation-\n   based congestion control with a wide range of people, including\n\
    \   members of the Reliable Multicast Research Group, the Reliable\n   Multicast\
    \ Transport Working Group, and the End-to-End Research Group.\n   We would particularly\
    \ like to thank Brian Adamson, Mark Pullen, Fei\n   Zhao, and Magnus Westerlund\
    \ for feedback on earlier versions of this\n   document.\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [1]   Whetten, B., Vicisano, L., Kermode, R.,\
    \ Handley, M., Floyd, S.,\n         and M. Luby, \"Reliable Multicast Transport\
    \ Building Blocks for\n         One-to-Many Bulk-Data Transfer\", RFC 3048, January\
    \ 2001.\n   [2]   Kermode, R. and L. Vicisano, \"Author Guidelines for Reliable\n\
    \         Multicast Transport (RMT) Building Blocks and Protocol\n         Instantiation\
    \ documents\", RFC 3269, April 2002.\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [3]   J. Widmer and M. Handley, \"Extending\
    \ Equation-Based Congestion\n         Control to Multicast Applications\", Proc\
    \ ACM Sigcomm 2001, San\n         Diego, August 2001.\n   [4]   S. Floyd, M. Handley,\
    \ J. Padhye, and J. Widmer, \"Equation-Based\n         Congestion Control for\
    \ Unicast Applications\", Proc ACM SIGCOMM\n         2000, Stockholm, August 2000.\n\
    \   [5]   Adamson, B., Bormann, C., Handley, M., and J. Macker,\n         \"Negative-Acknowledgment\
    \ (NACK)-Oriented Reliable Multicast\n         (NORM) Building Blocks\", RFC 3941,\
    \ November 2004.\n   [6]   Deering, S., \"Host extensions for IP multicasting\"\
    , STD 5, RFC\n         1112, August 1989.\n   [7]   H. W. Holbrook, \"A Channel\
    \ Model for Multicast,\" Ph.D.\n         Dissertation, Stanford University, Department\
    \ of Computer\n         Science, Stanford, California, August 2001.\n   [8]  \
    \ J. Padhye, V. Firoiu, D. Towsley, and J. Kurose, \"Modeling TCP\n         Throughput:\
    \ A Simple Model and its Empirical Validation\", Proc\n         ACM SIGCOMM 1998.\n\
    \   [9]   Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition of\n     \
    \    Explicit Congestion Notification (ECN) to IP\", RFC 3168,\n         September\
    \ 2001.\n   [10]  L. Rizzo, \"pgmcc: a TCP-friendly single-rate multicast\n  \
    \       congestion control scheme\", Proc ACM Sigcomm 2000, Stockholm,\n     \
    \    August 2000.\n   [11]  Schulzrinne, H., Casner, S., Frederick, R., and V.\
    \ Jacobson,\n         \"RTP: A Transport Protocol for Real-Time Applications\"\
    , STD 64,\n         RFC 3550, July 2003.\n   [12]  Spring, N., Wetherall, D.,\
    \ and D. Ely, \"Robust Explicit\n         Congestion Notification (ECN) Signaling\
    \ with Nonces\", RFC 3540,\n         June 2003.\n   [13]  J. Widmer and T. Fuhrmann,\
    \ \"Extremum Feedback for Very Large\n         Multicast Groups\", Proc NGC 2001,\
    \ London, November 2001.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Joerg Widmer\n   DoCoMo Euro-Labs\n   Landsberger Str.\
    \ 312, Munich, Germany\n   EMail: widmer@acm.org\n   Mark Handley\n   UCL (University\
    \ College London)\n   Gower Street, London WC1E 6BT, UK\n   EMail: m.handley@cs.ucl.ac.uk\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n\
    \   Administrative Support Activity (IASA).\n"
