- contents:
  - '                      PKIX over Secure HTTP (POSH)

    '
  title: __initial_text__
- contents:
  - "Abstract\n   Experience has shown that it is difficult to deploy proper PKIX\n
    \  certificates for Transport Layer Security (TLS) in multi-tenanted\n   environments.
    \ As a result, domains hosted in such environments often\n   deploy applications
    using certificates that identify the hosting\n   service, not the hosted domain.
    \ Such deployments force end users and\n   peer services to accept a certificate
    with an improper identifier,\n   resulting in degraded security.  This document
    defines methods that\n   make it easier to deploy certificates for proper server
    identity\n   checking in non-HTTP application protocols.  Although these methods\n
    \  were developed for use in the Extensible Messaging and Presence\n   Protocol
    (XMPP) as a Domain Name Association (DNA) prooftype, they\n   might also be usable
    in other non-HTTP application protocols.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7711.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2015 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \  2. Terminology .....................................................4\n   3.
    Obtaining Verification Material .................................5\n      3.1.
    Source Domain Possesses PKIX Certificate Information .......6\n      3.2. Source
    Domain References PKIX Certificate ..................8\n      3.3. Performing
    Verification ....................................9\n   4. Secure Delegation ...............................................9\n
    \  5. Order of Operations ............................................10\n   6.
    Caching Results ................................................11\n   7. Guidance
    for Server Operators ..................................12\n   8. Guidance for
    Protocol Authors ..................................12\n   9. IANA Considerations
    ............................................13\n      9.1. Well-Known URI ............................................13\n
    \     9.2. POSH Service Names ........................................13\n   10.
    Security Considerations .......................................14\n   11. References
    ....................................................15\n      11.1. Normative
    References .....................................15\n      11.2. Informative References
    ...................................16\n   Acknowledgements ..................................................18\n
    \  Authors' Addresses ................................................18\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   We begin with a thought experiment.\n   Imagine that you
    work on the operations team of a hosting company\n   that provides instances of
    the hypothetical \"Secure Protocol for\n   Internet Content Exchange\" (SPICE)
    service for ten thousand different\n   customer organizations.  Each customer
    wants their instance to be\n   identified by the customer's domain name (e.g.,
    bar.example.com), not\n   the hosting company's domain name (e.g., hosting.example.net).\n
    \  In order to properly secure each customer's SPICE instance via\n   Transport
    Layer Security (TLS) [RFC5246], you need to obtain and\n   deploy PKIX certificates
    [RFC5280] containing identifiers such as\n   bar.example.com, as explained in
    the \"CertID\" specification\n   [RFC6125].  Unfortunately, you can't obtain and
    deploy such\n   certificates because:\n   o  Certification authorities won't issue
    such certificates to you\n      because you work for the hosting company, not
    the customer\n      organization.\n   o  Customers won't obtain such certificates
    and then give them (plus\n      the associated private keys) to you because their
    legal department\n      is worried about liability.\n   o  You don't want to install
    such certificates (plus the associated\n      private keys) on your servers because
    your legal department is\n      worried about liability, too.\n   o  Even if your
    legal department is happy, this still means managing\n      one certificate for
    each customer across the infrastructure,\n      contributing to a large administrative
    load.\n   Given your inability to obtain and deploy public keys / certificates\n
    \  containing the right identifiers, your back-up approach has always\n   been
    to use a certificate containing hosting.example.net as the\n   identifier.  However,
    more and more customers and end users are\n   complaining about warning messages
    in user agents and the inherent\n   security issues involved with taking a \"leap
    of faith\" to accept the\n   identity mismatch between the source domain (bar.example.com)
    and the\n   delegated domain (hosting.example.net) [RFC6125].\n   This situation
    is both insecure and unsustainable.  You have\n   investigated the possibility
    of using DNS Security [RFC4033] and\n   DNS-Based Authentication of Named Entities
    (DANE) [RFC6698] to solve\n   the problem.  However, your customers and your operations
    team have\n   told you that it will be several years before they will be able
    to\n   deploy DNSSEC and DANE for all of your customers (because of tooling\n
    \  updates, slow deployment of DNSSEC at some top-level domains, etc.).\n   The
    product managers in your company are pushing you to find a method\n   that can
    be deployed more quickly to overcome the lack of proper\n   server identity checking
    for your hosted customers.\n   One possible approach that your team has investigated
    is to ask each\n   customer to provide the public key / certificate for its SPICE\n
    \  service at a special HTTPS URI on their website\n   (\"https://bar.example.com/.well-known/posh/spice.json\"
    is one\n   possibility).  This could be a public key that you generate for the\n
    \  customer, but because the customer hosts it via HTTPS, any user agent\n   can
    find that public key and check it against the public key you\n   provide during
    TLS negotiation for the SPICE service (as one added\n   benefit, the customer
    never needs to hand you a private key).\n   Alternatively, the customer can redirect
    requests for that special\n   HTTPS URI to an HTTPS URI at your own website, thus
    making it\n   explicit that they have delegated the SPICE service to you.\n   The
    approach sketched out above, called POSH (\"PKIX over Secure\n   HTTP\"), is explained
    in the remainder of this document.  Although\n   this approach was developed for
    use in the Extensible Messaging and\n   Presence Protocol (XMPP) as a prooftype
    for Domain Name Associations\n   (DNA) [RFC7712], it might be usable by any non-HTTP
    application\n   protocol.\n"
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   This document inherits security terminology from [RFC5280].
    \ The\n   terms \"source domain\", \"delegated domain\", \"derived domain\", and\n
    \  \"reference identifier\" are used as defined in the \"CertID\"\n   specification
    [RFC6125].\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\",
    \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described
    in\n   [RFC2119].\n   Additionally, this document uses the following terms:\n
    \  POSH client:  A client that uses the application service and that\n      uses
    POSH to obtain material for verifying the service's identity.\n   POSH server:
    \ A server that hosts the application service and that\n      uses POSH to provide
    material for verifying its identity.\n"
  title: 2.  Terminology
- contents:
  - "3.  Obtaining Verification Material\n   Server identity checking (see [RFC6125])
    involves three different\n   aspects:\n   1.  A proof of the POSH server's identity
    (in PKIX, this takes the\n       form of a PKIX end-entity certificate [RFC5280]).\n
    \  2.  Rules for checking the certificate (which vary by application\n       protocol,
    although [RFC6125] attempts to harmonize those rules).\n   3.  The material that
    a POSH client uses to verify the POSH server's\n       identity or check the POSH
    server's proof (in PKIX, this takes\n       the form of chaining the end-entity
    certificate back to a trusted\n       root and performing all validity checks
    as described in\n       [RFC5280], [RFC6125], and the relevant application protocol\n
    \      specification).\n   When POSH is used, the first two aspects remain the
    same: the POSH\n   server proves its identity by presenting a PKIX certificate\n
    \  [RFC5280], and the certificate is checked according to the rules\n   defined
    in the appropriate application protocol specification (such\n   as [RFC6120] for
    XMPP).  However, the POSH client obtains the\n   material it will use to verify
    the server's proof by retrieving a\n   JSON document [RFC7159] containing hashes
    of the PKIX certificate\n   over HTTPS ([RFC7230] and [RFC2818]) from a well-known
    URI [RFC5785]\n   at the source domain.  POSH servers MUST use HTTPS.  This means
    that\n   the POSH client MUST verify the certificate of the HTTPS service at\n
    \  the source domain in order to securely \"bootstrap\" into the use of\n   POSH;
    specifically, the rules of [RFC2818] apply to this\n   \"bootstrapping\" step
    to provide a secure basis for all subsequent\n   POSH operations.\n   A PKIX certificate
    is retrieved over secure HTTP in the\n   following way:\n   1.  The POSH client
    performs an HTTPS GET request at the source\n       domain to the path \"/.well-known/posh/{servicedesc}.json\".
    \ The\n       value of \"{servicedesc}\" is application-specific; see Section
    8\n       of this document for more details.  For example, if the\n       application
    protocol is the hypothetical SPICE service, then\n       \"{servicedesc}\" could
    be \"spice\"; thus, if an application client\n       were to use POSH to verify
    an application server for the source\n       domain \"bar.example.com\", the HTTPS
    GET request would be as\n       follows:\n       GET /.well-known/posh/spice.json
    HTTP/1.1\n       Host: bar.example.com\n   2.  The source domain HTTPS server
    responds in one of three ways:\n       *  If it possesses PKIX certificate information
    for the requested\n          path, it responds as detailed in Section 3.1.\n       *
    \ If it has a reference to where the PKIX certificate\n          information can
    be obtained, it responds as detailed in\n          Section 3.2.\n       *  If
    it does not have any PKIX certificate information or a\n          reference to
    such information for the requested path, it\n          responds with an HTTP 404
    Not Found status code [RFC7231].\n"
  - contents:
    - "3.1.  Source Domain Possesses PKIX Certificate Information\n   If the source
      domain HTTPS server possesses the certificate\n   information, it responds to
      the HTTPS GET request with a success\n   status code and the message body set
      to a JSON document [RFC7159];\n   the document is a \"fingerprints document\",
      i.e., a JSON object with\n   the following members:\n   o  A \"fingerprints\"
      member whose value is a JSON array of fingerprint\n      descriptors (the member
      MUST include at least one fingerprint\n      descriptor).\n   o  An \"expires\"
      member whose value is a JSON number specifying the\n      number of seconds
      after which the POSH client ought to consider\n      the keying material to
      be stale (further explained under\n      Section 6).\n   The JSON document returned
      MUST NOT contain a \"url\" member, as\n   described in Section 3.2.\n   Each
      included fingerprint descriptor is a JSON object, where each\n   member name
      is the textual name of a hash function (as listed in\n   [HASH-NAMES]) and its
      associated value is the base64-encoded\n   fingerprint hash generated using
      the named hash function (where the\n   encoding adheres to the definition in
      Section 4 of [RFC4648] and\n   where the padding bits are set to zero).\n   The
      fingerprint hash for a given hash algorithm is generated by\n   performing the
      named hash function over the DER encoding of the PKIX\n   X.509 certificate.
      \ (This implies that if the certificate expires or\n   is revoked, the fingerprint
      value will be out of date.)\n   As an example of the fingerprint format, the
      \"sha-256\" and \"sha-512\"\n   fingerprints are generated by performing the
      SHA-256 and SHA-512 hash\n   functions, respectively, over the DER encoding
      of the PKIX\n   certificate, as illustrated below.  Note that for readability\n
      \  whitespace has been added to the content portion of the HTTP response\n   shown
      below but is not reflected in the Content-Length.\n   Example Fingerprints Response\n
      \  HTTP/1.1 200 OK\n   Content-Type: application/json\n   Content-Length: 195\n
      \  {\n     \"fingerprints\": [\n       {\n         \"sha-256\": \"4/mggdlVx8A3pvHAWW5sD+qJyMtUHgiRuPjVC48N0XQ=\",\n
      \        \"sha-512\": \"25N+1hB2Vo42l9lSGqw+n3BKFhDHsyork8ou+D9B43TXeJ\n                     1J81mdQEDqm39oR/EHkPBDDG1y5+AG94Kec0xVqA==\"\n
      \      }\n     ],\n     \"expires\": 604800\n   }\n   The \"expires\" value
      is a hint regarding the expiration of the keying\n   material.  It MUST be a
      non-negative integer.  If the \"expires\"\n   member has a value of 0 (zero),
      a POSH client MUST consider the\n   verification material to be invalid.  See
      Section 6 for how to\n   reconcile this \"expires\" member with the reference's
      \"expires\"\n   member.\n   To indicate alternate PKIX certificates (such as
      when an existing\n   certificate will soon expire), the returned fingerprints
      member MAY\n   contain multiple fingerprint descriptors.  The fingerprints SHOULD
      be\n   ordered with the most relevant certificate first as determined by the\n
      \  application service operator (e.g., the renewed certificate),\n   followed
      by the next most relevant certificate (e.g., the certificate\n   soonest to
      expire).  Here is an example (note that whitespace is\n   added for readability):\n
      \  {\n     \"fingerprints\": [\n       {\n         \"sha-256\": \"4/mggdlVx8A3pvHAWW5sD+qJyMtUHgiRuPjVC48N0XQ\",\n
      \        \"sha-512\": \"25N+1hB2Vo42l9lSGqw+n3BKFhDHsyork8ou+D9B43TXe\n                     J1J81mdQEDqm39oR/EHkPBDDG1y5+AG94Kec0xVqA==\"\n
      \      },\n       {\n         \"sha-256\": \"otyLADSKjRDjVpj8X7/hmCAD5C7Qe+PedcmYV7cUncE=\",\n
      \        \"sha-512\": \"MbBD+ausTGJisEXKSynROWrMfHP2xvBnmI79Pr/KXnDyLN\n                     +13Jof8/Uq9fj5HZG8Rk1E2fclcivpGdijUsvHRg==\"\n
      \      }\n     ],\n     \"expires\": 806400\n   }\n   Matching on any of these
      fingerprints is acceptable.\n   Rolling over from one hosting provider to another
      is best handled by\n   updating the relevant SRV records, not primarily by updating
      the POSH\n   documents themselves.\n"
    title: 3.1.  Source Domain Possesses PKIX Certificate Information
  - contents:
    - "3.2.  Source Domain References PKIX Certificate\n   If the source domain HTTPS
      server has a reference to the certificate\n   information, it responds to the
      HTTPS GET request with a success\n   status code and message body set to a JSON
      document.  The document is\n   a \"reference document\", i.e., a JSON object
      with the following\n   members:\n   o  A \"url\" member whose value is a JSON
      string specifying the HTTPS\n      URI where POSH clients can obtain the actual
      certificate\n      information.  The URI can be a well-known POSH URI as described
      in\n      Section 8, but it need not be.  (For historical reasons, the\n      member
      name is \"url\", not \"uri\".)\n   o  An \"expires\" member whose value is a
      JSON number specifying the\n      number of seconds after which the POSH client
      ought to consider\n      the delegation to be stale (further explained under
      Section 6).\n   Example Reference Response\n   HTTP/1.1 200 OK\n   Content-Type:
      application/json\n   Content-Length: 82\n   {\n     \"url\":\"https://hosting.example.net/.well-known/posh/spice.json\",\n
      \    \"expires\":86400\n   }\n   In order to process a reference response, the
      client performs an\n   HTTPS GET request for the URI specified in the \"url\"
      member value.\n   The HTTPS server for the URI to which the client has been
      referred\n   responds to the request with a JSON document containing fingerprints\n
      \  as described in Section 3.1.  The document retrieved from the\n   location
      specified by the \"url\" member MUST NOT itself be a reference\n   document
      (i.e., containing a \"url\" member instead of a \"fingerprints\"\n   member),
      in order to prevent circular delegations.\n      Note: See Section 10 for discussion
      about HTTPS redirects.\n   The \"expires\" value is a hint regarding the expiration
      of the source\n   domain's delegation of service to the delegated domain.  It
      MUST be a\n   non-negative integer.  If the \"expires\" member has a value of
      0\n   (zero), a POSH client MUST consider the delegation invalid.  See\n   Section
      6 for guidelines about reconciling this \"expires\" member with\n   the \"expires\"
      member of the fingerprints document.\n"
    title: 3.2.  Source Domain References PKIX Certificate
  - contents:
    - "3.3.  Performing Verification\n   The POSH client compares the PKIX information
      presented by the POSH\n   server against each fingerprint descriptor object
      in the POSH\n   fingerprints document, until a match is found using the hash\n
      \  functions that the client supports, or until the collection of POSH\n   verification
      material is exhausted.  If none of the fingerprint\n   descriptor objects match
      the POSH server PKIX information, the POSH\n   client SHOULD reject the connection
      (however, the POSH client might\n   still accept the connection if other verification
      methods are\n   successful, such as DANE [RFC6698]).\n"
    title: 3.3.  Performing Verification
  title: 3.  Obtaining Verification Material
- contents:
  - "4.  Secure Delegation\n   The delegation from the source domain to the delegated
    domain can be\n   considered secure if the credentials offered by the POSH server
    match\n   the verification material obtained by the client, regardless of how\n
    \  the material was obtained.\n"
  title: 4.  Secure Delegation
- contents:
  - "5.  Order of Operations\n   In order for the POSH client to perform verification
    of reference\n   identifiers without potentially compromising data, POSH operations\n
    \  MUST be complete before any application-layer data is exchanged for\n   the
    source domain.  In cases where the POSH client initiates an\n   application-layer
    connection, the client SHOULD perform all POSH\n   retrievals before initiating
    a connection (naturally, this is not\n   possible in cases where the POSH client
    receives instead of initiates\n   an application-layer connection).  For application
    protocols that use\n   DNS SRV (including queries for TLSA records in concert
    with SRV\n   records as described in [RFC7673]), the POSH operations ideally ought\n
    \  to be done in parallel with resolving the SRV records and the\n   addresses
    of any targets, similar to the \"Happy Eyeballs\" approach\n   for IPv4 and IPv6
    [RFC6555].\n   The following diagram illustrates the possession flow:\n    POSH
    \                     Source                      POSH\n   Client                     Domain
    \                    Server\n   ------                     ------                     ------\n
    \    |                          |                          |\n     |      POSH
    Request        |                          |\n     |------------------------->|
    \                         |\n     |                          |                          |\n
    \    | Return POSH fingerprints |                          |\n     |<-------------------------|
    \                         |\n     |                                                     |\n
    \    |                  Service TLS Handshake              |\n     |<===================================================>|\n
    \    |                                                     |\n     |                     Service
    Data                    |\n     |<===================================================>|\n
    \    |                                                     |\n               Figure
    1: Order of Events for Possession Flow\n   While the following diagram illustrates
    the reference flow:\n    POSH              Source       Delegated              POSH\n
    \  Client             Domain         Domain              Server\n   ------             ------
    \        ------              ------\n     |                  |              |
    \                  |\n     |  POSH Request    |              |                   |\n
    \    |----------------->|              |                   |\n     |                  |
    \             |                   |\n     | Return POSH url  |              |
    \                  |\n     |<-----------------|              |                   |\n
    \    |                                 |                   |\n     |            POSH
    Request         |                   |\n     |-------------------------------->|
    \                  |\n     |                                 |                   |\n
    \    |     Return POSH fingerprints    |                   |\n     |<--------------------------------|
    \                  |\n     |                                                     |\n
    \    |                 Service TLS Handshake               |\n     |<===================================================>|\n
    \    |                                                     |\n     |                     Service
    Data                    |\n     |<===================================================>|\n
    \    |                                                     |\n               Figure
    2: Order of Events for Reference Flow\n"
  title: 5.  Order of Operations
- contents:
  - "6.  Caching Results\n   The POSH client MUST NOT cache results (reference or
    fingerprints)\n   indefinitely.  If the source domain returns a reference, the
    POSH\n   client MUST use the lower of the two \"expires\" values when\n   determining
    how long to cache results (i.e., if the reference\n   \"expires\" value is lower
    than the fingerprints \"expires\" value, honor\n   the reference \"expires\" value).
    \ Once the POSH client considers the\n   results stale, it needs to perform the
    entire POSH operation again,\n   starting with the HTTPS GET request to the source
    domain.  The POSH\n   client MAY use a lower value than any provided in the \"expires\"\n
    \  member(s), or not cache results at all.\n   The foregoing considerations apply
    to the handling of the \"expires\"\n   values in POSH documents; naturally, a
    POSH client MUST NOT consider\n   an expired PKIX certificate to be valid, in
    accordance with\n   [RFC5280].\n   The POSH client SHOULD NOT rely on HTTP caching
    mechanisms, instead\n   using the expiration hints provided in the POSH reference
    document or\n   fingerprints document.  To that end, the HTTPS servers for source\n
    \  domains and derived domains SHOULD specify a 'Cache-Control' header\n   indicating
    a very short duration (e.g., max-age=60) or \"no-cache\" to\n   indicate that
    the response (redirect, reference, or fingerprints) is\n   not appropriate to
    cache at the HTTP layer.\n"
  title: 6.  Caching Results
- contents:
  - "7.  Guidance for Server Operators\n   POSH is intended to ease the operational
    burden of securing\n   application services, especially in multi-tenanted environments.
    \ It\n   does so by obviating the need to obtain certificates for hosted\n   domains,
    so that an operator can obtain a certificate only for its\n   hosting service
    (naturally, this certificate needs to be valid\n   according to [RFC5280] and
    contain the proper identifier(s) in\n   accordance with [RFC6125] and the relevant
    application protocol\n   specification).\n   However, in order to use POSH, an
    operator does need to coordinate\n   with its customers so that the appropriate
    POSH documents are\n   provided via HTTPS at a well-known URI at each customer's
    domain\n   (i.e., at the source domain), thus ensuring delegation to the\n   operator's
    hosting service (i.e., the delegated domain).  Because\n   correct hosting of
    the POSH document at the source domain is\n   essential for successful functioning
    of the POSH \"chain\", errors at\n   the source domain will result in authentication
    problems, certificate\n   warnings, and other operational issues.\n   Furthermore,
    if the POSH document is a reference document instead of\n   a fingerprints document,
    the operational burden is further decreased\n   because the operator does not
    need to provision its customers with\n   updated POSH documents when the certificate
    for the delegated domain\n   expires or is replaced.\n"
  title: 7.  Guidance for Server Operators
- contents:
  - "8.  Guidance for Protocol Authors\n   Protocols that use POSH are expected to
    register with the \"POSH\n   Service Names\" registry defined under Section 9.2.\n
    \  For POSH-using protocols that rely on DNS SRV records [RFC2782], the\n   service
    name SHOULD be the same as the DNS SRV \"Service\".  As an\n   example, the POSH
    service name for XMPP server-to-server connections\n   would be \"xmpp-server\"
    because [RFC6120] registers a DNS SRV\n   \"Service\" of \"xmpp-server\".  One
    example of the resulting well-known\n   URI would be \"https://example.com/.well-known/posh/xmpp-server.json\".\n
    \  For other POSH-using protocols, the service name MAY be any unique\n   string
    or identifier for the protocol; for example, it might be a\n   service name registered
    with the IANA in accordance with [RFC6335],\n   or it might be an unregistered
    name.  As an example, the well-known\n   URI for the hypothetical SPICE application
    might be \"spice\".\n"
  title: 8.  Guidance for Protocol Authors
- contents:
  - '9.  IANA Considerations

    '
  - contents:
    - "9.1.  Well-Known URI\n   IANA has registered \"posh\" in the \"Well-Known URIs\"
      registry as\n   defined by [RFC5785].  The completed template follows.\n   URI
      suffix:  posh\n   Change controller:  IETF\n   Specification:  RFC 7711 (this
      document)\n   Related information:  The suffix \"posh\" is expected to be followed
      by\n      an additional path component consisting of a service name (say,\n
      \     \"spice\") and a file extension of \".json\", resulting in a full path\n
      \     of, for instance, \"/.well-known/posh/spice.json\".  Registration of\n
      \     service names shall be requested by developers of the relevant\n      application
      protocols.\n"
    title: 9.1.  Well-Known URI
  - contents:
    - "9.2.  POSH Service Names\n   IANA has established the \"POSH Service Names\"
      registry within the\n   \"Uniform Resource Identifier (URI) Schemes\" group
      of registries.\n   The IANA registration policy [RFC5226] is Expert Review or
      IETF\n   Review (this was chosen instead of the more liberal policy of First\n
      \  Come First Served to help ensure that POSH services are defined in\n   ways
      that are consistent with this specification).  One or more\n   Designated Experts
      are to be appointed by the IESG or their delegate.\n   Registration requests
      are to be sent to the posh@ietf.org mailing\n   list for review and comment,
      with an appropriate subject (e.g.,\n   \"Request for POSH service name: example\").\n
      \  Before a period of 14 days has passed, the Designated Expert(s) will\n   either
      approve or deny the registration request, communicating this\n   decision both
      to the review list and to IANA.  Denials should include\n   an explanation and,
      if applicable, suggestions as to how to make the\n   request successful.  Registration
      requests that are undetermined for\n   a period longer than 21 days can be brought
      to the IESG's attention\n   (using the iesg@iesg.org mailing list) for resolution.\n"
    - contents:
      - "9.2.1.  Registration Template\n   Service name:  The name requested, relative
        to \"/.well-known/posh/\";\n      e.g., a service name of \"example\" would
        result in a well-known URI\n      such as \"https://example.com/.well-known/posh/example.json\".\n
        \  Change controller:  For Standards Track RFCs, state \"IETF\".  In all\n
        \     other cases, provide the name and email address of the responsible\n
        \     party.  Other details (e.g., postal address or website URI) may\n      also
        be included.\n   Definition and usage:  A brief description that defines the
        service\n      name and mentions where and how it is used (e.g., in the context\n
        \     of a particular application protocol).\n   Specification:  Optionally,
        reference to a document that specifies\n      the service or application protocol
        that uses the service name,\n      preferably including a URI that can be
        used to retrieve a copy of\n      the document.  An indication of the relevant
        sections may also be\n      included but is not required.\n"
      title: 9.2.1.  Registration Template
    title: 9.2.  POSH Service Names
  title: 9.  IANA Considerations
- contents:
  - "10.  Security Considerations\n   This document supplements but does not supersede
    the security\n   considerations provided in specifications for application protocols\n
    \  that decide to use POSH (e.g., [RFC6120] and [RFC6125] for XMPP).\n   Specifically,
    the security of requests and responses sent via HTTPS\n   depends on checking
    the identity of the HTTP server in accordance\n   with [RFC2818] as well as following
    the most modern best practices\n   for TLS as specified in [RFC7525].  Additionally,
    the security of\n   POSH can benefit from other HTTP-hardening protocols, such
    as HTTP\n   Strict Transport Security (HSTS) [RFC6797] and key pinning [RFC7469],\n
    \  especially if the POSH client shares some information with a common\n   HTTPS
    implementation (e.g., a platform-default web browser).\n   Note well that POSH
    is used by a POSH client to obtain the public key\n   of a POSH server to which
    it might connect for a particular\n   application protocol such as IMAP or XMPP.
    \ POSH does not enable a\n   hosted domain to transfer private keys to a hosting
    service via\n   HTTPS.  POSH also does not enable a POSH server to engage in\n
    \  certificate enrollment with a certification authority via HTTPS, as\n   is
    done in Enrollment over Secure Transport [RFC7030].\n   A web server at the source
    domain might redirect an HTTPS request to\n   another HTTPS URI.  The location
    provided in the redirect response\n   MUST specify an HTTPS URI.  Source domains
    SHOULD use only temporary\n   redirect mechanisms, such as HTTP status codes 302
    (Found) and 307\n   (Temporary Redirect) [RFC7231].  Clients MAY treat any redirect
    as\n   temporary, ignoring the specific semantics for 301 (Moved\n   Permanently)
    [RFC7231] and 308 (Permanent Redirect) [RFC7538].  To\n   protect against circular
    references, it is RECOMMENDED that POSH\n   clients follow no more than 10 redirects,
    although applications or\n   implementations can require that fewer redirects
    be followed.\n   Hash function agility is an important quality to ensure secure\n
    \  operations in the face of attacks against the fingerprints obtained\n   within
    verification material.  Because POSH verification material is\n   relatively short-lived
    compared to long-lived credentials such as\n   PKIX end-entity certificates (at
    least as typically deployed),\n   entities that deploy POSH are advised to swap
    out POSH documents if\n   the hash functions are found to be subject to practical
    attacks\n   [RFC4270].\n"
  title: 10.  Security Considerations
- contents:
  - '11.  References

    '
  - contents:
    - "11.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n
      \             DOI 10.17487/RFC2119, March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n
      \  [RFC2818]  Rescorla, E., \"HTTP Over TLS\", RFC 2818,\n              DOI
      10.17487/RFC2818, May 2000,\n              <http://www.rfc-editor.org/info/rfc2818>.\n
      \  [RFC4648]  Josefsson, S., \"The Base16, Base32, and Base64 Data\n              Encodings\",
      RFC 4648, DOI 10.17487/RFC4648, October 2006,\n              <http://www.rfc-editor.org/info/rfc4648>.\n
      \  [RFC5246]  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS)
      Protocol Version 1.2\", RFC 5246,\n              DOI 10.17487/RFC5246, August
      2008,\n              <http://www.rfc-editor.org/info/rfc5246>.\n   [RFC5280]
      \ Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,\n              Housley,
      R., and W. Polk, \"Internet X.509 Public Key\n              Infrastructure Certificate
      and Certificate Revocation List\n              (CRL) Profile\", RFC 5280, DOI
      10.17487/RFC5280, May 2008,\n              <http://www.rfc-editor.org/info/rfc5280>.\n
      \  [RFC5785]  Nottingham, M. and E. Hammer-Lahav, \"Defining Well-Known\n              Uniform
      Resource Identifiers (URIs)\", RFC 5785,\n              DOI 10.17487/RFC5785,
      April 2010,\n              <http://www.rfc-editor.org/info/rfc5785>.\n   [RFC6125]
      \ Saint-Andre, P. and J. Hodges, \"Representation and\n              Verification
      of Domain-Based Application Service Identity\n              within Internet
      Public Key Infrastructure Using X.509\n              (PKIX) Certificates in
      the Context of Transport Layer\n              Security (TLS)\", RFC 6125, DOI
      10.17487/RFC6125,\n              March 2011, <http://www.rfc-editor.org/info/rfc6125>.\n
      \  [RFC7159]  Bray, T., Ed., \"The JavaScript Object Notation (JSON) Data\n
      \             Interchange Format\", RFC 7159, DOI 10.17487/RFC7159,\n              March
      2014, <http://www.rfc-editor.org/info/rfc7159>.\n   [RFC7230]  Fielding, R.,
      Ed., and J. Reschke, Ed., \"Hypertext\n              Transfer Protocol (HTTP/1.1):
      Message Syntax and Routing\",\n              RFC 7230, DOI 10.17487/RFC7230,
      June 2014,\n              <http://www.rfc-editor.org/info/rfc7230>.\n   [RFC7231]
      \ Fielding, R., Ed., and J. Reschke, Ed., \"Hypertext\n              Transfer
      Protocol (HTTP/1.1): Semantics and Content\",\n              RFC 7231, DOI 10.17487/RFC7231,
      June 2014,\n              <http://www.rfc-editor.org/info/rfc7231>.\n   [RFC7525]
      \ Sheffer, Y., Holz, R., and P. Saint-Andre,\n              \"Recommendations
      for Secure Use of Transport Layer\n              Security (TLS) and Datagram
      Transport Layer Security\n              (DTLS)\", BCP 195, RFC 7525, DOI 10.17487/RFC7525,\n
      \             May 2015, <http://www.rfc-editor.org/info/rfc7525>.\n"
    title: 11.1.  Normative References
  - contents:
    - "11.2.  Informative References\n   [HASH-NAMES]\n              \"Hash Function
      Textual Names\",\n              <http://www.iana.org/assignments/\n              hash-function-text-names>.\n
      \  [RFC2782]  Gulbrandsen, A., Vixie, P., and L. Esibov, \"A DNS RR for\n              specifying
      the location of services (DNS SRV)\", RFC 2782,\n              DOI 10.17487/RFC2782,
      February 2000,\n              <http://www.rfc-editor.org/info/rfc2782>.\n   [RFC4033]
      \ Arends, R., Austein, R., Larson, M., Massey, D., and S.\n              Rose,
      \"DNS Security Introduction and Requirements\",\n              RFC 4033, DOI
      10.17487/RFC4033, March 2005,\n              <http://www.rfc-editor.org/info/rfc4033>.\n
      \  [RFC4270]  Hoffman, P. and B. Schneier, \"Attacks on Cryptographic\n              Hashes
      in Internet Protocols\", RFC 4270,\n              DOI 10.17487/RFC4270, November
      2005,\n              <http://www.rfc-editor.org/info/rfc4270>.\n   [RFC5226]
      \ Narten, T. and H. Alvestrand, \"Guidelines for Writing an\n              IANA
      Considerations Section in RFCs\", BCP 26, RFC 5226,\n              DOI 10.17487/RFC5226,
      May 2008,\n              <http://www.rfc-editor.org/info/rfc5226>.\n   [RFC6120]
      \ Saint-Andre, P., \"Extensible Messaging and Presence\n              Protocol
      (XMPP): Core\", RFC 6120, DOI 10.17487/RFC6120,\n              March 2011, <http://www.rfc-editor.org/info/rfc6120>.\n
      \  [RFC6335]  Cotton, M., Eggert, L., Touch, J., Westerlund, M., and S.\n              Cheshire,
      \"Internet Assigned Numbers Authority (IANA)\n              Procedures for the
      Management of the Service Name and\n              Transport Protocol Port Number
      Registry\", BCP 165,\n              RFC 6335, DOI 10.17487/RFC6335, August 2011,\n
      \             <http://www.rfc-editor.org/info/rfc6335>.\n   [RFC6555]  Wing,
      D. and A. Yourtchenko, \"Happy Eyeballs: Success with\n              Dual-Stack
      Hosts\", RFC 6555, DOI 10.17487/RFC6555,\n              April 2012, <http://www.rfc-editor.org/info/rfc6555>.\n
      \  [RFC6698]  Hoffman, P. and J. Schlyter, \"The DNS-Based Authentication\n
      \             of Named Entities (DANE) Transport Layer Security (TLS)\n              Protocol:
      TLSA\", RFC 6698, DOI 10.17487/RFC6698,\n              August 2012, <http://www.rfc-editor.org/info/rfc6698>.\n
      \  [RFC6797]  Hodges, J., Jackson, C., and A. Barth, \"HTTP Strict\n              Transport
      Security (HSTS)\", RFC 6797,\n              DOI 10.17487/RFC6797, November 2012,\n
      \             <http://www.rfc-editor.org/info/rfc6797>.\n   [RFC7030]  Pritikin,
      M., Ed., Yee, P., Ed., and D. Harkins, Ed.,\n              \"Enrollment over
      Secure Transport\", RFC 7030,\n              DOI 10.17487/RFC7030, October 2013,\n
      \             <http://www.rfc-editor.org/info/rfc7030>.\n   [RFC7469]  Evans,
      C., Palmer, C., and R. Sleevi, \"Public Key Pinning\n              Extension
      for HTTP\", RFC 7469, DOI 10.17487/RFC7469,\n              April 2015, <http://www.rfc-editor.org/info/rfc7469>.\n
      \  [RFC7538]  Reschke, J., \"The Hypertext Transfer Protocol Status\n              Code
      308 (Permanent Redirect)\", RFC 7538,\n              DOI 10.17487/RFC7538, April
      2015,\n              <http://www.rfc-editor.org/info/rfc7538>.\n   [RFC7673]
      \ Finch, T., Miller, M., and P. Saint-Andre, \"Using\n              DNS-Based
      Authentication of Named Entities (DANE) TLSA\n              Records with SRV
      Records\", RFC 7673, DOI 10.17487/RFC7673,\n              October 2015, <http://www.rfc-editor.org/info/rfc7673>.\n
      \  [RFC7712]  Saint-Andre, P., Miller, M., and P. Hancke, \"Domain Name\n              Associations
      (DNA) in the Extensible Messaging and\n              Presence Protocol (XMPP)\",
      RFC 7712, DOI 10.17487/RFC7712,\n              November 2015, <http://www.rfc-editor.org/info/rfc7712>.\n"
    title: 11.2.  Informative References
  title: 11.  References
- contents:
  - "Acknowledgements\n   Thanks to Thijs Alkemade, Philipp Hancke, Joe Hildebrand,
    and Tobias\n   Markmann for their implementation feedback, and to Dave Cridland,\n
    \  Chris Newton, Max Pritikin, and Joe Salowey for their input on the\n   specification.\n
    \  During IESG review, Stephen Farrell, Barry Leiba, and Kathleen\n   Moriarty
    provided helpful input that resulted in improvements in the\n   document.\n   Thanks
    also to Dave Cridland as document shepherd, Joe Hildebrand as\n   working group
    chair, and Ben Campbell as area director.\n   Peter Saint-Andre wishes to acknowledge
    Cisco Systems, Inc., for\n   employing him during his work on earlier draft versions
    of this\n   document.\n"
  title: Acknowledgements
- contents:
  - "Authors' Addresses\n   Matthew Miller\n   Cisco Systems, Inc.\n   1899 Wynkoop
    Street, Suite 600\n   Denver, CO  80202\n   United States\n   Email: mamille2@cisco.com\n
    \  Peter Saint-Andre\n   &yet\n   Email: peter@andyet.com\n   URI:   https://andyet.com/\n"
  title: Authors' Addresses
