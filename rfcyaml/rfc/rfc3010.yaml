- title: __initial_text__
  contents:
  - '                         NFS version 4 Protocol

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2000).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   NFS (Network File System) version 4 is a distributed file system\n\
    \   protocol which owes heritage to NFS protocol versions 2 [RFC1094] and\n  \
    \ 3 [RFC1813].  Unlike earlier versions, the NFS version 4 protocol\n   supports\
    \ traditional file access while integrating support for file\n   locking and the\
    \ mount protocol.  In addition, support for strong\n   security (and its negotiation),\
    \ compound operations, client caching,\n   and internationalization have been\
    \ added.  Of course, attention has\n   been applied to making NFS version 4 operate\
    \ well in an Internet\n   environment.\n"
- title: Key Words
  contents:
  - "Key Words\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",\
    \ \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC\
    \ 2119.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   5\n   1.1.  Overview of NFS Version 4 Features . . . . . . . . .\
    \ . . .   6\n   1.1.1.  RPC and Security . . . . . . . . . . . . . . . . . . .\
    \ .   6\n   1.1.2.  Procedure and Operation Structure  . . . . . . . . . . . \
    \  7\n   1.1.3.  File System Model  . . . . . . . . . . . . . . . . . . .   8\n\
    \   1.1.3.1.  Filehandle Types . . . . . . . . . . . . . . . . . . .   8\n   1.1.3.2.\
    \  Attribute Types  . . . . . . . . . . . . . . . . . . .   8\n   1.1.3.3.  File\
    \ System Replication and Migration  . . . . . . . .   9\n   1.1.4.  OPEN and CLOSE\
    \ . . . . . . . . . . . . . . . . . . . . .   9\n   1.1.5.  File locking . . .\
    \ . . . . . . . . . . . . . . . . . . .   9\n   1.1.6.  Client Caching and Delegation\
    \  . . . . . . . . . . . . .  10\n   1.2.  General Definitions  . . . . . . .\
    \ . . . . . . . . . . . .  11\n   2.  Protocol Data Types  . . . . . . . . . .\
    \ . . . . . . . . . .  12\n   2.1.  Basic Data Types . . . . . . . . . . . . .\
    \ . . . . . . . .  12\n   2.2.  Structured Data Types  . . . . . . . . . . . .\
    \ . . . . . .  14\n   3.  RPC and Security Flavor  . . . . . . . . . . . . . .\
    \ . . . .  18\n   3.1.  Ports and Transports . . . . . . . . . . . . . . . . .\
    \ . .  18\n   3.2.  Security Flavors . . . . . . . . . . . . . . . . . . . . .\
    \  18\n   3.2.1.  Security mechanisms for NFS version 4  . . . . . . . . .  19\n\
    \   3.2.1.1.  Kerberos V5 as security triple . . . . . . . . . . . .  19\n   3.2.1.2.\
    \  LIPKEY as a security triple  . . . . . . . . . . . . .  19\n   3.2.1.3.  SPKM-3\
    \ as a security triple  . . . . . . . . . . . . .  20\n   3.3.  Security Negotiation\
    \ . . . . . . . . . . . . . . . . . . .  21\n   3.3.1.  Security Error . . . .\
    \ . . . . . . . . . . . . . . . . .  21\n   3.3.2.  SECINFO  . . . . . . . . .\
    \ . . . . . . . . . . . . . . .  21\n   3.4.  Callback RPC Authentication  . .\
    \ . . . . . . . . . . . . .  22\n   4.  Filehandles  . . . . . . . . . . . . .\
    \ . . . . . . . . . . .  23\n   4.1.  Obtaining the First Filehandle . . . . .\
    \ . . . . . . . . .  24\n   4.1.1.  Root Filehandle  . . . . . . . . . . . . .\
    \ . . . . . . .  24\n   4.1.2.  Public Filehandle  . . . . . . . . . . . . . .\
    \ . . . . .  24\n   4.2.  Filehandle Types . . . . . . . . . . . . . . . . . .\
    \ . . .  25\n   4.2.1.  General Properties of a Filehandle . . . . . . . . . .\
    \ .  25\n   4.2.2.  Persistent Filehandle  . . . . . . . . . . . . . . . . . \
    \ 26\n   4.2.3.  Volatile Filehandle  . . . . . . . . . . . . . . . . . .  26\n\
    \   4.2.4.  One Method of Constructing a Volatile Filehandle . . . .  28\n   4.3.\
    \  Client Recovery from Filehandle Expiration . . . . . . . .  28\n   5.  File\
    \ Attributes  . . . . . . . . . . . . . . . . . . . . . .  29\n   5.1.  Mandatory\
    \ Attributes . . . . . . . . . . . . . . . . . . .  30\n   5.2.  Recommended Attributes\
    \ . . . . . . . . . . . . . . . . . .  30\n   5.3.  Named Attributes . . . . .\
    \ . . . . . . . . . . . . . . . .  31\n   5.4.  Mandatory Attributes - Definitions\
    \ . . . . . . . . . . . .  31\n   5.5.  Recommended Attributes - Definitions .\
    \ . . . . . . . . . .  33\n   5.6.  Interpreting owner and owner_group . . . .\
    \ . . . . . . . .  38\n   5.7.  Character Case Attributes  . . . . . . . . . .\
    \ . . . . . .  39\n   5.8.  Quota Attributes . . . . . . . . . . . . . . . . .\
    \ . . . .  39\n   5.9.  Access Control Lists . . . . . . . . . . . . . . . . .\
    \ . .  40\n   5.9.1.  ACE type . . . . . . . . . . . . . . . . . . . . . . . .\
    \  41\n   5.9.2.  ACE flag . . . . . . . . . . . . . . . . . . . . . . . .  41\n\
    \   5.9.3.  ACE Access Mask  . . . . . . . . . . . . . . . . . . . .  43\n   5.9.4.\
    \  ACE who  . . . . . . . . . . . . . . . . . . . . . . . .  44\n   6.  File System\
    \ Migration and Replication  . . . . . . . . . . .  44\n   6.1.  Replication \
    \ . . . . . . . . . . . . . . . . . . . . . . .  45\n   6.2.  Migration  . . .\
    \ . . . . . . . . . . . . . . . . . . . . .  45\n   6.3.  Interpretation of the\
    \ fs_locations Attribute . . . . . . .  46\n   6.4.  Filehandle Recovery for Migration\
    \ or Replication . . . . .  47\n   7.  NFS Server Name Space  . . . . . . . .\
    \ . . . . . . . . . . .  47\n   7.1.  Server Exports . . . . . . . . . . . . .\
    \ . . . . . . . . .  47\n   7.2.  Browsing Exports . . . . . . . . . . . . . .\
    \ . . . . . . .  48\n   7.3.  Server Pseudo File System  . . . . . . . . . . .\
    \ . . . . .  48\n   7.4.  Multiple Roots . . . . . . . . . . . . . . . . . . .\
    \ . . .  49\n   7.5.  Filehandle Volatility  . . . . . . . . . . . . . . . . .\
    \ .  49\n   7.6.  Exported Root  . . . . . . . . . . . . . . . . . . . . . . \
    \ 49\n   7.7.  Mount Point Crossing . . . . . . . . . . . . . . . . . . .  49\n\
    \   7.8.  Security Policy and Name Space Presentation  . . . . . . .  50\n   8.\
    \  File Locking and Share Reservations  . . . . . . . . . . . .  50\n   8.1. \
    \ Locking  . . . . . . . . . . . . . . . . . . . . . . . . .  51\n   8.1.1.  Client\
    \ ID  . . . . . . . . . . . . . . . . . . . . . . .  51\n   8.1.2.  Server Release\
    \ of Clientid . . . . . . . . . . . . . . .  53\n   8.1.3.  nfs_lockowner and\
    \ stateid Definition . . . . . . . . . .  54\n   8.1.4.  Use of the stateid .\
    \ . . . . . . . . . . . . . . . . . .  55\n   8.1.5.  Sequencing of Lock Requests\
    \  . . . . . . . . . . . . . .  56\n   8.1.6.  Recovery from Replayed Requests\
    \  . . . . . . . . . . . .  56\n   8.1.7.  Releasing nfs_lockowner State  . .\
    \ . . . . . . . . . . .  57\n   8.2.  Lock Ranges  . . . . . . . . . . . . . .\
    \ . . . . . . . . .  57\n   8.3.  Blocking Locks . . . . . . . . . . . . . . .\
    \ . . . . . . .  58\n   8.4.  Lease Renewal  . . . . . . . . . . . . . . . . .\
    \ . . . . .  58\n   8.5.  Crash Recovery . . . . . . . . . . . . . . . . . . .\
    \ . . .  59\n   8.5.1.  Client Failure and Recovery  . . . . . . . . . . . . .\
    \ .  59\n   8.5.2.  Server Failure and Recovery  . . . . . . . . . . . . . . \
    \ 60\n   8.5.3.  Network Partitions and Recovery  . . . . . . . . . . . .  62\n\
    \   8.6.  Recovery from a Lock Request Timeout or Abort  . . . . . .  63\n   8.7.\
    \  Server Revocation of Locks . . . . . . . . . . . . . . . .  63\n   8.8.  Share\
    \ Reservations . . . . . . . . . . . . . . . . . . . .  65\n   8.9.  OPEN/CLOSE\
    \ Operations  . . . . . . . . . . . . . . . . . .  65\n   8.10.  Open Upgrade\
    \ and Downgrade  . . . . . . . . . . . . . . .  66\n   8.11.  Short and Long Leases\
    \ . . . . . . . . . . . . . . . . . .  66\n   8.12.  Clocks and Calculating Lease\
    \ Expiration . . . . . . . . .  67\n   8.13.  Migration, Replication and State\
    \  . . . . . . . . . . . .  67\n   8.13.1.  Migration and State . . . . . . .\
    \ . . . . . . . . . . .  67\n   8.13.2.  Replication and State . . . . . . . .\
    \ . . . . . . . . .  68\n   8.13.3.  Notification of Migrated Lease  . . . . .\
    \ . . . . . . .  69\n   9.  Client-Side Caching  . . . . . . . . . . . . . . .\
    \ . . . . .  69\n   9.1.  Performance Challenges for Client-Side Caching . . .\
    \ . . .  70\n   9.2.  Delegation and Callbacks . . . . . . . . . . . . . . . .\
    \ .  71\n   9.2.1.  Delegation Recovery  . . . . . . . . . . . . . . . . . . \
    \ 72\n   9.3.  Data Caching . . . . . . . . . . . . . . . . . . . . . . .  74\n\
    \   9.3.1.  Data Caching and OPENs . . . . . . . . . . . . . . . . .  74\n   9.3.2.\
    \  Data Caching and File Locking  . . . . . . . . . . . . .  75\n   9.3.3.  Data\
    \ Caching and Mandatory File Locking  . . . . . . . .  77\n   9.3.4.  Data Caching\
    \ and File Identity . . . . . . . . . . . . .  77\n   9.4.  Open Delegation  .\
    \ . . . . . . . . . . . . . . . . . . . .  78\n   9.4.1.  Open Delegation and\
    \ Data Caching . . . . . . . . . . . .  80\n   9.4.2.  Open Delegation and File\
    \ Locks . . . . . . . . . . . . .  82\n   9.4.3.  Recall of Open Delegation  .\
    \ . . . . . . . . . . . . . .  82\n   9.4.4.  Delegation Revocation  . . . . .\
    \ . . . . . . . . . . . .  84\n   9.5.  Data Caching and Revocation  . . . . .\
    \ . . . . . . . . . .  84\n   9.5.1.  Revocation Recovery for Write Open Delegation\
    \  . . . . .  85\n   9.6.  Attribute Caching  . . . . . . . . . . . . . . . .\
    \ . . . .  85\n   9.7.  Name Caching . . . . . . . . . . . . . . . . . . . . .\
    \ . .  86\n   9.8.  Directory Caching  . . . . . . . . . . . . . . . . . . . .\
    \  87\n   10.  Minor Versioning  . . . . . . . . . . . . . . . . . . . . .  88\n\
    \   11.  Internationalization  . . . . . . . . . . . . . . . . . . .  91\n   11.1.\
    \  Universal Versus Local Character Sets . . . . . . . . . .  91\n   11.2.  Overview\
    \ of Universal Character Set Standards . . . . . .  92\n   11.3.  Difficulties\
    \ with UCS-4, UCS-2, Unicode . . . . . . . . .  93\n   11.4.  UTF-8 and its solutions\
    \ . . . . . . . . . . . . . . . . .  94\n   11.5.  Normalization . . . . . . .\
    \ . . . . . . . . . . . . . . .  94\n   12.  Error Definitions . . . . . . . .\
    \ . . . . . . . . . . . . .  95\n   13.  NFS Version 4 Requests  . . . . . . .\
    \ . . . . . . . . . . .  99\n   13.1.  Compound Procedure  . . . . . . . . . .\
    \ . . . . . . . . . 100\n   13.2.  Evaluation of a Compound Request  . . . . .\
    \ . . . . . . . 100\n   13.3.  Synchronous Modifying Operations  . . . . . . .\
    \ . . . . . 101\n   13.4.  Operation Values  . . . . . . . . . . . . . . . . .\
    \ . . . 102\n   14.  NFS Version 4 Procedures  . . . . . . . . . . . . . . . .\
    \ . 102\n   14.1.  Procedure 0: NULL - No Operation  . . . . . . . . . . . . 102\n\
    \   14.2.  Procedure 1: COMPOUND - Compound Operations . . . . . . . 102\n   14.2.1.\
    \  Operation 3: ACCESS - Check Access Rights . . . . . . . 105\n   14.2.2.  Operation\
    \ 4: CLOSE - Close File . . . . . . . . . . . . 108\n   14.2.3.  Operation 5:\
    \ COMMIT - Commit Cached Data  . . . . . . . 109\n   14.2.4.  Operation 6: CREATE\
    \ - Create a Non-Regular File Object. 112\n   14.2.5.  Operation 7: DELEGPURGE\
    \ - Purge Delegations Awaiting\n            Recovery  . . . . . . . . . . . .\
    \ . . . . . . . . . . . 114\n   14.2.6.  Operation 8: DELEGRETURN - Return Delegation\
    \  . . . . . 115\n   14.2.7.  Operation 9: GETATTR - Get Attributes . . . . .\
    \ . . . . 115\n   14.2.8.  Operation 10: GETFH - Get Current Filehandle  . . .\
    \ . . 117\n   14.2.9.  Operation 11: LINK - Create Link to a File  . . . . . .\
    \ 118\n   14.2.10.  Operation 12: LOCK - Create Lock . . . . . . . . . . . 119\n\
    \   14.2.11.  Operation 13: LOCKT - Test For Lock  . . . . . . . . . 121\n   14.2.12.\
    \  Operation 14: LOCKU - Unlock File  . . . . . . . . . . 122\n   14.2.13.  Operation\
    \ 15: LOOKUP - Lookup Filename . . . . . . . . 123\n   14.2.14.  Operation 16:\
    \ LOOKUPP - Lookup Parent Directory  . . . 126\n   14.2.15.  Operation 17: NVERIFY\
    \ - Verify Difference in\n             Attributes . . . . . . . . . . . . . .\
    \ . . . . . . . . 127\n   14.2.16.  Operation 18: OPEN - Open a Regular File .\
    \ . . . . . . 128\n   14.2.17.  Operation 19: OPENATTR - Open Named Attribute\n\
    \             Directory  . . . . . . . . . . . . . . . . . . . . . . 137\n   14.2.18.\
    \  Operation 20: OPEN_CONFIRM - Confirm Open  . . . . . . 138\n   14.2.19.  Operation\
    \ 21: OPEN_DOWNGRADE - Reduce Open File Access 140\n   14.2.20.  Operation 22:\
    \ PUTFH - Set Current Filehandle . . . . . 141\n   14.2.21.  Operation 23: PUTPUBFH\
    \ - Set Public Filehandle . . . . 142\n   14.2.22.  Operation 24: PUTROOTFH -\
    \ Set Root Filehandle  . . . . 143\n   14.2.23.  Operation 25: READ - Read from\
    \ File  . . . . . . . . . 144\n   14.2.24.  Operation 26: READDIR - Read Directory\
    \ . . . . . . . . 146\n   14.2.25.  Operation 27: READLINK - Read Symbolic Link\
    \  . . . . . 150\n   14.2.26.  Operation 28: REMOVE - Remove Filesystem Object\
    \  . . . 151\n   14.2.27.  Operation 29: RENAME - Rename Directory Entry  . .\
    \ . . 153\n   14.2.28.  Operation 30: RENEW - Renew a Lease  . . . . . . . . .\
    \ 155\n   14.2.29.  Operation 31: RESTOREFH - Restore Saved Filehandle . . 156\n\
    \   14.2.30.  Operation 32: SAVEFH - Save Current Filehandle . . . . 157\n   14.2.31.\
    \  Operation 33: SECINFO - Obtain Available Security  . . 158\n   14.2.32.  Operation\
    \ 34: SETATTR - Set Attributes . . . . . . . . 160\n   14.2.33.  Operation 35:\
    \ SETCLIENTID - Negotiate Clientid . . . . 162\n   14.2.34.  Operation 36: SETCLIENTID_CONFIRM\
    \ - Confirm Clientid . 163\n   14.2.35.  Operation 37: VERIFY - Verify Same Attributes\
    \  . . . . 164\n   14.2.36.  Operation 38: WRITE - Write to File  . . . . . .\
    \ . . . 166\n   15.  NFS Version 4 Callback Procedures . . . . . . . . . . . .\
    \ . 170\n   15.1.  Procedure 0: CB_NULL - No Operation . . . . . . . . . . . 170\n\
    \   15.2.  Procedure 1: CB_COMPOUND - Compound Operations  . . . . . 171\n   15.2.1.\
    \  Operation 3: CB_GETATTR - Get Attributes  . . . . . . . 172\n   15.2.2.  Operation\
    \ 4: CB_RECALL - Recall an Open Delegation  . . 173\n   16.  Security Considerations\
    \ . . . . . . . . . . . . . . . . . . 174\n   17.  IANA Considerations . . . .\
    \ . . . . . . . . . . . . . . . . 174\n   17.1.  Named Attribute Definition  .\
    \ . . . . . . . . . . . . . . 174\n   18.  RPC definition file . . . . . . . .\
    \ . . . . . . . . . . . . 175\n   19.  Bibliography  . . . . . . . . . . . . .\
    \ . . . . . . . . . . 206\n   20.  Authors . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . 210\n   20.1.  Editor's Address  . . . . . . . . . . . . . .\
    \ . . . . . . 210\n   20.2.  Authors' Addresses  . . . . . . . . . . . . . . .\
    \ . . . . 210\n   20.3.  Acknowledgements  . . . . . . . . . . . . . . . . . .\
    \ . . 211\n   21.  Full Copyright Statement  . . . . . . . . . . . . . . . . .\
    \ 212\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The NFS version 4 protocol is a further revision of the\
    \ NFS protocol\n   defined already by versions 2 [RFC1094] and 3 [RFC1813].  It\
    \ retains\n   the essential characteristics of previous versions: design for easy\n\
    \   recovery, independent of transport protocols, operating systems and\n   filesystems,\
    \ simplicity, and good performance.  The NFS version 4\n   revision has the following\
    \ goals:\n   o  Improved access and good performance on the Internet.\n      The\
    \ protocol is designed to transit firewalls easily, perform well\n      where\
    \ latency is high and bandwidth is low, and scale to very\n      large numbers\
    \ of clients per server.\n   o  Strong security with negotiation built into the\
    \ protocol.\n      The protocol builds on the work of the ONCRPC working group\
    \ in\n      supporting the RPCSEC_GSS protocol.  Additionally, the NFS version\n\
    \      4 protocol provides a mechanism to allow clients and servers the\n    \
    \  ability to negotiate security and require clients and servers to\n      support\
    \ a minimal set of security schemes.\n   o  Good cross-platform interoperability.\n\
    \      The protocol features a file system model that provides a useful,\n   \
    \   common set of features that does not unduly favor one file system\n      or\
    \ operating system over another.\n   o  Designed for protocol extensions.\n  \
    \    The protocol is designed to accept standard extensions that do not\n    \
    \  compromise backward compatibility.\n"
- title: 1.1.  Overview of NFS Version 4 Features
  contents:
  - "1.1.  Overview of NFS Version 4 Features\n   To provide a reasonable context\
    \ for the reader, the major features of\n   NFS version 4 protocol will be reviewed\
    \ in brief.  This will be done\n   to provide an appropriate context for both\
    \ the reader who is familiar\n   with the previous versions of the NFS protocol\
    \ and the reader that is\n   new to the NFS protocols.  For the reader new to\
    \ the NFS protocols,\n   there is still a fundamental knowledge that is expected.\
    \  The reader\n   should be familiar with the XDR and RPC protocols as described\
    \ in\n   [RFC1831] and [RFC1832].  A basic knowledge of file systems and\n   distributed\
    \ file systems is expected as well.\n"
- title: 1.1.1.  RPC and Security
  contents:
  - "1.1.1.  RPC and Security\n   As with previous versions of NFS, the External Data\
    \ Representation\n   (XDR) and Remote Procedure Call (RPC) mechanisms used for\
    \ the NFS\n   version 4 protocol are those defined in [RFC1831] and [RFC1832].\
    \  To\n   meet end to end security requirements, the RPCSEC_GSS framework\n  \
    \ [RFC2203] will be used to extend the basic RPC security.  With the\n   use of\
    \ RPCSEC_GSS, various mechanisms can be provided to offer\n   authentication,\
    \ integrity, and privacy to the NFS version 4 protocol.\n   Kerberos V5 will be\
    \ used as described in [RFC1964] to provide one\n   security framework.  The LIPKEY\
    \ GSS-API mechanism described in\n   [RFC2847] will be used to provide for the\
    \ use of user password and\n   server public key by the NFS version 4 protocol.\
    \  With the use of\n   RPCSEC_GSS, other mechanisms may also be specified and\
    \ used for NFS\n   version 4 security.\n   To enable in-band security negotiation,\
    \ the NFS version 4 protocol\n   has added a new operation which provides the\
    \ client a method of\n   querying the server about its policies regarding which\
    \ security\n   mechanisms must be used for access to the server's file system\n\
    \   resources.  With this, the client can securely match the security\n   mechanism\
    \ that meets the policies specified at both the client and\n   server.\n"
- title: 1.1.2.  Procedure and Operation Structure
  contents:
  - "1.1.2.  Procedure and Operation Structure\n   A significant departure from the\
    \ previous versions of the NFS\n   protocol is the introduction of the COMPOUND\
    \ procedure.  For the NFS\n   version 4 protocol, there are two RPC procedures,\
    \ NULL and COMPOUND.\n   The COMPOUND procedure is defined in terms of operations\
    \ and these\n   operations correspond more closely to the traditional NFS procedures.\n\
    \   With the use of the COMPOUND procedure, the client is able to build\n   simple\
    \ or complex requests.  These COMPOUND requests allow for a\n   reduction in the\
    \ number of RPCs needed for logical file system\n   operations.  For example,\
    \ without previous contact with a server a\n   client will be able to read data\
    \ from a file in one request by\n   combining LOOKUP, OPEN, and READ operations\
    \ in a single COMPOUND RPC.\n   With previous versions of the NFS protocol, this\
    \ type of single\n   request was not possible.\n   The model used for COMPOUND\
    \ is very simple.  There is no logical OR\n   or ANDing of operations.  The operations\
    \ combined within a COMPOUND\n   request are evaluated in order by the server.\
    \  Once an operation\n   returns a failing result, the evaluation ends and the\
    \ results of all\n   evaluated operations are returned to the client.\n   The\
    \ NFS version 4 protocol continues to have the client refer to a\n   file or directory\
    \ at the server by a \"filehandle\".  The COMPOUND\n   procedure has a method\
    \ of passing a filehandle from one operation to\n   another within the sequence\
    \ of operations.  There is a concept of a\n   \"current filehandle\" and \"saved\
    \ filehandle\".  Most operations use the\n   \"current filehandle\" as the file\
    \ system object to operate upon.  The\n   \"saved filehandle\" is used as temporary\
    \ filehandle storage within a\n   COMPOUND procedure as well as an additional\
    \ operand for certain\n   operations.\n"
- title: 1.1.3.  File System Model
  contents:
  - "1.1.3.  File System Model\n   The general file system model used for the NFS\
    \ version 4 protocol is\n   the same as previous versions.  The server file system\
    \ is\n   hierarchical with the regular files contained within being treated as\n\
    \   opaque byte streams.  In a slight departure, file and directory names\n  \
    \ are encoded with UTF-8 to deal with the basics of\n   internationalization.\n\
    \   The NFS version 4 protocol does not require a separate protocol to\n   provide\
    \ for the initial mapping between path name and filehandle.\n   Instead of using\
    \ the older MOUNT protocol for this mapping, the\n   server provides a ROOT filehandle\
    \ that represents the logical root or\n   top of the file system tree provided\
    \ by the server.  The server\n   provides multiple file systems by gluing them\
    \ together with pseudo\n   file systems.  These pseudo file systems provide for\
    \ potential gaps\n   in the path names between real file systems.\n"
- title: 1.1.3.1.  Filehandle Types
  contents:
  - "1.1.3.1.  Filehandle Types\n   In previous versions of the NFS protocol, the\
    \ filehandle provided by\n   the server was guaranteed to be valid or persistent\
    \ for the lifetime\n   of the file system object to which it referred.  For some\
    \ server\n   implementations, this persistence requirement has been difficult\
    \ to\n   meet.  For the NFS version 4 protocol, this requirement has been\n  \
    \ relaxed by introducing another type of filehandle, volatile.  With\n   persistent\
    \ and volatile filehandle types, the server implementation\n   can match the abilities\
    \ of the file system at the server along with\n   the operating environment. \
    \ The client will have knowledge of the\n   type of filehandle being provided\
    \ by the server and can be prepared\n   to deal with the semantics of each.\n"
- title: 1.1.3.2.  Attribute Types
  contents:
  - "1.1.3.2.  Attribute Types\n   The NFS version 4 protocol introduces three classes\
    \ of file system or\n   file attributes.  Like the additional filehandle type,\
    \ the\n   classification of file attributes has been done to ease server\n   implementations\
    \ along with extending the overall functionality of the\n   NFS protocol.  This\
    \ attribute model is structured to be extensible\n   such that new attributes\
    \ can be introduced in minor revisions of the\n   protocol without requiring significant\
    \ rework.\n   The three classifications are: mandatory, recommended and named\n\
    \   attributes.  This is a significant departure from the previous\n   attribute\
    \ model used in the NFS protocol.  Previously, the attributes\n   for the file\
    \ system and file objects were a fixed set of mainly Unix\n   attributes.  If\
    \ the server or client did not support a particular\n   attribute, it would have\
    \ to simulate the attribute the best it could.\n   Mandatory attributes are the\
    \ minimal set of file or file system\n   attributes that must be provided by the\
    \ server and must be properly\n   represented by the server.  Recommended attributes\
    \ represent\n   different file system types and operating environments.  The\n\
    \   recommended attributes will allow for better interoperability and the\n  \
    \ inclusion of more operating environments.  The mandatory and\n   recommended\
    \ attribute sets are traditional file or file system\n   attributes.  The third\
    \ type of attribute is the named attribute.  A\n   named attribute is an opaque\
    \ byte stream that is associated with a\n   directory or file and referred to\
    \ by a string name.  Named attributes\n   are meant to be used by client applications\
    \ as a method to associate\n   application specific data with a regular file or\
    \ directory.\n   One significant addition to the recommended set of file attributes\
    \ is\n   the Access Control List (ACL) attribute.  This attribute provides for\n\
    \   directory and file access control beyond the model used in previous\n   versions\
    \ of the NFS protocol.  The ACL definition allows for\n   specification of user\
    \ and group level access control.\n"
- title: 1.1.3.3.  File System Replication and Migration
  contents:
  - "1.1.3.3.  File System Replication and Migration\n   With the use of a special\
    \ file attribute, the ability to migrate or\n   replicate server file systems\
    \ is enabled within the protocol.  The\n   file system locations attribute provides\
    \ a method for the client to\n   probe the server about the location of a file\
    \ system.  In the event\n   of a migration of a file system, the client will receive\
    \ an error\n   when operating on the file system and it can then query as to the\
    \ new\n   file system location.  Similar steps are used for replication, the\n\
    \   client is able to query the server for the multiple available\n   locations\
    \ of a particular file system.  From this information, the\n   client can use\
    \ its own policies to access the appropriate file system\n   location.\n"
- title: 1.1.4.  OPEN and CLOSE
  contents:
  - "1.1.4.  OPEN and CLOSE\n   The NFS version 4 protocol introduces OPEN and CLOSE\
    \ operations.  The\n   OPEN operation provides a single point where file lookup,\
    \ creation,\n   and share semantics can be combined.  The CLOSE operation also\n\
    \   provides for the release of state accumulated by OPEN.\n"
- title: 1.1.5.  File locking
  contents:
  - "1.1.5.  File locking\n   With the NFS version 4 protocol, the support for byte\
    \ range file\n   locking is part of the NFS protocol.  The file locking support\
    \ is\n   structured so that an RPC callback mechanism is not required.  This\n\
    \   is a departure from the previous versions of the NFS file locking\n   protocol,\
    \ Network Lock Manager (NLM).  The state associated with file\n   locks is maintained\
    \ at the server under a lease-based model.  The\n   server defines a single lease\
    \ period for all state held by a NFS\n   client.  If the client does not renew\
    \ its lease within the defined\n   period, all state associated with the client's\
    \ lease may be released\n   by the server.  The client may renew its lease with\
    \ use of the RENEW\n   operation or implicitly by use of other operations (primarily\
    \ READ).\n"
- title: 1.1.6.  Client Caching and Delegation
  contents:
  - "1.1.6.  Client Caching and Delegation\n   The file, attribute, and directory\
    \ caching for the NFS version 4\n   protocol is similar to previous versions.\
    \  Attributes and directory\n   information are cached for a duration determined\
    \ by the client.  At\n   the end of a predefined timeout, the client will query\
    \ the server to\n   see if the related file system object has been updated.\n\
    \   For file data, the client checks its cache validity when the file is\n   opened.\
    \  A query is sent to the server to determine if the file has\n   been changed.\
    \  Based on this information, the client determines if\n   the data cache for\
    \ the file should kept or released.  Also, when the\n   file is closed, any modified\
    \ data is written to the server.\n   If an application wants to serialize access\
    \ to file data, file\n   locking of the file data ranges in question should be\
    \ used.\n   The major addition to NFS version 4 in the area of caching is the\n\
    \   ability of the server to delegate certain responsibilities to the\n   client.\
    \  When the server grants a delegation for a file to a client,\n   the client\
    \ is guaranteed certain semantics with respect to the\n   sharing of that file\
    \ with other clients.  At OPEN, the server may\n   provide the client either a\
    \ read or write delegation for the file.\n   If the client is granted a read delegation,\
    \ it is assured that no\n   other client has the ability to write to the file\
    \ for the duration of\n   the delegation.  If the client is granted a write delegation,\
    \ the\n   client is assured that no other client has read or write access to\n\
    \   the file.\n   Delegations can be recalled by the server.  If another client\n\
    \   requests access to the file in such a way that the access conflicts\n   with\
    \ the granted delegation, the server is able to notify the initial\n   client\
    \ and recall the delegation.  This requires that a callback path\n   exist between\
    \ the server and client.  If this callback path does not\n   exist, then delegations\
    \ can not be granted.  The essence of a\n   delegation is that it allows the client\
    \ to locally service operations\n   such as OPEN, CLOSE, LOCK, LOCKU, READ, WRITE\
    \ without immediate\n   interaction with the server.\n"
- title: 1.2.  General Definitions
  contents:
  - "1.2.  General Definitions\n   The following definitions are provided for the\
    \ purpose of providing\n   an appropriate context for the reader.\n   Client \
    \   The \"client\" is the entity that accesses the NFS server's\n            \
    \ resources.  The client may be an application which contains\n             the\
    \ logic to access the NFS server directly.  The client\n             may also\
    \ be the traditional operating system client remote\n             file system\
    \ services for a set of applications.\n             In the case of file locking\
    \ the client is the entity that\n             maintains a set of locks on behalf\
    \ of one or more\n             applications.  This client is responsible for crash\
    \ or\n             failure recovery for those locks it manages.\n            \
    \ Note that multiple clients may share the same transport and\n             multiple\
    \ clients may exist on the same network node.\n   Clientid  A 64-bit quantity\
    \ used as a unique, short-hand reference to\n             a client supplied Verifier\
    \ and ID.  The server is\n             responsible for supplying the Clientid.\n\
    \   Lease     An interval of time defined by the server for which the\n      \
    \       client is irrevocably granted a lock.  At the end of a\n             lease\
    \ period the lock may be revoked if the lease has not\n             been extended.\
    \  The lock must be revoked if a conflicting\n             lock has been granted\
    \ after the lease interval.\n             All leases granted by a server have\
    \ the same fixed\n             interval.  Note that the fixed interval was chosen\
    \ to\n             alleviate the expense a server would have in maintaining\n\
    \             state about variable length leases across server failures.\n   Lock\
    \      The term \"lock\" is used to refer to both record (byte-\n            \
    \ range) locks as well as file (share) locks unless\n             specifically\
    \ stated otherwise.\n   Server    The \"Server\" is the entity responsible for\
    \ coordinating\n             client access to a set of file systems.\n   Stable\
    \ Storage\n             NFS version 4 servers must be able to recover without\
    \ data\n             loss from multiple power failures (including cascading\n\
    \             power failures, that is, several power failures in quick\n     \
    \        succession), operating system failures, and hardware\n             failure\
    \ of components other than the storage medium itself\n             (for example,\
    \ disk, nonvolatile RAM).\n             Some examples of stable storage that are\
    \ allowable for an\n             NFS server include:\n             1. Media commit\
    \ of data, that is, the modified data has\n                been successfully written\
    \ to the disk media, for\n                example, the disk platter.\n       \
    \      2. An immediate reply disk drive with battery-backed on-\n            \
    \    drive intermediate storage or uninterruptible power\n                system\
    \ (UPS).\n             3. Server commit of data with battery-backed intermediate\n\
    \                storage and recovery software.\n             4. Cache commit\
    \ with uninterruptible power system (UPS) and\n                recovery software.\n\
    \   Stateid   A 64-bit quantity returned by a server that uniquely\n         \
    \    defines the locking state granted by the server for a\n             specific\
    \ lock owner for a specific file.\n             Stateids composed of all bits\
    \ 0 or all bits 1 have special\n             meaning and are reserved values.\n\
    \   Verifier  A 64-bit quantity generated by the client that the server\n    \
    \         can use to determine if the client has restarted and lost\n        \
    \     all previous lock state.\n"
- title: 2.  Protocol Data Types
  contents:
  - "2.  Protocol Data Types\n   The syntax and semantics to describe the data types\
    \ of the NFS\n   version 4 protocol are defined in the XDR [RFC1832] and RPC [RFC1831]\n\
    \   documents.  The next sections build upon the XDR data types to define\n  \
    \ types and structures specific to this protocol.\n"
- title: 2.1.  Basic Data Types
  contents:
  - "2.1.  Basic Data Types\n   Data Type     Definition\n   _____________________________________________________________________\n\
    \   int32_t       typedef int             int32_t;\n   uint32_t      typedef unsigned\
    \ int    uint32_t;\n   int64_t       typedef hyper           int64_t;\n   uint64_t\
    \      typedef unsigned hyper  uint64_t;\n   attrlist4     typedef opaque    \
    \    attrlist4<>;\n                 Used for file/directory attributes\n   bitmap4\
    \       typedef uint32_t        bitmap4<>;\n                 Used in attribute\
    \ array encoding.\n   changeid4     typedef       uint64_t        changeid4;\n\
    \                 Used in definition of change_info\n   clientid4     typedef\
    \ uint64_t        clientid4;\n                 Shorthand reference to client identification\n\
    \   component4    typedef utf8string      component4;\n                 Represents\
    \ path name components\n   count4        typedef uint32_t        count4;\n   \
    \              Various count parameters (READ, WRITE, COMMIT)\n   length4    \
    \   typedef uint64_t        length4;\n                 Describes LOCK lengths\n\
    \   linktext4     typedef utf8string      linktext4;\n                 Symbolic\
    \ link contents\n   mode4         typedef uint32_t        mode4;\n           \
    \      Mode attribute data type\n   nfs_cookie4   typedef uint64_t        nfs_cookie4;\n\
    \                 Opaque cookie value for READDIR\n   nfs_fh4       typedef opaque\
    \          nfs_fh4<NFS4_FHSIZE>;\n                 Filehandle definition; NFS4_FHSIZE\
    \ is defined as 128\n   nfs_ftype4    enum nfs_ftype4;\n                 Various\
    \ defined file types\n   nfsstat4      enum nfsstat4;\n                 Return\
    \ value for operations\n   offset4       typedef uint64_t        offset4;\n  \
    \               Various offset designations (READ, WRITE, LOCK, COMMIT)\n   pathname4\
    \     typedef component4      pathname4<>;\n                 Represents path name\
    \ for LOOKUP, OPEN and others\n   qop4          typedef uint32_t        qop4;\n\
    \                 Quality of protection designation in SECINFO\n   sec_oid4  \
    \    typedef opaque          sec_oid4<>;\n                 Security Object Identifier\n\
    \                 The sec_oid4 data type is not really opaque.\n             \
    \    Instead contains an ASN.1 OBJECT IDENTIFIER as used\n                 by\
    \ GSS-API in the mech_type argument to\n                 GSS_Init_sec_context.\
    \  See [RFC2078] for details.\n   seqid4        typedef uint32_t        seqid4;\n\
    \                 Sequence identifier used for file locking\n   stateid4     \
    \ typedef uint64_t        stateid4;\n                 State identifier used for\
    \ file locking and delegation\n   utf8string    typedef opaque          utf8string<>;\n\
    \                 UTF-8 encoding for strings\n   verifier4     typedef opaque\
    \        verifier4[NFS4_VERIFIER_SIZE];\n                 Verifier used for various\
    \ operations (COMMIT, CREATE,\n                 OPEN, READDIR, SETCLIENTID, WRITE)\n\
    \                 NFS4_VERIFIER_SIZE is defined as 8\n"
- title: 2.2.  Structured Data Types
  contents:
  - "2.2.  Structured Data Types\n   nfstime4\n                  struct nfstime4 {\n\
    \                          int64_t seconds;\n                          uint32_t\
    \ nseconds;\n                  }\n      The nfstime4 structure gives the number\
    \ of seconds and nanoseconds\n      since midnight or 0 hour January 1, 1970 Coordinated\
    \ Universal\n      Time (UTC).  Values greater than zero for the seconds field\
    \ denote\n      dates after the 0 hour January 1, 1970.  Values less than zero\
    \ for\n      the seconds field denote dates before the 0 hour January 1, 1970.\n\
    \      In both cases, the nseconds field is to be added to the seconds\n     \
    \ field for the final time representation.  For example, if the time\n      to\
    \ be represented is one-half second before 0 hour January 1,\n      1970, the\
    \ seconds field would have a value of negative one (-1)\n      and the nseconds\
    \ fields would have a value of one-half second\n      (500000000).  Values greater\
    \ than 999,999,999 for nseconds are\n      considered invalid.\n      This data\
    \ type is used to pass time and date information.  A\n      server converts to\
    \ and from its local representation of time when\n      processing time values,\
    \ preserving as much accuracy as possible.\n      If the precision of timestamps\
    \ stored for a file system object is\n      less than defined, loss of precision\
    \ can occur.  An adjunct time\n      maintenance protocol is recommended to reduce\
    \ client and server\n      time skew.\n   time_how4\n                  enum time_how4\
    \ {\n                          SET_TO_SERVER_TIME4 = 0,\n                    \
    \      SET_TO_CLIENT_TIME4 = 1\n                  };\n   settime4\n          \
    \        union settime4 switch (time_how4 set_it) {\n                   case SET_TO_CLIENT_TIME4:\n\
    \                           nfstime4       time;\n                   default:\n\
    \                           void;\n                  };\n        The above definitions\
    \ are used as the attribute definitions to\n        set time values.  If set_it\
    \ is SET_TO_SERVER_TIME4, then the\n        server uses its local representation\
    \ of time for the time value.\n   specdata4\n                  struct specdata4\
    \ {\n                          uint32_t specdata1;\n                         \
    \ uint32_t specdata2;\n                  };\n        This data type represents\
    \ additional information for the device\n        file types NF4CHR and NF4BLK.\n\
    \   fsid4\n                  struct fsid4 {\n                    uint64_t    \
    \    major;\n                    uint64_t        minor;\n                  };\n\
    \        This type is the file system identifier that is used as a\n        mandatory\
    \ attribute.\n   fs_location4\n                  struct fs_location4 {\n     \
    \                     utf8string    server<>;\n                          pathname4\
    \     rootpath;\n                  };\n   fs_locations4\n                  struct\
    \ fs_locations4 {\n                          pathname4     fs_root;\n        \
    \                  fs_location4  locations<>;\n                  };\n        The\
    \ fs_location4 and fs_locations4 data types are used for the\n        fs_locations\
    \ recommended attribute which is used for migration\n        and replication support.\n\
    \   fattr4\n                  struct fattr4 {\n                          bitmap4\
    \       attrmask;\n                          attrlist4     attr_vals;\n      \
    \            };\n        The fattr4 structure is used to represent file and directory\n\
    \        attributes.\n        The bitmap is a counted array of 32 bit integers\
    \ used to contain\n        bit values.  The position of the integer in the array\
    \ that\n        contains bit n can be computed from the expression (n / 32) and\n\
    \        its bit within that integer is (n mod 32).\n                        \
    \              0            1\n                    +-----------+-----------+-----------+--\n\
    \                    |  count    | 31  ..  0 | 63  .. 32 |\n                 \
    \   +-----------+-----------+-----------+--\n   change_info4\n               \
    \   struct change_info4 {\n                          bool          atomic;\n \
    \                         changeid4     before;\n                          changeid4\
    \     after;\n                  };\n        This structure is used with the CREATE,\
    \ LINK, REMOVE, RENAME\n        operations to let the client the know value of\
    \ the change\n        attribute for the directory in which the target file system\n\
    \        object resides.\n   clientaddr4\n                  struct clientaddr4\
    \ {\n                          /* see struct rpcb in RFC 1833 */\n           \
    \               string r_netid<>;    /* network id */\n                      \
    \    string r_addr<>;     /* universal address */\n                  };\n    \
    \    The clientaddr4 structure is used as part of the SETCLIENT\n        operation\
    \ to either specify the address of the client that is\n        using a clientid\
    \ or as part of the call back registration.\n   cb_client4\n                 \
    \ struct cb_client4 {\n                          unsigned int  cb_program;\n \
    \                         clientaddr4   cb_location;\n                  };\n \
    \       This structure is used by the client to inform the server of its\n   \
    \     call back address; includes the program number and client\n        address.\n\
    \   nfs_client_id4\n                  struct nfs_client_id4 {\n              \
    \            verifier4     verifier;\n                          opaque       \
    \ id<>;\n                  };\n        This structure is part of the arguments\
    \ to the SETCLIENTID\n        operation.\n   nfs_lockowner4\n                \
    \  struct nfs_lockowner4 {\n                          clientid4     clientid;\n\
    \                          opaque        owner<>;\n                  };\n    \
    \    This structure is used to identify the owner of a OPEN share or\n       \
    \ file lock.\n"
- title: 3.  RPC and Security Flavor
  contents:
  - "3.  RPC and Security Flavor\n   The NFS version 4 protocol is a Remote Procedure\
    \ Call (RPC)\n   application that uses RPC version 2 and the corresponding eXternal\n\
    \   Data Representation (XDR) as defined in [RFC1831] and [RFC1832].  The\n  \
    \ RPCSEC_GSS security flavor as defined in [RFC2203] MUST be used as\n   the mechanism\
    \ to deliver stronger security for the NFS version 4\n   protocol.\n"
- title: 3.1.  Ports and Transports
  contents:
  - "3.1.  Ports and Transports\n   Historically, NFS version 2 and version 3 servers\
    \ have resided on\n   port 2049.  The registered port 2049 [RFC1700] for the NFS\
    \ protocol\n   should be the default configuration.  Using the registered port\
    \ for\n   NFS services means the NFS client will not need to use the RPC\n   binding\
    \ protocols as described in [RFC1833]; this will allow NFS to\n   transit firewalls.\n\
    \   The transport used by the RPC service for the NFS version 4 protocol\n   MUST\
    \ provide congestion control comparable to that defined for TCP in\n   [RFC2581].\
    \  If the operating environment implements TCP, the NFS\n   version 4 protocol\
    \ SHOULD be supported over TCP.  The NFS client and\n   server may use other transports\
    \ if they support congestion control as\n   defined above and in those cases a\
    \ mechanism may be provided to\n   override TCP usage in favor of another transport.\n\
    \   If TCP is used as the transport, the client and server SHOULD use\n   persistent\
    \ connections.  This will prevent the weakening of TCP's\n   congestion control\
    \ via short lived connections and will improve\n   performance for the WAN environment\
    \ by eliminating the need for SYN\n   handshakes.\n   Note that for various timers,\
    \ the client and server should avoid\n   inadvertent synchronization of those\
    \ timers.  For further discussion\n   of the general issue refer to [Floyd].\n"
- title: 3.2.  Security Flavors
  contents:
  - "3.2.  Security Flavors\n   Traditional RPC implementations have included AUTH_NONE,\
    \ AUTH_SYS,\n   AUTH_DH, and AUTH_KRB4 as security flavors.  With [RFC2203] an\n\
    \   additional security flavor of RPCSEC_GSS has been introduced which\n   uses\
    \ the functionality of GSS-API [RFC2078].  This allows for the use\n   of varying\
    \ security mechanisms by the RPC layer without the\n   additional implementation\
    \ overhead of adding RPC security flavors.\n   For NFS version 4, the RPCSEC_GSS\
    \ security flavor MUST be used to\n   enable the mandatory security mechanism.\
    \  Other flavors, such as,\n   AUTH_NONE, AUTH_SYS, and AUTH_DH MAY be implemented\
    \ as well.\n"
- title: 3.2.1.  Security mechanisms for NFS version 4
  contents:
  - "3.2.1.  Security mechanisms for NFS version 4\n   The use of RPCSEC_GSS requires\
    \ selection of: mechanism, quality of\n   protection, and service (authentication,\
    \ integrity, privacy).  The\n   remainder of this document will refer to these\
    \ three parameters of\n   the RPCSEC_GSS security as the security triple.\n"
- title: 3.2.1.1.  Kerberos V5 as security triple
  contents:
  - "3.2.1.1.  Kerberos V5 as security triple\n   The Kerberos V5 GSS-API mechanism\
    \ as described in [RFC1964] MUST be\n   implemented and provide the following\
    \ security triples.\n   column descriptions:\n   1 == number of pseudo flavor\n\
    \   2 == name of pseudo flavor\n   3 == mechanism's OID\n   4 == mechanism's algorithm(s)\n\
    \   5 == RPCSEC_GSS service\n"
- title: 1      2     3                    4              5
  contents:
  - '1      2     3                    4              5

    '
- title: '-----------------------------------------------------------------------'
  contents:
  - '-----------------------------------------------------------------------

    '
- title: 390003 krb5  1.2.840.113554.1.2.2 DES MAC MD5    rpc_gss_svc_none
  contents:
  - '390003 krb5  1.2.840.113554.1.2.2 DES MAC MD5    rpc_gss_svc_none

    '
- title: 390004 krb5i 1.2.840.113554.1.2.2 DES MAC MD5    rpc_gss_svc_integrity
  contents:
  - '390004 krb5i 1.2.840.113554.1.2.2 DES MAC MD5    rpc_gss_svc_integrity

    '
- title: 390005 krb5p 1.2.840.113554.1.2.2 DES MAC MD5    rpc_gss_svc_privacy
  contents:
  - "390005 krb5p 1.2.840.113554.1.2.2 DES MAC MD5    rpc_gss_svc_privacy\n      \
    \                            for integrity,\n                                \
    \  and 56 bit DES\n                                  for privacy.\n   Note that\
    \ the pseudo flavor is presented here as a mapping aid to the\n   implementor.\
    \  Because this NFS protocol includes a method to\n   negotiate security and it\
    \ understands the GSS-API mechanism, the\n   pseudo flavor is not needed.  The\
    \ pseudo flavor is needed for NFS\n   version 3 since the security negotiation\
    \ is done via the MOUNT\n   protocol.\n   For a discussion of NFS' use of RPCSEC_GSS\
    \ and Kerberos V5, please\n   see [RFC2623].\n"
- title: 3.2.1.2.  LIPKEY as a security triple
  contents:
  - "3.2.1.2.  LIPKEY as a security triple\n   The LIPKEY GSS-API mechanism as described\
    \ in [RFC2847] MUST be\n   implemented and provide the following security triples.\
    \ The\n   definition of the columns matches the previous subsection \"Kerberos\n\
    \   V5 as security triple\"\n"
- title: 1      2        3                    4              5
  contents:
  - '1      2        3                    4              5

    '
- title: '-----------------------------------------------------------------------'
  contents:
  - '-----------------------------------------------------------------------

    '
- title: 390006 lipkey   1.3.6.1.5.5.9        negotiated  rpc_gss_svc_none
  contents:
  - '390006 lipkey   1.3.6.1.5.5.9        negotiated  rpc_gss_svc_none

    '
- title: 390007 lipkey-i 1.3.6.1.5.5.9        negotiated  rpc_gss_svc_integrity
  contents:
  - '390007 lipkey-i 1.3.6.1.5.5.9        negotiated  rpc_gss_svc_integrity

    '
- title: 390008 lipkey-p 1.3.6.1.5.5.9        negotiated  rpc_gss_svc_privacy
  contents:
  - "390008 lipkey-p 1.3.6.1.5.5.9        negotiated  rpc_gss_svc_privacy\n   The\
    \ mechanism algorithm is listed as \"negotiated\".  This is because\n   LIPKEY\
    \ is layered on SPKM-3 and in SPKM-3 [RFC2847] the\n   confidentiality and integrity\
    \ algorithms are negotiated.  Since\n   SPKM-3 specifies HMAC-MD5 for integrity\
    \ as MANDATORY, 128 bit\n   cast5CBC for confidentiality for privacy as MANDATORY,\
    \ and further\n   specifies that HMAC-MD5 and cast5CBC MUST be listed first before\n\
    \   weaker algorithms, specifying \"negotiated\" in column 4 does not\n   impair\
    \ interoperability.  In the event an SPKM-3 peer does not\n   support the mandatory\
    \ algorithms, the other peer is free to accept or\n   reject the GSS-API context\
    \ creation.\n   Because SPKM-3 negotiates the algorithms, subsequent calls to\n\
    \   LIPKEY's GSS_Wrap() and GSS_GetMIC() by RPCSEC_GSS will use a quality\n  \
    \ of protection value of 0 (zero).  See section 5.2 of [RFC2025] for an\n   explanation.\n\
    \   LIPKEY uses SPKM-3 to create a secure channel in which to pass a user\n  \
    \ name and password from the client to the user.  Once the user name\n   and password\
    \ have been accepted by the server, calls to the LIPKEY\n   context are redirected\
    \ to the SPKM-3 context.  See [RFC2847] for more\n   details.\n"
- title: 3.2.1.3.  SPKM-3 as a security triple
  contents:
  - "3.2.1.3.  SPKM-3 as a security triple\n   The SPKM-3 GSS-API mechanism as described\
    \ in [RFC2847] MUST be\n   implemented and provide the following security triples.\
    \ The\n   definition of the columns matches the previous subsection \"Kerberos\n\
    \   V5 as security triple\".\n"
- title: 1      2        3                    4              5
  contents:
  - '1      2        3                    4              5

    '
- title: '-----------------------------------------------------------------------'
  contents:
  - '-----------------------------------------------------------------------

    '
- title: 390009 spkm3    1.3.6.1.5.5.1.3      negotiated  rpc_gss_svc_none
  contents:
  - '390009 spkm3    1.3.6.1.5.5.1.3      negotiated  rpc_gss_svc_none

    '
- title: 390010 spkm3i   1.3.6.1.5.5.1.3      negotiated  rpc_gss_svc_integrity
  contents:
  - '390010 spkm3i   1.3.6.1.5.5.1.3      negotiated  rpc_gss_svc_integrity

    '
- title: 390011 spkm3p   1.3.6.1.5.5.1.3      negotiated  rpc_gss_svc_privacy
  contents:
  - "390011 spkm3p   1.3.6.1.5.5.1.3      negotiated  rpc_gss_svc_privacy\n   For\
    \ a discussion as to why the mechanism algorithm is listed as\n   \"negotiated\"\
    , see the previous section \"LIPKEY as a security triple.\"\n   Because SPKM-3\
    \ negotiates the algorithms, subsequent calls to SPKM-\n   3's GSS_Wrap() and\
    \ GSS_GetMIC() by RPCSEC_GSS will use a quality of\n   protection value of 0 (zero).\
    \  See section 5.2 of [RFC2025] for an\n   explanation.\n   Even though LIPKEY\
    \ is layered over SPKM-3, SPKM-3 is specified as a\n   mandatory set of triples\
    \ to handle the situations where the initiator\n   (the client) is anonymous or\
    \ where the initiator has its own\n   certificate.  If the initiator is anonymous,\
    \ there will not be a user\n   name and password to send to the target (the server).\
    \  If the\n   initiator has its own certificate, then using passwords is\n   superfluous.\n"
- title: 3.3.  Security Negotiation
  contents:
  - "3.3.  Security Negotiation\n   With the NFS version 4 server potentially offering\
    \ multiple security\n   mechanisms, the client needs a method to determine or\
    \ negotiate which\n   mechanism is to be used for its communication with the server.\
    \  The\n   NFS server may have multiple points within its file system name space\n\
    \   that are available for use by NFS clients.  In turn the NFS server\n   may\
    \ be configured such that each of these entry points may have\n   different or\
    \ multiple security mechanisms in use.\n   The security negotiation between client\
    \ and server must be done with\n   a secure channel to eliminate the possibility\
    \ of a third party\n   intercepting the negotiation sequence and forcing the client\
    \ and\n   server to choose a lower level of security than required or desired.\n"
- title: 3.3.1.  Security Error
  contents:
  - "3.3.1.  Security Error\n   Based on the assumption that each NFS version 4 client\
    \ and server\n   must support a minimum set of security (i.e. LIPKEY, SPKM-3,\
    \ and\n   Kerberos-V5 all under RPCSEC_GSS), the NFS client will start its\n \
    \  communication with the server with one of the minimal security\n   triples.\
    \  During communication with the server, the client may\n   receive an NFS error\
    \ of NFS4ERR_WRONGSEC.  This error allows the\n   server to notify the client\
    \ that the security triple currently being\n   used is not appropriate for access\
    \ to the server's file system\n   resources.  The client is then responsible for\
    \ determining what\n   security triples are available at the server and choose\
    \ one which is\n   appropriate for the client.\n"
- title: 3.3.2.  SECINFO
  contents:
  - "3.3.2.  SECINFO\n   The new SECINFO operation will allow the client to determine,\
    \ on a\n   per filehandle basis, what security triple is to be used for server\n\
    \   access.  In general, the client will not have to use the SECINFO\n   procedure\
    \ except during initial communication with the server or when\n   the client crosses\
    \ policy boundaries at the server.  It is possible\n   that the server's policies\
    \ change during the client's interaction\n   therefore forcing the client to negotiate\
    \ a new security triple.\n"
- title: 3.4.  Callback RPC Authentication
  contents:
  - "3.4.  Callback RPC Authentication\n   The callback RPC (described later) must\
    \ mutually authenticate the NFS\n   server to the principal that acquired the\
    \ clientid (also described\n   later), using the same security flavor the original\
    \ SETCLIENTID\n   operation used. Because LIPKEY is layered over SPKM-3, it is\n\
    \   permissible for the server to use SPKM-3 and not LIPKEY for the\n   callback\
    \ even if the client used LIPKEY for SETCLIENTID.\n   For AUTH_NONE, there are\
    \ no principals, so this is a non-issue.\n   For AUTH_SYS, the server simply uses\
    \ the AUTH_SYS credential that the\n   user used when it set up the delegation.\n\
    \   For AUTH_DH, one commonly used convention is that the server uses the\n  \
    \ credential corresponding to this AUTH_DH principal:\n         unix.host@domain\n\
    \   where host and domain are variables corresponding to the name of\n   server\
    \ host and directory services domain in which it lives such as a\n   Network Information\
    \ System domain or a DNS domain.\n   Regardless of what security mechanism under\
    \ RPCSEC_GSS is being used,\n   the NFS server, MUST identify itself in GSS-API\
    \ via a\n   GSS_C_NT_HOSTBASED_SERVICE name type.  GSS_C_NT_HOSTBASED_SERVICE\n\
    \   names are of the form:\n         service@hostname\n   For NFS, the \"service\"\
    \ element is\n         nfs\n   Implementations of security mechanisms will convert\
    \ nfs@hostname to\n   various different forms. For Kerberos V5 and LIPKEY, the\
    \ following\n   form is RECOMMENDED:\n         nfs/hostname\n   For Kerberos V5,\
    \ nfs/hostname would be a server principal in the\n   Kerberos Key Distribution\
    \ Center database.  For LIPKEY, this would be\n   the username passed to the target\
    \ (the NFS version 4 client that\n   receives the callback).\n   It should be\
    \ noted that LIPKEY may not work for callbacks, since the\n   LIPKEY client uses\
    \ a user id/password.  If the NFS client receiving\n   the callback can authenticate\
    \ the NFS server's user name/password\n   pair, and if the user that the NFS server\
    \ is authenticating to has a\n   public key certificate, then it works.\n   In\
    \ situations where NFS client uses LIPKEY and uses a per-host\n   principal for\
    \ the SETCLIENTID operation, instead of using LIPKEY for\n   SETCLIENTID, it is\
    \ RECOMMENDED that SPKM-3 with mutual authentication\n   be used.  This effectively\
    \ means that the client will use a\n   certificate to authenticate and identify\
    \ the initiator to the target\n   on the NFS server.  Using SPKM-3 and not LIPKEY\
    \ has the following\n   advantages:\n   o  When the server does a callback, it\
    \ must authenticate to the\n      principal used in the SETCLIENTID.  Even if\
    \ LIPKEY is used,\n      because LIPKEY is layered over SPKM-3, the NFS client\
    \ will need to\n      have a certificate that corresponds to the principal used\
    \ in the\n      SETCLIENTID operation.  From an administrative perspective, having\n\
    \      a user name, password, and certificate for both the client and\n      server\
    \ is redundant.\n   o  LIPKEY was intended to minimize additional infrastructure\n\
    \      requirements beyond a certificate for the target, and the\n      expectation\
    \ is that existing password infrastructure can be\n      leveraged for the initiator.\
    \  In some environments, a per-host\n      password does not exist yet.  If certificates\
    \ are used for any\n      per-host principals, then additional password infrastructure\
    \ is\n      not needed.\n   o  In cases when a host is both an NFS client and\
    \ server, it can\n      share the same per-host certificate.\n"
- title: 4.  Filehandles
  contents:
  - "4.  Filehandles\n   The filehandle in the NFS protocol is a per server unique\
    \ identifier\n   for a file system object.  The contents of the filehandle are\
    \ opaque\n   to the client.  Therefore, the server is responsible for translating\n\
    \   the filehandle to an internal representation of the file system\n   object.\
    \  Since the filehandle is the client's reference to an object\n   and the client\
    \ may cache this reference, the server SHOULD not reuse\n   a filehandle for another\
    \ file system object.  If the server needs to\n   reuse a filehandle value, the\
    \ time elapsed before reuse SHOULD be\n   large enough such that it is unlikely\
    \ the client has a cached copy of\n   the reused filehandle value.  Note that\
    \ a client may cache a\n   filehandle for a very long time.  For example, a client\
    \ may cache NFS\n   data to local storage as a method to expand its effective\
    \ cache size\n   and as a means to survive client restarts.  Therefore, the lifetime\n\
    \   of a cached filehandle may be extended.\n"
- title: 4.1.  Obtaining the First Filehandle
  contents:
  - "4.1.  Obtaining the First Filehandle\n   The operations of the NFS protocol are\
    \ defined in terms of one or\n   more filehandles.  Therefore, the client needs\
    \ a filehandle to\n   initiate communication with the server.  With the NFS version\
    \ 2\n   protocol [RFC1094] and the NFS version 3 protocol [RFC1813], there\n \
    \  exists an ancillary protocol to obtain this first filehandle.  The\n   MOUNT\
    \ protocol, RPC program number 100005, provides the mechanism of\n   translating\
    \ a string based file system path name to a filehandle\n   which can then be used\
    \ by the NFS protocols.\n   The MOUNT protocol has deficiencies in the area of\
    \ security and use\n   via firewalls.  This is one reason that the use of the\
    \ public\n   filehandle was introduced in [RFC2054] and [RFC2055].  With the use\n\
    \   of the public filehandle in combination with the LOOKUP procedure in\n   the\
    \ NFS version 2 and 3 protocols, it has been demonstrated that the\n   MOUNT protocol\
    \ is unnecessary for viable interaction between NFS\n   client and server.\n \
    \  Therefore, the NFS version 4 protocol will not use an ancillary\n   protocol\
    \ for translation from string based path names to a\n   filehandle.  Two special\
    \ filehandles will be used as starting points\n   for the NFS client.\n"
- title: 4.1.1.  Root Filehandle
  contents:
  - "4.1.1.  Root Filehandle\n   The first of the special filehandles is the ROOT\
    \ filehandle.  The\n   ROOT filehandle is the \"conceptual\" root of the file\
    \ system name\n   space at the NFS server.  The client uses or starts with the\
    \ ROOT\n   filehandle by employing the PUTROOTFH operation.  The PUTROOTFH\n \
    \  operation instructs the server to set the \"current\" filehandle to the\n \
    \  ROOT of the server's file tree.  Once this PUTROOTFH operation is\n   used,\
    \ the client can then traverse the entirety of the server's file\n   tree with\
    \ the LOOKUP procedure.  A complete discussion of the server\n   name space is\
    \ in the section \"NFS Server Name Space\".\n"
- title: 4.1.2.  Public Filehandle
  contents:
  - "4.1.2.  Public Filehandle\n   The second special filehandle is the PUBLIC filehandle.\
    \  Unlike the\n   ROOT filehandle, the PUBLIC filehandle may be bound or represent\
    \ an\n   arbitrary file system object at the server.  The server is\n   responsible\
    \ for this binding.  It may be that the PUBLIC filehandle\n   and the ROOT filehandle\
    \ refer to the same file system object.\n   However, it is up to the administrative\
    \ software at the server and\n   the policies of the server administrator to define\
    \ the binding of the\n   PUBLIC filehandle and server file system object.  The\
    \ client may not\n   make any assumptions about this binding.\n"
- title: 4.2.  Filehandle Types
  contents:
  - "4.2.  Filehandle Types\n   In the NFS version 2 and 3 protocols, there was one\
    \ type of\n   filehandle with a single set of semantics.  The NFS version 4\n\
    \   protocol introduces a new type of filehandle in an attempt to\n   accommodate\
    \ certain server environments.  The first type of\n   filehandle is 'persistent'.\
    \  The semantics of a persistent filehandle\n   are the same as the filehandles\
    \ of the NFS version 2 and 3 protocols.\n   The second or new type of filehandle\
    \ is the \"volatile\" filehandle.\n   The volatile filehandle type is being introduced\
    \ to address server\n   functionality or implementation issues which make correct\n\
    \   implementation of a persistent filehandle infeasible.  Some server\n   environments\
    \ do not provide a file system level invariant that can be\n   used to construct\
    \ a persistent filehandle.  The underlying server\n   file system may not provide\
    \ the invariant or the server's file system\n   programming interfaces may not\
    \ provide access to the needed\n   invariant.  Volatile filehandles may ease the\
    \ implementation of\n   server functionality such as hierarchical storage management\
    \ or file\n   system reorganization or migration.  However, the volatile filehandle\n\
    \   increases the implementation burden for the client.  However this\n   increased\
    \ burden is deemed acceptable based on the overall gains\n   achieved by the protocol.\n\
    \   Since the client will need to handle persistent and volatile\n   filehandle\
    \ differently, a file attribute is defined which may be used\n   by the client\
    \ to determine the filehandle types being returned by the\n   server.\n"
- title: 4.2.1.  General Properties of a Filehandle
  contents:
  - "4.2.1.  General Properties of a Filehandle\n   The filehandle contains all the\
    \ information the server needs to\n   distinguish an individual file.  To the\
    \ client, the filehandle is\n   opaque. The client stores filehandles for use\
    \ in a later request and\n   can compare two filehandles from the same server\
    \ for equality by\n   doing a byte-by-byte comparison.  However, the client MUST\
    \ NOT\n   otherwise interpret the contents of filehandles.  If two filehandles\n\
    \   from the same server are equal, they MUST refer to the same file.  If\n  \
    \ they are not equal, the client may use information provided by the\n   server,\
    \ in the form of file attributes, to determine whether they\n   denote the same\
    \ files or different files.  The client would do this\n   as necessary for client\
    \ side caching.  Servers SHOULD try to maintain\n   a one-to-one correspondence\
    \ between filehandles and files but this is\n   not required.  Clients MUST use\
    \ filehandle comparisons only to\n   improve performance, not for correct behavior.\
    \  All clients need to\n   be prepared for situations in which it cannot be determined\
    \ whether\n   two filehandles denote the same object and in such cases, avoid\n\
    \   making invalid assumptions which might cause incorrect behavior.\n   Further\
    \ discussion of filehandle and attribute comparison in the\n   context of data\
    \ caching is presented in the section \"Data Caching and\n   File Identity\".\n\
    \   As an example, in the case that two different path names when\n   traversed\
    \ at the server terminate at the same file system object, the\n   server SHOULD\
    \ return the same filehandle for each path.  This can\n   occur if a hard link\
    \ is used to create two file names which refer to\n   the same underlying file\
    \ object and associated data.  For example, if\n   paths /a/b/c and /a/d/c refer\
    \ to the same file, the server SHOULD\n   return the same filehandle for both\
    \ path names traversals.\n"
- title: 4.2.2.  Persistent Filehandle
  contents:
  - "4.2.2.  Persistent Filehandle\n   A persistent filehandle is defined as having\
    \ a fixed value for the\n   lifetime of the file system object to which it refers.\
    \  Once the\n   server creates the filehandle for a file system object, the server\n\
    \   MUST accept the same filehandle for the object for the lifetime of\n   the\
    \ object.  If the server restarts or reboots the NFS server must\n   honor the\
    \ same filehandle value as it did in the server's previous\n   instantiation.\
    \  Similarly, if the file system is migrated, the new\n   NFS server must honor\
    \ the same file handle as the old NFS server.\n   The persistent filehandle will\
    \ be become stale or invalid when the\n   file system object is removed.  When\
    \ the server is presented with a\n   persistent filehandle that refers to a deleted\
    \ object, it MUST return\n   an error of NFS4ERR_STALE.  A filehandle may become\
    \ stale when the\n   file system containing the object is no longer available.\
    \  The file\n   system may become unavailable if it exists on removable media\
    \ and the\n   media is no longer available at the server or the file system in\n\
    \   whole has been destroyed or the file system has simply been removed\n   from\
    \ the server's name space (i.e. unmounted in a Unix environment).\n"
- title: 4.2.3.  Volatile Filehandle
  contents:
  - "4.2.3.  Volatile Filehandle\n   A volatile filehandle does not share the same\
    \ longevity\n   characteristics of a persistent filehandle.  The server may determine\n\
    \   that a volatile filehandle is no longer valid at many different\n   points\
    \ in time.  If the server can definitively determine that a\n   volatile filehandle\
    \ refers to an object that has been removed, the\n   server should return NFS4ERR_STALE\
    \ to the client (as is the case for\n   persistent filehandles).  In all other\
    \ cases where the server\n   determines that a volatile filehandle can no longer\
    \ be used, it\n   should return an error of NFS4ERR_FHEXPIRED.\n   The mandatory\
    \ attribute \"fh_expire_type\" is used by the client to\n   determine what type\
    \ of filehandle the server is providing for a\n   particular file system.  This\
    \ attribute is a bitmask with the\n   following values:\n   FH4_PERSISTENT\n \
    \        The value of FH4_PERSISTENT is used to indicate a persistent\n      \
    \   filehandle, which is valid until the object is removed from the\n        \
    \ file system.  The server will not return NFS4ERR_FHEXPIRED for\n         this\
    \ filehandle.  FH4_PERSISTENT is defined as a value in which\n         none of\
    \ the bits specified below are set.\n   FH4_NOEXPIRE_WITH_OPEN\n         The filehandle\
    \ will not expire while client has the file open.\n         If this bit is set,\
    \ then the values FH4_VOLATILE_ANY or\n         FH4_VOL_RENAME do not impact expiration\
    \ while the file is open.\n         Once the file is closed or if the FH4_NOEXPIRE_WITH_OPEN\
    \ bit is\n         false, the rest of the volatile related bits apply.\n   FH4_VOLATILE_ANY\n\
    \         The filehandle may expire at any time and will expire during\n     \
    \    system migration and rename.\n   FH4_VOL_MIGRATION\n         The filehandle\
    \ will expire during file system migration.  May\n         only be set if FH4_VOLATILE_ANY\
    \ is not set.\n   FH4_VOL_RENAME\n         The filehandle may expire due to a\
    \ rename.  This includes a\n         rename by the requesting client or a rename\
    \ by another client.\n         May only be set if FH4_VOLATILE_ANY is not set.\n\
    \   Servers which provide volatile filehandles should deny a RENAME or\n   REMOVE\
    \ that would affect an OPEN file or any of the components\n   leading to the OPEN\
    \ file.  In addition, the server should deny all\n   RENAME or REMOVE requests\
    \ during the grace or lease period upon\n   server restart.\n   The reader may\
    \ be wondering why there are three FH4_VOL* bits and why\n   FH4_VOLATILE_ANY\
    \ is exclusive of FH4_VOL_MIGRATION and\n   FH4_VOL_RENAME.  If the a filehandle\
    \ is normally persistent but\n   cannot persist across a file set migration, then\
    \ the presence of the\n   FH4_VOL_MIGRATION or FH4_VOL_RENAME tells the client\
    \ that it can\n   treat the file handle as persistent for purposes of maintaining\
    \ a\n   file name to file handle cache, except for the specific event\n   described\
    \ by the bit.  However, FH4_VOLATILE_ANY tells the client\n   that it should not\
    \ maintain such a cache for unopened files.  A\n   server MUST not present FH4_VOLATILE_ANY\
    \ with FH4_VOL_MIGRATION or\n   FH4_VOL_RENAME as this will lead to confusion.\
    \  FH4_VOLATILE_ANY\n   implies that the file handle will expire upon migration\
    \ or rename, in\n   addition to other events.\n"
- title: 4.2.4.  One Method of Constructing a Volatile Filehandle
  contents:
  - "4.2.4.  One Method of Constructing a Volatile Filehandle\n   As mentioned, in\
    \ some instances a filehandle is stale (no longer\n   valid; perhaps because the\
    \ file was removed from the server) or it is\n   expired (the underlying file\
    \ is valid but since the filehandle is\n   volatile, it may have expired).  Thus\
    \ the server needs to be able to\n   return NFS4ERR_STALE in the former case and\
    \ NFS4ERR_FHEXPIRED in the\n   latter case. This can be done by careful construction\
    \ of the volatile\n   filehandle.  One possible implementation follows.\n   A\
    \ volatile filehandle, while opaque to the client could contain:\n   [volatile\
    \ bit = 1 | server boot time | slot | generation number]\n   o  slot is an index\
    \ in the server volatile filehandle table\n   o  generation number is the generation\
    \ number for the table\n      entry/slot\n   If the server boot time is less than\
    \ the current server boot time,\n   return NFS4ERR_FHEXPIRED.  If slot is out\
    \ of range, return\n   NFS4ERR_BADHANDLE.  If the generation number does not match,\
    \ return\n   NFS4ERR_FHEXPIRED.\n   When the server reboots, the table is gone\
    \ (it is volatile).\n   If volatile bit is 0, then it is a persistent filehandle\
    \ with a\n   different structure following it.\n"
- title: 4.3.  Client Recovery from Filehandle Expiration
  contents:
  - "4.3.  Client Recovery from Filehandle Expiration\n   If possible, the client\
    \ SHOULD recover from the receipt of an\n   NFS4ERR_FHEXPIRED error.  The client\
    \ must take on additional\n   responsibility so that it may prepare itself to\
    \ recover from the\n   expiration of a volatile filehandle.  If the server returns\n\
    \   persistent filehandles, the client does not need these additional\n   steps.\n\
    \   For volatile filehandles, most commonly the client will need to store\n  \
    \ the component names leading up to and including the file system\n   object in\
    \ question.  With these names, the client should be able to\n   recover by finding\
    \ a filehandle in the name space that is still\n   available or by starting at\
    \ the root of the server's file system name\n   space.\n   If the expired filehandle\
    \ refers to an object that has been removed\n   from the file system, obviously\
    \ the client will not be able to\n   recover from the expired filehandle.\n  \
    \ It is also possible that the expired filehandle refers to a file that\n   has\
    \ been renamed.  If the file was renamed by another client, again\n   it is possible\
    \ that the original client will not be able to recover.\n   However, in the case\
    \ that the client itself is renaming the file and\n   the file is open, it is\
    \ possible that the client may be able to\n   recover.  The client can determine\
    \ the new path name based on the\n   processing of the rename request.  The client\
    \ can then regenerate the\n   new filehandle based on the new path name.  The\
    \ client could also use\n   the compound operation mechanism to construct a set\
    \ of operations\n   like:\n            RENAME A B\n            LOOKUP B\n    \
    \        GETFH\n"
- title: 5.  File Attributes
  contents:
  - "5.  File Attributes\n   To meet the requirements of extensibility and increased\n\
    \   interoperability with non-Unix platforms, attributes must be handled\n   in\
    \ a flexible manner.  The NFS Version 3 fattr3 structure contains a\n   fixed\
    \ list of attributes that not all clients and servers are able to\n   support\
    \ or care about.  The fattr3 structure can not be extended as\n   new needs arise\
    \ and it provides no way to indicate non-support.  With\n   the NFS Version 4\
    \ protocol, the client will be able to ask what\n   attributes the server supports\
    \ and will be able to request only those\n   attributes in which it is interested.\n\
    \   To this end, attributes will be divided into three groups: mandatory,\n  \
    \ recommended, and named.  Both mandatory and recommended attributes\n   are supported\
    \ in the NFS version 4 protocol by a specific and well-\n   defined encoding and\
    \ are identified by number.  They are requested by\n   setting a bit in the bit\
    \ vector sent in the GETATTR request; the\n   server response includes a bit vector\
    \ to list what attributes were\n   returned in the response.  New mandatory or\
    \ recommended attributes\n   may be added to the NFS protocol between major revisions\
    \ by\n   publishing a standards-track RFC which allocates a new attribute\n  \
    \ number value and defines the encoding for the attribute.  See the\n   section\
    \ \"Minor Versioning\" for further discussion.\n   Named attributes are accessed\
    \ by the new OPENATTR operation, which\n   accesses a hidden directory of attributes\
    \ associated with a file\n   system object.  OPENATTR takes a filehandle for the\
    \ object and\n   returns the filehandle for the attribute hierarchy.  The filehandle\n\
    \   for the named attributes is a directory object accessible by LOOKUP\n   or\
    \ READDIR and contains files whose names represent the named\n   attributes and\
    \ whose data bytes are the value of the attribute.  For\n   example:\n       \
    \  LOOKUP     \"foo\"       ; look up file\n         GETATTR    attrbits\n   \
    \      OPENATTR               ; access foo's named attributes\n         LOOKUP\
    \     \"x11icon\"   ; look up specific attribute\n         READ       0,4096 \
    \     ; read stream of bytes\n   Named attributes are intended for data needed\
    \ by applications rather\n   than by an NFS client implementation.  NFS implementors\
    \ are strongly\n   encouraged to define their new attributes as recommended attributes\n\
    \   by bringing them to the IETF standards-track process.\n   The set of attributes\
    \ which are classified as mandatory is\n   deliberately small since servers must\
    \ do whatever it takes to support\n   them.  The recommended attributes may be\
    \ unsupported; though a server\n   should support as many as it can.  Attributes\
    \ are deemed mandatory if\n   the data is both needed by a large number of clients\
    \ and is not\n   otherwise reasonably computable by the client when support is\
    \ not\n   provided on the server.\n"
- title: 5.1.  Mandatory Attributes
  contents:
  - "5.1.  Mandatory Attributes\n   These MUST be supported by every NFS Version 4\
    \ client and server in\n   order to ensure a minimum level of interoperability.\
    \  The server must\n   store and return these attributes and the client must be\
    \ able to\n   function with an attribute set limited to these attributes.  With\n\
    \   just the mandatory attributes some client functionality may be\n   impaired\
    \ or limited in some ways.  A client may ask for any of these\n   attributes to\
    \ be returned by setting a bit in the GETATTR request and\n   the server must\
    \ return their value.\n"
- title: 5.2.  Recommended Attributes
  contents:
  - "5.2.  Recommended Attributes\n   These attributes are understood well enough\
    \ to warrant support in the\n   NFS Version 4 protocol.  However, they may not\
    \ be supported on all\n   clients and servers.  A client may ask for any of these\
    \ attributes to\n   be returned by setting a bit in the GETATTR request but must\
    \ handle\n   the case where the server does not return them.  A client may ask\
    \ for\n   the set of attributes the server supports and should not request\n \
    \  attributes the server does not support.  A server should be tolerant\n   of\
    \ requests for unsupported attributes and simply not return them\n   rather than\
    \ considering the request an error.  It is expected that\n   servers will support\
    \ all attributes they comfortably can and only\n   fail to support attributes\
    \ which are difficult to support in their\n   operating environments.  A server\
    \ should provide attributes whenever\n   they don't have to \"tell lies\" to the\
    \ client.  For example, a file\n   modification time should be either an accurate\
    \ time or should not be\n   supported by the server.  This will not always be\
    \ comfortable to\n   clients but it seems that the client has a better ability\
    \ to\n   fabricate or construct an attribute or do without the attribute.\n"
- title: 5.3.  Named Attributes
  contents:
  - "5.3.  Named Attributes\n   These attributes are not supported by direct encoding\
    \ in the NFS\n   Version 4 protocol but are accessed by string names rather than\n\
    \   numbers and correspond to an uninterpreted stream of bytes which are\n   stored\
    \ with the file system object.  The name space for these\n   attributes may be\
    \ accessed by using the OPENATTR operation.  The\n   OPENATTR operation returns\
    \ a filehandle for a virtual \"attribute\n   directory\" and further perusal of\
    \ the name space may be done using\n   READDIR and LOOKUP operations on this filehandle.\
    \  Named attributes\n   may then be examined or changed by normal READ and WRITE\
    \ and CREATE\n   operations on the filehandles returned from READDIR and LOOKUP.\n\
    \   Named attributes may have attributes.\n   It is recommended that servers support\
    \ arbitrary named attributes.  A\n   client should not depend on the ability to\
    \ store any named attributes\n   in the server's file system.  If a server does\
    \ support named\n   attributes, a client which is also able to handle them should\
    \ be able\n   to copy a file's data and meta-data with complete transparency from\n\
    \   one location to another; this would imply that names allowed for\n   regular\
    \ directory entries are valid for named attribute names as\n   well.\n   Names\
    \ of attributes will not be controlled by this document or other\n   IETF standards\
    \ track documents.  See the section \"IANA\n   Considerations\" for further discussion.\n"
- title: 5.4.  Mandatory Attributes - Definitions
  contents:
  - "5.4.  Mandatory Attributes - Definitions\n   Name              #    DataType\
    \     Access   Description\n   ___________________________________________________________________\n\
    \   supp_attr         0    bitmap       READ     The bit vector which\n      \
    \                                          would retrieve all\n              \
    \                                  mandatory and\n                           \
    \                     recommended attributes\n                               \
    \                 that are supported for\n                                   \
    \             this object.\n   type              1    nfs4_ftype   READ     The\
    \ type of the object\n                                                (file, directory,\n\
    \                                                symlink)\n   fh_expire_type \
    \   2    uint32       READ     Server uses this to\n                         \
    \                       specify filehandle\n                                 \
    \               expiration behavior to\n                                     \
    \           the client.  See the\n                                           \
    \     section \"Filehandles\"\n                                              \
    \  for additional\n                                                description.\n\
    \   change            3    uint64       READ     A value created by the\n    \
    \                                            server that the client\n        \
    \                                        can use to determine\n              \
    \                                  if file data,\n                           \
    \                     directory contents or\n                                \
    \                attributes of the\n                                         \
    \       object have been\n                                                modified.\
    \  The server\n                                                may return the\n\
    \                                                object's time_modify\n      \
    \                                          attribute for this\n              \
    \                                  attribute's value but\n                   \
    \                             only if the file\n                             \
    \                   system object can not\n                                  \
    \              be updated more\n                                             \
    \   frequently than the\n                                                resolution\
    \ of\n                                                time_modify.\n   size  \
    \            4    uint64       R/W      The size of the object\n             \
    \                                   in bytes.\n   link_support      5    boolean\
    \      READ     Does the object's file\n                                     \
    \           system supports hard\n                                           \
    \     links?\n   symlink_support   6    boolean      READ     Does the object's\
    \ file\n                                                system supports\n    \
    \                                            symbolic links?\n   named_attr  \
    \      7    boolean      READ     Does this object have\n                    \
    \                            named attributes?\n   fsid              8    fsid4\
    \        READ     Unique file system\n                                       \
    \         identifier for the\n                                               \
    \ file system holding\n                                                this object.\
    \  fsid\n                                                contains major and\n\
    \                                                minor components each\n     \
    \                                           of which are uint64.\n   unique_handles\
    \    9    boolean      READ     Are two distinct\n                           \
    \                     filehandles guaranteed\n                               \
    \                 to refer to two\n                                          \
    \      different file system\n                                               \
    \ objects?\n   lease_time        10   nfs_lease4   READ     Duration of leases\
    \ at\n                                                server in seconds.\n   rdattr_error\
    \      11   enum         READ     Error returned from\n                      \
    \                          getattr during\n                                  \
    \              readdir.\n"
- title: 5.5.  Recommended Attributes - Definitions
  contents:
  - "5.5.  Recommended Attributes - Definitions\n   Name               #    Data Type\
    \      Access   Description\n   _____________________________________________________________________\n\
    \   ACL                12   nfsace4<>      R/W      The access control\n     \
    \                                              list for the object.\n   aclsupport\
    \         13   uint32         READ     Indicates what types\n                \
    \                                   of ACLs are supported\n                  \
    \                                 on the current file\n                      \
    \                             system.\n   archive            14   boolean    \
    \    R/W      Whether or not this\n                                          \
    \         file has been\n                                                   archived\
    \ since the\n                                                   time of last\n\
    \                                                   modification\n           \
    \                                        (deprecated in favor\n              \
    \                                     of time_backup).\n   cansettime        \
    \ 15   boolean        READ     Is the server able to\n                       \
    \                            change the times for\n                          \
    \                         a file system object\n                             \
    \                      as specified in a\n                                   \
    \                SETATTR operation?\n   case_insensitive   16   boolean      \
    \  READ     Are filename\n                                                   comparisons\
    \ on this\n                                                   file system case\n\
    \                                                   insensitive?\n   case_preserving\
    \    17   boolean        READ     Is filename case on\n                      \
    \                             this file system\n                             \
    \                      preserved?\n   chown_restricted   18   boolean        READ\
    \     If TRUE, the server\n                                                  \
    \ will reject any\n                                                   request\
    \ to change\n                                                   either the owner\
    \ or\n                                                   the group associated\n\
    \                                                   with a file if the\n     \
    \                                              caller is not a\n             \
    \                                      privileged user (for\n                \
    \                                   example, \"root\" in\n                   \
    \                                Unix operating\n                            \
    \                       environments or in NT\n                              \
    \                     the \"Take Ownership\"\n                               \
    \                    privilege)\n   filehandle         19   nfs4_fh        READ\
    \     The filehandle of\n                                                   this\
    \ object\n                                                   (primarily for\n\
    \                                                   readdir requests).\n   fileid\
    \             20   uint64         READ     A number uniquely\n               \
    \                                    identifying the file\n                  \
    \                                 within the file\n                          \
    \                         system.\n   files_avail        21   uint64         READ\
    \     File slots available\n                                                 \
    \  to this user on the\n                                                   file\
    \ system\n                                                   containing this\n\
    \                                                   object - this should\n   \
    \                                                be the smallest\n           \
    \                                        relevant limit.\n   files_free      \
    \   22   uint64         READ     Free file slots on\n                        \
    \                           the file system\n                                \
    \                   containing this\n                                        \
    \           object - this should\n                                           \
    \        be the smallest\n                                                   relevant\
    \ limit.\n   files_total        23   uint64         READ     Total file slots\
    \ on\n                                                   the file system\n   \
    \                                                containing this\n           \
    \                                        object.\n   fs_locations       24   fs_locations\
    \   READ     Locations where this\n                                          \
    \         file system may be\n                                               \
    \    found.  If the server\n                                                 \
    \  returns NFS4ERR_MOVED\n                                                   as\
    \ an error, this\n                                                   attribute\
    \ must be\n                                                   supported.\n   hidden\
    \             25   boolean        R/W      Is file considered\n              \
    \                                     hidden with respect\n                  \
    \                                 to the WIN32 API?\n   homogeneous        26\
    \   boolean        READ     Whether or not this\n                            \
    \                       object's file system\n                               \
    \                    is homogeneous, i.e.\n                                  \
    \                 are per file system\n                                      \
    \             attributes the same\n                                          \
    \         for all file system's\n                                            \
    \       objects.\n   maxfilesize        27   uint64         READ     Maximum supported\n\
    \                                                   file size for the\n      \
    \                                             file system of this\n          \
    \                                         object.\n   maxlink            28  \
    \ uint32         READ     Maximum number of\n                                \
    \                   links for this\n                                         \
    \          object.\n   maxname            29   uint32         READ     Maximum\
    \ filename size\n                                                   supported\
    \ for this\n                                                   object.\n   maxread\
    \            30   uint64         READ     Maximum read size\n                \
    \                                   supported for this\n                     \
    \                              object.\n   maxwrite           31   uint64    \
    \     READ     Maximum write size\n                                          \
    \         supported for this\n                                               \
    \    object.  This\n                                                   attribute\
    \ SHOULD be\n                                                   supported if the\
    \ file\n                                                   is writable.  Lack\
    \ of\n                                                   this attribute can\n\
    \                                                   lead to the client\n     \
    \                                              either wasting\n              \
    \                                     bandwidth or not\n                     \
    \                              receiving the best\n                          \
    \                         performance.\n   mimetype           32   utf8<>    \
    \     R/W      MIME body\n                                                   type/subtype\
    \ of this\n                                                   object.\n   mode\
    \               33   mode4          R/W      Unix-style permission\n         \
    \                                          bits for this object\n            \
    \                                       (deprecated in favor\n               \
    \                                    of ACLs)\n   no_trunc           34   boolean\
    \        READ     If a name longer than\n                                    \
    \               name_max is used,\n                                          \
    \         will an error be\n                                                 \
    \  returned or will the\n                                                   name\
    \ be truncated?\n   numlinks           35   uint32         READ     Number of\
    \ hard links\n                                                   to this object.\n\
    \   owner              36   utf8<>         R/W      The string name of\n     \
    \                                              the owner of this\n           \
    \                                        object.\n   owner_group        37   utf8<>\
    \         R/W      The string name of\n                                      \
    \             the group ownership\n                                          \
    \         of this object.\n   quota_avail_hard   38   uint64         READ    \
    \ For definition see\n                                                   \"Quota\
    \ Attributes\"\n                                                   section below.\n\
    \   quota_avail_soft   39   uint64         READ     For definition see\n     \
    \                                              \"Quota Attributes\"\n        \
    \                                           section below.\n   quota_used    \
    \     40   uint64         READ     For definition see\n                      \
    \                             \"Quota Attributes\"\n                         \
    \                          section below.\n   rawdev             41   specdata4\
    \      READ     Raw device\n                                                 \
    \  identifier.  Unix\n                                                   device\
    \ major/minor\n                                                   node information.\n\
    \   space_avail        42   uint64         READ     Disk space in bytes\n    \
    \                                               available to this\n          \
    \                                         user on the file\n                 \
    \                                  system containing\n                       \
    \                            this object - this\n                            \
    \                       should be the\n                                      \
    \             smallest relevant\n                                            \
    \       limit.\n   space_free         43   uint64         READ     Free disk space\
    \ in\n                                                   bytes on the file\n \
    \                                                  system containing\n       \
    \                                            this object - this\n            \
    \                                       should be the\n                      \
    \                             smallest relevant\n                            \
    \                       limit.\n   space_total        44   uint64         READ\
    \     Total disk space in\n                                                  \
    \ bytes on the file\n                                                   system\
    \ containing\n                                                   this object.\n\
    \   space_used         45   uint64         READ     Number of file system\n  \
    \                                                 bytes allocated to\n       \
    \                                            this object.\n   system         \
    \    46   boolean        R/W      Is this file a system\n                    \
    \                               file with respect to\n                       \
    \                            the WIN32 API?\n   time_access        47   nfstime4\
    \       READ     The time of last\n                                          \
    \         access to the object.\n   time_access_set    48   settime4       WRITE\
    \    Set the time of last\n                                                  \
    \ access to the object.\n                                                   SETATTR\
    \ use only.\n   time_backup        49   nfstime4       R/W      The time of last\n\
    \                                                   backup of the object.\n  \
    \ time_create        50   nfstime4       R/W      The time of creation\n     \
    \                                              of the object. This\n         \
    \                                          attribute does not\n              \
    \                                     have any relation to\n                 \
    \                                  the traditional Unix\n                    \
    \                               file attribute\n                             \
    \                      \"ctime\" or \"change\n                               \
    \                    time\".\n   time_delta         51   nfstime4       READ \
    \    Smallest useful\n                                                   server\
    \ time\n                                                   granularity.\n   time_metadata\
    \      52   nfstime4       R/W      The time of last\n                       \
    \                            meta-data\n                                     \
    \              modification of the\n                                         \
    \          object.\n   time_modify        53   nfstime4       READ     The time\
    \ of last\n                                                   modification to\
    \ the\n                                                   object.\n   time_modify_set\
    \    54   settime4       WRITE    Set the time of last\n                     \
    \                              modification to the\n                         \
    \                          object.  SETATTR use\n                            \
    \                       only.\n"
- title: 5.6.  Interpreting owner and owner_group
  contents:
  - "5.6.  Interpreting owner and owner_group\n   The recommended attributes \"owner\"\
    \ and \"owner_group\" are represented\n   in terms of a UTF-8 string.  To avoid\
    \ a representation that is tied\n   to a particular underlying implementation\
    \ at the client or server,\n   the use of the UTF-8 string has been chosen.  Note\
    \ that section 6.1\n   of [RFC2624] provides additional rationale.  It is expected\
    \ that the\n   client and server will have their own local representation of owner\n\
    \   and owner_group that is used for local storage or presentation to the\n  \
    \ end user.  Therefore, it is expected that when these attributes are\n   transferred\
    \ between the client and server that the local\n   representation is translated\
    \ to a syntax of the form\n   \"user@dns_domain\".  This will allow for a client\
    \ and server that do\n   not use the same local representation the ability to\
    \ translate to a\n   common syntax that can be interpreted by both.\n   The translation\
    \ is not specified as part of the protocol.  This\n   allows various solutions\
    \ to be employed.  For example, a local\n   translation table may be consulted\
    \ that maps between a numeric id to\n   the user@dns_domain syntax.  A name service\
    \ may also be used to\n   accomplish the translation.  The \"dns_domain\" portion\
    \ of the owner\n   string is meant to be a DNS domain name.  For example, user@ietf.org.\n\
    \   In the case where there is no translation available to the client or\n   server,\
    \ the attribute value must be constructed without the \"@\".\n   Therefore, the\
    \ absence of the @ from the owner or owner_group\n   attribute signifies that\
    \ no translation was available and the\n   receiver of the attribute should not\
    \ place any special meaning with\n   the attribute value.  Even though the attribute\
    \ value can not be\n   translated, it may still be useful.  In the case of a client,\
    \ the\n   attribute string may be used for local display of ownership.\n"
- title: 5.7.  Character Case Attributes
  contents:
  - "5.7.  Character Case Attributes\n   With respect to the case_insensitive and\
    \ case_preserving attributes,\n   each UCS-4 character (which UTF-8 encodes) has\
    \ a \"long descriptive\n   name\" [RFC1345] which may or may not included the\
    \ word \"CAPITAL\" or\n   \"SMALL\".  The presence of SMALL or CAPITAL allows\
    \ an NFS server to\n   implement unambiguous and efficient table driven mappings\
    \ for case\n   insensitive comparisons, and non-case-preserving storage.  For\n\
    \   general character handling and internationalization issues, see the\n   section\
    \ \"Internationalization\".\n"
- title: 5.8.  Quota Attributes
  contents:
  - "5.8.  Quota Attributes\n   For the attributes related to file system quotas,\
    \ the following\n   definitions apply:\n   quota_avail_soft\n         The value\
    \ in bytes which represents the amount of additional\n         disk space that\
    \ can be allocated to this file or directory\n         before the user may reasonably\
    \ be warned.  It is understood\n         that this space may be consumed by allocations\
    \ to other files\n         or directories though there is a rule as to which other\
    \ files\n         or directories.\n   quota_avail_hard\n         The value in\
    \ bytes which represent the amount of additional\n         disk space beyond the\
    \ current allocation that can be allocated\n         to this file or directory\
    \ before further allocations will be\n         refused.  It is understood that\
    \ this space may be consumed by\n         allocations to other files or directories.\n\
    \   quota_used\n         The value in bytes which represent the amount of disc\
    \ space\n         used by this file or directory and possibly a number of other\n\
    \         similar files or directories, where the set of \"similar\" meets\n \
    \        at least the criterion that allocating space to any file or\n       \
    \  directory in the set will reduce the \"quota_avail_hard\" of\n         every\
    \ other file or directory in the set.\n         Note that there may be a number\
    \ of distinct but overlapping\n         sets of files or directories for which\
    \ a quota_used value is\n         maintained. E.g. \"all files with a given owner\"\
    , \"all files\n         with a given group owner\". etc.\n         The server\
    \ is at liberty to choose any of those sets but should\n         do so in a repeatable\
    \ way.  The rule may be configured per-\n         filesystem or may be \"choose\
    \ the set with the smallest quota\".\n"
- title: 5.9.  Access Control Lists
  contents:
  - "5.9.  Access Control Lists\n   The NFS ACL attribute is an array of access control\
    \ entries (ACE).\n   There are various access control entry types.  The server\
    \ is able to\n   communicate which ACE types are supported by returning the\n\
    \   appropriate value within the aclsupport attribute.  The types of ACEs\n  \
    \ are defined as follows:\n   Type         Description\n   _____________________________________________________\n\
    \   ALLOW        Explicitly grants the access defined in\n                acemask4\
    \ to the file or directory.\n   DENY         Explicitly denies the access defined\
    \ in\n                acemask4 to the file or directory.\n   AUDIT        LOG\
    \ (system dependent) any access\n                attempt to a file or directory\
    \ which\n                uses any of the access methods specified\n          \
    \      in acemask4.\n   ALARM        Generate a system ALARM (system\n       \
    \         dependent) when any access attempt is\n                made to a file\
    \ or directory for the\n                access methods specified in acemask4.\n\
    \   The NFS ACE attribute is defined as follows:\n   typedef uint32_t        acetype4;\n\
    \   typedef uint32_t        aceflag4;\n   typedef uint32_t        acemask4;\n\
    \   struct nfsace4 {\n           acetype4        type;\n           aceflag4  \
    \      flag;\n           acemask4        access_mask;\n           utf8string \
    \     who;\n   };\n   To determine if an ACCESS or OPEN request succeeds each\
    \ nfsace4 entry\n   is processed in order by the server.  Only ACEs which have\
    \ a \"who\"\n   that matches the requester are considered.  Each ACE is processed\n\
    \   until all of the bits of the requester's access have been ALLOWED.\n   Once\
    \ a bit (see below) has been ALLOWED by an ACCESS_ALLOWED_ACE, it\n   is no longer\
    \ considered in the processing of later ACEs. If an\n   ACCESS_DENIED_ACE is encountered\
    \ where the requester's mode still has\n   unALLOWED bits in common with the \"\
    access_mask\" of the ACE, the\n   request is denied.\n   The bitmask constants\
    \ used to represent the above definitions within\n   the aclsupport attribute\
    \ are as follows:\n   const ACL4_SUPPORT_ALLOW_ACL    = 0x00000001;\n   const\
    \ ACL4_SUPPORT_DENY_ACL     = 0x00000002;\n   const ACL4_SUPPORT_AUDIT_ACL   \
    \ = 0x00000004;\n   const ACL4_SUPPORT_ALARM_ACL    = 0x00000008;\n"
- title: 5.9.1.  ACE type
  contents:
  - "5.9.1.  ACE type\n   The semantics of the \"type\" field follow the descriptions\
    \ provided\n   above.\n   The bitmask constants used for the type field are as\
    \ follows:\n   const ACE4_ACCESS_ALLOWED_ACE_TYPE      = 0x00000000;\n   const\
    \ ACE4_ACCESS_DENIED_ACE_TYPE       = 0x00000001;\n   const ACE4_SYSTEM_AUDIT_ACE_TYPE\
    \        = 0x00000002;\n   const ACE4_SYSTEM_ALARM_ACE_TYPE        = 0x00000003;\n"
- title: 5.9.2.  ACE flag
  contents:
  - "5.9.2.  ACE flag\n   The \"flag\" field contains values based on the following\
    \ descriptions.\n   ACE4_FILE_INHERIT_ACE\n   Can be placed on a directory and\
    \ indicates that this ACE should be\n   added to each new non-directory file created.\n\
    \   ACE4_DIRECTORY_INHERIT_ACE\n   Can be placed on a directory and indicates\
    \ that this ACE should be\n   added to each new directory created.\n   ACE4_INHERIT_ONLY_ACE\n\
    \   Can be placed on a directory but does not apply to the directory,\n   only\
    \ to newly created files/directories as specified by the above two\n   flags.\n\
    \   ACE4_NO_PROPAGATE_INHERIT_ACE\n   Can be placed on a directory. Normally when\
    \ a new directory is\n   created and an ACE exists on the parent directory which\
    \ is marked\n   ACL4_DIRECTORY_INHERIT_ACE, two ACEs are placed on the new directory.\n\
    \   One for the directory itself and one which is an inheritable ACE for\n   newly\
    \ created directories.  This flag tells the server to not place\n   an ACE on\
    \ the newly created directory which is inheritable by\n   subdirectories of the\
    \ created directory.\n   ACE4_SUCCESSFUL_ACCESS_ACE_FLAG\n   ACL4_FAILED_ACCESS_ACE_FLAG\n\
    \   Both indicate for AUDIT and ALARM which state to log the event.  On\n   every\
    \ ACCESS or OPEN call which occurs on a file or directory which\n   has an ACL\
    \ that is of type ACE4_SYSTEM_AUDIT_ACE_TYPE or\n   ACE4_SYSTEM_ALARM_ACE_TYPE,\
    \ the attempted access is compared to the\n   ace4mask of these ACLs. If the access\
    \ is a subset of ace4mask and the\n   identifier match, an AUDIT trail or an ALARM\
    \ is generated.  By\n   default this happens regardless of the success or failure\
    \ of the\n   ACCESS or OPEN call.\n   The flag ACE4_SUCCESSFUL_ACCESS_ACE_FLAG\
    \ only produces the AUDIT or\n   ALARM if the ACCESS or OPEN call is successful.\
    \ The\n   ACE4_FAILED_ACCESS_ACE_FLAG causes the ALARM or AUDIT if the ACCESS\n\
    \   or OPEN call fails.\n   ACE4_IDENTIFIER_GROUP\n   Indicates that the \"who\"\
    \ refers to a GROUP as defined under Unix.\n   The bitmask constants used for\
    \ the flag field are as follows:\n   const ACE4_FILE_INHERIT_ACE             =\
    \ 0x00000001;\n   const ACE4_DIRECTORY_INHERIT_ACE        = 0x00000002;\n   const\
    \ ACE4_NO_PROPAGATE_INHERIT_ACE     = 0x00000004;\n   const ACE4_INHERIT_ONLY_ACE\
    \             = 0x00000008;\n   const ACE4_SUCCESSFUL_ACCESS_ACE_FLAG   = 0x00000010;\n\
    \   const ACE4_FAILED_ACCESS_ACE_FLAG       = 0x00000020;\n   const ACE4_IDENTIFIER_GROUP\
    \             = 0x00000040;\n"
- title: 5.9.3.  ACE Access Mask
  contents:
  - "5.9.3.  ACE Access Mask\n   The access_mask field contains values based on the\
    \ following:\n   Access                 Description\n   _______________________________________________________________\n\
    \   READ_DATA              Permission to read the data of the file\n   LIST_DIRECTORY\
    \         Permission to list the contents of a\n                          directory\n\
    \   WRITE_DATA             Permission to modify the file's data\n   ADD_FILE \
    \              Permission to add a new file to a\n                          directory\n\
    \   APPEND_DATA            Permission to append data to a file\n   ADD_SUBDIRECTORY\
    \       Permission to create a subdirectory to a\n                          directory\n\
    \   READ_NAMED_ATTRS       Permission to read the named attributes\n         \
    \                 of a file\n   WRITE_NAMED_ATTRS      Permission to write the\
    \ named attributes\n                          of a file\n   EXECUTE          \
    \      Permission to execute a file\n   DELETE_CHILD           Permission to delete\
    \ a file or directory\n                          within a directory\n   READ_ATTRIBUTES\
    \        The ability to read basic attributes\n                          (non-acls)\
    \ of a file\n   WRITE_ATTRIBUTES       Permission to change basic attributes\n\
    \                          (non-acls) of a file\n   DELETE                 Permission\
    \ to Delete the file\n   READ_ACL               Permission to Read the ACL\n \
    \  WRITE_ACL              Permission to Write the ACL\n   WRITE_OWNER        \
    \    Permission to change the owner\n   SYNCHRONIZE            Permission to access\
    \ file locally at the\n                          server with synchronous reads\
    \ and writes\n   The bitmask constants used for the access mask field are as follows:\n\
    \   const ACE4_READ_DATA            = 0x00000001;\n   const ACE4_LIST_DIRECTORY\
    \       = 0x00000001;\n   const ACE4_WRITE_DATA           = 0x00000002;\n   const\
    \ ACE4_ADD_FILE             = 0x00000002;\n   const ACE4_APPEND_DATA         \
    \ = 0x00000004;\n   const ACE4_ADD_SUBDIRECTORY     = 0x00000004;\n   const ACE4_READ_NAMED_ATTRS\
    \     = 0x00000008;\n   const ACE4_WRITE_NAMED_ATTRS    = 0x00000010;\n   const\
    \ ACE4_EXECUTE              = 0x00000020;\n   const ACE4_DELETE_CHILD        \
    \ = 0x00000040;\n   const ACE4_READ_ATTRIBUTES      = 0x00000080;\n   const ACE4_WRITE_ATTRIBUTES\
    \     = 0x00000100;\n   const ACE4_DELETE               = 0x00010000;\n   const\
    \ ACE4_READ_ACL             = 0x00020000;\n   const ACE4_WRITE_ACL           \
    \ = 0x00040000;\n   const ACE4_WRITE_OWNER          = 0x00080000;\n   const ACE4_SYNCHRONIZE\
    \          = 0x00100000;\n"
- title: 5.9.4.  ACE who
  contents:
  - "5.9.4.  ACE who\n   There are several special identifiers (\"who\") which need\
    \ to be\n   understood universally. Some of these identifiers cannot be\n   understood\
    \ when an NFS client accesses the server, but have meaning\n   when a local process\
    \ accesses the file. The ability to display and\n   modify these permissions is\
    \ permitted over NFS.\n   Who                    Description\n   _______________________________________________________________\n\
    \   \"OWNER\"                The owner of the file.\n   \"GROUP\"            \
    \    The group associated with the file.\n   \"EVERYONE\"             The world.\n\
    \   \"INTERACTIVE\"          Accessed from an interactive terminal.\n   \"NETWORK\"\
    \              Accessed via the network.\n   \"DIALUP\"               Accessed\
    \ as a dialup user to the server.\n   \"BATCH\"                Accessed from a\
    \ batch job.\n   \"ANONYMOUS\"            Accessed without any authentication.\n\
    \   \"AUTHENTICATED\"        Any authenticated user (opposite of\n           \
    \               ANONYMOUS)\n   \"SERVICE\"              Access from a system service.\n\
    \   To avoid conflict, these special identifiers are distinguish by an\n   appended\
    \ \"@\" and should appear in the form \"xxxx@\" (note: no domain\n   name after\
    \ the \"@\").  For example: ANONYMOUS@.\n"
- title: 6.  File System Migration and Replication
  contents:
  - "6.  File System Migration and Replication\n   With the use of the recommended\
    \ attribute \"fs_locations\", the NFS\n   version 4 server has a method of providing\
    \ file system migration or\n   replication services.  For the purposes of migration\
    \ and replication,\n   a file system will be defined as all files that share a\
    \ given fsid\n   (both major and minor values are the same).\n   The fs_locations\
    \ attribute provides a list of file system locations.\n   These locations are\
    \ specified by providing the server name (either\n   DNS domain or IP address)\
    \ and the path name representing the root of\n   the file system.  Depending on\
    \ the type of service being provided,\n   the list will provide a new location\
    \ or a set of alternate locations\n   for the file system.  The client will use\
    \ this information to\n   redirect its requests to the new server.\n"
- title: 6.1.  Replication
  contents:
  - "6.1.  Replication\n   It is expected that file system replication will be used\
    \ in the case\n   of read-only data.  Typically, the file system will be replicated\
    \ on\n   two or more servers.  The fs_locations attribute will provide the\n \
    \  list of these locations to the client.  On first access of the file\n   system,\
    \ the client should obtain the value of the fs_locations\n   attribute.  If, in\
    \ the future, the client finds the server\n   unresponsive, the client may attempt\
    \ to use another server specified\n   by fs_locations.\n   If applicable, the\
    \ client must take the appropriate steps to recover\n   valid filehandles from\
    \ the new server.  This is described in more\n   detail in the following sections.\n"
- title: 6.2.  Migration
  contents:
  - "6.2.  Migration\n   File system migration is used to move a file system from\
    \ one server\n   to another.  Migration is typically used for a file system that\
    \ is\n   writable and has a single copy.  The expected use of migration is for\n\
    \   load balancing or general resource reallocation.  The protocol does\n   not\
    \ specify how the file system will be moved between servers.  This\n   server-to-server\
    \ transfer mechanism is left to the server\n   implementor.  However, the method\
    \ used to communicate the migration\n   event between client and server is specified\
    \ here.\n   Once the servers participating in the migration have completed the\n\
    \   move of the file system, the error NFS4ERR_MOVED will be returned for\n  \
    \ subsequent requests received by the original server.  The\n   NFS4ERR_MOVED\
    \ error is returned for all operations except GETATTR.\n   Upon receiving the\
    \ NFS4ERR_MOVED error, the client will obtain the\n   value of the fs_locations\
    \ attribute.  The client will then use the\n   contents of the attribute to redirect\
    \ its requests to the specified\n   server.  To facilitate the use of GETATTR,\
    \ operations such as PUTFH\n   must also be accepted by the server for the migrated\
    \ file system's\n   filehandles.  Note that if the server returns NFS4ERR_MOVED,\
    \ the\n   server MUST support the fs_locations attribute.\n   If the client requests\
    \ more attributes than just fs_locations, the\n   server may return fs_locations\
    \ only.  This is to be expected since\n   the server has migrated the file system\
    \ and may not have a method of\n   obtaining additional attribute data.\n   The\
    \ server implementor needs to be careful in developing a migration\n   solution.\
    \  The server must consider all of the state information\n   clients may have\
    \ outstanding at the server.  This includes but is not\n   limited to locking/share\
    \ state, delegation state, and asynchronous\n   file writes which are represented\
    \ by WRITE and COMMIT verifiers.  The\n   server should strive to minimize the\
    \ impact on its clients during and\n   after the migration process.\n"
- title: 6.3.  Interpretation of the fs_locations Attribute
  contents:
  - "6.3.  Interpretation of the fs_locations Attribute\n   The fs_location attribute\
    \ is structured in the following way:\n   struct fs_location {\n           utf8string\
    \      server<>;\n           pathname4       rootpath;\n   };\n   struct fs_locations\
    \ {\n           pathname4       fs_root;\n           fs_location     locations<>;\n\
    \   };\n   The fs_location struct is used to represent the location of a file\n\
    \   system by providing a server name and the path to the root of the\n   file\
    \ system.  For a multi-homed server or a set of servers that use\n   the same\
    \ rootpath, an array of server names may be provided.  An\n   entry in the server\
    \ array is an UTF8 string and represents one of a\n   traditional DNS host name,\
    \ IPv4 address, or IPv6 address.  It is not\n   a requirement that all servers\
    \ that share the same rootpath be listed\n   in one fs_location struct.  The array\
    \ of server names is provided for\n   convenience.  Servers that share the same\
    \ rootpath may also be listed\n   in separate fs_location entries in the fs_locations\
    \ attribute.\n   The fs_locations struct and attribute then contains an array\
    \ of\n   locations.  Since the name space of each server may be constructed\n\
    \   differently, the \"fs_root\" field is provided.  The path represented\n  \
    \ by fs_root represents the location of the file system in the server's\n   name\
    \ space.  Therefore, the fs_root path is only associated with the\n   server from\
    \ which the fs_locations attribute was obtained.  The\n   fs_root path is meant\
    \ to aid the client in locating the file system\n   at the various servers listed.\n\
    \   As an example, there is a replicated file system located at two\n   servers\
    \ (servA and servB).  At servA the file system is located at\n   path \"/a/b/c\"\
    .  At servB the file system is located at path \"/x/y/z\".\n   In this example\
    \ the client accesses the file system first at servA\n   with a multi-component\
    \ lookup path of \"/a/b/c/d\".  Since the client\n   used a multi-component lookup\
    \ to obtain the filehandle at \"/a/b/c/d\",\n   it is unaware that the file system's\
    \ root is located in servA's name\n   space at \"/a/b/c\".  When the client switches\
    \ to servB, it will need\n   to determine that the directory it first referenced\
    \ at servA is now\n   represented by the path \"/x/y/z/d\" on servB.  To facilitate\
    \ this, the\n   fs_locations attribute provided by servA would have a fs_root\
    \ value\n   of \"/a/b/c\" and two entries in fs_location.  One entry in fs_location\n\
    \   will be for itself (servA) and the other will be for servB with a\n   path\
    \ of \"/x/y/z\".  With this information, the client is able to\n   substitute\
    \ \"/x/y/z\" for the \"/a/b/c\" at the beginning of its access\n   path and construct\
    \ \"/x/y/z/d\" to use for the new server.\n"
- title: 6.4.  Filehandle Recovery for Migration or Replication
  contents:
  - "6.4.  Filehandle Recovery for Migration or Replication\n   Filehandles for file\
    \ systems that are replicated or migrated\n   generally have the same semantics\
    \ as for file systems that are not\n   replicated or migrated.  For example, if\
    \ a file system has persistent\n   filehandles and it is migrated to another server,\
    \ the filehandle\n   values for the file system will be valid at the new server.\n\
    \   For volatile filehandles, the servers involved likely do not have a\n   mechanism\
    \ to transfer filehandle format and content between\n   themselves.  Therefore,\
    \ a server may have difficulty in determining\n   if a volatile filehandle from\
    \ an old server should return an error of\n   NFS4ERR_FHEXPIRED.  Therefore, the\
    \ client is informed, with the use\n   of the fh_expire_type attribute, whether\
    \ volatile filehandles will\n   expire at the migration or replication event.\
    \  If the bit\n   FH4_VOL_MIGRATION is set in the fh_expire_type attribute, the\
    \ client\n   must treat the volatile filehandle as if the server had returned\
    \ the\n   NFS4ERR_FHEXPIRED error.  At the migration or replication event in\n\
    \   the presence of the FH4_VOL_MIGRATION bit, the client will not\n   present\
    \ the original or old volatile file handle to the new server.\n   The client will\
    \ start its communication with the new server by\n   recovering its filehandles\
    \ using the saved file names.\n"
- title: 7.  NFS Server Name Space
  contents:
  - '7.  NFS Server Name Space

    '
- title: 7.1.  Server Exports
  contents:
  - "7.1.  Server Exports\n   On a UNIX server the name space describes all the files\
    \ reachable by\n   pathnames under the root directory or \"/\".  On a Windows\
    \ NT server\n   the name space constitutes all the files on disks named by mapped\n\
    \   disk letters.  NFS server administrators rarely make the entire\n   server's\
    \ file system name space available to NFS clients.  More often\n   portions of\
    \ the name space are made available via an \"export\"\n   feature.  In previous\
    \ versions of the NFS protocol, the root\n   filehandle for each export is obtained\
    \ through the MOUNT protocol;\n   the client sends a string that identifies the\
    \ export of name space\n   and the server returns the root filehandle for it.\
    \  The MOUNT\n   protocol supports an EXPORTS procedure that will enumerate the\n\
    \   server's exports.\n"
- title: 7.2.  Browsing Exports
  contents:
  - "7.2.  Browsing Exports\n   The NFS version 4 protocol provides a root filehandle\
    \ that clients\n   can use to obtain filehandles for these exports via a multi-component\n\
    \   LOOKUP.  A common user experience is to use a graphical user\n   interface\
    \ (perhaps a file \"Open\" dialog window) to find a file via\n   progressive browsing\
    \ through a directory tree.  The client must be\n   able to move from one export\
    \ to another export via single-component,\n   progressive LOOKUP operations.\n\
    \   This style of browsing is not well supported by the NFS version 2 and\n  \
    \ 3 protocols.  The client expects all LOOKUP operations to remain\n   within\
    \ a single server file system.  For example, the device\n   attribute will not\
    \ change.  This prevents a client from taking name\n   space paths that span exports.\n\
    \   An automounter on the client can obtain a snapshot of the server's\n   name\
    \ space using the EXPORTS procedure of the MOUNT protocol.  If it\n   understands\
    \ the server's pathname syntax, it can create an image of\n   the server's name\
    \ space on the client.  The parts of the name space\n   that are not exported\
    \ by the server are filled in with a \"pseudo file\n   system\" that allows the\
    \ user to browse from one mounted file system\n   to another.  There is a drawback\
    \ to this representation of the\n   server's name space on the client: it is static.\
    \  If the server\n   administrator adds a new export the client will be unaware\
    \ of it.\n"
- title: 7.3.  Server Pseudo File System
  contents:
  - "7.3.  Server Pseudo File System\n   NFS version 4 servers avoid this name space\
    \ inconsistency by\n   presenting all the exports within the framework of a single\
    \ server\n   name space.  An NFS version 4 client uses LOOKUP and READDIR\n  \
    \ operations to browse seamlessly from one export to another.  Portions\n   of\
    \ the server name space that are not exported are bridged via a\n   \"pseudo file\
    \ system\" that provides a view of exported directories\n   only.  A pseudo file\
    \ system has a unique fsid and behaves like a\n   normal, read only file system.\n\
    \   Based on the construction of the server's name space, it is possible\n   that\
    \ multiple pseudo file systems may exist.  For example,\n   /a         pseudo\
    \ file system\n   /a/b       real file system\n   /a/b/c     pseudo file system\n\
    \   /a/b/c/d   real file system\n   Each of the pseudo file systems are consider\
    \ separate entities and\n   therefore will have a unique fsid.\n"
- title: 7.4.  Multiple Roots
  contents:
  - "7.4.  Multiple Roots\n   The DOS and Windows operating environments are sometimes\
    \ described as\n   having \"multiple roots\".  File systems are commonly represented\
    \ as\n   disk letters.  MacOS represents file systems as top level names.  NFS\n\
    \   version 4 servers for these platforms can construct a pseudo file\n   system\
    \ above these root names so that disk letters or volume names\n   are simply directory\
    \ names in the pseudo root.\n"
- title: 7.5.  Filehandle Volatility
  contents:
  - "7.5.  Filehandle Volatility\n   The nature of the server's pseudo file system\
    \ is that it is a logical\n   representation of file system(s) available from\
    \ the server.\n   Therefore, the pseudo file system is most likely constructed\n\
    \   dynamically when the server is first instantiated.  It is expected\n   that\
    \ the pseudo file system may not have an on disk counterpart from\n   which persistent\
    \ filehandles could be constructed.  Even though it is\n   preferable that the\
    \ server provide persistent filehandles for the\n   pseudo file system, the NFS\
    \ client should expect that pseudo file\n   system filehandles are volatile. \
    \ This can be confirmed by checking\n   the associated \"fh_expire_type\" attribute\
    \ for those filehandles in\n   question.  If the filehandles are volatile, the\
    \ NFS client must be\n   prepared to recover a filehandle value (e.g. with a multi-component\n\
    \   LOOKUP) when receiving an error of NFS4ERR_FHEXPIRED.\n"
- title: 7.6.  Exported Root
  contents:
  - "7.6.  Exported Root\n   If the server's root file system is exported, one might\
    \ conclude that\n   a pseudo-file system is not needed.  This would be wrong.\
    \  Assume the\n   following file systems on a server:\n            /       disk1\
    \  (exported)\n            /a      disk2  (not exported)\n            /a/b   \
    \ disk3  (exported)\n   Because disk2 is not exported, disk3 cannot be reached\
    \ with simple\n   LOOKUPs.  The server must bridge the gap with a pseudo-file\
    \ system.\n"
- title: 7.7.  Mount Point Crossing
  contents:
  - "7.7.  Mount Point Crossing\n   The server file system environment may be constructed\
    \ in such a way\n   that one file system contains a directory which is 'covered'\
    \ or\n   mounted upon by a second file system.  For example:\n            /a/b\
    \            (file system 1)\n            /a/b/c/d        (file system 2)\n  \
    \ The pseudo file system for this server may be constructed to look\n   like:\n\
    \            /               (place holder/not exported)\n            /a/b   \
    \         (file system 1)\n            /a/b/c/d        (file system 2)\n   It\
    \ is the server's responsibility to present the pseudo file system\n   that is\
    \ complete to the client.  If the client sends a lookup request\n   for the path\
    \ \"/a/b/c/d\", the server's response is the filehandle of\n   the file system\
    \ \"/a/b/c/d\".  In previous versions of the NFS\n   protocol, the server would\
    \ respond with the directory \"/a/b/c/d\"\n   within the file system \"/a/b\"\
    .\n   The NFS client will be able to determine if it crosses a server mount\n\
    \   point by a change in the value of the \"fsid\" attribute.\n"
- title: 7.8.  Security Policy and Name Space Presentation
  contents:
  - "7.8.  Security Policy and Name Space Presentation\n   The application of the\
    \ server's security policy needs to be carefully\n   considered by the implementor.\
    \  One may choose to limit the\n   viewability of portions of the pseudo file\
    \ system based on the\n   server's perception of the client's ability to authenticate\
    \ itself\n   properly.  However, with the support of multiple security mechanisms\n\
    \   and the ability to negotiate the appropriate use of these mechanisms,\n  \
    \ the server is unable to properly determine if a client will be able\n   to authenticate\
    \ itself.  If, based on its policies, the server\n   chooses to limit the contents\
    \ of the pseudo file system, the server\n   may effectively hide file systems\
    \ from a client that may otherwise\n   have legitimate access.\n"
- title: 8.  File Locking and Share Reservations
  contents:
  - "8.  File Locking and Share Reservations\n   Integrating locking into the NFS\
    \ protocol necessarily causes it to be\n   state-full.  With the inclusion of\
    \ \"share\" file locks the protocol\n   becomes substantially more dependent on\
    \ state than the traditional\n   combination of NFS and NLM [XNFS].  There are\
    \ three components to\n   making this state manageable:\n   o  Clear division\
    \ between client and server\n   o  Ability to reliably detect inconsistency in\
    \ state between client\n      and server\n   o  Simple and robust recovery mechanisms\n\
    \   In this model, the server owns the state information.  The client\n   communicates\
    \ its view of this state to the server as needed.  The\n   client is also able\
    \ to detect inconsistent state before modifying a\n   file.\n   To support Win32\
    \ \"share\" locks it is necessary to atomically OPEN or\n   CREATE files.  Having\
    \ a separate share/unshare operation would not\n   allow correct implementation\
    \ of the Win32 OpenFile API.  In order to\n   correctly implement share semantics,\
    \ the previous NFS protocol\n   mechanisms used when a file is opened or created\
    \ (LOOKUP, CREATE,\n   ACCESS) need to be replaced.  The NFS version 4 protocol\
    \ has an OPEN\n   operation that subsumes the functionality of LOOKUP, CREATE,\
    \ and\n   ACCESS.  However, because many operations require a filehandle, the\n\
    \   traditional LOOKUP is preserved to map a file name to filehandle\n   without\
    \ establishing state on the server.  The policy of granting\n   access or modifying\
    \ files is managed by the server based on the\n   client's state.  These mechanisms\
    \ can implement policy ranging from\n   advisory only locking to full mandatory\
    \ locking.\n"
- title: 8.1.  Locking
  contents:
  - "8.1.  Locking\n   It is assumed that manipulating a lock is rare when compared\
    \ to READ\n   and WRITE operations.  It is also assumed that crashes and network\n\
    \   partitions are relatively rare.  Therefore it is important that the\n   READ\
    \ and WRITE operations have a lightweight mechanism to indicate if\n   they possess\
    \ a held lock.  A lock request contains the heavyweight\n   information required\
    \ to establish a lock and uniquely define the lock\n   owner.\n   The following\
    \ sections describe the transition from the heavy weight\n   information to the\
    \ eventual stateid used for most client and server\n   locking and lease interactions.\n"
- title: 8.1.1.  Client ID
  contents:
  - "8.1.1.  Client ID\n   For each LOCK request, the client must identify itself\
    \ to the server.\n   This is done in such a way as to allow for correct lock\n\
    \   identification and crash recovery.  Client identification is\n   accomplished\
    \ with two values.\n   o  A verifier that is used to detect client reboots.\n\
    \   o  A variable length opaque array to uniquely define a client.\n         For\
    \ an operating system this may be a fully qualified host name\n         or IP\
    \ address.  For a user level NFS client it may additionally\n         contain\
    \ a process id or other unique sequence.\n   The data structure for the Client\
    \ ID would then appear as:\n            struct nfs_client_id {\n             \
    \       opaque verifier[4];\n                    opaque id<>;\n            }\n\
    \   It is possible through the mis-configuration of a client or the\n   existence\
    \ of a rogue client that two clients end up using the same\n   nfs_client_id.\
    \  This situation is avoided by \"negotiating\" the\n   nfs_client_id between\
    \ client and server with the use of the\n   SETCLIENTID and SETCLIENTID_CONFIRM\
    \ operations.  The following\n   describes the two scenarios of negotiation.\n\
    \   1  Client has never connected to the server\n      In this case the client\
    \ generates an nfs_client_id and unless\n      another client has the same nfs_client_id.id\
    \ field, the server\n      accepts the request. The server also records the principal\
    \ (or\n      principal to uid mapping) from the credential in the RPC request\n\
    \      that contains the nfs_client_id negotiation request (SETCLIENTID\n    \
    \  operation).\n      Two clients might still use the same nfs_client_id.id due\
    \ to\n      perhaps configuration error.  For example, a High Availability\n \
    \     configuration where the nfs_client_id.id is derived from the\n      ethernet\
    \ controller address and both systems have the same\n      address.  In this case,\
    \ the result is a switched union that\n      returns, in addition to NFS4ERR_CLID_INUSE,\
    \ the network address\n      (the rpcbind netid and universal address) of the\
    \ client that is\n      using the id.\n   2  Client is re-connecting to the server\
    \ after a client reboot\n      In this case, the client still generates an nfs_client_id\
    \ but the\n      nfs_client_id.id field will be the same as the nfs_client_id.id\n\
    \      generated prior to reboot.  If the server finds that the\n      principal/uid\
    \ is equal to the previously \"registered\"\n      nfs_client_id.id, then locks\
    \ associated with the old nfs_client_id\n      are immediately released.  If the\
    \ principal/uid is not equal, then\n      this is a rogue client and the request\
    \ is returned in error.  For\n      more discussion of crash recovery semantics,\
    \ see the section on\n      \"Crash Recovery\".\n      It is possible for a retransmission\
    \ of request to be received by\n      the server after the server has acted upon\
    \ and responded to the\n      original client request.  Therefore to mitigate\
    \ effects of the\n      retransmission of the SETCLIENTID operation, the client\
    \ and server\n      use a confirmation step.  The server returns a confirmation\n\
    \      verifier that the client then sends to the server in the\n      SETCLIENTID_CONFIRM\
    \ operation.  Once the server receives the\n      confirmation from the client,\
    \ the locking state for the client is\n      released.\n   In both cases, upon\
    \ success, NFS4_OK is returned.  To help reduce the\n   amount of data transferred\
    \ on OPEN and LOCK, the server will also\n   return a unique 64-bit clientid value\
    \ that is a shorthand reference\n   to the nfs_client_id values presented by the\
    \ client.  From this point\n   forward, the client will use the clientid to refer\
    \ to itself.\n   The clientid assigned by the server should be chosen so that\
    \ it will\n   not conflict with a clientid previously assigned by the server.\
    \  This\n   applies across server restarts or reboots.  When a clientid is\n \
    \  presented to a server and that clientid is not recognized, as would\n   happen\
    \ after a server reboot, the server will reject the request with\n   the error\
    \ NFS4ERR_STALE_CLIENTID.  When this happens, the client must\n   obtain a new\
    \ clientid by use of the SETCLIENTID operation and then\n   proceed to any other\
    \ necessary recovery for the server reboot case\n   (See the section \"Server\
    \ Failure and Recovery\").\n   The client must also employ the SETCLIENTID operation\
    \ when it\n   receives a NFS4ERR_STALE_STATEID error using a stateid derived from\n\
    \   its current clientid, since this also indicates a server reboot which\n  \
    \ has invalidated the existing clientid (see the next section\n   \"nfs_lockowner\
    \ and stateid Definition\" for details).\n"
- title: 8.1.2.  Server Release of Clientid
  contents:
  - "8.1.2.  Server Release of Clientid\n   If the server determines that the client\
    \ holds no associated state\n   for its clientid, the server may choose to release\
    \ the clientid.  The\n   server may make this choice for an inactive client so\
    \ that resources\n   are not consumed by those intermittently active clients.\
    \  If the\n   client contacts the server after this release, the server must ensure\n\
    \   the client receives the appropriate error so that it will use the\n   SETCLIENTID/SETCLIENTID_CONFIRM\
    \ sequence to establish a new identity.\n   It should be clear that the server\
    \ must be very hesitant to release a\n   clientid since the resulting work on\
    \ the client to recover from such\n   an event will be the same burden as if the\
    \ server had failed and\n   restarted.  Typically a server would not release a\
    \ clientid unless\n   there had been no activity from that client for many minutes.\n"
- title: 8.1.3.  nfs_lockowner and stateid Definition
  contents:
  - "8.1.3.  nfs_lockowner and stateid Definition\n   When requesting a lock, the\
    \ client must present to the server the\n   clientid and an identifier for the\
    \ owner of the requested lock.\n   These two fields are referred to as the nfs_lockowner\
    \ and the\n   definition of those fields are:\n   o  A clientid returned by the\
    \ server as part of the client's use of\n      the SETCLIENTID operation.\n  \
    \ o  A variable length opaque array used to uniquely define the owner\n      of\
    \ a lock managed by the client.\n         This may be a thread id, process id,\
    \ or other unique value.\n   When the server grants the lock, it responds with\
    \ a unique 64-bit\n   stateid.  The stateid is used as a shorthand reference to\
    \ the\n   nfs_lockowner, since the server will be maintaining the\n   correspondence\
    \ between them.\n   The server is free to form the stateid in any manner that\
    \ it chooses\n   as long as it is able to recognize invalid and out-of-date stateids.\n\
    \   This requirement includes those stateids generated by earlier\n   instances\
    \ of the server.  From this, the client can be properly\n   notified of a server\
    \ restart.  This notification will occur when the\n   client presents a stateid\
    \ to the server from a previous\n   instantiation.\n   The server must be able\
    \ to distinguish the following situations and\n   return the error as specified:\n\
    \   o  The stateid was generated by an earlier server instance (i.e.\n      before\
    \ a server reboot).  The error NFS4ERR_STALE_STATEID should\n      be returned.\n\
    \   o  The stateid was generated by the current server instance but the\n    \
    \  stateid no longer designates the current locking state for the\n      lockowner-file\
    \ pair in question (i.e. one or more locking\n      operations has occurred).\
    \  The error NFS4ERR_OLD_STATEID should be\n      returned.\n      This error\
    \ condition will only occur when the client issues a\n      locking request which\
    \ changes a stateid while an I/O request that\n      uses that stateid is outstanding.\n\
    \   o  The stateid was generated by the current server instance but the\n    \
    \  stateid does not designate a locking state for any active\n      lockowner-file\
    \ pair.  The error NFS4ERR_BAD_STATEID should be\n      returned.\n      This\
    \ error condition will occur when there has been a logic error\n      on the part\
    \ of the client or server.  This should not happen.\n   One mechanism that may\
    \ be used to satisfy these requirements is for\n   the server to divide stateids\
    \ into three fields:\n   o  A server verifier which uniquely designates a particular\
    \ server\n      instantiation.\n   o  An index into a table of locking-state structures.\n\
    \   o  A sequence value which is incremented for each stateid that is\n      associated\
    \ with the same index into the locking-state table.\n   By matching the incoming\
    \ stateid and its field values with the state\n   held at the server, the server\
    \ is able to easily determine if a\n   stateid is valid for its current instantiation\
    \ and state.  If the\n   stateid is not valid, the appropriate error can be supplied\
    \ to the\n   client.\n"
- title: 8.1.4.  Use of the stateid
  contents:
  - "8.1.4.  Use of the stateid\n   All READ and WRITE operations contain a stateid.\
    \  If the\n   nfs_lockowner performs a READ or WRITE on a range of bytes within\
    \ a\n   locked range, the stateid (previously returned by the server) must be\n\
    \   used to indicate that the appropriate lock (record or share) is held.\n  \
    \ If no state is established by the client, either record lock or share\n   lock,\
    \ a stateid of all bits 0 is used.  If no conflicting locks are\n   held on the\
    \ file, the server may service the READ or WRITE operation.\n   If a conflict\
    \ with an explicit lock occurs, an error is returned for\n   the operation (NFS4ERR_LOCKED).\
    \ This allows \"mandatory locking\" to be\n   implemented.\n   A stateid of all\
    \ bits 1 (one) allows READ operations to bypass record\n   locking checks at the\
    \ server.  However, WRITE operations with stateid\n   with bits all 1 (one) do\
    \ not bypass record locking checks.  File\n   locking checks are handled by the\
    \ OPEN operation (see the section\n   \"OPEN/CLOSE Operations\").\n   An explicit\
    \ lock may not be granted while a READ or WRITE operation\n   with conflicting\
    \ implicit locking is being performed.\n"
- title: 8.1.5.  Sequencing of Lock Requests
  contents:
  - "8.1.5.  Sequencing of Lock Requests\n   Locking is different than most NFS operations\
    \ as it requires \"at-\n   most-one\" semantics that are not provided by ONCRPC.\
    \  ONCRPC over a\n   reliable transport is not sufficient because a sequence of\
    \ locking\n   requests may span multiple TCP connections.  In the face of\n  \
    \ retransmission or reordering, lock or unlock requests must have a\n   well defined\
    \ and consistent behavior.  To accomplish this, each lock\n   request contains\
    \ a sequence number that is a consecutively increasing\n   integer.  Different\
    \ nfs_lockowners have different sequences.  The\n   server maintains the last\
    \ sequence number (L) received and the\n   response that was returned.\n   Note\
    \ that for requests that contain a sequence number, for each\n   nfs_lockowner,\
    \ there should be no more than one outstanding request.\n   If a request with\
    \ a previous sequence number (r < L) is received, it\n   is rejected with the\
    \ return of error NFS4ERR_BAD_SEQID.  Given a\n   properly-functioning client,\
    \ the response to (r) must have been\n   received before the last request (L)\
    \ was sent.  If a duplicate of\n   last request (r == L) is received, the stored\
    \ response is returned.\n   If a request beyond the next sequence (r == L + 2)\
    \ is received, it is\n   rejected with the return of error NFS4ERR_BAD_SEQID.\
    \  Sequence\n   history is reinitialized whenever the client verifier changes.\n\
    \   Since the sequence number is represented with an unsigned 32-bit\n   integer,\
    \ the arithmetic involved with the sequence number is mod\n   2^32.\n   It is\
    \ critical the server maintain the last response sent to the\n   client to provide\
    \ a more reliable cache of duplicate non-idempotent\n   requests than that of\
    \ the traditional cache described in [Juszczak].\n   The traditional duplicate\
    \ request cache uses a least recently used\n   algorithm for removing unneeded\
    \ requests. However, the last lock\n   request and response on a given nfs_lockowner\
    \ must be cached as long\n   as the lock state exists on the server.\n"
- title: 8.1.6.  Recovery from Replayed Requests
  contents:
  - "8.1.6.  Recovery from Replayed Requests\n   As described above, the sequence\
    \ number is per nfs_lockowner.  As\n   long as the server maintains the last sequence\
    \ number received and\n   follows the methods described above, there are no risks\
    \ of a\n   Byzantine router re-sending old requests.  The server need only\n \
    \  maintain the nfs_lockowner, sequence number state as long as there\n   are\
    \ open files or closed files with locks outstanding.\n   LOCK, LOCKU, OPEN, OPEN_DOWNGRADE,\
    \ and CLOSE each contain a sequence\n   number and therefore the risk of the replay\
    \ of these operations\n   resulting in undesired effects is non-existent while\
    \ the server\n   maintains the nfs_lockowner state.\n"
- title: 8.1.7.  Releasing nfs_lockowner State
  contents:
  - "8.1.7.  Releasing nfs_lockowner State\n   When a particular nfs_lockowner no\
    \ longer holds open or file locking\n   state at the server, the server may choose\
    \ to release the sequence\n   number state associated with the nfs_lockowner.\
    \  The server may make\n   this choice based on lease expiration, for the reclamation\
    \ of server\n   memory, or other implementation specific details.  In any event,\
    \ the\n   server is able to do this safely only when the nfs_lockowner no\n  \
    \ longer is being utilized by the client.  The server may choose to\n   hold the\
    \ nfs_lockowner state in the event that retransmitted requests\n   are received.\
    \  However, the period to hold this state is\n   implementation specific.\n  \
    \ In the case that a LOCK, LOCKU, OPEN_DOWNGRADE, or CLOSE is\n   retransmitted\
    \ after the server has previously released the\n   nfs_lockowner state, the server\
    \ will find that the nfs_lockowner has\n   no files open and an error will be\
    \ returned to the client.  If the\n   nfs_lockowner does have a file open, the\
    \ stateid will not match and\n   again an error is returned to the client.\n \
    \  In the case that an OPEN is retransmitted and the nfs_lockowner is\n   being\
    \ used for the first time or the nfs_lockowner state has been\n   previously released\
    \ by the server, the use of the OPEN_CONFIRM\n   operation will prevent incorrect\
    \ behavior.  When the server observes\n   the use of the nfs_lockowner for the\
    \ first time, it will direct the\n   client to perform the OPEN_CONFIRM for the\
    \ corresponding OPEN.  This\n   sequence establishes the use of an nfs_lockowner\
    \ and associated\n   sequence number.  See the section \"OPEN_CONFIRM - Confirm\
    \ Open\" for\n   further details.\n"
- title: 8.2.  Lock Ranges
  contents:
  - "8.2.  Lock Ranges\n   The protocol allows a lock owner to request a lock with\
    \ one byte\n   range and then either upgrade or unlock a sub-range of the initial\n\
    \   lock.  It is expected that this will be an uncommon type of request.\n   In\
    \ any case, servers or server file systems may not be able to\n   support sub-range\
    \ lock semantics.  In the event that a server\n   receives a locking request that\
    \ represents a sub-range of current\n   locking state for the lock owner, the\
    \ server is allowed to return the\n   error NFS4ERR_LOCK_RANGE to signify that\
    \ it does not support sub-\n   range lock operations.  Therefore, the client should\
    \ be prepared to\n   receive this error and, if appropriate, report the error\
    \ to the\n   requesting application.\n   The client is discouraged from combining\
    \ multiple independent locking\n   ranges that happen to be adjacent into a single\
    \ request since the\n   server may not support sub-range requests and for reasons\
    \ related to\n   the recovery of file locking state in the event of server failure.\n\
    \   As discussed in the section \"Server Failure and Recovery\" below, the\n \
    \  server may employ certain optimizations during recovery that work\n   effectively\
    \ only when the client's behavior during lock recovery is\n   similar to the client's\
    \ locking behavior prior to server failure.\n"
- title: 8.3.  Blocking Locks
  contents:
  - "8.3.  Blocking Locks\n   Some clients require the support of blocking locks.\
    \  The NFS version\n   4 protocol must not rely on a callback mechanism and therefore\
    \ is\n   unable to notify a client when a previously denied lock has been\n  \
    \ granted.  Clients have no choice but to continually poll for the\n   lock. \
    \ This presents a fairness problem.  Two new lock types are\n   added, READW and\
    \ WRITEW, and are used to indicate to the server that\n   the client is requesting\
    \ a blocking lock.  The server should maintain\n   an ordered list of pending\
    \ blocking locks.  When the conflicting lock\n   is released, the server may wait\
    \ the lease period for the first\n   waiting client to re-request the lock.  After\
    \ the lease period\n   expires the next waiting client request is allowed the\
    \ lock.  Clients\n   are required to poll at an interval sufficiently small that\
    \ it is\n   likely to acquire the lock in a timely manner.  The server is not\n\
    \   required to maintain a list of pending blocked locks as it is used to\n  \
    \ increase fairness and not correct operation.  Because of the\n   unordered nature\
    \ of crash recovery, storing of lock state to stable\n   storage would be required\
    \ to guarantee ordered granting of blocking\n   locks.\n   Servers may also note\
    \ the lock types and delay returning denial of\n   the request to allow extra\
    \ time for a conflicting lock to be\n   released, allowing a successful return.\
    \  In this way, clients can\n   avoid the burden of needlessly frequent polling\
    \ for blocking locks.\n   The server should take care in the length of delay in\
    \ the event the\n   client retransmits the request.\n"
- title: 8.4.  Lease Renewal
  contents:
  - "8.4.  Lease Renewal\n   The purpose of a lease is to allow a server to remove\
    \ stale locks\n   that are held by a client that has crashed or is otherwise\n\
    \   unreachable.  It is not a mechanism for cache consistency and lease\n   renewals\
    \ may not be denied if the lease interval has not expired.\n   The following events\
    \ cause implicit renewal of all of the leases for\n   a given client (i.e. all\
    \ those sharing a given clientid).  Each of\n   these is a positive indication\
    \ that the client is still active and\n   that the associated state held at the\
    \ server, for the client, is\n   still valid.\n   o  An OPEN with a valid clientid.\n\
    \   o  Any operation made with a valid stateid (CLOSE, DELEGRETURN, LOCK,\n  \
    \    LOCKU, OPEN, OPEN_CONFIRM, READ, RENEW, SETATTR, WRITE).  This\n      does\
    \ not include the special stateids of all bits 0 or all bits 1.\n         Note\
    \ that if the client had restarted or rebooted, the client\n         would not\
    \ be making these requests without issuing the\n         SETCLIENTID operation.\
    \  The use of the SETCLIENTID operation\n         (possibly with the addition\
    \ of the optional SETCLIENTID_CONFIRM\n         operation) notifies the server\
    \ to drop the locking state\n         associated with the client.\n         If\
    \ the server has rebooted, the stateids (NFS4ERR_STALE_STATEID\n         error)\
    \ or the clientid (NFS4ERR_STALE_CLIENTID error) will not\n         be valid hence\
    \ preventing spurious renewals.\n   This approach allows for low overhead lease\
    \ renewal which scales\n   well.  In the typical case no extra RPC calls are required\
    \ for lease\n   renewal and in the worst case one RPC is required every lease\
    \ period\n   (i.e. a RENEW operation).  The number of locks held by the client\
    \ is\n   not a factor since all state for the client is involved with the\n  \
    \ lease renewal action.\n   Since all operations that create a new lease also\
    \ renew existing\n   leases, the server must maintain a common lease expiration\
    \ time for\n   all valid leases for a given client.  This lease time can then\
    \ be\n   easily updated upon implicit lease renewal actions.\n"
- title: 8.5.  Crash Recovery
  contents:
  - "8.5.  Crash Recovery\n   The important requirement in crash recovery is that\
    \ both the client\n   and the server know when the other has failed.  Additionally,\
    \ it is\n   required that a client sees a consistent view of data across server\n\
    \   restarts or reboots.  All READ and WRITE operations that may have\n   been\
    \ queued within the client or network buffers must wait until the\n   client has\
    \ successfully recovered the locks protecting the READ and\n   WRITE operations.\n"
- title: 8.5.1.  Client Failure and Recovery
  contents:
  - "8.5.1.  Client Failure and Recovery\n   In the event that a client fails, the\
    \ server may recover the client's\n   locks when the associated leases have expired.\
    \  Conflicting locks\n   from another client may only be granted after this lease\
    \ expiration.\n   If the client is able to restart or reinitialize within the\
    \ lease\n   period the client may be forced to wait the remainder of the lease\n\
    \   period before obtaining new locks.\n   To minimize client delay upon restart,\
    \ lock requests are associated\n   with an instance of the client by a client\
    \ supplied verifier.  This\n   verifier is part of the initial SETCLIENTID call\
    \ made by the client.\n   The server returns a clientid as a result of the SETCLIENTID\n\
    \   operation.  The client then confirms the use of the verifier with\n   SETCLIENTID_CONFIRM.\
    \  The clientid in combination with an opaque\n   owner field is then used by\
    \ the client to identify the lock owner for\n   OPEN.  This chain of associations\
    \ is then used to identify all locks\n   for a particular client.\n   Since the\
    \ verifier will be changed by the client upon each\n   initialization, the server\
    \ can compare a new verifier to the verifier\n   associated with currently held\
    \ locks and determine that they do not\n   match.  This signifies the client's\
    \ new instantiation and subsequent\n   loss of locking state.  As a result, the\
    \ server is free to release\n   all locks held which are associated with the old\
    \ clientid which was\n   derived from the old verifier.\n   For secure environments,\
    \ a change in the verifier must only cause the\n   release of locks associated\
    \ with the authenticated requester.  This\n   is required to prevent a rogue entity\
    \ from freeing otherwise valid\n   locks.\n   Note that the verifier must have\
    \ the same uniqueness properties of\n   the verifier for the COMMIT operation.\n"
- title: 8.5.2.  Server Failure and Recovery
  contents:
  - "8.5.2.  Server Failure and Recovery\n   If the server loses locking state (usually\
    \ as a result of a restart\n   or reboot), it must allow clients time to discover\
    \ this fact and re-\n   establish the lost locking state.  The client must be\
    \ able to re-\n   establish the locking state without having the server deny valid\n\
    \   requests because the server has granted conflicting access to another\n  \
    \ client.  Likewise, if there is the possibility that clients have not\n   yet\
    \ re-established their locking state for a file, the server must\n   disallow\
    \ READ and WRITE operations for that file.  The duration of\n   this recovery\
    \ period is equal to the duration of the lease period.\n   A client can determine\
    \ that server failure (and thus loss of locking\n   state) has occurred, when\
    \ it receives one of two errors.  The\n   NFS4ERR_STALE_STATEID error indicates\
    \ a stateid invalidated by a\n   reboot or restart.  The NFS4ERR_STALE_CLIENTID\
    \ error indicates a\n   clientid invalidated by reboot or restart.  When either\
    \ of these are\n   received, the client must establish a new clientid (See the\
    \ section\n   \"Client ID\") and re-establish the locking state as discussed below.\n\
    \   The period of special handling of locking and READs and WRITEs, equal\n  \
    \ in duration to the lease period, is referred to as the \"grace\n   period\"\
    .  During the grace period, clients recover locks and the\n   associated state\
    \ by reclaim-type locking requests (i.e. LOCK requests\n   with reclaim set to\
    \ true and OPEN operations with a claim type of\n   CLAIM_PREVIOUS).  During the\
    \ grace period, the server must reject\n   READ and WRITE operations and non-reclaim\
    \ locking requests (i.e.\n   other LOCK and OPEN operations) with an error of\
    \ NFS4ERR_GRACE.\n   If the server can reliably determine that granting a non-reclaim\n\
    \   request will not conflict with reclamation of locks by other clients,\n  \
    \ the NFS4ERR_GRACE error does not have to be returned and the non-\n   reclaim\
    \ client request can be serviced.  For the server to be able to\n   service READ\
    \ and WRITE operations during the grace period, it must\n   again be able to guarantee\
    \ that no possible conflict could arise\n   between an impending reclaim locking\
    \ request and the READ or WRITE\n   operation.  If the server is unable to offer\
    \ that guarantee, the\n   NFS4ERR_GRACE error must be returned to the client.\n\
    \   For a server to provide simple, valid handling during the grace\n   period,\
    \ the easiest method is to simply reject all non-reclaim\n   locking requests\
    \ and READ and WRITE operations by returning the\n   NFS4ERR_GRACE error.  However,\
    \ a server may keep information about\n   granted locks in stable storage.  With\
    \ this information, the server\n   could determine if a regular lock or READ or\
    \ WRITE operation can be\n   safely processed.\n   For example, if a count of\
    \ locks on a given file is available in\n   stable storage, the server can track\
    \ reclaimed locks for the file and\n   when all reclaims have been processed,\
    \ non-reclaim locking requests\n   may be processed.  This way the server can\
    \ ensure that non-reclaim\n   locking requests will not conflict with potential\
    \ reclaim requests.\n   With respect to I/O requests, if the server is able to\
    \ determine that\n   there are no outstanding reclaim requests for a file by information\n\
    \   from stable storage or another similar mechanism, the processing of\n   I/O\
    \ requests could proceed normally for the file.\n   To reiterate, for a server\
    \ that allows non-reclaim lock and I/O\n   requests to be processed during the\
    \ grace period, it MUST determine\n   that no lock subsequently reclaimed will\
    \ be rejected and that no lock\n   subsequently reclaimed would have prevented\
    \ any I/O operation\n   processed during the grace period.\n   Clients should\
    \ be prepared for the return of NFS4ERR_GRACE errors for\n   non-reclaim lock\
    \ and I/O requests.  In this case the client should\n   employ a retry mechanism\
    \ for the request.  A delay (on the order of\n   several seconds) between retries\
    \ should be used to avoid overwhelming\n   the server.  Further discussion of\
    \ the general is included in\n   [Floyd].  The client must account for the server\
    \ that is able to\n   perform I/O and non-reclaim locking requests within the\
    \ grace period\n   as well as those that can not do so.\n   A reclaim-type locking\
    \ request outside the server's grace period can\n   only succeed if the server\
    \ can guarantee that no conflicting lock or\n   I/O request has been granted since\
    \ reboot or restart.\n"
- title: 8.5.3.  Network Partitions and Recovery
  contents:
  - "8.5.3.  Network Partitions and Recovery\n   If the duration of a network partition\
    \ is greater than the lease\n   period provided by the server, the server will\
    \ have not received a\n   lease renewal from the client.  If this occurs, the\
    \ server may free\n   all locks held for the client.  As a result, all stateids\
    \ held by the\n   client will become invalid or stale.  Once the client is able\
    \ to\n   reach the server after such a network partition, all I/O submitted by\n\
    \   the client with the now invalid stateids will fail with the server\n   returning\
    \ the error NFS4ERR_EXPIRED.  Once this error is received,\n   the client will\
    \ suitably notify the application that held the lock.\n   As a courtesy to the\
    \ client or as an optimization, the server may\n   continue to hold locks on behalf\
    \ of a client for which recent\n   communication has extended beyond the lease\
    \ period.  If the server\n   receives a lock or I/O request that conflicts with\
    \ one of these\n   courtesy locks, the server must free the courtesy lock and\
    \ grant the\n   new request.\n   If the server continues to hold locks beyond\
    \ the expiration of a\n   client's lease, the server MUST employ a method of recording\
    \ this\n   fact in its stable storage.  Conflicting locks requests from another\n\
    \   client may be serviced after the lease expiration.  There are various\n  \
    \ scenarios involving server failure after such an event that require\n   the\
    \ storage of these lease expirations or network partitions.  One\n   scenario\
    \ is as follows:\n         A client holds a lock at the server and encounters\
    \ a network\n         partition and is unable to renew the associated lease. \
    \ A\n         second client obtains a conflicting lock and then frees the\n  \
    \       lock.  After the unlock request by the second client, the\n         server\
    \ reboots or reinitializes.  Once the server recovers, the\n         network partition\
    \ heals and the original client attempts to\n         reclaim the original lock.\n\
    \   In this scenario and without any state information, the server will\n   allow\
    \ the reclaim and the client will be in an inconsistent state\n   because the\
    \ server or the client has no knowledge of the conflicting\n   lock.\n   The server\
    \ may choose to store this lease expiration or network\n   partitioning state\
    \ in a way that will only identify the client as a\n   whole.  Note that this\
    \ may potentially lead to lock reclaims being\n   denied unnecessarily because\
    \ of a mix of conflicting and non-\n   conflicting locks.  The server may also\
    \ choose to store information\n   about each lock that has an expired lease with\
    \ an associated\n   conflicting lock.  The choice of the amount and type of state\n\
    \   information that is stored is left to the implementor.  In any case,\n   the\
    \ server must have enough state information to enable correct\n   recovery from\
    \ multiple partitions and multiple server failures.\n"
- title: 8.6.  Recovery from a Lock Request Timeout or Abort
  contents:
  - "8.6.  Recovery from a Lock Request Timeout or Abort\n   In the event a lock request\
    \ times out, a client may decide to not\n   retry the request.  The client may\
    \ also abort the request when the\n   process for which it was issued is terminated\
    \ (e.g. in UNIX due to a\n   signal.  It is possible though that the server received\
    \ the request\n   and acted upon it.  This would change the state on the server\
    \ without\n   the client being aware of the change.  It is paramount that the\n\
    \   client re-synchronize state with server before it attempts any other\n   operation\
    \ that takes a seqid and/or a stateid with the same\n   nfs_lockowner. This is\
    \ straightforward to do without a special re-\n   synchronize operation.\n   Since\
    \ the server maintains the last lock request and response\n   received on the\
    \ nfs_lockowner, for each nfs_lockowner, the client\n   should cache the last\
    \ lock request it sent such that the lock request\n   did not receive a response.\
    \  From this, the next time the client does\n   a lock operation for the nfs_lockowner,\
    \ it can send the cached\n   request, if there is one, and if the request was\
    \ one that established\n   state (e.g. a LOCK or OPEN operation) the client can\
    \ follow up with a\n   request to remove the state (e.g. a LOCKU or CLOSE operation).\
    \  With\n   this approach, the sequencing and stateid information on the client\n\
    \   and server for the given nfs_lockowner will re-synchronize and in\n   turn\
    \ the lock state will re-synchronize.\n"
- title: 8.7.  Server Revocation of Locks
  contents:
  - "8.7.  Server Revocation of Locks\n   At any point, the server can revoke locks\
    \ held by a client and the\n   client must be prepared for this event.  When the\
    \ client detects that\n   its locks have been or may have been revoked, the client\
    \ is\n   responsible for validating the state information between itself and\n\
    \   the server.  Validating locking state for the client means that it\n   must\
    \ verify or reclaim state for each lock currently held.\n   The first instance\
    \ of lock revocation is upon server reboot or re-\n   initialization.  In this\
    \ instance the client will receive an error\n   (NFS4ERR_STALE_STATEID or NFS4ERR_STALE_CLIENTID)\
    \ and the client will\n   proceed with normal crash recovery as described in the\
    \ previous\n   section.\n   The second lock revocation event is the inability\
    \ to renew the lease\n   period.  While this is considered a rare or unusual event,\
    \ the client\n   must be prepared to recover.  Both the server and client will\
    \ be able\n   to detect the failure to renew the lease and are capable of\n  \
    \ recovering without data corruption.  For the server, it tracks the\n   last\
    \ renewal event serviced for the client and knows when the lease\n   will expire.\
    \  Similarly, the client must track operations which will\n   renew the lease\
    \ period.  Using the time that each such request was\n   sent and the time that\
    \ the corresponding reply was received, the\n   client should bound the time that\
    \ the corresponding renewal could\n   have occurred on the server and thus determine\
    \ if it is possible that\n   a lease period expiration could have occurred.\n\
    \   The third lock revocation event can occur as a result of\n   administrative\
    \ intervention within the lease period.  While this is\n   considered a rare event,\
    \ it is possible that the server's\n   administrator has decided to release or\
    \ revoke a particular lock held\n   by the client.  As a result of revocation,\
    \ the client will receive an\n   error of NFS4ERR_EXPIRED and the error is received\
    \ within the lease\n   period for the lock.  In this instance the client may assume\
    \ that\n   only the nfs_lockowner's locks have been lost.  The client notifies\n\
    \   the lock holder appropriately.  The client may not assume the lease\n   period\
    \ has been renewed as a result of failed operation.\n   When the client determines\
    \ the lease period may have expired, the\n   client must mark all locks held for\
    \ the associated lease as\n   \"unvalidated\".  This means the client has been\
    \ unable to re-establish\n   or confirm the appropriate lock state with the server.\
    \  As described\n   in the previous section on crash recovery, there are scenarios\
    \ in\n   which the server may grant conflicting locks after the lease period\n\
    \   has expired for a client.  When it is possible that the lease period\n   has\
    \ expired, the client must validate each lock currently held to\n   ensure that\
    \ a conflicting lock has not been granted. The client may\n   accomplish this\
    \ task by issuing an I/O request, either a pending I/O\n   or a zero-length read,\
    \ specifying the stateid associated with the\n   lock in question. If the response\
    \ to the request is success, the\n   client has validated all of the locks governed\
    \ by that stateid and\n   re-established the appropriate state between itself\
    \ and the server.\n   If the I/O request is not successful, then one or more of\
    \ the locks\n   associated with the stateid was revoked by the server and the\
    \ client\n   must notify the owner.\n"
- title: 8.8.  Share Reservations
  contents:
  - "8.8.  Share Reservations\n   A share reservation is a mechanism to control access\
    \ to a file.  It\n   is a separate and independent mechanism from record locking.\
    \  When a\n   client opens a file, it issues an OPEN operation to the server\n\
    \   specifying the type of access required (READ, WRITE, or BOTH) and the\n  \
    \ type of access to deny others (deny NONE, READ, WRITE, or BOTH).  If\n   the\
    \ OPEN fails the client will fail the application's open request.\n   Pseudo-code\
    \ definition of the semantics:\n               if ((request.access & file_state.deny))\
    \ ||\n                     (request.deny & file_state.access))\n             \
    \                return (NFS4ERR_DENIED)\n   The constants used for the OPEN and\
    \ OPEN_DOWNGRADE operations for the\n   access and deny fields are as follows:\n\
    \   const OPEN4_SHARE_ACCESS_READ   = 0x00000001;\n   const OPEN4_SHARE_ACCESS_WRITE\
    \  = 0x00000002;\n   const OPEN4_SHARE_ACCESS_BOTH   = 0x00000003;\n   const OPEN4_SHARE_DENY_NONE\
    \     = 0x00000000;\n   const OPEN4_SHARE_DENY_READ     = 0x00000001;\n   const\
    \ OPEN4_SHARE_DENY_WRITE    = 0x00000002;\n   const OPEN4_SHARE_DENY_BOTH    \
    \ = 0x00000003;\n"
- title: 8.9.  OPEN/CLOSE Operations
  contents:
  - "8.9.  OPEN/CLOSE Operations\n   To provide correct share semantics, a client\
    \ MUST use the OPEN\n   operation to obtain the initial filehandle and indicate\
    \ the desired\n   access and what if any access to deny.  Even if the client intends\
    \ to\n   use a stateid of all 0's or all 1's, it must still obtain the\n   filehandle\
    \ for the regular file with the OPEN operation so the\n   appropriate share semantics\
    \ can be applied.  For clients that do not\n   have a deny mode built into their\
    \ open programming interfaces, deny\n   equal to NONE should be used.\n   The\
    \ OPEN operation with the CREATE flag, also subsumes the CREATE\n   operation\
    \ for regular files as used in previous versions of the NFS\n   protocol.  This\
    \ allows a create with a share to be done atomically.\n   The CLOSE operation\
    \ removes all share locks held by the nfs_lockowner\n   on that file.  If record\
    \ locks are held, the client SHOULD release\n   all locks before issuing a CLOSE.\
    \  The server MAY free all\n   outstanding locks on CLOSE but some servers may\
    \ not support the CLOSE\n   of a file that still has record locks held.  The server\
    \ MUST return\n   failure if any locks would exist after the CLOSE.\n   The LOOKUP\
    \ operation will return a filehandle without establishing\n   any lock state on\
    \ the server.  Without a valid stateid, the server\n   will assume the client\
    \ has the least access.  For example, a file\n   opened with deny READ/WRITE cannot\
    \ be accessed using a filehandle\n   obtained through LOOKUP because it would\
    \ not have a valid stateid\n   (i.e. using a stateid of all bits 0 or all bits\
    \ 1).\n"
- title: 8.10.  Open Upgrade and Downgrade
  contents:
  - "8.10.  Open Upgrade and Downgrade\n   When an OPEN is done for a file and the\
    \ lockowner for which the open\n   is being done already has the file open, the\
    \ result is to upgrade the\n   open file status maintained on the server to include\
    \ the access and\n   deny bits specified by the new OPEN as well as those for\
    \ the existing\n   OPEN.  The result is that there is one open file, as far as\
    \ the\n   protocol is concerned, and it includes the union of the access and\n\
    \   deny bits for all of the OPEN requests completed.  Only a single\n   CLOSE\
    \ will be done to reset the effects of both OPEN's.  Note that\n   the client,\
    \ when issuing the OPEN, may not know that the same file is\n   in fact being\
    \ opened.  The above only applies if both OPEN's result\n   in the OPEN'ed object\
    \ being designated by the same filehandle.\n   When the server chooses to export\
    \ multiple filehandles corresponding\n   to the same file object and returns different\
    \ filehandles on two\n   different OPEN's of the same file object, the server\
    \ MUST NOT \"OR\"\n   together the access and deny bits and coalesce the two open\
    \ files.\n   Instead the server must maintain separate OPEN's with separate\n\
    \   stateid's and will require separate CLOSE's to free them.\n   When multiple\
    \ open files on the client are merged into a single open\n   file object on the\
    \ server, the close of one of the open files (on the\n   client) may necessitate\
    \ change of the access and deny status of the\n   open file on the server.  This\
    \ is because the union of the access and\n   deny bits for the remaining open's\
    \ may be smaller (i.e. a proper\n   subset) than previously.  The OPEN_DOWNGRADE\
    \ operation is used to\n   make the necessary change and the client should use\
    \ it to update the\n   server so that share reservation requests by other clients\
    \ are\n   handled properly.\n"
- title: 8.11.  Short and Long Leases
  contents:
  - "8.11.  Short and Long Leases\n   When determining the time period for the server\
    \ lease, the usual\n   lease tradeoffs apply.  Short leases are good for fast\
    \ server\n   recovery at a cost of increased RENEW or READ (with zero length)\n\
    \   requests.  Longer leases are certainly kinder and gentler to large\n   internet\
    \ servers trying to handle very large numbers of clients.  The\n   number of RENEW\
    \ requests drop in proportion to the lease time.  The\n   disadvantages of long\
    \ leases are slower recovery after server failure\n   (server must wait for leases\
    \ to expire and grace period before\n   granting new lock requests) and increased\
    \ file contention (if client\n   fails to transmit an unlock request then server\
    \ must wait for lease\n   expiration before granting new locks).\n   Long leases\
    \ are usable if the server is able to store lease state in\n   non-volatile memory.\
    \  Upon recovery, the server can reconstruct the\n   lease state from its non-volatile\
    \ memory and continue operation with\n   its clients and therefore long leases\
    \ are not an issue.\n"
- title: 8.12.  Clocks and Calculating Lease Expiration
  contents:
  - "8.12.  Clocks and Calculating Lease Expiration\n   To avoid the need for synchronized\
    \ clocks, lease times are granted by\n   the server as a time delta.  However,\
    \ there is a requirement that the\n   client and server clocks do not drift excessively\
    \ over the duration\n   of the lock.  There is also the issue of propagation delay\
    \ across the\n   network which could easily be several hundred milliseconds as\
    \ well as\n   the possibility that requests will be lost and need to be\n   retransmitted.\n\
    \   To take propagation delay into account, the client should subtract it\n  \
    \ from lease times (e.g. if the client estimates the one-way\n   propagation delay\
    \ as 200 msec, then it can assume that the lease is\n   already 200 msec old when\
    \ it gets it).  In addition, it will take\n   another 200 msec to get a response\
    \ back to the server.  So the client\n   must send a lock renewal or write data\
    \ back to the server 400 msec\n   before the lease would expire.\n"
- title: 8.13.  Migration, Replication and State
  contents:
  - "8.13.  Migration, Replication and State\n   When responsibility for handling\
    \ a given file system is transferred\n   to a new server (migration) or the client\
    \ chooses to use an alternate\n   server (e.g. in response to server unresponsiveness)\
    \ in the context\n   of file system replication, the appropriate handling of state\
    \ shared\n   between the client and server (i.e. locks, leases, stateid's, and\n\
    \   clientid's) is as described below.  The handling differs between\n   migration\
    \ and replication.  For related discussion of file server\n   state and recover\
    \ of such see the sections under \"File Locking and\n   Share Reservations\"\n"
- title: 8.13.1.  Migration and State
  contents:
  - "8.13.1.  Migration and State\n   In the case of migration, the servers involved\
    \ in the migration of a\n   file system SHOULD transfer all server state from\
    \ the original to the\n   new server.  This must be done in a way that is transparent\
    \ to the\n   client.  This state transfer will ease the client's transition when\
    \ a\n   file system migration occurs.  If the servers are successful in\n   transferring\
    \ all state, the client will continue to use stateid's\n   assigned by the original\
    \ server.  Therefore the new server must\n   recognize these stateid's as valid.\
    \  This holds true for the clientid\n   as well.  Since responsibility for an\
    \ entire file system is\n   transferred with a migration event, there is no possibility\
    \ that\n   conflicts will arise on the new server as a result of the transfer\
    \ of\n   locks.\n   As part of the transfer of information between servers, leases\
    \ would\n   be transferred as well.  The leases being transferred to the new\n\
    \   server will typically have a different expiration time from those for\n  \
    \ the same client, previously on the new server.  To maintain the\n   property\
    \ that all leases on a given server for a given client expire\n   at the same\
    \ time, the server should advance the expiration time to\n   the later of the\
    \ leases being transferred or the leases already\n   present.  This allows the\
    \ client to maintain lease renewal of both\n   classes without special effort.\n\
    \   The servers may choose not to transfer the state information upon\n   migration.\
    \  However, this choice is discouraged.  In this case, when\n   the client presents\
    \ state information from the original server, the\n   client must be prepared\
    \ to receive either NFS4ERR_STALE_CLIENTID or\n   NFS4ERR_STALE_STATEID from the\
    \ new server.  The client should then\n   recover its state information as it\
    \ normally would in response to a\n   server failure.  The new server must take\
    \ care to allow for the\n   recovery of state information as it would in the event\
    \ of server\n   restart.\n"
- title: 8.13.2.  Replication and State
  contents:
  - "8.13.2.  Replication and State\n   Since client switch-over in the case of replication\
    \ is not under\n   server control, the handling of state is different.  In this\
    \ case,\n   leases, stateid's and clientid's do not have validity across a\n \
    \  transition from one server to another.  The client must re-establish\n   its\
    \ locks on the new server.  This can be compared to the re-\n   establishment\
    \ of locks by means of reclaim-type requests after a\n   server reboot.  The difference\
    \ is that the server has no provision to\n   distinguish requests reclaiming locks\
    \ from those obtaining new locks\n   or to defer the latter.  Thus, a client re-establishing\
    \ a lock on the\n   new server (by means of a LOCK or OPEN request), may have\
    \ the\n   requests denied due to a conflicting lock.  Since replication is\n \
    \  intended for read-only use of filesystems, such denial of locks\n   should\
    \ not pose large difficulties in practice.  When an attempt to\n   re-establish\
    \ a lock on a new server is denied, the client should\n   treat the situation\
    \ as if his original lock had been revoked.\n"
- title: 8.13.3.  Notification of Migrated Lease
  contents:
  - "8.13.3.  Notification of Migrated Lease\n   In the case of lease renewal, the\
    \ client may not be submitting\n   requests for a file system that has been migrated\
    \ to another server.\n   This can occur because of the implicit lease renewal\
    \ mechanism.  The\n   client renews leases for all file systems when submitting\
    \ a request\n   to any one file system at the server.\n   In order for the client\
    \ to schedule renewal of leases that may have\n   been relocated to the new server,\
    \ the client must find out about\n   lease relocation before those leases expire.\
    \  To accomplish this, all\n   operations which implicitly renew leases for a\
    \ client (i.e. OPEN,\n   CLOSE, READ, WRITE, RENEW, LOCK, LOCKT, LOCKU), will\
    \ return the error\n   NFS4ERR_LEASE_MOVED if responsibility for any of the leases\
    \ to be\n   renewed has been transferred to a new server.  This condition will\n\
    \   continue until the client receives an NFS4ERR_MOVED error and the\n   server\
    \ receives the subsequent GETATTR(fs_locations) for an access to\n   each file\
    \ system for which a lease has been moved to a new server.\n   When a client receives\
    \ an NFS4ERR_LEASE_MOVED error, it should\n   perform some operation, such as\
    \ a RENEW, on each file system\n   associated with the server in question.  When\
    \ the client receives an\n   NFS4ERR_MOVED error, the client can follow the normal\
    \ process to\n   obtain the new server information (through the fs_locations\n\
    \   attribute) and perform renewal of those leases on the new server.  If\n  \
    \ the server has not had state transferred to it transparently, it will\n   receive\
    \ either NFS4ERR_STALE_CLIENTID or NFS4ERR_STALE_STATEID from\n   the new server,\
    \ as described above, and can then recover state\n   information as it does in\
    \ the event of server failure.\n"
- title: 9.  Client-Side Caching
  contents:
  - "9.  Client-Side Caching\n   Client-side caching of data, of file attributes,\
    \ and of file names is\n   essential to providing good performance with the NFS\
    \ protocol.\n   Providing distributed cache coherence is a difficult problem and\n\
    \   previous versions of the NFS protocol have not attempted it.\n   Instead,\
    \ several NFS client implementation techniques have been used\n   to reduce the\
    \ problems that a lack of coherence poses for users.\n   These techniques have\
    \ not been clearly defined by earlier protocol\n   specifications and it is often\
    \ unclear what is valid or invalid\n   client behavior.\n   The NFS version 4\
    \ protocol uses many techniques similar to those that\n   have been used in previous\
    \ protocol versions.  The NFS version 4\n   protocol does not provide distributed\
    \ cache coherence.  However, it\n   defines a more limited set of caching guarantees\
    \ to allow locks and\n   share reservations to be used without destructive interference\
    \ from\n   client side caching.\n   In addition, the NFS version 4 protocol introduces\
    \ a delegation\n   mechanism which allows many decisions normally made by the\
    \ server to\n   be made locally by clients.  This mechanism provides efficient\n\
    \   support of the common cases where sharing is infrequent or where\n   sharing\
    \ is read-only.\n"
- title: 9.1.  Performance Challenges for Client-Side Caching
  contents:
  - "9.1.  Performance Challenges for Client-Side Caching\n   Caching techniques used\
    \ in previous versions of the NFS protocol have\n   been successful in providing\
    \ good performance.  However, several\n   scalability challenges can arise when\
    \ those techniques are used with\n   very large numbers of clients.  This is particularly\
    \ true when\n   clients are geographically distributed which classically increases\n\
    \   the latency for cache revalidation requests.\n   The previous versions of\
    \ the NFS protocol repeat their file data\n   cache validation requests at the\
    \ time the file is opened.  This\n   behavior can have serious performance drawbacks.\
    \  A common case is\n   one in which a file is only accessed by a single client.\
    \  Therefore,\n   sharing is infrequent.\n   In this case, repeated reference\
    \ to the server to find that no\n   conflicts exist is expensive.  A better option\
    \ with regards to\n   performance is to allow a client that repeatedly opens a\
    \ file to do\n   so without reference to the server.  This is done until potentially\n\
    \   conflicting operations from another client actually occur.\n   A similar situation\
    \ arises in connection with file locking.  Sending\n   file lock and unlock requests\
    \ to the server as well as the read and\n   write requests necessary to make data\
    \ caching consistent with the\n   locking semantics (see the section \"Data Caching\
    \ and File Locking\")\n   can severely limit performance.  When locking is used\
    \ to provide\n   protection against infrequent conflicts, a large penalty is incurred.\n\
    \   This penalty may discourage the use of file locking by applications.\n   The\
    \ NFS version 4 protocol provides more aggressive caching\n   strategies with\
    \ the following design goals:\n   o  Compatibility with a large range of server\
    \ semantics.\n   o  Provide the same caching benefits as previous versions of\
    \ the NFS\n      protocol when unable to provide the more aggressive model.\n\
    \   o  Requirements for aggressive caching are organized so that a large\n   \
    \   portion of the benefit can be obtained even when not all of the\n      requirements\
    \ can be met.\n   The appropriate requirements for the server are discussed in\
    \ later\n   sections in which specific forms of caching are covered. (see the\n\
    \   section \"Open Delegation\").\n"
- title: 9.2.  Delegation and Callbacks
  contents:
  - "9.2.  Delegation and Callbacks\n   Recallable delegation of server responsibilities\
    \ for a file to a\n   client improves performance by avoiding repeated requests\
    \ to the\n   server in the absence of inter-client conflict.  With the use of\
    \ a\n   \"callback\" RPC from server to client, a server recalls delegated\n \
    \  responsibilities when another client engages in sharing of a\n   delegated\
    \ file.\n   A delegation is passed from the server to the client, specifying the\n\
    \   object of the delegation and the type of delegation.  There are\n   different\
    \ types of delegations but each type contains a stateid to be\n   used to represent\
    \ the delegation when performing operations that\n   depend on the delegation.\
    \  This stateid is similar to those\n   associated with locks and share reservations\
    \ but differs in that the\n   stateid for a delegation is associated with a clientid\
    \ and may be\n   used on behalf of all the nfs_lockowners for the given client.\
    \  A\n   delegation is made to the client as a whole and not to any specific\n\
    \   process or thread of control within it.\n   Because callback RPCs may not\
    \ work in all environments (due to\n   firewalls, for example), correct protocol\
    \ operation does not depend\n   on them.  Preliminary testing of callback functionality\
    \ by means of a\n   CB_NULL procedure determines whether callbacks can be supported.\
    \  The\n   CB_NULL procedure checks the continuity of the callback path.  A\n\
    \   server makes a preliminary assessment of callback availability to a\n   given\
    \ client and avoids delegating responsibilities until it has\n   determined that\
    \ callbacks are supported.  Because the granting of a\n   delegation is always\
    \ conditional upon the absence of conflicting\n   access, clients must not assume\
    \ that a delegation will be granted and\n   they must always be prepared for OPENs\
    \ to be processed without any\n   delegations being granted.\n   Once granted,\
    \ a delegation behaves in most ways like a lock.  There\n   is an associated lease\
    \ that is subject to renewal together with all\n   of the other leases held by\
    \ that client.\n   Unlike locks, an operation by a second client to a delegated\
    \ file\n   will cause the server to recall a delegation through a callback.\n\
    \   On recall, the client holding the delegation must flush modified\n   state\
    \ (such as modified data) to the server and return the\n   delegation.  The conflicting\
    \ request will not receive a response\n   until the recall is complete.  The recall\
    \ is considered complete when\n   the client returns the delegation or the server\
    \ times out on the\n   recall and revokes the delegation as a result of the timeout.\n\
    \   Following the resolution of the recall, the server has the\n   information\
    \ necessary to grant or deny the second client's request.\n   At the time the\
    \ client receives a delegation recall, it may have\n   substantial state that\
    \ needs to be flushed to the server.  Therefore,\n   the server should allow sufficient\
    \ time for the delegation to be\n   returned since it may involve numerous RPCs\
    \ to the server.  If the\n   server is able to determine that the client is diligently\
    \ flushing\n   state to the server as a result of the recall, the server may extend\n\
    \   the usual time allowed for a recall.  However, the time allowed for\n   recall\
    \ completion should not be unbounded.\n   An example of this is when responsibility\
    \ to mediate opens on a given\n   file is delegated to a client (see the section\
    \ \"Open Delegation\").\n   The server will not know what opens are in effect\
    \ on the client.\n   Without this knowledge the server will be unable to determine\
    \ if the\n   access and deny state for the file allows any particular open until\n\
    \   the delegation for the file has been returned.\n   A client failure or a network\
    \ partition can result in failure to\n   respond to a recall callback. In this\
    \ case, the server will revoke\n   the delegation which in turn will render useless\
    \ any modified state\n   still on the client.\n"
- title: 9.2.1.  Delegation Recovery
  contents:
  - "9.2.1.  Delegation Recovery\n   There are three situations that delegation recovery\
    \ must deal with:\n   o  Client reboot or restart\n   o  Server reboot or restart\n\
    \   o  Network partition (full or callback-only)\n   In the event the client reboots\
    \ or restarts, the failure to renew\n   leases will result in the revocation of\
    \ record locks and share\n   reservations.  Delegations, however, may be treated\
    \ a bit\n   differently.\n   There will be situations in which delegations will\
    \ need to be\n   reestablished after a client reboots or restarts.  The reason\
    \ for\n   this is the client may have file data stored locally and this data\n\
    \   was associated with the previously held delegations.  The client will\n  \
    \ need to reestablish the appropriate file state on the server.\n   To allow for\
    \ this type of client recovery, the server may extend the\n   period for delegation\
    \ recovery beyond the typical lease expiration\n   period.  This implies that\
    \ requests from other clients that conflict\n   with these delegations will need\
    \ to wait.  Because the normal recall\n   process may require significant time\
    \ for the client to flush changed\n   state to the server, other clients need\
    \ be prepared for delays that\n   occur because of a conflicting delegation. \
    \ This longer interval\n   would increase the window for clients to reboot and\
    \ consult stable\n   storage so that the delegations can be reclaimed.  For open\n\
    \   delegations, such delegations are reclaimed using OPEN with a claim\n   type\
    \ of CLAIM_DELEGATE_PREV.  (see the sections on \"Data Caching and\n   Revocation\"\
    \ and \"Operation 18: OPEN\" for discussion of open\n   delegation and the details\
    \ of OPEN respectively).\n   When the server reboots or restarts, delegations\
    \ are reclaimed (using\n   the OPEN operation with CLAIM_DELEGATE_PREV) in a similar\
    \ fashion to\n   record locks and share reservations.  However, there is a slight\n\
    \   semantic difference.  In the normal case if the server decides that a\n  \
    \ delegation should not be granted, it performs the requested action\n   (e.g.\
    \ OPEN) without granting any delegation.  For reclaim, the server\n   grants the\
    \ delegation but a special designation is applied so that\n   the client treats\
    \ the delegation as having been granted but recalled\n   by the server.  Because\
    \ of this, the client has the duty to write all\n   modified state to the server\
    \ and then return the delegation.  This\n   process of handling delegation reclaim\
    \ reconciles three principles of\n   the NFS Version 4 protocol:\n   o  Upon reclaim,\
    \ a client reporting resources assigned to it by an\n      earlier server instance\
    \ must be granted those resources.\n   o  The server has unquestionable authority\
    \ to determine whether\n      delegations are to be granted and, once granted,\
    \ whether they are\n      to be continued.\n   o  The use of callbacks is not\
    \ to be depended upon until the client\n      has proven its ability to receive\
    \ them.\n   When a network partition occurs, delegations are subject to freeing\n\
    \   by the server when the lease renewal period expires.  This is similar\n  \
    \ to the behavior for locks and share reservations.  For delegations,\n   however,\
    \ the server may extend the period in which conflicting\n   requests are held\
    \ off.  Eventually the occurrence of a conflicting\n   request from another client\
    \ will cause revocation of the delegation.\n   A loss of the callback path (e.g.\
    \ by later network configuration\n   change) will have the same effect.  A recall\
    \ request will fail and\n   revocation of the delegation will result.\n   A client\
    \ normally finds out about revocation of a delegation when it\n   uses a stateid\
    \ associated with a delegation and receives the error\n   NFS4ERR_EXPIRED.  It\
    \ also may find out about delegation revocation\n   after a client reboot when\
    \ it attempts to reclaim a delegation and\n   receives that same error.  Note\
    \ that in the case of a revoked write\n   open delegation, there are issues because\
    \ data may have been modified\n   by the client whose delegation is revoked and\
    \ separately by other\n   clients.  See the section \"Revocation Recovery for\
    \ Write Open\n   Delegation\" for a discussion of such issues.  Note also that\
    \ when\n   delegations are revoked, information about the revoked delegation\n\
    \   will be written by the server to stable storage (as described in the\n   section\
    \ \"Crash Recovery\").  This is done to deal with the case in\n   which a server\
    \ reboots after revoking a delegation but before the\n   client holding the revoked\
    \ delegation is notified about the\n   revocation.\n"
- title: 9.3.  Data Caching
  contents:
  - "9.3.  Data Caching\n   When applications share access to a set of files, they\
    \ need to be\n   implemented so as to take account of the possibility of conflicting\n\
    \   access by another application.  This is true whether the applications\n  \
    \ in question execute on different clients or reside on the same\n   client.\n\
    \   Share reservations and record locks are the facilities the NFS\n   version\
    \ 4 protocol provides to allow applications to coordinate\n   access by providing\
    \ mutual exclusion facilities.  The NFS version 4\n   protocol's data caching\
    \ must be implemented such that it does not\n   invalidate the assumptions that\
    \ those using these facilities depend\n   upon.\n"
- title: 9.3.1.  Data Caching and OPENs
  contents:
  - "9.3.1.  Data Caching and OPENs\n   In order to avoid invalidating the sharing\
    \ assumptions that\n   applications rely on, NFS version 4 clients should not\
    \ provide cached\n   data to applications or modify it on behalf of an application\
    \ when it\n   would not be valid to obtain or modify that same data via a READ\
    \ or\n   WRITE operation.\n   Furthermore, in the absence of open delegation (see\
    \ the section \"Open\n   Delegation\") two additional rules apply.  Note that\
    \ these rules are\n   obeyed in practice by many NFS version 2 and version 3 clients.\n\
    \   o  First, cached data present on a client must be revalidated after\n    \
    \  doing an OPEN.  This is to ensure that the data for the OPENed\n      file\
    \ is still correctly reflected in the client's cache.  This\n      validation\
    \ must be done at least when the client's OPEN operation\n      includes DENY=WRITE\
    \ or BOTH thus terminating a period in which\n      other clients may have had\
    \ the opportunity to open the file with\n      WRITE access.  Clients may choose\
    \ to do the revalidation more\n      often (i.e. at OPENs specifying DENY=NONE)\
    \ to parallel the NFS\n      version 3 protocol's practice for the benefit of\
    \ users assuming\n      this degree of cache revalidation.\n   o  Second, modified\
    \ data must be flushed to the server before closing\n      a file OPENed for write.\
    \  This is complementary to the first rule.\n      If the data is not flushed\
    \ at CLOSE, the revalidation done after\n      client OPENs as file is unable\
    \ to achieve its purpose.  The other\n      aspect to flushing the data before\
    \ close is that the data must be\n      committed to stable storage, at the server,\
    \ before the CLOSE\n      operation is requested by the client.  In the case of\
    \ a server\n      reboot or restart and a CLOSEd file, it may not be possible\
    \ to\n      retransmit the data to be written to the file.  Hence, this\n    \
    \  requirement.\n"
- title: 9.3.2.  Data Caching and File Locking
  contents:
  - "9.3.2.  Data Caching and File Locking\n   For those applications that choose\
    \ to use file locking instead of\n   share reservations to exclude inconsistent\
    \ file access, there is an\n   analogous set of constraints that apply to client\
    \ side data caching.\n   These rules are effective only if the file locking is\
    \ used in a way\n   that matches in an equivalent way the actual READ and WRITE\n\
    \   operations executed.  This is as opposed to file locking that is\n   based\
    \ on pure convention.  For example, it is possible to manipulate\n   a two-megabyte\
    \ file by dividing the file into two one-megabyte\n   regions and protecting access\
    \ to the two regions by file locks on\n   bytes zero and one.  A lock for write\
    \ on byte zero of the file would\n   represent the right to do READ and WRITE\
    \ operations on the first\n   region.  A lock for write on byte one of the file\
    \ would represent the\n   right to do READ and WRITE operations on the second\
    \ region.  As long\n   as all applications manipulating the file obey this convention,\
    \ they\n   will work on a local file system.  However, they may not work with\n\
    \   the NFS version 4 protocol unless clients refrain from data caching.\n   The\
    \ rules for data caching in the file locking environment are:\n   o  First, when\
    \ a client obtains a file lock for a particular region,\n      the data cache\
    \ corresponding to that region (if any cache data\n      exists) must be revalidated.\
    \  If the change attribute indicates\n      that the file may have been updated\
    \ since the cached data was\n      obtained, the client must flush or invalidate\
    \ the cached data for\n      the newly locked region.  A client might choose to\
    \ invalidate all\n      of non-modified cached data that it has for the file but\
    \ the only\n      requirement for correct operation is to invalidate all of the\
    \ data\n      in the newly locked region.\n   o  Second, before releasing a write\
    \ lock for a region, all modified\n      data for that region must be flushed\
    \ to the server.  The modified\n      data must also be written to stable storage.\n\
    \   Note that flushing data to the server and the invalidation of cached\n   data\
    \ must reflect the actual byte ranges locked or unlocked.\n   Rounding these up\
    \ or down to reflect client cache block boundaries\n   will cause problems if\
    \ not carefully done.  For example, writing a\n   modified block when only half\
    \ of that block is within an area being\n   unlocked may cause invalid modification\
    \ to the region outside the\n   unlocked area.  This, in turn, may be part of\
    \ a region locked by\n   another client.  Clients can avoid this situation by\
    \ synchronously\n   performing portions of write operations that overlap that\
    \ portion\n   (initial or final) that is not a full block.  Similarly, invalidating\n\
    \   a locked area which is not an integral number of full buffer blocks\n   would\
    \ require the client to read one or two partial blocks from the\n   server if\
    \ the revalidation procedure shows that the data which the\n   client possesses\
    \ may not be valid.\n   The data that is written to the server as a pre-requisite\
    \ to the\n   unlocking of a region must be written, at the server, to stable\n\
    \   storage.  The client may accomplish this either with synchronous\n   writes\
    \ or by following asynchronous writes with a COMMIT operation.\n   This is required\
    \ because retransmission of the modified data after a\n   server reboot might\
    \ conflict with a lock held by another client.\n   A client implementation may\
    \ choose to accommodate applications which\n   use record locking in non-standard\
    \ ways (e.g. using a record lock as\n   a global semaphore) by flushing to the\
    \ server more data upon an LOCKU\n   than is covered by the locked range.  This\
    \ may include modified data\n   within files other than the one for which the\
    \ unlocks are being done.\n   In such cases, the client must not interfere with\
    \ applications whose\n   READs and WRITEs are being done only within the bounds\
    \ of record\n   locks which the application holds.  For example, an application\
    \ locks\n   a single byte of a file and proceeds to write that single byte.  A\n\
    \   client that chose to handle a LOCKU by flushing all modified data to\n   the\
    \ server could validly write that single byte in response to an\n   unrelated\
    \ unlock.  However, it would not be valid to write the entire\n   block in which\
    \ that single written byte was located since it includes\n   an area that is not\
    \ locked and might be locked by another client.\n   Client implementations can\
    \ avoid this problem by dividing files with\n   modified data into those for which\
    \ all modifications are done to\n   areas covered by an appropriate record lock\
    \ and those for which there\n   are modifications not covered by a record lock.\
    \  Any writes done for\n   the former class of files must not include areas not\
    \ locked and thus\n   not modified on the client.\n"
- title: 9.3.3.  Data Caching and Mandatory File Locking
  contents:
  - "9.3.3.  Data Caching and Mandatory File Locking\n   Client side data caching\
    \ needs to respect mandatory file locking when\n   it is in effect.  The presence\
    \ of mandatory file locking for a given\n   file is indicated in the result flags\
    \ for an OPEN.  When mandatory\n   locking is in effect for a file, the client\
    \ must check for an\n   appropriate file lock for data being read or written.\
    \  If a lock\n   exists for the range being read or written, the client may satisfy\n\
    \   the request using the client's validated cache.  If an appropriate\n   file\
    \ lock is not held for the range of the read or write, the read or\n   write request\
    \ must not be satisfied by the client's cache and the\n   request must be sent\
    \ to the server for processing.  When a read or\n   write request partially overlaps\
    \ a locked region, the request should\n   be subdivided into multiple pieces with\
    \ each region (locked or not)\n   treated appropriately.\n"
- title: 9.3.4.  Data Caching and File Identity
  contents:
  - "9.3.4.  Data Caching and File Identity\n   When clients cache data, the file\
    \ data needs to organized according\n   to the file system object to which the\
    \ data belongs.  For NFS version\n   3 clients, the typical practice has been\
    \ to assume for the purpose of\n   caching that distinct filehandles represent\
    \ distinct file system\n   objects.  The client then has the choice to organize\
    \ and maintain the\n   data cache on this basis.\n   In the NFS version 4 protocol,\
    \ there is now the possibility to have\n   significant deviations from a \"one\
    \ filehandle per object\" model\n   because a filehandle may be constructed on\
    \ the basis of the object's\n   pathname.  Therefore, clients need a reliable\
    \ method to determine if\n   two filehandles designate the same file system object.\
    \  If clients\n   were simply to assume that all distinct filehandles denote distinct\n\
    \   objects and proceed to do data caching on this basis, caching\n   inconsistencies\
    \ would arise between the distinct client side objects\n   which mapped to the\
    \ same server side object.\n   By providing a method to differentiate filehandles,\
    \ the NFS version 4\n   protocol alleviates a potential functional regression\
    \ in comparison\n   with the NFS version 3 protocol.  Without this method, caching\n\
    \   inconsistencies within the same client could occur and this has not\n   been\
    \ present in previous versions of the NFS protocol.  Note that it\n   is possible\
    \ to have such inconsistencies with applications executing\n   on multiple clients\
    \ but that is not the issue being addressed here.\n   For the purposes of data\
    \ caching, the following steps allow an NFS\n   version 4 client to determine\
    \ whether two distinct filehandles denote\n   the same server side object:\n \
    \  o  If GETATTR directed to two filehandles have different values of\n      the\
    \ fsid attribute, then the filehandles represent distinct\n      objects.\n  \
    \ o  If GETATTR for any file with an fsid that matches the fsid of the\n     \
    \ two filehandles in question returns a unique_handles attribute\n      with a\
    \ value of TRUE, then the two objects are distinct.\n   o  If GETATTR directed\
    \ to the two filehandles does not return the\n      fileid attribute for one or\
    \ both of the handles, then the it\n      cannot be determined whether the two\
    \ objects are the same.\n      Therefore, operations which depend on that knowledge\
    \ (e.g.  client\n      side data caching) cannot be done reliably.\n   o  If GETATTR\
    \ directed to the two filehandles returns different\n      values for the fileid\
    \ attribute, then they are distinct objects.\n   o  Otherwise they are the same\
    \ object.\n"
- title: 9.4.  Open Delegation
  contents:
  - "9.4.  Open Delegation\n   When a file is being OPENed, the server may delegate\
    \ further handling\n   of opens and closes for that file to the opening client.\
    \  Any such\n   delegation is recallable, since the circumstances that allowed\
    \ for\n   the delegation are subject to change.  In particular, the server may\n\
    \   receive a conflicting OPEN from another client, the server must\n   recall\
    \ the delegation before deciding whether the OPEN from the other\n   client may\
    \ be granted.  Making a delegation is up to the server and\n   clients should\
    \ not assume that any particular OPEN either will or\n   will not result in an\
    \ open delegation.  The following is a typical\n   set of conditions that servers\
    \ might use in deciding whether OPEN\n   should be delegated:\n   o  The client\
    \ must be able to respond to the server's callback\n      requests.  The server\
    \ will use the CB_NULL procedure for a test of\n      callback ability.\n   o\
    \  The client must have responded properly to previous recalls.\n   o  There must\
    \ be no current open conflicting with the requested\n      delegation.\n   o \
    \ There should be no current delegation that conflicts with the\n      delegation\
    \ being requested.\n   o  The probability of future conflicting open requests\
    \ should be low\n      based on the recent history of the file.\n   o  The existence\
    \ of any server-specific semantics of OPEN/CLOSE that\n      would make the required\
    \ handling incompatible with the prescribed\n      handling that the delegated\
    \ client would apply (see below).\n   There are two types of open delegations,\
    \ read and write.  A read open\n   delegation allows a client to handle, on its\
    \ own, requests to open a\n   file for reading that do not deny read access to\
    \ others.  Multiple\n   read open delegations may be outstanding simultaneously\
    \ and do not\n   conflict.  A write open delegation allows the client to handle,\
    \ on\n   its own, all opens.  Only one write open delegation may exist for a\n\
    \   given file at a given time and it is inconsistent with any read open\n   delegations.\n\
    \   When a client has a read open delegation, it may not make any changes\n  \
    \ to the contents or attributes of the file but it is assured that no\n   other\
    \ client may do so.  When a client has a write open delegation,\n   it may modify\
    \ the file data since no other client will be accessing\n   the file's data. \
    \ The client holding a write delegation may only\n   affect file attributes which\
    \ are intimately connected with the file\n   data:  object_size, time_modify,\
    \ change.\n   When a client has an open delegation, it does not send OPENs or\n\
    \   CLOSEs to the server but updates the appropriate status internally.\n   For\
    \ a read open delegation, opens that cannot be handled locally\n   (opens for\
    \ write or that deny read access) must be sent to the\n   server.\n   When an\
    \ open delegation is made, the response to the OPEN contains an\n   open delegation\
    \ structure which specifies the following:\n   o  the type of delegation (read\
    \ or write)\n   o  space limitation information to control flushing of data on\
    \ close\n      (write open delegation only, see the section \"Open Delegation\
    \ and\n      Data Caching\")\n   o  an nfsace4 specifying read and write permissions\n\
    \   o  a stateid to represent the delegation for READ and WRITE\n   The stateid\
    \ is separate and distinct from the stateid for the OPEN\n   proper.  The standard\
    \ stateid, unlike the delegation stateid, is\n   associated with a particular\
    \ nfs_lockowner and will continue to be\n   valid after the delegation is recalled\
    \ and the file remains open.\n   When a request internal to the client is made\
    \ to open a file and open\n   delegation is in effect, it will be accepted or\
    \ rejected solely on\n   the basis of the following conditions.  Any requirement\
    \ for other\n   checks to be made by the delegate should result in open delegation\n\
    \   being denied so that the checks can be made by the server itself.\n   o  The\
    \ access and deny bits for the request and the file as described\n      in the\
    \ section \"Share Reservations\".\n   o  The read and write permissions as determined\
    \ below.\n   The nfsace4 passed with delegation can be used to avoid frequent\n\
    \   ACCESS calls.  The permission check should be as follows:\n   o  If the nfsace4\
    \ indicates that the open may be done, then it should\n      be granted without\
    \ reference to the server.\n   o  If the nfsace4 indicates that the open may not\
    \ be done, then an\n      ACCESS request must be sent to the server to obtain\
    \ the definitive\n      answer.\n   The server may return an nfsace4 that is more\
    \ restrictive than the\n   actual ACL of the file.  This includes an nfsace4 that\
    \ specifies\n   denial of all access.  Note that some common practices such as\n\
    \   mapping the traditional user \"root\" to the user \"nobody\" may make it\n\
    \   incorrect to return the actual ACL of the file in the delegation\n   response.\n\
    \   The use of delegation together with various other forms of caching\n   creates\
    \ the possibility that no server authentication will ever be\n   performed for\
    \ a given user since all of the user's requests might be\n   satisfied locally.\
    \  Where the client is depending on the server for\n   authentication, the client\
    \ should be sure authentication occurs for\n   each user by use of the ACCESS\
    \ operation.  This should be the case\n   even if an ACCESS operation would not\
    \ be required otherwise.  As\n   mentioned before, the server may enforce frequent\
    \ authentication by\n   returning an nfsace4 denying all access with every open\
    \ delegation.\n"
- title: 9.4.1.  Open Delegation and Data Caching
  contents:
  - "9.4.1.  Open Delegation and Data Caching\n   OPEN delegation allows much of the\
    \ message overhead associated with\n   the opening and closing files to be eliminated.\
    \  An open when an open\n   delegation is in effect does not require that a validation\
    \ message be\n   sent to the server.  The continued endurance of the \"read open\n\
    \   delegation\" provides a guarantee that no OPEN for write and thus no\n   write\
    \ has occurred.  Similarly, when closing a file opened for write\n   and if write\
    \ open delegation is in effect, the data written does not\n   have to be flushed\
    \ to the server until the open delegation is\n   recalled.  The continued endurance\
    \ of the open delegation provides a\n   guarantee that no open and thus no read\
    \ or write has been done by\n   another client.\n   For the purposes of open delegation,\
    \ READs and WRITEs done without an\n   OPEN are treated as the functional equivalents\
    \ of a corresponding\n   type of OPEN.  This refers to the READs and WRITEs that\
    \ use the\n   special stateids consisting of all zero bits or all one bits.\n\
    \   Therefore, READs or WRITEs with a special stateid done by another\n   client\
    \ will force the server to recall a write open delegation.  A\n   WRITE with a\
    \ special stateid done by another client will force a\n   recall of read open\
    \ delegations.\n   With delegations, a client is able to avoid writing data to\
    \ the\n   server when the CLOSE of a file is serviced.  The CLOSE operation is\n\
    \   the usual point at which the client is notified of a lack of stable\n   storage\
    \ for the modified file data generated by the application.  At\n   the CLOSE,\
    \ file data is written to the server and through normal\n   accounting the server\
    \ is able to determine if the available file\n   system space for the data has\
    \ been exceeded (i.e. server returns\n   NFS4ERR_NOSPC or NFS4ERR_DQUOT).  This\
    \ accounting includes quotas.\n   The introduction of delegations requires that\
    \ a alternative method be\n   in place for the same type of communication to occur\
    \ between client\n   and server.\n   In the delegation response, the server provides\
    \ either the limit of\n   the size of the file or the number of modified blocks\
    \ and associated\n   block size.  The server must ensure that the client will\
    \ be able to\n   flush data to the server of a size equal to that provided in\
    \ the\n   original delegation.  The server must make this assurance for all\n\
    \   outstanding delegations.  Therefore, the server must be careful in\n   its\
    \ management of available space for new or modified data taking\n   into account\
    \ available file system space and any applicable quotas.\n   The server can recall\
    \ delegations as a result of managing the\n   available file system space.  The\
    \ client should abide by the server's\n   state space limits for delegations.\
    \  If the client exceeds the stated\n   limits for the delegation, the server's\
    \ behavior is undefined.\n   Based on server conditions, quotas or available file\
    \ system space,\n   the server may grant write open delegations with very restrictive\n\
    \   space limitations.  The limitations may be defined in a way that will\n  \
    \ always force modified data to be flushed to the server on close.\n   With respect\
    \ to authentication, flushing modified data to the server\n   after a CLOSE has\
    \ occurred may be problematic.  For example, the user\n   of the application may\
    \ have logged off of the client and unexpired\n   authentication credentials may\
    \ not be present.  In this case, the\n   client may need to take special care\
    \ to ensure that local unexpired\n   credentials will in fact be available.  This\
    \ may be accomplished by\n   tracking the expiration time of credentials and flushing\
    \ data well in\n   advance of their expiration or by making private copies of\n\
    \   credentials to assure their availability when needed.\n"
- title: 9.4.2.  Open Delegation and File Locks
  contents:
  - "9.4.2.  Open Delegation and File Locks\n   When a client holds a write open delegation,\
    \ lock operations are\n   performed locally.  This includes those required for\
    \ mandatory file\n   locking.  This can be done since the delegation implies that\
    \ there\n   can be no conflicting locks.  Similarly, all of the revalidations\n\
    \   that would normally be associated with obtaining locks and the\n   flushing\
    \ of data associated with the releasing of locks need not be\n   done.\n"
- title: 9.4.3.  Recall of Open Delegation
  contents:
  - "9.4.3.  Recall of Open Delegation\n   The following events necessitate recall\
    \ of an open delegation:\n   o  Potentially conflicting OPEN request (or READ/WRITE\
    \ done with\n      \"special\" stateid)\n   o  SETATTR issued by another client\n\
    \   o  REMOVE request for the file\n   o  RENAME request for the file as either\
    \ source or target of the\n      RENAME\n   Whether a RENAME of a directory in\
    \ the path leading to the file\n   results in recall of an open delegation depends\
    \ on the semantics of\n   the server file system.  If that file system denies\
    \ such RENAMEs when\n   a file is open, the recall must be performed to determine\
    \ whether the\n   file in question is, in fact, open.\n   In addition to the situations\
    \ above, the server may choose to recall\n   open delegations at any time if resource\
    \ constraints make it\n   advisable to do so.  Clients should always be prepared\
    \ for the\n   possibility of recall.\n   The server needs to employ special handling\
    \ for a GETATTR where the\n   target is a file that has a write open delegation\
    \ in effect.  In this\n   case, the client holding the delegation needs to be\
    \ interrogated.\n   The server will use a CB_GETATTR callback, if the GETATTR\
    \ attribute\n   bits include any of the attributes that a write open delegate\
    \ may\n   modify (object_size, time_modify, change).\n   When a client receives\
    \ a recall for an open delegation, it needs to\n   update state on the server\
    \ before returning the delegation.  These\n   same updates must be done whenever\
    \ a client chooses to return a\n   delegation voluntarily.  The following items\
    \ of state need to be\n   dealt with:\n   o  If the file associated with the delegation\
    \ is no longer open and\n      no previous CLOSE operation has been sent to the\
    \ server, a CLOSE\n      operation must be sent to the server.\n   o  If a file\
    \ has other open references at the client, then OPEN\n      operations must be\
    \ sent to the server.  The appropriate stateids\n      will be provided by the\
    \ server for subsequent use by the client\n      since the delegation stateid\
    \ will not longer be valid.  These OPEN\n      requests are done with the claim\
    \ type of CLAIM_DELEGATE_CUR.  This\n      will allow the presentation of the\
    \ delegation stateid so that the\n      client can establish the appropriate rights\
    \ to perform the OPEN.\n      (see the section \"Operation 18: OPEN\" for details.)\n\
    \   o  If there are granted file locks, the corresponding LOCK operations\n  \
    \    need to be performed.  This applies to the write open delegation\n      case\
    \ only.\n   o  For a write open delegation, if at the time of recall the file\
    \ is\n      not open for write, all modified data for the file must be flushed\n\
    \      to the server.  If the delegation had not existed, the client\n      would\
    \ have done this data flush before the CLOSE operation.\n   o  For a write open\
    \ delegation when a file is still open at the time\n      of recall, any modified\
    \ data for the file needs to be flushed to\n      the server.\n   o  With the\
    \ write open delegation in place, it is possible that the\n      file was truncated\
    \ during the duration of the delegation.  For\n      example, the truncation could\
    \ have occurred as a result of an OPEN\n      UNCHECKED with a object_size attribute\
    \ value of zero.  Therefore,\n      if a truncation of the file has occurred and\
    \ this operation has\n      not been propagated to the server, the truncation\
    \ must occur\n      before any modified data is written to the server.\n   In\
    \ the case of write open delegation, file locking imposes some\n   additional\
    \ requirements.  The flushing of any modified data in any\n   region for which\
    \ a write lock was released while the write open\n   delegation was in effect\
    \ is what is required to precisely maintain\n   the associated invariant.  However,\
    \ because the write open delegation\n   implies no other locking by other clients,\
    \ a simpler implementation\n   is to flush all modified data for the file (as\
    \ described just above)\n   if any write lock has been released while the write\
    \ open delegation\n   was in effect.\n"
- title: 9.4.4.  Delegation Revocation
  contents:
  - "9.4.4.  Delegation Revocation\n   At the point a delegation is revoked, if there\
    \ are associated opens\n   on the client, the applications holding these opens\
    \ need to be\n   notified.  This notification usually occurs by returning errors\
    \ for\n   READ/WRITE operations or when a close is attempted for the open file.\n\
    \   If no opens exist for the file at the point the delegation is\n   revoked,\
    \ then notification of the revocation is unnecessary.\n   However, if there is\
    \ modified data present at the client for the\n   file, the user of the application\
    \ should be notified.  Unfortunately,\n   it may not be possible to notify the\
    \ user since active applications\n   may not be present at the client.  See the\
    \ section \"Revocation\n   Recovery for Write Open Delegation\" for additional\
    \ details.\n"
- title: 9.5.  Data Caching and Revocation
  contents:
  - "9.5.  Data Caching and Revocation\n   When locks and delegations are revoked,\
    \ the assumptions upon which\n   successful caching depend are no longer guaranteed.\
    \  The owner of the\n   locks or share reservations which have been revoked needs\
    \ to be\n   notified.  This notification includes applications with a file open\n\
    \   that has a corresponding delegation which has been revoked.  Cached\n   data\
    \ associated with the revocation must be removed from the client.\n   In the case\
    \ of modified data existing in the client's cache, that\n   data must be removed\
    \ from the client without it being written to the\n   server.  As mentioned, the\
    \ assumptions made by the client are no\n   longer valid at the point when a lock\
    \ or delegation has been revoked.\n   For example, another client may have been\
    \ granted a conflicting lock\n   after the revocation of the lock at the first\
    \ client.  Therefore, the\n   data within the lock range may have been modified\
    \ by the other\n   client.  Obviously, the first client is unable to guarantee\
    \ to the\n   application what has occurred to the file in the case of revocation.\n\
    \   Notification to a lock owner will in many cases consist of simply\n   returning\
    \ an error on the next and all subsequent READs/WRITEs to the\n   open file or\
    \ on the close.  Where the methods available to a client\n   make such notification\
    \ impossible because errors for certain\n   operations may not be returned, more\
    \ drastic action such as signals\n   or process termination may be appropriate.\
    \  The justification for\n   this is that an invariant for which an application\
    \ depends on may be\n   violated.  Depending on how errors are typically treated\
    \ for the\n   client operating environment, further levels of notification\n \
    \  including logging, console messages, and GUI pop-ups may be\n   appropriate.\n"
- title: 9.5.1.  Revocation Recovery for Write Open Delegation
  contents:
  - "9.5.1.  Revocation Recovery for Write Open Delegation\n   Revocation recovery\
    \ for a write open delegation poses the special\n   issue of modified data in\
    \ the client cache while the file is not\n   open.  In this situation, any client\
    \ which does not flush modified\n   data to the server on each close must ensure\
    \ that the user receives\n   appropriate notification of the failure as a result\
    \ of the\n   revocation.  Since such situations may require human action to\n\
    \   correct problems, notification schemes in which the appropriate user\n   or\
    \ administrator is notified may be necessary.  Logging and console\n   messages\
    \ are typical examples.\n   If there is modified data on the client, it must not\
    \ be flushed\n   normally to the server.  A client may attempt to provide a copy\
    \ of\n   the file data as modified during the delegation under a different\n \
    \  name in the file system name space to ease recovery.  Unless the\n   client\
    \ can determine that the file has not modified by any other\n   client, this technique\
    \ must be limited to situations in which a\n   client has a complete cached copy\
    \ of the file in question.  Use of\n   such a technique may be limited to files\
    \ under a certain size or may\n   only be used when sufficient disk space is guaranteed\
    \ to be available\n   within the target file system and when the client has sufficient\n\
    \   buffering resources to keep the cached copy available until it is\n   properly\
    \ stored to the target file system.\n"
- title: 9.6.  Attribute Caching
  contents:
  - "9.6.  Attribute Caching\n   The attributes discussed in this section do not include\
    \ named\n   attributes.  Individual named attributes are analogous to files and\n\
    \   caching of the data for these needs to be handled just as data\n   caching\
    \ is for ordinary files.  Similarly, LOOKUP results from an\n   OPENATTR directory\
    \ are to be cached on the same basis as any other\n   pathnames and similarly\
    \ for directory contents.\n   Clients may cache file attributes obtained from\
    \ the server and use\n   them to avoid subsequent GETATTR requests.  Such caching\
    \ is write\n   through in that modification to file attributes is always done\
    \ by\n   means of requests to the server and should not be done locally and\n\
    \   cached.  The exception to this are modifications to attributes that\n   are\
    \ intimately connected with data caching.  Therefore, extending a\n   file by\
    \ writing data to the local data cache is reflected immediately\n   in the object_size\
    \ as seen on the client without this change being\n   immediately reflected on\
    \ the server.  Normally such changes are not\n   propagated directly to the server\
    \ but when the modified data is\n   flushed to the server, analogous attribute\
    \ changes are made on the\n   server.  When open delegation is in effect, the\
    \ modified attributes\n   may be returned to the server in the response to a CB_RECALL\
    \ call.\n   The result of local caching of attributes is that the attribute\n\
    \   caches maintained on individual clients will not be coherent. Changes\n  \
    \ made in one order on the server may be seen in a different order on\n   one\
    \ client and in a third order on a different client.\n   The typical file system\
    \ application programming interfaces do not\n   provide means to atomically modify\
    \ or interrogate attributes for\n   multiple files at the same time.  The following\
    \ rules provide an\n   environment where the potential incoherences mentioned\
    \ above can be\n   reasonably managed.  These rules are derived from the practice\
    \ of\n   previous NFS protocols.\n   o  All attributes for a given file (per-fsid\
    \ attributes excepted) are\n      cached as a unit at the client so that no non-serializability\
    \ can\n      arise within the context of a single file.\n   o  An upper time boundary\
    \ is maintained on how long a client cache\n      entry can be kept without being\
    \ refreshed from the server.\n   o  When operations are performed that change\
    \ attributes at the\n      server, the updated attribute set is requested as part\
    \ of the\n      containing RPC.  This includes directory operations that update\n\
    \      attributes indirectly.  This is accomplished by following the\n      modifying\
    \ operation with a GETATTR operation and then using the\n      results of the\
    \ GETATTR to update the client's cached attributes.\n   Note that if the full\
    \ set of attributes to be cached is requested by\n   READDIR, the results can\
    \ be cached by the client on the same basis as\n   attributes obtained via GETATTR.\n\
    \   A client may validate its cached version of attributes for a file by\n   fetching\
    \ only the change attribute and assuming that if the change\n   attribute has\
    \ the same value as it did when the attributes were\n   cached, then no attributes\
    \ have changed.  The possible exception is\n   the attribute time_access.\n"
- title: 9.7.  Name Caching
  contents:
  - "9.7.  Name Caching\n   The results of LOOKUP and READDIR operations may be cached\
    \ to avoid\n   the cost of subsequent LOOKUP operations.  Just as in the case\
    \ of\n   attribute caching, inconsistencies may arise among the various client\n\
    \   caches.  To mitigate the effects of these inconsistencies and given\n   the\
    \ context of typical file system APIs, the following rules should\n   be followed:\n\
    \   o  The results of unsuccessful LOOKUPs should not be cached, unless\n    \
    \  they are specifically reverified at the point of use.\n   o  An upper time\
    \ boundary is maintained on how long a client name\n      cache entry can be kept\
    \ without verifying that the entry has not\n      been made invalid by a directory\
    \ change operation performed by\n      another client.\n   When a client is not\
    \ making changes to a directory for which there\n   exist name cache entries,\
    \ the client needs to periodically fetch\n   attributes for that directory to\
    \ ensure that it is not being\n   modified.  After determining that no modification\
    \ has occurred, the\n   expiration time for the associated name cache entries\
    \ may be updated\n   to be the current time plus the name cache staleness bound.\n\
    \   When a client is making changes to a given directory, it needs to\n   determine\
    \ whether there have been changes made to the directory by\n   other clients.\
    \  It does this by using the change attribute as\n   reported before and after\
    \ the directory operation in the associated\n   change_info4 value returned for\
    \ the operation.  The server is able to\n   communicate to the client whether\
    \ the change_info4 data is provided\n   atomically with respect to the directory\
    \ operation.  If the change\n   values are provided atomically, the client is\
    \ then able to compare\n   the pre-operation change value with the change value\
    \ in the client's\n   name cache.  If the comparison indicates that the directory\
    \ was\n   updated by another client, the name cache associated with the\n   modified\
    \ directory is purged from the client.  If the comparison\n   indicates no modification,\
    \ the name cache can be updated on the\n   client to reflect the directory operation\
    \ and the associated timeout\n   extended.  The post-operation change value needs\
    \ to be saved as the\n   basis for future change_info4 comparisons.\n   As demonstrated\
    \ by the scenario above, name caching requires that the\n   client revalidate\
    \ name cache data by inspecting the change attribute\n   of a directory at the\
    \ point when the name cache item was cached.\n   This requires that the server\
    \ update the change attribute for\n   directories when the contents of the corresponding\
    \ directory is\n   modified.  For a client to use the change_info4 information\n\
    \   appropriately and correctly, the server must report the pre and post\n   operation\
    \ change attribute values atomically.  When the server is\n   unable to report\
    \ the before and after values atomically with respect\n   to the directory operation,\
    \ the server must indicate that fact in the\n   change_info4 return value.  When\
    \ the information is not atomically\n   reported, the client should not assume\
    \ that other clients have not\n   changed the directory.\n"
- title: 9.8.  Directory Caching
  contents:
  - "9.8.  Directory Caching\n   The results of READDIR operations may be used to\
    \ avoid subsequent\n   READDIR operations.  Just as in the cases of attribute\
    \ and name\n   caching, inconsistencies may arise among the various client caches.\n\
    \   To mitigate the effects of these inconsistencies, and given the\n   context\
    \ of typical file system APIs, the following rules should be\n   followed:\n \
    \  o  Cached READDIR information for a directory which is not obtained\n     \
    \ in a single READDIR operation must always be a consistent snapshot\n      of\
    \ directory contents.  This is determined by using a GETATTR\n      before the\
    \ first READDIR and after the last of READDIR that\n      contributes to the cache.\n\
    \   o  An upper time boundary is maintained to indicate the length of\n      time\
    \ a directory cache entry is considered valid before the client\n      must revalidate\
    \ the cached information.\n   The revalidation technique parallels that discussed\
    \ in the case of\n   name caching.  When the client is not changing the directory\
    \ in\n   question, checking the change attribute of the directory with GETATTR\n\
    \   is adequate.  The lifetime of the cache entry can be extended at\n   these\
    \ checkpoints.  When a client is modifying the directory, the\n   client needs\
    \ to use the change_info4 data to determine whether there\n   are other clients\
    \ modifying the directory.  If it is determined that\n   no other client modifications\
    \ are occurring, the client may update\n   its directory cache to reflect its\
    \ own changes.\n   As demonstrated previously, directory caching requires that\
    \ the\n   client revalidate directory cache data by inspecting the change\n  \
    \ attribute of a directory at the point when the directory was cached.\n   This\
    \ requires that the server update the change attribute for\n   directories when\
    \ the contents of the corresponding directory is\n   modified.  For a client to\
    \ use the change_info4 information\n   appropriately and correctly, the server\
    \ must report the pre and post\n   operation change attribute values atomically.\
    \  When the server is\n   unable to report the before and after values atomically\
    \ with respect\n   to the directory operation, the server must indicate that fact\
    \ in the\n   change_info4 return value.  When the information is not atomically\n\
    \   reported, the client should not assume that other clients have not\n   changed\
    \ the directory.\n"
- title: 10.  Minor Versioning
  contents:
  - "10.  Minor Versioning\n   To address the requirement of an NFS protocol that\
    \ can evolve as the\n   need arises, the NFS version 4 protocol contains the rules\
    \ and\n   framework to allow for future minor changes or versioning.\n   The base\
    \ assumption with respect to minor versioning is that any\n   future accepted\
    \ minor version must follow the IETF process and be\n   documented in a standards\
    \ track RFC.  Therefore, each minor version\n   number will correspond to an RFC.\
    \  Minor version zero of the NFS\n   version 4 protocol is represented by this\
    \ RFC.  The COMPOUND\n   procedure will support the encoding of the minor version\
    \ being\n   requested by the client.\n   The following items represent the basic\
    \ rules for the development of\n   minor versions.  Note that a future minor version\
    \ may decide to\n   modify or add to the following rules as part of the minor\
    \ version\n   definition.\n   1    Procedures are not added or deleted\n     \
    \   To maintain the general RPC model, NFS version 4 minor versions\n        will\
    \ not add or delete procedures from the NFS program.\n   2    Minor versions may\
    \ add operations to the COMPOUND and\n        CB_COMPOUND procedures.\n      \
    \  The addition of operations to the COMPOUND and CB_COMPOUND\n        procedures\
    \ does not affect the RPC model.\n   2.1  Minor versions may append attributes\
    \ to GETATTR4args, bitmap4,\n        and GETATTR4res.\n        This allows for\
    \ the expansion of the attribute model to allow\n        for future growth or\
    \ adaptation.\n   2.2  Minor version X must append any new attributes after the\
    \ last\n        documented attribute.\n        Since attribute results are specified\
    \ as an opaque array of\n        per-attribute XDR encoded results, the complexity\
    \ of adding new\n        attributes in the midst of the current definitions will\
    \ be too\n        burdensome.\n   3    Minor versions must not modify the structure\
    \ of an existing\n        operation's arguments or results.\n        Again the\
    \ complexity of handling multiple structure definitions\n        for a single\
    \ operation is too burdensome.  New operations should\n        be added instead\
    \ of modifying existing structures for a minor\n        version.\n        This\
    \ rule does not preclude the following adaptations in a minor\n        version.\n\
    \        o  adding bits to flag fields such as new attributes to\n           GETATTR's\
    \ bitmap4 data type\n        o  adding bits to existing attributes like ACLs that\
    \ have flag\n           words\n        o  extending enumerated types (including\
    \ NFS4ERR_*) with new\n           values\n   4    Minor versions may not modify\
    \ the structure of existing\n        attributes.\n   5    Minor versions may not\
    \ delete operations.\n        This prevents the potential reuse of a particular\
    \ operation\n        \"slot\" in a future minor version.\n   6    Minor versions\
    \ may not delete attributes.\n   7    Minor versions may not delete flag bits\
    \ or enumeration values.\n   8    Minor versions may declare an operation as mandatory\
    \ to NOT\n        implement.\n        Specifying an operation as \"mandatory to\
    \ not implement\" is\n        equivalent to obsoleting an operation.  For the\
    \ client, it means\n        that the operation should not be sent to the server.\
    \  For the\n        server, an NFS error can be returned as opposed to \"dropping\"\
    \n        the request as an XDR decode error.  This approach allows for\n    \
    \    the obsolescence of an operation while maintaining its structure\n      \
    \  so that a future minor version can reintroduce the operation.\n   8.1  Minor\
    \ versions may declare attributes mandatory to NOT\n        implement.\n   8.2\
    \  Minor versions may declare flag bits or enumeration values as\n        mandatory\
    \ to NOT implement.\n   9    Minor versions may downgrade features from mandatory\
    \ to\n        recommended, or recommended to optional.\n   10   Minor versions\
    \ may upgrade features from optional to recommended\n        or recommended to\
    \ mandatory.\n   11   A client and server that support minor version X must support\n\
    \        minor versions 0 (zero) through X-1 as well.\n   12   No new features\
    \ may be introduced as mandatory in a minor\n        version.\n        This rule\
    \ allows for the introduction of new functionality and\n        forces the use\
    \ of implementation experience before designating a\n        feature as mandatory.\n\
    \   13   A client MUST NOT attempt to use a stateid, file handle, or\n       \
    \ similar returned object from the COMPOUND procedure with minor\n        version\
    \ X for another COMPOUND procedure with minor version Y,\n        where X != Y.\n"
- title: 11.  Internationalization
  contents:
  - "11.  Internationalization\n   The primary issue in which NFS needs to deal with\n\
    \   internationalization, or I18n, is with respect to file names and\n   other\
    \ strings as used within the protocol.  The choice of string\n   representation\
    \ must allow reasonable name/string access to clients\n   which use various languages.\
    \  The UTF-8 encoding of the UCS as\n   defined by [ISO10646] allows for this\
    \ type of access and follows the\n   policy described in \"IETF Policy on Character\
    \ Sets and Languages\",\n   [RFC2277].  This choice is explained further in the\
    \ following.\n"
- title: 11.1.  Universal Versus Local Character Sets
  contents:
  - "11.1.  Universal Versus Local Character Sets\n   [RFC1345] describes a table\
    \ of 16 bit characters for many different\n   languages (the bit encodings match\
    \ Unicode, though of course RFC1345\n   is somewhat out of date with respect to\
    \ current Unicode assignments).\n   Each character from each language has a unique\
    \ 16 bit value in the 16\n   bit character set.  Thus this table can be thought\
    \ of as a universal\n   character set.  [RFC1345] then talks about groupings of\
    \ subsets of\n   the entire 16 bit character set into \"Charset Tables\".  For\
    \ example\n   one might take all the Greek characters from the 16 bit table (which\n\
    \   are consecutively allocated), and normalize their offsets to a table\n   that\
    \ fits in 7 bits.  Thus it is determined that \"lower case alpha\"\n   is in the\
    \ same position as \"upper case a\" in the US-ASCII table, and\n   \"upper case\
    \ alpha\" is in the same position as \"lower case a\" in the\n   US-ASCII table.\n\
    \   These normalized subset character sets can be thought of as \"local\n   character\
    \ sets\", suitable for an operating system locale.\n   Local character sets are\
    \ not suitable for the NFS protocol.  Consider\n   someone who creates a file\
    \ with a name in a Swedish character set.\n   If someone else later goes to access\
    \ the file with their locale set\n   to the Swedish language, then there are no\
    \ problems.  But if someone\n   in say the US-ASCII locale goes to access the\
    \ file, the file name\n   will look very different, because the Swedish characters\
    \ in the 7 bit\n   table will now be represented in US-ASCII characters on the\
    \ display.\n   It would be preferable to give the US-ASCII user a way to display\
    \ the\n   file name using Swedish glyphs. In order to do that, the NFS protocol\n\
    \   would have to include the locale with the file name on each operation\n  \
    \ to create a file.\n   But then what of the situation when there is a path name\
    \ on the\n   server like:\n         /component-1/component-2/component-3\n   Each\
    \ component could have been created with a different locale.  If\n   one issues\
    \ CREATE with multi-component path name, and if some of the\n   leading components\
    \ already exist, what is to be done with the\n   existing components?  Is the\
    \ current locale attribute replaced with\n   the user's current one?  These types\
    \ of situations quickly become too\n   complex when there is an alternate solution.\n\
    \   If the NFS version 4 protocol used a universal 16 bit or 32 bit\n   character\
    \ set (or an encoding of a 16 bit or 32 bit character set\n   into octets), then\
    \ the server and client need not care if the locale\n   of the user accessing\
    \ the file is different than the locale of the\n   user who created the file.\
    \  The unique 16 bit or 32 bit encoding of\n   the character allows for determination\
    \ of what language the character\n   is from and also how to display that character\
    \ on the client.  The\n   server need not know what locales are used.\n"
- title: 11.2.  Overview of Universal Character Set Standards
  contents:
  - "11.2.  Overview of Universal Character Set Standards\n   The previous section\
    \ makes a case for using a universal character\n   set.  This section makes the\
    \ case for using UTF-8 as the specific\n   universal character set for the NFS\
    \ version 4 protocol.\n   [RFC2279] discusses UTF-* (UTF-8 and other UTF-XXX encodings),\n\
    \   Unicode, and UCS-*.  There are two standards bodies managing\n   universal\
    \ code sets:\n   o  ISO/IEC which has the standard 10646-1\n   o  Unicode which\
    \ has the Unicode standard\n   Both standards bodies have pledged to track each\
    \ other's assignments\n   of character codes.\n   The following is a brief analysis\
    \ of the various standards.\n   UCS       Universal Character Set.  This is ISO/IEC\
    \ 10646-1: \"a\n             multi-octet character set called the Universal Character\n\
    \             Set (UCS), which encompasses most of the world's writing\n     \
    \        systems.\"\n   UCS-2     a two octet per character encoding that addresses\
    \ the first\n             2^16 characters of UCS. Currently there are no UCS\n\
    \             characters beyond that range.\n   UCS-4     a four octet per character\
    \ encoding that permits the\n             encoding of up to 2^31 characters.\n\
    \   UTF       UTF is an abbreviation of the term \"UCS transformation\n      \
    \       format\" and is used in the naming of various standards for\n        \
    \     encoding of UCS characters as described below.\n   UTF-1     Only historical\
    \ interest; it has been removed from 10646-1\n   UTF-7     Encodes the entire\
    \ \"repertoire\" of UCS \"characters using\n             only octets with the\
    \ higher order bit clear\".  [RFC2152]\n             describes UTF-7. UTF-7 accomplishes\
    \ this by reserving one\n             of the 7bit US-ASCII characters as a \"\
    shift\" character to\n             indicate non-US-ASCII characters.\n   UTF-8\
    \     Unlike UTF-7, uses all 8 bits of the octets. US-ASCII\n             characters\
    \ are encoded as before unchanged. Any octet with\n             the high bit cleared\
    \ can only mean a US-ASCII character.\n             The high bit set means that\
    \ a UCS character is being\n             encoded.\n   UTF-16    Encodes UCS-4\
    \ characters into UCS-2 characters using a\n             reserved range in UCS-2.\n\
    \   Unicode   Unicode and UCS-2 are the same; [RFC2279] states:\n            \
    \ Up to the present time, changes in Unicode and amendments\n             to ISO/IEC\
    \ 10646 have tracked each other, so that the\n             character repertoires\
    \ and code point assignments have\n             remained in sync.  The relevant\
    \ standardization committees\n             have committed to maintain this very\
    \ useful synchronism.\n"
- title: 11.3.  Difficulties with UCS-4, UCS-2, Unicode
  contents:
  - "11.3.  Difficulties with UCS-4, UCS-2, Unicode\n   Adapting existing applications,\
    \ and file systems to multi-octet\n   schemes like UCS and Unicode can be difficult.\
    \  A significant amount\n   of code has been written to process streams of bytes.\
    \ Also there are\n   many existing stored objects described with 7 bit or 8 bit\n\
    \   characters. Doubling or quadrupling the bandwidth and storage\n   requirements\
    \ seems like an expensive way to accomplish I18N.\n   UCS-2 and Unicode are \"\
    only\" 16 bits long.  That might seem to be\n   enough but, according to [Unicode1],\
    \ 49,194 Unicode characters are\n   already assigned.  According to [Unicode2]\
    \ there are still more\n   languages that need to be added.\n"
- title: 11.4.  UTF-8 and its solutions
  contents:
  - "11.4.  UTF-8 and its solutions\n   UTF-8 solves problems for NFS that exist with\
    \ the use of UCS and\n   Unicode.  UTF-8 will encode 16 bit and 32 bit characters\
    \ in a way\n   that will be compact for most users. The encoding table from UCS-4\
    \ to\n   UTF-8, as copied from [RFC2279]:\n      UCS-4 range (hex.)          \
    \ UTF-8 octet sequence (binary)\n    0000 0000-0000 007F   0xxxxxxx\n    0000\
    \ 0080-0000 07FF   110xxxxx 10xxxxxx\n    0000 0800-0000 FFFF   1110xxxx 10xxxxxx\
    \ 10xxxxxx\n    0001 0000-001F FFFF   11110xxx 10xxxxxx 10xxxxxx 10xxxxxx\n  \
    \  0020 0000-03FF FFFF   111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx\n    0400\
    \ 0000-7FFF FFFF   1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx\n            \
    \              10xxxxxx\n   See [RFC2279] for precise encoding and decoding rules.\
    \ Note because\n   of UTF-16, the algorithm from Unicode/UCS-2 to UTF-8 needs\
    \ to account\n   for the reserved range between D800 and DFFF.\n   Note that the\
    \ 16 bit UCS or Unicode characters require no more than 3\n   octets to encode\
    \ into UTF-8\n   Interestingly, UTF-8 has room to handle characters larger than\
    \ 31\n   bits, because the leading octet of form:\n         1111111x\n   is not\
    \ defined. If needed, ISO could either use that octet to\n   indicate a sequence\
    \ of an encoded 8 octet character, or perhaps use\n   11111110 to permit the next\
    \ octet to indicate an even more expandable\n   character set.\n   So using UTF-8\
    \ to represent character encodings means never having to\n   run out of room.\n"
- title: 11.5.  Normalization
  contents:
  - "11.5.  Normalization\n   The client and server operating environments may differ\
    \ in their\n   policies and operational methods with respect to character\n  \
    \ normalization (See [Unicode1] for a discussion of normalization\n   forms).\
    \  This difference may also exist between applications on the\n   same client.\
    \  This adds to the difficulty of providing a single\n   normalization policy\
    \ for the protocol that allows for maximal\n   interoperability.  This issue is\
    \ similar to the character case issues\n   where the server may or may not support\
    \ case insensitive file name\n   matching and may or may not preserve the character\
    \ case when storing\n   file names.  The protocol does not mandate a particular\
    \ behavior but\n   allows for the various permutations.\n   The NFS version 4\
    \ protocol does not mandate the use of a particular\n   normalization form at\
    \ this time.  A later revision of this\n   specification may specify a particular\
    \ normalization form.\n   Therefore, the server and client can expect that they\
    \ may receive\n   unnormalized characters within protocol requests and responses.\
    \  If\n   the operating environment requires normalization, then the\n   implementation\
    \ must normalize the various UTF-8 encoded strings\n   within the protocol before\
    \ presenting the information to an\n   application (at the client) or local file\
    \ system (at the server).\n"
- title: 12.  Error Definitions
  contents:
  - "12.  Error Definitions\n   NFS error numbers are assigned to failed operations\
    \ within a compound\n   request.  A compound request contains a number of NFS\
    \ operations that\n   have their results encoded in sequence in a compound reply.\
    \  The\n   results of successful operations will consist of an NFS4_OK status\n\
    \   followed by the encoded results of the operation.  If an NFS\n   operation\
    \ fails, an error status will be entered in the reply and the\n   compound request\
    \ will be terminated.\n   A description of each defined error follows:\n   NFS4_OK\
    \               Indicates the operation completed successfully.\n   NFS4ERR_ACCES\
    \         Permission denied. The caller does not have the\n                  \
    \       correct permission to perform the requested\n                        \
    \ operation. Contrast this with NFS4ERR_PERM,\n                         which\
    \ restricts itself to owner or privileged\n                         user permission\
    \ failures.\n   NFS4ERR_BADHANDLE     Illegal NFS file handle. The file handle\
    \ failed\n                         internal consistency checks.\n   NFS4ERR_BADTYPE\
    \       An attempt was made to create an object of a\n                       \
    \  type not supported by the server.\n   NFS4ERR_BAD_COOKIE    READDIR cookie\
    \ is stale.\n   NFS4ERR_BAD_SEQID     The sequence number in a locking request\
    \ is\n                         neither the next expected number or the last\n\
    \                         number processed.\n   NFS4ERR_BAD_STATEID   A stateid\
    \ generated by the current server\n                         instance, but which\
    \ does not designate any\n                         locking state (either current\
    \ or superseded)\n                         for a current lockowner-file pair,\
    \ was used.\n   NFS4ERR_CLID_INUSE    The SETCLIENTID procedure has found that\
    \ a\n                         client id is already in use by another client.\n\
    \   NFS4ERR_DELAY         The server initiated the request, but was not\n    \
    \                     able to complete it in a timely fashion. The\n         \
    \                client should wait and then try the request\n               \
    \          with a new RPC transaction ID.  For example,\n                    \
    \     this error should be returned from a server\n                         that\
    \ supports hierarchical storage and receives\n                         a request\
    \ to process a file that has been\n                         migrated. In this\
    \ case, the server should start\n                         the immigration process\
    \ and respond to client\n                         with this error.  This error\
    \ may also occur\n                         when a necessary delegation recall\
    \ makes\n                         processing a request in a timely fashion\n \
    \                        impossible.\n   NFS4ERR_DENIED        An attempt to lock\
    \ a file is denied.  Since\n                         this may be a temporary condition,\
    \ the client\n                         is encouraged to retry the lock request\
    \ until\n                         the lock is accepted.\n   NFS4ERR_DQUOT    \
    \     Resource (quota) hard limit exceeded. The\n                         user's\
    \ resource limit on the server has been\n                         exceeded.\n\
    \   NFS4ERR_EXIST         File exists. The file specified already exists.\n  \
    \ NFS4ERR_EXPIRED       A lease has expired that is being used in the\n      \
    \                   current procedure.\n   NFS4ERR_FBIG          File too large.\
    \ The operation would have caused\n                         a file to grow beyond\
    \ the server's limit.\n   NFS4ERR_FHEXPIRED     The file handle provided is volatile\
    \ and has\n                         expired at the server.\n   NFS4ERR_GRACE \
    \        The server is in its recovery or grace period\n                     \
    \    which should match the lease period of the\n                         server.\n\
    \   NFS4ERR_INVAL         Invalid argument or unsupported argument for an\n  \
    \                       operation. Two examples are attempting a\n           \
    \              READLINK on an object other than a symbolic\n                 \
    \        link or attempting to SETATTR a time field on a\n                   \
    \      server that does not support this operation.\n   NFS4ERR_IO           \
    \ I/O error. A hard error (for example, a disk\n                         error)\
    \ occurred while processing the requested\n                         operation.\n\
    \   NFS4ERR_ISDIR         Is a directory. The caller specified a\n           \
    \              directory in a non-directory operation.\n   NFS4ERR_LEASE_MOVED\
    \   A lease being renewed is associated with a file\n                        \
    \ system that has been migrated to a new server.\n   NFS4ERR_LOCKED        A read\
    \ or write operation was attempted on a\n                         locked file.\n\
    \   NFS4ERR_LOCK_RANGE    A lock request is operating on a sub-range of a\n  \
    \                       current lock for the lock owner and the server\n     \
    \                    does not support this type of request.\n   NFS4ERR_MINOR_VERS_MISMATCH\n\
    \                         The server has received a request that\n           \
    \              specifies an unsupported minor version.  The\n                \
    \         server must return a COMPOUND4res with a zero\n                    \
    \     length operations result array.\n   NFS4ERR_MLINK         Too many hard\
    \ links.\n   NFS4ERR_MOVED         The filesystem which contains the current\n\
    \                         filehandle object has been relocated or\n          \
    \               migrated to another server.  The client may\n                \
    \         obtain the new filesystem location by obtaining\n                  \
    \       the \"fs_locations\" attribute for the current\n                     \
    \    filehandle.  For further discussion, refer to\n                         the\
    \ section \"Filesystem Migration or\n                         Relocation\".\n\
    \   NFS4ERR_NAMETOOLONG   The filename in an operation was too long.\n   NFS4ERR_NODEV\
    \         No such device.\n   NFS4ERR_NOENT         No such file or directory.\
    \ The file or\n                         directory name specified does not exist.\n\
    \   NFS4ERR_NOFILEHANDLE  The logical current file handle value has not\n    \
    \                     been set properly.  This may be a result of a\n        \
    \                 malformed COMPOUND operation (i.e. no PUTFH or\n           \
    \              PUTROOTFH before an operation that requires the\n             \
    \            current file handle be set).\n   NFS4ERR_NOSPC         No space left\
    \ on device. The operation would\n                         have caused the server's\
    \ file system to exceed\n                         its limit.\n   NFS4ERR_NOTDIR\
    \        Not a directory. The caller specified a non-\n                      \
    \   directory in a directory operation.\n   NFS4ERR_NOTEMPTY      An attempt was\
    \ made to remove a directory that\n                         was not empty.\n \
    \  NFS4ERR_NOTSUPP       Operation is not supported.\n   NFS4ERR_NOT_SAME    \
    \  This error is returned by the VERIFY operation\n                         to\
    \ signify that the attributes compared were\n                         not the\
    \ same as provided in the client's\n                         request.\n   NFS4ERR_NXIO\
    \          I/O error. No such device or address.\n   NFS4ERR_OLD_STATEID   A stateid\
    \ which designates the locking state\n                         for a lockowner-file\
    \ at an earlier time was\n                         used.\n   NFS4ERR_PERM    \
    \      Not owner. The operation was not allowed\n                         because\
    \ the caller is either not a privileged\n                         user (root)\
    \ or not the owner of the target of\n                         the operation.\n\
    \   NFS4ERR_READDIR_NOSPC The encoded response to a READDIR request\n        \
    \                 exceeds the size limit set by the initial\n                \
    \         request.\n   NFS4ERR_RESOURCE      For the processing of the COMPOUND\
    \ procedure,\n                         the server may exhaust available resources\
    \ and\n                         can not continue processing procedures within\n\
    \                         the COMPOUND operation.  This error will be\n      \
    \                   returned from the server in those instances of\n         \
    \                resource exhaustion related to the processing\n             \
    \            of the COMPOUND procedure.\n   NFS4ERR_ROFS          Read-only file\
    \ system. A modifying operation\n                         was attempted on a read-only\
    \ file system.\n   NFS4ERR_SAME          This error is returned by the NVERIFY\
    \ operation\n                         to signify that the attributes compared\
    \ were\n                         the same as provided in the client's request.\n\
    \   NFS4ERR_SERVERFAULT   An error occurred on the server which does not\n   \
    \                      map to any of the legal NFS version 4 protocol\n      \
    \                   error values.  The client should translate this\n        \
    \                 into an appropriate error.  UNIX clients may\n             \
    \            choose to translate this to EIO.\n   NFS4ERR_SHARE_DENIED  An attempt\
    \ to OPEN a file with a share\n                         reservation has failed\
    \ because of a share\n                         conflict.\n   NFS4ERR_STALE   \
    \      Invalid file handle. The file handle given in\n                       \
    \  the arguments was invalid. The file referred to\n                         by\
    \ that file handle no longer exists or access\n                         to it\
    \ has been revoked.\n   NFS4ERR_STALE_CLIENTID A clientid not recognized by the\
    \ server was\n                         used in a locking or SETCLIENTID_CONFIRM\n\
    \                         request.\n   NFS4ERR_STALE_STATEID A stateid generated\
    \ by an earlier server\n                         instance was used.\n   NFS4ERR_SYMLINK\
    \       The current file handle provided for a LOOKUP\n                      \
    \   is not a directory but a symbolic link.  Also\n                         used\
    \ if the final component of the OPEN path is\n                         a symbolic\
    \ link.\n                         NFS4ERR_TOOSMALL      Buffer or request is too\n\
    \                         small.\n   NFS4ERR_WRONGSEC      The security mechanism\
    \ being used by the client\n                         for the procedure does not\
    \ match the server's\n                         security policy.  The client should\
    \ change the\n                         security mechanism being used and retry\
    \ the\n                         operation.\n   NFS4ERR_XDEV          Attempt to\
    \ do a cross-device hard link.\n"
- title: 13.  NFS Version 4 Requests
  contents:
  - "13.  NFS Version 4 Requests\n   For the NFS version 4 RPC program, there are\
    \ two traditional RPC\n   procedures: NULL and COMPOUND.  All other functionality\
    \ is defined as\n   a set of operations and these operations are defined in normal\n\
    \   XDR/RPC syntax and semantics.  However, these operations are\n   encapsulated\
    \ within the COMPOUND procedure.  This requires that the\n   client combine one\
    \ or more of the NFS version 4 operations into a\n   single request.\n   The NFS4_CALLBACK\
    \ program is used to provide server to client\n   signaling and is constructed\
    \ in a similar fashion as the NFS version\n   4 program.  The procedures CB_NULL\
    \ and CB_COMPOUND are defined in the\n   same way as NULL and COMPOUND are within\
    \ the NFS program.  The\n   CB_COMPOUND request also encapsulates the remaining\
    \ operations of the\n   NFS4_CALLBACK program.  There is no predefined RPC program\
    \ number for\n   the NFS4_CALLBACK program.  It is up to the client to specify\
    \ a\n   program number in the \"transient\" program range.  The program and\n\
    \   port number of the NFS4_CALLBACK program are provided by the client\n   as\
    \ part of the SETCLIENTID operation and therefore is fixed for the\n   life of\
    \ the client instantiation.\n"
- title: 13.1.  Compound Procedure
  contents:
  - "13.1.  Compound Procedure\n   The COMPOUND procedure provides the opportunity\
    \ for better\n   performance within high latency networks.  The client can avoid\n\
    \   cumulative latency of multiple RPCs by combining multiple dependent\n   operations\
    \ into a single COMPOUND procedure.  A compound operation\n   may provide for\
    \ protocol simplification by allowing the client to\n   combine basic procedures\
    \ into a single request that is customized for\n   the client's environment.\n\
    \   The CB_COMPOUND procedure precisely parallels the features of\n   COMPOUND\
    \ as described above.\n   The basics of the COMPOUND procedures construction is:\n\
    \                  +-----------+-----------+-----------+--\n                 \
    \ | op + args | op + args | op + args |\n                  +-----------+-----------+-----------+--\n\
    \   and the reply looks like this:\n      +------------+-----------------------+-----------------------+--\n\
    \      |last status | status + op + results | status + op + results |\n      +------------+-----------------------+-----------------------+--\n"
- title: 13.2.  Evaluation of a Compound Request
  contents:
  - "13.2.  Evaluation of a Compound Request\n   The server will process the COMPOUND\
    \ procedure by evaluating each of\n   the operations within the COMPOUND procedure\
    \ in order.  Each\n   component operation consists of a 32 bit operation code,\
    \ followed by\n   the argument of length determined by the type of operation.\
    \ The\n   results of each operation are encoded in sequence into a reply\n   buffer.\
    \  The results of each operation are preceded by the opcode and\n   a status code\
    \ (normally zero).  If an operation results in a non-zero\n   status code, the\
    \ status will be encoded and evaluation of the\n   compound sequence will halt\
    \ and the reply will be returned.  Note\n   that evaluation stops even in the\
    \ event of \"non error\" conditions\n   such as NFS4ERR_SAME.\n   There are no\
    \ atomicity requirements for the operations contained\n   within the COMPOUND\
    \ procedure.  The operations being evaluated as\n   part of a COMPOUND request\
    \ may be evaluated simultaneously with other\n   COMPOUND requests that the server\
    \ receives.\n   It is the client's responsibility for recovering from any partially\n\
    \   completed COMPOUND procedure.  Partially completed COMPOUND\n   procedures\
    \ may occur at any point due to errors such as\n   NFS4ERR_RESOURCE and NFS4ERR_LONG_DELAY.\
    \  This may occur even given\n   an otherwise valid operation string.  Further,\
    \ a server reboot which\n   occurs in the middle of processing a COMPOUND procedure\
    \ may leave the\n   client with the difficult task of determining how far COMPOUND\n\
    \   processing has proceeded.  Therefore, the client should avoid overly\n   complex\
    \ COMPOUND procedures in the event of the failure of an\n   operation within the\
    \ procedure.\n   Each operation assumes a \"current\" and \"saved\" filehandle\
    \ that is\n   available as part of the execution context of the compound request.\n\
    \   Operations may set, change, or return the current filehandle.  The\n   \"\
    saved\" filehandle is used for temporary storage of a filehandle\n   value and\
    \ as operands for the RENAME and LINK operations.\n"
- title: 13.3.  Synchronous Modifying Operations
  contents:
  - "13.3.  Synchronous Modifying Operations\n   NFS version 4 operations that modify\
    \ the file system are synchronous.\n   When an operation is successfully completed\
    \ at the server, the client\n   can depend that any data associated with the request\
    \ is now on stable\n   storage (the one exception is in the case of the file data\
    \ in a WRITE\n   operation with the UNSTABLE option specified).\n   This implies\
    \ that any previous operations within the same compound\n   request are also reflected\
    \ in stable storage.  This behavior enables\n   the client's ability to recover\
    \ from a partially executed compound\n   request which may resulted from the failure\
    \ of the server.  For\n   example, if a compound request contains operations A\
    \ and B and the\n   server is unable to send a response to the client, depending\
    \ on the\n   progress the server made in servicing the request the result of both\n\
    \   operations may be reflected in stable storage or just operation A may\n  \
    \ be reflected.  The server must not have just the results of operation\n   B\
    \ in stable storage.\n"
- title: 13.4.  Operation Values
  contents:
  - "13.4.  Operation Values\n   The operations encoded in the COMPOUND procedure\
    \ are identified by\n   operation values.  To avoid overlap with the RPC procedure\
    \ numbers,\n   operations 0 (zero) and 1 are not defined.  Operation 2 is not\n\
    \   defined but reserved for future use with minor versioning.\n"
- title: 14.  NFS Version 4 Procedures
  contents:
  - '14.  NFS Version 4 Procedures

    '
- title: '14.1.  Procedure 0: NULL - No Operation'
  contents:
  - "14.1.  Procedure 0: NULL - No Operation\n   SYNOPSIS\n      <null>\n   ARGUMENT\n\
    \      void;\n   RESULT\n      void;\n   DESCRIPTION\n      Standard NULL procedure.\
    \  Void argument, void response.  This\n      procedure has no functionality associated\
    \ with it.  Because of\n      this it is sometimes used to measure the overhead\
    \ of processing a\n      service request.  Therefore, the server should ensure\
    \ that no\n      unnecessary work is done in servicing this procedure.\n   ERRORS\n\
    \      None.\n"
- title: '14.2.  Procedure 1: COMPOUND - Compound Operations'
  contents:
  - "14.2.  Procedure 1: COMPOUND - Compound Operations\n   SYNOPSIS\n      compoundargs\
    \ -> compoundres\n   ARGUMENT\n      union nfs_argop4 switch (nfs_opnum4 argop)\
    \ {\n              case <OPCODE>: <argument>;\n              ...\n      };\n \
    \     struct COMPOUND4args {\n              utf8string      tag;\n           \
    \   uint32_t        minorversion;\n              nfs_argop4      argarray<>;\n\
    \      };\n   RESULT\n         union nfs_resop4 switch (nfs_opnum4 resop){\n \
    \                case <OPCODE>: <result>;\n                 ...\n         };\n\
    \         struct COMPOUND4res {\n                 nfsstat4        status;\n  \
    \               utf8string      tag;\n                 nfs_resop4      resarray<>;\n\
    \         };\n   DESCRIPTION\n      The COMPOUND procedure is used to combine\
    \ one or more of the NFS\n      operations into a single RPC request.  The main\
    \ NFS RPC program\n      has two main procedures: NULL and COMPOUND.  All other\
    \ operations\n      use the COMPOUND procedure as a wrapper.\n      The COMPOUND\
    \ procedure is used to combine individual operations\n      into a single RPC\
    \ request.  The server interprets each of the\n      operations in turn.  If an\
    \ operation is executed by the server and\n      the status of that operation\
    \ is NFS4_OK, then the next operation\n      in the COMPOUND procedure is executed.\
    \  The server continues this\n      process until there are no more operations\
    \ to be executed or one\n      of the operations has a status value other than\
    \ NFS4_OK.\n      In the processing of the COMPOUND procedure, the server may\
    \ find\n      that it does not have the available resources to execute any or\n\
    \      all of the operations within the COMPOUND sequence.  In this case,\n  \
    \    the error NFS4ERR_RESOURCE will be returned for the particular\n      operation\
    \ within the COMPOUND procedure where the resource\n      exhaustion occurred.\
    \  This assumes that all previous operations\n      within the COMPOUND sequence\
    \ have been evaluated successfully.\n      The results for all of the evaluated\
    \ operations must be returned\n      to the client.\n      The COMPOUND arguments\
    \ contain a \"minorversion\" field.  The\n      initial and default value for\
    \ this field is 0 (zero).  This field\n      will be used by future minor versions\
    \ such that the client can\n      communicate to the server what minor version\
    \ is being requested.\n      If the server receives a COMPOUND procedure with\
    \ a minorversion\n      field value that it does not support, the server MUST\
    \ return an\n      error of NFS4ERR_MINOR_VERS_MISMATCH and a zero length resultdata\n\
    \      array.\n      Contained within the COMPOUND results is a \"status\" field.\
    \  If the\n      results array length is non-zero, this status must be equivalent\n\
    \      to the status of the last operation that was executed within the\n    \
    \  COMPOUND procedure.  Therefore, if an operation incurred an error\n      then\
    \ the \"status\" value will be the same error value as is being\n      returned\
    \ for the operation that failed.\n      Note that operations, 0 (zero) and 1 (one)\
    \ are not defined for the\n      COMPOUND procedure.  If the server receives an\
    \ operation array\n      with either of these included, an error of NFS4ERR_NOTSUPP\
    \ must be\n      returned.  Operation 2 is not defined but reserved for future\n\
    \      definition and use with minor versioning.  If the server receives\n   \
    \   a operation array that contains operation 2 and the minorversion\n      field\
    \ has a value of 0 (zero), an error of NFS4ERR_NOTSUPP is\n      returned.  If\
    \ an operation array contains an operation 2 and the\n      minorversion field\
    \ is non-zero and the server does not support the\n      minor version, the server\
    \ returns an error of\n      NFS4ERR_MINOR_VERS_MISMATCH.  Therefore, the\n  \
    \    NFS4ERR_MINOR_VERS_MISMATCH error takes precedence over all other\n     \
    \ errors.\n   IMPLEMENTATION\n      Note that the definition of the \"tag\" in\
    \ both the request and\n      response are left to the implementor.  It may be\
    \ used to summarize\n      the content of the compound request for the benefit\
    \ of packet\n      sniffers and engineers debugging implementations.\n      Since\
    \ an error of any type may occur after only a portion of the\n      operations\
    \ have been evaluated, the client must be prepared to\n      recover from any\
    \ failure.  If the source of an NFS4ERR_RESOURCE\n      error was a complex or\
    \ lengthy set of operations, it is likely\n      that if the number of operations\
    \ were reduced the server would be\n      able to evaluate them successfully.\
    \  Therefore, the client is\n      responsible for dealing with this type of complexity\
    \ in recovery.\n   ERRORS\n      All errors defined in the protocol\n"
- title: '14.2.1.  Operation 3: ACCESS - Check Access Rights'
  contents:
  - "14.2.1.  Operation 3: ACCESS - Check Access Rights\n   SYNOPSIS\n         (cfh),\
    \ accessreq -> supported, accessrights\n   ARGUMENT\n         const ACCESS4_READ\
    \      = 0x00000001;\n         const ACCESS4_LOOKUP    = 0x00000002;\n       \
    \  const ACCESS4_MODIFY    = 0x00000004;\n         const ACCESS4_EXTEND    = 0x00000008;\n\
    \         const ACCESS4_DELETE    = 0x00000010;\n         const ACCESS4_EXECUTE\
    \   = 0x00000020;\n         struct ACCESS4args {\n                 /* CURRENT_FH:\
    \ object */\n                 uint32_t        access;\n         };\n   RESULT\n\
    \         struct ACCESS4resok {\n                 uint32_t        supported;\n\
    \                 uint32_t        access;\n         };\n         union ACCESS4res\
    \ switch (nfsstat4 status) {\n          case NFS4_OK:\n                  ACCESS4resok\
    \   resok4;\n          default:\n                  void;\n         };\n   DESCRIPTION\n\
    \      ACCESS determines the access rights that a user, as identified by\n   \
    \   the credentials in the RPC request, has with respect to the file\n      system\
    \ object specified by the current filehandle.  The client\n      encodes the set\
    \ of access rights that are to be checked in the bit\n      mask \"access\". \
    \ The server checks the permissions encoded in the\n      bit mask.  If a status\
    \ of NFS4_OK is returned, two bit masks are\n      included in the response. \
    \ The first, \"supported\", represents the\n      access rights for which the\
    \ server can verify reliably.  The\n      second, \"access\", represents the access\
    \ rights available to the\n      user for the filehandle provided.  On success,\
    \ the current\n      filehandle retains its value.\n      Note that the supported\
    \ field will contain only as many values as\n      was originally sent in the\
    \ arguments.  For example, if the client\n      sends an ACCESS operation with\
    \ only the ACCESS4_READ value set and\n      the server supports this value, the\
    \ server will return only\n      ACCESS4_READ even if it could have reliably checked\
    \ other values.\n      The results of this operation are necessarily advisory\
    \ in nature.\n      A return status of NFS4_OK and the appropriate bit set in\
    \ the bit\n      mask does not imply that such access will be allowed to the file\n\
    \      system object in the future. This is because access rights can be\n   \
    \   revoked by the server at any time.\n      The following access permissions\
    \ may be requested:\n   ACCESS4_READ    Read data from file or read a directory.\n\
    \   ACCESS4_LOOKUP  Look up a name in a directory (no meaning for non-\n     \
    \              directory objects).\n   ACCESS4_MODIFY  Rewrite existing file data\
    \ or modify existing\n                   directory entries.\n   ACCESS4_EXTEND\
    \  Write new data or add directory entries.\n   ACCESS4_DELETE  Delete an existing\
    \ directory entry (no meaning for\n                   non-directory objects).\n\
    \   ACCESS4_EXECUTE Execute file (no meaning for a directory).\n   On success,\
    \ the current filehandle retains its value.\n   IMPLEMENTATION\n      For the\
    \ NFS version 4 protocol, the use of the ACCESS procedure\n      when opening\
    \ a regular file is deprecated in favor of using OPEN.\n      In general, it is\
    \ not sufficient for the client to attempt to\n      deduce access permissions\
    \ by inspecting the uid, gid, and mode\n      fields in the file attributes or\
    \ by attempting to interpret the\n      contents of the ACL attribute.  This is\
    \ because the server may\n      perform uid or gid mapping or enforce additional\
    \ access control\n      restrictions.  It is also possible that the server may\
    \ not be in\n      the same ID space as the client.  In these cases (and perhaps\n\
    \      others), the client can not reliably perform an access check with\n   \
    \   only current file attributes.\n      In the NFS version 2 protocol, the only\
    \ reliable way to determine\n      whether an operation was allowed was to try\
    \ it and see if it\n      succeeded or failed.  Using the ACCESS procedure in\
    \ the NFS\n      version 4 protocol, the client can ask the server to indicate\n\
    \      whether or not one or more classes of operations are permitted.\n     \
    \ The ACCESS operation is provided to allow clients to check before\n      doing\
    \ a series of operations which will result in an access\n      failure.  The OPEN\
    \ operation provides a point where the server can\n      verify access to the\
    \ file object and method to return that\n      information to the client.  The\
    \ ACCESS operation is still useful\n      for directory operations or for use\
    \ in the case the UNIX API\n      \"access\" is used on the client.\n      The\
    \ information returned by the server in response to an ACCESS\n      call is not\
    \ permanent.  It was correct at the exact time that the\n      server performed\
    \ the checks, but not necessarily afterwards.  The\n      server can revoke access\
    \ permission at any time.\n      The client should use the effective credentials\
    \ of the user to\n      build the authentication information in the ACCESS request\
    \ used to\n      determine access rights.  It is the effective user and group\n\
    \      credentials that are used in subsequent read and write operations.\n  \
    \    Many implementations do not directly support the ACCESS4_DELETE\n      permission.\
    \  Operating systems like UNIX will ignore the\n      ACCESS4_DELETE bit if set\
    \ on an access request on a non-directory\n      object.  In these systems, delete\
    \ permission on a file is\n      determined by the access permissions on the directory\
    \ in which the\n      file resides, instead of being determined by the permissions\
    \ of\n      the file itself.  Therefore, the mask returned enumerating which\n\
    \      access rights can be determined will have the ACCESS4_DELETE value\n  \
    \    set to 0.  This indicates to the client that the server was unable\n    \
    \  to check that particular access right.  The ACCESS4_DELETE bit in\n      the\
    \ access mask returned will then be ignored by the client.\n   ERRORS\n      \
    \   NFS4ERR_ACCES\n         NFS4ERR_BADHANDLE\n         NFS4ERR_DELAY\n      \
    \   NFS4ERR_FHEXPIRED\n         NFS4ERR_IO\n         NFS4ERR_MOVED\n         NFS4ERR_NOFILEHANDLE\n\
    \         NFS4ERR_RESOURCE\n         NFS4ERR_SERVERFAULT\n         NFS4ERR_STALE\n\
    \         NFS4ERR_WRONGSEC\n"
- title: '14.2.2.  Operation 4: CLOSE - Close File'
  contents:
  - "14.2.2.  Operation 4: CLOSE - Close File\n   SYNOPSIS\n         (cfh), seqid,\
    \ stateid -> stateid\n   ARGUMENT\n         struct CLOSE4args {\n            \
    \     /* CURRENT_FH: object */\n                 seqid4          seqid\n     \
    \            stateid4        stateid;\n         };\n   RESULT\n         union\
    \ CLOSE4res switch (nfsstat4 status) {\n          case NFS4_OK:\n            \
    \      stateid4       stateid;\n          default:\n                  void;\n\
    \         };\n   DESCRIPTION\n      The CLOSE operation releases share reservations\
    \ for the file as\n      specified by the current filehandle.  The share reservations\
    \ and\n      other state information released at the server as a result of this\n\
    \      CLOSE is only associated with the supplied stateid.  The sequence\n   \
    \   id provides for the correct ordering. State associated with other\n      OPENs\
    \ is not affected.\n      If record locks are held, the client SHOULD release\
    \ all locks\n      before issuing a CLOSE.  The server MAY free all outstanding\
    \ locks\n      on CLOSE but some servers may not support the CLOSE of a file that\n\
    \      still has record locks held.  The server MUST return failure if\n     \
    \ any locks would exist after the CLOSE.\n      On success, the current filehandle\
    \ retains its value.\n   IMPLEMENTATION\n      ERRORS\n         NFS4ERR_BADHANDLE\n\
    \         NFS4ERR_BAD_SEQID\n         NFS4ERR_BAD_STATEID\n         NFS4ERR_DELAY\n\
    \         NFS4ERR_EXPIRED\n         NFS4ERR_FHEXPIRED\n         NFS4ERR_GRACE\n\
    \         NFS4ERR_INVAL\n         NFS4ERR_ISDIR\n         NFS4ERR_LEASE_MOVED\n\
    \         NFS4ERR_MOVED\n         NFS4ERR_NOFILEHANDLE\n         NFS4ERR_OLD_STATEID\n\
    \         NFS4ERR_RESOURCE\n         NFS4ERR_SERVERFAULT\n         NFS4ERR_STALE\n\
    \         NFS4ERR_STALE_STATEID\n"
- title: '14.2.3.  Operation 5: COMMIT - Commit Cached Data'
  contents:
  - "14.2.3.  Operation 5: COMMIT - Commit Cached Data\n   SYNOPSIS\n         (cfh),\
    \ offset, count -> verifier\n   ARGUMENT\n         struct COMMIT4args {\n    \
    \             /* CURRENT_FH: file */\n                 offset4         offset;\n\
    \                 count4          count;\n         };\n   RESULT\n         struct\
    \ COMMIT4resok {\n                 verifier4       writeverf;\n         };\n \
    \        union COMMIT4res switch (nfsstat4 status) {\n          case NFS4_OK:\n\
    \                  COMMIT4resok   resok4;\n          default:\n              \
    \    void;\n         };\n   DESCRIPTION\n      The COMMIT operation forces or\
    \ flushes data to stable storage for\n      the file specified by the current\
    \ file handle.  The flushed data\n      is that which was previously written with\
    \ a WRITE operation which\n      had the stable field set to UNSTABLE4.\n    \
    \  The offset specifies the position within the file where the flush\n      is\
    \ to begin.  An offset value of 0 (zero) means to flush data\n      starting at\
    \ the beginning of the file.  The count specifies the\n      number of bytes of\
    \ data to flush.  If count is 0 (zero), a flush\n      from offset to the end\
    \ of the file is done.\n      The server returns a write verifier upon successful\
    \ completion of\n      the COMMIT.  The write verifier is used by the client to\
    \ determine\n      if the server has restarted or rebooted between the initial\n\
    \      WRITE(s) and the COMMIT.  The client does this by comparing the\n     \
    \ write verifier returned from the initial writes and the verifier\n      returned\
    \ by the COMMIT procedure.  The server must vary the value\n      of the write\
    \ verifier at each server event or instantiation that\n      may lead to a loss\
    \ of uncommitted data.  Most commonly this occurs\n      when the server is rebooted;\
    \ however, other events at the server\n      may result in uncommitted data loss\
    \ as well.\n      On success, the current filehandle retains its value.\n   IMPLEMENTATION\n\
    \      The COMMIT procedure is similar in operation and semantics to the\n   \
    \   POSIX fsync(2) system call that synchronizes a file's state with\n      the\
    \ disk (file data and metadata is flushed to disk or stable\n      storage). COMMIT\
    \ performs the same operation for a client,\n      flushing any unsynchronized\
    \ data and metadata on the server to the\n      server's disk or stable storage\
    \ for the specified file.  Like\n      fsync(2), it may be that there is some\
    \ modified data or no\n      modified data to synchronize.  The data may have\
    \ been synchronized\n      by the server's normal periodic buffer synchronization\
    \ activity.\n      COMMIT should return NFS4_OK, unless there has been an unexpected\n\
    \      error.\n      COMMIT differs from fsync(2) in that it is possible for the\
    \ client\n      to flush a range of the file (most likely triggered by a buffer-\n\
    \      reclamation scheme on the client before file has been completely\n    \
    \  written).\n      The server implementation of COMMIT is reasonably simple.\
    \  If the\n      server receives a full file COMMIT request, that is starting\
    \ at\n      offset 0 and count 0, it should do the equivalent of fsync()'ing\n\
    \      the file.  Otherwise, it should arrange to have the cached data in\n  \
    \    the range specified by offset and count to be flushed to stable\n      storage.\
    \  In both cases, any metadata associated with the file\n      must be flushed\
    \ to stable storage before returning.  It is not an\n      error for there to\
    \ be nothing to flush on the server.  This means\n      that the data and metadata\
    \ that needed to be flushed have already\n      been flushed or lost during the\
    \ last server failure.\n      The client implementation of COMMIT is a little\
    \ more complex.\n      There are two reasons for wanting to commit a client buffer\
    \ to\n      stable storage.  The first is that the client wants to reuse a\n \
    \     buffer.  In this case, the offset and count of the buffer are sent\n   \
    \   to the server in the COMMIT request.  The server then flushes any\n      cached\
    \ data based on the offset and count, and flushes any\n      metadata associated\
    \ with the file.  It then returns the status of\n      the flush and the write\
    \ verifier.  The other reason for the client\n      to generate a COMMIT is for\
    \ a full file flush, such as may be done\n      at close.  In this case, the client\
    \ would gather all of the\n      buffers for this file that contain uncommitted\
    \ data, do the COMMIT\n      operation with an offset of 0 and count of 0, and\
    \ then free all of\n      those buffers.  Any other dirty buffers would be sent\
    \ to the\n      server in the normal fashion.\n      After a buffer is written\
    \ by the client with the stable parameter\n      set to UNSTABLE4, the buffer\
    \ must be considered as modified by the\n      client until the buffer has either\
    \ been flushed via a COMMIT\n      operation or written via a WRITE operation\
    \ with stable parameter\n      set to FILE_SYNC4 or DATA_SYNC4. This is done to\
    \ prevent the\n      buffer from being freed and reused before the data can be\
    \ flushed\n      to stable storage on the server.\n      When a response is returned\
    \ from either a WRITE or a COMMIT\n      operation and it contains a write verifier\
    \ that is different than\n      previously returned by the server, the client\
    \ will need to\n      retransmit all of the buffers containing uncommitted cached\
    \ data\n      to the server.  How this is to be done is up to the implementor.\n\
    \      If there is only one buffer of interest, then it should probably\n    \
    \  be sent back over in a WRITE request with the appropriate stable\n      parameter.\
    \  If there is more than one buffer, it might be\n      worthwhile retransmitting\
    \ all of the buffers in WRITE requests\n      with the stable parameter set to\
    \ UNSTABLE4 and then retransmitting\n      the COMMIT operation to flush all of\
    \ the data on the server to\n      stable storage.  The timing of these retransmissions\
    \ is left to\n      the implementor.\n      The above description applies to page-cache-based\
    \ systems as well\n      as buffer-cache-based systems.  In those systems, the\
    \ virtual\n      memory system will need to be modified instead of the buffer\n\
    \      cache.\n   ERRORS\n         NFS4ERR_ACCES\n         NFS4ERR_BADHANDLE\n\
    \         NFS4ERR_FHEXPIRED\n         NFS4ERR_IO\n         NFS4ERR_ISDIR\n   \
    \      NFS4ERR_LOCKED\n         NFS4ERR_MOVED\n         NFS4ERR_NOFILEHANDLE\n\
    \         NFS4ERR_RESOURCE\n         NFS4ERR_ROFS\n         NFS4ERR_SERVERFAULT\n\
    \         NFS4ERR_STALE\n         NFS4ERR_WRONGSEC\n"
- title: '14.2.4.  Operation 6: CREATE - Create a Non-Regular File Object'
  contents:
  - "14.2.4.  Operation 6: CREATE - Create a Non-Regular File Object\n   SYNOPSIS\n\
    \         (cfh), name, type -> (cfh), change_info\n   ARGUMENT\n         union\
    \ createtype4 switch (nfs_ftype4 type) {\n          case NF4LNK:\n           \
    \       linktext4      linkdata;\n          case NF4BLK:\n          case NF4CHR:\n\
    \                  specdata4      devdata;\n          case NF4SOCK:\n        \
    \  case NF4FIFO:\n          case NF4DIR:\n                  void;\n         };\n\
    \         struct CREATE4args {\n                 /* CURRENT_FH: directory for\
    \ creation */\n                 component4      objname;\n                 createtype4\
    \     objtype;\n         };\n   RESULT\n         struct CREATE4resok {\n     \
    \            change_info4     cinfo;\n         };\n         union CREATE4res switch\
    \ (nfsstat4 status) {\n          case NFS4_OK:\n                  CREATE4resok\
    \ resok4;\n          default:\n                  void;\n         };\n   DESCRIPTION\n\
    \      The CREATE operation creates a non-regular file object in a\n      directory\
    \ with a given name.  The OPEN procedure MUST be used to\n      create a regular\
    \ file.\n      The objname specifies the name for the new object.  If the objname\n\
    \      has a length of 0 (zero), the error NFS4ERR_INVAL will be\n      returned.\
    \  The objtype determines the type of object to be\n      created: directory,\
    \ symlink, etc.\n      If an object of the same name already exists in the directory,\
    \ the\n      server will return the error NFS4ERR_EXIST.\n      For the directory\
    \ where the new file object was created, the\n      server returns change_info4\
    \ information in cinfo.  With the atomic\n      field of the change_info4 struct,\
    \ the server will indicate if the\n      before and after change attributes were\
    \ obtained atomically with\n      respect to the file object creation.\n     \
    \ If the objname has a length of 0 (zero), or if objname does not\n      obey\
    \ the UTF-8 definition, the error NFS4ERR_INVAL will be\n      returned.\n   \
    \   The current filehandle is replaced by that of the new object.\n   IMPLEMENTATION\n\
    \      If the client desires to set attribute values after the create, a\n   \
    \   SETATTR operation can be added to the COMPOUND request so that the\n     \
    \ appropriate attributes will be set.\n   ERRORS\n         NFS4ERR_ACCES\n   \
    \      NFS4ERR_BADHANDLE\n         NFS4ERR_BADTYPE\n         NFS4ERR_DQUOT\n \
    \        NFS4ERR_EXIST\n         NFS4ERR_FHEXPIRED\n         NFS4ERR_INVAL\n \
    \        NFS4ERR_IO\n         NFS4ERR_MOVED\n         NFS4ERR_NAMETOOLONG\n  \
    \       NFS4ERR_NOFILEHANDLE\n         NFS4ERR_NOSPC\n         NFS4ERR_NOTDIR\n\
    \         NFS4ERR_NOTSUPP\n         NFS4ERR_RESOURCE\n         NFS4ERR_ROFS\n\
    \         NFS4ERR_SERVERFAULT\n         NFS4ERR_STALE\n         NFS4ERR_WRONGSEC\n"
- title: '14.2.5.  Operation 7: DELEGPURGE - Purge Delegations Awaiting Recovery'
  contents:
  - "14.2.5.  Operation 7: DELEGPURGE - Purge Delegations Awaiting Recovery\n   SYNOPSIS\n\
    \         clientid ->\n   ARGUMENT\n         struct DELEGPURGE4args {\n      \
    \           clientid4       clientid;\n        };\n   RESULT\n         struct\
    \ DELEGPURGE4res {\n                 nfsstat4        status;\n         };\n  \
    \ DESCRIPTION\n      Purges all of the delegations awaiting recovery for a given\n\
    \      client.  This is useful for clients which do not commit delegation\n  \
    \    information to stable storage to indicate that conflicting\n      requests\
    \ need not be delayed by the server awaiting recovery of\n      delegation information.\n\
    \      This operation should be used by clients that record delegation\n     \
    \ information on stable storage on the client.  In this case,\n      DELEGPURGE\
    \ should be issued immediately after doing delegation\n      recovery on all delegations\
    \ know to the client.  Doing so will\n      notify the server that no additional\
    \ delegations for the client\n      will be recovered allowing it to free resources,\
    \ and avoid\n      delaying other clients who make requests that conflict with\
    \ the\n      unrecovered delegations.  The set of delegations known to the\n \
    \     server and the client may be different.  The reason for this is\n      that\
    \ a client may fail after making a request which resulted in\n      delegation\
    \ but before it received the results and committed them\n      to the client's\
    \ stable storage.\n   ERRORS\n      NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n\
    \      NFS4ERR_STALE_CLIENTID\n"
- title: '14.2.6.  Operation 8: DELEGRETURN - Return Delegation'
  contents:
  - "14.2.6.  Operation 8: DELEGRETURN - Return Delegation\n   SYNOPSIS\n        \
    \ stateid ->\n   ARGUMENT\n         struct DELEGRETURN4args {\n              \
    \   stateid4        stateid;\n         };\n   RESULT\n         struct DELEGRETURN4res\
    \ {\n                 nfsstat4        status;\n         };\n   DESCRIPTION\n \
    \     Returns the delegation represented by the given stateid.\n   ERRORS\n  \
    \       NFS4ERR_BAD_STATEID\n         NFS4ERR_OLD_STATEID\n         NFS4ERR_RESOURCE\n\
    \         NFS4ERR_SERVERFAULT\n         NFS4ERR_STALE_STATEID\n"
- title: '14.2.7.  Operation 9: GETATTR - Get Attributes'
  contents:
  - "14.2.7.  Operation 9: GETATTR - Get Attributes\n   SYNOPSIS\n         (cfh),\
    \ attrbits -> attrbits, attrvals\n   ARGUMENT\n         struct GETATTR4args {\n\
    \                 /* CURRENT_FH: directory or file */\n                 bitmap4\
    \         attr_request;\n         };\n   RESULT\n         struct GETATTR4resok\
    \ {\n                 fattr4          obj_attributes;\n         };\n         union\
    \ GETATTR4res switch (nfsstat4 status) {\n          case NFS4_OK:\n          \
    \        GETATTR4resok  resok4;\n          default:\n                  void;\n\
    \         };\n   DESCRIPTION\n      The GETATTR operation will obtain attributes\
    \ for the file system\n      object specified by the current filehandle.  The\
    \ client sets a bit\n      in the bitmap argument for each attribute value that\
    \ it would like\n      the server to return.  The server returns an attribute\
    \ bitmap that\n      indicates the attribute values for which it was able to return,\n\
    \      followed by the attribute values ordered lowest attribute number\n    \
    \  first.\n      The server must return a value for each attribute that the client\n\
    \      requests if the attribute is supported by the server.  If the\n      server\
    \ does not support an attribute or cannot approximate a\n      useful value then\
    \ it must not return the attribute value and must\n      not set the attribute\
    \ bit in the result bitmap.  The server must\n      return an error if it supports\
    \ an attribute but cannot obtain its\n      value.  In that case no attribute\
    \ values will be returned.\n      All servers must support the mandatory attributes\
    \ as specified in\n      the section \"File Attributes\".\n      On success, the\
    \ current filehandle retains its value.\n   IMPLEMENTATION\n   ERRORS\n      \
    \   NFS4ERR_ACCES\n         NFS4ERR_BADHANDLE\n         NFS4ERR_DELAY\n      \
    \   NFS4ERR_FHEXPIRED\n         NFS4ERR_INVAL\n         NFS4ERR_IO\n         NFS4ERR_MOVED\n\
    \         NFS4ERR_NOFILEHANDLE\n         NFS4ERR_RESOURCE\n         NFS4ERR_SERVERFAULT\n\
    \         NFS4ERR_STALE\n         NFS4ERR_WRONGSEC\n"
- title: '14.2.8.  Operation 10: GETFH - Get Current Filehandle'
  contents:
  - "14.2.8.  Operation 10: GETFH - Get Current Filehandle\n   SYNOPSIS\n        \
    \ (cfh) -> filehandle\n   ARGUMENT\n         /* CURRENT_FH: */\n         void;\n\
    \   RESULT\n         struct GETFH4resok {\n                 nfs_fh4         object;\n\
    \         };\n         union GETFH4res switch (nfsstat4 status) {\n          case\
    \ NFS4_OK:\n                 GETFH4resok     resok4;\n          default:\n   \
    \              void;\n         };\n   DESCRIPTION\n         This operation returns\
    \ the current filehandle value.\n         On success, the current filehandle retains\
    \ its value.\n   IMPLEMENTATION\n      Operations that change the current filehandle\
    \ like LOOKUP or\n      CREATE do not automatically return the new filehandle\
    \ as a result.\n      For instance, if a client needs to lookup a directory entry\
    \ and\n      obtain its filehandle then the following request is needed.\n   \
    \            PUTFH  (directory filehandle)\n               LOOKUP (entry name)\n\
    \               GETFH\n   ERRORS\n      NFS4ERR_BADHANDLE\n      NFS4ERR_FHEXPIRED\n\
    \      NFS4ERR_MOVED\n      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_RESOURCE\n   \
    \   NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n      NFS4ERR_WRONGSEC\n"
- title: '14.2.9.  Operation 11: LINK - Create Link to a File'
  contents:
  - "14.2.9.  Operation 11: LINK - Create Link to a File\n   SYNOPSIS\n      (sfh),\
    \ (cfh), newname -> (cfh), change_info\n   ARGUMENT\n      struct LINK4args {\n\
    \              /* SAVED_FH: source object */\n              /* CURRENT_FH: target\
    \ directory */\n              component4      newname;\n      };\n   RESULT\n\
    \      struct LINK4resok {\n              change_info4    cinfo;\n      };\n \
    \     union LINK4res switch (nfsstat4 status) {\n       case NFS4_OK:\n      \
    \         LINK4resok resok4;\n       default:\n               void;\n      };\n\
    \   DESCRIPTION\n      The LINK operation creates an additional newname for the\
    \ file\n      represented by the saved filehandle, as set by the SAVEFH\n    \
    \  operation, in the directory represented by the current filehandle.\n      The\
    \ existing file and the target directory must reside within the\n      same file\
    \ system on the server.  On success, the current\n      filehandle will continue\
    \ to be the target directory.\n      For the target directory, the server returns\
    \ change_info4\n      information in cinfo.  With the atomic field of the change_info4\n\
    \      struct, the server will indicate if the before and after change\n     \
    \ attributes were obtained atomically with respect to the link\n      creation.\n\
    \      If the newname has a length of 0 (zero), or if newname does not\n     \
    \ obey the UTF-8 definition, the error NFS4ERR_INVAL will be\n      returned.\n\
    \   IMPLEMENTATION\n      Changes to any property of the \"hard\" linked files\
    \ are reflected\n      in all of the linked files.  When a link is made to a file,\
    \ the\n      attributes for the file should have a value for numlinks that is\n\
    \      one greater than the value before the LINK operation.\n      The comments\
    \ under RENAME regarding object and target residing on\n      the same file system\
    \ apply here as well. The comments regarding\n      the target name applies as\
    \ well.\n      Note that symbolic links are created with the CREATE operation.\n\
    \   ERRORS\n      NFS4ERR_ACCES NFS4ERR_BADHANDLE NFS4ERR_DELAY NFS4ERR_DQUOT\n\
    \      NFS4ERR_EXIST NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_IO\n      NFS4ERR_ISDIR\
    \ NFS4ERR_MLINK NFS4ERR_MOVED NFS4ERR_NAMETOOLONG\n      NFS4ERR_NOFILEHANDLE\
    \ NFS4ERR_NOSPC NFS4ERR_NOTDIR NFS4ERR_NOTSUPP\n      NFS4ERR_RESOURCE NFS4ERR_ROFS\
    \ NFS4ERR_SERVERFAULT NFS4ERR_STALE\n      NFS4ERR_WRONGSEC NFS4ERR_XDEV\n"
- title: '14.2.10.  Operation 12: LOCK - Create Lock'
  contents:
  - "14.2.10.  Operation 12: LOCK - Create Lock\n   SYNOPSIS\n      (cfh) type, seqid,\
    \ reclaim, stateid, offset, length -> stateid,\n      access\n   ARGUMENT\n  \
    \    enum nfs4_lock_type {\n              READ_LT         = 1,\n             \
    \ WRITE_LT        = 2,\n              READW_LT        = 3,    /* blocking read\
    \ */\n              WRITEW_LT       = 4     /* blocking write */ };\n      struct\
    \ LOCK4args {\n              /* CURRENT_FH: file */\n              nfs_lock_type4\
    \  locktype;\n              seqid4          seqid;\n              bool       \
    \     reclaim;\n              stateid4        stateid;\n              offset4\
    \         offset;\n              length4         length; };\n   RESULT\n     \
    \ struct LOCK4denied {\n              nfs_lockowner4  owner;\n              offset4\
    \         offset;\n              length4         length; };\n      union LOCK4res\
    \ switch (nfsstat4 status) {\n       case NFS4_OK:\n               stateid4  \
    \     stateid;\n       case NFS4ERR_DENIED:\n               LOCK4denied    denied;\n\
    \       default:\n               void; };\n   DESCRIPTION\n      The LOCK operation\
    \ requests a record lock for the byte range\n      specified by the offset and\
    \ length parameters.  The lock type is\n      also specified to be one of the\
    \ nfs4_lock_types.  If this is a\n      reclaim request, the reclaim parameter\
    \ will be TRUE;\n      Bytes in a file may be locked even if those bytes are not\n\
    \      currently allocated to the file.  To lock the file from a specific\n  \
    \    offset through the end-of-file (no matter how long the file\n      actually\
    \ is) use a length field with all bits set to 1 (one).  To\n      lock the entire\
    \ file, use an offset of 0 (zero) and a length with\n      all bits set to 1.\
    \  A length of 0 is reserved and should not be\n      used.\n      In the case\
    \ that the lock is denied, the owner, offset, and length\n      of a conflicting\
    \ lock are returned.\n      On success, the current filehandle retains its value.\n\
    \   IMPLEMENTATION\n      If the server is unable to determine the exact offset\
    \ and length\n      of the conflicting lock, the same offset and length that were\n\
    \      provided in the arguments should be returned in the denied\n      results.\
    \  The File Locking section contains a full description of\n      this and the\
    \ other file locking operations.\n   ERRORS\n      NFS4ERR_ACCES NFS4ERR_BADHANDLE\
    \ NFS4ERR_BAD_SEQID\n      NFS4ERR_BAD_STATEID NFS4ERR_DELAY NFS4ERR_DENIED NFS4ERR_EXPIRED\n\
    \      NFS4ERR_FHEXPIRED NFS4ERR_GRACE NFS4ERR_INVAL NFS4ERR_ISDIR\n      NFS4ERR_LEASE_MOVED\
    \ NFS4ERR_LOCK_RANGE NFS4ERR_MOVED\n      NFS4ERR_NOFILEHANDLE NFS4ERR_OLD_STATEID\
    \ NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT NFS4ERR_STALE NFS4ERR_STALE_CLIENTID\n\
    \      NFS4ERR_STALE_STATEID NFS4ERR_WRONGSEC\n"
- title: '14.2.11.  Operation 13: LOCKT - Test For Lock'
  contents:
  - "14.2.11.  Operation 13: LOCKT - Test For Lock\n   SYNOPSIS\n      (cfh) type,\
    \ owner, offset, length -> {void, NFS4ERR_DENIED ->\n      owner}\n   ARGUMENT\n\
    \      struct LOCKT4args {\n              /* CURRENT_FH: file */\n           \
    \   nfs_lock_type4  locktype;\n              nfs_lockowner4  owner;\n        \
    \      offset4         offset;\n              length4         length; };\n   RESULT\n\
    \      union LOCKT4res switch (nfsstat4 status) {\n       case NFS4ERR_DENIED:\n\
    \               LOCK4denied    denied;\n       case NFS4_OK:\n               void;\n\
    \       default:\n               void; };\n   DESCRIPTION\n      The LOCKT operation\
    \ tests the lock as specified in the arguments.\n      If a conflicting lock exists,\
    \ the owner, offset, and length of the\n      conflicting lock are returned; if\
    \ no lock is held, nothing other\n      than NFS4_OK is returned.\n      On success,\
    \ the current filehandle retains its value.\n   IMPLEMENTATION\n      If the server\
    \ is unable to determine the exact offset and length\n      of the conflicting\
    \ lock, the same offset and length that were\n      provided in the arguments\
    \ should be returned in the denied\n      results.  The File Locking section contains\
    \ further discussion of\n      the file locking mechanisms.\n      LOCKT uses\
    \ nfs_lockowner4 instead of a stateid4, as LOCK does, to\n      identify the owner\
    \ so that the client does not have to open the\n      file to test for the existence\
    \ of a lock.\n   ERRORS\n      NFS4ERR_ACCES\n      NFS4ERR_BADHANDLE\n      NFS4ERR_DELAY\n\
    \      NFS4ERR_DENIED\n      NFS4ERR_FHEXPIRED\n      NFS4ERR_GRACE\n      NFS4ERR_INVAL\n\
    \      NFS4ERR_ISDIR\n      NFS4ERR_LEASE_MOVED\n      NFS4ERR_LOCK_RANGE\n  \
    \    NFS4ERR_MOVED\n      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_RESOURCE\n     \
    \ NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n      NFS4ERR_STALE_CLIENTID\n   \
    \   NFS4ERR_WRONGSEC\n"
- title: '14.2.12.  Operation 14: LOCKU - Unlock File'
  contents:
  - "14.2.12.  Operation 14: LOCKU - Unlock File\n   SYNOPSIS\n      (cfh) type, seqid,\
    \ stateid, offset, length -> stateid\n   ARGUMENT\n      struct LOCKU4args {\n\
    \              /* CURRENT_FH: file */\n              nfs_lock_type4  locktype;\n\
    \              seqid4          seqid;\n              stateid4        stateid;\n\
    \              offset4         offset;\n              length4         length;\n\
    \      };\n   RESULT\n      union LOCKU4res switch (nfsstat4 status) {\n     \
    \  case   NFS4_OK:\n               stateid4       stateid;\n       default:\n\
    \               void;\n      };\n   DESCRIPTION\n      The LOCKU operation unlocks\
    \ the record lock specified by the\n      parameters.\n      On success, the current\
    \ filehandle retains its value.\n   IMPLEMENTATION\n      The File Locking section\
    \ contains a full description of this and\n      the other file locking procedures.\n\
    \   ERRORS\n      NFS4ERR_ACCES\n      NFS4ERR_BADHANDLE\n      NFS4ERR_BAD_SEQID\n\
    \      NFS4ERR_BAD_STATEID\n      NFS4ERR_EXPIRED\n      NFS4ERR_FHEXPIRED\n \
    \     NFS4ERR_GRACE\n      NFS4ERR_INVAL\n      NFS4ERR_LOCK_RANGE\n      NFS4ERR_LEASE_MOVED\n\
    \      NFS4ERR_MOVED\n      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_OLD_STATEID\n\
    \      NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n    \
    \  NFS4ERR_STALE_CLIENTID\n      NFS4ERR_STALE_STATEID\n"
- title: '14.2.13.  Operation 15: LOOKUP - Lookup Filename'
  contents:
  - "14.2.13.  Operation 15: LOOKUP - Lookup Filename\n   SYNOPSIS\n      (cfh), filenames\
    \ -> (cfh)\n   ARGUMENT\n      struct LOOKUP4args {\n              /* CURRENT_FH:\
    \ directory */\n              pathname4       path;\n      };\n   RESULT\n   \
    \   struct LOOKUP4res {\n              /* CURRENT_FH: object */\n            \
    \  nfsstat4        status;\n      };\n   DESCRIPTION\n      This operation LOOKUPs\
    \ or finds a file system object starting from\n      the directory specified by\
    \ the current filehandle.  LOOKUP\n      evaluates the pathname contained in the\
    \ array of names and obtains\n      a new current filehandle from the final name.\
    \  All but the final\n      name in the list must be the names of directories.\n\
    \      If the pathname cannot be evaluated either because a component\n      does\
    \ not exist or because the client does not have permission to\n      evaluate\
    \ a component of the path, then an error will be returned\n      and the current\
    \ filehandle will be unchanged.\n      If the path is a zero length array, if\
    \ any component does not obey\n      the UTF-8 definition, or if any component\
    \ in the path is of zero\n      length, the error NFS4ERR_INVAL will be returned.\n\
    \   IMPLEMENTATION\n      If the client prefers a partial evaluation of the path\
    \ then a\n      sequence of LOOKUP operations can be substituted e.g.\n      \
    \         PUTFH  (directory filehandle)\n               LOOKUP \"pub\" \"foo\"\
    \ \"bar\"\n               GETFH\n      or, if the client wishes to obtain the\
    \ intermediate filehandles\n               PUTFH  (directory filehandle)\n   \
    \            LOOKUP \"pub\"\n               GETFH\n               LOOKUP \"foo\"\
    \n               GETFH\n               LOOKUP \"bar\"\n               GETFH\n\
    \      NFS version 4 servers depart from the semantics of previous NFS\n     \
    \ versions in allowing LOOKUP requests to cross mountpoints on the\n      server.\
    \  The client can detect a mountpoint crossing by comparing\n      the fsid attribute\
    \ of the directory with the fsid attribute of the\n      directory looked up.\
    \  If the fsids are different then the new\n      directory is a server mountpoint.\
    \  Unix clients that detect a\n      mountpoint crossing will need to mount the\
    \ server's filesystem.\n      This needs to be done to maintain the file object\
    \ identity\n      checking mechanisms common to Unix clients.\n      Servers that\
    \ limit NFS access to \"shares\" or \"exported\"\n      filesystems should provide\
    \ a pseudo-filesystem into which the\n      exported filesystems can be integrated,\
    \ so that clients can browse\n      the server's name space.  The clients view\
    \ of a pseudo filesystem\n      will be limited to paths that lead to exported\
    \ filesystems.\n      Note: previous versions of the protocol assigned special\
    \ semantics\n      to the names \".\" and \"..\".  NFS version 4 assigns no special\n\
    \      semantics to these names.  The LOOKUPP operator must be used to\n     \
    \ lookup a parent directory.\n      Note that this procedure does not follow symbolic\
    \ links.  The\n      client is responsible for all parsing of filenames including\n\
    \      filenames that are modified by symbolic links encountered during\n    \
    \  the lookup process.\n      If the current file handle supplied is not a directory\
    \ but a\n      symbolic link, the error NFS4ERR_SYMLINK is returned as the error.\n\
    \      For all other non-directory file types, the error NFS4ERR_NOTDIR\n    \
    \  is returned.\n   ERRORS\n      NFS4ERR_ACCES\n      NFS4ERR_BADHANDLE\n   \
    \   NFS4ERR_FHEXPIRED\n      NFS4ERR_INVAL\n      NFS4ERR_IO\n      NFS4ERR_MOVED\n\
    \      NFS4ERR_NAMETOOLONG\n      NFS4ERR_NOENT\n      NFS4ERR_NOFILEHANDLE\n\
    \      NFS4ERR_NOTDIR\n      NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n   \
    \   NFS4ERR_STALE\n      NFS4ERR_SYMLINK\n      NFS4ERR_WRONGSEC\n"
- title: '14.2.14.  Operation 16: LOOKUPP - Lookup Parent Directory'
  contents:
  - "14.2.14.  Operation 16: LOOKUPP - Lookup Parent Directory\n   SYNOPSIS\n    \
    \  (cfh) -> (cfh)\n   ARGUMENT\n      /* CURRENT_FH: object */\n      void;\n\
    \   RESULT\n      struct LOOKUPP4res {\n              /* CURRENT_FH: directory\
    \ */\n              nfsstat4        status;\n      };\n   DESCRIPTION\n      The\
    \ current filehandle is assumed to refer to a regular directory\n      or a named\
    \ attribute directory.  LOOKUPP assigns the filehandle\n      for its parent directory\
    \ to be the current filehandle.  If there\n      is no parent directory an NFS4ERR_ENOENT\
    \ error must be returned.\n      Therefore, NFS4ERR_ENOENT will be returned by\
    \ the server when the\n      current filehandle is at the root or top of the server's\
    \ file\n      tree.\n   IMPLEMENTATION\n      As for LOOKUP, LOOKUPP will also\
    \ cross mountpoints.\n      If the current filehandle is not a directory or named\
    \ attribute\n      directory, the error NFS4ERR_NOTDIR is returned.\n   ERRORS\n\
    \      NFS4ERR_ACCES\n      NFS4ERR_BADHANDLE\n      NFS4ERR_FHEXPIRED\n     \
    \ NFS4ERR_INVAL\n      NFS4ERR_IO\n      NFS4ERR_MOVED\n      NFS4ERR_NOENT\n\
    \      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_NOTDIR\n      NFS4ERR_RESOURCE\n  \
    \    NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n      NFS4ERR_WRONGSEC\n"
- title: '14.2.15.  Operation 17: NVERIFY - Verify Difference in Attributes'
  contents:
  - "14.2.15.  Operation 17: NVERIFY - Verify Difference in Attributes\n   SYNOPSIS\n\
    \      (cfh), fattr -> -\n   ARGUMENT\n      struct NVERIFY4args {\n         \
    \     /* CURRENT_FH: object */\n              fattr4          obj_attributes;\n\
    \      };\n   RESULT\n      struct NVERIFY4res {\n              nfsstat4     \
    \   status;\n      };\n   DESCRIPTION\n      This operation is used to prefix\
    \ a sequence of operations to be\n      performed if one or more attributes have\
    \ changed on some\n      filesystem object.  If all the attributes match then\
    \ the error\n      NFS4ERR_SAME must be returned.\n      On success, the current\
    \ filehandle retains its value.\n   IMPLEMENTATION\n      This operation is useful\
    \ as a cache validation operator.  If the\n      object to which the attributes\
    \ belong has changed then the\n      following operations may obtain new data\
    \ associated with that\n      object.  For instance, to check if a file has been\
    \ changed and\n      obtain new data if it has:\n               PUTFH  (public)\n\
    \               LOOKUP \"pub\" \"foo\" \"bar\"\n               NVERIFY attrbits\
    \ attrs\n               READ 0 32767\n      In the case that a recommended attribute\
    \ is specified in the\n      NVERIFY operation and the server does not support\
    \ that attribute\n      for the file system object, the error NFS4ERR_NOTSUPP\
    \ is returned\n      to the client.\n   ERRORS\n      NFS4ERR_ACCES\n      NFS4ERR_BADHANDLE\n\
    \      NFS4ERR_DELAY\n      NFS4ERR_FHEXPIRED\n      NFS4ERR_INVAL\n      NFS4ERR_IO\n\
    \      NFS4ERR_MOVED\n      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_NOTSUPP\n    \
    \  NFS4ERR_RESOURCE\n      NFS4ERR_SAME\n      NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n\
    \      NFS4ERR_WRONGSEC\n"
- title: '14.2.16.  Operation 18: OPEN - Open a Regular File'
  contents:
  - "14.2.16.  Operation 18: OPEN - Open a Regular File\n   SYNOPSIS\n  (cfh), claim,\
    \ openhow, owner, seqid, access, deny -> (cfh),\n  stateid, cinfo, rflags, open_confirm,\
    \ delegation\n   ARGUMENT\n  struct OPEN4args {\n          open_claim4     claim;\n\
    \          openflag4       openhow;\n          nfs_lockowner4  owner;\n      \
    \    seqid4          seqid;\n          uint32_t        share_access;\n       \
    \   uint32_t        share_deny;\n  };\n  enum createmode4 {\n          UNCHECKED4\
    \      = 0,\n          GUARDED4        = 1,\n          EXCLUSIVE4      = 2\n \
    \ };\n  union createhow4 switch (createmode4 mode) {\n   case UNCHECKED4:\n  \
    \ case GUARDED4:\n           fattr4         createattrs;\n   case EXCLUSIVE4:\n\
    \           verifier4      createverf;\n  };\n  enum opentype4 {\n          OPEN4_NOCREATE\
    \  = 0,\n          OPEN4_CREATE    = 1\n  };\n  union openflag4 switch (opentype4\
    \ opentype) {\n   case OPEN4_CREATE:\n           createhow4     how;\n   default:\n\
    \           void;\n  };\n  /* Next definitions used for OPEN delegation */\n \
    \ enum limit_by4 {\n          NFS_LIMIT_SIZE          = 1,\n          NFS_LIMIT_BLOCKS\
    \        = 2\n          /* others as needed */\n  };\n  struct nfs_modified_limit4\
    \ {\n          uint32_t        num_blocks;\n          uint32_t        bytes_per_block;\n\
    \  };\n  union nfs_space_limit4 switch (limit_by4 limitby) {\n   /* limit specified\
    \ as file size */\n   case NFS_LIMIT_SIZE:\n           uint64_t              \
    \ filesize;\n   /* limit specified by number of blocks */\n   case NFS_LIMIT_BLOCKS:\n\
    \           nfs_modified_limit4    mod_blocks;\n  } ;\n  enum open_delegation_type4\
    \ {\n          OPEN_DELEGATE_NONE      = 0,\n          OPEN_DELEGATE_READ    \
    \  = 1,\n          OPEN_DELEGATE_WRITE     = 2\n  };\n  enum open_claim_type4\
    \ {\n          CLAIM_NULL              = 0,\n          CLAIM_PREVIOUS        \
    \  = 1,\n          CLAIM_DELEGATE_CUR      = 2,\n          CLAIM_DELEGATE_PREV\
    \     = 3\n  };\n  struct open_claim_delegate_cur4 {\n          pathname4    \
    \   file;\n          stateid4        delegate_stateid;\n  };\n  union open_claim4\
    \ switch (open_claim_type4 claim) {\n   /*\n    * No special rights to file. Ordinary\
    \ OPEN of the specified file.\n    */\n   case CLAIM_NULL:\n           /* CURRENT_FH:\
    \ directory */\n           pathname4      file;\n   /*\n    * Right to the file\
    \ established by an open previous to server\n    * reboot.  File identified by\
    \ filehandle obtained at that time\n    * rather than by name.\n    */\n   case\
    \ CLAIM_PREVIOUS:\n           /* CURRENT_FH: file being reclaimed */\n       \
    \    uint32_t        delegate_type;\n   /*\n    * Right to file based on a delegation\
    \ granted by the server.\n    * File is specified by name.\n    */\n   case CLAIM_DELEGATE_CUR:\n\
    \           /* CURRENT_FH: directory */\n           open_claim_delegate_cur4 \
    \      delegate_cur_info;\n   /* Right to file based on a delegation granted to\
    \ a previous boot\n    * instance of the client.  File is specified by name.\n\
    \    */\n   case CLAIM_DELEGATE_PREV:\n           /* CURRENT_FH: directory */\n\
    \           pathname4      file_delegate_prev;\n  };\n   RESULT\n  struct open_read_delegation4\
    \ {\n          stateid4        stateid;        /* Stateid for delegation*/\n \
    \         bool            recall;         /* Pre-recalled flag for\n         \
    \                                    delegations obtained\n                  \
    \                           by reclaim\n                                     \
    \        (CLAIM_PREVIOUS) */\n          nfsace4         permissions;    /* Defines\
    \ users who don't\n                                             need an ACCESS\
    \ call to\n                                             open for read */\n  };\n\
    \  struct open_write_delegation4 {\n          stateid4        stateid;       \
    \ /* Stateid for delegation*/\n          bool            recall;         /* Pre-recalled\
    \ flag for\n                                             delegations obtained\n\
    \                                             by reclaim\n                   \
    \                          (CLAIM_PREVIOUS) */\n          nfs_space_limit4 space_limit;\
    \   /* Defines condition that\n                                             the\
    \ client must check to\n                                             determine\
    \ whether the\n                                             file needs to be flushed\n\
    \                                             to the server on close.\n      \
    \                                       */\n          nfsace4         permissions;\
    \    /* Defines users who don't\n                                            \
    \ need an ACCESS call as\n                                             part of\
    \ a delegated\n                                             open. */\n  };\n \
    \ union open_delegation4\n  switch (open_delegation_type4 delegation_type) {\n\
    \          case OPEN_DELEGATE_NONE:\n                  void;\n          case OPEN_DELEGATE_READ:\n\
    \                  open_read_delegation4 read;\n          case OPEN_DELEGATE_WRITE:\n\
    \                  open_write_delegation4 write;\n  };\n  const OPEN4_RESULT_MLOCK\
    \        = 0x00000001;\n  const OPEN4_RESULT_CONFIRM= 0x00000002;\n  struct OPEN4resok\
    \ {\n          stateid4        stateid;        /* Stateid for open */\n      \
    \    change_info4    cinfo;          /* Directory Change Info */\n          uint32_t\
    \        rflags;         /* Result flags */\n          verifier4       open_confirm;\
    \   /* OPEN_CONFIRM verifier */\n          open_delegation4 delegation;    /*\
    \ Info on any open\n                                             delegation */\n\
    \  };\n  union OPEN4res switch (nfsstat4 status) {\n   case NFS4_OK:\n       \
    \   /* CURRENT_FH: opened file */\n          OPEN4resok      resok4;\n   default:\n\
    \          void;\n  };\n   WARNING TO CLIENT IMPLEMENTORS\n      OPEN resembles\
    \ LOOKUP in that it generates a filehandle for the\n      client to use.  Unlike\
    \ LOOKUP though, OPEN creates server state on\n      the filehandle.  In normal\
    \ circumstances, the client can only\n      release this state with a CLOSE operation.\
    \  CLOSE uses the current\n      filehandle to determine which file to close.\
    \  Therefore the client\n      MUST follow every OPEN operation with a GETFH operation\
    \ in the\n      same COMPOUND procedure.  This will supply the client with the\n\
    \      filehandle such that CLOSE can be used appropriately.\n      Simply waiting\
    \ for the lease on the file to expire is insufficient\n      because the server\
    \ may maintain the state indefinitely as long as\n      another client does not\
    \ attempt to make a conflicting access to\n      the same file.\n   DESCRIPTION\n\
    \      The OPEN operation creates and/or opens a regular file in a\n      directory\
    \ with the provided name.  If the file does not exist at\n      the server and\
    \ creation is desired, specification of the method of\n      creation is provided\
    \ by the openhow parameter.  The client has the\n      choice of three creation\
    \ methods: UNCHECKED, GUARDED, or\n      EXCLUSIVE.\n      UNCHECKED means that\
    \ the file should be created if a file of that\n      name does not exist and\
    \ encountering an existing regular file of\n      that name is not an error. \
    \ For this type of create, createattrs\n      specifies the initial set of attributes\
    \ for the file.  The set of\n      attributes may includes any writable attribute\
    \ valid for regular\n      files.  When an UNCHECKED create encounters an existing\
    \ file, the\n      attributes specified by createattrs is not used, except that\
    \ when\n      an object_size of zero is specified, the existing file is\n    \
    \  truncated.  If GUARDED is specified, the server checks for the\n      presence\
    \ of a duplicate object by name before performing the\n      create.  If a duplicate\
    \ exists, an error of NFS4ERR_EXIST is\n      returned as the status.  If the\
    \ object does not exist, the request\n      is performed as described for UNCHECKED.\n\
    \      EXCLUSIVE specifies that the server is to follow exclusive\n      creation\
    \ semantics, using the verifier to ensure exclusive\n      creation of the target.\
    \  The server should check for the presence\n      of a duplicate object by name.\
    \  If the object does not exist, the\n      server creates the object and stores\
    \ the verifier with the object.\n      If the object does exist and the stored\
    \ verifier matches the\n      client provided verifier, the server uses the existing\
    \ object as\n      the newly created object.  If the stored verifier does not\
    \ match,\n      then an error of NFS4ERR_EXIST is returned.  No attributes may\
    \ be\n      provided in this case, since the server may use an attribute of\n\
    \      the target object to store the verifier.\n      For the target directory,\
    \ the server returns change_info4\n      information in cinfo.  With the atomic\
    \ field of the change_info4\n      struct, the server will indicate if the before\
    \ and after change\n      attributes were obtained atomically with respect to\
    \ the link\n      creation.\n      Upon successful creation, the current filehandle\
    \ is replaced by\n      that of the new object.\n      The OPEN procedure provides\
    \ for DOS SHARE capability with the use\n      of the access and deny fields of\
    \ the OPEN arguments.  The client\n      specifies at OPEN the required access\
    \ and deny modes.  For clients\n      that do not directly support SHAREs (i.e.\
    \ Unix), the expected deny\n      value is DENY_NONE.  In the case that there\
    \ is a existing SHARE\n      reservation that conflicts with the OPEN request,\
    \ the server\n      returns the error NFS4ERR_DENIED.  For a complete SHARE request,\n\
    \      the client must provide values for the owner and seqid fields for\n   \
    \   the OPEN argument.  For additional discussion of SHARE semantics\n      see\
    \ the section on 'Share Reservations'.\n      In the case that the client is recovering\
    \ state from a server\n      failure, the reclaim field of the OPEN argument is\
    \ used to signify\n      that the request is meant to reclaim state previously\
    \ held.\n      The \"claim\" field of the OPEN argument is used to specify the\
    \ file\n      to be opened and the state information which the client claims to\n\
    \      possess.  There are four basic claim types which cover the various\n  \
    \    situations for an OPEN.  They are as follows:\n      CLAIM_NULL\n       \
    \                     For the client, this is a new OPEN\n                   \
    \         request and there is no previous state\n                           \
    \ associate with the file for the client.\n      CLAIM_PREVIOUS\n            \
    \                The client is claiming basic OPEN state\n                   \
    \         for a file that was held previous to a\n                           \
    \ server reboot.  Generally used when a\n                            server is\
    \ returning persistent file\n                            handles; the client may\
    \ not have the\n                            file name to reclaim the OPEN.\n \
    \     CLAIM_DELEGATE_CUR\n                            The client is claiming a\
    \ delegation for\n                            OPEN as granted by the server.\n\
    \                            Generally this is done as part of\n             \
    \               recalling a delegation.\n      CLAIM_DELEGATE_PREV\n         \
    \                   The client is claiming a delegation\n                    \
    \        granted to a previous client instance;\n                            used\
    \ after the client reboots.\n      For OPEN requests whose claim type is other\
    \ than CLAIM_PREVIOUS\n      (i.e. requests other than those devoted to reclaiming\
    \ opens after\n      a server reboot) that reach the server during its grace or\
    \ lease\n      expiration period, the server returns an error of NFS4ERR_GRACE.\n\
    \      For any OPEN request, the server may return an open delegation,\n     \
    \ which allows further opens and closes to be handled locally on the\n      client\
    \ as described in the section Open Delegation.  Note that\n      delegation is\
    \ up to the server to decide.  The client should never\n      assume that delegation\
    \ will or will not be granted in a particular\n      instance.  It should always\
    \ be prepared for either case.  A\n      partial exception is the reclaim (CLAIM_PREVIOUS)\
    \ case, in which a\n      delegation type is claimed.  In this case, delegation\
    \ will always\n      be granted, although the server may specify an immediate\
    \ recall in\n      the delegation structure.\n      The rflags returned by a successful\
    \ OPEN allow the server to\n      return information governing how the open file\
    \ is to be handled.\n      OPEN4_RESULT_MLOCK indicates to the caller that mandatory\
    \ locking\n      is in effect for this file and the client should act appropriately\n\
    \      with regard to data cached on the client.  OPEN4_RESULT_CONFIRM\n     \
    \ indicates that the client MUST execute an OPEN_CONFIRM operation\n      before\
    \ using the open file.\n      If the file is a zero length array, if any component\
    \ does not obey\n      the UTF-8 definition, or if any component in the path is\
    \ of zero\n      length, the error NFS4ERR_INVAL will be returned.\n      When\
    \ an OPEN is done and the specified lockowner already has the\n      resulting\
    \ filehandle open, the result is to \"OR\" together the new\n      share and deny\
    \ status together with the existing status.  In this\n      case, only a single\
    \ CLOSE need be done, even though multiple\n      OPEN's were completed.\n   IMPLEMENTATION\n\
    \      The OPEN procedure contains support for EXCLUSIVE create.  The\n      mechanism\
    \ is similar to the support in NFS version 3 [RFC1813].\n      As in NFS version\
    \ 3, this mechanism provides reliable exclusive\n      creation.  Exclusive create\
    \ is invoked when the how parameter is\n      EXCLUSIVE.  In this case, the client\
    \ provides a verifier that can\n      reasonably be expected to be unique.  A\
    \ combination of a client\n      identifier, perhaps the client network address,\
    \ and a unique\n      number generated by the client, perhaps the RPC transaction\n\
    \      identifier, may be appropriate.\n      If the object does not exist, the\
    \ server creates the object and\n      stores the verifier in stable storage.\
    \ For file systems that do\n      not provide a mechanism for the storage of arbitrary\
    \ file\n      attributes, the server may use one or more elements of the object\n\
    \      meta-data to store the verifier. The verifier must be stored in\n     \
    \ stable storage to prevent erroneous failure on retransmission of\n      the\
    \ request. It is assumed that an exclusive create is being\n      performed because\
    \ exclusive semantics are critical to the\n      application. Because of the expected\
    \ usage, exclusive CREATE does\n      not rely solely on the normally volatile\
    \ duplicate request cache\n      for storage of the verifier. The duplicate request\
    \ cache in\n      volatile storage does not survive a crash and may actually flush\n\
    \      on a long network partition, opening failure windows.  In the UNIX\n  \
    \    local file system environment, the expected storage location for\n      the\
    \ verifier on creation is the meta-data (time stamps) of the\n      object. For\
    \ this reason, an exclusive object create may not\n      include initial attributes\
    \ because the server would have nowhere\n      to store the verifier.\n      If\
    \ the server can not support these exclusive create semantics,\n      possibly\
    \ because of the requirement to commit the verifier to\n      stable storage,\
    \ it should fail the OPEN request with the error,\n      NFS4ERR_NOTSUPP.\n  \
    \    During an exclusive CREATE request, if the object already exists,\n     \
    \ the server reconstructs the object's verifier and compares it with\n      the\
    \ verifier in the request. If they match, the server treats the\n      request\
    \ as a success. The request is presumed to be a duplicate of\n      an earlier,\
    \ successful request for which the reply was lost and\n      that the server duplicate\
    \ request cache mechanism did not detect.\n      If the verifiers do not match,\
    \ the request is rejected with the\n      status, NFS4ERR_EXIST.\n      Once the\
    \ client has performed a successful exclusive create, it\n      must issue a SETATTR\
    \ to set the correct object attributes.  Until\n      it does so, it should not\
    \ rely upon any of the object attributes,\n      since the server implementation\
    \ may need to overload object meta-\n      data to store the verifier.  The subsequent\
    \ SETATTR must not occur\n      in the same COMPOUND request as the OPEN.  This\
    \ separation will\n      guarantee that the exclusive create mechanism will continue\
    \ to\n      function properly in the face of retransmission of the request.\n\
    \      Use of the GUARDED attribute does not provide exactly-once\n      semantics.\
    \  In particular, if a reply is lost and the server does\n      not detect the\
    \ retransmission of the request, the procedure can\n      fail with NFS4ERR_EXIST,\
    \ even though the create was performed\n      successfully.\n      For SHARE reservations,\
    \ the client must specify a value for access\n      that is one of READ, WRITE,\
    \ or BOTH.  For deny, the client must\n      specify one of NONE, READ, WRITE,\
    \ or BOTH.  If the client fails to\n      do this, the server must return NFS4ERR_INVAL.\n\
    \      If the final component provided to OPEN is a symbolic link, the\n     \
    \ error NFS4ERR_SYMLINK will be returned to the client.  If an\n      intermediate\
    \ component of the pathname provided to OPEN is a\n      symbolic link, the error\
    \ NFS4ERR_NOTDIR will be returned to the\n      client.\n   ERRORS\n      NFS4ERR_ACCES\n\
    \      NFS4ERR_BAD_SEQID\n      NFS4ERR_DELAY\n      NFS4ERR_DQUOT\n      NFS4ERR_EXIST\n\
    \      NFS4ERR_FHEXPIRED\n      NFS4ERR_GRACE\n      NFS4ERR_IO\n      NFS4ERR_ISDIR\n\
    \      NFS4ERR_LEASE_MOVED\n      NFS4ERR_MOVED\n      NFS4ERR_NAMETOOLONG\n \
    \     NFS4ERR_NOFILEHANDLE\n      NFS4ERR_NOSPC\n      NFS4ERR_NOTDIR\n      NFS4ERR_NOTSUPP\n\
    \      NFS4ERR_RESOURCE\n      NFS4ERR_ROFS\n      NFS4ERR_SERVERFAULT\n     \
    \ NFS4ERR_SHARE_DENIED\n      NFS4ERR_STALE_CLIENTID\n      NFS4ERR_SYMLINK\n"
- title: '14.2.17.  Operation 19: OPENATTR - Open Named Attribute Directory'
  contents:
  - "14.2.17.  Operation 19: OPENATTR - Open Named Attribute Directory\n   SYNOPSIS\n\
    \   (cfh) -> (cfh)\n   ARGUMENT\n   /* CURRENT_FH: file or directory */\n   void;\n\
    \   RESULT\n   struct OPENATTR4res {\n           /* CURRENT_FH: name attr directory*/\n\
    \           nfsstat4        status;\n   };\n   DESCRIPTION\n      The OPENATTR\
    \ operation is used to obtain the filehandle of the\n      named attribute directory\
    \ associated with the current filehandle.\n      The result of the OPENATTR will\
    \ be a filehandle to an object of\n      type NF4ATTRDIR.  From this filehandle,\
    \ READDIR and LOOKUP\n      procedures can be used to obtain filehandles for the\
    \ various named\n      attributes associated with the original file system object.\n\
    \      Filehandles returned within the named attribute directory will\n      have\
    \ a type of NF4NAMEDATTR.\n   IMPLEMENTATION\n      If the server does not support\
    \ named attributes for the current\n      filehandle, an error of NFS4ERR_NOTSUPP\
    \ will be returned to the\n      client.\n   ERRORS\n      NFS4ERR_ACCES\n   \
    \   NFS4ERR_BADHANDLE\n      NFS4ERR_DELAY\n      NFS4ERR_FHEXPIRED\n      NFS4ERR_INVAL\n\
    \      NFS4ERR_IO\n      NFS4ERR_MOVED\n      NFS4ERR_NOENT\n      NFS4ERR_NOFILEHANDLE\n\
    \      NFS4ERR_NOTSUPP\n      NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n  \
    \    NFS4ERR_STALE\n      NFS4ERR_WRONGSEC\n"
- title: '14.2.18.  Operation 20: OPEN_CONFIRM - Confirm Open'
  contents:
  - "14.2.18.  Operation 20: OPEN_CONFIRM - Confirm Open\n   SYNOPSIS\n   (cfh), seqid,\
    \ open_confirm-> stateid\n   ARGUMENT\n   struct OPEN_CONFIRM4args {\n       \
    \    /* CURRENT_FH: opened file */\n           seqid4          seqid;\n      \
    \     verifier4       open_confirm;   /* OPEN_CONFIRM verifier */\n   };\n   RESULT\n\
    \   struct OPEN_CONFIRM4resok {\n           stateid4        stateid;\n   };\n\
    \   union OPEN_CONFIRM4res switch (nfsstat4 status) {\n    case NFS4_OK:\n   \
    \         OPEN_CONFIRM4resok     resok4;\n    default:\n            void;\n  \
    \ };\n   DESCRIPTION\n      This operation is used to confirm the sequence id\
    \ usage for the\n      first time that a nfs_lockowner is used by a client.  The\
    \ OPEN\n      operation returns a opaque confirmation verifier that is then\n\
    \      passed to this operation along with the next sequence id for the\n    \
    \  nfs_lockowner.  The sequence id passed to the OPEN_CONFIRM must be\n      1\
    \ (one) greater than the seqid passed to the OPEN operation from\n      which\
    \ the open_confirm value was obtained.  If the server receives\n      an unexpected\
    \ sequence id with respect to the original open, then\n      the server assumes\
    \ that the client will not confirm the original\n      OPEN and all state associated\
    \ with the original OPEN is released\n      by the server.\n      On success,\
    \ the current filehandle retains its value.\n   IMPLEMENTATION\n      A given\
    \ client might generate many nfs_lockowner data structures\n      for a given\
    \ clientid.  The client will periodically either dispose\n      of its nfs_lockowners\
    \ or stop using them for indefinite periods of\n      time.  The latter situation\
    \ is why the NFS version 4 protocol does\n      not have a an explicit operation\
    \ to exit an nfs_lockowner: such an\n      operation is of no use in that situation.\
    \  Instead, to avoid\n      unbounded memory use, the server needs to implement\
    \ a strategy for\n      disposing of nfs_lockowners that have no current lock,\
    \ open, or\n      delegation state for any files and have not been used recently.\n\
    \      The time period used to determine when to dispose of\n      nfs_lockowners\
    \ is an implementation choice.  The time period\n      should certainly be no\
    \ less than the lease time plus any grace\n      period the server wishes to implement\
    \ beyond a lease time.  The\n      OPEN_CONFIRM operation allows the server to\
    \ safely dispose of\n      unused nfs_lockowner data structures.\n      In the\
    \ case that a client issues an OPEN operation and the server\n      no longer\
    \ has a record of the nfs_lockowner, the server needs\n      ensure that this\
    \ is a new OPEN and not a replay or retransmission.\n      A lazy server implementation\
    \ might require confirmation for every\n      nfs_lockowner for which it has no\
    \ record.  However, this is not\n      necessary until the server records the\
    \ fact that it has disposed\n      of one nfs_lockowner for the given clientid.\n\
    \      The server must hold unconfirmed OPEN state until one of three\n      events\
    \ occur.  First, the client sends an OPEN_CONFIRM request\n      with the appropriate\
    \ sequence id and confirmation verifier within\n      the lease period.  In this\
    \ case, the OPEN state on the server goes\n      to confirmed, and the nfs_lockowner\
    \ on the server is fully\n      established.\n      Second, the client sends another\
    \ OPEN request with a sequence id\n      that is incorrect for the nfs_lockowner\
    \ (out of sequence).  In\n      this case, the server assumes the second OPEN\
    \ request is valid and\n      the first one is a replay.  The server cancels the\
    \ OPEN state of\n      the first OPEN request, establishes an unconfirmed OPEN\
    \ state for\n      the second OPEN request, and responds to the second OPEN request\n\
    \      with an indication that an OPEN_CONFIRM is needed.  The process\n     \
    \ then repeats itself.  While there is a potential for a denial of\n      service\
    \ attack on the client, it is mitigated if the client and\n      server require\
    \ the use of a security flavor based on Kerberos V5,\n      LIPKEY, or some other\
    \ flavor that uses cryptography.\n      What if the server is in the unconfirmed\
    \ OPEN state for a given\n      nfs_lockowner, and it receives an operation on\
    \ the nfs_lockowner\n      that has a stateid but the operation is not OPEN, or\
    \ it is\n      OPEN_CONFIRM but with the wrong confirmation verifier?  Then, even\n\
    \      if the seqid is correct, the server returns NFS4ERR_BAD_STATEID,\n    \
    \  because the server assumes the operation is a replay: if the\n      server\
    \ has no established OPEN state, then there is no way, for\n      example, a LOCK\
    \ operation could be valid.\n      Third, neither of the two aforementioned events\
    \ occur for the\n      nfs_lockowner within the lease period.  In this case, the\
    \ OPEN\n      state is cancelled and disposal of the nfs_lockowner can occur.\n\
    \   ERRORS\n      NFS4ERR_BADHANDLE\n      NFS4ERR_BAD_SEQID\n      NFS4ERR_EXPIRED\n\
    \      NFS4ERR_FHEXPIRED\n      NFS4ERR_GRACE\n      NFS4ERR_INVAL\n      NFS4ERR_MOVED\n\
    \      NFS4ERR_NOENT\n      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_NOTSUPP\n    \
    \  NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n      NFS4ERR_WRONGSEC\n"
- title: '14.2.19.  Operation 21: OPEN_DOWNGRADE - Reduce Open File Access'
  contents:
  - "14.2.19.  Operation 21: OPEN_DOWNGRADE - Reduce Open File Access\n   SYNOPSIS\n\
    \   (cfh), stateid, seqid, access, deny -> stateid\n   ARGUMENT\n   struct OPEN_DOWNGRADE4args\
    \ {\n           /* CURRENT_FH: opened file */\n           stateid4        stateid;\n\
    \           seqid4          seqid;\n           uint32_t        share_access;\n\
    \           uint32_t        share_deny;\n   };\n   RESULT\n   struct OPEN_DOWNGRADE4resok\
    \ {\n           stateid4        stateid;\n   };\n   union OPEN_DOWNGRADE4res switch(nfsstat4\
    \ status) {\n    case NFS4_OK:\n           OPEN_DOWNGRADE4resok    resok4;\n \
    \   default:\n           void;\n   };\n   This operation is used to adjust the\
    \ access and deny bits for a given\n   open.  This is necessary when a given lockowner\
    \ opens the same file\n   multiple times with different access and deny flags.\
    \  In this\n   situation, a close of one of the open's may change the appropriate\n\
    \   access and deny flags to remove bits associated with open's no longer\n  \
    \ in effect.\n   The access and deny bits specified in this operation replace\
    \ the\n   current ones for the specified open file.  If either the access or\n\
    \   the deny mode specified includes bits not in effect for the open, the\n  \
    \ error NFS4ERR_INVAL should be returned.  Since access and deny bits\n   are\
    \ subsets of those already granted, it is not possible for this\n   request to\
    \ be denied because of conflicting share reservations.\n   On success, the current\
    \ filehandle retains its value.\n   ERRORS\n      NFS4ERR_BADHANDLE NFS4ERR_BAD_SEQID\
    \ NFS4ERR_BAD_STATEID\n      NFS4ERR_EXPIRED NFS4ERR_FHEXPIRED NFS4ERR_INVAL NFS4ERR_MOVED\n\
    \      NFS4ERR_NOFILEHANDLE NFS4ERR_OLD_STATEID NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\
    \ NFS4ERR_STALE NFS4ERR_STALE_STATEID\n"
- title: '14.2.20.  Operation 22: PUTFH - Set Current Filehandle'
  contents:
  - "14.2.20.  Operation 22: PUTFH - Set Current Filehandle\n   SYNOPSIS\n      filehandle\
    \ -> (cfh)\n   ARGUMENT\n      struct PUTFH4args {\n              nfs4_fh    \
    \     object; };\n   RESULT\n      struct PUTFH4res {\n              /* CURRENT_FH:\
    \ */\n              nfsstat4        status; };\n   DESCRIPTION\n      Replaces\
    \ the current filehandle with the filehandle provided as an\n      argument.\n\
    \   IMPLEMENTATION\n      Commonly used as the first operator in an NFS request\
    \ to set the\n      context for following operations.\n   ERRORS\n      NFS4ERR_BADHANDLE\n\
    \      NFS4ERR_FHEXPIRED\n      NFS4ERR_MOVED\n      NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n\
    \      NFS4ERR_STALE\n      NFS4ERR_WRONGSEC\n"
- title: '14.2.21.  Operation 23: PUTPUBFH - Set Public Filehandle'
  contents:
  - "14.2.21.  Operation 23: PUTPUBFH - Set Public Filehandle\n   SYNOPSIS\n     \
    \ - -> (cfh)\n   ARGUMENT\n      void;\n   RESULT\n      struct PUTPUBFH4res {\n\
    \              /* CURRENT_FH: public fh */\n              nfsstat4        status;\n\
    \      };\n   DESCRIPTION\n      Replaces the current filehandle with the filehandle\
    \ that\n      represents the public filehandle of the server's name space.  This\n\
    \      filehandle may be different from the \"root\" filehandle which may\n  \
    \    be associated with some other directory on the server.\n   IMPLEMENTATION\n\
    \      Used as the first operator in an NFS request to set the context\n     \
    \ for following operations.\n   ERRORS\n      NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n\
    \      NFS4ERR_WRONGSEC\n"
- title: '14.2.22.  Operation 24: PUTROOTFH - Set Root Filehandle'
  contents:
  - "14.2.22.  Operation 24: PUTROOTFH - Set Root Filehandle\n   SYNOPSIS\n      -\
    \ -> (cfh)\n   ARGUMENT\n      void;\n   RESULT\n      struct PUTROOTFH4res {\n\
    \              /* CURRENT_FH: root fh */\n              nfsstat4        status;\n\
    \      };\n   DESCRIPTION\n      Replaces the current filehandle with the filehandle\
    \ that\n      represents the root of the server's name space.  From this\n   \
    \   filehandle a LOOKUP operation can locate any other filehandle on\n      the\
    \ server. This filehandle may be different from the \"public\"\n      filehandle\
    \ which may be associated with some other directory on\n      the server.\n  \
    \ IMPLEMENTATION\n      Commonly used as the first operator in an NFS request\
    \ to set the\n      context for following operations.\n   ERRORS\n      NFS4ERR_RESOURCE\n\
    \      NFS4ERR_SERVERFAULT\n      NFS4ERR_WRONGSEC\n"
- title: '14.2.23.  Operation 25: READ - Read from File'
  contents:
  - "14.2.23.  Operation 25: READ - Read from File\n   SYNOPSIS\n      (cfh), offset,\
    \ count, stateid -> eof, data\n   ARGUMENT\n      struct READ4args {\n       \
    \       /* CURRENT_FH: file */\n              stateid4        stateid;\n     \
    \         offset4         offset;\n              count4          count;\n    \
    \  };\n   RESULT\n      struct READ4resok {\n              bool            eof;\n\
    \              opaque          data<>;\n      };\n      union READ4res switch\
    \ (nfsstat4 status) {\n       case NFS4_OK:\n               READ4resok     resok4;\n\
    \       default:\n               void;\n      };\n   DESCRIPTION\n      The READ\
    \ operation reads data from the regular file identified by\n      the current\
    \ filehandle.\n      The client provides an offset of where the READ is to start\
    \ and a\n      count of how many bytes are to be read.  An offset of 0 (zero)\n\
    \      means to read data starting at the beginning of the file.  If\n      offset\
    \ is greater than or equal to the size of the file, the\n      status, NFS4_OK,\
    \ is returned with a data length set to 0 (zero)\n      and eof is set to TRUE.\
    \  The READ is subject to access permissions\n      checking.\n      If the client\
    \ specifies a count value of 0 (zero), the READ\n      succeeds and returns 0\
    \ (zero) bytes of data again subject to\n      access permissions checking.  The\
    \ server may choose to return\n      fewer bytes than specified by the client.\
    \  The client needs to\n      check for this condition and handle the condition\
    \ appropriately.\n      The stateid value for a READ request represents a value\
    \ returned\n      from a previous record lock or share reservation request.  Used\
    \ by\n      the server to verify that the associated lock is still valid and\n\
    \      to update lease timeouts for the client.\n      If the read ended at the\
    \ end-of-file (formally, in a correctly\n      formed READ request, if offset\
    \ + count is equal to the size of the\n      file), or the read request extends\
    \ beyond the size of the file (if\n      offset + count is greater than the size\
    \ of the file), eof is\n      returned as TRUE; otherwise it is FALSE.  A successful\
    \ READ of an\n      empty file will always return eof as TRUE.\n      On success,\
    \ the current filehandle retains its value.\n   IMPLEMENTATION\n      It is possible\
    \ for the server to return fewer than count bytes of\n      data.  If the server\
    \ returns less than the count requested and eof\n      set to FALSE, the client\
    \ should issue another READ to get the\n      remaining data.  A server may return\
    \ less data than requested\n      under several circumstances.  The file may have\
    \ been truncated by\n      another client or perhaps on the server itself, changing\
    \ the file\n      size from what the requesting client believes to be the case.\n\
    \      This would reduce the actual amount of data available to the\n      client.\
    \  It is possible that the server may back off the transfer\n      size and reduce\
    \ the read request return.  Server resource\n      exhaustion may also occur necessitating\
    \ a smaller read return.\n      If the file is locked the server will return an\
    \ NFS4ERR_LOCKED\n      error.  Since the lock may be of short duration, the client\
    \ may\n      choose to retransmit the READ request (with exponential backoff)\n\
    \      until the operation succeeds.\n   ERRORS\n      NFS4ERR_ACCES\n      NFS4ERR_BADHANDLE\n\
    \      NFS4ERR_BAD_STATEID\n      NFS4ERR_DELAY\n      NFS4ERR_DENIED\n      NFS4ERR_EXPIRED\n\
    \      NFS4ERR_FHEXPIRED\n      NFS4ERR_GRACE\n      NFS4ERR_INVAL\n      NFS4ERR_IO\n\
    \      NFS4ERR_LOCKED\n      NFS4ERR_LEASE_MOVED\n      NFS4ERR_MOVED\n      NFS4ERR_NOFILEHANDLE\n\
    \      NFS4ERR_NXIO\n      NFS4ERR_OLD_STATEID\n      NFS4ERR_RESOURCE\n     \
    \ NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n      NFS4ERR_STALE_STATEID\n    \
    \  NFS4ERR_WRONGSEC\n"
- title: '14.2.24.  Operation 26: READDIR - Read Directory'
  contents:
  - "14.2.24.  Operation 26: READDIR - Read Directory\n   SYNOPSIS\n      (cfh), cookie,\
    \ cookieverf, dircount, maxcount, attrbits ->\n      cookieverf { cookie, filename,\
    \ attrbits, attributes }\n   ARGUMENT\n      struct READDIR4args {\n         \
    \     /* CURRENT_FH: directory */\n              nfs_cookie4     cookie;\n   \
    \           verifier4       cookieverf;\n              count4          dircount;\n\
    \              count4          maxcount;\n              bitmap4         attr_request;\n\
    \      };\n   RESULT\n      struct entry4 {\n              nfs_cookie4     cookie;\n\
    \              component4      name;\n              fattr4          attrs;\n \
    \             entry4          *nextentry;\n      };\n      struct dirlist4 {\n\
    \              entry4          *entries;\n              bool            eof;\n\
    \      };\n      struct READDIR4resok {\n              verifier4       cookieverf;\n\
    \              dirlist4        reply;\n      };\n      union READDIR4res switch\
    \ (nfsstat4 status) {\n       case NFS4_OK:\n               READDIR4resok  resok4;\n\
    \       default:\n               void;\n      };\n   DESCRIPTION\n      The READDIR\
    \ operation retrieves a variable number of entries from\n      a file system directory\
    \ and returns client requested attributes\n      for each entry along with information\
    \ to allow the client to\n      request additional directory entries in a subsequent\
    \ READDIR.\n      The arguments contain a cookie value that represents where the\n\
    \      READDIR should start within the directory.  A value of 0 (zero)\n     \
    \ for the cookie is used to start reading at the beginning of the\n      directory.\
    \  For subsequent READDIR requests, the client specifies\n      a cookie value\
    \ that is provided by the server on a previous\n      READDIR request.\n     \
    \ The cookieverf value should be set to 0 (zero) when the cookie\n      value\
    \ is 0 (zero) (first directory read).  On subsequent requests,\n      it should\
    \ be a cookieverf as returned by the server.  The\n      cookieverf must match\
    \ that returned by the READDIR in which the\n      cookie was acquired.\n    \
    \  The dircount portion of the argument is a hint of the maximum\n      number\
    \ of bytes of directory information that should be returned.\n      This value\
    \ represents the length of the names of the directory\n      entries and the cookie\
    \ value for these entries.  This length\n      represents the XDR encoding of\
    \ the data (names and cookies) and\n      not the length in the native format\
    \ of the server.  The server may\n      return less data.\n      The maxcount\
    \ value of the argument is the maximum number of bytes\n      for the result.\
    \  This maximum size represents all of the data\n      being returned and includes\
    \ the XDR overhead.  The server may\n      return less data.  If the server is\
    \ unable to return a single\n      directory entry within the maxcount limit,\
    \ the error\n      NFS4ERR_READDIR_NOSPC will be returned to the client.\n   \
    \   Finally, attrbits represents the list of attributes to be returned\n     \
    \ for each directory entry supplied by the server.\n      On successful return,\
    \ the server's response will provide a list of\n      directory entries.  Each\
    \ of these entries contains the name of the\n      directory entry, a cookie value\
    \ for that entry, and the associated\n      attributes as requested.\n      The\
    \ cookie value is only meaningful to the server and is used as a\n      \"bookmark\"\
    \ for the directory entry.  As mentioned, this cookie is\n      used by the client\
    \ for subsequent READDIR operations so that it\n      may continue reading a directory.\
    \  The cookie is similar in\n      concept to a READ offset but should not be\
    \ interpreted as such by\n      the client.  Ideally, the cookie value should\
    \ not change if the\n      directory is modified since the client may be caching\
    \ these\n      values.\n      In some cases, the server may encounter an error\
    \ while obtaining\n      the attributes for a directory entry.  Instead of returning\
    \ an\n      error for the entire READDIR operation, the server can instead\n \
    \     return the attribute 'fattr4_rdattr_error'.  With this, the server\n   \
    \   is able to communicate the failure to the client and not fail the\n      entire\
    \ operation in the instance of what might be a transient\n      failure.  Obviously,\
    \ the client must request the\n      fattr4_rdattr_error attribute for this method\
    \ to work properly.\n      If the client does not request the attribute, the server\
    \ has no\n      choice but to return failure for the entire READDIR operation.\n\
    \      For some file system environments, the directory entries \".\" and\n  \
    \    \"..\"  have special meaning and in other environments, they may\n      not.\
    \  If the server supports these special entries within a\n      directory, they\
    \ should not be returned to the client as part of\n      the READDIR response.\
    \  To enable some client environments, the\n      cookie values of 0, 1, and 2\
    \ are to be considered reserved.  Note\n      that the Unix client will use these\
    \ values when combining the\n      server's response and local representations\
    \ to enable a fully\n      formed Unix directory presentation to the application.\n\
    \      For READDIR arguments, cookie values of 1 and 2 should not be used\n  \
    \    and for READDIR results cookie values of 0, 1, and 2 should not\n      returned.\n\
    \      On success, the current filehandle retains its value.\n   IMPLEMENTATION\n\
    \      The server's file system directory representations can differ\n      greatly.\
    \  A client's programming interfaces may also be bound to\n      the local operating\
    \ environment in a way that does not translate\n      well into the NFS protocol.\
    \  Therefore the use of the dircount and\n      maxcount fields are provided to\
    \ allow the client the ability to\n      provide guidelines to the server.  If\
    \ the client is aggressive\n      about attribute collection during a READDIR,\
    \ the server has an\n      idea of how to limit the encoded response.  The dircount\
    \ field\n      provides a hint on the number of entries based solely on the names\n\
    \      of the directory entries.  Since it is a hint, it may be possible\n   \
    \   that a dircount value is zero.  In this case, the server is free\n      to\
    \ ignore the dircount value and return directory information\n      based on the\
    \ specified maxcount value.\n      The cookieverf may be used by the server to\
    \ help manage cookie\n      values that may become stale.  It should be a rare\
    \ occurrence that\n      a server is unable to continue properly reading a directory\
    \ with\n      the provided cookie/cookieverf pair.  The server should make every\n\
    \      effort to avoid this condition since the application at the client\n  \
    \    may not be able to properly handle this type of failure.\n      The use of\
    \ the cookieverf will also protect the client from using\n      READDIR cookie\
    \ values that may be stale.  For example, if the file\n      system has been migrated,\
    \ the server may or may not be able to use\n      the same cookie values to service\
    \ READDIR as the previous server\n      used.  With the client providing the cookieverf,\
    \ the server is\n      able to provide the appropriate response to the client.\
    \  This\n      prevents the case where the server may accept a cookie value but\n\
    \      the underlying directory has changed and the response is invalid\n    \
    \  from the client's context of its previous READDIR.\n      Since some servers\
    \ will not be returning \".\" and \"..\" entries as\n      has been done with\
    \ previous versions of the NFS protocol, the\n      client that requires these\
    \ entries be present in READDIR responses\n      must fabricate them.\n   ERRORS\n\
    \      NFS4ERR_ACCES\n      NFS4ERR_BADHANDLE\n      NFS4ERR_BAD_COOKIE\n    \
    \  NFS4ERR_DELAY\n      NFS4ERR_FHEXPIRED\n      NFS4ERR_INVAL\n      NFS4ERR_IO\n\
    \      NFS4ERR_MOVED\n      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_NOTDIR\n     \
    \ NFS4ERR_NOTSUPP\n      NFS4ERR_READDIR_NOSPC\n      NFS4ERR_RESOURCE\n     \
    \ NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n      NFS4ERR_TOOSMALL\n      NFS4ERR_WRONGSEC\n"
- title: '14.2.25.  Operation 27: READLINK - Read Symbolic Link'
  contents:
  - "14.2.25.  Operation 27: READLINK - Read Symbolic Link\n   SYNOPSIS\n      (cfh)\
    \ -> linktext\n   ARGUMENT\n      /* CURRENT_FH: symlink */\n      void;\n   RESULT\n\
    \      struct READLINK4resok {\n              linktext4       link;\n      };\n\
    \      union READLINK4res switch (nfsstat4 status) {\n       case NFS4_OK:\n \
    \              READLINK4resok resok4;\n       default:\n               void;\n\
    \      };\n   DESCRIPTION\n      READLINK reads the data associated with a symbolic\
    \ link.  The data\n      is a UTF-8 string that is opaque to the server.  That\
    \ is, whether\n      created by an NFS client or created locally on the server,\
    \ the\n      data in a symbolic link is not interpreted when created, but is\n\
    \      simply stored.\n      On success, the current filehandle retains its value.\n\
    \   IMPLEMENTATION\n      A symbolic link is nominally a pointer to another file.\
    \  The data\n      is not necessarily interpreted by the server, just stored in\
    \ the\n      file.  It is possible for a client implementation to store a path\n\
    \      name that is not meaningful to the server operating system in a\n     \
    \ symbolic link.  A READLINK operation returns the data to the\n      client for\
    \ interpretation. If different implementations want to\n      share access to\
    \ symbolic links, then they must agree on the\n      interpretation of the data\
    \ in the symbolic link.\n      The READLINK operation is only allowed on objects\
    \ of type NF4LNK.\n      The server should return the error, NFS4ERR_INVAL, if\
    \ the object\n      is not of type, NF4LNK.\n   ERRORS\n      NFS4ERR_ACCES\n\
    \      NFS4ERR_BADHANDLE\n      NFS4ERR_DELAY\n      NFS4ERR_FHEXPIRED\n     \
    \ NFS4ERR_INVAL\n      NFS4ERR_IO\n      NFS4ERR_MOVED\n      NFS4ERR_NOFILEHANDLE\n\
    \      NFS4ERR_NOTSUPP\n      NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n  \
    \    NFS4ERR_STALE\n      NFS4ERR_WRONGSEC\n"
- title: '14.2.26.  Operation 28: REMOVE - Remove Filesystem Object'
  contents:
  - "14.2.26.  Operation 28: REMOVE - Remove Filesystem Object\n   SYNOPSIS\n    \
    \  (cfh), filename -> change_info\n   ARGUMENT\n      struct REMOVE4args {\n \
    \             /* CURRENT_FH: directory */\n              component4       target;\n\
    \      };\n   RESULT\n      struct REMOVE4resok {\n              change_info4\
    \    cinfo;\n      }\n      union REMOVE4res switch (nfsstat4 status) {\n    \
    \   case NFS4_OK:\n               REMOVE4resok   resok4;\n       default:\n  \
    \             void;\n      }\n   DESCRIPTION\n      The REMOVE operation removes\
    \ (deletes) a directory entry named by\n      filename from the directory corresponding\
    \ to the current\n      filehandle.  If the entry in the directory was the last\
    \ reference\n      to the corresponding file system object, the object may be\n\
    \      destroyed.\n      For the directory where the filename was removed, the\
    \ server\n      returns change_info4 information in cinfo.  With the atomic field\n\
    \      of the change_info4 struct, the server will indicate if the before\n  \
    \    and after change attributes were obtained atomically with respect\n     \
    \ to the removal.\n      If the target has a length of 0 (zero), or if target\
    \ does not obey\n      the UTF-8 definition, the error NFS4ERR_INVAL will be returned.\n\
    \      On success, the current filehandle retains its value.\n   IMPLEMENTATION\n\
    \      NFS versions 2 and 3 required a different operator RMDIR for\n      directory\
    \ removal.  NFS version 4 REMOVE can be used to delete any\n      directory entry\
    \ independent of its file type.\n      The concept of last reference is server\
    \ specific. However, if the\n      numlinks field in the previous attributes of\
    \ the object had the\n      value 1, the client should not rely on referring to\
    \ the object via\n      a file handle. Likewise, the client should not rely on\
    \ the\n      resources (disk space, directory entry, and so on) formerly\n   \
    \   associated with the object becoming immediately available. Thus,\n      if\
    \ a client needs to be able to continue to access a file after\n      using REMOVE\
    \ to remove it, the client should take steps to make\n      sure that the file\
    \ will still be accessible. The usual mechanism\n      used is to RENAME the file\
    \ from its old name to a new hidden name.\n   ERRORS\n      NFS4ERR_ACCES\n  \
    \    NFS4ERR_BADHANDLE\n      NFS4ERR_DELAY\n      NFS4ERR_FHEXPIRED\n      NFS4ERR_IO\n\
    \      NFS4ERR_MOVED\n      NFS4ERR_NAMETOOLONG\n      NFS4ERR_NOENT\n      NFS4ERR_NOFILEHANDLE\n\
    \      NFS4ERR_NOTDIR\n      NFS4ERR_NOTEMPTY\n      NFS4ERR_NOTSUPP\n      NFS4ERR_RESOURCE\n\
    \      NFS4ERR_ROFS\n      NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n      NFS4ERR_WRONGSEC\n"
- title: '14.2.27.  Operation 29: RENAME - Rename Directory Entry'
  contents:
  - "14.2.27.  Operation 29: RENAME - Rename Directory Entry\n   SYNOPSIS\n      (sfh),\
    \ oldname (cfh), newname -> source_change_info,\n      target_change_info\n  \
    \    ARGUMENT\n      struct RENAME4args {\n              /* SAVED_FH: source directory\
    \ */\n              component4      oldname;\n              /* CURRENT_FH: target\
    \ directory */\n              component4      newname;\n      };\n   RESULT\n\
    \      struct RENAME4resok {\n              change_info4    source_cinfo;\n  \
    \            change_info4    target_cinfo;\n      };\n      union RENAME4res switch\
    \ (nfsstat4 status) {\n       case NFS4_OK:\n               RENAME4resok   resok4;\n\
    \       default:\n               void;\n      };\n   DESCRIPTION\n      The RENAME\
    \ operation renames the object identified by oldname in\n      the source directory\
    \ corresponding to the saved filehandle, as set\n      by the SAVEFH operation,\
    \ to newname in the target directory\n      corresponding to the current filehandle.\
    \  The operation is\n      required to be atomic to the client.  Source and target\n\
    \      directories must reside on the same file system on the server.  On\n  \
    \    success, the current filehandle will continue to be the target\n      directory.\n\
    \      If the target directory already contains an entry with the name,\n    \
    \  newname, the source object must be compatible with the target:\n      either\
    \ both are non-directories or both are directories and the\n      target must\
    \ be empty.  If compatible, the existing target is\n      removed before the rename\
    \ occurs.  If they are not compatible or\n      if the target is a directory but\
    \ not empty, the server will return\n      the error, NFS4ERR_EXIST.\n      If\
    \ oldname and newname both refer to the same file (they might be\n      hard links\
    \ of each other), then RENAME should perform no action\n      and return success.\n\
    \      For both directories involved in the RENAME, the server returns\n     \
    \ change_info4 information.  With the atomic field of the\n      change_info4\
    \ struct, the server will indicate if the before and\n      after change attributes\
    \ were obtained atomically with respect to\n      the rename.\n      If the oldname\
    \ or newname has a length of 0 (zero), or if oldname\n      or newname does not\
    \ obey the UTF-8 definition, the error\n      NFS4ERR_INVAL will be returned.\n\
    \   IMPLEMENTATION\n      The RENAME operation must be atomic to the client. \
    \ The statement\n      \"source and target directories must reside on the same\
    \ file system\n      on the server\" means that the fsid fields in the attributes\
    \ for\n      the directories are the same. If they reside on different file\n\
    \      systems, the error, NFS4ERR_XDEV, is returned.\n      A filehandle may\
    \ or may not become stale or expire on a rename.\n      However, server implementors\
    \ are strongly encouraged to attempt to\n      keep file handles from becoming\
    \ stale or expiring in this fashion.\n      On some servers, the filenames, \"\
    .\" and \"..\", are illegal as\n      either oldname or newname.  In addition,\
    \ neither oldname nor\n      newname can be an alias for the source directory.\
    \  These servers\n      will return the error, NFS4ERR_INVAL, in these cases.\n\
    \   ERRORS\n      NFS4ERR_ACCES\n      NFS4ERR_BADHANDLE\n      NFS4ERR_DELAY\n\
    \      NFS4ERR_DQUOT\n      NFS4ERR_EXIST\n      NFS4ERR_FHEXPIRED\n      NFS4ERR_INVAL\n\
    \      NFS4ERR_IO\n      NFS4ERR_ISDIR\n      NFS4ERR_MOVED\n      NFS4ERR_NAMETOOLONG\n\
    \      NFS4ERR_NOENT\n      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_NOSPC\n      NFS4ERR_NOTDIR\n\
    \      NFS4ERR_NOTEMPTY\n      NFS4ERR_NOTSUPP\n      NFS4ERR_RESOURCE\n     \
    \ NFS4ERR_ROFS\n      NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n      NFS4ERR_WRONGSEC\n\
    \      NFS4ERR_XDEV\n"
- title: '14.2.28.  Operation 30: RENEW - Renew a Lease'
  contents:
  - "14.2.28.  Operation 30: RENEW - Renew a Lease\n   SYNOPSIS\n      stateid ->\
    \ ()\n   ARGUMENT\n      struct RENEW4args {\n              stateid4        stateid;\n\
    \      };\n   RESULT\n      struct RENEW4res {\n              nfsstat4       \
    \ status;\n      };\n   DESCRIPTION\n      The RENEW operation is used by the\
    \ client to renew leases which it\n      currently holds at a server.  In processing\
    \ the RENEW request, the\n      server renews all leases associated with the client.\
    \  The\n      associated leases are determined by the client id provided via the\n\
    \      SETCLIENTID procedure.\n      The stateid for RENEW may not be one of the\
    \ special stateids\n      consisting of all bits 0 (zero) or all bits 1.\n   IMPLEMENTATION\n\
    \   ERRORS\n      NFS4ERR_BAD_STATEID\n      NFS4ERR_EXPIRED\n      NFS4ERR_GRACE\n\
    \      NFS4ERR_INVAL\n      NFS4ERR_LEASE_MOVED\n      NFS4ERR_MOVED\n      NFS4ERR_OLD_STATEID\n\
    \      NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE_STATEID\n\
    \      NFS4ERR_WRONGSEC\n"
- title: '14.2.29.  Operation 31: RESTOREFH - Restore Saved Filehandle'
  contents:
  - "14.2.29.  Operation 31: RESTOREFH - Restore Saved Filehandle\n   SYNOPSIS\n \
    \     (sfh) -> (cfh)\n   ARGUMENT\n      /* SAVED_FH: */\n      void;\n   RESULT\n\
    \      struct RESTOREFH4res {\n              /* CURRENT_FH: value of saved fh\
    \ */\n              nfsstat4        status;\n      };\n   DESCRIPTION\n      Set\
    \ the current filehandle to the value in the saved filehandle.\n      If there\
    \ is no saved filehandle then return an error\n      NFS4ERR_NOFILEHANDLE.\n \
    \  IMPLEMENTATION\n      Operations like OPEN and LOOKUP use the current filehandle\
    \ to\n      represent a directory and replace it with a new filehandle.\n    \
    \  Assuming the previous filehandle was saved with a SAVEFH operator,\n      the\
    \ previous filehandle can be restored as the current filehandle.\n      This is\
    \ commonly used to obtain post-operation attributes for the\n      directory,\
    \ e.g.\n               PUTFH (directory filehandle)\n               SAVEFH\n \
    \              GETATTR attrbits     (pre-op dir attrs)\n               CREATE\
    \ optbits \"foo\" attrs\n               GETATTR attrbits     (file attributes)\n\
    \               RESTOREFH\n               GETATTR attrbits     (post-op dir attrs)\n\
    \   ERRORS\n      NFS4ERR_BADHANDLE\n      NFS4ERR_FHEXPIRED\n      NFS4ERR_MOVED\n\
    \      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n\
    \      NFS4ERR_STALE\n      NFS4ERR_WRONGSEC\n"
- title: '14.2.30.  Operation 32: SAVEFH - Save Current Filehandle'
  contents:
  - "14.2.30.  Operation 32: SAVEFH - Save Current Filehandle\n   SYNOPSIS\n     \
    \ (cfh) -> (sfh)\n   ARGUMENT\n      /* CURRENT_FH: */\n      void;\n   RESULT\n\
    \      struct SAVEFH4res {\n              /* SAVED_FH: value of current fh */\n\
    \              nfsstat4        status;\n      };\n      DESCRIPTION\n      Save\
    \ the current filehandle.  If a previous filehandle was saved\n      then it is\
    \ no longer accessible.  The saved filehandle can be\n      restored as the current\
    \ filehandle with the RESTOREFH operator.\n      On success, the current filehandle\
    \ retains its value.\n   IMPLEMENTATION\n   ERRORS\n      NFS4ERR_BADHANDLE\n\
    \      NFS4ERR_FHEXPIRED\n      NFS4ERR_MOVED\n      NFS4ERR_NOFILEHANDLE\n  \
    \    NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n      NFS4ERR_WRONGSEC\n"
- title: '14.2.31.  Operation 33: SECINFO - Obtain Available Security'
  contents:
  - "14.2.31.  Operation 33: SECINFO - Obtain Available Security\n   SYNOPSIS\n  \
    \    (cfh), name -> { secinfo }\n   ARGUMENT\n      struct SECINFO4args {\n  \
    \            /* CURRENT_FH: */\n              component4     name;\n      };\n\
    \   RESULT\n      enum rpc_gss_svc_t {\n              RPC_GSS_SVC_NONE       \
    \ = 1,\n              RPC_GSS_SVC_INTEGRITY   = 2,\n              RPC_GSS_SVC_PRIVACY\
    \     = 3\n      };\n      struct rpcsec_gss_info {\n              sec_oid4  \
    \      oid;\n              qop4            qop;\n              rpc_gss_svc_t \
    \  service;\n      };\n      struct secinfo4 {\n              uint32_t flavor;\n\
    \              opaque flavor_info<>;   /* null for AUTH_SYS, AUTH_NONE;\n    \
    \                                     contains rpcsec_gss_info for\n         \
    \                                RPCSEC_GSS. */\n      };\n      typedef secinfo4\
    \ SECINFO4resok<>;\n      union SECINFO4res switch (nfsstat4 status) {\n     \
    \  case NFS4_OK:\n               SECINFO4resok resok4;\n       default:\n    \
    \           void;\n      };\n   DESCRIPTION\n      The SECINFO operation is used\
    \ by the client to obtain a list of\n      valid RPC authentication flavors for\
    \ a specific file handle, file\n      name pair.  The result will contain an array\
    \ which represents the\n      security mechanisms available.  The array entries\
    \ are represented\n      by the secinfo4 structure.  The field 'flavor' will contain\
    \ a\n      value of AUTH_NONE, AUTH_SYS (as defined in [RFC1831]), or\n      RPCSEC_GSS\
    \ (as defined in [RFC2203]).\n      For the flavors, AUTH_NONE, and AUTH_SYS no\
    \ additional security\n      information is returned.  For a return value of RPCSEC_GSS,\
    \ a\n      security triple is returned that contains the mechanism object id\n\
    \      (as defined in [RFC2078]), the quality of protection (as defined\n    \
    \  in [RFC2078]) and the service type (as defined in [RFC2203]).  It\n      is\
    \ possible for SECINFO to return multiple entries with flavor\n      equal to\
    \ RPCSEC_GSS with different security triple values.\n      On success, the current\
    \ filehandle retains its value.\n   IMPLEMENTATION\n      The SECINFO operation\
    \ is expected to be used by the NFS client\n      when the error value of NFS4ERR_WRONGSEC\
    \ is returned from another\n      NFS operation.  This signifies to the client\
    \ that the server's\n      security policy is different from what the client is\
    \ currently\n      using.  At this point, the client is expected to obtain a list\
    \ of\n      possible security flavors and choose what best suits its policies.\n\
    \      It is recommended that the client issue the SECINFO call protected\n  \
    \    by a security triple that uses either rpc_gss_svc_integrity or\n      rpc_gss_svc_privacy\
    \ service. The use of rpc_gss_svc_none would\n      allow an attacker in the middle\
    \ to modify the SECINFO results such\n      that the client might select a weaker\
    \ algorithm in the set allowed\n      by server, making the client and/or server\
    \ vulnerable to further\n      attacks.\n   ERRORS\n      NFS4ERR_BADHANDLE\n\
    \      NFS4ERR_FHEXPIRED\n      NFS4ERR_MOVED\n      NFS4ERR_NAMETOOLONG\n   \
    \   NFS4ERR_NOENT\n      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_NOTDIR\n      NFS4ERR_RESOURCE\n\
    \      NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n      NFS4ERR_WRONGSEC\n"
- title: '14.2.32.  Operation 34: SETATTR - Set Attributes'
  contents:
  - "14.2.32.  Operation 34: SETATTR - Set Attributes\n   SYNOPSIS\n      (cfh), attrbits,\
    \ attrvals -> -\n   ARGUMENT\n      struct SETATTR4args {\n              /* CURRENT_FH:\
    \ target object */\n              stateid4        stateid;\n              fattr4\
    \          obj_attributes;\n      };\n   RESULT\n      struct SETATTR4res {\n\
    \              nfsstat4        status;\n              bitmap4         attrsset;\n\
    \      };\n   DESCRIPTION\n      The SETATTR operation changes one or more of\
    \ the attributes of a\n      file system object.  The new attributes are specified\
    \ with a\n      bitmap and the attributes that follow the bitmap in bit order.\n\
    \      The stateid is necessary for SETATTRs that change the size of a\n     \
    \ file (modify the attribute object_size).  This stateid represents\n      a record\
    \ lock, share reservation, or delegation which must be\n      valid for the SETATTR\
    \ to modify the file data.  A valid stateid\n      would always be specified.\
    \  When the file size is not changed, the\n      special stateid consisting of\
    \ all bits 0 (zero) should be used.\n      On either success or failure of the\
    \ operation, the server will\n      return the attrsset bitmask to represent what\
    \ (if any) attributes\n      were successfully set.\n      On success, the current\
    \ filehandle retains its value.\n   IMPLEMENTATION\n      The file size attribute\
    \ is used to request changes to the size of\n      a file. A value of 0 (zero)\
    \ causes the file to be truncated, a\n      value less than the current size of\
    \ the file causes data from new\n      size to the end of the file to be discarded,\
    \ and a size greater\n      than the current size of the file causes logically\
    \ zeroed data\n      bytes to be added to the end of the file.  Servers are free\
    \ to\n      implement this using holes or actual zero data bytes. Clients\n  \
    \    should not make any assumptions regarding a server's\n      implementation\
    \ of this feature, beyond that the bytes returned\n      will be zeroed.  Servers\
    \ must support extending the file size via\n      SETATTR.\n      SETATTR is not\
    \ guaranteed atomic.  A failed SETATTR may partially\n      change a file's attributes.\n\
    \      Changing the size of a file with SETATTR indirectly changes the\n     \
    \ time_modify.  A client must account for this as size changes can\n      result\
    \ in data deletion.\n      If server and client times differ, programs that compare\
    \ client\n      time to file times can break. A time maintenance protocol should\n\
    \      be used to limit client/server time skew.\n      If the server cannot successfully\
    \ set all the attributes it must\n      return an NFS4ERR_INVAL error.  If the\
    \ server can only support 32\n      bit offsets and sizes, a SETATTR request to\
    \ set the size of a file\n      to larger than can be represented in 32 bits will\
    \ be rejected with\n      this same error.\n   ERRORS\n      NFS4ERR_ACCES\n \
    \     NFS4ERR_BADHANDLE\n      NFS4ERR_BAD_STATEID\n      NFS4ERR_DELAY\n    \
    \  NFS4ERR_DENIED\n      NFS4ERR_DQUOT\n      NFS4ERR_EXPIRED\n      NFS4ERR_FBIG\n\
    \      NFS4ERR_FHEXPIRED\n      NFS4ERR_GRACE\n      NFS4ERR_INVAL\n      NFS4ERR_IO\n\
    \      NFS4ERR_MOVED\n      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_NOSPC\n      NFS4ERR_NOTSUPP\n\
    \      NFS4ERR_OLD_STATEID\n      NFS4ERR_PERM\n      NFS4ERR_RESOURCE\n     \
    \ NFS4ERR_ROFS\n      NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n      NFS4ERR_STALE_STATEID\n\
    \      NFS4ERR_WRONGSEC\n"
- title: '14.2.33.  Operation 35: SETCLIENTID - Negotiate Clientid'
  contents:
  - "14.2.33.  Operation 35: SETCLIENTID - Negotiate Clientid\n   SYNOPSIS\n     \
    \ client, callback -> clientid, setclientid_confirm\n   ARGUMENT\n      struct\
    \ SETCLIENTID4args {\n              nfs_client_id4  client;\n              cb_client4\
    \      callback;\n      };\n   RESULT\n      struct SETCLIENTID4resok {\n    \
    \          clientid4       clientid;\n              verifier4       setclientid_confirm;\n\
    \      };\n      union SETCLIENTID4res switch (nfsstat4 status) {\n       case\
    \ NFS4_OK:\n               SETCLIENTID4resok      resok4;\n       case NFS4ERR_CLID_INUSE:\n\
    \               clientaddr4    client_using;\n       default:\n              \
    \ void;\n      };\n   DESCRIPTION\n      The SETCLIENTID operation introduces\
    \ the ability of the client to\n      notify the server of its intention to use\
    \ a particular client\n      identifier and verifier pair.  Upon successful completion\
    \ the\n      server will return a clientid which is used in subsequent file\n\
    \      locking requests and a confirmation verifier.  The client will use\n  \
    \    the SETCLIENTID_CONFIRM operation to return the verifier to the\n      server.\
    \  At that point, the client may use the clientid in\n      subsequent operations\
    \ that require an nfs_lockowner.\n      The callback information provided in this\
    \ operation will be used\n      if the client is provided an open delegation at\
    \ a future point.\n      Therefore, the client must correctly reflect the program\
    \ and port\n      numbers for the callback program at the time SETCLIENTID is\
    \ used.\n   IMPLEMENTATION\n      The server takes the verifier and client identification\
    \ supplied\n      in the nfs_client_id4 and searches for a match of the client\n\
    \      identification.  If no match is found the server saves the\n      principal/uid\
    \ information along with the verifier and client\n      identification and returns\
    \ a unique clientid that is used as a\n      shorthand reference to the supplied\
    \ information.\n      If the server finds matching client identification and a\n\
    \      corresponding match in principal/uid, the server releases all\n      locking\
    \ state for the client and returns a new clientid.\n      The principal, or principal\
    \ to user-identifier mapping is taken\n      from the credential presented in\
    \ the RPC.  As mentioned, the\n      server will use the credential and associated\
    \ principal for the\n      matching with existing clientids.  If the client is\
    \ a traditional\n      host-based client like a Unix NFS client, then the credential\n\
    \      presented may be the host credential.  If the client is a user\n      level\
    \ client or lightweight client, the credential used may be the\n      end user's\
    \ credential.  The client should take care in choosing an\n      appropriate credential\
    \ since denial of service attacks could be\n      attempted by a rogue client\
    \ that has access to the credential.\n   ERRORS\n      NFS4ERR_CLID_INUSE\n  \
    \    NFS4ERR_INVAL\n      NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n"
- title: '14.2.34.  Operation 36: SETCLIENTID_CONFIRM - Confirm Clientid'
  contents:
  - "14.2.34.  Operation 36: SETCLIENTID_CONFIRM - Confirm Clientid\n   SYNOPSIS\n\
    \      setclientid_confirm -> -\n   ARGUMENT\n      struct SETCLIENTID_CONFIRM4args\
    \ {\n              verifier4       setclientid_confirm;\n      };\n   RESULT\n\
    \      struct SETCLIENTID_CONFIRM4res {\n              nfsstat4        status;\n\
    \      };\n   DESCRIPTION\n      This operation is used by the client to confirm\
    \ the results from a\n      previous call to SETCLIENTID.  The client provides\
    \ the server\n      supplied (from a SETCLIENTID response) opaque confirmation\n\
    \      verifier.  The server responds with a simple status of success or\n   \
    \   failure.\n   IMPLEMENTATION\n      The client must use the SETCLIENTID_CONFIRM\
    \ operation to confirm\n      its use of client identifier.  If the server is\
    \ holding state for\n      a client which has presented a new verifier via SETCLIENTID,\
    \ then\n      the state will not be released, as described in the section\n  \
    \    \"Client Failure and Recovery\", until a valid SETCLIENTID_CONFIRM\n    \
    \  is received.  Upon successful confirmation the server will release\n      the\
    \ previous state held on behalf of the client.  The server\n      should choose\
    \ a confirmation cookie value that is reasonably\n      unique for the client.\n\
    \   ERRORS\n      NFS4ERR_CLID_INUSE\n      NFS4ERR_INVAL\n      NFS4ERR_RESOURCE\n\
    \      NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE_CLIENTID\n"
- title: '14.2.35.  Operation 37: VERIFY - Verify Same Attributes'
  contents:
  - "14.2.35.  Operation 37: VERIFY - Verify Same Attributes\n   SYNOPSIS\n      (cfh),\
    \ fattr -> -\n   ARGUMENT\n      struct VERIFY4args {\n              /* CURRENT_FH:\
    \ object */\n              fattr4          obj_attributes;\n      };\n   RESULT\n\
    \      struct VERIFY4res {\n              nfsstat4        status;\n      };\n\
    \   DESCRIPTION\n      The VERIFY operation is used to verify that attributes\
    \ have a\n      value assumed by the client before proceeding with following\n\
    \      operations in the compound request.  If any of the attributes do\n    \
    \  not match then the error NFS4ERR_NOT_SAME must be returned.  The\n      current\
    \ filehandle retains its value after successful completion\n      of the operation.\n\
    \   IMPLEMENTATION\n      One possible use of the VERIFY operation is the following\
    \ compound\n      sequence.  With this the client is attempting to verify that\
    \ the\n      file being removed will match what the client expects to be\n   \
    \   removed.  This sequence can help prevent the unintended deletion\n      of\
    \ a file.\n               PUTFH (directory filehandle)\n               LOOKUP\
    \ (file name)\n               VERIFY (filehandle == fh)\n               PUTFH\
    \ (directory filehandle)\n               REMOVE (file name)\n      This sequence\
    \ does not prevent a second client from removing and\n      creating a new file\
    \ in the middle of this sequence but it does\n      help avoid the unintended\
    \ result.\n      In the case that a recommended attribute is specified in the\n\
    \      VERIFY operation and the server does not support that attribute\n     \
    \ for the file system object, the error NFS4ERR_NOTSUPP is returned\n      to\
    \ the client.\n   ERRORS\n      NFS4ERR_ACCES\n      NFS4ERR_BADHANDLE\n     \
    \ NFS4ERR_DELAY\n      NFS4ERR_FHEXPIRED\n      NFS4ERR_INVAL\n      NFS4ERR_MOVED\n\
    \      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_NOTSUPP\n      NFS4ERR_NOT_SAME\n \
    \     NFS4ERR_RESOURCE\n      NFS4ERR_SERVERFAULT\n      NFS4ERR_STALE\n     \
    \ NFS4ERR_WRONGSEC\n"
- title: '14.2.36.  Operation 38: WRITE - Write to File'
  contents:
  - "14.2.36.  Operation 38: WRITE - Write to File\n   SYNOPSIS\n      (cfh), offset,\
    \ count, stability, stateid, data -> count, committed,\n      verifier\n   ARGUMENT\n\
    \      enum stable_how4 {\n              UNSTABLE4       = 0,\n              DATA_SYNC4\
    \      = 1,\n              FILE_SYNC4      = 2\n      };\n      struct WRITE4args\
    \ {\n              /* CURRENT_FH: file */\n              stateid4        stateid;\n\
    \              offset4         offset;\n              stable_how4     stable;\n\
    \              opaque          data<>;\n      };\n   RESULT\n      struct WRITE4resok\
    \ {\n              count4          count;\n              stable_how4     committed;\n\
    \              verifier4       writeverf;\n      };\n      union WRITE4res switch\
    \ (nfsstat4 status) {\n       case NFS4_OK:\n               WRITE4resok    resok4;\n\
    \       default:\n               void;\n      };\n   DESCRIPTION\n      The WRITE\
    \ operation is used to write data to a regular file.  The\n      target file is\
    \ specified by the current filehandle.  The offset\n      specifies the offset\
    \ where the data should be written.  An offset\n      of 0 (zero) specifies that\
    \ the write should start at the beginning\n      of the file.  The count represents\
    \ the number of bytes of data\n      that are to be written.  If the count is\
    \ 0 (zero), the WRITE will\n      succeed and return a count of 0 (zero) subject\
    \ to permissions\n      checking.  The server may choose to write fewer bytes\
    \ than\n      requested by the client.\n      Part of the write request is a specification\
    \ of how the write is\n      to be performed.  The client specifies with the stable\
    \ parameter\n      the method of how the data is to be processed by the server.\
    \  If\n      stable is FILE_SYNC4, the server must commit the data written plus\n\
    \      all file system metadata to stable storage before returning\n      results.\
    \  This corresponds to the NFS version 2 protocol\n      semantics.  Any other\
    \ behavior constitutes a protocol violation.\n      If stable is DATA_SYNC4, then\
    \ the server must commit all of the\n      data to stable storage and enough of\
    \ the metadata to retrieve the\n      data before returning.  The server implementor\
    \ is free to\n      implement DATA_SYNC4 in the same fashion as FILE_SYNC4, but\
    \ with a\n      possible performance drop.  If stable is UNSTABLE4, the server\
    \ is\n      free to commit any part of the data and the metadata to stable\n \
    \     storage, including all or none, before returning a reply to the\n      client.\
    \ There is no guarantee whether or when any uncommitted data\n      will subsequently\
    \ be committed to stable storage. The only\n      guarantees made by the server\
    \ are that it will not destroy any\n      data without changing the value of verf\
    \ and that it will not\n      commit the data and metadata at a level less than\
    \ that requested\n      by the client.\n      The stateid returned from a previous\
    \ record lock or share\n      reservation request is provided as part of the argument.\
    \  The\n      stateid is used by the server to verify that the associated lock\n\
    \      is still valid and to update lease timeouts for the client.\n      Upon\
    \ successful completion, the following results are returned.\n      The count\
    \ result is the number of bytes of data written to the\n      file. The server\
    \ may write fewer bytes than requested. If so, the\n      actual number of bytes\
    \ written starting at location, offset, is\n      returned.\n      The server\
    \ also returns an indication of the level of commitment\n      of the data and\
    \ metadata via committed. If the server committed\n      all data and metadata\
    \ to stable storage, committed should be set\n      to FILE_SYNC4. If the level\
    \ of commitment was at least as strong\n      as DATA_SYNC4, then committed should\
    \ be set to DATA_SYNC4.\n      Otherwise, committed must be returned as UNSTABLE4.\
    \ If stable was\n      FILE4_SYNC, then committed must also be FILE_SYNC4: anything\
    \ else\n      constitutes a protocol violation. If stable was DATA_SYNC4, then\n\
    \      committed may be FILE_SYNC4 or DATA_SYNC4: anything else\n      constitutes\
    \ a protocol violation. If stable was UNSTABLE4, then\n      committed may be\
    \ either FILE_SYNC4, DATA_SYNC4, or UNSTABLE4.\n      The final portion of the\
    \ result is the write verifier, verf.  The\n      write verifier is a cookie that\
    \ the client can use to determine\n      whether the server has changed state\
    \ between a call to WRITE and a\n      subsequent call to either WRITE or COMMIT.\
    \  This cookie must be\n      consistent during a single instance of the NFS version\
    \ 4 protocol\n      service and must be unique between instances of the NFS version\
    \ 4\n      protocol server, where uncommitted data may be lost.\n      If a client\
    \ writes data to the server with the stable argument set\n      to UNSTABLE4 and\
    \ the reply yields a committed response of\n      DATA_SYNC4 or UNSTABLE4, the\
    \ client will follow up some time in\n      the future with a COMMIT operation\
    \ to synchronize outstanding\n      asynchronous data and metadata with the server's\
    \ stable storage,\n      barring client error. It is possible that due to client\
    \ crash or\n      other error that a subsequent COMMIT will not be received by\
    \ the\n      server.\n      On success, the current filehandle retains its value.\n\
    \   IMPLEMENTATION\n      It is possible for the server to write fewer than count\
    \ bytes of\n      data.  In this case, the server should not return an error unless\n\
    \      no data was written at all.  If the server writes less than count\n   \
    \   bytes, the client should issue another WRITE to write the\n      remaining\
    \ data.\n      It is assumed that the act of writing data to a file will cause\n\
    \      the time_modified of the file to be updated.  However, the\n      time_modified\
    \ of the file should not be changed unless the\n      contents of the file are\
    \ changed.  Thus, a WRITE request with\n      count set to 0 should not cause\
    \ the time_modified of the file to\n      be updated.\n      The definition of\
    \ stable storage has been historically a point of\n      contention.  The following\
    \ expected properties of stable storage\n      may help in resolving design issues\
    \ in the implementation. Stable\n      storage is persistent storage that survives:\n\
    \               1. Repeated power failures.\n               2. Hardware failures\
    \ (of any board, power supply, etc.).\n               3. Repeated software crashes,\
    \ including reboot cycle.\n      This definition does not address failure of the\
    \ stable storage\n      module itself.\n      The verifier is defined to allow\
    \ a client to detect different\n      instances of an NFS version 4 protocol server\
    \ over which cached,\n      uncommitted data may be lost. In the most likely case,\
    \ the\n      verifier allows the client to detect server reboots.  This\n    \
    \  information is required so that the client can safely determine\n      whether\
    \ the server could have lost cached data.  If the server\n      fails unexpectedly\
    \ and the client has uncommitted data from\n      previous WRITE requests (done\
    \ with the stable argument set to\n      UNSTABLE4 and in which the result committed\
    \ was returned as\n      UNSTABLE4 as well) it may not have flushed cached data\
    \ to stable\n      storage. The burden of recovery is on the client and the client\n\
    \      will need to retransmit the data to the server.\n      A suggested verifier\
    \ would be to use the time that the server was\n      booted or the time the server\
    \ was last started (if restarting the\n      server without a reboot results in\
    \ lost buffers).\n      The committed field in the results allows the client to\
    \ do more\n      effective caching.  If the server is committing all WRITE requests\n\
    \      to stable storage, then it should return with committed set to\n      FILE_SYNC4,\
    \ regardless of the value of the stable field in the\n      arguments. A server\
    \ that uses an NVRAM accelerator may choose to\n      implement this policy. \
    \ The client can use this to increase the\n      effectiveness of the cache by\
    \ discarding cached data that has\n      already been committed on the server.\n\
    \      Some implementations may return NFS4ERR_NOSPC instead of\n      NFS4ERR_DQUOT\
    \ when a user's quota is exceeded.\n   ERRORS\n      NFS4ERR_ACCES\n      NFS4ERR_BADHANDLE\n\
    \      NFS4ERR_BAD_STATEID\n      NFS4ERR_DELAY\n      NFS4ERR_DENIED\n      NFS4ERR_DQUOT\n\
    \      NFS4ERR_EXPIRED\n      NFS4ERR_FBIG\n      NFS4ERR_FHEXPIRED\n      NFS4ERR_GRACE\n\
    \      NFS4ERR_INVAL\n      NFS4ERR_IO\n      NFS4ERR_LEASE_MOVED\n      NFS4ERR_LOCKED\n\
    \      NFS4ERR_MOVED\n      NFS4ERR_NOFILEHANDLE\n      NFS4ERR_NOSPC\n      NFS4ERR_OLD_STATEID\n\
    \      NFS4ERR_RESOURCE\n      NFS4ERR_ROFS\n      NFS4ERR_SERVERFAULT\n     \
    \ NFS4ERR_STALE\n      NFS4ERR_STALE_STATEID\n      NFS4ERR_WRONGSEC\n"
- title: 15.  NFS Version 4 Callback Procedures
  contents:
  - "15.  NFS Version 4 Callback Procedures\n   The procedures used for callbacks\
    \ are defined in the following\n   sections.  In the interest of clarity, the\
    \ terms \"client\" and\n   \"server\" refer to NFS clients and servers, despite\
    \ the fact that for\n   an individual callback RPC, the sense of these terms would\
    \ be\n   precisely the opposite.\n"
- title: '15.1.  Procedure 0: CB_NULL - No Operation'
  contents:
  - "15.1.  Procedure 0: CB_NULL - No Operation\n   SYNOPSIS\n      <null>\n   ARGUMENT\n\
    \      void;\n   RESULT\n      void;\n   DESCRIPTION\n      Standard NULL procedure.\
    \  Void argument, void response.  Even\n      though there is no direct functionality\
    \ associated with this\n      procedure, the server will use CB_NULL to confirm\
    \ the existence of\n      a path for RPCs from server to client.\n   ERRORS\n\
    \      None.\n"
- title: '15.2.  Procedure 1: CB_COMPOUND - Compound Operations'
  contents:
  - "15.2.  Procedure 1: CB_COMPOUND - Compound Operations\n   SYNOPSIS\n      compoundargs\
    \ -> compoundres\n   ARGUMENT\n      enum nfs_cb_opnum4 {\n              OP_CB_GETATTR\
    \           = 3,\n              OP_CB_RECALL            = 4 };\n      union nfs_cb_argop4\
    \ switch (unsigned argop) {\n       case OP_CB_GETATTR:    CB_GETATTR4args opcbgetattr;\n\
    \       case OP_CB_RECALL:     CB_RECALL4args  opcbrecall; };\n      struct CB_COMPOUND4args\
    \ {\n              utf8string      tag;\n              uint32_t        minorversion;\n\
    \              nfs_cb_argop4   argarray<>; };\n   RESULT\n      union nfs_cb_resop4\
    \ switch (unsigned resop){\n       case OP_CB_GETATTR:    CB_GETATTR4res  opcbgetattr;\n\
    \       case OP_CB_RECALL:     CB_RECALL4res   opcbrecall; };\n      struct CB_COMPOUND4res\
    \ {\n              nfsstat4 status;\n              utf8string      tag;\n    \
    \          nfs_cb_resop4   resarray<>; };\n   DESCRIPTION\n      The CB_COMPOUND\
    \ procedure is used to combine one or more of the\n      callback procedures into\
    \ a single RPC request.  The main callback\n      RPC program has two main procedures:\
    \ CB_NULL and CB_COMPOUND.  All\n      other operations use the CB_COMPOUND procedure\
    \ as a wrapper.\n      In the processing of the CB_COMPOUND procedure, the client\
    \ may\n      find that it does not have the available resources to execute any\n\
    \      or all of the operations within the CB_COMPOUND sequence.  In this\n  \
    \    case, the error NFS4ERR_RESOURCE will be returned for the\n      particular\
    \ operation within the CB_COMPOUND procedure where the\n      resource exhaustion\
    \ occurred.  This assumes that all previous\n      operations within the CB_COMPOUND\
    \ sequence have been evaluated\n      successfully.\n      Contained within the\
    \ CB_COMPOUND results is a 'status' field.\n      This status must be equivalent\
    \ to the status of the last operation\n      that was executed within the CB_COMPOUND\
    \ procedure.  Therefore, if\n      an operation incurred an error then the 'status'\
    \ value will be the\n      same error value as is being returned for the operation\
    \ that\n      failed.\n   IMPLEMENTATION\n      The CB_COMPOUND procedure is used\
    \ to combine individual operations\n      into a single RPC request.  The client\
    \ interprets each of the\n      operations in turn.  If an operation is executed\
    \ by the client and\n      the status of that operation is NFS4_OK, then the next\
    \ operation\n      in the CB_COMPOUND procedure is executed.  The client continues\n\
    \      this process until there are no more operations to be executed or\n   \
    \   one of the operations has a status value other than NFS4_OK.\n   ERRORS\n\
    \      NFS4ERR_BADHANDLE\n      NFS4ERR_BAD_STATEID\n      NFS4ERR_RESOURCE\n"
- title: '15.2.1.  Operation 3: CB_GETATTR - Get Attributes'
  contents:
  - "15.2.1.  Operation 3: CB_GETATTR - Get Attributes\n   SYNOPSIS\n      fh, attrbits\
    \ -> attrbits, attrvals\n   ARGUMENT\n      struct CB_GETATTR4args {\n       \
    \       nfs_fh4 fh;\n              bitmap4 attr_request;\n      };\n   RESULT\n\
    \      struct CB_GETATTR4resok {\n              fattr4  obj_attributes;\n    \
    \  };\n      union CB_GETATTR4res switch (nfsstat4 status) {\n       case NFS4_OK:\n\
    \               CB_GETATTR4resok       resok4;\n       default:\n            \
    \   void;\n      };\n   DESCRIPTION\n      The CB_GETATTR operation is used to\
    \ obtain the attributes modified\n      by an open delegate to allow the server\
    \ to respond to GETATTR\n      requests for a file which is the subject of an\
    \ open delegation.\n      If the handle specified is not one for which the client\
    \ holds a\n      write open delegation, an NFS4ERR_BADHANDLE error is returned.\n\
    \   IMPLEMENTATION\n      The client returns attrbits and the associated attribute\
    \ values\n      only for attributes that it may change (change, time_modify,\n\
    \      object_size).\n   ERRORS\n      NFS4ERR_BADHANDLE\n      NFS4ERR_RESOURCE\n"
- title: '15.2.2.  Operation 4: CB_RECALL - Recall an Open Delegation'
  contents:
  - "15.2.2.  Operation 4: CB_RECALL - Recall an Open Delegation\n   SYNOPSIS\n  \
    \    stateid, truncate, fh -> status\n   ARGUMENT\n      struct CB_RECALL4args\
    \ {\n              stateid4        stateid;\n              bool            truncate;\n\
    \              nfs_fh4         fh;\n      };\n   RESULT\n      struct CB_RECALL4res\
    \ {\n              nfsstat4        status;\n      };\n   DESCRIPTION\n      The\
    \ CB_RECALL operation is used to begin the process of recalling\n      an open\
    \ delegation and returning it to the server.\n      The truncate flag is used\
    \ to optimize recall for a file which is\n      about to be truncated to zero.\
    \  When it is set, the client is\n      freed of obligation to propagate modified\
    \ data for the file to the\n      server, since this data is irrelevant.\n   \
    \   If the handle specified is not one for which the client holds an\n      open\
    \ delegation, an NFS4ERR_BADHANDLE error is returned.\n      If the stateid specified\
    \ is not one corresponding to an open\n      delegation for the file specified\
    \ by the filehandle, an\n      NFS4ERR_BAD_STATEID is returned.\n   IMPLEMENTATION\n\
    \      The client should reply to the callback immediately.  Replying\n      does\
    \ not complete the recall.  The recall is not complete until\n      the delegation\
    \ is returned using a DELEGRETURN.\n   ERRORS\n      NFS4ERR_BADHANDLE\n     \
    \ NFS4ERR_BAD_STATEID\n      NFS4ERR_RESOURCE\n"
- title: 16.  Security Considerations
  contents:
  - "16.  Security Considerations\n   The major security feature to consider is the\
    \ authentication of the\n   user making the request of NFS service.  Consideration\
    \ should also be\n   given to the integrity and privacy of this NFS request. \
    \ These\n   specific issues are discussed as part of the section on \"RPC and\n\
    \   Security Flavor\".\n"
- title: 17.  IANA Considerations
  contents:
  - '17.  IANA Considerations

    '
- title: 17.1.  Named Attribute Definition
  contents:
  - "17.1.  Named Attribute Definition\n   The NFS version 4 protocol provides for\
    \ the association of named\n   attributes to files.  The name space identifiers\
    \ for these attributes\n   are defined as string names.  The protocol does not\
    \ define the\n   specific assignment of the name space for these file attributes;\
    \ the\n   application developer or system vendor is allowed to define the\n  \
    \ attribute, its semantics, and the associated name.  Even though this\n   name\
    \ space will not be specifically controlled to prevent collisions,\n   the application\
    \ developer or system vendor is strongly encouraged to\n   provide the name assignment\
    \ and associated semantics for attributes\n   via an Informational RFC.  This\
    \ will provide for interoperability\n   where common interests exist.\n"
- title: 18.  RPC definition file
  contents:
  - "18.  RPC definition file\n   /*\n    *  Copyright (C) The Internet Society (1998,1999,2000).\n\
    \    *  All Rights Reserved.\n    */\n   /*\n    *      nfs4_prot.x\n    *\n \
    \   */\n   %#pragma ident  \"@(#)nfs4_prot.x        1.97    00/06/12\"\n   /*\n\
    \    * Basic typedefs for RFC 1832 data type definitions\n    */\n   typedef int\
    \             int32_t;\n   typedef unsigned int    uint32_t;\n   typedef hyper\
    \           int64_t;\n   typedef unsigned hyper  uint64_t;\n   /*\n    * Sizes\n\
    \    */\n   const NFS4_FHSIZE               = 128;\n   const NFS4_VERIFIER_SIZE\
    \        = 8;\n   /*\n    * File types\n    */\n   enum nfs_ftype4 {\n       \
    \    NF4REG          = 1,    /* Regular File */\n           NF4DIR          =\
    \ 2,    /* Directory */\n           NF4BLK          = 3,    /* Special File -\
    \ block device */\n           NF4CHR          = 4,    /* Special File - character\
    \ device */\n           NF4LNK          = 5,    /* Symbolic Link */\n        \
    \   NF4SOCK         = 6,    /* Special File - socket */\n           NF4FIFO  \
    \       = 7,    /* Special File - fifo */\n           NF4ATTRDIR      = 8,   \
    \ /* Attribute Directory */\n           NF4NAMEDATTR    = 9     /* Named Attribute\
    \ */\n   };\n   /*\n    * Error status\n    */\n   enum nfsstat4 {\n         \
    \  NFS4_OK                 = 0,\n           NFS4ERR_PERM            = 1,\n   \
    \        NFS4ERR_NOENT           = 2,\n           NFS4ERR_IO              = 5,\n\
    \           NFS4ERR_NXIO            = 6,\n           NFS4ERR_ACCES           =\
    \ 13,\n           NFS4ERR_EXIST           = 17,\n           NFS4ERR_XDEV     \
    \       = 18,\n           NFS4ERR_NODEV           = 19,\n           NFS4ERR_NOTDIR\
    \          = 20,\n           NFS4ERR_ISDIR           = 21,\n           NFS4ERR_INVAL\
    \           = 22,\n           NFS4ERR_FBIG            = 27,\n           NFS4ERR_NOSPC\
    \           = 28,\n           NFS4ERR_ROFS            = 30,\n           NFS4ERR_MLINK\
    \           = 31,\n           NFS4ERR_NAMETOOLONG     = 63,\n           NFS4ERR_NOTEMPTY\
    \        = 66,\n           NFS4ERR_DQUOT           = 69,\n           NFS4ERR_STALE\
    \           = 70,\n           NFS4ERR_BADHANDLE       = 10001,\n           NFS4ERR_BAD_COOKIE\
    \      = 10003,\n           NFS4ERR_NOTSUPP         = 10004,\n           NFS4ERR_TOOSMALL\
    \        = 10005,\n           NFS4ERR_SERVERFAULT     = 10006,\n           NFS4ERR_BADTYPE\
    \         = 10007,\n           NFS4ERR_DELAY           = 10008,\n           NFS4ERR_SAME\
    \            = 10009,/* nverify says attrs same */\n           NFS4ERR_DENIED\
    \          = 10010,/* lock unavailable        */\n           NFS4ERR_EXPIRED \
    \        = 10011,/* lock lease expired      */\n           NFS4ERR_LOCKED    \
    \      = 10012,/* I/O failed due to lock  */\n           NFS4ERR_GRACE       \
    \    = 10013,/* in grace period         */\n           NFS4ERR_FHEXPIRED     \
    \  = 10014,/* file handle expired     */\n           NFS4ERR_SHARE_DENIED    =\
    \ 10015,/* share reserve denied    */\n           NFS4ERR_WRONGSEC        = 10016,/*\
    \ wrong security flavor   */\n           NFS4ERR_CLID_INUSE      = 10017,/* clientid\
    \ in use         */\n           NFS4ERR_RESOURCE        = 10018,/* resource exhaustion\
    \     */\n           NFS4ERR_MOVED           = 10019,/* filesystem relocated \
    \   */\n           NFS4ERR_NOFILEHANDLE    = 10020,/* current FH is not set  \
    \ */\n           NFS4ERR_MINOR_VERS_MISMATCH = 10021,/* minor vers not supp */\n\
    \           NFS4ERR_STALE_CLIENTID  = 10022,\n           NFS4ERR_STALE_STATEID\
    \   = 10023,\n           NFS4ERR_OLD_STATEID     = 10024,\n           NFS4ERR_BAD_STATEID\
    \     = 10025,\n           NFS4ERR_BAD_SEQID       = 10026,\n           NFS4ERR_NOT_SAME\
    \        = 10027,/* verify - attrs not same */\n           NFS4ERR_LOCK_RANGE\
    \      = 10028,\n           NFS4ERR_SYMLINK         = 10029,\n           NFS4ERR_READDIR_NOSPC\
    \   = 10030,\n           NFS4ERR_LEASE_MOVED     = 10031\n   };\n   /*\n    *\
    \ Basic data types\n    */\n   typedef uint32_t        bitmap4<>;\n   typedef\
    \ uint64_t        offset4;\n   typedef uint32_t        count4;\n   typedef uint64_t\
    \        length4;\n   typedef uint64_t        clientid4;\n   typedef uint64_t\
    \        stateid4;\n   typedef uint32_t        seqid4;\n   typedef opaque    \
    \      utf8string<>;\n   typedef utf8string      component4;\n   typedef component4\
    \      pathname4<>;\n   typedef uint64_t        nfs_lockid4;\n   typedef uint64_t\
    \        nfs_cookie4;\n   typedef utf8string      linktext4;\n   typedef opaque\
    \          sec_oid4<>;\n   typedef uint32_t        qop4;\n   typedef uint32_t\
    \        mode4;\n   typedef uint64_t        changeid4;\n   typedef opaque    \
    \      verifier4[NFS4_VERIFIER_SIZE];\n   /*\n    * Timeval\n    */\n   struct\
    \ nfstime4 {\n           int64_t         seconds;\n           uint32_t       \
    \ nseconds;\n   };\n   enum time_how4 {\n           SET_TO_SERVER_TIME4 = 0,\n\
    \           SET_TO_CLIENT_TIME4 = 1\n   };\n   union settime4 switch (time_how4\
    \ set_it) {\n    case SET_TO_CLIENT_TIME4:\n            nfstime4       time;\n\
    \    default:\n            void;\n   };\n   /*\n    * File access handle\n   \
    \ */\n   typedef opaque  nfs_fh4<NFS4_FHSIZE>;\n   /*\n    * File attribute definitions\n\
    \    */\n   /*\n    * FSID structure for major/minor\n    */\n   struct fsid4\
    \ {\n           uint64_t        major;\n           uint64_t        minor;\n  \
    \ };\n   /*\n    * Filesystem locations attribute for relocation/migration\n \
    \   */\n   struct fs_location4 {\n           utf8string      server<>;\n     \
    \      pathname4       rootpath;\n   };\n   struct fs_locations4 {\n         \
    \  pathname4       fs_root;\n           fs_location4    locations<>;\n   };\n\
    \   /*\n    * Various Access Control Entry definitions\n    */\n   /*\n    * Mask\
    \ that indicates which Access Control Entries are supported.\n    * Values for\
    \ the fattr4_aclsupport attribute.\n    */\n   const ACL4_SUPPORT_ALLOW_ACL  \
    \  = 0x00000001;\n   const ACL4_SUPPORT_DENY_ACL     = 0x00000002;\n   const ACL4_SUPPORT_AUDIT_ACL\
    \    = 0x00000004;\n   const ACL4_SUPPORT_ALARM_ACL    = 0x00000008;\n   typedef\
    \ uint32_t        acetype4;\n   /*\n    * acetype4 values, others can be added\
    \ as needed.\n    */\n   const ACE4_ACCESS_ALLOWED_ACE_TYPE      = 0x00000000;\n\
    \   const ACE4_ACCESS_DENIED_ACE_TYPE       = 0x00000001;\n   const ACE4_SYSTEM_AUDIT_ACE_TYPE\
    \        = 0x00000002;\n   const ACE4_SYSTEM_ALARM_ACE_TYPE        = 0x00000003;\n\
    \   /*\n    * ACE flag\n    */\n   typedef uint32_t aceflag4;\n   /*\n    * ACE\
    \ flag values\n    */\n   const ACE4_FILE_INHERIT_ACE             = 0x00000001;\n\
    \   const ACE4_DIRECTORY_INHERIT_ACE        = 0x00000002;\n   const ACE4_NO_PROPAGATE_INHERIT_ACE\
    \     = 0x00000004;\n   const ACE4_INHERIT_ONLY_ACE             = 0x00000008;\n\
    \   const ACE4_SUCCESSFUL_ACCESS_ACE_FLAG   = 0x00000010;\n   const ACE4_FAILED_ACCESS_ACE_FLAG\
    \       = 0x00000020;\n   const ACE4_IDENTIFIER_GROUP             = 0x00000040;\n\
    \   /*\n    * ACE mask\n    */\n   typedef uint32_t        acemask4;\n   /*\n\
    \    * ACE mask values\n    */\n   const ACE4_READ_DATA            = 0x00000001;\n\
    \   const ACE4_LIST_DIRECTORY       = 0x00000001;\n   const ACE4_WRITE_DATA  \
    \         = 0x00000002;\n   const ACE4_ADD_FILE             = 0x00000002;\n  \
    \ const ACE4_APPEND_DATA          = 0x00000004;\n   const ACE4_ADD_SUBDIRECTORY\
    \     = 0x00000004;\n   const ACE4_READ_NAMED_ATTRS     = 0x00000008;\n   const\
    \ ACE4_WRITE_NAMED_ATTRS    = 0x00000010;\n   const ACE4_EXECUTE             \
    \ = 0x00000020;\n   const ACE4_DELETE_CHILD         = 0x00000040;\n   const ACE4_READ_ATTRIBUTES\
    \      = 0x00000080;\n   const ACE4_WRITE_ATTRIBUTES     = 0x00000100;\n   const\
    \ ACE4_DELETE               = 0x00010000;\n   const ACE4_READ_ACL            \
    \ = 0x00020000;\n   const ACE4_WRITE_ACL            = 0x00040000;\n   const ACE4_WRITE_OWNER\
    \          = 0x00080000;\n   const ACE4_SYNCHRONIZE          = 0x00100000;\n \
    \  /*\n    * ACE4_GENERIC_READ -- defined as combination of\n    *      ACE4_READ_ACL\
    \ |\n    *      ACE4_READ_DATA |\n    *      ACE4_READ_ATTRIBUTES |\n    *   \
    \   ACE4_SYNCHRONIZE\n    */\n   const ACE4_GENERIC_READ = 0x00120081;\n   /*\n\
    \    * ACE4_GENERIC_WRITE -- defined as combination of\n    *      ACE4_READ_ACL\
    \ |\n    *      ACE4_WRITE_DATA |\n    *      ACE4_WRITE_ATTRIBUTES |\n    * \
    \     ACE4_WRITE_ACL |\n    *      ACE4_APPEND_DATA |\n    *      ACE4_SYNCHRONIZE\n\
    \    */\n   const ACE4_GENERIC_WRITE = 0x00160106;\n   /*\n    * ACE4_GENERIC_EXECUTE\
    \ -- defined as combination of\n    *      ACE4_READ_ACL\n    *      ACE4_READ_ATTRIBUTES\n\
    \    *      ACE4_EXECUTE\n    *      ACE4_SYNCHRONIZE\n    */\n   const ACE4_GENERIC_EXECUTE\
    \ = 0x001200A0;\n   /*\n    * Access Control Entry definition\n    */\n   struct\
    \ nfsace4 {\n           acetype4        type;\n           aceflag4        flag;\n\
    \           acemask4        access_mask;\n           utf8string      who;\n  \
    \ };\n   /*\n    * Special data/attribute associated with\n    * file types NF4BLK\
    \ and NF4CHR.\n    */\n   struct specdata4 {\n           uint32_t        specdata1;\n\
    \           uint32_t        specdata2;\n   };\n   /*\n    * Values for fattr4_fh_expire_type\n\
    \    */\n   const   FH4_PERSISTENT          = 0x00000000;\n   const   FH4_NOEXPIRE_WITH_OPEN\
    \  = 0x00000001;\n   const   FH4_VOLATILE_ANY        = 0x00000002;\n   const \
    \  FH4_VOL_MIGRATION       = 0x00000004;\n   const   FH4_VOL_RENAME          =\
    \ 0x00000008;\n   typedef bitmap4         fattr4_supported_attrs;\n   typedef\
    \ nfs_ftype4      fattr4_type;\n   typedef uint32_t        fattr4_fh_expire_type;\n\
    \   typedef changeid4       fattr4_change;\n   typedef uint64_t        fattr4_size;\n\
    \   typedef bool            fattr4_link_support;\n   typedef bool            fattr4_symlink_support;\n\
    \   typedef bool            fattr4_named_attr;\n   typedef fsid4           fattr4_fsid;\n\
    \   typedef bool            fattr4_unique_handles;\n   typedef uint32_t      \
    \  fattr4_lease_time;\n   typedef nfsstat4        fattr4_rdattr_error;\n   typedef\
    \ nfsace4         fattr4_acl<>;\n   typedef uint32_t        fattr4_aclsupport;\n\
    \   typedef bool            fattr4_archive;\n   typedef bool            fattr4_cansettime;\n\
    \   typedef bool            fattr4_case_insensitive;\n   typedef bool        \
    \    fattr4_case_preserving;\n   typedef bool            fattr4_chown_restricted;\n\
    \   typedef uint64_t        fattr4_fileid;\n   typedef uint64_t        fattr4_files_avail;\n\
    \   typedef nfs_fh4         fattr4_filehandle;\n   typedef uint64_t        fattr4_files_free;\n\
    \   typedef uint64_t        fattr4_files_total;\n   typedef fs_locations4   fattr4_fs_locations;\n\
    \   typedef bool            fattr4_hidden;\n   typedef bool            fattr4_homogeneous;\n\
    \   typedef uint64_t        fattr4_maxfilesize;\n   typedef uint32_t        fattr4_maxlink;\n\
    \   typedef uint32_t        fattr4_maxname;\n   typedef uint64_t        fattr4_maxread;\n\
    \   typedef uint64_t        fattr4_maxwrite;\n   typedef utf8string      fattr4_mimetype;\n\
    \   typedef mode4           fattr4_mode;\n   typedef bool            fattr4_no_trunc;\n\
    \   typedef uint32_t        fattr4_numlinks;\n   typedef utf8string      fattr4_owner;\n\
    \   typedef utf8string      fattr4_owner_group;\n   typedef uint64_t        fattr4_quota_avail_hard;\n\
    \   typedef uint64_t        fattr4_quota_avail_soft;\n   typedef uint64_t    \
    \    fattr4_quota_used;\n   typedef specdata4       fattr4_rawdev;\n   typedef\
    \ uint64_t        fattr4_space_avail;\n   typedef uint64_t        fattr4_space_free;\n\
    \   typedef uint64_t        fattr4_space_total;\n   typedef uint64_t        fattr4_space_used;\n\
    \   typedef bool            fattr4_system;\n   typedef nfstime4        fattr4_time_access;\n\
    \   typedef settime4        fattr4_time_access_set;\n   typedef nfstime4     \
    \   fattr4_time_backup;\n   typedef nfstime4        fattr4_time_create;\n   typedef\
    \ nfstime4        fattr4_time_delta;\n   typedef nfstime4        fattr4_time_metadata;\n\
    \   typedef nfstime4        fattr4_time_modify;\n   typedef settime4        fattr4_time_modify_set;\n\
    \   /*\n    * Mandatory Attributes\n    */\n   const FATTR4_SUPPORTED_ATTRS  \
    \  = 0;\n   const FATTR4_TYPE               = 1;\n   const FATTR4_FH_EXPIRE_TYPE\
    \     = 2;\n   const FATTR4_CHANGE             = 3;\n   const FATTR4_SIZE    \
    \           = 4;\n   const FATTR4_LINK_SUPPORT       = 5;\n   const FATTR4_SYMLINK_SUPPORT\
    \    = 6;\n   const FATTR4_NAMED_ATTR         = 7;\n   const FATTR4_FSID     \
    \          = 8;\n   const FATTR4_UNIQUE_HANDLES     = 9;\n   const FATTR4_LEASE_TIME\
    \         = 10;\n   const FATTR4_RDATTR_ERROR       = 11;\n   /*\n    * Recommended\
    \ Attributes\n    */\n   const FATTR4_ACL                = 12;\n   const FATTR4_ACLSUPPORT\
    \         = 13;\n   const FATTR4_ARCHIVE            = 14;\n   const FATTR4_CANSETTIME\
    \         = 15;\n   const FATTR4_CASE_INSENSITIVE   = 16;\n   const FATTR4_CASE_PRESERVING\
    \    = 17;\n   const FATTR4_CHOWN_RESTRICTED   = 18;\n   const FATTR4_FILEHANDLE\
    \         = 19;\n   const FATTR4_FILEID             = 20;\n   const FATTR4_FILES_AVAIL\
    \        = 21;\n   const FATTR4_FILES_FREE         = 22;\n   const FATTR4_FILES_TOTAL\
    \        = 23;\n   const FATTR4_FS_LOCATIONS       = 24;\n   const FATTR4_HIDDEN\
    \             = 25;\n   const FATTR4_HOMOGENEOUS        = 26;\n   const FATTR4_MAXFILESIZE\
    \        = 27;\n   const FATTR4_MAXLINK            = 28;\n   const FATTR4_MAXNAME\
    \            = 29;\n   const FATTR4_MAXREAD            = 30;\n   const FATTR4_MAXWRITE\
    \           = 31;\n   const FATTR4_MIMETYPE           = 32;\n   const FATTR4_MODE\
    \               = 33;\n   const FATTR4_NO_TRUNC           = 34;\n   const FATTR4_NUMLINKS\
    \           = 35;\n   const FATTR4_OWNER              = 36;\n   const FATTR4_OWNER_GROUP\
    \        = 37;\n   const FATTR4_QUOTA_AVAIL_HARD   = 38;\n   const FATTR4_QUOTA_AVAIL_SOFT\
    \   = 39;\n   const FATTR4_QUOTA_USED         = 40;\n   const FATTR4_RAWDEV  \
    \           = 41;\n   const FATTR4_SPACE_AVAIL        = 42;\n   const FATTR4_SPACE_FREE\
    \         = 43;\n   const FATTR4_SPACE_TOTAL        = 44;\n   const FATTR4_SPACE_USED\
    \         = 45;\n   const FATTR4_SYSTEM             = 46;\n   const FATTR4_TIME_ACCESS\
    \        = 47;\n   const FATTR4_TIME_ACCESS_SET    = 48;\n   const FATTR4_TIME_BACKUP\
    \        = 49;\n   const FATTR4_TIME_CREATE        = 50;\n   const FATTR4_TIME_DELTA\
    \         = 51;\n   const FATTR4_TIME_METADATA      = 52;\n   const FATTR4_TIME_MODIFY\
    \        = 53;\n   const FATTR4_TIME_MODIFY_SET    = 54;\n   typedef opaque  attrlist4<>;\n\
    \   /*\n    * File attribute container\n    */\n   struct fattr4 {\n         \
    \  bitmap4         attrmask;\n           attrlist4       attr_vals;\n   };\n \
    \  /*\n    * Change info for the client\n    */\n   struct change_info4 {\n  \
    \         bool            atomic;\n           changeid4       before;\n      \
    \     changeid4       after;\n   };\n   struct clientaddr4 {\n           /* see\
    \ struct rpcb in RFC 1833 */\n           string r_netid<>;               /* network\
    \ id */\n           string r_addr<>;                /* universal address */\n\
    \   };\n   /*\n    * Callback program info as provided by the client\n    */\n\
    \   struct cb_client4 {\n           unsigned int    cb_program;\n           clientaddr4\
    \     cb_location;\n   };\n   /*\n    * Client ID\n    */\n   struct nfs_client_id4\
    \ {\n           verifier4       verifier;\n           opaque          id<>;\n\
    \   };\n   struct nfs_lockowner4 {\n           clientid4       clientid;\n   \
    \        opaque          owner<>;\n   };\n   enum nfs_lock_type4 {\n         \
    \  READ_LT         = 1,\n           WRITE_LT        = 2,\n           READW_LT\
    \        = 3,    /* blocking read */\n           WRITEW_LT       = 4     /* blocking\
    \ write */\n   };\n   /*\n    * ACCESS: Check access permission\n    */\n   const\
    \ ACCESS4_READ      = 0x00000001;\n   const ACCESS4_LOOKUP    = 0x00000002;\n\
    \   const ACCESS4_MODIFY    = 0x00000004;\n   const ACCESS4_EXTEND    = 0x00000008;\n\
    \   const ACCESS4_DELETE    = 0x00000010;\n   const ACCESS4_EXECUTE   = 0x00000020;\n\
    \   struct ACCESS4args {\n           /* CURRENT_FH: object */\n           uint32_t\
    \        access;\n   };\n   struct ACCESS4resok {\n           uint32_t       \
    \ supported;\n           uint32_t        access;\n   };\n   union ACCESS4res switch\
    \ (nfsstat4 status) {\n    case NFS4_OK:\n            ACCESS4resok   resok4;\n\
    \    default:\n            void;\n   };\n   /*\n    * CLOSE: Close a file and\
    \ release share locks\n    */\n   struct CLOSE4args {\n           /* CURRENT_FH:\
    \ object */\n           seqid4          seqid;\n           stateid4        stateid;\n\
    \   };\n   union CLOSE4res switch (nfsstat4 status) {\n    case NFS4_OK:\n   \
    \         stateid4       stateid;\n    default:\n            void;\n   };\n  \
    \ /*\n    * COMMIT: Commit cached data on server to stable storage\n    */\n \
    \  struct COMMIT4args {\n           /* CURRENT_FH: file */\n           offset4\
    \         offset;\n           count4          count;\n   };\n   struct COMMIT4resok\
    \ {\n           verifier4       writeverf;\n   };\n   union COMMIT4res switch\
    \ (nfsstat4 status) {\n    case NFS4_OK:\n            COMMIT4resok   resok4;\n\
    \    default:\n            void;\n   };\n   /*\n    * CREATE: Create a file\n\
    \    */\n   union createtype4 switch (nfs_ftype4 type) {\n    case NF4LNK:\n \
    \           linktext4      linkdata;\n    case NF4BLK:\n    case NF4CHR:\n   \
    \         specdata4      devdata;\n    case NF4SOCK:\n    case NF4FIFO:\n    case\
    \ NF4DIR:\n            void;\n   };\n   struct CREATE4args {\n           /* CURRENT_FH:\
    \ directory for creation */\n           component4      objname;\n           createtype4\
    \     objtype;\n   };\n   struct CREATE4resok {\n           change_info4     cinfo;\n\
    \   };\n   union CREATE4res switch (nfsstat4 status) {\n    case NFS4_OK:\n  \
    \          CREATE4resok resok4;\n    default:\n            void;\n   };\n   /*\n\
    \    * DELEGPURGE: Purge Delegations Awaiting Recovery\n    */\n   struct DELEGPURGE4args\
    \ {\n           clientid4       clientid;\n   };\n   struct DELEGPURGE4res {\n\
    \           nfsstat4        status;\n   };\n   /*\n    * DELEGRETURN: Return a\
    \ delegation\n    */\n   struct DELEGRETURN4args {\n           stateid4      \
    \  stateid;\n   };\n   struct DELEGRETURN4res {\n           nfsstat4        status;\n\
    \   };\n   /*\n    * GETATTR: Get file attributes\n    */\n   struct GETATTR4args\
    \ {\n           /* CURRENT_FH: directory or file */\n           bitmap4      \
    \   attr_request;\n   };\n   struct GETATTR4resok {\n           fattr4       \
    \   obj_attributes;\n   };\n   union GETATTR4res switch (nfsstat4 status) {\n\
    \    case NFS4_OK:\n            GETATTR4resok  resok4;\n    default:\n       \
    \     void;\n   };\n   /*\n    * GETFH: Get current filehandle\n    */\n   struct\
    \ GETFH4resok {\n           nfs_fh4         object;\n   };\n   union GETFH4res\
    \ switch (nfsstat4 status) {\n    case NFS4_OK:\n           GETFH4resok     resok4;\n\
    \    default:\n           void;\n   };\n   /*\n    * LINK: Create link to an object\n\
    \    */\n   struct LINK4args {\n           /* SAVED_FH: source object */\n   \
    \        /* CURRENT_FH: target directory */\n           component4      newname;\n\
    \   };\n   struct LINK4resok {\n           change_info4    cinfo;\n   };\n   union\
    \ LINK4res switch (nfsstat4 status) {\n    case NFS4_OK:\n            LINK4resok\
    \ resok4;\n    default:\n            void;\n   };\n   /*\n    * LOCK/LOCKT/LOCKU:\
    \ Record lock management\n    */\n   struct LOCK4args {\n           /* CURRENT_FH:\
    \ file */\n           nfs_lock_type4  locktype;\n           seqid4          seqid;\n\
    \           bool            reclaim;\n           stateid4        stateid;\n  \
    \         offset4         offset;\n           length4         length;\n   };\n\
    \   struct LOCK4denied {\n           nfs_lockowner4  owner;\n           offset4\
    \         offset;\n           length4         length;\n   };\n   union LOCK4res\
    \ switch (nfsstat4 status) {\n    case NFS4_OK:\n            stateid4       stateid;\n\
    \    case NFS4ERR_DENIED:\n            LOCK4denied    denied;\n    default:\n\
    \            void;\n   };\n   struct LOCKT4args {\n           /* CURRENT_FH: file\
    \ */\n           nfs_lock_type4  locktype;\n           nfs_lockowner4  owner;\n\
    \           offset4         offset;\n           length4         length;\n   };\n\
    \   union LOCKT4res switch (nfsstat4 status) {\n    case NFS4ERR_DENIED:\n   \
    \         LOCK4denied    denied;\n    case NFS4_OK:\n            void;\n    default:\n\
    \            void;\n   };\n   struct LOCKU4args {\n           /* CURRENT_FH: file\
    \ */\n           nfs_lock_type4  locktype;\n           seqid4          seqid;\n\
    \           stateid4        stateid;\n           offset4         offset;\n   \
    \        length4         length;\n   };\n   union LOCKU4res switch (nfsstat4 status)\
    \ {\n    case   NFS4_OK:\n            stateid4       stateid;\n    default:\n\
    \            void;\n   };\n   /*\n    * LOOKUP: Lookup filename\n    */\n   struct\
    \ LOOKUP4args {\n           /* CURRENT_FH: directory */\n           pathname4\
    \       path;\n   };\n   struct LOOKUP4res {\n           /* CURRENT_FH: object\
    \ */\n           nfsstat4        status;\n   };\n   /*\n    * LOOKUPP: Lookup\
    \ parent directory\n    */\n   struct LOOKUPP4res {\n           /* CURRENT_FH:\
    \ directory */\n           nfsstat4        status;\n   };\n   /*\n    * NVERIFY:\
    \ Verify attributes different\n    */\n   struct NVERIFY4args {\n           /*\
    \ CURRENT_FH: object */\n           fattr4          obj_attributes;\n   };\n \
    \  struct NVERIFY4res {\n           nfsstat4        status;\n   };\n   /*\n  \
    \  * Various definitions for OPEN\n    */\n   enum createmode4 {\n           UNCHECKED4\
    \      = 0,\n           GUARDED4        = 1,\n           EXCLUSIVE4      = 2\n\
    \   };\n   union createhow4 switch (createmode4 mode) {\n    case UNCHECKED4:\n\
    \    case GUARDED4:\n            fattr4         createattrs;\n    case EXCLUSIVE4:\n\
    \            verifier4      createverf;\n   };\n   enum opentype4 {\n        \
    \   OPEN4_NOCREATE  = 0,\n           OPEN4_CREATE    = 1\n   };\n   union openflag4\
    \ switch (opentype4 opentype) {\n    case OPEN4_CREATE:\n            createhow4\
    \     how;\n    default:\n            void;\n   };\n   /* Next definitions used\
    \ for OPEN delegation */\n   enum limit_by4 {\n           NFS_LIMIT_SIZE     \
    \     = 1,\n           NFS_LIMIT_BLOCKS        = 2\n           /* others as needed\
    \ */\n   };\n   struct nfs_modified_limit4 {\n           uint32_t        num_blocks;\n\
    \           uint32_t        bytes_per_block;\n   };\n   union nfs_space_limit4\
    \ switch (limit_by4 limitby) {\n    /* limit specified as file size */\n    case\
    \ NFS_LIMIT_SIZE:\n            uint64_t               filesize;\n    /* limit\
    \ specified by number of blocks */\n    case NFS_LIMIT_BLOCKS:\n            nfs_modified_limit4\
    \    mod_blocks;\n   } ;\n   /*\n    * Share Access and Deny constants for open\
    \ argument\n    */\n   const OPEN4_SHARE_ACCESS_READ   = 0x00000001;\n   const\
    \ OPEN4_SHARE_ACCESS_WRITE  = 0x00000002;\n   const OPEN4_SHARE_ACCESS_BOTH  \
    \ = 0x00000003;\n   const OPEN4_SHARE_DENY_NONE     = 0x00000000;\n   const OPEN4_SHARE_DENY_READ\
    \     = 0x00000001;\n   const OPEN4_SHARE_DENY_WRITE    = 0x00000002;\n   const\
    \ OPEN4_SHARE_DENY_BOTH     = 0x00000003;\n   enum open_delegation_type4 {\n \
    \          OPEN_DELEGATE_NONE      = 0,\n           OPEN_DELEGATE_READ      =\
    \ 1,\n           OPEN_DELEGATE_WRITE     = 2\n   };\n   enum open_claim_type4\
    \ {\n           CLAIM_NULL              = 0,\n           CLAIM_PREVIOUS      \
    \    = 1,\n           CLAIM_DELEGATE_CUR      = 2,\n           CLAIM_DELEGATE_PREV\
    \     = 3\n   };\n   struct open_claim_delegate_cur4 {\n           pathname4 \
    \      file;\n           stateid4        delegate_stateid;\n   };\n   union open_claim4\
    \ switch (open_claim_type4 claim) {\n    /*\n     * No special rights to file.\
    \ Ordinary OPEN of the specified file.\n     */\n    case CLAIM_NULL:\n      \
    \     /* CURRENT_FH: directory */\n           pathname4       file;\n    /*\n\
    \     * Right to the file established by an open previous to server\n     * reboot.\
    \  File identified by filehandle obtained at that time\n     * rather than by\
    \ name.\n     */\n    case CLAIM_PREVIOUS:\n           /* CURRENT_FH: file being\
    \ reclaimed */\n           uint32_t        delegate_type;\n    /*\n     * Right\
    \ to file based on a delegation granted by the server.\n     * File is specified\
    \ by name.\n     */\n    case CLAIM_DELEGATE_CUR:\n           /* CURRENT_FH: directory\
    \ */\n           open_claim_delegate_cur4        delegate_cur_info;\n    /* Right\
    \ to file based on a delegation granted to a previous boot\n     * instance of\
    \ the client.  File is specified by name.\n     */\n    case CLAIM_DELEGATE_PREV:\n\
    \            /* CURRENT_FH: directory */\n           pathname4       file_delegate_prev;\n\
    \   };\n   /*\n    * OPEN: Open a file, potentially receiving an open delegation\n\
    \    */\n   struct OPEN4args {\n           open_claim4     claim;\n          \
    \ openflag4       openhow;\n           nfs_lockowner4  owner;\n           seqid4\
    \          seqid;\n           uint32_t        share_access;\n           uint32_t\
    \        share_deny;\n   };\n   struct open_read_delegation4 {\n           stateid4\
    \        stateid;        /* Stateid for delegation*/\n           bool        \
    \    recall;         /* Pre-recalled flag for\n                              \
    \                delegations obtained\n                                      \
    \        by reclaim\n                                              (CLAIM_PREVIOUS)\
    \ */\n           nfsace4         permissions;    /* Defines users who don't\n\
    \                                              need an ACCESS call to\n      \
    \                                        open for read */\n   };\n   struct open_write_delegation4\
    \ {\n           stateid4        stateid;        /* Stateid for delegation */\n\
    \           bool            recall;         /* Pre-recalled flag for\n       \
    \                                       delegations obtained\n               \
    \                               by reclaim\n                                 \
    \             (CLAIM_PREVIOUS) */\n           nfs_space_limit4 space_limit;  \
    \ /* Defines condition that\n                                              the\
    \ client must check to\n                                              determine\
    \ whether the\n                                              file needs to be\
    \ flushed\n                                              to the server on close.\n\
    \                                              */\n           nfsace4        \
    \ permissions;    /* Defines users who don't\n                               \
    \               need an ACCESS call as\n                                     \
    \         part of a delegated\n                                              open.\
    \ */\n   };\n   union open_delegation4\n   switch (open_delegation_type4 delegation_type)\
    \ {\n           case OPEN_DELEGATE_NONE:\n                   void;\n         \
    \  case OPEN_DELEGATE_READ:\n                   open_read_delegation4 read;\n\
    \           case OPEN_DELEGATE_WRITE:\n                   open_write_delegation4\
    \ write;\n   };\n   /*\n    * Result flags\n    */\n   /* Mandatory locking is\
    \ in effect for this file. */\n   const OPEN4_RESULT_MLOCK        = 0x00000001;\n\
    \   /* Client must confirm open */\n   const OPEN4_RESULT_CONFIRM      = 0x00000002;\n\
    \   struct OPEN4resok {\n           stateid4        stateid;        /* Stateid\
    \ for open */\n           change_info4    cinfo;          /* Directory Change\
    \ Info */\n           uint32_t        rflags;         /* Result flags */\n   \
    \        verifier4       open_confirm;   /* OPEN_CONFIRM verifier */\n       \
    \    open_delegation4 delegation;    /* Info on any open\n                   \
    \                           delegation */\n   };\n   union OPEN4res switch (nfsstat4\
    \ status) {\n    case NFS4_OK:\n           /* CURRENT_FH: opened file */\n   \
    \        OPEN4resok      resok4;\n    default:\n           void;\n   };\n   /*\n\
    \    * OPENATTR: open named attributes directory\n    */\n   struct OPENATTR4res\
    \ {\n           /* CURRENT_FH: name attr directory*/\n           nfsstat4    \
    \    status;\n   };\n   /*\n    * OPEN_CONFIRM: confirm the open\n    */\n   struct\
    \ OPEN_CONFIRM4args {\n           /* CURRENT_FH: opened file */\n           seqid4\
    \          seqid;\n           verifier4       open_confirm;   /* OPEN_CONFIRM\
    \ verifier */\n   };\n   struct OPEN_CONFIRM4resok {\n           stateid4    \
    \    stateid;\n   };\n   union OPEN_CONFIRM4res switch (nfsstat4 status) {\n \
    \   case NFS4_OK:\n            OPEN_CONFIRM4resok     resok4;\n    default:\n\
    \            void;\n   };\n   /*\n    * OPEN_DOWNGRADE: downgrade the access/deny\
    \ for a file\n    */\n   struct OPEN_DOWNGRADE4args {\n           /* CURRENT_FH:\
    \ opened file */\n           stateid4        stateid;\n           seqid4     \
    \     seqid;\n           uint32_t        share_access;\n           uint32_t  \
    \      share_deny;\n   };\n   struct OPEN_DOWNGRADE4resok {\n              stateid4\
    \        stateid;\n   };\n   union OPEN_DOWNGRADE4res switch(nfsstat4 status)\
    \ {\n    case NFS4_OK:\n           OPEN_DOWNGRADE4resok    resok4;\n    default:\n\
    \            void;\n   };\n   /*\n    * PUTFH: Set current filehandle\n    */\n\
    \   struct PUTFH4args {\n           nfs_fh4         object;\n   };\n   struct\
    \ PUTFH4res {\n           /* CURRENT_FH: */\n           nfsstat4        status;\n\
    \   };\n   /*\n    * PUTPUBFH: Set public filehandle\n    */\n   struct PUTPUBFH4res\
    \ {\n           /* CURRENT_FH: public fh */\n           nfsstat4        status;\n\
    \   };\n   /*\n    * PUTROOTFH: Set root filehandle\n    */\n   struct PUTROOTFH4res\
    \ {\n           /* CURRENT_FH: root fh */\n           nfsstat4        status;\n\
    \   };\n   /*\n    * READ: Read from file\n    */\n   struct READ4args {\n   \
    \        /* CURRENT_FH: file */\n           stateid4        stateid;\n       \
    \    offset4         offset;\n           count4          count;\n   };\n   struct\
    \ READ4resok {\n           bool            eof;\n           opaque          data<>;\n\
    \   };\n   union READ4res switch (nfsstat4 status) {\n    case NFS4_OK:\n    \
    \        READ4resok     resok4;\n    default:\n            void;\n   };\n   /*\n\
    \    * READDIR: Read directory\n    */\n   struct READDIR4args {\n           /*\
    \ CURRENT_FH: directory */\n           nfs_cookie4     cookie;\n           verifier4\
    \       cookieverf;\n           count4          dircount;\n           count4 \
    \         maxcount;\n           bitmap4         attr_request;\n   };\n   struct\
    \ entry4 {\n           nfs_cookie4     cookie;\n           component4      name;\n\
    \           fattr4          attrs;\n           entry4          *nextentry;\n \
    \  };\n   struct dirlist4 {\n           entry4          *entries;\n          \
    \ bool            eof;\n   };\n   struct READDIR4resok {\n           verifier4\
    \       cookieverf;\n           dirlist4        reply;\n   };\n   union READDIR4res\
    \ switch (nfsstat4 status) {\n    case NFS4_OK:\n            READDIR4resok  resok4;\n\
    \    default:\n            void;\n   };\n   /*\n    * READLINK: Read symbolic\
    \ link\n    */\n   struct READLINK4resok {\n           linktext4       link;\n\
    \   };\n   union READLINK4res switch (nfsstat4 status) {\n    case NFS4_OK:\n\
    \            READLINK4resok resok4;\n    default:\n            void;\n   };\n\
    \   /*\n    * REMOVE: Remove filesystem object\n    */\n   struct REMOVE4args\
    \ {\n           /* CURRENT_FH: directory */\n           component4      target;\n\
    \   };\n   struct REMOVE4resok {\n           change_info4    cinfo;\n   };\n \
    \  union REMOVE4res switch (nfsstat4 status) {\n    case NFS4_OK:\n          \
    \  REMOVE4resok   resok4;\n    default:\n            void;\n   };\n   /*\n   \
    \ * RENAME: Rename directory entry\n    */\n   struct RENAME4args {\n        \
    \   /* SAVED_FH: source directory */\n           component4      oldname;\n  \
    \         /* CURRENT_FH: target directory */\n           component4      newname;\n\
    \   };\n   struct RENAME4resok {\n           change_info4    source_cinfo;\n \
    \          change_info4    target_cinfo;\n   };\n   union RENAME4res switch (nfsstat4\
    \ status) {\n    case NFS4_OK:\n           RENAME4resok    resok4;\n    default:\n\
    \           void;\n   };\n   /*\n    * RENEW: Renew a Lease\n    */\n   struct\
    \ RENEW4args {\n           stateid4        stateid;\n   };\n   struct RENEW4res\
    \ {\n           nfsstat4        status;\n   };\n   /*\n    * RESTOREFH: Restore\
    \ saved filehandle\n    */\n   struct RESTOREFH4res {\n           /* CURRENT_FH:\
    \ value of saved fh */\n           nfsstat4        status;\n   };\n   /*\n   \
    \ * SAVEFH: Save current filehandle\n    */\n   struct SAVEFH4res {\n        \
    \   /* SAVED_FH: value of current fh */\n           nfsstat4        status;\n\
    \   };\n   /*\n    * SECINFO: Obtain Available Security Mechanisms\n    */\n \
    \  struct SECINFO4args {\n           /* CURRENT_FH: */\n           component4\
    \      name;\n   };\n   /*\n    * From RFC 2203\n    */\n   enum rpc_gss_svc_t\
    \ {\n           RPC_GSS_SVC_NONE        = 1,\n           RPC_GSS_SVC_INTEGRITY\
    \   = 2,\n           RPC_GSS_SVC_PRIVACY     = 3\n   };\n   struct rpcsec_gss_info\
    \ {\n           sec_oid4        oid;\n           qop4            qop;\n      \
    \     rpc_gss_svc_t   service;\n   };\n   struct secinfo4 {\n           uint32_t\
    \        flavor;\n           /* null for AUTH_SYS, AUTH_NONE;\n              contains\
    \ rpcsec_gss_info for\n              RPCSEC_GSS. */\n           opaque       \
    \   flavor_info<>;\n   };\n   typedef secinfo4 SECINFO4resok<>;\n   union SECINFO4res\
    \ switch (nfsstat4 status) {\n    case NFS4_OK:\n            SECINFO4resok resok4;\n\
    \    default:\n            void;\n   };\n   /*\n    * SETATTR: Set attributes\n\
    \    */\n   struct SETATTR4args {\n           /* CURRENT_FH: target object */\n\
    \           stateid4        stateid;\n           fattr4          obj_attributes;\n\
    \   };\n   struct SETATTR4res {\n           nfsstat4        status;\n        \
    \   bitmap4         attrsset;\n   };\n   /*\n    * SETCLIENTID\n    */\n   struct\
    \ SETCLIENTID4args {\n           nfs_client_id4  client;\n           cb_client4\
    \      callback;\n   };\n   struct SETCLIENTID4resok {\n           clientid4 \
    \      clientid;\n           verifier4       setclientid_confirm;\n   };\n   union\
    \ SETCLIENTID4res switch (nfsstat4 status) {\n    case NFS4_OK:\n            SETCLIENTID4resok\
    \      resok4;\n    case NFS4ERR_CLID_INUSE:\n            clientaddr4    client_using;\n\
    \    default:\n            void;\n   };\n   struct SETCLIENTID_CONFIRM4args {\n\
    \           verifier4       setclientid_confirm;\n   };\n   struct SETCLIENTID_CONFIRM4res\
    \ {\n           nfsstat4        status;\n   };\n   /*\n    * VERIFY: Verify attributes\
    \ same\n    */\n   struct VERIFY4args {\n           /* CURRENT_FH: object */\n\
    \           fattr4          obj_attributes;\n   };\n   struct VERIFY4res {\n \
    \          nfsstat4        status;\n   };\n   /*\n    * WRITE: Write to file\n\
    \    */\n   enum stable_how4 {\n           UNSTABLE4       = 0,\n           DATA_SYNC4\
    \      = 1,\n           FILE_SYNC4      = 2\n   };\n   struct WRITE4args {\n \
    \          /* CURRENT_FH: file */\n           stateid4        stateid;\n     \
    \      offset4         offset;\n           stable_how4     stable;\n         \
    \  opaque          data<>;\n   };\n   struct WRITE4resok {\n           count4\
    \          count;\n           stable_how4     committed;\n           verifier4\
    \       writeverf;\n   };\n   union WRITE4res switch (nfsstat4 status) {\n   \
    \ case NFS4_OK:\n            WRITE4resok    resok4;\n    default:\n          \
    \  void;\n   };\n   /*\n    * Operation arrays\n    */\n   enum nfs_opnum4 {\n\
    \           OP_ACCESS               = 3,\n           OP_CLOSE                =\
    \ 4,\n           OP_COMMIT               = 5,\n           OP_CREATE          \
    \     = 6,\n           OP_DELEGPURGE           = 7,\n           OP_DELEGRETURN\
    \          = 8,\n           OP_GETATTR              = 9,\n           OP_GETFH\
    \                = 10,\n           OP_LINK                 = 11,\n           OP_LOCK\
    \                 = 12,\n           OP_LOCKT                = 13,\n          \
    \ OP_LOCKU                = 14,\n           OP_LOOKUP               = 15,\n  \
    \         OP_LOOKUPP              = 16,\n           OP_NVERIFY              =\
    \ 17,\n           OP_OPEN                 = 18,\n           OP_OPENATTR      \
    \       = 19,\n           OP_OPEN_CONFIRM         = 20,\n           OP_OPEN_DOWNGRADE\
    \       = 21,\n           OP_PUTFH                = 22,\n           OP_PUTPUBFH\
    \             = 23,\n           OP_PUTROOTFH            = 24,\n           OP_READ\
    \                 = 25,\n           OP_READDIR              = 26,\n          \
    \ OP_READLINK             = 27,\n           OP_REMOVE               = 28,\n  \
    \         OP_RENAME               = 29,\n           OP_RENEW                =\
    \ 30,\n           OP_RESTOREFH            = 31,\n           OP_SAVEFH        \
    \       = 32,\n           OP_SECINFO              = 33,\n           OP_SETATTR\
    \              = 34,\n           OP_SETCLIENTID          = 35,\n           OP_SETCLIENTID_CONFIRM\
    \  = 36,\n           OP_VERIFY               = 37,\n           OP_WRITE      \
    \          = 38\n   };\n   union nfs_argop4 switch (nfs_opnum4 argop) {\n    case\
    \ OP_ACCESS:        ACCESS4args opaccess;\n    case OP_CLOSE:         CLOSE4args\
    \ opclose;\n    case OP_COMMIT:        COMMIT4args opcommit;\n    case OP_CREATE:\
    \        CREATE4args opcreate;\n    case OP_DELEGPURGE:    DELEGPURGE4args opdelegpurge;\n\
    \    case OP_DELEGRETURN:   DELEGRETURN4args opdelegreturn;\n    case OP_GETATTR:\
    \       GETATTR4args opgetattr;\n    case OP_GETFH:         void;\n    case OP_LINK:\
    \          LINK4args oplink;\n    case OP_LOCK:          LOCK4args oplock;\n \
    \   case OP_LOCKT:         LOCKT4args oplockt;\n    case OP_LOCKU:         LOCKU4args\
    \ oplocku;\n    case OP_LOOKUP:        LOOKUP4args oplookup;\n    case OP_LOOKUPP:\
    \       void;\n    case OP_NVERIFY:       NVERIFY4args opnverify;\n    case OP_OPEN:\
    \          OPEN4args opopen;\n    case OP_OPENATTR:      void;\n    case OP_OPEN_CONFIRM:\
    \  OPEN_CONFIRM4args opopen_confirm;\n    case OP_OPEN_DOWNGRADE:        OPEN_DOWNGRADE4args\
    \ opopen_downgrade;\n    case OP_PUTFH:         PUTFH4args opputfh;\n    case\
    \ OP_PUTPUBFH:      void;\n    case OP_PUTROOTFH:     void;\n    case OP_READ:\
    \          READ4args opread;\n    case OP_READDIR:       READDIR4args opreaddir;\n\
    \    case OP_READLINK:      void;\n    case OP_REMOVE:        REMOVE4args opremove;\n\
    \    case OP_RENAME:        RENAME4args oprename;\n    case OP_RENEW:        \
    \ RENEW4args oprenew;\n    case OP_RESTOREFH:     void;\n    case OP_SAVEFH: \
    \       void;\n    case OP_SECINFO:       SECINFO4args opsecinfo;\n    case OP_SETATTR:\
    \       SETATTR4args opsetattr;\n    case OP_SETCLIENTID:   SETCLIENTID4args opsetclientid;\n\
    \    case OP_SETCLIENTID_CONFIRM:   SETCLIENTID_CONFIRM4args\n               \
    \                            opsetclientid_confirm;\n    case OP_VERIFY:     \
    \   VERIFY4args opverify;\n    case OP_WRITE:         WRITE4args opwrite;\n  \
    \ };\n   union nfs_resop4 switch (nfs_opnum4 resop){\n    case OP_ACCESS:    \
    \    ACCESS4res opaccess;\n    case OP_CLOSE:         CLOSE4res opclose;\n   \
    \ case OP_COMMIT:        COMMIT4res opcommit;\n    case OP_CREATE:        CREATE4res\
    \ opcreate;\n    case OP_DELEGPURGE:    DELEGPURGE4res opdelegpurge;\n    case\
    \ OP_DELEGRETURN:   DELEGRETURN4res opdelegreturn;\n    case OP_GETATTR:     \
    \  GETATTR4res opgetattr;\n    case OP_GETFH:         GETFH4res opgetfh;\n   \
    \ case OP_LINK:          LINK4res oplink;\n    case OP_LOCK:          LOCK4res\
    \ oplock;\n    case OP_LOCKT:         LOCKT4res oplockt;\n    case OP_LOCKU: \
    \        LOCKU4res oplocku;\n    case OP_LOOKUP:        LOOKUP4res oplookup;\n\
    \    case OP_LOOKUPP:       LOOKUPP4res oplookupp;\n    case OP_NVERIFY:     \
    \  NVERIFY4res opnverify;\n    case OP_OPEN:          OPEN4res opopen;\n    case\
    \ OP_OPENATTR:      OPENATTR4res opopenattr;\n    case OP_OPEN_CONFIRM:  OPEN_CONFIRM4res\
    \ opopen_confirm;\n    case OP_OPEN_DOWNGRADE:        OPEN_DOWNGRADE4res opopen_downgrade;\n\
    \    case OP_PUTFH:         PUTFH4res opputfh;\n    case OP_PUTPUBFH:      PUTPUBFH4res\
    \ opputpubfh;\n    case OP_PUTROOTFH:     PUTROOTFH4res opputrootfh;\n    case\
    \ OP_READ:          READ4res opread;\n    case OP_READDIR:       READDIR4res opreaddir;\n\
    \    case OP_READLINK:      READLINK4res opreadlink;\n    case OP_REMOVE:    \
    \    REMOVE4res opremove;\n    case OP_RENAME:        RENAME4res oprename;\n \
    \   case OP_RENEW:         RENEW4res oprenew;\n    case OP_RESTOREFH:     RESTOREFH4res\
    \ oprestorefh;\n    case OP_SAVEFH:        SAVEFH4res opsavefh;\n    case OP_SECINFO:\
    \       SECINFO4res opsecinfo;\n    case OP_SETATTR:       SETATTR4res opsetattr;\n\
    \    case OP_SETCLIENTID:   SETCLIENTID4res opsetclientid;\n    case OP_SETCLIENTID_CONFIRM:\
    \   SETCLIENTID_CONFIRM4res\n                                           opsetclientid_confirm;\n\
    \    case OP_VERIFY:        VERIFY4res opverify;\n    case OP_WRITE:         WRITE4res\
    \ opwrite;\n   };\n   struct COMPOUND4args {\n           utf8string      tag;\n\
    \           uint32_t        minorversion;\n           nfs_argop4      argarray<>;\n\
    \   };\n   struct COMPOUND4res {\n           nfsstat4 status;\n           utf8string\
    \      tag;\n           nfs_resop4      resarray<>;\n   };\n   /*\n    * Remote\
    \ file service routines\n    */\n   program NFS4_PROGRAM {\n           version\
    \ NFS_V4 {\n                   void\n                           NFSPROC4_NULL(void)\
    \ = 0;\n                   COMPOUND4res\n                           NFSPROC4_COMPOUND(COMPOUND4args)\
    \ = 1;\n           } = 4;\n   } = 100003;\n   /*\n    * NFS4 Callback Procedure\
    \ Definitions and Program\n    */\n   /*\n    * CB_GETATTR: Get Current Attributes\n\
    \    */\n   struct CB_GETATTR4args {\n           nfs_fh4 fh;\n           bitmap4\
    \ attr_request;\n   };\n   struct CB_GETATTR4resok {\n           fattr4  obj_attributes;\n\
    \   };\n   union CB_GETATTR4res switch (nfsstat4 status) {\n    case NFS4_OK:\n\
    \            CB_GETATTR4resok       resok4;\n    default:\n            void;\n\
    \   };\n   /*\n    * CB_RECALL: Recall an Open Delegation\n    */\n   struct CB_RECALL4args\
    \ {\n           stateid4        stateid;\n           bool            truncate;\n\
    \           nfs_fh4         fh;\n   };\n   struct CB_RECALL4res {\n          \
    \ nfsstat4        status;\n   };\n   /*\n    * Various definitions for CB_COMPOUND\n\
    \    */\n   enum nfs_cb_opnum4 {\n           OP_CB_GETATTR           = 3,\n  \
    \         OP_CB_RECALL            = 4\n   };\n   union nfs_cb_argop4 switch (unsigned\
    \ argop) {\n    case OP_CB_GETATTR:    CB_GETATTR4args opcbgetattr;\n    case\
    \ OP_CB_RECALL:     CB_RECALL4args  opcbrecall;\n   };\n   union nfs_cb_resop4\
    \ switch (unsigned resop){\n    case OP_CB_GETATTR:    CB_GETATTR4res  opcbgetattr;\n\
    \    case OP_CB_RECALL:     CB_RECALL4res   opcbrecall;\n   };\n   struct CB_COMPOUND4args\
    \ {\n           utf8string      tag;\n           uint32_t        minorversion;\n\
    \           nfs_cb_argop4   argarray<>;\n   };\n   struct CB_COMPOUND4res {\n\
    \           nfsstat4 status;\n           utf8string      tag;\n           nfs_cb_resop4\
    \   resarray<>;\n   };\n   /*\n    * Program number is in the transient range\
    \ since the client\n    * will assign the exact transient program number and provide\n\
    \    * that to the server via the SETCLIENTID operation.\n    */\n   program NFS4_CALLBACK\
    \ {\n           version NFS_CB {\n                   void\n                  \
    \         CB_NULL(void) = 0;\n                   CB_COMPOUND4res\n           \
    \                CB_COMPOUND(CB_COMPOUND4args) = 1;\n           } = 1;\n   } =\
    \ 40000000;\n"
- title: 19.  Bibliography
  contents:
  - "19.  Bibliography\n   [Floyd]      S. Floyd, V. Jacobson, \"The Synchronization\
    \ of Periodic\n                Routing Messages,\" IEEE/ACM Transactions on Networking,\n\
    \                2(2), pp. 122-136, April 1994.\n   [Gray]       C. Gray, D. Cheriton,\
    \ \"Leases: An Efficient Fault-\n                Tolerant Mechanism for Distributed\
    \ File Cache\n                Consistency,\" Proceedings of the Twelfth Symposium\
    \ on\n                Operating Systems Principles, p. 202-210, December 1989.\n\
    \   [ISO10646]   \"ISO/IEC 10646-1:1993. International Standard --\n         \
    \       Information technology -- Universal Multiple-Octet Coded\n           \
    \     Character Set (UCS) -- Part 1: Architecture and Basic\n                Multilingual\
    \ Plane.\"\n   [Juszczak]   Juszczak, Chet, \"Improving the Performance and\n\
    \                Correctness of an NFS Server,\" USENIX Conference\n         \
    \       Proceedings, USENIX Association, Berkeley, CA, June\n                1990,\
    \ pages 53-63.  Describes reply cache implementation\n                that avoids\
    \ work in the server by handling duplicate\n                requests. More important,\
    \ though listed as a side-\n                effect, the reply cache aids in the\
    \ avoidance of\n                destructive non-idempotent operation re-application\
    \ --\n                improving correctness.\n   [Kazar]      Kazar, Michael Leon,\
    \ \"Synchronization and Caching Issues\n                in the Andrew File System,\"\
    \ USENIX Conference\n                Proceedings, USENIX Association, Berkeley,\
    \ CA, Dallas\n                Winter 1988, pages 27-36.  A description of the\
    \ cache\n                consistency scheme in AFS.  Contrasted with other\n \
    \               distributed file systems.\n   [Macklem]    Macklem, Rick, \"Lessons\
    \ Learned Tuning the 4.3BSD Reno\n                Implementation of the NFS Protocol,\"\
    \ Winter USENIX\n                Conference Proceedings, USENIX Association, Berkeley,\n\
    \                CA, January 1991.  Describes performance work in tuning\n   \
    \             the 4.3BSD Reno NFS implementation. Describes\n                performance\
    \ improvement (reduced CPU loading) through\n                elimination of data\
    \ copies.\n   [Mogul]      Mogul, Jeffrey C., \"A Recovery Protocol for Spritely\n\
    \                NFS,\" USENIX File System Workshop Proceedings, Ann\n       \
    \         Arbor, MI, USENIX Association, Berkeley, CA, May 1992.\n           \
    \     Second paper on Spritely NFS proposes a lease-based\n                scheme\
    \ for recovering state of consistency protocol.\n   [Nowicki]    Nowicki, Bill,\
    \ \"Transport Issues in the Network File\n                System,\" ACM SIGCOMM\
    \ newsletter Computer Communication\n                Review, April 1989.  A brief\
    \ description of the basis\n                for the dynamic retransmission work.\n\
    \   [Pawlowski]  Pawlowski, Brian, Ron Hixon, Mark Stein, Joseph\n           \
    \     Tumminaro, \"Network Computing in the UNIX and IBM\n                Mainframe\
    \ Environment,\" Uniforum `89 Conf.  Proc.,\n                (1989) Description\
    \ of an NFS server implementation for\n                IBM's MVS operating system.\n\
    \   [RFC1094]    Sun Microsystems, Inc., \"NFS: Network File System\n        \
    \        Protocol Specification\", RFC 1094, March 1989.\n   [RFC1345]    Simonsen,\
    \ K., \"Character Mnemonics & Character Sets\",\n                RFC 1345, June\
    \ 1992.\n   [RFC1700]    Reynolds, J. and J. Postel, \"Assigned Numbers\", STD\
    \ 2,\n                RFC 1700, October 1994.\n   [RFC1813]    Callaghan, B.,\
    \ Pawlowski, B. and P. Staubach, \"NFS\n                Version 3 Protocol Specification\"\
    , RFC 1813, June 1995.\n   [RFC1831]    Srinivasan, R., \"RPC: Remote Procedure\
    \ Call Protocol\n                Specification Version 2\", RFC 1831, August 1995.\n\
    \   [RFC1832]    Srinivasan, R., \"XDR: External Data Representation\n       \
    \         Standard\", RFC 1832, August 1995.\n   [RFC1833]    Srinivasan, R.,\
    \ \"Binding Protocols for ONC RPC Version\n                2\", RFC 1833, August\
    \ 1995.\n   [RFC2025]    Adams, C., \"The Simple Public-Key GSS-API Mechanism\n\
    \                (SPKM)\", RFC 2025, October 1996.\n   [RFC2054]    Callaghan,\
    \ B., \"WebNFS Client Specification\", RFC 2054,\n                October 1996.\n\
    \   [RFC2055]    Callaghan, B., \"WebNFS Server Specification\", RFC 2055,\n \
    \               October 1996.\n   [RFC2078]    Linn, J., \"Generic Security Service\
    \ Application Program\n                Interface, Version 2\", RFC 2078, January\
    \ 1997.\n   [RFC2152]    Goldsmith, D., \"UTF-7 A Mail-Safe Transformation Format\n\
    \                of Unicode\", RFC 2152, May 1997.\n   [RFC2203]    Eisler, M.,\
    \ Chiu, A. and L. Ling, \"RPCSEC_GSS Protocol\n                Specification\"\
    , RFC 2203, August 1995.\n   [RFC2277]    Alvestrand, H., \"IETF Policy on Character\
    \ Sets and\n                Languages\", BCP 18, RFC 2277, January 1998.\n   [RFC2279]\
    \    Yergeau, F., \"UTF-8, a transformation format of ISO\n                10646\"\
    , RFC 2279, January 1998.\n   [RFC2623]    Eisler, M., \"NFS Version 2 and Version\
    \ 3 Security Issues\n                and the NFS Protocol's Use of RPCSEC_GSS\
    \ and Kerberos\n                V5\", RFC 2623, June 1999.\n   [RFC2624]    Shepler,\
    \ S., \"NFS Version 4 Design Considerations\", RFC\n                2624, June\
    \ 1999.\n   [RFC2847]    Eisler, M., \"LIPKEY - A Low Infrastructure Public Key\n\
    \                Mechanism Using SPKM\", RFC 2847, June 2000.\n   [Sandberg] \
    \  Sandberg, R., D. Goldberg, S. Kleiman, D. Walsh, B.\n                Lyon,\
    \ \"Design and Implementation of the Sun Network\n                Filesystem,\"\
    \ USENIX Conference Proceedings, USENIX\n                Association, Berkeley,\
    \ CA, Summer 1985.  The basic paper\n                describing the SunOS implementation\
    \ of the NFS version 2\n                protocol, and discusses the goals, protocol\n\
    \                specification and trade-offs.\n   [Srinivasan] Srinivasan, V.,\
    \ Jeffrey C. Mogul, \"Spritely NFS:\n                Implementation and Performance\
    \ of Cache Consistency\n                Protocols\", WRL Research Report 89/5,\
    \ Digital Equipment\n                Corporation Western Research Laboratory,\
    \ 100 Hamilton\n                Ave., Palo Alto, CA, 94301, May 1989.  This paper\n\
    \                analyzes the effect of applying a Sprite-like\n             \
    \   consistency protocol applied to standard NFS. The issues\n               \
    \ of recovery in a stateful environment are covered in\n                [Mogul].\n\
    \   [Unicode1]   The Unicode Consortium, \"The Unicode Standard, Version\n   \
    \             3.0\", Addison-Wesley Developers Press, Reading, MA,\n         \
    \       2000. ISBN 0-201-61633-5.\n                More information available\
    \ at: http://www.unicode.org/\n   [Unicode2]   \"Unsupported Scripts\" Unicode,\
    \ Inc., The Unicode\n                Consortium, P.O. Box 700519, San Jose, CA\
    \ 95710-0519\n                USA, September 1999\n                http://www.unicode.org/unicode/standard/unsupported.html\n\
    \   [XNFS]       The Open Group, Protocols for Interworking: XNFS,\n         \
    \       Version 3W, The Open Group, 1010 El Camino Real Suite\n              \
    \  380, Menlo Park, CA 94025, ISBN 1-85912-184-5, February\n                1998.\n\
    \                HTML version available: http://www.opengroup.org\n"
- title: 20.  Authors
  contents:
  - '20.  Authors

    '
- title: 20.1.  Editor's Address
  contents:
  - "20.1.  Editor's Address\n   Spencer Shepler\n   Sun Microsystems, Inc.\n   7808\
    \ Moonflower Drive\n   Austin, Texas 78750\n   Phone: +1 512-349-9376\n   EMail:\
    \ spencer.shepler@sun.com\n"
- title: 20.2.  Authors' Addresses
  contents:
  - "20.2.  Authors' Addresses\n   Carl Beame\n   Hummingbird Ltd.\n   EMail: beame@bws.com\n\
    \   Brent Callaghan\n   Sun Microsystems, Inc.\n   901 San Antonio Road\n   Palo\
    \ Alto, CA 94303\n   Phone: +1 650-786-5067\n   EMail: brent.callaghan@sun.com\n\
    \   Mike Eisler\n   5565 Wilson Road\n   Colorado Springs, CO 80919\n   Phone:\
    \ +1 719-599-9026\n   EMail: mike@eisler.com\n   David Noveck\n   Network Appliance\n\
    \   375 Totten Pond Road\n   Waltham, MA  02451\n   Phone: +1 781-895-4949\n \
    \  E-mail: dnoveck@netapp.com\n   David Robinson\n   Sun Microsystems, Inc.\n\
    \   901 San Antonio Road\n   Palo Alto, CA 94303\n   Phone: +1 650-786-5088\n\
    \   EMail: david.robinson@sun.com\n   Robert Thurlow\n   Sun Microsystems, Inc.\n\
    \   901 San Antonio Road\n   Palo Alto, CA 94303\n   Phone: +1 650-786-5096\n\
    \   EMail: robert.thurlow@sun.com\n"
- title: 20.3.  Acknowledgements
  contents:
  - "20.3.  Acknowledgements\n   The author thanks and acknowledges:\n   Neil Brown\
    \ for his extensive review and comments of various drafts.\n"
- title: 21.  Full Copyright Statement
  contents:
  - "21.  Full Copyright Statement\n   Copyright (C) The Internet Society (2000).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
