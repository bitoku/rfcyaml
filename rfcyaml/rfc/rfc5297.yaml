- title: __initial_text__
  contents:
  - "    Synthetic Initialization Vector (SIV) Authenticated Encryption\n        \
    \      Using the Advanced Encryption Standard (AES)\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This memo describes SIV (Synthetic Initialization Vector), a block\n\
    \   cipher mode of operation.  SIV takes a key, a plaintext, and multiple\n  \
    \ variable-length octet strings that will be authenticated but not\n   encrypted.\
    \  It produces a ciphertext having the same length as the\n   plaintext and a\
    \ synthetic initialization vector.  Depending on how it\n   is used, SIV achieves\
    \ either the goal of deterministic authenticated\n   encryption or the goal of\
    \ nonce-based, misuse-resistant authenticated\n   encryption.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \      1.1. Background .................................................3\n  \
    \    1.2. Definitions ................................................4\n    \
    \  1.3. Motivation .................................................4\n      \
    \     1.3.1. Key Wrapping ........................................4\n        \
    \   1.3.2. Resistance to Nonce Misuse/Reuse ....................4\n          \
    \ 1.3.3. Key Derivation ......................................5\n           1.3.4.\
    \ Robustness versus Performance .......................6\n           1.3.5. Conservation\
    \ of Cryptographic Primitives ............6\n   2. Specification of SIV ............................................6\n\
    \      2.1. Notation ...................................................6\n  \
    \    2.2. Overview ...................................................7\n    \
    \  2.3. Doubling ...................................................7\n      2.4.\
    \ S2V ........................................................8\n      2.5. CTR\
    \ .......................................................10\n      2.6. SIV Encrypt\
    \ ...............................................10\n      2.7. SIV Decrypt ...............................................12\n\
    \   3. Nonce-Based Authenticated Encryption with SIV ..................14\n  \
    \ 4. Deterministic Authenticated Encryption with SIV ................15\n   5.\
    \ Optimizations ..................................................15\n   6. IANA\
    \ Considerations ............................................15\n      6.1. AEAD_AES_SIV_CMAC_256\
    \ .....................................17\n      6.2. AEAD_AES_SIV_CMAC_384 .....................................17\n\
    \      6.3. AEAD_AES_SIV_CMAC_512 .....................................18\n  \
    \ 7. Security Considerations ........................................18\n   8.\
    \ Acknowledgments ................................................19\n   9. References\
    \ .....................................................19\n      9.1. Normative\
    \ References ......................................19\n      9.2. Informative\
    \ References ....................................19\n   Appendix A.  Test Vectors\
    \  ....................................... 22\n     A.1.  Deterministic Authenticated\
    \ Encryption Example ........... 22\n     A.2.  Nonce-Based Authenticated Encryption\
    \ Example ............. 23\n"
- title: 1.  Introduction
  contents:
  - '1.  Introduction

    '
- title: 1.1.  Background
  contents:
  - "1.1.  Background\n   Various attacks have been described (e.g., [BADESP]) when\
    \ data is\n   merely privacy protected and not additionally authenticated or\n\
    \   integrity protected.  Therefore, combined modes of encryption and\n   authentication\
    \ have been developed ([RFC5116], [RFC3610], [GCM],\n   [JUTLA], [OCB]).  These\
    \ provide conventional authenticated encryption\n   when used with a nonce (\"\
    a number used once\") and typically accept\n   additional inputs that are authenticated\
    \ but not encrypted,\n   hereinafter referred to as \"associated data\" or AD.\n\
    \   A deterministic, nonce-less, form of authenticated encryption has\n   been\
    \ used to protect the transportation of cryptographic keys (e.g.,\n   [X9F1],\
    \ [RFC3217], [RFC3394]).  This is generally referred to as \"Key\n   Wrapping\"\
    .\n   This memo describes a new block cipher mode, SIV, that provides both\n \
    \  nonce-based authenticated encryption as well as deterministic, nonce-\n   less\
    \ key wrapping.  It contains a Pseudo-Random Function (PRF)\n   construction called\
    \ S2V and an encryption/decryption construction,\n   called CTR.  SIV was specified\
    \ by Phillip Rogaway and Thomas\n   Shrimpton in [DAE].  The underlying block\
    \ cipher used herein for both\n   S2V and CTR is AES with key lengths of 128 bits,\
    \ 192 bits, or 256\n   bits.  S2V uses AES in Cipher-based Message Authentication\
    \ Code\n   ([CMAC]) mode, CTR uses AES in counter ([MODES]) mode.\n   Associated\
    \ data is data input to an authenticated-encryption mode\n   that will be authenticated\
    \ but not encrypted.  [RFC5116] says that\n   associated data can include \"addresses,\
    \ ports, sequence numbers,\n   protocol version numbers, and other fields that\
    \ indicate how the\n   plaintext or ciphertext should be handled, forwarded, or\
    \ processed\".\n   These are multiple, distinct inputs and may not be contiguous.\
    \  Other\n   authenticated-encryption cipher modes allow only a single associated\n\
    \   data input.  Such a limitation may require implementation of a\n   scatter/gather\
    \ form of data marshalling to combine the multiple\n   components of the associated\
    \ data into a single input or may require\n   a pre-processing step where the\
    \ associated data inputs are\n   concatenated together.  SIV accepts multiple\
    \ variable-length octet\n   strings (hereinafter referred to as a \"vector of\
    \ strings\") as\n   associated data inputs.  This obviates the need for data marshalling\n\
    \   or pre-processing of associated data to package it into a single\n   input.\n\
    \   By allowing associated data to consist of a vector of strings SIV\n   also\
    \ obviates the requirement to encode the length of component\n   fields of the\
    \ associated data when those fields have variable length.\n"
- title: 1.2.  Definitions
  contents:
  - "1.2.  Definitions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"\
    SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\"\
    , and \"OPTIONAL\" in this\n   document are to be interpreted as described in\
    \ RFC 2119 [RFC2119].\n"
- title: 1.3.  Motivation
  contents:
  - '1.3.  Motivation

    '
- title: 1.3.1.  Key Wrapping
  contents:
  - "1.3.1.  Key Wrapping\n   A key distribution protocol must protect keys it is\
    \ distributing.\n   This has not always been done correctly.  For example, RADIUS\n\
    \   [RFC2865] uses Microsoft Point-to-Point Encryption (MPPE) [RFC2548]\n   to\
    \ encrypt a key prior to transmission from server to client.  It\n   provides\
    \ no integrity checking of the encrypted key.  [RADKEY]\n   specifies the use\
    \ of [RFC3394] to wrap a key in a RADIUS request but\n   because of the inability\
    \ to pass associated data, a Hashed Message\n   Authentication Code (HMAC) [RFC2104]\
    \ is necessary to provide\n   authentication of the entire request.\n   SIV can\
    \ be used as a drop-in replacement for any specification that\n   uses [RFC3394]\
    \ or [RFC3217], including the aforementioned use.  It is\n   a more general purpose\
    \ solution as it allows for associated data to\n   be specified.\n"
- title: 1.3.2.  Resistance to Nonce Misuse/Reuse
  contents:
  - "1.3.2.  Resistance to Nonce Misuse/Reuse\n   The nonce-based authenticated encryption\
    \ schemes described above are\n   susceptible to reuse and/or misuse of the nonce.\
    \  Depending on the\n   specific scheme there are subtle and critical requirements\
    \ placed on\n   the nonce (see [SP800-38D]).  [GCM] states that it provides\n\
    \   \"excellent security\" if its nonce is guaranteed to be distinct but\n   provides\
    \ \"no security\" otherwise.  Confidentiality guarantees are\n   voided if a counter\
    \ in [RFC3610] is reused.  In many cases,\n   guaranteeing no reuse of a nonce/counter/IV\
    \ is not a problem, but in\n   others it will be.\n   For example, many applications\
    \ obtain access to cryptographic\n   functions via an application program interface\
    \ to a cryptographic\n   library.  These libraries are typically not stateful\
    \ and any nonce,\n   initialization vector, or counter required by the cipher\
    \ mode is\n   passed to the cryptographic library by the application.  Putting\
    \ the\n   construction of a security-critical datum outside the control of the\n\
    \   encryption engine places an onerous burden on the application writer\n   who\
    \ may not provide the necessary cryptographic hygiene.  Perhaps his\n   random\
    \ number generator is not very good or maybe an application\n   fault causes a\
    \ counter to be reset.  The fragility of the cipher mode\n   may result in its\
    \ inadvertent misuse.  Also, if one's environment is\n   (knowingly or unknowingly)\
    \ a virtual machine, it may be possible to\n   roll back a virtual state machine\
    \ and cause nonce reuse thereby\n   gutting the security of the authenticated\
    \ encryption scheme (see\n   [VIRT]).\n   If the nonce is random, a requirement\
    \ that it never repeat will limit\n   the amount of data that can be safely protected\
    \ with a single key to\n   one block.  More sensibly, a random nonce is required\
    \ to \"almost\n   always\" be non-repeating, but that will drastically limit the\
    \ amount\n   of data that can be safely protected.\n   SIV provides a level of\
    \ resistance to nonce reuse and misuse.  If the\n   nonce is never reused, then\
    \ the usual notion of nonce-based security\n   of an authenticated encryption\
    \ mode is achieved.  If, however, the\n   nonce is reused, authenticity is retained\
    \ and confidentiality is only\n   compromised to the extent that an attacker can\
    \ determine that the\n   same plaintext (and same associated data) was protected\
    \ with the same\n   nonce and key.  See Security Considerations (Section 7).\n"
- title: 1.3.3.  Key Derivation
  contents:
  - "1.3.3.  Key Derivation\n   A PRF is frequently used as a key derivation function\
    \ (e.g., [WLAN])\n   by passing it a key and a single string.  Typically, this\
    \ single\n   string is the concatenation of a series of smaller strings -- for\n\
    \   example, a label and some context to bind into the derived string.\n   These\
    \ are usually multiple strings but are mapped to a single string\n   because of\
    \ the way PRFs are typically defined -- two inputs: a key\n   and data.  Such\
    \ a crude mapping is inefficient because additional\n   data must be included\
    \ -- the length of variable-length inputs must be\n   encoded separately -- and,\
    \ depending on the PRF, memory allocation\n   and copying may be needed.  Also,\
    \ if only one or two of the inputs\n   changed when deriving a new key, it may\
    \ still be necessary to process\n   all of the other constants that preceded it\
    \ every time the PRF is\n   invoked.\n   When a PRF is used in this manner its\
    \ input is a vector of strings\n   and not a single string and the PRF should\
    \ handle the data as such.\n   The S2V (\"string to vector\") PRF construction\
    \ accepts a vector of\n   inputs and provides a more natural mapping of input\
    \ that does not\n   require additional lengths encodings and obviates the memory\
    \ and\n   processing overhead to marshal inputs and their encoded lengths into\n\
    \   a single string.  Constant inputs to the PRF need only be computed\n   once.\n"
- title: 1.3.4.  Robustness versus Performance
  contents:
  - "1.3.4.  Robustness versus Performance\n   SIV cannot perform at the same high\
    \ throughput rates that other\n   authenticated encryption schemes can (e.g.,\
    \ [GCM] or [OCB]) due to\n   the requirement for two passes of the data, but for\
    \ situations where\n   performance is not a limiting factor -- e.g., control plane\n\
    \   applications -- it can provide a robust alternative, especially when\n   considering\
    \ its resistance to nonce reuse.\n"
- title: 1.3.5.  Conservation of Cryptographic Primitives
  contents:
  - "1.3.5.  Conservation of Cryptographic Primitives\n   The cipher mode described\
    \ herein can do authenticated encryption, key\n   wrapping, key derivation, and\
    \ serve as a generic message\n   authentication algorithm.  It is therefore possible\
    \ to implement all\n   these functions with a single tool, instead of one tool\
    \ for each\n   function.  This is extremely attractive for devices that are memory\n\
    \   and/or processor constrained and that cannot afford to implement\n   multiple\
    \ cryptographic primitives to accomplish these functions.\n"
- title: 2.  Specification of SIV
  contents:
  - '2.  Specification of SIV

    '
- title: 2.1.  Notation
  contents:
  - "2.1.  Notation\n   SIV and S2V use the following notation:\n   len(A)\n     \
    \ returns the number of bits in A.\n   pad(X)\n      indicates padding of string\
    \ X, len(X) < 128, out to 128 bits by\n      the concatenation of a single bit\
    \ of 1 followed by as many 0 bits\n      as are necessary.\n   leftmost(A,n)\n\
    \      the n most significant bits of A.\n   rightmost(A,n)\n      the n least\
    \ significant bits of A.\n   A || B\n      means concatenation of string A with\
    \ string B.\n   A xor B\n      is the exclusive OR operation on two equal length\
    \ strings, A and\n      B.\n   A xorend B\n      where len(A) >= len(B), means\
    \ xoring a string B onto the end of\n      string A -- i.e., leftmost(A, len(A)-len(B))\
    \ || (rightmost(A,\n      len(B)) xor B).\n   A bitand B\n      is the logical\
    \ AND operation on two equal length strings, A and B.\n   dbl(S)\n      is the\
    \ multiplication of S and 0...010 in the finite field\n      represented using\
    \ the primitive polynomial\n      x^128 + x^7 + x^2 + x + 1.  See Doubling (Section\
    \ 2.3).\n   a^b\n      indicates a string that is \"b\" bits, each having the\
    \ value \"a\".\n   <zero>\n      indicates a string that is 128 zero bits.\n \
    \  <one>\n      indicates a string that is 127 zero bits concatenated with a\n\
    \      single one bit, that is 0^127 || 1^1.\n   A/B\n      indicates the greatest\
    \ integer less than or equal to the real-\n      valued quotient of A and B.\n\
    \   E(K,X)\n      indicates AES encryption of string X using key K.\n"
- title: 2.2.  Overview
  contents:
  - "2.2.  Overview\n   SIV-AES uses AES in CMAC mode (S2V) and in counter mode (CTR).\
    \  SIV-\n   AES takes either a 256-, 384-, or 512-bit key (which is broken up\n\
    \   into two equal-sized keys, one for S2V and the other for CTR), a\n   variable\
    \ length plaintext, and multiple variable-length strings\n   representing associated\
    \ data.  Its output is a ciphertext that\n   comprises a synthetic initialization\
    \ vector concatenated with the\n   encrypted plaintext.\n"
- title: 2.3.  Doubling
  contents:
  - "2.3.  Doubling\n   The doubling operation on a 128-bit input string is performed\
    \ using a\n   left-shift of the input followed by a conditional xor operation\
    \ on\n   the result with the constant:\n                    00000000 00000000\
    \ 00000000 00000087\n   The condition under which the xor operation is performed\
    \ is when the\n   bit being shifted off is one.\n   Note that this is the same\
    \ operation used to generate sub-keys for\n   CMAC-AES.\n"
- title: 2.4.  S2V
  contents:
  - "2.4.  S2V\n   The S2V operation consists of the doubling and xoring of the outputs\n\
    \   of a pseudo-random function, CMAC, operating over individual strings\n   in\
    \ the input vector: S1, S2, ... , Sn.  It is bootstrapped by\n   performing CMAC\
    \ on a 128-bit string of zeros.  If the length of the\n   final string in the\
    \ vector is greater than or equal to 128 bits, the\n   output of the double/xor\
    \ chain is xored onto the end of the final\n   input string.  That result is input\
    \ to a final CMAC operation to\n   produce the output V.  If the length of the\
    \ final string is less than\n   128 bits, the output of the double/xor chain is\
    \ doubled once more and\n   it is xored with the final string padded using the\
    \ padding function\n   pad(X).  That result is input to a final CMAC operation\
    \ to produce\n   the output V.\n   S2V with key K on a vector of n inputs S1,\
    \ S2, ..., Sn-1, Sn, and\n   len(Sn) >= 128:\n                  +----+       +----+\
    \       +------+      +----+\n                  | S1 |       | S2 | . . . | Sn-1\
    \ |      | Sn |\n                  +----+       +----+       +------+      +----+\n\
    \     <zero>   K     |            |             |             |\n       |    \
    \  |     |            |             |             V\n       V      |     V   \
    \         V             V    /----> xorend\n   +-----+    |  +-----+      +-----+\
    \       +-----+ |        |\n   | AES-|<----->| AES-|  K-->| AES-|  K--->| AES-|\
    \ |        |\n   | CMAC|       | CMAC|      | CMAC|       | CMAC| |        |\n\
    \   +-----+       +-----+      +-----+       +-----+ |        V\n       |    \
    \       |             |             |    |     +-----+\n       |           | \
    \            |             |    | K-->| AES-|\n       |           |          \
    \   |             |    |     | CMAC|\n       |           |             |     \
    \        |    |     +-----+\n       \\-> dbl -> xor -> dbl -> xor -> dbl -> xor---/\
    \        |\n                                                             V\n \
    \                                                          +---+\n           \
    \                                                | V |\n                     \
    \                                      +---+\n                               \
    \  Figure 2\n   S2V with key K on a vector of n inputs S1, S2, ..., Sn-1, Sn,\
    \ and\n   len(Sn) < 128:\n                +----+       +----+       +------+ \
    \     +---------+\n                | S1 |       | S2 | . . . | Sn-1 |      | pad(Sn)\
    \ |\n                +----+       +----+       +------+      +---------+\n   \
    \ <zero>  K     |            |             |               |\n      |     |  \
    \   |            |             |               V\n      V     |     V        \
    \    V             V     /------> xor\n   +-----+  |  +-----+      +-----+   \
    \    +-----+  |         |\n   | AES-|<--->| AES-|  K-->| AES-|   K-->| AES-| \
    \ |         |\n   | CMAC|     | CMAC|      | CMAC|       | CMAC|  |         |\n\
    \   +-----+     +-----+      +-----+       +-----+  |         V\n     |      \
    \     |             |             |     |      +-----+\n     |           |   \
    \          |             |     |  K-->| AES-|\n     |           |            \
    \ |             |     |      | CMAC|\n     |           |             |       \
    \      |     |      +-----+\n     \\-> dbl -> xor -> dbl -> xor -> dbl -> xor->\
    \ dbl        |\n                                                             V\n\
    \                                                           +---+\n          \
    \                                                 | V |\n                    \
    \                                       +---+\n                              \
    \   Figure 3\n   Algorithmically S2V can be described as:\n      S2V(K, S1, ...,\
    \ Sn) {\n        if n = 0 then\n          return V = AES-CMAC(K, <one>)\n    \
    \    fi\n        D = AES-CMAC(K, <zero>)\n        for i = 1 to n-1 do\n      \
    \    D = dbl(D) xor AES-CMAC(K, Si)\n        done\n        if len(Sn) >= 128 then\n\
    \          T = Sn xorend D\n        else\n          T = dbl(D) xor pad(Sn)\n \
    \       fi\n        return V = AES-CMAC(K, T)\n      }\n"
- title: 2.5.  CTR
  contents:
  - "2.5.  CTR\n   CTR is a counter mode of AES.  It takes as input a plaintext P\
    \ of\n   arbitrary length, a key K of length 128, 192, or 256 bits, and a\n  \
    \ counter X that is 128 bits in length, and outputs Z, which represents\n   a\
    \ concatenation of a synthetic initialization vector V and the\n   ciphertext\
    \ C, which is the same length as the plaintext.\n   The ciphertext is produced\
    \ by xoring the plaintext with the first\n   len(P) bits of the following string:\n\
    \                 E(K, X) || E(K, X+1) || E(K, X+2) || ...\n   Before beginning\
    \ counter mode, the 31st and 63rd bits (where the\n   rightmost bit is the 0th\
    \ bit) of the counter are cleared.  This\n   enables implementations that support\
    \ native 32-bit (64-bit) addition\n   to increment the counter modulo 2^32 (2^64)\
    \ in a manner that cannot\n   be distinguished from 128-bit increments, as long\
    \ as the number of\n   increment operations is limited by an upper bound that\
    \ safely avoids\n   carry to occur out of the respective pre-cleared bit.  More\
    \ formally,\n   for 32-bit addition, the counter is incremented as:\n      SALT=leftmost(X,96)\n\
    \      n=rightmost(X,32)\n      X+i = SALT || (n + i mod 2^32).\n   For 64-bit\
    \ addition, the counter is incremented as:\n      SALT=leftmost(X,64)\n      n=rightmost(X,64)\n\
    \      X+i = SALT || (n + i mod 2^64).\n   Performing 32-bit or 64-bit addition\
    \ on the counter will limit the\n   amount of plaintext that can be safely protected\
    \ by SIV-AES to 2^39 -\n   128 bits or 2^71 - 128 bits, respectively.\n"
- title: 2.6.  SIV Encrypt
  contents:
  - "2.6.  SIV Encrypt\n   SIV-encrypt takes as input a key K of length 256, 384,\
    \ or 512 bits,\n   plaintext of arbitrary length, and a vector of associated data\
    \ AD[ ]\n   where the number of components in the vector is not greater than 126\n\
    \   (see Section 7).  It produces output, Z, which is the concatenation\n   of\
    \ a 128-bit synthetic initialization vector and ciphertext whose\n   length is\
    \ equal to the length of the plaintext.\n   The key is split into equal halves,\
    \ K1 = leftmost(K, len(K)/2) and K2\n   = rightmost(K, len(K)/2).  K1 is used\
    \ for S2V and K2 is used for CTR.\n   In the encryption mode, the associated data\
    \ and plaintext represent\n   the vector of inputs to S2V, with the plaintext\
    \ being the last string\n   in the vector.  The output of S2V is a synthetic IV\
    \ that represents\n   the initial counter to CTR.\n   The encryption construction\
    \ of SIV is as follows:\n    +------+ +------+   +------+              +---+\n\
    \    | AD 1 | | AD 2 |...| AD n |              | P |\n    +------+ +------+  \
    \ +------+              +---+\n       |         |         |                  \
    \  |\n       |         |   ...   |  ------------------|\n       \\         | \
    \       /  /                  |\n        \\        |       /  / +------------+\
    \    |\n         \\       |      /  /  | K = K1||K2 |    |\n          \\     \
    \ |     /  /   +------------+    V\n           \\     |    /  /      |     | \
    \      +-----+\n            \\    |   /  /   K1  |     |  K2   |     |\n     \
    \        \\   |  /  /  ------/     \\------>| CTR |\n              \\  | /  /\
    \  /            ------->|     |\n               | | | |  |             |     \
    \  +-----+\n               V V V V  V             |          |\n             +------------+\
    \       +--------+     V\n             |    S2V     |------>|   V    |   +----+\n\
    \             +------------+       +--------+   | C  |\n                     \
    \                 |        +----+\n                                      |   \
    \       |\n                                      -----\\     |\n             \
    \                               \\    |\n                                    \
    \         \\   |\n                                              V  V\n       \
    \                                      +-----+\n                             \
    \                |  Z  |\n                                             +-----+\n\
    \   where the plaintext is P, the associated data is AD1 through ADn, V\n   is\
    \ the synthetic IV, the ciphertext is C, and Z is the output.\n              \
    \                   Figure 8\n   Algorithmically, SIV Encrypt can be described\
    \ as:\n      SIV-ENCRYPT(K, P, AD1, ..., ADn) {\n        K1 = leftmost(K, len(K)/2)\n\
    \        K2 = rightmost(K, len(K)/2)\n        V = S2V(K1, AD1, ..., ADn, P)\n\
    \        Q = V bitand (1^64 || 0^1 || 1^31 || 0^1 || 1^31)\n        m = (len(P)\
    \ + 127)/128\n        for i = 0 to m-1 do\n          Xi = AES(K2, Q+i)\n     \
    \   done\n        X = leftmost(X0 || ... || Xm-1, len(P))\n        C = P xor X\n\
    \        return V || C\n      }\n   where the key length used by AES in CTR and\
    \ S2V is len(K)/2 and will\n   each be either 128 bits, 192 bits, or 256 bits.\n\
    \   The 31st and 63rd bit (where the rightmost bit is the 0th) of the\n   counter\
    \ are zeroed out just prior to being used by CTR for\n   optimization purposes,\
    \ see Section 5.\n"
- title: 2.7.  SIV Decrypt
  contents:
  - "2.7.  SIV Decrypt\n   SIV-decrypt takes as input a key K of length 256, 384,\
    \ or 512 bits,\n   Z, which represents a synthetic initialization vector V concatenated\n\
    \   with a ciphertext C, and a vector of associated data AD[ ] where the\n   number\
    \ of components in the vector is not greater than 126 (see\n   Section 7).  It\
    \ produces either the original plaintext or the special\n   symbol FAIL.\n   The\
    \ key is split as specified in Section 2.6\n   The synthetic initialization vector\
    \ acts as the initial counter to\n   CTR to decrypt the ciphertext.  The associated\
    \ data and the output of\n   CTR represent a vector of strings that is passed\
    \ to S2V, with the CTR\n   output being the last string in the vector.  The output\
    \ of S2V is\n   then compared against the synthetic IV that accompanied the original\n\
    \   ciphertext.  If they match, the output from CTR is returned as the\n   decrypted\
    \ and authenticated plaintext; otherwise, the special symbol\n   FAIL is returned.\n\
    \   The decryption construction of SIV is as follows:\n   +------+ +------+  \
    \ +------+           +---+\n   | AD 1 | | AD 2 |...| AD n |           | P |\n\
    \   +------+ +------+   +------+           +---+\n      |        |         | \
    \                 ^\n      |        |    ...  /                  |\n      |  \
    \      |        /  /----------------|\n      |        |       /  /           \
    \      |\n      \\        |      /  /  +------------+  |\n       \\       |  \
    \   /  /   | K = K1||k2 |  |\n        \\      |    /  /    +------------+  |\n\
    \         \\     |   /  /       |   |      +-----+\n          \\    |  /  /  \
    \   K1 |   |  K2  |     |\n           \\   | |  |   /-----/   \\----->| CTR |\n\
    \            \\  | |  |  |         ------->|     |\n             | | |  |  | \
    \        |       +-----+\n             V V V  V  V         |         ^\n     \
    \      +-------------+   +--------+    |\n           |    S2V      |   |   V \
    \   |  +---+\n           +-------------+   +--------+  | C |\n               \
    \  |               | ^     +---+\n                 |               | |       ^\n\
    \                 |               |  \\      |\n                 |           \
    \    |   \\___  |\n                 V               V       \\ |\n           \
    \  +-------+      +---------+ +---+\n             |   T   |----->|  if !=  | |\
    \ Z |\n             +-------+      +---------+ +---+\n                       \
    \          |\n                                 |\n                           \
    \      V\n                                FAIL\n                             \
    \    Figure 10\n   Algorithmically, SIV-Decrypt can be described as:\n      SIV-DECRYPT(K,\
    \ Z, AD1, ..., ADn) {\n        V = leftmost(Z, 128)\n        C = rightmost(Z,\
    \ len(Z)-128)\n        K1 = leftmost(K, len(K)/2)\n        K2 = rightmost(K, len(K)/2)\n\
    \        Q = V bitand (1^64 || 0^1 || 1^31 || 0^1 || 1^31)\n        m = (len(C)\
    \ + 127)/128\n        for i = 0 to m-1 do\n          Xi = AES(K2, Q+i)\n     \
    \   done\n        X = leftmost(X0 || ... || Xm-1, len(C))\n        P = C xor X\n\
    \        T = S2V(K1, AD1, ..., ADn, P)\n        if T = V then\n          return\
    \ P\n        else\n          return FAIL\n        fi\n      }\n   where the key\
    \ length used by AES in CTR and S2V is len(K)/2 and will\n   each be either 128\
    \ bits, 192 bits, or 256 bits.\n   The 31st and 63rd bit (where the rightmost\
    \ bit is the 0th) of the\n   counter are zeroed out just prior to being used in\
    \ CTR mode for\n   optimization purposes, see Section 5.\n"
- title: 3.  Nonce-Based Authenticated Encryption with SIV
  contents:
  - "3.  Nonce-Based Authenticated Encryption with SIV\n   SIV performs nonce-based\
    \ authenticated encryption when a component of\n   the associated data is a nonce.\
    \  For purposes of interoperability the\n   final component -- i.e., the string\
    \ immediately preceding the\n   plaintext in the vector input to S2V -- is used\
    \ for the nonce.  Other\n   associated data are optional.  It is up to the specific\
    \ application\n   of SIV to specify how the rest of the associated data are input.\n\
    \   If the nonce is random, it SHOULD be at least 128 bits in length and\n   be\
    \ harvested from a pool having at least 128 bits of entropy.  A non-\n   random\
    \ source MAY also be used, for instance, a time stamp, or a\n   counter.  The\
    \ definition of a nonce precludes reuse, but SIV is\n   resistant to nonce reuse.\
    \  See Section 1.3.2 for a discussion on the\n   security implications of nonce\
    \ reuse.\n   It MAY be necessary to transport this nonce with the output generated\n\
    \   by S2V.\n"
- title: 4.  Deterministic Authenticated Encryption with SIV
  contents:
  - "4.  Deterministic Authenticated Encryption with SIV\n   When the plaintext to\
    \ encrypt and authenticate contains data that is\n   unpredictable to an adversary\
    \ -- for example, a secret key -- SIV can\n   be used in a deterministic mode\
    \ to perform \"key wrapping\".  Because\n   S2V allows for associated data and\
    \ imposes no unnatural size\n   restrictions on the data it is protecting, it\
    \ is a more useful and\n   general purpose solution than [RFC3394].  Protocols\
    \ that use SIV for\n   deterministic authenticated encryption (i.e., for more\
    \ than just\n   wrapping of keys) MAY define associated data inputs to SIV.  It\
    \ is\n   not necessary to add a nonce component to the AD in this case.\n"
- title: 5.  Optimizations
  contents:
  - "5.  Optimizations\n   Implementations that cannot or do not wish to support addition\
    \ modulo\n   2^128 can take advantage of the fact that the 31st and 63rd bits\n\
    \   (where the rightmost bit is the 0th bit) in the counter are cleared\n   before\
    \ being used by CTR.  This allows implementations that natively\n   support 32-bit\
    \ or 64-bit addition to increment the counter naturally.\n   Of course, in this\
    \ case, the amount of plaintext that can be safely\n   protected by SIV is reduced\
    \ by a commensurate amount -- addition\n   modulo 2^32 limits plaintext to (2^39\
    \ - 128) bits, addition modulo\n   2^64 limits plaintext to (2^71 - 128) bits.\n\
    \   It is possible to optimize an implementation of S2V when it is being\n   used\
    \ as a key derivation function (KDF), for example in [WLAN].  This\n   is because\
    \ S2V operates on a vector of distinct strings and typically\n   the data passed\
    \ to a KDF contains constant strings.  Depending on the\n   location of variant\
    \ components of the input different optimizations\n   are possible.  The CMACed\
    \ output of intermediate and invariant\n   components can be computed once and\
    \ cached.  This can then be doubled\n   and xored with the running sum to produce\
    \ the output.  Or an\n   intermediate value that represents the doubled and xored\
    \ output of\n   multiple components, up to the variant component, can be computed\n\
    \   once and cached.\n"
- title: 6.  IANA Considerations
  contents:
  - "6.  IANA Considerations\n   [RFC5116] defines a uniform interface to cipher modes\
    \ that provide\n   nonce-based Authenticated Encryption with Associated Data (AEAD).\
    \  It\n   does this via a registry of AEAD algorithms.\n   The Internet Assigned\
    \ Numbers Authority (IANA) assigned three entries\n   from the AEAD Registry for\
    \ AES-SIV-CMAC-256 (15), AES-SIV-CMAC-384\n   (16), and AES-SIV-CMAC-512 (17)\
    \ based upon the following AEAD\n   algorithm definitions.  [RFC5116] defines\
    \ operations in octets, not\n   bits.  Limits in this section will therefore be\
    \ specified in octets.\n   The security analysis for each of these algorithms\
    \ is in [DAE].\n   Unfortunately, [RFC5116] restricts AD input to a single component\
    \ and\n   limits the benefit SIV offers for dealing in a natural fashion with\n\
    \   AD consisting of multiple distinct components.  Therefore, when it is\n  \
    \ required to access SIV through the interface defined in [RFC5116], it\n   is\
    \ necessary to marshal multiple AD inputs into a single string (see\n   Section\
    \ 1.1) prior to invoking SIV.  Note that this requirement is\n   not unique to\
    \ SIV.  All cipher modes using [RFC5116] MUST similarly\n   marshal multiple AD\
    \ inputs into a single string, and any technique\n   used for any other AEAD mode\
    \ (e.g., a scatter/gather technique) can\n   be used with SIV.\n   [RFC5116] requires\
    \ AEAD algorithm specifications to include maximal\n   limits to the amount of\
    \ plaintext, the amount of associated data, and\n   the size of a nonce that the\
    \ AEAD algorithm can accept.\n   SIV uses AES in counter mode and the security\
    \ guarantees of SIV would\n   be lost if the counter was allowed to repeat.  Since\
    \ the counter is\n   128 bits, a limit to the amount of plaintext that can be\
    \ safely\n   protected by a single invocation of SIV is 2^128 blocks.\n   To prevent\
    \ the possibility of collisions, [CMAC] recommends that no\n   more than 2^48\
    \ invocations be made to CMAC with the same key.  This\n   is not a limit on the\
    \ amount of data that can be passed to CMAC,\n   though.  There is no practical\
    \ limit to the amount of data that can\n   be made to a single invocation of CMAC,\
    \ and likewise, there is no\n   practical limit to the amount of associated data\
    \ or nonce material\n   that can be passed to SIV.\n   A collision in the output\
    \ of S2V would mean the same counter would be\n   used with different plaintext\
    \ in counter mode.  This would void the\n   security guarantees of SIV.  The \"\
    Birthday Paradox\" (see [APPCRY])\n   would imply that no more than 2^64 distinct\
    \ invocations to SIV be\n   made with the same key.  It is prudent to follow the\
    \ example of\n   [CMAC] though, and further limit the number of distinct invocations\n\
    \   of SIV using the same key to 2^48.  Note that [RFC5116] does not\n   provide\
    \ a variable to describe this limit.\n   The counter-space for SIV is 2^128. \
    \ Each invocation of SIV consumes\n   a portion of that counter-space and the\
    \ amount consumed depends on\n   the amount of plaintext being passed to that\
    \ single invocation.\n   Multiple invocations of SIV with the same key can increase\
    \ the\n   possibility of distinct invocations overlapping the counter-space.\n\
    \   The total amount of plaintext that can be safely protected with a\n   single\
    \ key is, therefore, a function of the number of distinct\n   invocations and\
    \ the amount of plaintext protected with each\n   invocation.\n"
- title: 6.1.  AEAD_AES_SIV_CMAC_256
  contents:
  - "6.1.  AEAD_AES_SIV_CMAC_256\n   The AES-SIV-CMAC-256 AEAD algorithm works as\
    \ specified in Sections\n   2.6 and 2.7.  The input and output lengths for AES-SIV-CMAC-256\
    \ as\n   defined by [RFC5116] are:\n   K_LEN  is 32 octets.\n   P_MAX  is 2^132\
    \ octets.\n   A_MAX  is unlimited.\n   N_MIN  is 1 octet.\n   N_MAX  is unlimited.\n\
    \   C_MAX  is 2^132 + 16 octets.\n   The security implications of nonce reuse\
    \ and/or misuse are described\n   in Section 1.3.2.\n"
- title: 6.2.  AEAD_AES_SIV_CMAC_384
  contents:
  - "6.2.  AEAD_AES_SIV_CMAC_384\n   The AES-SIV-CMAC-384 AEAD algorithm works as\
    \ specified in Sections\n   2.6 and 2.7.  The input and output lengths for AES-SIV-CMAC-384\
    \ as\n   defined by [RFC5116] are:\n   K_LEN  is 48 octets.\n   P_MAX  is 2^132\
    \ octets.\n   A_MAX  is unlimited.\n   N_MIN  is 1 octet.\n   N_MAX  is unlimited.\n\
    \   C_MAX  is 2^132 + 16 octets.\n   The security implications of nonce reuse\
    \ and/or misuse are described\n   in Section 1.3.2.\n"
- title: 6.3.  AEAD_AES_SIV_CMAC_512
  contents:
  - "6.3.  AEAD_AES_SIV_CMAC_512\n   The AES-SIV-CMAC-512 AEAD algorithm works as\
    \ specified in Sections\n   2.6 and 2.7.  The input and output lengths for AES-SIV-CMAC-512\
    \ as\n   defined by [RFC5116] are:\n   K_LEN  is 64 octets.\n   P_MAX  is 2^132\
    \ octets.\n   A_MAX  is unlimited.\n   N_MIN  is 1 octet.\n   N_MAX  is unlimited.\n\
    \   C_MAX  is 2^132 + 16 octets.\n   The security implications of nonce reuse\
    \ and/or misuse are described\n   in Section 1.3.2.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   SIV provides confidentiality in the sense that\
    \ the output of SIV-\n   Encrypt is indistinguishable from a random string of\
    \ bits.  It\n   provides authenticity in the sense that an attacker is unable\
    \ to\n   construct a string of bits that will return other than FAIL when\n  \
    \ input to SIV-Decrypt.  A proof of the security of SIV with an \"all-\n   in-one\"\
    \ notion of security for an authenticated encryption scheme is\n   provided in\
    \ [DAE].\n   SIV provides deterministic \"key wrapping\" when the plaintext contains\n\
    \   data that is unpredictable to an adversary (for instance, a\n   cryptographic\
    \ key).  Even when this key is made available to an\n   attacker the output of\
    \ SIV-Encrypt is indistinguishable from random\n   bits.  Similarly, even when\
    \ this key is made available to an\n   attacker, she is unable to construct a\
    \ string of bits that when input\n   to SIV-Decrypt will return anything other\
    \ than FAIL.\n   When the nonce used in the nonce-based authenticated encryption\
    \ mode\n   of SIV-AES is treated with the care afforded a nonce or counter in\n\
    \   other conventional nonce-based authenticated encryption schemes --\n   i.e.,\
    \ guarantee that it will never be used with the same key for two\n   distinct\
    \ invocations -- then SIV achieves the level of security\n   described above.\
    \  If, however, the nonce is reused SIV continues to\n   provide the level of\
    \ authenticity described above but with a slightly\n   reduced amount of privacy\
    \ (see Section 1.3.2).\n   If S2V is used as a key derivation function, the secret\
    \ input MUST be\n   generated uniformly at random.  S2V is a pseudo-random function\
    \ and\n   is not suitable for use as a random oracle as defined in [RANDORCL].\n\
    \   The security bound set by the proof of security of S2V in [DAE]\n   depends\
    \ on the number of vector-based queries made by an adversary\n   and the total\
    \ number of all components in those queries.  The\n   security is only proven\
    \ when the number of components in each query\n   is limited to n-1, where n is\
    \ the blocksize of the underlying pseudo-\n   random function.  The underlying\
    \ pseudo-random function used here is\n   based on AES whose blocksize is 128\
    \ bits.  Therefore, S2V must not be\n   passed more than 127 components.  Since\
    \ SIV includes the plaintext as\n   a component to S2V, that limits the number\
    \ of components of\n   associated data that can be safely passed to SIV to 126.\n"
- title: 8.  Acknowledgments
  contents:
  - "8.  Acknowledgments\n   Thanks to Phil Rogaway for patiently answering numerous\
    \ questions on\n   SIV and S2V and for useful critiques of earlier versions of\
    \ this\n   paper.  Thanks also to David McGrew for numerous helpful comments and\n\
    \   suggestions for improving this paper.  Thanks to Jouni Malinen for\n   reviewing\
    \ this paper and producing another independent implementation\n   of SIV, thereby\
    \ confirming the correctness of the test vectors.\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative References
  contents:
  - "9.1.  Normative References\n   [CMAC]      Dworkin, M., \"Recommendation for\
    \ Block Cipher Modes of\n               Operation: The CMAC Mode for Authentication\"\
    , NIST\n               Special Pulication 800-38B, May 2005.\n   [MODES]     Dworkin,\
    \ M., \"Recommendation for Block Cipher Modes of\n               Operation: Methods\
    \ and Techniques\", NIST Special\n               Pulication 800-38A, 2001 edition.\n\
    \   [RFC2119]    Bradner, S., \"Key words for use in RFCs to Indicate\n      \
    \         Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC5116]  \
    \  McGrew, D., \"An Interface and Algorithms for\n               Authenticated\
    \ Encryption\", RFC 5116, January 2008.\n"
- title: 9.2.  Informative References
  contents:
  - "9.2.  Informative References\n   [APPCRY]    Menezes, A., van Oorshot, P., and\
    \ S. Vanstone, \"Handbook\n               of Applied Cryptography\", CRC Press\
    \ Series on Discrete\n               Mathematics and Its Applications, 1996.\n\
    \   [BADESP]    Bellovin, S., \"Problem Areas for the IP Security\n          \
    \     Protocols\", Proceedings from the 6th Usenix UNIX Security\n           \
    \    Symposium, July 22-25 1996.\n   [RFC3610]   Whiting, D., Housley, R., and\
    \ N. Ferguson, \"Counter with\n               CBC-MAC (CCM)\", RFC 3610, September\
    \ 2003.\n   [DAE]       Rogaway, P. and T. Shrimpton, \"Deterministic\n      \
    \         Authenticated Encryption, A Provable-Security Treatment\n          \
    \     of the Key-Wrap Problem\", Advances in Cryptology --\n               EUROCRYPT\
    \ '06 St. Petersburg, Russia, 2006.\n   [GCM]       McGrew, D. and J. Viega, \"\
    The Galois/Counter Mode of\n               Operation (GCM)\".\n   [JUTLA]    \
    \ Jutla, C., \"Encryption Modes With Almost Free Message\n               Integrity\"\
    , Proceedings of the International Conference\n               on the Theory and\
    \ Application of Cryptographic\n               Techniques:  Advances in Cryptography.\n\
    \   [OCB]       Krovetz, T. and P. Rogaway, \"The OCB Authenticated\n        \
    \       Encryption Algorithm\", Work in Progress, March 2005.\n   [RADKEY]   \
    \ Zorn, G., Zhang, T., Walker, J., and J. Salowey, \"RADIUS\n               Attributes\
    \ for the Delivery of Keying Material\", Work in\n               Progress, April\
    \ 2007.\n   [RANDORCL]  Bellare, M. and P. Rogaway, \"Random Oracles are\n   \
    \            Practical:  A Paradigm for Designing Efficient\n               Protocols\"\
    , Proceeding of the First ACM Conference on\n               Computer and Communications\
    \ Security, November 1993.\n   [RFC2104]   Krawczyk, H., Bellare, M., and R. Canetti,\
    \ \"HMAC: Keyed-\n               Hashing for Message Authentication\", RFC 2104,\
    \ February\n               1997.\n   [RFC2548]   Zorn, G., \"Microsoft Vendor-specific\
    \ RADIUS Attributes\",\n               RFC 2548, March 1999.\n   [RFC2865]   Rigney,\
    \ C., Willens, S., Rubens, A., and W. Simpson,\n               \"Remote Authentication\
    \ Dial In User Service (RADIUS)\",\n               RFC 2865, June 2000.\n   [RFC3217]\
    \   Housley, R., \"Triple-DES and RC2 Key Wrapping\", RFC 3217,\n            \
    \   December 2001.\n   [RFC3394]   Schaad, J. and R. Housley, \"Advanced Encryption\
    \ Standard\n               (AES) Key Wrap Algorithm\", RFC 3394, September 2002.\n\
    \   [SP800-38D] Dworkin, M., \"Recommendations for Block Cipher Modes of\n   \
    \            Operation: Galois Counter Mode (GCM) and GMAC\", NIST\n         \
    \      Special Pulication 800-38D, June 2007.\n   [VIRT]      Garfinkel, T. and\
    \ M. Rosenblum, \"When Virtual is Harder\n               than Real: Security Challenges\
    \ in Virtual Machine Based\n               Computing Environments\" In 10th Workshop\
    \ on Hot Topics in\n               Operating Systems, May 2005.\n   [WLAN]   \
    \   \"Draft Standard for IEEE802.11: Wireless LAN Medium\n               Access\
    \ Control (MAC) and Physical Layer (PHY)\n               Specification\", 2007.\n\
    \   [X9F1]      Dworkin, M., \"Wrapping of Keys and Associated Data\",\n     \
    \          Request for review of key wrap algorithms. Cryptology\n           \
    \    ePrint report 2004/340, 2004. Contents are excerpts from\n              \
    \ a draft standard of the Accredited Standards Committee,\n               X9,\
    \ entitled ANS X9.102.\n"
- title: Appendix A.  Test Vectors
  contents:
  - "Appendix A.  Test Vectors\n   The following test vectors are for the mode defined\
    \ in Section 6.1.\n"
- title: A.1.  Deterministic Authenticated Encryption Example
  contents:
  - "A.1.  Deterministic Authenticated Encryption Example\n   Input:\n   -----\n \
    \  Key:\n           fffefdfc fbfaf9f8 f7f6f5f4 f3f2f1f0\n           f0f1f2f3 f4f5f6f7\
    \ f8f9fafb fcfdfeff\n   AD:\n           10111213 14151617 18191a1b 1c1d1e1f\n\
    \           20212223 24252627\n   Plaintext:\n           11223344 55667788 99aabbcc\
    \ ddee\n   S2V-CMAC-AES\n   ------------\n   CMAC(zero):\n           0e04dfaf\
    \ c1efbf04 01405828 59bf073a\n   double():\n           1c09bf5f 83df7e08 0280b050\
    \ b37e0e74\n   CMAC(ad):\n           f1f922b7 f5193ce6 4ff80cb4 7d93f23b\n   xor:\n\
    \           edf09de8 76c642ee 4d78bce4 ceedfc4f\n   double():\n           dbe13bd0\
    \ ed8c85dc 9af179c9 9ddbf819\n   pad:\n           11223344 55667788 99aabbcc ddee8000\n\
    \   xor:\n           cac30894 b8eaf254 035bc205 40357819\n   CMAC(final):\n  \
    \         85632d07 c6e8f37f 950acd32 0a2ecc93\n   CTR-AES\n   -------\n   CTR:\n\
    \           85632d07 c6e8f37f 150acd32 0a2ecc93\n   E(K,CTR):\n           51e218d2\
    \ c5a2ab8c 4345c4a6 23b2f08f\n   ciphertext:\n           40c02b96 90c4dc04 daef7f6a\
    \ fe5c\n   output\n   ------\n   IV || C:\n           85632d07 c6e8f37f 950acd32\
    \ 0a2ecc93\n           40c02b96 90c4dc04 daef7f6a fe5c\n"
- title: A.2.  Nonce-Based Authenticated Encryption Example
  contents:
  - "A.2.  Nonce-Based Authenticated Encryption Example\n   Input:\n   -----\n   Key:\n\
    \           7f7e7d7c 7b7a7978 77767574 73727170\n           40414243 44454647\
    \ 48494a4b 4c4d4e4f\n   AD1:\n           00112233 44556677 8899aabb ccddeeff\n\
    \           deaddada deaddada ffeeddcc bbaa9988\n           77665544 33221100\n\
    \   AD2:\n           10203040 50607080 90a0\n   Nonce:\n           09f91102 9d74e35b\
    \ d84156c5 635688c0\n   Plaintext:\n           74686973 20697320 736f6d65 20706c61\n\
    \           696e7465 78742074 6f20656e 63727970\n           74207573 696e6720\
    \ 5349562d 414553\n   S2V-CMAC-AES\n   ------------\n   CMAC(zero):\n        \
    \   c8b43b59 74960e7c e6a5dd85 231e591a\n   double():\n           916876b2 e92c1cf9\
    \ cd4bbb0a 463cb2b3\n   CMAC(ad1)\n           3c9b689a b41102e4 80954714 1dd0d15a\n\
    \   xor:\n           adf31e28 5d3d1e1d 4ddefc1e 5bec63e9\n   double():\n     \
    \      5be63c50 ba7a3c3a 9bbdf83c b7d8c755\n   CMAC(ad2)\n           d98c9b0b\
    \ e42cb2d7 aa98478e d11eda1b\n   xor:\n           826aa75b 5e568eed 3125bfb2 66c61d4e\n\
    \   double():\n           04d54eb6 bcad1dda 624b7f64 cd8c3a1b\n   CMAC(nonce)\n\
    \           128c62a1 ce3747a8 372c1c05 a538b96d\n   xor:\n           16592c17\
    \ 729a5a72 55676361 68b48376\n   xorend:\n           74686973 20697320 736f6d65\
    \ 20706c61\n           696e7465 78742074 6f20656e 63727966\n           2d0c6201\
    \ f3341575 342a3745 f5c625\n   CMAC(final)\n           7bdb6e3b 432667eb 06f4d14b\
    \ ff2fbd0f\n   CTR-AES\n   -------\n   CTR:\n           7bdb6e3b 432667eb 06f4d14b\
    \ 7f2fbd0f\n   E(K,CTR):\n           bff8665c fdd73363 550f7400 e8f9d376\n   CTR+1:\n\
    \           7bdb6e3b 432667eb 06f4d14b 7f2fbd10\n   E(K,CTR+1):\n           b2c9088e\
    \ 713b8617 d8839226 d9f88159\n   CTR+2\n           7bdb6e3b 432667eb 06f4d14b\
    \ 7f2fbd11\n   E(K,CTR+2):\n           9e44d827 234949bc 1b12348e bc195ec7\n \
    \  ciphertext:\n           cb900f2f ddbe4043 26601965 c889bf17\n           dba77ceb\
    \ 094fa663 b7a3f748 ba8af829\n           ea64ad54 4a272e9c 485b62a3 fd5c0d\n \
    \  output\n   ------\n   IV || C:\n           7bdb6e3b 432667eb 06f4d14b ff2fbd0f\n\
    \           cb900f2f ddbe4043 26601965 c889bf17\n           dba77ceb 094fa663\
    \ b7a3f748 ba8af829\n           ea64ad54 4a272e9c 485b62a3 fd5c0d\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Dan Harkins\n   Aruba Networks\n   EMail: dharkins@arubanetworks.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2008).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
