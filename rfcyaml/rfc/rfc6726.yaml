- contents:
  - '          FLUTE - File Delivery over Unidirectional Transport

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document defines File Delivery over Unidirectional Transport\n
    \  (FLUTE), a protocol for the unidirectional delivery of files over the\n   Internet,
    which is particularly suited to multicast networks.  The\n   specification builds
    on Asynchronous Layered Coding, the base\n   protocol designed for massively scalable
    multicast distribution.\n   This document obsoletes RFC 3926.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6726.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2012 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \     1.1. Applicability Statement ....................................5\n           1.1.1.
    The Target Application Space ........................5\n           1.1.2. The
    Target Scale ....................................5\n           1.1.3. Intended
    Environments ...............................5\n           1.1.4. Weaknesses ..........................................6\n
    \  2. Conventions Used in This Document ...............................6\n   3.
    File Delivery ...................................................7\n      3.1.
    File Delivery Session ......................................8\n      3.2. File
    Delivery Table .......................................10\n      3.3. Dynamics
    of FDT Instances within a File Delivery Session ..12\n      3.4. Structure of
    FDT Instance Packets .........................15\n           3.4.1. Format of
    FDT Instance Header ......................16\n           3.4.2. Syntax of FDT
    Instance .............................17\n           3.4.3. Content Encoding of
    FDT Instance ...................21\n      3.5. Multiplexing of Files within a
    File Delivery Session ......22\n   4. Channels, Congestion Control, and Timing
    .......................23\n   5. Delivering FEC Object Transmission Information
    .................24\n   6. Describing File Delivery Sessions ..............................26\n
    \  7. Security Considerations ........................................27\n      7.1.
    Problem Statement .........................................27\n      7.2. Attacks
    against the Data Flow .............................28\n           7.2.1. Access
    to Confidential Files .......................28\n           7.2.2. File Corruption
    ....................................28\n      7.3. Attacks against the Session
    Control Parameters and\n           Associated Building Blocks ................................30\n
    \          7.3.1. Attacks against the Session Description ............30\n           7.3.2.
    Attacks against the FDT Instances ..................31\n           7.3.3. Attacks
    against the ALC/LCT Parameters .............31\n           7.3.4. Attacks against
    the Associated Building Blocks .....32\n      7.4. Other Security Considerations
    .............................32\n      7.5. Minimum Security Recommendations ..........................33\n
    \  8. IANA Considerations ............................................34\n      8.1.
    Registration of the FDT Instance XML Namespace ............34\n      8.2. Registration
    of the FDT Instance XML Schema ...............34\n      8.3. Registration of the
    application/fdt+xml Media Type ........35\n      8.4. Creation of the FLUTE Content
    Encoding Algorithms\n           Registry ..................................................36\n
    \     8.5. Registration of LCT Header Extension Types ................36\n   9.
    Acknowledgments ................................................36\n   10. Contributors
    ..................................................37\n   11. Change Log ....................................................37\n
    \     11.1. RFC 3926 to This Document ................................37\n   12.
    References ....................................................40\n      12.1.
    Normative References .....................................40\n      12.2. Informative
    References ...................................41\n   Appendix A. Receiver Operation
    (Informative) ......................44\n   Appendix B. Example of FDT Instance
    (Informative) .................45\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This document defines FLUTE version 2, a protocol for unidirectional\n
    \  delivery of files over the Internet.  This specification is not\n   backwards
    compatible with the previous experimental version defined\n   in [RFC3926] (see
    Section 11 for details).  The specification builds\n   on Asynchronous Layered
    Coding (ALC), version 1 [RFC5775], the base\n   protocol designed for massively
    scalable multicast distribution.  ALC\n   defines transport of arbitrary binary
    objects.  For file delivery\n   applications, mere transport of objects is not
    enough, however.  The\n   end systems need to know what the objects actually represent.
    \ This\n   document specifies a technique called FLUTE -- a mechanism for\n   signaling
    and mapping the properties of files to concepts of ALC in a\n   way that allows
    receivers to assign those parameters for received\n   objects.  Consequently,
    throughout this document the term 'file'\n   relates to an 'object' as discussed
    in ALC.  Although this\n   specification frequently makes use of multicast addressing
    as an\n   example, the techniques are similarly applicable for use with unicast\n
    \  addressing.\n   This document defines a specific transport application of ALC,
    adding\n   the following specifications:\n   -  Definition of a file delivery
    session built on top of ALC,\n      including transport details and timing constraints.\n
    \  -  In-band signaling of the transport parameters of the ALC session.\n   -
    \ In-band signaling of the properties of delivered files.\n   -  Details associated
    with the multiplexing of multiple files within\n      a session.\n   This specification
    is structured as follows.  Section 3 begins by\n   defining the concept of the
    file delivery session.  Following that,\n   it introduces the File Delivery Table,
    which forms the core part of\n   this specification.  Further, it discusses multiplexing
    issues of\n   transmission objects within a file delivery session.  Section 4\n
    \  describes the use of congestion control and channels with FLUTE.\n   Section
    5 defines how the Forward Error Correction (FEC) Object\n   Transmission Information
    is to be delivered within a file delivery\n   session.  Section 6 defines the
    required parameters for describing\n   file delivery sessions in a general case.
    \ Section 7 outlines\n   security considerations regarding file delivery with
    FLUTE.  Last,\n   there are two informative appendices.  Appendix A describes
    an\n   envisioned receiver operation for the receiver of the file delivery\n   session.
    \ Readers who want to see a simple example of FLUTE in\n   operation should refer
    to Appendix A right away.  Appendix B gives an\n   example of a File Delivery
    Table.\n   This specification contains part of the definitions necessary to\n
    \  fully specify a Reliable Multicast Transport (RMT) protocol in\n   accordance
    with [RFC2357].\n   This document obsoletes [RFC3926], which contained a previous
    version\n   of this specification and was published in the \"Experimental\"\n
    \  category.  This Proposed Standard specification is thus based on\n   [RFC3926]
    and has been updated according to accumulated experience\n   and growing protocol
    maturity since the publication of [RFC3926].\n   Said experience applies both
    to this specification itself and to\n   congestion control strategies related
    to the use of this\n   specification.\n   The differences between [RFC3926] and
    this document are listed in\n   Section 11.\n   This document updates ALC [RFC5775]
    and Layered Coding Transport\n   (LCT) [RFC5651] in the sense that it defines
    two new header\n   extensions, EXT_FDT and EXT_CENC.\n"
  - contents:
    - '1.1.  Applicability Statement

      '
    - contents:
      - "1.1.1.  The Target Application Space\n   FLUTE is applicable to the delivery
        of large and small files to many\n   hosts, using delivery sessions of several
        seconds or more.  For\n   instance, FLUTE could be used for the delivery of
        large software\n   updates to many hosts simultaneously.  It could also be
        used for\n   continuous, but segmented, data such as time-lined text for\n
        \  subtitling -- potentially leveraging its layering inheritance from\n   ALC
        and LCT to scale the richness of the session to the congestion\n   status
        of the network.  It is also suitable for the basic transport\n   of metadata,
        for example, Session Description Protocol (SDP)\n   [RFC4566] files that enable
        user applications to access multimedia\n   sessions.\n"
      title: 1.1.1.  The Target Application Space
    - contents:
      - "1.1.2.  The Target Scale\n   Massive scalability is a primary design goal
        for FLUTE.  IP multicast\n   is inherently massively scalable, but the best-effort
        service that it\n   provides does not provide session management functionality,\n
        \  congestion control, or reliability.  FLUTE provides all of this by\n   using
        ALC and IP multicast without sacrificing any of the inherent\n   scalability
        of IP multicast.\n"
      title: 1.1.2.  The Target Scale
    - contents:
      - "1.1.3.  Intended Environments\n   All of the environmental requirements and
        considerations that apply\n   to the RMT building blocks used by FLUTE shall
        also apply to FLUTE.\n   These are the ALC protocol instantiation [RFC5775],
        the LCT building\n   block [RFC5651], and the FEC building block [RFC5052].\n
        \  FLUTE can be used with both multicast and unicast delivery, but its\n   primary
        application is for unidirectional multicast file delivery.\n   FLUTE requires
        connectivity between a sender and receivers but does\n   not require connectivity
        from receivers to a sender.  Because of its\n   low expectations, FLUTE works
        with most types of networks, including\n   LANs, WANs, Intranets, the Internet,
        asymmetric networks, wireless\n   networks, and satellite networks.\n   FLUTE
        is compatible with both IPv4 and IPv6, as no part of the packet\n   is IP
        version specific.  FLUTE works with both multicast models:\n   Any-Source
        Multicast (ASM) [RFC1112] and Source-Specific Multicast\n   (SSM) [PAPER.SSM].\n
        \  FLUTE is applicable for both shared networks, such as the Internet,\n   with
        a suitable congestion control building block; and provisioned/\n   controlled
        networks, such as wireless broadcast radio systems, with a\n   traffic-shaping
        building block.\n"
      title: 1.1.3.  Intended Environments
    - contents:
      - "1.1.4.  Weaknesses\n   FLUTE congestion control protocols depend on the ability
        of a\n   receiver to change multicast subscriptions between multicast groups\n
        \  supporting different rates and/or layered codings.  If the network\n   does
        not support this, then the FLUTE congestion control protocols\n   may not
        be amenable to such a network.\n   FLUTE can also be used for point-to-point
        (unicast) communications.\n   At a minimum, implementations of ALC MUST support
        the Wave and\n   Equation Based Rate Control (WEBRC) [RFC3738] multiple-rate\n
        \  congestion control scheme [RFC5775].  However, since WEBRC has been\n   designed
        for massively scalable multicast flows, it is not clear how\n   appropriate
        it is to the particular case of unicast flows.  Using a\n   separate point-to-point
        congestion control scheme is another\n   alternative.  How to do that is outside
        the scope of the present\n   document.\n   FLUTE provides reliability using
        the FEC building block.  This will\n   reduce the error rate as seen by applications.
        \ However, FLUTE does\n   not provide a method for senders to verify the reception
        success of\n   receivers, and the specification of such a method is outside
        the\n   scope of this document.\n"
      title: 1.1.4.  Weaknesses
    title: 1.1.  Applicability Statement
  title: 1.  Introduction
- contents:
  - "2.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\",
    \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",
    \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described
    in [RFC2119].\n   The terms \"object\" and \"transmission object\" are consistent
    with the\n   definitions in ALC [RFC5775] and LCT [RFC5651].  The terms \"file\"
    and\n   \"source object\" are pseudonyms for \"object\".\n"
  title: 2.  Conventions Used in This Document
- contents:
  - "3.  File Delivery\n   Asynchronous Layered Coding [RFC5775] is a protocol designed
    for\n   delivery of arbitrary binary objects.  It is especially suitable for\n
    \  massively scalable, unidirectional multicast distribution.  ALC\n   provides
    the basic transport for FLUTE, and thus FLUTE inherits the\n   requirements of
    ALC.\n   This specification is designed for the delivery of files.  The core\n
    \  of this specification is to define how the properties of the files\n   are
    carried in-band together with the delivered files.\n   As an example, let us consider
    a 5200-byte file referred to by\n   \"http://www.example.com/docs/file.txt\".
    \ Using the example, the\n   following properties describe the properties that
    need to be conveyed\n   by the file delivery protocol.\n   *  Identifier of the
    file, expressed as a URI [RFC3986].  The\n      identifier MAY provide a location
    for the file.  In the above\n      example: \"http://www.example.com/docs/file.txt\".\n
    \  *  File name (usually, this can be concluded from the URI).  In the\n      above
    example: \"file.txt\".\n   *  File type, expressed as Internet Media Types (often
    referred to as\n      \"Media Types\").  In the above example: \"text/plain\".\n
    \  *  File size, expressed in octets.  In the above example: \"5200\".  If\n      the
    file is content encoded, then this is the file size before\n      content encoding.\n
    \  *  Content encoding of the file, within transport.  In the above\n      example,
    the file could be encoded using ZLIB [RFC1950].  In this\n      case, the size
    of the transmission object carrying the file would\n      probably differ from
    the file size.  The transmission object size\n      is delivered to receivers
    as part of the FLUTE protocol.\n   *  Security properties of the file, such as
    digital signatures,\n      message digests, etc.  For example, one could use S/MIME
    [RFC5751]\n      as the content encoding type for files with this authentication\n
    \     wrapper, and one could use XML Digital Signatures (XML-DSIG)\n      [RFC3275]
    to digitally sign the file.  XML-DSIG can also be used\n      to provide tamper
    prevention, e.g., in the Content-Location field.\n      Content encoding is applied
    to file data before FEC protection.\n   For each unique file, FLUTE encodes the
    attributes listed above and\n   other attributes as children of an XML file element.
    \ A table of XML\n   file elements is transmitted as a special file called a 'File\n
    \  Delivery Table' (FDT), which is further described in the next\n   subsection
    and in Section 3.2.\n"
  - contents:
    - "3.1.  File Delivery Session\n   ALC is a protocol instantiation of the Layered
      Coding Transport (LCT)\n   building block [RFC5651].  Thus, ALC inherits the
      session concept of\n   LCT.  In this document, we will use the concept of the
      ALC/LCT\n   session to collectively denote the interchangeable terms \"ALC\n
      \  session\" and \"LCT session\".\n   An ALC/LCT session consists of a set of
      logically grouped ALC/LCT\n   channels associated with a single sender sending
      ALC/LCT packets for\n   one or more objects.  An ALC/LCT channel is defined
      by the\n   combination of a sender and an address associated with the channel
      by\n   the sender.  A receiver joins a channel to start receiving the data\n
      \  packets sent to the channel by the sender, and a receiver leaves a\n   channel
      to stop receiving data packets from the channel.\n   One of the fields carried
      in the ALC/LCT header is the Transport\n   Session Identifier (TSI), an integer
      carried in a field of size 16,\n   32, or 48 bits (note that the TSI may be
      carried by other means, in\n   which case it is absent from the LCT header [RFC5651]).
      \ The (source\n   IP address, TSI) pair uniquely identifies a session.  Note
      that the\n   TSI is scoped by the IP address, so the same TSI may be used by\n
      \  several source IP addresses at once.  Thus, the receiver uses the\n   (source
      IP address, TSI) pair from each packet to uniquely identify\n   the session
      sending each packet.  When a session carries multiple\n   objects, the Transmission
      Object Identifier (TOI) field within the\n   ALC/LCT header names the object
      used to generate each packet.  Note\n   that each object is associated with
      a unique TOI within the scope of\n   a session.\n   A FLUTE session consistent
      with this specification MUST use FLUTE\n   version 2 as specified in this document.
      \ Thus, all sessions\n   consistent with this specification MUST set the FLUTE
      version to 2.\n   The FLUTE version is carried within the EXT_FDT Header Extension\n
      \  (defined in Section 3.4.1) in the ALC/LCT layer.  A FLUTE session\n   consistent
      with this specification MUST use ALC version 1 as\n   specified in [RFC5775],
      and LCT version 1 as specified in [RFC5651].\n   If multiple FLUTE sessions
      are sent to a channel, then receivers MUST\n   determine the FLUTE protocol
      version, based on version fields and the\n   (source IP address, TSI) pair carried
      in the ALC/LCT header of the\n   packet.  Note that when a receiver first begins
      receiving packets, it\n   might not know the FLUTE protocol version, as not
      every LCT packet\n   carries the EXT_FDT header (containing the FLUTE protocol
      version).\n   A new receiver MAY keep an open binding in the LCT protocol layer\n
      \  between the TSI and the FLUTE protocol version, until the EXT_FDT\n   header
      arrives.  Alternatively, a new receiver MAY discover a binding\n   between TSI
      and FLUTE protocol version via a session discovery\n   protocol that is out
      of scope of this document.\n   If the sender's IP address is not accessible
      to receivers, then\n   packets that can be received by receivers contain an
      intermediate IP\n   address.  In this case, the TSI is scoped by this intermediate
      IP\n   address of the sender for the duration of the session.  As an\n   example,
      the sender may be behind a Network Address Translation (NAT)\n   device that
      temporarily assigns an IP address for the sender.  In\n   this case, the TSI
      is scoped by the intermediate IP address assigned\n   by the NAT.  As another
      example, the sender may send its original\n   packets using IPv6, but some portions
      of the network may not be IPv6\n   capable.  Thus, there may be an IPv6-to-IPv4
      translator that changes\n   the IP address of the packets to a different IPv4
      address.  In this\n   case, receivers in the IPv4 portion of the network will
      receive\n   packets containing the IPv4 address, and thus the TSI for them is\n
      \  scoped by the IPv4 address.  How the IP address of the sender to be\n   used
      to scope the session by receivers is delivered to receivers,\n   whether it
      is the sender's IP address or an intermediate IP address,\n   is outside the
      scope of this document.\n   When FLUTE is used for file delivery over ALC, the
      ALC/LCT session is\n   called a file delivery session, and the ALC/LCT concept
      of 'object'\n   denotes either a 'file' or a 'File Delivery Table Instance'\n
      \  (Section 3.2).\n   Additionally, the following rules apply:\n   *  The TOI
      field MUST be included in ALC packets sent within a FLUTE\n      session, with
      the exception that ALC packets sent in a FLUTE\n      session with the Close
      Session (A) flag set to 1 (signaling the\n      end of the session) and that
      contain no payload (carrying no\n      information for any file or FDT) SHALL
      NOT carry the TOI.  See\n      Section 5.1 of [RFC5651] for the LCT definition
      of the Close\n      Session flag, and see Section 4.2 of [RFC5775] for an example
      of\n      the use of a TOI within an ALC packet.\n   *  The TOI value '0' is
      reserved for the delivery of File Delivery\n      Table Instances.  Each non-expired
      File Delivery Table Instance is\n      uniquely identified by an FDT Instance
      ID within the EXT_FDT\n      header defined in Section 3.4.1.\n   *  Each file
      in a file delivery session MUST be associated with a TOI\n      (>0) in the
      scope of that session.\n   *  Information carried in the headers and the payload
      of a packet is\n      scoped by the source IP address and the TSI.  Information\n
      \     particular to the object carried in the headers and the payload of\n      a
      packet is further scoped by the TOI for file objects, and is\n      further
      scoped by both the TOI and the FDT Instance ID for FDT\n      Instance objects.\n"
    title: 3.1.  File Delivery Session
  - contents:
    - "3.2.  File Delivery Table\n   The File Delivery Table (FDT) provides a means
      to describe various\n   attributes associated with files that are to be delivered
      within the\n   file delivery session.  The following lists are examples of such\n
      \  attributes and are not intended to be mutually exclusive or\n   exhaustive.\n
      \  Attributes related to the delivery of a file:\n   -  TOI value that represents
      the file\n   -  FEC Object Transmission Information (including the FEC Encoding
      ID\n      and, if relevant, the FEC Instance ID)\n   -  Size of the transmission
      object carrying the file\n   -  Aggregate rate of sending packets to all channels\n
      \  Attributes related to the file itself:\n   -  Name, Identification, and Location
      of file (specified by the URI)\n   -  Media type of file\n   -  Size of file\n
      \  -  Encoding of file\n   -  Message digest of file\n   Some of these attributes
      MUST be included in the file description\n   entry for a file; others are optional,
      as defined in Section 3.4.2.\n   Logically, the FDT is a set of file description
      entries for files to\n   be delivered in the session.  Each file description
      entry MUST\n   include the TOI for the file that it describes and the URI\n
      \  identifying the file.  The TOI carried in each file description entry\n   is
      how FLUTE names the ALC/LCT data packets used for delivery of the\n   file.
      \ Each file description entry may also contain one or more\n   descriptors that
      map the above-mentioned attributes to the file.\n   Each file delivery session
      MUST have an FDT that is local to the\n   given session.  The FDT MUST provide
      a file description entry mapped\n   to a TOI for each file appearing within
      the session.  An object that\n   is delivered within the ALC session, but not
      described in the FDT,\n   other than the FDT itself, is not considered a 'file'
      belonging to\n   the file delivery session.  This object received with an unmapped
      TOI\n   (non-zero TOI that is not resolved by the FDT) SHOULD in general be\n
      \  ignored by a FLUTE receiver.  The details of how to do that are out\n   of
      scope of this specification.\n   Note that a client that joins an active file
      delivery session MAY\n   receive data packets for a TOI > 0 before receiving
      any FDT Instance\n   (see Section 3.3 for recommendations on how to limit the
      probability\n   that this situation will occur).  Even if the TOI is not mapped
      to\n   any file description entry, this is hopefully a transient situation.\n
      \  When this happens, system performance might be improved by caching\n   such
      packets within a reasonable time window and storage size.  Such\n   optimizations
      are use-case and implementation specific, and further\n   details are beyond
      the scope of this document.\n   Within the file delivery session, the FDT is
      delivered as FDT\n   Instances.  An FDT Instance contains one or more file description\n
      \  entries of the FDT.  Any FDT Instance can be equal to, be a subset\n   of,
      be a superset of, overlap with, or complement any other FDT\n   Instance.  A
      certain FDT Instance may be repeated multiple times\n   during a session, even
      after subsequent FDT Instances (with higher\n   FDT Instance ID numbers) have
      been transmitted.  Each FDT Instance\n   contains at least a single file description
      entry and at most the\n   exhaustive set of file description entries of the
      files being\n   delivered in the file delivery session.\n   A receiver of the
      file delivery session keeps an FDT database for\n   received file description
      entries.  The receiver maintains the\n   database, for example, upon reception
      of FDT Instances.  Thus, at any\n   given time the contents of the FDT database
      represent the receiver's\n   current view of the FDT of the file delivery session.
      \ Since each\n   receiver behaves independently of other receivers, it SHOULD
      NOT be\n   assumed that the contents of the FDT database are the same for all\n
      \  the receivers of a given file delivery session.\n   Since the FDT database
      is an abstract concept, the structure and the\n   maintenance of the FDT database
      are left to individual\n   implementations and are thus out of scope of this
      specification.\n"
    title: 3.2.  File Delivery Table
  - contents:
    - "3.3.  Dynamics of FDT Instances within a File Delivery Session\n   The following
      rules define the dynamics of the FDT Instances within a\n   file delivery session:\n
      \  *  For every file delivered within a file delivery session, there\n      MUST
      be a file description entry included in at least one FDT\n      Instance sent
      within the session.  A file description entry\n      contains at a minimum the
      mapping between the TOI and the URI.\n   *  An FDT Instance MAY appear in any
      part of the file delivery\n      session, and packets for an FDT Instance MAY
      be interleaved with\n      packets for other files or other FDT Instances within
      a session.\n   *  The TOI value of '0' MUST be reserved for delivery of FDT\n
      \     Instances.  The use of other TOI values (i.e., an integer > 0) for\n      FDT
      Instances is outside the scope of this specification.\n   *  The FDT Instance
      is identified by the use of a new fixed-length\n      LCT Header Extension,
      EXT_FDT (defined later in this section).\n      Each non-expired FDT Instance
      is uniquely identified within the\n      file delivery session by its FDT Instance
      ID, carried by the\n      EXT_FDT Header Extension.  Any ALC/LCT packet carrying
      an FDT\n      Instance MUST include EXT_FDT.\n   *  It is RECOMMENDED that an
      FDT Instance that contains the file\n      description entry for a file be sent
      at least once before sending\n      the described file within a file delivery
      session.  This\n      recommendation is intended to minimize the amount of file
      data\n      that may be received by receivers in advance of the FDT Instance\n
      \     containing the entry for a file (such data must either be\n      speculatively
      buffered or discarded).  Note that this possibility\n      cannot be completely
      eliminated, since the first transmission of\n      FDT data might be lost.\n
      \  *  Within a file delivery session, any TOI > 0 MAY be described more\n      than
      once.  For example, a previous FDT Instance 0 describes a TOI\n      of value
      '3'.  Now, subsequent FDT Instances can either keep TOI\n      '3' unmodified
      in the table, not include it, or augment the\n      description.  However, subsequent
      FDT Instances MUST NOT change\n      the parameters already described for a
      specific TOI.\n   *  An FDT Instance is valid until its expiration time.  The\n
      \     expiration time is expressed within the FDT Instance payload as a\n      UTF-8
      decimal representation of a 32-bit unsigned integer.  The\n      value of this
      integer represents the 32 most significant bits of a\n      64-bit Network Time
      Protocol (NTP) [RFC5905] time value.  These\n      32 bits provide an unsigned
      integer representing the time in\n      seconds relative to 0 hours 1 January
      1900 in the case of the\n      prime epoch (era 0) [RFC5905].  The handling
      of time wraparound\n      (to happen in 2036) requires that the associated epoch
      be\n      considered.  In any case, both a sender and a receiver easily\n      determine
      to which (136-year) epoch the FDT Instance expiration\n      time value pertains
      by choosing the epoch for which the expiration\n      time is closest in time
      to the current time.\n      Here is an example.  Let us imagine that a new FLUTE
      session is\n      started on February 7th, 2036, 0h, i.e., at NTP time\n      4,294,944,000,
      a few hours before the end of epoch 0.  In order to\n      define an FDT Instance
      valid for the next 48 hours, The FLUTE\n      sender sets an expiry time of
      149,504.  This FDT Instance will\n      expire exactly on February 9th, 2036,
      0h.  A client that receives\n      this FDT Instance on the 7th, 0h, just after
      it has been sent,\n      immediately understands that this value corresponds
      to epoch 1.  A\n      client that joins the session on February 8th, 0h, i.e.,
      at NTP\n      time 63,104, epoch 1, immediately understands that the 149,504
      NTP\n      timestamp corresponds to epoch 1.\n   *  The space of FDT Instance
      IDs is limited by the associated field\n      size (i.e., 20 bits) in the EXT_FDT
      Header Extension\n      (Section 3.4.1).  Therefore, senders should take care
      to always\n      have a large enough supply of available FDT Instance IDs when\n
      \     specifying FDT expiration times.\n   *  The receiver MUST NOT use a received
      FDT Instance to interpret\n      packets received beyond the expiration time
      of the FDT Instance.\n   *  A sender MUST use an expiration time in the future
      upon creation\n      of an FDT Instance relative to its Sender Current Time
      (SCT).\n   *  Any FEC Encoding ID MAY be used for the sending of FDT Instances.\n
      \     The default is to use the Compact No-Code FEC Encoding ID 0\n      [RFC5445]
      for the sending of FDT Instances.  (Note that since FEC\n      Encoding ID 0
      is the default for FLUTE, this implies that Source\n      Block Number and Encoding
      Symbol ID lengths both default to\n      16 bits each.)\n   *  If the receiver
      does not support the FEC Scheme indicated by the\n      FEC Encoding ID, the
      receiver MUST NOT decode the associated FDT.\n   *  It is RECOMMENDED that the
      mechanisms used for file attribute\n      delivery SHOULD achieve a delivery
      probability that is higher than\n      the file recovery probability and the
      file attributes SHOULD be\n      delivered at this higher priority before the
      delivery of the\n      associated files begins.\n   Generally, a receiver needs
      to receive an FDT Instance describing a\n   file before it is able to recover
      the file itself.  In this sense,\n   FDT Instances are of higher priority than
      files.  Additionally, a\n   FLUTE sender SHOULD assume that receivers will not
      receive all\n   packets pertaining to FDT Instances.  The way FDT Instances
      are\n   transmitted has a large impact on satisfying the recommendation\n   above.
      \ When there is a single file transmitted in the session, one\n   way to satisfy
      the recommendation above is to repeatedly transmit on\n   a regular enough basis
      FDT Instances describing the file while the\n   file is being transmitted.  If
      an FDT Instance is longer than one\n   packet payload in length, it is RECOMMENDED
      that an FEC code that\n   provides protection against loss be used for delivering
      this FDT\n   Instance.  When there are multiple files in a session concurrently\n
      \  being transmitted to receivers, the way the FDT Instances are\n   structured
      and transmitted also has a large impact.  As an example, a\n   way to satisfy
      the recommendation above is to transmit an FDT\n   Instance that describes all
      files currently being transmitted, and to\n   transmit this FDT Instance reliably,
      using the same techniques as\n   explained for the case when there is a single
      file transmitted in a\n   session.  If instead the concurrently transmitted
      files are described\n   in separate FDT Instances, another way to satisfy this
      recommendation\n   is to transmit all the relevant FDT Instances reliably, using
      the\n   same techniques as explained for the case when there is a single file\n
      \  transmitted in a session.\n   In any case, how often the description of a
      file is sent in an FDT\n   Instance, how often an FDT Instance is sent, and
      how much FEC\n   protection is provided for an FDT Instance (if longer than
      one packet\n   payload) are dependent on the particular application and are
      outside\n   the scope of this document.\n   Sometimes the various attributes
      associated with files that are to be\n   delivered within the file delivery
      session are sent out-of-band.  The\n   details of how this is done are out of
      the scope of this document.\n   However, it is still RECOMMENDED that any out-of-band
      transmission be\n   managed in such a way that a receiver will be able to recover
      the\n   attributes associated with a file at least as reliably as the\n   receiver
      is able to receive enough packets containing encoding\n   symbols to recover
      the file.  For example, the probability of a\n   randomly chosen receiver being
      able to recover a given file can often\n   be estimated based on a statistical
      model of reception conditions,\n   the amount of data transmitted, and the properties
      of any Forward\n   Error Correction in use.  The recommendation above suggests
      that\n   mechanisms used for file attribute delivery should achieve a higher\n
      \  delivery probability than the file recovery probability.  The sender\n   MAY
      also continue sending the various file attributes in-band, in\n   addition to
      the out-of-band transmission.\n"
    title: 3.3.  Dynamics of FDT Instances within a File Delivery Session
  - contents:
    - "3.4.  Structure of FDT Instance Packets\n   FDT Instances are carried in ALC
      packets with TOI = 0 and with an\n   additional REQUIRED LCT Header extension
      called the FDT Instance\n   Header.  The FDT Instance Header (EXT_FDT) contains
      the FDT Instance\n   ID that uniquely identifies FDT Instances within a file
      delivery\n   session.  Placement of the FDT Instance Header is the same as that
      of\n   any other LCT Header Extension.  There MAY be other LCT Header\n   Extensions
      in use.\n   The FDT Instance is encoded for transmission, like any other object,\n
      \  using an FEC Scheme (which MAY be the Compact No-Code FEC Scheme).\n   The
      LCT Header Extensions are followed by the FEC Payload ID, and\n   finally the
      Encoding Symbols for the FDT Instance, which contains one\n   or more file description
      entries.  An FDT Instance MAY span several\n   ALC packets -- the number of
      ALC packets is a function of the file\n   attributes associated with the FDT
      Instance.  The FDT Instance Header\n   is carried in each ALC packet carrying
      the FDT Instance.  The FDT\n   Instance Header is identical for all ALC/LCT
      packets for a particular\n   FDT Instance.\n   The overall format of ALC/LCT
      packets carrying an FDT Instance is\n   depicted in Figure 1 below.  All integer
      fields are carried in\n   \"big-endian\" or \"network order\" format (i.e.,
      most significant byte\n   (octet) first).  As defined in [RFC5775], all ALC/LCT
      packets are\n   sent using UDP.\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                         UDP header                            |\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                Default
      LCT header (with TOI = 0)              |\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |          LCT
      Header Extensions (EXT_FDT, EXT_FTI, etc.)       |\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                       FEC
      Payload ID                          |\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                  FLUTE
      Payload: Encoding Symbol(s)\n   ~             (for FDT Instance in an FDT packet)
      \              ~\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                      Figure 1: Overall FDT Packet\n"
    - contents:
      - "3.4.1.  Format of FDT Instance Header\n   The FDT Instance Header (EXT_FDT)
        is a new fixed-length, ALC\n   Protocol-Instantiation-specific LCT Header
        Extension [RFC5651].  The\n   Header Extension Type (HET) for the extension
        is 192.  Its format is\n   defined below:\n    0                   1                   2
        \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |   HET = 192   |   V   |          FDT Instance ID              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \                        Figure 2: EXT_FDT Format\n   Version of FLUTE (V),
        4 bits:\n   This document specifies FLUTE version 2.  Hence, in any ALC packet\n
        \  that carries an FDT Instance and that belongs to the file delivery\n   session
        as specified in this specification MUST set this field\n   to '2'.\n   FDT
        Instance ID, 20 bits:\n   For each file delivery session, the numbering of
        FDT Instances starts\n   from '0' and is incremented by one for each subsequent
        FDT Instance.\n   After reaching the maximum value (2^20-1), the numbering
        starts from\n   the smallest FDT Instance ID value assigned to an expired
        FDT\n   Instance.  When wraparound from a greater FDT Instance ID value to
        a\n   smaller FDT Instance ID value occurs, the smaller FDT Instance ID\n
        \  value is considered logically higher than the greater FDT Instance ID\n
        \  value.  Then, the subsequent FDT Instances are assigned the next\n   available
        smallest FDT Instance ID value, in order to always keep the\n   FDT Instance
        ID values logically increasing.\n   Senders MUST NOT reuse an FDT Instance
        ID value that is already in\n   use for a non-expired FDT Instance.  Sender
        behavior when all the FDT\n   Instance IDs are used by non-expired FEC Instances
        is outside the\n   scope of this specification and left to individual implementations
        of\n   FLUTE.  Receipt of an FDT Instance that reuses an FDT Instance ID\n
        \  value that is currently used by a non-expired FDT Instance MUST be\n   considered
        an error case.  Receiver behavior in this case (e.g.,\n   leave the session
        or ignore the new FDT Instance) is outside the\n   scope of this specification
        and left to individual implementations of\n   FLUTE.  Receivers MUST be ready
        to handle FDT Instance ID wraparound\n   and situations where missing FDT
        Instance IDs result in increments\n   larger than one.\n"
      title: 3.4.1.  Format of FDT Instance Header
    - contents:
      - "3.4.2.  Syntax of FDT Instance\n   The FDT Instance contains file description
        entries that provide the\n   mapping functionality described in Section 3.2
        above.\n   The FDT Instance is an Extensible Markup Language (XML) structure\n
        \  that has a single root element \"FDT-Instance\".  The \"FDT-Instance\"\n
        \  element MUST contain the \"Expires\" attribute, which provides the\n   expiration
        time of the FDT Instance.  In addition, the \"FDT-Instance\"\n   element MAY
        contain the \"Complete\" attribute, a boolean that can be\n   either set to
        '1' or 'true' for TRUE, or '0' or 'false' for FALSE.\n   When TRUE, the \"Complete\"
        attribute signals that this \"FDT Instance\"\n   includes the set of \"File\"
        entries that exhausts both the set of\n   files delivered so far and the set
        of files to be delivered in the\n   session.  This implies that no new data
        will be provided in future\n   FDT Instances within this session (i.e., that
        either FDT Instances\n   with higher ID numbers will not be used or, if they
        are used, will\n   only provide file parameters identical to those already
        given in this\n   and previous FDT Instances).  The \"Complete\" attribute
        is therefore\n   used to provide a complete list of files in an entire FLUTE
        session\n   (a \"complete FDT\").  Note that when all the FDT Instances received
        so\n   far have no \"Complete\" attribute, the receiver MUST consider that
        the\n   session is not complete and that new data MAY be provided in future\n
        \  FDT Instances.  This is equivalent to receiving FDT Instances having\n
        \  the \"Complete\" attribute set to FALSE.\n   The \"FDT-Instance\" element
        MAY contain attributes that give common\n   parameters for all files of an
        FDT Instance.  These attributes MAY\n   also be provided for individual files
        in the \"File\" element.  Where\n   the same attribute appears in both the
        \"FDT-Instance\" and the \"File\"\n   elements, the value of the attribute
        provided in the \"File\" element\n   takes precedence.\n   For each file to
        be declared in the given FDT Instance, there is a\n   single file description
        entry in the FDT Instance.  Each entry is\n   represented by element \"File\",
        which is a child element of the FDT\n   Instance structure.\n   The attributes
        of the \"File\" element in the XML structure represent\n   the attributes
        given to the file that is delivered in the file\n   delivery session.  The
        value of the XML attribute name corresponds to\n   the MIME field name, and
        the XML attribute value corresponds to the\n   value of the MIME field body
        [RFC2045].  Each \"File\" element MUST\n   contain at least two attributes:
        \"TOI\" and \"Content-Location\".  \"TOI\"\n   MUST be assigned a valid TOI
        value as described in Section 3.3.\n   \"Content-Location\" [RFC2616] MUST
        be assigned a syntactically valid\n   URI, as defined in [RFC3986], which
        identifies the file to be\n   delivered.  For example, it can be a URI with
        the \"http\" or \"file\"\n   URI scheme.  Only one \"Content-Location\" attribute
        is allowed for\n   each file.  The \"Content-Location\" field MUST be considered
        a string\n   that identifies a file (i.e., two different strings are two different\n
        \  identifiers).  Any use of the \"Content-Location\" field for anything\n
        \  else other than to identify the object is out of scope of this\n   specification.
        \ The semantics for any two \"File\" elements declaring\n   the same \"Content-Location\"
        but differing \"TOI\" is that the element\n   appearing in the FDT Instance
        with the greater FDT Instance ID is\n   considered to declare a newer instance
        (e.g., version) of the same\n   \"File\".\n   In addition to mandatory attributes,
        the \"FDT-Instance\" element and\n   the \"File\" element MAY contain other
        attributes, of which the\n   following are specifically pointed out:\n   *
        \ The attribute \"Content-Type\" SHOULD be included and, when present,\n      MUST
        be used for the purpose defined in [RFC2616].\n   *  Where the length is described,
        the attribute \"Content-Length\" MUST\n      be used for the purpose defined
        in [RFC2616].  The transfer length\n      is defined to be the length of the
        object transported in octets.\n      It is often important to convey the transfer
        length to receivers,\n      because the source block structure needs to be
        known for the FEC\n      decoder to be applied to recover source blocks of
        the file, and\n      the transfer length is often needed to properly determine
        the\n      source block structure of the file.  There generally will be a\n
        \     difference between the length of the original file and the\n      transfer
        length if content encoding is applied to the file before\n      transport,
        and thus the \"Content-Encoding\" attribute is used.  If\n      the file is
        not content encoded before transport (and thus the\n      \"Content-Encoding\"
        attribute is not used), then the transfer\n      length is the length of the
        original file, and in this case the\n      \"Content-Length\" is also the
        transfer length.  However, if the\n      file is content encoded before transport
        (and thus the\n      \"Content-Encoding\" attribute is used), e.g., if compression
        is\n      applied before transport to reduce the number of octets that need\n
        \     to be transferred, then the transfer length is generally different\n
        \     than the length of the original file, and in this case the\n      attribute
        \"Transfer-Length\" MAY be used to carry the transfer\n      length.\n   *
        \ Whenever content encoding is applied, the attribute\n      \"Content-Encoding\"
        MUST be included.  Whenever the attribute\n      \"Content-Encoding\" is included,
        it MUST be used as described in\n      [RFC2616].\n   *  Where the MD5 message
        digest is described, the attribute\n      \"Content-MD5\" MUST be used for
        the purpose defined in [RFC2616].\n      Note that the goal is to provide
        a decoded object integrity\n      service in cases where transmission and/or
        FLUTE/ALC processing\n      errors may occur (the probability of collision
        is in that case\n      negligible).  It MUST NOT be regarded as a security
        mechanism (see\n      Section 7 for information regarding security measures).\n
        \  *  The FEC Object Transmission Information attributes are described\n      in
        Section 5.\n   The following specifies the XML Schema [XML-Schema-Part-1]\n
        \  [XML-Schema-Part-2] for the FDT Instance:\n   BEGIN\n   <?xml version=\"1.0\"
        encoding=\"UTF-8\"?>\n   <xs:schema xmlns=\"urn:ietf:params:xml:ns:fdt\"\n
        \             xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n              targetNamespace=\"urn:ietf:params:xml:ns:fdt\"\n
        \             elementFormDefault=\"qualified\">\n     <xs:element name=\"FDT-Instance\"
        type=\"FDT-InstanceType\"/>\n     <xs:complexType name=\"FDT-InstanceType\">\n
        \      <xs:sequence>\n         <xs:element name=\"File\" type=\"FileType\"
        maxOccurs=\"unbounded\"/>\n         <xs:any namespace=\"##other\" processContents=\"skip\"\n
        \                minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n       </xs:sequence>\n
        \      <xs:attribute name=\"Expires\"\n                     type=\"xs:string\"\n
        \                    use=\"required\"/>\n       <xs:attribute name=\"Complete\"\n
        \                    type=\"xs:boolean\"\n                     use=\"optional\"/>\n
        \      <xs:attribute name=\"Content-Type\"\n                     type=\"xs:string\"\n
        \                    use=\"optional\"/>\n       <xs:attribute name=\"Content-Encoding\"\n
        \                    type=\"xs:string\"\n                     use=\"optional\"/>\n
        \      <xs:attribute name=\"FEC-OTI-FEC-Encoding-ID\"\n                     type=\"xs:unsignedByte\"\n
        \                    use=\"optional\"/>\n       <xs:attribute name=\"FEC-OTI-FEC-Instance-ID\"\n
        \                    type=\"xs:unsignedLong\"\n                     use=\"optional\"/>\n
        \      <xs:attribute name=\"FEC-OTI-Maximum-Source-Block-Length\"\n                     type=\"xs:unsignedLong\"\n
        \                    use=\"optional\"/>\n       <xs:attribute name=\"FEC-OTI-Encoding-Symbol-Length\"\n
        \                    type=\"xs:unsignedLong\"\n                     use=\"optional\"/>\n
        \      <xs:attribute name=\"FEC-OTI-Max-Number-of-Encoding-Symbols\"\n                     type=\"xs:unsignedLong\"\n
        \                    use=\"optional\"/>\n       <xs:attribute name=\"FEC-OTI-Scheme-Specific-Info\"\n
        \                    type=\"xs:base64Binary\"\n                     use=\"optional\"/>\n
        \      <xs:anyAttribute processContents=\"skip\"/>\n     </xs:complexType>\n
        \    <xs:complexType name=\"FileType\">\n       <xs:sequence>\n         <xs:any
        namespace=\"##other\" processContents=\"skip\"\n                 minOccurs=\"0\"
        maxOccurs=\"unbounded\"/>\n       </xs:sequence>\n       <xs:attribute name=\"Content-Location\"\n
        \                    type=\"xs:anyURI\"\n                     use=\"required\"/>\n
        \      <xs:attribute name=\"TOI\"\n                     type=\"xs:positiveInteger\"\n
        \                    use=\"required\"/>\n       <xs:attribute name=\"Content-Length\"\n
        \                    type=\"xs:unsignedLong\"\n                     use=\"optional\"/>\n
        \      <xs:attribute name=\"Transfer-Length\"\n                     type=\"xs:unsignedLong\"\n
        \                    use=\"optional\"/>\n       <xs:attribute name=\"Content-Type\"\n
        \                    type=\"xs:string\"\n                     use=\"optional\"/>\n
        \      <xs:attribute name=\"Content-Encoding\"\n                     type=\"xs:string\"\n
        \                    use=\"optional\"/>\n       <xs:attribute name=\"Content-MD5\"\n
        \                    type=\"xs:base64Binary\"\n                     use=\"optional\"/>\n
        \      <xs:attribute name=\"FEC-OTI-FEC-Encoding-ID\"\n                     type=\"xs:unsignedByte\"\n
        \                    use=\"optional\"/>\n       <xs:attribute name=\"FEC-OTI-FEC-Instance-ID\"\n
        \                    type=\"xs:unsignedLong\"\n                     use=\"optional\"/>\n
        \      <xs:attribute name=\"FEC-OTI-Maximum-Source-Block-Length\"\n                     type=\"xs:unsignedLong\"\n
        \                    use=\"optional\"/>\n       <xs:attribute name=\"FEC-OTI-Encoding-Symbol-Length\"\n
        \                    type=\"xs:unsignedLong\"\n                     use=\"optional\"/>\n
        \      <xs:attribute name=\"FEC-OTI-Max-Number-of-Encoding-Symbols\"\n                     type=\"xs:unsignedLong\"\n
        \                    use=\"optional\"/>\n       <xs:attribute name=\"FEC-OTI-Scheme-Specific-Info\"\n
        \                    type=\"xs:base64Binary\"\n                     use=\"optional\"/>\n
        \      <xs:anyAttribute processContents=\"skip\"/>\n     </xs:complexType>\n
        \  </xs:schema>\n   END\n                 Figure 3: XML Schema for the FDT
        Instance\n   Any valid FDT Instance MUST use the above XML Schema.  This way,
        FDT\n   provides extensibility to support private elements and private\n   attributes
        within the file description entries.  Those could be, for\n   example, the
        attributes related to the delivery of the file (timing,\n   packet transmission
        rate, etc.).  Unsupported private elements and\n   attributes SHOULD be silently
        ignored by a FLUTE receiver.\n   In case the basic FDT XML Schema is extended
        in terms of new\n   descriptors (attributes or elements), for descriptors
        applying to a\n   single file, those MUST be placed within the element \"File\".
        \ For\n   descriptors applying to all files described by the current FDT\n
        \  Instance, those MUST be placed within the element \"FDT-Instance\".  It\n
        \  is RECOMMENDED that the new attributes applied in the FDT be in the\n   format
        of message header fields and be either defined in the HTTP/1.1\n   specification
        [RFC2616] or another well-known specification, or in an\n   IANA registry
        [IANAheaderfields].  However, this specification\n   doesn't prohibit the
        use of other formats to allow private attributes\n   to be used when interoperability
        is not a concern.\n"
      title: 3.4.2.  Syntax of FDT Instance
    - contents:
      - "3.4.3.  Content Encoding of FDT Instance\n   The FDT Instance itself MAY
        be content encoded (e.g., compressed).\n   This specification defines the
        FDT Instance Content Encoding Header\n   (EXT_CENC).  EXT_CENC is a new fixed-length
        LCT Header Extension\n   [RFC5651].  The Header Extension Type (HET) for the
        extension is 193.\n   If the FDT Instance is content encoded, EXT_CENC MUST
        be used to\n   signal the content encoding type.  In that case, the EXT_CENC
        Header\n   Extension MUST be used in all ALC packets carrying the same FDT\n
        \  Instance ID.  Consequently, when the EXT_CENC header is used, it MUST\n
        \  be used together with a proper FDT Instance Header (EXT_FDT).  Within\n
        \  a file delivery session, FDT Instances that are not content encoded\n   and
        FDT Instances that are content encoded MAY both appear.  If\n   content encoding
        is not used for a given FDT Instance, EXT_CENC MUST\n   NOT be used in any
        packet carrying the FDT Instance.  The format of\n   EXT_CENC is defined below:\n
        \   0                   1                   2                   3\n    0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |   HET = 193   |     CENC      |          Reserved             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \                        Figure 4: EXT_CENC Format\n   Content Encoding Algorithm
        (CENC), 8 bits:\n   This field signals the content encoding algorithm used
        in the FDT\n   Instance payload.  This subsection reserves the Content Encoding\n
        \  Algorithm values 0, 1, 2, and 3 for null, ZLIB [RFC1950], DEFLATE\n   [RFC1951],
        and GZIP [RFC1952], respectively.\n   Reserved, 16 bits:\n   This field MUST
        be set to all '0's.  This field MUST be ignored on\n   reception.\n"
      title: 3.4.3.  Content Encoding of FDT Instance
    title: 3.4.  Structure of FDT Instance Packets
  - contents:
    - "3.5.  Multiplexing of Files within a File Delivery Session\n   The delivered
      files are carried as transmission objects (identified\n   with TOIs) in the
      file delivery session.  All these objects,\n   including the FDT Instances,
      MAY be multiplexed in any order and in\n   parallel with each other within a
      session; i.e., packets for one file\n   may be interleaved with packets for
      other files or other FDT\n   Instances within a session.\n   Multiple FDT Instances
      MAY be delivered in a single session using\n   TOI = 0.  In this case, it is
      RECOMMENDED that the sending of a\n   previous FDT Instance SHOULD end before
      the sending of the next FDT\n   Instance starts.  However, due to unexpected
      network conditions,\n   packets for the FDT Instances might be interleaved.
      \ A receiver can\n   determine which FDT Instance a packet contains information
      about,\n   since the FDT Instances are uniquely identified by their FDT Instance\n
      \  ID carried in the EXT_FDT headers.\n"
    title: 3.5.  Multiplexing of Files within a File Delivery Session
  title: 3.  File Delivery
- contents:
  - "4.  Channels, Congestion Control, and Timing\n   ALC/LCT has a concept of channels
    and congestion control.  There are\n   four scenarios in which FLUTE is envisioned
    to be applied.\n   (a)  Use of a single channel and a single-rate congestion control\n
    \       protocol.\n   (b)  Use of multiple channels and a multiple-rate congestion
    control\n        protocol.  In this case, the FDT Instances MAY be delivered on\n
    \       more than one channel.\n   (c)  Use of a single channel without congestion
    control supplied by\n        ALC, but only when in a controlled network environment
    where\n        flow/congestion control is being provided by other means.\n   (d)
    \ Use of multiple channels without congestion control supplied by\n        ALC,
    but only when in a controlled network environment where\n        flow/congestion
    control is being provided by other means.  In\n        this case, the FDT Instances
    MAY be delivered on more than one\n        channel.\n   When using just one channel
    for a file delivery session, as in (a)\n   and (c), the notion of 'prior' and
    'after' are intuitively defined\n   for the delivery of objects with respect to
    their delivery times.\n   However, if multiple channels are used, as in (b) and
    (d), it is not\n   straightforward to state that an object was delivered 'prior'
    to the\n   other.  An object may begin to be delivered on one or more of those\n
    \  channels before the delivery of a second object begins.  However, the\n   use
    of multiple channels/layers may mean that the delivery of the\n   second object
    is completed before the first.  This is not a problem\n   when objects are delivered
    sequentially using a single channel.\n   Thus, if the application of FLUTE has
    a mandatory or critical\n   requirement that the first transmission object must
    complete 'prior'\n   to the second one, it is RECOMMENDED that only a single channel
    be\n   used for the file delivery session.\n   Furthermore, if multiple channels
    are used, then a receiver joined to\n   the session at a low reception rate will
    only be joined to the lower\n   layers of the session.  Thus, since the reception
    of FDT Instances is\n   of higher priority than the reception of files (because
    the reception\n   of files depends on the reception of an FDT Instance describing
    it),\n   the following are RECOMMENDED:\n   1.  The layers to which packets for
    FDT Instances are sent SHOULD NOT\n       be biased towards those layers to which
    lower-rate receivers are\n       not joined.  For example, it is okay to put all
    the packets for\n       an FDT Instance into the lowest layer (if this layer carries\n
    \      enough packets to deliver the FDT to higher-rate receivers in a\n       reasonable
    amount of time), but it is not okay to put all the\n       packets for an FDT
    Instance into the higher layers that only\n       higher-rate receivers will receive.\n
    \  2.  If FDT Instances are generally longer than one Encoding Symbol in\n       length
    and some packets for FDT Instances are sent to layers that\n       lower-rate
    receivers do not receive, an FEC encoding other than\n       Compact No-Code FEC
    Encoding ID 0 [RFC5445] SHOULD be used to\n       deliver FDT Instances.  This
    is because in this case, even when\n       there is no packet loss in the network,
    a lower-rate receiver\n       will not receive all packets sent for an FDT Instance.\n"
  title: 4.  Channels, Congestion Control, and Timing
- contents:
  - "5.  Delivering FEC Object Transmission Information\n   FLUTE inherits the use
    of the FEC building block [RFC5052] from ALC.\n   When using FLUTE for file delivery
    over ALC, the FEC Object\n   Transmission Information MUST be delivered in-band
    within the file\n   delivery session.  There are two methods to achieve this:
    the use of\n   the ALC-specific LCT Header Extension EXT_FTI [RFC5775] and the
    use\n   of the FDT.  The latter method is specified in this section.  The use\n
    \  of EXT_FTI requires repetition of the FEC Object Transmission\n   Information
    to ensure reception (though not necessarily in every\n   packet) and thus may
    entail higher overhead than the use of the FDT,\n   but may also provide more
    timely delivery of the FEC Object\n   Transmission Information.\n   The receiver
    of a file delivery session MUST support delivery of FEC\n   Object Transmission
    Information using EXT_FTI for the FDT Instances\n   carried using TOI value 0.
    \ For the TOI values other than 0, the\n   receiver MUST support both methods:
    the use of EXT_FTI and the use of\n   the FDT.\n   The FEC Object Transmission
    Information that needs to be delivered to\n   receivers MUST be exactly the same
    whether it is delivered using\n   EXT_FTI or using the FDT (or both).  The FEC
    Object Transmission\n   Information that MUST be delivered to receivers is defined
    by the FEC\n   Scheme.  This section describes the delivery using the FDT.\n   The
    FEC Object Transmission Information regarding a given TOI may be\n   available
    from several sources.  In this case, it is RECOMMENDED that\n   the receiver of
    the file delivery session prioritize the sources in\n   the following way (in
    order of decreasing priority).\n   1.  FEC Object Transmission Information that
    is available in EXT_FTI.\n   2.  FEC Object Transmission Information that is available
    in the FDT.\n   The FDT delivers FEC Object Transmission Information for each
    file\n   using an appropriate attribute within the \"FDT-Instance\" or the\n   \"File\"
    element of the FDT structure.\n   *  \"Transfer-Length\" carries the \"Transfer-Length\"
    Object\n      Transmission Information element defined in [RFC5052].\n   *  \"FEC-OTI-FEC-Encoding-ID\"
    carries the \"FEC Encoding ID\" Object\n      Transmission Information element
    defined in [RFC5052], as carried\n      in the Codepoint field of the ALC/LCT
    header.\n   *  \"FEC-OTI-FEC-Instance-ID\" carries the \"FEC Instance ID\" Object\n
    \     Transmission Information element defined in [RFC5052] for\n      Under-Specified
    FEC Schemes.\n   *  \"FEC-OTI-Maximum-Source-Block-Length\" carries the\n      \"Maximum-Source-Block-Length\"
    Object Transmission Information\n      element defined in [RFC5052], if required
    by the FEC Scheme.\n   *  \"FEC-OTI-Encoding-Symbol-Length\" carries the\n      \"Encoding-Symbol-Length\"
    Object Transmission Information element\n      defined in [RFC5052], if required
    by the FEC Scheme.\n   *  \"FEC-OTI-Max-Number-of-Encoding-Symbols\" carries the\n
    \     \"Max-Number-of-Encoding-Symbols\" Object Transmission Information\n      element
    defined in [RFC5052], if required by the FEC Scheme.\n   *  \"FEC-OTI-Scheme-Specific-Info\"
    carries the \"encoded\n      Scheme-specific FEC Object Transmission Information\"
    as defined in\n      [RFC5052], if required by the FEC Scheme.\n   In FLUTE, the
    FEC Encoding ID (8 bits) for a given TOI MUST be\n   carried in the Codepoint
    field of the ALC/LCT header.  When the FEC\n   Object Transmission Information
    for this TOI is delivered through the\n   FDT, then the associated \"FEC-OTI-FEC-Encoding-ID\"
    attribute and the\n   Codepoint field of all packets for this TOI MUST be the
    same.\n"
  title: 5.  Delivering FEC Object Transmission Information
- contents:
  - "6.  Describing File Delivery Sessions\n   To start receiving a file delivery
    session, the receiver needs to\n   know transport parameters associated with the
    session.  Interpreting\n   these parameters and starting the reception therefore
    represent the\n   entry point from which thereafter the receiver operation falls
    into\n   the scope of this specification.  According to [RFC5775], the\n   transport
    parameters of an ALC/LCT session that the receiver needs to\n   know are:\n   *
    \ The source IP address;\n   *  The number of channels in the session;\n   *  The
    destination IP address and port number for each channel in the\n      session;\n
    \  *  The Transport Session Identifier (TSI) of the session;\n   *  An indication
    that the session is a FLUTE session.  The need to\n      demultiplex objects upon
    reception is implicit in any use of\n      FLUTE, and this fulfills the ALC requirement
    of an indication of\n      whether or not a session carries packets for more than
    one object\n      (all FLUTE sessions carry packets for more than one object).\n
    \  Optionally, the following parameters MAY be associated with the\n   session
    (note that the list is not exhaustive):\n   *  The start time and end time of
    the session;\n   *  FEC Encoding ID and FEC Instance ID when the default FEC Encoding\n
    \     ID 0 is not used for the delivery of the FDT;\n   *  Content encoding format
    if optional content encoding of the FDT\n      Instance is used, e.g., compression;\n
    \  *  Some information that tells receiver, in the first place, that the\n      session
    contains files that are of interest;\n   *  Definition and configuration of a
    congestion control mechanism for\n      the session;\n   *  Security parameters
    relevant for the session;\n   *  FLUTE version number.\n   It is envisioned that
    these parameters would be described according\n   to some session description
    syntax (such as SDP [RFC4566] or XML\n   based) and held in a file that would
    be acquired by the receiver\n   before the FLUTE session begins by means of some
    transport protocol\n   (such as the Session Announcement Protocol (SAP) [RFC2974],
    email,\n   HTTP [RFC2616], SIP [RFC3261], manual preconfiguration, etc.).\n   However,
    the way in which the receiver discovers the above-mentioned\n   parameters is
    out of scope of this document, as it is for LCT and\n   ALC.  In particular, this
    specification does not mandate or exclude\n   any mechanism.\n"
  title: 6.  Describing File Delivery Sessions
- contents:
  - '7.  Security Considerations

    '
  - contents:
    - "7.1.  Problem Statement\n   A content delivery system is potentially subject
      to attacks.  Attacks\n   may target:\n   *  the network (to compromise the routing
      infrastructure, e.g., by\n      creating congestion),\n   *  the Content Delivery
      Protocol (CDP) (e.g., to compromise the\n      normal behavior of FLUTE), or\n
      \  *  the content itself (e.g., to corrupt the files being transmitted).\n   These
      attacks can be launched either:\n   *  against the data flow itself (e.g., by
      sending forged packets),\n   *  against the session control parameters (e.g.,
      by corrupting the\n      session description, the FDT Instances, or the ALC/LCT
      control\n      parameters) that are sent either in-band or out-of-band, or\n
      \  *  against some associated building blocks (e.g., the congestion\n      control
      component).\n   In the following sections, we provide more details on these
      possible\n   attacks and sketch some possible countermeasures.  We provide\n
      \  recommendations in Section 7.5.\n"
    title: 7.1.  Problem Statement
  - contents:
    - "7.2.  Attacks against the Data Flow\n   Let us consider attacks against the
      data flow first.  At the least,\n   the following types of attacks exist:\n
      \  *  attacks that are meant to give access to a confidential file\n      (e.g.,
      in the case of non-free content) and\n   *  attacks that try to corrupt the
      file being transmitted (e.g., to\n      inject malicious code within a file,
      or to prevent a receiver from\n      using a file, which is a kind of denial
      of service (DoS)).\n"
    - contents:
      - "7.2.1.  Access to Confidential Files\n   Access control to the file being
        transmitted is typically provided by\n   means of encryption.  This encryption
        can be done over the whole\n   file, i.e., before applying FEC protection
        (e.g., by the content\n   provider, before submitting the file to FLUTE),
        or can be done on a\n   packet-by-packet basis (e.g., when IPsec/ESP [RFC4303]
        is used; see\n   Section 7.5).  If confidentiality is a concern, it is RECOMMENDED\n
        \  that one of these solutions be used.\n"
      title: 7.2.1.  Access to Confidential Files
    - contents:
      - "7.2.2.  File Corruption\n   Protection against corruptions (e.g., if an attacker
        sends forged\n   packets) is achieved by means of a content integrity verification/\n
        \  sender authentication scheme.  This service can be provided at the\n   file
        level, i.e., before applying content encoding and FEC encoding.\n   In that
        case, a receiver has no way to identify which symbol(s)\n   is(are) corrupted
        if the file is detected as corrupted.  This service\n   can also be provided
        at the packet level, i.e., after applying\n   content encoding and FEC encoding,
        on a packet-by-packet basis.  In\n   this case, after removing all corrupted
        packets, the file may be in\n   some cases recovered from the remaining correct
        packets.\n   Integrity protection applied at the file level has the advantage
        of\n   lower overhead, since only relatively few bits are added to provide\n
        \  the integrity protection compared to the file size.  However, it has\n
        \  the disadvantage that it cannot distinguish between correct packets\n   and
        corrupt packets, and therefore correct packets, which may form\n   the majority
        of packets received, may be unusable.  Integrity\n   protection applied at
        the packet level has the advantage that it can\n   distinguish between correct
        and corrupt packets, at the cost of\n   additional per-packet overhead.\n
        \  Several techniques can provide this source authentication/content\n   integrity
        service:\n   *  At the file level, the file MAY be digitally signed (e.g.,
        by\n      using RSA Probabilistic Signature Scheme Public-Key Cryptography\n
        \     Standards version 1.5 (RSASSA-PKCS1-v1_5) [RFC3447]).  This\n      signature
        enables a receiver to check the file's integrity once\n      the file has
        been fully decoded.  Even if digital signatures are\n      computationally
        expensive, this calculation occurs only once per\n      file, which is usually
        acceptable.\n   *  At the packet level, each packet can be digitally signed\n
        \     [RFC6584].  A major limitation is the high computational and\n      transmission
        overheads that this solution requires.  To avoid this\n      problem, the
        signature may span a set of symbols (instead of a\n      single one) in order
        to amortize the signature calculation, but if\n      a single symbol is missing,
        the integrity of the whole set cannot\n      be checked.\n   *  At the packet
        level, a Group-Keyed Message Authentication Code\n      (MAC) [RFC2104] [RFC6584]
        scheme can be used; an example is using\n      HMAC-SHA-256 with a secret
        key shared by all the group members,\n      senders, and receivers.  This
        technique creates a\n      cryptographically secured digest of a packet that
        is sent along\n      with the packet.  The Group-Keyed MAC scheme does not
        create\n      prohibitive processing load or transmission overhead, but it
        has a\n      major limitation: it only provides a group authentication/\n
        \     integrity service, since all group members share the same secret\n      group
        key, which means that each member can send a forged packet.\n      It is therefore
        restricted to situations where group members are\n      fully trusted (or
        in association with another technique as a\n      pre-check).\n   *  At the
        packet level, Timed Efficient Stream Loss-Tolerant\n      Authentication (TESLA)
        [RFC4082] [RFC5776] is an attractive\n      solution that is robust to losses,
        provides a true authentication/\n      integrity service, and does not create
        any prohibitive processing\n      load or transmission overhead.  However,
        checking a packet\n      requires a small delay (a second or more) after its
        reception.\n   *  At the packet level, IPsec/ESP [RFC4303] can be used to
        check the\n      integrity and authenticate the sender of all the packets
        being\n      exchanged in a session (see Section 7.5).\n   Techniques relying
        on public key cryptography (digital signatures and\n   TESLA during the bootstrap
        process, when used) require that public\n   keys be securely associated to
        the entities.  This can be achieved by\n   a Public Key Infrastructure (PKI),
        or by a Pretty Good Privacy (PGP)\n   Web of Trust, or by pre-distributing
        the public keys of each group\n   member.\n   Techniques relying on symmetric
        key cryptography (Group-Keyed MAC)\n   require that a secret key be shared
        by all group members.  This can\n   be achieved by means of a group key management
        protocol, or simply by\n   pre-distributing the secret key (but this manual
        solution has many\n   limitations).\n   It is up to the developer and deployer,
        who know the security\n   requirements and features of the target application
        area, to define\n   which solution is the most appropriate.  Nonetheless,
        in case there\n   is any concern of the threat of file corruption, it is RECOMMENDED\n
        \  that at least one of these techniques be used.\n"
      title: 7.2.2.  File Corruption
    title: 7.2.  Attacks against the Data Flow
  - contents:
    - "7.3.  Attacks against the Session Control Parameters and Associated\n      Building
      Blocks\n   Let us now consider attacks against the session control parameters\n
      \  and the associated building blocks.  The attacker has at least the\n   following
      opportunities to launch an attack:\n   *  the attack can target the session
      description,\n   *  the attack can target the FDT Instances,\n   *  the attack
      can target the ALC/LCT parameters, carried within the\n      LCT header, or\n
      \  *  the attack can target the FLUTE associated building blocks (e.g.,\n      the
      multiple-rate congestion control protocol).\n   The consequences of these attacks
      are potentially serious, since they\n   might compromise the behavior of the
      content delivery system itself.\n"
    - contents:
      - "7.3.1.  Attacks against the Session Description\n   A FLUTE receiver may
        potentially obtain an incorrect session\n   description for the session.  The
        consequence of this is that\n   legitimate receivers with the wrong session
        description are unable to\n   correctly receive the session content, or that
        receivers\n   inadvertently try to receive at a much higher rate than they
        are\n   capable of, thereby possibly disrupting other traffic in the network.\n
        \  To avoid these problems, it is RECOMMENDED that measures be taken to\n
        \  prevent receivers from accepting incorrect session descriptions.  One\n
        \  such measure is source authentication to ensure that receivers only\n   accept
        legitimate session descriptions from authorized senders.  How\n   these measures
        are achieved is outside the scope of this document,\n   since this session
        description is usually carried out-of-band.\n"
      title: 7.3.1.  Attacks against the Session Description
    - contents:
      - "7.3.2.  Attacks against the FDT Instances\n   Corrupting the FDT Instances
        is one way to create a DoS attack.  For\n   example, the attacker changes
        the MD5 sum associated to a file.  This\n   possibly leads a receiver to reject
        the files received, no matter\n   whether the files have been correctly received
        or not.\n   Corrupting the FDT Instances is also a way to make the reception\n
        \  process more costly than it should be.  This can be achieved by\n   changing
        the FEC Object Transmission Information when the FEC Object\n   Transmission
        Information is included in the FDT Instance.  For\n   example, an attacker
        may corrupt the FDT Instance in such a way that\n   Reed-Solomon over GF(2^^16)
        would be used instead of GF(2^^8) with\n   FEC Encoding ID 2.  This may significantly
        increase the processing\n   load while compromising FEC decoding.\n   More
        generally, because FDT Instance data is structured using the XML\n   language
        by means of an XML media type, many of the security\n   considerations described
        in [RFC3023] and [RFC3470] also apply to\n   such data.\n   It is therefore
        RECOMMENDED that measures be taken to guarantee the\n   integrity and to check
        the sender's identity of the FDT Instances.\n   To that purpose, one of the
        countermeasures mentioned above\n   (Section 7.2.2) SHOULD be used.  These
        measures will either be\n   applied on a packet level or globally over the
        whole FDT Instance\n   object.  Additionally, XML digital signatures [RFC3275]
        are a way to\n   protect the FDT Instance by digitally signing it.  When there
        is no\n   packet-level integrity verification scheme, it is RECOMMENDED to
        rely\n   on XML digital signatures of the FDT Instances.\n"
      title: 7.3.2.  Attacks against the FDT Instances
    - contents:
      - "7.3.3.  Attacks against the ALC/LCT Parameters\n   By corrupting the ALC/LCT
        header (or header extensions), one can\n   execute attacks on the underlying
        ALC/LCT implementation.  For\n   example, sending forged ALC packets with
        the Close Session flag (A)\n   set to one can lead the receiver to prematurely
        close the session.\n   Similarly, sending forged ALC packets with the Close
        Object flag (B)\n   set to one can lead the receiver to prematurely give up
        the reception\n   of an object.\n   It is therefore RECOMMENDED that measures
        be taken to guarantee the\n   integrity and to check the sender's identity
        of the ALC packets\n   received.  To that purpose, one of the countermeasures
        mentioned\n   above (Section 7.2.2) SHOULD be used.\n"
      title: 7.3.3.  Attacks against the ALC/LCT Parameters
    - contents:
      - "7.3.4.  Attacks against the Associated Building Blocks\n   Let us first focus
        on the congestion control building block, which\n   may be used in the ALC
        session.  A receiver with an incorrect or\n   corrupted implementation of
        the multiple-rate congestion control\n   building block may affect the health
        of the network in the path\n   between the sender and the receiver.  That
        may also affect the\n   reception rates of other receivers who joined the
        session.\n   When the congestion control building block is applied with FLUTE,
        it\n   is RECOMMENDED that receivers be required to identify themselves as\n
        \  legitimate before they receive the session description needed to join\n
        \  the session.  How receivers identify themselves as legitimate is\n   outside
        the scope of this document.  If authenticating a receiver\n   does not prevent
        this receiver from launching an attack, this\n   authentication will enable
        the network operator to identify him and\n   to take countermeasures.\n   When
        the congestion control building block is applied with FLUTE, it\n   is also
        RECOMMENDED that a packet-level authentication scheme be\n   used, as explained
        in Section 7.2.2.  Some of them, like TESLA, only\n   provide a delayed authentication
        service, whereas congestion control\n   requires a rapid reaction.  It is
        therefore RECOMMENDED [RFC5775]\n   that a receiver using TESLA quickly reduce
        its subscription level\n   when the receiver believes that congestion did
        occur, even if the\n   packet has not yet been authenticated.  Therefore,
        TESLA will not\n   prevent DoS attacks where an attacker makes the receiver
        believe that\n   congestion occurred.  This is an issue for the receiver,
        but this\n   will not compromise the network.  Other authentication methods
        that\n   do not feature this delayed authentication could be preferred, or
        a\n   Group-Keyed MAC scheme could be used in parallel with TESLA to\n   prevent
        attacks launched from outside of the group.\n"
      title: 7.3.4.  Attacks against the Associated Building Blocks
    title: 7.3.  Attacks against the Session Control Parameters and Associated
  - contents:
    - "7.4.  Other Security Considerations\n   The security considerations that apply
      to, and are described in, ALC\n   [RFC5775], LCT [RFC5651], and FEC [RFC5052]
      also apply to FLUTE, as\n   FLUTE builds on those specifications.  In addition,
      any security\n   considerations that apply to any congestion control building
      block\n   used in conjunction with FLUTE also apply to FLUTE.\n   Even if FLUTE
      defines a purely unidirectional delivery service,\n   without any feedback information
      that would be sent to the sender,\n   security considerations MAY require bidirectional
      communications.\n   For instance, if an automated key management scheme is used,
      a\n   bidirectional point-to-point channel is often needed to establish a\n
      \  shared secret between each receiver and the sender.  Each shared\n   secret
      can then be used to distribute additional keys to the\n   associated receiver
      (e.g., traffic encryption keys).\n   As an example, [MBMSsecurity] details a
      complete security framework\n   for the Third Generation Partnership Project
      (3GPP) Multimedia\n   Broadcast/Multicast Service (MBMS) that relies on FLUTE/ALC
      for\n   Download Sessions.  It relies on bidirectional point-to-point\n   communications
      for User Equipment authentication and for key\n   distribution, using the Multimedia
      Internet KEYing (MIKEY) protocol\n   [RFC3830].  Because this security framework
      is specific to this use\n   case, it cannot be reused as such for generic security\n
      \  recommendations in this specification.  Instead, the following\n   section
      introduces minimum security recommendations.\n"
    title: 7.4.  Other Security Considerations
  - contents:
    - "7.5.  Minimum Security Recommendations\n   We now introduce a mandatory-to-implement,
      but not necessarily to\n   use, security configuration, in the sense of [RFC3365].
      \ Since FLUTE\n   relies on ALC/LCT, it inherits the \"baseline secure ALC operation\"
      of\n   [RFC5775].  More precisely, security is achieved by means of IPsec/\n
      \  ESP in transport mode.  [RFC4303] explains that ESP can be used to\n   potentially
      provide confidentiality, data origin authentication,\n   content integrity,
      anti-replay, and (limited) traffic flow\n   confidentiality.  [RFC5775] specifies
      that the data origin\n   authentication, content integrity, and anti-replay
      services SHALL be\n   supported, and that the confidentiality service is RECOMMENDED.
      \ If a\n   short-lived session MAY rely on manual keying, it is also RECOMMENDED\n
      \  that an automated key management scheme be used, especially in the\n   case
      of long-lived sessions.\n   Therefore, the RECOMMENDED solution for FLUTE provides
      per-packet\n   security, with data origin authentication, integrity verification,\n
      \  and anti-replay.  This is sufficient to prevent most of the in-band\n   attacks
      listed above.  If confidentiality is required, a per-packet\n   encryption SHOULD
      also be used.\n"
    title: 7.5.  Minimum Security Recommendations
  title: 7.  Security Considerations
- contents:
  - "8.  IANA Considerations\n   This specification contains five separate items upon
    which IANA has\n   taken action:\n   1.  Registration of the FDT Instance XML
    Namespace.\n   2.  Registration of the FDT Instance XML Schema.\n   3.  Registration
    of the application/fdt+xml Media Type.\n   4.  Registration of the Content Encoding
    Algorithms.\n   5.  Registration of two LCT Header Extension Types (EXT_FDT and\n
    \      EXT_CENC).\n"
  - contents:
    - "8.1.  Registration of the FDT Instance XML Namespace\n   IANA has registered
      the following new XML Namespace in the IETF XML\n   \"ns\" registry [RFC3688]
      at\n   http://www.iana.org/assignments/xml-registry/ns.html.\n   URI: urn:ietf:params:xml:ns:fdt\n
      \  Registrant Contact: Toni Paila (toni.paila@gmail.com)\n   XML: N/A\n"
    title: 8.1.  Registration of the FDT Instance XML Namespace
  - contents:
    - "8.2.  Registration of the FDT Instance XML Schema\n   IANA has registered the
      following in the IETF XML \"schema\" registry\n   [RFC3688] at\n   http://www.iana.org/assignments/xml-registry/schema.html.\n
      \  URI: urn:ietf:params:xml:schema:fdt\n   Registrant Contact: Toni Paila (toni.paila@gmail.com)\n
      \  XML: The XML Schema specified in Section 3.4.2\n"
    title: 8.2.  Registration of the FDT Instance XML Schema
  - contents:
    - "8.3.  Registration of the application/fdt+xml Media Type\n   IANA has registered
      the following in the \"Application Media Types\"\n   registry at http://www.iana.org/assignments/media-types/application/.\n
      \  Type name: application\n   Subtype name: fdt+xml\n   Required parameters:
      none\n   Optional parameters: charset=\"utf-8\"\n   Encoding considerations:
      binary (the FLUTE file delivery protocol\n   does not impose any restriction
      on the objects it carries and in\n   particular on the FDT Instance itself)\n
      \  Restrictions on usage: none\n   Security considerations: fdt+xml data is
      passive and does not\n   generally represent a unique or new security threat.
      \ However, there\n   is some risk in sharing any kind of data, in that unintentional\n
      \  information may be exposed, and that risk applies to fdt+xml data as\n   well.\n
      \  Interoperability considerations: None\n   Published specification: [RFC6726],
      especially noting Section 3.4.2.\n   The specified FDT Instance functions as
      an actual media format of use\n   to the general Internet community, and thus
      media type registration\n   under the Standards Tree is appropriate to maximize
      interoperability.\n   Applications that use this media type: file and object
      delivery\n   applications and protocols (e.g., FLUTE).\n   Additional information:\n
      \      Magic number(s): none\n       File extension(s): \".fdt\" (e.g., if there
      is a need to store an\n                          FDT Instance as a file)\n       Macintosh
      File Type Code(s): none\n   Person and email address to contact for further
      information:\n   Toni Paila (toni.paila@gmail.com)\n   Intended usage: Common\n
      \  Author/Change controller: IETF\n"
    title: 8.3.  Registration of the application/fdt+xml Media Type
  - contents:
    - "8.4.  Creation of the FLUTE Content Encoding Algorithms Registry\n   IANA has
      created a new registry, \"FLUTE Content Encoding Algorithms\",\n   with a reference
      to [RFC6726]; see Section 3.4.3.  The registry\n   entries consist of a numeric
      value from 0 to 255, inclusive, and may\n   be registered using the Specification
      Required policy [RFC5226].\n   The initial contents of the registry are as follows,
      with unspecified\n   values available for new registrations:\n                  +-------+----------------+-----------+\n
      \                 | Value | Algorithm Name | Reference |\n                  +-------+----------------+-----------+\n
      \                 |   0   |      null      | [RFC6726] |\n                  |
      \  1   |      ZLIB      | [RFC1950] |\n                  |   2   |     DEFLATE
      \   | [RFC1951] |\n                  |   3   |      GZIP      | [RFC1952] |\n
      \                 +-------+----------------+-----------+\n"
    title: 8.4.  Creation of the FLUTE Content Encoding Algorithms Registry
  - contents:
    - "8.5.  Registration of LCT Header Extension Types\n   IANA has registered two
      new entries in the \"Layered Coding Transport\n   (LCT) Header Extension Types\"
      registry [RFC5651], as follows:\n              +--------+----------+-------------------------+\n
      \             | Number |   Name   |        Reference        |\n              +--------+----------+-------------------------+\n
      \             |   192  |  EXT_FDT | [RFC6726] Section 3.4.1 |\n              |
      \  193  | EXT_CENC | [RFC6726] Section 3.4.3 |\n              +--------+----------+-------------------------+\n"
    title: 8.5.  Registration of LCT Header Extension Types
  title: 8.  IANA Considerations
- contents:
  - "9.  Acknowledgments\n   The following persons have contributed to this specification:
    Brian\n   Adamson, Mark Handley, Esa Jalonen, Roger Kermode, Juha-Pekka Luoma,\n
    \  Topi Pohjolainen, Lorenzo Vicisano, Mark Watson, David Harrington,\n   Ben
    Campbell, Stephen Farrell, Robert Sparks, Ronald Bonica, Francis\n   Dupont, Peter
    Saint-Andre, Don Gillies, and Barry Leiba.  The authors\n   would like to thank
    all the contributors for their valuable work in\n   reviewing and providing feedback
    regarding this specification.\n"
  title: 9.  Acknowledgments
- contents:
  - "10.  Contributors\n   Jani Peltotalo\n   Tampere University of Technology\n   P.O.
    Box 553 (Korkeakoulunkatu 1)\n   Tampere FIN-33101\n   Finland\n   EMail: jani.peltotalo@tut.fi\n
    \  Sami Peltotalo\n   Tampere University of Technology\n   P.O. Box 553 (Korkeakoulunkatu
    1)\n   Tampere FIN-33101\n   Finland\n   EMail: sami.peltotalo@tut.fi\n   Magnus
    Westerlund\n   Ericsson Research\n   Ericsson AB\n   SE-164 80 Stockholm\n   Sweden\n
    \  EMail: magnus.westerlund@ericsson.com\n   Thorsten Lohmar\n   Ericsson Research
    (EDD)\n   Ericsson Allee 1\n   52134 Herzogenrath\n   Germany\n   EMail: thorsten.lohmar@ericsson.com\n"
  title: 10.  Contributors
- contents:
  - '11.  Change Log

    '
  - contents:
    - "11.1.  RFC 3926 to This Document\n   Incremented the FLUTE protocol version
      from 1 to 2, due to concerns\n   about backwards compatibility.  For instance,
      the LCT header changed\n   between RFC 3451 and [RFC5651].  In RFC 3451, the
      T and R fields of\n   the LCT header indicate the presence of Sender Current
      Time and\n   Expected Residual Time, respectively.  In [RFC5651], these fields\n
      \  MUST be set to zero and MUST be ignored by receivers (instead, the\n   EXT_TIME
      Header Extensions can convey this information if needed).\n   Thus, [RFC5651]
      is not backwards compatible with RFC 3451, even\n   though both use LCT version
      1.  FLUTE version 1 as specified in\n   [RFC3926] MUST use RFC 3451.  FLUTE
      version 2 as specified in this\n   document MUST use [RFC5651].  Therefore,
      an implementation that\n   relies on [RFC3926] and RFC 3451 will not be backwards
      compatible\n   with FLUTE as specified in this document.\n   Updated dependencies
      to other RFCs to revised versions; e.g., changed\n   ALC reference from RFC
      3450 to [RFC5775], changed LCT reference from\n   RFC 3451 to [RFC5651], etc.\n
      \  Added clarification for the use of FLUTE for unicast communications\n   in
      Section 1.1.4.\n   Clarified how to reliably deliver the FDT in Section 3.3
      and the\n   possibility of using out-of-band delivery of FDT information.\n
      \  Clarified how to address FDT Instance expiration time wraparound with\n   the
      notion of the NTPv4 \"epoch\" in Section 3.3.\n   Clarified what should be considered
      erroneous situations in\n   Section 3.4.1 (definition of FDT Instance ID).  In
      particular, a\n   receiver MUST be ready to handle FDT Instance ID wraparounds
      and\n   missing FDT Instances.\n   Updated Section 7.5 to define IPsec/ESP as
      a mandatory-to-implement\n   security solution.\n   Removed the 'Statement of
      Intent' from Section 1.  The statement of\n   intent was meant to clarify the
      \"Experimental\" status of [RFC3926].\n   It does not apply to this document.\n
      \  Added clarification of \"XML-DSIG\" near the end of Section 3.\n   In Section
      3.2, replaced \"complete FDT\" with text that is more\n   descriptive.\n   Clarified
      Figure 1 with regard to \"Encoding Symbol(s) for FDT\n   Instance\".\n   Clarified
      the text regarding FDT Instance ID wraparound at the end of\n   Section 3.4.1.\n
      \  Clarified \"complete FDT\" in Section 3.4.2.\n   Added semantics for the
      case where two TOIs refer to the same\n   Content-Location.  It is now in line
      with the way that 3GPP and\n   Digital Video Broadcasting (DVB) standards interpret
      this case.\n   In Section 3.4.2, the XML Schema of the FDT Instance was modified
      per\n   advice from various sources.  For example, extension by element was\n
      \  missing but is now supported.  Also, the namespace definition was\n   changed
      to URN format.\n   Clarified FDT-schema extensibility at the end of Section
      3.4.2.\n   The CENC value allocation has been added at the end of Section 3.4.3.\n
      \  Section 5 has been modified so that EXT_FTI and the FEC issues were\n   replaced
      by a reference to the ALC specification [RFC5775].\n   Added a clarifying paragraph
      on the use of the Codepoint field at the\n   end of Section 5.\n   Reworked
      Section 8 -- IANA Considerations; it now contains six IANA\n   registration
      requests:\n   *  Registration of the FDT Instance XML Namespace.\n   *  Registration
      of the FDT Instance XML Schema.\n   *  Registration of the application/fdt+xml
      Media Type.\n   *  Registration of the Content Encoding Algorithms.\n   *  Registration
      of two LCT Header Extension Types and corresponding\n      values in the LCT
      Header Extension Types Registry (192 for EXT_FDT\n      and 193 for EXT_CENC).\n
      \  Added Section 10 -- Contributors.\n   Revised lists of both Normative and
      Informative references.\n   Added a clarification that the receiver should ignore
      reserved bits\n   of Header Extension type 193 upon reception.\n   Elaborated
      on what kinds of networks cannot support FLUTE congestion\n   control (Section
      1.1.4).\n   In Section 3.2, changed \"several\" (meaning 3-n vs. \"couple\"
      = 2) to\n   \"multiple\" (meaning 2-n).\n   Moved the requirement in Section
      3.3 (to send FDT more reliably than\n   files) to a bulleted RECOMMENDED requirement,
      making check-off easier\n   for testers.\n   In Section 3.3, sharpened the definition
      that future FDT file\n   instances can \"augment\" (meaning enhance) rather
      than \"complement\"\n   (sometimes meaning negate, which is not allowed) the
      file parameters.\n   Elaborated in Sections 3.3 and 4 that FEC Encoding ID =
      0 is Compact\n   No-Code FEC, so that the reader doesn't have to search other
      RFCs to\n   understand these protocol constants used by FLUTE.\n   Required
      in Section 3.3 that FLUTE receivers SHALL NOT attempt to\n   decode FDTs if
      they do not understand the FEC Encoding ID.\n   Removed the restriction of Section
      3.3, in bullet #4, that TOI = 0\n   for the FDT, to be consistent with Appendix
      A step 6 and elsewhere.\n   An FDT is signaled by an FDT Instance ID, NOT only
      by TOI = 0.\n   Standardized on the term \"expiration time\", and avoided using
      the\n   redundant and possibly confusing term \"expiry time\".\n   To interwork
      with experimental FLUTE, stipulated in Section 3.1 that\n   only 1 instantiation
      of all 3 protocols -- FLUTE, ALC, and LCT -- can\n   be associated with a session
      (source IP Address, TSI), and mentioned\n   in Section 6 that one may (optionally)
      derive the FLUTE version from\n   the file delivery session description.\n   Used
      a software writing tool to lower the reading grade level and\n   simplify Section
      3.1.\n"
    title: 11.1.  RFC 3926 to This Document
  title: 11.  Change Log
- contents:
  - '12.  References

    '
  - contents:
    - "12.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March
      1997.\n   [RFC5775]  Luby, M., Watson, M., and L. Vicisano, \"Asynchronous\n
      \             Layered Coding (ALC) Protocol Instantiation\", RFC 5775,\n              April
      2010.\n   [RFC5651]  Luby, M., Watson, M., and L. Vicisano, \"Layered Coding\n
      \             Transport (LCT) Building Block\", RFC 5651, October 2009.\n   [RFC5052]
      \ Watson, M., Luby, M., and L. Vicisano, \"Forward Error\n              Correction
      (FEC) Building Block\", RFC 5052, August 2007.\n   [RFC5445]  Watson, M., \"Basic
      Forward Error Correction (FEC)\n              Schemes\", RFC 5445, March 2009.\n
      \  [RFC5905]  Mills, D., Martin, J., Ed., Burbank, J., and W. Kasch,\n              \"Network
      Time Protocol Version 4: Protocol and Algorithms\n              Specification\",
      RFC 5905, June 2010.\n   [RFC2616]  Fielding, R., Gettys, J., Mogul, J., Frystyk,
      H.,\n              Masinter, L., Leach, P., and T. Berners-Lee, \"Hypertext\n
      \             Transfer Protocol -- HTTP/1.1\", RFC 2616, June 1999.\n   [XML-Schema-Part-1]\n
      \             Thompson, H., Beech, D., Maloney, M., and N. Mendelsohn,\n              \"XML
      Schema Part 1: Structures Second Edition\",\n              W3C Recommendation,
      October 2004,\n              <http://www.w3.org/TR/xmlschema-1/>.\n   [XML-Schema-Part-2]\n
      \             Biron, P. and A. Malhotra, \"XML Schema Part 2: Datatypes\n              Second
      Edition\", W3C Recommendation, October 2004,\n              <http://www.w3.org/TR/xmlschema-2/>.\n
      \  [RFC3023]  Murata, M., St. Laurent, S., and D. Kohn, \"XML Media\n              Types\",
      RFC 3023, January 2001.\n   [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines
      for Writing an\n              IANA Considerations Section in RFCs\", RFC 5226,
      May 2008.\n   [RFC3738]  Luby, M. and V. Goyal, \"Wave and Equation Based Rate\n
      \             Control (WEBRC) Building Block\", RFC 3738, April 2004.\n              Note:
      The RFC 3738 reference is to a target document of a\n              lower maturity
      level.  Some caution should be used, since\n              it may be less stable
      than the present document.\n   [RFC4303]  Kent, S., \"IP Encapsulating Security
      Payload (ESP)\",\n              RFC 4303, December 2005.\n"
    title: 12.1.  Normative References
  - contents:
    - "12.2.  Informative References\n   [RFC3926]  Paila, T., Luby, M., Lehtonen,
      R., Roca, V., and R. Walsh,\n              \"FLUTE - File Delivery over Unidirectional
      Transport\",\n              RFC 3926, October 2004.\n   [RFC2357]  Mankin, A.,
      Romanow, A., Bradner, S., and V. Paxson, \"IETF\n              Criteria for
      Evaluating Reliable Multicast Transport and\n              Application Protocols\",
      RFC 2357, June 1998.\n   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter,
      \"Uniform\n              Resource Identifier (URI): Generic Syntax\", STD 66,\n
      \             RFC 3986, January 2005.\n   [RFC3470]  Hollenbeck, S., Rose, M.,
      and L. Masinter, \"Guidelines for\n              the Use of Extensible Markup
      Language (XML)\n              within IETF Protocols\", BCP 70, RFC 3470, January
      2003.\n   [RFC2045]  Freed, N. and N. Borenstein, \"Multipurpose Internet Mail\n
      \             Extensions (MIME) Part One: Format of Internet Message\n              Bodies\",
      RFC 2045, November 1996.\n   [RFC1950]  Deutsch, P. and J-L. Gailly, \"ZLIB
      Compressed Data Format\n              Specification version 3.3\", RFC 1950,
      May 1996.\n   [RFC1951]  Deutsch, P., \"DEFLATE Compressed Data Format Specification\n
      \             version 1.3\", RFC 1951, May 1996.\n   [RFC1952]  Deutsch, P.,
      \"GZIP file format specification version 4.3\",\n              RFC 1952, May
      1996.\n   [IANAheaderfields]\n              IANA, \"Message Header Fields\",\n
      \             <http://www.iana.org/protocols>.\n   [RFC2974]  Handley, M., Perkins,
      C., and E. Whelan, \"Session\n              Announcement Protocol\", RFC 2974,
      October 2000.\n   [RFC4566]  Handley, M., Jacobson, V., and C. Perkins, \"SDP:
      Session\n              Description Protocol\", RFC 4566, July 2006.\n   [RFC1112]
      \ Deering, S., \"Host extensions for IP multicasting\", STD 5,\n              RFC
      1112, August 1989.\n   [PAPER.SSM]\n              Holbrook, H., \"A Channel
      Model for Multicast\", Ph.D.\n              Dissertation, Stanford University,
      Department of Computer\n              Science, Stanford, California, August
      2001.\n   [RFC3365]  Schiller, J., \"Strong Security Requirements for Internet\n
      \             Engineering Task Force Standard Protocols\", BCP 61,\n              RFC
      3365, August 2002.\n   [RFC5751]  Ramsdell, B. and S. Turner, \"Secure/Multipurpose
      Internet\n              Mail Extensions (S/MIME) Version 3.2 Message\n              Specification\",
      RFC 5751, January 2010.\n   [RFC3275]  Eastlake 3rd, D., Reagle, J., and D.
      Solo, \"(Extensible\n              Markup Language) XML-Signature Syntax and
      Processing\",\n              RFC 3275, March 2002.\n   [RFC3261]  Rosenberg,
      J., Schulzrinne, H., Camarillo, G., Johnston,\n              A., Peterson, J.,
      Sparks, R., Handley, M., and E.\n              Schooler, \"SIP: Session Initiation
      Protocol\", RFC 3261,\n              June 2002.\n   [RFC3688]  Mealling, M.,
      \"The IETF XML Registry\", BCP 81, RFC 3688,\n              January 2004.\n
      \  [RFC3447]  Jonsson, J. and B. Kaliski, \"Public-Key Cryptography\n              Standards
      (PKCS) #1: RSA Cryptography Specifications\n              Version 2.1\", RFC
      3447, February 2003.\n   [RFC2104]  Krawczyk, H., Bellare, M., and R. Canetti,
      \"HMAC: Keyed-\n              Hashing for Message Authentication\", RFC 2104,\n
      \             February 1997.\n   [RFC4082]  Perrig, A., Song, D., Canetti, R.,
      Tygar, J., and B.\n              Briscoe, \"Timed Efficient Stream Loss-Tolerant\n
      \             Authentication (TESLA): Multicast Source Authentication\n              Transform
      Introduction\", RFC 4082, June 2005.\n   [RFC5776]  Roca, V., Francillon, A.,
      and S. Faurite, \"Use of Timed\n              Efficient Stream Loss-Tolerant
      Authentication (TESLA) in\n              the Asynchronous Layered Coding (ALC)
      and NACK-Oriented\n              Reliable Multicast (NORM) Protocols\", RFC
      5776,\n              April 2010.\n   [RFC6584]  Roca, V., \"Simple Authentication
      Schemes for the\n              Asynchronous Layered Coding (ALC) and NACK-Oriented\n
      \             Reliable Multicast (NORM) Protocols\", RFC 6584,\n              April
      2012.\n   [RFC3830]  Arkko, J., Carrara, E., Lindholm, F., Naslund, M., and
      K.\n              Norrman, \"MIKEY: Multimedia Internet KEYing\", RFC 3830,\n
      \             August 2004.\n   [MBMSsecurity]\n              3GPP, \"3rd Generation
      Partnership Project; Technical\n              Specification Group Services and
      System Aspects; 3G\n              Security; Security of Multimedia Broadcast/Multicast\n
      \             Service (MBMS) (Release 10)\", December 2010,\n              <http://www.3gpp.org/ftp/Specs/archive/33_series/33.246/>.\n"
    title: 12.2.  Informative References
  title: 12.  References
- contents:
  - "Appendix A.  Receiver Operation (Informative)\n   This section gives an example
    of how the receiver of the file\n   delivery session may operate.  Instead of
    a detailed state-by-state\n   specification, the following should be interpreted
    as a rough\n   sequence of an envisioned file delivery receiver.\n   1.  The receiver
    obtains the description of the file delivery session\n       identified by the
    (source IP address, Transport Session\n       Identifier) pair.  The receiver
    also obtains the destination IP\n       addresses and respective ports associated
    with the file delivery\n       session.\n   2.  The receiver joins the channels
    in order to receive packets\n       associated with the file delivery session.
    \ The receiver may\n       schedule this join operation utilizing the timing information\n
    \      contained in a possible description of the file delivery session.\n   3.
    \ The receiver receives ALC/LCT packets associated with the file\n       delivery
    session.  The receiver checks that the packets match the\n       declared Transport
    Session Identifier.  If not, the packets are\n       silently discarded.\n   4.
    \ While receiving, the receiver demultiplexes packets based on\n       their TOI
    and stores the relevant packet information in an\n       appropriate area for
    recovery of the corresponding file.\n       Multiple files can be reconstructed
    concurrently.\n   5.  The receiver recovers an object.  An object can be recovered
    when\n       an appropriate set of packets containing Encoding Symbols for the\n
    \      transmission object has been received.  An appropriate set of\n       packets
    is dependent on the properties of the FEC Encoding ID and\n       FEC Instance
    ID, and on other information contained in the FEC\n       Object Transmission
    Information.\n   6.  Objects with TOI = 0 are reserved for FDT Instances.  All
    FDT\n       Instances are signaled by including an EXT_FDT Header Extension\n
    \      in the LCT header.  The EXT_FDT header contains an FDT Instance\n       ID
    (i.e., an FDT version number).  If the object has an FDT\n       Instance ID 'N',
    the receiver parses the payload of the instance\n       'N' of the FDT and updates
    its FDT database accordingly.\n   7.  If the object recovered is not an FDT Instance
    but a file, the\n       receiver looks up its FDT database to get the properties\n
    \      described in the database, and assigns the file the given\n       properties.
    \ The receiver also checks that the received content\n       length matches with
    the description in the database.  Optionally,\n       if an MD5 checksum has been
    used, the receiver checks that the\n       calculated MD5 matches the description
    in the FDT database.\n   8.  The actions the receiver takes with imperfectly received
    files\n       (missing data, mismatching content integrity digest, etc.) are\n
    \      outside the scope of this specification.  When a file is\n       recovered
    before the associated file description entry is\n       available, a possible
    behavior is to wait until an FDT Instance\n       is received that includes the
    missing properties.\n   9.  If the file delivery session end time has not been
    reached, go\n       back to step 3.  Otherwise, end.\n"
  title: Appendix A.  Receiver Operation (Informative)
- contents:
  - "Appendix B.  Example of FDT Instance (Informative)\n   <?xml version=\"1.0\"
    encoding=\"UTF-8\"?>\n   <FDT-Instance xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n
    \    xsi:schemaLocation=\"urn:ietf:params:xml:ns:fdt\n                         ietf-flute-fdt.xsd\"\n
    \    Expires=\"2890842807\">\n     <File\n       Content-Location=\"http://www.example.com/menu/tracklist.html\"\n
    \      TOI=\"1\"\n       Content-Type=\"text/html\"/>\n     <File\n       Content-Location=\"http://www.example.com/tracks/track1.mp3\"\n
    \      TOI=\"2\"\n       Content-Length=\"6100\"\n       Content-Type=\"audio/mp3\"\n
    \      Content-Encoding=\"gzip\"\n       Content-MD5=\"+VP5IrWploFkZWc11iLDdA==\"\n
    \      Some-Private-Extension-Tag=\"abc123\"/>\n   </FDT-Instance>\n"
  title: Appendix B.  Example of FDT Instance (Informative)
- contents:
  - "Authors' Addresses\n   Toni Paila\n   Nokia\n   Itamerenkatu 11-13\n   Helsinki
    \ 00180\n   Finland\n   EMail: toni.paila@gmail.com\n   Rod Walsh\n   Nokia/Tampere
    University of Technology\n   P.O. Box 553 (Korkeakoulunkatu 1)\n   Tampere  FI-33101\n
    \  Finland\n   EMail: roderick.walsh@tut.fi\n   Michael Luby\n   Qualcomm Technologies,
    Inc.\n   2030 Addison Street, Suite 420\n   Berkeley, CA  94704\n   USA\n   EMail:
    luby@qti.qualcomm.com\n   Vincent Roca\n   INRIA\n   655, av. de l'Europe\n   Inovallee;
    Montbonnot\n   ST ISMIER cedex  38334\n   France\n   EMail: vincent.roca@inria.fr\n
    \  Rami Lehtonen\n   TeliaSonera\n   Hatanpaankatu 1\n   Tampere  FIN-33100\n
    \  Finland\n   EMail: rami.lehtonen@teliasonera.com\n"
  title: Authors' Addresses
