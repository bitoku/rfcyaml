- contents:
  - "           Transport Layer Security (TLS) Transport Model for\n             the
    Simple Network Management Protocol (SNMP)\n"
  title: __initial_text__
- contents:
  - "Abstract\n   This document describes a Transport Model for the Simple Network\n
    \  Management Protocol (SNMP), that uses either the Transport Layer\n   Security
    protocol or the Datagram Transport Layer Security (DTLS)\n   protocol.  The TLS
    and DTLS protocols provide authentication and\n   privacy services for SNMP applications.
    \ This document describes how\n   the TLS Transport Model (TLSTM) implements the
    needed features of an\n   SNMP Transport Subsystem to make this protection possible
    in an\n   interoperable way.\n   This Transport Model is designed to meet the
    security and operational\n   needs of network administrators.  It supports the
    sending of SNMP\n   messages over TLS/TCP and DTLS/UDP.  The TLS mode can make
    use of\n   TCP's improved support for larger packet sizes and the DTLS mode\n
    \  provides potentially superior operation in environments where a\n   connectionless
    (e.g., UDP) transport is preferred.  Both TLS and DTLS\n   integrate well into
    existing public keying infrastructures.\n   This document also defines a portion
    of the Management Information\n   Base (MIB) for use with network management protocols.
    \ In particular,\n   it defines objects for managing the TLS Transport Model for
    SNMP.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6353.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  4\n     1.1.  Conventions  . . . . . . . . . . . . . . . . . . .
    . . . .  7\n     1.2.  Changes Since RFC 5953 . . . . . . . . . . . . . . . .
    . .  8\n   2.  The Transport Layer Security Protocol  . . . . . . . . . . . .
    \ 8\n   3.  How the TLSTM Fits into the Transport Subsystem  . . . . . . .  8\n
    \    3.1.  Security Capabilities of This Model  . . . . . . . . . . . 11\n       3.1.1.
    \ Threats  . . . . . . . . . . . . . . . . . . . . . . . 11\n       3.1.2.  Message
    Protection . . . . . . . . . . . . . . . . . . 12\n       3.1.3.  (D)TLS Connections
    . . . . . . . . . . . . . . . . . . 13\n     3.2.  Security Parameter Passing
    . . . . . . . . . . . . . . . . 14\n     3.3.  Notifications and Proxy  . . .
    . . . . . . . . . . . . . . 14\n   4.  Elements of the Model  . . . . . . . .
    . . . . . . . . . . . . 15\n     4.1.  X.509 Certificates . . . . . . . . . .
    . . . . . . . . . . 15\n       4.1.1.  Provisioning for the Certificate . . .
    . . . . . . . . 15\n     4.2.  (D)TLS Usage . . . . . . . . . . . . . . . . .
    . . . . . . 17\n     4.3.  SNMP Services  . . . . . . . . . . . . . . . . . .
    . . . . 18\n       4.3.1.  SNMP Services for an Outgoing Message  . . . . . .
    . . 18\n       4.3.2.  SNMP Services for an Incoming Message  . . . . . . . .
    19\n     4.4.  Cached Information and References  . . . . . . . . . . . . 20\n
    \      4.4.1.  TLS Transport Model Cached Information . . . . . . . . 20\n         4.4.1.1.
    \ tmSecurityName . . . . . . . . . . . . . . . . . . 20\n         4.4.1.2.  tmSessionID
    \ . . . . . . . . . . . . . . . . . . . 21\n         4.4.1.3.  Session State  .
    . . . . . . . . . . . . . . . . . 21\n   5.  Elements of Procedure  . . . . .
    . . . . . . . . . . . . . . . 21\n     5.1.  Procedures for an Incoming Message
    . . . . . . . . . . . . 21\n       5.1.1.  DTLS over UDP Processing for Incoming
    Messages . . . . 22\n       5.1.2.  Transport Processing for Incoming SNMP Messages
    \ . . . 23\n     5.2.  Procedures for an Outgoing SNMP Message  . . . . . . .
    . . 25\n     5.3.  Establishing or Accepting a Session  . . . . . . . . . . .
    26\n       5.3.1.  Establishing a Session as a Client . . . . . . . . . . 26\n
    \      5.3.2.  Accepting a Session as a Server  . . . . . . . . . . . 28\n     5.4.
    \ Closing a Session  . . . . . . . . . . . . . . . . . . . . 29\n   6.  MIB Module
    Overview  . . . . . . . . . . . . . . . . . . . . . 30\n     6.1.  Structure of
    the MIB Module  . . . . . . . . . . . . . . . 30\n     6.2.  Textual Conventions
    \ . . . . . . . . . . . . . . . . . . . 30\n     6.3.  Statistical Counters .
    . . . . . . . . . . . . . . . . . . 30\n     6.4.  Configuration Tables . . .
    . . . . . . . . . . . . . . . . 30\n       6.4.1.  Notifications  . . . . . .
    . . . . . . . . . . . . . . 31\n     6.5.  Relationship to Other MIB Modules  .
    . . . . . . . . . . . 31\n       6.5.1.  MIB Modules Required for IMPORTS . .
    . . . . . . . . . 31\n   7.  MIB Module Definition  . . . . . . . . . . . . .
    . . . . . . . 31\n   8.  Operational Considerations . . . . . . . . . . . . .
    . . . . . 54\n     8.1.  Sessions . . . . . . . . . . . . . . . . . . . . . .
    . . . 54\n     8.2.  Notification Receiver Credential Selection . . . . . . .
    . 54\n     8.3.  contextEngineID Discovery  . . . . . . . . . . . . . . . . 55\n
    \    8.4.  Transport Considerations . . . . . . . . . . . . . . . . . 55\n   9.
    \ Security Considerations  . . . . . . . . . . . . . . . . . . . 55\n     9.1.
    \ Certificates, Authentication, and Authorization  . . . . . 55\n     9.2.  (D)TLS
    Security Considerations . . . . . . . . . . . . . . 56\n       9.2.1.  TLS Version
    Requirements . . . . . . . . . . . . . . . 56\n       9.2.2.  Perfect Forward
    Secrecy  . . . . . . . . . . . . . . . 57\n     9.3.  Use with SNMPv1/SNMPv2c
    Messages . . . . . . . . . . . . . 57\n     9.4.  MIB Module Security  . . . .
    . . . . . . . . . . . . . . . 57\n   10. IANA Considerations  . . . . . . . .
    . . . . . . . . . . . . . 59\n   11. Acknowledgements . . . . . . . . . . . .
    . . . . . . . . . . . 59\n   12. References . . . . . . . . . . . . . . . . .
    . . . . . . . . . 60\n     12.1. Normative References . . . . . . . . . . . .
    . . . . . . . 60\n     12.2. Informative References . . . . . . . . . . . . .
    . . . . . 61\n   Appendix A.  Target and Notification Configuration Example .
    . . . 63\n     A.1.  Configuring a Notification Originator  . . . . . . . . .
    . 63\n     A.2.  Configuring TLSTM to Utilize a Simple Derivation of\n           tmSecurityName
    . . . . . . . . . . . . . . . . . . . . . . 64\n     A.3.  Configuring TLSTM to
    Utilize Table-Driven Certificate\n           Mapping  . . . . . . . . . . . .
    . . . . . . . . . . . . . 64\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   It is important to understand the modular SNMPv3 architecture
    as\n   defined by [RFC3411] and enhanced by the Transport Subsystem\n   [RFC5590].
    \ It is also important to understand the terminology of the\n   SNMPv3 architecture
    in order to understand where the Transport Model\n   described in this document
    fits into the architecture and how it\n   interacts with the other architecture
    subsystems.  For a detailed\n   overview of the documents that describe the current
    Internet-Standard\n   Management Framework, please refer to Section 7 of [RFC3410].\n
    \  This document describes a Transport Model that makes use of the\n   Transport
    Layer Security (TLS) [RFC5246] and the Datagram Transport\n   Layer Security (DTLS)
    Protocol [RFC4347], within a Transport\n   Subsystem [RFC5590].  DTLS is the datagram
    variant of the Transport\n   Layer Security (TLS) protocol [RFC5246].  The Transport
    Model in this\n   document is referred to as the Transport Layer Security Transport\n
    \  Model (TLSTM).  TLS and DTLS take advantage of the X.509 public\n   keying
    infrastructure [RFC5280].  While (D)TLS supports multiple\n   authentication mechanisms,
    this document only discusses X.509\n   certificate-based authentication.  Although
    other forms of\n   authentication are possible, they are outside the scope of
    this\n   specification.  This transport model is designed to meet the security\n
    \  and operational needs of network administrators, operating in both\n   environments
    where a connectionless (e.g., UDP) transport is\n   preferred and in environments
    where large quantities of data need to\n   be sent (e.g., over a TCP-based stream).
    \ Both TLS and DTLS integrate\n   well into existing public keying infrastructures.
    \ This document\n   supports sending of SNMP messages over TLS/TCP and DTLS/UDP.\n
    \  This document also defines a portion of the Management Information\n   Base
    (MIB) for use with network management protocols.  In particular,\n   it defines
    objects for managing the TLS Transport Model for SNMP.\n   Managed objects are
    accessed via a virtual information store, termed\n   the Management Information
    Base or MIB.  MIB objects are generally\n   accessed through the Simple Network
    Management Protocol (SNMP).\n   Objects in the MIB are defined using the mechanisms
    defined in the\n   Structure of Management Information (SMI).  This memo specifies
    a MIB\n   module that is compliant to the SMIv2, which is described in STD 58:\n
    \  [RFC2578], [RFC2579], and [RFC2580].\n   The diagram shown below gives a conceptual
    overview of two SNMP\n   entities communicating using the TLS Transport Model
    (shown as\n   \"TLSTM\").  One entity contains a command responder and notification\n
    \  originator application, and the other a command generator and\n   notification
    receiver application.  It should be understood that this\n   particular mix of
    application types is an example only and other\n   combinations are equally valid.\n
    \  Note: this diagram shows the Transport Security Model (TSM) being\n   used
    as the security model that is defined in [RFC5591].\n +---------------------------------------------------------------------+\n
    |                              Network                                |\n +---------------------------------------------------------------------+\n
    \    ^                     |            ^               |\n     |Notifications
    \       |Commands    |Commands       |Notifications\n +---|---------------------|-------+
    +--|---------------|--------------+\n |   |                     V       | |  |
    \              V              |\n | +------------+  +------------+  | | +-----------+
    \  +----------+    |\n | |  (D)TLS    |  |  (D)TLS    |  | | | (D)TLS    |   |
    (D)TLS   |    |\n | |  (Client)  |  |  (Server)  |  | | | (Client)  |   | (Server)
    |    |\n | +------------+  +------------+  | | +-----------+   +----------+    |\n
    |       ^             ^           | |       ^              ^          |\n |       |
    \            |           | |       |              |          |\n |       +-------------+
    \          | |       +--------------+          |\n | +-----|------------+            |
    | +-----|------------+            |\n | |     V            |            | | |
    \    V            |            |\n | | +--------+       |   +-----+  | | | +--------+
    \      |   +-----+  |\n | | | TLS TM |<--------->|Cache|  | | | | TLS TM |<--------->|Cache|
    \ |\n | | +--------+       |   +-----+  | | | +--------+       |   +-----+  |\n
    | |Transport Subsys. |      ^     | | |Transport Subsys. |      ^     |\n | +------------------+
    \     |     | | +------------------+      |     |\n |    ^                      |
    \    | |    ^                      |     |\n |    |                      +--+
    \ | |    |                      +--+  |\n |    v                         |  |
    |    V                         |  |\n | +-----+ +--------+ +-------+ |  | | +-----+
    +--------+ +-------+ |  |\n | |     | |Message | |Securi.| |  | | |     | |Message
    | |Securi.| |  |\n | |Disp.| |Proc.   | |Subsys.| |  | | |Disp.| |Proc.   | |Subsys.|
    |  |\n | |     | |Subsys. | |       | |  | | |     | |Subsys. | |       | |  |\n
    | |     | |        | |       | |  | | |     | |        | |       | |  |\n | |
    \    | | +----+ | | +---+ | |  | | |     | | +----+ | | +---+ | |  |\n | |    <--->|v3MP|<-->
    |TSM|<--+  | | |    <--->|v3MP|<--->|TSM|<--+  |\n | |     | | +----+ | | +---+
    |    | | |     | | +----+ | | +---+ |    |\n | |     | |        | |       |    |
    | |     | |        | |       |    |\n | +-----+ +--------+ +-------+    | | +-----+
    +--------+ +-------+    |\n |    ^                            | |    ^                            |\n
    |    |                            | |    |                            |\n |    +-+------------+
    \            | |    +-+----------+               |\n |      |            |             |
    |      |          |               |\n |      v            v             | |      v
    \         V               |\n | +-------------+ +-------------+ | | +-------------+
    +-------------+ |\n | |   COMMAND   | | NOTIFICAT.  | | | |  COMMAND    | | NOTIFICAT.
    \ | |\n | |  RESPONDER  | | ORIGINATOR  | | | | GENERATOR   | | RECEIVER    |
    |\n | | application | | application | | | | application | | application | |\n
    | +-------------+ +-------------+ | | +-------------+ +-------------+ |\n |                     SNMP
    entity | |                     SNMP entity |\n +---------------------------------+
    +---------------------------------+\n"
  - contents:
    - "1.1.  Conventions\n   For consistency with SNMP-related specifications, this
      document\n   favors terminology as defined in STD 62, rather than favoring\n
      \  terminology that is consistent with non-SNMP specifications.  This is\n   consistent
      with the IESG decision to not require the SNMPv3\n   terminology be modified
      to match the usage of other non-SNMP\n   specifications when SNMPv3 was advanced
      to a Full Standard.\n   \"Authentication\" in this document typically refers
      to the English\n   meaning of \"serving to prove the authenticity of\" the message,
      not\n   data source authentication or peer identity authentication.\n   The
      terms \"manager\" and \"agent\" are not used in this document\n   because, in
      the [RFC3411] architecture, all SNMP entities have the\n   capability of acting
      as manager, agent, or both depending on the SNMP\n   application types supported
      in the implementation.  Where distinction\n   is required, the application names
      of command generator, command\n   responder, notification originator, notification
      receiver, and proxy\n   forwarder are used.  See \"SNMP Applications\" [RFC3413]
      for further\n   information.\n   Large portions of this document simultaneously
      refer to both TLS and\n   DTLS when discussing TLSTM components that function
      equally with\n   either protocol.  \"(D)TLS\" is used in these places to indicate
      that\n   the statement applies to either or both protocols as appropriate.\n
      \  When a distinction between the protocols is needed, they are referred\n   to
      independently through the use of \"TLS\" or \"DTLS\".  The Transport\n   Model,
      however, is named \"TLS Transport Model\" and refers not to the\n   TLS or DTLS
      protocol but to the specification in this document, which\n   includes support
      for both TLS and DTLS.\n   Throughout this document, the terms \"client\" and
      \"server\" are used to\n   refer to the two ends of the (D)TLS transport connection.
      \ The client\n   actively opens the (D)TLS connection, and the server passively\n
      \  listens for the incoming (D)TLS connection.  An SNMP entity may act\n   as
      a (D)TLS client or server or both, depending on the SNMP\n   applications supported.\n
      \  The User-Based Security Model (USM) [RFC3414] is a mandatory-to-\n   implement
      Security Model in STD 62.  While (D)TLS and USM frequently\n   refer to a user,
      the terminology preferred in RFC 3411 and in this\n   memo is \"principal\".
      \ A principal is the \"who\" on whose behalf\n   services are provided or processing
      takes place.  A principal can be,\n   among other things, an individual acting
      in a particular role; a set\n   of individuals, with each acting in a particular
      role; an application\n   or a set of applications, or a combination of these
      within an\n   administrative domain.\n   Throughout this document, the term
      \"session\" is used to refer to a\n   secure association between two TLS Transport
      Models that permits the\n   transmission of one or more SNMP messages within
      the lifetime of the\n   session.  The (D)TLS protocols also have an internal
      notion of a\n   session and although these two concepts of a session are related,\n
      \  when the term \"session\" is used this document is referring to the\n   TLSTM's
      specific session and not directly to the (D)TLS protocol's\n   session.\n   The
      key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n
      \  \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in
      this\n   document are to be interpreted as described in [RFC2119].\n"
    title: 1.1.  Conventions
  - contents:
    - "1.2.  Changes Since RFC 5953\n   This document obsoletes [RFC5953].\n   Since
      the publication of RFC 5953, a few editorial errata have been\n   noted.  These
      errata are posted on the RFC Editor web site.  These\n   errors have been corrected
      in this document.\n   This document updates the references to RFC 3490 (IDNA
      2003) to\n   [RFC5890] (IDNA 2008), because RFC 3490 was obsoleted by RFC 5890.\n
      \  References to RFC 1033 were replaced with references to [RFC1123].\n   Added
      informative reference to 5953.\n   Updated MIB dates and revision date.\n"
    title: 1.2.  Changes Since RFC 5953
  title: 1.  Introduction
- contents:
  - "2.  The Transport Layer Security Protocol\n   (D)TLS provides authentication,
    data message integrity, and privacy\n   at the transport layer (see [RFC4347]).\n
    \  The primary goals of the TLS Transport Model are to provide privacy,\n   peer
    identity authentication, and data integrity between two\n   communicating SNMP
    entities.  The TLS and DTLS protocols provide a\n   secure transport upon which
    the TLSTM is based.  Please refer to\n   [RFC5246] and [RFC4347] for complete
    descriptions of the protocols.\n"
  title: 2.  The Transport Layer Security Protocol
- contents:
  - "3.  How the TLSTM Fits into the Transport Subsystem\n   A transport model is
    a component of the Transport Subsystem.  The TLS\n   Transport Model thus fits
    between the underlying (D)TLS transport\n   layer and the Message Dispatcher [RFC3411]
    component of the SNMP\n   engine.\n   The TLS Transport Model will establish a
    session between itself and\n   the TLS Transport Model of another SNMP engine.
    \ The sending\n   transport model passes unencrypted and unauthenticated messages
    from\n   the Dispatcher to (D)TLS to be encrypted and authenticated, and the\n
    \  receiving transport model accepts decrypted and authenticated/\n   integrity-checked
    incoming messages from (D)TLS and passes them to\n   the Dispatcher.\n   After
    a TLS Transport Model session is established, SNMP messages can\n   conceptually
    be sent through the session from one SNMP message\n   Dispatcher to another SNMP
    Message Dispatcher.  If multiple SNMP\n   messages are needed to be passed between
    two SNMP applications they\n   MAY be passed through the same session.  A TLSTM
    implementation\n   engine MAY choose to close the session to conserve resources.\n
    \  The TLS Transport Model of an SNMP engine will perform the\n   translation
    between (D)TLS-specific security parameters and SNMP-\n   specific, model-independent
    parameters.\n   The diagram below depicts where the TLS Transport Model (shown
    as\n   \"(D)TLS TM\") fits into the architecture described in RFC 3411 and the\n
    \  Transport Subsystem:\n   +------------------------------+\n   |    Network
    \                  |\n   +------------------------------+\n      ^       ^              ^\n
    \     |       |              |\n      v       v              v\n   +-------------------------------------------------------------------+\n
    \  | +--------------------------------------------------+              |\n   |
    |  Transport Subsystem                             |  +--------+  |\n   | | +-----+
    +-----+ +-------+             +-------+  |  |        |  |\n   | | | UDP | | SSH
    | |(D)TLS |    . . .    | other |<--->| Cache  |  |\n   | | |     | | TM  | |
    TM    |             |       |  |  |        |  |\n   | | +-----+ +-----+ +-------+
    \            +-------+  |  +--------+  |\n   | +--------------------------------------------------+
    \        ^    |\n   |              ^                                               |
    \   |\n   |              |                                               |    |\n
    \  | Dispatcher   v                                               |    |\n   |
    +--------------+ +---------------------+  +----------------+ |    |\n   | | Transport
    \   | | Message Processing  |  | Security       | |    |\n   | | Dispatch     |
    | Subsystem           |  | Subsystem      | |    |\n   | |              | |     +------------+
    \ |  | +------------+ | |    |\n   | |              | |  +->| v1MP       |<--->|
    | USM        | | |    |\n   | |              | |  |  +------------+  |  | +------------+
    | |    |\n   | |              | |  |  +------------+  |  | +------------+ | |
    \   |\n   | |              | |  +->| v2cMP      |<--->| | Transport  | | |    |\n
    \  | | Message      | |  |  +------------+  |  | | Security   |<--+    |\n   |
    | Dispatch    <---->|  +------------+  |  | | Model      | |      |\n   | |              |
    |  +->| v3MP       |<--->| +------------+ |      |\n   | |              | |  |
    \ +------------+  |  | +------------+ |      |\n   | | PDU Dispatch | |  |  +------------+
    \ |  | | Other      | |      |\n   | +--------------+ |  +->| otherMP    |<--->|
    | Model(s)   | |      |\n   |              ^   |     +------------+  |  | +------------+
    |      |\n   |              |   +---------------------+  +----------------+      |\n
    \  |              v                                                    |\n   |
    \     +-------+-------------------------+---------------+          |\n   |      ^
    \                                ^               ^          |\n   |      |                                 |
    \              |          |\n   |      v                                 v               v
    \         |\n   | +-------------+   +---------+   +--------------+  +-------------+
    |\n   | |   COMMAND   |   | ACCESS  |   | NOTIFICATION |  |    PROXY    | |\n
    \  | |  RESPONDER  |<->| CONTROL |<->|  ORIGINATOR  |  |  FORWARDER  | |\n   |
    | application |   |         |   | applications |  | application | |\n   | +-------------+
    \  +---------+   +--------------+  +-------------+ |\n   |      ^                                 ^
    \                         |\n   |      |                                 |                          |\n
    \  |      v                                 v                          |\n   |
    +----------------------------------------------+                  |\n   | |             MIB
    instrumentation              |      SNMP entity |\n   +-------------------------------------------------------------------+\n"
  - contents:
    - '3.1.  Security Capabilities of This Model

      '
    - contents:
      - "3.1.1.  Threats\n   The TLS Transport Model provides protection against the
        threats\n   identified by the RFC 3411 architecture [RFC3411]:\n   1.  Modification
        of Information - The modification threat is the\n       danger that an unauthorized
        entity may alter in-transit SNMP\n       messages generated on behalf of an
        authorized principal in such a\n       way as to effect unauthorized management
        operations, including\n       falsifying the value of an object.\n       (D)TLS
        provides verification that the content of each received\n       message has
        not been modified during its transmission through the\n       network, data
        has not been altered or destroyed in an\n       unauthorized manner, and data
        sequences have not been altered to\n       an extent greater than can occur
        non-maliciously.\n   2.  Masquerade - The masquerade threat is the danger
        that management\n       operations unauthorized for a given principal may
        be attempted by\n       assuming the identity of another principal that has
        the\n       appropriate authorizations.\n       The TLSTM verifies the identity
        of the (D)TLS server through the\n       use of the (D)TLS protocol and X.509
        certificates.  A TLS\n       Transport Model implementation MUST support the
        authentication of\n       both the server and the client.\n   3.  Message
        stream modification - The re-ordering, delay, or replay\n       of messages
        can and does occur through the natural operation of\n       many connectionless
        transport services.  The message stream\n       modification threat is the
        danger that messages may be\n       maliciously re-ordered, delayed, or replayed
        to an extent that is\n       greater than can occur through the natural operation
        of\n       connectionless transport services, in order to effect\n       unauthorized
        management operations.\n       (D)TLS provides replay protection with a Message
        Authentication\n       Code (MAC) that includes a sequence number.  Since
        UDP provides\n       no sequencing ability, DTLS uses a sliding window protocol
        with\n       the sequence number used for replay protection (see [RFC4347]).\n
        \  4.  Disclosure - The disclosure threat is the danger of eavesdropping\n
        \      on the exchanges between SNMP engines.\n       (D)TLS provides protection
        against the disclosure of information\n       to unauthorized recipients or
        eavesdroppers by allowing for\n       encryption of all traffic between SNMP
        engines.  A TLS Transport\n       Model implementation MUST support message
        encryption to protect\n       sensitive data from eavesdropping attacks.\n
        \  5.  Denial of Service - The RFC 3411 architecture [RFC3411] states\n       that
        denial-of-service (DoS) attacks need not be addressed by an\n       SNMP security
        protocol.  However, connectionless transports (like\n       DTLS over UDP)
        are susceptible to a variety of DoS attacks\n       because they are more
        vulnerable to spoofed IP addresses.  See\n       Section 4.2 for details on
        how the cookie mechanism is used.\n       Note, however, that this mechanism
        does not provide any defense\n       against DoS attacks mounted from valid
        IP addresses.\n   See Section 9 for more detail on the security considerations\n
        \  associated with the TLSTM and these security threats.\n"
      title: 3.1.1.  Threats
    - contents:
      - "3.1.2.  Message Protection\n   The RFC 3411 architecture recognizes three
        levels of security:\n   o  without authentication and without privacy (noAuthNoPriv)\n
        \  o  with authentication but without privacy (authNoPriv)\n   o  with authentication
        and with privacy (authPriv)\n   The TLS Transport Model determines from (D)TLS
        the identity of the\n   authenticated principal, the transport type, and the
        transport\n   address associated with an incoming message.  The TLS Transport
        Model\n   provides the identity and destination type and address to (D)TLS
        for\n   outgoing messages.\n   When an application requests a session for
        a message, it also\n   requests a security level for that session.  The TLS
        Transport Model\n   MUST ensure that the (D)TLS connection provides security
        at least as\n   high as the requested level of security.  How the security
        level is\n   translated into the algorithms used to provide data integrity
        and\n   privacy is implementation dependent.  However, the NULL integrity
        and\n   encryption algorithms MUST NOT be used to fulfill security level\n
        \  requests for authentication or privacy.  Implementations MAY choose\n   to
        force (D)TLS to only allow cipher_suites that provide both\n   authentication
        and privacy to guarantee this assertion.\n   If a suitable interface between
        the TLS Transport Model and the\n   (D)TLS Handshake Protocol is implemented
        to allow the selection of\n   security-level-dependent algorithms (for example,
        a security level to\n   cipher_suites mapping table), then different security
        levels may be\n   utilized by the application.\n   The authentication, integrity,
        and privacy algorithms used by the\n   (D)TLS Protocols may vary over time
        as the science of cryptography\n   continues to evolve and the development
        of (D)TLS continues over\n   time.  Implementers are encouraged to plan for
        changes in operator\n   trust of particular algorithms.  Implementations SHOULD
        offer\n   configuration settings for mapping algorithms to SNMPv3 security\n
        \  levels.\n"
      title: 3.1.2.  Message Protection
    - contents:
      - "3.1.3.  (D)TLS Connections\n   (D)TLS connections are opened by the TLS Transport
        Model during the\n   elements of procedure for an outgoing SNMP message.  Since
        the sender\n   of a message initiates the creation of a (D)TLS connection
        if needed,\n   the (D)TLS connection will already exist for an incoming message.\n
        \  Implementations MAY choose to instantiate (D)TLS connections in\n   anticipation
        of outgoing messages.  This approach might be useful to\n   ensure that a
        (D)TLS connection to a given target can be established\n   before it becomes
        important to send a message over the (D)TLS\n   connection.  Of course, there
        is no guarantee that a pre-established\n   session will still be valid when
        needed.\n   DTLS connections, when used over UDP, are uniquely identified
        within\n   the TLS Transport Model by the combination of transportDomain,\n
        \  transportAddress, tmSecurityName, and requestedSecurityLevel\n   associated
        with each session.  Each unique combination of these\n   parameters MUST have
        a locally chosen unique tlstmSessionID for each\n   active session.  For further
        information, see Section 5.  TLS over\n   TCP sessions, on the other hand,
        do not require a unique pairing of\n   address and port attributes since their
        lower-layer protocols (TCP)\n   already provide adequate session framing.
        \ But they must still\n   provide a unique tlstmSessionID for referencing
        the session.\n   The tlstmSessionID MUST NOT change during the entire duration
        of the\n   session from the TLSTM's perspective, and MUST uniquely identify
        a\n   single session.  As an implementation hint: note that the (D)TLS\n   internal
        SessionID does not meet these requirements, since it can\n   change over the
        life of the connection as seen by the TLSTM (for\n   example, during renegotiation),
        and does not necessarily uniquely\n   identify a TLSTM session (there can
        be multiple TLSTM sessions\n   sharing the same D(TLS) internal SessionID).\n"
      title: 3.1.3.  (D)TLS Connections
    title: 3.1.  Security Capabilities of This Model
  - contents:
    - "3.2.  Security Parameter Passing\n   For the (D)TLS server-side, (D)TLS-specific
      security parameters\n   (i.e., cipher_suites, X.509 certificate fields, IP addresses,
      and\n   ports) are translated by the TLS Transport Model into security\n   parameters
      for the TLS Transport Model and security model (e.g.,\n   tmSecurityLevel, tmSecurityName,
      transportDomain, transportAddress).\n   The transport-related and (D)TLS-security-related
      information,\n   including the authenticated identity, are stored in a cache\n
      \  referenced by tmStateReference.\n   For the (D)TLS client side, the TLS Transport
      Model takes input\n   provided by the Dispatcher in the sendMessage() Abstract
      Service\n   Interface (ASI) and input from the tmStateReference cache.  The\n
      \  (D)TLS Transport Model converts that information into suitable\n   security
      parameters for (D)TLS and establishes sessions as needed.\n   The elements of
      procedure in Section 5 discuss these concepts in much\n   greater detail.\n"
    title: 3.2.  Security Parameter Passing
  - contents:
    - "3.3.  Notifications and Proxy\n   (D)TLS connections may be initiated by (D)TLS
      clients on behalf of\n   SNMP applications that initiate communications, such
      as command\n   generators, notification originators, proxy forwarders.  Command\n
      \  generators are frequently operated by a human, but notification\n   originators
      and proxy forwarders are usually unmanned automated\n   processes.  The targets
      to whom notifications and proxied requests\n   should be sent are typically
      determined and configured by a network\n   administrator.\n   The SNMP-TARGET-MIB
      module [RFC3413] contains objects for defining\n   management targets, including
      transportDomain, transportAddress,\n   securityName, securityModel, and securityLevel
      parameters, for\n   notification originator, proxy forwarder, and SNMP-controllable\n
      \  command generator applications.  Transport domains and transport\n   addresses
      are configured in the snmpTargetAddrTable, and the\n   securityModel, securityName,
      and securityLevel parameters are\n   configured in the snmpTargetParamsTable.
      \ This document defines a MIB\n   module that extends the SNMP-TARGET-MIB's
      snmpTargetParamsTable to\n   specify a (D)TLS client-side certificate to use
      for the connection.\n   When configuring a (D)TLS target, the snmpTargetAddrTDomain
      and\n   snmpTargetAddrTAddress parameters in snmpTargetAddrTable SHOULD be\n
      \  set to the snmpTLSTCPDomain or snmpDTLSUDPDomain object and an\n   appropriate
      snmpTLSAddress value.  When used with the SNMPv3 message\n   processing model,
      the snmpTargetParamsMPModel column of the\n   snmpTargetParamsTable SHOULD be
      set to a value of 3.  The\n   snmpTargetParamsSecurityName SHOULD be set to
      an appropriate\n   securityName value, and the snmpTlstmParamsClientFingerprint\n
      \  parameter of the snmpTlstmParamsTable SHOULD be set to a value that\n   refers
      to a locally held certificate (and the corresponding private\n   key) to be
      used.  Other parameters, for example, cryptographic\n   configuration such as
      which cipher_suites to use, must come from\n   configuration mechanisms not
      defined in this document.\n   The securityName defined in the snmpTargetParamsSecurityName
      column\n   will be used by the access control model to authorize any\n   notifications
      that need to be sent.\n"
    title: 3.3.  Notifications and Proxy
  title: 3.  How the TLSTM Fits into the Transport Subsystem
- contents:
  - "4.  Elements of the Model\n   This section contains definitions required to realize
    the (D)TLS\n   Transport Model defined by this document.\n"
  - contents:
    - "4.1.  X.509 Certificates\n   (D)TLS can make use of X.509 certificates for
      authentication of both\n   sides of the transport.  This section discusses the
      use of X.509\n   certificates in the TLSTM.\n   While (D)TLS supports multiple
      authentication mechanisms, this\n   document only discusses X.509-certificate-based
      authentication; other\n   forms of authentication are outside the scope of this
      specification.\n   TLSTM implementations are REQUIRED to support X.509 certificates.\n"
    - contents:
      - "4.1.1.  Provisioning for the Certificate\n   Authentication using (D)TLS
        will require that SNMP entities have\n   certificates, either signed by trusted
        Certification Authorities\n   (CAs), or self signed.  Furthermore, SNMP entities
        will most commonly\n   need to be provisioned with root certificates that
        represent the list\n   of trusted CAs that an SNMP entity can use for certificate\n
        \  verification.  SNMP entities SHOULD also be provisioned with an X.509\n
        \  certificate revocation mechanism which can be used to verify that a\n   certificate
        has not been revoked.  Trusted public keys from either CA\n   certificates
        and/or self-signed certificates MUST be installed into\n   the server through
        a trusted out-of-band mechanism and their\n   authenticity MUST be verified
        before access is granted.\n   Having received a certificate from a connecting
        TLSTM client, the\n   authenticated tmSecurityName of the principal is derived
        using the\n   snmpTlstmCertToTSNTable.  This table allows mapping of incoming\n
        \  connections to tmSecurityNames through defined transformations.  The\n
        \  transformations defined in the SNMP-TLS-TM-MIB include:\n   o  Mapping
        a certificate's subjectAltName or CommonName components to\n      a tmSecurityName,
        or\n   o  Mapping a certificate's fingerprint value to a directly specified\n
        \     tmSecurityName\n   As an implementation hint: implementations may choose
        to discard any\n   connections for which no potential snmpTlstmCertToTSNTable
        mapping\n   exists before performing certificate verification to avoid expending\n
        \  computational resources associated with certificate verification.\n   Deployments
        SHOULD map the \"subjectAltName\" component of X.509\n   certificates to the
        TLSTM specific tmSecurityNames.  The\n   authenticated identity can be obtained
        by the TLS Transport Model by\n   extracting the subjectAltName(s) from the
        peer's certificate.  The\n   receiving application will then have an appropriate
        tmSecurityName\n   for use by other SNMPv3 components like an access control
        model.\n   An example of this type of mapping setup can be found in Appendix
        A.\n   This tmSecurityName may be later translated from a TLSTM specific\n
        \  tmSecurityName to an SNMP engine securityName by the security model.\n
        \  A security model, like the TSM security model [RFC5591], may perform\n
        \  an identity mapping or a more complex mapping to derive the\n   securityName
        from the tmSecurityName offered by the TLS Transport\n   Model.\n   The standard
        View-Based Access Control Model (VACM) access control\n   model constrains
        securityNames to be 32 octets or less in length.  A\n   TLSTM generated tmSecurityName,
        possibly in combination with a\n   messaging or security model that increases
        the length of the\n   securityName, might cause the securityName length to
        exceed 32\n   octets.  For example, a 32-octet tmSecurityName derived from
        an IPv6\n   address, paired with a TSM prefix, will generate a 36-octet\n
        \  securityName.  Such a securityName will not be able to be used with\n   standard
        VACM or TARGET MIB modules.  Operators should be careful to\n   select algorithms
        and subjectAltNames to avoid this situation.\n   A pictorial view of the complete
        transformation process (using the\n   TSM security model for the example)
        is shown below:\n    +-------------+     +-------+                   +-----+\n
        \   | Certificate |     |       |                   |     |\n    |    Path
        \    |     | TLSTM |  tmSecurityName   | TSM |\n    | Validation  | --> |
        \      | ----------------->|     |\n    +-------------+     +-------+                   +-----+\n
        \                                                       |\n                                                        |
        securityName\n                                                        V\n
        \                                                   +-------------+\n                                                    |
        application |\n                                                    +-------------+\n"
      title: 4.1.1.  Provisioning for the Certificate
    title: 4.1.  X.509 Certificates
  - contents:
    - "4.2.  (D)TLS Usage\n   (D)TLS MUST negotiate a cipher_suite that uses X.509
      certificates for\n   authentication, and MUST authenticate both the client and
      the server.\n   The mandatory-to-implement cipher_suite is specified in the
      TLS\n   specification [RFC5246].\n   TLSTM verifies the certificates when the
      connection is opened (see\n   Section 5.3).  For this reason, TLS renegotiation
      with different\n   certificates MUST NOT be done.  That is, implementations
      MUST either\n   disable renegotiation completely (RECOMMENDED), or they MUST
      present\n   the same certificate during renegotiation (and MUST verify that
      the\n   other end presented the same certificate).\n   For DTLS over UDP, each
      SNMP message MUST be placed in a single UDP\n   datagram; it MAY be split to
      multiple DTLS records.  In other words,\n   if a single datagram contains multiple
      DTLS application_data records,\n   they are concatenated when received.  The
      TLSTM implementation SHOULD\n   return an error if the SNMP message does not
      fit in the UDP datagram,\n   and thus cannot be sent.\n   For DTLS over UDP,
      the DTLS server implementation MUST support DTLS\n   cookies ([RFC4347] already
      requires that clients support DTLS\n   cookies).  Implementations are not required
      to perform the cookie\n   exchange for every DTLS handshake; however, enabling
      it by default is\n   RECOMMENDED.\n   For DTLS, replay protection MUST be used.\n"
    title: 4.2.  (D)TLS Usage
  - contents:
    - "4.3.  SNMP Services\n   This section describes the services provided by the
      TLS Transport\n   Model with their inputs and outputs.  The services are between
      the\n   Transport Model and the Dispatcher.\n   The services are described as
      primitives of an abstract service\n   interface (ASI) and the inputs and outputs
      are described as abstract\n   data elements as they are passed in these abstract
      service\n   primitives.\n"
    - contents:
      - "4.3.1.  SNMP Services for an Outgoing Message\n   The Dispatcher passes the
        information to the TLS Transport Model\n   using the ASI defined in the Transport
        Subsystem:\n      statusInformation =\n      sendMessage(\n      IN   destTransportDomain
        \          -- transport domain to be used\n      IN   destTransportAddress
        \         -- transport address to be used\n      IN   outgoingMessage               --
        the message to send\n      IN   outgoingMessageLength         -- its length\n
        \     IN   tmStateReference              -- reference to transport state\n
        \      )\n   The abstract data elements returned from or passed as parameters
        into\n   the abstract service primitives are as follows:\n   statusInformation:
        \ An indication of whether the sending of the\n      message was successful.
        \ If not, it is an indication of the\n      problem.\n   destTransportDomain:
        \ The transport domain for the associated\n      destTransportAddress.  The
        Transport Model uses this parameter to\n      determine the transport type
        of the associated\n      destTransportAddress.  This document specifies the\n
        \     snmpTLSTCPDomain and the snmpDTLSUDPDomain transport domains.\n   destTransportAddress:
        \ The transport address of the destination TLS\n      Transport Model in a
        format specified by the SnmpTLSAddress\n      TEXTUAL-CONVENTION.\n   outgoingMessage:
        \ The outgoing message to send to (D)TLS for\n      encapsulation and transmission.\n
        \  outgoingMessageLength:  The length of the outgoingMessage.\n   tmStateReference:
        \ A reference used to pass model-specific and\n      mechanism-specific parameters
        between the Transport Subsystem and\n      transport-aware Security Models.\n"
      title: 4.3.1.  SNMP Services for an Outgoing Message
    - contents:
      - "4.3.2.  SNMP Services for an Incoming Message\n   The TLS Transport Model
        processes the received message from the\n   network using the (D)TLS service
        and then passes it to the Dispatcher\n   using the following ASI:\n      statusInformation
        =\n      receiveMessage(\n      IN   transportDomain               -- origin
        transport domain\n      IN   transportAddress              -- origin transport
        address\n      IN   incomingMessage               -- the message received\n
        \     IN   incomingMessageLength         -- its length\n      IN   tmStateReference
        \             -- reference to transport state\n       )\n   The abstract data
        elements returned from or passed as parameters into\n   the abstract service
        primitives are as follows:\n   statusInformation:  An indication of whether
        the passing of the\n      message was successful.  If not, it is an indication
        of the\n      problem.\n   transportDomain:  The transport domain for the
        associated\n      transportAddress.  This document specifies the snmpTLSTCPDomain\n
        \     and the snmpDTLSUDPDomain transport domains.\n   transportAddress:  The
        transport address of the source of the\n      received message in a format
        specified by the SnmpTLSAddress\n      TEXTUAL-CONVENTION.\n   incomingMessage:
        \ The whole SNMP message after being processed by\n      (D)TLS.\n   incomingMessageLength:
        \ The length of the incomingMessage.\n   tmStateReference:  A reference used
        to pass model-specific and\n      mechanism-specific parameters between the
        Transport Subsystem and\n      transport-aware Security Models.\n"
      title: 4.3.2.  SNMP Services for an Incoming Message
    title: 4.3.  SNMP Services
  - contents:
    - "4.4.  Cached Information and References\n   When performing SNMP processing,
      there are two levels of state\n   information that may need to be retained:
      the immediate state linking\n   a request-response pair, and potentially longer-term
      state relating\n   to transport and security.  \"Transport Subsystem for the
      Simple\n   Network Management Protocol (SNMP)\" [RFC5590] defines general\n
      \  requirements for caches and references.\n"
    - contents:
      - "4.4.1.  TLS Transport Model Cached Information\n   The TLS Transport Model
        has specific responsibilities regarding the\n   cached information.  See the
        Elements of Procedure in Section 5 for\n   detailed processing instructions
        on the use of the tmStateReference\n   fields by the TLS Transport Model.\n"
      - contents:
        - "4.4.1.1.  tmSecurityName\n   The tmSecurityName MUST be a human-readable
          name (in snmpAdminString\n   format) representing the identity that has
          been set according to the\n   procedures in Section 5.  The tmSecurityName
          MUST be constant for all\n   traffic passing through a single TLSTM session.
          \ Messages MUST NOT be\n   sent through an existing (D)TLS connection that
          was established using\n   a different tmSecurityName.\n   On the (D)TLS
          server side of a connection, the tmSecurityName is\n   derived using the
          procedures described in Section 5.3.2 and the SNMP-\n   TLS-TM-MIB's snmpTlstmCertToTSNTable
          DESCRIPTION clause.\n   On the (D)TLS client side of a connection, the tmSecurityName
          is\n   presented to the TLS Transport Model by the security model through\n
          \  the tmStateReference.  This tmSecurityName is typically a copy of or\n
          \  is derived from the securityName that was passed by application\n   (possibly
          because of configuration specified in the SNMP-TARGET-MIB).\n   The Security
          Model likely derived the tmSecurityName from the\n   securityName presented
          to the Security Model by the application\n   (possibly because of configuration
          specified in the SNMP-TARGET-MIB).\n   Transport-Model-aware security models
          derive tmSecurityName from a\n   securityName, possibly configured in MIB
          modules for notifications\n   and access controls.  Transport Models SHOULD
          use predictable\n   tmSecurityNames so operators will know what to use when
          configuring\n   MIB modules that use securityNames derived from tmSecurityNames.
          \ The\n   TLSTM generates predictable tmSecurityNames based on the\n   configuration
          found in the SNMP-TLS-TM-MIB's snmpTlstmCertToTSNTable\n   and relies on
          the network operators to have configured this table\n   appropriately.\n"
        title: 4.4.1.1.  tmSecurityName
      - contents:
        - "4.4.1.2.  tmSessionID\n   The tmSessionID MUST be recorded per message
          at the time of receipt.\n   When tmSameSecurity is set, the recorded tmSessionID
          can be used to\n   determine whether the (D)TLS connection available for
          sending a\n   corresponding outgoing message is the same (D)TLS connection
          as was\n   used when receiving the incoming message (e.g., a response to
          a\n   request).\n"
        title: 4.4.1.2.  tmSessionID
      - contents:
        - "4.4.1.3.  Session State\n   The per-session state that is referenced by
          tmStateReference may be\n   saved across multiple messages in a Local Configuration
          Datastore.\n   Additional session/connection state information might also
          be stored\n   in a Local Configuration Datastore.\n"
        title: 4.4.1.3.  Session State
      title: 4.4.1.  TLS Transport Model Cached Information
    title: 4.4.  Cached Information and References
  title: 4.  Elements of the Model
- contents:
  - "5.  Elements of Procedure\n   Abstract service interfaces have been defined by
    [RFC3411] and\n   further augmented by [RFC5590] to describe the conceptual data
    flows\n   between the various subsystems within an SNMP entity.  The TLSTM uses\n
    \  some of these conceptual data flows when communicating between\n   subsystems.\n
    \  To simplify the elements of procedure, the release of state\n   information
    is not always explicitly specified.  As a general rule,\n   if state information
    is available when a message gets discarded, the\n   message-state information
    should also be released.  If state\n   information is available when a session
    is closed, the session state\n   information should also be released.  Sensitive
    information, like\n   cryptographic keys, should be overwritten appropriately
    prior to\n   being released.\n   An error indication in statusInformation will
    typically include the\n   Object Identifier (OID) and value for an incremented
    error counter.\n   This may be accompanied by the requested securityLevel and
    the\n   tmStateReference.  Per-message context information is not accessible\n
    \  to Transport Models, so for the returned counter OID and value,\n   contextEngine
    would be set to the local value of snmpEngineID and\n   contextName to the default
    context for error counters.\n"
  - contents:
    - "5.1.  Procedures for an Incoming Message\n   This section describes the procedures
      followed by the (D)TLS\n   Transport Model when it receives a (D)TLS protected
      packet.  The\n   required functionality is broken into two different sections.\n
      \  Section 5.1.1 describes the processing required for de-multiplexing\n   multiple
      DTLS connections, which is specifically needed for DTLS over\n   UDP sessions.
      \ It is assumed that TLS protocol implementations\n   already provide appropriate
      message demultiplexing.\n   Section 5.1.2 describes the transport processing
      required once the\n   (D)TLS processing has been completed.  This will be needed
      for all\n   (D)TLS-based connections.\n"
    - contents:
      - "5.1.1.  DTLS over UDP Processing for Incoming Messages\n   Demultiplexing
        of incoming packets into separate DTLS sessions MUST\n   be implemented.  For
        connection-oriented transport protocols, such as\n   TCP, the transport protocol
        takes care of demultiplexing incoming\n   packets to the right connection.
        \ For DTLS over UDP, this\n   demultiplexing will either need to be done within
        the DTLS\n   implementation, if supported, or by the TLSTM implementation.\n
        \  Like TCP, DTLS over UDP uses the four-tuple <source IP, destination\n   IP,
        source port, destination port> for identifying the connection\n   (and relevant
        DTLS connection state).  This means that when\n   establishing a new session,
        implementations MUST use a different UDP\n   source port number for each active
        connection to a remote destination\n   IP-address/port-number combination
        to ensure the remote entity can\n   disambiguate between multiple connections.\n
        \  If demultiplexing received UDP datagrams to DTLS connection state is\n
        \  done by the TLSTM implementation (instead of the DTLS\n   implementation),
        the steps below describe one possible method to\n   accomplish this.\n   The
        important output results from the steps in this process are the\n   remote
        transport address, incomingMessage, incomingMessageLength, and\n   the tlstmSessionID.\n
        \  1)  The TLS Transport Model examines the raw UDP message, in an\n       implementation-dependent
        manner.\n   2)  The TLS Transport Model queries the Local Configuration Datastore\n
        \      (LCD) (see [RFC3411], Section 3.4.2) using the transport\n       parameters
        (source and destination IP addresses and ports) to\n       determine if a
        session already exists.\n       2a)  If a matching entry in the LCD does not
        exist, then the UDP\n            packet is passed to the DTLS implementation
        for processing.\n            If the DTLS implementation decides to continue
        with the\n            connection and allocate state for it, it returns a new
        DTLS\n            connection handle (an implementation dependent detail).
        \ In\n            this case, TLSTM selects a new tlstmSessionId, and caches\n
        \           this and the DTLS connection handle as a new entry in the\n            LCD
        (indexed by the transport parameters).  If the DTLS\n            implementation
        returns an error or does not allocate\n            connection state (which
        can happen with the stateless cookie\n            exchange), processing stops.\n
        \      2b)  If a session does exist in the LCD, then its DTLS connection\n
        \           handle (an implementation dependent detail) and its\n            tlstmSessionId
        is extracted from the LCD.  The UDP packet\n            and the connection
        handle are passed to the DTLS\n            implementation.  If the DTLS implementation
        returns success\n            but does not return an incomingMessage and an\n
        \           incomingMessageLength, then processing stops (this is the\n            case
        when the UDP datagram contained DTLS handshake\n            messages, for
        example).  If the DTLS implementation returns\n            an error, then
        processing stops.\n   3)  Retrieve the incomingMessage and an incomingMessageLength
        from\n       DTLS.  These results and the tlstmSessionID are used below in\n
        \      Section 5.1.2 to complete the processing of the incoming message.\n"
      title: 5.1.1.  DTLS over UDP Processing for Incoming Messages
    - contents:
      - "5.1.2.  Transport Processing for Incoming SNMP Messages\n   The procedures
        in this section describe how the TLS Transport Model\n   should process messages
        that have already been properly extracted\n   from the (D)TLS stream.  Note
        that care must be taken when processing\n   messages originating from either
        TLS or DTLS to ensure they're\n   complete and single.  For example, multiple
        SNMP messages can be\n   passed through a single DTLS message and partial
        SNMP messages may be\n   received from a TLS stream.  These steps describe
        the processing of a\n   singular SNMP message after it has been delivered
        from the (D)TLS\n   stream.\n   1)  Determine the tlstmSessionID for the incoming
        message.  The\n       tlstmSessionID MUST be a unique session identifier for
        this\n       (D)TLS connection.  The contents and format of this identifier\n
        \      are implementation dependent as long as it is unique to the\n       session.
        \ A session identifier MUST NOT be reused until all\n       references to
        it are no longer in use.  The tmSessionID is equal\n       to the tlstmSessionID
        discussed in Section 5.1.1. tmSessionID\n       refers to the session identifier
        when stored in the\n       tmStateReference and tlstmSessionID refers to the
        session\n       identifier when stored in the LCD.  They MUST always be equal\n
        \      when processing a given session's traffic.\n       If this is the first
        message received through this session, and\n       the session does not have
        an assigned tlstmSessionID yet, then\n       the snmpTlstmSessionAccepts counter
        is incremented and a\n       tlstmSessionID for the session is created.  This
        will only happen\n       on the server side of a connection because a client
        would have\n       already assigned a tlstmSessionID during the openSession()\n
        \      invocation.  Implementations may have performed the procedures\n       described
        in Section 5.3.2 prior to this point or they may\n       perform them now,
        but the procedures described in Section 5.3.2\n       MUST be performed before
        continuing beyond this point.\n   2)  Create a tmStateReference cache for
        the subsequent reference and\n       assign the following values within it:\n
        \      tmTransportDomain  = snmpTLSTCPDomain or snmpDTLSUDPDomain as\n          appropriate.\n
        \      tmTransportAddress  = The address from which the message\n          originated.\n
        \      tmSecurityLevel  = The derived tmSecurityLevel for the session,\n          as
        discussed in Sections 3.1.2 and 5.3.\n       tmSecurityName  = The derived
        tmSecurityName for the session as\n          discussed in Section 5.3.  This
        value MUST be constant during\n          the lifetime of the session.\n       tmSessionID
        \ = The tlstmSessionID described in step 1 above.\n   3)  The incomingMessage
        and incomingMessageLength are assigned values\n       from the (D)TLS processing.\n
        \  4)  The TLS Transport Model passes the transportDomain,\n       transportAddress,
        incomingMessage, and incomingMessageLength to\n       the Dispatcher using
        the receiveMessage ASI:\n      statusInformation =\n      receiveMessage(\n
        \     IN   transportDomain     -- snmpTLSTCPDomain or snmpDTLSUDPDomain,\n
        \     IN   transportAddress    -- address for the received message\n      IN
        \  incomingMessage        -- the whole SNMP message from (D)TLS\n      IN
        \  incomingMessageLength  -- the length of the SNMP message\n      IN   tmStateReference
        \   -- transport info\n       )\n"
      title: 5.1.2.  Transport Processing for Incoming SNMP Messages
    title: 5.1.  Procedures for an Incoming Message
  - contents:
    - "5.2.  Procedures for an Outgoing SNMP Message\n   The Dispatcher sends a message
      to the TLS Transport Model using the\n   following ASI:\n      statusInformation
      =\n      sendMessage(\n      IN   destTransportDomain           -- transport
      domain to be used\n      IN   destTransportAddress          -- transport address
      to be used\n      IN   outgoingMessage               -- the message to send\n
      \     IN   outgoingMessageLength         -- its length\n      IN   tmStateReference
      \             -- transport info\n      )\n   This section describes the procedure
      followed by the TLS Transport\n   Model whenever it is requested through this
      ASI to send a message.\n   1)  If tmStateReference does not refer to a cache
      containing values\n       for tmTransportDomain, tmTransportAddress, tmSecurityName,\n
      \      tmRequestedSecurityLevel, and tmSameSecurity, then increment the\n       snmpTlstmSessionInvalidCaches
      counter, discard the message, and\n       return the error indication in the
      statusInformation.  Processing\n       of this message stops.\n   2)  Extract
      the tmSessionID, tmTransportDomain, tmTransportAddress,\n       tmSecurityName,
      tmRequestedSecurityLevel, and tmSameSecurity\n       values from the tmStateReference.
      \ Note: the tmSessionID value\n       may be undefined if no session exists
      yet over which the message\n       can be sent.\n   3)  If tmSameSecurity is
      true and tmSessionID is either undefined or\n       refers to a session that
      is no longer open, then increment the\n       snmpTlstmSessionNoSessions counter,
      discard the message, and\n       return the error indication in the statusInformation.
      \ Processing\n       of this message stops.\n   4)  If tmSameSecurity is false
      and tmSessionID refers to a session\n       that is no longer available, then
      an implementation SHOULD open a\n       new session, using the openSession()
      ASI (described in greater\n       detail in step 5b).  Instead of opening a
      new session an\n       implementation MAY return an snmpTlstmSessionNoSessions
      error to\n       the calling module and stop the processing of the message.\n
      \  5)  If tmSessionID is undefined, then use tmTransportDomain,\n       tmTransportAddress,
      tmSecurityName, and tmRequestedSecurityLevel\n       to see if there is a corresponding
      entry in the LCD suitable to\n       send the message over.\n       5a)  If
      there is a corresponding LCD entry, then this session\n            will be used
      to send the message.\n       5b)  If there is no corresponding LCD entry, then
      open a session\n            using the openSession() ASI (discussed further in\n
      \           Section 5.3.1).  Implementations MAY wish to offer message\n            buffering
      to prevent redundant openSession() calls for the\n            same cache entry.
      \ If an error is returned from\n            openSession(), then discard the
      message, discard the\n            tmStateReference, increment the snmpTlstmSessionOpenErrors,\n
      \           return an error indication to the calling module, and stop\n            the
      processing of the message.\n   6)  Using either the session indicated by the
      tmSessionID (if there\n       was one) or the session resulting from a previous
      step (4 or 5),\n       pass the outgoingMessage to (D)TLS for encapsulation
      and\n       transmission.\n"
    title: 5.2.  Procedures for an Outgoing SNMP Message
  - contents:
    - "5.3.  Establishing or Accepting a Session\n   Establishing a (D)TLS connection
      as either a client or a server\n   requires slightly different processing.  The
      following two sections\n   describe the necessary processing steps.\n"
    - contents:
      - "5.3.1.  Establishing a Session as a Client\n   The TLS Transport Model provides
        the following primitive for use by a\n   client to establish a new (D)TLS
        connection:\n   statusInformation =           -- errorIndication or success\n
        \  openSession(\n   IN   tmStateReference         -- transport information
        to be used\n   OUT  tmStateReference         -- transport information to be
        used\n   IN   maxMessageSize           -- of the sending SNMP entity\n   )\n
        \  The following describes the procedure to follow when establishing an\n
        \  SNMP over a (D)TLS connection between SNMP engines for exchanging\n   SNMP
        messages.  This process is followed by any SNMP client's engine\n   when establishing
        a session for subsequent use.\n   This procedure MAY be done automatically
        for an SNMP application that\n   initiates a transaction, such as a command
        generator, a notification\n   originator, or a proxy forwarder.\n   1)  The
        snmpTlstmSessionOpens counter is incremented.\n   2)  The client selects the
        appropriate certificate and cipher_suites\n       for the key agreement based
        on the tmSecurityName and the\n       tmRequestedSecurityLevel for the session.
        \ For sessions being\n       established as a result of an SNMP-TARGET-MIB
        based operation,\n       the certificate will potentially have been identified
        via the\n       snmpTlstmParamsTable mapping and the cipher_suites will have
        to\n       be taken from a system-wide or implementation-specific\n       configuration.
        \ If no row in the snmpTlstmParamsTable exists,\n       then implementations
        MAY choose to establish the connection using\n       a default client certificate
        available to the application.\n       Otherwise, the certificate and appropriate
        cipher_suites will\n       need to be passed to the openSession() ASI as supplemental\n
        \      information or configured through an implementation-dependent\n       mechanism.
        \ It is also implementation-dependent and possibly\n       policy-dependent
        how tmRequestedSecurityLevel will be used to\n       influence the security
        capabilities provided by the (D)TLS\n       connection.  However this is done,
        the security capabilities\n       provided by (D)TLS MUST be at least as high
        as the level of\n       security indicated by the tmRequestedSecurityLevel
        parameter.\n       The actual security level of the session is reported in
        the\n       tmStateReference cache as tmSecurityLevel.  For (D)TLS to provide\n
        \      strong authentication, each principal acting as a command\n       generator
        SHOULD have its own certificate.\n   3)  Using the destTransportDomain and
        destTransportAddress values,\n       the client will initiate the (D)TLS handshake
        protocol to\n       establish session keys for message integrity and encryption.\n
        \      If the attempt to establish a session is unsuccessful, then\n       snmpTlstmSessionOpenErrors
        is incremented, an error indication is\n       returned, and processing stops.
        \ If the session failed to open\n       because the presented server certificate
        was unknown or invalid,\n       then the snmpTlstmSessionUnknownServerCertificate
        or\n       snmpTlstmSessionInvalidServerCertificates MUST be incremented and\n
        \      an snmpTlstmServerCertificateUnknown or\n       snmpTlstmServerInvalidCertificate
        notification SHOULD be sent as\n       appropriate.  Reasons for server certificate
        invalidation\n       include, but are not limited to, cryptographic validation\n
        \      failures and an unexpected presented certificate identity.\n   4)  The
        (D)TLS client MUST then verify that the (D)TLS server's\n       presented
        certificate is the expected certificate.  The (D)TLS\n       client MUST NOT
        transmit SNMP messages until the server\n       certificate has been authenticated,
        the client certificate has\n       been transmitted, and the TLS connection
        has been fully\n       established.\n       If the connection is being established
        from a configuration based\n       on SNMP-TARGET-MIB configuration, then
        the snmpTlstmAddrTable\n       DESCRIPTION clause describes how the verification
        is done (using\n       either a certificate fingerprint, or an identity authenticated\n
        \      via certification path validation).\n       If the connection is being
        established for reasons other than\n       configuration found in the SNMP-TARGET-MIB,
        then configuration\n       and procedures outside the scope of this document
        should be\n       followed.  Configuration mechanisms SHOULD be similar in
        nature\n       to those defined in the snmpTlstmAddrTable to ensure consistency\n
        \      across management configuration systems.  For example, a command-\n
        \      line tool for generating SNMP GETs might support specifying\n       either
        the server's certificate fingerprint or the expected host\n       name as
        a command-line argument.\n   5)  (D)TLS provides assurance that the authenticated
        identity has\n       been signed by a trusted configured Certification Authority.
        \ If\n       verification of the server's certificate fails in any way (for\n
        \      example, because of failures in cryptographic verification or the\n
        \      presented identity did not match the expected named entity), then\n
        \      the session establishment MUST fail, and the\n       snmpTlstmSessionInvalidServerCertificates
        object is incremented.\n       If the session cannot be opened for any reason
        at all, including\n       cryptographic verification failures and snmpTlstmCertToTSNTable\n
        \      lookup failures, then the snmpTlstmSessionOpenErrors counter is\n       incremented
        and processing stops.\n   6)  The TLSTM-specific session identifier (tlstmSessionID)
        is set in\n       the tmSessionID of the tmStateReference passed to the TLS\n
        \      Transport Model to indicate that the session has been established\n
        \      successfully and to point to a specific (D)TLS connection for\n       future
        use.  The tlstmSessionID is also stored in the LCD for\n       later lookup
        during processing of incoming messages\n       (Section 5.1.2).\n"
      title: 5.3.1.  Establishing a Session as a Client
    - contents:
      - "5.3.2.  Accepting a Session as a Server\n   A (D)TLS server should accept
        new session connections from any client\n   for which it is able to verify
        the client's credentials.  This is\n   done by authenticating the client's
        presented certificate through a\n   certificate path validation process (e.g.,
        [RFC5280]) or through\n   certificate fingerprint verification using fingerprints
        configured in\n   the snmpTlstmCertToTSNTable.  Afterward, the server will
        determine\n   the identity of the remote entity using the following procedures.\n
        \  The (D)TLS server identifies the authenticated identity from the\n   (D)TLS
        client's principal certificate using configuration information\n   from the
        snmpTlstmCertToTSNTable mapping table.  The (D)TLS server\n   MUST request
        and expect a certificate from the client and MUST NOT\n   accept SNMP messages
        over the (D)TLS connection until the client has\n   sent a certificate and
        it has been authenticated.  The resulting\n   derived tmSecurityName is recorded
        in the tmStateReference cache as\n   tmSecurityName.  The details of the lookup
        process are fully\n   described in the DESCRIPTION clause of the snmpTlstmCertToTSNTable\n
        \  MIB object.  If any verification fails in any way (for example,\n   because
        of failures in cryptographic verification or because of the\n   lack of an
        appropriate row in the snmpTlstmCertToTSNTable), then the\n   session establishment
        MUST fail, and the\n   snmpTlstmSessionInvalidClientCertificates object is
        incremented.  If\n   the session cannot be opened for any reason at all, including\n
        \  cryptographic verification failures, then the\n   snmpTlstmSessionOpenErrors
        counter is incremented and processing\n   stops.\n   Servers that wish to
        support multiple principals at a particular port\n   SHOULD make use of a
        (D)TLS extension that allows server-side\n   principal selection like the
        Server Name Indication extension defined\n   in Section 3.1 of [RFC4366].
        \ Supporting this will allow, for\n   example, sending notifications to a
        specific principal at a given TCP\n   or UDP port.\n"
      title: 5.3.2.  Accepting a Session as a Server
    title: 5.3.  Establishing or Accepting a Session
  - contents:
    - "5.4.  Closing a Session\n   The TLS Transport Model provides the following
      primitive to close a\n   session:\n   statusInformation =\n   closeSession(\n
      \  IN  tmSessionID        -- session ID of the session to be closed\n   )\n
      \  The following describes the procedure to follow to close a session\n   between
      a client and server.  This process is followed by any SNMP\n   engine closing
      the corresponding SNMP session.\n   1)  Increment either the snmpTlstmSessionClientCloses
      or the\n       snmpTlstmSessionServerCloses counter as appropriate.\n   2)  Look
      up the session using the tmSessionID.\n   3)  If there is no open session associated
      with the tmSessionID, then\n       closeSession processing is completed.\n   4)
      \ Have (D)TLS close the specified connection.  This MUST include\n       sending
      a close_notify TLS Alert to inform the other side that\n       session cleanup
      may be performed.\n"
    title: 5.4.  Closing a Session
  title: 5.  Elements of Procedure
- contents:
  - "6.  MIB Module Overview\n   This MIB module provides management of the TLS Transport
    Model.  It\n   defines needed textual conventions, statistical counters,\n   notifications,
    and configuration infrastructure necessary for session\n   establishment.  Example
    usage of the configuration tables can be\n   found in Appendix A.\n"
  - contents:
    - "6.1.  Structure of the MIB Module\n   Objects in this MIB module are arranged
      into subtrees.  Each subtree\n   is organized as a set of related objects.  The
      overall structure and\n   assignment of objects to their subtrees, and the intended
      purpose of\n   each subtree, is shown below.\n"
    title: 6.1.  Structure of the MIB Module
  - contents:
    - "6.2.  Textual Conventions\n   Generic and Common Textual Conventions used in
      this module can be\n   found summarized at http://www.ops.ietf.org/mib-common-tcs.html.\n
      \  This module defines the following new Textual Conventions:\n   o  A new TransportAddress
      format for describing (D)TLS connection\n      addressing requirements.\n   o
      \ A certificate fingerprint allowing MIB module objects to\n      generically
      refer to a stored X.509 certificate using a\n      cryptographic hash as a reference
      pointer.\n"
    title: 6.2.  Textual Conventions
  - contents:
    - "6.3.  Statistical Counters\n   The SNMP-TLS-TM-MIB defines counters that provide
      network management\n   stations with information about session usage and potential
      errors\n   that a device may be experiencing.\n"
    title: 6.3.  Statistical Counters
  - contents:
    - "6.4.  Configuration Tables\n   The SNMP-TLS-TM-MIB defines configuration tables
      that an\n   administrator can use for configuring a device for sending and\n
      \  receiving SNMP messages over (D)TLS.  In particular, there are MIB\n   tables
      that extend the SNMP-TARGET-MIB for configuring (D)TLS\n   certificate usage
      and a MIB table for mapping incoming (D)TLS client\n   certificates to SNMPv3
      tmSecurityNames.\n"
    - contents:
      - "6.4.1.  Notifications\n   The SNMP-TLS-TM-MIB defines notifications to alert
        management\n   stations when a (D)TLS connection fails because a server's
        presented\n   certificate did not meet an expected value\n   (snmpTlstmServerCertificateUnknown)
        or because cryptographic\n   validation failed (snmpTlstmServerInvalidCertificate).\n"
      title: 6.4.1.  Notifications
    title: 6.4.  Configuration Tables
  - contents:
    - "6.5.  Relationship to Other MIB Modules\n   Some management objects defined
      in other MIB modules are applicable\n   to an entity implementing the TLS Transport
      Model.  In particular, it\n   is assumed that an entity implementing the SNMP-TLS-TM-MIB
      will\n   implement the SNMPv2-MIB [RFC3418], the SNMP-FRAMEWORK-MIB [RFC3411],\n
      \  the SNMP-TARGET-MIB [RFC3413], the SNMP-NOTIFICATION-MIB [RFC3413],\n   and
      the SNMP-VIEW-BASED-ACM-MIB [RFC3415].\n   The SNMP-TLS-TM-MIB module contained
      in this document is for managing\n   TLS Transport Model information.\n"
    - contents:
      - "6.5.1.  MIB Modules Required for IMPORTS\n   The SNMP-TLS-TM-MIB module imports
        items from SNMPv2-SMI [RFC2578],\n   SNMPv2-TC [RFC2579], SNMP-FRAMEWORK-MIB
        [RFC3411], SNMP-TARGET-MIB\n   [RFC3413], and SNMPv2-CONF [RFC2580].\n"
      title: 6.5.1.  MIB Modules Required for IMPORTS
    title: 6.5.  Relationship to Other MIB Modules
  title: 6.  MIB Module Overview
- contents:
  - '7.  MIB Module Definition

    '
  - 'SNMP-TLS-TM-MIB DEFINITIONS ::= BEGIN

    '
  - "IMPORTS\n    MODULE-IDENTITY, OBJECT-TYPE,\n    OBJECT-IDENTITY, mib-2, snmpDomains,\n
    \   Counter32, Unsigned32, Gauge32, NOTIFICATION-TYPE\n      FROM SNMPv2-SMI                 --
    RFC 2578 or any update thereof\n    TEXTUAL-CONVENTION, TimeStamp, RowStatus,
    StorageType,\n    AutonomousType\n      FROM SNMPv2-TC                  -- RFC
    2579 or any update thereof\n    MODULE-COMPLIANCE, OBJECT-GROUP, NOTIFICATION-GROUP\n
    \     FROM SNMPv2-CONF                -- RFC 2580 or any update thereof\n    SnmpAdminString\n
    \     FROM SNMP-FRAMEWORK-MIB         -- RFC 3411 or any update thereof\n    snmpTargetParamsName,
    snmpTargetAddrName\n      FROM SNMP-TARGET-MIB            -- RFC 3413 or any update
    thereof\n    ;\n"
  - "snmpTlstmMIB MODULE-IDENTITY\n    LAST-UPDATED \"201107190000Z\"\n    ORGANIZATION
    \"ISMS Working Group\"\n    CONTACT-INFO \"WG-EMail:   isms@lists.ietf.org\n                  Subscribe:
    \ isms-request@lists.ietf.org\n                  Chairs:\n                     Juergen
    Schoenwaelder\n                     Jacobs University Bremen\n                     Campus
    Ring 1\n                     28725 Bremen\n                     Germany\n                     +49
    421 200-3587\n                     j.schoenwaelder@jacobs-university.de\n                     Russ
    Mundy\n                     SPARTA, Inc.\n                     7110 Samuel Morse
    Drive\n                     Columbia, MD  21046\n                     USA\n                  Editor:\n
    \                    Wes Hardaker\n                     SPARTA, Inc.\n                     P.O.
    Box 382\n                     Davis, CA  95617\n                     USA\n                     ietf@hardakers.net\n
    \                 \"\n    DESCRIPTION  \"\n        The TLS Transport Model MIB\n
    \       Copyright (c) 2010-2011 IETF Trust and the persons identified\n        as
    authors of the code.  All rights reserved.\n        Redistribution and use in
    source and binary forms, with or\n        without modification, is permitted pursuant
    to, and subject\n        to the license terms contained in, the Simplified BSD
    License\n        set forth in Section 4.c of the IETF Trust's Legal Provisions\n
    \       Relating to IETF Documents\n        (http://trustee.ietf.org/license-info).\"\n
    \      REVISION     \"201107190000Z\"\n       DESCRIPTION  \"This version of this
    MIB module is part of\n                     RFC 6353; see the RFC itself for full
    legal\n                     notices.  The only change was to introduce\n                     new
    wording to reflect require changes for\n                     IDNA addresses in
    the SnmpTLSAddress TC.\"\n       REVISION     \"201005070000Z\"\n       DESCRIPTION
    \ \"This version of this MIB module is part of\n                     RFC 5953;
    see the RFC itself for full legal\n                     notices.\"\n    ::= {
    mib-2 198 }\n"
  - '-- ************************************************

    '
  - '-- subtrees of the SNMP-TLS-TM-MIB

    '
  - '-- ************************************************

    '
  - 'snmpTlstmNotifications OBJECT IDENTIFIER ::= { snmpTlstmMIB 0 }

    '
  - 'snmpTlstmIdentities    OBJECT IDENTIFIER ::= { snmpTlstmMIB 1 }

    '
  - 'snmpTlstmObjects       OBJECT IDENTIFIER ::= { snmpTlstmMIB 2 }

    '
  - 'snmpTlstmConformance   OBJECT IDENTIFIER ::= { snmpTlstmMIB 3 }

    '
  - '-- ************************************************

    '
  - '-- snmpTlstmObjects - Objects

    '
  - '-- ************************************************

    '
  - "snmpTLSTCPDomain OBJECT-IDENTITY\n    STATUS      current\n    DESCRIPTION\n
    \       \"The SNMP over TLS via TCP transport domain.  The\n        corresponding
    transport address is of type SnmpTLSAddress.\n        The securityName prefix
    to be associated with the\n        snmpTLSTCPDomain is 'tls'.  This prefix may
    be used by\n        security models or other components to identify which secure\n
    \       transport infrastructure authenticated a securityName.\"\n    REFERENCE\n
    \     \"RFC 2579: Textual Conventions for SMIv2\"\n    ::= { snmpDomains 8 }\n"
  - "snmpDTLSUDPDomain OBJECT-IDENTITY\n    STATUS      current\n    DESCRIPTION\n
    \       \"The SNMP over DTLS via UDP transport domain.  The\n        corresponding
    transport address is of type SnmpTLSAddress.\n        The securityName prefix
    to be associated with the\n        snmpDTLSUDPDomain is 'dtls'.  This prefix may
    be used by\n        security models or other components to identify which secure\n
    \       transport infrastructure authenticated a securityName.\"\n    REFERENCE\n
    \     \"RFC 2579: Textual Conventions for SMIv2\"\n    ::= { snmpDomains 9 }\n"
  - "SnmpTLSAddress ::= TEXTUAL-CONVENTION\n    DISPLAY-HINT \"1a\"\n    STATUS       current\n
    \   DESCRIPTION\n        \"Represents an IPv4 address, an IPv6 address, or a\n
    \        US-ASCII-encoded hostname and port number.\n        An IPv4 address must
    be in dotted decimal format followed by a\n        colon ':' (US-ASCII character
    0x3A) and a decimal port number\n        in US-ASCII.\n        An IPv6 address
    must be a colon-separated format (as described\n        in RFC 5952), surrounded
    by square brackets ('[', US-ASCII\n        character 0x5B, and ']', US-ASCII character
    0x5D), followed by\n        a colon ':' (US-ASCII character 0x3A) and a decimal
    port number\n        in US-ASCII.\n        A hostname is always in US-ASCII (as
    per RFC 1123);\n        internationalized hostnames are encoded as A-labels as
    specified\n        in  RFC 5890.  The hostname is followed by a\n        colon
    ':' (US-ASCII character 0x3A) and a decimal port number\n        in US-ASCII.
    \ The name SHOULD be fully qualified whenever\n        possible.\n        Values
    of this textual convention may not be directly usable\n        as transport-layer
    addressing information, and may require\n        run-time resolution.  As such,
    applications that write them\n        must be prepared for handling errors if
    such values are not\n        supported, or cannot be resolved (if resolution occurs
    at the\n        time of the management operation).\n        The DESCRIPTION clause
    of TransportAddress objects that may\n        have SnmpTLSAddress values must
    fully describe how (and\n        when) such names are to be resolved to IP addresses
    and vice\n        versa.\n        This textual convention SHOULD NOT be used directly
    in object\n        definitions since it restricts addresses to a specific\n        format.
    \ However, if it is used, it MAY be used either on its\n        own or in conjunction
    with TransportAddressType or\n        TransportDomain as a pair.\n        When
    this textual convention is used as a syntax of an index\n        object, there
    may be issues with the limit of 128\n        sub-identifiers specified in SMIv2
    (STD 58).  It is RECOMMENDED\n        that all MIB documents using this textual
    convention make\n        explicit any limitations on index component lengths that\n
    \       management software must observe.  This may be done either by\n        including
    SIZE constraints on the index components or by\n        specifying applicable
    constraints in the conceptual row\n        DESCRIPTION clause or in the surrounding
    documentation.\"\n    REFERENCE\n      \"RFC 1123: Requirements for Internet Hosts
    - Application and\n                 Support\n       RFC 5890: Internationalized
    Domain Names for Applications (IDNA):\n                 Definitions and Document
    Framework\n       RFC 5952: A Recommendation for IPv6 Address Text Representation\n
    \     \"\n    SYNTAX       OCTET STRING (SIZE (1..255))\n"
  - "SnmpTLSFingerprint ::= TEXTUAL-CONVENTION\n    DISPLAY-HINT \"1x:1x\"\n    STATUS
    \      current\n    DESCRIPTION\n       \"A fingerprint value that can be used
    to uniquely reference\n       other data of potentially arbitrary length.\n       An
    SnmpTLSFingerprint value is composed of a 1-octet hashing\n       algorithm identifier
    followed by the fingerprint value.  The\n       octet value encoded is taken from
    the IANA TLS HashAlgorithm\n       Registry (RFC 5246).  The remaining octets
    are filled using the\n       results of the hashing algorithm.\n       This TEXTUAL-CONVENTION
    allows for a zero-length (blank)\n       SnmpTLSFingerprint value for use in tables
    where the\n       fingerprint value may be optional.  MIB definitions or\n       implementations
    may refuse to accept a zero-length value as\n       appropriate.\"\n       REFERENCE
    \"RFC 5246: The Transport Layer\n                  Security (TLS) Protocol Version
    1.2\n                  http://www.iana.org/assignments/tls-parameters/\n       \"\n
    \   SYNTAX OCTET STRING (SIZE (0..255))\n"
  - '-- Identities for use in the snmpTlstmCertToTSNTable

    '
  - "snmpTlstmCertToTSNMIdentities OBJECT IDENTIFIER\n    ::= { snmpTlstmIdentities
    1 }\n"
  - "snmpTlstmCertSpecified OBJECT-IDENTITY\n    STATUS        current\n    DESCRIPTION
    \ \"Directly specifies the tmSecurityName to be used for\n                  this
    certificate.  The value of the tmSecurityName\n                  to use is specified
    in the snmpTlstmCertToTSNData\n                  column.  The snmpTlstmCertToTSNData
    column must\n                  contain a non-zero length SnmpAdminString compliant\n
    \                 value or the mapping described in this row must be\n                  considered
    a failure.\"\n    ::= { snmpTlstmCertToTSNMIdentities 1 }\n"
  - "snmpTlstmCertSANRFC822Name OBJECT-IDENTITY\n    STATUS        current\n    DESCRIPTION
    \ \"Maps a subjectAltName's rfc822Name to a\n                  tmSecurityName.
    \ The local part of the rfc822Name is\n                  passed unaltered but
    the host-part of the name must\n                  be passed in lowercase.  This
    mapping results in a\n                  1:1 correspondence between equivalent
    subjectAltName\n                  rfc822Name values and tmSecurityName values
    except\n                  that the host-part of the name MUST be passed in\n                  lowercase.\n
    \                 Example rfc822Name Field:  FooBar@Example.COM\n                  is
    mapped to tmSecurityName: FooBar@example.com.\"\n    ::= { snmpTlstmCertToTSNMIdentities
    2 }\n"
  - "snmpTlstmCertSANDNSName OBJECT-IDENTITY\n    STATUS        current\n    DESCRIPTION
    \ \"Maps a subjectAltName's dNSName to a\n                  tmSecurityName after
    first converting it to all\n                  lowercase (RFC 5280 does not specify
    converting to\n                  lowercase so this involves an extra step).  This\n
    \                 mapping results in a 1:1 correspondence between\n                  subjectAltName
    dNSName values and the tmSecurityName\n                  values.\"\n    REFERENCE
    \"RFC 5280 - Internet X.509 Public Key Infrastructure\n                         Certificate
    and Certificate Revocation\n                         List (CRL) Profile.\"\n    ::=
    { snmpTlstmCertToTSNMIdentities 3 }\n"
  - "snmpTlstmCertSANIpAddress OBJECT-IDENTITY\n    STATUS        current\n    DESCRIPTION
    \ \"Maps a subjectAltName's iPAddress to a\n                  tmSecurityName by
    transforming the binary encoded\n                  address as follows:\n                  1)
    for IPv4, the value is converted into a\n                     decimal-dotted quad
    address (e.g., '192.0.2.1').\n                  2) for IPv6 addresses, the value
    is converted into a\n                     32-character all lowercase hexadecimal
    string\n                     without any colon separators.\n                  This
    mapping results in a 1:1 correspondence between\n                  subjectAltName
    iPAddress values and the\n                  tmSecurityName values.\n                  The
    resulting length of an encoded IPv6 address is\n                  the maximum
    length supported by the View-Based\n                  Access Control Model (VACM).
    \ Using both the\n                  Transport Security Model's support for transport\n
    \                 prefixes (see the SNMP-TSM-MIB's\n                  snmpTsmConfigurationUsePrefix
    object for details)\n                  will result in securityName lengths that
    exceed what\n                  VACM can handle.\"\n    ::= { snmpTlstmCertToTSNMIdentities
    4 }\n"
  - "snmpTlstmCertSANAny OBJECT-IDENTITY\n    STATUS        current\n    DESCRIPTION
    \ \"Maps any of the following fields using the\n                  corresponding
    mapping algorithms:\n                  |------------+----------------------------|\n
    \                 | Type       | Algorithm                  |\n                  |------------+----------------------------|\n
    \                 | rfc822Name | snmpTlstmCertSANRFC822Name |\n                  |
    dNSName    | snmpTlstmCertSANDNSName    |\n                  | iPAddress  | snmpTlstmCertSANIpAddress
    \ |\n                  |------------+----------------------------|\n                  The
    first matching subjectAltName value found in the\n                  certificate
    of the above types MUST be used when\n                  deriving the tmSecurityName.
    \ The mapping algorithm\n                  specified in the 'Algorithm' column
    MUST be used to\n                  derive the tmSecurityName.\n                  This
    mapping results in a 1:1 correspondence between\n                  subjectAltName
    values and tmSecurityName values.  The\n                  three sub-mapping algorithms
    produced by this\n                  combined algorithm cannot produce conflicting\n
    \                 results between themselves.\"\n    ::= { snmpTlstmCertToTSNMIdentities
    5 }\n"
  - "snmpTlstmCertCommonName OBJECT-IDENTITY\n    STATUS        current\n    DESCRIPTION
    \ \"Maps a certificate's CommonName to a tmSecurityName\n                  after
    converting it to a UTF-8 encoding.  The usage\n                  of CommonNames
    is deprecated and users are\n                  encouraged to use subjectAltName
    mapping methods\n                  instead.  This mapping results in a 1:1\n                  correspondence
    between certificate CommonName values\n                  and tmSecurityName values.\"\n
    \   ::= { snmpTlstmCertToTSNMIdentities 6 }\n"
  - '-- The snmpTlstmSession Group

    '
  - 'snmpTlstmSession           OBJECT IDENTIFIER ::= { snmpTlstmObjects 1 }

    '
  - "snmpTlstmSessionOpens  OBJECT-TYPE\n    SYNTAX       Counter32\n    MAX-ACCESS
    \  read-only\n    STATUS       current\n    DESCRIPTION\n       \"The number of
    times an openSession() request has been executed\n       as a (D)TLS client, regardless
    of whether it succeeded or\n       failed.\"\n    ::= { snmpTlstmSession 1 }\n"
  - "snmpTlstmSessionClientCloses  OBJECT-TYPE\n    SYNTAX       Counter32\n    MAX-ACCESS
    \  read-only\n    STATUS       current\n    DESCRIPTION\n        \"The number
    of times a closeSession() request has been\n        executed as a (D)TLS client,
    regardless of whether it\n        succeeded or failed.\"\n    ::= { snmpTlstmSession
    2 }\n"
  - "snmpTlstmSessionOpenErrors  OBJECT-TYPE\n    SYNTAX       Counter32\n    MAX-ACCESS
    \  read-only\n    STATUS       current\n    DESCRIPTION\n        \"The number
    of times an openSession() request failed to open a\n        session as a (D)TLS
    client, for any reason.\"\n    ::= { snmpTlstmSession 3 }\n"
  - "snmpTlstmSessionAccepts  OBJECT-TYPE\n    SYNTAX       Counter32\n    MAX-ACCESS
    \  read-only\n    STATUS       current\n    DESCRIPTION\n       \"The number of
    times a (D)TLS server has accepted a new\n       connection from a client and
    has received at least one SNMP\n       message through it.\"\n    ::= { snmpTlstmSession
    4 }\n"
  - "snmpTlstmSessionServerCloses  OBJECT-TYPE\n    SYNTAX       Counter32\n    MAX-ACCESS
    \  read-only\n    STATUS       current\n    DESCRIPTION\n        \"The number
    of times a closeSession() request has been\n        executed as a (D)TLS server,
    regardless of whether it\n        succeeded or failed.\"\n    ::= { snmpTlstmSession
    5 }\n"
  - "snmpTlstmSessionNoSessions  OBJECT-TYPE\n    SYNTAX       Counter32\n    MAX-ACCESS
    \  read-only\n    STATUS       current\n    DESCRIPTION\n        \"The number
    of times an outgoing message was dropped because\n        the session associated
    with the passed tmStateReference was no\n        longer (or was never) available.\"\n
    \   ::= { snmpTlstmSession 6 }\n"
  - "snmpTlstmSessionInvalidClientCertificates OBJECT-TYPE\n    SYNTAX       Counter32\n
    \   MAX-ACCESS   read-only\n    STATUS       current\n    DESCRIPTION\n        \"The
    number of times an incoming session was not established\n        on a (D)TLS server
    because the presented client certificate\n        was invalid.  Reasons for invalidation
    include, but are not\n        limited to, cryptographic validation failures or
    lack of a\n        suitable mapping row in the snmpTlstmCertToTSNTable.\"\n    ::=
    { snmpTlstmSession 7 }\n"
  - "snmpTlstmSessionUnknownServerCertificate OBJECT-TYPE\n    SYNTAX       Counter32\n
    \   MAX-ACCESS   read-only\n    STATUS       current\n    DESCRIPTION\n        \"The
    number of times an outgoing session was not established\n         on a (D)TLS
    client because the server certificate presented\n         by an SNMP over (D)TLS
    server was invalid because no\n         configured fingerprint or Certification
    Authority (CA) was\n         acceptable to validate it.\n         This may result
    because there was no entry in the\n         snmpTlstmAddrTable or because no path
    could be found to a\n         known CA.\"\n    ::= { snmpTlstmSession 8 }\n"
  - "snmpTlstmSessionInvalidServerCertificates OBJECT-TYPE\n    SYNTAX       Counter32\n
    \   MAX-ACCESS   read-only\n    STATUS       current\n    DESCRIPTION\n        \"The
    number of times an outgoing session was not established\n         on a (D)TLS
    client because the server certificate presented\n         by an SNMP over (D)TLS
    server could not be validated even if\n         the fingerprint or expected validation
    path was known.  That\n         is, a cryptographic validation error occurred
    during\n         certificate validation processing.\n        Reasons for invalidation
    include, but are not\n        limited to, cryptographic validation failures.\"\n
    \   ::= { snmpTlstmSession 9 }\n"
  - "snmpTlstmSessionInvalidCaches OBJECT-TYPE\n    SYNTAX       Counter32\n    MAX-ACCESS
    \  read-only\n    STATUS       current\n    DESCRIPTION\n        \"The number
    of outgoing messages dropped because the\n        tmStateReference referred to
    an invalid cache.\"\n    ::= { snmpTlstmSession 10 }\n"
  - '-- Configuration Objects

    '
  - 'snmpTlstmConfig             OBJECT IDENTIFIER ::= { snmpTlstmObjects 2 }

    '
  - '-- Certificate mapping

    '
  - 'snmpTlstmCertificateMapping OBJECT IDENTIFIER ::= { snmpTlstmConfig 1 }

    '
  - "snmpTlstmCertToTSNCount OBJECT-TYPE\n    SYNTAX      Gauge32\n    MAX-ACCESS
    \ read-only\n    STATUS      current\n    DESCRIPTION\n        \"A count of the
    number of entries in the\n        snmpTlstmCertToTSNTable.\"\n    ::= { snmpTlstmCertificateMapping
    1 }\n"
  - "snmpTlstmCertToTSNTableLastChanged OBJECT-TYPE\n    SYNTAX      TimeStamp\n    MAX-ACCESS
    \ read-only\n    STATUS      current\n    DESCRIPTION\n        \"The value of
    sysUpTime.0 when the snmpTlstmCertToTSNTable was\n        last modified through
    any means, or 0 if it has not been\n        modified since the command responder
    was started.\"\n    ::= { snmpTlstmCertificateMapping 2 }\n"
  - "snmpTlstmCertToTSNTable OBJECT-TYPE\n    SYNTAX      SEQUENCE OF SnmpTlstmCertToTSNEntry\n
    \   MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"This
    table is used by a (D)TLS server to map the (D)TLS\n        client's presented
    X.509 certificate to a tmSecurityName.\n        On an incoming (D)TLS/SNMP connection,
    the client's presented\n        certificate must either be validated based on
    an established\n        trust anchor, or it must directly match a fingerprint
    in this\n        table.  This table does not provide any mechanisms for\n        configuring
    the trust anchors; the transfer of any needed\n        trusted certificates for
    path validation is expected to occur\n        through an out-of-band transfer.\n
    \       Once the certificate has been found acceptable (either by path\n        validation
    or directly matching a fingerprint in this table),\n        this table is consulted
    to determine the appropriate\n        tmSecurityName to identify with the remote
    connection.  This\n        is done by considering each active row from this table
    in\n        prioritized order according to its snmpTlstmCertToTSNID value.\n        Each
    row's snmpTlstmCertToTSNFingerprint value determines\n        whether the row
    is a match for the incoming connection:\n            1) If the row's snmpTlstmCertToTSNFingerprint
    value\n               identifies the presented certificate, then consider the\n
    \              row as a successful match.\n            2) If the row's snmpTlstmCertToTSNFingerprint
    value\n               identifies a locally held copy of a trusted CA\n               certificate
    and that CA certificate was used to\n               validate the path to the presented
    certificate, then\n               consider the row as a successful match.\n        Once
    a matching row has been found, the\n        snmpTlstmCertToTSNMapType value can
    be used to determine how\n        the tmSecurityName to associate with the session
    should be\n        determined.  See the snmpTlstmCertToTSNMapType column's\n        DESCRIPTION
    for details on determining the tmSecurityName\n        value.  If it is impossible
    to determine a tmSecurityName from\n        the row's data combined with the data
    presented in the\n        certificate, then additional rows MUST be searched looking
    for\n        another potential match.  If a resulting tmSecurityName mapped\n
    \       from a given row is not compatible with the needed\n        requirements
    of a tmSecurityName (e.g., VACM imposes a\n        32-octet-maximum length and
    the certificate derived\n        securityName could be longer), then it must be
    considered an\n        invalid match and additional rows MUST be searched looking
    for\n        another potential match.\n        If no matching and valid row can
    be found, the connection MUST\n        be closed and SNMP messages MUST NOT be
    accepted over it.\n        Missing values of snmpTlstmCertToTSNID are acceptable
    and\n        implementations should continue to the next highest numbered\n        row.
    \ It is recommended that administrators skip index values\n        to leave room
    for the insertion of future rows (for example,\n        use values of 10 and 20
    when creating initial rows).\n        Users are encouraged to make use of certificates
    with\n        subjectAltName fields that can be used as tmSecurityNames so\n        that
    a single root CA certificate can allow all child\n        certificate's subjectAltName
    to map directly to a\n        tmSecurityName via a 1:1 transformation.  However,
    this table\n        is flexible to allow for situations where existing deployed\n
    \       certificate infrastructures do not provide adequate\n        subjectAltName
    values for use as tmSecurityNames.\n        Certificates may also be mapped to
    tmSecurityNames using the\n        CommonName portion of the Subject field.  However,
    the usage\n        of the CommonName field is deprecated and thus this usage is\n
    \       NOT RECOMMENDED.  Direct mapping from each individual\n        certificate
    fingerprint to a tmSecurityName is also possible\n        but requires one entry
    in the table per tmSecurityName and\n        requires more management operations
    to completely configure a\n        device.\"\n    ::= { snmpTlstmCertificateMapping
    3 }\n"
  - "snmpTlstmCertToTSNEntry OBJECT-TYPE\n    SYNTAX      SnmpTlstmCertToTSNEntry\n
    \   MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"A
    row in the snmpTlstmCertToTSNTable that specifies a mapping\n        for an incoming
    (D)TLS certificate to a tmSecurityName to use\n        for a connection.\"\n    INDEX
    \  { snmpTlstmCertToTSNID }\n    ::= { snmpTlstmCertToTSNTable 1 }\n"
  - "SnmpTlstmCertToTSNEntry ::= SEQUENCE {\n    snmpTlstmCertToTSNID           Unsigned32,\n
    \   snmpTlstmCertToTSNFingerprint  SnmpTLSFingerprint,\n    snmpTlstmCertToTSNMapType
    \     AutonomousType,\n    snmpTlstmCertToTSNData         OCTET STRING,\n    snmpTlstmCertToTSNStorageType
    \ StorageType,\n    snmpTlstmCertToTSNRowStatus    RowStatus\n"
  - '}

    '
  - "snmpTlstmCertToTSNID OBJECT-TYPE\n    SYNTAX      Unsigned32 (1..4294967295)\n
    \   MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"A
    unique, prioritized index for the given entry.  Lower\n        numbers indicate
    a higher priority.\"\n    ::= { snmpTlstmCertToTSNEntry 1 }\n"
  - "snmpTlstmCertToTSNFingerprint OBJECT-TYPE\n    SYNTAX      SnmpTLSFingerprint
    (SIZE(1..255))\n    MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n
    \       \"A cryptographic hash of an X.509 certificate.  The results of\n        a
    successful matching fingerprint to either the trusted CA in\n        the certificate
    validation path or to the certificate itself\n        is dictated by the snmpTlstmCertToTSNMapType
    column.\"\n    ::= { snmpTlstmCertToTSNEntry 2 }\n"
  - "snmpTlstmCertToTSNMapType OBJECT-TYPE\n    SYNTAX      AutonomousType\n    MAX-ACCESS
    \ read-create\n    STATUS      current\n    DESCRIPTION\n        \"Specifies the
    mapping type for deriving a tmSecurityName from\n        a certificate.  Details
    for mapping of a particular type SHALL\n        be specified in the DESCRIPTION
    clause of the OBJECT-IDENTITY\n        that describes the mapping.  If a mapping
    succeeds it will\n        return a tmSecurityName for use by the TLSTM model and\n
    \       processing stops.\n        If the resulting mapped value is not compatible
    with the\n        needed requirements of a tmSecurityName (e.g., VACM imposes
    a\n        32-octet-maximum length and the certificate derived\n        securityName
    could be longer), then future rows MUST be\n        searched for additional snmpTlstmCertToTSNFingerprint
    matches\n        to look for a mapping that succeeds.\n        Suitable values
    for assigning to this object that are defined\n        within the SNMP-TLS-TM-MIB
    can be found in the\n        snmpTlstmCertToTSNMIdentities portion of the MIB
    tree.\"\n    DEFVAL { snmpTlstmCertSpecified }\n    ::= { snmpTlstmCertToTSNEntry
    3 }\n"
  - "snmpTlstmCertToTSNData OBJECT-TYPE\n    SYNTAX      OCTET STRING (SIZE(0..1024))\n
    \   MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n        \"Auxiliary
    data used as optional configuration information for\n        a given mapping specified
    by the snmpTlstmCertToTSNMapType\n        column.  Only some mapping systems will
    make use of this\n        column.  The value in this column MUST be ignored for
    any\n        mapping type that does not require data present in this\n        column.\"\n
    \   DEFVAL { \"\" }\n    ::= { snmpTlstmCertToTSNEntry 4 }\n"
  - "snmpTlstmCertToTSNStorageType OBJECT-TYPE\n    SYNTAX       StorageType\n    MAX-ACCESS
    \  read-create\n    STATUS       current\n    DESCRIPTION\n        \"The storage
    type for this conceptual row.  Conceptual rows\n        having the value 'permanent'
    need not allow write-access to\n        any columnar objects in the row.\"\n    DEFVAL
    \     { nonVolatile }\n    ::= { snmpTlstmCertToTSNEntry 5 }\n"
  - "snmpTlstmCertToTSNRowStatus OBJECT-TYPE\n    SYNTAX      RowStatus\n    MAX-ACCESS
    \ read-create\n    STATUS      current\n    DESCRIPTION\n        \"The status
    of this conceptual row.  This object may be used\n        to create or remove
    rows from this table.\n        To create a row in this table, an administrator
    must set this\n        object to either createAndGo(4) or createAndWait(5).\n
    \       Until instances of all corresponding columns are appropriately\n        configured,
    the value of the corresponding instance of the\n        snmpTlstmParamsRowStatus
    column is notReady(3).\n        In particular, a newly created row cannot be made
    active until\n        the corresponding snmpTlstmCertToTSNFingerprint,\n        snmpTlstmCertToTSNMapType,
    and snmpTlstmCertToTSNData columns\n        have been set.\n        The following
    objects may not be modified while the\n        value of this object is active(1):\n
    \           - snmpTlstmCertToTSNFingerprint\n            - snmpTlstmCertToTSNMapType\n
    \           - snmpTlstmCertToTSNData\n        An attempt to set these objects
    while the value of\n        snmpTlstmParamsRowStatus is active(1) will result
    in\n        an inconsistentValue error.\"\n    ::= { snmpTlstmCertToTSNEntry 6
    }\n"
  - '-- Maps tmSecurityNames to certificates for use by the SNMP-TARGET-MIB

    '
  - "snmpTlstmParamsCount OBJECT-TYPE\n    SYNTAX      Gauge32\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n        \"A count of the number of entries
    in the snmpTlstmParamsTable.\"\n    ::= { snmpTlstmCertificateMapping 4 }\n"
  - "snmpTlstmParamsTableLastChanged OBJECT-TYPE\n    SYNTAX      TimeStamp\n    MAX-ACCESS
    \ read-only\n    STATUS      current\n    DESCRIPTION\n        \"The value of
    sysUpTime.0 when the snmpTlstmParamsTable\n        was last modified through any
    means, or 0 if it has not been\n        modified since the command responder was
    started.\"\n    ::= { snmpTlstmCertificateMapping 5 }\n"
  - "snmpTlstmParamsTable OBJECT-TYPE\n    SYNTAX      SEQUENCE OF SnmpTlstmParamsEntry\n
    \   MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"This
    table is used by a (D)TLS client when a (D)TLS\n        connection is being set
    up using an entry in the\n        SNMP-TARGET-MIB.  It extends the SNMP-TARGET-MIB's\n
    \       snmpTargetParamsTable with a fingerprint of a certificate to\n        use
    when establishing such a (D)TLS connection.\"\n    ::= { snmpTlstmCertificateMapping
    6 }\n"
  - "snmpTlstmParamsEntry OBJECT-TYPE\n    SYNTAX      SnmpTlstmParamsEntry\n    MAX-ACCESS
    \ not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"A conceptual
    row containing a fingerprint hash of a locally\n        held certificate for a
    given snmpTargetParamsEntry.  The\n        values in this row should be ignored
    if the connection that\n        needs to be established, as indicated by the SNMP-TARGET-MIB\n
    \       infrastructure, is not a certificate and (D)TLS based\n        connection.
    \ The connection SHOULD NOT be established if the\n        certificate fingerprint
    stored in this entry does not point to\n        a valid locally held certificate
    or if it points to an\n        unusable certificate (such as might happen when
    the\n        certificate's expiration date has been reached).\"\n    INDEX    {
    IMPLIED snmpTargetParamsName }\n    ::= { snmpTlstmParamsTable 1 }\n"
  - "SnmpTlstmParamsEntry ::= SEQUENCE {\n    snmpTlstmParamsClientFingerprint SnmpTLSFingerprint,\n
    \   snmpTlstmParamsStorageType       StorageType,\n    snmpTlstmParamsRowStatus
    \        RowStatus\n"
  - '}

    '
  - "snmpTlstmParamsClientFingerprint OBJECT-TYPE\n    SYNTAX      SnmpTLSFingerprint\n
    \   MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n        \"This
    object stores the hash of the public portion of a\n        locally held X.509
    certificate.  The X.509 certificate, its\n        public key, and the corresponding
    private key will be used\n        when initiating a (D)TLS connection as a (D)TLS
    client.\"\n    ::= { snmpTlstmParamsEntry 1 }\n"
  - "snmpTlstmParamsStorageType OBJECT-TYPE\n    SYNTAX       StorageType\n    MAX-ACCESS
    \  read-create\n    STATUS       current\n    DESCRIPTION\n        \"The storage
    type for this conceptual row.  Conceptual rows\n        having the value 'permanent'
    need not allow write-access to\n        any columnar objects in the row.\"\n    DEFVAL
    \     { nonVolatile }\n    ::= { snmpTlstmParamsEntry 2 }\n"
  - "snmpTlstmParamsRowStatus OBJECT-TYPE\n    SYNTAX      RowStatus\n    MAX-ACCESS
    \ read-create\n    STATUS      current\n    DESCRIPTION\n        \"The status
    of this conceptual row.  This object may be used\n        to create or remove
    rows from this table.\n        To create a row in this table, an administrator
    must set this\n        object to either createAndGo(4) or createAndWait(5).\n
    \       Until instances of all corresponding columns are appropriately\n        configured,
    the value of the corresponding instance of the\n        snmpTlstmParamsRowStatus
    column is notReady(3).\n        In particular, a newly created row cannot be made
    active until\n        the corresponding snmpTlstmParamsClientFingerprint column
    has\n        been set.\n        The snmpTlstmParamsClientFingerprint object may
    not be modified\n        while the value of this object is active(1).\n        An
    attempt to set these objects while the value of\n        snmpTlstmParamsRowStatus
    is active(1) will result in\n        an inconsistentValue error.\"\n    ::= {
    snmpTlstmParamsEntry 3 }\n"
  - "snmpTlstmAddrCount OBJECT-TYPE\n    SYNTAX      Gauge32\n    MAX-ACCESS  read-only\n
    \   STATUS      current\n    DESCRIPTION\n        \"A count of the number of entries
    in the snmpTlstmAddrTable.\"\n    ::= { snmpTlstmCertificateMapping 7 }\n"
  - "snmpTlstmAddrTableLastChanged OBJECT-TYPE\n    SYNTAX      TimeStamp\n    MAX-ACCESS
    \ read-only\n    STATUS      current\n    DESCRIPTION\n        \"The value of
    sysUpTime.0 when the snmpTlstmAddrTable\n        was last modified through any
    means, or 0 if it has not been\n        modified since the command responder was
    started.\"\n    ::= { snmpTlstmCertificateMapping 8 }\n"
  - "snmpTlstmAddrTable OBJECT-TYPE\n    SYNTAX      SEQUENCE OF SnmpTlstmAddrEntry\n
    \   MAX-ACCESS  not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"This
    table is used by a (D)TLS client when a (D)TLS\n        connection is being set
    up using an entry in the\n        SNMP-TARGET-MIB.  It extends the SNMP-TARGET-MIB's\n
    \       snmpTargetAddrTable so that the client can verify that the\n        correct
    server has been reached.  This verification can use\n        either a certificate
    fingerprint, or an identity\n        authenticated via certification path validation.\n
    \       If there is an active row in this table corresponding to the\n        entry
    in the SNMP-TARGET-MIB that was used to establish the\n        connection, and
    the row's snmpTlstmAddrServerFingerprint\n        column has non-empty value,
    then the server's presented\n        certificate is compared with the\n        snmpTlstmAddrServerFingerprint
    value (and the\n        snmpTlstmAddrServerIdentity column is ignored).  If the\n
    \       fingerprint matches, the verification has succeeded.  If the\n        fingerprint
    does not match, then the connection MUST be\n        closed.\n        If the server's
    presented certificate has passed\n        certification path validation [RFC5280]
    to a configured\n        trust anchor, and an active row exists with a zero-length\n
    \       snmpTlstmAddrServerFingerprint value, then the\n        snmpTlstmAddrServerIdentity
    column contains the expected\n        host name.  This expected host name is then
    compared against\n        the server's certificate as follows:\n          - Implementations
    MUST support matching the expected host\n          name against a dNSName in the
    subjectAltName extension\n          field and MAY support checking the name against
    the\n          CommonName portion of the subject distinguished name.\n          -
    The '*' (ASCII 0x2a) wildcard character is allowed in the\n          dNSName of
    the subjectAltName extension (and in common\n          name, if used to store
    the host name), but only as the\n          left-most (least significant) DNS label
    in that value.\n          This wildcard matches any left-most DNS label in the\n
    \         server name.  That is, the subject *.example.com matches\n          the
    server names a.example.com and b.example.com, but does\n          not match example.com
    or a.b.example.com.  Implementations\n          MUST support wildcards in certificates
    as specified above,\n          but MAY provide a configuration option to disable
    them.\n          - If the locally configured name is an internationalized\n          domain
    name, conforming implementations MUST convert it to\n          the ASCII Compatible
    Encoding (ACE) format for performing\n          comparisons, as specified in Section
    7 of [RFC5280].\n        If the expected host name fails these conditions then
    the\n        connection MUST be closed.\n        If there is no row in this table
    corresponding to the entry\n        in the SNMP-TARGET-MIB and the server can
    be authorized by\n        another, implementation-dependent means, then the connection\n
    \       MAY still proceed.\"\n    ::= { snmpTlstmCertificateMapping 9 }\n"
  - "snmpTlstmAddrEntry OBJECT-TYPE\n    SYNTAX      SnmpTlstmAddrEntry\n    MAX-ACCESS
    \ not-accessible\n    STATUS      current\n    DESCRIPTION\n        \"A conceptual
    row containing a copy of a certificate's\n        fingerprint for a given snmpTargetAddrEntry.
    \ The values in\n        this row should be ignored if the connection that needs
    to be\n        established, as indicated by the SNMP-TARGET-MIB\n        infrastructure,
    is not a (D)TLS based connection.  If an\n        snmpTlstmAddrEntry exists for
    a given snmpTargetAddrEntry, then\n        the presented server certificate MUST
    match or the connection\n        MUST NOT be established.  If a row in this table
    does not\n        exist to match an snmpTargetAddrEntry row, then the connection\n
    \       SHOULD still proceed if some other certificate validation path\n        algorithm
    (e.g., RFC 5280) can be used.\"\n    INDEX    { IMPLIED snmpTargetAddrName }\n
    \   ::= { snmpTlstmAddrTable 1 }\n"
  - "SnmpTlstmAddrEntry ::= SEQUENCE {\n    snmpTlstmAddrServerFingerprint    SnmpTLSFingerprint,\n
    \   snmpTlstmAddrServerIdentity       SnmpAdminString,\n    snmpTlstmAddrStorageType
    \         StorageType,\n    snmpTlstmAddrRowStatus            RowStatus\n"
  - '}

    '
  - "snmpTlstmAddrServerFingerprint OBJECT-TYPE\n    SYNTAX      SnmpTLSFingerprint\n
    \   MAX-ACCESS  read-create\n    STATUS      current\n    DESCRIPTION\n        \"A
    cryptographic hash of a public X.509 certificate.  This\n        object should
    store the hash of the public X.509 certificate\n        that the remote server
    should present during the (D)TLS\n        connection setup.  The fingerprint of
    the presented\n        certificate and this hash value MUST match exactly or the\n
    \       connection MUST NOT be established.\"\n    DEFVAL { \"\" }\n    ::= {
    snmpTlstmAddrEntry 1 }\n"
  - "snmpTlstmAddrServerIdentity OBJECT-TYPE\n    SYNTAX      SnmpAdminString\n    MAX-ACCESS
    \ read-create\n    STATUS      current\n    DESCRIPTION\n        \"The reference
    identity to check against the identity\n        presented by the remote system.\"\n
    \   DEFVAL { \"\" }\n    ::= { snmpTlstmAddrEntry 2 }\n"
  - "snmpTlstmAddrStorageType OBJECT-TYPE\n    SYNTAX       StorageType\n    MAX-ACCESS
    \  read-create\n    STATUS       current\n    DESCRIPTION\n        \"The storage
    type for this conceptual row.  Conceptual rows\n        having the value 'permanent'
    need not allow write-access to\n        any columnar objects in the row.\"\n    DEFVAL
    \     { nonVolatile }\n    ::= { snmpTlstmAddrEntry 3 }\n"
  - "snmpTlstmAddrRowStatus OBJECT-TYPE\n    SYNTAX      RowStatus\n    MAX-ACCESS
    \ read-create\n    STATUS      current\n    DESCRIPTION\n        \"The status
    of this conceptual row.  This object may be used\n        to create or remove
    rows from this table.\n        To create a row in this table, an administrator
    must set this\n        object to either createAndGo(4) or createAndWait(5).\n
    \       Until instances of all corresponding columns are\n        appropriately
    configured, the value of the\n        corresponding instance of the snmpTlstmAddrRowStatus\n
    \       column is notReady(3).\n        In particular, a newly created row cannot
    be made active until\n        the corresponding snmpTlstmAddrServerFingerprint
    column has been\n        set.\n        Rows MUST NOT be active if the snmpTlstmAddrServerFingerprint\n
    \       column is blank and the snmpTlstmAddrServerIdentity is set to\n        '*'
    since this would insecurely accept any presented\n        certificate.\n        The
    snmpTlstmAddrServerFingerprint object may not be modified\n        while the value
    of this object is active(1).\n        An attempt to set these objects while the
    value of\n        snmpTlstmAddrRowStatus is active(1) will result in\n        an
    inconsistentValue error.\"\n    ::= { snmpTlstmAddrEntry 4 }\n"
  - '-- ************************************************

    '
  - '--  snmpTlstmNotifications - Notifications Information

    '
  - '-- ************************************************

    '
  - "snmpTlstmServerCertificateUnknown NOTIFICATION-TYPE\n    OBJECTS { snmpTlstmSessionUnknownServerCertificate
    }\n    STATUS  current\n    DESCRIPTION\n        \"Notification that the server
    certificate presented by an SNMP\n         over (D)TLS server was invalid because
    no configured\n         fingerprint or CA was acceptable to validate it.  This
    may be\n         because there was no entry in the snmpTlstmAddrTable or\n         because
    no path could be found to known Certification\n         Authority.\n         To
    avoid notification loops, this notification MUST NOT be\n         sent to servers
    that themselves have triggered the\n         notification.\"\n    ::= { snmpTlstmNotifications
    1 }\n"
  - "snmpTlstmServerInvalidCertificate NOTIFICATION-TYPE\n    OBJECTS { snmpTlstmAddrServerFingerprint,\n
    \             snmpTlstmSessionInvalidServerCertificates}\n    STATUS  current\n
    \   DESCRIPTION\n        \"Notification that the server certificate presented
    by an SNMP\n         over (D)TLS server could not be validated even if the\n         fingerprint
    or expected validation path was known.  That is, a\n         cryptographic validation
    error occurred during certificate\n         validation processing.\n         To
    avoid notification loops, this notification MUST NOT be\n         sent to servers
    that themselves have triggered the\n         notification.\"\n    ::= { snmpTlstmNotifications
    2 }\n"
  - '-- ************************************************

    '
  - '-- snmpTlstmCompliances - Conformance Information

    '
  - '-- ************************************************

    '
  - 'snmpTlstmCompliances OBJECT IDENTIFIER ::= { snmpTlstmConformance 1 }

    '
  - 'snmpTlstmGroups OBJECT IDENTIFIER ::= { snmpTlstmConformance 2 }

    '
  - '-- ************************************************

    '
  - '-- Compliance statements

    '
  - '-- ************************************************

    '
  - "snmpTlstmCompliance MODULE-COMPLIANCE\n    STATUS      current\n    DESCRIPTION\n
    \       \"The compliance statement for SNMP engines that support the\n        SNMP-TLS-TM-MIB\"\n
    \   MODULE\n        MANDATORY-GROUPS { snmpTlstmStatsGroup,\n                           snmpTlstmIncomingGroup,\n
    \                          snmpTlstmOutgoingGroup,\n                           snmpTlstmNotificationGroup
    }\n    ::= { snmpTlstmCompliances 1 }\n"
  - '-- ************************************************

    '
  - '-- Units of conformance

    '
  - '-- ************************************************

    '
  - "snmpTlstmStatsGroup OBJECT-GROUP\n    OBJECTS {\n        snmpTlstmSessionOpens,\n
    \       snmpTlstmSessionClientCloses,\n        snmpTlstmSessionOpenErrors,\n        snmpTlstmSessionAccepts,\n
    \       snmpTlstmSessionServerCloses,\n        snmpTlstmSessionNoSessions,\n        snmpTlstmSessionInvalidClientCertificates,\n
    \       snmpTlstmSessionUnknownServerCertificate,\n        snmpTlstmSessionInvalidServerCertificates,\n
    \       snmpTlstmSessionInvalidCaches\n    }\n    STATUS      current\n    DESCRIPTION\n
    \       \"A collection of objects for maintaining\n        statistical information
    of an SNMP engine that\n        implements the SNMP TLS Transport Model.\"\n    ::=
    { snmpTlstmGroups 1 }\n"
  - "snmpTlstmIncomingGroup OBJECT-GROUP\n    OBJECTS {\n        snmpTlstmCertToTSNCount,\n
    \       snmpTlstmCertToTSNTableLastChanged,\n        snmpTlstmCertToTSNFingerprint,\n
    \       snmpTlstmCertToTSNMapType,\n        snmpTlstmCertToTSNData,\n        snmpTlstmCertToTSNStorageType,\n
    \       snmpTlstmCertToTSNRowStatus\n    }\n    STATUS      current\n    DESCRIPTION\n
    \       \"A collection of objects for maintaining\n        incoming connection
    certificate mappings to\n        tmSecurityNames of an SNMP engine that implements
    the\n        SNMP TLS Transport Model.\"\n    ::= { snmpTlstmGroups 2 }\n"
  - "snmpTlstmOutgoingGroup OBJECT-GROUP\n    OBJECTS {\n        snmpTlstmParamsCount,\n
    \       snmpTlstmParamsTableLastChanged,\n        snmpTlstmParamsClientFingerprint,\n
    \       snmpTlstmParamsStorageType,\n        snmpTlstmParamsRowStatus,\n        snmpTlstmAddrCount,\n
    \       snmpTlstmAddrTableLastChanged,\n        snmpTlstmAddrServerFingerprint,\n
    \       snmpTlstmAddrServerIdentity,\n        snmpTlstmAddrStorageType,\n        snmpTlstmAddrRowStatus\n
    \   }\n    STATUS      current\n    DESCRIPTION\n        \"A collection of objects
    for maintaining\n        outgoing connection certificates to use when opening\n
    \       connections as a result of SNMP-TARGET-MIB settings.\"\n    ::= { snmpTlstmGroups
    3 }\n"
  - "snmpTlstmNotificationGroup NOTIFICATION-GROUP\n    NOTIFICATIONS {\n        snmpTlstmServerCertificateUnknown,\n
    \       snmpTlstmServerInvalidCertificate\n    }\n    STATUS current\n    DESCRIPTION\n
    \       \"Notifications\"\n    ::= { snmpTlstmGroups 4 }\n"
  - 'END

    '
  title: 7.  MIB Module Definition
- contents:
  - "8.  Operational Considerations\n   This section discusses various operational
    aspects of deploying\n   TLSTM.\n"
  - contents:
    - "8.1.  Sessions\n   A session is discussed throughout this document as meaning
      a security\n   association between two TLSTM instances.  State information for
      the\n   sessions are maintained in each TLSTM implementation and this\n   information
      is created and destroyed as sessions are opened and\n   closed.  A \"broken\"
      session (one side up and one side down) can\n   result if one side of a session
      is brought down abruptly (i.e.,\n   reboot, power outage, etc.).  Whenever possible,
      implementations\n   SHOULD provide graceful session termination through the
      use of TLS\n   disconnect messages.  Implementations SHOULD also have a system
      in\n   place for detecting \"broken\" sessions through the use of heartbeats\n
      \  [HEARTBEAT] or other detection mechanisms.\n   Implementations SHOULD limit
      the lifetime of established sessions\n   depending on the algorithms used for
      generation of the master session\n   secret, the privacy and integrity algorithms
      used to protect\n   messages, the environment of the session, the amount of
      data\n   transferred, and the sensitivity of the data.\n"
    title: 8.1.  Sessions
  - contents:
    - "8.2.  Notification Receiver Credential Selection\n   When an SNMP engine needs
      to establish an outgoing session for\n   notifications, the snmpTargetParamsTable
      includes an entry for the\n   snmpTargetParamsSecurityName of the target.  Servers
      that wish to\n   support multiple principals at a particular port SHOULD make
      use of\n   the Server Name Indication extension defined in Section 3.1 of\n
      \  [RFC4366].  Without the Server Name Indication the receiving SNMP\n   engine
      (server) will not know which (D)TLS certificate to offer to\n   the client so
      that the tmSecurityName identity-authentication will be\n   successful.\n   Another
      solution is to maintain a one-to-one mapping between\n   certificates and incoming
      ports for notification receivers.  This can\n   be handled at the notification
      originator by configuring the\n   snmpTargetAddrTable (snmpTargetAddrTDomain
      and\n   snmpTargetAddrTAddress) and requiring the receiving SNMP engine to\n
      \  monitor multiple incoming static ports based on which principals are\n   capable
      of receiving notifications.\n   Implementations MAY also choose to designate
      a single Notification\n   Receiver Principal to receive all incoming notifications
      or select an\n   implementation specific method of selecting a server certificate
      to\n   present to clients.\n"
    title: 8.2.  Notification Receiver Credential Selection
  - contents:
    - "8.3.  contextEngineID Discovery\n   SNMPv3 requires that an application know
      the identifier\n   (snmpEngineID) of the remote SNMP protocol engine in order
      to\n   retrieve or manipulate objects maintained on the remote SNMP entity.\n
      \  [RFC5343] introduces a well-known localEngineID and a discovery\n   mechanism
      that can be used to learn the snmpEngineID of a remote SNMP\n   protocol engine.
      \ Implementations are RECOMMENDED to support and use\n   the contextEngineID
      discovery mechanism defined in [RFC5343].\n"
    title: 8.3.  contextEngineID Discovery
  - contents:
    - "8.4.  Transport Considerations\n   This document defines how SNMP messages
      can be transmitted over the\n   TLS- and DTLS-based protocols.  Each of these
      protocols is\n   additionally based on other transports (TCP and UDP).  These
      two base\n   protocols also have operational considerations that must be taken\n
      \  into consideration when selecting a (D)TLS-based protocol to use such\n   as
      its performance in degraded or limited networks.  It is beyond the\n   scope
      of this document to summarize the characteristics of these\n   transport mechanisms.
      \ Please refer to the base protocol documents\n   for details on messaging considerations
      with respect to MTU size,\n   fragmentation, performance in lossy networks,
      etc.\n"
    title: 8.4.  Transport Considerations
  title: 8.  Operational Considerations
- contents:
  - "9.  Security Considerations\n   This document describes a transport model that
    permits SNMP to\n   utilize (D)TLS security services.  The security threats and
    how the\n   (D)TLS transport model mitigates these threats are covered in detail\n
    \  throughout this document.  Security considerations for DTLS are\n   covered
    in [RFC4347] and security considerations for TLS are\n   described in Section
    11 and Appendices D, E, and F of TLS 1.2\n   [RFC5246].  When run over a connectionless
    transport such as UDP,\n   DTLS is more vulnerable to denial-of-service attacks
    from spoofed IP\n   addresses; see Section 4.2 for details how the cookie exchange
    is\n   used to address this issue.\n"
  - contents:
    - "9.1.  Certificates, Authentication, and Authorization\n   Implementations are
      responsible for providing a security certificate\n   installation and configuration
      mechanism.  Implementations SHOULD\n   support certificate revocation lists.\n
      \  (D)TLS provides for authentication of the identity of both the (D)TLS\n   server
      and the (D)TLS client.  Access to MIB objects for the\n   authenticated principal
      MUST be enforced by an access control\n   subsystem (e.g., the VACM).\n   Authentication
      of the command generator principal's identity is\n   important for use with
      the SNMP access control subsystem to ensure\n   that only authorized principals
      have access to potentially sensitive\n   data.  The authenticated identity of
      the command generator\n   principal's certificate is mapped to an SNMP model-independent\n
      \  securityName for use with SNMP access control.\n   The (D)TLS handshake only
      provides assurance that the certificate of\n   the authenticated identity has
      been signed by a configured accepted\n   Certification Authority.  (D)TLS has
      no way to further authorize or\n   reject access based on the authenticated
      identity.  An Access Control\n   Model (such as the VACM) provides access control
      and authorization of\n   a command generator's requests to a command responder
      and a\n   notification receiver's authorization to receive Notifications from
      a\n   notification originator.  However, to avoid man-in-the-middle\n   attacks,
      both ends of the (D)TLS-based connection MUST check the\n   certificate presented
      by the other side against what was expected.\n   For example, command generators
      must check that the command responder\n   presented and authenticated itself
      with an X.509 certificate that was\n   expected.  Not doing so would allow an
      impostor, at a minimum, to\n   present false data, receive sensitive information,
      and/or provide a\n   false belief that configuration was actually received and
      acted upon.\n   Authenticating and verifying the identity of the (D)TLS server
      and\n   the (D)TLS client for all operations ensures the authenticity of the\n
      \  SNMP engine that provides MIB data.\n   The instructions found in the DESCRIPTION
      clause of the\n   snmpTlstmCertToTSNTable object must be followed exactly.  It
      is also\n   important that the rows of the table be searched in prioritized
      order\n   starting with the row containing the lowest numbered\n   snmpTlstmCertToTSNID
      value.\n"
    title: 9.1.  Certificates, Authentication, and Authorization
  - contents:
    - "9.2.  (D)TLS Security Considerations\n   This section discusses security considerations
      specific to the usage\n   of (D)TLS.\n"
    - contents:
      - "9.2.1.  TLS Version Requirements\n   Implementations of TLS typically support
        multiple versions of the\n   Transport Layer Security protocol as well as
        the older Secure Sockets\n   Layer (SSL) protocol.  Because of known security
        vulnerabilities,\n   TLSTM clients and servers MUST NOT request, offer, or
        use SSL 2.0.\n   See Appendix E.2 of [RFC5246] for further details.\n"
      title: 9.2.1.  TLS Version Requirements
    - contents:
      - "9.2.2.  Perfect Forward Secrecy\n   The use of Perfect Forward Secrecy is
        RECOMMENDED and can be provided\n   by (D)TLS with appropriately selected
        cipher_suites, as discussed in\n   Appendix F of [RFC5246].\n"
      title: 9.2.2.  Perfect Forward Secrecy
    title: 9.2.  (D)TLS Security Considerations
  - contents:
    - "9.3.  Use with SNMPv1/SNMPv2c Messages\n   The SNMPv1 and SNMPv2c message processing
      described in [RFC3584] (BCP\n   74) always selects the SNMPv1 or SNMPv2c Security
      Models,\n   respectively.  Both of these and the User-based Security Model\n
      \  typically used with SNMPv3 derive the securityName and securityLevel\n   from
      the SNMP message received, even when the message was received\n   over a secure
      transport.  Access control decisions are therefore made\n   based on the contents
      of the SNMP message, rather than using the\n   authenticated identity and securityLevel
      provided by the TLS\n   Transport Model.  It is RECOMMENDED that only SNMPv3
      messages using\n   the Transport Security Model (TSM) or another secure-transport
      aware\n   security model be sent over the TLSTM transport.\n   Using a non-transport-aware
      Security Model with a secure Transport\n   Model is NOT RECOMMENDED.  See [RFC5590],
      Section 7.1 for additional\n   details on the coexistence of security-aware
      transports and non-\n   transport-aware security models.\n"
    title: 9.3.  Use with SNMPv1/SNMPv2c Messages
  - contents:
    - "9.4.  MIB Module Security\n   There are a number of management objects defined
      in this MIB module\n   with a MAX-ACCESS clause of read-write and/or read-create.
      \ Such\n   objects may be considered sensitive or vulnerable in some network\n
      \  environments.  The support for SET operations in a non-secure\n   environment
      without proper protection can have a negative effect on\n   network operations.
      \ These are the tables and objects and their\n   sensitivity/vulnerability:\n
      \  o  The snmpTlstmParamsTable can be used to change the outgoing X.509\n      certificate
      used to establish a (D)TLS connection.  Modifications\n      to objects in this
      table need to be adequately authenticated since\n      modifying the values
      in this table will have profound impacts to\n      the security of outbound
      connections from the device.  Since\n      knowledge of authorization rules
      and certificate usage mechanisms\n      may be considered sensitive, protection
      from disclosure of the\n      SNMP traffic via encryption is also highly recommended.\n
      \  o  The snmpTlstmAddrTable can be used to change the expectations of\n      the
      certificates presented by a remote (D)TLS server.\n      Modifications to objects
      in this table need to be adequately\n      authenticated since modifying the
      values in this table will have\n      profound impacts to the security of outbound
      connections from the\n      device.  Since knowledge of authorization rules
      and certificate\n      usage mechanisms may be considered sensitive, protection
      from\n      disclosure of the SNMP traffic via encryption is also highly\n      recommended.\n
      \  o  The snmpTlstmCertToTSNTable is used to specify the mapping of\n      incoming
      X.509 certificates to tmSecurityNames, which eventually\n      get mapped to
      an SNMPv3 securityName.  Modifications to objects in\n      this table need
      to be adequately authenticated since modifying the\n      values in this table
      will have profound impacts to the security of\n      incoming connections to
      the device.  Since knowledge of\n      authorization rules and certificate usage
      mechanisms may be\n      considered sensitive, protection from disclosure of
      the SNMP\n      traffic via encryption is also highly recommended.  When this\n
      \     table contains a significant number of rows it may affect the\n      system
      performance when accepting new (D)TLS connections.\n   Some of the readable
      objects in this MIB module (i.e., objects with a\n   MAX-ACCESS other than not-accessible)
      may be considered sensitive or\n   vulnerable in some network environments.
      \ It is thus important to\n   control even GET and/or NOTIFY access to these
      objects and possibly\n   to even encrypt the values of these objects when sending
      them over\n   the network via SNMP.  These are the tables and objects and their\n
      \  sensitivity/vulnerability:\n   o  This MIB contains a collection of counters
      that monitor the (D)TLS\n      connections being established with a device.
      \ Since knowledge of\n      connection and certificate usage mechanisms may
      be considered\n      sensitive, protection from disclosure of the SNMP traffic
      via\n      encryption is highly recommended.\n   SNMP versions prior to SNMPv3
      did not include adequate security.\n   Even if the network itself is secure
      (for example, by using IPsec),\n   even then, there is no control as to who
      on the secure network is\n   allowed to access and GET/SET (read/change/create/delete)
      the objects\n   in this MIB module.\n   It is RECOMMENDED that implementers
      consider the security features as\n   provided by the SNMPv3 framework (see
      [RFC3410], Section 8),\n   including full support for the SNMPv3 cryptographic
      mechanisms (for\n   authentication and privacy).\n   Further, deployment of
      SNMP versions prior to SNMPv3 is NOT\n   RECOMMENDED.  Instead, it is RECOMMENDED
      to deploy SNMPv3 and to\n   enable cryptographic security.  It is then a customer/operator\n
      \  responsibility to ensure that the SNMP entity giving access to an\n   instance
      of this MIB module is properly configured to give access to\n   the objects
      only to those principals (users) that have legitimate\n   rights to indeed GET
      or SET (change/create/delete) them.\n"
    title: 9.4.  MIB Module Security
  title: 9.  Security Considerations
- contents:
  - "10.  IANA Considerations\n   IANA has assigned:\n   1.  Two TCP/UDP port numbers
    from the \"Registered Ports\" range of the\n       Port Numbers registry, with
    the following keywords:\n     Keyword         Decimal      Description       References\n
    \    -------         -------      -----------       ----------\n     snmptls         10161/tcp
    \   SNMP-TLS          [RFC6353]\n     snmpdtls        10161/udp    SNMP-DTLS         [RFC6353]\n
    \    snmptls-trap    10162/tcp    SNMP-Trap-TLS     [RFC6353]\n     snmpdtls-trap
    \  10162/udp    SNMP-Trap-DTLS    [RFC6353]\n   These are the default ports for
    receipt of SNMP command messages\n   (snmptls and snmpdtls) and SNMP notification
    messages (snmptls-trap\n   and snmpdtls-trap) over a TLS Transport Model as defined
    in this\n   document.\n   2.  An SMI number (8) under snmpDomains for the snmpTLSTCPDomain\n
    \      object identifier\n   3.  An SMI number (9) under snmpDomains for the snmpDTLSUDPDomain\n
    \      object identifier\n   4.  An SMI number (198) under mib-2, for the MIB
    module in this\n       document\n   5.  \"tls\" as the corresponding prefix for
    the snmpTLSTCPDomain in the\n       SNMP Transport Domains registry\n   6.  \"dtls\"
    as the corresponding prefix for the snmpDTLSUDPDomain in\n       the SNMP Transport
    Domains registry\n"
  title: 10.  IANA Considerations
- contents:
  - "11.  Acknowledgements\n   This document closely follows and copies the Secure
    Shell Transport\n   Model for SNMP documented by David Harrington and Joseph Salowey
    in\n   [RFC5592].\n   This document was reviewed by the following people who helped
    provide\n   useful comments (in alphabetical order): Andy Donati, Pasi Eronen,\n
    \  David Harrington, Jeffrey Hutzelman, Alan Luchuk, Michael Peck, Tom\n   Petch,
    Randy Presuhn, Ray Purvis, Peter Saint-Andre, Joseph Salowey,\n   Juergen Schoenwaelder,
    Dave Shield, and Robert Story.\n   This work was supported in part by the United
    States Department of\n   Defense.  Large portions of this document are based on
    work by\n   General Dynamics C4 Systems and the following individuals: Brian\n
    \  Baril, Kim Bryant, Dana Deluca, Dan Hanson, Tim Huemiller, John\n   Holzhauer,
    Colin Hoogeboom, Dave Kornbau, Chris Knaian, Dan Knaul,\n   Charles Limoges, Steve
    Moccaldi, Gerardo Orlando, and Brandon Yip.\n"
  title: 11.  Acknowledgements
- contents:
  - '12.  References

    '
  - contents:
    - "12.1.  Normative References\n   [RFC1123]    Braden, R., \"Requirements for
      Internet Hosts -\n                Application and Support\", STD 3, RFC 1123,
      October 1989.\n   [RFC2119]    Bradner, S., \"Key words for use in RFCs to Indicate\n
      \               Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC2578]
      \   McCloghrie, K., Ed., Perkins, D., Ed., and J.\n                Schoenwaelder,
      Ed., \"Structure of Management Information\n                Version 2 (SMIv2)\",
      STD 58, RFC 2578, April 1999.\n   [RFC2579]    McCloghrie, K., Ed., Perkins,
      D., Ed., and J.\n                Schoenwaelder, Ed., \"Textual Conventions for
      SMIv2\",\n                STD 58, RFC 2579, April 1999.\n   [RFC2580]    McCloghrie,
      K., Perkins, D., and J. Schoenwaelder,\n                \"Conformance Statements
      for SMIv2\", STD 58, RFC 2580,\n                April 1999.\n   [RFC3411]    Harrington,
      D., Presuhn, R., and B. Wijnen, \"An\n                Architecture for Describing
      Simple Network Management\n                Protocol (SNMP) Management Frameworks\",
      STD 62,\n                RFC 3411, December 2002.\n   [RFC3413]    Levi, D.,
      Meyer, P., and B. Stewart, \"Simple Network\n                Management Protocol
      (SNMP) Applications\", STD 62,\n                RFC 3413, December 2002.\n   [RFC3414]
      \   Blumenthal, U. and B. Wijnen, \"User-based Security Model\n                (USM)
      for version 3 of the Simple Network Management\n                Protocol (SNMPv3)\",
      STD 62, RFC 3414, December 2002.\n   [RFC3415]    Wijnen, B., Presuhn, R., and
      K. McCloghrie, \"View-based\n                Access Control Model (VACM) for
      the Simple Network\n                Management Protocol (SNMP)\", STD 62, RFC
      3415,\n                December 2002.\n   [RFC3418]    Presuhn, R., \"Management
      Information Base (MIB) for the\n                Simple Network Management Protocol
      (SNMP)\", STD 62,\n                RFC 3418, December 2002.\n   [RFC3584]    Frye,
      R., Levi, D., Routhier, S., and B. Wijnen,\n                \"Coexistence between
      Version 1, Version 2, and Version 3\n                of the Internet-standard
      Network Management Framework\",\n                BCP 74, RFC 3584, August 2003.\n
      \  [RFC4347]    Rescorla, E. and N. Modadugu, \"Datagram Transport Layer\n                Security\",
      RFC 4347, April 2006.\n   [RFC4366]    Blake-Wilson, S., Nystrom, M., Hopwood,
      D., Mikkelsen,\n                J., and T. Wright, \"Transport Layer Security
      (TLS)\n                Extensions\", RFC 4366, April 2006.\n   [RFC5246]    Dierks,
      T. and E. Rescorla, \"The Transport Layer\n                Security (TLS) Protocol
      Version 1.2\", RFC 5246,\n                August 2008.\n   [RFC5280]    Cooper,
      D., Santesson, S., Farrell, S., Boeyen, S.,\n                Housley, R., and
      W. Polk, \"Internet X.509 Public Key\n                Infrastructure Certificate
      and Certificate Revocation\n                List (CRL) Profile\", RFC 5280,
      May 2008.\n   [RFC5590]    Harrington, D. and J. Schoenwaelder, \"Transport\n
      \               Subsystem for the Simple Network Management Protocol\n                (SNMP)\",
      RFC 5590, June 2009.\n   [RFC5591]    Harrington, D. and W. Hardaker, \"Transport
      Security\n                Model for the Simple Network Management Protocol\n
      \               (SNMP)\", RFC 5591, June 2009.\n   [RFC5952]    Kawamura, S.
      and M. Kawashima, \"A Recommendation for\n                IPv6 Address Text
      Representation\", RFC 5952,\n                August 2010.\n"
    title: 12.1.  Normative References
  - contents:
    - "12.2.  Informative References\n   [HEARTBEAT]  Seggelmann, R., Tuexen, M.,
      and M. Williams, \"Transport\n                Layer Security (TLS) and Datagram
      Transport Layer\n                Security (DTLS) Heartbeat Extension\", Work
      in Progress,\n                July 2011.\n   [RFC3410]    Case, J., Mundy, R.,
      Partain, D., and B. Stewart,\n                \"Introduction and Applicability
      Statements for Internet-\n                Standard Management Framework\", RFC
      3410, December 2002.\n   [RFC5343]    Schoenwaelder, J., \"Simple Network Management
      Protocol\n                (SNMP) Context EngineID Discovery\", RFC 5343,\n                September
      2008.\n   [RFC5592]    Harrington, D., Salowey, J., and W. Hardaker, \"Secure\n
      \               Shell Transport Model for the Simple Network Management\n                Protocol
      (SNMP)\", RFC 5592, June 2009.\n   [RFC5890]    Klensin, J., \"Internationalized
      Domain Names for\n                Applications (IDNA): Definitions and Document\n
      \               Framework\", RFC 5890, August 2010.\n   [RFC5953]    Hardaker,
      W., \"Transport Layer Security (TLS) Transport\n                Model for the
      Simple Network Management Protocol\n                (SNMP)\", RFC 5953, August
      2010.\n"
    title: 12.2.  Informative References
  title: 12.  References
- contents:
  - "Appendix A.  Target and Notification Configuration Example\n   The following
    sections describe example configuration for the SNMP-\n   TLS-TM-MIB, the SNMP-TARGET-MIB,
    the NOTIFICATION-MIB, and the SNMP-\n   VIEW-BASED-ACM-MIB.\n"
  - contents:
    - "A.1.  Configuring a Notification Originator\n   The following row adds the
      \"Joe Cool\" user to the \"administrators\"\n   group:\n       vacmSecurityModel
      \             = 4 (TSM)\n       vacmSecurityName               = \"Joe Cool\"\n
      \      vacmGroupName                  = \"administrators\"\n       vacmSecurityToGroupStorageType
      = 3 (nonVolatile)\n       vacmSecurityToGroupStatus      = 4 (createAndGo)\n
      \  The following row configures the snmpTlstmAddrTable to use\n   certificate
      path validation and to require the remote notification\n   receiver to present
      a certificate for the \"server.example.org\"\n   identity.\n       snmpTargetAddrName
      \            =  \"toNRAddr\"\n       snmpTlstmAddrServerFingerprint =  \"\"\n
      \      snmpTlstmAddrServerIdentity    =  \"server.example.org\"\n       snmpTlstmAddrStorageType
      \      =  3         (nonVolatile)\n       snmpTlstmAddrRowStatus         =  4
      \        (createAndGo)\n   The following row configures the snmpTargetAddrTable
      to send\n   notifications using TLS/TCP to the snmptls-trap port at 192.0.2.1:\n
      \      snmpTargetAddrName              = \"toNRAddr\"\n       snmpTargetAddrTDomain
      \          = snmpTLSTCPDomain\n       snmpTargetAddrTAddress          = \"192.0.2.1:10162\"\n
      \      snmpTargetAddrTimeout           = 1500\n       snmpTargetAddrRetryCount
      \       = 3\n       snmpTargetAddrTagList           = \"toNRTag\"\n       snmpTargetAddrParams
      \           = \"toNR\"     (MUST match below)\n       snmpTargetAddrStorageType
      \      = 3          (nonVolatile)\n       snmpTargetAddrRowStatus         =
      4          (createAndGo)\n   The following row configures the snmpTargetParamsTable
      to send the\n   notifications to \"Joe Cool\", using authPriv SNMPv3 notifications\n
      \  through the TransportSecurityModel [RFC5591]:\n       snmpTargetParamsName
      \           = \"toNR\"     (must match above)\n       snmpTargetParamsMPModel
      \        = 3 (SNMPv3)\n       snmpTargetParamsSecurityModel   = 4 (TransportSecurityModel)\n
      \      snmpTargetParamsSecurityName    = \"Joe Cool\"\n       snmpTargetParamsSecurityLevel
      \  = 3          (authPriv)\n       snmpTargetParamsStorageType     = 3          (nonVolatile)\n
      \      snmpTargetParamsRowStatus       = 4          (createAndGo)\n"
    title: A.1.  Configuring a Notification Originator
  - contents:
    - "A.2.  Configuring TLSTM to Utilize a Simple Derivation of tmSecurityName\n
      \  The following row configures the snmpTlstmCertToTSNTable to map a\n   validated
      client certificate, referenced by the client's public X.509\n   hash fingerprint,
      to a tmSecurityName using the subjectAltName\n   component of the certificate.\n
      \      snmpTlstmCertToTSNID          = 1\n                                       (chosen
      by ordering preference)\n       snmpTlstmCertToTSNFingerprint = HASH (appropriate
      fingerprint)\n       snmpTlstmCertToTSNMapType     = snmpTlstmCertSANAny\n       snmpTlstmCertToTSNData
      \       = \"\"  (not used)\n       snmpTlstmCertToTSNStorageType = 3   (nonVolatile)\n
      \      snmpTlstmCertToTSNRowStatus   = 4   (createAndGo)\n   This type of configuration
      should only be used when the naming\n   conventions of the (possibly multiple)
      Certification Authorities are\n   well understood, so two different principals
      cannot inadvertently be\n   identified by the same derived tmSecurityName.\n"
    title: A.2.  Configuring TLSTM to Utilize a Simple Derivation of tmSecurityName
  - contents:
    - "A.3.  Configuring TLSTM to Utilize Table-Driven Certificate Mapping\n   The
      following row configures the snmpTlstmCertToTSNTable to map a\n   validated
      client certificate, referenced by the client's public X.509\n   hash fingerprint,
      to the directly specified tmSecurityName of \"Joe\n   Cool\".\n       snmpTlstmCertToTSNID
      \          = 2\n                                        (chosen by ordering
      preference)\n       snmpTlstmCertToTSNFingerprint  = HASH (appropriate fingerprint)\n
      \      snmpTlstmCertToTSNMapType      = snmpTlstmCertSpecified\n       snmpTlstmCertToTSNSecurityName
      = \"Joe Cool\"\n       snmpTlstmCertToTSNStorageType  = 3  (nonVolatile)\n       snmpTlstmCertToTSNRowStatus
      \   = 4  (createAndGo)\n"
    title: A.3.  Configuring TLSTM to Utilize Table-Driven Certificate Mapping
  title: Appendix A.  Target and Notification Configuration Example
- contents:
  - "Author's Address\n   Wes Hardaker\n   SPARTA, Inc.\n   P.O. Box 382\n   Davis,
    CA  95617\n   USA\n   Phone: +1 530 792 1913\n   EMail: ietf@hardakers.net\n"
  title: Author's Address
