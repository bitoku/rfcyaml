- title: __initial_text__
  contents:
  - '               Transport Layer Security (TLS) Extensions

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2006).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes extensions that may be used to add\n   functionality\
    \ to Transport Layer Security (TLS).  It provides both\n   generic extension mechanisms\
    \ for the TLS handshake client and server\n   hellos, and specific extensions\
    \ using these generic mechanisms.\n   The extensions may be used by TLS clients\
    \ and servers.  The\n   extensions are backwards compatible: communication is\
    \ possible\n   between TLS clients that support the extensions and TLS servers\
    \ that\n   do not support the extensions, and vice versa.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \      1.1. Conventions Used in This Document ..........................5\n  \
    \ 2. General Extension Mechanisms ....................................5\n    \
    \  2.1. Extended Client Hello ......................................5\n      2.2.\
    \ Extended Server Hello ......................................6\n      2.3. Hello\
    \ Extensions ...........................................6\n      2.4. Extensions\
    \ to the Handshake Protocol .......................8\n   3. Specific Extensions\
    \ .............................................8\n      3.1.  Server Name Indication\
    \ ....................................9\n      3.2.  Maximum Fragment Length Negotiation\
    \ ......................11\n      3.3.  Client Certificate URLs ..................................12\n\
    \      3.4.  Trusted CA Indication ....................................15\n  \
    \    3.5. Truncated HMAC ............................................16\n    \
    \  3.6. Certificate Status Request ................................17\n   4. Error\
    \ Alerts ...................................................19\n   5. Procedure\
    \ for Defining New Extensions ..........................20\n   6. Security Considerations\
    \ ........................................21\n      6.1. Security of server_name\
    \ ...................................22\n      6.2. Security of max_fragment_length\
    \ ...........................22\n      6.3. Security of client_certificate_url\
    \ ........................22\n      6.4. Security of trusted_ca_keys ...............................24\n\
    \      6.5. Security of truncated_hmac ................................24\n  \
    \    6.6. Security of status_request ................................25\n   7.\
    \ Internationalization Considerations ............................25\n   8. IANA\
    \ Considerations ............................................25\n   9. Acknowledgements\
    \ ...............................................27\n   10. Normative References\
    \ ..........................................27\n   11. Informative References\
    \ ........................................28\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document describes extensions that may be used to add\n\
    \   functionality to Transport Layer Security (TLS).  It provides both\n   generic\
    \ extension mechanisms for the TLS handshake client and server\n   hellos, and\
    \ specific extensions using these generic mechanisms.\n   TLS is now used in an\
    \ increasing variety of operational environments,\n   many of which were not envisioned\
    \ when the original design criteria\n   for TLS were determined.  The extensions\
    \ introduced in this document\n   are designed to enable TLS to operate as effectively\
    \ as possible in\n   new environments such as wireless networks.\n   Wireless\
    \ environments often suffer from a number of constraints not\n   commonly present\
    \ in wired environments.  These constraints may\n   include bandwidth limitations,\
    \ computational power limitations,\n   memory limitations, and battery life limitations.\n\
    \   The extensions described here focus on extending the functionality\n   provided\
    \ by the TLS protocol message formats.  Other issues, such as\n   the addition\
    \ of new cipher suites, are deferred.\n   Specifically, the extensions described\
    \ in this document:\n   -  Allow TLS clients to provide to the TLS server the\
    \ name of the\n      server they are contacting.  This functionality is desirable\
    \ in\n      order to facilitate secure connections to servers that host\n    \
    \  multiple 'virtual' servers at a single underlying network address.\n   -  Allow\
    \ TLS clients and servers to negotiate the maximum fragment\n      length to be\
    \ sent.  This functionality is desirable as a result of\n      memory constraints\
    \ among some clients, and bandwidth constraints\n      among some access networks.\n\
    \   -  Allow TLS clients and servers to negotiate the use of client\n      certificate\
    \ URLs.  This functionality is desirable in order to\n      conserve memory on\
    \ constrained clients.\n   -  Allow TLS clients to indicate to TLS servers which\
    \ CA root keys\n      they possess.  This functionality is desirable in order\
    \ to prevent\n      multiple handshake failures involving TLS clients that are\
    \ only\n      able to store a small number of CA root keys due to memory\n   \
    \   limitations.\n   -  Allow TLS clients and servers to negotiate the use of\
    \ truncated\n      MACs.  This functionality is desirable in order to conserve\n\
    \      bandwidth in constrained access networks.\n   -  Allow TLS clients and\
    \ servers to negotiate that the server sends\n      the client certificate status\
    \ information (e.g., an Online\n      Certificate Status Protocol (OCSP) [OCSP]\
    \ response) during a TLS\n      handshake.  This functionality is desirable in\
    \ order to avoid\n      sending a Certificate Revocation List (CRL) over a constrained\n\
    \      access network and therefore save bandwidth.\n   In order to support the\
    \ extensions above, general extension\n   mechanisms for the client hello message\
    \ and the server hello message\n   are introduced.\n   The extensions described\
    \ in this document may be used by TLS clients\n   and servers.  The extensions\
    \ are designed to be backwards compatible,\n   meaning that TLS clients that support\
    \ the extensions can talk to TLS\n   servers that do not support the extensions,\
    \ and vice versa.  The\n   document therefore updates TLS 1.0 [TLS] and TLS 1.1\
    \ [TLSbis].\n   Backwards compatibility is primarily achieved via two considerations:\n\
    \   -  Clients typically request the use of extensions via the extended\n    \
    \  client hello message described in Section 2.1. TLS requires\n      servers\
    \ to accept extended client hello messages, even if the\n      server does not\
    \ \"understand\" the extension.\n   -  For the specific extensions described here,\
    \ no mandatory server\n      response is required when clients request extended\
    \ functionality.\n   Essentially, backwards compatibility is achieved based on\
    \ the TLS\n   requirement that servers that are not \"extensions-aware\" ignore\
    \ data\n   added to client hellos that they do not recognize; for example, see\n\
    \   Section 7.4.1.2 of [TLS].\n   Note, however, that although backwards compatibility\
    \ is supported,\n   some constrained clients may be forced to reject communications\
    \ with\n   servers that do not support the extensions as a result of the limited\n\
    \   capabilities of such clients.\n   This document is a revision of the RFC3546\
    \ [RFC3546].  The only major\n   change concerns the definition of new extensions.\
    \  New extensions can\n   now be defined via the IETF Consensus Process (rather\
    \ than requiring\n   a standards track RFC).  In addition, a few minor clarifications\
    \ and\n   editorial improvements were made.\n   The remainder of this document\
    \ is organized as follows.  Section 2\n   describes general extension mechanisms\
    \ for the client hello and\n   server hello handshake messages.  Section 3 describes\
    \ specific\n   extensions to TLS.  Section 4 describes new error alerts for use\
    \ with\n   the TLS extensions.  The final sections of the document address IPR,\n\
    \   security considerations, registration of the application/pkix-pkipath\n  \
    \ MIME type, acknowledgements, and references.\n"
- title: 1.1.  Conventions Used in This Document
  contents:
  - "1.1.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in BCP 14, RFC 2119\n   [KEYWORDS].\n"
- title: 2.  General Extension Mechanisms
  contents:
  - "2.  General Extension Mechanisms\n   This section presents general extension\
    \ mechanisms for the TLS\n   handshake client hello and server hello messages.\n\
    \   These general extension mechanisms are necessary in order to enable\n   clients\
    \ and servers to negotiate whether to use specific extensions,\n   and how to\
    \ use specific extensions.  The extension formats described\n   are based on [MAILINGLIST].\n\
    \   Section 2.1 specifies the extended client hello message format,\n   Section\
    \ 2.2 specifies the extended server hello message format, and\n   Section 2.3\
    \ describes the actual extension format used with the\n   extended client and\
    \ server hellos.\n"
- title: 2.1.  Extended Client Hello
  contents:
  - "2.1.  Extended Client Hello\n   Clients MAY request extended functionality from\
    \ servers by sending\n   the extended client hello message format in place of\
    \ the client hello\n   message format.  The extended client hello message format\
    \ is:\n         struct {\n             ProtocolVersion client_version;\n     \
    \        Random random;\n             SessionID session_id;\n             CipherSuite\
    \ cipher_suites<2..2^16-1>;\n             CompressionMethod compression_methods<1..2^8-1>;\n\
    \             Extension client_hello_extension_list<0..2^16-1>;\n         } ClientHello;\n\
    \   Here the new \"client_hello_extension_list\" field contains a list of\n  \
    \ extensions.  The actual \"Extension\" format is defined in Section 2.3.\n  \
    \ In the event that a client requests additional functionality using\n   the extended\
    \ client hello, and this functionality is not supplied by\n   the server, the\
    \ client MAY abort the handshake.\n   Note that [TLS], Section 7.4.1.2, allows\
    \ additional information to be\n   added to the client hello message.  Thus, the\
    \ use of the extended\n   client hello defined above should not \"break\" existing\
    \ TLS servers.\n   A server that supports the extensions mechanism MUST accept\
    \ only\n   client hello messages in either the original or extended ClientHello\n\
    \   format and (as for all other messages) MUST check that the amount of\n   data\
    \ in the message precisely matches one of these formats.  If it\n   does not,\
    \ then it MUST send a fatal \"decode_error\" alert.  This\n   overrides the \"\
    Forward compatibility note\" in [TLS].\n"
- title: 2.2.  Extended Server Hello
  contents:
  - "2.2.  Extended Server Hello\n   The extended server hello message format MAY\
    \ be sent in place of the\n   server hello message when the client has requested\
    \ extended\n   functionality via the extended client hello message specified in\n\
    \   Section 2.1.  The extended server hello message format is:\n      struct {\n\
    \          ProtocolVersion server_version;\n          Random random;\n       \
    \   SessionID session_id;\n          CipherSuite cipher_suite;\n          CompressionMethod\
    \ compression_method;\n          Extension server_hello_extension_list<0..2^16-1>;\n\
    \      } ServerHello;\n   Here the new \"server_hello_extension_list\" field contains\
    \ a list of\n   extensions.  The actual \"Extension\" format is defined in Section\
    \ 2.3.\n   Note that the extended server hello message is only sent in response\n\
    \   to an extended client hello message.  This prevents the possibility\n   that\
    \ the extended server hello message could \"break\" existing TLS\n   clients.\n"
- title: 2.3.  Hello Extensions
  contents:
  - "2.3.  Hello Extensions\n   The extension format for extended client hellos and\
    \ extended server\n   hellos is:\n      struct {\n          ExtensionType extension_type;\n\
    \          opaque extension_data<0..2^16-1>;\n      } Extension;\n   Here:\n \
    \  - \"extension_type\" identifies the particular extension type.\n   - \"extension_data\"\
    \ contains information specific to the particular\n     extension type.\n   The\
    \ extension types defined in this document are:\n      enum {\n          server_name(0),\
    \ max_fragment_length(1),\n          client_certificate_url(2), trusted_ca_keys(3),\n\
    \          truncated_hmac(4), status_request(5), (65535)\n      } ExtensionType;\n\
    \   The list of defined extension types is maintained by the IANA.  The\n   current\
    \ list can be found at:\n   http://www.iana.org/assignments/tls-extensiontype-values.\
    \  See\n   Sections 5 and 8 for more information on how new values are added.\n\
    \   Note that for all extension types (including those defined in the\n   future),\
    \ the extension type MUST NOT appear in the extended server\n   hello unless the\
    \ same extension type appeared in the corresponding\n   client hello.  Thus clients\
    \ MUST abort the handshake if they receive\n   an extension type in the extended\
    \ server hello that they did not\n   request in the associated (extended) client\
    \ hello.\n   Nonetheless, \"server-oriented\" extensions may be provided in the\n\
    \   future within this framework.  Such an extension (say, of type x)\n   would\
    \ require the client to first send an extension of type x in the\n   (extended)\
    \ client hello with empty extension_data to indicate that it\n   supports the\
    \ extension type.  In this case, the client is offering\n   the capability to\
    \ understand the extension type, and the server is\n   taking the client up on\
    \ its offer.\n   Also note that when multiple extensions of different types are\n\
    \   present in the extended client hello or the extended server hello,\n   the\
    \ extensions may appear in any order.  There MUST NOT be more than\n   one extension\
    \ of the same type.\n   Finally, note that an extended client hello may be sent\
    \ both when\n   starting a new session and when requesting session resumption.\n\
    \   Indeed, a client that requests resumption of a session does not in\n   general\
    \ know whether the server will accept this request, and\n   therefore it SHOULD\
    \ send an extended client hello if it would\n   normally do so for a new session.\
    \  In general the specification of\n   each extension type must include a discussion\
    \ of the effect of the\n   extension both during new sessions and during resumed\
    \ sessions.\n"
- title: 2.4.  Extensions to the Handshake Protocol
  contents:
  - "2.4.  Extensions to the Handshake Protocol\n   This document suggests the use\
    \ of two new handshake messages,\n   \"CertificateURL\" and \"CertificateStatus\"\
    .  These messages are\n   described in Section 3.3 and Section 3.6, respectively.\
    \  The new\n   handshake message structure therefore becomes:\n      enum {\n\
    \          hello_request(0), client_hello(1), server_hello(2),\n          certificate(11),\
    \ server_key_exchange (12),\n          certificate_request(13), server_hello_done(14),\n\
    \          certificate_verify(15), client_key_exchange(16),\n          finished(20),\
    \ certificate_url(21), certificate_status(22),\n          (255)\n      } HandshakeType;\n\
    \      struct {\n          HandshakeType msg_type;    /* handshake type */\n \
    \         uint24 length;             /* bytes in message */\n          select\
    \ (HandshakeType) {\n              case hello_request:       HelloRequest;\n \
    \             case client_hello:        ClientHello;\n              case server_hello:\
    \        ServerHello;\n              case certificate:         Certificate;\n\
    \              case server_key_exchange: ServerKeyExchange;\n              case\
    \ certificate_request: CertificateRequest;\n              case server_hello_done:\
    \   ServerHelloDone;\n              case certificate_verify:  CertificateVerify;\n\
    \              case client_key_exchange: ClientKeyExchange;\n              case\
    \ finished:            Finished;\n              case certificate_url:     CertificateURL;\n\
    \              case certificate_status:  CertificateStatus;\n          } body;\n\
    \      } Handshake;\n"
- title: 3.  Specific Extensions
  contents:
  - "3.  Specific Extensions\n   This section describes the specific TLS extensions\
    \ specified in this\n   document.\n   Note that any messages associated with these\
    \ extensions that are sent\n   during the TLS handshake MUST be included in the\
    \ hash calculations\n   involved in \"Finished\" messages.\n   Note also that\
    \ all the extensions defined in this section are\n   relevant only when a session\
    \ is initiated.  When a client includes\n   one or more of the defined extension\
    \ types in an extended client\n   hello while requesting session resumption:\n\
    \   -  If the resumption request is denied, the use of the extensions is\n   \
    \   negotiated as normal.\n   -  If, on the other hand, the older session is resumed,\
    \ then the\n      server MUST ignore the extensions and send a server hello\n\
    \      containing none of the extension types.  In this case, the\n      functionality\
    \ of these extensions negotiated during the original\n      session initiation\
    \ is applied to the resumed session.\n   Section 3.1 describes the extension of\
    \ TLS to allow a client to\n   indicate which server it is contacting.  Section\
    \ 3.2 describes the\n   extension that provides maximum fragment length negotiation.\
    \  Section\n   3.3 describes the extension that allows client certificate URLs.\n\
    \   Section 3.4 describes the extension that allows a client to indicate\n   which\
    \ CA root keys it possesses.  Section 3.5 describes the extension\n   that allows\
    \ the use of truncated HMAC.  Section 3.6 describes the\n   extension that supports\
    \ integration of certificate status information\n   messages into TLS handshakes.\n"
- title: 3.1.  Server Name Indication
  contents:
  - "3.1.  Server Name Indication\n   TLS does not provide a mechanism for a client\
    \ to tell a server the\n   name of the server it is contacting.  It may be desirable\
    \ for clients\n   to provide this information to facilitate secure connections\
    \ to\n   servers that host multiple 'virtual' servers at a single underlying\n\
    \   network address.\n   In order to provide the server name, clients MAY include\
    \ an extension\n   of type \"server_name\" in the (extended) client hello.  The\n\
    \   \"extension_data\" field of this extension SHALL contain\n   \"ServerNameList\"\
    \ where:\n      struct {\n          NameType name_type;\n          select (name_type)\
    \ {\n              case host_name: HostName;\n          } name;\n      } ServerName;\n\
    \      enum {\n          host_name(0), (255)\n      } NameType;\n      opaque\
    \ HostName<1..2^16-1>;\n      struct {\n          ServerName server_name_list<1..2^16-1>\n\
    \      } ServerNameList;\n   Currently, the only server names supported are DNS\
    \ hostnames;\n   however, this does not imply any dependency of TLS on DNS, and\
    \ other\n   name types may be added in the future (by an RFC that updates this\n\
    \   document).  TLS MAY treat provided server names as opaque data and\n   pass\
    \ the names and types to the application.\n   \"HostName\" contains the fully\
    \ qualified DNS hostname of the server,\n   as understood by the client.  The\
    \ hostname is represented as a byte\n   string using UTF-8 encoding [UTF8], without\
    \ a trailing dot.\n   If the hostname labels contain only US-ASCII characters,\
    \ then the\n   client MUST ensure that labels are separated only by the byte 0x2E,\n\
    \   representing the dot character U+002E (requirement 1 in Section 3.1\n   of\
    \ [IDNA] notwithstanding).  If the server needs to match the\n   HostName against\
    \ names that contain non-US-ASCII characters, it MUST\n   perform the conversion\
    \ operation described in Section 4 of [IDNA],\n   treating the HostName as a \"\
    query string\" (i.e., the AllowUnassigned\n   flag MUST be set).  Note that IDNA\
    \ allows labels to be separated by\n   any of the Unicode characters U+002E, U+3002,\
    \ U+FF0E, and U+FF61;\n   therefore, servers MUST accept any of these characters\
    \ as a label\n   separator.  If the server only needs to match the HostName against\n\
    \   names containing exclusively ASCII characters, it MUST compare ASCII\n   names\
    \ case-insensitively.\n   Literal IPv4 and IPv6 addresses are not permitted in\
    \ \"HostName\".\n   It is RECOMMENDED that clients include an extension of type\n\
    \   \"server_name\" in the client hello whenever they locate a server by a\n \
    \  supported name type.\n   A server that receives a client hello containing the\
    \ \"server_name\"\n   extension MAY use the information contained in the extension\
    \ to guide\n   its selection of an appropriate certificate to return to the client,\n\
    \   and/or other aspects of security policy.  In this event, the server\n   SHALL\
    \ include an extension of type \"server_name\" in the (extended)\n   server hello.\
    \  The \"extension_data\" field of this extension SHALL be\n   empty.\n   If the\
    \ server understood the client hello extension but does not\n   recognize the\
    \ server name, it SHOULD send an \"unrecognized_name\"\n   alert (which MAY be\
    \ fatal).\n   If an application negotiates a server name using an application\n\
    \   protocol and then upgrades to TLS, and if a server_name extension is\n   sent,\
    \ then the extension SHOULD contain the same name that was\n   negotiated in the\
    \ application protocol.  If the server_name is\n   established in the TLS session\
    \ handshake, the client SHOULD NOT\n   attempt to request a different server name\
    \ at the application layer.\n"
- title: 3.2.  Maximum Fragment Length Negotiation
  contents:
  - "3.2.  Maximum Fragment Length Negotiation\n   Without this extension, TLS specifies\
    \ a fixed maximum plaintext\n   fragment length of 2^14 bytes.  It may be desirable\
    \ for constrained\n   clients to negotiate a smaller maximum fragment length due\
    \ to memory\n   limitations or bandwidth limitations.\n   In order to negotiate\
    \ smaller maximum fragment lengths, clients MAY\n   include an extension of type\
    \ \"max_fragment_length\" in the (extended)\n   client hello.  The \"extension_data\"\
    \ field of this extension SHALL\n   contain:\n   enum{\n       2^9(1), 2^10(2),\
    \ 2^11(3), 2^12(4), (255)\n   } MaxFragmentLength;\n   whose value is the desired\
    \ maximum fragment length.  The allowed\n   values for this field are: 2^9, 2^10,\
    \ 2^11, and 2^12.\n   Servers that receive an extended client hello containing\
    \ a\n   \"max_fragment_length\" extension MAY accept the requested maximum\n \
    \  fragment length by including an extension of type\n   \"max_fragment_length\"\
    \ in the (extended) server hello.  The\n   \"extension_data\" field of this extension\
    \ SHALL contain a\n   \"MaxFragmentLength\" whose value is the same as the requested\
    \ maximum\n   fragment length.\n   If a server receives a maximum fragment length\
    \ negotiation request\n   for a value other than the allowed values, it MUST abort\
    \ the\n   handshake with an \"illegal_parameter\" alert.  Similarly, if a client\n\
    \   receives a maximum fragment length negotiation response that differs\n   from\
    \ the length it requested, it MUST also abort the handshake with\n   an \"illegal_parameter\"\
    \ alert.\n   Once a maximum fragment length other than 2^14 has been successfully\n\
    \   negotiated, the client and server MUST immediately begin fragmenting\n   messages\
    \ (including handshake messages), to ensure that no fragment\n   larger than the\
    \ negotiated length is sent.  Note that TLS already\n   requires clients and servers\
    \ to support fragmentation of handshake\n   messages.\n   The negotiated length\
    \ applies for the duration of the session\n   including session resumptions.\n\
    \   The negotiated length limits the input that the record layer may\n   process\
    \ without fragmentation (that is, the maximum value of\n   TLSPlaintext.length;\
    \ see [TLS], Section 6.2.1).  Note that the output\n   of the record layer may\
    \ be larger.  For example, if the negotiated\n   length is 2^9=512, then for currently\
    \ defined cipher suites (those\n   defined in [TLS], [KERB], and [AESSUITES]),\
    \ and when null compression\n   is used, the record layer output can be at most\
    \ 793 bytes: 5 bytes of\n   headers, 512 bytes of application data, 256 bytes\
    \ of padding, and 20\n   bytes of MAC.  This means that in this event a TLS record\
    \ layer peer\n   receiving a TLS record layer message larger than 793 bytes may\n\
    \   discard the message and send a \"record_overflow\" alert, without\n   decrypting\
    \ the message.\n"
- title: 3.3.  Client Certificate URLs
  contents:
  - "3.3.  Client Certificate URLs\n   Without this extension, TLS specifies that\
    \ when client authentication\n   is performed, client certificates are sent by\
    \ clients to servers\n   during the TLS handshake.  It may be desirable for constrained\n\
    \   clients to send certificate URLs in place of certificates, so that\n   they\
    \ do not need to store their certificates and can therefore save\n   memory.\n\
    \   In order to negotiate sending certificate URLs to a server, clients\n   MAY\
    \ include an extension of type \"client_certificate_url\" in the\n   (extended)\
    \ client hello.  The \"extension_data\" field of this\n   extension SHALL be empty.\n\
    \   (Note that it is necessary to negotiate use of client certificate\n   URLs\
    \ in order to avoid \"breaking\" existing TLS servers.)\n   Servers that receive\
    \ an extended client hello containing a\n   \"client_certificate_url\" extension\
    \ MAY indicate that they are willing\n   to accept certificate URLs by including\
    \ an extension of type\n   \"client_certificate_url\" in the (extended) server\
    \ hello.  The\n   \"extension_data\" field of this extension SHALL be empty.\n\
    \   After negotiation of the use of client certificate URLs has been\n   successfully\
    \ completed (by exchanging hellos including\n   \"client_certificate_url\" extensions),\
    \ clients MAY send a\n   \"CertificateURL\" message in place of a \"Certificate\"\
    \ message:\n      enum {\n          individual_certs(0), pkipath(1), (255)\n \
    \     } CertChainType;\n      enum {\n          false(0), true(1)\n      } Boolean;\n\
    \      struct {\n          CertChainType type;\n          URLAndOptionalHash url_and_hash_list<1..2^16-1>;\n\
    \      } CertificateURL;\n      struct {\n          opaque url<1..2^16-1>;\n \
    \         Boolean hash_present;\n          select (hash_present) {\n         \
    \     case false: struct {};\n              case true: SHA1Hash;\n          }\
    \ hash;\n      } URLAndOptionalHash;\n      opaque SHA1Hash[20];\n   Here \"url_and_hash_list\"\
    \ contains a sequence of URLs and optional\n   hashes.\n   When X.509 certificates\
    \ are used, there are two possibilities:\n   -  If CertificateURL.type is \"individual_certs\"\
    , each URL refers to a\n      single DER-encoded X.509v3 certificate, with the\
    \ URL for the\n      client's certificate first.\n   -  If CertificateURL.type\
    \ is \"pkipath\", the list contains a single\n      URL referring to a DER-encoded\
    \ certificate chain, using the type\n      PkiPath described in Section 8.\n \
    \  When any other certificate format is used, the specification that\n   describes\
    \ use of that format in TLS should define the encoding format\n   of certificates\
    \ or certificate chains, and any constraint on their\n   ordering.\n   The hash\
    \ corresponding to each URL at the client's discretion either\n   is not present\
    \ or is the SHA-1 hash of the certificate or certificate\n   chain (in the case\
    \ of X.509 certificates, the DER-encoded certificate\n   or the DER-encoded PkiPath).\n\
    \   Note that when a list of URLs for X.509 certificates is used, the\n   ordering\
    \ of URLs is the same as that used in the TLS Certificate\n   message (see [TLS],\
    \ Section 7.4.2), but opposite to the order in\n   which certificates are encoded\
    \ in PkiPath.  In either case, the\n   self-signed root certificate MAY be omitted\
    \ from the chain, under the\n   assumption that the server must already possess\
    \ it in order to\n   validate it.\n   Servers receiving \"CertificateURL\" SHALL\
    \ attempt to retrieve the\n   client's certificate chain from the URLs and then\
    \ process the\n   certificate chain as usual.  A cached copy of the content of\
    \ any URL\n   in the chain MAY be used, provided that a SHA-1 hash is present\
    \ for\n   that URL and it matches the hash of the cached copy.\n   Servers that\
    \ support this extension MUST support the http: URL scheme\n   for certificate\
    \ URLs, and MAY support other schemes.  Use of other\n   schemes than \"http\"\
    , \"https\", or \"ftp\" may create unexpected\n   problems.\n   If the protocol\
    \ used is HTTP, then the HTTP server can be configured\n   to use the Cache-Control\
    \ and Expires directives described in [HTTP]\n   to specify whether and for how\
    \ long certificates or certificate\n   chains should be cached.\n   The TLS server\
    \ is not required to follow HTTP redirects when\n   retrieving the certificates\
    \ or certificate chain.  The URLs used in\n   this extension SHOULD therefore\
    \ be chosen not to depend on such\n   redirects.\n   If the protocol used to retrieve\
    \ certificates or certificate chains\n   returns a MIME-formatted response (as\
    \ HTTP does), then the following\n   MIME Content-Types SHALL be used: when a\
    \ single X.509v3 certificate\n   is returned, the Content-Type is \"application/pkix-cert\"\
    \ [PKIOP], and\n   when a chain of X.509v3 certificates is returned, the Content-Type\
    \ is\n   \"application/pkix-pkipath\" (see Section 8).\n   If a SHA-1 hash is\
    \ present for an URL, then the server MUST check\n   that the SHA-1 hash of the\
    \ contents of the object retrieved from that\n   URL (after decoding any MIME\
    \ Content-Transfer-Encoding) matches the\n   given hash.  If any retrieved object\
    \ does not have the correct SHA-1\n   hash, the server MUST abort the handshake\
    \ with a\n   \"bad_certificate_hash_value\" alert.\n   Note that clients may choose\
    \ to send either \"Certificate\" or\n   \"CertificateURL\" after successfully\
    \ negotiating the option to send\n   certificate URLs.  The option to send a certificate\
    \ is included to\n   provide flexibility to clients possessing multiple certificates.\n\
    \   If a server encounters an unreasonable delay in obtaining\n   certificates\
    \ in a given CertificateURL, it SHOULD time out and signal\n   a \"certificate_unobtainable\"\
    \ error alert.\n"
- title: 3.4.  Trusted CA Indication
  contents:
  - "3.4.  Trusted CA Indication\n   Constrained clients that, due to memory limitations,\
    \ possess only a\n   small number of CA root keys may wish to indicate to servers\
    \ which\n   root keys they possess, in order to avoid repeated handshake\n   failures.\n\
    \   In order to indicate which CA root keys they possess, clients MAY\n   include\
    \ an extension of type \"trusted_ca_keys\" in the (extended)\n   client hello.\
    \  The \"extension_data\" field of this extension SHALL\n   contain \"TrustedAuthorities\"\
    \ where:\n      struct {\n          TrustedAuthority trusted_authorities_list<0..2^16-1>;\n\
    \      } TrustedAuthorities;\n      struct {\n          IdentifierType identifier_type;\n\
    \          select (identifier_type) {\n              case pre_agreed: struct {};\n\
    \              case key_sha1_hash: SHA1Hash;\n              case x509_name: DistinguishedName;\n\
    \              case cert_sha1_hash: SHA1Hash;\n          } identifier;\n     \
    \ } TrustedAuthority;\n      enum {\n          pre_agreed(0), key_sha1_hash(1),\
    \ x509_name(2),\n          cert_sha1_hash(3), (255)\n      } IdentifierType;\n\
    \      opaque DistinguishedName<1..2^16-1>;\n   Here \"TrustedAuthorities\" provides\
    \ a list of CA root key identifiers\n   that the client possesses.  Each CA root\
    \ key is identified via\n   either:\n   -  \"pre_agreed\": no CA root key identity\
    \ supplied.\n   -  \"key_sha1_hash\": contains the SHA-1 hash of the CA root key.\
    \  For\n      Digital Signature Algorithm (DSA) and Elliptic Curve Digital\n \
    \     Signature Algorithm (ECDSA) keys, this is the hash of the\n      \"subjectPublicKey\"\
    \ value.  For RSA keys, the hash is of the big-\n      endian byte string representation\
    \ of the modulus without any\n      initial 0-valued bytes.  (This copies the\
    \ key hash formats\n      deployed in other environments.)\n   -  \"x509_name\"\
    : contains the DER-encoded X.509 DistinguishedName of\n      the CA.\n   -  \"\
    cert_sha1_hash\": contains the SHA-1 hash of a DER-encoded\n      Certificate\
    \ containing the CA root key.\n   Note that clients may include none, some, or\
    \ all of the CA root keys\n   they possess in this extension.\n   Note also that\
    \ it is possible that a key hash or a Distinguished Name\n   alone may not uniquely\
    \ identify a certificate issuer (for example, if\n   a particular CA has multiple\
    \ key pairs).  However, here we assume\n   this is the case following the use\
    \ of Distinguished Names to identify\n   certificate issuers in TLS.\n   The option\
    \ to include no CA root keys is included to allow the client\n   to indicate possession\
    \ of some pre-defined set of CA root keys.\n   Servers that receive a client hello\
    \ containing the \"trusted_ca_keys\"\n   extension MAY use the information contained\
    \ in the extension to guide\n   their selection of an appropriate certificate\
    \ chain to return to the\n   client.  In this event, the server SHALL include\
    \ an extension of type\n   \"trusted_ca_keys\" in the (extended) server hello.\
    \  The\n   \"extension_data\" field of this extension SHALL be empty.\n"
- title: 3.5.  Truncated HMAC
  contents:
  - "3.5.  Truncated HMAC\n   Currently defined TLS cipher suites use the MAC construction\
    \ HMAC\n   with either MD5 or SHA-1 [HMAC] to authenticate record layer\n   communications.\
    \  In TLS, the entire output of the hash function is\n   used as the MAC tag.\
    \  However, it may be desirable in constrained\n   environments to save bandwidth\
    \ by truncating the output of the hash\n   function to 80 bits when forming MAC\
    \ tags.\n   In order to negotiate the use of 80-bit truncated HMAC, clients MAY\n\
    \   include an extension of type \"truncated_hmac\" in the extended client\n \
    \  hello.  The \"extension_data\" field of this extension SHALL be empty.\n  \
    \ Servers that receive an extended hello containing a \"truncated_hmac\"\n   extension\
    \ MAY agree to use a truncated HMAC by including an extension\n   of type \"truncated_hmac\"\
    , with empty \"extension_data\", in the\n   extended server hello.\n   Note that\
    \ if new cipher suites are added that do not use HMAC, and\n   the session negotiates\
    \ one of these cipher suites, this extension\n   will have no effect.  It is strongly\
    \ recommended that any new cipher\n   suites using other MACs consider the MAC\
    \ size an integral part of the\n   cipher suite definition, taking into account\
    \ both security and\n   bandwidth considerations.\n   If HMAC truncation has been\
    \ successfully negotiated during a TLS\n   handshake, and the negotiated cipher\
    \ suite uses HMAC, both the client\n   and the server pass this fact to the TLS\
    \ record layer along with the\n   other negotiated security parameters.  Subsequently\
    \ during the\n   session, clients and servers MUST use truncated HMACs, calculated\
    \ as\n   specified in [HMAC].  That is, CipherSpec.hash_size is 10 bytes, and\n\
    \   only the first 10 bytes of the HMAC output are transmitted and\n   checked.\
    \  Note that this extension does not affect the calculation of\n   the pseudo-random\
    \ function (PRF) as part of handshaking or key\n   derivation.\n   The negotiated\
    \ HMAC truncation size applies for the duration of the\n   session including session\
    \ resumptions.\n"
- title: 3.6.  Certificate Status Request
  contents:
  - "3.6.  Certificate Status Request\n   Constrained clients may wish to use a certificate-status\
    \ protocol\n   such as OCSP [OCSP] to check the validity of server certificates,\
    \ in\n   order to avoid transmission of CRLs and therefore save bandwidth on\n\
    \   constrained networks.  This extension allows for such information to\n   be\
    \ sent in the TLS handshake, saving roundtrips and resources.\n   In order to\
    \ indicate their desire to receive certificate status\n   information, clients\
    \ MAY include an extension of type\n   \"status_request\" in the (extended) client\
    \ hello.  The\n   \"extension_data\" field of this extension SHALL contain\n \
    \  \"CertificateStatusRequest\" where:\n      struct {\n          CertificateStatusType\
    \ status_type;\n          select (status_type) {\n              case ocsp: OCSPStatusRequest;\n\
    \          } request;\n      } CertificateStatusRequest;\n      enum { ocsp(1),\
    \ (255) } CertificateStatusType;\n      struct {\n          ResponderID responder_id_list<0..2^16-1>;\n\
    \          Extensions  request_extensions;\n      } OCSPStatusRequest;\n     \
    \ opaque ResponderID<1..2^16-1>;\n      opaque Extensions<0..2^16-1>;\n   In the\
    \ OCSPStatusRequest, the \"ResponderIDs\" provides a list of OCSP\n   responders\
    \ that the client trusts.  A zero-length \"responder_id_list\"\n   sequence has\
    \ the special meaning that the responders are implicitly\n   known to the server,\
    \ e.g., by prior arrangement.  \"Extensions\" is a\n   DER encoding of OCSP request\
    \ extensions.\n   Both \"ResponderID\" and \"Extensions\" are DER-encoded ASN.1\
    \ types as\n   defined in [OCSP].  \"Extensions\" is imported from [PKIX].  A\
    \ zero-\n   length \"request_extensions\" value means that there are no extensions\n\
    \   (as opposed to a zero-length ASN.1 SEQUENCE, which is not valid for\n   the\
    \ \"Extensions\" type).\n   In the case of the \"id-pkix-ocsp-nonce\" OCSP extension,\
    \ [OCSP] is\n   unclear about its encoding; for clarification, the nonce MUST\
    \ be a\n   DER-encoded OCTET STRING, which is encapsulated as another OCTET\n\
    \   STRING (note that implementations based on an existing OCSP client\n   will\
    \ need to be checked for conformance to this requirement).\n   Servers that receive\
    \ a client hello containing the \"status_request\"\n   extension MAY return a\
    \ suitable certificate status response to the\n   client along with their certificate.\
    \  If OCSP is requested, they\n   SHOULD use the information contained in the\
    \ extension when selecting\n   an OCSP responder and SHOULD include request_extensions\
    \ in the OCSP\n   request.\n   Servers return a certificate response along with\
    \ their certificate by\n   sending a \"CertificateStatus\" message immediately\
    \ after the\n   \"Certificate\" message (and before any \"ServerKeyExchange\"\
    \ or\n   \"CertificateRequest\" messages).  If a server returns a\n   \"CertificateStatus\"\
    \ message, then the server MUST have included an\n   extension of type \"status_request\"\
    \ with empty \"extension_data\" in the\n   extended server hello.\n      struct\
    \ {\n          CertificateStatusType status_type;\n          select (status_type)\
    \ {\n              case ocsp: OCSPResponse;\n          } response;\n      } CertificateStatus;\n\
    \      opaque OCSPResponse<1..2^24-1>;\n   An \"ocsp_response\" contains a complete,\
    \ DER-encoded OCSP response\n   (using the ASN.1 type OCSPResponse defined in\
    \ [OCSP]).  Note that\n   only one OCSP response may be sent.\n   The \"CertificateStatus\"\
    \ message is conveyed using the handshake\n   message type \"certificate_status\"\
    .\n   Note that a server MAY also choose not to send a \"CertificateStatus\"\n\
    \   message, even if it receives a \"status_request\" extension in the\n   client\
    \ hello message.\n   Note in addition that servers MUST NOT send the \"CertificateStatus\"\
    \n   message unless it received a \"status_request\" extension in the client\n\
    \   hello message.\n   Clients requesting an OCSP response and receiving an OCSP\
    \ response in\n   a \"CertificateStatus\" message MUST check the OCSP response\
    \ and abort\n   the handshake if the response is not satisfactory.\n"
- title: 4.  Error Alerts
  contents:
  - "4.  Error Alerts\n   This section defines new error alerts for use with the TLS\
    \ extensions\n   defined in this document.\n   The following new error alerts\
    \ are defined.  To avoid \"breaking\"\n   existing clients and servers, these\
    \ alerts MUST NOT be sent unless\n   the sending party has received an extended\
    \ hello message from the\n   party they are communicating with.\n   -  \"unsupported_extension\"\
    : this alert is sent by clients that\n      receive an extended server hello containing\
    \ an extension that they\n      did not put in the corresponding client hello\
    \ (see Section 2.3).\n      This message is always fatal.\n   -  \"unrecognized_name\"\
    : this alert is sent by servers that receive a\n      server_name extension request,\
    \ but do not recognize the server\n      name.  This message MAY be fatal.\n \
    \  -  \"certificate_unobtainable\": this alert is sent by servers who are\n  \
    \    unable to retrieve a certificate chain from the URL supplied by\n      the\
    \ client (see Section 3.3).  This message MAY be fatal; for\n      example, if\
    \ client authentication is required by the server for\n      the handshake to\
    \ continue and the server is unable to retrieve the\n      certificate chain,\
    \ it may send a fatal alert.\n   -  \"bad_certificate_status_response\": this\
    \ alert is sent by clients\n      that receive an invalid certificate status response\
    \ (see Section\n      3.6).  This message is always fatal.\n   -  \"bad_certificate_hash_value\"\
    : this alert is sent by servers when a\n      certificate hash does not match\
    \ a client-provided\n      certificate_hash.  This message is always fatal.\n\
    \   These error alerts are conveyed using the following syntax:\n      enum {\n\
    \          close_notify(0),\n          unexpected_message(10),\n          bad_record_mac(20),\n\
    \          decryption_failed(21),\n          record_overflow(22),\n          decompression_failure(30),\n\
    \          handshake_failure(40),\n          /* 41 is not defined, for historical\
    \ reasons */\n          bad_certificate(42),\n          unsupported_certificate(43),\n\
    \          certificate_revoked(44),\n          certificate_expired(45),\n    \
    \      certificate_unknown(46),\n          illegal_parameter(47),\n          unknown_ca(48),\n\
    \          access_denied(49),\n          decode_error(50),\n          decrypt_error(51),\n\
    \          export_restriction(60),\n          protocol_version(70),\n        \
    \  insufficient_security(71),\n          internal_error(80),\n          user_canceled(90),\n\
    \          no_renegotiation(100),\n          unsupported_extension(110),     \
    \      /* new */\n          certificate_unobtainable(111),        /* new */\n\
    \          unrecognized_name(112),               /* new */\n          bad_certificate_status_response(113),\
    \ /* new */\n          bad_certificate_hash_value(114),      /* new */\n     \
    \     (255)\n      } AlertDescription;\n"
- title: 5.  Procedure for Defining New Extensions
  contents:
  - "5.  Procedure for Defining New Extensions\n   The list of extension types, as\
    \ defined in Section 2.3, is maintained\n   by the Internet Assigned Numbers Authority\
    \ (IANA).  Thus, an\n   application needs to be made to the IANA in order to obtain\
    \ a new\n   extension type value.  Since there are subtle (and not-so-subtle)\n\
    \   interactions that may occur in this protocol between new features and\n  \
    \ existing features that may result in a significant reduction in\n   overall\
    \ security, new values SHALL be defined only through the IETF\n   Consensus process\
    \ specified in [IANA].\n   (This means that new assignments can be made only via\
    \ RFCs approved\n   by the IESG.)\n   The following considerations should be taken\
    \ into account when\n   designing new extensions:\n   -  All of the extensions\
    \ defined in this document follow the\n      convention that for each extension\
    \ that a client requests and that\n      the server understands, the server replies\
    \ with an extension of\n      the same type.\n   -  Some cases where a server\
    \ does not agree to an extension are error\n      conditions, and some simply\
    \ a refusal to support a particular\n      feature.  In general, error alerts\
    \ should be used for the former,\n      and a field in the server extension response\
    \ for the latter.\n   -  Extensions should as far as possible be designed to prevent\
    \ any\n      attack that forces use (or non-use) of a particular feature by\n\
    \      manipulation of handshake messages.  This principle should be\n      followed\
    \ regardless of whether the feature is believed to cause a\n      security problem.\n\
    \      Often the fact that the extension fields are included in the\n      inputs\
    \ to the Finished message hashes will be sufficient, but\n      extreme care is\
    \ needed when the extension changes the meaning of\n      messages sent in the\
    \ handshake phase.  Designers and implementors\n      should be aware of the fact\
    \ that until the handshake has been\n      authenticated, active attackers can\
    \ modify messages and insert,\n      remove, or replace extensions.\n   -  It\
    \ would be technically possible to use extensions to change major\n      aspects\
    \ of the design of TLS; for example, the design of cipher\n      suite negotiation.\
    \  This is not recommended; it would be more\n      appropriate to define a new\
    \ version of TLS, particularly since the\n      TLS handshake algorithms have\
    \ specific protection against version\n      rollback attacks based on the version\
    \ number.  The possibility of\n      version rollback should be a significant\
    \ consideration in any\n      major design change.\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   Security considerations for the extension mechanism\
    \ in general and\n   for the design of new extensions are described in the previous\n\
    \   section.  A security analysis of each of the extensions defined in\n   this\
    \ document is given below.\n   In general, implementers should continue to monitor\
    \ the state of the\n   art and address any weaknesses identified.\n   Additional\
    \ security considerations are described in the TLS 1.0 RFC\n   [TLS] and the TLS\
    \ 1.1 RFC [TLSbis].\n"
- title: 6.1.  Security of server_name
  contents:
  - "6.1.  Security of server_name\n   If a single server hosts several domains, then\
    \ clearly it is\n   necessary for the owners of each domain to ensure that this\
    \ satisfies\n   their security needs.  Apart from this, server_name does not appear\n\
    \   to introduce significant security issues.\n   Implementations MUST ensure\
    \ that a buffer overflow does not occur,\n   whatever the values of the length\
    \ fields in server_name.\n   Although this document specifies an encoding for\
    \ internationalized\n   hostnames in the server_name extension, it does not address\
    \ any\n   security issues associated with the use of internationalized\n   hostnames\
    \ in TLS (in particular, the consequences of \"spoofed\" names\n   that are indistinguishable\
    \ from another name when displayed or\n   printed).  It is recommended that server\
    \ certificates not be issued\n   for internationalized hostnames unless procedures\
    \ are in place to\n   mitigate the risk of spoofed hostnames.\n"
- title: 6.2.  Security of max_fragment_length
  contents:
  - "6.2.  Security of max_fragment_length\n   The maximum fragment length takes effect\
    \ immediately, including for\n   handshake messages.  However, that does not introduce\
    \ any security\n   complications that are not already present in TLS, since TLS\
    \ requires\n   implementations to be able to handle fragmented handshake messages.\n\
    \   Note that as described in Section 3.2, once a non-null cipher suite\n   has\
    \ been activated, the effective maximum fragment length depends on\n   the cipher\
    \ suite and compression method, as well as on the negotiated\n   max_fragment_length.\
    \  This must be taken into account when sizing\n   buffers, and checking for buffer\
    \ overflow.\n"
- title: 6.3.  Security of client_certificate_url
  contents:
  - "6.3.  Security of client_certificate_url\n   There are two major issues with\
    \ this extension.\n   The first major issue is whether or not clients should include\n\
    \   certificate hashes when they send certificate URLs.\n   When client authentication\
    \ is used *without* the\n   client_certificate_url extension, the client certificate\
    \ chain is\n   covered by the Finished message hashes.  The purpose of including\n\
    \   hashes and checking them against the retrieved certificate chain is\n   to\
    \ ensure that the same property holds when this extension is used,\n   i.e., that\
    \ all of the information in the certificate chain retrieved\n   by the server\
    \ is as the client intended.\n   On the other hand, omitting certificate hashes\
    \ enables functionality\n   that is desirable in some circumstances; for example,\
    \ clients can be\n   issued daily certificates that are stored at a fixed URL\
    \ and need not\n   be provided to the client.  Clients that choose to omit certificate\n\
    \   hashes should be aware of the possibility of an attack in which the\n   attacker\
    \ obtains a valid certificate on the client's key that is\n   different from the\
    \ certificate the client intended to provide.\n   Although TLS uses both MD5 and\
    \ SHA-1 hashes in several other places,\n   this was not believed to be necessary\
    \ here.  The property required of\n   SHA-1 is second pre-image resistance.\n\
    \   The second major issue is that support for client_certificate_url\n   involves\
    \ the server's acting as a client in another URL protocol.\n   The server therefore\
    \ becomes subject to many of the same security\n   concerns that clients of the\
    \ URL scheme are subject to, with the\n   added concern that the client can attempt\
    \ to prompt the server to\n   connect to some (possibly weird-looking) URL.\n\
    \   In general, this issue means that an attacker might use the server to\n  \
    \ indirectly attack another host that is vulnerable to some security\n   flaw.\
    \  It also introduces the possibility of denial of service\n   attacks in which\
    \ an attacker makes many connections to the server,\n   each of which results\
    \ in the server's attempting a connection to the\n   target of the attack.\n \
    \  Note that the server may be behind a firewall or otherwise able to\n   access\
    \ hosts that would not be directly accessible from the public\n   Internet.  This\
    \ could exacerbate the potential security and denial of\n   service problems described\
    \ above, as well as allow the existence of\n   internal hosts to be confirmed\
    \ when they would otherwise be hidden.\n   The detailed security concerns involved\
    \ will depend on the URL\n   schemes supported by the server.  In the case of\
    \ HTTP, the concerns\n   are similar to those that apply to a publicly accessible\
    \ HTTP proxy\n   server.  In the case of HTTPS, loops and deadlocks may be created,\n\
    \   and this should be addressed.  In the case of FTP, attacks arise that\n  \
    \ are similar to FTP bounce attacks.\n   As a result of this issue, it is RECOMMENDED\
    \ that the\n   client_certificate_url extension should have to be specifically\n\
    \   enabled by a server administrator, rather than be enabled by default.\n  \
    \ It is also RECOMMENDED that URI protocols be enabled by the\n   administrator\
    \ individually, and only a minimal set of protocols be\n   enabled.  Unusual protocols\
    \ that offer limited security or whose\n   security is not well-understood SHOULD\
    \ be avoided.\n   As discussed in [URI], URLs that specify ports other than the\
    \ default\n   may cause problems, as may very long URLs (which are more likely\
    \ to\n   be useful in exploiting buffer overflow bugs).\n   Also note that HTTP\
    \ caching proxies are common on the Internet, and\n   some proxies do not check\
    \ for the latest version of an object\n   correctly.  If a request using HTTP\
    \ (or another caching protocol)\n   goes through a misconfigured or otherwise\
    \ broken proxy, the proxy may\n   return an out-of-date response.\n"
- title: 6.4.  Security of trusted_ca_keys
  contents:
  - "6.4.  Security of trusted_ca_keys\n   It is possible that which CA root keys\
    \ a client possesses could be\n   regarded as confidential information.  As a\
    \ result, the CA root key\n   indication extension should be used with care.\n\
    \   The use of the SHA-1 certificate hash alternative ensures that each\n   certificate\
    \ is specified unambiguously.  As for the previous\n   extension, it was not believed\
    \ necessary to use both MD5 and SHA-1\n   hashes.\n"
- title: 6.5.  Security of truncated_hmac
  contents:
  - "6.5.  Security of truncated_hmac\n   It is possible that truncated MACs are weaker\
    \ than \"un-truncated\"\n   MACs.  However, no significant weaknesses are currently\
    \ known or\n   expected to exist for HMAC with MD5 or SHA-1, truncated to 80 bits.\n\
    \   Note that the output length of a MAC need not be as long as the\n   length\
    \ of a symmetric cipher key, since forging of MAC values cannot\n   be done off-line:\
    \ in TLS, a single failed MAC guess will cause the\n   immediate termination of\
    \ the TLS session.\n   Since the MAC algorithm only takes effect after all handshake\n\
    \   messages that affect extension parameters have been authenticated by\n   the\
    \ hashes in the Finished messages, it is not possible for an active\n   attacker\
    \ to force negotiation of the truncated HMAC extension where\n   it would not\
    \ otherwise be used (to the extent that the handshake\n   authentication is secure).\
    \  Therefore, in the event that any security\n   problem were found with truncated\
    \ HMAC in the future, if either the\n   client or the server for a given session\
    \ were updated to take the\n   problem into account, it would be able to veto\
    \ use of this extension.\n"
- title: 6.6.  Security of status_request
  contents:
  - "6.6.  Security of status_request\n   If a client requests an OCSP response, it\
    \ must take into account that\n   an attacker's server using a compromised key\
    \ could (and probably\n   would) pretend not to support the extension.  In this\
    \ case, a client\n   that requires OCSP validation of certificates SHOULD either\
    \ contact\n   the OCSP server directly or abort the handshake.\n   Use of the\
    \ OCSP nonce request extension (id-pkix-ocsp-nonce) may\n   improve security against\
    \ attacks that attempt to replay OCSP\n   responses; see Section 4.4.1 of [OCSP]\
    \ for further details.\n"
- title: 7.  Internationalization Considerations
  contents:
  - "7.  Internationalization Considerations\n   None of the extensions defined here\
    \ directly use strings subject to\n   localization.  Domain Name System (DNS)\
    \ hostnames are encoded using\n   UTF-8.  If future extensions use text strings,\
    \ then\n   internationalization should be considered in their design.\n"
- title: 8.  IANA Considerations
  contents:
  - "8.  IANA Considerations\n   Sections 2.3 and 5 describe a registry of ExtensionType\
    \ values to be\n   maintained by the IANA.  ExtensionType values are to be assigned\
    \ via\n   IETF Consensus as defined in RFC 2434 [IANA].  The initial registry\n\
    \   corresponds to the definition of \"ExtensionType\" in Section 2.3.\n   The\
    \ MIME type \"application/pkix-pkipath\" has been registered by the\n   IANA with\
    \ the following template:\n   To: ietf-types@iana.org\n   Subject: Registration\
    \ of MIME media type application/pkix-pkipath\n   MIME media type name: application\n\
    \   MIME subtype name: pkix-pkipath\n   Required parameters: none\n   Optional\
    \ parameters: version (default value is \"1\")\n   Encoding considerations:\n\
    \      This MIME type is a DER encoding of the ASN.1 type PkiPath,\n      defined\
    \ as follows:\n        PkiPath ::= SEQUENCE OF Certificate\n        PkiPath is\
    \ used to represent a certification path.  Within the\n        sequence, the order\
    \ of certificates is such that the subject of\n        the first certificate is\
    \ the issuer of the second certificate,\n        etc.\n      This is identical\
    \ to the definition published in [X509-4th-TC1];\n      note that it is different\
    \ from that in [X509-4th].\n      All Certificates MUST conform to [PKIX].  (This\
    \ should be\n      interpreted as a requirement to encode only PKIX-conformant\n\
    \      certificates using this type.  It does not necessarily require\n      that\
    \ all certificates that are not strictly PKIX-conformant must\n      be rejected\
    \ by relying parties, although the security consequences\n      of accepting any\
    \ such certificates should be considered\n      carefully.)\n      DER (as opposed\
    \ to BER) encoding MUST be used.  If this type is\n      sent over a 7-bit transport,\
    \ base64 encoding SHOULD be used.\n   Security considerations:\n      The security\
    \ considerations of [X509-4th] and [PKIX] (or any\n      updates to them) apply,\
    \ as well as those of any protocol that uses\n      this type (e.g., TLS).\n \
    \     Note that this type only specifies a certificate chain that can be\n   \
    \   assessed for validity according to the relying party's existing\n      configuration\
    \ of trusted CAs; it is not intended to be used to\n      specify any change to\
    \ that configuration.\n   Interoperability considerations:\n      No specific\
    \ interoperability problems are known with this type,\n      but for recommendations\
    \ relating to X.509 certificates in general,\n      see [PKIX].\n   Published\
    \ specification: RFC 4366 (this memo), and [PKIX].\n   Applications which use\
    \ this media type: TLS.  It may also be used by\n      other protocols, or for\
    \ general interchange of PKIX certificate\n      chains.\n   Additional information:\n\
    \      Magic number(s): DER-encoded ASN.1 can be easily recognized.\n        Further\
    \ parsing is required to distinguish it from other ASN.1\n        types.\n   \
    \   File extension(s): .pkipath\n      Macintosh File Type Code(s): not specified\n\
    \   Person & email address to contact for further information:\n      Magnus Nystrom\
    \ <magnus@rsasecurity.com>\n   Intended usage: COMMON\n   Change controller:\n\
    \      IESG <iesg@ietf.org>\n"
- title: 9.  Acknowledgements
  contents:
  - "9.  Acknowledgements\n   The authors wish to thank the TLS Working Group and\
    \ the WAP Security\n   Group.  This document is based on discussion within these\
    \ groups.\n"
- title: 10.  Normative References
  contents:
  - "10.  Normative References\n   [HMAC]         Krawczyk, H., Bellare, M., and R.\
    \ Canetti, \"HMAC:\n                  Keyed-Hashing for Message Authentication\"\
    , RFC 2104,\n                  February 1997.\n   [HTTP]         Fielding,  R.,\
    \ Gettys, J., Mogul, J., Frystyk, H.,\n                  Masinter, L., Leach,\
    \ P., and T. Berners-Lee,\n                  \"Hypertext Transfer Protocol --\
    \ HTTP/1.1\", RFC 2616,\n                  June 1999.\n   [IANA]         Narten,\
    \ T. and H. Alvestrand, \"Guidelines for Writing\n                  an IANA Considerations\
    \ Section in RFCs\", BCP 26, RFC\n                  2434, October 1998.\n   [IDNA]\
    \         Faltstrom, P., Hoffman, P., and A. Costello,\n                  \"Internationalizing\
    \ Domain Names in Applications\n                  (IDNA)\", RFC 3490, March 2003.\n\
    \   [KEYWORDS]     Bradner, S., \"Key words for use in RFCs to Indicate\n    \
    \              Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [OCSP]\
    \         Myers, M., Ankney, R., Malpani, A., Galperin, S., and\n            \
    \      C. Adams, \"X.509 Internet Public Key Infrastructure\n                \
    \  Online Certificate Status Protocol - OCSP\", RFC 2560,\n                  June\
    \ 1999.\n   [PKIOP]        Housley, R. and P. Hoffman, \"Internet X.509 Public\
    \ Key\n                  Infrastructure Operational Protocols: FTP and HTTP\"\
    ,\n                  RFC 2585, May 1999.\n   [PKIX]         Housley, R., Polk,\
    \ W., Ford, W., and D. Solo,\n                  \"Internet X.509 Public Key Infrastructure\
    \ Certificate\n                  and Certificate Revocation List (CRL) Profile\"\
    , RFC\n                  3280, April 2002.\n   [TLS]          Dierks, T. and C.\
    \ Allen, \"The TLS Protocol Version\n                  1.0\", RFC 2246, January\
    \ 1999.\n   [TLSbis]       Dierks, T. and E. Rescorla, \"The Transport Layer\n\
    \                  Security (TLS) Protocol Version 1.1\", RFC 4346, April\n  \
    \                2006.\n   [URI]          Berners-Lee, T., Fielding, R., and L.\
    \ Masinter,\n                  \"Uniform Resource Identifier (URI): Generic Syntax\"\
    ,\n                  STD 66, RFC 3986, January 2005.\n   [UTF8]         Yergeau,\
    \ F., \"UTF-8, a transformation format of ISO\n                  10646\", STD\
    \ 63, RFC 3629, November 2003.\n   [X509-4th]     ITU-T Recommendation X.509 (2000)\
    \ | ISO/IEC\n                  9594-8:2001, \"Information Systems - Open Systems\n\
    \                  Interconnection - The Directory:  Public key and\n        \
    \          attribute certificate frameworks.\"\n   [X509-4th-TC1] ITU-T Recommendation\
    \ X.509(2000) Corrigendum 1(2001) |\n                  ISO/IEC 9594-8:2001/Cor.1:2002,\
    \ Technical Corrigendum\n                  1 to ISO/IEC 9594:8:2001.\n"
- title: 11.  Informative References
  contents:
  - "11.  Informative References\n   [AESSUITES]    Chown, P., \"Advanced Encryption\
    \ Standard (AES)\n                  Ciphersuites for Transport Layer Security\
    \ (TLS)\", RFC\n                  3268, June 2002.\n   [KERB]         Medvinsky,\
    \ A. and M. Hur, \"Addition of Kerberos Cipher\n                  Suites to Transport\
    \ Layer Security (TLS)\", RFC 2712,\n                  October 1999.\n   [MAILINGLIST]\
    \  J. Mikkelsen, R. Eberhard, and J. Kistler, \"General\n                  ClientHello\
    \ extension mechanism and virtual hosting,\"\n                  ietf-tls mailing\
    \ list posting, August 14, 2000.\n   [RFC3546]      Blake-Wilson, S., Nystrom,\
    \ M., Hopwood, D., Mikkelsen,\n                  J., and T. Wright, \"Transport\
    \ Layer Security (TLS)\n                  Extensions\", RFC 3546, June 2003.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Simon Blake-Wilson\n   BCI\n   EMail: sblakewilson@bcisse.com\n\
    \   Magnus Nystrom\n   RSA Security\n   EMail: magnus@rsasecurity.com\n   David\
    \ Hopwood\n   Independent Consultant\n   EMail: david.hopwood@blueyonder.co.uk\n\
    \   Jan Mikkelsen\n   Transactionware\n   EMail: janm@transactionware.com\n  \
    \ Tim Wright\n   Vodafone\n   EMail: timothy.wright@vodafone.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2006).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is provided by the IETF\n\
    \   Administrative Support Activity (IASA).\n"
