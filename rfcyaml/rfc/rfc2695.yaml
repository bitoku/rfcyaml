- title: __initial_text__
  contents:
  - '                 Authentication Mechanisms for ONC RPC

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n"
- title: ABSTRACT
  contents:
  - "ABSTRACT\n   This document describes two authentication mechanisms created by\
    \ Sun\n   Microsystems that are commonly used in conjunction with the ONC\n  \
    \ Remote Procedure Call (ONC RPC Version 2) protocol.\n"
- title: WARNING
  contents:
  - "WARNING\n   The DH authentication as defined in Section 2 in this document refers\n\
    \   to the authentication mechanism with flavor AUTH_DH currently\n   implemented\
    \ in ONC RPC.  It uses the underlying Diffie-Hellman\n   algorithm for key exchange.\
    \  The DH authentication defined in this\n   document is flawed due to the selection\
    \ of a small prime for the BASE\n   field (Section 2.5). To avoid the flaw a new\
    \ DH authentication\n   mechanism could be defined with a larger prime.  However,\
    \ the new DH\n   authentication would not be interoperable with the existing DH\n\
    \   authentication.\n   As illustrated in [10], a large number of attacks are\
    \ possible on ONC\n   RPC system services that use non-secure authentication mechanisms.\n\
    \   Other secure authentication mechanisms need to be developed for ONC\n   RPC.\
    \  RFC 2203 describes the RPCSEC_GSS ONC RPC security flavor, a\n   secure authentication\
    \ mechanism that enables RPC protocols to use\n   Generic Security Service Application\
    \ Program Interface (RFC 2078) to\n   provide security services, integrity and\
    \ privacy, that are\n   independent of the underlying security mechanisms.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n      1. Introduction ...............................................\
    \ 2\n      2. Diffie-Hellman Authentication .............................. 2\n\
    \      2.1 Naming .................................................... 3\n   \
    \   2.2 DH Authentication Verifiers ............................... 3\n      2.3\
    \ Nicknames and Clock Synchronization ....................... 5\n      2.4 DH\
    \ Authentication Protocol Specification .................. 5\n      2.4.1 The\
    \ Full Network Name Credential and Verifier (Client) .. 6\n      2.4.2 The Nickname\
    \ Credential and Verifier (Client) ........... 8\n      2.4.3 The Nickname Verifier\
    \ (Server) .......................... 9\n      2.5 Diffie-Hellman Encryption .................................\
    \ 9\n      3. Kerberos-based Authentication ............................. 10\n\
    \      3.1 Naming ................................................... 11\n   \
    \   3.2 Kerberos-based Authentication Protocol Specification ..... 11\n      3.2.1\
    \ The Full Network Name Credential and Verifier (Client) . 12\n      3.2.2 The\
    \ Nickname Credential and Verifier (Client) .......... 14\n      3.2.3 The Nickname\
    \ Verifier (Server) ......................... 15\n      3.2.4 Kerberos-specific\
    \ Authentication Status Values ......... 15\n      4. Security Considerations\
    \ ................................... 16\n      5. REFERENCES ................................................\
    \ 16\n      6. AUTHOR'S ADDRESS .......................................... 17\n\
    \      7. FULL COPYRIGHT STATEMENT ...................................18\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   The ONC RPC protocol provides the fields necessary for a\
    \ client to\n   identify itself to a service, and vice-versa, in each call and\
    \ reply\n   message.  Security and access control mechanisms can be built on top\n\
    \   of this message authentication.  Several different authentication\n   protocols\
    \ can be supported.\n   This document specifies two authentication protocols created\
    \ by Sun\n   Microsystems that are commonly used: Diffie-Hellman (DH)\n   authentication\
    \ and Kerberos (Version 4) based authentication.\n   As a prerequisite to reading\
    \ this document, the reader is expected to\n   be familiar with [1] and [2]. \
    \ This document uses terminology and\n   definitions from [1] and [2].\n"
- title: 2. Diffie-Hellman Authentication
  contents:
  - "2. Diffie-Hellman Authentication\n   System authentication (defined in [1]) suffers\
    \ from some problems.\n   It is very UNIX oriented, and can be easily faked (there\
    \ is no\n   attempt to provide cryptographically secure authentication).\n   DH\
    \ authentication was created to address these problems.  However, it\n   has been\
    \ compromised [9] due to the selection of a small length for\n   the prime in\
    \ the ONC RPC implementation.  While the information\n   provided here will be\
    \ useful for implementors to ensure\n   interoperability with existing applications\
    \ that use DH\n   authentication, it is strongly recommended that new applications\
    \ use\n   more secure authentication, and that existing applications that\n  \
    \ currently use DH authentication migrate to more robust authentication\n   mechanisms.\n"
- title: 2.1 Naming
  contents:
  - "2.1 Naming\n   The client is addressed by a simple string of characters instead\
    \ of\n   by an operating system specific integer.  This string of characters\n\
    \   is known as the \"netname\" or network name of the client. The server\n  \
    \ is not allowed to interpret the contents of the client's name in any\n   other\
    \ way except to identify the client.  Thus, netnames should be\n   unique for\
    \ every client in the Internet.\n   It is up to each operating system's implementation\
    \ of DH\n   authentication to generate netnames for its users that insure this\n\
    \   uniqueness when they call upon remote servers.  Operating systems\n   already\
    \ know how to distinguish users local to their systems. It is\n   usually a simple\
    \ matter to extend this mechanism to the network.  For\n   example, a UNIX(tm)\
    \ user at Sun with a user ID of 515 might be\n   assigned the following netname:\
    \ \"unix.515@sun.com\".  This netname\n   contains three items that serve to insure\
    \ it is unique.  Going\n   backwards, there is only one naming domain called \"\
    sun.com\" in the\n   Internet.  Within this domain, there is only one UNIX(tm)\
    \ user with\n   user ID 515.  However, there may be another user on another operating\n\
    \   system, for example VMS, within the same naming domain that, by\n   coincidence,\
    \ happens to have the same user ID. To insure that these\n   two users can be\
    \ distinguished we add the operating system name. So\n   one user is \"unix.515@sun.com\"\
    \ and the other is \"vms.515@sun.com\".\n   The first field is actually a naming\
    \ method rather than an operating\n   system name.  It happens that today there\
    \ is almost a one-to-one\n   correspondence between naming methods and operating\
    \ systems.  If the\n   world could agree on a naming standard, the first field\
    \ could be the\n   name of that standard, instead of an operating system name.\n"
- title: 2.2 DH Authentication Verifiers
  contents:
  - "2.2 DH Authentication Verifiers\n   Unlike System authentication, DH authentication\
    \ does have a verifier\n   so the server can validate the client's credential\
    \ (and vice-versa).\n   The contents of this verifier are primarily an encrypted\
    \ timestamp.\n   The server can decrypt this timestamp, and if it is within an\n\
    \   accepted range relative to the current time, then the client must\n   have\
    \ encrypted it correctly.  The only way the client could encrypt\n   it correctly\
    \ is to know the \"conversation key\" of the RPC session,\n   and if the client\
    \ knows the conversation key, then it must be the\n   real client.\n   The conversation\
    \ key is a DES [5] key which the client generates and\n   passes to the server\
    \ in the first RPC call of a session.  The\n   conversation key is encrypted using\
    \ a public key scheme in this first\n   transaction.  The particular public key\
    \ scheme used in DH\n   authentication is Diffie-Hellman [3] with 192-bit keys.\
    \  The details\n   of this encryption method are described later.\n   The client\
    \ and the server need the same notion of the current time in\n   order for all\
    \ of this to work, perhaps by using the Network Time\n   Protocol [4].  If network\
    \ time synchronization cannot be guaranteed,\n   then the client can determine\
    \ the server's time before beginning the\n   conversation using a time request\
    \ protocol.\n   The way a server determines if a client timestamp is valid is\n\
    \   somewhat complicated. For any other transaction but the first, the\n   server\
    \ just checks for two things:\n   (1) the timestamp is greater than the one previously\
    \ seen from the\n   same client.  (2) the timestamp has not expired.\n   A timestamp\
    \ is expired if the server's time is later than the sum of\n   the client's timestamp\
    \ plus what is known as the client's \"ttl\"\n   (standing for \"time-to-live\"\
    \ - you can think of this as the lifetime\n   for the client's credential).  The\
    \ \"ttl\" is a number the client\n   passes (encrypted) to the server in its first\
    \ transaction.\n   In the first transaction, the server checks only that the timestamp\n\
    \   has not expired.  Also, as an added check, the client sends an\n   encrypted\
    \ item in the first transaction known as the \"ttl verifier\"\n   which must be\
    \ equal to the time-to-live minus 1, or the server will\n   reject the credential.\
    \  If either check fails, the server rejects the\n   credential with an authentication\
    \ status of AUTH_BADCRED, however if\n   the timestamp is earlier than the previous\
    \ one seen, the server\n   returns an authentication status of AUTH_REJECTEDCRED.\n\
    \   The client too must check the verifier returned from the server to be\n  \
    \ sure it is legitimate.  The server sends back to the client the\n   timestamp\
    \ it received from the client, minus one second, encrypted\n   with the conversation\
    \ key.  If the client gets anything different\n   than this, it will reject it,\
    \ returning an AUTH_INVALIDRESP\n   authentication status to the user.\n"
- title: 2.3 Nicknames and Clock Synchronization
  contents:
  - "2.3 Nicknames and Clock Synchronization\n   After the first transaction, the\
    \ server's DH authentication subsystem\n   returns in its verifier to the client\
    \ an integer \"nickname\" which the\n   client may use in its further transactions\
    \ instead of passing its\n   netname. The nickname could be an index into a table\
    \ on the server\n   which stores for each client its netname, decrypted conversation\
    \ key\n   and ttl.\n   Though they originally were synchronized, the client's\
    \ and server's\n   clocks can get out of synchronization again.  When this happens\
    \ the\n   server returns to the client an authentication status of\n   AUTH_REJECTEDVERF\
    \ at which point the client should attempt to\n   resynchronize.\n   A client\
    \ may also get an AUTH_BADCRED error when using a nickname\n   that was previously\
    \ valid.  The reason is that the server's nickname\n   table is a limited size,\
    \ and it may flush entries whenever it wants.\n   A client should resend its original\
    \ full name credential in this case\n   and the server will give it a new nickname.\
    \  If a server crashes, the\n   entire nickname table gets flushed, and all clients\
    \ will have to\n   resend their original credentials.\n"
- title: 2.4 DH Authentication Protocol Specification
  contents:
  - "2.4 DH Authentication Protocol Specification\n   There are two kinds of credentials:\
    \ one in which the client uses its\n   full network name, and one in which it\
    \ uses its \"nickname\" (just an\n   unsigned integer) given to it by the server.\
    \  The client must use its\n   fullname in its first transaction with the server,\
    \ in which the\n   server will return to the client its nickname.  The client\
    \ may use\n   its nickname in all further transactions with the server. There\
    \ is no\n   requirement to use the nickname, but it is wise to use it for\n  \
    \ performance reasons.\n   The following definitions are used for describing the\
    \ protocol:\n      enum authdh_namekind {\n         ADN_FULLNAME = 0,\n      \
    \   ADN_NICKNAME = 1\n      };\n      typedef opaque des_block[8]; /* 64-bit block\
    \ of encrypted data */\n      const MAXNETNAMELEN = 255;   /* maximum length of\
    \ a netname */\n   The flavor used for all DH authentication credentials and verifiers\n\
    \   is \"AUTH_DH\", with the numerical value 3.  The opaque data\n   constituting\
    \ the client credential encodes the following structure:\n   union authdh_cred\
    \ switch (authdh_namekind namekind) {\n   case ADN_FULLNAME:\n      authdh_fullname\
    \ fullname;\n   case ADN_NICKNAME:\n      authdh_nickname nickname;\n   };\n \
    \  The opaque data constituting a verifier that accompanies a client\n   credential\
    \ encodes the following structure:\n   union authdh_verf switch (authdh_namekind\
    \ namekind) {\n   case ADN_FULLNAME:\n      authdh_fullname_verf fullname_verf;\n\
    \   case ADN_NICKNAME:\n      authdh_nickname_verf nickname_verf;\n   };\n   The\
    \ opaque data constituting a verifier returned by a server in\n   response to\
    \ a client request encodes the following structure:\n   struct authdh_server_verf;\n\
    \   These structures are described in detail below.\n"
- title: 2.4.1 The Full Network Name Credential and Verifier (Client)
  contents:
  - "2.4.1 The Full Network Name Credential and Verifier (Client)\n   First, the client\
    \ creates a conversation key for the session. Next,\n   the client fills out the\
    \ following structure:\n      +---------------------------------------------------------------+\n\
    \      |   timestamp   |  timestamp    |               |               |\n   \
    \   |   seconds     | micro seconds |      ttl      |   ttl - 1     |\n      |\
    \   32 bits     |    32 bits    |    32 bits    |   32 bits     |\n      +---------------------------------------------------------------+\n\
    \      0              31              63              95             127\n   The\
    \ fields are stored in XDR (external data representation) format.\n   The timestamp\
    \ encodes the time since midnight, January 1, 1970. These\n   128 bits of data\
    \ are then encrypted in the DES CBC mode, using the\n   conversation key for the\
    \ session, and with an initialization vector\n   of 0.  This yields:\n      +---------------------------------------------------------------+\n\
    \      |               T               |               |               |\n   \
    \   |     T1               T2       |      W1       |     W2        |\n      |\
    \   32 bits     |    32 bits    |    32 bits    |   32 bits     |\n      +---------------------------------------------------------------+\n\
    \      0              31              63              95             127\n   where\
    \ T1, T2, W1, and W2 are all 32-bit quantities, and have some\n   correspondence\
    \ to the original quantities occupying their positions,\n   but are now interdependent\
    \ on each other for proper decryption.  The\n   64 bit sequence comprising T1\
    \ and T2 is denoted by T.\n   The full network name credential is represented\
    \ as follows using XDR\n   notation:\n   struct authdh_fullname {\n      string\
    \ name<MAXNETNAMELEN>;  /* netname of client             */\n      des_block key;\
    \               /* encrypted conversation key    */\n      opaque w1[4];     \
    \           /* W1                            */\n   };\n   The conversation key\
    \ is encrypted using the \"common key\" using the\n   ECB mode.  The common key\
    \ is a DES key that is derived from the\n   Diffie-Hellman public and private\
    \ keys, and is described later.\n   The verifier is represented as follows:\n\
    \   struct authdh_fullname_verf {\n      des_block timestamp;         /* T (the\
    \ 64 bits of T1 and T2) */\n      opaque w2[4];                /* W2         \
    \                  */\n   };\n   Note that all of the encrypted quantities (key,\
    \ w1, w2, timestamp) in\n   the above structures are opaque.\n   The fullname\
    \ credential and its associated verifier together contain\n   the network name\
    \ of the client, an encrypted conversation key, the\n   ttl, a timestamp, and\
    \ a ttl verifier that is one less than the ttl.\n   The ttl is actually the lifetime\
    \ for the credential.  The server will\n   accept the credential if the current\
    \ server time is \"within\" the time\n   indicated in the timestamp plus the ttl.\
    \  Otherwise, the server\n   rejects the credential with an authentication status\
    \ of AUTH_BADCRED.\n   One way to insure that requests are not replayed would\
    \ be for the\n   server to insist that timestamps are greater than the previous\
    \ one\n   seen, unless it is the first transaction.  If the timestamp is\n   earlier\
    \ than the previous one seen, the server returns an\n   authentication status\
    \ of AUTH_REJECTEDCRED.\n   The server returns a authdh_server_verf structure,\
    \ which is described\n   in detail below.  This structure contains a \"nickname\"\
    , which may be\n   used for subsequent requests in the current conversation.\n"
- title: 2.4.2 The Nickname Credential and Verifier (Client)
  contents:
  - "2.4.2 The Nickname Credential and Verifier (Client)\n   In transactions following\
    \ the first, the client may use the shorter\n   nickname credential and verifier\
    \ for efficiency.  First, the client\n   fills out the following structure:\n\
    \      +-------------------------------+\n      |   timestamp   |  timestamp \
    \   |\n      |   seconds     | micro seconds |\n      |   32 bits     |    32\
    \ bits    |\n      +-------------------------------+\n      0              31\
    \              63\n   The fields are stored in XDR (external data representation)\
    \ format.\n   These 64 bits of data are then encrypted in the DES ECB mode, using\n\
    \   the conversation key for the session.  This yields:\n      +-------------------------------+\n\
    \      |     (T1)      |      (T2)     |\n      |               T            \
    \   |\n      |             64 bits           |\n      +-------------------------------+\n\
    \      0              31              63\n   The nickname credential is represented\
    \ as follows using XDR notation:\n   struct authdh_nickname {\n      unsigned\
    \ int nickname;       /* nickname returned by server   */\n   };\n   The nickname\
    \ verifier is represented as follows using XDR notation:\n   struct authdh_nickname_verf\
    \ {\n      des_block timestamp;         /* T (the 64 bits of T1 and T2) */\n \
    \     opaque w[4];                 /* Set to zero                  */\n   };\n\
    \   The nickname credential may be reject by the server for several\n   reasons.\
    \  An authentication status of AUTH_BADCRED indicates that the\n   nickname is\
    \ no longer valid. The client should retry the request\n   using the fullname\
    \ credential.  AUTH_REJECTEDVERF indicates that the\n   nickname verifier is not\
    \ valid.  Again, the client should retry the\n   request using the fullname credential.\n"
- title: 2.4.3 The Nickname Verifier (Server)
  contents:
  - "2.4.3 The Nickname Verifier (Server)\n   The server never returns a credential.\
    \  It returns only one kind of\n   verifier, i.e., the nickname verifier.  This\
    \ has the following XDR\n   representation:\n   struct authdh_server_verf {\n\
    \      des_block timestamp_verf; /* timestamp verifier (encrypted)    */\n   \
    \   unsigned int nickname;    /* new client nickname (unencrypted) */\n   };\n\
    \   The timestamp verifier is constructed in exactly the same way as the\n   client\
    \ nickname credential.  The server sets the timestamp value to\n   the value the\
    \ client sent minus one second and encrypts it in DES ECB\n   mode using the conversation\
    \ key.  The server also sends the client a\n   nickname to be used in future transactions\
    \ (unencrypted).\n"
- title: 2.5 Diffie-Hellman Encryption
  contents:
  - "2.5 Diffie-Hellman Encryption\n   In this scheme, there are two constants \"\
    BASE\" and \"MODULUS\" [3].\n   The particular values Sun has chosen for these\
    \ for the DH\n   authentication protocol are:\n      const BASE = 3;\n      const\
    \ MODULUS = \"d4a0ba0250b6fd2ec626e7efd637df76c716e22d0944b88b\";\n   Note that\
    \ the modulus is represented above as a hexadecimal string.\n   The way this scheme\
    \ works is best explained by an example.  Suppose\n   there are two people \"\
    A\" and \"B\" who want to send encrypted messages\n   to each other.  So, A and\
    \ B both generate \"secret\" keys at random\n   which they do not reveal to anyone.\
    \  Let these keys be represented as\n   SK(A) and SK(B).  They also publish in\
    \ a public directory their\n   \"public\" keys. These keys are computed as follows:\n\
    \      PK(A) = ( BASE ** SK(A) ) mod MODULUS\n      PK(B) = ( BASE ** SK(B) )\
    \ mod MODULUS\n   The \"**\" notation is used here to represent exponentiation.\
    \ Now, both\n   A and B can arrive at the \"common\" key between them, represented\
    \ here\n   as CK(A, B), without revealing their secret keys.\n   A computes:\n\
    \      CK(A, B) = ( PK(B) ** SK(A)) mod MODULUS\n   while B computes:\n      CK(A,\
    \ B) = ( PK(A) ** SK(B)) mod MODULUS\n   These two can be shown to be equivalent:\n\
    \      (PK(B) ** SK(A)) mod MODULUS = (PK(A) ** SK(B)) mod MODULUS\n   We drop\
    \ the \"mod MODULUS\" parts and assume modulo arithmetic to simplify\n   things:\n\
    \      PK(B) ** SK(A) = PK(A) ** SK(B)\n   Then, replace PK(B) by what B computed\
    \ earlier and likewise for PK(A).\n      (BASE ** SK(B)) ** SK(A) = (BASE ** SK(A))\
    \ ** SK(B)\n   which leads to:\n      BASE ** (SK(A) * SK(B)) = BASE ** (SK(A)\
    \ * SK(B))\n   This common key CK(A, B) is not used to encrypt the timestamps\
    \ used\n   in the protocol. Rather, it is used only to encrypt a conversation\n\
    \   key which is then used to encrypt the timestamps.  The reason for\n   doing\
    \ this is to use the common key as little as possible, for fear\n   that it could\
    \ be broken.  Breaking the conversation key is a far less\n   damaging, since\
    \ conversations are relatively short-lived.\n   The conversation key is encrypted\
    \ using 56-bit DES keys, yet the\n   common key is 192 bits.  To reduce the number\
    \ of bits, 56 bits are\n   selected from the common key as follows. The middle-most\
    \ 8-bytes are\n   selected from the common key, and then parity is added to the\
    \ lower\n   order bit of each byte, producing a 56-bit key with 8 bits of parity.\n\
    \   Only 48 bits of the 8-byte conversation key are used in the DH\n   Authentication\
    \ scheme.  The least and most significant bits of each\n   byte of the conversation\
    \ key are unused.\n"
- title: 3. Kerberos-based Authentication
  contents:
  - "3. Kerberos-based Authentication\n   Conceptually, Kerberos-based authentication\
    \ is very similar to DH\n   authentication.  The major difference is, Kerberos-based\n\
    \   authentication takes advantage of the fact that Kerberos tickets have\n  \
    \ encoded in them the client name and the conversation key.  This RFC\n   does\
    \ not describe Kerberos name syntax, protocols and ticket formats.\n   The reader\
    \ is referred to [6], [7], and [8].\n"
- title: 3.1 Naming
  contents:
  - "3.1 Naming\n   A Kerberos name contains three parts.  The first is the principal\n\
    \   name, which is usually a user's or service's name.  The second is the\n  \
    \ instance, which in the case of a user is usually NULL.  Some users\n   may have\
    \ privileged instances, however, such as root or admin.  In\n   the case of a\
    \ service, the instance is the name of the machine on\n   which it runs; that\
    \ is, there can be an NFS service running on the\n   machine ABC, which is different\
    \ from the NFS service running on the\n   machine XYZ.  The third part of a Kerberos\
    \ name is the realm.  The\n   realm corresponds to the Kerberos service providing\
    \ authentication\n   for the principal.  When writing a Kerberos name, the principal\
    \ name\n   is separated from the instance (if not NULL) by a period, and the\n\
    \   realm (if not the local realm) follows, preceded by an \"@\" sign.  The\n\
    \   following are examples of valid Kerberos names:\n      billb\n      jis.admin\n\
    \      srz@lcs.mit.edu\n      treese.root@athena.mit.edu\n"
- title: 3.2 Kerberos-based Authentication Protocol Specification
  contents:
  - "3.2 Kerberos-based Authentication Protocol Specification\n   The Kerberos-based\
    \ authentication protocol described is based on\n   Kerberos version 4.\n   There\
    \ are two kinds of credentials: one in which the client uses its\n   full network\
    \ name, and one in which it uses its \"nickname\" (just an\n   unsigned integer)\
    \ given to it by the server.  The client must use its\n   fullname in its first\
    \ transaction with the server, in which the\n   server will return to the client\
    \ its nickname.  The client may use\n   its nickname in all further transactions\
    \ with the server. There is no\n   requirement to use the nickname, but it is\
    \ wise to use it for\n   performance reasons.\n   The following definitions are\
    \ used for describing the protocol:\n      enum authkerb4_namekind {\n       \
    \  AKN_FULLNAME = 0,\n         AKN_NICKNAME = 1\n      };\n   The flavor used\
    \ for all Kerberos-based authentication credentials and\n   verifiers is \"AUTH_KERB4\"\
    , with numerical value 4.  The opaque data\n   constituting the client credential\
    \ encodes the following structure:\n   union authkerb4_cred switch (authkerb4_namekind\
    \ namekind) {\n   case AKN_FULLNAME:\n      authkerb4_fullname fullname;\n   case\
    \ AKN_NICKNAME:\n      authkerb4_nickname nickname;\n   };\n   The opaque data\
    \ constituting a verifier that accompanies a client\n   credential encodes the\
    \ following structure:\n   union authkerb4_verf switch (authkerb4_namekind namekind)\
    \ {\n   case AKN_FULLNAME:\n      authkerb4_fullname_verf fullname_verf;\n   case\
    \ AKN_NICKNAME:\n      authkerb4_nickname_verf nickname_verf;\n   };\n   The opaque\
    \ data constituting a verifier returned by a server in\n   response to a client\
    \ request encodes the following structure:\n   struct authkerb4_server_verf;\n\
    \   These structures are described in detail below.\n"
- title: 3.2.1 The Full Network Name Credential and Verifier (Client)
  contents:
  - "3.2.1 The Full Network Name Credential and Verifier (Client)\n   First, the client\
    \ must obtain a Kerberos ticket from the Kerberos\n   Server.  The ticket contains\
    \ a Kerberos session key, which will\n   become the conversation key.  Next, the\
    \ client fills out the\n   following structure:\n      +---------------------------------------------------------------+\n\
    \      |   timestamp   |  timestamp    |               |               |\n   \
    \   |   seconds     | micro seconds |      ttl      |   ttl - 1     |\n      |\
    \   32 bits     |    32 bits    |    32 bits    |   32 bits     |\n      +---------------------------------------------------------------+\n\
    \      0              31              63              95             127\n   The\
    \ fields are stored in XDR (external data representation) format.\n   The timestamp\
    \ encodes the time since midnight, January 1, 1970.\n   \"ttl\" is identical in\
    \ meaning to the corresponding field in Diffie-\n   Hellman authentication: the\
    \ credential \"time-to-live\" for the\n   conversation being initiated.  These\
    \ 128 bits of data are then\n   encrypted in the DES CBC mode, using the conversation\
    \ key, and with\n   an initialization vector of 0.  This yields:\n      +---------------------------------------------------------------+\n\
    \      |               T               |               |               |\n   \
    \   |     T1               T2       |      W1       |     W2        |\n      |\
    \   32 bits     |    32 bits    |    32 bits    |   32 bits     |\n      +---------------------------------------------------------------+\n\
    \      0              31              63              95             127\n   where\
    \ T1, T2, W1, and W2 are all 32-bit quantities, and have some\n   correspondence\
    \ to the original quantities occupying their positions,\n   but are now interdependent\
    \ on each other for proper decryption.  The\n   64 bit sequence comprising T1\
    \ and T2 is denoted by T.\n   The full network name credential is represented\
    \ as follows using XDR\n   notation:\n   struct authkerb4_fullname {\n      opaque\
    \ ticket<>;         /* kerberos ticket for the server */\n      opaque w1[4];\
    \            /* W1                             */\n   };\n   The verifier is represented\
    \ as follows:\n   struct authkerb4_fullname_verf {\n      des_block timestamp;\
    \         /* T (the 64 bits of T1 and T2) */\n      opaque w2[4];            \
    \    /* W2                           */\n   };\n   Note that all of the client-encrypted\
    \ quantities (w1, w2, timestamp)\n   in the above structures are opaque.  The\
    \ client does not encrypt the\n   Kerberos ticket for the server.\n   The fullname\
    \ credential and its associated verifier together contain\n   the Kerberos ticket\
    \ (which contains the client name and the\n   conversation key), the ttl, a timestamp,\
    \ and a ttl verifier that is\n   one less than the ttl.  The ttl is actually the\
    \ lifetime for the\n   credential.  The server will accept the credential if the\
    \ current\n   server time is \"within\" the time indicated in the timestamp plus\
    \ the\n   ttl.  Otherwise, the server rejects the credential with an\n   authentication\
    \ status of AUTH_BADCRED.  One way to insure that\n   requests are not replayed\
    \ would be for the server to insist that\n   timestamps are greater than the previous\
    \ one seen, unless it is the\n   first transaction.  If the timestamp is earlier\
    \ than the previous one\n   seen, the server returns an authentication status\
    \ of\n   AUTH_REJECTEDCRED.\n   The server returns a authkerb4_server_verf structure,\
    \ which is\n   described in detail below.  This structure contains a \"nickname\"\
    ,\n   which may be used for subsequent requests in the current session.\n"
- title: 3.2.2 The Nickname Credential and Verifier (Client)
  contents:
  - "3.2.2 The Nickname Credential and Verifier (Client)\n   In transactions following\
    \ the first, the client may use the shorter\n   nickname credential and verifier\
    \ for efficiency.  First, the client\n   fills out the following structure:\n\
    \      +-------------------------------+\n      |   timestamp   |  timestamp \
    \   |\n      |   seconds     | micro seconds |\n      |   32 bits     |    32\
    \ bits    |\n      +-------------------------------+\n      0              31\
    \              63\n   The fields are stored in XDR (external data representation)\
    \ format.\n   These 64 bits of data are then encrypted in the DES ECB mode, using\n\
    \   the conversation key for the session.  This yields:\n      +-------------------------------+\n\
    \      |     (T1)      |      (T2)     |\n      |               T            \
    \   |\n      |             64 bits           |\n      +-------------------------------+\n\
    \      0              31              63\n   The nickname credential is represented\
    \ as follows using XDR notation:\n   struct authkerb4_nickname {\n      unsigned\
    \ int nickname;       /* nickname returned by server   */\n   };\n   The nickname\
    \ verifier is represented as follows using XDR notation:\n   struct authkerb4_nickname_verf\
    \ {\n      des_block timestamp;         /* T (the 64 bits of T1 and T2) */\n \
    \     opaque w[4];                 /* Set to zero                  */\n   };\n\
    \   The nickname credential may be reject by the server for several\n   reasons.\
    \  An authentication status of AUTH_BADCRED indicates that the\n   nickname is\
    \ no longer valid. The client should retry the request\n   using the fullname\
    \ credential.  AUTH_REJECTEDVERF indicates that the\n   nickname verifier is not\
    \ valid.  Again, the client should retry the\n   request using the fullname credential.\
    \  AUTH_TIMEEXPIRE indicates\n   that the session's Kerberos ticket has expired.\
    \  The client should\n   initiate a new session by obtaining a new Kerberos ticket.\n"
- title: 3.2.3 The Nickname Verifier (Server)
  contents:
  - "3.2.3 The Nickname Verifier (Server)\n   The server never returns a credential.\
    \  It returns only one kind of\n   verifier, i.e., the nickname verifier.  This\
    \ has the following XDR\n   representation:\n   struct authkerb4_server_verf {\n\
    \      des_block timestamp_verf; /* timestamp verifier (encrypted)    */\n   \
    \   unsigned int nickname;    /* new client nickname (unencrypted) */\n   };\n\
    \   The timestamp verifier is constructed in exactly the same way as the\n   client\
    \ nickname credential.  The server sets the timestamp value to\n   the value the\
    \ client sent minus one second and encrypts it in DES ECB\n   mode using the conversation\
    \ key.  The server also sends the client a\n   nickname to be used in future transactions\
    \ (unencrypted).\n"
- title: 3.2.4 Kerberos-specific Authentication Status Values
  contents:
  - "3.2.4 Kerberos-specific Authentication Status Values\n   The server may return\
    \ to the client one of the following errors in\n   the authentication status field:\n\
    \  enum auth_stat {\n      ...\n      /*\n       * kerberos errors\n       */\n\
    \      AUTH_KERB_GENERIC = 8,  /* Any Kerberos-specific error other\n        \
    \                         than the following                   */\n      AUTH_TIMEEXPIRE\
    \ = 9,    /* The client's ticket has expired      */\n      AUTH_TKT_FILE = 10,\
    \     /* The server was unable to find the\n                                 ticket\
    \ file.  The client should\n                                 create a new session\
    \ by obtaining a\n                                 new ticket                \
    \           */\n      AUTH_DECODE = 11,       /* The server is unable to decode\
    \ the\n                                 authenticator of the client's ticket */\n\
    \      AUTH_NET_ADDR = 12      /* The network address of the client\n        \
    \                         does not match the address contained\n             \
    \                    in the ticket                        */\n      /* and more\
    \ to be defined */\n  };\n"
- title: 4. Security Considerations
  contents:
  - "4. Security Considerations\n   The DH authentication mechanism and the Kerberos\
    \ V4 authentication\n   mechanism are described in this document only for informational\n\
    \   purposes.\n   In addition to the weakness pointed out earlier in this document\
    \ (see\n   WARNING on page 1), the two security mechanisms described herein lack\n\
    \   the support for integrity and privacy data protection. It is strongly\n  \
    \ recommended that new applications use more secure mechanisms, and\n   that existing\
    \ applications migrate to more robust mechanisms.\n   The RPCSEC_GSS ONC RPC security\
    \ flavor, specified in RFC 2203, allows\n   applications built on top of RPC to\
    \ access security mechanisms that\n   adhere to the GSS-API specification.  It\
    \ provides a GSS-API based\n   security framework that allows for strong security\
    \ mechanisms.  RFC\n   1964 describes the Kerberos Version 5 GSS-API security\
    \ mechanism\n   which provides integrity and privacy, in addition to authentication.\n\
    \   RFC 2623 [14] describes how Kerberos V5 is pluggued into RPCSEC_GSS,\n   and\
    \ how the Version 2 and Version 3 of the NFS protocol use Kerberos\n   V5 via\
    \ RPCSEC_GSS. The RPCSEC_GSS/GSS-API/Kerberos-V5 stack provides\n   a robust security\
    \ mechanism for applications that require strong\n   protection.\n"
- title: 5. REFERENCES
  contents:
  - "5. REFERENCES\n   [1]  Srinivasan, R., \"Remote Procedure Call Protocol Version\
    \ 2\", RFC\n        1831, August 1995.\n   [2]  Srinivasan, R., \"XDR: External\
    \ Data Representation Standard\",\n        RFC 1832, August 1995.\n   [3]  Diffie\
    \ & Hellman, \"New Directions in Cryptography\", IEEE\n        Transactions on\
    \ Information Theory IT-22, November 1976.\n   [4]  Mills, D., \"Network Time\
    \ Protocol (Version 3)\", RFC 1305, March\n        1992.\n   [5]  National Bureau\
    \ of Standards, \"Data Encryption Standard\",\n        Federal Information Processing\
    \ Standards Publication 46, January\n        1977.\n   [6]  Miller, S., Neuman,\
    \ C., Schiller, J. and  J. Saltzer, \"Section\n        E.2.1: Kerberos Authentication\
    \ and Authorization System\",\n        December 1987.\n   [7]  Steiner, J., Neuman,\
    \ C. and J. Schiller, \"Kerberos: An\n        Authentication Service for Open\
    \ Network Systems\", pp. 191-202 in\n        Usenix Conference Proceedings, Dallas,\
    \ Texas, February, 1988.\n   [8]  Kohl, J. and C. Neuman, \"The Kerberos Network\
    \ Authentication\n        Service (V5)\", RFC 1510, September 1993.\n   [9]  La\
    \ Macchia, B.A., and Odlyzko, A.M., \"Computation of Discrete\n        Logarithms\
    \ in Prime Fields\", pp. 47-62 in \"Designs, Codes and\n        Cryptography\"\
    , Kluwer Academic Publishers, 1991.\n   [10] Cheswick, W.R., and Bellovin, S.M.,\
    \ \"Firewalls and Internet\n        Security,\" Addison-Wesley, 1995.\n   [11]\
    \ Linn, J., \"The Kerberos Version 5 GSS-API Mechanism\", RFC 1964,\n        June\
    \ 1996.\n   [12] Linn, J., \"Generic Security Service Application Program\n  \
    \      Interface, Version 2\", RFC 2078, January 1997.\n   [13] Eisler, M., Chiu,\
    \ A., and Ling, L., \"RPCSEC_GSS Protocol\n        Specification\", RFC 2203,\
    \ September 1997.\n   [14] Eisler, M., \"NFS Version 2 and Version 3 Security\
    \ Issues and the\n        NFS Protocol's Use of RPCSEC_GSS and Kerberos V5\",\
    \ RFC 2623,\n        June 1999.\n"
- title: 6. AUTHOR'S ADDRESS
  contents:
  - "6. AUTHOR'S ADDRESS\n   Alex Chiu\n   Sun Microsystems, Inc.\n   901 San Antonio\
    \ Road\n   Palo Alto, CA 94303\n   Phone: +1 (650) 786-6465\n   EMail: alex.chiu@Eng.sun.com\n"
- title: 7.  Full Copyright Statement
  contents:
  - "7.  Full Copyright Statement\n   Copyright (C) The Internet Society (1999). \
    \ All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
