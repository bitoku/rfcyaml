- title: __initial_text__
  contents:
  - '          PKCS #1: RSA Cryptography Specifications Version 2.2

    '
- title: Abstract
  contents:
  - "Abstract\n   This document provides recommendations for the implementation of\n\
    \   public-key cryptography based on the RSA algorithm, covering\n   cryptographic\
    \ primitives, encryption schemes, signature schemes with\n   appendix, and ASN.1\
    \ syntax for representing keys and for identifying\n   the schemes.\n   This document\
    \ represents a republication of PKCS #1 v2.2 from RSA\n   Laboratories' Public-Key\
    \ Cryptography Standards (PKCS) series.  By\n   publishing this RFC, change control\
    \ is transferred to the IETF.\n   This document also obsoletes RFC 3447.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 7841.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc8017.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2016 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   4\n     1.1.  Requirements Language . . . . . . . . . . . . . .\
    \ . . . .   5\n   2.  Notation  . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . .   6\n   3.  Key Types . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . .   8\n     3.1.  RSA Public Key  . . . . . . . . . . . . . . . . . . . .\
    \ .   8\n     3.2.  RSA Private Key . . . . . . . . . . . . . . . . . . . . .\
    \   9\n   4.  Data Conversion Primitives  . . . . . . . . . . . . . . . . .  11\n\
    \     4.1.  I2OSP . . . . . . . . . . . . . . . . . . . . . . . . . .  11\n  \
    \   4.2.  OS2IP . . . . . . . . . . . . . . . . . . . . . . . . . .  12\n   5.\
    \  Cryptographic Primitives  . . . . . . . . . . . . . . . . . .  12\n     5.1.\
    \  Encryption and Decryption Primitives  . . . . . . . . . .  12\n       5.1.1.\
    \  RSAEP . . . . . . . . . . . . . . . . . . . . . . . .  13\n       5.1.2.  RSADP\
    \ . . . . . . . . . . . . . . . . . . . . . . . .  13\n     5.2.  Signature and\
    \ Verification Primitives . . . . . . . . . .  15\n       5.2.1.  RSASP1  . .\
    \ . . . . . . . . . . . . . . . . . . . . .  15\n       5.2.2.  RSAVP1  . . .\
    \ . . . . . . . . . . . . . . . . . . . .  16\n   6.  Overview of Schemes . .\
    \ . . . . . . . . . . . . . . . . . . .  17\n   7.  Encryption Schemes  . . .\
    \ . . . . . . . . . . . . . . . . . .  18\n     7.1.  RSAES-OAEP  . . . . . .\
    \ . . . . . . . . . . . . . . . . .  19\n       7.1.1.  Encryption Operation \
    \ . . . . . . . . . . . . . . . .  22\n       7.1.2.  Decryption Operation  .\
    \ . . . . . . . . . . . . . . .  25\n     7.2.  RSAES-PKCS1-v1_5  . . . . . .\
    \ . . . . . . . . . . . . . .  27\n       7.2.1.  Encryption Operation  . . .\
    \ . . . . . . . . . . . . .  28\n       7.2.2.  Decryption Operation  . . . .\
    \ . . . . . . . . . . . .  29\n   8.  Signature Scheme with Appendix  . . . .\
    \ . . . . . . . . . . .  31\n     8.1.  RSASSA-PSS  . . . . . . . . . . . . .\
    \ . . . . . . . . . .  32\n       8.1.1.  Signature Generation Operation  . .\
    \ . . . . . . . . .  33\n       8.1.2.  Signature Verification Operation  . .\
    \ . . . . . . . .  34\n     8.2.  RSASSA-PKCS1-v1_5 . . . . . . . . . . . . .\
    \ . . . . . . .  35\n       8.2.1.  Signature Generation Operation  . . . . .\
    \ . . . . . .  36\n       8.2.2.  Signature Verification Operation  . . . . .\
    \ . . . . .  37\n   9.  Encoding Methods for Signatures with Appendix . . . .\
    \ . . . .  39\n     9.1.  EMSA-PSS  . . . . . . . . . . . . . . . . . . . . .\
    \ . . .  40\n       9.1.1.  Encoding Operation  . . . . . . . . . . . . . . .\
    \ . .  42\n       9.1.2.  Verification Operation  . . . . . . . . . . . . . .\
    \ .  44\n     9.2.  EMSA-PKCS1-v1_5 . . . . . . . . . . . . . . . . . . . . .\
    \  45\n   10. Security Considerations . . . . . . . . . . . . . . . . . . .  47\n\
    \   11. References  . . . . . . . . . . . . . . . . . . . . . . . . .  48\n  \
    \   11.1.  Normative References . . . . . . . . . . . . . . . . . .  48\n    \
    \ 11.2.  Informative References . . . . . . . . . . . . . . . . .  48\n   Appendix\
    \ A.  ASN.1 Syntax . . . . . . . . . . . . . . . . . . . .  54\n     A.1.  RSA\
    \ Key Representation  . . . . . . . . . . . . . . . . .  54\n       A.1.1.  RSA\
    \ Public Key Syntax . . . . . . . . . . . . . . . .  54\n       A.1.2.  RSA Private\
    \ Key Syntax  . . . . . . . . . . . . . . .  55\n     A.2.  Scheme Identification\
    \ . . . . . . . . . . . . . . . . . .  57\n       A.2.1.  RSAES-OAEP  . . . .\
    \ . . . . . . . . . . . . . . . . .  57\n       A.2.2.  RSAES-PKCS-v1_5 . . .\
    \ . . . . . . . . . . . . . . . .  60\n       A.2.3.  RSASSA-PSS  . . . . . .\
    \ . . . . . . . . . . . . . . .  60\n       A.2.4.  RSASSA-PKCS-v1_5  . . . .\
    \ . . . . . . . . . . . . . .  62\n   Appendix B.  Supporting Techniques  . .\
    \ . . . . . . . . . . . . .  63\n     B.1.  Hash Functions  . . . . . . . . .\
    \ . . . . . . . . . . . .  63\n     B.2.  Mask Generation Functions . . . . .\
    \ . . . . . . . . . . .  66\n       B.2.1.  MGF1  . . . . . . . . . . . . . .\
    \ . . . . . . . . . .  67\n   Appendix C.  ASN.1 Module . . . . . . . . . . .\
    \ . . . . . . . . .  68\n   Appendix D.  Revision History of PKCS #1  . . . .\
    \ . . . . . . . .  76\n   Appendix E.  About PKCS . . . . . . . . . . . . . .\
    \ . . . . . . .  77\n   Acknowledgements  . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  78\n   Authors' Addresses  . . . . . . . . . . . . . . . . . .\
    \ . . . . .  78\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document provides recommendations for the implementation\
    \ of\n   public-key cryptography based on the RSA algorithm [RSA], covering\n\
    \   the following aspects:\n   o  Cryptographic primitives\n   o  Encryption schemes\n\
    \   o  Signature schemes with appendix\n   o  ASN.1 syntax for representing keys\
    \ and for identifying the schemes\n   The recommendations are intended for general\
    \ application within\n   computer and communications systems and as such include\
    \ a fair amount\n   of flexibility.  It is expected that application standards\
    \ based on\n   these specifications may include additional constraints.  The\n\
    \   recommendations are intended to be compatible with the standards IEEE\n  \
    \ 1363 [IEEE1363], IEEE 1363a [IEEE1363A], and ANSI X9.44 [ANSIX944].\n   This\
    \ document supersedes PKCS #1 version 2.1 [RFC3447] but includes\n   compatible\
    \ techniques.\n   The organization of this document is as follows:\n   o  Section\
    \ 1 is an introduction.\n   o  Section 2 defines some notation used in this document.\n\
    \   o  Section 3 defines the RSA public and private key types.\n   o  Sections\
    \ 4 and 5 define several primitives, or basic mathematical\n      operations.\
    \  Data conversion primitives are in Section 4, and\n      cryptographic primitives\
    \ (encryption-decryption and signature-\n      verification) are in Section 5.\n\
    \   o  Sections 6, 7, and 8 deal with the encryption and signature\n      schemes\
    \ in this document.  Section 6 gives an overview.  Along\n      with the methods\
    \ found in PKCS #1 v1.5, Section 7 defines an\n      encryption scheme based on\
    \ Optimal Asymmetric Encryption Padding\n      (OAEP) [OAEP], and Section 8 defines\
    \ a signature scheme with\n      appendix based on the Probabilistic Signature\
    \ Scheme (PSS)\n      [RSARABIN] [PSS].\n   o  Section 9 defines the encoding\
    \ methods for the signature schemes\n      in Section 8.\n   o  Appendix A defines\
    \ the ASN.1 syntax for the keys defined in\n      Section 3 and the schemes in\
    \ Sections 7 and 8.\n   o  Appendix B defines the hash functions and the mask\
    \ generation\n      function (MGF) used in this document, including ASN.1 syntax\
    \ for\n      the techniques.\n   o  Appendix C gives an ASN.1 module.\n   o  Appendices\
    \ D and E outline the revision history of PKCS #1 and\n      provide general information\
    \ about the Public-Key Cryptography\n      Standards.\n   This document represents\
    \ a republication of PKCS #1 v2.2 [PKCS1_22]\n   from RSA Laboratories' Public-Key\
    \ Cryptography Standards (PKCS)\n   series.\n"
- title: 1.1.  Requirements Language
  contents:
  - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n"
- title: 2.  Notation
  contents:
  - "2.  Notation\n   The notation in this document includes:\n      c           \
    \   ciphertext representative, an integer between 0 and\n                    \
    \ n-1\n      C              ciphertext, an octet string\n      d             \
    \ RSA private exponent\n      d_i            additional factor r_i's CRT exponent,\n\
    \                     a positive integer such that\n                       e *\
    \ d_i == 1 (mod (r_i-1)), i = 3, ..., u\n      dP             p's CRT exponent,\
    \ a positive integer such that\n                       e * dP == 1 (mod (p-1))\n\
    \      dQ             q's CRT exponent, a positive integer such that\n       \
    \                e * dQ == 1 (mod (q-1))\n      e              RSA public exponent\n\
    \      EM             encoded message, an octet string\n      emBits         (intended)\
    \ length in bits of an encoded message EM\n      emLen          (intended) length\
    \ in octets of an encoded message\n                     EM\n      GCD(. , .) \
    \    greatest common divisor of two nonnegative integers\n      Hash         \
    \  hash function\n      hLen           output length in octets of hash function\
    \ Hash\n      k              length in octets of the RSA modulus n\n      K  \
    \            RSA private key\n      L              optional RSAES-OAEP label,\
    \ an octet string\n      LCM(., ..., .) least common multiple of a list of nonnegative\n\
    \                     integers\n      m              message representative, an\
    \ integer between 0 and\n                     n-1\n      M              message,\
    \ an octet string\n      mask           MGF output, an octet string\n      maskLen\
    \        (intended) length of the octet string mask\n      MGF            mask\
    \ generation function\n      mgfSeed        seed from which mask is generated,\
    \ an octet string\n      mLen           length in octets of a message M\n    \
    \  n              RSA modulus, n = r_1 * r_2 * ... * r_u , u >= 2\n      (n, e)\
    \         RSA public key\n      p, q           first two prime factors of the\
    \ RSA modulus n\n      qInv           CRT coefficient, a positive integer less\
    \ than\n                     p such that q * qInv == 1 (mod p)\n      r_i    \
    \        prime factors of the RSA modulus n, including\n                     r_1\
    \ = p, r_2 = q, and additional factors if any\n      s              signature\
    \ representative, an integer between 0 and\n                     n-1\n      S\
    \              signature, an octet string\n      sLen           length in octets\
    \ of the EMSA-PSS salt\n      t_i            additional prime factor r_i's CRT\
    \ coefficient, a\n                     positive integer less than r_i such that\n\
    \                       r_1 * r_2 * ... * r_(i-1) * t_i == 1 (mod r_i) ,\n   \
    \                  i = 3, ... , u\n      u              number of prime factors\
    \ of the RSA modulus, u >= 2\n      x              a nonnegative integer\n   \
    \   X              an octet string corresponding to x\n      xLen           (intended)\
    \ length of the octet string X\n      0x             indicator of hexadecimal\
    \ representation of an octet\n                     or an octet string: \"0x48\"\
    \ denotes the octet with\n                     hexadecimal value 48; \"(0x)48\
    \ 09 0e\" denotes the\n                     string of three consecutive octets\
    \ with hexadecimal\n                     values 48, 09, and 0e, respectively\n\
    \      \\lambda(n)     LCM(r_1-1, r_2-1, ... , r_u-1)\n      \\xor           bit-wise\
    \ exclusive-or of two octet strings\n      \\ceil(.)       ceiling function; \\\
    ceil(x) is the smallest integer\n                     larger than or equal to\
    \ the real number x\n      ||             concatenation operator\n      ==   \
    \          congruence symbol; a == b (mod n) means that the\n                \
    \     integer n divides the integer a - b\n   Note: The Chinese Remainder Theorem\
    \ (CRT) can be applied in a non-\n   recursive as well as a recursive way.  In\
    \ this document, a recursive\n   approach following Garner's algorithm [GARNER]\
    \ is used.  See also\n   Note 1 in Section 3.2.\n"
- title: 3.  Key Types
  contents:
  - "3.  Key Types\n   Two key types are employed in the primitives and schemes defined\
    \ in\n   this document: RSA public key and RSA private key.  Together, an RSA\n\
    \   public key and an RSA private key form an RSA key pair.\n   This specification\
    \ supports so-called \"multi-prime\" RSA where the\n   modulus may have more than\
    \ two prime factors.  The benefit of multi-\n   prime RSA is lower computational\
    \ cost for the decryption and\n   signature primitives, provided that the CRT\
    \ is used.  Better\n   performance can be achieved on single processor platforms,\
    \ but to a\n   greater extent on multiprocessor platforms, where the modular\n\
    \   exponentiations involved can be done in parallel.\n   For a discussion on\
    \ how multi-prime affects the security of the RSA\n   cryptosystem, the reader\
    \ is referred to [SILVERMAN].\n"
- title: 3.1.  RSA Public Key
  contents:
  - "3.1.  RSA Public Key\n   For the purposes of this document, an RSA public key\
    \ consists of two\n   components:\n         n        the RSA modulus, a positive\
    \ integer\n         e        the RSA public exponent, a positive integer\n   In\
    \ a valid RSA public key, the RSA modulus n is a product of u\n   distinct odd\
    \ primes r_i, i = 1, 2, ..., u, where u >= 2, and the RSA\n   public exponent\
    \ e is an integer between 3 and n - 1 satisfying\n   GCD(e,\\lambda(n)) = 1, where\
    \ \\lambda(n) = LCM(r_1 - 1, ..., r_u - 1).\n   By convention, the first two primes\
    \ r_1 and r_2 may also be denoted p\n   and q, respectively.\n   A recommended\
    \ syntax for interchanging RSA public keys between\n   implementations is given\
    \ in Appendix A.1.1; an implementation's\n   internal representation may differ.\n"
- title: 3.2.  RSA Private Key
  contents:
  - "3.2.  RSA Private Key\n   For the purposes of this document, an RSA private key\
    \ may have either\n   of two representations.\n   1.  The first representation\
    \ consists of the pair (n, d), where the\n       components have the following\
    \ meanings:\n            n       the RSA modulus, a positive integer\n       \
    \     d       the RSA private exponent, a positive integer\n   2.  The second\
    \ representation consists of a quintuple (p, q, dP, dQ,\n       qInv) and a (possibly\
    \ empty) sequence of triplets (r_i, d_i,\n       t_i), i = 3, ..., u, one for\
    \ each prime not in the quintuple,\n       where the components have the following\
    \ meanings:\n            p      the first factor, a positive integer\n       \
    \     q      the second factor, a positive integer\n            dP     the first\
    \ factor's CRT exponent, a positive integer\n            dQ     the second factor's\
    \ CRT exponent, a positive integer\n            qInv   the (first) CRT coefficient,\
    \ a positive integer\n            r_i    the i-th factor, a positive integer\n\
    \            d_i    the i-th factor's CRT exponent, a positive integer\n     \
    \       t_i    the i-th factor's CRT coefficient, a positive integer\n   In a\
    \ valid RSA private key with the first representation, the RSA\n   modulus n is\
    \ the same as in the corresponding RSA public key and is\n   the product of u\
    \ distinct odd primes r_i, i = 1, 2, ..., u, where u\n   >= 2.  The RSA private\
    \ exponent d is a positive integer less than n\n   satisfying\n      e * d ==\
    \ 1 (mod \\lambda(n)),\n   where e is the corresponding RSA public exponent and\
    \ \\lambda(n) is\n   defined as in Section 3.1.\n   In a valid RSA private key\
    \ with the second representation, the two\n   factors p and q are the first two\
    \ prime factors of the RSA modulus n\n   (i.e., r_1 and r_2); the CRT exponents\
    \ dP and dQ are positive\n   integers less than p and q, respectively, satisfying\n\
    \      e * dP == 1 (mod (p-1))\n      e * dQ == 1 (mod (q-1)) ,\n   and the CRT\
    \ coefficient qInv is a positive integer less than p\n   satisfying\n      q *\
    \ qInv == 1 (mod p).\n   If u > 2, the representation will include one or more\
    \ triplets (r_i,\n   d_i, t_i), i = 3, ..., u.  The factors r_i are the additional\
    \ prime\n   factors of the RSA modulus n.  Each CRT exponent d_i (i = 3, ...,\
    \ u)\n   satisfies\n      e * d_i == 1 (mod (r_i - 1)).\n   Each CRT coefficient\
    \ t_i (i = 3, ..., u) is a positive integer less\n   than r_i satisfying\n   \
    \   R_i * t_i == 1 (mod r_i) ,\n   where R_i = r_1 * r_2 * ... * r_(i-1).\n  \
    \ A recommended syntax for interchanging RSA private keys between\n   implementations,\
    \ which includes components from both representations,\n   is given in Appendix\
    \ A.1.2; an implementation's internal\n   representation may differ.\n   Notes:\n\
    \   1.  The definition of the CRT coefficients here and the formulas that\n  \
    \     use them in the primitives in Section 5 generally follow Garner's\n    \
    \   algorithm [GARNER] (see also Algorithm 14.71 in [HANDBOOK]).\n       However,\
    \ for compatibility with the representations of RSA\n       private keys in PKCS\
    \ #1 v2.0 and previous versions, the roles of\n       p and q are reversed compared\
    \ to the rest of the primes.  Thus,\n       the first CRT coefficient, qInv, is\
    \ defined as the inverse of q\n       mod p, rather than as the inverse of R_1\
    \ mod r_2, i.e., of\n       p mod q.\n   2.  Quisquater and Couvreur [FASTDEC]\
    \ observed the benefit of\n       applying the CRT to RSA operations.\n"
- title: 4.  Data Conversion Primitives
  contents:
  - "4.  Data Conversion Primitives\n   Two data conversion primitives are employed\
    \ in the schemes defined in\n   this document:\n   o  I2OSP - Integer-to-Octet-String\
    \ primitive\n   o  OS2IP - Octet-String-to-Integer primitive\n   For the purposes\
    \ of this document, and consistent with ASN.1 syntax,\n   an octet string is an\
    \ ordered sequence of octets (eight-bit bytes).\n   The sequence is indexed from\
    \ first (conventionally, leftmost) to last\n   (rightmost).  For purposes of conversion\
    \ to and from integers, the\n   first octet is considered the most significant\
    \ in the following\n   conversion primitives.\n"
- title: 4.1.  I2OSP
  contents:
  - "4.1.  I2OSP\n   I2OSP converts a nonnegative integer to an octet string of a\n\
    \   specified length.\n   I2OSP (x, xLen)\n   Input:\n      x        nonnegative\
    \ integer to be converted\n      xLen     intended length of the resulting octet\
    \ string\n   Output:\n         X corresponding octet string of length xLen\n \
    \  Error:  \"integer too large\"\n   Steps:\n      1.  If x >= 256^xLen, output\
    \ \"integer too large\" and stop.\n      2.  Write the integer x in its unique\
    \ xLen-digit representation in\n          base 256:\n             x = x_(xLen-1)\
    \ 256^(xLen-1) + x_(xLen-2) 256^(xLen-2) + ...\n             + x_1 256 + x_0,\n\
    \          where 0 <= x_i < 256 (note that one or more leading digits\n      \
    \    will be zero if x is less than 256^(xLen-1)).\n      3.  Let the octet X_i\
    \ have the integer value x_(xLen-i) for 1 <= i\n          <= xLen.  Output the\
    \ octet string\n             X = X_1 X_2 ... X_xLen.\n"
- title: 4.2.  OS2IP
  contents:
  - "4.2.  OS2IP\n   OS2IP converts an octet string to a nonnegative integer.\n  \
    \ OS2IP (X)\n   Input:  X octet string to be converted\n   Output:  x corresponding\
    \ nonnegative integer\n   Steps:\n      1.  Let X_1 X_2 ... X_xLen be the octets\
    \ of X from first to last,\n          and let x_(xLen-i) be the integer value\
    \ of the octet X_i for 1\n          <= i <= xLen.\n      2.  Let x = x_(xLen-1)\
    \ 256^(xLen-1) + x_(xLen-2) 256^(xLen-2) +\n          ...  + x_1 256 + x_0.\n\
    \      3.  Output x.\n"
- title: 5.  Cryptographic Primitives
  contents:
  - "5.  Cryptographic Primitives\n   Cryptographic primitives are basic mathematical\
    \ operations on which\n   cryptographic schemes can be built.  They are intended\
    \ for\n   implementation in hardware or as software modules and are not\n   intended\
    \ to provide security apart from a scheme.\n   Four types of primitive are specified\
    \ in this document, organized in\n   pairs: encryption and decryption; and signature\
    \ and verification.\n   The specifications of the primitives assume that certain\
    \ conditions\n   are met by the inputs, in particular that RSA public and private\
    \ keys\n   are valid.\n"
- title: 5.1.  Encryption and Decryption Primitives
  contents:
  - "5.1.  Encryption and Decryption Primitives\n   An encryption primitive produces\
    \ a ciphertext representative from a\n   message representative under the control\
    \ of a public key, and a\n   decryption primitive recovers the message representative\
    \ from the\n   ciphertext representative under the control of the corresponding\n\
    \   private key.\n   One pair of encryption and decryption primitives is employed\
    \ in the\n   encryption schemes defined in this document and is specified here:\n\
    \   RSA Encryption Primitive (RSAEP) / RSA Decryption Primitive (RSADP).\n   RSAEP\
    \ and RSADP involve the same mathematical operation, with\n   different keys as\
    \ input.  The primitives defined here are the same as\n   Integer Factorization\
    \ Encryption Primitive using RSA (IFEP-RSA) /\n   Integer Factorization Decryption\
    \ Primitive using RSA (IFDP-RSA) in\n   IEEE 1363 [IEEE1363] (except that support\
    \ for multi-prime RSA has\n   been added) and are compatible with PKCS #1 v1.5.\n\
    \   The main mathematical operation in each primitive is exponentiation.\n"
- title: 5.1.1.  RSAEP
  contents:
  - "5.1.1.  RSAEP\n   RSAEP ((n, e), m)\n   Input:\n         (n, e) RSA public key\n\
    \         m message representative, an integer between 0 and n - 1\n   Output:\
    \  c ciphertext representative, an integer between 0 and n - 1\n   Error:  \"\
    message representative out of range\"\n   Assumption:  RSA public key (n, e) is\
    \ valid\n   Steps:\n      1.  If the message representative m is not between 0\
    \ and n - 1,\n          output \"message representative out of range\" and stop.\n\
    \      2.  Let c = m^e mod n.\n      3.  Output c.\n"
- title: 5.1.2.  RSADP
  contents:
  - "5.1.2.  RSADP\n   RSADP (K, c)\n   Input:\n         K RSA private key, where\
    \ K has one of the following forms:\n         +  a pair (n, d)\n         +  a\
    \ quintuple (p, q, dP, dQ, qInv) and a possibly empty\n            sequence of\
    \ triplets (r_i, d_i, t_i), i = 3, ..., u\n         c ciphertext representative,\
    \ an integer between 0 and n - 1\n   Output:  m message representative, an integer\
    \ between 0 and n - 1\n   Error:  \"ciphertext representative out of range\"\n\
    \   Assumption:  RSA private key K is valid\n   Steps:\n      1.  If the ciphertext\
    \ representative c is not between 0 and n - 1,\n          output \"ciphertext\
    \ representative out of range\" and stop.\n      2.  The message representative\
    \ m is computed as follows.\n          a.  If the first form (n, d) of K is used,\
    \ let m = c^d mod n.\n          b.  If the second form (p, q, dP, dQ, qInv) and\
    \ (r_i, d_i,\n              t_i) of K is used, proceed as follows:\n         \
    \     i.   Let m_1 = c^dP mod p and m_2 = c^dQ mod q.\n              ii.  If u\
    \ > 2, let m_i = c^(d_i) mod r_i, i = 3, ..., u.\n              iii. Let h = (m_1\
    \ - m_2) * qInv mod p.\n              iv.  Let m = m_2 + q * h.\n            \
    \  v.   If u > 2, let R = r_1 and for i = 3 to u do\n                   1.  Let\
    \ R = R * r_(i-1).\n                   2.  Let h = (m_i - m) * t_i mod r_i.\n\
    \                   3.  Let m = m + R * h.\n      3.  Output m.\n   Note: Step\
    \ 2.b can be rewritten as a single loop, provided that one\n   reverses the order\
    \ of p and q.  For consistency with PKCS #1 v2.0,\n   however, the first two primes\
    \ p and q are treated separately from the\n   additional primes.\n"
- title: 5.2.  Signature and Verification Primitives
  contents:
  - "5.2.  Signature and Verification Primitives\n   A signature primitive produces\
    \ a signature representative from a\n   message representative under the control\
    \ of a private key, and a\n   verification primitive recovers the message representative\
    \ from the\n   signature representative under the control of the corresponding\n\
    \   public key.  One pair of signature and verification primitives is\n   employed\
    \ in the signature schemes defined in this document and is\n   specified here:\
    \ RSA Signature Primitive, version 1 (RSASP1) / RSA\n   Verification Primitive,\
    \ version 1 (RSAVP1).\n   The primitives defined here are the same as Integer\
    \ Factorization\n   Signature Primitive using RSA, version 1 (IFSP-RSA1) / Integer\n\
    \   Factorization Verification Primitive using RSA, version 1 (IFVP-RSA1)\n  \
    \ in IEEE 1363 [IEEE1363] (except that support for multi-prime RSA has\n   been\
    \ added) and are compatible with PKCS #1 v1.5.\n   The main mathematical operation\
    \ in each primitive is exponentiation,\n   as in the encryption and decryption\
    \ primitives of Section 5.1.\n   RSASP1 and RSAVP1 are the same as RSADP and RSAEP\
    \ except for the\n   names of their input and output arguments; they are distinguished\
    \ as\n   they are intended for different purposes.\n"
- title: 5.2.1.  RSASP1
  contents:
  - "5.2.1.  RSASP1\n   RSASP1 (K, m)\n   Input:\n      K        RSA private key,\
    \ where K has one of the following forms:\n               - a pair (n, d)\n  \
    \             - a quintuple (p, q, dP, dQ, qInv) and a (possibly empty)\n    \
    \             sequence of triplets (r_i, d_i, t_i), i = 3, ..., u\n      m   \
    \     message representative, an integer between 0 and n - 1\n   Output:\n   \
    \   s        signature representative, an integer between 0 and n - 1\n   Error:\
    \  \"message representative out of range\"\n   Assumption:  RSA private key K\
    \ is valid\n   Steps:\n      1.  If the message representative m is not between\
    \ 0 and n - 1,\n          output \"message representative out of range\" and stop.\n\
    \      2.  The signature representative s is computed as follows.\n          a.\
    \  If the first form (n, d) of K is used, let s = m^d mod n.\n          b.  If\
    \ the second form (p, q, dP, dQ, qInv) and (r_i, d_i,\n              t_i) of K\
    \ is used, proceed as follows:\n              1.  Let s_1 = m^dP mod p and s_2\
    \ = m^dQ mod q.\n              2.  If u > 2, let s_i = m^(d_i) mod r_i, i = 3,\
    \ ..., u.\n              3.  Let h = (s_1 - s_2) * qInv mod p.\n             \
    \ 4.  Let s = s_2 + q * h.\n              5.  If u > 2, let R = r_1 and for i\
    \ = 3 to u do\n                  a.  Let R = R * r_(i-1).\n                  b.\
    \  Let h = (s_i - s) * t_i mod r_i.\n                  c.  Let s = s + R * h.\n\
    \      3.  Output s.\n   Note: Step 2.b can be rewritten as a single loop, provided\
    \ that one\n   reverses the order of p and q.  For consistency with PKCS #1 v2.0,\n\
    \   however, the first two primes p and q are treated separately from the\n  \
    \ additional primes.\n"
- title: 5.2.2.  RSAVP1
  contents:
  - "5.2.2.  RSAVP1\n   RSAVP1 ((n, e), s)\n   Input:\n         (n, e) RSA public\
    \ key\n         s signature representative, an integer between 0 and n - 1\n \
    \  Output:\n         m message representative, an integer between 0 and n - 1\n\
    \   Error:  \"signature representative out of range\"\n   Assumption:  RSA public\
    \ key (n, e) is valid\n   Steps:\n      1.  If the signature representative s\
    \ is not between 0 and n - 1,\n          output \"signature representative out\
    \ of range\" and stop.\n      2.  Let m = s^e mod n.\n      3.  Output m.\n"
- title: 6.  Overview of Schemes
  contents:
  - "6.  Overview of Schemes\n   A scheme combines cryptographic primitives and other\
    \ techniques to\n   achieve a particular security goal.  Two types of scheme are\n\
    \   specified in this document: encryption schemes and signature schemes\n   with\
    \ appendix.\n   The schemes specified in this document are limited in scope in\
    \ that\n   their operations consist only of steps to process data with an RSA\n\
    \   public or private key, and they do not include steps for obtaining or\n  \
    \ validating the key.  Thus, in addition to the scheme operations, an\n   application\
    \ will typically include key management operations by which\n   parties may select\
    \ RSA public and private keys for a scheme\n   operation.  The specific additional\
    \ operations and other details are\n   outside the scope of this document.\n \
    \  As was the case for the cryptographic primitives (Section 5), the\n   specifications\
    \ of scheme operations assume that certain conditions\n   are met by the inputs,\
    \ in particular that RSA public and private keys\n   are valid.  The behavior\
    \ of an implementation is thus unspecified\n   when a key is invalid.  The impact\
    \ of such unspecified behavior\n   depends on the application.  Possible means\
    \ of addressing key\n   validation include explicit key validation by the application;\
    \ key\n   validation within the public-key infrastructure; and assignment of\n\
    \   liability for operations performed with an invalid key to the party\n   who\
    \ generated the key.\n   A generally good cryptographic practice is to employ\
    \ a given RSA key\n   pair in only one scheme.  This avoids the risk that vulnerability\
    \ in\n   one scheme may compromise the security of the other and may be\n   essential\
    \ to maintain provable security.  While RSAES-PKCS1-v1_5\n   (Section 7.2) and\
    \ RSASSA-PKCS1-v1_5 (Section 8.2) have traditionally\n   been employed together\
    \ without any known bad interactions (indeed,\n   this is the model introduced\
    \ by PKCS #1 v1.5), such a combined use of\n   an RSA key pair is NOT RECOMMENDED\
    \ for new applications.\n   To illustrate the risks related to the employment\
    \ of an RSA key pair\n   in more than one scheme, suppose an RSA key pair is employed\
    \ in both\n   RSAES-OAEP (Section 7.1) and RSAES-PKCS1-v1_5.  Although RSAES-OAEP\n\
    \   by itself would resist attack, an opponent might be able to exploit a\n  \
    \ weakness in the implementation of RSAES-PKCS1-v1_5 to recover\n   messages encrypted\
    \ with either scheme.  As another example, suppose\n   an RSA key pair is employed\
    \ in both RSASSA-PSS (Section 8.1) and\n   RSASSA-PKCS1-v1_5.  Then the security\
    \ proof for RSASSA-PSS would no\n   longer be sufficient since the proof does\
    \ not account for the\n   possibility that signatures might be generated with\
    \ a second scheme.\n   Similar considerations may apply if an RSA key pair is\
    \ employed in\n   one of the schemes defined here and in a variant defined elsewhere.\n"
- title: 7.  Encryption Schemes
  contents:
  - "7.  Encryption Schemes\n   For the purposes of this document, an encryption scheme\
    \ consists of\n   an encryption operation and a decryption operation, where the\n\
    \   encryption operation produces a ciphertext from a message with a\n   recipient's\
    \ RSA public key, and the decryption operation recovers the\n   message from the\
    \ ciphertext with the recipient's corresponding RSA\n   private key.\n   An encryption\
    \ scheme can be employed in a variety of applications.  A\n   typical application\
    \ is a key establishment protocol, where the\n   message contains key material\
    \ to be delivered confidentially from one\n   party to another.  For instance,\
    \ PKCS #7 [RFC2315] employs such a\n   protocol to deliver a content-encryption\
    \ key from a sender to a\n   recipient; the encryption schemes defined here would\
    \ be suitable key-\n   encryption algorithms in that context.\n   Two encryption\
    \ schemes are specified in this document: RSAES-OAEP and\n   RSAES-PKCS1-v1_5.\
    \  RSAES-OAEP is REQUIRED to be supported for new\n   applications; RSAES-PKCS1-v1_5\
    \ is included only for compatibility\n   with existing applications.\n   The encryption\
    \ schemes given here follow a general model similar to\n   that employed in IEEE\
    \ 1363 [IEEE1363], combining encryption and\n   decryption primitives with an\
    \ encoding method for encryption.  The\n   encryption operations apply a message\
    \ encoding operation to a message\n   to produce an encoded message, which is\
    \ then converted to an integer\n   message representative.  An encryption primitive\
    \ is applied to the\n   message representative to produce the ciphertext.  Reversing\
    \ this,\n   the decryption operations apply a decryption primitive to the\n  \
    \ ciphertext to recover a message representative, which is then\n   converted\
    \ to an octet-string-encoded message.  A message decoding\n   operation is applied\
    \ to the encoded message to recover the message\n   and verify the correctness\
    \ of the decryption.\n   To avoid implementation weaknesses related to the way\
    \ errors are\n   handled within the decoding operation (see [BLEICHENBACHER] and\n\
    \   [MANGER]), the encoding and decoding operations for RSAES-OAEP and\n   RSAES-PKCS1-v1_5\
    \ are embedded in the specifications of the respective\n   encryption schemes\
    \ rather than defined in separate specifications.\n   Both encryption schemes\
    \ are compatible with the corresponding schemes\n   in PKCS #1 v2.1.\n"
- title: 7.1.  RSAES-OAEP
  contents:
  - "7.1.  RSAES-OAEP\n   RSAES-OAEP combines the RSAEP and RSADP primitives (Sections\
    \ 5.1.1\n   and 5.1.2) with the EME-OAEP encoding method (Step 2 in\n   Section\
    \ 7.1.1, and Step 3 in Section 7.1.2).  EME-OAEP is based on\n   Bellare and Rogaway's\
    \ Optimal Asymmetric Encryption scheme [OAEP].\n   It is compatible with the Integer\
    \ Factorization Encryption Scheme\n   (IFES) defined in IEEE 1363 [IEEE1363],\
    \ where the encryption and\n   decryption primitives are IFEP-RSA and IFDP-RSA\
    \ and the message\n   encoding method is EME-OAEP.  RSAES-OAEP can operate on\
    \ messages of\n   length up to k - 2hLen -2 octets, where hLen is the length of\
    \ the\n   output from the underlying hash function and k is the length in\n  \
    \ octets of the recipient's RSA modulus.\n   Assuming that computing e-th roots\
    \ modulo n is infeasible and the\n   mask generation function in RSAES-OAEP has\
    \ appropriate properties,\n   RSAES-OAEP is semantically secure against adaptive\
    \ chosen-ciphertext\n   attacks.  This assurance is provable in the sense that\
    \ the difficulty\n   of breaking RSAES-OAEP can be directly related to the difficulty\
    \ of\n   inverting the RSA function, provided that the mask generation\n   function\
    \ is viewed as a black box or random oracle; see [FOPS] and\n   the note below\
    \ for further discussion.\n   Both the encryption and the decryption operations\
    \ of RSAES-OAEP take\n   the value of a label L as input.  In this version of\
    \ PKCS #1, L is\n   the empty string; other uses of the label are outside the\
    \ scope of\n   this document.  See Appendix A.2.1 for the relevant ASN.1 syntax.\n\
    \   RSAES-OAEP is parameterized by the choice of hash function and mask\n   generation\
    \ function.  This choice should be fixed for a given RSA\n   key.  Suggested hash\
    \ and mask generation functions are given in\n   Appendix B.\n   Note: Past results\
    \ have helpfully clarified the security properties\n   of the OAEP encoding method\
    \ [OAEP]  (roughly the procedure described\n   in Step 2 in Section 7.1.1).  The\
    \ background is as follows.  In 1994,\n   Bellare and Rogaway [OAEP] introduced\
    \ a security concept that they\n   denoted plaintext awareness (PA94).  They proved\
    \ that if a\n   deterministic public-key encryption primitive (e.g., RSAEP) is\
    \ hard\n   to invert without the private key, then the corresponding OAEP-based\n\
    \   encryption scheme is plaintext aware (in the random oracle model),\n   meaning\
    \ roughly that an adversary cannot produce a valid ciphertext\n   without actually\
    \ \"knowing\" the underlying plaintext.  Plaintext\n   awareness of an encryption\
    \ scheme is closely related to the\n   resistance of the scheme against chosen-ciphertext\
    \ attacks.  In such\n   attacks, an adversary is given the opportunity to send\
    \ queries to an\n   oracle simulating the decryption primitive.  Using the results\
    \ of\n   these queries, the adversary attempts to decrypt a challenge\n   ciphertext.\n\
    \   However, there are two flavors of chosen-ciphertext attacks, and PA94\n  \
    \ implies security against only one of them.  The difference relies on\n   what\
    \ the adversary is allowed to do after she is given the challenge\n   ciphertext.\
    \  The indifferent attack scenario (denoted CCA1) does not\n   admit any queries\
    \ to the decryption oracle after the adversary is\n   given the challenge ciphertext,\
    \ whereas the adaptive scenario\n   (denoted CCA2) does (except that the decryption\
    \ oracle refuses to\n   decrypt the challenge ciphertext once it is published).\
    \  In 1998,\n   Bellare and Rogaway, together with Desai and Pointcheval [PA98],\
    \ came\n   up with a new, stronger notion of plaintext awareness (PA98) that\n\
    \   does imply security against CCA2.\n   To summarize, there have been two potential\
    \ sources for\n   misconception: that PA94 and PA98 are equivalent concepts, or\
    \ that\n   CCA1 and CCA2 are equivalent concepts.  Either assumption leads to\n\
    \   the conclusion that the Bellare-Rogaway paper implies security of\n   OAEP\
    \ against CCA2, which it does not.\n   (Footnote: It might be fair to mention\
    \ that PKCS #1 v2.0 cites [OAEP]\n   and claims that \"a chosen ciphertext attack\
    \ is ineffective against a\n   plaintext-aware encryption scheme such as RSAES-OAEP\"\
    \ without\n   specifying the kind of plaintext awareness or chosen ciphertext\n\
    \   attack considered.)\n   OAEP has never been proven secure against CCA2; in\
    \ fact, Victor Shoup\n   [SHOUP] has demonstrated that such a proof does not exist\
    \ in the\n   general case.  Put briefly, Shoup showed that an adversary in the\n\
    \   CCA2 scenario who knows how to partially invert the encryption\n   primitive\
    \ but does not know how to invert it completely may well be\n   able to break\
    \ the scheme.  For example, one may imagine an attacker\n   who is able to break\
    \ RSAES-OAEP if she knows how to recover all but\n   the first 20 bytes of a random\
    \ integer encrypted with RSAEP.  Such an\n   attacker does not need to be able\
    \ to fully invert RSAEP, because she\n   does not use the first 20 octets in her\
    \ attack.\n   Still, RSAES-OAEP is secure against CCA2, which was proved by\n\
    \   Fujisaki, Okamoto, Pointcheval, and Stern [FOPS] shortly after the\n   announcement\
    \ of Shoup's result.  Using clever lattice reduction\n   techniques, they managed\
    \ to show how to invert RSAEP completely given\n   a sufficiently large part of\
    \ the pre-image.  This observation,\n   combined with a proof that OAEP is secure\
    \ against CCA2 if the\n   underlying encryption primitive is hard to partially\
    \ invert, fills\n   the gap between what Bellare and Rogaway proved about RSAES-OAEP\
    \ and\n   what some may have believed that they proved.  Somewhat\n   paradoxically,\
    \ we are hence saved by an ostensible weakness in RSAEP\n   (i.e., the whole inverse\
    \ can be deduced from parts of it).\n   Unfortunately, however, the security reduction\
    \ is not efficient for\n   concrete parameters.  While the proof successfully\
    \ relates an\n   adversary A against the CCA2 security of RSAES-OAEP to an algorithm\
    \ I\n   inverting RSA, the probability of success for I is only approximately\n\
    \   \\epsilon^2 / 2^18, where \\epsilon is the probability of success for\n  \
    \ A.\n   (Footnote: In [FOPS], the probability of success for the inverter was\n\
    \   \\epsilon^2 / 4.  The additional factor 1 / 2^16 is due to the eight\n   fixed\
    \ zero bits at the beginning of the encoded message EM, which are\n   not present\
    \ in the variant of OAEP considered in [FOPS].  (A must be\n   applied twice to\
    \ invert RSA, and each application corresponds to a\n   factor 1 / 2^8.))\n  \
    \ In addition, the running time for I is approximately t^2, where t is\n   the\
    \ running time of the adversary.  The consequence is that we cannot\n   exclude\
    \ the possibility that attacking RSAES-OAEP is considerably\n   easier than inverting\
    \ RSA for concrete parameters.  Still, the\n   existence of a security proof provides\
    \ some assurance that the\n   RSAES-OAEP construction is sounder than ad hoc constructions\
    \ such as\n   RSAES-PKCS1-v1_5.\n   Hybrid encryption schemes based on the RSA\
    \ Key Encapsulation\n   Mechanism (RSA-KEM) paradigm offer tight proofs of security\
    \ directly\n   applicable to concrete parameters; see [ISO18033] for discussion.\n\
    \   Future versions of PKCS #1 may specify schemes based on this\n   paradigm.\n"
- title: 7.1.1.  Encryption Operation
  contents:
  - "7.1.1.  Encryption Operation\n   RSAES-OAEP-ENCRYPT ((n, e), M, L)\n   Options:\n\
    \      Hash     hash function (hLen denotes the length in octets of\n        \
    \       the hash function output)\n      MGF      mask generation function\n \
    \  Input:\n      (n, e)   recipient's RSA public key (k denotes the length in\n\
    \               octets of the RSA modulus n)\n      M        message to be encrypted,\
    \ an octet string of length mLen,\n               where mLen <= k - 2hLen - 2\n\
    \      L        optional label to be associated with the message; the\n      \
    \         default value for L, if L is not provided, is the empty\n          \
    \     string\n   Output:\n      C        ciphertext, an octet string of length\
    \ k\n   Errors:  \"message too long\"; \"label too long\"\n   Assumption:  RSA\
    \ public key (n, e) is valid\n   Steps:\n      1.  Length checking:\n        \
    \  a.  If the length of L is greater than the input limitation\n             \
    \ for the hash function (2^61 - 1 octets for SHA-1), output\n              \"\
    label too long\" and stop.\n          b.  If mLen > k - 2hLen - 2, output \"message\
    \ too long\" and\n              stop.\n      2.  EME-OAEP encoding (see Figure\
    \ 1 below):\n          a.  If the label L is not provided, let L be the empty\
    \ string.\n              Let lHash = Hash(L), an octet string of length hLen (see\n\
    \              the note below).\n          b.  Generate a padding string PS consisting\
    \ of k - mLen -\n              2hLen - 2 zero octets.  The length of PS may be\
    \ zero.\n          c.  Concatenate lHash, PS, a single octet with hexadecimal\n\
    \              value 0x01, and the message M to form a data block DB of\n    \
    \          length k - hLen - 1 octets as\n                 DB = lHash || PS ||\
    \ 0x01 || M.\n          d.  Generate a random octet string seed of length hLen.\n\
    \          e.  Let dbMask = MGF(seed, k - hLen - 1).\n          f.  Let maskedDB\
    \ = DB \\xor dbMask.\n          g.  Let seedMask = MGF(maskedDB, hLen).\n    \
    \      h.  Let maskedSeed = seed \\xor seedMask.\n          i.  Concatenate a\
    \ single octet with hexadecimal value 0x00,\n              maskedSeed, and maskedDB\
    \ to form an encoded message EM of\n              length k octets as\n       \
    \          EM = 0x00 || maskedSeed || maskedDB.\n      3.  RSA encryption:\n \
    \         a.  Convert the encoded message EM to an integer message\n         \
    \     representative m (see Section 4.2):\n                 m = OS2IP (EM).\n\
    \          b.  Apply the RSAEP encryption primitive (Section 5.1.1) to\n     \
    \         the RSA public key (n, e) and the message representative m\n       \
    \       to produce an integer ciphertext representative c:\n                 c\
    \ = RSAEP ((n, e), m).\n          c.  Convert the ciphertext representative c\
    \ to a ciphertext C\n              of length k octets (see Section 4.1):\n   \
    \              C = I2OSP (c, k).\n      4.  Output the ciphertext C.\n      _________________________________________________________________\n\
    \                                +----------+------+--+-------+\n            \
    \               DB = |  lHash   |  PS  |01|   M   |\n                        \
    \        +----------+------+--+-------+\n                                    \
    \           |\n                     +----------+              |\n            \
    \         |   seed   |              |\n                     +----------+     \
    \         |\n                           |                   |\n              \
    \             |-------> MGF ---> xor\n                           |           \
    \        |\n                  +--+     V                   |\n               \
    \   |00|    xor <----- MGF <-----|\n                  +--+     |             \
    \      |\n                    |      |                   |\n                 \
    \   V      V                   V\n                  +--+----------+----------------------------+\n\
    \            EM =  |00|maskedSeed|          maskedDB          |\n            \
    \      +--+----------+----------------------------+\n      _________________________________________________________________\n\
    \                   Figure 1: EME-OAEP Encoding Operation\n   Notes:\n   -  lHash\
    \ is the hash of the optional label L.\n   -  The decoding operation follows reverse\
    \ steps to recover M and\n      verify lHash and PS.\n   -  If L is the empty\
    \ string, the corresponding hash value lHash has\n      the following hexadecimal\
    \ representation for different choices of\n      Hash:\n      SHA-1:   (0x)da39a3ee\
    \ 5e6b4b0d 3255bfef 95601890 afd80709\n      SHA-256: (0x)e3b0c442 98fc1c14 9afbf4c8\
    \ 996fb924 27ae41e4 649b934c\n                   a495991b 7852b855\n      SHA-384:\
    \ (0x)38b060a7 51ac9638 4cd9327e b1b1e36a 21fdb711 14be0743\n                \
    \   4c0cc7bf 63f6e1da 274edebf e76f65fb d51ad2f1 4898b95b\n      SHA-512: (0x)cf83e135\
    \ 7eefb8bd f1542850 d66d8007 d620e405 0b5715dc\n                   83f4a921 d36ce9ce\
    \ 47d0d13c 5d85f2b0 ff8318d2 877eec2f\n                   63b931bd 47417a81 a538327a\
    \ f927da3e\n"
- title: 7.1.2.  Decryption Operation
  contents:
  - "7.1.2.  Decryption Operation\n   RSAES-OAEP-DECRYPT (K, C, L)\n   Options:\n\
    \      Hash     hash function (hLen denotes the length in octets of\n        \
    \       the hash function output)\n      MGF      mask generation function\n \
    \  Input:\n      K        recipient's RSA private key (k denotes the length in\n\
    \               octets of the RSA modulus n), where k >= 2hLen + 2\n      C  \
    \      ciphertext to be decrypted, an octet string of length k\n      L      \
    \  optional label whose association with the message is to\n               be\
    \ verified; the default value for L, if L is not\n               provided, is\
    \ the empty string\n   Output:\n      M        message, an octet string of length\
    \ mLen, where\n               mLen <= k - 2hLen - 2\n   Error:  \"decryption error\"\
    \n   Steps:\n      1.  Length checking:\n          a.  If the length of L is greater\
    \ than the input limitation\n              for the hash function (2^61 - 1 octets\
    \ for SHA-1), output\n              \"decryption error\" and stop.\n         \
    \ b.  If the length of the ciphertext C is not k octets, output\n            \
    \  \"decryption error\" and stop.\n          c.  If k < 2hLen + 2, output \"decryption\
    \ error\" and stop.\n      2.  RSA decryption:\n          a.  Convert the ciphertext\
    \ C to an integer ciphertext\n              representative c (see Section 4.2):\n\
    \                 c = OS2IP (C).\n          b.  Apply the RSADP decryption primitive\
    \ (Section 5.1.2) to\n              the RSA private key K and the ciphertext representative\
    \ c\n              to produce an integer message representative m:\n         \
    \        m = RSADP (K, c).\n              If RSADP outputs \"ciphertext representative\
    \ out of range\"\n              (meaning that c >= n), output \"decryption error\"\
    \ and stop.\n          c.  Convert the message representative m to an encoded\
    \ message\n              EM of length k octets (see Section 4.1):\n          \
    \       EM = I2OSP (m, k).\n      3.  EME-OAEP decoding:\n          a.  If the\
    \ label L is not provided, let L be the empty string.\n              Let lHash\
    \ = Hash(L), an octet string of length hLen (see\n              the note in Section\
    \ 7.1.1).\n          b.  Separate the encoded message EM into a single octet Y,\
    \ an\n              octet string maskedSeed of length hLen, and an octet\n   \
    \           string maskedDB of length k - hLen - 1 as\n                 EM = Y\
    \ || maskedSeed || maskedDB.\n          c.  Let seedMask = MGF(maskedDB, hLen).\n\
    \          d.  Let seed = maskedSeed \\xor seedMask.\n          e.  Let dbMask\
    \ = MGF(seed, k - hLen - 1).\n          f.  Let DB = maskedDB \\xor dbMask.\n\
    \          g.  Separate DB into an octet string lHash' of length hLen, a\n   \
    \           (possibly empty) padding string PS consisting of octets\n        \
    \      with hexadecimal value 0x00, and a message M as\n                 DB =\
    \ lHash' || PS || 0x01 || M.\n              If there is no octet with hexadecimal\
    \ value 0x01 to\n              separate PS from M, if lHash does not equal lHash',\
    \ or if\n              Y is nonzero, output \"decryption error\" and stop.  (See\n\
    \              the note below.)\n      4.  Output the message M.\n      Note:\
    \ Care must be taken to ensure that an opponent cannot\n      distinguish the\
    \ different error conditions in Step 3.g, whether by\n      error message or timing,\
    \ and, more generally, that an opponent\n      cannot learn partial information\
    \ about the encoded message EM.\n      Otherwise, an opponent may be able to obtain\
    \ useful information\n      about the decryption of the ciphertext C, leading\
    \ to a chosen-\n      ciphertext attack such as the one observed by Manger [MANGER].\n"
- title: 7.2.  RSAES-PKCS1-v1_5
  contents:
  - "7.2.  RSAES-PKCS1-v1_5\n   RSAES-PKCS1-v1_5 combines the RSAEP and RSADP primitives\
    \ (Sections\n   5.1.1 and 5.1.2) with the EME-PKCS1-v1_5 encoding method (Step\
    \ 2 in\n   Section 7.2.1, and Step 3 in Section 7.2.2).  It is mathematically\n\
    \   equivalent to the encryption scheme in PKCS #1 v1.5.\n   RSAES-PKCS1-v1_5\
    \ can operate on messages of length up to k - 11\n   octets (k is the octet length\
    \ of the RSA modulus), although care\n   should be taken to avoid certain attacks\
    \ on low-exponent RSA due to\n   Coppersmith, Franklin, Patarin, and Reiter when\
    \ long messages are\n   encrypted (see the third bullet in the notes below and\
    \ [LOWEXP];\n   [NEWATTACK] contains an improved attack).  As a general rule,\
    \ the use\n   of this scheme for encrypting an arbitrary message, as opposed to\
    \ a\n   randomly generated key, is NOT RECOMMENDED.\n   It is possible to generate\
    \ valid RSAES-PKCS1-v1_5 ciphertexts without\n   knowing the corresponding plaintexts,\
    \ with a reasonable probability\n   of success.  This ability can be exploited\
    \ in a chosen-ciphertext\n   attack as shown in [BLEICHENBACHER].  Therefore,\
    \ if RSAES-PKCS1-v1_5\n   is to be used, certain easily implemented countermeasures\
    \ should be\n   taken to thwart the attack found in [BLEICHENBACHER].  Typical\n\
    \   examples include the addition of structure to the data to be encoded,\n  \
    \ rigorous checking of PKCS #1 v1.5 conformance (and other redundancy)\n   in\
    \ decrypted messages, and the consolidation of error messages in a\n   client-server\
    \ protocol based on PKCS #1 v1.5.  These can all be\n   effective countermeasures\
    \ and do not involve changes to a protocol\n   based on PKCS #1 v1.5.  See [BKS]\
    \ for a further discussion of these\n   and other countermeasures.  It has recently\
    \ been shown that the\n   security of the SSL/TLS handshake protocol [RFC5246],\
    \ which uses\n   RSAES-PKCS1-v1_5 and certain countermeasures, can be related\
    \ to a\n   variant of the RSA problem; see [RSATLS] for discussion.\n   Note:\
    \ The following passages describe some security recommendations\n   pertaining\
    \ to the use of RSAES-PKCS1-v1_5.  Recommendations from PKCS\n   #1 v1.5 are included\
    \ as well as new recommendations motivated by\n   cryptanalytic advances made\
    \ in the intervening years.\n   o  It is RECOMMENDED that the pseudorandom octets\
    \ in Step 2 in\n      Section 7.2.1 be generated independently for each encryption\n\
    \      process, especially if the same data is input to more than one\n      encryption\
    \ process.  Haastad's results [HAASTAD] are one\n      motivation for this recommendation.\n\
    \   o  The padding string PS in Step 2 in Section 7.2.1 is at least eight\n  \
    \    octets long, which is a security condition for public-key\n      operations\
    \ that makes it difficult for an attacker to recover data\n      by trying all\
    \ possible encryption blocks.\n   o  The pseudorandom octets can also help thwart\
    \ an attack due to\n      Coppersmith et al.  [LOWEXP] (see [NEWATTACK] for an\
    \ improvement\n      of the attack) when the size of the message to be encrypted\
    \ is\n      kept small.  The attack works on low-exponent RSA when similar\n \
    \     messages are encrypted with the same RSA public key.  More\n      specifically,\
    \ in one flavor of the attack, when two inputs to\n      RSAEP agree on a large\
    \ fraction of bits (8/9) and low-exponent RSA\n      (e = 3) is used to encrypt\
    \ both of them, it may be possible to\n      recover both inputs with the attack.\
    \  Another flavor of the attack\n      is successful in decrypting a single ciphertext\
    \ when a large\n      fraction (2/3) of the input to RSAEP is already known. \
    \ For\n      typical applications, the message to be encrypted is short (e.g.,\n\
    \      a 128-bit symmetric key), so not enough information will be known\n   \
    \   or common between two messages to enable the attack.  However, if\n      a\
    \ long message is encrypted, or if part of a message is known,\n      then the\
    \ attack may be a concern.  In any case, the RSAES-OAEP\n      scheme overcomes\
    \ the attack.\n"
- title: 7.2.1.  Encryption Operation
  contents:
  - "7.2.1.  Encryption Operation\n   RSAES-PKCS1-V1_5-ENCRYPT ((n, e), M)\n   Input:\n\
    \      (n, e)   recipient's RSA public key (k denotes the length in\n        \
    \       octets of the modulus n)\n      M        message to be encrypted, an octet\
    \ string of length\n               mLen, where mLen <= k - 11\n   Output:\n  \
    \    C        ciphertext, an octet string of length k\n   Error:  \"message too\
    \ long\"\n   Steps:\n      1.  Length checking: If mLen > k - 11, output \"message\
    \ too long\"\n          and stop.\n      2.  EME-PKCS1-v1_5 encoding:\n      \
    \    a.  Generate an octet string PS of length k - mLen - 3\n              consisting\
    \ of pseudo-randomly generated nonzero octets.\n              The length of PS\
    \ will be at least eight octets.\n          b.  Concatenate PS, the message M,\
    \ and other padding to form\n              an encoded message EM of length k octets\
    \ as\n                 EM = 0x00 || 0x02 || PS || 0x00 || M.\n      3.  RSA encryption:\n\
    \          a.  Convert the encoded message EM to an integer message\n        \
    \      representative m (see Section 4.2):\n                 m = OS2IP (EM).\n\
    \          b.  Apply the RSAEP encryption primitive (Section 5.1.1) to\n     \
    \         the RSA public key (n, e) and the message representative m\n       \
    \       to produce an integer ciphertext representative c:\n                 c\
    \ = RSAEP ((n, e), m).\n          c.  Convert the ciphertext representative c\
    \ to a ciphertext C\n              of length k octets (see Section 4.1):\n   \
    \              C = I2OSP (c, k).\n      4.  Output the ciphertext C.\n"
- title: 7.2.2.  Decryption Operation
  contents:
  - "7.2.2.  Decryption Operation\n   RSAES-PKCS1-V1_5-DECRYPT (K, C)\n   Input:\n\
    \      K        recipient's RSA private key\n      C        ciphertext to be decrypted,\
    \ an octet string of length k,\n               where k is the length in octets\
    \ of the RSA modulus n\n   Output:\n      M        message, an octet string of\
    \ length at most k - 11\n   Error:  \"decryption error\"\n   Steps:\n      1.\
    \  Length checking: If the length of the ciphertext C is not k\n          octets\
    \ (or if k < 11), output \"decryption error\" and stop.\n      2.  RSA decryption:\n\
    \          a.  Convert the ciphertext C to an integer ciphertext\n           \
    \   representative c (see Section 4.2):\n                 c = OS2IP (C).\n   \
    \       b.  Apply the RSADP decryption primitive (Section 5.1.2) to\n        \
    \      the RSA private key (n, d) and the ciphertext\n              representative\
    \ c to produce an integer message\n              representative m:\n         \
    \        m = RSADP ((n, d), c).\n              If RSADP outputs \"ciphertext representative\
    \ out of range\"\n              (meaning that c >= n), output \"decryption error\"\
    \ and stop.\n          c.  Convert the message representative m to an encoded\
    \ message\n              EM of length k octets (see Section 4.1):\n          \
    \       EM = I2OSP (m, k).\n      3.  EME-PKCS1-v1_5 decoding: Separate the encoded\
    \ message EM into\n          an octet string PS consisting of nonzero octets and\
    \ a message\n          M as\n             EM = 0x00 || 0x02 || PS || 0x00 || M.\n\
    \          If the first octet of EM does not have hexadecimal value 0x00,\n  \
    \        if the second octet of EM does not have hexadecimal value\n         \
    \ 0x02, if there is no octet with hexadecimal value 0x00 to\n          separate\
    \ PS from M, or if the length of PS is less than 8\n          octets, output \"\
    decryption error\" and stop.  (See the note\n          below.)\n      4.  Output\
    \ M.\n      Note: Care shall be taken to ensure that an opponent cannot\n    \
    \  distinguish the different error conditions in Step 3, whether by\n      error\
    \ message or timing.  Otherwise, an opponent may be able to\n      obtain useful\
    \ information about the decryption of the ciphertext\n      C, leading to a strengthened\
    \ version of Bleichenbacher's attack\n      [BLEICHENBACHER]; compare to Manger's\
    \ attack [MANGER].\n"
- title: 8.  Signature Scheme with Appendix
  contents:
  - "8.  Signature Scheme with Appendix\n   For the purposes of this document, a signature\
    \ scheme with appendix\n   consists of a signature generation operation and a\
    \ signature\n   verification operation, where the signature generation operation\n\
    \   produces a signature from a message with a signer's RSA private key,\n   and\
    \ the signature verification operation verifies the signature on\n   the message\
    \ with the signer's corresponding RSA public key.  To\n   verify a signature constructed\
    \ with this type of scheme, it is\n   necessary to have the message itself.  In\
    \ this way, signature schemes\n   with appendix are distinguished from signature\
    \ schemes with message\n   recovery, which are not supported in this document.\n\
    \   A signature scheme with appendix can be employed in a variety of\n   applications.\
    \  For instance, the signature schemes with appendix\n   defined here would be\
    \ suitable signature algorithms for X.509\n   certificates [ISO9594].  Related\
    \ signature schemes could be employed\n   in PKCS #7 [RFC2315], although for technical\
    \ reasons the current\n   version of PKCS #7 separates a hash function from a\
    \ signature scheme,\n   which is different than what is done here; see the note\
    \ in\n   Appendix A.2.3 for more discussion.\n   Two signature schemes with appendix\
    \ are specified in this document:\n   RSASSA-PSS and RSASSA-PKCS1-v1_5.  Although\
    \ no attacks are known\n   against RSASSA-PKCS1-v1_5, in the interest of increased\
    \ robustness,\n   RSASSA-PSS is REQUIRED in new applications.  RSASSA-PKCS1-v1_5\
    \ is\n   included only for compatibility with existing applications.\n   The signature\
    \ schemes with appendix given here follow a general model\n   similar to that\
    \ employed in IEEE 1363 [IEEE1363], combining signature\n   and verification primitives\
    \ with an encoding method for signatures.\n   The signature generation operations\
    \ apply a message encoding\n   operation to a message to produce an encoded message,\
    \ which is then\n   converted to an integer message representative.  A signature\n\
    \   primitive is applied to the message representative to produce the\n   signature.\
    \  Reversing this, the signature verification operations\n   apply a signature\
    \ verification primitive to the signature to recover\n   a message representative,\
    \ which is then converted to an octet-string-\n   encoded message.  A verification\
    \ operation is applied to the message\n   and the encoded message to determine\
    \ whether they are consistent.\n   If the encoding method is deterministic (e.g.,\
    \ EMSA-PKCS1-v1_5), the\n   verification operation may apply the message encoding\
    \ operation to\n   the message and compare the resulting encoded message to the\n\
    \   previously derived encoded message.  If there is a match, the\n   signature\
    \ is considered valid.  If the method is randomized (e.g.,\n   EMSA-PSS), the\
    \ verification operation is typically more complicated.\n   For example, the verification\
    \ operation in EMSA-PSS extracts the\n   random salt and a hash output from the\
    \ encoded message and checks\n   whether the hash output, the salt, and the message\
    \ are consistent;\n   the hash output is a deterministic function in terms of\
    \ the message\n   and the salt.  For both signature schemes with appendix defined\
    \ in\n   this document, the signature generation and signature verification\n\
    \   operations are readily implemented as \"single-pass\" operations if the\n\
    \   signature is placed after the message.  See PKCS #7 [RFC2315] for an\n   example\
    \ format in the case of RSASSA-PKCS1-v1_5.\n"
- title: 8.1.  RSASSA-PSS
  contents:
  - "8.1.  RSASSA-PSS\n   RSASSA-PSS combines the RSASP1 and RSAVP1 primitives with\
    \ the\n   EMSA-PSS encoding method.  It is compatible with the Integer\n   Factorization\
    \ Signature Scheme with Appendix (IFSSA) as amended in\n   IEEE 1363a [IEEE1363A],\
    \ where the signature and verification\n   primitives are IFSP-RSA1 and IFVP-RSA1\
    \ as defined in IEEE 1363\n   [IEEE1363], and the message encoding method is EMSA4.\
    \  EMSA4 is\n   slightly more general than EMSA-PSS as it acts on bit strings\
    \ rather\n   than on octet strings.  EMSA-PSS is equivalent to EMSA4 restricted\
    \ to\n   the case that the operands as well as the hash and salt values are\n\
    \   octet strings.\n   The length of messages on which RSASSA-PSS can operate\
    \ is either\n   unrestricted or constrained by a very large number, depending\
    \ on the\n   hash function underlying the EMSA-PSS encoding method.\n   Assuming\
    \ that computing e-th roots modulo n is infeasible and the\n   hash and mask generation\
    \ functions in EMSA-PSS have appropriate\n   properties, RSASSA-PSS provides secure\
    \ signatures.  This assurance is\n   provable in the sense that the difficulty\
    \ of forging signatures can\n   be directly related to the difficulty of inverting\
    \ the RSA function,\n   provided that the hash and mask generation functions are\
    \ viewed as\n   black boxes or random oracles.  The bounds in the security proof\
    \ are\n   essentially \"tight\", meaning that the success probability and running\n\
    \   time for the best forger against RSASSA-PSS are very close to the\n   corresponding\
    \ parameters for the best RSA inversion algorithm; see\n   [RSARABIN] [PSSPROOF]\
    \ [JONSSON] for further discussion.\n   In contrast to the RSASSA-PKCS1-v1_5 signature\
    \ scheme, a hash\n   function identifier is not embedded in the EMSA-PSS encoded\
    \ message,\n   so in theory it is possible for an adversary to substitute a\n\
    \   different (and potentially weaker) hash function than the one\n   selected\
    \ by the signer.  Therefore, it is RECOMMENDED that the\n   EMSA-PSS mask generation\
    \ function be based on the same hash function.\n   In this manner, the entire\
    \ encoded message will be dependent on the\n   hash function, and it will be difficult\
    \ for an opponent to substitute\n   a different hash function than the one intended\
    \ by the signer.  This\n   matching of hash functions is only for the purpose\
    \ of preventing hash\n   function substitution and is not necessary if hash function\n\
    \   substitution is addressed by other means (e.g., the verifier accepts\n   only\
    \ a designated hash function).  See [HASHID] for further\n   discussion of these\
    \ points.  The provable security of RSASSA-PSS does\n   not rely on the hash function\
    \ in the mask generation function being\n   the same as the hash function applied\
    \ to the message.\n   RSASSA-PSS is different from other RSA-based signature schemes\
    \ in\n   that it is probabilistic rather than deterministic, incorporating a\n\
    \   randomly generated salt value.  The salt value enhances the security\n   of\
    \ the scheme by affording a \"tighter\" security proof than\n   deterministic\
    \ alternatives such as Full Domain Hashing (FDH); see\n   [RSARABIN] for discussion.\
    \  However, the randomness is not critical\n   to security.  In situations where\
    \ random generation is not possible,\n   a fixed value or a sequence number could\
    \ be employed instead, with\n   the resulting provable security similar to that\
    \ of FDH [FDH].\n"
- title: 8.1.1.  Signature Generation Operation
  contents:
  - "8.1.1.  Signature Generation Operation\n   RSASSA-PSS-SIGN (K, M)\n   Input:\n\
    \      K        signer's RSA private key\n      M        message to be signed,\
    \ an octet string\n   Output:\n      S        signature, an octet string of length\
    \ k, where k is the\n               length in octets of the RSA modulus n\n  \
    \ Errors:  \"message too long;\" \"encoding error\"\n   Steps:\n      1.  EMSA-PSS\
    \ encoding: Apply the EMSA-PSS encoding operation\n          (Section 9.1.1) to\
    \ the message M to produce an encoded message\n          EM of length \\ceil ((modBits\
    \ - 1)/8) octets such that the bit\n          length of the integer OS2IP (EM)\
    \ (see Section 4.2) is at most\n          modBits - 1, where modBits is the length\
    \ in bits of the RSA\n          modulus n:\n             EM = EMSA-PSS-ENCODE\
    \ (M, modBits - 1).\n          Note that the octet length of EM will be one less\
    \ than k if\n          modBits - 1 is divisible by 8 and equal to k otherwise.\
    \  If\n          the encoding operation outputs \"message too long\", output\n\
    \          \"message too long\" and stop.  If the encoding operation\n       \
    \   outputs \"encoding error\", output \"encoding error\" and stop.\n      2.\
    \  RSA signature:\n          a.  Convert the encoded message EM to an integer\
    \ message\n              representative m (see Section 4.2):\n               \
    \  m = OS2IP (EM).\n          b.  Apply the RSASP1 signature primitive (Section\
    \ 5.2.1) to\n              the RSA private key K and the message representative\
    \ m to\n              produce an integer signature representative s:\n       \
    \          s = RSASP1 (K, m).\n          c.  Convert the signature representative\
    \ s to a signature S of\n              length k octets (see Section 4.1):\n  \
    \               S = I2OSP (s, k).\n      3.  Output the signature S.\n"
- title: 8.1.2.  Signature Verification Operation
  contents:
  - "8.1.2.  Signature Verification Operation\n   RSASSA-PSS-VERIFY ((n, e), M, S)\n\
    \   Input:\n      (n, e)  signer's RSA public key\n      M       message whose\
    \ signature is to be verified, an octet string\n      S       signature to be\
    \ verified, an octet string of length k,\n              where k is the length\
    \ in octets of the RSA modulus n\n   Output:  \"valid signature\" or \"invalid\
    \ signature\"\n   Steps:\n      1.  Length checking: If the length of the signature\
    \ S is not k\n          octets, output \"invalid signature\" and stop.\n     \
    \ 2.  RSA verification:\n          a.  Convert the signature S to an integer signature\n\
    \              representative s (see Section 4.2):\n                 s = OS2IP\
    \ (S).\n          b.  Apply the RSAVP1 verification primitive (Section 5.2.2)\
    \ to\n              the RSA public key (n, e) and the signature representative\n\
    \              s to produce an integer message representative m:\n           \
    \      m = RSAVP1 ((n, e), s).\n              If RSAVP1 output \"signature representative\
    \ out of range\",\n              output \"invalid signature\" and stop.\n    \
    \      c.  Convert the message representative m to an encoded message\n      \
    \        EM of length emLen = \\ceil ((modBits - 1)/8) octets, where\n       \
    \       modBits is the length in bits of the RSA modulus n (see\n            \
    \  Section 4.1):\n                 EM = I2OSP (m, emLen).\n              Note\
    \ that emLen will be one less than k if modBits - 1 is\n              divisible\
    \ by 8 and equal to k otherwise.  If I2OSP outputs\n              \"integer too\
    \ large\", output \"invalid signature\" and stop.\n      3.  EMSA-PSS verification:\
    \ Apply the EMSA-PSS verification\n          operation (Section 9.1.2) to the\
    \ message M and the encoded\n          message EM to determine whether they are\
    \ consistent:\n             Result = EMSA-PSS-VERIFY (M, EM, modBits - 1).\n \
    \     4.  If Result = \"consistent\", output \"valid signature\".\n          Otherwise,\
    \ output \"invalid signature\".\n"
- title: 8.2.  RSASSA-PKCS1-v1_5
  contents:
  - "8.2.  RSASSA-PKCS1-v1_5\n   RSASSA-PKCS1-v1_5 combines the RSASP1 and RSAVP1\
    \ primitives with the\n   EMSA-PKCS1-v1_5 encoding method.  It is compatible with\
    \ the IFSSA\n   scheme defined in IEEE 1363 [IEEE1363], where the signature and\n\
    \   verification primitives are IFSP-RSA1 and IFVP-RSA1, and the message\n   encoding\
    \ method is EMSA-PKCS1-v1_5 (which is not defined in IEEE 1363\n   but is in IEEE\
    \ 1363a [IEEE1363A]).\n   The length of messages on which RSASSA-PKCS1-v1_5 can\
    \ operate is\n   either unrestricted or constrained by a very large number, depending\n\
    \   on the hash function underlying the EMSA-PKCS1-v1_5 method.\n   Assuming that\
    \ computing e-th roots modulo n is infeasible and the\n   hash function in EMSA-PKCS1-v1_5\
    \ has appropriate properties,\n   RSASSA-PKCS1-v1_5 is conjectured to provide\
    \ secure signatures.  More\n   precisely, forging signatures without knowing the\
    \ RSA private key is\n   conjectured to be computationally infeasible.  Also,\
    \ in the encoding\n   method EMSA-PKCS1-v1_5, a hash function identifier is embedded\
    \ in the\n   encoding.  Because of this feature, an adversary trying to find a\n\
    \   message with the same signature as a previously signed message must\n   find\
    \ collisions of the particular hash function being used; attacking\n   a different\
    \ hash function than the one selected by the signer is not\n   useful to the adversary.\
    \  See [HASHID] for further discussion.\n   Note: As noted in PKCS #1 v1.5, the\
    \ EMSA-PKCS1-v1_5 encoding method\n   has the property that the encoded message,\
    \ converted to an integer\n   message representative, is guaranteed to be large\
    \ and at least\n   somewhat \"random\".  This prevents attacks of the kind proposed\
    \ by\n   Desmedt and Odlyzko [CHOSEN] where multiplicative relationships\n   between\
    \ message representatives are developed by factoring the\n   message representatives\
    \ into a set of small values (e.g., a set of\n   small primes).  Coron, Naccache,\
    \ and Stern [PADDING] showed that a\n   stronger form of this type of attack could\
    \ be quite effective against\n   some instances of the ISO/IEC 9796-2 signature\
    \ scheme.  They also\n   analyzed the complexity of this type of attack against\
    \ the\n   EMSA-PKCS1-v1_5 encoding method and concluded that an attack would be\n\
    \   impractical, requiring more operations than a collision search on the\n  \
    \ underlying hash function (i.e., more than 2^80 operations).\n   Coppersmith,\
    \ Halevi, and Jutla [FORGERY] subsequently extended Coron\n   et al.'s attack\
    \ to break the ISO/IEC 9796-1 signature scheme with\n   message recovery.  The\
    \ various attacks illustrate the importance of\n   carefully constructing the\
    \ input to the RSA signature primitive,\n   particularly in a signature scheme\
    \ with message recovery.\n   Accordingly, the EMSA-PKCS-v1_5 encoding method explicitly\
    \ includes a\n   hash operation and is not intended for signature schemes with\
    \ message\n   recovery.  Moreover, while no attack is known against the\n   EMSA-PKCS-v1_5\
    \ encoding method, a gradual transition to EMSA-PSS is\n   recommended as a precaution\
    \ against future developments.\n"
- title: 8.2.1.  Signature Generation Operation
  contents:
  - "8.2.1.  Signature Generation Operation\n   RSASSA-PKCS1-V1_5-SIGN (K, M)\n  \
    \ Input:\n      K        signer's RSA private key\n      M        message to be\
    \ signed, an octet string\n   Output:\n      S        signature, an octet string\
    \ of length k, where k is the\n               length in octets of the RSA modulus\
    \ n\n   Errors:  \"message too long\"; \"RSA modulus too short\"\n   Steps:\n\
    \      1.  EMSA-PKCS1-v1_5 encoding: Apply the EMSA-PKCS1-v1_5 encoding\n    \
    \      operation (Section 9.2) to the message M to produce an encoded\n      \
    \    message EM of length k octets:\n             EM = EMSA-PKCS1-V1_5-ENCODE\
    \ (M, k).\n          If the encoding operation outputs \"message too long\", output\n\
    \          \"message too long\" and stop.  If the encoding operation\n       \
    \   outputs \"intended encoded message length too short\", output\n          \"\
    RSA modulus too short\" and stop.\n      2.  RSA signature:\n          a.  Convert\
    \ the encoded message EM to an integer message\n              representative m\
    \ (see Section 4.2):\n                 m = OS2IP (EM).\n          b.  Apply the\
    \ RSASP1 signature primitive (Section 5.2.1) to\n              the RSA private\
    \ key K and the message representative m to\n              produce an integer\
    \ signature representative s:\n                 s = RSASP1 (K, m).\n         \
    \ c.  Convert the signature representative s to a signature S of\n           \
    \   length k octets (see Section 4.1):\n                 S = I2OSP (s, k).\n \
    \     3.  Output the signature S.\n"
- title: 8.2.2.  Signature Verification Operation
  contents:
  - "8.2.2.  Signature Verification Operation\n   RSASSA-PKCS1-V1_5-VERIFY ((n, e),\
    \ M, S)\n   Input:\n      (n, e)  signer's RSA public key\n      M       message\
    \ whose signature is to be verified, an octet string\n      S       signature\
    \ to be verified, an octet string of length k,\n              where k is the length\
    \ in octets of the RSA modulus n\n   Output  \"valid signature\" or \"invalid\
    \ signature\"\n   Errors:  \"message too long\"; \"RSA modulus too short\"\n \
    \  Steps:\n      1.  Length checking: If the length of the signature S is not\
    \ k\n          octets, output \"invalid signature\" and stop.\n      2.  RSA verification:\n\
    \          a.  Convert the signature S to an integer signature\n             \
    \ representative s (see Section 4.2):\n                 s = OS2IP (S).\n     \
    \     b.  Apply the RSAVP1 verification primitive (Section 5.2.2) to\n       \
    \       the RSA public key (n, e) and the signature representative\n         \
    \     s to produce an integer message representative m:\n                 m =\
    \ RSAVP1 ((n, e), s).\n              If RSAVP1 outputs \"signature representative\
    \ out of range\",\n              output \"invalid signature\" and stop.\n    \
    \      c.  Convert the message representative m to an encoded message\n      \
    \        EM of length k octets (see Section 4.1):\n                 EM = I2OSP\
    \ (m, k).\n              If I2OSP outputs \"integer too large\", output \"invalid\n\
    \              signature\" and stop.\n      3.  EMSA-PKCS1-v1_5 encoding: Apply\
    \ the EMSA-PKCS1-v1_5 encoding\n          operation (Section 9.2) to the message\
    \ M to produce a second\n          encoded message EM' of length k octets:\n \
    \            EM' = EMSA-PKCS1-V1_5-ENCODE (M, k).\n          If the encoding operation\
    \ outputs \"message too long\", output\n          \"message too long\" and stop.\
    \  If the encoding operation\n          outputs \"intended encoded message length\
    \ too short\", output\n          \"RSA modulus too short\" and stop.\n      4.\
    \  Compare the encoded message EM and the second encoded message\n          EM'.\
    \  If they are the same, output \"valid signature\";\n          otherwise, output\
    \ \"invalid signature\".\n      Note: Another way to implement the signature verification\n\
    \      operation is to apply a \"decoding\" operation (not specified in\n    \
    \  this document) to the encoded message to recover the underlying\n      hash\
    \ value, and then compare it to a newly computed hash value.\n      This has the\
    \ advantage that it requires less intermediate storage\n      (two hash values\
    \ rather than two encoded messages), but the\n      disadvantage that it requires\
    \ additional code.\n"
- title: 9.  Encoding Methods for Signatures with Appendix
  contents:
  - "9.  Encoding Methods for Signatures with Appendix\n   Encoding methods consist\
    \ of operations that map between octet string\n   messages and octet-string-encoded\
    \ messages, which are converted to\n   and from integer message representatives\
    \ in the schemes.  The integer\n   message representatives are processed via the\
    \ primitives.  The\n   encoding methods thus provide the connection between the\
    \ schemes,\n   which process messages, and the primitives.\n   An encoding method\
    \ for signatures with appendix, for the purposes of\n   this document, consists\
    \ of an encoding operation and optionally a\n   verification operation.  An encoding\
    \ operation maps a message M to an\n   encoded message EM of a specified length.\
    \  A verification operation\n   determines whether a message M and an encoded\
    \ message EM are\n   consistent, i.e., whether the encoded message EM is a valid\
    \ encoding\n   of the message M.\n   The encoding operation may introduce some\
    \ randomness, so that\n   different applications of the encoding operation to\
    \ the same message\n   will produce different encoded messages, which has benefits\
    \ for\n   provable security.  For such an encoding method, both an encoding and\n\
    \   a verification operation are needed unless the verifier can reproduce\n  \
    \ the randomness (e.g., by obtaining the salt value from the signer).\n   For\
    \ a deterministic encoding method, only an encoding operation is\n   needed.\n\
    \   Two encoding methods for signatures with appendix are employed in the\n  \
    \ signature schemes and are specified here: EMSA-PSS and\n   EMSA-PKCS1-v1_5.\n"
- title: 9.1.  EMSA-PSS
  contents:
  - "9.1.  EMSA-PSS\n   This encoding method is parameterized by the choice of hash\
    \ function,\n   mask generation function, and salt length.  These options should\
    \ be\n   fixed for a given RSA key, except that the salt length can be\n   variable\
    \ (see [JONSSON] for discussion).  Suggested hash and mask\n   generation functions\
    \ are given in Appendix B.  The encoding method is\n   based on Bellare and Rogaway's\
    \ Probabilistic Signature Scheme (PSS)\n   [RSARABIN][PSS].  It is randomized\
    \ and has an encoding operation and\n   a verification operation.\n   Figure 2\
    \ illustrates the encoding operation.\n      __________________________________________________________________\n\
    \                                     +-----------+\n                        \
    \             |     M     |\n                                     +-----------+\n\
    \                                           |\n                              \
    \             V\n                                         Hash\n             \
    \                              |\n                                           V\n\
    \                             +--------+----------+----------+\n             \
    \           M' = |Padding1|  mHash   |   salt   |\n                          \
    \   +--------+----------+----------+\n                                       \
    \     |\n                  +--------+----------+     V\n            DB =  |Padding2|\
    \   salt   |   Hash\n                  +--------+----------+     |\n         \
    \                   |               |\n                            V         \
    \      |\n                           xor <--- MGF <---|\n                    \
    \        |               |\n                            |               |\n  \
    \                          V               V\n                  +-------------------+----------+--+\n\
    \            EM =  |    maskedDB       |     H    |bc|\n                  +-------------------+----------+--+\n\
    \      __________________________________________________________________\n  \
    \ Figure 2: EMSA-PSS Encoding Operation\n   Note that the verification operation\
    \ follows reverse steps to recover\n   salt and then forward steps to recompute\
    \ and compare H.\n   Notes:\n   1.  The encoding method defined here differs from\
    \ the one in Bellare\n       and Rogaway's submission to IEEE 1363a [PSS] in three\
    \ respects:\n       *  It applies a hash function rather than a mask generation\n\
    \          function to the message.  Even though the mask generation\n       \
    \   function is based on a hash function, it seems more natural to\n         \
    \ apply a hash function directly.\n       *  The value that is hashed together\
    \ with the salt value is the\n          string (0x)00 00 00 00 00 00 00 00 ||\
    \ mHash rather than the\n          message M itself.  Here, mHash is the hash\
    \ of M.  Note that\n          the hash function is the same in both steps.  See\
    \ Note 3 below\n          for further discussion.  (Also, the name \"salt\" is\
    \ used\n          instead of \"seed\", as it is more reflective of the value's\n\
    \          role.)\n       *  The encoded message in EMSA-PSS has nine fixed bits;\
    \ the first\n          bit is 0 and the last eight bits form a \"trailer field\"\
    , the\n          octet 0xbc.  In the original scheme, only the first bit is\n\
    \          fixed.  The rationale for the trailer field is for\n          compatibility\
    \ with the Integer Factorization Signature\n          Primitive using Rabin-Williams\
    \ (IFSP-RW) in IEEE 1363\n          [IEEE1363] and the corresponding primitive\
    \ in ISO/IEC\n          9796-2:2010 [ISO9796].\n   2.  Assuming that the mask\
    \ generation function is based on a hash\n       function, it is RECOMMENDED that\
    \ the hash function be the same as\n       the one that is applied to the message;\
    \ see Section 8.1 for\n       further discussion.\n   3.  Without compromising\
    \ the security proof for RSASSA-PSS, one may\n       perform Steps 1 and 2 of\
    \ EMSA-PSS-ENCODE and EMSA-PSS-VERIFY (the\n       application of the hash function\
    \ to the message) outside the\n       module that computes the rest of the signature\
    \ operation, so that\n       mHash rather than the message M itself is input to\
    \ the module.\n       In other words, the security proof for RSASSA-PSS still\
    \ holds\n       even if an opponent can control the value of mHash.  This is\n\
    \       convenient if the module has limited I/O bandwidth, e.g., a smart\n  \
    \     card.  Note that previous versions of PSS [RSARABIN][PSS] did not\n    \
    \   have this property.  Of course, it may be desirable for other\n       security\
    \ reasons to have the module process the full message.\n       For instance, the\
    \ module may need to \"see\" what it is signing if\n       it does not trust the\
    \ component that computes the hash value.\n   4.  Typical salt lengths in octets\
    \ are hLen (the length of the output\n       of the hash function Hash) and 0.\
    \  In both cases, the security of\n       RSASSA-PSS can be closely related to\
    \ the hardness of inverting\n       RSAVP1.  Bellare and Rogaway [RSARABIN] give\
    \ a tight lower bound\n       for the security of the original RSA-PSS scheme,\
    \ which\n       corresponds roughly to the former case, while Coron [FDH] gives\
    \ a\n       lower bound for the related Full Domain Hashing scheme, which\n  \
    \     corresponds roughly to the latter case.  In [PSSPROOF], Coron\n       provides\
    \ a general treatment with various salt lengths ranging\n       from 0 to hLen;\
    \ see [IEEE1363A] for discussion.  See also\n       [JONSSON], which adapts the\
    \ security proofs in [RSARABIN]\n       [PSSPROOF] to address the differences\
    \ between the original and\n       the present version of RSA-PSS as listed in\
    \ Note 1 above.\n   5.  As noted in IEEE 1363a [IEEE1363A], the use of randomization\
    \ in\n       signature schemes -- such as the salt value in EMSA-PSS -- may\n\
    \       provide a \"covert channel\" for transmitting information other\n    \
    \   than the message being signed.  For more on covert channels, see\n       [SIMMONS].\n"
- title: 9.1.1.  Encoding Operation
  contents:
  - "9.1.1.  Encoding Operation\n   EMSA-PSS-ENCODE (M, emBits)\n   Options:\n   \
    \   Hash     hash function (hLen denotes the length in octets of\n           \
    \    the hash function output)\n      MGF      mask generation function\n    \
    \  sLen     intended length in octets of the salt\n   Input:\n      M        message\
    \ to be encoded, an octet string\n      emBits   maximal bit length of the integer\
    \ OS2IP (EM) (see Section\n               4.2), at least 8hLen + 8sLen + 9\n \
    \  Output:\n      EM       encoded message, an octet string of length emLen =\
    \ \\ceil\n               (emBits/8)\n   Errors:  \"Encoding error\"; \"message\
    \ too long\"\n   Steps:\n      1.   If the length of M is greater than the input\
    \ limitation for\n           the hash function (2^61 - 1 octets for SHA-1), output\n\
    \           \"message too long\" and stop.\n      2.   Let mHash = Hash(M), an\
    \ octet string of length hLen.\n      3.   If emLen < hLen + sLen + 2, output\
    \ \"encoding error\" and stop.\n      4.   Generate a random octet string salt\
    \ of length sLen; if sLen =\n           0, then salt is the empty string.\n  \
    \    5.   Let\n              M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt;\n\
    \           M' is an octet string of length 8 + hLen + sLen with eight\n     \
    \      initial zero octets.\n      6.   Let H = Hash(M'), an octet string of length\
    \ hLen.\n      7.   Generate an octet string PS consisting of emLen - sLen - hLen\n\
    \           - 2 zero octets.  The length of PS may be 0.\n      8.   Let DB =\
    \ PS || 0x01 || salt; DB is an octet string of length\n           emLen - hLen\
    \ - 1.\n      9.   Let dbMask = MGF(H, emLen - hLen - 1).\n      10.  Let maskedDB\
    \ = DB \\xor dbMask.\n      11.  Set the leftmost 8emLen - emBits bits of the\
    \ leftmost octet\n           in maskedDB to zero.\n      12.  Let EM = maskedDB\
    \ || H || 0xbc.\n      13.  Output EM.\n"
- title: 9.1.2.  Verification Operation
  contents:
  - "9.1.2.  Verification Operation\n   EMSA-PSS-VERIFY (M, EM, emBits)\n   Options:\n\
    \      Hash     hash function (hLen denotes the length in octets of\n        \
    \       the hash function output)\n      MGF      mask generation function\n \
    \     sLen     intended length in octets of the salt\n   Input:\n      M     \
    \   message to be verified, an octet string\n      EM       encoded message, an\
    \ octet string of length emLen = \\ceil\n               (emBits/8)\n      emBits\
    \   maximal bit length of the integer OS2IP (EM) (see Section\n              \
    \ 4.2), at least 8hLen + 8sLen + 9\n   Output:  \"consistent\" or \"inconsistent\"\
    \n   Steps:\n      1.   If the length of M is greater than the input limitation\
    \ for\n           the hash function (2^61 - 1 octets for SHA-1), output\n    \
    \       \"inconsistent\" and stop.\n      2.   Let mHash = Hash(M), an octet string\
    \ of length hLen.\n      3.   If emLen < hLen + sLen + 2, output \"inconsistent\"\
    \ and stop.\n      4.   If the rightmost octet of EM does not have hexadecimal\
    \ value\n           0xbc, output \"inconsistent\" and stop.\n      5.   Let maskedDB\
    \ be the leftmost emLen - hLen - 1 octets of EM,\n           and let H be the\
    \ next hLen octets.\n      6.   If the leftmost 8emLen - emBits bits of the leftmost\
    \ octet in\n           maskedDB are not all equal to zero, output \"inconsistent\"\
    \ and\n           stop.\n      7.   Let dbMask = MGF(H, emLen - hLen - 1).\n \
    \     8.   Let DB = maskedDB \\xor dbMask.\n      9.   Set the leftmost 8emLen\
    \ - emBits bits of the leftmost octet\n           in DB to zero.\n      10.  If\
    \ the emLen - hLen - sLen - 2 leftmost octets of DB are not\n           zero or\
    \ if the octet at position emLen - hLen - sLen - 1 (the\n           leftmost position\
    \ is \"position 1\") does not have hexadecimal\n           value 0x01, output\
    \ \"inconsistent\" and stop.\n      11.  Let salt be the last sLen octets of DB.\n\
    \      12.  Let\n              M' = (0x)00 00 00 00 00 00 00 00 || mHash || salt\
    \ ;\n           M' is an octet string of length 8 + hLen + sLen with eight\n \
    \          initial zero octets.\n      13.  Let H' = Hash(M'), an octet string\
    \ of length hLen.\n      14.  If H = H', output \"consistent\".  Otherwise, output\n\
    \           \"inconsistent\".\n"
- title: 9.2.  EMSA-PKCS1-v1_5
  contents:
  - "9.2.  EMSA-PKCS1-v1_5\n   This encoding method is deterministic and only has\
    \ an encoding\n   operation.\n   EMSA-PKCS1-v1_5-ENCODE (M, emLen)\n   Option:\n\
    \      Hash     hash function (hLen denotes the length in octets of\n        \
    \       the hash function output)\n   Input:\n      M        message to be encoded\n\
    \      emLen    intended length in octets of the encoded message, at\n       \
    \        least tLen + 11, where tLen is the octet length of the\n            \
    \   Distinguished Encoding Rules (DER) encoding T of\n               a certain\
    \ value computed during the encoding operation\n   Output:\n      EM       encoded\
    \ message, an octet string of length emLen\n   Errors:  \"message too long\";\
    \ \"intended encoded message length too\n      short\"\n   Steps:\n      1.  Apply\
    \ the hash function to the message M to produce a hash\n          value H:\n \
    \            H = Hash(M).\n          If the hash function outputs \"message too\
    \ long\", output\n          \"message too long\" and stop.\n      2.  Encode the\
    \ algorithm ID for the hash function and the hash\n          value into an ASN.1\
    \ value of type DigestInfo (see\n          Appendix A.2.4) with the DER, where\
    \ the type DigestInfo has\n          the syntax\n               DigestInfo ::=\
    \ SEQUENCE {\n                   digestAlgorithm AlgorithmIdentifier,\n      \
    \             digest OCTET STRING\n               }\n          The first field\
    \ identifies the hash function and the second\n          contains the hash value.\
    \  Let T be the DER encoding of the\n          DigestInfo value (see the notes\
    \ below), and let tLen be the\n          length in octets of T.\n      3.  If\
    \ emLen < tLen + 11, output \"intended encoded message length\n          too short\"\
    \ and stop.\n      4.  Generate an octet string PS consisting of emLen - tLen\
    \ - 3\n          octets with hexadecimal value 0xff.  The length of PS will be\n\
    \          at least 8 octets.\n      5.  Concatenate PS, the DER encoding T, and\
    \ other padding to form\n          the encoded message EM as\n             EM\
    \ = 0x00 || 0x01 || PS || 0x00 || T.\n      6.  Output EM.\n   Notes:\n   1. \
    \ For the nine hash functions mentioned in Appendix B.1, the DER\n       encoding\
    \ T of the DigestInfo value is equal to the following:\n         MD2:     (0x)30\
    \ 20 30 0c 06 08 2a 86 48 86 f7 0d 02 02 05 00 04\n                      10 ||\
    \ H.\n         MD5:     (0x)30 20 30 0c 06 08 2a 86 48 86 f7 0d 02 05 05 00 04\n\
    \                      10 || H.\n         SHA-1:   (0x)30 21 30 09 06 05 2b 0e\
    \ 03 02 1a 05 00 04 14 || H.\n         SHA-224:  (0x)30 2d 30 0d 06 09 60 86 48\
    \ 01 65 03 04 02 04\n                      05 00 04 1c || H.\n         SHA-256:\
    \ (0x)30 31 30 0d 06 09 60 86 48 01 65 03 04 02 01 05 00\n                   \
    \   04 20 || H.\n         SHA-384: (0x)30 41 30 0d 06 09 60 86 48 01 65 03 04\
    \ 02 02 05 00\n                      04 30 || H.\n         SHA-512: (0x)30 51\
    \ 30 0d 06 09 60 86 48 01 65 03 04 02 03 05 00\n                      04 40 ||\
    \ H.\n         SHA-512/224:  (0x)30 2d 30 0d 06 09 60 86 48 01 65 03 04 02 05\n\
    \                           05 00 04 1c || H.\n         SHA-512/256:  (0x)30 31\
    \ 30 0d 06 09 60 86 48 01 65 03 04 02 06\n                           05 00 04\
    \ 20 || H.\n   2.  In version 1.5 of this document, T was defined as the BER\n\
    \       encoding, rather than the DER encoding, of the DigestInfo value.\n   \
    \    In particular, it is possible -- at least in theory -- that the\n       verification\
    \ operation defined in this document (as well as in\n       version 2.0) rejects\
    \ a signature that is valid with respect to\n       the specification given in\
    \ PKCS #1 v1.5.  This occurs if other\n       rules than DER are applied to DigestInfo\
    \ (e.g., an indefinite\n       length encoding of the underlying SEQUENCE type).\
    \  While this is\n       unlikely to be a concern in practice, a cautious implementor\
    \ may\n       choose to employ a verification operation based on a BER decoding\n\
    \       operation as specified in PKCS #1 v1.5.  In this manner,\n       compatibility\
    \ with any valid implementation based on PKCS #1 v1.5\n       is obtained.  Such\
    \ a verification operation should indicate\n       whether the underlying BER\
    \ encoding is a DER encoding and hence\n       whether the signature is valid\
    \ with respect to the specification\n       given in this document.\n"
- title: 10.  Security Considerations
  contents:
  - "10.  Security Considerations\n   Security considerations are discussed throughout\
    \ this memo.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [GARNER]   Garner, H., \"The Residue Number System\"\
    , IRE Transactions\n              on Electronic Computers, Volume EC-8, Issue\
    \ 2, pp.\n              140-147, DOI 10.1109/TEC.1959.5219515, June 1959.\n  \
    \ [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n          \
    \    Requirement Levels\", BCP 14, RFC 2119,\n              DOI 10.17487/RFC2119,\
    \ March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n   [RSA]\
    \      Rivest, R., Shamir, A., and L. Adleman, \"A Method for\n              Obtaining\
    \ Digital Signatures and Public-Key\n              Cryptosystems\", Communications\
    \ of the ACM, Volume 21,\n              Issue 2, pp. 120-126, DOI 10.1145/359340.359342,\
    \ February\n              1978.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [ANSIX944] ANSI, \"Key Establishment Using\
    \ Integer Factorization\n              Cryptography\", ANSI X9.44-2007, August\
    \ 2007.\n   [BKS]      Bleichenbacher, D., Kaliski, B., and J. Staddon, \"Recent\n\
    \              Results on PKCS #1: RSA Encryption Standard\", RSA\n          \
    \    Laboratories, Bulletin No. 7, June 1998.\n   [BLEICHENBACHER]\n         \
    \     Bleichenbacher, D., \"Chosen Ciphertext Attacks Against\n              Protocols\
    \ Based on the RSA Encryption Standard PKCS #1\",\n              Lecture Notes\
    \ in Computer Science, Volume 1462, pp. 1-12,\n              1998.\n   [CHOSEN]\
    \   Desmedt, Y. and A. Odlyzko, \"A Chosen Text Attack on the\n              RSA\
    \ Cryptosystem and Some Discrete Logarithm Schemes\",\n              Lecture Notes\
    \ in Computer Science, Volume 218, pp.\n              516-522, 1985.\n   [COCHRAN]\
    \  Cochran, M., \"Notes on the Wang et al. 2^63 SHA-1\n              Differential\
    \ Path\", Cryptology ePrint Archive: Report\n              2007/474, August 2008,\
    \ <http://eprint.iacr.org/2007/474>.\n   [FASTDEC]  Quisquater, J. and C. Couvreur,\
    \ \"Fast Decipherment\n              Algorithm for RSA Public-Key Cryptosystem\"\
    , Electronic\n              Letters, Volume 18, Issue 21, pp. 905-907,\n     \
    \         DOI 10.1049/el:19820617, October 1982.\n   [FDH]      Coron, J., \"\
    On the Exact Security of Full Domain Hash\",\n              Lecture Notes in Computer\
    \ Science, Volume 1880, pp.\n              229-235, 2000.\n   [FOPS]     Fujisaki,\
    \ E., Okamoto, T., Pointcheval, D., and J. Stern,\n              \"RSA-OAEP is\
    \ Secure under the RSA Assumption\", Lecture\n              Notes in Computer\
    \ Science, Volume 2139, pp. 260-274,\n              August 2001.\n   [FORGERY]\
    \  Coppersmith, D., Halevi, S., and C. Jutla, \"ISO 9796-1 and\n             \
    \ the new forgery strategy\", rump session of Crypto, August\n              1999.\n\
    \   [HAASTAD]  Haastad, J., \"Solving Simultaneous Modular Equations of\n    \
    \          Low Degree\", SIAM Journal on Computing, Volume 17,\n             \
    \ Issue 2, pp. 336-341, DOI 10.1137/0217019, April 1988.\n   [HANDBOOK] Menezes,\
    \ A., van Oorschot, P., and S. Vanstone, \"Handbook\n              of Applied\
    \ Cryptography\", CRC Press, ISBN: 0849385237,\n              1996.\n   [HASHID]\
    \   Kaliski, B., \"On Hash Function Firewalls in Signature\n              Schemes\"\
    , Lecture Notes in Computer Science, Volume 2271,\n              pp. 1-16, DOI\
    \ 10.1007/3-540-45760-7_1, February 2002.\n   [IEEE1363] IEEE, \"Standard Specifications\
    \ for Public Key\n              Cryptography\", IEEE Std 1363-2000,\n        \
    \      DOI 10.1109/IEEESTD.2000.92292, August 2000,\n              <http://ieeexplore.ieee.org/document/891000/>.\n\
    \   [IEEE1363A]\n              IEEE, \"Standard Specifications for Public Key\
    \ Cryptography\n              - Amendment 1: Additional Techniques\", IEEE Std\
    \ 1363a-\n              2004, DOI 10.1109/IEEESTD.2004.94612, September 2004,\n\
    \              <http://ieeexplore.ieee.org/document/1335427/>.\n   [ISO18033]\
    \ International Organization for Standardization,\n              \"Information\
    \ technology -- Security techniques --\n              Encryption algorithms -\
    \ Part 2: Asymmetric ciphers\", ISO/\n              IEC 18033-2:2006, May 2006.\n\
    \   [ISO9594]  International Organization for Standardization,\n             \
    \ \"Information technology - Open Systems Interconnection -\n              The\
    \ Directory: Public-key and attribute certificate\n              frameworks\"\
    , ISO/IEC 9594-8:2008, December 2008.\n   [ISO9796]  International Organization\
    \ for Standardization,\n              \"Information technology - Security techniques\
    \ - Digital\n              signature schemes giving message recovery - Part 2:\n\
    \              Integer factorization based mechanisms\",\n              ISO/IEC\
    \ 9796-2:2010, December 2010.\n   [JONSSON]  Jonsson, J., \"Security Proofs for\
    \ the RSA-PSS Signature\n              Scheme and Its Variants\", Cryptology ePrint\n\
    \              Archive: Report 2001/053, March 2002,\n              <http://eprint.iacr.org/2001/053>.\n\
    \   [LOWEXP]   Coppersmith, D., Franklin, M., Patarin, J., and M. Reiter,\n  \
    \            \"Low-Exponent RSA with Related Messages\", Lecture Notes in\n  \
    \            Computer Science, Volume 1070, pp. 1-9, 1996.\n   [MANGER]   Manger,\
    \ J., \"A Chosen Ciphertext Attack on RSA Optimal\n              Asymmetric Encryption\
    \ Padding (OAEP) as Standardized in\n              PKCS #1 v2.0\", Lecture Notes\
    \ in Computer Science, Volume\n              2139, pp. 230-238, DOI 10.1007/3-540-44647-8_14,\
    \ 2001.\n   [MD4]      Dobbertin, H., \"Cryptanalysis of MD4\", Lecture Notes\
    \ in\n              Computer Science, Volume 1039, pp. 53-69,\n              DOI\
    \ 10.1007/3-540-60865-6_43, 1996.\n   [MD4FIRST] Dobbertin, H., \"The First Two\
    \ Rounds of MD4 are Not One-\n              Way\", Lecture Notes in Computer Science,\
    \ Volume 1372, pp.\n              284-292, DOI 10.1007/3-540-69710-1_19, March\
    \ 1998.\n   [MD4LAST]  den Boer, B. and A. Bosselaers, \"An Attack on the Last\
    \ Two\n              Rounds of MD4\", Lecture Notes in Computer Science, Volume\n\
    \              576, pp. 194-203, DOI 10.1007/3-540-46766-1_14, 1992.\n   [NEWATTACK]\n\
    \              Coron, J., Joye, M., Naccache, D., and P. Paillier, \"New\n   \
    \           Attacks on PKCS #1 v1.5 Encryption\", Lecture Notes in\n         \
    \     Computer Science, Volume 1807, pp. 369-381,\n              DOI 10.1007/3-540-45539-6_25,\
    \ May 2000.\n   [OAEP]     Bellare, M. and P. Rogaway, \"Optimal Asymmetric Encryption\n\
    \              - How to Encrypt with RSA\", Lecture Notes in Computer\n      \
    \        Science, Volume 950, pp. 92-111, November 1995.\n   [PA98]     Bellare,\
    \ M., Desai, A., Pointcheval, D., and P. Rogaway,\n              \"Relations Among\
    \ Notions of Security for Public-Key\n              Encryption Schemes\", Lecture\
    \ Notes in Computer\n              Science, Volume 1462, pp. 26-45, DOI 10.1007/BFb0055718,\n\
    \              1998.\n   [PADDING]  Coron, J., Naccache, D., and J. Stern, \"\
    On the Security of\n              RSA Padding\", Lecture Notes in Computer Science,\
    \ Volume\n              1666, pp. 1-18, DOI 10.1007/3-540-48405-1_1, December\n\
    \              1999.\n   [PKCS1_22] RSA Laboratories, \"PKCS #1: RSA Cryptography\
    \ Standard\n              Version 2.2\", October 2012.\n   [PREFIX]   Stevens,\
    \ M., Lenstra, A., and B. de Weger, \"Chosen-prefix\n              collisions\
    \ for MD5 and applications\", International\n              Journal of Applied\
    \ Cryptography, Volume 2, No. 4, pp.\n              322-359, July 2012.\n   [PSS]\
    \      Bellare, M. and P. Rogaway, \"PSS: Provably Secure Encoding\n         \
    \     Method for Digital Signatures\", Submission to IEEE P1363a,\n          \
    \    August 1998, <http://grouper.ieee.org/groups/1363/\n              P1363a/contributions/pss-submission.pdf>.\n\
    \   [PSSPROOF] Coron, J., \"Optimal Security Proofs for PSS and Other\n      \
    \        Signature Schemes\", Lecture Notes in Computer\n              Science,\
    \ Volume 2332, pp. 272-287,\n              DOI 10.1007/3-540-46035-7_18, 2002.\n\
    \   [RFC1319]  Kaliski, B., \"The MD2 Message-Digest Algorithm\", RFC 1319,\n\
    \              DOI 10.17487/RFC1319, April 1992,\n              <http://www.rfc-editor.org/info/rfc1319>.\n\
    \   [RFC1321]  Rivest, R., \"The MD5 Message-Digest Algorithm\", RFC 1321,\n \
    \             DOI 10.17487/RFC1321, April 1992,\n              <http://www.rfc-editor.org/info/rfc1321>.\n\
    \   [RFC2313]  Kaliski, B., \"PKCS #1: RSA Encryption Version 1.5\",\n       \
    \       RFC 2313, DOI 10.17487/RFC2313, March 1998,\n              <http://www.rfc-editor.org/info/rfc2313>.\n\
    \   [RFC2315]  Kaliski, B., \"PKCS #7: Cryptographic Message Syntax\n        \
    \      Version 1.5\", RFC 2315, DOI 10.17487/RFC2315, March 1998,\n          \
    \    <http://www.rfc-editor.org/info/rfc2315>.\n   [RFC2437]  Kaliski, B. and\
    \ J. Staddon, \"PKCS #1: RSA Cryptography\n              Specifications Version\
    \ 2.0\", RFC 2437,\n              DOI 10.17487/RFC2437, October 1998,\n      \
    \        <http://www.rfc-editor.org/info/rfc2437>.\n   [RFC3447]  Jonsson, J.\
    \ and B. Kaliski, \"Public-Key Cryptography\n              Standards (PKCS) #1:\
    \ RSA Cryptography Specifications\n              Version 2.1\", RFC 3447, DOI\
    \ 10.17487/RFC3447, February\n              2003, <http://www.rfc-editor.org/info/rfc3447>.\n\
    \   [RFC5246]  Dierks, T. and E. Rescorla, \"The Transport Layer Security\n  \
    \            (TLS) Protocol Version 1.2\", RFC 5246,\n              DOI 10.17487/RFC5246,\
    \ August 2008,\n              <http://www.rfc-editor.org/info/rfc5246>.\n   [RFC5652]\
    \  Housley, R., \"Cryptographic Message Syntax (CMS)\", STD 70,\n            \
    \  RFC 5652, DOI 10.17487/RFC5652, September 2009,\n              <http://www.rfc-editor.org/info/rfc5652>.\n\
    \   [RFC5958]  Turner, S., \"Asymmetric Key Packages\", RFC 5958,\n          \
    \    DOI 10.17487/RFC5958, August 2010,\n              <http://www.rfc-editor.org/info/rfc5958>.\n\
    \   [RFC6149]  Turner, S. and L. Chen, \"MD2 to Historic Status\",\n         \
    \     RFC 6149, DOI 10.17487/RFC6149, March 2011,\n              <http://www.rfc-editor.org/info/rfc6149>.\n\
    \   [RFC7292]  Moriarty, K., Ed., Nystrom, M., Parkinson, S., Rusch, A.,\n   \
    \           and M. Scott, \"PKCS #12: Personal Information Exchange\n        \
    \      Syntax v1.1\", RFC 7292, DOI 10.17487/RFC7292, July 2014,\n           \
    \   <http://www.rfc-editor.org/info/rfc7292>.\n   [RSARABIN] Bellare, M. and P.\
    \ Rogaway, \"The Exact Security of Digital\n              Signatures - How to\
    \ Sign with RSA and Rabin\", Lecture\n              Notes in Computer Science,\
    \ Volume 1070, pp. 399-416,\n              DOI 10.1007/3-540-68339-9_34, 1996.\n\
    \   [RSATLS]   Jonsson, J. and B. Kaliski, \"On the Security of RSA\n        \
    \      Encryption in TLS\", Lecture Notes in Computer\n              Science,\
    \ Volume 2442, pp. 127-142,\n              DOI 10.1007/3-540-45708-9_9, 2002.\n\
    \   [SHA1CRYPT]\n              Wang, X., Yao, A., and F. Yao, \"Cryptanalysis\
    \ on SHA-1\",\n              Lecture Notes in Computer Science, Volume 2442, pp.\n\
    \              127-142, February 2005,\n              <http://csrc.nist.gov/groups/ST/hash/documents/\n\
    \              Wang_SHA1-New-Result.pdf>.\n   [SHOUP]    Shoup, V., \"OAEP Reconsidered\
    \ (Extended Abstract)\",\n              Lecture Notes in Computer Science, Volume\
    \ 2139, pp.\n              239-259, DOI 10.1007/3-540-44647-8_15, 2001.\n   [SHS]\
    \      National Institute of Standards and Technology, \"Secure\n            \
    \  Hash Standard (SHS)\", FIPS PUB 180-4, August 2015,\n              <http://dx.doi.org/10.6028/NIST.FIPS.180-4>.\n\
    \   [SILVERMAN]\n              Silverman, R., \"A Cost-Based Security Analysis\
    \ of\n              Symmetric and Asymmetric Key Lengths\", RSA\n            \
    \  Laboratories, Bulletin No. 13, 2000.\n   [SIMMONS]  Simmons, G., \"Subliminal\
    \ Communication is Easy Using the\n              DSA\", Lecture Notes in Computer\
    \ Science, Volume 765, pp.\n              218-232, DOI 10.1007/3-540-48285-7_18,\
    \ 1994.\n"
- title: Appendix A.  ASN.1 Syntax
  contents:
  - 'Appendix A.  ASN.1 Syntax

    '
- title: A.1.  RSA Key Representation
  contents:
  - "A.1.  RSA Key Representation\n   This section defines ASN.1 object identifiers\
    \ for RSA public and\n   private keys and defines the types RSAPublicKey and RSAPrivateKey.\n\
    \   The intended application of these definitions includes X.509\n   certificates,\
    \ PKCS #8 [RFC5958], and PKCS #12 [RFC7292].\n   The object identifier rsaEncryption\
    \ identifies RSA public and private\n   keys as defined in Appendices A.1.1 and\
    \ A.1.2.  The parameters field\n   has associated with this OID in a value of\
    \ type AlgorithmIdentifier\n   SHALL have a value of type NULL.\n      rsaEncryption\
    \    OBJECT IDENTIFIER ::= { pkcs-1 1 }\n   The definitions in this section have\
    \ been extended to support multi-\n   prime RSA, but they are backward compatible\
    \ with previous versions.\n"
- title: A.1.1.  RSA Public Key Syntax
  contents:
  - "A.1.1.  RSA Public Key Syntax\n   An RSA public key should be represented with\
    \ the ASN.1 type\n   RSAPublicKey:\n         RSAPublicKey ::= SEQUENCE {\n   \
    \          modulus           INTEGER,  -- n\n             publicExponent    INTEGER\
    \   -- e\n         }\n   The fields of type RSAPublicKey have the following meanings:\n\
    \   o  modulus is the RSA modulus n.\n   o  publicExponent is the RSA public exponent\
    \ e.\n"
- title: A.1.2.  RSA Private Key Syntax
  contents:
  - "A.1.2.  RSA Private Key Syntax\n   An RSA private key should be represented with\
    \ the ASN.1 type\n   RSAPrivateKey:\n         RSAPrivateKey ::= SEQUENCE {\n \
    \            version           Version,\n             modulus           INTEGER,\
    \  -- n\n             publicExponent    INTEGER,  -- e\n             privateExponent\
    \   INTEGER,  -- d\n             prime1            INTEGER,  -- p\n          \
    \   prime2            INTEGER,  -- q\n             exponent1         INTEGER,\
    \  -- d mod (p-1)\n             exponent2         INTEGER,  -- d mod (q-1)\n \
    \            coefficient       INTEGER,  -- (inverse of q) mod p\n           \
    \  otherPrimeInfos   OtherPrimeInfos OPTIONAL\n         }\n   The fields of type\
    \ RSAPrivateKey have the following meanings:\n   o  version is the version number,\
    \ for compatibility with future\n      revisions of this document.  It SHALL be\
    \ 0 for this version of the\n      document, unless multi-prime is used; in which\
    \ case, it SHALL be\n      1.\n            Version ::= INTEGER { two-prime(0),\
    \ multi(1) }\n               (CONSTRAINED BY\n               {-- version must\
    \ be multi if otherPrimeInfos present --})\n   o  modulus is the RSA modulus n.\n\
    \   o  publicExponent is the RSA public exponent e.\n   o  privateExponent is\
    \ the RSA private exponent d.\n   o  prime1 is the prime factor p of n.\n   o\
    \  prime2 is the prime factor q of n.\n   o  exponent1 is d mod (p - 1).\n   o\
    \  exponent2 is d mod (q - 1).\n   o  coefficient is the CRT coefficient q^(-1)\
    \ mod p.\n   o  otherPrimeInfos contains the information for the additional primes\n\
    \      r_3, ..., r_u, in order.  It SHALL be omitted if version is 0 and\n   \
    \   SHALL contain at least one instance of OtherPrimeInfo if version\n      is\
    \ 1.\n            OtherPrimeInfos ::= SEQUENCE SIZE(1..MAX) OF OtherPrimeInfo\n\
    \            OtherPrimeInfo ::= SEQUENCE {\n                prime            \
    \ INTEGER,  -- ri\n                exponent          INTEGER,  -- di\n       \
    \         coefficient       INTEGER   -- ti\n            }\n   The fields of type\
    \ OtherPrimeInfo have the following meanings:\n   o  prime is a prime factor r_i\
    \ of n, where i >= 3.\n   o  exponent is d_i = d mod (r_i - 1).\n   o  coefficient\
    \ is the CRT coefficient t_i = (r_1 * r_2 * ... *\n      r_(i-1))^(-1) mod r_i.\n\
    \   Note: It is important to protect the RSA private key against both\n   disclosure\
    \ and modification.  Techniques for such protection are\n   outside the scope\
    \ of this document.  Methods for storing and\n   distributing private keys and\
    \ other cryptographic data are described\n   in PKCS #12 and #15.\n"
- title: A.2.  Scheme Identification
  contents:
  - "A.2.  Scheme Identification\n   This section defines object identifiers for the\
    \ encryption and\n   signature schemes.  The schemes compatible with PKCS #1 v1.5\
    \ have the\n   same definitions as in PKCS #1 v1.5.  The intended application\
    \ of\n   these definitions includes X.509 certificates and PKCS #7.\n   Here are\
    \ type identifier definitions for the PKCS #1 OIDs:\n   PKCS1Algorithms    ALGORITHM-IDENTIFIER\
    \ ::= {\n       { OID rsaEncryption                PARAMETERS NULL } |\n     \
    \  { OID md2WithRSAEncryption         PARAMETERS NULL } |\n       { OID md5WithRSAEncryption\
    \         PARAMETERS NULL } |\n       { OID sha1WithRSAEncryption        PARAMETERS\
    \ NULL } |\n       { OID sha224WithRSAEncryption      PARAMETERS NULL } |\n  \
    \     { OID sha256WithRSAEncryption      PARAMETERS NULL } |\n       { OID sha384WithRSAEncryption\
    \      PARAMETERS NULL } |\n       { OID sha512WithRSAEncryption      PARAMETERS\
    \ NULL } |\n       { OID sha512-224WithRSAEncryption  PARAMETERS NULL } |\n  \
    \     { OID sha512-256WithRSAEncryption  PARAMETERS NULL } |\n       { OID id-RSAES-OAEP\
    \   PARAMETERS RSAES-OAEP-params } |\n       PKCS1PSourceAlgorithms          \
    \                     |\n       { OID id-RSASSA-PSS   PARAMETERS RSASSA-PSS-params\
    \ },\n       ...  -- Allows for future expansion --\n   }\n"
- title: A.2.1.  RSAES-OAEP
  contents:
  - "A.2.1.  RSAES-OAEP\n   The object identifier id-RSAES-OAEP identifies the RSAES-OAEP\n\
    \   encryption scheme.\n       id-RSAES-OAEP    OBJECT IDENTIFIER ::= { pkcs-1\
    \ 7 }\n   The parameters field associated with this OID in a value of type\n \
    \  AlgorithmIdentifier SHALL have a value of type RSAES-OAEP-params:\n   RSAES-OAEP-params\
    \ ::= SEQUENCE {\n       hashAlgorithm      [0] HashAlgorithm     DEFAULT sha1,\n\
    \       maskGenAlgorithm   [1] MaskGenAlgorithm  DEFAULT mgf1SHA1,\n       pSourceAlgorithm\
    \   [2] PSourceAlgorithm  DEFAULT pSpecifiedEmpty\n   }\n   The fields of type\
    \ RSAES-OAEP-params have the following meanings:\n   o  hashAlgorithm identifies\
    \ the hash function.  It SHALL be an\n      algorithm ID with an OID in the set\
    \ OAEP-PSSDigestAlgorithms.  For\n      a discussion of supported hash functions,\
    \ see Appendix B.1.\n       HashAlgorithm ::= AlgorithmIdentifier {\n        \
    \  {OAEP-PSSDigestAlgorithms}\n       }\n       OAEP-PSSDigestAlgorithms    ALGORITHM-IDENTIFIER\
    \ ::= {\n           { OID id-sha1       PARAMETERS NULL }|\n           { OID id-sha224\
    \     PARAMETERS NULL }|\n           { OID id-sha256     PARAMETERS NULL }|\n\
    \           { OID id-sha384     PARAMETERS NULL }|\n           { OID id-sha512\
    \     PARAMETERS NULL }|\n           { OID id-sha512-224 PARAMETERS NULL }|\n\
    \           { OID id-sha512-256 PARAMETERS NULL },\n           ...  -- Allows\
    \ for future expansion --\n       }\n   The default hash function is SHA-1:\n\
    \       sha1    HashAlgorithm ::= {\n           algorithm   id-sha1,\n       \
    \    parameters  SHA1Parameters : NULL\n       }\n       SHA1Parameters ::= NULL\n\
    \   o  maskGenAlgorithm identifies the mask generation function.  It\n      SHALL\
    \ be an algorithm ID with an OID in the set\n      PKCS1MGFAlgorithms, which for\
    \ this version SHALL consist of\n      id-mgf1, identifying the MGF1 mask generation\
    \ function (see\n      Appendix B.2.1).  The parameters field associated with\
    \ id-mgf1\n      SHALL be an algorithm ID with an OID in the set\n      OAEP-PSSDigestAlgorithms,\
    \ identifying the hash function on which\n      MGF1 is based.\n       MaskGenAlgorithm\
    \ ::= AlgorithmIdentifier { {PKCS1MGFAlgorithms} }\n       PKCS1MGFAlgorithms\
    \    ALGORITHM-IDENTIFIER ::= {\n           { OID id-mgf1 PARAMETERS HashAlgorithm\
    \ },\n           ...  -- Allows for future expansion --\n       }\n   o  The default\
    \ mask generation function is MGF1 with SHA-1:\n       mgf1SHA1    MaskGenAlgorithm\
    \ ::= {\n           algorithm   id-mgf1,\n           parameters  HashAlgorithm\
    \ : sha1\n       }\n   o  pSourceAlgorithm identifies the source (and possibly\
    \ the value) of\n      the label L.  It SHALL be an algorithm ID with an OID in\
    \ the set\n      PKCS1PSourceAlgorithms, which for this version SHALL consist\
    \ of\n      id-pSpecified, indicating that the label is specified explicitly.\n\
    \      The parameters field associated with id-pSpecified SHALL have a\n     \
    \ value of type OCTET STRING, containing the label.  In previous\n      versions\
    \ of this specification, the term \"encoding parameters\" was\n      used rather\
    \ than \"label\", hence the name of the type below.\n       PSourceAlgorithm ::=\
    \ AlgorithmIdentifier {\n          {PKCS1PSourceAlgorithms}\n       }\n      \
    \ PKCS1PSourceAlgorithms    ALGORITHM-IDENTIFIER ::= {\n           { OID id-pSpecified\
    \ PARAMETERS EncodingParameters },\n           ...  -- Allows for future expansion\
    \ --\n       }\n       id-pSpecified    OBJECT IDENTIFIER ::= { pkcs-1 9 }\n \
    \      EncodingParameters ::= OCTET STRING(SIZE(0..MAX))\n   o  The default label\
    \ is an empty string (so that lHash will contain\n      the hash of the empty\
    \ string):\n       pSpecifiedEmpty    PSourceAlgorithm ::= {\n           algorithm\
    \   id-pSpecified,\n           parameters  EncodingParameters : emptyString\n\
    \       }\n       emptyString    EncodingParameters ::= ''H\n   If all of the\
    \ default values of the fields in RSAES-OAEP-params are\n   used, then the algorithm\
    \ identifier will have the following value:\n       rSAES-OAEP-Default-Identifier\
    \    RSAES-AlgorithmIdentifier ::= {\n           algorithm   id-RSAES-OAEP,\n\
    \           parameters  RSAES-OAEP-params : {\n               hashAlgorithm  \
    \     sha1,\n               maskGenAlgorithm    mgf1SHA1,\n               pSourceAlgorithm\
    \    pSpecifiedEmpty\n           }\n       }\n       RSAES-AlgorithmIdentifier\
    \ ::= AlgorithmIdentifier  {\n           {PKCS1Algorithms}\n       }\n"
- title: A.2.2.  RSAES-PKCS-v1_5
  contents:
  - "A.2.2.  RSAES-PKCS-v1_5\n   The object identifier rsaEncryption (see Appendix\
    \ A.1) identifies the\n   RSAES-PKCS1-v1_5 encryption scheme.  The parameters\
    \ field associated\n   with this OID in a value of type AlgorithmIdentifier SHALL\
    \ have a\n   value of type NULL.  This is the same as in PKCS #1 v1.5.\n     \
    \  rsaEncryption    OBJECT IDENTIFIER ::= { pkcs-1 1 }\n"
- title: A.2.3.  RSASSA-PSS
  contents:
  - "A.2.3.  RSASSA-PSS\n   The object identifier id-RSASSA-PSS identifies the RSASSA-PSS\n\
    \   encryption scheme.\n       id-RSASSA-PSS    OBJECT IDENTIFIER ::= { pkcs-1\
    \ 10 }\n   The parameters field associated with this OID in a value of type\n\
    \   AlgorithmIdentifier SHALL have a value of type RSASSA-PSS-params:\n   RSASSA-PSS-params\
    \ ::= SEQUENCE {\n       hashAlgorithm      [0] HashAlgorithm      DEFAULT sha1,\n\
    \       maskGenAlgorithm   [1] MaskGenAlgorithm   DEFAULT mgf1SHA1,\n       saltLength\
    \         [2] INTEGER            DEFAULT 20,\n       trailerField       [3] TrailerField\
    \       DEFAULT trailerFieldBC\n   }\n   The fields of type RSASSA-PSS-params\
    \ have the following meanings:\n   o  hashAlgorithm identifies the hash function.\
    \  It SHALL be an\n      algorithm ID with an OID in the set OAEP-PSSDigestAlgorithms\
    \ (see\n      Appendix A.2.1).  The default hash function is SHA-1.\n   o  maskGenAlgorithm\
    \ identifies the mask generation function.  It\n      SHALL be an algorithm ID\
    \ with an OID in the set PKCS1MGFAlgorithms\n      (see Appendix A.2.1).  The\
    \ default mask generation function is\n      MGF1 with SHA-1.  For MGF1 (and more\
    \ generally, for other mask\n      generation functions based on a hash function),\
    \ it is RECOMMENDED\n      that the underlying hash function be the same as the\
    \ one\n      identified by hashAlgorithm; see Note 2 in Section 9.1 for further\n\
    \      comments.\n   o  saltLength is the octet length of the salt.  It SHALL\
    \ be an\n      integer.  For a given hashAlgorithm, the default value of\n   \
    \   saltLength is the octet length of the hash value.  Unlike the\n      other\
    \ fields of type RSASSA-PSS-params, saltLength does not need\n      to be fixed\
    \ for a given RSA key pair.\n   o  trailerField is the trailer field number, for\
    \ compatibility with\n      IEEE 1363a [IEEE1363A].  It SHALL be 1 for this version\
    \ of the\n      document, which represents the trailer field with hexadecimal\n\
    \      value 0xbc.  Other trailer fields (including the trailer field\n      HashID\
    \ || 0xcc in IEEE 1363a) are not supported in this document.\n       TrailerField\
    \ ::= INTEGER { trailerFieldBC(1) }\n   If the default values of the hashAlgorithm,\
    \ maskGenAlgorithm, and\n   trailerField fields of RSASSA-PSS-params are used,\
    \ then the algorithm\n   identifier will have the following value:\n       rSASSA-PSS-Default-Identifier\
    \    RSASSA-AlgorithmIdentifier ::= {\n           algorithm   id-RSASSA-PSS,\n\
    \           parameters  RSASSA-PSS-params : {\n               hashAlgorithm  \
    \     sha1,\n               maskGenAlgorithm    mgf1SHA1,\n               saltLength\
    \          20,\n               trailerField        trailerFieldBC\n          \
    \ }\n       }\n       RSASSA-AlgorithmIdentifier ::= AlgorithmIdentifier {\n \
    \          {PKCS1Algorithms}\n       }\n   Note: In some applications, the hash\
    \ function underlying a signature\n   scheme is identified separately from the\
    \ rest of the operations in\n   the signature scheme.  For instance, in PKCS #7\
    \ [RFC2315], a hash\n   function identifier is placed before the message and a\
    \ \"digest\n   encryption\" algorithm identifier (indicating the rest of the\n\
    \   operations) is carried with the signature.  In order for PKCS #7 to\n   support\
    \ the RSASSA-PSS signature scheme, an object identifier would\n   need to be defined\
    \ for the operations in RSASSA-PSS after the hash\n   function (analogous to the\
    \ RSAEncryption OID for the\n   RSASSA-PKCS1-v1_5 scheme).  S/MIME Cryptographic\
    \ Message Syntax (CMS)\n   [RFC5652] takes a different approach.  Although a hash\
    \ function\n   identifier is placed before the message, an algorithm identifier\
    \ for\n   the full signature scheme may be carried with a CMS signature (this\n\
    \   is done for DSA signatures).  Following this convention, the\n   id-RSASSA-PSS\
    \ OID can be used to identify RSASSA-PSS signatures in\n   CMS.  Since CMS is\
    \ considered the successor to PKCS #7 and new\n   developments such as the addition\
    \ of support for RSASSA-PSS will be\n   pursued with respect to CMS rather than\
    \ PKCS #7, an OID for the \"rest\n   of\" RSASSA-PSS is not defined in this version\
    \ of PKCS #1.\n"
- title: A.2.4.  RSASSA-PKCS-v1_5
  contents:
  - "A.2.4.  RSASSA-PKCS-v1_5\n   The object identifier for RSASSA-PKCS1-v1_5 SHALL\
    \ be one of the\n   following.  The choice of OID depends on the choice of hash\n\
    \   algorithm: MD2, MD5, SHA-1, SHA-224, SHA-256, SHA-384, SHA-512,\n   SHA-512/224,\
    \ or SHA-512/256.  Note that if either MD2 or MD5 is used,\n   then the OID is\
    \ just as in PKCS #1 v1.5.  For each OID, the\n   parameters field associated\
    \ with this OID in a value of type\n   AlgorithmIdentifier SHALL have a value\
    \ of type NULL.  The OID should\n   be chosen in accordance with the following\
    \ table:\n         Hash algorithm   OID\n         ------------------------------------------------------------\n\
    \         MD2              md2WithRSAEncryption        ::= {pkcs-1 2}\n      \
    \   MD5              md5WithRSAEncryption        ::= {pkcs-1 4}\n         SHA-1\
    \            sha1WithRSAEncryption       ::= {pkcs-1 5}\n         SHA-256    \
    \      sha224WithRSAEncryption     ::= {pkcs-1 14}\n         SHA-256         \
    \ sha256WithRSAEncryption     ::= {pkcs-1 11}\n         SHA-384          sha384WithRSAEncryption\
    \     ::= {pkcs-1 12}\n         SHA-512          sha512WithRSAEncryption     ::=\
    \ {pkcs-1 13}\n         SHA-512/224      sha512-224WithRSAEncryption ::= {pkcs-1\
    \ 15}\n         SHA-512/256      sha512-256WithRSAEncryption ::= {pkcs-1 16}\n\
    \   The EMSA-PKCS1-v1_5 encoding method includes an ASN.1 value of type\n   DigestInfo,\
    \ where the type DigestInfo has the syntax\n       DigestInfo ::= SEQUENCE {\n\
    \           digestAlgorithm DigestAlgorithm,\n           digest OCTET STRING\n\
    \       }\n   digestAlgorithm identifies the hash function and SHALL be an\n \
    \  algorithm ID with an OID in the set PKCS1-v1-5DigestAlgorithms.  For\n   a\
    \ discussion of supported hash functions, see Appendix B.1.\n       DigestAlgorithm\
    \ ::= AlgorithmIdentifier {\n          {PKCS1-v1-5DigestAlgorithms}\n       }\n\
    \       PKCS1-v1-5DigestAlgorithms    ALGORITHM-IDENTIFIER ::= {\n           {\
    \ OID id-md2        PARAMETERS NULL }|\n           { OID id-md5        PARAMETERS\
    \ NULL }|\n           { OID id-sha1       PARAMETERS NULL }|\n           { OID\
    \ id-sha224     PARAMETERS NULL }|\n           { OID id-sha256     PARAMETERS\
    \ NULL }|\n           { OID id-sha384     PARAMETERS NULL }|\n           { OID\
    \ id-sha512     PARAMETERS NULL }|\n           { OID id-sha512-224 PARAMETERS\
    \ NULL }|\n           { OID id-sha512-256 PARAMETERS NULL }\n       }\n"
- title: Appendix B.  Supporting Techniques
  contents:
  - "Appendix B.  Supporting Techniques\n   This section gives several examples of\
    \ underlying functions\n   supporting the encryption schemes in Section 7 and\
    \ the encoding\n   methods in Section 9.  A range of techniques is given here\
    \ to allow\n   compatibility with existing applications as well as migration to\
    \ new\n   techniques.  While these supporting techniques are appropriate for\n\
    \   applications to implement, none of them is required to be\n   implemented.\
    \  It is expected that profiles for PKCS #1 v2.2 will be\n   developed that specify\
    \ particular supporting techniques.\n   This section also gives object identifiers\
    \ for the supporting\n   techniques.\n"
- title: B.1.  Hash Functions
  contents:
  - "B.1.  Hash Functions\n   Hash functions are used in the operations contained\
    \ in Sections 7 and\n   9.  Hash functions are deterministic, meaning that the\
    \ output is\n   completely determined by the input.  Hash functions take octet\n\
    \   strings of variable length and generate fixed-length octet strings.\n   The\
    \ hash functions used in the operations contained in Sections 7 and\n   9 should\
    \ generally be collision-resistant.  This means that it is\n   infeasible to find\
    \ two distinct inputs to the hash function that\n   produce the same output. \
    \ A collision-resistant hash function also\n   has the desirable property of being\
    \ one-way; this means that given an\n   output, it is infeasible to find an input\
    \ whose hash is the specified\n   output.  In addition to the requirements, the\
    \ hash function should\n   yield a mask generation function (Appendix B.2) with\
    \ pseudorandom\n   output.\n   Nine hash functions are given as examples for the\
    \ encoding methods in\n   this document: MD2 [RFC1319] (which was retired by [RFC6149]),\
    \ MD5\n   [RFC1321], SHA-1, SHA-224, SHA-256, SHA-384, SHA-512, SHA-512/224,\n\
    \   and SHA-512/256 [SHS].  For the RSAES-OAEP encryption scheme and\n   EMSA-PSS\
    \ encoding method, only SHA-1, SHA-224, SHA-256, SHA-384, SHA-\n   512, SHA-512/224,\
    \ and SHA-512/256 are RECOMMENDED.  For the EMSA-\n   PKCS1-v1_5 encoding method,\
    \ SHA-224, SHA-256, SHA-384, SHA-512, SHA-\n   512/224, and SHA-512/256 are RECOMMENDED\
    \ for new applications.  MD2,\n   MD5, and SHA-1 are recommended only for compatibility\
    \ with existing\n   applications based on PKCS #1 v1.5.\n   The object identifiers\
    \ id-md2, id-md5, id-sha1, id-sha224, id-sha256,\n   id-sha384, id-sha512, id-sha512/224,\
    \ and id-sha512/256 identify the\n   respective hash functions:\n       id-md2\
    \      OBJECT IDENTIFIER ::= {\n           iso (1) member-body (2) us (840) rsadsi\
    \ (113549)\n           digestAlgorithm (2) 2\n       }\n       id-md5      OBJECT\
    \ IDENTIFIER ::= {\n           iso (1) member-body (2) us (840) rsadsi (113549)\n\
    \           digestAlgorithm (2) 5\n       }\n       id-sha1    OBJECT IDENTIFIER\
    \ ::= {\n           iso(1) identified-organization(3) oiw(14) secsig(3)\n    \
    \        algorithms(2) 26\n       }\n       id-sha224    OBJECT IDENTIFIER ::=\
    \ {\n           joint-iso-itu-t (2) country (16) us (840) organization (1)\n \
    \          gov (101) csor (3) nistalgorithm (4) hashalgs (2) 4\n       }\n   \
    \    id-sha256    OBJECT IDENTIFIER ::= {\n           joint-iso-itu-t (2) country\
    \ (16) us (840) organization (1)\n           gov (101) csor (3) nistalgorithm\
    \ (4) hashalgs (2) 1\n       }\n       id-sha384    OBJECT IDENTIFIER ::= {\n\
    \           joint-iso-itu-t (2) country (16) us (840) organization (1)\n     \
    \      gov (101) csor (3) nistalgorithm (4) hashalgs (2) 2\n       }\n       id-sha512\
    \    OBJECT IDENTIFIER ::= {\n           joint-iso-itu-t (2) country (16) us (840)\
    \ organization (1)\n           gov (101) csor (3) nistalgorithm (4) hashalgs (2)\
    \ 3\n       }\n       id-sha512-224    OBJECT IDENTIFIER ::= {\n           joint-iso-itu-t\
    \ (2) country (16) us (840) organization (1)\n           gov (101) csor (3) nistalgorithm\
    \ (4) hashalgs (2) 5\n       }\n       id-sha512-256    OBJECT IDENTIFIER ::=\
    \ {\n           joint-iso-itu-t (2) country (16) us (840) organization (1)\n \
    \          gov (101) csor (3) nistalgorithm (4) hashalgs (2) 6\n       }\n   The\
    \ parameters field associated with these OIDs in a value of type\n   AlgorithmIdentifier\
    \ SHALL have a value of type NULL.\n   The parameters field associated with id-md2\
    \ and id-md5 in a value of\n   type AlgorithmIdentifier shall have a value of\
    \ type NULL.\n   The parameters field associated with id-sha1, id-sha224, id-sha256,\n\
    \   id-sha384, id-sha512, id-sha512/224, and id-sha512/256 should\n   generally\
    \ be omitted, but if present, it shall have a value of type\n   NULL.\n   This\
    \ is to align with the definitions originally promulgated by NIST.\n   For the\
    \ SHA algorithms, implementations MUST accept\n   AlgorithmIdentifier values both\
    \ without parameters and with NULL\n   parameters.\n   Exception: When formatting\
    \ the DigestInfoValue in EMSA-PKCS1-v1_5\n   (see Section 9.2), the parameters\
    \ field associated with id-sha1,\n   id-sha224, id-sha256, id-sha384, id-sha512,\
    \ id-sha512/224, and\n   id-sha512/256 shall have a value of type NULL.  This\
    \ is to maintain\n   compatibility with existing implementations and with the\
    \ numeric\n   information values already published for EMSA-PKCS1-v1_5, which\
    \ are\n   also reflected in IEEE 1363a [IEEE1363A].\n   Note: Version 1.5 of PKCS\
    \ #1 also allowed for the use of MD4 in\n   signature schemes.  The cryptanalysis\
    \ of MD4 has progressed\n   significantly in the intervening years.  For example,\
    \ Dobbertin [MD4]\n   demonstrated how to find collisions for MD4 and that the\
    \ first two\n   rounds of MD4 are not one-way [MD4FIRST].  Because of these results\n\
    \   and others (e.g., [MD4LAST]), MD4 is NOT RECOMMENDED.\n   Further advances\
    \ have been made in the cryptanalysis of MD2 and MD5,\n   especially after the\
    \ findings of Stevens et al.  [PREFIX] on chosen-\n   prefix collisions on MD5.\
    \  MD2 and MD5 should be considered\n   cryptographically broken and removed from\
    \ existing applications.\n   This version of the standard supports MD2 and MD5\
    \ just for backwards-\n   compatibility reasons.\n   There have also been advances\
    \ in the cryptanalysis of SHA-1.\n   Particularly, the results of Wang et al.\
    \  [SHA1CRYPT] (which have\n   been independently verified by M.  Cochran in his\
    \ analysis [COCHRAN])\n   on using a differential path to find collisions in SHA-1,\
    \ which\n   conclude that the security strength of the SHA-1 hashing algorithm\
    \ is\n   significantly reduced.  However, this reduction is not significant\n\
    \   enough to warrant the removal of SHA-1 from existing applications,\n   but\
    \ its usage is only recommended for backwards-compatibility\n   reasons.\n   To\
    \ address these concerns, only SHA-224, SHA-256, SHA-384, SHA-512,\n   SHA-512/224,\
    \ and SHA-512/256 are RECOMMENDED for new applications.\n   As of today, the best\
    \ (known) collision attacks against these hash\n   functions are generic attacks\
    \ with complexity 2L/2, where L is the\n   bit length of the hash output.  For\
    \ the signature schemes in this\n   document, a collision attack is easily translated\
    \ into a signature\n   forgery.  Therefore, the value L / 2 should be at least\
    \ equal to the\n   desired security level in bits of the signature scheme (a security\n\
    \   level of B bits means that the best attack has complexity 2B).  The\n   same\
    \ rule of thumb can be applied to RSAES-OAEP; it is RECOMMENDED\n   that the bit\
    \ length of the seed (which is equal to the bit length of\n   the hash output)\
    \ be twice the desired security level in bits.\n"
- title: B.2.  Mask Generation Functions
  contents:
  - "B.2.  Mask Generation Functions\n   A mask generation function takes an octet\
    \ string of variable length\n   and a desired output length as input and outputs\
    \ an octet string of\n   the desired length.  There may be restrictions on the\
    \ length of the\n   input and output octet strings, but such bounds are generally\
    \ very\n   large.  Mask generation functions are deterministic; the octet string\n\
    \   output is completely determined by the input octet string.  The\n   output\
    \ of a mask generation function should be pseudorandom: Given\n   one part of\
    \ the output but not the input, it should be infeasible to\n   predict another\
    \ part of the output.  The provable security of\n   RSAES-OAEP and RSASSA-PSS\
    \ relies on the random nature of the output\n   of the mask generation function,\
    \ which in turn relies on the random\n   nature of the underlying hash.\n   One\
    \ mask generation function is given here: MGF1, which is based on a\n   hash function.\
    \  MGF1 coincides with the mask generation functions\n   defined in IEEE 1363\
    \ [IEEE1363] and ANSI X9.44 [ANSIX944].  Future\n   versions of this document\
    \ may define other mask generation functions.\n"
- title: B.2.1.  MGF1
  contents:
  - "B.2.1.  MGF1\n   MGF1 is a mask generation function based on a hash function.\n\
    \   MGF1 (mgfSeed, maskLen)\n   Options:\n      Hash     hash function (hLen denotes\
    \ the length in octets of\n               the hash function output)\n   Input:\n\
    \      mgfSeed  seed from which mask is generated, an octet string\n      maskLen\
    \  intended length in octets of the mask, at most 2^32 hLen\n   Output:\n    \
    \  mask     mask, an octet string of length maskLen\n   Error: \"mask too long\"\
    \n   Steps:\n   1.  If maskLen > 2^32 hLen, output \"mask too long\" and stop.\n\
    \   2.  Let T be the empty octet string.\n   3.  For counter from 0 to \\ceil\
    \ (maskLen / hLen) - 1, do the\n       following:\n       A.  Convert counter\
    \ to an octet string C of length 4 octets (see\n           Section 4.1):\n   \
    \           C = I2OSP (counter, 4) .\n       B.  Concatenate the hash of the seed\
    \ mgfSeed and C to the octet\n           string T:\n              T = T || Hash(mgfSeed\
    \ || C) .\n   4.  Output the leading maskLen octets of T as the octet string mask.\n\
    \   The object identifier id-mgf1 identifies the MGF1 mask generation\n   function:\n\
    \      id-mgf1    OBJECT IDENTIFIER ::= { pkcs-1 8 }\n   The parameters field\
    \ associated with this OID in a value of type\n   AlgorithmIdentifier shall have\
    \ a value of type hashAlgorithm,\n   identifying the hash function on which MGF1\
    \ is based.\n"
- title: Appendix C.  ASN.1 Module
  contents:
  - "Appendix C.  ASN.1 Module\n   -- PKCS #1 v2.2 ASN.1 Module\n   -- Revised October\
    \ 27, 2012\n   -- This module has been checked for conformance with the\n   --\
    \ ASN.1 standard by the OSS ASN.1 Tools\n   PKCS-1 {\n       iso(1) member-body(2)\
    \ us(840) rsadsi(113549) pkcs(1) pkcs-1(1)\n       modules(0) pkcs-1(1)\n   }\n\
    \   DEFINITIONS EXPLICIT TAGS ::=\n   BEGIN\n   -- EXPORTS ALL\n   -- All types\
    \ and values defined in this module are exported for use\n   -- in other ASN.1\
    \ modules.\n   IMPORTS\n   id-sha224, id-sha256, id-sha384, id-sha512, id-sha512-224,\n\
    \   id-sha512-256\n       FROM NIST-SHA2 {\n           joint-iso-itu-t(2) country(16)\
    \ us(840) organization(1)\n           gov(101) csor(3) nistalgorithm(4) hashAlgs(2)\n\
    \       };\n   -- ============================\n   --   Basic object identifiers\n\
    \   -- ============================\n   -- The DER encoding of this in hexadecimal\
    \ is:\n   -- (0x)06 08\n   --        2A 86 48 86 F7 0D 01 01\n   --\n   pkcs-1\
    \    OBJECT IDENTIFIER ::= {\n       iso(1) member-body(2) us(840) rsadsi(113549)\
    \ pkcs(1) 1\n   }\n   --\n   -- When rsaEncryption is used in an AlgorithmIdentifier,\n\
    \   -- the parameters MUST be present and MUST be NULL.\n   --\n   rsaEncryption\
    \    OBJECT IDENTIFIER ::= { pkcs-1 1 }\n   --\n   -- When id-RSAES-OAEP is used\
    \ in an AlgorithmIdentifier, the\n   -- parameters MUST be present and MUST be\
    \ RSAES-OAEP-params.\n   --\n   id-RSAES-OAEP    OBJECT IDENTIFIER ::= { pkcs-1\
    \ 7 }\n   --\n   -- When id-pSpecified is used in an AlgorithmIdentifier, the\n\
    \   -- parameters MUST be an OCTET STRING.\n   --\n   id-pSpecified    OBJECT\
    \ IDENTIFIER ::= { pkcs-1 9 }\n   --\n   -- When id-RSASSA-PSS is used in an AlgorithmIdentifier,\
    \ the\n   -- parameters MUST be present and MUST be RSASSA-PSS-params.\n   --\n\
    \   id-RSASSA-PSS    OBJECT IDENTIFIER ::= { pkcs-1 10 }\n   --\n   -- When the\
    \ following OIDs are used in an AlgorithmIdentifier,\n   -- the parameters MUST\
    \ be present and MUST be NULL.\n   --\n   md2WithRSAEncryption         OBJECT\
    \ IDENTIFIER ::= { pkcs-1 2 }\n   md5WithRSAEncryption         OBJECT IDENTIFIER\
    \ ::= { pkcs-1 4 }\n   sha1WithRSAEncryption        OBJECT IDENTIFIER ::= { pkcs-1\
    \ 5 }\n   sha224WithRSAEncryption      OBJECT IDENTIFIER ::= { pkcs-1 14 }\n \
    \  sha256WithRSAEncryption      OBJECT IDENTIFIER ::= { pkcs-1 11 }\n   sha384WithRSAEncryption\
    \      OBJECT IDENTIFIER ::= { pkcs-1 12 }\n   sha512WithRSAEncryption      OBJECT\
    \ IDENTIFIER ::= { pkcs-1 13 }\n   sha512-224WithRSAEncryption  OBJECT IDENTIFIER\
    \ ::= { pkcs-1 15 }\n   sha512-256WithRSAEncryption  OBJECT IDENTIFIER ::= { pkcs-1\
    \ 16 }\n   --\n   -- This OID really belongs in a module with the secsig OIDs.\n\
    \   --\n   id-sha1    OBJECT IDENTIFIER ::= {\n       iso(1) identified-organization(3)\
    \ oiw(14) secsig(3) algorithms(2)\n       26\n   }\n   --\n   -- OIDs for MD2\
    \ and MD5, allowed only in EMSA-PKCS1-v1_5.\n   --\n   id-md2 OBJECT IDENTIFIER\
    \ ::= {\n       iso(1) member-body(2) us(840) rsadsi(113549) digestAlgorithm(2)\
    \ 2\n   }\n   id-md5 OBJECT IDENTIFIER ::= {\n       iso(1) member-body(2) us(840)\
    \ rsadsi(113549) digestAlgorithm(2) 5\n   }\n   --\n   -- When id-mgf1 is used\
    \ in an AlgorithmIdentifier, the parameters\n   -- MUST be present and MUST be\
    \ a HashAlgorithm, for example, sha1.\n   --\n   id-mgf1    OBJECT IDENTIFIER\
    \ ::= { pkcs-1 8 }\n   -- ================\n   --   Useful types\n   -- ================\n\
    \   ALGORITHM-IDENTIFIER ::= CLASS {\n       &id    OBJECT IDENTIFIER  UNIQUE,\n\
    \       &Type  OPTIONAL\n   }\n       WITH SYNTAX { OID &id [PARAMETERS &Type]\
    \ }\n   -- Note: the parameter InfoObjectSet in the following definitions\n  \
    \ -- allows a distinct information object set to be specified for sets\n   --\
    \ of algorithms such as:\n   -- DigestAlgorithms    ALGORITHM-IDENTIFIER ::= {\n\
    \   --     { OID id-md2  PARAMETERS NULL }|\n   --     { OID id-md5  PARAMETERS\
    \ NULL }|\n   --     { OID id-sha1 PARAMETERS NULL }\n   -- }\n   --\n   AlgorithmIdentifier\
    \ { ALGORITHM-IDENTIFIER:InfoObjectSet } ::=\n       SEQUENCE {\n         algorithm\n\
    \             ALGORITHM-IDENTIFIER.&id({InfoObjectSet}),\n         parameters\n\
    \             ALGORITHM-IDENTIFIER.&Type({InfoObjectSet}{@.algorithm})\n     \
    \          OPTIONAL\n   }\n   -- ==============\n   --   Algorithms\n   -- ==============\n\
    \   --\n   -- Allowed EME-OAEP and EMSA-PSS digest algorithms.\n   --\n   OAEP-PSSDigestAlgorithms\
    \    ALGORITHM-IDENTIFIER ::= {\n       { OID id-sha1       PARAMETERS NULL }|\n\
    \       { OID id-sha224     PARAMETERS NULL }|\n       { OID id-sha256     PARAMETERS\
    \ NULL }|\n       { OID id-sha384     PARAMETERS NULL }|\n       { OID id-sha512\
    \     PARAMETERS NULL }|\n       { OID id-sha512-224 PARAMETERS NULL }|\n    \
    \   { OID id-sha512-256 PARAMETERS NULL },\n       ...  -- Allows for future expansion\
    \ --\n   }\n   --\n   -- Allowed EMSA-PKCS1-v1_5 digest algorithms.\n   --\n \
    \  PKCS1-v1-5DigestAlgorithms    ALGORITHM-IDENTIFIER ::= {\n       { OID id-md2\
    \        PARAMETERS NULL }|\n       { OID id-md5        PARAMETERS NULL }|\n \
    \      { OID id-sha1       PARAMETERS NULL }|\n       { OID id-sha224     PARAMETERS\
    \ NULL }|\n       { OID id-sha256     PARAMETERS NULL }|\n       { OID id-sha384\
    \     PARAMETERS NULL }|\n       { OID id-sha512     PARAMETERS NULL }|\n    \
    \   { OID id-sha512-224 PARAMETERS NULL }|\n       { OID id-sha512-256 PARAMETERS\
    \ NULL }\n   }\n   -- When id-md2 and id-md5 are used in an AlgorithmIdentifier,\
    \ the\n   -- parameters field shall have a value of type NULL.\n   -- When id-sha1,\
    \ id-sha224, id-sha256, id-sha384, id-sha512,\n   -- id-sha512-224, and id-sha512-256\
    \ are used in an\n   -- AlgorithmIdentifier, the parameters (which are optional)\
    \ SHOULD be\n   -- omitted, but if present, they SHALL have a value of type NULL.\n\
    \   -- However, implementations MUST accept AlgorithmIdentifier values\n   --\
    \ both without parameters and with NULL parameters.\n   -- Exception: When formatting\
    \ the DigestInfoValue in EMSA-PKCS1-v1_5\n   -- (see Section 9.2), the parameters\
    \ field associated with id-sha1,\n   -- id-sha224, id-sha256, id-sha384, id-sha512,\
    \ id-sha512-224, and\n   -- id-sha512-256 SHALL have a value of type NULL.  This\
    \ is to\n   -- maintain compatibility with existing implementations and with the\n\
    \   -- numeric information values already published for EMSA-PKCS1-v1_5,\n   --\
    \ which are also reflected in IEEE 1363a.\n   sha1    HashAlgorithm ::= {\n  \
    \     algorithm   id-sha1,\n       parameters  SHA1Parameters : NULL\n   }\n \
    \  HashAlgorithm ::= AlgorithmIdentifier { {OAEP-PSSDigestAlgorithms} }\n   SHA1Parameters\
    \ ::= NULL\n   --\n   -- Allowed mask generation function algorithms.\n   -- If\
    \ the identifier is id-mgf1, the parameters are a HashAlgorithm.\n   --\n   PKCS1MGFAlgorithms\
    \    ALGORITHM-IDENTIFIER ::= {\n       { OID id-mgf1 PARAMETERS HashAlgorithm\
    \ },\n       ...  -- Allows for future expansion --\n   }\n   --\n   -- Default\
    \ AlgorithmIdentifier for id-RSAES-OAEP.maskGenAlgorithm and\n   -- id-RSASSA-PSS.maskGenAlgorithm.\n\
    \   --\n   mgf1SHA1    MaskGenAlgorithm ::= {\n       algorithm   id-mgf1,\n \
    \      parameters  HashAlgorithm : sha1\n   }\n   MaskGenAlgorithm ::= AlgorithmIdentifier\
    \ { {PKCS1MGFAlgorithms} }\n   --\n   -- Allowed algorithms for pSourceAlgorithm.\n\
    \   --\n   PKCS1PSourceAlgorithms    ALGORITHM-IDENTIFIER ::= {\n       { OID\
    \ id-pSpecified PARAMETERS EncodingParameters },\n       ...  -- Allows for future\
    \ expansion --\n   }\n   EncodingParameters ::= OCTET STRING(SIZE(0..MAX))\n \
    \  --\n   -- This identifier means that the label L is an empty string, so the\n\
    \   -- digest of the empty string appears in the RSA block before\n   -- masking.\n\
    \   --\n   pSpecifiedEmpty    PSourceAlgorithm ::= {\n       algorithm   id-pSpecified,\n\
    \       parameters  EncodingParameters : emptyString\n   }\n   PSourceAlgorithm\
    \ ::= AlgorithmIdentifier { {PKCS1PSourceAlgorithms} }\n   emptyString    EncodingParameters\
    \ ::= ''H\n   --\n   -- Type identifier definitions for the PKCS #1 OIDs.\n  \
    \ --\n   PKCS1Algorithms    ALGORITHM-IDENTIFIER ::= {\n       { OID rsaEncryption\
    \                PARAMETERS NULL } |\n       { OID md2WithRSAEncryption      \
    \   PARAMETERS NULL } |\n       { OID md5WithRSAEncryption         PARAMETERS\
    \ NULL } |\n       { OID sha1WithRSAEncryption        PARAMETERS NULL } |\n  \
    \     { OID sha224WithRSAEncryption      PARAMETERS NULL } |\n       { OID sha256WithRSAEncryption\
    \      PARAMETERS NULL } |\n       { OID sha384WithRSAEncryption      PARAMETERS\
    \ NULL } |\n       { OID sha512WithRSAEncryption      PARAMETERS NULL } |\n  \
    \     { OID sha512-224WithRSAEncryption  PARAMETERS NULL } |\n       { OID sha512-256WithRSAEncryption\
    \  PARAMETERS NULL } |\n       { OID id-RSAES-OAEP   PARAMETERS RSAES-OAEP-params\
    \ } |\n       PKCS1PSourceAlgorithms                               |\n       {\
    \ OID id-RSASSA-PSS   PARAMETERS RSASSA-PSS-params },\n       ...  -- Allows for\
    \ future expansion --\n   }\n   -- ===================\n   --   Main structures\n\
    \   -- ===================\n   RSAPublicKey ::= SEQUENCE {\n       modulus   \
    \        INTEGER,  -- n\n       publicExponent    INTEGER   -- e\n   }\n   --\n\
    \   -- Representation of RSA private key with information for the CRT\n   -- algorithm.\n\
    \   --\n   RSAPrivateKey ::= SEQUENCE {\n       version           Version,\n \
    \      modulus           INTEGER,  -- n\n       publicExponent    INTEGER,  --\
    \ e\n       privateExponent   INTEGER,  -- d\n       prime1            INTEGER,\
    \  -- p\n       prime2            INTEGER,  -- q\n       exponent1         INTEGER,\
    \  -- d mod (p-1)\n       exponent2         INTEGER,  -- d mod (q-1)\n       coefficient\
    \       INTEGER,  -- (inverse of q) mod p\n       otherPrimeInfos   OtherPrimeInfos\
    \ OPTIONAL\n   }\n   Version ::= INTEGER { two-prime(0), multi(1) }\n       (CONSTRAINED\
    \ BY\n         {-- version MUST\n    be multi if otherPrimeInfos present --})\n\
    \   OtherPrimeInfos ::= SEQUENCE SIZE(1..MAX) OF OtherPrimeInfo\n   OtherPrimeInfo\
    \ ::= SEQUENCE {\n       prime             INTEGER,  -- ri\n       exponent  \
    \        INTEGER,  -- di\n       coefficient       INTEGER   -- ti\n   }\n   --\n\
    \   -- AlgorithmIdentifier.parameters for id-RSAES-OAEP.\n   -- Note that the\
    \ tags in this Sequence are explicit.\n   --\n   RSAES-OAEP-params ::= SEQUENCE\
    \ {\n       hashAlgorithm      [0] HashAlgorithm     DEFAULT sha1,\n       maskGenAlgorithm\
    \   [1] MaskGenAlgorithm  DEFAULT mgf1SHA1,\n       pSourceAlgorithm   [2] PSourceAlgorithm\
    \  DEFAULT pSpecifiedEmpty\n   }\n   --\n   -- Identifier for default RSAES-OAEP\
    \ algorithm identifier.\n   -- The DER encoding of this is in hexadecimal:\n \
    \  -- (0x)30 0D\n   --        06 09\n   --           2A 86 48 86 F7 0D 01 01 07\n\
    \   --        30 00\n   -- Notice that the DER encoding of default values is \"\
    empty\".\n   --\n   rSAES-OAEP-Default-Identifier    RSAES-AlgorithmIdentifier\
    \ ::= {\n       algorithm   id-RSAES-OAEP,\n       parameters  RSAES-OAEP-params\
    \ : {\n           hashAlgorithm       sha1,\n           maskGenAlgorithm    mgf1SHA1,\n\
    \           pSourceAlgorithm    pSpecifiedEmpty\n       }\n   }\n   RSAES-AlgorithmIdentifier\
    \ ::= AlgorithmIdentifier {\n       {PKCS1Algorithms}\n   }\n   --\n   -- AlgorithmIdentifier.parameters\
    \ for id-RSASSA-PSS.\n   -- Note that the tags in this Sequence are explicit.\n\
    \   --\n   RSASSA-PSS-params ::= SEQUENCE {\n       hashAlgorithm      [0] HashAlgorithm\
    \      DEFAULT sha1,\n       maskGenAlgorithm   [1] MaskGenAlgorithm   DEFAULT\
    \ mgf1SHA1,\n       saltLength         [2] INTEGER            DEFAULT 20,\n  \
    \     trailerField       [3] TrailerField       DEFAULT trailerFieldBC\n   }\n\
    \   TrailerField ::= INTEGER { trailerFieldBC(1) }\n   --\n   -- Identifier for\
    \ default RSASSA-PSS algorithm identifier\n   -- The DER encoding of this is in\
    \ hexadecimal:\n   -- (0x)30 0D\n   --        06 09\n   --           2A 86 48\
    \ 86 F7 0D 01 01 0A\n   --        30 00\n   -- Notice that the DER encoding of\
    \ default values is \"empty\".\n   --\n   rSASSA-PSS-Default-Identifier    RSASSA-AlgorithmIdentifier\
    \ ::= {\n       algorithm   id-RSASSA-PSS,\n       parameters  RSASSA-PSS-params\
    \ : {\n           hashAlgorithm       sha1,\n           maskGenAlgorithm    mgf1SHA1,\n\
    \           saltLength          20,\n           trailerField        trailerFieldBC\n\
    \       }\n   }\n   RSASSA-AlgorithmIdentifier ::= AlgorithmIdentifier {\n   \
    \    {PKCS1Algorithms}\n   }\n   --\n   -- Syntax for the EMSA-PKCS1-v1_5 hash\
    \ identifier.\n   --\n   DigestInfo ::= SEQUENCE {\n       digestAlgorithm DigestAlgorithm,\n\
    \       digest OCTET STRING\n   }\n   DigestAlgorithm ::= AlgorithmIdentifier\
    \ {\n       {PKCS1-v1-5DigestAlgorithms}\n   }\n   END\n"
- title: 'Appendix D.  Revision History of PKCS #1'
  contents:
  - "Appendix D.  Revision History of PKCS #1\n   Versions 1.0 - 1.5:\n      Versions\
    \ 1.0 - 1.3 were distributed to participants in RSA Data\n      Security, Inc.'s\
    \ Public-Key Cryptography Standards meetings in\n      February and March 1991.\n\
    \      Version 1.4 was part of the June 3, 1991 initial public release of\n  \
    \    PKCS.  Version 1.4 was published as NIST/OSI Implementors'\n      Workshop\
    \ document SEC-SIG-91-18.\n      Version 1.5 incorporated several editorial changes,\
    \ including\n      updates to the references and the addition of a revision history.\n\
    \      The following substantive changes were made:\n      *  Section 10: \"MD4\
    \ with RSA\" signature and verification processes\n         were added.\n    \
    \  *  Section 11: md4WithRSAEncryption object identifier was added.\n      Version\
    \ 1.5 was republished as [RFC2313] (which was later\n      obsoleted by [RFC2437]).\n\
    \   Version 2.0:\n      Version 2.0 incorporated major editorial changes in terms\
    \ of the\n      document structure and introduced the RSAES-OAEP encryption\n\
    \      scheme.  This version continued to support the encryption and\n      signature\
    \ processes in version 1.5, although the hash algorithm\n      MD4 was no longer\
    \ allowed due to cryptanalytic advances in the\n      intervening years.  Version\
    \ 2.0 was republished as [RFC2437]\n      (which was later obsoleted by [RFC3447]).\n\
    \   Version 2.1:\n      Version 2.1 introduced multi-prime RSA and the RSASSA-PSS\n\
    \      signature scheme with appendix along with several editorial\n      improvements.\
    \  This version continued to support the schemes in\n      version 2.0.  Version\
    \ 2.1 was republished as [RFC3447].\n   Version 2.2:\n      Version 2.2 updates\
    \ the list of allowed hashing algorithms to\n      align them with FIPS 180-4\
    \ [SHS], therefore adding SHA-224,\n      SHA-512/224, and SHA-512/256.  The following\
    \ substantive changes\n      were made:\n      *  Object identifiers for sha224WithRSAEncryption,\n\
    \         sha512-224WithRSAEncryption, and sha512-256WithRSAEncryption\n     \
    \    were added.\n      *  This version continues to support the schemes in version\
    \ 2.1.\n"
- title: Appendix E.  About PKCS
  contents:
  - "Appendix E.  About PKCS\n   The Public-Key Cryptography Standards are specifications\
    \ produced by\n   RSA Laboratories in cooperation with secure systems developers\n\
    \   worldwide for the purpose of accelerating the deployment of public-\n   key\
    \ cryptography.  First published in 1991 as a result of meetings\n   with a small\
    \ group of early adopters of public-key technology, the\n   PKCS documents have\
    \ become widely referenced and implemented.\n   Contributions from the PKCS series\
    \ have become part of many formal\n   and de facto standards, including ANSI X9\
    \ and IEEE P1363 documents,\n   PKIX, Secure Electronic Transaction (SET), S/MIME,\
    \ SSL/TLS, and\n   Wireless Application Protocol (WAP) / WAP Transport Layer Security\n\
    \   (WTLS).\n   Further development of most PKCS documents occurs through the\
    \ IETF.\n   Suggestions for improvement are welcome.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   This document is based on a contribution of RSA Laboratories,\
    \ the\n   research center of RSA Security Inc.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Kathleen M. Moriarty (editor)\n   EMC Corporation\n  \
    \ 176 South Street\n   Hopkinton, MA  01748\n   United States of America\n   Email:\
    \ kathleen.moriarty@emc.com\n   Burt Kaliski\n   Verisign\n   12061 Bluemont Way\n\
    \   Reston, VA  20190\n   United States of America\n   Email: bkaliski@verisign.com\n\
    \   URI:   http://verisignlabs.com\n   Jakob Jonsson\n   Subset AB\n   Munkbrogtan\
    \ 4\n   Stockholm  SE-11127\n   Sweden\n   Phone: +46 8 428 687 43\n   Email:\
    \ jakob.jonsson@subset.se\n   Andreas Rusch\n   RSA\n   345 Queen Street\n   Brisbane,\
    \ QLD  4000\n   Australia\n   Email: andreas.rusch@rsa.com\n"
