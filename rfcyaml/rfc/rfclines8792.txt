Abstract This document defines two strategies for handling long lines in width bounded text content.
The second strategy, called the "double backslash" strategy, extends the first strategy by adding a second backslash character to identify where the continuation begins and is thereby able to handle cases not supported by the first strategy.
Both strategies use a self describing header enabling automated reconstitution of the original content.
Introduction [RFC7994] sets out the requirements for plain text RFCs and states that each line of an RFC (and hence of an Internet Draft) must be limited to 72 characters followed by the character sequence that denotes an end of line (EOL).
Internet Drafts and RFCs often include example text or code fragments.
Many times, the example text or code exceeds the 72 character line length limit.
The 'xml2rfc' utility [xml2rfc], at the time of this document's publication, does not attempt to wrap the content of such inclusions, simply issuing a warning whenever lines exceed 69 characters.
Historically, there has been no convention recommended by the RFC Editor in place for how to handle long lines in such inclusions, other than advising authors to clearly indicate what manipulation has occurred.
This document defines two strategies for handling long lines in width bounded text content.
The second strategy, called the "double backslash" strategy, extends the first strategy by adding a second backslash character to identify where the continuation begins and is thereby able to handle cases not supported by the first strategy.
Both strategies use a self describing header enabling automated reconstitution of the original content.
The strategies defined in this document work on any text content but are primarily intended for a structured sequence of lines, such as would be referenced by the <sourcecode> element defined in Section 2.48 of [RFC7991], rather than for two dimensional imagery, such as would be referenced by the <artwork> element defined in Section 2.5 of [RFC7991].
Note that text files are represented as lines having their first character in column 1, and a line length of N where the last character is in the Nth column and is immediately followed by an end  of line character sequence.
The formats and algorithms defined in this document may be used in any context, whether for IETF documents or in other situations where structured folding is desired.
Within the IETF, this work primarily targets the xml2rfc v3 <sourcecode> element (Section 2.48 of [RFC7991]) and the xml2rfc v2 <artwork> element (Section 2.5 of [RFC7749]), which, for lack of a better option, is used in xml2rfc v2 for both source code and artwork.
This work may also be used for the xml2rfc v3 <artwork> element (Section 2.5 of [RFC7991]), but as described in Section 5.1, it is generally not recommended.
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in BCP 14
when, and only when, they appear in all capitals, as shown here.
Automated Folding of Long Lines in Text Content
Automated folding of long lines is needed in order to support documents that are dynamically compiled to include content with potentially unconstrained line lengths.
For instance, the build process may wish to include content from other local files or content that is dynamically generated by some external process.
Both of these cases are discussed next.
Many documents need to include the content from local files (e.g., XML, JSON, ABNF, ASN.1).
Prior to including a file's content, the build process SHOULD first validate these source files using format  specific validators.
In order for such tooling to be able to process the files, the files must be in their original/natural state, which may entail them having some long lines.
Thus, these source files need to be folded before inclusion into the XML document, in order to satisfy 'xml2rfc' line length limits.
Similarly, documents sometimes contain dynamically generated output, typically from an external process operating on the same source files discussed in the previous paragraph.
For instance, such processes may translate the input format to another format, or they may render a report on, or a view of, the input file.
In some cases, the dynamically generated output may contain lines exceeding the 'xml2rfc' line length limits.
In both cases, folding is required and SHOULD be automated to reduce effort and errors resulting from manual processing.
Automated Reconstitution of the Original Text Content Automated reconstitution of the exact original text content is needed to support validation of text based content extracted from documents.
For instance, YANG modules [RFC7950] are already extracted from Internet Drafts and validated as part of the submission process.
Additionally, the desire to validate instance examples (i.e., XML/ JSON documents) contained within Internet Drafts has been discussed [yang doctors thread].
Not Recommended for Graphical Artwork
While the solution presented in this document works on any kind of text based content, it is most useful on content that represents source code (XML, JSON, etc.)
or, more generally, on content that has not been laid out in two dimensions (e.g., diagrams).
Fundamentally, the issue is whether the text content remains readable once folded.
Text content that is unpredictable is especially susceptible to looking bad when folded; falling into this category are most Unified Modeling Language (UML) diagrams, YANG tree diagrams, and ASCII art in general.
It is NOT RECOMMENDED to use the solution presented in this document on graphical artwork.
Doesn't Work as Well as Format Specific Options
The solution presented in this document works generically for all text based content, as it only views content as plain text.
However, various formats sometimes have built in mechanisms that are better suited to prevent long lines.
For instance, both the 'pyang' and 'yanglint' utilities [pyang]
[yanglint] have the command line option "tree line length", which can be used to indicate a desired maximum line length when generating YANG tree diagrams [RFC8340].
It is RECOMMENDED that authors do as much as possible within the selected format to avoid long lines.
This document defines two nearly identical strategies for folding text based content.
The first strategy produces output that is more readable.
However, (1) it is significantly more likely to encounter unfoldable input (e.g., a long line containing only space characters), and (2) for long lines that can be folded, automation implementations may encounter scenarios that, without special care, will produce errors.
The second strategy produces output that is less readable, but it is unlikely to encounter unfoldable input, there are no long lines that cannot be folded, and no special care is required when folding a long line.
It is RECOMMENDED that implementations first attempt to fold content using the single backslash strategy and, only in the unlikely event that it cannot fold the input or the folding logic is unable to cope with a contingency occurring on the desired folding column, then fall back to the double backslash strategy.
Folded Structure Text content that has been folded as specified by this strategy MUST adhere to the following structure.
The header is two lines long.
The first line is the following 36 character string; this string MAY be surrounded by any number of printable characters.
This first line cannot itself be folded.
line wrapping per RFC 8792
The second line is an empty line, containing only the end of line character sequence.
This line provides visual separation for readability.
The character encoding is the same as the encoding described in Section 2 of [RFC7994], except that, per [RFC7991], tab characters are prohibited.
occurring as the last character in a line are considered "folded".
Exceptionally long lines MAY be folded multiple times.
This section describes a process for folding and unfolding long lines when they are encountered in text content.
The steps are complete, but implementations MAY achieve the same result in other ways.
When a larger document contains multiple instances of text content that may need to be folded or unfolded, another process must insert/extract the individual text content instances to/from the larger document prior to utilizing the algorithms described in this section.
For example, the 'xiax' utility [xiax] does this.
Folding Determine the desired maximum line length from input to the line  wrapping process, such as from a command line parameter.
If no value is explicitly specified, the value "69" SHOULD be used.
Ensure that the desired maximum line length is not less than the minimum header, which is 36 characters.
If the desired maximum line length is less than this minimum, exit (this text based content cannot be folded).
Scan the text content for horizontal tab characters.
If any horizontal tab characters appear, either resolve them to space characters or exit, forcing the input provider to convert them to space characters themselves first.
Scan the text content to ensure that at least one line exceeds the desired maximum.
If no line exceeds the desired maximum, exit (this text content does not need to be folded).
If such a line is found, and its width is less than the desired maximum, then it SHOULD be flagged for "forced" folding (folding even though unnecessary).
If the folding implementation doesn't support forced foldings, it MUST exit.
If this text content needs to, and can, be folded, insert the header described in Section 7.1.1, ensuring that any additional printable characters surrounding the header do not result in a line exceeding the desired maximum.
For each line in the text content, from top to bottom, if the line exceeds the desired maximum or requires a forced folding, then fold the line by performing the following steps: 1.  Determine where the fold will occur.
If no such location can be found, then exit (this text content cannot be folded).
Continue in this manner until reaching the end of the text content.
Note that this algorithm naturally addresses the case where the remainder of a folded line is still longer than the desired maximum and, hence, needs to be folded again, ad infinitum.
The process described in this section is illustrated by the "fold it 1()" function in Appendix A. 7.2.2.
Unfolding Scan the beginning of the text content for the header described in Section 7.1.1.
If the header is not present, exit (this text content does not need to be unfolded).
Remove the two line header from the text content.
Then continue to scan each line in the text content starting with the current line (in case it was multiply folded).
Continue in this manner until reaching the end of the text content.
The process described in this section is illustrated by the "unfold it 1()" function in Appendix A. 8.
Folded Structure Text content that has been folded as specified by this strategy MUST adhere to the following structure.
The header is two lines long.
The first line is the following 37 character string; this string MAY be surrounded by any number of printable characters.
This first line cannot itself be folded.
The second line is an empty line, containing only the end of line character sequence.
This line provides visual separation for readability.
The character encoding is the same as the encoding described in Section 2 of [RFC7994], except that, per [RFC7991], tab characters are prohibited.
Exceptionally long lines MAY be folded multiple times.
This section describes a process for folding and unfolding long lines when they are encountered in text content.
The steps are complete, but implementations MAY achieve the same result in other ways.
When a larger document contains multiple instances of text content that may need to be folded or unfolded, another process must insert/extract the individual text content instances to/from the larger document prior to utilizing the algorithms described in this section.
For example, the 'xiax' utility [xiax] does this.
Folding Determine the desired maximum line length from input to the line  wrapping process, such as from a command line parameter.
If no value is explicitly specified, the value "69" SHOULD be used.
Ensure that the desired maximum line length is not less than the minimum header, which is 37 characters.
If the desired maximum line length is less than this minimum, exit (this text based content cannot be folded).
Scan the text content for horizontal tab characters.
If any horizontal tab characters appear, either resolve them to space characters or exit, forcing the input provider to convert them to space characters themselves first.
Scan the text content to see if any line exceeds the desired maximum.
If no line exceeds the desired maximum, exit (this text content does not need to be folded).
If such a line is found and its width is less than the desired maximum, then it SHOULD be flagged for forced folding (folding even though unnecessary).
If the folding implementation doesn't support forced foldings, it MUST exit.
If this text content needs to, and can, be folded, insert the header described in Section 8.1.1, ensuring that any additional printable characters surrounding the header do not result in a line exceeding the desired maximum.
For each line in the text content, from top to bottom, if the line exceeds the desired maximum or requires a forced folding, then fold the line by performing the following steps: 1.  Determine where the fold will occur.
This location MUST be before or at the desired maximum column.
Continue in this manner until reaching the end of the text content.
Note that this algorithm naturally addresses the case where the remainder of a folded line is still longer than the desired maximum and, hence, needs to be folded again, ad infinitum.
The process described in this section is illustrated by the "fold it 2()" function in Appendix A. 8.2.2.
Unfolding Scan the beginning of the text content for the header described in Section 8.1.1.
If the header is not present, exit (this text content does not need to be unfolded).
Remove the two line header from the text content.
Then, continue to scan each line in the text content starting with the current line (in case it was multiply folded).
Continue in this manner until reaching the end of the text content.
The process described in this section is illustrated by the "unfold it 2()" function in Appendix A. 9.
The following self documenting examples illustrate folded text based content.
The source text content cannot be presented here, as it would again be folded.
Alas, only the results can be provided.
This example illustrates boundary conditions.
The input contains seven lines, each line one character longer than the previous line.
Numbers are used for counting purposes.
The default desired maximum column value "69" is used.
line wrapping per RFC 8792   123456789012345678901234567890123456789012345678901234567890123456 1234567890123456789012345678901234567890123456789012345678901234567 12345678901234567890123456789012345678901234567890123456789012345678 123456789012345678901234567890123456789012345678901234567890123456789
Example Showing Multiple Wraps of a Single Line
This example illustrates what happens when a very long line needs to be folded multiple times.
The input contains one line containing 280 characters.
Numbers are used for counting purposes.
The default desired maximum column value "69" is used.
line wrapping per RFC 8792   12345678901234567890123456789012345678901234567890123456789012345678\
Folding This example illustrates how readability can be improved via "smart" folding, whereby folding occurs at format specific locations and format specific indentations are used.
The text content was manually folded, since the script in Appendix A does not implement smart folding.
Note that the headers are surrounded by different printable characters than those shown in the script generated examples.
line wrapping per RFC 8792]
> <revision>2018 02 20</revision> <namespace
> <revision>2018 02 20</revision> <namespace
Folding This example illustrates how invalid sequences in lines that do not have to be folded can be handled via forced folding, whereby the folding occurs even though unnecessary.
The following line exceeds a 68 char max and, thus, demands folding: 123456789012345678901234567890123456789012345678901234567890123456789 This line ends with a backslash \
This line ends with a backslash
This line begins with a backslash
The samples below were manually folded, since the script in the appendix does not implement forced folding.
line wrapping per RFC 8792
The following line exceeds a 68 char max and, thus, demands folding: 1234567890123456789012345678901234567890123456789012345678901234567\ 89
This line ends with a backslash \\ This line ends with a backslash \\
This line begins with a backslash
The following line exceeds a 68 char max and, thus, demands folding: 1234567890123456789012345678901234567890123456789012345678901234567\ \89
This line ends with a backslash \
This line ends with a backslash \\
This line begins with a backslash
The following is an indented 3x3 block of backslashes:
This document has no security considerations.
This document has no IANA actions.
Appendix A.  Bash Shell Script: rfcfold This non normative appendix includes a Bash shell script [bash] that can both fold and unfold text content using both the single and double backslash strategies described in Sections 7 and 8, respectively.
This shell script, called 'rfcfold', is maintained at <https://github.com/ietf tools/rfcfold>.
This script is intended to be applied to a single text content instance.
If it is desired to fold or unfold text content instances within a larger document (e.g., an Internet Draft or RFC), then another tool must be used to extract the content from the larger document before utilizing this script.
When a tab character is detected in the input file, this script exits with the following error message: Error: infile contains a tab character, which is not allowed.
This script tests for the availability of GNU awk (gawk), in order to test for ASCII based control characters and non ASCII characters in the input file (see below).
Note that testing revealed flaws in the default version of 'awk' on some platforms.
As this script uses 'gawk' only to issue warning messages, if 'gawk' is not found, this script issues the following debug message:
Debug: no GNU awk; skipping checks for special characters.
When 'gawk' is available (see above) and ASCII based control characters are detected in the input file, this script issues the following warning message:
Warning: infile contains ASCII control characters (unsupported).
When 'gawk' is available (see above) and non ASCII characters are detected in the input file, this script issues the following warning message:
Warning: infile contains non ASCII characters (unsupported).
This script does not implement the whitespace avoidance logic described in Section 7.2.1.
In such a case, the script will exit with the following error message:
Error: infile has a space character occurring on the folding column.
While this script can unfold input that contains forced foldings, it is unable to fold files that would require forced foldings.
Forced folding is described in Sections 7.2.1 and 8.2.1.
characters have been purposely added to the script so as to ensure that the script is itself not folded in this document, thus simplifying the ability to copy/paste the script for local use.
As should be evident by the lack of the mandatory header described in Section 7.1.1, these backslashes do not designate a folded line (e.g., as described in Section 7).
# This script may need some adjustments to work on a given system.
# For instance, the utility 'gsed' may need to be installed.
# Also, please be advised that 'bash' (not 'sh') must be used.
2020 IETF Trust, Kent Watsen, and Erik Auerswald.
# # THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT
THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS # FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
SHALL THE # COPYRIGHT OWNER
BE LIABLE FOR ANY DIRECT, INDIRECT, # INCIDENTAL, SPECIAL, EXEMPLARY, OR
CONSEQUENTIAL DAMAGES # (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
# SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
# HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
WHETHER IN CONTRACT, # STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
# ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
# ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
[ q] [ s <strategy>]
o <outfile>\n" printf "\n" printf "
strategy to use, '1' or '2'
the input filename\n" printf "
h: show this message\n" printf "\n
" printf "Exit status code: 1 on error, 0 on success, 255 on no op."
reversed 0 infile "" outfile "" maxcol 69
# default, may be overridden by param col gvn 0
\ warn 'not using GNU `sed` (likely cause if an error occurs).'
cleanup' EXIT fold it 1()
# where to fold foldcol
$(expr ${#hdr txt 1}   2) left
$(expr "$maxcol" "$length" "$left sp") header $(printf "%.
s" "$left sp" "$equal chars"\ "
$hdr txt 1" "$right sp" "$equal chars")
$(expr ${#hdr txt 2}   2) left
$(expr "$maxcol" "$length" "$left sp") header $(printf "%.
s" "$left sp" "$equal chars"\ "
$hdr txt 2" "$right sp" "$equal chars")
{ # ensure input file doesn't contain a tab grep  q
" return 1 fi # folding of input containing ASCII control or
non ASCII characters # may result in a wrong folding column and is not supported if type gawk > /dev/null 2>&1; then
" else dbg "no GNU awk; skipping checks for special characters."
# check if file needs folding testcol $
; then dbg "nothing to do; copying infile to outfile." cp "$infile"
quiet" quiet 1 fold it
" fold it 2 return $?
# output all but the first two lines (the header) to wip file awk "NR>2" "$infile" >
"$temp dir/wip" # unfold wip file "$SED" '{H;$!d};x;s/^\n//;s/\\\n  //g' "$temp dir/wip"
> "$outfile" return 0 } unfold it 2
# output all but the first two lines (the header) to wip file awk "NR>2" "$infile" >
"$temp dir/wip" # unfold wip file "$SED" '{H;$!d};x;s/^\n//;s/\\\n
$("$SED"  n '2p' "$infile") result
$(echo "$line"   fgrep "$hdr txt 1")
fi result $(echo "$line"   fgrep "$hdr txt 2")
return 1 fi unfold it
fi dbg "nothing to do; copying infile to outfile.
"$outfile" return 255 } process input() {
(expr ${#hdr txt 2}   8)
1 fi # this is only because the code otherwise runs out of equal chars
