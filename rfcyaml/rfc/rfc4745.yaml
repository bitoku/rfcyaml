- contents:
  - '  Common Policy: A Document Format for Expressing Privacy Preferences

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The IETF Trust (2007).\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document defines a framework for authorization policies\n   controlling
    access to application-specific data.  This framework\n   combines common location-
    and presence-specific authorization\n   aspects.  An XML schema specifies the
    language in which common policy\n   rules are represented.  The common policy
    framework can be extended\n   to other application domains.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \  2. Terminology .....................................................4\n   3.
    Modes of Operation ..............................................4\n      3.1.
    Passive Request-Response - PS as Server (Responder) ........5\n      3.2. Active
    Request-Response - PS as Client (Initiator) .........5\n      3.3. Event Notification
    .........................................5\n   4. Goals and Assumptions ...........................................6\n
    \  5. Non-Goals .......................................................7\n   6.
    Basic Data Model and Processing .................................8\n      6.1.
    Identification of Rules ....................................9\n      6.2. Extensions
    .................................................9\n   7. Conditions .....................................................10\n
    \     7.1. Identity Condition ........................................10\n           7.1.1.
    Overview ...........................................10\n           7.1.2. Matching
    One Entity ................................11\n           7.1.3. Matching Multiple
    Entities .........................11\n      7.2. Single Entity .............................................14\n
    \     7.3. Sphere ....................................................15\n      7.4.
    Validity ..................................................16\n   8. Actions ........................................................17\n
    \  9. Transformations ................................................18\n   10.
    Procedure for Combining Permissions ...........................18\n      10.1.
    Introduction .............................................18\n      10.2. Combining
    Rules (CRs) ....................................18\n      10.3. Example ..................................................19\n
    \  11. Meta Policies .................................................21\n   12.
    Example .......................................................21\n   13. XML
    Schema Definition .........................................22\n   14. Security
    Considerations .......................................25\n   15. IANA Considerations
    ...........................................25\n      15.1. Common Policy Namespace
    Registration .....................25\n      15.2. Content-type Registration for\n
    \           'application/auth-policy+xml' ............................26\n      15.3.
    Common Policy Schema Registration ........................27\n   16. References
    ....................................................27\n      16.1. Normative
    References .....................................27\n      16.2. Informative References
    ...................................28\n   Appendix A. Contributors ..........................................29\n
    \  Appendix B. Acknowledgments .......................................29\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This document defines a framework for creating authorization
    policies\n   for access to application-specific data.  This framework is the\n
    \  result of combining the common aspects of single authorization\n   systems
    that more specifically control access to presence and\n   location information
    and that previously had been developed\n   separately.  The benefit of combining
    these two authorization systems\n   is two-fold.  First, it allows building a
    system that enhances the\n   value of presence with location information in a
    natural way and\n   reuses the same underlying authorization mechanism.  Second,
    it\n   encourages a more generic authorization framework with mechanisms for\n
    \  extensibility.  The applicability of the framework specified in this\n   document
    is not limited to policies controlling access to presence\n   and location information
    data, but can be extended to other\n   application domains.\n   The general framework
    defined in this document is intended to be\n   accompanied and enhanced by application-specific
    policies specified\n   elsewhere.  The common policy framework described here
    is enhanced by\n   domain-specific policy documents, including presence [7] and
    location\n   [8].  This relationship is shown in Figure 1.\n                           +-----------------+\n
    \                          |                 |\n                           |     Common
    \     |\n                           |     Policy      |\n                           |
    \                |\n                           +---+---------+---+\n                              /|\\
    \      /|\\\n                               |         |\n      +-------------------+
    \   |         |    +-------------------+\n      |                   |    | enhance
    |    |                   |\n      | Location-specific |    |         |    | Presence-specific
    |\n      |      Policy       |----+         +----|      Policy       |\n      |
    \                  |                   |                   |\n      +-------------------+
    \                  +-------------------+\n                   Figure 1: Common
    Policy Enhancements\n   This document starts with an introduction to the terminology
    in\n   Section 2, an illustration of basic modes of operation in Section 3,\n
    \  a description of goals (see Section 4) and non-goals (see Section 5)\n   of
    the policy framework, followed by the data model in Section 6.\n   The structure
    of a rule, namely, conditions, actions, and\n   transformations, is described
    in Sections 7, 8, and 9.  The procedure\n   for combining permissions is explained
    in Section 10 and used when\n   conditions for more than one rule are satisfied.
    \ A short description\n   of meta policies is given in Section 11.  An example
    is provided in\n   Section 12.  The XML schema will be discussed in Section 13.
    \ IANA\n   considerations in Section 15 follow security considerations in\n   Section
    14.\n"
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\",\"RECOMMENDED\", \"MAY\", and \"OPTIONAL\"
    in this\n   document are to be interpreted as described in [1].\n   This document
    introduces the following terms:\n   PT - Presentity / Target:  The PT is the entity
    about whom\n        information has been requested.\n   RM - Rule Maker:  The
    RM is an entity that creates the authorization\n        rules that restrict access
    to data items.\n   PS - (Authorization) Policy Server:  This entity has access
    to both\n        the authorization policies and the data items.  In location-\n
    \       specific applications, the entity PS is labeled as location\n        server
    (LS).\n   WR - Watcher / Recipient:  This entity requests access to data items\n
    \       of the PT.  An access operation might be a read, a write, or any\n        other
    operation.\n   A policy is given by a 'rule set' that contains an unordered list
    of\n   'rules'.  A 'rule' has a 'conditions', an 'actions', and a\n   'transformations'
    part.\n   The term 'permission' indicates the action and transformation\n   components
    of a 'rule'.\n   The term 'using protocol' is defined in [9].  It refers to the\n
    \  protocol used to request access to and to return privacy-sensitive\n   data
    items.\n"
  title: 2.  Terminology
- contents:
  - "3.  Modes of Operation\n   The abstract sequence of operations can roughly be
    described as\n   follows.  The PS receives a query for data items for a particular
    PT,\n   via the using protocol.  The using protocol (or more precisely, the\n
    \  authentication protocol) provides the identity of the requestor,\n   either
    at the time of the query or at the subscription time.  The\n   authenticated identity
    of the WR, together with other information\n   provided by the using protocol
    or generally available to the server,\n   is then used for searching through the
    rule set.  All matching rules\n   are combined according to a permission combining
    algorithm described\n   in Section 10.  The combined rules are applied to the
    application\n   data, resulting in the application of privacy based on the\n   transformation
    policies.  The resulting application data is returned\n   to the WR.\n   Three
    different modes of operation can be distinguished:\n"
  - contents:
    - "3.1.  Passive Request-Response - PS as Server (Responder)\n   In a passive
      request-response mode, the WR queries the PS for data\n   items about the PT.
      \ Examples of protocols following this mode of\n   operation include HTTP, FTP,
      LDAP, finger, and various remote\n   procedure call (RPC) protocols, including
      Sun RPC, Distributed\n   Computing Environment (DCE), Distributed Component
      Object Model\n   (DCOM), common object request broker architecture (Corba),
      and Simple\n   Object Access Protocol (SOAP).  The PS uses the rule set to determine\n
      \  whether the WR is authorized to access the PT's information, refusing\n   the
      request if necessary.  Furthermore, the PS might filter\n   information by removing
      elements or by reducing the resolution of\n   elements.\n"
    title: 3.1.  Passive Request-Response - PS as Server (Responder)
  - contents:
    - "3.2.  Active Request-Response - PS as Client (Initiator)\n   Alternatively,
      the PS may contact the WR and convey data items.\n   Examples include HTTP,
      SIP session setup (INVITE request), H.323\n   session setup or SMTP.\n"
    title: 3.2.  Active Request-Response - PS as Client (Initiator)
  - contents:
    - "3.3.  Event Notification\n   Event notification adds a subscription phase to
      the \"Active Request-\n   Response - PS as Client (Initiator)\" mode of operation.
      \ A watcher or\n   subscriber asks to be added to the notification list for
      a particular\n   presentity or event.  When the presentity changes state or
      the event\n   occurs, the PS sends a message to the WR containing the updated\n
      \  state.  (Presence is a special case of event notification; thus, we\n   often
      use the term interchangeably.)\n   In addition, the subscriber may itself add
      a filter to the\n   subscription, limiting the rate or content of the notifications.
      \ If\n   an event, after filtering by the rule-maker-provided rules and by the\n
      \  subscriber-provided rules, only produces the same notification\n   content
      that was sent previously, no event notification is sent.\n   A single PS may
      authorize access to data items in more than one mode.\n   Rather than having
      different rule sets for different modes all three\n   modes are supported with
      a one rule set schema.  Specific instances\n   of the rule set can omit elements
      that are only applicable to the\n   subscription model.\n"
    title: 3.3.  Event Notification
  title: 3.  Modes of Operation
- contents:
  - "4.  Goals and Assumptions\n   Below, we summarize our design goals and constraints.\n
    \  Table representation:\n      Each rule must be representable as a row in a
    relational database.\n      This design goal should allow efficient policy implementation
    by\n      utilizing standard database optimization techniques.\n   Permit only:\n
    \     Rules only provide permissions rather than denying them.  Removing\n      a
    rule can never increase permissions.  Depending on the\n      interpretation of
    'deny' and 'permit' rules, the ordering of rules\n      might matter, making updating
    rule sets more complicated since\n      such update mechanisms would have to support
    insertion at specific\n      locations in the rule set.  Additionally, it would
    make\n      distributed rule sets more complicated.  Hence, only 'permit'\n      actions
    are allowed that result in more efficient rule processing.\n      This also implies
    that rule ordering is not important.\n      Consequently, to make a policy decision
    requires processing all\n      rules.\n   Additive permissions:\n      A query
    for access to data items is matched against the rules in\n      the rule database.
    \ If several rules match, then the overall\n      permissions granted to the WR
    are the union of those permissions.\n      A more detailed discussion is provided
    in Section 10.\n   Upgradeable:\n      It should be possible to add additional
    rules later, without\n      breaking PSs that have not been upgraded.  Any such
    upgrades must\n      not degrade privacy constraints, but PSs not yet upgraded
    may\n      reveal less information than the rule maker would have chosen.\n   Capability
    support:\n      In addition to the previous goal, a RM should be able to determine\n
    \     which extensions are supported by the PS.  The mechanism used to\n      determine
    the capability of a PS is outside the scope of this\n      specification.\n   Protocol-independent:\n
    \     The rule set supports constraints on both notifications or queries\n      as
    well as subscriptions for event-based systems such as presence\n      systems.\n
    \  No false assurance:\n      It appears more dangerous to give the user the impression
    that the\n      system will prevent disclosure automatically, but fail to do so\n
    \     with a significant probability of operator error or\n      misunderstanding,
    than to force the user to explicitly invoke\n      simpler rules.  For example,
    rules based on weekday and time-of-\n      day ranges seem particularly subject
    to misinterpretation and\n      false assumptions on part of the RM.  (For example,
    a non-\n      technical RM would probably assume that the rules are based on the\n
    \     time zone of his current location, which may not be known to other\n      components
    of the system.)\n"
  title: 4.  Goals and Assumptions
- contents:
  - "5.  Non-Goals\n   We explicitly decided that a number of possibly worthwhile\n
    \  capabilities are beyond the scope of this first version.  Future\n   versions
    may include these capabilities, using the extension\n   mechanism described in
    this document.  Non-goals include:\n   No external references:\n      Attributes
    within specific rules cannot refer to external rule\n      sets, databases, directories,
    or other network elements.  Any such\n      external reference would make simple
    database implementation\n      difficult and hence they are not supported in this
    version.\n   No regular expressions:\n      Conditions are matched on equality
    or 'greater-than'-style\n      comparisons, not regular expressions, partial matches
    such as the\n      SQL LIKE operator (e.g., LIKE \"%foo%\"), or glob-style matches\n
    \     (\"*@example.com\").  Most of these are better expressed as explicit\n      elements.\n
    \  No repeat times:\n      Repeat times (e.g., every day from 9 am to 4 pm) are
    difficult to\n      make work correctly, due to the different time zones that
    PT, WR,\n      PS, and RM may occupy.  It appears that suggestions for including\n
    \     time intervals are often based on supporting work/non-work\n      distinctions,
    which unfortunately are difficult to capture by time\n      alone.  Note that
    this feature must not be confused with the\n      'Validity' element that provides
    a mechanism to restrict the\n      lifetime of a rule.\n"
  title: 5.  Non-Goals
- contents:
  - "6.  Basic Data Model and Processing\n   A rule set (or synonymously, a policy)
    consists of zero or more\n   rules.  The ordering of these rules is irrelevant.
    \ The rule set can\n   be stored at the PS and conveyed from RM to PS as a single
    document,\n   in subsets or as individual rules.  A rule consists of three parts:\n
    \  conditions (see Section 7), actions (see Section 8), and\n   transformations
    (see Section 9).\n   The conditions part is a set of expressions, each of which
    evaluates\n   to either TRUE or FALSE.  When a WR asks for information about a
    PT,\n   the PS goes through each rule in the rule set.  For each rule, it\n   evaluates
    the expressions in the conditions part.  If all of the\n   expressions evaluate
    to TRUE, then the rule is applicable to this\n   request.  Generally, each expression
    specifies a condition based on\n   some variable that is associated with the context
    of the request.\n   These variables can include the identity of the WR, the domain
    of the\n   WR, the time of day, or even external variables, such as the\n   temperature
    or the mood of the PT.\n   Assuming that the rule is applicable to the request,
    the actions and\n   transformations (commonly referred to as permissions) in the
    rule\n   specify how the PS is supposed to handle this request.  If the\n   request
    is to view the location of the PT, or to view its presence,\n   the typical action
    is \"permit\", which allows the request to proceed.\n   Assuming the action allows
    the request to proceed, the\n   transformations part of the rule specifies how
    the information about\n   the PT -- their location information, their presence,
    etc. -- is\n   modified before being presented to the WR.  These transformations
    are\n   in the form of positive permissions.  That is, they always specify a\n
    \  piece of information that is allowed to be seen by the WR.  When a PS\n   processes
    a request, it takes the transformations specified across\n   all rules that match,
    and creates the union of them.  For computing\n   this union, the data type, such
    as Integer, Boolean, Set, or the\n   Undef data type, plays a role.  The details
    of the algorithm for\n   combining permissions is described in Section 10.  The
    resulting\n   union effectively represents a \"mask\" -- it defines what information\n
    \  is exposed to the WR.  This mask is applied to the actual location or\n   presence
    data for the PT, and the data that is permitted by the mask\n   is shown to the
    WR.  If the WR requests a subset of information only\n   (such as city-level civic
    location data only, instead of the full\n   civic location information), the information
    delivered to the WR MUST\n   be the intersection of the permissions granted to
    the WR and the data\n   requested by the WR.\n   Rules are encoded in XML.  To
    this end, Section 13 contains an XML\n   schema defining the Common Policy Markup
    Language.  This, however, is\n   purely an exchange format between RM and PS.
    \ The format does not\n   imply that the RM or the PS use this format internally,
    e.g., in\n   matching a query with the policy rules.  The rules are designed so\n
    \  that a PS can translate the rules into a relational database table,\n   with
    each rule represented by one row in the database.  The database\n   representation
    is by no means mandatory; we will use it as a\n   convenient and widely-understood
    example of an internal\n   representation.  The database model has the advantage
    that operations\n   on rows have tightly defined meanings.  In addition, it appears\n
    \  plausible that larger-scale implementations will employ a backend\n   database
    to store and query rules, as they can then benefit from\n   existing optimized
    indexing, access control, scaling, and integrity\n   constraint mechanisms.  Smaller-scale
    implementations may well choose\n   different implementations, e.g., a simple
    traversal of the set of\n   rules.\n"
  - contents:
    - "6.1.  Identification of Rules\n   Each rule is equipped with a parameter that
      identifies the rule.\n   This rule identifier is an opaque token chosen by the
      RM.  A RM MUST\n   NOT use the same identifier for two rules that are available
      to the\n   PS at the same time for a given PT.  If more than one RM modifies
      the\n   same rule set, then it needs to be ensured that a unique identifier\n
      \  is chosen for each rule.  A RM can accomplish this goal by retrieving\n   the
      already specified rule set and choosing a new identifier for a\n   rule that
      is different from the existing rule set.\n"
    title: 6.1.  Identification of Rules
  - contents:
    - "6.2.  Extensions\n   The policy framework defined in this document is meant
      to be\n   extensible towards specific application domains.  Such an extension\n
      \  is accomplished by defining conditions, actions, and transformations\n   that
      are specific to the desired application domain.  Each extension\n   MUST define
      its own namespace.\n   Extensions cannot change the schema defined in this document,
      and\n   this schema is not expected to change except via revision to this\n
      \  specification.  Therefore, no versioning procedures for this schema\n   or
      namespace are provided.\n"
    title: 6.2.  Extensions
  title: 6.  Basic Data Model and Processing
- contents:
  - "7.  Conditions\n   The access to data items needs to be matched with the rule
    set stored\n   at the PS.  Each instance of a request has different attributes\n
    \  (e.g., the identity of the requestor) that are used for\n   authorization.
    \ A rule in a rule set might have a number of\n   conditions that need to be met
    before executing the remaining parts\n   of a rule (i.e., actions and transformations).
    \ Details about rule\n   matching are described in Section 10.  This document
    specifies only a\n   few conditions (i.e., identity, sphere, and validity).  Further\n
    \  condition elements can be added via extensions to this document.  If\n   a
    child element of the <conditions> element is in a namespace that is\n   not known
    or not supported, then this child element evaluates to\n   FALSE.\n   As noted
    in Section 5, conditions are matched on equality or \"greater\n   than\" style
    comparisons, rather than regular expressions.  Equality\n   is determined according
    to the rules for the data type associated\n   with the element in the schema given
    in Section 13, unless explicit\n   comparison steps are included in this document.
    \ For xs:anyURI types,\n   readers may wish to consult [2] for its discussion
    xs:anyURI, as well\n   as the text in Section 13.\n"
  - contents:
    - '7.1.  Identity Condition

      '
    - contents:
      - "7.1.1.  Overview\n   The identity condition restricts matching of a rule
        either to a\n   single entity or a group of entities.  Only authenticated
        entities\n   can be matched; acceptable means of authentication are defined
        in\n   protocol-specific documents.  If the <identity> element is absent,\n
        \  identities are not considered, and thus, other conditions in the rule\n
        \  apply to any user, authenticated or not.\n   The <identity> condition is
        considered TRUE if any of its child\n   elements (e.g., the <one/> and the
        <many/> elements defined in this\n   document) evaluate to TRUE, i.e., the
        results of the individual child\n   element are combined using a logical OR.\n
        \  If a child element of the <identity> element is in a namespace that\n   is
        not known or not supported, then this child element evaluates to\n   FALSE.\n"
      title: 7.1.1.  Overview
    - contents:
      - "7.1.2.  Matching One Entity\n   The <one> element matches the authenticated
        identity (as contained in\n   the 'id' attribute) of exactly one entity or
        user.  For\n   considerations regarding the 'id' attribute, refer to Section
        7.2.\n   An example is shown below:\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n
        \  <ruleset xmlns=\"urn:ietf:params:xml:ns:common-policy\">\n       <rule
        id=\"f3g44r1\">\n           <conditions>\n               <identity>\n                   <one
        id=\"sip:alice@example.com\"/>\n                   <one id=\"tel:+1-212-555-1234\"
        />\n                   <one id=\"mailto:bob@example.net\" />\n               </identity>\n
        \          </conditions>\n           <actions/>\n           <transformations/>\n
        \      </rule>\n   </ruleset>\n   This example matches if the authenticated
        identity of the WR is\n   either sip:alice@example.com, tel:+1-212-555-1234,
        or\n   mailto:bob@example.net.\n"
      title: 7.1.2.  Matching One Entity
    - contents:
      - "7.1.3.  Matching Multiple Entities\n   The <many> element is a mechanism
        to perform authorization decisions\n   based on the domain part of the authenticated
        identity.  As such, it\n   allows matching a large and possibly unknown number
        of users within a\n   domain.\n   Furthermore, it is possible to include one
        or multiple <except>\n   elements to exclude either individual users or users
        belonging to a\n   specific domain.  Excluding individual entities is implemented
        using\n   a <except id=\"...\"/> statement.  The semantic of the 'id' attribute\n
        \  of the <except> element has the same meaning as the 'id' attribute of\n
        \  the <one> element (see Section 7.2).  Excluding users belonging to a\n
        \  specific domain is implemented using the <except domain=\"...\"/>\n   element
        that excludes any user from the indicated domain.\n   If multiple <except>
        elements are listed as child elements of the\n   <many> element, then the
        result of each <except> element is combined\n   using a logical OR.\n   Common
        policy MUST either use UTF-8 or UTF-16 to store domain names\n   in the 'domain'
        attribute.  For non-IDNs (Internationalized Domain\n   Names), lowercase ASCII
        SHOULD be used.  For the comparison operation\n   between the value stored
        in the 'domain' attribute and the domain\n   value provided via the using
        protocol (referred to as \"protocol\n   domain identifier\"), the following
        rules are applicable:\n   1.  Translate percent-encoding for either string.\n
        \  2.  Convert both domain strings using the ToASCII operation described\n
        \      in RFC 3490 [3].\n   3.  Compare the two domain strings for ASCII equality,
        for each\n       label.  If the string comparison for each label indicates\n
        \      equality, the comparison succeeds.  Otherwise, the domains are\n       not
        equal.\n   If the conversion fails in step (2), the domains are not equal.\n"
      - contents:
        - "7.1.3.1.  Matching Any Authenticated Identity\n   The <many/> element without
          any child elements or attributes matches\n   any authenticated user.\n   The
          following example shows such a rule that matches any\n   authenticated user:\n
          \  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <ruleset xmlns=\"urn:ietf:params:xml:ns:common-policy\">\n
          \      <rule id=\"f3g44r5\">\n           <conditions>\n               <identity>\n
          \                <many/>\n               </identity>\n           </conditions>\n
          \          <actions/>\n           <transformations/>\n       </rule>\n   </ruleset>\n"
        title: 7.1.3.1.  Matching Any Authenticated Identity
      - contents:
        - "7.1.3.2.  Matching Any Authenticated Identity Except Enumerated\n          Domains/Identities\n
          \  The <many> element enclosing one or more <except domain=\"...\"/>\n   elements
          matches any user from any domain except those enumerated.\n   The <except
          id=\"...\"/> element excludes particular users.  The\n   semantics of the
          'id' attribute of the <except> element is described\n   in Section 7.2.
          \ The results of the child elements of the <many>\n   element are combined
          using a logical OR.\n   An example is shown below:\n   <?xml version=\"1.0\"
          encoding=\"UTF-8\"?>\n   <ruleset xmlns=\"urn:ietf:params:xml:ns:common-policy\">\n
          \      <rule id=\"f3g44r1\">\n           <conditions>\n               <sphere
          value=\"work\"/>\n               <identity>\n                   <many>\n
          \                      <except domain=\"example.com\"/>\n                       <except
          domain=\"example.org\"/>\n                       <except id=\"sip:alice@bad.example.net\"/>\n
          \                      <except id=\"sip:bob@good.example.net\"/>\n                       <except
          id=\"tel:+1-212-555-1234\" />\n                       <except id=\"sip:alice@example.com\"/>\n
          \                  </many>\n               </identity>\n               <validity>\n
          \                  <from>2003-12-24T17:00:00+01:00</from>\n                   <until>2003-12-24T19:00:00+01:00</until>\n
          \              </validity>\n           </conditions>\n           <actions/>\n
          \          <transformations/>\n       </rule>\n   </ruleset>\n   This example
          matches all users except any user in example.com, or any\n   user in example.org
          or the particular users alice@bad.example.net,\n   bob@good.example.net,
          and the user with the telephone number\n   'tel:+1-212-555-1234'.  The last
          'except' element is redundant since\n   alice@example.com is already excluded
          through the first line.\n"
        title: 7.1.3.2.  Matching Any Authenticated Identity Except Enumerated
      - contents:
        - "7.1.3.3.  Matching Any Authenticated Identity within a Domain Except\n
          \         Enumerated Identities\n   The <many> element with a 'domain' attribute
          and zero or more <except\n   id=\"...\"/> elements matches any authenticated
          user from the indicated\n   domain except those explicitly enumerated.  The
          semantics of the 'id'\n   attribute of the <except> element is described
          in Section 7.2.\n   It is nonsensical to have domains in the 'id' attribute
          that do not\n   match the value of the 'domain' attribute in the enclosing
          <many>\n   element.\n   An example is shown below:\n   <?xml version=\"1.0\"
          encoding=\"UTF-8\"?>\n   <ruleset xmlns=\"urn:ietf:params:xml:ns:common-policy\">\n
          \      <rule id=\"f3g44r1\">\n           <conditions>\n               <identity>\n
          \                  <many domain=\"example.com\">\n                       <except
          id=\"sip:alice@example.com\"/>\n                       <except id=\"sip:bob@example.com\"/>\n
          \                  </many>\n               </identity>\n           </conditions>\n
          \          <actions/>\n           <transformations/>\n       </rule>\n   </ruleset>\n
          \  This example matches any user within example.com (such as\n   carol@example.com)
          except alice@example.com and bob@example.com.\n"
        title: 7.1.3.3.  Matching Any Authenticated Identity within a Domain Except
      title: 7.1.3.  Matching Multiple Entities
    title: 7.1.  Identity Condition
  - contents:
    - "7.2.  Single Entity\n   The 'id' attribute used in the <one> and in the <except>
      element\n   refers to a single entity.  In the subsequent text, we use the term\n
      \  'single-user entity' as a placeholder for the <one> and the <except>\n   element.
      \ The <except> element fulfills the purpose of excluding\n   elements from the
      solution set.\n   A single-user entity matches the authenticated identity (as
      contained\n   in the 'id' attribute) of exactly one entity or user.  If there
      is a\n   match, the single-user entity is considered TRUE.  The single-user\n
      \  entity MUST NOT contain a 'domain' attribute.\n   The 'id' attribute contains
      an identity that MUST first be expressed\n   as a URI.  Applications using this
      framework must describe how the\n   identities they are using can be expressed
      as URIs.\n"
    title: 7.2.  Single Entity
  - contents:
    - "7.3.  Sphere\n   The <sphere> element belongs to the group of condition elements.
      \ It\n   can be used to indicate a state (e.g., 'work', 'home', 'meeting',\n
      \  'travel') the PT is currently in.  A sphere condition matches only if\n   the
      PT is currently in the state indicated.  The state may be\n   conveyed by manual
      configuration or by some protocol.  For example,\n   RPID [10] provides the
      ability to inform the PS of its current\n   sphere.  The application domain
      needs to describe in more detail how\n   the sphere state is determined.  Switching
      from one sphere to another\n   causes a switch between different modes of visibility.
      \ As a result,\n   different subsets of rules might be applicable.\n   The content
      of the 'value' attribute of the <sphere> element MAY\n   contain more than one
      token.  The individual tokens MUST be separated\n   by a blank character.  A
      logical OR is used for the matching the\n   tokens against the sphere settings
      of the PT.  As an example, if the\n   content of the 'value' attribute in the
      sphere attribute contains two\n   tokens 'work' and 'home' then this part of
      the rule matches if the\n   sphere for a particular PT is either 'work' OR 'home'.
      \ To compare\n   the content of the 'value' attribute in the <sphere> element
      with the\n   stored state information about the PT's sphere setting a\n   case-insensitive
      string comparison MUST be used for each individual\n   token.  There is neither
      a registry for these values nor a language-\n   specific indication of the sphere
      content.  As such, the tokens are\n   treated as opaque strings.\n   <?xml version=\"1.0\"
      encoding=\"UTF-8\"?>\n   <ruleset xmlns=\"urn:ietf:params:xml:ns:common-policy\">\n
      \    <rule id=\"f3g44r2\">\n       <conditions>\n         <sphere value=\"work\"/>\n
      \        <identity>\n           <one id=\"sip:andrew@example.com\"/>\n         </identity>\n
      \      </conditions>\n       <actions/>\n       <transformations/>\n     </rule>\n
      \    <rule id=\"y6y55r2\">\n       <conditions>\n         <sphere value=\"home\"/>\n
      \        <identity>\n           <one id=\"sip:allison@example.com\"/>\n         </identity>\n
      \      </conditions>\n       <actions/>\n       <transformations/>\n     </rule>\n
      \    <rule id=\"z6y55r2\">\n       <conditions>\n         <identity>\n              <one
      id=\"sip:john@doe.example.com\"/>\n         </identity>\n         <sphere value=\"home
      work\"/>\n       </conditions>\n       <actions/>\n       <transformations/>\n
      \    </rule>\n   </ruleset>\n   The rule example above illustrates that the
      rule with the entity\n   andrew@example.com matches if the sphere is been set
      to 'work'.  In\n   the second rule, the entity allison@example.com matches if
      the sphere\n   is set to 'home'.  The third rule also matches since the value
      in the\n   sphere element also contains the token 'home'.\n"
    title: 7.3.  Sphere
  - contents:
    - "7.4.  Validity\n   The <validity> element is the third condition element specified
      in\n   this document.  It expresses the rule validity period by two\n   attributes,
      a starting and an ending time.  The validity condition is\n   TRUE if the current
      time is greater than or equal to at least one\n   <from> child, but less than
      the <until> child after it.  This\n   represents a logical OR operation across
      each <from> and <until>\n   pair.  Times are expressed in XML dateTime format.
      \ A rule maker\n   might not always have access to the PS to invalidate some
      rules that\n   grant permissions.  Hence, this mechanism allows invalidating
      granted\n   permissions automatically without further interaction between the\n
      \  rule maker and the PS.  The PS does not remove the rules; instead the\n   rule
      maker has to clean them up.\n   An example of a rule fragment is shown below:\n
      \  <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   <ruleset xmlns=\"urn:ietf:params:xml:ns:common-policy\">\n
      \    <rule id=\"f3g44r3\">\n       <conditions>\n           <validity>\n               <from>2003-08-15T10:20:00.000-05:00</from>\n
      \              <until>2003-09-15T10:20:00.000-05:00</until>\n           </validity>\n
      \      </conditions>\n       <actions/>\n       <transformations/>\n     </rule>\n
      \  </ruleset>\n   The <validity> element MUST have the <from> and <until> subelements\n
      \  in pairs.  Multiple <from> and <until> elements might appear in pairs\n   (i.e.,
      without nesting of <from> and <until> elements).  Using\n   multiple <validity>
      elements as subelements of the <conditions>\n   element is not useful since
      all subelements of the <conditions>\n   element are combined as a logical AND.\n"
    title: 7.4.  Validity
  title: 7.  Conditions
- contents:
  - "8.  Actions\n   While conditions are the 'if'-part of rules, actions and\n   transformations
    form their 'then'-part.  The actions and\n   transformations parts of a rule determine
    which operations the PS\n   MUST execute after having received from a WR a data
    access request\n   that matches all conditions of this rule.  Actions and\n   transformations
    only permit certain operations; there is no 'deny'\n   functionality.  Transformations
    exclusively specify PS-side\n   operations that lead to a modification of the
    data items requested by\n   the WR.  Regarding location data items, for instance,
    a\n   transformation could force the PS to lower the precision of the\n   location
    information that is returned to the WR.\n   Actions, on the other hand, specify
    all remaining types of operations\n   the PS is obliged to execute, i.e., all
    operations that are not of\n   transformation type.  Actions are defined by application-specific\n
    \  usages of this framework.  The reader is referred to the\n   corresponding
    extensions to see examples of such elements.\n"
  title: 8.  Actions
- contents:
  - "9.  Transformations\n   Two sub-parts follow the conditions part of a rule: transformations\n
    \  and actions.  As defined in Section 8, transformations specify\n   operations
    that the PS MUST execute and that modify the result that\n   is returned to the
    WR.  This functionality is particularly helpful in\n   reducing the granularity
    of information provided to the WR, as, for\n   example, required for location
    privacy.  Transformations are defined\n   by application-specific usages of this
    framework.\n   A simple transformation example is provided in Section 10.\n"
  title: 9.  Transformations
- contents:
  - '10.  Procedure for Combining Permissions

    '
  - contents:
    - "10.1.  Introduction\n   This section describes how rules are selected and how
      actions and\n   permissions are determined.  When a PS receives a request for
      access\n   to privacy-sensitive data, the request is matched against the rule\n
      \  set.  A rule matches if all conditions contained as child elements in\n   the
      <conditions> element of a rule evaluate to TRUE.  Each type of\n   condition
      defines when it is TRUE.  All rules where the conditions\n   match the request
      form the matching rule set.  The permissions in the\n   matching rule set are
      combined using a set of combining rules (CRs)\n   described in Section 10.2.\n"
    title: 10.1.  Introduction
  - contents:
    - "10.2.  Combining Rules (CRs)\n   Each type of permission is combined across
      all matching rules.  Each\n   type of action or transformation is combined separately
      and\n   independently.  The combining rules generate a combined permission.\n
      \  The combining rules depend only on the data type of permission.  If a\n   particular
      permission type has no value in a rule, it assumes the\n   lowest possible value
      for that permission for the purpose of\n   computing the combined permission.
      \ That value is given by the data\n   type for booleans (FALSE) and sets (empty
      set), and MUST be defined\n   by any extension to the Common Policy for other
      data types.\n   For boolean permissions, the resulting permission is TRUE if
      and only\n   if at least one permission in the matching rule set has a value
      of\n   TRUE and FALSE otherwise.  For integer, real-valued and date-time\n   permissions,
      the resulting permission is the maximum value across the\n   permission values
      in the matching set of rules.  For sets, it is the\n   union of values across
      the permissions in the matching rule set.\n"
    title: 10.2.  Combining Rules (CRs)
  - contents:
    - "10.3.  Example\n   In the following example we illustrate the process of combining\n
      \  permissions.  We will consider three conditions for our purpose,\n   namely
      those of name identity (WR-ID), sphere, and validity\n   (from,until).  The
      ID column is used as a rule identifier.  For\n   editorial reasons we omit the
      domain part of the WR's identity.\n   We use two actions in our example, namely
      X and Y.  The values of X\n   and Y are of data types Boolean and Integer, respectively.\n
      \  The transformation, referred to as Z, uses values that can be set\n   either
      to '+' (or 3), 'o' (or 2) or '-' (or 1).  Permission Z allows\n   us to show
      the granularity reduction whereby a value of '+' shows the\n   corresponding
      information unrestricted, and '-' shows nothing.  This\n   permission might
      be related to location information or other presence\n   attributes like mood.
      \ Internally, we use the data type Integer for\n   computing the permission
      of this attribute.\n   The label 'NULL' in the table indicates that no value
      is available\n   for a particular cell.\n         Conditions                  Actions/Transformations\n
      \    +---------------------------------+---------------------+\n     | Id  WR-ID
      \   sphere  from until |  X       Y     Z    |\n     +---------------------------------+---------------------+\n
      \    |  1   bob      home    A1    A2  |  TRUE    10    o    |\n     |  2   alice
      \   work    A1    A2  |  FALSE   5     +    |\n     |  3   bob      work    A1
      \   A2  |  TRUE    3     -    |\n     |  4   tom      work    A1    A2  |  TRUE
      \   5     +    |\n     |  5   bob      work    A1    A3  |  NULL    12    o
      \   |\n     |  6   bob      work    B1    B2  |  FALSE   10    -    |\n     +---------------------------------+---------------------+\n
      \  Again for editorial reasons, we use the following abbreviations for\n   the
      two <validity> attributes 'from' and 'until':\n     A1=2003-12-24T17:00:00+01:00\n
      \    A2=2003-12-24T21:00:00+01:00\n     A3=2003-12-24T23:30:00+01:00\n     B1=2003-12-22T17:00:00+01:00\n
      \    B2=2003-12-23T17:00:00+01:00\n   Note that B1 < B2 < A1 < A2 < A3.\n   The
      entity 'bob' acts as a WR and requests data items.  The rule set\n   consists
      of the six rules shown in the table and identified by the\n   values 1 to 6
      in the 'Id' column.  The PS receives the query at\n   2003-12-24T17:15:00+01:00,
      which falls between A1 and A2.  In our\n   example, we assume that the sphere
      value of the PT is currently set\n   to 'work'.\n   As a first step, it is necessary
      to determine which rules fire by\n   evaluating the conditions part of each
      of them.\n   Rule 1 does not match since the sphere condition does not match.\n
      \  Rule 2 does not match as the identity of the WR (here 'alice') does\n   not
      equal 'bob'.  Rule 3 matches since all conditions evaluate to\n   TRUE.  Rule
      4 does not match as the identity of the WR (here 'tom')\n   does not equal 'bob'.
      \ Rule 5 matches.  Rule 6 does not match since\n   the rule is not valid anymore.\n
      \  Only rules 3 and 5 fire.  We use the actions and transformations part\n   of
      these two rules to determine the combined permission, as shown\n   below.\n
      \            Actions/Transformations\n     +-----+-----------------------+\n
      \    | Id  |  X       Y      Z     |\n     +-----+-----------------------+\n
      \    |  3  |  TRUE     3     -     |\n     |  5  |  NULL    12     o     |\n
      \    +-----+-----------------------+\n   Each column is treated independently.
      \ The combined value of X is set\n   to TRUE since the NULL value equals FALSE
      according to the\n   description in Section 10.2.  For the column with the name
      Y, we\n   apply the maximum of 3 and 12, so that the combined value of Y is
      12.\n   For column Z, we again compute the maximum of 'o' and '-' (i.e., 2\n
      \  and 1) which is 'o' (2).\n   The combined permission for all three columns
      is therefore:\n             Actions/Transformations\n           +-----------------------+\n
      \          |  X       Y      Z     |\n           +-----------------------+\n
      \          |  TRUE    12     o     |\n           +-----------------------+\n"
    title: 10.3.  Example
  title: 10.  Procedure for Combining Permissions
- contents:
  - "11.  Meta Policies\n   Meta policies authorize a rule maker to insert, update,
    or delete a\n   particular rule or an entire rule set.  Some authorization policies\n
    \  are required to prevent unauthorized modification of rule sets.  Meta\n   policies
    are outside the scope of this document.\n   A simple implementation could restrict
    access to the rule set only to\n   the PT but more sophisticated mechanisms could
    be useful.  As an\n   example of such policies, one could think of parents configuring
    the\n   policies for their children.\n"
  title: 11.  Meta Policies
- contents:
  - "12.  Example\n   This section gives an example of an XML document valid with
    respect\n   to the XML schema defined in Section 13.  Semantically richer\n   examples
    can be found in documents that extend this schema with\n   application-domain-specific
    data (e.g., location or presence\n   information).\n   Below a rule is shown with
    a condition that matches for a given\n   authenticated identity (bob@example.com)
    and within a given time\n   period.  Additionally, the rule matches only if the
    target has set\n   its sphere to 'work'.\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n
    \  <ruleset xmlns=\"urn:ietf:params:xml:ns:common-policy\">\n       <rule id=\"f3g44r1\">\n
    \          <conditions>\n               <identity>\n                   <one id=\"sip:bob@example.com\"/>\n
    \              </identity>\n               <sphere value=\"work\"/>\n               <validity>\n
    \                  <from>2003-12-24T17:00:00+01:00</from>\n                   <until>2003-12-24T19:00:00+01:00</until>\n
    \              </validity>\n           </conditions>\n           <actions/>\n
    \          <transformations/>\n       </rule>\n   </ruleset>\n"
  title: 12.  Example
- contents:
  - "13.  XML Schema Definition\n   This section provides the XML schema definition
    for the common policy\n   markup language described in this document.\n"
  - '<?xml version="1.0" encoding="UTF-8"?>

    '
  - "<xs:schema targetNamespace=\"urn:ietf:params:xml:ns:common-policy\"\n    xmlns:cp=\"urn:ietf:params:xml:ns:common-policy\"\n
    \   xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n    elementFormDefault=\"qualified\"
    attributeFormDefault=\"unqualified\">\n    <!-- /ruleset -->\n    <xs:element
    name=\"ruleset\">\n        <xs:complexType>\n            <xs:complexContent>\n
    \               <xs:restriction base=\"xs:anyType\">\n                    <xs:sequence>\n
    \                       <xs:element name=\"rule\" type=\"cp:ruleType\"\n                        minOccurs=\"0\"
    maxOccurs=\"unbounded\"/>\n                    </xs:sequence>\n                </xs:restriction>\n
    \           </xs:complexContent>\n        </xs:complexType>\n    </xs:element>\n
    \   <!-- /ruleset/rule -->\n    <xs:complexType name=\"ruleType\">\n        <xs:complexContent>\n
    \           <xs:restriction base=\"xs:anyType\">\n                <xs:sequence>\n
    \                   <xs:element name=\"conditions\"\n                    type=\"cp:conditionsType\"
    minOccurs=\"0\"/>\n                    <xs:element name=\"actions\"\n                    type=\"cp:extensibleType\"
    minOccurs=\"0\"/>\n                    <xs:element name=\"transformations\"\n
    \                   type=\"cp:extensibleType\" minOccurs=\"0\"/>\n                </xs:sequence>\n
    \               <xs:attribute name=\"id\" type=\"xs:ID\" use=\"required\"/>\n
    \           </xs:restriction>\n        </xs:complexContent>\n    </xs:complexType>\n
    \   <!-- //rule/conditions -->\n    <xs:complexType name=\"conditionsType\">\n
    \       <xs:complexContent>\n            <xs:restriction base=\"xs:anyType\">\n
    \               <xs:choice maxOccurs=\"unbounded\">\n                    <xs:element
    name=\"identity\"\n                    type=\"cp:identityType\" minOccurs=\"0\"/>\n
    \                   <xs:element name=\"sphere\"\n                    type=\"cp:sphereType\"
    minOccurs=\"0\"/>\n                    <xs:element name=\"validity\"\n                    type=\"cp:validityType\"
    minOccurs=\"0\"/>\n                    <xs:any namespace=\"##other\" processContents=\"lax\"\n
    \                   minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n                </xs:choice>\n
    \           </xs:restriction>\n        </xs:complexContent>\n    </xs:complexType>\n
    \   <!-- //conditions/identity -->\n    <xs:complexType name=\"identityType\">\n
    \       <xs:complexContent>\n            <xs:restriction base=\"xs:anyType\">\n
    \               <xs:choice  minOccurs=\"1\" maxOccurs=\"unbounded\">\n                    <xs:element
    name=\"one\" type=\"cp:oneType\"/>\n                    <xs:element name=\"many\"
    type=\"cp:manyType\"/>\n                    <xs:any namespace=\"##other\" processContents=\"lax\"/>\n
    \               </xs:choice>\n            </xs:restriction>\n        </xs:complexContent>\n
    \   </xs:complexType>\n    <!-- //identity/one -->\n    <xs:complexType name=\"oneType\">\n
    \       <xs:complexContent>\n            <xs:restriction base=\"xs:anyType\">\n
    \               <xs:sequence>\n                    <xs:any namespace=\"##other\"\n
    \                   minOccurs=\"0\" processContents=\"lax\"/>\n                </xs:sequence>\n
    \               <xs:attribute name=\"id\"\n                type=\"xs:anyURI\"
    use=\"required\"/>\n            </xs:restriction>\n        </xs:complexContent>\n
    \   </xs:complexType>\n    <!-- //identity/many -->\n    <xs:complexType name=\"manyType\">\n
    \       <xs:complexContent>\n            <xs:restriction base=\"xs:anyType\">\n
    \               <xs:choice minOccurs=\"0\" maxOccurs=\"unbounded\">\n                    <xs:element
    name=\"except\" type=\"cp:exceptType\"/>\n                    <xs:any namespace=\"##other\"\n
    \                   minOccurs=\"0\" processContents=\"lax\"/>\n                </xs:choice>\n
    \               <xs:attribute name=\"domain\"\n                use=\"optional\"
    type=\"xs:string\"/>\n            </xs:restriction>\n        </xs:complexContent>\n
    \   </xs:complexType>\n    <!-- //many/except -->\n    <xs:complexType name=\"exceptType\">\n
    \       <xs:attribute name=\"domain\" type=\"xs:string\" use=\"optional\"/>\n
    \       <xs:attribute name=\"id\" type=\"xs:anyURI\" use=\"optional\"/>\n    </xs:complexType>\n
    \   <!-- //conditions/sphere -->\n    <xs:complexType name=\"sphereType\">\n        <xs:complexContent>\n
    \           <xs:restriction base=\"xs:anyType\">\n                <xs:attribute
    name=\"value\"\n                type=\"xs:string\" use=\"required\"/>\n            </xs:restriction>\n
    \       </xs:complexContent>\n    </xs:complexType>\n    <!-- //conditions/validity
    -->\n    <xs:complexType name=\"validityType\">\n        <xs:complexContent>\n
    \           <xs:restriction base=\"xs:anyType\">\n                <xs:sequence
    minOccurs=\"1\" maxOccurs=\"unbounded\">\n                    <xs:element name=\"from\"
    type=\"xs:dateTime\"/>\n                    <xs:element name=\"until\" type=\"xs:dateTime\"/>\n
    \               </xs:sequence>\n            </xs:restriction>\n        </xs:complexContent>\n
    \   </xs:complexType>\n    <!-- //rule/actions or //rule/transformations -->\n
    \   <xs:complexType name=\"extensibleType\">\n        <xs:complexContent>\n            <xs:restriction
    base=\"xs:anyType\">\n                <xs:sequence>\n                    <xs:any
    namespace=\"##other\" processContents=\"lax\"\n                    minOccurs=\"0\"
    maxOccurs=\"unbounded\"/>\n                </xs:sequence>\n            </xs:restriction>\n
    \       </xs:complexContent>\n    </xs:complexType>\n"
  - '</xs:schema>

    '
  title: 13.  XML Schema Definition
- contents:
  - "14.  Security Considerations\n   This document describes a framework for policies.
    \ This framework is\n   intended to be enhanced elsewhere by application-domain-specific\n
    \  data.  Security considerations are to a great extent application-data\n   dependent,
    and therefore need to be covered by documents that extend\n   the framework defined
    in this specification.  However, new action and\n   transformation permissions
    along with their allowed values must be\n   defined in a way so that the usage
    of the permissions combining rules\n   of Section 10 does not lower the level
    of privacy protection.  See\n   Section 10 for more details on this privacy issue.\n"
  title: 14.  Security Considerations
- contents:
  - "15.  IANA Considerations\n   This section registers a new XML namespace, a new
    XML schema, and a\n   new MIME type.  This section registers a new XML namespace
    per the\n   procedures in [4].\n"
  - contents:
    - "15.1.  Common Policy Namespace Registration\n   URI:  urn:ietf:params:xml:ns:common-policy\n
      \  Registrant Contact:  IETF GEOPRIV working group, Henning Schulzrinne\n      (hgs+geopriv@cs.columbia.edu).\n
      \  XML:\n   BEGIN\n   <?xml version=\"1.0\"?>\n   <!DOCTYPE html PUBLIC \"-//W3C//DTD
      XHTML Basic 1.0//EN\"\n     \"http://www.w3.org/TR/xhtml-basic/xhtml-basic10.dtd\">\n
      \  <html xmlns=\"http://www.w3.org/1999/xhtml\">\n   <head>\n     <meta http-equiv=\"content-type\"\n
      \          content=\"text/html;charset=iso-8859-1\"/>\n     <title>Common Policy
      Namespace</title>\n   </head>\n   <body>\n     <h1>Namespace for Common Authorization
      Policies</h1>\n     <h2>urn:ietf:params:xml:ns:common-policy</h2>\n   <p>See
      <a href=\"ftp://ftp.rfc-editor.org/in-notes/rfc4745.txt\">\n      RFC 4745</a>.</p>\n
      \  </body>\n   </html>\n   END\n"
    title: 15.1.  Common Policy Namespace Registration
  - contents:
    - "15.2.  Content-type Registration for 'application/auth-policy+xml'\n   This
      specification requests the registration of a new MIME type\n   according to
      the procedures of RFC 4288 [5] and guidelines in RFC\n   3023 [6].\n   MIME
      media type name:  application\n   MIME subtype name:  auth-policy+xml\n   Mandatory
      parameters:  none\n   Optional parameters:  charset\n      Indicates the character
      encoding of enclosed XML.\n   Encoding considerations:\n      Uses XML, which
      can employ 8-bit characters, depending on the\n      character encoding used.
      \ See RFC 3023 [6], Section 3.2.\n   Security considerations:\n      This content
      type is designed to carry authorization policies.\n      Appropriate precautions
      should be adopted to limit disclosure of\n      this information.  Please refer
      to Section 14 of RFC 4745 and to\n      the security considerations described
      in Section 10 of RFC 3023\n      [6] for more information.\n   Interoperability
      considerations:  None\n   Published specification:  RFC 4745\n   Applications
      which use this media type:\n      Presence- and location-based systems\n   Additional
      information:\n      Magic Number:  None\n      File Extension:  .apxml\n      Macintosh
      file type code:  'TEXT'\n   Personal and email address for further information:\n
      \     Hannes Tschofenig, Hannes.Tschofenig@siemens.com\n   Intended usage:  LIMITED
      USE\n   Author:\n      This specification is a work item of the IETF GEOPRIV
      working\n      group, with mailing list address <geopriv@ietf.org>.\n   Change
      controller:\n      The IESG <iesg@ietf.org>\n"
    title: 15.2.  Content-type Registration for 'application/auth-policy+xml'
  - contents:
    - "15.3.  Common Policy Schema Registration\n   URI:  urn:ietf:params:xml:schema:common-policy\n
      \  Registrant Contact:  IETF GEOPRIV working group, Henning Schulzrinne\n      (hgs+geopriv@cs.columbia.edu).\n
      \  XML:  The XML schema to be registered is contained in Section 13.\n      Its
      first line is\n   <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n   and its last
      line is\n   </xs:schema>\n"
    title: 15.3.  Common Policy Schema Registration
  title: 15.  IANA Considerations
- contents:
  - '16.  References

    '
  - contents:
    - "16.1.  Normative References\n   [1]  Bradner, S., \"Key words for use in RFCs
      to Indicate Requirement\n        Levels\", BCP 14, RFC 2119, March 1997.\n   [2]
      \ Duerst, M. and M. Suignard, \"Internationalized Resource\n        Identifiers
      (IRIs)\", RFC 3987, January 2005.\n   [3]  Faltstrom, P., Hoffman, P., and A.
      Costello, \"Internationalizing\n        Domain Names in Applications (IDNA)\",
      RFC 3490, March 2003.\n   [4]  Mealling, M., \"The IETF XML Registry\", BCP
      81, RFC 3688,\n        January 2004.\n   [5]  Freed, N. and J. Klensin, \"Media
      Type Specifications and\n        Registration Procedures\", BCP 13, RFC 4288,
      December 2005.\n   [6]  Murata, M., St. Laurent, S., and D. Kohn, \"XML Media
      Types\",\n        RFC 3023, January 2001.\n"
    title: 16.1.  Normative References
  - contents:
    - "16.2.  Informative References\n   [7]  Rosenberg, J., \"Presence Authorization
      Rules\", Work in Progress,\n        June 2006.\n   [8]  Schulzrinne, H., Tschofenig,
      H., Morris, J., Cuellar, J., and J.\n        Polk, \"A Document Format for Expressing
      Privacy Preferences for\n        Location Information\", Work in Progress, February
      2006.\n   [9]  Cuellar, J., Morris, J., Mulligan, D., Peterson, J., and J.\n
      \       Polk, \"Geopriv Requirements\", RFC 3693, February 2004.\n   [10] Schulzrinne,
      H., Gurbani, V., Kyzivat, P., and J. Rosenberg,\n        \"RPID: Rich Presence
      Extensions to the Presence Information Data\n        Format (PIDF)\", RFC 4480,
      July 2006.\n"
    title: 16.2.  Informative References
  title: 16.  References
- contents:
  - "Appendix A.  Contributors\n   We would like to thank Christian Guenther for his
    help with initial\n   versions of this document.\n"
  title: Appendix A.  Contributors
- contents:
  - "Appendix B.  Acknowledgments\n   This document is partially based on the discussions
    within the IETF\n   GEOPRIV working group.  Discussions at the Geopriv Interim
    Meeting\n   2003 in Washington, D.C., helped the working group to make progress\n
    \  on the authorization policies based on the discussions among the\n   participants.\n
    \  We particularly want to thank Allison Mankin <mankin@psg.com>,\n   Randall
    Gellens <rg+ietf@qualcomm.com>, Andrew Newton\n   <anewton@ecotroph.net>, Ted
    Hardie <hardie@qualcomm.com>, and Jon\n   Peterson <jon.peterson@neustar.biz>
    for discussing a number of\n   details with us.  They helped us to improve the
    quality of this\n   document.  Allison, Ted, and Andrew also helped us to make
    good\n   progress with the internationalization support of the identifier/\n   domain
    attributes.\n   Furthermore, we would like to thank the IETF SIMPLE working group
    for\n   their discussions of J. Rosenberg's draft on presence authorization\n
    \  policies.  We would also like to thank Stefan Berg, Murugaraj\n   Shanmugam,
    Christian Schmidt, Martin Thomson, Markus Isomaki, Aki\n   Niemi, Eva Maria Leppanen,
    Josip Matanovic, and Mark Baker for their\n   comments.  Martin Thomson helped
    us with the XML schema.  Mark Baker\n   provided a review of the media type.  Scott
    Brim provided a review on\n   behalf of the General Area Review Team.\n"
  title: Appendix B.  Acknowledgments
- contents:
  - "Authors' Addresses\n   Henning Schulzrinne\n   Columbia University\n   Department
    of Computer Science\n   450 Computer Science Building\n   New York, NY  10027\n
    \  USA\n   Phone: +1 212 939 7042\n   EMail: schulzrinne@cs.columbia.edu\n   URI:
    \  http://www.cs.columbia.edu/~hgs\n   Hannes Tschofenig\n   Siemens Networks
    GmbH & Co KG\n   Otto-Hahn-Ring 6\n   Munich, Bavaria  81739\n   Germany\n   EMail:
    Hannes.Tschofenig@siemens.com\n   URI:   http://www.tschofenig.com\n   John B.
    Morris, Jr.\n   Center for Democracy and Technology\n   1634 I Street NW, Suite
    1100\n   Washington, DC  20006\n   USA\n   EMail: jmorris@cdt.org\n   URI:   http://www.cdt.org\n
    \  Jorge R. Cuellar\n   Siemens\n   Otto-Hahn-Ring 6\n   Munich, Bavaria  81739\n
    \  Germany\n   EMail: Jorge.Cuellar@siemens.com\n   James Polk\n   Cisco\n   2200
    East President George Bush Turnpike\n   Richardson, Texas  75082\n   USA\n   EMail:
    jmpolk@cisco.com\n   Jonathan Rosenberg\n   Cisco Systems\n   600 Lanidex Plaza\n
    \  Parsippany, New York  07054\n   USA\n   EMail: jdrosen@cisco.com\n   URI:   http://www.jdrosen.net\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document
    is subject to the rights, licenses and restrictions\n   contained in BCP 78, and
    except as set forth therein, the authors\n   retain all their rights.\n   This
    document and the information contained herein are provided on an\n   \"AS IS\"
    basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE INTERNET ENGINEERING
    TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT
    LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION HEREIN WILL NOT INFRINGE
    ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at\n   ietf-ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
