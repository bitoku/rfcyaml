Abstract This document specifies ROHC (Robust Header Compression) profiles that efficiently compress RTP/UDP/IP (Real Time Transport Protocol, User Datagram Protocol, Internet Protocol), RTP/UDP Lite/IP (User Datagram Protocol Lite), UDP/IP, UDP Lite/IP, IP and ESP/IP (Encapsulating Security Payload) headers.
This specification defines a second version of the profiles found in RFC 3095, RFC 3843 and RFC 4019; it supersedes their definition, but does not obsolete them.
The ROHCv2 profiles introduce a number of simplifications to the rules and algorithms that govern the behavior of the compression endpoints.
It also defines robustness mechanisms that may be used by a compressor implementation to increase the probability of decompression success when packets can be lost and/or reordered on the ROHC channel.
Finally, the ROHCv2 profiles define their own specific set of header formats, using the ROHC formal notation.
The ROHC WG has developed a header compression framework on top of which various profiles can be defined for different protocol sets or compression requirements.
The ROHC framework was first documented in [RFC3095], together with profiles for compression of RTP/UDP/IP (Real Time Transport Protocol, User Datagram Protocol, Internet Protocol), UDP/IP, IP and ESP/IP (Encapsulating Security Payload) headers.
Additional profiles for compression of IP headers
UDP Lite (User Datagram Protocol Lite) headers [RFC4019] were later specified to complete the initial set of ROHC profiles.
This document defines an updated version for each of the above mentioned profiles, and the definitions depend on the ROHC framework as found in [RFC4995].
The framework is required reading to understand the profile definitions, rules, and their role.
RTP/UDP Lite/IP : profile 0x0107
Each of the profiles above can compress the following type of extension headers:  AH [RFC4302]
[RFC2004]  IPv6 Destination Options header[RFC2460]
IPv6 Hop by hop Options header[RFC2460]
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119
This document is consistent with the terminology found in the ROHC framework [RFC4995] and in the formal notation for ROHC [RFC4997].
In addition, this document uses or defines the following terms:
The Acknowledgment Number identifies what packet is being acknowledged in the RoHCv2 feedback element (See Section 6.9).
The value of this field normally corresponds to the Master Sequence Number (MSN) of the header that was last successfully decompressed, for the compression context (CID) for which the feedback information applies.
A chain of items groups fields based on similar characteristics.
ROHCv2 defines chain items for static, dynamic and irregular fields.
Chaining is achieved by appending an item to the chain for each header in its order of appearance in the uncompressed packet.
Chaining is useful to construct compressed headers from an arbitrary number of any of the protocol headers for which a ROHCv2 profile defines a compressed format.
CRC 3 Control Fields Validation
The CRC 3 control fields validation refers to the validation of the control fields.
This validation is performed by the decompressor when it receives a Compressed (CO) header that contains a 3 bit Cyclic Redundancy Check (CRC) calculated over control fields.
This 3 bit CRC covers controls fields carried in the CO header as well as specific control fields in the context.
In the formal definition of the header formats, this 3 bit CRC is labeled "control crc3" and uses the control crc3 encoding (See also Section 6.6.11).
The delta refers to the difference in the absolute value of a field between two consecutive packets being processed by the same compression endpoint.
The number of packets by which a packet is received late within its sequence due to reordering between the compressor and the decompressor, i.e., reordering between packets associated with the same context (CID).
See the definition of sequentially late packet below.
Header Types ROHCv2 profiles use two different header types: the Initialization and Refresh (IR) header type, and the Compressed (CO) header type.
Sequentially Early Packet A packet that reaches the decompressor before one or several packets that were delayed over the channel, where all of the said packets belong to the same header compressed flow and are associated to the same compression context (CID).
At the time of the arrival of a sequentially early packet, the packet(s) delayed on the link cannot be differentiated from lost packet(s).
Sequentially Late Packet A packet is late within its sequence if it reaches the decompressor after one or several other packets belonging to the same CID have been received, although the sequentially late packet was sent from the compressor before the other packet(s).
How the decompressor detects a sequentially late packet is outside the scope of this specification, but it can for example use the MSN for this purpose.
The timestamp stride (ts stride) is the expected increase in the timestamp value between two RTP packets with consecutive sequence numbers.
For example, for a media encoding with a sample rate of 8 kHz producing one frame every 20 ms, the RTP timestamp will typically increase by n   160
(  8000   0.02), for some integer n. Time Stride (time stride)
The time stride (time stride) is the time interval equivalent to one ts stride, e.g.,
20 ms in the example for the RTP timestamp increment above.
This section lists most acronyms used for reference, in addition to those defined in [RFC4995].
Set of header compression profiles defined in this document.
The RTP header contains an optional list of contributing sources.
Field in the IPv6 header.
Field in the IPv4 header.
Field in the IPv4 header.
UDP Lite User Datagram Protocol Lite.
This section provides background information on the compression profiles defined in this document.
The fundamentals of general header compression and of the ROHC framework may be found in sections 3 and 4 of [RFC4995], respectively.
The fundamentals of the formal notation for ROHC are defined in [RFC4997].
[RFC4224] describes the impacts of out of order delivery on profiles based on [RFC3095].
Classification of Header Fields Section 3.1 of [RFC4995] explains that header compression is possible due to the fact that there is much redundancy between field values within the headers of a packet, especially between the headers of consecutive packets.
Appendix A lists and classifies in detail all the header fields relevant to this document.
The appendix concludes with recommendations on how the various fields should be handled by header compression algorithms.
The main conclusion is that most of the header fields can easily be compressed away since they never or seldom change.
A small number of fields however need more sophisticated mechanisms.
Checksum UDP Lite Checksum Coverage (16 bits) CCov
In particular, for RTP, the analysis in Appendix A reveals that the values of the RTP Timestamp (TS) field usually have a strong correlation to the RTP Sequence Number (SN), which increments by one for each packet emitted by an RTP source.
The RTP M bit is expected to have the same value most of the time, but it needs to be communicated explicitly on occasion.
For UDP, the Checksum field cannot be inferred or recalculated at the receiving end without violating its end to end properties, and is thus sent as is when enabled (mandatory with IPv6).
The same applies to the UDP Lite Checksum (mandatory with both IPv4 and IPv6), while the UDP Lite Checksum Coverage may in some cases be compressible.
For IPv4, a similar correlation as that of the RTP TS to the RTP SN is often observed between the Identifier field (IP ID) and the master sequence number (MSN) used for compression (e.g., the RTP SN when compressing RTP headers).
Improvements of ROHCv2 over RFC 3095 Profiles
The ROHCv2 profiles can achieve compression efficiency and robustness that are both at least equivalent to RFC 3095 profiles [RFC3095], when used under the same operating conditions.
In particular, the size and bit layout of the smallest compressed header
(i.e., PT 0 format U/O 0 in RFC 3095, and pt 0 crc3 in ROHCv2) are identical.
There are a number of differences and improvements between profiles defined in this document and their earlier version defined in RFC 3095.
This section provides an overview of some of the most significant improvements:
Tolerance to reordering Profiles defined in RFC 3095 require that the channel between compressor and decompressor provide in order delivery between compression endpoints.
ROHCv2 profiles, however, can handle robustly and efficiently a limited amount of reordering after the compression point as part of the compression algorithm itself.
In addition, this improved support for reordering makes it possible for ROHCv2 profiles to handle prelink reordering more efficiently.
Operational logic Profiles in RFC 3095 define multiple operational modes, each with different updating logic and compressed header formats.
ROHCv2 profiles operate in unidirectional operation until feedback is first received for a context (CID), at which point bidirectional operation is used; the formats are independent of what operational logic is used.
IP extension header Profiles in RFC 3095 compress IP Extension headers using list compression.
ROHCv2 profiles instead treat extension headers in the same manner as other protocol headers, i.e., using the chaining mechanism; it thus assumes that extension headers are not added or removed during the lifetime of a context (CID), otherwise compression has to be restarted for this flow.
IP encapsulation Profiles in RFC 3095 can compress at most two levels of IP headers.
ROHCv2 profiles can compress an arbitrary number of IP headers.
List compression ROHCv2 profiles do not support reference based list compression.
Robustness and repairs ROHCv2 profiles do not define a format for the IR DYN packet; instead, each profile defines a compressed header that can be used to perform a more robust context repair using a 7 bit CRC verification.
This also implies that only the IR header can change the association between a CID and the profile it uses.
Feedback ROHCv2 profiles mandate a CRC in the format of the FEEDBACK 2, while this is optional in RFC 3095.
A different set of feedback options is also used in ROHCv2 compared to RFC 3095.
Operational Characteristics of ROHCv2 Profiles Robust header compression can be used over different link technologies.
Section 4.4 of [RFC4995] lists the operational characteristics of the ROHC channel.
The ROHCv2 profiles address a wide range of applications, and this section summarizes some of the operational characteristics that are specific to these profiles.
Packet length ROHCv2 profiles assume that the lower layer indicates the length of a compressed packet.
compressed headers do not contain length information for the payload.
Out of order delivery between compression endpoints The definition of the ROHCv2 profiles places no strict requirement on the delivery sequence between the compression endpoints, i.e., packets may be received in a different order than the compressor has sent them and still have a fair probability of being successfully decompressed.
However, frequent out of order delivery and/or significant reordering depth will negatively impact the compression efficiency.
More specifically, if the compressor can operate using a proper estimate of the reordering characteristics of the path between the compression endpoints, larger headers can be sent more often to increase the robustness against decompression failures due to out of order delivery.
Otherwise, the compression efficiency will be impaired from an increase in the frequency of decompression failures and recovery attempts.
Overview of the ROHCv2 Profiles (Informative)
This section provides an overview of concepts that are important and useful to the ROHCv2 profiles.
These concepts may be used as guidelines for implementations but they are not part of the normative definition of the profiles, as these concepts relate to the compression efficiency of the protocol without impacting the interoperability characteristics of an implementation.
Compressor Concepts Header compression can be conceptually characterized as the interaction of a compressor with a decompressor state machine, one per context.
The responsibility of the compressor is to convey the information needed to successfully decompress a packet, based on a certain confidence regarding the state of the decompressor context.
This confidence is obtained from the frequency and the type of information the compressor sends when updating the decompressor context from the optimistic approach (Section 5.1.1), and optionally from feedback messages (See Section 6.9), received from the decompressor.
Optimistic Approach A compressor always uses the optimistic approach when it performs context updates.
The compressor normally repeats the same type of update until it is fairly confident that the decompressor has successfully received the information.
If the decompressor successfully receives any of the headers containing this update, the state will be available for the decompressor to process smaller compressed headers.
If field X in the uncompressed header changes value, the compressor uses a header type that contains an encoding of field X until it has gained confidence that the decompressor has received at least one packet containing the new value for X.
The compressor normally selects a compressed format with the smallest header that can convey the changes needed to achieve confidence.
The number of repetitions that is needed to obtain this confidence is normally related to the packet loss and out of order delivery characteristics of the link where header compression is used; it is thus not defined in this document.
It is outside the scope of this specification and is left to implementors to decide.
Tradeoff between Robustness to Losses and to Reordering The ability of a header compression algorithm to handle sequentially late packets is mainly limited by two factors: the interpretation interval offset of the sliding window used for lsb encoded fields [RFC4997], and the optimistic approach (See Section 5.1.1) for seldom changing fields.
lsb encoded fields: The interpretation interval offset specifies an upper limit for the maximum reordering depth, by which is it possible for the decompressor to recover the original value of a dynamically changing (i.e., sequentially incrementing) field that is encoded using a window based lsb encoding.
Its value is typically bound to the number of lsb compressed bits in the compressed header format, and thus grows with the number of bits transmitted.
However, the offset and the lsb encoding only provide robustness for the field that it compresses, and (implicitly) for other sequentially changing fields that are derived from that field.
where (2^k 1) p is the maximum positive delta, corresponding to the maximum number of consecutive losses for which the lsb encoding can recover the original value of the field; where v ref is the reference value, as defined in the lsb encoding method in [RFC4997].
There is thus a tradeoff between the robustness against reordering and the robustness against packet losses, with respect to the number of MSN bits needed and the distribution of the interpretation interval between negative and positive deltas in the MSN.
The optimistic approach (Section 5.1.1) provides the upper limit for the maximum reordering depth for seldom changing fields.
There is thus a tradeoff between compression efficiency and robustness.
When only information on the MSN needs to be conveyed to the decompressor, the tradeoff relates to the number of compressed MSN bits in the compressed header format.
Otherwise, the tradeoff relates to the implementation of the optimistic approach.
In particular, compressor implementations should adjust their optimistic approach strategy to match both packet loss and reordering characteristics of the link over which header compression is applied.
For example, the number of repetitions for each update of a non lsb encoded field can be increased.
The compressor can ensure that each update is repeated until it is reasonably confident that at least one packet containing the change has reached the decompressor before the first packet sent after this sequence.
Interactions with the Decompressor Context
The compressor normally starts compression with the initial assumption that the decompressor has no useful information to process the new flow, and sends Initialization and Refresh (IR) packets.
Initially, when sending the first IR packet for a compressed flow, the compressor does not expect to receive feedback for that flow, until such feedback is first received.
At this point, the compressor may then assume that the decompressor will continue to send feedback in order to repair its context when necessary.
The former is referred to as unidirectional operation, while the latter is called bidirectional operation.
The compressor can then adjust the compression level (i.e., what header format it selects) based on its confidence that the decompressor has the necessary information to successfully process the compressed headers that it selects.
In other words, the responsibilities of the compressor are to ensure that the decompressor operates with state information that is sufficient to successfully decompress the type of compressed header(s) it receives, and to allow the decompressor to successfully recover that state information as soon as possible otherwise.
The compressor therefore selects the type of compressed header based on the following factors:  the outcome of the encoding method applied to each field;  the optimistic approach, with respect to the characteristics of the channel;  the type of operation (unidirectional or bidirectional), and if in bidirectional operation, feedback received from the decompressor (ACKs, NACKs, STATIC NACK, and options).
Encoding methods normally use previous value(s) from a history of packets whose headers it has previously compressed.
The optimistic approach is meant to ensure that at least one compressed header containing the information to update the state for a field is received.
Finally, feedback indicates what actions the decompressor has taken with respect to its assumptions regarding the validity of its context (Section 5.2.2); it indicates what type of compressed header the decompressor can or cannot decompress.
The decompressor has the means to detect decompression failures for any compressed (CO) header format, using the CRC verification.
Depending on the frequency and/or on the type of the failure, it might send a negative acknowledgement (NACK) or an explicit request for a complete context update (STATIC NACK).
However, the decompressor does not have the means to identify the cause of the failure, and in particular the decompression of what field(s) is responsible for the failure.
The compressor is thus always responsible for determining the most suitable response to a negative acknowledgement, using the confidence it has in the state of the decompressor context, when selecting the type of compressed header it will use when compressing a header.
The decompressor normally uses the last received and successfully validated (IR packets) or verified (CO packets)
header as the reference for future decompression.
The decompressor is responsible for verifying the outcome of every decompression attempt, to update its context when successful, and finally to request context repairs by making coherent usage of feedback once it has started using feedback.
Specifically, the outcome of every decompression attempt is verified using the CRC present in the compressed header; the decompressor updates the context information when this outcome is successfully verified; finally, if the decompressor uses feedback once for a compressed flow, then it will continue to do so for as long as the corresponding context is associated with the same profile.
The decompressor operation may be represented as a state machine defining three states: No Context (NC), Repair Context (RC), and Full Context (FC).
The decompressor starts without a valid context, the NC state.
Upon receiving an IR packet, the decompressor validates the integrity of its header using the CRC 8 validation.
If the IR header is successfully validated, the decompressor updates the context and uses this header as the reference header, and moves to the FC state.
Once the decompressor state machine has entered the FC state, it does not normally leave; only repeated decompression failures will force the decompressor to transit downwards to a lower state.
When context damage is detected, the decompressor moves to the repair context (RC) state, where it stays until it successfully verifies a decompression attempt for a compressed header with a 7 bit CRC or until it successfully validates an IR header.
When static context damage is detected, the decompressor moves back to the NC state.
Below is the state machine for the decompressor.
Details of the transitions between states and decompression logic are given in the sub sections following the figure.
Successful CRC 8 validation for the IR header. !
Unsuccessful CRC 8 validation for the IR header.
Successful CRC verification for the decompression of a CO header, based on the number of CRC bits carried in the CO header. !
Failure to CRC verify the decompression of a CO header carrying a 7 bit CRC.
The decompressor has received a packet type (PT) for which the decompressor's current context does not provide enough valid state information to decompress the packet.
Static Context Damage Detected: See definition in Section 5.2.2.
Context Damage Detected: See definition in Section 5.2.2.
No Context (NC) State Initially, while working in the No Context (NC) state, the decompressor has not yet successfully validated an IR header.
Attempting decompression: In the NC state, only packets carrying sufficient information on the static fields (i.e., IR packets) can be decompressed.
Upward transition: The decompressor can move to the Full Context (FC) state when the CRC validation of an 8 bit CRC in an IR header is successful.
In the NC state, the decompressor should send a STATIC NACK if a packet of a type other than IR is received, or if an IR header has failed the CRC 8 validation, subject to the feedback rate limitation as described in Section 5.2.3.
In the Repair Context (RC) state, the decompressor has successfully decompressed packets for this context, but does not have confidence that the entire context is valid.
Attempting decompression: In the RC state, only headers covered by an 8 bit CRC (i.e., IR) or CO headers carrying a 7 bit CRC can be decompressed.
Upward transition: The decompressor can move to the Full Context (FC) state when the CRC verification succeeds for a CO header carrying a 7 bit CRC or when validation of an 8 bit CRC in an IR header succeeds.
Downward transition: The decompressor moves back to the NC state if it assumes static context damage.
In the RC state, the decompressor should send a STATIC NACK when CRC 8 validation of an IR header fails, or when a CO header carrying a 7 bit CRC fails and static context damage is assumed, subject to the feedback rate limitation as described in Section 5.2.3.
If any other packet type is received, the decompressor should treat it as a CRC verification failure to determine if NACK is to be sent.
In the Full Context (FC) state, the decompressor assumes that its entire context is valid.
Attempting decompression: In the FC state, decompression can be attempted regardless of the type of packet received.
Downward transition: The decompressor moves back to the RC state if it assumes context damage.
If the decompressor assumes static context damage, it moves directly to the NC state.
In the FC state, the decompressor should send a NACK when CRC 8 validation or CRC verification of any header type fails and if context damage is assumed, or it should send a STATIC NACK if static context damage is assumed; this is subject to the feedback rate limitation described in Section 5.2.3.
All header formats carry a CRC and are context updating.
A packet for which the CRC succeeds updates the reference values of all header fields, either explicitly (from the information about a field carried within the compressed header) or implicitly (fields inferred from other fields).
The decompressor may assume that some or the entire context is invalid, when it fails to validate or to verify one or more headers using the CRC.
Because the decompressor cannot know the exact reason(s) for a CRC failure or
what field caused it, the validity of the context hence does not refer to what specific part(s) of the context is deemed valid or not.
Validity of the context rather relates to the detection of a problem with the context.
The decompressor first assumes that the type of information that most likely caused the failure(s) is the state that normally changes for each packet, i.e., context damage of the dynamic part of the context.
Upon repeated decompression failures and unsuccessful repairs, the decompressor then assumes that the entire context, including the static part, needs to be repaired, i.e., static context damage.
Failure to validate the 3 bit CRC that protects control fields should be treated as a decompression failure when the decompressor asserts the validity of its context.
The assumption of context damage means that the decompressor will not attempt decompression of a CO header that carries only a 3 bit CRC, and will only attempt decompression of IR headers or CO headers protected by a CRC 7.
The assumption of static context damage means that the decompressor refrains from attempting decompression of any type of header other than the IR header.
How these assumptions are made, i.e., how context damage is detected, is open to implementations.
It can be based on the residual error rate, where a low error rate makes the decompressor assume damage more often than on a high rate link.
The decompressor implements these assumptions by selecting the type of compressed header for which it will attempt decompression.
In other words, validity of the context refers to the ability of a decompressor to attempt (or not) decompression of specific packet types.
When ROHCv2 profiles are used over a channel that cannot guarantee in order delivery, the decompressor may refrain from updating its context with the content of a sequentially late packet that is successfully decompressed.
This is to avoid updating the context with information that is older than what the decompressor already has in its context.
Feedback Logic ROHCv2 profiles may be used in environments with or without feedback capabilities from decompressor to compressor.
however assumes that if a ROHC feedback channel is available and if this channel is used at least once by the decompressor for a specific context, this channel will be used during the entire compression operation for that context (i.e., bidirectional operation).
The ROHC framework defines 3 types of feedback messages: ACKs, NACKs, and STATIC NACKs.
The semantics of each message is defined in Section 5.2.4.1.
What feedback to send is coupled with the context management of the decompressor, i.e., with the implementation of the context damage detection algorithms as described in Section 5.2.2.
The decompressor should send a NACK when it assumes context damage, and it should send a STATIC NACK when it assumes static context damage.
The decompressor is not strictly expected to send ACK feedback upon successful decompression, other than for the purpose of improving compression efficiency.
When ROHCv2 profiles are used over a channel that cannot guarantee in order delivery, the decompressor may refrain from sending ACK feedback for a sequentially late packet that is successfully decompressed.
The decompressor should limit the rate at which it sends feedback, for both ACKs and STATIC NACK/NACKs, and should avoid sending unnecessary duplicates of the same type of feedback message that may be associated with the same event.
Channel Parameters, Segmentation, and Reordering The compressor MUST NOT use ROHC segmentation (see Section 5.2.5 of [RFC4995]), i.e., the Maximum Reconstructed Reception Unit (MRRU) MUST be set to 0, if the configuration of the ROHC channel contains at least one ROHCv2 profile in the list of supported profiles (i.e., the PROFILES parameter) and if the channel cannot guarantee in order delivery of packets between compression endpoints.
Profile Operation, Per context ROHCv2 profiles operate differently, per context, depending on how the decompressor makes use of the feedback channel, if any.
Once the decompressor uses the feedback channel for a context, it establishes the feedback channel for that CID.
The compressor always starts with the assumption that the decompressor will not send feedback when it initializes a new context (see also the definition of a new context in Section 5.1.1. of [RFC4995], i.e., there is no established feedback channel for the new context.
At this point, despite the use of the optimistic approach, decompression failure is still possible because the decompressor may not have received sufficient information to correctly decompress the packets; therefore, until the decompressor has established a feedback channel, the compressor SHOULD periodically send IR packets.
The periodicity can be based on timeouts, on the number of compressed packets sent for the flow, or any other strategy the implementer chooses.
The reception of either positive feedback (ACKs) or negative feedback (NACKs or STATIC NACKs) from the decompressor establishes the feedback channel for the context (CID) for which the feedback was received.
Once there is an established feedback channel for a specific context, the compressor can make use of this feedback to estimate the current state of the decompressor.
This helps to increase the compression efficiency by providing the information needed for the compressor to achieve the necessary confidence level.
When the feedback channel is established, it becomes superfluous for the compressor to send periodic refreshes, and instead it can rely entirely on the optimistic approach and feedback from the decompressor.
The decompressor MAY send positive feedback (ACKs) to initially establish the feedback channel for a particular flow.
Either positive feedback (ACKs) or negative feedback (NACKs or STATIC NACKs) establishes this channel.
Once it has established a feedback channel for a CID, the decompressor is REQUIRED to continue sending feedback for the lifetime of the context (i.e., until it receives an IR packet that associates the CID to a different profile), to send error recovery requests and (optionally) acknowledgments of significant context updates.
Compression without an established feedback channel will be less efficient, because of the periodic refreshes and the lack of feedback to trigger error recovery; there will also be a slightly higher probability of loss propagation compared to the case where the decompressor uses feedback.
Control Fields ROHCv2 defines a number of control fields that are used by the decompressor in its interpretation of the header formats received from the compressor.
The control fields listed in the following subsections are defined using the formal notation [RFC4997] in Section 6.8.2.4 of this document.
The Master Sequence Number (MSN) field is either taken from a field that already exists in one of the headers of the protocol that the profile compresses (e.g., RTP SN), or alternatively it is created at the compressor.
There is one MSN space per context.
The MSN field has the following two functions:  Differentiating between reference headers when receiving feedback data;  Inferring the value of incrementing fields (e.g., IPv4 Identifier).
There is one MSN field in every ROHCv2 header, i.e., the MSN is always present in each header type sent by the compressor.
The MSN is sent in full in IR headers, while it can be lsb encoded within CO header formats.
The decompressor always includes LSBs of the MSN in the Acknowledgment Number field in feedback (see Section 6.9).
The compressor can later use this field to infer what packet the decompressor is acknowledging.
For profiles for which the MSN is created by the compressor (i.e., 0x0102, 0x0104, and 0x0108), the following applies:  The compressor only initializes the MSN for a context when that context is first created or when the profile associated with a context changes;  When the MSN is initialized, it is initialized to a random value;  The value of the MSN SHOULD be incremented by one for each packet that the compressor sends for a specific CID.
The control field reorder ratio specifies how much reordering is handled by the lsb encoding of the MSN.
This is useful when header compression is performed over links with varying reordering characteristics.
The reorder ratio control field provides the means for the compressor to adjust the robustness characteristics of the lsb encoding method with respect to reordering and consecutive losses, as described in Section 5.1.2.
The IP ID field of the IPv4 header can have different change patterns: sequential in network byte order, sequential byte swapped, random or constant (a constant value of zero, although not conformant with [RFC0791], has been observed in practice).
There is one IP ID behavior control field per IP header.
The control field for the IP ID behavior of the innermost IP header determines which set of header formats is used.
The IP ID behavior control field is also used to determine the contents of the irregular chain item, for each IP header.
ROHCv2 profiles MUST NOT assign a sequential behavior (network byte order or byte swapped) to any IP ID but the one in the innermost IP header when compressing more than one level of IP headers.
This is because only the IP ID of the innermost IP header is likely to have a sufficiently close correlation with the MSN to compress it as a sequentially changing field.
Therefore, a compressor MUST assign either the constant zero IP ID or the random IP ID behavior to tunneling headers.
The control field coverage behavior specifies how the checksum coverage field of the UDP Lite header is compressed with RoHCv2.
It can indicate one of the following encoding methods: irregular, static, or inferred encoding.
The ts stride control field is used in scaled RTP timestamp encoding (see Section 6.6.8).
It defines the expected increase in the RTP timestamp between consecutive RTP sequence numbers.
The time stride control field is used in timer based compression encoding (see Section 6.6.9).
When timer based compression is used, time stride should be set to the expected difference in arrival time between consecutive RTP packets.
CRC 3 for Control Fields ROHCv2 profiles define a CRC 3 calculated over a number of control fields.
This 3 bit CRC protecting the control fields is present in the header format for the co common and co repair header types.
The decompressor MUST always validate the integrity of the control fields covered by this 3 bit CRC when processing a co common or a co repair compressed header.
Failure to validate the control fields using this CRC should be considered as a decompression failure by the decompressor in the algorithm that assesses the validity of the context.
However, if the decompression attempt can be verified using either the CRC 3 or the CRC 7 calculated over the uncompressed header, the decompressor MAY still forward the decompressed header to upper layers.
because the protected control fields are not always used to decompress the header (i.e., co common or co repair) that updates their respective value.
The CRC polynomial and coverage of this CRC 3 is defined in Section 6.6.11.
6.4.  Reconstruction and Verification Validation of the IR header (8 bit CRC)
The decompressor MUST always validate the integrity of the IR header using the 8 bit CRC carried within the IR header.
When the header is validated, the decompressor updates the context with the information in the IR header.
Otherwise, if the IR cannot be validated, the context MUST NOT be updated and the IR header MUST NOT be delivered to upper layers.
Verification of CO headers (3 bit CRC or 7 bit CRC)
The decompressor MUST always verify the decompression of a CO header using the CRC carried within the compressed header.
When the decompression is verified and successful, the decompressor updates the context with the information received in the CO header; otherwise, if the reconstructed header fails the CRC verification, these updates MUST NOT be performed.
A packet for which the decompression attempt cannot be verified using the CRC MUST NOT be delivered to upper layers.
Decompressor implementations may attempt corrective or repair measures on CO headers prior to performing the above actions, and the result of any decompression attempt MUST be verified using the CRC.
Some header types use one or more chains containing sub header information.
The function of a chain is to group fields based on similar characteristics, such as static, dynamic, or irregular fields.
Chaining is done by appending an item for each header to the chain in their order of appearance in the uncompressed packet, starting from the fields in the outermost header.
In the text below, the term <protocol name> is used to identify formal notation names corresponding to different protocol headers.
IPv6 Destination Option RFC 2460
In the formal description of the header formats, this static chain item for each header type is labeled <protocol name
The static chain is only used in the IR header format.
The dynamic chain consists of one item for each header of the chain of protocol headers that is compressed, starting from the outermost IP header.
In the formal description of the header formats, the dynamic chain item for each header type is labeled <protocol name
The dynamic chain is only used in the IR and co repair header formats.
The structure of the irregular chain is analogous to the structure of the static chain.
For each compressed header that uses the general format of Section 6.8, the irregular chain is appended at a specific location in the general format of the compressed headers.
In the formal description of the header formats, the irregular chain item for each header type is a format whose name is suffixed by " irregular".
The irregular chain is used in all CO headers, except for the co repair format.
The format of the irregular chain for the innermost IP header differs from the format used for the outer IP headers, because the innermost IP header is part of the compressed base header.
In the definition of the header formats using the formal notation, the argument "is innermost", which is passed to the corresponding encoding method (ipv4 or ipv6), determines what irregular chain items to use.
The format of the irregular chain item for the outer IP headers is also determined using one flag for TTL/Hop Limit and TOS/TC.
This flag is defined in the format of some of the compressed base headers.
ROHCv2 profiles compress extension headers as other headers, and thus extension headers have a static chain, a dynamic chain, and an irregular chain.
ROHCv2 profiles define chains for all headers that can be compressed, i.e., RTP [RFC3550], UDP [RFC0768], ESP [RFC4303],
UDP Lite [RFC3828], IPv4 [RFC0791], IPv6 [RFC2460], AH [RFC4302], GRE [RFC2784][RFC2890], MINE [RFC2004], IPv6 Destination Options header [RFC2460], IPv6 Hop by
hop Options header [RFC2460], and IPv6 Routing header [RFC2460].
Header Formats and Encoding Methods
The header formats are defined using the ROHC formal notation.
Some of the encoding methods used in the header formats are defined in [RFC4997], while other methods are defined in this section.
The baseheader extension headers encoding method skips over all fields of the extension headers of the innermost IP header, without encoding any of them.
Fields in these extension headers are instead encoded in the irregular chain.
This encoding is used in CO headers (see Section 6.8.2).
The innermost IP header is combined with other header(s) (i.e., UDP, UDP  Lite, RTP) to create the compressed base header.
In this case, there may be a number of extension headers between the IP headers and the other headers.
The base header defines a representation of the extension headers, to comply with the syntax of the formal notation; this encoding method provides this representation.
The baseheader outer headers encoding method skips over all the fields of the extension header(s)
that do not belong to the innermost IP header, without encoding any of them.
Changing fields in outer headers are instead handled by the irregular chain.
This encoding method, similarly to the baseheader extension headers encoding method above, is necessary to keep the definition of the header formats syntactically correct.
It describes tunneling IP headers and their respective extension headers (i.e., all headers located before the innermost IP header) for CO headers (see Section 6.8.2).
The decompressor infers the value of the UDP length field as being the sum of the UDP header length and the UDP payload length.
The compressor must therefore ensure that the UDP length field is consistent with the length field(s) of preceding subheaders, i.e., there must not be any padding after the UDP payload that is covered by the IP Length.
This encoding method is also used for the UDP Lite Checksum Coverage field when it behaves in the same manner as the UDP length field (i.e., when the checksum always covers the entire UDP Lite payload).
inferred ip v4 header checksum
This encoding method compresses the header checksum field of the IPv4 header.
This checksum is defined in RFC 791
A checksum on the header only.
Since some header fields change (e.g., time to live), this is recomputed and verified at each point that the internet header is processed.
The checksum algorithm is: The checksum field is the 16 bit one's complement of the one's complement sum of all 16 bit words in the header.
For purposes of computing the checksum, the value of the checksum field is zero.
As described above, the header checksum protects individual hops from processing a corrupted header.
As the data that this checksum protects is mostly compressed away and is instead taken from state stored in the context, this checksum becomes cumulative to the ROHC CRC.
When using this encoding method, the checksum is recomputed by the decompressor.
The inferred ip v4 header checksum encoding method thus compresses the header checksum field of the IPv4 header down to a size of zero bits, i.e., no bits are transmitted in compressed headers for this field.
Using this encoding method, the decompressor infers the value of this field using the computation above.
The compressor MAY use the header checksum to validate the correctness of the header before compressing it, to avoid processing a corrupted header.
This encoding method compresses the minimal encapsulation header checksum.
This checksum is defined in RFC 2004
The 16 bit one's complement of the one's complement sum of all 16 bit words in the minimal forwarding header.
For purposes of computing the checksum, the value of the checksum field is 0.
The IP header and IP payload (after the minimal forwarding header) are not included in this checksum computation.
The inferred mine header checksum encoding method compresses the minimal encapsulation header checksum down to a size of zero bits
, i.e., no bits are transmitted in compressed headers for this field.
Using this encoding method, the decompressor infers the value of this field using the above computation.
The motivations for inferring this checksum are similar to the ones explained above in Section 6.6.4.
The compressor MAY use the minimal encapsulation header checksum to validate the correctness of the header before compressing it, to avoid processing a corrupted header.
This encoding method compresses the total length field of the IPv4 header.
The total length field of the IPv4 header is defined in RFC 791
Total Length: 16 bits Total Length is the length of the datagram, measured in octets, including internet header and data.
This field allows the length of a datagram to be up to 65,535 octets.
The inferred ip v4 length encoding method compresses the IPv4 header checksum down to a size of zero bits, i.e., no bits are transmitted in compressed headers for this field.
Using this encoding method, the decompressor infers the value of this field by counting in octets the length of the entire packet after decompression.
This encoding method compresses the payload length field in the IPv6 header.
This length field is defined in RFC 2460 [RFC2460] as follows:
Payload Length: 16 bit unsigned integer Length of the IPv6 payload, i.e., the rest of the packet following this IPv6 header, in octets.
(Note that any extension headers present are considered part of the payload, i.e., included in the length count.)
The "inferred ip v6 length" encoding method compresses the payload length field of the IPv6 header down to a size of zero bits, i.e., no bits are transmitted in compressed headers for this field.
Using this encoding method, the decompressor infers the value of this field by counting in octets the length of the entire packet after decompression.
IPv6 headers using the jumbo payload option of RFC 2675 [RFC2675] will not be compressible with this encoding method since the value of the payload length field does not match the length of the packet.
This section provides additional details on encodings used to scale the RTP timestamp, as defined in the formal notation in Section 6.8.2.4.
The RTP timestamp (TS) usually increases by a multiple of the RTP Sequence Number's (SN's) increase and is therefore a suitable candidate for scaled encoding.
This scaling factor is labeled ts stride in the definition of the profile in the formal notation.
The compressor sets the scaling factor based on the change in TS with respect to the change in the RTP SN.
The default value of the scaling factor ts stride is 160, as defined in Section 6.8.2.4.
To use a different value for ts stride, the compressor explicitly updates the value of ts stride to the decompressor using one of the header formats that can carry this information.
When the compressor uses a scaling factor that is different than the default value of ts stride, it can only use the new scaling factor once it has enough confidence that the decompressor has successfully calculated the residue (ts offset) of the scaling function for the timestamp.
The compressor achieves this by sending unscaled timestamp values, to allow the decompressor to establish the residue based on the current ts stride.
The compressor MAY send the unscaled timestamp in the same compressed header(s) used to establish the value of ts stride.
Once the compressor has gained enough confidence that both the value of the scaling factor and the value of the residue have been established in the decompressor, the compressor can start compressing packets using the new scaling factor.
When the compressor detects that the residue (ts offset) value has changed, it MUST NOT select a compressed header format that uses the scaled timestamp encoding before it has re established the residue as described above.
When the value of the timestamp field wraps around, the value of the residue of the scaling function is likely to change.
When this occurs, the compressor re establishes
the new residue value as described above.
If the decompressor receives a compressed header containing scaled timestamp bits while the ts stride equals zero, it MUST NOT deliver the packet to upper layers and it SHOULD treat this as a CRC verification failure.
Whether or not the scaling is applied to the RTP TS field is up to the compressor implementation (i.e., the use of scaling is OPTIONAL), and is indicated by the tsc indicator control field.
In case scaling is applied to the RTP TS field, the value of ts stride used by the compressor is up to the implementation.
A value of ts stride that is set to the expected increase in the RTP timestamp between consecutive unit increases of the RTP SN will provide the most gain for the scaled encoding.
Other values may provide the same gain in some situations, but may reduce the gain in others.
When scaled timestamp encoding is used for header formats that do not transmit any lsb encoded timestamp bits at all, the inferred scaled field encoding of Section 6.6.10 is used for encoding the timestamp.
The timer based compression encoding method, timer based lsb, compresses a field whose change pattern approximates a linear function of the time of day.
This encoding uses the local clock to obtain an approximation of the value that it encodes.
The approximated value is then used as a reference value together with the num lsbs param least significant bits received as the encoded value, where num lsbs param represents a number of bits that is sufficient to uniquely represent the encoded value in the presence of jitter between compression endpoints.
The parameters "num lsbs param" and "offset param" are the parameters to use for the lsb encoding, i.e., the number of least significant bits and the interpretation interval offset, respectively.
The parameter "time stride param" represents the context value of the control field time stride.
This encoding method always uses a scaled version of the field it compresses.
The value of the field is decoded by calculating an approximation of the scaled value, using: tsc ref advanced   tsc ref   (a n a ref) / time stride.
where: tsc ref is a reference value of the scaled representation of the field.
a n is the arrival time associated with the value to decode.
a ref is the arrival time associated with the reference header.
tsc ref advanced is an approximation of the scaled value of the field.
The lsb encoding is then applied using the num lsbs param bits received in the compressed header and the tsc ref advanced as "ref value" (as per Section 4.11.5 of [RFC4997]).
Appendix B.3 provides an example of how the compressor can calculate jitter.
The control field time stride controls whether or not the timer based lsb method is used in the CO header.
The decompressor SHOULD send the CLOCK RESOLUTION option with a zero value, if:
it receives a non zero time stride value, and  it has not previously sent a CLOCK RESOLUTION feedback with a non  zero value.
This is to allow compression to recover from the case where a compressor erroneously activates timer based compression.
The support and usage of timer based compression is OPTIONAL for both the compressor and the decompressor; the compressor is not required to set the time stride control field to a non zero value when it has received a non zero value for the CLOCK RESOLUTION option.
The inferred scaled field encoding method encodes a field that is defined as changing in relation to the MSN, and for which the increase with respect to the MSN can be scaled by some scaling factor.
This encoding method is used in compressed header formats that do not contain any bits for the scaled field.
In this case, the decompressor infers the unscaled value of the scaled field from the MSN field.
The unscaled value is calculated according to the following formula:
msn   stride   reference unscaled value where "delta msn" is the difference in MSN between the reference value of the MSN in the context and the value of the MSN decompressed from this packet, "reference unscaled value" is the value of the field being scaled in the context, and "stride" is the scaling value for this field.
For example, when this encoding method is applied to the RTP timestamp in the RTP profile, the calculation above becomes: timestamp   delta msn
The control crc3 encoding method provides a CRC calculated over a number of control fields.
The definition of this encoding method is the same as for the "crc" encoding method specified in Section 4.11.6 of [RFC4997], with the difference being that the data covered by the CRC is given by a concatenated list of control fields.
In other words, the definition of the control crc3 encoding method is equivalent to the following definition: control crc encoding(ctrl data value, ctrl data length) {
0x07, ctrl data value, ctrl data length)
time stride, 32 bits (only for profiles 0x0101
msn, 16 bits (not applicable for profiles 0x0101, 0x0103, and 0x0107)
coverage behavior, 2 bits padded with 6 MSB of zeroes (only for profiles 0x0107
id behavior, one octet for each IP header in the compressible header chain starting from the outermost header.
Each octet consists of 2 bits
padded with 6 MSBs of zeroes.
The "ctrl data length" binds to the sum of the length of the control field(s) that are applicable to the specific profile.
The decompressor uses the resulting 3 bit CRC to validate the control fields that are updated by the co common and co repair header formats; this CRC cannot be used to verify the outcome of a decompression attempt.
This CRC protects the update of control fields, as the updated values are not always used to decompress the header that carries them and thus are not protected by the CRC 7 verification.
This prevents impairments that could occur if the decompression of a co common or of a co repair succeeds and the decompressor sends positive feedback, while for some reason the control fields are incorrectly updated.
This encoding method is used with a sequential IP ID behavior (sequential or sequential byte swapped) and when there are no coded IP ID bits in the compressed header.
In this case, the IP ID offset from the MSN is constant, and the IP ID increases by the same amount as the MSN (similar to the inferred scaled field encoding method).
The decompressor calculates the value for the IP ID according to the following formula: IP ID   delta msn   reference IP ID value where "delta msn" is the difference between the reference value of the MSN in the context and the uncompressed value of the MSN associated to the compressed header, and where "reference IP ID value" is the value of the IP ID in the context.
For swapped IP ID behavior (i.e., when ip id behavior innermost is set to IP ID BEHAVIOR SEQUENTIAL SWAPPED), "reference IP ID value" and "IP ID" are byte swapped with regard to the corresponding fields in the context.
If the IP ID behavior is random or zero, this encoding method does not update any fields.
This encoding method compresses the list of RTP CSRC identifiers using list compression.
This encoding establishes a content for the different CSRC identifiers (items) and a list describing the order in which they appear.
The compressor passes an argument (cc value) to this encoding method: this is the value of the CC field taken from the RTP header.
The decompressor is required to bind the value of this argument to the number of items in the list, which will allow the decompressor to correctly reconstruct the CC field.
The CSRC identifiers in the uncompressed packet can be represented as an ordered list, whose order and presence are usually constant between packets.
When performing list compression on a CSRC list, each item is the uncompressed value of one CSRC identifier.
The basic principles of list based compression are the following: When initializing the context: 1) The complete representation of the list of CSRC identifiers is transmitted.
Then, once the context has been initialized: 2) When the list is unchanged, a compressed header that does not contain information about the list can be used.
When the list changes, a compressed list is sent in the compressed header, including a representation of its structure and order.
Previously unknown items are sent uncompressed in the list, while previously known items are only represented by an index pointing to the item stored in the context.
The table based item compression compresses individual items sent in compressed lists.
The compressor assigns a unique identifier, "Index", to each item "Item" of a list.
The compressor conceptually maintains an item table containing all items, indexed using "Index".
The (Index, Item) pair is sent together in compressed lists until the compressor gains enough confidence that the decompressor has observed the mapping between items and their respective index.
Confidence is obtained from the reception of an acknowledgment from the decompressor, or by sending (Index, Item) pairs using the optimistic approach.
Once confidence is obtained, the index alone is sent in compressed lists to indicate the presence of the item corresponding to this index.
The compressor MAY reset its item table upon receiving a negative acknowledgement.
The compressor MAY reassign an existing index to a new item by re  establishing the mapping using the procedure described above.
The decompressor conceptually maintains an item table that contains all (Index, Item) pairs received.
The item table is updated whenever an (Index, Item) pair is received and decompression is successful (CRC verification, or CRC 8 validation).
The decompressor retrieves the item from the table whenever an Index is received without an accompanying Item.
If an index is received without an accompanying Item and the decompressor does not have any context for this index, the decompressor MUST NOT deliver the packet to upper layers.
Each item present in a compressed list is represented by:  an Index into the table of items, and a presence bit indicating if a compressed representation of the item is present in the list.
an item (if the presence bit is set).
If the presence bit is not set, the item must already be known by the decompressor.
A compressed list of items uses the following encoding: 0
PS: Indicates size of XI fields:
PS   0 indicates 4 bit XI fields; PS   1 indicates 8 bit XI fields.
: Number of XI item(s) in the compressed list.
Also, the value of the cc value argument of the list csrc encoding (see Section 6.6.13).
Each XI represents one item in the list of items of the uncompressed header, in the same order as they appear in the uncompressed header.
The format of an XI item is as follows: 0
: Indicates whether the item is present in the list:
; X   0 indicates that the item corresponding to the Index is not sent.
Reserved: MUST be set to zero; otherwise, the decompressor MUST discard the packet.
An index into the item table.
When 4 bit XI items are used, the XI items are placed in octets in the following manner: 0
The Padding field MUST be set to zero; otherwise, the decompressor MUST discard the packet.
Each entry in the Item list is the uncompressed representation of one CSRC identifier.
The item table for list compression is limited to 16 different items, since the RTP header can only carry at most 15 simultaneous CSRC identifiers.
The effect of having more than 16 items in the item table will only cause a slight overhead to the compressor when items are swapped in/out of the item table.
Compressed Lists in Dynamic Chain
A compressed list that is part of the dynamic chain must have all of its list items present, i.e., all X bits in the XI list MUST be set.
All items previously established in the item table that are not present in the list decompressed from this packet MUST also be retained in the decompressor context.
Encoding Methods with External Parameters as Arguments
A number of encoding methods in Section 6.8.2.4 have one or more arguments for which the derivation of the parameter's value is outside the scope of the ROHC FN [RFC4997] specification of the header formats.
The following is a list of encoding methods with external parameters as arguments, from Section 6.8.2.4:  udp(profile value, reorder ratio value)
udp lite(profile value, reorder ratio value, coverage behavior value)
esp(profile value, reorder ratio value)
rtp(profile value, ts stride value, time stride value, reorder ratio value)  ipv4(profile value, is innermost, outer ip flag,
ip id behavior value, reorder ratio value))
ipv6(profile value, is innermost, outer ip flag, reorder ratio value))
iponly baseheader(profile value, outer ip flag, ip id behavior value, reorder ratio value)
udp baseheader(profile value, outer ip flag, ip id behavior value, reorder ratio value)
udplite baseheader(profile value, outer ip flag, ip id behavior value, reorder ratio value)
esp baseheader(profile value, outer ip flag, ip id behavior value, reorder ratio value)
baseheader(profile value, ts stride value, time stride value, outer ip flag, ip id behavior value, reorder ratio value)
baseheader(profile value, ts stride value, time stride value, outer ip flag, ip id behavior value, reorder ratio value, coverage behavior value)
The following applies for all parameters listed below: At the compressor, the value of the parameter is set according to the recommendations for each parameter.
At the decompressor, the value of the parameter is set to undefined and will get bound by encoding methods, except where otherwise noted.
The following is a list of external arguments with their respective definition:  profile value:
Set to the 16 bit number that identifies the profile used to compress this packet.
When processing the static chain at the decompressor, this parameter is set to the value of the profile field in the IR header (see Section 6.8.1).
: Set to a 2 bit integer value, using one of the constants whose name begins with the prefix
REORDERING  and as defined in Section 6.8.2.4.
Set to a 2 bit integer value, using one of the constants whose name begins with the prefix IP ID BEHAVIOR  and as defined in Section 6.8.2.4.
Set to a 2 bit integer value, using one of the constants whose name begins with the prefix UDP LITE COVERAGE  and as defined in Section 6.8.2.4.
outer ip flag: This parameter is set to 1 if at least one of the TOS/TC or TTL/Hop Limit fields in outer IP headers has changed compared to their reference values in the context; otherwise, it is set to 0.
This flag may only be set to 1 for the "co common" header format in the different profiles.
is innermost: This boolean flag is set to 1 when processing the innermost of the compressible IP headers; otherwise, it is set to 0.
The value of this parameter should be set to the expected increase in the RTP Timestamp between consecutive RTP sequence numbers.
The value selected is implementation specific.
The value of this parameter should be set to the expected inter arrival time between consecutive packets for the flow.
The value selected is implementation specific.
This parameter MUST be set to zero, unless the compressor has received a feedback message with the CLOCK RESOLUTION option set to a non  zero value.
Header Formats ROHCv2 profiles use two different header types: the Initialization and Refresh (IR) header type, and the Compressed header type (CO).
The CO header type defines a number of header formats: there are two sets of base header formats, with a few additional formats that are common to both sets.
Initialization and Refresh Header Format (IR)
The IR header format uses the structure of the ROHC IR header as defined in Section 5.2.2.1 of [RFC4995].
IR This header format communicates the static part and the dynamic part of the context.
The ROHCv2 IR header has the following format: 0
using the polynomial defined in [RFC4995].
For purposes of computing the CRC, the CRC field is zero.
Design Rationale for Compressed Base Headers
The compressed header formats are defined as two separate sets for each profile: one set for the headers where the innermost IP header contains a sequential IP ID (either network byte order or byte  swapped), and one set for the headers without sequential IP ID (either random, zero, or no IP ID).
There are also a number of common header formats shared between both sets.
In the description below, the naming convention used for header formats that belong to the sequential set is to include "seq" in the name of the format, while similarly "rnd" is used for those that belong to the non  sequential set.
The design of the header formats is derived from the field behavior analysis found in Appendix A.
All of the compressed base headers transmit lsb encoded MSN bits and a CRC.
The following header formats exist for all profiles defined in this document, and are common to both the sequential and the random header format
: This format can be used to update the context when the established change pattern of a dynamic field changes, for any of the dynamic fields.
However, not all dynamic fields are updated by conveying their uncompressed value; some fields can only be transmitted using a compressed representation.
This format is especially useful when a rarely changing field needs to be updated.
This format contains a set of flags to indicate what fields are present in the header, and its size can vary accordingly.
This format is protected by a 7 bit CRC.
It can update control fields, and it thus also carries a 3 bit CRC to protect those fields.
This format is similar in purpose to the UOR 2 extension 3 format of [RFC3095].
: This format can be used to update the context of all the dynamic fields by conveying their uncompressed value.
This is especially useful when context damage is assumed (e.g., from the reception of a NACK) and a context repair is performed.
This format is protected by a 7 bit CRC.
It also carries a 3 bit CRC over the control fields that it can update.
This format is similar in purpose to the IR DYN format of [RFC3095] when performing context repairs.
This format conveys only the MSN; it can therefore only update the MSN and fields that are derived from the MSN, such as IP ID and the RTP Timestamp (for applicable profiles).
It is protected by a 3 bit CRC.
This format is equivalent to the UO 0 header format in [RFC3095].
0 crc7: This format has the same properties as pt 0 crc3, but is instead protected by a 7 bit CRC and contains a larger amount of lsb encoded MSN bits.
This format is useful in environments where a high amount of reordering or a high residual error rate can occur.
The following header format descriptions apply to profiles 0x0101
1 rnd: This format can convey changes to the MSN and to the RTP Marker bit, and it can update the RTP timestamp using scaled timestamp encoding.
It is protected by a 3 bit CRC.
It is similar in purpose to the UO 1 format in [RFC3095].
d: This format can convey changes to the MSN and to the IP ID.
It is protected by a 3 bit CRC.
It is similar in purpose to the UO 1 ID format in [RFC3095].
: This format can convey changes to the MSN and to the RTP Marker bit, and it can update the RTP Timestamp using scaled timestamp encoding.
It is protected by a 3 bit CRC.
It is similar in purpose to the UO 1 TS format in [RFC3095].
2 rnd: This format can convey changes to the MSN, to the RTP Marker bit, and to the RTP Timestamp.
It is protected by a 7 bit CRC.
It is similar in purpose to the UOR 2 format in [RFC3095].
d: This format can convey changes to the MSN and to the IP ID.
It is protected by a 7 bit CRC.
It is similar in purpose to the UO 2 ID format in [RFC3095].
: This format can convey changes to the MSN, to the RTP Marker bit and it can update the RTP Timestamp using scaled timestamp encoding.
It is protected by a 7 bit CRC.
It is similar in purpose to the UO 2 TS format in [RFC3095].
pt 2 seq both: This format can convey changes to both the RTP Timestamp and the IP ID, in addition to the MSN and to the Marker bit.
It is protected by a 7 bit CRC.
It is similar in purpose to the UOR 2 ID extension 1 format in [RFC3095].
The following header format descriptions apply to profiles 0x0102, 0x0103, 0x0104, and 0x0108.
d: This format can convey changes to the MSN and to the IP ID.
It is protected by a 7 bit CRC.
It is similar in purpose to the UO 1 ID format in [RFC3095].
d: This format can convey changes to the MSN and to the IP ID.
It is protected by a 7 bit CRC.
It is similar in purpose to the UO 2 ID format in [RFC3095].
The ROHCv2 co repair header has the following format: 0
A 7 bit CRC over the entire uncompressed header, computed using the crc7 (data value, data length) encoding method defined in Section 6.8.2.4, where data value corresponds to the entire uncompressed header chain and where data length corresponds to the length of this header chain.
r2: MUST be set to zero; otherwise, the decompressor MUST discard the packet.
Encoded using the control crc3 encoding method defined in Section 6.6.11.
The CO header format communicates irregularities in the packet header.
All CO formats carry a CRC and can update the context.
All CO header formats use the general format defined in this section, with the exception of the co repair format, which is defined in Section 6.8.2.2.
The general format for a compressed header is as follows:
if for small CIDs and CID 1 15
The base header in the figure above is the compressed representation of the innermost IP header and other header(s), if any, in the uncompressed packet.
The base header formats are defined in Section 6.8.2.4.
In the formal description of the header formats, the base header for each profile is labeled <profile name> baseheader, where <profile name> is defined in the following table:
Header Formats in ROHC FN
This section defines the complete set of base header formats for ROHCv2 profiles.
The base header formats are defined using the ROHC Formal Notation [RFC4997].
In particular, note that the static and dynamic // chains ordinarily go together.
The uncompressed fields are // defined across these two formats combined, rather than in one // or the other of them.
The irregular chain items are likewise // combined with a baseheader format.
IP ID behavior constants IP ID BEHAVIOR
The value 3 is reserved and cannot be used for coverage behavior //
With UDP LITE PROFILE UDPLITE
ip id fields are for innermost IP header
Encoding method for updating a scaled field and its associated // control fields.
Should be used both when the value is scaled // or unscaled in a compressed format. //
Does not have an uncompressed side.
Nothing } COMPRESSED no scaling { ENFORCE(stride value   0)
ip dest opt { UNCOMPRESSED { next header [ 8 ];
ip hop opt { UNCOMPRESSED { next header [ 8 ];
ip rout opt { UNCOMPRESSED { next header [ 8 ];
UVALUE   1 && checksum and res.
[   4 ]; tos tc
UVALUE   reorder ratio value); ENFORCE(innermost ip.
{ UNCOMPRESSED { ip id [ 16 ];
id seq { ENFORCE((behavior   IP ID BEHAVIOR SEQUENTIAL)
(behavior   IP ID BEHAVIOR SEQUENTIAL SWAPPED)); ENFORCE(ip id offset.
random { ENFORCE(behavior   IP ID BEHAVIOR RANDOM);
} } ip id enc
irreg(behavior) { UNCOMPRESSED { ip id [ 16 ];
ENFORCE(behavior   IP ID BEHAVIOR SEQUENTIAL);
ENFORCE(behavior   IP ID BEHAVIOR SEQUENTIAL SWAPPED)
UVALUE   reorder ratio value); ENFORCE(innermost ip.
PROFILE IP 0104)); ENFORCE(ip id behavior innermost.
} COMPRESSED ipv4 innermost irregular { ENFORCE(is innermost   1); ip i
{ UNCOMPRESSED { ENFORCE((profile value
ENFORCE(profile   PROFILE UDP 0102); ENFORCE(checksum used.
UVALUE   reorder ratio value); ENFORCE(time stride value   time stride.
UVALUE); ENFORCE(ts stride value   ts stride.
coverage behavior value); ENFORCE(reorder ratio.
esp(profile value, reorder ratio value) { UNCOMPRESSED { ENFORCE(profile value   PROFILE ESP 0103);
ENFORCE(behavior   IP ID BEHAVIOR SEQUENTIAL SWAPPED)
UVALUE % 256)   256); ENFORCE(ip id nbo.
ULENGTH   16); ENFORCE(ip id offset.
UNCOMPRESSED { ip id [ 16 ];
} COMPRESSED short { ENFORCE((behavior   IP ID BEHAVIOR SEQUENTIAL)
(behavior   IP ID BEHAVIOR SEQUENTIAL SWAPPED));
(behavior   IP ID BEHAVIOR SEQUENTIAL SWAPPED)); ENFORCE(indicator   1); ENFORCE(ip id offset.
CVALUE   0); ENFORCE(ttl hopl indicator.
CVALUE   0); ENFORCE(tos tc indicator.
CVALUE   0); ENFORCE(time stride indicator.
baseheader(profile value, ts stride value, time stride value, outer ip flag, ip id behavior value, reorder ratio value)
{ UNCOMPRESSED v4 { ENFORCE(msn.
[  16 ]; next header
UVALUE   time stride value); ENFORCE(ts stride.
ts stride value); ENFORCE(reorder ratio.
common { ENFORCE(outer ip flag   outer ip indicator.
[ 3 ]; outer ip indicator : ttl hopl indicator : tos tc indicator :
1 7 flags1 enc(flags1 indicator.
CVALUE, 8) [ 0, 8 ];
( ip id behavior innermost.
pt 1 rnd { ENFORCE(ts stride.
; ENFORCE((ip id behavior innermost.
UVALUE, 5) [ 5 ];
UVALUE, 4) [ 4 ];
1 seq ts { ENFORCE(ts stride.
; ENFORCE((ip id behavior innermost.
IP ID BEHAVIOR SEQUENTIAL SWAPPED))
UOR 2 replacement COMPRESSED pt
2 rnd { ENFORCE(ts stride.
; ENFORCE((ip id behavior innermost.
UOR 2 ID replacement COMPRESSED
; ENFORCE((ip id behavior innermost.
2 seq ts { ENFORCE(ts stride.
; ENFORCE((ip id behavior innermost.
IP ID BEHAVIOR SEQUENTIAL SWAPPED))
IP ID BEHAVIOR RANDOM); outer headers   :
} DEFAULT { ENFORCE(outer ip flag   0);
ip id behavior innermost  :
profile 2 3 4 flags enc( flags indicator.
CVALUE, 8) [ 0, 8 ];
[ 0, 8, 16 ]
UOR 2 ID replacement COMPRESSED
{ UNCOMPRESSED v4 { ENFORCE(msn.
UVALUE % 65536)); ENFORCE(ip id behavior innermost.
IP ID BEHAVIOR RANDOM); outer headers   :
[  16 ]; next header
ip id behavior value); ENFORCE(reorder ratio.
common { ENFORCE(outer ip flag
ip id behavior innermost  :
profile 2 3 4 flags enc( flags indicator.
CVALUE, 8) [ 0, 8 ];
UOR 2 ID replacement COMPRESSED
} DEFAULT { ENFORCE(outer ip flag   0);
common { ENFORCE(outer ip flag   outer ip indicator.
ip id behavior innermost  :
profile 2 3 4 flags enc( flags indicator.
CVALUE, 8) [ 0, 8 ];
[ 0, 8, 16 ]
UOR 2 ID replacement COMPRESSED
baseheader(profile value, ts stride value, time stride value, outer ip flag, ip id behavior value, reorder ratio value, coverage behavior value)
{ UNCOMPRESSED v4 { ENFORCE(msn.
IP ID BEHAVIOR RANDOM); outer headers   :
[  16 ]; next header
UVALUE   time stride value); ENFORCE(ts stride.
coverage behavior value); ENFORCE(reorder ratio.
[ 3 ]; outer ip indicator : ttl hopl indicator : tos tc indicator :
1 7 flags1 enc(flags1 indicator.
CVALUE, 8) [ 0, 8 ];
pt 1 rnd { ENFORCE(ts stride.
; ENFORCE((ip id behavior innermost.
UVALUE, 5) [ 5 ];
UVALUE, 4) [ 4 ];
1 seq ts { ENFORCE(ts stride.
; ENFORCE((ip id behavior innermost.
IP ID BEHAVIOR SEQUENTIAL SWAPPED))
UOR 2 replacement COMPRESSED pt
2 rnd { ENFORCE(ts stride.
; ENFORCE((ip id behavior innermost.
UOR 2 ID replacement COMPRESSED
; ENFORCE((ip id behavior innermost.
2 seq ts { ENFORCE(ts stride.
; ENFORCE((ip id behavior innermost.
IP ID BEHAVIOR SEQUENTIAL SWAPPED))
IP ID BEHAVIOR RANDOM); outer headers   :
[  16 ]; next header
coverage behavior value); ENFORCE(reorder ratio.
CVALUE, 8) [ 0, 8 ];
[ 0, 8, 16 ]
UOR 2 ID replacement COMPRESSED
This section describes the feedback format for ROHCv2 profiles, using the formats described in Section 5.2.3 of [RFC4995].
The Acknowledgment Number field of the feedback formats contains the least significant bits of the MSN (see Section 6.3.1) that corresponds to the reference header that is being acknowledged.
A reference header is a header that has been successfully CRC 8 validated or CRC verified.
If there is no reference header available, the feedback MUST carry an ACKNUMBER NOT VALID option.
The eight least significant bits of the MSN.
A FEEDBACK 1 is an ACK.
In order to send a NACK or a STATIC NACK, FEEDBACK 2 must be used.
STATIC NACK 3 is reserved (MUST NOT be used for parsability)
Acknowledgment Number: The least significant bits of the MSN.
CRC: 8 bit CRC computed over the entire feedback payload including any CID fields but excluding the feedback type, the 'Size' field, and the 'Code' octet, using the polynomial defined in Section 5.3.1.1 of [RFC4995].
If the CID is given with an Add CID octet, the Add CID octet immediately precedes the FEEDBACK 1 or FEEDBACK 2 format.
For purposes of computing the CRC, the CRC field is zero.
A variable number of feedback options, see Section 6.9.2.
Options may appear in any order.
A FEEDBACK 2 of type NACK or STATIC NACK is always implicitly an acknowledgment for a successfully decompressed packet, which corresponds to a packet whose LSBs match the Acknowledgment Number of the feedback element, unless the ACKNUMBER NOT VALID option (see Section 6.9.2.2) appears in the feedback element.
The FEEDBACK 2 format always carries a CRC and is thus more robust than the FEEDBACK 1 format.
When receiving FEEDBACK 2, the compressor MUST verify the information by computing the CRC and comparing the result with the CRC carried in the feedback format.
If the two are not identical, the feedback element MUST be discarded.
A feedback option has variable length and the following general format: 0
Unsigned integer that represents the type of the feedback option.
Section 6.9.2.1 through Section 6.9.2.4
describes the ROHCv2 feedback options.
Unsigned integer that represents the length of the Option Data field, in octets.
Option Data: Feedback type specific data.
if the value of the Opt Len field is set to a non zero value.
The REJECT option informs the compressor that the decompressor does not have sufficient resources to handle the flow. 0
When receiving a REJECT option, the compressor MUST stop compressing the packet flow, and SHOULD refrain from attempting to increase the number of compressed packet flows for some time.
The REJECT option MUST NOT appear more than once in the FEEDBACK 2 format; otherwise, the compressor MUST discard the entire feedback element.
The ACKNUMBER NOT VALID Option
The ACKNUMBER NOT VALID option indicates that the Acknowledgment Number field of the feedback is not valid. 0
A compressor MUST NOT use the Acknowledgment Number of the feedback to find the corresponding sent header when this option is present.
When this option is used, the Acknowledgment Number field of the FEEDBACK 2 format is set to zero.
Consequently, a NACK or a STATIC  NACK feedback type sent with the ACKNUMBER NOT VALID option is equivalent to a STATIC NACK with respect to the type of context repair requested by the decompressor.
The ACKNUMBER NOT VALID option MUST NOT appear more than once in the FEEDBACK 2 format; otherwise, the compressor MUST discard the entire feedback element.
The CONTEXT MEMORY option informs the compressor that the decompressor does not have sufficient memory resources to handle the context of the packet flow, as the flow is currently compressed. 0
When receiving a CONTEXT MEMORY option, the compressor SHOULD take actions to compress the packet flow in a way that requires less decompressor memory resources or stop compressing the packet flow.
The CONTEXT MEMORY option MUST NOT appear more than once in the FEEDBACK 2 format; otherwise, the compressor MUST discard the entire feedback element.
The CLOCK RESOLUTION option informs the compressor of the clock resolution of the decompressor.
It also informs whether or not the decompressor supports timer based compression of the RTP TS timestamp (see Section 6.6.9).
The CLOCK RESOLUTION option is applicable per channel, i.e., it applies to any context associated with a profile for which the option is relevant between a compressor and decompressor pair.
The smallest clock resolution that can be indicated is 1 millisecond.
The value zero has a special meaning: it indicates that the decompressor cannot do timer based compression of the RTP Timestamp.
The CLOCK RESOLUTION option MUST NOT appear more than once in the FEEDBACK 2 format; otherwise, the compressor MUST discard the entire feedback element.
If an option type other than those defined in this document is encountered, the compressor MUST discard the entire feedback element.
Security Considerations Impairments such as bit errors on the received compressed headers, missing packets, and reordering between packets could cause the header decompressor to reconstitute erroneous packets, i.e., packets that do not match the original packet, but still have a valid IP, UDP (or UDP Lite), and RTP headers, and possibly also valid UDP (or UDP  Lite) checksums.
The header compression profiles defined herein use an internal checksum for verification of reconstructed headers.
This reduces the probability that a header decompressor delivers erroneous packets to upper layers without the error being noticed.
In particular, the probability that consecutive erroneous packets are not detected by the internal checksum is close to zero.
This small but non zero probability remains unchanged when integrity protection is applied after compression and verified before decompression, in the case where an attacker could discard or reorder packets between the compression endpoints.
The impairments mentioned above could be caused by a malfunctioning or malicious header compressor.
Such corruption may be detected with end to end integrity mechanisms that will not be affected by the compression.
Moreover, the internal checksum can also be useful in the case of malfunctioning compressors.
Denial of service attacks are possible if an intruder can introduce (for example) bogus IR or FEEDBACK packets onto the link and thereby cause compression efficiency to be reduced.
However, an intruder having the ability to inject arbitrary packets at the link layer in this manner raises additional security issues that dwarf those related to the use of header compression.
The following ROHC profile identifiers have been assigned by the IANA for the profiles defined in this document:
UDP Lite Appendix A.  Detailed Classification of Header Fields Header compression is possible due to the fact that most header fields do not vary randomly from packet to packet.
Many of the fields exhibit static behavior or change in a more or less predictable way.
When designing a header compression scheme, it is of fundamental importance to understand the behavior of the fields in detail.
In this appendix, all fields in the headers compressible by these profiles are classified and analyzed.
The analysis is based on behavior for the types of traffic that are expected to be the most frequently compressed (e.g., RTP field behavior is based on voice and/or video traffic behavior).
Fields are classified as belonging to one of the following classes:
INFERRED These fields contain values that can be inferred from other values, for example the size of the frame carrying the packet, and thus do not have to be included in compressed packets.
These fields are expected to be constant throughout the lifetime of the flow; in general, it is sufficient to design a compressed format so that these fields are only updated by IR packets.
These fields are expected to be constant throughout the lifetime of the flow and their values can be used to define a flow.
They are only sent in IR packets.
These fields are expected to have well known values and therefore do not need to be communicated at all.
These fields are unchanged most of the time.
However, occasionally the value changes but will revert to its original value.
For ROHCv2, the values of such fields do not need to be possible to change with the smallest compressed packet formats, but should be possible to change via slightly larger compressed packets.
These are fields that change their values occasionally and then keep their new values.
For ROHCv2, the values of such fields do not need to be possible to change with the smallest compressed packet formats, but should be possible to change via slightly larger compressed packets.
These are the fields for which no useful change pattern can be identified and should be transmitted uncompressed in all compressed packets.
PATTERN These are fields that change between each packet, but change in a predictable pattern.
The version field states which IP version is used and is set to the value four.
As long as no options are present in the IP header, the header length is constant with the value five.
If there are options, the field could be RACH or STATIC DEF, but only option less headers are compressed by ROHCv2 profiles.
The field is therefore classified as STATIC KNOWN.
For the type of flows compressed by the ROHCv2 profiles, the DSCP (Differentiated Services Code Point) and ECN (Explicit Congestion Notification) fields are expected to change relatively seldom.
Packet Length Information about packet length is expected to be provided by the link layer.
The field is therefore classified as INFERRED.
The Identification field (IP ID) is used to identify what fragments constitute a datagram when reassembling fragmented datagrams.
The IPv4 specification does not specify exactly how this field is to be assigned values, only that each packet should get an IP ID that is unique for the source destination pair and protocol for the time
the datagram (or any of its fragments) could be alive in the network.
This means that assignment of IP ID values can be done in various ways, but the expected behaviors have been separated into four classes.
In this behavior, the IP ID is expected to increment by one for most packets, but may increment by a value larger than one, depending on the behavior of the transmitting IPv4 stack.
When using this behavior, the IP ID behaves as in the Sequential behavior, but the two bytes of IP ID are byte  swapped.
Therefore, the IP ID can be swapped before compression to make it behave exactly as the Sequential behavior.
Some IP stacks assign IP ID values using a pseudo random number generator.
There is thus no correlation between the ID values of subsequent datagrams, and therefore there is no way to predict the IP ID value for the next datagram.
For header compression purposes, this means that the IP ID field needs to be sent uncompressed with each datagram, resulting in two extra octets of header.
This behavior, although not a legal implementation of IPv4, is sometimes seen in existing IPv4 stacks.
When this behavior is used, all IP packets have the IP ID value set to zero.
The Reserved flag must be set to zero and is therefore classified as STATIC KNOWN.
The Don't Fragment (DF) flag changes rarely and is therefore classified as RACH.
Finally, the More Fragments (MF) flag is expected to be zero because IP fragments will not be compressed by ROHC and is therefore classified as STATIC KNOWN.
Under the assumption that no fragmentation occurs, the fragment offset is always zero and is therefore classified as STATIC KNOWN.
To Live The Time To Live field is expected to be constant during the lifetime of a flow or to alternate between a limited number of values due to route changes.
This field will have the same value in all packets of a flow and is therefore classified as STATIC DEF.
The header checksum protects individual hops from processing a corrupted header.
When almost all IP header information is compressed away, there is no point in having this additional checksum; instead, it can be regenerated at the decompressor side.
The field is therefore classified as INFERRED.
Source and Destination addresses These fields are part of the definition of a flow and must thus be constant for all packets in the flow.
The version field states which IP version is used and is set to the value six.
For the type of flows compressed by the ROHCv2 profiles, the DSCP and ECN fields are expected to change relatively seldom.
This field may be used to identify packets belonging to a specific flow.
If it is not used, the value should be set to zero.
Otherwise, all packets belonging to the same flow must have the same value in this field.
The field is therefore classified as STATIC DEF.
Payload Length Information about packet length (and, consequently, payload length) is expected to be provided by the link layer.
The field is therefore classified as INFERRED.
Next Header This field will have the same value in all packets of a flow and is therefore classified as STATIC DEF.
The Hop Limit field is expected to be constant during the lifetime of a flow or to alternate between a limited number of values due to route changes.
Source and Destination addresses These fields are part of the definition of a flow and must thus be constant for all packets in the flow.
The fields are therefore classified as STATIC DEF.
Length Information about packet length is expected to be provided by the link layer.
The field is therefore classified as INFERRED.
The checksum can be optional.
If disabled, its value is constantly zero and can be compressed away.
If enabled, its value depends on the payload, which for compression purposes is equivalent to it changing randomly with every packet.
These fields are part of the definition of a flow and must thus be constant for all packets in the flow.
The Checksum Coverage field may behave in different ways: it may have a value of zero, it may be equal to the datagram length, or it may have any value between eight octets and the length of the datagram.
From a compression perspective, this field is expected to either be entirely predictable (for the cases where it follows the same behavior as the UDP Length field or where it takes on a constant value) or to change randomly for each packet (making the value unpredictable from a header compression perspective).
For all cases, the behavior itself is not expected to change for this field during the lifetime of a packet flow, or to change relatively seldom.
The information used for the calculation of the UDP Lite checksum is governed by the value of the checksum coverage and minimally includes the UDP Lite header.
The checksum is a changing field that must always be sent as is.
This field is expected to have the value two and the field is therefore classified as STATIC KNOWN.
Padding The use of this field is application dependent, but when payload padding is used, it is likely to be present in most or all packets.
The field is classified as RACH to allow for the case where the value of this field changes.
If RTP extensions are used by the application, these extensions are often present in all packets, although the use of extensions is infrequent.
To allow efficient compression of a flow using extensions in only a few packets, this field is classified as RACH.
This field indicates the number of CSRC items present in the CSRC list.
This number is expected to be mostly constant on a packet  to packet basis and when it changes, change by small amounts.
As long as no RTP mixer is used, the value of this field will be zero.
For audio, the marker bit should be set only in the first packet of a talkspurt, while for video, it should be set in the last packet of every picture.
This means that in both cases the RTP marker is classified as SEMISTATIC.
Payload Type Applications could adapt to congestion by changing payload type and/or frame sizes, but that is not expected to happen frequently, so this field is classified as RACH.
The RTP Sequence Number will be incremented by one for each packet sent.
In the audio case: As long as there are no pauses in the audio stream, the RTP Timestamp will be incremented by a constant value, which corresponds to the number of samples in the speech frame.
It will thus mostly follow the RTP Sequence Number.
When there has been a silent period and a new talkspurt begins, the timestamp will jump in proportion to the length of the silent period.
However, the increment will probably be within a relatively limited range.
In the video case: Between two consecutive packets, the timestamp will either be unchanged or increase by a multiple of a fixed value corresponding to the picture clock frequency.
The timestamp can also decrease by a multiple of the fixed value for certain coding schemes.
The change in timestamp value, expressed as a multiple of the picture clock frequency, is in most cases within a limited range.
This field is part of the definition of a flow and must thus be constant for all packets in the flow.
The field is therefore classified as STATIC DEF.
The participants in a session, who are identified by the CSRC fields, are usually expected to be unchanged on a packet to packet basis, but will infrequently change by a few additions and/or removals.
This field is used to identify a distinct flow between two IPsec peers and it changes rarely; therefore, it is classified as STATIC DEF.
The ESP Sequence Number will be incremented by one for each packet sent.
This field will have the same value in all packets of a flow and is therefore classified as STATIC DEF.
Ext Hdr Len For the Routing header, it is expected that the length will remain constant for the duration of the flow, and that a change in the length should be classified as a new flow by the ROHC compressor.
For Hop by hop and Destination options headers, the length is expected to remain static, but can be updated by an IR packet.
Options For the Routing header, it is expected that the option content will remain constant for the duration of the flow, and that a change in the routing information should be classified as a new flow by the ROHC compressor.
For Hop by hop and Destination options headers, the options are expected to remain static, but can be updated by an IR packet.
The four flag bits are not expected to change for the duration of the flow, and the R flag is expected to always be set to zero.
Both of these fields are expected to be set to zero for the duration of any flow.
This field will have the same value in all packets of a flow and is therefore classified as STATIC DEF.
Checksum When the checksum field is present, it is expected to behave unpredictably.
When present, this field is expected to be set to zero.
When present, the Sequence Number increases by one for each packet.
When present, the Key field is used to define the flow and does not change.
This field will have the same value in all packets of a flow and is therefore classified as STATIC DEF.
The S bit is not expected to change during a flow.
Reserved The reserved field is expected to be set to zero.
The header checksum protects individual routing hops from processing a corrupted header.
Since all fields of this header are compressed away, there is no need to include this checksum in compressed packets and it can be regenerated at the decompressor side.
Source and Destination Addresses These fields can be used to define the flow and are not expected to change.
This field will have the same value in all packets of a flow and is therefore classified as STATIC DEF.
It is expected that the length of the header is constant for the duration of the flow.
Reserved The value of this field will be set to zero.
This field is used to identify a specific flow and only changes when the sequence number wraps around, and is therefore classified as STATIC DEF.
The Sequence Number will be incremented by one for each packet sent.
The ICV is expected to behave unpredictably and is therefore classified as IRREGULAR.
Appendix B.  Compressor Implementation Guidelines
This section describes some guiding principles for implementing a ROHCv2 compressor with focus on how to efficiently select appropriate packet formats.
The text in this appendix should be considered guidelines; it does not define any normative requirement on how ROHCv2 profiles are implemented.
The compressor usually maintains a sliding window of reference headers, which contains as many references as needed for the optimistic approach.
Each reference contains a description of which changes occurred in the flow between two consecutive headers in the flow, and a new reference is inserted into the window each time a packet is compressed by this context.
A reference may for example be implemented as a stored copy of the uncompressed header being represented.
When the compressor is confident that a specific reference is no longer used by the decompressor (for example by using the optimistic approach or feedback received), the reference is removed from the sliding window.
Window based LSB Encoding (W LSB) Section 5.1.1
describes how the optimistic approach impacts the packet format selection for the compressor.
Exactly how the compressor selects a packet format is up to the implementation to decide, but the following is an example of how this process can be performed for lsb encoded fields through the use of Window based LSB encoding (W LSB).
With W LSB encoding, the compressor uses a number of references (a window) from its context.
What references to use is determined by its optimistic approach.
The compressor extracts the value of the field to be W LSB encoded from each reference in the window, and finds the maximum and minimum values.
Once it determines these values, the compressor uses the assumption that the decompressor has a value for this field within the range given by these boundaries (inclusively) as its reference.
The compressor can then select a number of LSBs from the value to be compressed, so that the LSBs can be decompressed regardless of whether the decompressor uses the minimum value, the maximum value or any other value in the range of possible references.
W LSB Encoding and Timer based Compression Section
6.6.9 defines decompressor behavior for timer based RTP timestamp compression.
This section gives guidelines on how the compressor should determine the number of LSB bits it should send for the timestamp field.
When using timer based compression, this number depends on the sum of the jitter before the compressor and the jitter between the compressor and decompressor.
The jitter before the compressor can be estimated using the following computation: Max Jitter BC   max { (T n T j)
((a n a j) / time stride) , for all headers j in the sliding window} where (T n T j) is the difference in the timestamp between the currently compressed header and a reference header and (a n a j) is the difference in arrival time between those same two headers.
In addition to this, the compressor needs to estimate an upper bound for the jitter between the compressor and decompressor (Max Jitter CD).
This information may for example come from lower layers.
A compressor implementation can determine whether the difference in clock resolution between the compressor and decompressor induces an error when performing integer arithmetics; it can then treat this error as additional jitter.
After obtaining estimates for the jitters, the number of bits needed to transmit is obtained using the following calculation: ceiling(log2(2
(Max Jitter BC   Max Jitter CD   2)   1))
This number is then used to select a packet format that contains at least this many scaled timestamp bits.
