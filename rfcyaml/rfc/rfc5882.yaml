- contents:
  - '    Generic Application of Bidirectional Forwarding Detection (BFD)

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document describes the generic application of the Bidirectional\n
    \  Forwarding Detection (BFD) protocol.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc5882.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \     1.1. Conventions Used in This Document ..........................3\n   2.
    Overview ........................................................3\n   3. Basic
    Interaction between BFD Sessions and Clients ..............4\n      3.1. Session
    State Hysteresis ...................................4\n      3.2. AdminDown State
    ............................................5\n      3.3. Hitless Establishment/Reestablishment
    of BFD State .........5\n   4. Control Protocol Interactions ...................................6\n
    \     4.1. Adjacency Establishment ....................................6\n      4.2.
    Reaction to BFD Session State Changes ......................7\n           4.2.1.
    Control Protocols with a Single Data Protocol .......7\n           4.2.2. Control
    Protocols with Multiple Data Protocols ......8\n      4.3. Interactions with Graceful
    Restart Mechanisms ..............8\n           4.3.1. BFD Fate Independent of
    the Control Plane ...........9\n           4.3.2. BFD Shares Fate with the Control
    Plane ..............9\n      4.4. Interactions with Multiple Control Protocols
    ..............10\n   5. Interactions with Non-Protocol Functions .......................10\n
    \  6. Data Protocols and Demultiplexing ..............................11\n   7.
    Multiple Link Subnetworks ......................................11\n      7.1.
    Complete Decoupling .......................................12\n      7.2. Layer
    N-1 Hints ...........................................12\n      7.3. Aggregating
    BFD Sessions ..................................12\n      7.4. Combinations of
    Scenarios .................................12\n   8. Other Application Issues
    .......................................13\n   9. Interoperability Issues ........................................13\n
    \  10. Specific Protocol Interactions (Non-Normative) ................13\n      10.1.
    BFD Interactions with OSPFv2, OSPFv3, and IS-IS ..........14\n           10.1.1.
    Session Establishment .............................14\n           10.1.2. Reaction
    to BFD State Changes .....................14\n           10.1.3. OSPF Virtual
    Links ................................15\n      10.2. Interactions with BGP ....................................15\n
    \     10.3. Interactions with RIP ....................................15\n   11.
    Security Considerations .......................................16\n   12. References
    ....................................................16\n      12.1. Normative
    References .....................................16\n      12.2. Informative References
    ...................................16\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The Bidirectional Forwarding Detection [BFD] protocol provides
    a\n   liveness detection mechanism that can be utilized by other network\n   components
    for which their integral liveness mechanisms are either\n   too slow, inappropriate,
    or nonexistent.  Other documents have\n   detailed the use of BFD with specific
    encapsulations ([BFD-1HOP]\n   [BFD-MULTI] [BFD-MPLS]).  As the utility of BFD
    has become\n   understood, there have been calls to specify BFD interactions with
    a\n   growing list of network functions.  Rather than producing a long\n   series
    of short documents on the application of BFD, it seemed\n   worthwhile to describe
    the interactions between BFD and other network\n   functions (\"BFD clients\")
    in a broad way.\n   This document describes the generic application of BFD.  Specific\n
    \  protocol applications are provided for illustrative purposes.\n"
  - contents:
    - "1.1. Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\",
      \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\",
      \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described
      in RFC 2119 [KEYWORDS].\n"
    title: 1.1. Conventions Used in This Document
  title: 1.  Introduction
- contents:
  - "2.  Overview\n   The Bidirectional Forwarding Detection (BFD) specification defines
    a\n   protocol with simple and specific semantics.  Its sole purpose is to\n   verify
    connectivity between a pair of systems, for a particular data\n   protocol across
    a path (which may be of any technology, length, or\n   OSI layer).  The promptness
    of the detection of a path failure can be\n   controlled by trading off protocol
    overhead and system load with\n   detection times.\n   BFD is *not* intended to
    directly provide control protocol liveness\n   information; those protocols have
    their own means and vagaries.\n   Rather, control protocols can use the services
    provided by BFD to\n   inform their operation.  BFD can be viewed as a service
    provided by\n   the layer in which it is running.\n   The service interface with
    BFD is straightforward.  The application\n   supplies session parameters (neighbor
    address, time parameters,\n   protocol options), and BFD provides the session
    state, of which the\n   most interesting transitions are to and from the Up state.
    \ The\n   application is expected to bootstrap the BFD session, as BFD has no\n
    \  discovery mechanism.\n   An implementation SHOULD establish only a single BFD
    session per data\n   protocol path, regardless of the number of applications that
    wish to\n   utilize it.  There is no additional value in having multiple BFD\n
    \  sessions to the same endpoints.  If multiple applications request\n   different
    session parameters, it is a local issue as to how to\n   resolve the parameter
    conflicts.  BFD in turn will notify all\n   applications bound to a session when
    a session state change occurs.\n   BFD should be viewed as having an advisory
    role to the protocol or\n   protocols or other network functions with which it
    is interacting,\n   which will then use their own mechanisms to effect any state\n
    \  transitions.  The interaction is very much at arm's length, which\n   keeps
    things simple and decoupled.  In particular, BFD explicitly\n   does not carry
    application-specific information, partly for\n   architectural reasons and partly
    because BFD may have curious and\n   unpredictable latency characteristics and
    as such makes a poor\n   transport mechanism.\n   It is important to remember
    that the interaction between BFD and its\n   client applications has essentially
    no interoperability issues,\n   because BFD is acting in an advisory nature (similar
    to hardware\n   signaling the loss of light on a fiber optic circuit, for example)\n
    \  and existing mechanisms in the client applications are used in\n   reaction
    to BFD events.  In fact, BFD may interact with only one of a\n   pair of systems
    for a particular client application without any ill\n   effect.\n"
  title: 2.  Overview
- contents:
  - "3.  Basic Interaction between BFD Sessions and Clients\n   The interaction between
    a BFD session and its associated client\n   applications is, for the most part,
    an implementation issue that is\n   outside the scope of this specification.  However,
    it is useful to\n   describe some mechanisms that implementors may use in order
    to\n   promote full-featured implementations.  One way of modeling this\n   interaction
    is to create an adaptation layer between the BFD state\n   machine and the client
    applications.  The adaptation layer is\n   cognizant of both the internals of
    the BFD implementation and the\n   requirements of the clients.\n"
  - contents:
    - "3.1.  Session State Hysteresis\n   A BFD session can be tightly coupled to
      its client applications;  for\n   example, any transition out of the Up state
      could cause signaling to\n   the clients to take failure action.  However, in
      some cases, this may\n   not always be the best course of action.\n   Implementors
      may choose to hide rapid Up/Down/Up transitions of the\n   BFD session from
      its clients.  This is useful in order to support\n   process restarts without
      necessitating complex protocol mechanisms,\n   for example.\n   As such, a system
      MAY choose not to notify clients if a BFD session\n   transitions from Up to
      Down state, and returns to Up state, if it\n   does so within a reasonable period
      of time (the length of which is\n   outside the scope of this specification).
      \ If the BFD session does\n   not return to Up state within that time frame,
      the clients SHOULD be\n   notified that a session failure has occurred.\n"
    title: 3.1.  Session State Hysteresis
  - contents:
    - "3.2.  AdminDown State\n   The AdminDown mechanism in BFD is intended to signal
      that the BFD\n   session is being taken down for administrative purposes, and
      the\n   session state is not indicative of the liveness of the data path.\n
      \  Therefore, a system SHOULD NOT indicate a connectivity failure to a\n   client
      if either the local session state or the remote session state\n   (if known)
      transitions to AdminDown, so long as that client has\n   independent means of
      liveness detection (typically, control\n   protocols).\n   If a client does
      not have any independent means of liveness\n   detection, a system SHOULD indicate
      a connectivity failure to a\n   client, and assume the semantics of Down state,
      if either the local\n   or remote session state transitions to AdminDown.  Otherwise,
      the\n   client will not be able to determine whether the path is viable, and\n
      \  unfortunate results may occur.\n"
    title: 3.2.  AdminDown State
  - contents:
    - "3.3.  Hitless Establishment/Reestablishment of BFD State\n   It is useful to
      be able to configure a BFD session between a pair of\n   systems without impacting
      the state of any clients that will be\n   associated with that session.  Similarly,
      it is useful for BFD state\n   to be reestablished without perturbing associated
      clients when all\n   BFD state is lost (such as in process restart situations).
      \ This\n   interacts with the clients' ability to establish their state\n   independent
      of BFD.\n   The BFD state machine transitions that occur in the process of\n
      \  bringing up a BFD session in such situations SHOULD NOT cause a\n   connectivity
      failure notification to the clients.\n   A client that is capable of establishing
      its state prior to the\n   configuration or restarting of a BFD session MAY
      do so if\n   appropriate.  The means to do so is outside of the scope of this\n
      \  specification.\n"
    title: 3.3.  Hitless Establishment/Reestablishment of BFD State
  title: 3.  Basic Interaction between BFD Sessions and Clients
- contents:
  - "4.  Control Protocol Interactions\n   Very common client applications of BFD
    are control protocols, such as\n   routing protocols.  The object, when BFD interacts
    with a control\n   protocol, is to advise the control protocol of the connectivity
    of\n   the data protocol.  In the case of routing protocols, for example,\n   this
    allows the connectivity failure to trigger the rerouting of\n   traffic around
    the failed path more quickly than the native detection\n   mechanisms.\n"
  - contents:
    - "4.1.  Adjacency Establishment\n   If the session state on either the local
      or remote system (if known)\n   is AdminDown, BFD has been administratively
      disabled, and the\n   establishment of a control protocol adjacency MUST be
      allowed.\n   BFD sessions are typically bootstrapped by the control protocol,\n
      \  using the mechanism (discovery, configuration) used by the control\n   protocol
      to find neighbors.  Note that it is possible in some failure\n   scenarios for
      the network to be in a state such that the control\n   protocol is capable of
      coming up, but the BFD session cannot be\n   established, and, more particularly,
      data cannot be forwarded.  To\n   avoid this situation, it would be beneficial
      not to allow the control\n   protocol to establish a neighbor adjacency.  However,
      this would\n   preclude the operation of the control protocol in an environment
      in\n   which not all systems support BFD.\n   Therefore, the establishment of
      control protocol adjacencies SHOULD\n   be blocked if both systems are willing
      to establish a BFD session but\n   a BFD session cannot be established.  One
      method for determining that\n   both systems are willing to establish a BFD
      session is if the control\n   protocol carries explicit signaling of this fact.
      \ If there is no\n   explicit signaling, the willingness to establish a BFD
      session may be\n   determined by means outside the scope of this specification.\n
      \  If it is believed that the neighboring system does not support BFD,\n   the
      establishment of a control protocol adjacency SHOULD NOT be\n   blocked.\n   The
      setting of BFD's various timing parameters and modes are not\n   subject to
      standardization.  Note that all protocols sharing a\n   session will operate
      using the same parameters.  The mechanism for\n   choosing the parameters among
      those desired by the various protocols\n   is outside the scope of this specification.
      \ It is generally useful\n   to choose the parameters resulting in the shortest
      Detection Time; a\n   particular client application can always apply hysteresis
      to the\n   notifications from BFD if it desires longer Detection Times.\n   Note
      that many control protocols assume full connectivity between all\n   systems
      on multiaccess media such as LANs.  If BFD is running on only\n   a subset of
      systems on such a network, and adjacency establishment is\n   blocked by the
      absence of a BFD session, the assumptions of the\n   control protocol may be
      violated, with unpredictable results.\n"
    title: 4.1.  Adjacency Establishment
  - contents:
    - "4.2.  Reaction to BFD Session State Changes\n   If a BFD session transitions
      from Up state to AdminDown, or the\n   session transitions from Up to Down because
      the remote system is\n   indicating that the session is in state AdminDown,
      clients SHOULD NOT\n   take any control protocol action.\n   For other transitions
      from Up to Down state, the mechanism by which\n   the control protocol reacts
      to a path failure signaled by BFD depends\n   on the capabilities of the protocol,
      as specified in the following\n   subsections.\n"
    - contents:
      - "4.2.1.  Control Protocols with a Single Data Protocol\n   A control protocol
        that is tightly bound to a single failing data\n   protocol SHOULD take action
        to ensure that data traffic is no longer\n   directed to the failing path.
        \ Note that this should not be\n   interpreted as BFD replacing the control
        protocol liveness mechanism,\n   if any, as the control protocol may rely
        on mechanisms not verified\n   by BFD (multicast, for instance) so BFD most
        likely cannot detect all\n   failures that would impact the control protocol.
        \ However, a control\n   protocol MAY choose to use BFD session state information
        to more\n   rapidly detect an impending control protocol failure, particularly
        if\n   the control protocol operates in-band (over the data protocol).\n   Therefore,
        when a BFD session transitions from Up to Down, action\n   SHOULD be taken
        in the control protocol to signal the lack of\n   connectivity for the path
        over which BFD is running.  If the control\n   protocol has an explicit mechanism
        for announcing path state, a\n   system SHOULD use that mechanism rather than
        impacting the\n   connectivity of the control protocol, particularly if the
        control\n   protocol operates out-of-band from the failed data protocol.\n
        \  However, if such a mechanism is not available, a control protocol\n   timeout
        SHOULD be emulated for the associated neighbor.\n"
      title: 4.2.1.  Control Protocols with a Single Data Protocol
    - contents:
      - "4.2.2.  Control Protocols with Multiple Data Protocols\n   Slightly different
        mechanisms are used if the control protocol\n   supports the routing of multiple
        data protocols, depending on whether\n   the control protocol supports separate
        topologies for each data\n   protocol.\n"
      - contents:
        - "4.2.2.1.  Shared Topologies\n   With a shared topology, if one of the data
          protocols fails (as\n   signaled by the associated BFD session), it is necessary
          to consider\n   the path to have failed for all data protocols.  Otherwise,
          there is\n   no way for the control protocol to turn away traffic for the
          failed\n   data protocol (and such traffic would be black-holed indefinitely).\n
          \  Therefore, when a BFD session transitions from Up to Down, action\n   SHOULD
          be taken in the control protocol to signal the lack of\n   connectivity
          for the path in the topology corresponding to the BFD\n   session.  If this
          cannot be signaled otherwise, a control protocol\n   timeout SHOULD be emulated
          for the associated neighbor.\n"
        title: 4.2.2.1.  Shared Topologies
      - contents:
        - "4.2.2.2.  Independent Topologies\n   With individual routing topologies
          for each data protocol, only the\n   failed data protocol needs to be rerouted
          around the failed path.\n   Therefore, when a BFD session transitions from
          Up to Down, action\n   SHOULD be taken in the control protocol to signal
          the lack of\n   connectivity for the path in the topology over which BFD
          is running.\n   Generally, this can be done without impacting the connectivity
          of\n   other topologies (since otherwise it is very difficult to support\n
          \  separate topologies for multiple data protocols).\n"
        title: 4.2.2.2.  Independent Topologies
      title: 4.2.2.  Control Protocols with Multiple Data Protocols
    title: 4.2.  Reaction to BFD Session State Changes
  - contents:
    - "4.3.  Interactions with Graceful Restart Mechanisms\n   A number of control
      protocols support Graceful Restart mechanisms,\n   including IS-IS [ISIS-GRACE],
      OSPF [OSPF-GRACE], and BGP [BGP-GRACE].\n   These mechanisms are designed to
      allow a control protocol to restart\n   without perturbing network connectivity
      state (lest it appear that\n   the system and/or all of its links had failed).
      \ They are predicated\n   on the existence of a separate forwarding plane that
      does not\n   necessarily share fate with the control plane in which the routing\n
      \  protocols operate.  In particular, the assumption is that the\n   forwarding
      plane can continue to function while the protocols restart\n   and sort things
      out.\n   BFD implementations announce via the Control Plane Independent \"C\"\n
      \  bit whether or not BFD shares fate with the control plane.  This\n   information
      is used to determine the actions to be taken in\n   conjunction with Graceful
      Restart.  If BFD does not share its fate\n   with the control plane on either
      system, it can be used to determine\n   whether Graceful Restart in a control
      protocol is NOT viable (the\n   forwarding plane is not operating).\n   If the
      control protocol has a Graceful Restart mechanism, BFD may be\n   used in conjunction
      with this mechanism.  The interaction between BFD\n   and the control protocol
      depends on the capabilities of the control\n   protocol and whether or not BFD
      shares fate with the control plane.\n   In particular, it may be desirable for
      a BFD session failure to abort\n   the Graceful Restart process and allow the
      failure to be visible to\n   the network.\n"
    - contents:
      - "4.3.1.  BFD Fate Independent of the Control Plane\n   If BFD is implemented
        in the forwarding plane and does not share fate\n   with the control plane
        on either system (the \"C\" bit is set in the\n   BFD Control packets in both
        directions), control protocol restarts\n   should not affect the BFD session.
        \ In this case, a BFD session\n   failure implies that data can no longer
        be forwarded, so any Graceful\n   Restart in progress at the time of the BFD
        session failure SHOULD be\n   aborted in order to avoid black holes, and a
        topology change SHOULD\n   be signaled in the control protocol.\n"
      title: 4.3.1.  BFD Fate Independent of the Control Plane
    - contents:
      - "4.3.2.  BFD Shares Fate with the Control Plane\n   If BFD shares fate with
        the control plane on either system (the \"C\"\n   bit is clear in either direction),
        a BFD session failure cannot be\n   disentangled from other events taking
        place in the control plane.  In\n   many cases, the BFD session will fail
        as a side effect of the restart\n   taking place.  As such, it would be best
        to avoid aborting any\n   Graceful Restart taking place, if possible (since
        otherwise BFD and\n   Graceful Restart cannot coexist).\n   There is some
        risk in doing so, since a simultaneous failure or\n   restart of the forwarding
        plane will not be detected, but this is\n   always an issue when BFD shares
        fate with the control plane.\n"
      - contents:
        - "4.3.2.1.  Control Protocols with Planned Restart Signaling\n   Some control
          protocols can signal a planned restart prior to the\n   restart taking place.
          \ In this case, if a BFD session failure occurs\n   during the restart,
          such a planned restart SHOULD NOT be aborted and\n   the session failure
          SHOULD NOT result in a topology change being\n   signaled in the control
          protocol.\n"
        title: 4.3.2.1.  Control Protocols with Planned Restart Signaling
      - contents:
        - "4.3.2.2.  Control Protocols without Planned Restart Signaling\n   Control
          protocols that cannot signal a planned restart depend on the\n   recently
          restarted system to signal the Graceful Restart prior to the\n   control
          protocol adjacency timeout.  In most cases, whether the\n   restart is planned
          or unplanned, it is likely that the BFD session\n   will time out prior
          to the onset of Graceful Restart, in which case a\n   topology change SHOULD
          be signaled in the control protocol as\n   specified in Section 3.2.\n   However,
          if the restart is in fact planned, an implementation MAY\n   adjust the
          BFD session timing parameters prior to restarting in such\n   a way that
          the Detection Time in each direction is longer than the\n   restart period
          of the control protocol, providing the restarting\n   system the same opportunity
          to enter Graceful Restart as it would\n   have without BFD.  The restarting
          system SHOULD NOT send any BFD\n   Control packets until there is a high
          likelihood that its neighbors\n   know a Graceful Restart is taking place,
          as the first BFD Control\n   packet will cause the BFD session to fail.\n"
        title: 4.3.2.2.  Control Protocols without Planned Restart Signaling
      title: 4.3.2.  BFD Shares Fate with the Control Plane
    title: 4.3.  Interactions with Graceful Restart Mechanisms
  - contents:
    - "4.4.  Interactions with Multiple Control Protocols\n   If multiple control
      protocols wish to establish BFD sessions with the\n   same remote system for
      the same data protocol, all MUST share a\n   single BFD session.\n   If hierarchical
      or dependent layers of control protocols are in use\n   (say, OSPF and Internal
      BGP (IBGP)), it may not be useful for more\n   than one of them to interact
      with BFD.  In this example, because IBGP\n   is dependent on OSPF for its routing
      information, the faster failure\n   detection relayed to IBGP may actually be
      detrimental.  The cost of a\n   peer state transition is high in BGP, and OSPF
      will naturally heal\n   the path through the network if it were to receive the
      failure\n   detection.\n   In general, it is best for the protocol at the lowest
      point in the\n   hierarchy to interact with BFD, and then to use existing interactions\n
      \  between the control protocols to effect changes as necessary.  This\n   will
      provide the fastest possible failure detection and recovery in a\n   network.\n"
    title: 4.4.  Interactions with Multiple Control Protocols
  title: 4.  Control Protocol Interactions
- contents:
  - "5.  Interactions with Non-Protocol Functions\n   BFD session status may be used
    to affect other system functions that\n   are not protocol based (for example,
    static routes).  If the path to\n   a remote system fails, it may be desirable
    to avoid passing traffic\n   to that remote system, so the local system may wish
    to take internal\n   measures to accomplish this (such as withdrawing a static
    route and\n   withdrawing that route from routing protocols).\n   If it is known,
    or presumed, that the remote system is BFD capable\n   and the BFD session is
    not in Up state, appropriate action SHOULD be\n   taken (such as withdrawing a
    static route).\n   If it is known, or presumed, that the remote system does not
    support\n   BFD, action such as withdrawing a static route SHOULD NOT be taken.\n
    \  Bootstrapping of the BFD session in the non-protocol case is likely\n   to
    be derived from configuration information.\n   There is no need to exchange endpoints
    or discriminator values via\n   any mechanism other than configuration (via Operational
    Support\n   Systems or any other means) as the endpoints must be known and\n   configured
    by the same means.\n"
  title: 5.  Interactions with Non-Protocol Functions
- contents:
  - "6.  Data Protocols and Demultiplexing\n   BFD is intended to protect a single
    \"data protocol\" and is\n   encapsulated within that protocol.  A pair of systems
    may have\n   multiple BFD sessions over the same topology if they support (and
    are\n   encapsulated by) different protocols.  For example, if two systems\n   have
    IPv4 and IPv6 running across the same link between them, these\n   are considered
    two separate paths and require two separate BFD\n   sessions.\n   This same technique
    is used for more fine-grained paths.  For\n   example, if multiple differentiated
    services [DIFFSERV] are being\n   operated over IPv4, an independent BFD session
    may be run for each\n   service level.  The BFD Control packets must be marked
    in the same\n   way as the data packets, partly to ensure as much fate sharing
    as\n   possible between BFD and data traffic, and also to demultiplex the\n   initial
    packet if the discriminator values have not been exchanged.\n"
  title: 6.  Data Protocols and Demultiplexing
- contents:
  - "7.  Multiple Link Subnetworks\n   A number of technologies exist for aggregating
    multiple parallel\n   links at layer N-1 and treating them as a single link at
    layer N.\n   BFD may be used in a number of ways to protect the path at layer
    N.\n   The exact mechanism used is outside the scope of this specification.\n
    \  However, this section provides examples of some possible deployment\n   scenarios.
    \ Other scenarios are possible and are not precluded.\n"
  - contents:
    - "7.1.  Complete Decoupling\n   The simplest approach is to simply run BFD over
      the layer N path,\n   with no interaction with the layer N-1 mechanisms.  Doing
      so assumes\n   that the layer N-1 mechanism will deal with connectivity issues
      in\n   individual layer N-1 links.  BFD will declare a failure in the layer\n
      \  N path only when the session times out.\n   This approach will work whether
      or not the layer N-1 neighbor is the\n   same as the layer N neighbor.\n"
    title: 7.1.  Complete Decoupling
  - contents:
    - "7.2.  Layer N-1 Hints\n   A slightly more intelligent approach than complete
      decoupling is to\n   have the layer N-1 mechanism inform the layer N BFD when
      the\n   aggregated link is no longer viable.  In this case, the BFD session\n
      \  will detect the failure more rapidly, as it need not wait for the\n   session
      to time out.  This is analogous to triggering a session\n   failure based on
      the hardware-detected failure of a single link.\n   This approach will also
      work whether or not the layer N-1 neighbor is\n   the same as the layer N neighbor.\n"
    title: 7.2.  Layer N-1 Hints
  - contents:
    - "7.3.  Aggregating BFD Sessions\n   Another approach would be to use BFD on
      each layer N-1 link and to\n   aggregate the state of the multiple sessions
      into a single indication\n   to the layer N clients.  This approach has the
      advantage that it is\n   independent of the layer N-1 technology.  However,
      this approach only\n   works if the layer N neighbor is the same as the layer
      N-1 neighbor\n   (a single hop at layer N-1).\n"
    title: 7.3.  Aggregating BFD Sessions
  - contents:
    - "7.4.  Combinations of Scenarios\n   Combinations of more than one of the scenarios
      listed above (or\n   others) may be useful in some cases.  For example, if the
      layer N\n   neighbor is not directly connected at layer N-1, a system might
      run a\n   BFD session across each layer N-1 link to the immediate layer N-1\n
      \  neighbor and then run another BFD session to the layer N neighbor.\n   The
      aggregate state of the layer N-1 BFD sessions could be used to\n   trigger a
      layer N BFD session failure.\n"
    title: 7.4.  Combinations of Scenarios
  title: 7.  Multiple Link Subnetworks
- contents:
  - "8.  Other Application Issues\n   BFD can provide liveness detection for functions
    related to\n   Operations, Administration, and Maintenance (OAM) in tunneling
    and\n   pseudowire protocols.  Running BFD inside the tunnel is recommended,\n
    \  as it exercises more aspects of the path.  One way to accommodate\n   this
    is to address BFD packets based on the tunnel endpoints,\n   assuming that they
    are numbered.\n   If a planned outage is to take place on a path over which BFD
    is run,\n   it is preferable to take down the BFD session by going into AdminDown\n
    \  state prior to the outage.  The system asserting AdminDown SHOULD do\n   so
    for at least one Detection Time in order to ensure that the remote\n   system
    is aware of it.\n   Similarly, if BFD is to be deconfigured from a system, it
    is\n   desirable not to trigger any client application action.  Simply\n   ceasing
    the transmission of BFD Control packets will cause the remote\n   system to detect
    a session failure.  In order to avoid this, the\n   system on which BFD is being
    deconfigured SHOULD put the session into\n   AdminDown state and maintain this
    state for a Detection Time to\n   ensure that the remote system is aware of it.\n"
  title: 8.  Other Application Issues
- contents:
  - "9.  Interoperability Issues\n   The BFD protocol itself is designed so that it
    will always\n   interoperate at a basic level; asynchronous mode is mandatory
    and is\n   always available, and other modes and functions are negotiated at run\n
    \  time.  Since the service provided by BFD is identical regardless of\n   the
    variants used, the particular choice of BFD options has no\n   bearing on interoperability.\n
    \  The interaction between BFD and other protocols and control functions\n   is
    very loosely coupled.  The actions taken are based on existing\n   mechanisms
    in those protocols and functions, so interoperability\n   problems are very unlikely
    unless BFD is applied in contradictory\n   ways (such as a BFD session failure
    causing one implementation to go\n   down and another implementation to come up).
    \ In fact, BFD may be\n   advising one system for a particular control function
    but not the\n   other; the only impact of this would be potentially asymmetric\n
    \  control protocol failure detection.\n"
  title: 9.  Interoperability Issues
- contents:
  - "10.  Specific Protocol Interactions (Non-Normative)\n   As noted above, there
    are no interoperability concerns regarding\n   interactions between BFD and control
    protocols.  However, there is\n   enough concern and confusion in this area so
    that it is worthwhile to\n   provide examples of interactions with specific protocols.\n
    \  Since the interactions do not affect interoperability, they are non-\n   normative.\n"
  - contents:
    - "10.1.  BFD Interactions with OSPFv2, OSPFv3, and IS-IS\n   The two versions
      of OSPF ([OSPFv2] and [OSPFv3]), as well as IS-IS\n   [ISIS], all suffer from
      an architectural limitation, namely that\n   their Hello protocols are limited
      in the granularity of their failure\n   detection times.  In particular, OSPF
      has a minimum detection time of\n   two seconds, and IS-IS has a minimum detection
      time of one second.\n   BFD may be used to achieve arbitrarily small detection
      times for\n   these protocols by supplementing the Hello protocols used in each\n
      \  case.\n"
    - contents:
      - "10.1.1.  Session Establishment\n   The most obvious choice for triggering
        BFD session establishment with\n   these protocols would be to use the discovery
        mechanism inherent in\n   the Hello protocols in OSPF and IS-IS to bootstrap
        the establishment\n   of the BFD session.  Any BFD sessions established to
        support OSPF and\n   IS-IS across a single IP hop must operate in accordance
        with\n   [BFD-1HOP].\n"
      title: 10.1.1.  Session Establishment
    - contents:
      - "10.1.2.  Reaction to BFD State Changes\n   The basic mechanisms are covered
        in Section 3 above.  At this time,\n   OSPFv2 and OSPFv3 carry routing information
        for a single data\n   protocol (IPv4 and IPv6, respectively) so when it is
        desired to\n   signal a topology change after a BFD session failure, this
        should be\n   done by tearing down the corresponding OSPF neighbor.\n   IS-IS
        may be used to support only one data protocol, or multiple data\n   protocols.
        \ [ISIS] specifies a common topology for multiple data\n   protocols, but
        work is under way to support multiple topologies.  If\n   multiple topologies
        are used to support multiple data protocols (or\n   multiple classes of service
        of the same data protocol), the topology-\n   specific path associated with
        a failing BFD session should no longer\n   be advertised in IS-IS Label Switched
        Paths (LSPs) in order to signal\n   a lack of connectivity.  Otherwise, a
        failing BFD session should be\n   signaled by simulating an IS-IS adjacency
        failure.\n   OSPF has a planned restart signaling mechanism, whereas IS-IS
        does\n   not.  The appropriate mechanisms outlined in Section 3.3 should be\n
        \  used.\n"
      title: 10.1.2.  Reaction to BFD State Changes
    - contents:
      - "10.1.3.  OSPF Virtual Links\n   If it is desired to use BFD for failure detection
        of OSPF Virtual\n   Links, the mechanism described in [BFD-MULTI] MUST be
        used, since\n   OSPF Virtual Links may traverse an arbitrary number of hops.
        \ BFD\n   authentication SHOULD be used and is strongly encouraged.\n"
      title: 10.1.3.  OSPF Virtual Links
    title: 10.1.  BFD Interactions with OSPFv2, OSPFv3, and IS-IS
  - contents:
    - "10.2.  Interactions with BGP\n   BFD may be useful with External Border Gateway
      Protocol (EBGP)\n   sessions [BGP] in order to more rapidly trigger topology
      changes in\n   the face of path failure.  As noted in Section 4.4, it is generally\n
      \  unwise for IBGP sessions to interact with BFD if the underlying IGP\n   is
      already doing so.\n   EBGP sessions being advised by BFD may establish either
      a one-hop\n   [BFD-1HOP] or a multihop [BFD-MULTI] session, depending on whether
      or\n   not the neighbor is immediately adjacent.  The BFD session should be\n
      \  established to the BGP neighbor (as opposed to any other Next Hop\n   advertised
      in BGP).  BFD authentication SHOULD be used and is\n   strongly encouraged.\n
      \  [BGP-GRACE] describes a Graceful Restart mechanism for BGP.  If\n   Graceful
      Restart is not taking place on an EBGP session, and the\n   corresponding BFD
      session fails, the EBGP session should be torn down\n   in accordance with Section
      3.2.  If Graceful Restart is taking place,\n   the basic procedures in Section
      4.3 apply.  BGP Graceful Restart does\n   not signal planned restarts, so Section
      4.3.2.2 applies.  If Graceful\n   Restart is aborted due to the rules described
      in Section 4.3, the\n   \"receiving speaker\" should act as if the \"restart
      timer\" expired (as\n   described in [BGP-GRACE]).\n"
    title: 10.2.  Interactions with BGP
  - contents:
    - "10.3.  Interactions with RIP\n   The Routing Information Protocol (RIP) [RIP]
      is somewhat unique in\n   that, at least as specified, neighbor adjacency state
      is not stored\n   per se.  Rather, installed routes contain a next hop address,
      which\n   in most cases is the address of the advertising neighbor (but may
      not\n   be).\n   In the case of RIP, when the BFD session associated with a
      neighbor\n   fails, an expiration of the \"timeout\" timer for each route installed\n
      \  from the neighbor (for which the neighbor is the next hop) should be\n   simulated.\n
      \  Note that if a BFD session fails, and a route is received from that\n   neighbor
      with a next hop address that is not the address of the\n   neighbor itself,
      the route will linger until it naturally times out\n   (after 180 seconds).
      \ However, if an implementation keeps track of\n   all of the routes received
      from each neighbor, all of the routes from\n   the neighbor corresponding to
      the failed BFD session should be timed\n   out, regardless of the next hop specified
      therein, and thereby\n   avoiding the lingering route problem.\n"
    title: 10.3.  Interactions with RIP
  title: 10.  Specific Protocol Interactions (Non-Normative)
- contents:
  - "11.  Security Considerations\n   This specification does not raise any additional
    security issues\n   beyond those of the specifications referred to in the list
    of\n   normative references.\n"
  title: 11.  Security Considerations
- contents:
  - '12.  References

    '
  - contents:
    - "12.1.  Normative References\n   [BFD]        Katz, D. and D. Ward, \"Bidirectional
      Forwarding\n                Detection\", RFC 5880, June 2010.\n   [BFD-1HOP]
      \  Katz, D. and D. Ward,\"Bidirectional Forwarding Detection\n                (BFD)
      for IPv4 and IPv6 (Single Hop)\", RFC 5881, June\n                2010.\n   [BFD-MPLS]
      \  Aggarwal, R., Kompella, K., Nadeau, T., and G. Swallow,\n                \"Bidirectional
      Forwarding Detection (BFD) for MPLS Label\n                Switched Paths (LSPs)\",
      RFC 5884, June 2010.\n   [BFD-MULTI]  Katz, D. and D. Ward, \"Bidirectional
      Forwarding\n                Detection (BFD) for Multihop Paths\", RFC 5883,
      June\n                2010.\n   [KEYWORDS]   Bradner, S., \"Key words for use
      in RFCs to Indicate\n                Requirement Levels\", BCP 14, RFC 2119,
      March 1997.\n"
    title: 12.1.  Normative References
  - contents:
    - "12.2.  Informative References\n   [BGP]        Rekhter, Y., Ed., Li, T., Ed.,
      and S. Hares, Ed., \"A\n                Border Gateway Protocol 4 (BGP-4)\",
      RFC 4271, January\n                2006.\n   [BGP-GRACE]  Sangli, S., Chen,
      E., Fernando, R., Scudder, J., and Y.\n                Rekhter, \"Graceful Restart
      Mechanism for BGP\", RFC 4724,\n                January 2007.\n   [DIFFSERV]
      \  Nichols, K., Blake, S., Baker, F., and D. Black,\n                \"Definition
      of the Differentiated Services Field (DS\n                Field) in the IPv4
      and IPv6 Headers\", RFC 2474, December\n                1998.\n   [ISIS]       Callon,
      R., \"Use of OSI IS-IS for routing in TCP/IP and\n                dual environments\",
      RFC 1195, December 1990.\n   [ISIS-GRACE] Shand, M. and L. Ginsberg, \"Restart
      Signaling for\n                IS-IS\", RFC 5306, October 2008.\n   [OSPFv2]
      \    Moy, J., \"OSPF Version 2\", STD 54, RFC 2328, April 1998.\n   [OSPFv3]
      \    Coltun, R., Ferguson, D., Moy, J., and A. Lindem, \"OSPF\n                for
      IPv6\", RFC 5340, July 2008.\n   [OSPF-GRACE] Moy, J., Pillay-Esnault, P., and
      A. Lindem, \"Graceful\n                OSPF Restart\", RFC 3623, November 2003.\n
      \  [RIP]        Malkin, G., \"RIP Version 2\", STD 56, RFC 2453, November\n
      \               1998.\n"
    title: 12.2.  Informative References
  title: 12.  References
- contents:
  - "Authors' Addresses\n   Dave Katz\n   Juniper Networks\n   1194 N. Mathilda Ave.\n
    \  Sunnyvale, CA  94089-1206\n   USA\n   Phone: +1-408-745-2000\n   EMail: dkatz@juniper.net\n
    \  Dave Ward\n   Juniper Networks\n   1194 N. Mathilda Ave.\n   Sunnyvale, CA
    \ 94089-1206\n   USA\n   Phone: +1-408-745-2000\n   EMail: dward@juniper.net\n"
  title: Authors' Addresses
