- contents:
  - '         Basic Transition Mechanisms for IPv6 Hosts and Routers

    '
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2005).\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document specifies IPv4 compatibility mechanisms that can be\n
    \  implemented by IPv6 hosts and routers.  Two mechanisms are specified,\n   dual
    stack and configured tunneling.  Dual stack implies providing\n   complete implementations
    of both versions of the Internet Protocol\n   (IPv4 and IPv6), and configured
    tunneling provides a means to carry\n   IPv6 packets over unmodified IPv4 routing
    infrastructures.\n   This document obsoletes RFC 2893.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ....................................................2\n
    \     1.1. Terminology ................................................3\n   2.
    Dual IP Layer Operation .........................................4\n      2.1.
    Address Configuration ......................................5\n      2.2. DNS
    ........................................................5\n   3. Configured Tunneling
    Mechanisms .................................6\n      3.1. Encapsulation ..............................................7\n
    \     3.2. Tunnel MTU and Fragmentation ...............................8\n           3.2.1.
    Static Tunnel MTU ...................................9\n           3.2.2. Dynamic
    Tunnel MTU ..................................9\n      3.3. Hop Limit .................................................11\n
    \     3.4. Handling ICMPv4 Errors ....................................11\n      3.5.
    IPv4 Header Construction ..................................13\n      3.6. Decapsulation
    .............................................14\n      3.7. Link-Local Addresses
    ......................................17\n      3.8. Neighbor Discovery over Tunnels
    ...........................18\n   4. Threat Related to Source Address Spoofing
    ......................18\n   5. Security Considerations ........................................19\n
    \  6. Acknowledgements ...............................................21\n   7.
    References .....................................................21\n      7.1.
    Normative References ......................................21\n      7.2. Informative
    References ....................................21\n   8. Changes from RFC 2893
    ..........................................23\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The key to a successful IPv6 transition is compatibility
    with the\n   large installed base of IPv4 hosts and routers.  Maintaining\n   compatibility
    with IPv4 while deploying IPv6 will streamline the task\n   of transitioning the
    Internet to IPv6.  This specification defines\n   two mechanisms that IPv6 hosts
    and routers may implement in order to\n   be compatible with IPv4 hosts and routers.\n
    \  The mechanisms in this document are designed to be employed by IPv6\n   hosts
    and routers that need to interoperate with IPv4 hosts and\n   utilize IPv4 routing
    infrastructures.  We expect that most nodes in\n   the Internet will need such
    compatibility for a long time to come,\n   and perhaps even indefinitely.\n   The
    mechanisms specified here are:\n   -  Dual IP layer (also known as dual stack):
    \ A technique for\n      providing complete support for both Internet protocols
    -- IPv4 and\n      IPv6 -- in hosts and routers.\n   -  Configured tunneling of
    IPv6 over IPv4:  A technique for\n      establishing point-to-point tunnels by
    encapsulating IPv6 packets\n      within IPv4 headers to carry them over IPv4
    routing\n      infrastructures.\n   The mechanisms defined here are intended to
    be the core of a\n   \"transition toolbox\" -- a growing collection of techniques
    that\n   implementations and users may employ to ease the transition.  The\n   tools
    may be used as needed.  Implementations and sites decide which\n   techniques
    are appropriate to their specific needs.\n   This document defines the basic set
    of transition mechanisms, but\n   these are not the only tools available.  Additional
    transition and\n   compatibility mechanisms are specified in other documents.\n"
  - contents:
    - "1.1.  Terminology\n   The following terms are used in this document:\n   Types
      of Nodes\n      IPv4-only node:\n         A host or router that implements only
      IPv4.  An IPv4-only node\n         does not understand IPv6.  The installed
      base of IPv4 hosts and\n         routers existing before the transition begins
      are IPv4-only\n         nodes.\n      IPv6/IPv4 node:\n         A host or router
      that implements both IPv4 and IPv6.\n      IPv6-only node:\n         A host
      or router that implements IPv6 and does not implement\n         IPv4.  The operation
      of IPv6-only nodes is not addressed in\n         this memo.\n      IPv6 node:\n
      \        Any host or router that implements IPv6.  IPv6/IPv4 and IPv6-\n         only
      nodes are both IPv6 nodes.\n      IPv4 node:\n         Any host or router that
      implements IPv4.  IPv6/IPv4 and IPv4-\n         only nodes are both IPv4 nodes.\n
      \  Techniques Used in the Transition\n      IPv6-over-IPv4 tunneling:\n         The
      technique of encapsulating IPv6 packets within IPv4 so that\n         they can
      be carried across IPv4 routing infrastructures.\n      Configured tunneling:\n
      \        IPv6-over-IPv4 tunneling where the IPv4 tunnel endpoint\n         address(es)
      are determined by configuration information on\n         tunnel endpoints.  All
      tunnels are assumed to be bidirectional.\n         The tunnel provides a (virtual)
      point-to-point link to the IPv6\n         layer, using the configured IPv4 addresses
      as the lower-layer\n         endpoint addresses.\n   Other transition mechanisms,
      including other tunneling mechanisms,\n   are outside the scope of this document.\n
      \  The key words MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,\n   SHOULD
      NOT, RECOMMENDED, MAY, and OPTIONAL, when they appear in this\n   document,
      are to be interpreted as described in [RFC2119].\n"
    title: 1.1.  Terminology
  title: 1.  Introduction
- contents:
  - "2.  Dual IP Layer Operation\n   The most straightforward way for IPv6 nodes to
    remain compatible with\n   IPv4-only nodes is by providing a complete IPv4 implementation.
    \ IPv6\n   nodes that provide complete IPv4 and IPv6 implementations are called\n
    \  \"IPv6/IPv4 nodes\".  IPv6/IPv4 nodes have the ability to send and\n   receive
    both IPv4 and IPv6 packets.  They can directly interoperate\n   with IPv4 nodes
    using IPv4 packets, and also directly interoperate\n   with IPv6 nodes using IPv6
    packets.\n   Even though a node may be equipped to support both protocols, one
    or\n   the other stack may be disabled for operational reasons.  Here we use\n
    \  a rather loose notion of \"stack\".  A stack being enabled has IP\n   addresses
    assigned, but whether or not any particular application is\n   available on the
    stacks is explicitly not defined.  Thus, IPv6/IPv4\n   nodes may be operated in
    one of three modes:\n   -  With their IPv4 stack enabled and their IPv6 stack
    disabled.\n   -  With their IPv6 stack enabled and their IPv4 stack disabled.\n
    \  -  With both stacks enabled.\n   IPv6/IPv4 nodes with their IPv6 stack disabled
    will operate like\n   IPv4-only nodes.  Similarly, IPv6/IPv4 nodes with their
    IPv4 stacks\n   disabled will operate like IPv6-only nodes.  IPv6/IPv4 nodes MAY\n
    \  provide a configuration switch to disable either their IPv4 or IPv6\n   stack.\n
    \  The configured tunneling technique, which is described in Section 3,\n   may
    or may not be used in addition to the dual IP layer operation.\n"
  - contents:
    - "2.1.  Address Configuration\n   Because the nodes support both protocols, IPv6/IPv4
      nodes may be\n   configured with both IPv4 and IPv6 addresses.  IPv6/IPv4 nodes
      use\n   IPv4 mechanisms (e.g., DHCP) to acquire their IPv4 addresses, and\n
      \  IPv6 protocol mechanisms (e.g., stateless address autoconfiguration\n   [RFC2462]
      and/or DHCPv6) to acquire their IPv6 addresses.\n"
    title: 2.1.  Address Configuration
  - contents:
    - "2.2.  DNS\n   The Domain Naming System (DNS) is used in both IPv4 and IPv6
      to map\n   between hostnames and IP addresses.  A new resource record type named\n
      \  \"AAAA\" has been defined for IPv6 addresses [RFC3596].  Since\n   IPv6/IPv4
      nodes must be able to interoperate directly with both IPv4\n   and IPv6 nodes,
      they must provide resolver libraries capable of\n   dealing with IPv4 \"A\"
      records as well as IPv6 \"AAAA\" records.  Note\n   that the lookup of A versus
      AAAA records is independent of whether\n   the DNS packets are carried in IPv4
      or IPv6 packets and that there is\n   no assumption that the DNS servers know
      the IPv4/IPv6 capabilities of\n   the requesting node.\n   The issues and operational
      guidelines for using IPv6 with DNS are\n   described at more length in other
      documents, e.g., [DNSOPV6].\n   DNS resolver libraries on IPv6/IPv4 nodes MUST
      be capable of handling\n   both AAAA and A records.  However, when a query locates
      an AAAA\n   record holding an IPv6 address, and an A record holding an IPv4\n
      \  address, the resolver library MAY order the results returned to the\n   application
      in order to influence the version of IP packets used to\n   communicate with
      that specific node -- IPv6 first, or IPv4 first.\n   The applications SHOULD
      be able to specify whether they want IPv4,\n   IPv6, or both records [RFC3493].
      \ That defines which address families\n   the resolver looks up.  If there is
      not an application choice, or if\n   the application has requested both, the
      resolver library MUST NOT\n   filter out any records.\n   Since most applications
      try the addresses in the order they are\n   returned by the resolver, this can
      affect the IP version \"preference\"\n   of applications.\n   The actual ordering
      mechanisms are out of scope of this memo.\n   Address selection is described
      at more length in [RFC3484].\n"
    title: 2.2.  DNS
  title: 2.  Dual IP Layer Operation
- contents:
  - "3.  Configured Tunneling Mechanisms\n   In most deployment scenarios, the IPv6
    routing infrastructure will be\n   built up over time.  While the IPv6 infrastructure
    is being deployed,\n   the existing IPv4 routing infrastructure can remain functional
    and\n   can be used to carry IPv6 traffic.  Tunneling provides a way to\n   utilize
    an existing IPv4 routing infrastructure to carry IPv6\n   traffic.\n   IPv6/IPv4
    hosts and routers can tunnel IPv6 datagrams over regions of\n   IPv4 routing topology
    by encapsulating them within IPv4 packets.\n   Tunneling can be used in a variety
    of ways:\n   -  Router-to-Router.  IPv6/IPv4 routers interconnected by an IPv4\n
    \     infrastructure can tunnel IPv6 packets between themselves.  In\n      this
    case, the tunnel spans one segment of the end-to-end path\n      that the IPv6
    packet takes.\n   -  Host-to-Router.  IPv6/IPv4 hosts can tunnel IPv6 packets
    to an\n      intermediary IPv6/IPv4 router that is reachable via an IPv4\n      infrastructure.
    \ This type of tunnel spans the first segment of\n      the packet's end-to-end
    path.\n   -  Host-to-Host.  IPv6/IPv4 hosts that are interconnected by an IPv4\n
    \     infrastructure can tunnel IPv6 packets between themselves.  In\n      this
    case, the tunnel spans the entire end-to-end path that the\n      packet takes.\n
    \  -  Router-to-Host.  IPv6/IPv4 routers can tunnel IPv6 packets to\n      their
    final destination IPv6/IPv4 host.  This tunnel spans only\n      the last segment
    of the end-to-end path.\n   Configured tunneling can be used in all of the above
    cases, but it is\n   most likely to be used router-to-router due to the need to
    explicitly\n   configure the tunneling endpoints.\n   The underlying mechanisms
    for tunneling are:\n   -  The entry node of the tunnel (the encapsulator) creates
    an\n      encapsulating IPv4 header and transmits the encapsulated packet.\n   -
    \ The exit node of the tunnel (the decapsulator) receives the\n      encapsulated
    packet, reassembles the packet if needed, removes the\n      IPv4 header, and
    processes the received IPv6 packet.\n   -  The encapsulator may need to maintain
    soft-state information for\n      each tunnel recording such parameters as the
    MTU of the tunnel in\n      order to process IPv6 packets forwarded into the tunnel.\n
    \  In configured tunneling, the tunnel endpoint addresses are determined\n   in
    the encapsulator from configuration information stored for each\n   tunnel.  When
    an IPv6 packet is transmitted over a tunnel, the\n   destination and source addresses
    for the encapsulating IPv4 header\n   are set as described in Section 3.5.\n   The
    determination of which packets to tunnel is usually made by\n   routing information
    on the encapsulator.  This is usually done via a\n   routing table, which directs
    packets based on their destination\n   address using the prefix mask and match
    technique.\n   The decapsulator matches the received protocol-41 packets to the\n
    \  tunnels it has configured, and allows only the packets in which IPv4\n   source
    addresses match the tunnels configured on the decapsulator.\n   Therefore, the
    operator must ensure that the tunnel's IPv4 address\n   configuration is the same
    both at the encapsulator and the\n   decapsulator.\n"
  - contents:
    - "3.1.  Encapsulation\n   The encapsulation of an IPv6 datagram in IPv4 is shown
      below:\n                                             +-------------+\n                                             |
      \   IPv4     |\n                                             |   Header    |\n
      \            +-------------+                 +-------------+\n             |
      \   IPv6     |                 |    IPv6     |\n             |   Header    |
      \                |   Header    |\n             +-------------+                 +-------------+\n
      \            |  Transport  |                 |  Transport  |\n             |
      \  Layer     |      ===>       |   Layer     |\n             |   Header    |
      \                |   Header    |\n             +-------------+                 +-------------+\n
      \            |             |                 |             |\n             ~
      \   Data     ~                 ~    Data     ~\n             |             |
      \                |             |\n             +-------------+                 +-------------+\n
      \                     Encapsulating IPv6 in IPv4\n   In addition to adding an
      IPv4 header, the encapsulator also has to\n   handle some more complex issues:\n
      \  -  Determine when to fragment and when to report an ICMPv6 \"packet\n      too
      big\" error back to the source.\n   -  How to reflect ICMPv4 errors from routers
      along the tunnel path\n      back to the source as ICMPv6 errors.\n   Those
      issues are discussed in the following sections.\n"
    title: 3.1.  Encapsulation
  - contents:
    - "3.2.  Tunnel MTU and Fragmentation\n   Naively, the encapsulator could view
      encapsulation as IPv6 using IPv4\n   as a link layer with a very large MTU (65535-20
      bytes at most; 20\n   bytes \"extra\" are needed for the encapsulating IPv4
      header).  The\n   encapsulator would only need to report ICMPv6 \"packet too
      big\" errors\n   back to the source for packets that exceed this MTU.  However,
      such a\n   scheme would be inefficient or non-interoperable for three reasons\n
      \  and therefore MUST NOT be used:\n   1) It would result in more fragmentation
      than needed.  IPv4 layer\n      fragmentation should be avoided due to the performance
      problems\n      caused by the loss unit being smaller than the retransmission
      unit\n      [KM97].\n   2) Any IPv4 fragmentation occurring inside the tunnel,
      i.e., between\n      the encapsulator and the decapsulator, would have to be\n
      \     reassembled at the tunnel endpoint.  For tunnels that terminate at\n      a
      router, this would require additional memory and other resources\n      to reassemble
      the IPv4 fragments into a complete IPv6 packet\n      before that packet could
      be forwarded.\n   3) The encapsulator has no way of knowing that the decapsulator
      is\n      able to defragment such IPv4 packets (see Section 3.6 for\n      details),
      and has no way of knowing that the decapsulator is able\n      to handle such
      a large IPv6 Maximum Receive Unit (MRU).\n   Hence, the encapsulator MUST NOT
      treat the tunnel as an interface\n   with an MTU of 64 kilobytes, but instead
      either use the fixed static\n   MTU or OPTIONAL dynamic MTU determination based
      on the IPv4 path MTU\n   to the tunnel endpoint.\n   If both the mechanisms
      are implemented, the decision of which to use\n   SHOULD be configurable on
      a per-tunnel endpoint basis.\n"
    - contents:
      - "3.2.1.  Static Tunnel MTU\n   A node using static tunnel MTU treats the tunnel
        interface as having\n   a fixed-interface MTU.  By default, the MTU MUST be
        between 1280 and\n   1480 bytes (inclusive), but it SHOULD be 1280 bytes.
        \ If the default\n   is not 1280 bytes, the implementation MUST have a configuration
        knob\n   that can be used to change the MTU value.\n   A node must be able
        to accept a fragmented IPv6 packet that, after\n   reassembly, is as large
        as 1500 octets [RFC2460].  This memo also\n   includes requirements (see Section
        3.6) for the amount of IPv4\n   reassembly and IPv6 MRU that MUST be supported
        by all the\n   decapsulators.  These ensure correct interoperability with
        any fixed\n   MTUs between 1280 and 1480 bytes.\n   A larger fixed MTU than
        supported by these requirements must not be\n   configured unless it has been
        administratively ensured that the\n   decapsulator can reassemble or receive
        packets of that size.\n   The selection of a good tunnel MTU depends on many
        factors, at least:\n   -  Whether the IPv4 protocol-41 packets will be transported
        over\n      media that may have a lower path MTU (e.g., IPv4 Virtual Private\n
        \     Networks); then picking too high a value might lead to IPv4\n      fragmentation.\n
        \  -  Whether the tunnel is used to transport IPv6 tunneled packets\n      (e.g.,
        a mobile node with an IPv6-in-IPv4 configured tunnel, and\n      an IPv6-in-IPv6
        tunnel interface); then picking too low a value\n      might lead to IPv6
        fragmentation.\n   If layered encapsulation is believed to be present, it
        may be prudent\n   to consider supporting dynamic MTU determination instead
        as it is\n   able to minimize fragmentation and optimize packet sizes.\n   When
        using the static tunnel MTU, the Don't Fragment bit MUST NOT be\n   set in
        the encapsulating IPv4 header.  As a result, the encapsulator\n   should not
        receive any ICMPv4 \"packet too big\" messages as a result\n   of the packets
        it has encapsulated.\n"
      title: 3.2.1.  Static Tunnel MTU
    - contents:
      - "3.2.2.  Dynamic Tunnel MTU\n   The dynamic MTU determination is OPTIONAL.
        \ However, if it is\n   implemented, it SHOULD have the behavior described
        in this document.\n   The fragmentation inside the tunnel can be reduced to
        a minimum by\n   having the encapsulator track the IPv4 path MTU across the
        tunnel,\n   using the IPv4 Path MTU Discovery Protocol [RFC1191] and recording\n
        \  the resulting path MTU.  The IPv6 layer in the encapsulator can then\n
        \  view a tunnel as a link layer with an MTU equal to the IPv4 path MTU,\n
        \  minus the size of the encapsulating IPv4 header.\n   Note that this does
        not eliminate IPv4 fragmentation in the case when\n   the IPv4 path MTU would
        result in an IPv6 MTU less than 1280 bytes.\n   (Any link layer used by IPv6
        has to have an MTU of at least 1280\n   bytes [RFC2460].)  In this case, the
        IPv6 layer has to \"see\" a link\n   layer with an MTU of 1280 bytes and the
        encapsulator has to use IPv4\n   fragmentation in order to forward the 1280
        byte IPv6 packets.\n   The encapsulator SHOULD employ the following algorithm
        to determine\n   when to forward an IPv6 packet that is larger than the tunnel's
        path\n   MTU using IPv4 fragmentation, and when to return an ICMPv6 \"packet\n
        \  too big\" message per [RFC1981]:\n         if (IPv4 path MTU - 20) is less
        than 1280\n                 if packet is larger than 1280 bytes\n                         Send
        ICMPv6 \"packet too big\" with MTU = 1280.\n                         Drop
        packet.\n                 else\n                         Encapsulate but do
        not set the Don't Fragment\n                         flag in the IPv4 header.
        \ The resulting IPv4\n                         packet might be fragmented
        by the IPv4 layer\n                         on the encapsulator or by some
        router along\n                         the IPv4 path.\n                 endif\n
        \        else\n                 if packet is larger than (IPv4 path MTU -
        20)\n                         Send ICMPv6 \"packet too big\" with\n                         MTU
        = (IPv4 path MTU - 20).\n                         Drop packet.\n                 else\n
        \                        Encapsulate and set the Don't Fragment flag\n                         in
        the IPv4 header.\n                 endif\n         endif\n   Encapsulators
        that have a large number of tunnels may choose between\n   dynamic versus
        static tunnel MTUs on a per-tunnel endpoint basis.  In\n   cases where the
        number of tunnels that any one node is using is\n   large, it is helpful to
        observe that this state information can be\n   cached and discarded when not
        in use.\n   Note that using dynamic tunnel MTU is subject to IPv4 path MTU\n
        \  blackholes should the ICMPv4 \"packet too big\" messages be dropped by\n
        \  firewalls or not generated by the routers [RFC1435, RFC2923].\n"
      title: 3.2.2.  Dynamic Tunnel MTU
    title: 3.2.  Tunnel MTU and Fragmentation
  - contents:
    - "3.3.  Hop Limit\n   IPv6-over-IPv4 tunnels are modeled as \"single-hop\" from
      the IPv6\n   perspective.  The tunnel is opaque to users of the network, and
      it is\n   not detectable by network diagnostic tools such as traceroute.\n   The
      single-hop model is implemented by having the encapsulators and\n   decapsulators
      process the IPv6 hop limit field as they would if they\n   were forwarding a
      packet on to any other datalink.  That is, they\n   decrement the hop limit
      by 1 when forwarding an IPv6 packet.  (The\n   originating node and final destination
      do not decrement the hop\n   limit.)\n   The TTL of the encapsulating IPv4 header
      is selected in an\n   implementation-dependent manner.  The current suggested
      value is\n   published in the \"Assigned Numbers\" RFC [RFC3232][ASSIGNED].\n
      \  Implementations MAY provide a mechanism to allow the administrator to\n   configure
      the IPv4 TTL as the IP Tunnel MIB [RFC4087].\n"
    title: 3.3.  Hop Limit
  - contents:
    - "3.4.  Handling ICMPv4 Errors\n   In response to encapsulated packets it has
      sent into the tunnel, the\n   encapsulator might receive ICMPv4 error messages
      from IPv4 routers\n   inside the tunnel.  These packets are addressed to the
      encapsulator\n   because it is the IPv4 source of the encapsulated packet.\n
      \  ICMPv4 error handling is only applicable to dynamic MTU\n   determination,
      even though the functions could be used with static\n   MTU tunnels as well.\n
      \  The ICMPv4 \"packet too big\" error messages are handled according to\n   IPv4
      Path MTU Discovery [RFC1191] and the resulting path MTU is\n   recorded in the
      IPv4 layer.  The recorded path MTU is used by IPv6 to\n   determine if an ICMPv6
      \"packet too big\" error has to be generated as\n   described in Section 3.2.2.\n
      \  The handling of other types of ICMPv4 error messages depends on how\n   much
      information is available from the encapsulated packet that\n   caused the error.\n
      \  Many older IPv4 routers return only 8 bytes of data beyond the IPv4\n   header
      of the packet in error, which is not enough to include the\n   address fields
      of the IPv6 header.  More modern IPv4 routers are\n   likely to return enough
      data beyond the IPv4 header to include the\n   entire IPv6 header and possibly
      even the data beyond that.  See\n   [RFC1812].\n   If sufficient data bytes
      from the offending packet are available, the\n   encapsulator MAY extract the
      encapsulated IPv6 packet and use it to\n   generate an ICMPv6 message directed
      back to the originating IPv6\n   node, as shown below:\n                         +--------------+\n
      \                        | IPv4 Header  |\n                         | dst =
      encaps |\n                         |       node   |\n                         +--------------+\n
      \                        |    ICMPv4    |\n                         |    Header
      \   |\n                  - -    +--------------+\n                         |
      IPv4 Header  |\n                         | src = encaps |\n                 IPv4
      \   |       node   |\n                         +--------------+   - -\n                 Packet
      \ |    IPv6      |\n                         |    Header    |   Original IPv6\n
      \                 in     +--------------+   Packet -\n                         |
      \ Transport   |   Can be used to\n                 Error   |    Header    |
      \  generate an\n                         +--------------+   ICMPv6\n                         |
      \             |   error message\n                         ~     Data     ~   back
      to the source.\n                         |              |\n                  -
      -    +--------------+   - -\n             ICMPv4 Error Message Returned to Encapsulating
      Node\n   When receiving ICMPv4 errors as above and the errors are not \"packet\n
      \  too big\", it would be useful to log the error as an error related to\n   the
      tunnel.  Also, if sufficient headers are available, then the\n   originating
      node MAY send an ICMPv6 error of type \"unreachable\" with\n   code \"address
      unreachable\" to the IPv6 source.  (The \"address\n   unreachable\" code is
      appropriate since, from the perspective of IPv6,\n   the tunnel is a link and
      that code is used for link-specific errors\n   [RFC2463]).\n   Note that when
      the IPv4 path MTU is exceeded, and sufficient bytes of\n   payload associated
      with the ICMPv4 errors are not available, or\n   ICMPv4 errors do not cause
      the generation of ICMPv6 errors in case\n   there is enough payload, there will
      be at least two packet drops\n   instead of at least one (the case of a single
      layer of MTU\n   discovery).  Consider a case where an IPv6 host is connected
      to an\n   IPv4/IPv6 router, which is connected to a network where an ICMPv4\n
      \  error about too big packet size is generated.  First, the router\n   needs
      to learn the tunnel (IPv4) MTU that causes at least one packet\n   loss, and
      then the host needs to learn the (IPv6) MTU from the router\n   that causes
      at least one packet loss.  Still, in all cases there can\n   be more than one
      packet loss if there are multiple large packets in\n   flight at the same time.\n"
    title: 3.4.  Handling ICMPv4 Errors
  - contents:
    - "3.5.  IPv4 Header Construction\n   When encapsulating an IPv6 packet in an
      IPv4 datagram, the IPv4\n   header fields are set as follows:\n      Version:\n
      \        4\n      IP Header Length in 32-bit words:\n         5 (There are no
      IPv4 options in the encapsulating header.)\n      Type of Service:\n         0
      unless otherwise specified. (See [RFC2983] and [RFC3168]\n         Section 9.1
      for issues relating to the Type-of-Service byte and\n         tunneling.)\n
      \     Total Length:\n         Payload length from IPv6 header plus length of
      IPv6 and IPv4\n         headers (i.e., IPv6 payload length plus a constant 60
      bytes).\n      Identification:\n         Generated uniquely as for any IPv4
      packet transmitted by the\n         system.\n      Flags:\n         Set the
      Don't Fragment (DF) flag as specified in Section 3.2.\n         Set the More
      Fragments (MF) bit as necessary if fragmenting.\n      Fragment Offset:\n         Set
      as necessary if fragmenting.\n      Time to Live:\n         Set in an implementation-specific
      manner, as described in\n         Section 3.3.\n      Protocol:\n         41
      (Assigned payload type number for IPv6).\n      Header Checksum:\n         Calculate
      the checksum of the IPv4 header [RFC791].\n      Source Address:\n         An
      IPv4 address of the encapsulator: either configured by the\n         administrator
      or an address of the outgoing interface.\n      Destination Address:\n         IPv4
      address of the tunnel endpoint.\n   When encapsulating the packets, the node
      must ensure that it will use\n   the correct source address so that the packets
      are acceptable to the\n   decapsulator as described in Section 3.6.  Configuring
      the source\n   address is appropriate particularly in cases in which automatic\n
      \  selection of source address may produce different results in a\n   certain
      period of time.  This is often the case with multiple\n   addresses, and multiple
      interfaces, or when routes may change\n   frequently.  Therefore, it SHOULD
      be possible to administratively\n   specify the source address of a tunnel.\n"
    title: 3.5.  IPv4 Header Construction
  - contents:
    - "3.6.  Decapsulation\n   When an IPv6/IPv4 host or a router receives an IPv4
      datagram that is\n   addressed to one of its own IPv4 addresses or a joined
      multicast\n   group address, and the value of the protocol field is 41, the
      packet\n   is potentially a tunnel packet and needs to be verified to belong
      to\n   one of the configured tunnel interfaces (by checking\n   source/destination
      addresses), reassembled (if fragmented at the IPv4\n   level), and have the
      IPv4 header removed and the resulting IPv6\n   datagram be submitted to the
      IPv6 layer code on the node.\n   The decapsulator MUST verify that the tunnel
      source address is\n   correct before further processing packets, to mitigate
      the problems\n   with address spoofing (see Section 4).  This check also applies
      to\n   packets that are delivered to transport protocols on the\n   decapsulator.
      \ This is done by verifying that the source address is\n   the IPv4 address
      of the encapsulator, as configured on the\n   decapsulator.  Packets for which
      the IPv4 source address does not\n   match MUST be discarded and an ICMP message
      SHOULD NOT be generated;\n   however, if the implementation normally sends an
      ICMP message when\n   receiving an unknown protocol packet, such an error message
      MAY be\n   sent (e.g., ICMPv4 Protocol 41 Unreachable).\n   A side effect of
      this address verification is that the node will\n   silently discard packets
      with a wrong source address and packets that\n   were received by the node but
      not directly addressed to it (e.g.,\n   broadcast addresses).\n   Independent
      of any other forms of IPv4 ingress filtering the\n   administrator of the node
      may have configured, the implementation MAY\n   perform ingress filtering, i.e.,
      check that the packet is arriving\n   from the interface in the direction of
      the route toward the tunnel\n   end-point, similar to a Strict Reverse Path
      Forwarding (RPF) check\n   [RFC3704].  As this may cause problems on tunnels
      that are routed\n   through multiple links, it is RECOMMENDED that this check,
      if done,\n   is disabled by default.  The packets caught by this check SHOULD
      be\n   discarded; an ICMP message SHOULD NOT be generated by default.\n   The
      decapsulator MUST be capable of having, on the tunnel interfaces,\n   an IPv6
      MRU of at least the maximum of 1500 bytes and the largest\n   (IPv6) interface
      MTU on the decapsulator.\n   The decapsulator MUST be capable of reassembling
      an IPv4 packet that\n   is (after the reassembly) the maximum of 1500 bytes
      and the largest\n   (IPv4) interface MTU on the decapsulator.  The 1500-byte
      number is a\n   result of encapsulators that use the static MTU scheme in Section\n
      \  3.2.1, while encapsulators that use the dynamic scheme in Section\n   3.2.2
      can cause up to the largest interface MTU on the decapsulator\n   to be received.
      (Note that it is strictly the interface MTU on the\n   last IPv4 router *before*
      the decapsulator that matters, but for most\n   links the MTU is the same between
      all neighbors.)\n   This reassembly limit allows dynamic tunnel MTU determination
      by the\n   encapsulator to take advantage of larger IPv4 path MTUs.  An\n   implementation
      MAY have a configuration knob that can be used to set\n   a larger value of
      the tunnel reassembly buffers than the above\n   number, but it MUST NOT be
      set below the above number.\n   The decapsulation is shown below:\n            +-------------+\n
      \           |    IPv4     |\n            |   Header    |\n            +-------------+
      \                +-------------+\n            |    IPv6     |                 |
      \   IPv6     |\n            |   Header    |                 |   Header    |\n
      \           +-------------+                 +-------------+\n            |  Transport
      \ |                 |  Transport  |\n            |   Layer     |      ===>       |
      \  Layer     |\n            |   Header    |                 |   Header    |\n
      \           +-------------+                 +-------------+\n            |             |
      \                |             |\n            ~    Data     ~                 ~
      \   Data     ~\n            |             |                 |             |\n
      \           +-------------+                 +-------------+\n                    Decapsulating
      IPv6 from IPv4\n   The decapsulator performs IPv4 reassembly before decapsulating
      the\n   IPv6 packet.\n   When decapsulating the packet, the IPv6 header is not
      modified.\n   (However, see [RFC2983] and [RFC3168] section 9.1 for issues relating\n
      \  to the Type of Service byte and tunneling.)  If the packet is\n   subsequently
      forwarded, its hop limit is decremented by one.\n   The encapsulating IPv4 header
      is discarded, and the resulting packet\n   is checked for validity when submitted
      to the IPv6 layer.  When\n   reconstructing the IPv6 packet, the length MUST
      be determined from\n   the IPv6 payload length since the IPv4 packet might be
      padded (thus\n   have a length that is larger than the IPv6 packet plus the
      IPv4\n   header being removed).\n   After the decapsulation, the node MUST silently
      discard a packet with\n   an invalid IPv6 source address.  The list of invalid
      source addresses\n   SHOULD include at least:\n   -  all multicast addresses
      (FF00::/8)\n   -  the loopback address (::1)\n   -  all the IPv4-compatible
      IPv6 addresses [RFC3513] (::/96),\n      excluding the unspecified address for
      Duplicate Address Detection\n      (::/128)\n   -  all the IPv4-mapped IPv6
      addresses (::ffff:0:0/96)\n   In addition, the node should be configured to
      perform ingress\n   filtering [RFC2827][RFC3704] on the IPv6 source address,
      similar to\n   on any of its interfaces, e.g.:\n   1) if the tunnel is toward
      the Internet, the node should be\n      configured to check that the site's
      IPv6 prefixes are not used as\n      the source addresses, or\n   2) if the
      tunnel is toward an edge network, the node should be\n      configured to check
      that the source address belongs to that edge\n      network.\n   The prefix
      lists in the former typically need to be manually\n   configured; the latter
      could be verified automatically, e.g., by\n   using a strict unicast RPF check,
      as long as an interface can be\n   designated to be toward an edge.\n   It is
      RECOMMENDED that the implementations provide a single knob to\n   make it easier
      to for the administrators to enable strict ingress\n   filtering toward edge
      networks.\n"
    title: 3.6.  Decapsulation
  - contents:
    - "3.7.  Link-Local Addresses\n   The configured tunnels are IPv6 interfaces (over
      the IPv4 \"link\n   layer\") and thus MUST have link-local addresses.  The link-local\n
      \  addresses are used by, e.g., routing protocols operating over the\n   tunnels.\n
      \  The interface identifier [RFC3513] for such an interface may be based\n   on
      the 32-bit IPv4 address of an underlying interface, or formed\n   using some
      other means, as long as it is unique from the other tunnel\n   endpoint with
      a reasonably high probability.\n   Note that it may be desirable to form the
      link-local address in a\n   fashion that minimizes the probability and the effect
      of having to\n   renumber the link-local address in the event of a topology
      or\n   hardware change.\n   If an IPv4 address is used for forming the IPv6
      link-local address,\n   the interface identifier is the IPv4 address, prepended
      by zeros.\n   Note that the \"Universal/Local\" bit is zero, indicating that
      the\n   interface identifier is not globally unique.  The link-local address\n
      \  is formed by appending the interface identifier to the prefix\n   FE80::/64.\n
      \  When the host has more than one IPv4 address in use on the physical\n   interface
      concerned, a choice of one of these IPv4 addresses is made\n   by the administrator
      or the implementation when forming the link-\n   local address.\n      +-------+-------+-------+-------+-------+-------+------+------+\n
      \     |  FE      80      00      00      00      00      00     00  |\n      +-------+-------+-------+-------+-------+-------+------+------+\n
      \     |  00      00      00      00   |        IPv4 Address         |\n      +-------+-------+-------+-------+-------+-------+------+------+\n"
    title: 3.7.  Link-Local Addresses
  - contents:
    - "3.8.  Neighbor Discovery over Tunnels\n   Configured tunnel implementations
      MUST at least accept and respond to\n   the probe packets used by Neighbor Unreachability
      Detection (NUD)\n   [RFC2461].  The implementations SHOULD also send NUD probe
      packets to\n   detect when the configured tunnel fails at which point the\n
      \  implementation can use an alternate path to reach the destination.\n   Note
      that Neighbor Discovery allows that the sending of NUD probes be\n   omitted
      for router-to-router links if the routing protocol tracks\n   bidirectional
      reachability.\n   For the purposes of Neighbor Discovery, the configured tunnels\n
      \  specified in this document are assumed to NOT have a link-layer\n   address,
      even though the link-layer (IPv4) does have an address.\n   This means that:\n
      \  -  the sender of Neighbor Discovery packets SHOULD NOT include Source\n      Link
      Layer Address options or Target Link Layer Address options on\n      the tunnel
      link.\n   -  the receiver MUST, while otherwise processing the Neighbor\n      Discovery
      packet, silently ignore the content of any Source Link\n      Layer Address
      options or Target Link Layer Address options\n      received on the tunnel link.\n
      \  Not using link-layer address options is consistent with how Neighbor\n   Discovery
      is used on other point-to-point links.\n"
    title: 3.8.  Neighbor Discovery over Tunnels
  title: 3.  Configured Tunneling Mechanisms
- contents:
  - "4.  Threat Related to Source Address Spoofing\n   The specification above contains
    rules that apply tunnel source\n   address verification in particular and ingress
    filtering\n   [RFC2827][RFC3704] in general to packets before they are\n   decapsulated.
    \ When IP-in-IP tunneling (independent of IP versions)\n   is used, it is important
    that this not be used to bypass any ingress\n   filtering in use for non-tunneled
    packets.  Thus, the rules in this\n   document are derived based on should ingress
    filtering be used for\n   IPv4 and IPv6, the use of tunneling should not provide
    an easy way to\n   circumvent the filtering.\n   In this case, without specific
    ingress filtering checks in the\n   decapsulator, it would be possible for an
    attacker to inject a packet\n   with:\n   -  Outer IPv4 source: real IPv4 address
    of attacker\n   -  Outer IPv4 destination: IPv4 address of decapsulator\n   -
    \ Inner IPv6 source: Alice, which is either the decapsulator or a\n      node
    close to it\n   -  Inner IPv6 destination: Bob\n   Even if all IPv4 routers between
    the attacker and the decapsulator\n   implement IPv4 ingress filtering, and all
    IPv6 routers between the\n   decapsulator and Bob implement IPv6 ingress filtering,
    the above\n   spoofed packets will not be filtered out.  As a result, Bob will\n
    \  receive a packet that looks like it was sent from Alice even though\n   the
    sender was some unrelated node.\n   The solution to this is to have the decapsulator
    accept only\n   encapsulated packets from the explicitly configured source address\n
    \  (i.e., the other end of the tunnel) as specified in Section 3.6.\n   While
    this does not provide complete protection in the case ingress\n   filtering has
    not been deployed, it does provide a significant\n   increase in security.  The
    issue and the remainder threats are\n   discussed at more length in Security Considerations.\n"
  title: 4.  Threat Related to Source Address Spoofing
- contents:
  - "5.  Security Considerations\n   Generic security considerations of using IPv6
    are discussed in a\n   separate document [V6SEC].\n   An implementation of tunneling
    needs to be aware that although a\n   tunnel is a link (as defined in [RFC2460]),
    the threat model for a\n   tunnel might be rather different than for other links,
    since the\n   tunnel potentially includes all of the Internet.\n   Several mechanisms
    (e.g., Neighbor Discovery) depend on Hop Count\n   being 255 and/or the addresses
    being link local for ensuring that a\n   packet originated on-link, in a semi-trusted
    environment.  Tunnels\n   are more vulnerable to a breach of this assumption than
    physical\n   links, as an attacker anywhere in the Internet can send an IPv6-in-\n
    \  IPv4 packet to the tunnel decapsulator, causing injection of an\n   encapsulted
    IPv6 packet to the configured tunnel interface unless the\n   decapsulation checks
    are able to discard packets injected in such a\n   manner.\n   Therefore, this
    memo specifies that the decapsulators make these\n   steps (as described in Section
    3.6) to mitigate this threat:\n   -  IPv4 source address of the packet MUST be
    the same as configured\n      for the tunnel end-point;\n   -  Independent of
    any IPv4 ingress filtering the administrator may\n      have configured, the implementation
    MAY perform IPv4 ingress\n      filtering to check that the IPv4 packets are received
    from an\n      expected interface (but as this may cause some problems, it may
    be\n      disabled by default);\n   -  IPv6 packets with several, obviously invalid
    IPv6 source addresses\n      received from the tunnel MUST be discarded (see Section
    3.6 for\n      details); and\n   -  IPv6 ingress filtering should be performed
    (typically requiring\n      configuration from the operator), to check that the
    tunneled IPv6\n      packets are received from an expected interface.\n   Especially
    the first verification is vital: to avoid this check, the\n   attacker must be
    able to know the source of the tunnel (ranging from\n   difficult to predictable)
    and be able to spoof it (easier).\n   If the remainder threats of tunnel source
    verification are considered\n   to be significant, a tunneling scheme with authentication
    should be\n   used instead, e.g., IPsec [RFC2401] (preferable) or Generic Routing\n
    \  Encapsulation with a pre-configured secret key [RFC2890].  As the\n   configured
    tunnels are set up more or less manually, setting up the\n   keying material is
    probably not a problem.  However, setting up\n   secure IPsec IPv6-in-IPv4 tunnels
    is described in another document\n   [V64IPSEC].\n   If the tunneling is done
    inside an administrative domain, proper\n   ingress filtering at the edge of the
    domain can also eliminate the\n   threat from outside of the domain.  Therefore,
    shorter tunnels are\n   preferable to longer ones, possibly spanning the whole
    Internet.\n   In addition, an implementation MUST treat interfaces to different\n
    \  links as separate, e.g., to ensure that Neighbor Discovery packets\n   arriving
    on one link do not affect other links.  This is especially\n   important for tunnel
    links.\n   When dropping packets due to failing to match the allowed IPv4 source\n
    \  addresses for a tunnel the node should not \"acknowledge\" the\n   existence
    of a tunnel, otherwise this could be used to probe the\n   acceptable tunnel endpoint
    addresses.  For that reason, the\n   specification says that such packets MUST
    be discarded, and an ICMP\n   error message SHOULD NOT be generated, unless the
    implementation\n   normally sends ICMP destination unreachable messages for unknown\n
    \  protocols; in such a case, the same code MAY be sent.  As should be\n   obvious,
    not returning the same ICMP code if an error is returned for\n   other protocols
    may hint that the IPv6 stack (or the protocol 41\n   tunneling processing) has
    been enabled -- the behaviour should be\n   consistent on how the implementation
    otherwise behaves to be\n   transparent to probing.\n"
  title: 5.  Security Considerations
- contents:
  - "6.  Acknowledgements\n   We would like to thank the members of the IPv6 working
    group, the\n   Next Generation Transition (ngtrans) working group, and the v6ops\n
    \  working group for their many contributions and extensive review of\n   this
    document.  Special thanks are due to (in alphabetical order) Jim\n   Bound, Ross
    Callon, Tim Chown,  Alex Conta, Bob Hinden, Bill Manning,\n   John Moy, Mohan
    Parthasarathy, Chirayu Patel, Pekka Savola, and Fred\n   Templin for many helpful
    suggestions.  Pekka Savola helped in editing\n   the final revisions of the specification.\n"
  title: 6.  Acknowledgements
- contents:
  - '7.  References

    '
  - contents:
    - "7.1.  Normative References\n   [RFC791]   Postel, J., \"Internet Protocol\",
      STD 5, RFC 791, September\n              1981.\n   [RFC1191]  Mogul, J. and
      S. Deering, \"Path MTU discovery\", RFC 1191,\n              November 1990.\n
      \  [RFC1981]  McCann, J., Deering, S., and J. Mogul, \"Path MTU Discovery\n
      \             for IP version 6\", RFC 1981, August 1996.\n   [RFC2119]  Bradner,
      S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\",
      BCP 14, RFC 2119, March 1997.\n   [RFC2460]  Deering, S. and R. Hinden, \"Internet
      Protocol, Version 6\n              (IPv6) Specification\", RFC 2460, December
      1998.\n   [RFC2463]  Conta, A. and S. Deering, \"Internet Control Message\n
      \             Protocol (ICMPv6) for the Internet Protocol Version 6\n              (IPv6)
      Specification\", RFC 2463, December 1998.\n"
    title: 7.1.  Normative References
  - contents:
    - "7.2.  Informative References\n   [ASSIGNED] IANA, \"Assigned numbers online
      database\",\n              http://www.iana.org/numbers.html\n   [DNSOPV6]  Durand,
      A., Ihren, J., and Savola P., \"Operational\n              Considerations and
      Issues with IPv6 DNS\", Work in\n              Progress, October 2004.\n   [KM97]
      \    Kent, C., and J. Mogul, \"Fragmentation Considered\n              Harmful\".
      \ In Proc.  SIGCOMM '87 Workshop on Frontiers in\n              Computer Communications
      Technology.  August 1987.\n   [V6SEC]    Savola, P., \"IPv6 Transition/Co-existence
      Security\n              Considerations\", Work in Progress, October 2004.\n
      \  [V64IPSEC] Graveman, R., et al., \"Using IPsec to Secure IPv6-over-\n              IPv4
      Tunnels\", Work in Progress, December 2004.\n   [RFC1435]  Knowles, S., \"IESG
      Advice from Experience with Path MTU\n              Discovery\", RFC 1435, March
      1993.\n   [RFC1812]  Baker, F., \"Requirements for IP Version 4 Routers\", RFC\n
      \             1812, June 1995.\n   [RFC2401]  Kent, S. and R. Atkinson, \"Security
      Architecture for the\n              Internet Protocol\", RFC 2401, November
      1998.\n   [RFC2461]  Narten, T., Nordmark, E., and W. Simpson, \"Neighbor\n
      \             Discovery for IP Version 6 (IPv6)\", RFC 2461, December\n              1998.\n
      \  [RFC2462]  Thomson, S. and T. Narten, \"IPv6 Stateless Address\n              Autoconfiguration\",
      RFC 2462, December 1998.\n   [RFC2827]  Ferguson, P. and D. Senie, \"Network
      Ingress Filtering:\n              Defeating Denial of Service Attacks which
      employ IP Source\n              Address Spoofing\", BCP 38, RFC 2827, May 2000.\n
      \  [RFC2890]  Dommety, G., \"Key and Sequence Number Extensions to GRE\",\n
      \             RFC 2890, September 2000.\n   [RFC2923]  Lahey, K., \"TCP Problems
      with Path MTU Discovery\", RFC\n              2923, September 2000.\n   [RFC2983]
      \ Black, D., \"Differentiated Services and Tunnels\", RFC\n              2983,
      October 2000.\n   [RFC3056]  Carpenter, B. and K. Moore, \"Connection of IPv6
      Domains\n              via IPv4 Clouds\", RFC 3056, February 2001.\n   [RFC3168]
      \ Ramakrishnan, K., Floyd, S., and D. Black, \"The Addition\n              of
      Explicit Congestion Notification (ECN) to IP\", RFC\n              3168, September
      2001.\n   [RFC3232]  Reynolds, J., \"Assigned Numbers: RFC 1700 is Replaced
      by\n              an On-line Database\", RFC 3232, January 2002.\n   [RFC3484]
      \ Draves, R., \"Default Address Selection for Internet\n              Protocol
      version 6 (IPv6)\", RFC 3484, February 2003.\n   [RFC3493]  Gilligan, R., Thomson,
      S., Bound, J., McCann, J., and W.\n              Stevens, \"Basic Socket Interface
      Extensions for IPv6\", RFC\n              3493, February 2003.\n   [RFC3513]
      \ Hinden, R. and S. Deering, \"Internet Protocol Version 6\n              (IPv6)
      Addressing Architecture\", RFC 3513, April 2003.\n   [RFC3596]  Thomson, S.,
      Huitema, C., Ksinant, V., and M. Souissi,\n              \"DNS Extensions to
      Support IP Version 6\", RFC 3596,\n              October 2003.\n   [RFC3704]
      \ Baker, F. and P. Savola, \"Ingress Filtering for Multihomed\n              Networks\",
      BCP 84, RFC 3704, March 2004.\n   [RFC4087]  Thaler, D., \"IP Tunnel MIB\",
      RFC 4087, June 2005.\n"
    title: 7.2.  Informative References
  title: 7.  References
- contents:
  - "8.  Changes from RFC 2893\n   The motivation for the bulk of these changes are
    to simplify the\n   document to only contain the mechanisms of wide-spread use.\n
    \  RFC 2893 contains a mechanism called automatic tunneling.  But a much\n   more
    general mechanism is specified in RFC 3056 [RFC3056] which gives\n   each node
    with a (global) IPv4 address a /48 IPv6 prefix i.e., enough\n   for a whole site.\n
    \  The following changes have been performed since RFC 2893:\n   -  Removed references
    to A6 and retained AAAA.\n   -  Removed automatic tunneling and use of IPv4-compatible
    addresses.\n   -  Removed default Configured Tunnel using IPv4 \"Anycast Address\"\n
    \  -  Removed Source Address Selection section since this is now covered\n      by
    another document ([RFC3484]).\n   -  Removed brief mention of 6over4.\n   -  Split
    into normative and non-normative references and other\n      reference cleanup.\n
    \  -  Dropped \"or equal\" in if (IPv4 path MTU - 20) is less than or\n      equal
    to 1280.\n   -  Dropped this: However, IPv6 may be used in some environments where\n
    \     interoperability with IPv4 is not required.  IPv6 nodes that are\n      designed
    to be used in such environments need not use or even\n      implement these mechanisms.\n
    \  -  Described Static MTU and Dynamic MTU cases separately; clarified\n      that
    the dynamic path MTU mechanism is OPTIONAL but if it is\n      implemented it
    should follow the rules in section 3.2.2.\n   -  Specified Static MTU to default
    to a MTU of 1280 to 1480 bytes,\n      and that this may be configurable.  Discussed
    the issues with\n      using Static MTU at more length.\n   -  Specified minimal
    rules for IPv4 reassembly and IPv6 MRU to\n      enhance interoperability and
    to minimize blacholes.\n   -  Restated the \"currently underway\" language about
    Type-of-Service,\n      and loosely point at [RFC2983] and [RFC3168].\n   -  Fixed
    reference to Assigned Numbers to be to online version (with\n      proper pointer
    to \"Assigned Numbers is obsolete\" RFC).\n   -  Clarified text about ingress
    filtering e.g., that it applies to\n      packet delivered to transport protocols
    on the decapsulator as\n      well as packets being forwarded by the decapsulator,
    and how the\n      decapsulator's checks help when IPv4 and IPv6 ingress filtering
    is\n      in place.\n   -  Removed unidirectional tunneling; assume all tunnels
    are\n      bidirectional, between endpoint addresses (not nodes).\n   -  Removed
    the guidelines for advertising addresses in DNS as\n      slightly out of scope,
    referring to another document for the\n      details.\n   -  Removed the SHOULD
    requirement that the link-local addresses\n      should be formed based on IPv4
    addresses.\n   -  Added a SHOULD for implementing a knob to be able to set the\n
    \     source address of the tunnel, and add discussion why this is\n      useful.\n
    \  -  Added stronger wording for source address checks: both IPv4 and\n      IPv6
    source addresses MUST be checked, and RPF-like ingress\n      filtering is optional.\n
    \  -  Rewrote security considerations to be more precise about the\n      threats
    of tunneling.\n   -  Added a note about considering using TTL=255 when encapsulating.\n
    \  -  Added more discussion in Section 3.2 why using an \"infinite\" IPv6\n      MTU
    leads to likely interoperability problems.\n   -  Added an explicit requirement
    that if both MTU determination\n      methods are used, choosing one should be
    possible on a per-tunnel\n      basis.\n   -  Clarified that ICMPv4 error handling
    is only applicable to dynamic\n      MTU determination.\n   -  Removed/clarified
    DNS record filtering; an API is a SHOULD and if\n      it does not exist, MUST
    NOT filter anything.  Decree ordering out\n      of scope, but refer to RFC3484.\n
    \  -  Add a note that the destination IPv4 address could also be a\n      multicast
    address.\n   -  Make it RECOMMENDED to provide a toggle to perform strict ingress\n
    \     filtering on an interface.\n   -  Generalize the text on the data in ICMPv4
    messages.\n   -  Made a lot of miscellaneous editorial cleanups.\n"
  title: 8.  Changes from RFC 2893
- contents:
  - "Authors' Addresses\n   Erik Nordmark\n   Sun Microsystems\n   17 Network Circle\n
    \  Menlo Park, CA 94025\n   USA\n   Phone: +1 650 786 2921\n   EMail: erik.nordmark@sun.com\n
    \  Robert E. Gilligan\n   Intransa, Inc.\n   2870 Zanker Rd., Suite 100\n   San
    Jose, CA 95134 USA\n   Phone : +1 408 678 8600\n   Fax :   +1 408 678 8800\n   EMail:
    \ bob.gilligan@acm.org\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2005).\n   This
    document is subject to the rights, licenses and restrictions\n   contained in
    BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n
    \  This document and the information contained herein are provided on an\n   \"AS
    IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n   OR IS SPONSORED
    BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING TASK FORCE
    DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT LIMITED TO
    ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT INFRINGE ANY
    RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR
    PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or
    scope of any\n   Intellectual Property Rights or other rights that might be claimed
    to\n   pertain to the implementation or use of the technology described in\n   this
    document or the extent to which any license under such rights\n   might or might
    not be available; nor does it represent that it has\n   made any independent effort
    to identify any such rights.  Information\n   on the procedures with respect to
    rights in RFC documents can be\n   found in BCP 78 and BCP 79.\n   Copies of IPR
    disclosures made to the IETF Secretariat and any\n   assurances of licenses to
    be made available, or the result of an\n   attempt made to obtain a general license
    or permission for the use of\n   such proprietary rights by implementers or users
    of this\n   specification can be obtained from the IETF on-line IPR repository
    at\n   http://www.ietf.org/ipr.\n   The IETF invites any interested party to bring
    to its attention any\n   copyrights, patents or patent applications, or other
    proprietary\n   rights that may cover technology that may be required to implement\n
    \  this standard.  Please address the information to the IETF at ietf-\n   ipr@ietf.org.\n"
  title: Intellectual Property
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
