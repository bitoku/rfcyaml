- title: __initial_text__
  contents:
  - ''
- title: Internet Research Task Force (IRTF)                           T. Krovetz
  contents:
  - "Internet Research Task Force (IRTF)                           T. Krovetz\n  \
    \             The OCB Authenticated-Encryption Algorithm\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies OCB, a shared-key blockcipher-based\n  \
    \ encryption scheme that provides confidentiality and authenticity for\n   plaintexts\
    \ and authenticity for associated data.  This document is a\n   product of the\
    \ Crypto Forum Research Group (CFRG).\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Research Task Force\n   (IRTF).  The IRTF publishes the results\
    \ of Internet-related research\n   and development activities.  These results\
    \ might not be suitable for\n   deployment.  This RFC represents the consensus\
    \ of the Crypto Forum\n   Research Group of the Internet Research Task Force (IRTF).\
    \  Documents\n   approved for publication by the IRSG are not a candidate for\
    \ any\n   level of Internet Standard; see Section 2 of RFC 5741.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7253.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2014 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................2\n\
    \   2. Notation and Basic Operations ...................................4\n  \
    \ 3. OCB Global Parameters ...........................................5\n    \
    \  3.1. Named OCB Parameter Sets and RFC 5116 Constants ............6\n   4. OCB\
    \ Algorithms ..................................................6\n      4.1. Processing\
    \ Associated Data: HASH ...........................6\n      4.2. Encryption: OCB-ENCRYPT\
    \ ....................................8\n      4.3. Decryption: OCB-DECRYPT ....................................9\n\
    \   5. Security Considerations ........................................11\n  \
    \    5.1. Nonce Requirements ........................................12\n   6.\
    \ IANA Considerations ............................................13\n   7. Acknowledgements\
    \ ...............................................13\n   8. References .....................................................14\n\
    \      8.1. Normative References ......................................14\n  \
    \    8.2. Informative References ....................................14\n   Appendix\
    \ A.  Sample Results .......................................15\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Schemes for authenticated encryption (AE) simultaneously\
    \ provide for\n   confidentiality and authentication.  While this goal would\n\
    \   traditionally be achieved by melding separate encryption and\n   authentication\
    \ mechanisms, each using its own key, integrated AE\n   schemes intertwine what\
    \ is needed for confidentiality and what is\n   needed for authenticity.  By conceptualizing\
    \ AE as a single\n   cryptographic goal, AE schemes are less likely to be misused\
    \ than\n   conventional encryption schemes.  Also, integrated AE schemes can be\n\
    \   significantly faster than what one sees from composing separate\n   confidentiality\
    \ and authenticity means.\n   When an AE scheme allows for the authentication\
    \ of unencrypted data\n   at the same time that a plaintext is being encrypted\
    \ and\n   authenticated, the scheme is an authenticated encryption with\n   associated\
    \ data (AEAD) scheme.  Associated data can be useful when,\n   for example, a\
    \ network packet has unencrypted routing information and\n   an encrypted payload.\n\
    \   OCB is an AEAD scheme that depends on a blockcipher.  This document\n   fully\
    \ defines OCB encryption and decryption except for the choice of\n   the blockcipher\
    \ and the length of authentication tag that is part of\n   the ciphertext.  The\
    \ blockcipher must have a 128-bit blocksize.  Each\n   choice of blockcipher and\
    \ tag length specifies a different variant of\n   OCB.  Several AES-based variants\
    \ are defined in Section 3.1.\n   OCB encryption and decryption employ a nonce\
    \ N, which must be\n   distinct for each invocation of the OCB encryption operation.\
    \  OCB\n   requires the associated data A to be specified when one encrypts or\n\
    \   decrypts, but it may be zero-length.  The plaintext P and the\n   associated\
    \ data A can have any bitlength.  The ciphertext C one gets\n   by encrypting\
    \ P in the presence of A consists of a ciphertext-core\n   having the same length\
    \ as P, plus an authentication tag.  One can\n   view the resulting ciphertext\
    \ as either the pair (ciphertext-core,\n   tag) or their concatenation (ciphertext-core\
    \ || tag), the difference\n   being purely how one assembles and parses ciphertexts.\
    \  This document\n   uses concatenation.\n   OCB encryption protects the confidentiality\
    \ of P and the authenticity\n   of A, N, and P.  It does this using, on average,\
    \ about a + m + 1.02\n   blockcipher calls, where a is the blocklength of A, m\
    \ is the\n   blocklength of P, and the nonce N is implemented as a counter (if\
    \ N\n   is random, then OCB uses a + m + 2 blockcipher calls).  If A is fixed\n\
    \   during a session, then, after preprocessing, there is effectively no\n   cost\
    \ to having A authenticated on subsequent encryptions, and the\n   mode will average\
    \ m + 1.02 blockcipher calls.  OCB requires a single\n   key K for the underlying\
    \ blockcipher, and all blockcipher calls are\n   keyed by K.  OCB is online. \
    \ In particular, one need not know the\n   length of A or P to proceed with encryption,\
    \ nor need one know the\n   length of A or C to proceed with decryption.  OCB\
    \ is parallelizable:\n   the bulk of its blockcipher calls can be performed simultaneously.\n\
    \   Computational work beyond blockcipher calls consists of a small and\n   fixed\
    \ number of logical operations per call.  OCB enjoys provable\n   security: the\
    \ mode of operation is secure assuming that the\n   underlying blockcipher is\
    \ secure.  As with most modes of operation,\n   security degrades as the number\
    \ of blocks processed gets large (see\n   Section 5 for details).\n   For reasons\
    \ of generality, OCB is defined to operate on arbitrary\n   bitstrings.  But for\
    \ reasons of simplicity and efficiency, most\n   implementations will assume that\
    \ strings operated on are bytestrings\n   (i.e., strings that are a multiple of\
    \ 8 bits).  To promote\n   interoperability, implementations of OCB that communicate\
    \ with\n   implementations of unknown capabilities should restrict all provided\n\
    \   values (nonces, tags, plaintexts, ciphertexts, and associated data)\n   to\
    \ bytestrings.\n   The version of OCB defined in this document is a refinement\
    \ of two\n   prior schemes.  The original OCB version was published in 2001 [OCB1]\n\
    \   and was listed as an optional component in IEEE 802.11i.  A second\n   version\
    \ was published in 2004 [OCB2] and is specified in ISO 19772.\n   The scheme described\
    \ here is called OCB3 in the 2011 paper describing\n   the mode [OCB3]; it shall\
    \ be referred to simply as OCB throughout\n   this document.  The only difference\
    \ between the algorithm of this RFC\n   and that of the [OCB3] paper is that the\
    \ tag length is now encoded\n   into the internally formatted nonce.  See [OCB3]\
    \ for complete\n   references, timing information, and a discussion of the differences\n\
    \   between the algorithms.  OCB was initially the acronym for Offset\n   Codebook\
    \ but is now the algorithm's full name.\n   OCB has received years of in-depth\
    \ analysis previous to its\n   submission to the CFRG and has been under review\
    \ by the members of\n   the CFRG for over a year.  It is the consensus of the\
    \ CFRG that the\n   security mechanisms provided by the OCB AEAD algorithm described\
    \ in\n   this document are suitable for use in providing confidentiality and\n\
    \   authentication.\n"
- title: 2.  Notation and Basic Operations
  contents:
  - "2.  Notation and Basic Operations\n   There are two types of variables used in\
    \ this specification, strings\n   and integers.  Although strings processed by\
    \ most implementations of\n   OCB will be strings of bytes, bit-level operations\
    \ are used\n   throughout this specification document for defining OCB.  String\n\
    \   variables are always written with an initial uppercase letter while\n   integer\
    \ variables are written in all lowercase.  Following C's\n   convention, a single\
    \ equals (\"=\") indicates variable assignment and\n   double equals (\"==\")\
    \ is the equality relation.  Whenever a variable\n   is followed by an underscore\
    \ (\"_\"), the underscore is intended to\n   denote a subscript, with the subscripted\
    \ expression requiring\n   evaluation to resolve the meaning of the variable.\
    \  For example, when\n   i == 2, then P_i refers to the variable P_2.\n   c^i\
    \           The integer c raised to the i-th power.\n   bitlen(S)     The length\
    \ of string S in bits (e.g., bitlen(101) ==\n                 3).\n   zeros(n)\
    \      The string made of n zero bits.\n   ntz(n)        The number of trailing\
    \ zero bits in the base-2\n                 representation of the positive integer\
    \ n.  More\n                 formally, ntz(n) is the largest integer x for which\
    \ 2^x\n                 divides n.\n   S xor T       The string that is the bitwise\
    \ exclusive-or of S and T.\n                 Strings S and T will always have\
    \ the same length.\n   S[i]          The i-th bit of the string S (indices begin\
    \ at 1, so if\n                 S is 011, then S[1] == 0, S[2] == 1, S[3] == 1).\n\
    \   S[i..j]       The substring of S consisting of bits i through j,\n       \
    \          inclusive.\n   S || T        String S concatenated with string T (e.g.,\
    \ 000 || 111\n                 == 000111).\n   str2num(S)    The base-2 interpretation\
    \ of bitstring S (e.g.,\n                 str2num(1110) == 14).\n   num2str(i,n)\
    \  The n-bit string whose base-2 interpretation is i\n                 (e.g.,\
    \ num2str(14,4) == 1110 and num2str(1,2) == 01).\n   double(S)     If S[1] ==\
    \ 0, then double(S) == (S[2..128] || 0);\n                 otherwise, double(S)\
    \ == (S[2..128] || 0) xor\n                 (zeros(120) || 10000111).\n"
- title: 3.  OCB Global Parameters
  contents:
  - "3.  OCB Global Parameters\n   To be complete, the algorithms in this document\
    \ require specification\n   of two global parameters: a blockcipher operating\
    \ on 128-bit blocks\n   and the length of authentication tags in use.\n   Specifying\
    \ a blockcipher implicitly defines the following symbols.\n   KEYLEN         The\
    \ blockcipher's key length in bits.\n   ENCIPHER(K,P)  The blockcipher function\
    \ mapping 128-bit plaintext\n                  block P to its corresponding ciphertext\
    \ block using\n                  KEYLEN-bit key K.\n   DECIPHER(K,C)  The inverse\
    \ blockcipher function mapping 128-bit\n                  ciphertext block C to\
    \ its corresponding plaintext\n                  block using KEYLEN-bit key K.\n\
    \   The TAGLEN parameter specifies the length of authentication tag used\n   by\
    \ OCB and may be any value up to 128.  Greater values for TAGLEN\n   provide greater\
    \ assurances of authenticity, but ciphertexts produced\n   by OCB are longer than\
    \ their corresponding plaintext by TAGLEN bits.\n   See Section 5 for details\
    \ about TAGLEN and security.\n   As an example, if 128-bit authentication tags\
    \ and AES with 192-bit\n   keys are to be used, then KEYLEN is 192, ENCIPHER refers\
    \ to the\n   AES-192 cipher, DECIPHER refers to the AES-192 inverse cipher, and\n\
    \   TAGLEN is 128 [AES].\n"
- title: 3.1.  Named OCB Parameter Sets and RFC 5116 Constants
  contents:
  - "3.1.  Named OCB Parameter Sets and RFC 5116 Constants\n   The following table\
    \ gives names to common OCB global parameter sets.\n   Each of the AES variants\
    \ is defined in [AES].\n           +----------------------------+-------------+--------+\n\
    \           | Name                       | Blockcipher | TAGLEN |\n          \
    \ +----------------------------+-------------+--------+\n           | AEAD_AES_128_OCB_TAGLEN128\
    \ |   AES-128   |  128   |\n           | AEAD_AES_128_OCB_TAGLEN96  |   AES-128\
    \   |   96   |\n           | AEAD_AES_128_OCB_TAGLEN64  |   AES-128   |   64 \
    \  |\n           | AEAD_AES_192_OCB_TAGLEN128 |   AES-192   |  128   |\n     \
    \      | AEAD_AES_192_OCB_TAGLEN96  |   AES-192   |   96   |\n           | AEAD_AES_192_OCB_TAGLEN64\
    \  |   AES-192   |   64   |\n           | AEAD_AES_256_OCB_TAGLEN128 |   AES-256\
    \   |  128   |\n           | AEAD_AES_256_OCB_TAGLEN96  |   AES-256   |   96 \
    \  |\n           | AEAD_AES_256_OCB_TAGLEN64  |   AES-256   |   64   |\n     \
    \      +----------------------------+-------------+--------+\n   RFC 5116 defines\
    \ an interface for authenticated-encryption schemes\n   [RFC5116].  RFC 5116 requires\
    \ the specification of certain constants\n   for each named AEAD scheme.  For\
    \ each of the OCB parameter sets\n   listed above: P_MAX, A_MAX, and C_MAX are\
    \ all unbounded; N_MIN is 1\n   byte, and N_MAX is 15 bytes.  The parameter sets\
    \ indicating the use\n   of AES-128, AES-192, and AES-256 have K_LEN equal to\
    \ 16, 24, and 32\n   bytes, respectively.\n   Each ciphertext is longer than its\
    \ corresponding plaintext by exactly\n   TAGLEN bits, and TAGLEN is given at the\
    \ end of each name.  For\n   instance, an AEAD_AES_128_OCB_TAGLEN64 ciphertext\
    \ is exactly 64 bits\n   longer than its corresponding plaintext.\n"
- title: 4.  OCB Algorithms
  contents:
  - "4.  OCB Algorithms\n   OCB is described in this section using pseudocode.  Given\
    \ any\n   collection of inputs of the required types, following the pseudocode\n\
    \   description for a function will produce the correct output of the\n   promised\
    \ type.\n"
- title: '4.1.  Processing Associated Data: HASH'
  contents:
  - "4.1.  Processing Associated Data: HASH\n   OCB has the ability to authenticate\
    \ unencrypted associated data at\n   the same time that it provides for authentication\
    \ and encrypts a\n   plaintext.  The following hash function is central to providing\
    \ this\n   functionality.  If an application has no associated data, then the\n\
    \   associated data should be considered to exist and to be the empty\n   string.\
    \  HASH, conveniently, always returns zeros(128) when the\n   associated data\
    \ is the empty string.\n   Function name:\n     HASH\n   Input:\n     K, string\
    \ of KEYLEN bits                      // Key\n     A, string of any length   \
    \                    // Associated data\n   Output:\n     Sum, string of 128 bits\
    \                       // Hash result\n   Sum is defined as follows.\n     //\n\
    \     // Key-dependent variables\n     //\n     L_* = ENCIPHER(K, zeros(128))\n\
    \     L_$ = double(L_*)\n     L_0 = double(L_$)\n     L_i = double(L_{i-1}) for\
    \ every integer i > 0\n     //\n     // Consider A as a sequence of 128-bit blocks\n\
    \     //\n     Let m be the largest integer so that 128m <= bitlen(A)\n     Let\
    \ A_1, A_2, ..., A_m and A_* be strings so that\n       A == A_1 || A_2 || ...\
    \ || A_m || A_*, and\n       bitlen(A_i) == 128 for each 1 <= i <= m.\n      \
    \ Note: A_* may possibly be the empty string.\n     //\n     // Process any whole\
    \ blocks\n     //\n     Sum_0 = zeros(128)\n     Offset_0 = zeros(128)\n     for\
    \ each 1 <= i <= m\n        Offset_i = Offset_{i-1} xor L_{ntz(i)}\n        Sum_i\
    \ = Sum_{i-1} xor ENCIPHER(K, A_i xor Offset_i)\n     end for\n     //\n     //\
    \ Process any final partial block; compute final hash value\n     //\n     if\
    \ bitlen(A_*) > 0 then\n        Offset_* = Offset_m xor L_*\n        CipherInput\
    \ = (A_* || 1 || zeros(127-bitlen(A_*))) xor Offset_*\n        Sum = Sum_m xor\
    \ ENCIPHER(K, CipherInput)\n     else\n        Sum = Sum_m\n     end if\n"
- title: '4.2.  Encryption: OCB-ENCRYPT'
  contents:
  - "4.2.  Encryption: OCB-ENCRYPT\n   This function computes a ciphertext (which\
    \ includes a bundled\n   authentication tag) when given a plaintext, associated\
    \ data, nonce,\n   and key.  For each invocation of OCB-ENCRYPT using the same\
    \ key K,\n   the value of the nonce input N must be distinct.\n   Function name:\n\
    \     OCB-ENCRYPT\n   Input:\n     K, string of KEYLEN bits                  \
    \    // Key\n     N, string of no more than 120 bits            // Nonce\n   \
    \  A, string of any length                       // Associated data\n     P, string\
    \ of any length                       // Plaintext\n   Output:\n     C, string\
    \ of length bitlen(P) + TAGLEN bits   // Ciphertext\n   C is defined as follows.\n\
    \     //\n     // Key-dependent variables\n     //\n     L_* = ENCIPHER(K, zeros(128))\n\
    \     L_$ = double(L_*)\n     L_0 = double(L_$)\n     L_i = double(L_{i-1}) for\
    \ every integer i > 0\n     //\n     // Consider P as a sequence of 128-bit blocks\n\
    \     //\n     Let m be the largest integer so that 128m <= bitlen(P)\n     Let\
    \ P_1, P_2, ..., P_m and P_* be strings so that\n       P == P_1 || P_2 || ...\
    \ || P_m || P_*, and\n       bitlen(P_i) == 128 for each 1 <= i <= m.\n      \
    \ Note: P_* may possibly be the empty string.\n     //\n     // Nonce-dependent\
    \ and per-encryption variables\n     //\n     Nonce = num2str(TAGLEN mod 128,7)\
    \ || zeros(120-bitlen(N)) || 1 || N\n     bottom = str2num(Nonce[123..128])\n\
    \     Ktop = ENCIPHER(K, Nonce[1..122] || zeros(6))\n     Stretch = Ktop || (Ktop[1..64]\
    \ xor Ktop[9..72])\n     Offset_0 = Stretch[1+bottom..128+bottom]\n     Checksum_0\
    \ = zeros(128)\n     //\n     // Process any whole blocks\n     //\n     for each\
    \ 1 <= i <= m\n        Offset_i = Offset_{i-1} xor L_{ntz(i)}\n        C_i = Offset_i\
    \ xor ENCIPHER(K, P_i xor Offset_i)\n        Checksum_i = Checksum_{i-1} xor P_i\n\
    \     end for\n     //\n     // Process any final partial block and compute raw\
    \ tag\n     //\n     if bitlen(P_*) > 0 then\n        Offset_* = Offset_m xor\
    \ L_*\n        Pad = ENCIPHER(K, Offset_*)\n        C_* = P_* xor Pad[1..bitlen(P_*)]\n\
    \        Checksum_* = Checksum_m xor (P_* || 1 || zeros(127-bitlen(P_*)))\n  \
    \      Tag = ENCIPHER(K, Checksum_* xor Offset_* xor L_$) xor HASH(K,A)\n    \
    \ else\n        C_* = <empty string>\n        Tag = ENCIPHER(K, Checksum_m xor\
    \ Offset_m xor L_$) xor HASH(K,A)\n     end if\n     //\n     // Assemble ciphertext\n\
    \     //\n     C = C_1 || C_2 || ... || C_m || C_* || Tag[1..TAGLEN]\n"
- title: '4.3.  Decryption: OCB-DECRYPT'
  contents:
  - "4.3.  Decryption: OCB-DECRYPT\n   This function computes a plaintext when given\
    \ a ciphertext,\n   associated data, nonce, and key.  An authentication tag is\
    \ embedded\n   in the ciphertext.  If the tag is not correct for the ciphertext,\n\
    \   associated data, nonce, and key, then an INVALID signal is produced.\n   Function\
    \ name:\n     OCB-DECRYPT\n   Input:\n     K, string of KEYLEN bits          \
    \            // Key\n     N, string of no more than 120 bits            // Nonce\n\
    \     A, string of any length                       // Associated data\n     C,\
    \ string of at least TAGLEN bits             // Ciphertext\n   Output:\n     P,\
    \ string of length bitlen(C) - TAGLEN bits,  // Plaintext\n          or INVALID\
    \ indicating authentication failure\n   P is defined as follows.\n     //\n  \
    \   // Key-dependent variables\n     //\n     L_* = ENCIPHER(K, zeros(128))\n\
    \     L_$ = double(L_*)\n     L_0 = double(L_$)\n     L_i = double(L_{i-1}) for\
    \ every integer i > 0\n     //\n     // Consider C as a sequence of 128-bit blocks\n\
    \     //\n     Let m be the largest integer so that 128m <= bitlen(C) - TAGLEN\n\
    \     Let C_1, C_2, ..., C_m, C_* and T be strings so that\n       C == C_1 ||\
    \ C_2 || ... || C_m || C_* || T,\n       bitlen(C_i) == 128 for each 1 <= i <=\
    \ m, and\n       bitlen(T) == TAGLEN.\n       Note: C_* may possibly be the empty\
    \ string.\n     //\n     // Nonce-dependent and per-decryption variables\n   \
    \  //\n     Nonce = num2str(TAGLEN mod 128,7) || zeros(120-bitlen(N)) || 1 ||\
    \ N\n     bottom = str2num(Nonce[123..128])\n     Ktop = ENCIPHER(K, Nonce[1..122]\
    \ || zeros(6))\n     Stretch = Ktop || (Ktop[1..64] xor Ktop[9..72])\n     Offset_0\
    \ = Stretch[1+bottom..128+bottom]\n     Checksum_0 = zeros(128)\n     //\n   \
    \  // Process any whole blocks\n     //\n     for each 1 <= i <= m\n        Offset_i\
    \ = Offset_{i-1} xor L_{ntz(i)}\n        P_i = Offset_i xor DECIPHER(K, C_i xor\
    \ Offset_i)\n        Checksum_i = Checksum_{i-1} xor P_i\n     end for\n     //\n\
    \     // Process any final partial block and compute raw tag\n     //\n     if\
    \ bitlen(C_*) > 0 then\n        Offset_* = Offset_m xor L_*\n        Pad = ENCIPHER(K,\
    \ Offset_*)\n        P_* = C_* xor Pad[1..bitlen(C_*)]\n        Checksum_* = Checksum_m\
    \ xor (P_* || 1 || zeros(127-bitlen(P_*)))\n        Tag = ENCIPHER(K, Checksum_*\
    \ xor Offset_* xor L_$) xor HASH(K,A)\n     else\n        P_* = <empty string>\n\
    \        Tag = ENCIPHER(K, Checksum_m xor Offset_m xor L_$) xor HASH(K,A)\n  \
    \   end if\n     //\n     // Check for validity and assemble plaintext\n     //\n\
    \     if (Tag[1..TAGLEN] == T) then\n        P = P_1 || P_2 || ... || P_m || P_*\n\
    \     else\n        P = INVALID\n     end if\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   OCB achieves two security properties, confidentiality\
    \ and\n   authenticity.  Confidentiality is defined via \"indistinguishability\n\
    \   from random bits\", meaning that an adversary is unable to distinguish\n \
    \  OCB outputs from an equal number of random bits.  Authenticity is\n   defined\
    \ via \"authenticity of ciphertexts\", meaning that an adversary\n   is unable\
    \ to produce any valid nonce-ciphertext pair that it has not\n   already acquired.\
    \  The security guarantees depend on the underlying\n   blockcipher being secure\
    \ in the sense of a strong pseudorandom\n   permutation.  Thus, if OCB is used\
    \ with a blockcipher that is not\n   secure as a strong pseudorandom permutation,\
    \ the security guarantees\n   vanish.  The need for the strong pseudorandom permutation\
    \ property\n   means that OCB should be used with a conservatively designed, well-\n\
    \   trusted blockcipher, such as AES.\n   Both the confidentiality and the authenticity\
    \ properties of OCB\n   degrade as per s^2 / 2^128, where s is the total number\
    \ of blocks\n   that the adversary acquires.  The consequence of this formula\
    \ is that\n   the proven security disappears when s becomes as large as 2^64.\n\
    \   Thus, the user should never use a key to generate an amount of\n   ciphertext\
    \ that is near to, or exceeds, 2^64 blocks.  In order to\n   ensure that s^2 /\
    \ 2^128 remains small, a given key should be used to\n   encrypt at most 2^48\
    \ blocks (2^55 bits or 4 petabytes), including the\n   associated data.  To ensure\
    \ these limits are not crossed, automated\n   key management is recommended in\
    \ systems exchanging large amounts of\n   data [RFC4107].\n   When a ciphertext\
    \ decrypts as INVALID, it is the implementor's\n   responsibility to make sure\
    \ that no information beyond this fact is\n   made adversarially available.\n\
    \   OCB encryption and decryption produce an internal 128-bit\n   authentication\
    \ tag.  The parameter TAGLEN determines how many bits of\n   this internal tag\
    \ are included in ciphertexts and used for\n   authentication.  The value of TAGLEN\
    \ has two impacts: an adversary\n   can trivially forge with probability 2^{-TAGLEN},\
    \ and ciphertexts are\n   TAGLEN bits longer than their corresponding plaintexts.\
    \  It is up to\n   the application designer to choose an appropriate value for\
    \ TAGLEN.\n   Long tags cost no more computationally than short ones.\n   Normally,\
    \ a given key should be used to create ciphertexts with a\n   single tag length,\
    \ TAGLEN, and an application should reject any\n   ciphertext that claims authenticity\
    \ under the same key but a\n   different tag length.  While the ciphertext core\
    \ and all of the bits\n   of the tag do depend on the tag length, this is done\
    \ for added\n   robustness to misuse and should not suggest that receivers accept\n\
    \   ciphertexts employing variable tag lengths under a single key.\n   Timing\
    \ attacks are not a part of the formal security model and an\n   implementation\
    \ should take care to mitigate them in contexts where\n   this is a concern. \
    \ To render timing attacks impotent, the amount of\n   time to encrypt or decrypt\
    \ a string should be independent of the key\n   and the contents of the string.\
    \  The only explicitly conditional OCB\n   operation that depends on private data\
    \ is double(), which means that\n   using constant-time blockcipher and double()\
    \ implementations\n   eliminates most (if not all) sources of timing attacks on\
    \ OCB.\n   Power-usage attacks are likewise out of the scope of the formal model\n\
    \   and should be considered for environments where they are threatening.\n  \
    \ The OCB encryption scheme reveals in the ciphertext the length of the\n   plaintext.\
    \  Sometimes the length of the plaintext is a valuable piece\n   of information\
    \ that should be hidden.  For environments where\n   \"traffic analysis\" is a\
    \ concern, techniques beyond OCB encryption\n   (typically involving padding)\
    \ would be necessary.\n   Defining the ciphertext that results from OCB-ENCRYPT\
    \ to be the pair\n   (C_1 || C_2 || ... || C_m || C_*, Tag[1..TAGLEN]) instead\
    \ of the\n   concatenation C_1 || C_2 || ... || C_m || C_* || Tag[1..TAGLEN]\n\
    \   introduces no security concerns.  Because TAGLEN is fixed, both\n   versions\
    \ allow ciphertexts to be parsed unambiguously.\n"
- title: 5.1.  Nonce Requirements
  contents:
  - "5.1.  Nonce Requirements\n   It is crucial that, as one encrypts, one does not\
    \ repeat a nonce.\n   The inadvertent reuse of the same nonce by two invocations\
    \ of the OCB\n   encryption operation, with the same key, but with distinct plaintext\n\
    \   values, undermines the confidentiality of the plaintexts protected in\n  \
    \ those two invocations and undermines all of the authenticity and\n   integrity\
    \ protection provided by that key.  For this reason, OCB\n   should only be used\
    \ whenever nonce uniqueness can be provided with\n   certainty.  Note that it\
    \ is acceptable to input the same nonce value\n   multiple times to the decryption\
    \ operation.  We emphasize that the\n   security consequences are quite serious\
    \ if an attacker observes two\n   ciphertexts that were created using the same\
    \ nonce and key values,\n   unless the plaintext and associated data values in\
    \ both invocations\n   of the encrypt operation were identical.  First, a loss\
    \ of\n   confidentiality ensues because the attacker will be able to infer\n \
    \  relationships between the two plaintext values.  Second, a loss of\n   authenticity\
    \ ensues because the attacker will be able to recover\n   secret information used\
    \ to provide authenticity, making subsequent\n   forgeries trivial.  Note that\
    \ there are AEAD schemes, particularly\n   the Synthetic Initialization Vector\
    \ (SIV) [RFC5297], appropriate for\n   environments where nonces are unavailable\
    \ or unreliable.  OCB is not\n   such a scheme.\n   Nonces need not be secret,\
    \ and a counter may be used for them.  If\n   two parties send OCB-encrypted plaintexts\
    \ to one another using the\n   same key, then the space of nonces used by the\
    \ two parties must be\n   partitioned so that no nonce that could be used by one\
    \ party to\n   encrypt could be used by the other to encrypt (e.g., odd and even\n\
    \   counters).\n"
- title: 6.  IANA Considerations
  contents:
  - "6.  IANA Considerations\n   The Internet Assigned Numbers Authority (IANA) has\
    \ defined a registry\n   for Authenticated Encryption with Associated Data parameters.\
    \  The\n   IANA has added the following entries to the AEAD Registry.  Each name\n\
    \   refers to a set of parameters defined in Section 3.1.\n         +----------------------------+-------------+------------+\n\
    \         | Name                       |  Reference  | Numeric ID |\n        \
    \ +----------------------------+-------------+------------+\n         | AEAD_AES_128_OCB_TAGLEN128\
    \ | Section 3.1 |     20     |\n         | AEAD_AES_128_OCB_TAGLEN96  | Section\
    \ 3.1 |     21     |\n         | AEAD_AES_128_OCB_TAGLEN64  | Section 3.1 |  \
    \   22     |\n         | AEAD_AES_192_OCB_TAGLEN128 | Section 3.1 |     23   \
    \  |\n         | AEAD_AES_192_OCB_TAGLEN96  | Section 3.1 |     24     |\n   \
    \      | AEAD_AES_192_OCB_TAGLEN64  | Section 3.1 |     25     |\n         | AEAD_AES_256_OCB_TAGLEN128\
    \ | Section 3.1 |     26     |\n         | AEAD_AES_256_OCB_TAGLEN96  | Section\
    \ 3.1 |     27     |\n         | AEAD_AES_256_OCB_TAGLEN64  | Section 3.1 |  \
    \   28     |\n         +----------------------------+-------------+------------+\n"
- title: 7.  Acknowledgements
  contents:
  - "7.  Acknowledgements\n   The design of the original OCB scheme [OCB1] was done\
    \ while Rogaway\n   was at Chiang Mai University, Thailand.  Follow-up work [OCB2]\
    \ was\n   done with support of NSF grant 0208842 and a gift from Cisco.  The\n\
    \   final work by Krovetz and Rogaway [OCB3] that has resulted in this\n   specification\
    \ was supported by NSF grant 0904380.  Thanks go to the\n   many members of the\
    \ Crypto Forum Research Group (CFRG) who provided\n   feedback on earlier drafts.\
    \  Thanks in particular go to David McGrew\n   for contributing some text and\
    \ for managing the RFC approval process,\n   to James Manger for initiating a\
    \ productive discussion on tag-length\n   dependency and for greatly improving\
    \ Appendix A, to Matt Caswell and\n   Peter Dettman for writing implementations\
    \ and verifying test vectors,\n   and to Stephen Farrell and Spencer Dawkins for\
    \ their careful reading\n   and suggestions.\n"
- title: 8.  References
  contents:
  - '8.  References

    '
- title: 8.1.  Normative References
  contents:
  - "8.1.  Normative References\n   [AES]      National Institute of Standards and\
    \ Technology, \"Advanced\n              Encryption Standard (AES)\", FIPS PUB\
    \ 197, November 2001.\n   [RFC5116]  McGrew, D., \"An Interface and Algorithms\
    \ for Authenticated\n              Encryption\", RFC 5116, January 2008.\n"
- title: 8.2.  Informative References
  contents:
  - "8.2.  Informative References\n   [OCB1]     Rogaway, P., Bellare, M., Black,\
    \ J., and T. Krovetz, \"OCB:\n              A Block-Cipher Mode of Operation for\
    \ Efficient\n              Authenticated Encryption\", ACM Conference on Computer\
    \ and\n              Communications Security 2001 - CCS 2001, ACM Press, 2001.\n\
    \   [OCB2]     Rogaway, P., \"Efficient Instantiations of Tweakable\n        \
    \      Blockciphers and Refinements to Modes OCB and PMAC\",\n              Advances\
    \ in Cryptology - ASIACRYPT 2004, Springer, 2004.\n   [OCB3]     Krovetz, T. and\
    \ P. Rogaway, \"The Software Performance of\n              Authenticated-Encryption\
    \ Modes\", Fast Software Encryption\n              - FSE 2011 Springer, 2011.\n\
    \   [RFC4107]  Bellovin, S. and R. Housley, \"Guidelines for Cryptographic\n \
    \             Key Management\", BCP 107, RFC 4107, June 2005.\n   [RFC5297]  Harkins,\
    \ D., \"Synthetic Initialization Vector (SIV)\n              Authenticated Encryption\
    \ Using the Advanced Encryption\n              Standard (AES)\", RFC 5297, October\
    \ 2008.\n"
- title: Appendix A.  Sample Results
  contents:
  - "Appendix A.  Sample Results\n   This section gives sample output values for various\
    \ inputs when using\n   OCB with AES as per the parameters defined in Section\
    \ 3.1.  All\n   strings are represented in hexadecimal (e.g., 0F represents the\n\
    \   bitstring 00001111).\n   The following 16 (N,A,P,C) tuples show the ciphertext\
    \ C that results\n   from OCB-ENCRYPT(K,N,A,P) for various lengths of associated\
    \ data (A)\n   and plaintext (P).  The key (K) has a fixed value, the tag length\
    \ is\n   128 bits, and the nonce (N) increments.\n     K : 000102030405060708090A0B0C0D0E0F\n\
    \   An empty entry indicates the empty string.\n     N: BBAA99887766554433221100\n\
    \     A:\n     P:\n     C: 785407BFFFC8AD9EDCC5520AC9111EE6\n     N: BBAA99887766554433221101\n\
    \     A: 0001020304050607\n     P: 0001020304050607\n     C: 6820B3657B6F615A5725BDA0D3B4EB3A257C9AF1F8F03009\n\
    \     N: BBAA99887766554433221102\n     A: 0001020304050607\n     P:\n     C:\
    \ 81017F8203F081277152FADE694A0A00\n     N: BBAA99887766554433221103\n     A:\n\
    \     P: 0001020304050607\n     C: 45DD69F8F5AAE72414054CD1F35D82760B2CD00D2F99BFA9\n\
    \     N: BBAA99887766554433221104\n     A: 000102030405060708090A0B0C0D0E0F\n\
    \     P: 000102030405060708090A0B0C0D0E0F\n     C: 571D535B60B277188BE5147170A9A22C3AD7A4FF3835B8C5\n\
    \        701C1CCEC8FC3358\n     N: BBAA99887766554433221105\n     A: 000102030405060708090A0B0C0D0E0F\n\
    \     P:\n     C: 8CF761B6902EF764462AD86498CA6B97\n     N: BBAA99887766554433221106\n\
    \     A:\n     P: 000102030405060708090A0B0C0D0E0F\n     C: 5CE88EC2E0692706A915C00AEB8B2396F40E1C743F52436B\n\
    \        DF06D8FA1ECA343D\n     N: BBAA99887766554433221107\n     A: 000102030405060708090A0B0C0D0E0F1011121314151617\n\
    \     P: 000102030405060708090A0B0C0D0E0F1011121314151617\n     C: 1CA2207308C87C010756104D8840CE1952F09673A448A122\n\
    \        C92C62241051F57356D7F3C90BB0E07F\n     N: BBAA99887766554433221108\n\
    \     A: 000102030405060708090A0B0C0D0E0F1011121314151617\n     P:\n     C: 6DC225A071FC1B9F7C69F93B0F1E10DE\n\
    \     N: BBAA99887766554433221109\n     A:\n     P: 000102030405060708090A0B0C0D0E0F1011121314151617\n\
    \     C: 221BD0DE7FA6FE993ECCD769460A0AF2D6CDED0C395B1C3C\n        E725F32494B9F914D85C0B1EB38357FF\n\
    \     N: BBAA9988776655443322110A\n     A: 000102030405060708090A0B0C0D0E0F1011121314151617\n\
    \        18191A1B1C1D1E1F\n     P: 000102030405060708090A0B0C0D0E0F1011121314151617\n\
    \        18191A1B1C1D1E1F\n     C: BD6F6C496201C69296C11EFD138A467ABD3C707924B964DE\n\
    \        AFFC40319AF5A48540FBBA186C5553C68AD9F592A79A4240\n     N: BBAA9988776655443322110B\n\
    \     A: 000102030405060708090A0B0C0D0E0F1011121314151617\n        18191A1B1C1D1E1F\n\
    \     P:\n     C: FE80690BEE8A485D11F32965BC9D2A32\n     N: BBAA9988776655443322110C\n\
    \     A:\n     P: 000102030405060708090A0B0C0D0E0F1011121314151617\n        18191A1B1C1D1E1F\n\
    \     C: 2942BFC773BDA23CABC6ACFD9BFD5835BD300F0973792EF4\n        6040C53F1432BCDFB5E1DDE3BC18A5F840B52E653444D5DF\n\
    \     N: BBAA9988776655443322110D\n     A: 000102030405060708090A0B0C0D0E0F1011121314151617\n\
    \        18191A1B1C1D1E1F2021222324252627\n     P: 000102030405060708090A0B0C0D0E0F1011121314151617\n\
    \        18191A1B1C1D1E1F2021222324252627\n     C: D5CA91748410C1751FF8A2F618255B68A0A12E093FF45460\n\
    \        6E59F9C1D0DDC54B65E8628E568BAD7AED07BA06A4A69483\n        A7035490C5769E60\n\
    \     N: BBAA9988776655443322110E\n     A: 000102030405060708090A0B0C0D0E0F1011121314151617\n\
    \        18191A1B1C1D1E1F2021222324252627\n     P:\n     C: C5CD9D1850C141E358649994EE701B68\n\
    \     N: BBAA9988776655443322110F\n     A:\n     P: 000102030405060708090A0B0C0D0E0F1011121314151617\n\
    \        18191A1B1C1D1E1F2021222324252627\n     C: 4412923493C57D5DE0D700F753CCE0D1D2D95060122E9F15\n\
    \        A5DDBFC5787E50B5CC55EE507BCB084E479AD363AC366B95\n        A98CA5F3000B1479\n\
    \   Next are several internal values generated during the OCB-ENCRYPT\n   computation\
    \ for the last test vector listed above.\n     L_*       : C6A13B37878F5B826F4F8162A1C8D879\n\
    \     L_$       : 8D42766F0F1EB704DE9F02C54391B075\n     L_0       : 1A84ECDE1E3D6E09BD3E058A8723606D\n\
    \     L_1       : 3509D9BC3C7ADC137A7C0B150E46C0DA\n     bottom    : 15 (decimal)\n\
    \     Ktop      : 9862B0FDEE4E2DD56DBA6433F0125AA2\n     Stretch   : 9862B0FDEE4E2DD56DBA6433F0125AA2FAD24D13A063F8B8\n\
    \     Offset_0  : 587EF72716EAB6DD3219F8092D517D69\n     Offset_1  : 42FA1BF908D7D8D48F27FD83AA721D04\n\
    \     Offset_2  : 77F3C24534AD04C7F55BF696A434DDDE\n     Offset_*  : B152F972B3225F459A1477F405FC05A7\n\
    \     Checksum_1: 000102030405060708090A0B0C0D0E0F\n     Checksum_2: 10101010101010101010101010101010\n\
    \     Checksum_*: 30313233343536379010101010101010\n   The next tuple shows a\
    \ result with a tag length of 96 bits and a\n   different key.\n     K: 0F0E0D0C0B0A09080706050403020100\n\
    \     N: BBAA9988776655443322110D\n     A: 000102030405060708090A0B0C0D0E0F1011121314151617\n\
    \        18191A1B1C1D1E1F2021222324252627\n     P: 000102030405060708090A0B0C0D0E0F1011121314151617\n\
    \        18191A1B1C1D1E1F2021222324252627\n     C: 1792A4E31E0755FB03E31B22116E6C2DDF9EFD6E33D536F1\n\
    \        A0124B0A55BAE884ED93481529C76B6AD0C515F4D1CDD4FD\n        AC4F02AA\n\
    \   The following algorithm tests a wider variety of inputs.  Results are\n  \
    \ given for each parameter set defined in Section 3.1.\n      K = zeros(KEYLEN-8)\
    \ || num2str(TAGLEN,8)\n      C = <empty string>\n      for i = 0 to 127 do\n\
    \         S = zeros(8i)\n         N = num2str(3i+1,96)\n         C = C || OCB-ENCRYPT(K,N,S,S)\n\
    \         N = num2str(3i+2,96)\n         C = C || OCB-ENCRYPT(K,N,<empty string>,S)\n\
    \         N = num2str(3i+3,96)\n         C = C || OCB-ENCRYPT(K,N,S,<empty string>)\n\
    \      end for\n      N = num2str(385,96)\n      Output : OCB-ENCRYPT(K,N,C,<empty\
    \ string>)\n   Iteration i of the loop adds 2i + (3 * TAGLEN / 8) bytes to C,\n\
    \   resulting in an ultimate length for C of 22,400 bytes when TAGLEN ==\n   128,\
    \ 20,864 bytes when TAGLEN == 192, and 19,328 bytes when TAGLEN ==\n   64.  The\
    \ final OCB-ENCRYPT has an empty plaintext component, so\n   serves only to authenticate\
    \ C.  The output should be:\n     AEAD_AES_128_OCB_TAGLEN128 Output: 67E944D23256C5E0B6C61FA22FDF1EA2\n\
    \     AEAD_AES_192_OCB_TAGLEN128 Output: F673F2C3E7174AAE7BAE986CA9F29E17\n  \
    \   AEAD_AES_256_OCB_TAGLEN128 Output: D90EB8E9C977C88B79DD793D7FFA161C\n    \
    \ AEAD_AES_128_OCB_TAGLEN96 Output : 77A3D8E73589158D25D01209\n     AEAD_AES_192_OCB_TAGLEN96\
    \ Output : 05D56EAD2752C86BE6932C5E\n     AEAD_AES_256_OCB_TAGLEN96 Output : 5458359AC23B0CBA9E6330DD\n\
    \     AEAD_AES_128_OCB_TAGLEN64 Output : 192C9B7BD90BA06A\n     AEAD_AES_192_OCB_TAGLEN64\
    \ Output : 0066BC6E0EF34E24\n     AEAD_AES_256_OCB_TAGLEN64 Output : 7D4EA5D445501CBE\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Ted Krovetz\n   Computer Science Department\n   California\
    \ State University, Sacramento\n   6000 J Street\n   Sacramento, CA  95819-6021\n\
    \   USA\n   EMail: ted@krovetz.net\n   Phillip Rogaway\n   Computer Science Department\n\
    \   University of California, Davis\n   One Shields Avenue\n   Davis, CA  95616-8562\n\
    \   USA\n   EMail: rogaway@cs.ucdavis.edu\n"
