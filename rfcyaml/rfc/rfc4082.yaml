- title: __initial_text__
  contents:
  - "     Timed Efficient Stream Loss-Tolerant Authentication (TESLA):\n         Multicast\
    \ Source Authentication Transform Introduction\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2005).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document introduces Timed Efficient Stream Loss-tolerant\n\
    \   Authentication (TESLA).  TESLA allows all receivers to check the\n   integrity\
    \ and authenticate the source of each packet in multicast or\n   broadcast data\
    \ streams.  TESLA requires no trust between receivers,\n   uses low-cost operations\
    \ per packet at both sender and receiver, can\n   tolerate any level of loss without\
    \ retransmissions, and requires no\n   per-receiver state at the sender.  TESLA\
    \ can protect receivers\n   against denial of service attacks in certain circumstances.\
    \  Each\n   receiver must be loosely time-synchronized with the source in order\n\
    \   to verify messages, but otherwise receivers do not have to send any\n   messages.\
    \  TESLA alone cannot support non-repudiation of the data\n   source to third\
    \ parties.\n   This informational document is intended to assist in writing\n\
    \   standardizable and secure specifications for protocols based on TESLA\n  \
    \ in different contexts.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................2\n\
    \      1.1. Notation ...................................................3\n  \
    \ 2. Functionality ...................................................4\n    \
    \  2.1. Threat Model and Security Guarantee ........................5\n      2.2.\
    \ Assumptions ................................................5\n   3. The Basic\
    \ TESLA Protocol ........................................6\n      3.1. Protocol\
    \ Sketch ............................................6\n      3.2. Sender Setup\
    \ ...............................................7\n      3.3. Bootstrapping Receivers\
    \ ....................................8\n           3.3.1. Time Synchronization\
    \ ................................9\n      3.4. Broadcasting Authenticated Messages\
    \ .......................10\n      3.5. Authentication at Receiver ................................11\n\
    \      3.6. Determining the Key Disclosure Delay ......................12\n  \
    \    3.7. Denial of Service Protection ..............................13\n    \
    \       3.7.1. Additional Group Authentication ....................14\n      \
    \     3.7.2. Not Re-using Keys ..................................15\n        \
    \   3.7.3. Sender Buffering ...................................17\n      3.8.\
    \ Some Extensions ...........................................17\n   4. Layer Placement\
    \ ................................................17\n   5. Security Considerations\
    \ ........................................18\n   6. Acknowledgements ...............................................19\n\
    \   7. Informative References .........................................19\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   In multicast, a single packet can reach millions of receivers.\n\
    \   Unfortunately, this introduces the danger that an attacker can\n   potentially\
    \ also reach millions of receivers with a malicious packet.\n   Through source\
    \ authentication, receivers can ensure that a received\n   multicast packet originates\
    \ from the correct source.  In these\n   respects, a multicast is equivalent to\
    \ a broadcast to a superset of\n   the multicast receivers.\n   In unicast communication,\
    \ we can achieve data authentication through\n   a simple mechanism: the sender\
    \ and the receiver share a secret key to\n   compute a message authentication\
    \ code (MAC) of all communicated data.\n   When a message with a correct MAC arrives,\
    \ the receiver is assured\n   that the sender generated that message.  Standard\
    \ mechanisms achieve\n   unicast authentication this way; for example, TLS or\
    \ IPsec [1,2].\n   Symmetric MAC authentication is not secure in a broadcast setting.\n\
    \   Consider a sender that broadcasts authentic data to mutually\n   mistrusting\
    \ receivers.  The symmetric MAC is not secure: every\n   receiver knows the MAC\
    \ key and therefore could impersonate the sender\n   and forge messages to other\
    \ receivers.  Intuitively, we need an\n   asymmetric mechanism to achieve authenticated\
    \ broadcast, such that\n   every receiver can verify the authenticity of messages\
    \ it receives,\n   without being able to generate authentic messages.  Achieving\
    \ this in\n   an efficient way is a challenging problem [3].\n   The standard\
    \ approach to achieving such asymmetry for authentication\n   is to use asymmetric\
    \ cryptography; e.g., a digital signature.\n   Digital signatures have the required\
    \ asymmetric property: the sender\n   generates the signature with its private\
    \ key, and all receivers can\n   verify the signature with the sender's public\
    \ key, but a receiver\n   with the public key alone cannot generate a digital\
    \ signature for a\n   new message.  A digital signature provides non-repudiation,\
    \ a\n   stronger property than authentication.  However, digital signatures\n\
    \   have a high cost: they have a high computation overhead for both the\n   sender\
    \ and the receiver, and most signatures also have a high-\n   bandwidth overhead.\
    \  Since we assume broadcast settings for which the\n   sender does not retransmit\
    \ lost packets, and the receiver still wants\n   to authenticate each packet it\
    \ receives immediately, we would need to\n   attach a digital signature to each\
    \ message.  Because of the high\n   overhead of asymmetric cryptography, this\
    \ approach would restrict us\n   to low-rate streams, and to senders and receivers\
    \ with powerful\n   workstations.  We can try to amortize one digital signature\
    \ over\n   multiple messages.  However, this approach is still expensive in\n\
    \   contrast to symmetric cryptography, since symmetric cryptography is\n   in\
    \ general 3 to 5 orders of magnitude more efficient than asymmetric\n   cryptography.\
    \  In addition, the straight-forward amortization of one\n   digital signature\
    \ over multiple packets requires reliability, as the\n   receiver needs to receive\
    \ all packets to verify the signature.  A\n   number of schemes that follow this\
    \ approach are [4,5,6,7].  See [8]\n   for more details.\n   This document presents\
    \ the Timed Efficient Stream Loss-tolerant\n   Authentication protocol (TESLA).\
    \  TESLA uses mainly symmetric\n   cryptography, and uses time-delayed key disclosure\
    \ to achieve the\n   required asymmetry property.  However, TESLA requires loosely\n\
    \   synchronized clocks between the sender and the receivers.  See more\n   details\
    \ in Section 3.3.1.  Schemes that follow a similar approach to\n   TESLA are [9,10,11].\n"
- title: 1.1.  Notation
  contents:
  - "1.1.  Notation\n   To denote the subscript or an index of a variable, we use\
    \ the\n   underscore between the variable name and the index; e.g., the key K\n\
    \   with index i is K_i, and the key K with index i+d is K_{i+d}.  To\n   write\
    \ a superscript, we use the caret; e.g., function F with the\n   argument x executed\
    \ i times is F^i(x).\n"
- title: 2.  Functionality
  contents:
  - "2.  Functionality\n   TESLA provides delayed per-packet data authentication and\
    \ integrity\n   checking.  The key idea to providing both efficiency and security\
    \ is\n   a delayed disclosure of keys.  The delayed key disclosure results in\n\
    \   an authentication delay.  In practice, the delay is on the order of\n   one\
    \ RTT (round-trip-time).\n   TESLA has the following properties:\n      o Low\
    \ computation overhead for generation and verification of\n        authentication\
    \ information.\n      o Low communication overhead.\n      o Limited buffering\
    \ required for the sender and the receiver, and\n        therefore timely authentication\
    \ for each individual packet.\n      o Strong robustness to packet loss.\n   \
    \   o Scales to a large number of receivers.\n      o Protects receivers from\
    \ denial of service attacks in certain\n        circumstances if configured appropriately.\n\
    \      o Each receiver cannot verify message authenticity unless it is\n     \
    \   loosely time-synchronized with the source, where synchronization\n       \
    \ can take place at session setup.  Once the session is in\n        progress,\
    \ receivers need not send any messages or\n        acknowledgements.\n      o\
    \ Non-repudiation is not supported; each receiver can know that a\n        stream\
    \ is from an authentic source, but cannot prove this to a\n        third party.\n\
    \   TESLA can be used in the network layer, in the transport layer, or in\n  \
    \ the application layer.  Delayed authentication, however, requires\n   buffering\
    \ of packets until authentication is completed.  Certain\n   applications intolerant\
    \ of delay may be willing to process packets in\n   parallel to being buffered\
    \ while awaiting authentication, as long as\n   roll-back is possible if packets\
    \ are later found to be\n   unauthenticated.  For instance, an interactive video\
    \ may play out\n   packets still awaiting authentication, but if they are later\
    \ found to\n   be unauthenticated, it could stop further play-out and warn the\n\
    \   viewer that the last x msec were unauthenticated and should be\n   ignored.\
    \  However, in the remainder of this document, for brevity, we\n   will assume\
    \ that packets are not processed in parallel to buffering.\n"
- title: 2.1.  Threat Model and Security Guarantee
  contents:
  - "2.1.  Threat Model and Security Guarantee\n   We design TESLA to be secure against\
    \ a powerful adversary with the\n   following capabilities:\n      o Full control\
    \ over the network.  The adversary can eavesdrop,\n        capture, drop, re-send,\
    \ delay, and alter packets.\n      o Access to a fast network with negligible\
    \ delay.\n      o The adversary's computational resources may be very large, but\n\
    \        not unbounded.  In particular, this means that the adversary can\n  \
    \      perform efficient computations, such as computing a reasonable\n      \
    \  number of pseudo-random function applications and MACs with\n        negligible\
    \ delay.  Nonetheless, the adversary cannot find the\n        key of a pseudo-random\
    \ function (or distinguish it from a random\n        function) with non-negligible\
    \ probability.\n   The security property of TESLA guarantees that the receiver\
    \ never\n   accepts M_i as an authentic message unless the sender really sent\n\
    \   M_i.  A scheme that provides this guarantee is called a secure\n   broadcast\
    \ authentication scheme.\n   Because TESLA expects the receiver to buffer packets\
    \ before\n   authentication, the receiver needs to protect itself from a potential\n\
    \   denial of service (DoS) attack due to a flood of bogus packets (see\n   Section\
    \ 3.8).\n"
- title: 2.2.  Assumptions
  contents:
  - "2.2.  Assumptions\n   TESLA makes the following assumptions in order to provide\
    \ security:\n      1.  The sender and the receiver must be loosely time-synchronized.\n\
    \          Specifically, each receiver must be able to compute an upper\n    \
    \      bound on the lag of the receiver clock relative to the sender\n       \
    \   clock.  We denote this quantity with D_t.  (That is, D_t =\n          sender\
    \ time - receiver time).  We note that an upper bound on\n          D_t can easily\
    \ be obtained via a simple two-message exchange.\n          (Such an exchange\
    \ can be piggybacked on any secure session\n          initiation protocol.  Alternatively,\
    \ standard protocols such\n          as NTP [15] can be used.\n      2.  TESLA\
    \ MUST be bootstrapped at session setup through a regular\n          data authentication\
    \ system.  One option is to use a digital\n          signature algorithm for this\
    \ purpose, in which case the\n          receiver is required to have an authentic\
    \ copy of either the\n          sender's public key certificate or a root key\
    \ certificate in\n          case of a PKI (public-key infrastructure).  Alternatively,\n\
    \          this initialization step can be done using any secure session\n   \
    \       initiation protocol.\n      3.  TESLA uses cryptographic MAC and PRF (pseudo-random\n\
    \          functions).  These MUST be cryptographically secure.  Further\n   \
    \       details on the instantiation of the MAC and PRF are in Section\n     \
    \     3.4.\n   We would like to emphasize that the security of TESLA does NOT\
    \ rely\n   on any assumptions about network propagation delay.\n"
- title: 3.  The Basic TESLA Protocol
  contents:
  - "3.  The Basic TESLA Protocol\n   TESLA is described in several academic publications:\
    \ A book on\n   broadcast security [12], a journal paper [13], and two conference\n\
    \   papers [7,14].  Please refer to these publications for in-depth\n   proofs\
    \ of security, experimental results, etc.\n   We first outline the main ideas\
    \ behind TESLA.\n"
- title: 3.1.  Protocol Sketch
  contents:
  - "3.1.  Protocol Sketch\n   As we argue in the introduction, broadcast authentication\
    \ requires a\n   source of asymmetry.  TESLA uses time for asymmetry.  We first\
    \ make\n   sure that the sender and receivers are loosely time-synchronized as\n\
    \   described above.  Next, the sender forms a one-way chain of keys, in\n   which\
    \ each key in the chain is associated with a time interval (say,\n   a second).\
    \  Here is the basic approach:\n      o The sender attaches a MAC to each packet.\
    \  The MAC is computed\n        over the contents of the packet.  For each packet,\
    \ the sender\n        uses the current key from the one-way chain as a cryptographic\n\
    \        key to compute the MAC.\n      o The sender discloses a key from the\
    \ one-way chain after some\n        pre-defined time delay (e.g., the key used\
    \ in time interval i is\n        disclosed at time interval i+3).\n      o Each\
    \ receiver receives the packet.  Each receiver knows the\n        schedule for\
    \ disclosing keys and, since it has an upper bound on\n        the local time\
    \ at the sender, it can check that the key used to\n        compute the MAC was\
    \ not yet disclosed by the sender.  If it was\n        not, then the receiver\
    \ buffers the packet.  Otherwise the packet\n        is dropped due to inability\
    \ to authenticate.  Note that we do\n        not know for sure whether a \"late\
    \ packet\" is a bogus one or\n        simply a delayed packet.  We drop the packet\
    \ because we are\n        unable to authenticate it.  (Of course, an implementation\
    \ may\n        choose not to drop packets and to use them unauthenticated.)\n\
    \      o Each receiver checks that the disclosed key belongs to the\n        hash-chain\
    \ (by checking against previously released keys in the\n        chain) and then\
    \ checks the correctness of the MAC.  If the MAC\n        is correct, the receiver\
    \ accepts the packet.\n   Note that one-way chains have the property that if intermediate\n\
    \   values of the one-way chain are lost, they can be recomputed using\n   subsequent\
    \ values in the chain.  Even if some key disclosures are\n   lost, a receiver\
    \ can recover the corresponding keys and check the\n   correctness of earlier\
    \ packets.\n   We now describe the stages of the basic TESLA protocol in this\
    \ order:\n   sender setup, receiver bootstrap, sender transmission of\n   authenticated\
    \ broadcast messages, and receiver authentication of\n   broadcast messages.\n"
- title: 3.2.  Sender Setup
  contents:
  - "3.2.  Sender Setup\n   The sender divides the time into uniform intervals of\
    \ duration T_int.\n   The sender assigns one key from the one-way chain to each\
    \ time\n   interval in sequence.\n   The sender determines the length N of the\
    \ one-way chain K_0,\n   K_1, ..., K_N, and this length limits the maximum transmission\n\
    \   duration before a new one-way chain must be created.  The sender\n   picks\
    \ a random value for K_N.  Using a pseudo-random function (PRF),\n   f, the sender\
    \ constructs the one-way function F: F(k) = f_k(0).  The\n   rest of the chain\
    \ is computed recursively using K_i = F(K_{i+1}).\n   Note that this gives us\
    \ K_i = F^{N-i}(K_N), so the receiver can\n   compute any value in the key chain\
    \ from K_N, even if it does not have\n   intermediate values.  The key K_i will\
    \ be used to authenticate\n   packets sent in time interval i.\n   Jakobsson [20]\
    \ and Coppersmith and Jakobsson [21] present a storage-\n   and computation-efficient\
    \ mechanism for one-way chains.  For a chain\n   of length N, storage is about\
    \ log(N) elements, and the computation\n   overhead to reconstruct each element\
    \ is also about log(N).\n   The sender determines the duration of a time interval,\
    \ T_int, and the\n   key disclosure delay, d.  (T_int is measured in time units,\
    \ say\n   milliseconds, and d is measured in number of time intervals.  That\n\
    \   is, a key that is used for time interval i will be disclosed in time\n   interval\
    \ i+d.) It is stressed that the scheme remains secure for any\n   values of T_int\
    \ and d>0.  Still, correct choice of T_int and d is\n   crucial for the usability\
    \ of the scheme.  The choice is influenced by\n   the estimated network delay,\
    \ the length of the transmission, and the\n   tolerable delay at the receiver.\
    \  A T_int that is too short will\n   cause the keys to run out too soon.  A T_int\
    \ that is too long will\n   cause excessive delay in authentication for some of\
    \ the packets\n   (those that were sent at the beginning of a time period).  A\
    \ delay d\n   that is too short will cause too many packets to be unverifiable\
    \ by\n   the receiver.  A delay d that is too long will cause excessive delay\n\
    \   in authentication.\n   The sender estimates a reasonable upper bound on the\
    \ network delay\n   between the sender and any receiver as m milliseconds.  This\
    \ includes\n   any delay expected in the stack (see Section 4, on layer placement).\n\
    \   If the sender expects to send a packet every n milliseconds, then a\n   reasonable\
    \ value for T_int is max(n,m).  Based on T_int, a rule of\n   thumb for determining\
    \ the key disclosure delay, d, is given in\n   Section 3.6.\n   The above value\
    \ for T_int is neither an upper or a lower bound; it is\n   merely the value that\
    \ reduces key change processing to a minimum\n   without causing authentication\
    \ delay to be higher than necessary.  If\n   the application can tolerate higher\
    \ authentication delay, then T_int\n   can be made appropriately larger.  Also,\
    \ if m (or n) increases during\n   the session, perhaps due to congestion or a\
    \ late joiner on a high\n   delay path, T_int need not be revised.\n   Finally,\
    \ the sender needs to allow each receiver to synchronize its\n   time with the\
    \ sender.  See more details on how this can be done in\n   Section 3.3.1.  (It\
    \ is stressed that estimating the network delay is\n   a separate task from the\
    \ time synchronization between the sender and\n   the receivers.)\n"
- title: 3.3.  Bootstrapping Receivers
  contents:
  - "3.3.  Bootstrapping Receivers\n   Before a receiver can authenticate messages\
    \ with TESLA, it needs to\n   have the following:\n      o An upper bound, D_t,\
    \ on the lag of its own clock with respect to\n        the clock of the sender.\
    \  (That is, if the local time reading is\n        t, the current time reading\
    \ at the sender is at most t+D_t.).\n      o One authenticated key of the one-way\
    \ key chain.  (Typically,\n        this will be the last key in the chain; i.e.,\
    \ K_0.  This key\n        will be signed by the sender, and all receivers will\
    \ verify the\n        signature with the public key of the signer.)\n      o The\
    \ disclosure schedule of the following keys:\n           - T_int, the interval\
    \ duration.\n           - T_0, the start time of interval 0.\n           - N,\
    \ the length of the one-way key chain.\n           - d, the key disclosure delay\
    \ d (in number of intervals).\n   The receiver can perform the time synchronization\
    \ and get the\n   authenticated TESLA parameters in a two-round message exchange,\
    \ as\n   described below.  We stress again that time synchronization can be\n\
    \   performed as part of the registration protocol between any receiver\n   (including\
    \ late joiners) and the sender, or between any receiver and\n   a group controller.\n"
- title: 3.3.1.  Time Synchronization
  contents:
  - "3.3.1.  Time Synchronization\n   Various approaches exist for time synchronization\
    \ [15,16,17,18].\n   TESLA only requires the receiver to know an upper bound on\
    \ the delay\n   of its local clock with respect to the sender's clock, so a simple\n\
    \   algorithm is sufficient.  TESLA can be used with direct, indirect,\n   and\
    \ delayed synchronization as three default options.  The specific\n   synchronization\
    \ method will be part of each instantiation of TESLA.\n   For completeness, we\
    \ sketch a simple method for direct\n   synchronization between the sender and\
    \ a receiver:\n      o The receiver sends a (sync t_r) message to the sender and\n\
    \        records its local time, t_r, at the moment of sending.\n      o Upon\
    \ receipt of the (sync t_r) message, the sender records its\n        local time,\
    \ t_s, and sends (synch, t_r,t_s) to the receiver.\n      o Upon receiving (synch,t_r,t_s),\
    \ the receiver sets D_t = t_s -\n        t_r + S, where S is an estimated bound\
    \ on the clock drift\n        throughout the duration of the session.\n   Note:\n\
    \      o Assuming that the messages are authentic (i.e., the message\n       \
    \ received by the receiver was actually sent by the sender), and\n        assuming\
    \ that the clock drift is at most S, then at any point\n        throughout the\
    \ session T_s < T_r + D_t, where T_s is the current\n        time at the sender\
    \ and T_r is the current time at the receiver.\n      o The exchange of sync messages\
    \ needs to be authenticated.  This\n        can be done in a number of ways; for\
    \ instance, with a secure NTP\n        protocol or in conjunction with a session\
    \ set-up protocol.\n   For indirect time synchronization (e.g., synchronization\
    \ via a group\n   controller), the sender and the controller engage in a protocol\
    \ for\n   finding the value D^0_t between them.  Next, each receiver, R,\n   interacts\
    \ with the group controller (say, when registering to the\n   group) and finds\
    \ the value D^R_t between the group controller and R.\n   The overall value of\
    \ D_t within R is set to the sum D_t = D^R_t +\n   D^0_t.\n"
- title: 3.4.  Broadcasting Authenticated Messages
  contents:
  - "3.4.  Broadcasting Authenticated Messages\n   Each key in the one-way key chain\
    \ corresponds to a time interval.\n   Every time a sender broadcasts a message,\
    \ it appends a MAC to the\n   message, using the key corresponding to the current\
    \ time interval.\n   The key remains secret for the next d-1 intervals, so messages\
    \ that a\n   sender broadcasts in interval j effectively disclose key K_j-d. \
    \ We\n   call d the key disclosure delay.\n   We do not want to use the same key\
    \ multiple times in different\n   cryptographic operations; that is, using key\
    \ K_j to derive the\n   previous key of the one-way key chain K_{j-1}, and using\
    \ the same key\n   K_j as the key to compute the MACs in time interval j may potentially\n\
    \   lead to a cryptographic weakness.  Using a pseudo-random function\n   (PRF),\
    \ f', we construct the one-way function F': F'(k) = f'_k(1).  We\n   use F' to\
    \ derive the key to compute the MAC of messages in each\n   interval.  The sender\
    \ derives the MAC key as follows: K'_i = F'(K_i).\n   Figure 1 depicts the one-way\
    \ key chain construction and MAC key\n   derivation.  To broadcast message M_j\
    \ in interval i the sender\n   constructs the packet\n                   P_j =\
    \ {M_j || i || MAC(K'_i,M_j) || K_{i-d}}\n      where || denotes concatenation.\n\
    \                       F(K_i)     F(K_{i+1})      F(K_{i+2})\n             K_{i-1}\
    \ <------- K_i <------- K_{i+1} <------- K_{i+2}\n                 |         \
    \    |              |\n                 | F'(K_{i-1}) | F'(K_i)      | F'(K_{i+1})\n\
    \                 |             |              |\n                 V         \
    \    V              V\n                K'_{i-1}      K'_i          K'_{i+1}\n\
    \   Figure 1: At the top of the figure, we see the one-way key chain\n   (derived\
    \ using the one-way function F), and the derived MAC keys\n   (derived using the\
    \ one-way function F').\n"
- title: 3.5.  Authentication at Receiver
  contents:
  - "3.5.  Authentication at Receiver\n   Once a sender discloses a key, we must assume\
    \ that all parties might\n   have access to that key.  An adversary could create\
    \ a bogus message\n   and forge a MAC using the disclosed key.  So whenever a\
    \ packet\n   arrives, the receiver must verify that the MAC is based on a safe\n\
    \   key; a safe key is one that is still secret (known only by the\n   sender).\
    \  We define a safe packet or safe message as one with a MAC\n   that is computed\
    \ with a safe key.\n   If a packet proves safe, it will be buffered, only to be\
    \ released\n   when its own key, disclosed in a later packet, proves its\n   authenticity.\
    \  Although a newly arriving packet cannot immediately be\n   authenticated, it\
    \ may disclose a new key so that earlier, buffered\n   packets can be authenticated.\
    \  Any newly disclosed key must be\n   checked to determine whether it is genuine;\
    \ then authentication of\n   buffered packets that have been waiting for it can\
    \ proceed.\n   We now describe TESLA authentication at the receiver with more\n\
    \   detail, listing all of these steps in the exact order they should be\n   carried\
    \ out:\n      1.  Safe packet test: When the receiver receives packet P_j, which\n\
    \          carries an interval index i, and a disclosed key K_{i-d}, it\n    \
    \      first records local time T at which the packet arrived.  The\n        \
    \  receiver then computes an upper bound t_j on the sender's\n          clock\
    \ at the time when the packet arrived: t_j = T + D_t.  To\n          test whether\
    \ the packet is safe, the receiver then computes\n          the highest interval\
    \ x the sender could possibly be in; namely\n          x = floor((t_j - T_0) /\
    \ T_int).  The receiver verifies that x\n          < i + d (where i is the interval\
    \ index), which implies that\n          the sender is not yet in the interval\
    \ during which it\n          discloses the key K_i.\n          Even if the packet\
    \ is safe, the receiver cannot yet verify the\n          authenticity of this\
    \ packet sent in interval i without key\n          K_i, which will be disclosed\
    \ later.  Instead, it adds the\n          triplet ( i, M_j, MAC( K'_i, M_j) )\
    \ to a buffer and verifies\n          the authenticity after it learns K'_i.\n\
    \          If the packet is unsafe, then the receiver considers the\n        \
    \  packet unauthenticated.  It should discard unsafe packets,\n          but,\
    \ at its own risk it may choose to use them unverified.\n      2.  New key index\
    \ test: Next the receiver checks whether a key K_v\n          has already been\
    \ disclosed with the same index v as the\n          current disclosed key K_{i-d},\
    \ or with a later one; that is,\n          with v >= i-d.\n      3.  Key verification\
    \ test: If the disclosed key index is new, the\n          receiver checks the\
    \ legitimacy of K_{i-d} by verifying, for\n          some earlier disclosed key\
    \ K_v (v<i-d), that K_v = F^{i-d-\n          v}(K_{i-d}).\n          If key verification\
    \ fails, the newly arrived packet P_j should\n          be discarded.\n      4.\
    \  Message verification tests: If the disclosed key is\n          legitimate,\
    \ the receiver then verifies the authenticity of any\n          earlier safe,\
    \ buffered packets of interval i-d.  To\n          authenticate one of the buffered\
    \ packets P_h containing\n          message M_h protected with a MAC that used\
    \ key index i-d, the\n          receiver will compute K'_{i-d} = F'(K_{i-d}) from\
    \ which it can\n          compute MAC( K'_{i-d}, M_h).\n          If this MAC\
    \ equals the MAC stored in the buffer, the packet is\n          authenticated\
    \ and can be released from the buffer.  If the\n          MACs do not agree, the\
    \ buffered packet P_h should be\n          discarded.\n          The receiver\
    \ continues to verify and release (or not) any\n          remaining buffered packets\
    \ that depend on the newly disclosed\n          key K_{i-d}.\n   Using a disclosed\
    \ key, we can calculate all previous disclosed keys,\n   so even if packets are\
    \ lost, we will still be able to verify\n   buffered, safe packets from earlier\
    \ time intervals.  Thus, if i-d-\n   v>1, the receiver can also verify the authenticity\
    \ of the stored\n   packets of intervals v+1 ... i-d-1.\n"
- title: 3.6.  Determining the Key Disclosure Delay
  contents:
  - "3.6.  Determining the Key Disclosure Delay\n   An important TESLA parameter is\
    \ the key disclosure delay d.  Although\n   the choice of the disclosure delay\
    \ does not affect the security of\n   the system, it is an important performance\
    \ factor.  A short\n   disclosure delay will cause packets to lose their safety\
    \ property, so\n   receivers will not be able to authenticate them; but a long\n\
    \   disclosure delay leads to a long authentication delay for receivers.\n   We\
    \ recommend determining the disclosure delay as follows: In direct\n   time synchronization,\
    \ let the RTT, 2m, be a reasonable upper bound on\n   the round trip time between\
    \ the sender and any receiver including\n   worst-case congestion delay and worst-case\
    \ buffering delay in host\n   stacks.  Then choose d = ceil( 2m / T_int) + 1.\
    \  Note that rounding\n   up the quotient ensures that d >= 2.  Also note that\
    \ a disclosure\n   delay of one time interval (d=1) does not work.  Consider packets\n\
    \   sent close to the boundary of the time interval: After the network\n   propagation\
    \ delay and the receiver time synchronization error, a\n   receiver will not be\
    \ able to authenticate the packet, because the\n   sender will already be in the\
    \ next time interval when it discloses\n   the corresponding key.\n   Measuring\
    \ the delay to each receiver before determining m will still\n   not adequately\
    \ predict the upper bound on delay to late joiners, or\n   where congestion delay\
    \ rises later in the session.  It may be\n   adequate to use a hard-coded historic\
    \ estimate of worst-case delay\n   (e.g., round trip delays to any host on the\
    \ intra-planetary Internet\n   rarely exceed 500msec if routing remains stable).\n\
    \   We stress that the security of TESLA does not rely on any assumptions\n  \
    \ about network propagation delay: If the delay is longer than\n   expected, then\
    \ authentic packets may be considered unauthenticated.\n   Still, no inauthentic\
    \ packet will be accepted as authentic.\n"
- title: 3.7.  Denial of Service Protection
  contents:
  - "3.7.  Denial of Service Protection\n   Because TESLA authentication is delayed,\
    \ receivers seem vulnerable to\n   flooding attacks that cause them to buffer\
    \ excess packets, even\n   though they may eventually prove to be inauthentic.\
    \  When TESLA is\n   deployed in an environment with a threat of flooding attacks,\
    \ the\n   receiver can take a number of extra precautions.\n   First, we list\
    \ simple DoS mitigation precautions that can and should\n   be taken by any receiver\
    \ independently of others, thus requiring no\n   changes to the protocol or sender\
    \ behaviour.  We precisely specify\n   where these extra steps interleave with\
    \ the receiver authentication\n   steps already given in Section 3.5.\n      o\
    \ Session validity test: Before the safe packet test (Step 1),\n        check\
    \ that arriving packets have a valid source IP address and\n        port number\
    \ for the session, that they do not replay a message\n        already received\
    \ in the session, and that they are not\n        significantly larger than the\
    \ packet sizes expected in the\n        session.\n      o Reasonable misordering\
    \ test: Before the key verification test\n        (Step 3), check whether the\
    \ disclosed key index i-d of the\n        arriving packet is within g of the previous\
    \ highest disclosed\n        key index v; thus, for example, i-d-v <= g.  g sets\
    \ the\n        threshold beyond which an out-of-order key index is assumed to\n\
    \        be malicious rather than just misordered.  Without this test, an\n  \
    \      attacker could exploit the iterated test in Step 3 to make\n        receivers\
    \ consume inordinate CPU time checking along the hash\n        chain for what\
    \ appear to be extremely misordered packets.\n        Each receiver can independently\
    \ adapt g to prevailing attack\n        conditions; for instance, by using the\
    \ following algorithm.\n        Initially, g should be set to g_max (say, 16).\
    \  But whenever an\n        arriving packet fails the reasonable misordering test\
    \ above or\n        the key verification test (Step 3), g should be dropped to\
    \ g_min\n        (>0 and typically 1).  At each successful key verification (Step\n\
    \        3), g should be incremented by 1 unless it is already g_max.\n      \
    \  These precautions will guarantee that sustained attack packets\n        cannot\
    \ cause the receiver to execute more than an average of\n        g_min hashes\
    \ each, unless they are paced against genuine\n        packets.  In the latter\
    \ case, attacks are limited to\n        g_max/(g_max-g_min) hashes per each genuine\
    \ packet.\n        When choosing g_max and g_min, note that they limit the average\n\
    \        gap in a packet sequence to g.max(n,m)/n packets (see Section\n     \
    \   3.2 for definitions of n and m).  So with g=1, m=100msec RTT,\n        and\
    \ n=4msec inter-packet period, reordering would be limited to\n        gaps of\
    \ 25 packets on average.  Bigger naturally occurring gaps\n        would have\
    \ to be written off as if they were losses.\n   Stronger DoS protection requires\
    \ that both senders and receivers\n   arrange additional constraints on the protocol.\
    \  Below, we outline\n   three alternative extensions to basic TESLA; the first\
    \ adding group\n   authentication, the second not re-using keys during a time\
    \ interval,\n   and the third moving buffering to the sender.\n   It is important\
    \ to understand the applicability of each scheme, as\n   the first two schemes\
    \ use slightly more (but bounded) resources in\n   order to prevent attackers\
    \ from consuming unbounded resources.\n   Adding group authentication requires\
    \ larger per-packet overhead.\n   Never re-using a key requires both ends to process\
    \ two hashes per\n   packet (rather than per time interval), and the sender must\
    \ store or\n   re-generate a longer hash chain.  The merits of each scheme,\n\
    \   summarised after each is described below, must be weighed against\n   these\
    \ additional costs.\n"
- title: 3.7.1.  Additional Group Authentication
  contents:
  - "3.7.1.  Additional Group Authentication\n   This scheme simply involves addition\
    \ of a group MAC to every packet.\n   That is, a shared key K_g common to the\
    \ whole group is communicated\n   as an additional step during receiver bootstrap\
    \ (Section 3.3).  Then,\n   during broadcast of message M_j (Section 3.4), the\
    \ sender computes\n   the group MAC of each packet MAC(K_g, P_j), which it appends\
    \ to the\n   packet header.  Note that the group MAC covers the whole packet P_j;\n\
    \   that is, the concatenation of the message M_j and the additional\n   TESLA\
    \ authentication material, using the formula in Section 3.4.\n   Immediately upon\
    \ packet arrival, each receiver can check that each\n   packet came from a group\
    \ member, by recomputing and comparing the\n   group MAC.\n   Note that TESLA\
    \ source authentication is only necessary when other\n   group members cannot\
    \ be trusted to refrain from spoofing the source;\n   otherwise, simpler group\
    \ authentication would be sufficient.\n   Therefore, additional group authentication\
    \ will only make sense in\n   scenarios where other group members are trusted\
    \ to refrain from\n   flooding the group, but where they are still not trusted\
    \ to refrain\n   from spoofing the source.\n"
- title: 3.7.2.  Not Re-using Keys
  contents:
  - "3.7.2.  Not Re-using Keys\n   In TESLA as described so far, each MAC key was\
    \ used repeatedly for\n   all the packets sent in a time interval.  If instead\
    \ the sender were\n   to guarantee never to use a MAC key more than once, each\
    \ disclosed\n   key could assume an additional purpose on top of authenticating\
    \ a\n   previously buffered packet.  Each key would also immediately show\n  \
    \ each receiver that the sender of each arriving packet knew the next\n   key\
    \ back along the hash chain, which is now only disclosed once,\n   similar to\
    \ S/KEY [22].  Therefore a reasonable receiver strategy\n   would be to discard\
    \ any arriving packets that disclosed a key seen\n   already.  The fill rate of\
    \ the receiver's buffer would then be\n   clocked by each packet revealed by the\
    \ genuine sender, preventing\n   memory flooding attacks.\n   An attacker with\
    \ control of a network element or of a faster bypass\n   network could intercept\
    \ messages and overtake or replace them with\n   different messages but with the\
    \ same keys.  However, as long as\n   packets are only buffered if they also pass\
    \ the delay safety test,\n   these bogus packets will fail TESLA verification\
    \ after the disclosure\n   delay.  Admittedly, receivers could be fooled into\
    \ discarding genuine\n   messages that had been overtaken by bogus ones.  But\
    \ it is hard to\n   overtake messages without compromising a network element,\
    \ and any\n   attacker that can compromise a network element can discard genuine\n\
    \   messages anyway.  We will now describe this scheme in more detail.\n   For\
    \ the sender, the scheme is hardly different from TESLA.  It merely\n   uses an\
    \ interval duration short enough to ensure a new key back along\n   the hash chain\
    \ for each packet.  So the rule of thumb given in\n   Section 3.2 for an efficient\
    \ re-keying interval T_int no longer\n   applies.  Instead, T_int is simply n,\
    \ the inter-arrival time between\n   packets in milliseconds.  The rule of thumb\
    \ for calculating d, the\n   key disclosure delay, remains unchanged from that\
    \ given in Section\n   3.6.\n   If the packet rate is likely to vary, for safety\
    \ n should be taken as\n   the minimum inter-departure time between any two packets.\
    \  (In fact,\n   n need not be so strict; it can be the minimum average packet\
    \ inter-\n   departure time over any burst of d packets expected throughout the\n\
    \   session.)\n   Note that if the packet rate slows down, whenever no packets\
    \ are sent\n   in a key change interval, the key index must increment along the\
    \ hash\n   chain once for each missed interval.  (During a burst, if the less\n\
    \   strict definition of n above has been used, packets may need to\n   depart\
    \ before their key change interval.  The sender can safely\n   continue changing\
    \ the key for each packet, using keys from future key\n   intervals, because if\
    \ n has been chosen as defined above, such bursts\n   will never sustain long\
    \ enough to cause the associated key to be\n   disclosed in a period less than\
    \ the disclosure delay later.)\n   To be absolutely clear, the precise guarantees\
    \ that the sender keeps\n   to by following the above guidance are:\n      o not\
    \ to re-use a MAC key,\n      o not to use a MAC key K_i after its time interval\
    \ i, and\n      o not to disclose key K_i sooner than the disclosure delay d *\n\
    \        T_int following the packet it protects.\n   Sender setup, receiver bootstrapping,\
    \ and broadcasting authenticated\n   messages are otherwise all identical to the\
    \ descriptions in Sections\n   3.2, 3.3, and 3.4, respectively.  However, the\
    \ following step must be\n   added to the receiver authentication steps in Section\
    \ 3.5:\n      o After Step 2, if a packet arrives carrying a key index i-d that\n\
    \        has already been received, it should not be buffered.\n   This simple\
    \ scheme would suffice against DoS, were it not for the\n   fact that a network\
    \ sometimes misorders packets without being\n   compromised.  Even without control\
    \ of a network element, an attacker\n   can opportunistically exploit such openings\
    \ to fool a receiver into\n   buffering a bogus packet and discarding a later\
    \ genuine one.  A\n   receiver can choose to set aside a fixed size cache and\
    \ can manage it\n   to minimise the chances of discarding a genuine packet.  However,\n\
    \   given such vulnerabilities are rare and unpredictable, it is simpler\n   to\
    \ count these events as additions to the network loss rate.  As\n   always, TESLA\
    \ authentication will still uncover any bogus packets\n   after the disclosure\
    \ delay.\n   To summarise, avoiding re-using keys has the following properties,\n\
    \   even under extreme flooding attacks:\n      o After delayed TESLA authentication,\
    \ packets arriving within the\n        disclosure delay will always be identified\
    \ as authentic if they\n        are and as inauthentic if they are not authentic.\n\
    \      o The fill rate of the receiver's buffer is clocked by each packet\n  \
    \      revealed by the genuine sender, preventing memory flooding\n        attacks.\n\
    \      o An attacker with control of a network element can cause any loss\n  \
    \      rate it chooses (but that's always true anyway).\n      o Where attackers\
    \ do not have control of any network elements, the\n        effective loss rate\
    \ is bounded by the sum of the network's\n        actual loss rate and its re-ordering\
    \ rate.\n"
- title: 3.7.3.  Sender Buffering
  contents:
  - "3.7.3.  Sender Buffering\n   Buffering of packets can be moved to the sender\
    \ side; then receivers\n   can authenticate packets immediately upon receipt.\
    \  This method is\n   described in [14].\n"
- title: 3.8.  Some Extensions
  contents:
  - "3.8.  Some Extensions\n   Let us mention two salient extensions of the basic\
    \ TESLA scheme.  A\n   first extension allows having multiple TESLA authentication\
    \ chains\n   for a single stream, where each chain uses a different delay for\n\
    \   disclosing the keys.  This extension is typically used to deal with\n   heterogeneous\
    \ network delays within a single multicast transmission.\n   A second extension\
    \ allows having most of the buffering of packets at\n   the sender side (rather\
    \ than at the receiver side).  Both extensions\n   are described in [14].\n  \
    \ TESLA's requirement that a key be received in a later packet for\n   authentication\
    \ prevents a receiver from authenticating the last part\n   of a message.  Thus,\
    \ to enable authentication of the last part of a\n   message or of the last message\
    \ before a transmission suspension, the\n   sender needs to send an empty message\
    \ with the key.\n"
- title: 4.  Layer Placement
  contents:
  - "4.  Layer Placement\n   TESLA authentication can be performed at any layer in\
    \ the networking\n   stack.  Three natural places are the network, transport,\
    \ or\n   application layer.  We list some considerations regarding the choice\n\
    \   of layer:\n      o Performing TESLA in the network layer has the advantage\
    \ that the\n        transport or application layer only receives authenticated\
    \ data,\n        potentially aiding a reliability protocol and mitigating denial\n\
    \        of service attacks.  (Indeed, reliable multicast tools based on\n   \
    \     forward error correction are highly susceptible to denial of\n        service\
    \ due to bogus packets.)\n      o Performing TESLA in either the transport or\
    \ the application\n        layer has the advantage that the network layer remains\n\
    \        unchanged, but it has the potential drawback that packets are\n     \
    \   obtained by the application layer only after being processed by\n        the\
    \ transport layer.  Consequently, if buffering is used in the\n        transport,\
    \ then this may introduce additional and unpredictable\n        delays on top\
    \ of the unavoidable network delays.\n      o Note that because TESLA relies upon\
    \ timing of packets, deploying\n        TESLA on top of a protocol or layer that\
    \ aggressively buffers\n        packets and hides the true packet arrival time\
    \ will\n        significantly reduce TESLA's performance.\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   See the academic publications on TESLA [7,13,19]\
    \ for several security\n   analyses.  Regarding the security of implementations,\
    \ by far the most\n   delicate point is the verification of the timing conditions.\
    \  Care\n   should be taken to make sure that (a) the value bound D_t on the\n\
    \   clock skew is calculated according to the spec at session setup and\n   that\
    \ (b) the receiver records the arrival time of the packet as soon\n   as possible\
    \ after the packet's arrival, and computes the safety\n   condition correctly.\n\
    \   It should be noted that a change to the key disclosure schedule for a\n  \
    \ message stream should never be declared within the message stream\n   itself.\
    \  This would introduce a vulnerability, because a receiver\n   that did not receive\
    \ the notification of the change would still\n   believe in the old key disclosure\
    \ schedule.\n   Finally, in common with all authentication schemes, if verification\n\
    \   is located separately from the ultimate destination application\n   (e.g.,\
    \ an IPSec tunnel end point), a trusted channel must be present\n   between verification\
    \ and the application.  For instance, the\n   interface between the verifier and\
    \ the application might simply\n   assume that packets received by the application\
    \ must have been\n   verified by the verifier (because otherwise they would have\
    \ been\n   dropped).  The application is then vulnerable to reception of packets\n\
    \   that have managed to bypass the verifier.\n"
- title: 6.  Acknowledgements
  contents:
  - "6.  Acknowledgements\n   We would like to thank the following for their feedback\
    \ and support:\n   Mike Luby, Mark Baugher, Mats Naslund, Dave McGrew, Ross Finlayson,\n\
    \   Sylvie Laniepce, Lakshminath Dondeti, Russ Housley, and the IESG\n   reviewers.\n"
- title: 7.  Informative References
  contents:
  - "7.  Informative References\n   [1]  Dierks, T. and C. Allen, \"The TLS Protocol\
    \ Version 1.0\", RFC\n        2246, January 1999.\n   [2]  IPsec, \"IP Security\
    \ Protocol, IETF working group\"\n        http://www.ietf.org/html.charters/OLD/ipsec-charter.html.\n\
    \   [3]  D. Boneh, G. Durfee, and M. Franklin, \"Lower bounds for\n        multicast\
    \ message authentication,\" in Advances in Cryptology --\n        EUROCRYPT 2001\
    \ (B. Pfitzmann, ed.), Vol. 2045 of Lecture Notes\n        in Computer Science,\
    \ (Innsbruck, Austria), p. 434-450,\n        Springer-Verlag, Berlin Germany,\
    \ 2001.\n   [4]  R. Gennaro and P. Rohatgi, \"How to Sign Digital Streams\", tech.\n\
    \        rep., IBM T.J.Watson Research Center, 1997.\n   [5]  P. Rohatgi, \"A\
    \ compact and fast hybrid signature scheme for\n        multicast packet authentication\"\
    , 6th ACM Conference on Computer\n        and Communications Security , November\
    \ 1999.\n   [6]  C. K. Wong and S. S. Lam, \"Digital signatures for flows and\n\
    \        multicasts,\" in Proc. IEEE ICNP `98, 1998.\n   [7]  A. Perrig, R. Canetti,\
    \ J. Tygar, and D. X. Song, \"Efficient\n        authentication and signing of\
    \ multicast streams over lossy\n        channels\", IEEE Symposium on Security\
    \ and Privacy, May 2000.\n   [8]  R. Canetti, J. Garay, G. Itkis, D. Micciancio,\
    \ M. Naor, and B.\n        Pinkas, \"Multicast security: A taxonomy and some efficient\n\
    \        constructions\", Infocom '99, 1999.\n   [9] S. Cheung, \"An efficient\
    \ message authentication scheme for link\n        state routing\", 13th Annual\
    \ Computer Security Applications\n        Conference, 1997.\n   [10] F. Bergadano,\
    \ D. Cavagnino, and B. Crispo, \"Chained stream\n        authentication,\" in\
    \ Selected Areas in Cryptography 2000,\n        (Waterloo, Canada), August 2000.\
    \ A talk describing this scheme\n        was given at IBM Watson in August 1998.\n\
    \   [11] F. Bergadano, D. Cavalino, and B. Crispo, \"Individual single\n     \
    \   source authentication on the mbone\", ICME 2000, August 2000. A\n        talk\
    \ containing this work was given at IBM Watson, August 1998.\n   [12] A. Perrig\
    \ and J. D. Tygar, Secure Broadcast Communication in\n        Wired and Wireless\
    \ Networks Kluwer Academic Publishers, October\n        2002.  ISBN 0792376501.\n\
    \   [13] A. Perrig, R. Canetti, J. D. Tygar, and D. Song, \"The tesla\n      \
    \  broadcast authentication protocol,\" RSA CryptoBytes, Volume 5,\n        No.\
    \ 2 Summer/Fall 2002.\n   [14] A. Perrig, R. Canetti, D. Song, and J. D. Tygar,\
    \ \"Efficient and\n        secure source authentication for multicast\", Network\
    \ and\n        Distributed System Security Symposium, NDSS '01, p. 35-46,\n  \
    \      February 2001.\n   [15] Mills, D., \"Network Time Protocol (Version 3)\
    \ Specification,\n        Implementation and Analysis\", RFC 1305, March 1992.\n\
    \   [16] B. Simons, J. Lundelius-Welch, and N. Lynch, \"An overview of\n     \
    \   clock synchronization\", Fault-Tolerant Distributed Computing (B.\n      \
    \  Simons and A. Spector, eds.), No. 448 in LNCS, p. 84-96,\n        Springer-Verlag,\
    \ Berlin Germany, 1990.\n   [17] D. Mills, \"Improved algorithms for synchronizing\
    \ computer\n        network clocks\", Proceedings of the conference on Communications\n\
    \        architectures, protocols and applications, SIGCOMM 94, (London,\n   \
    \     England), p. 317-327, 1994.\n   [18] L. Lamport and P. Melliar-Smith, \"\
    Synchronizing clocks in the\n        presence of faults\", J. ACM, Volume 32,\
    \ No. 1, p. 52-78, 1985.\n   [19] P. Broadfoot and G. Lowe, \"Analysing a Stream\
    \ Authentication\n        Protocol using Model Checking\", Proceedings of the\
    \ 7th European\n        Symposium on Research in Computer Security (ESORICS),\
    \ 2002.\n   [20] M. Jakobsson, \"Fractal hash sequence representation and\n  \
    \      traversal\", Cryptology ePrint Archive,\n        http://eprint.iacr.org/2002/001/,\
    \ January 2002.\n   [21] D. Coppersmith and M. Jakobsson, \"Almost optimal hash\
    \ sequence\n        traversal\", Proceedings of the Sixth International Financial\n\
    \        Cryptography Conference (FC '02), March 2002.\n   [22] Haller, N., \"\
    The S/KEY One-Time Password System\", RFC 1760,\n        February 1995.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Adrian Perrig\n   ECE Department\n   Carnegie Mellon University\n\
    \   Pittsburgh, PA 15218\n   US\n   EMail: perrig@cmu.edu\n   Ran Canetti\n  \
    \ IBM Research\n   30 Saw Mill River Rd\n   Hawthorne, NY 10532\n   US\n   EMail:\
    \ canetti@watson.ibm.com\n   Dawn Song\n   ECE Department\n   Carnegie Mellon\
    \ University\n   Pittsburgh, PA 15218\n   US\n   EMail: dawnsong@cmu.edu\n   J.\
    \ D. Tygar\n   UC Berkeley - EECS & SIMS\n   102 South Hall 4600\n   Berkeley,\
    \ CA  94720-4600\n   US\n   EMail: doug.tygar@gmail.com\n   Bob Briscoe\n   BT\
    \ Research\n   B54/77, BT Labs\n   Martlesham Heath\n   Ipswich, IP5 3RE\n   UK\n\
    \   EMail: bob.briscoe@bt.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2005).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
