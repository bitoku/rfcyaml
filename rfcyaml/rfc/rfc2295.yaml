- title: __initial_text__
  contents:
  - '                Transparent Content Negotiation in HTTP

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard of any kind.\n   Discussion\
    \ and suggestions for improvement are requested.\n   Distribution of this memo\
    \ is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1998).  All Rights Reserved.\n"
- title: ABSTRACT
  contents:
  - "ABSTRACT\n   HTTP allows web site authors to put multiple versions of the same\n\
    \   information under a single URL.  Transparent content negotiation is\n   an\
    \ extensible negotiation mechanism, layered on top of HTTP, for\n   automatically\
    \ selecting the best version when the URL is accessed.\n   This enables the smooth\
    \ deployment of new web data formats and markup\n   tags.\n"
- title: TABLE OF CONTENTS
  contents:
  - "TABLE OF CONTENTS\n   1  Introduction................................................4\n\
    \    1.1 Background................................................4\n   2  Terminology.................................................5\n\
    \    2.1 Terms from HTTP/1.1.......................................5\n    2.2\
    \ New terms.................................................6\n   3  Notation....................................................8\n\
    \   4  Overview....................................................9\n    4.1\
    \ Content negotiation.......................................9\n    4.2 HTTP/1.0\
    \ style negotiation scheme.........................9\n    4.3 Transparent content\
    \ negotiation scheme...................10\n    4.4 Optimizing the negotiation\
    \ process.......................12\n    4.5 Downwards compatibility with non-negotiating\
    \ user agents.14\n    4.6 Retrieving a variant by hand.............................15\n\
    \    4.7 Dimensions of negotiation................................15\n    4.8\
    \ Feature negotiation......................................15\n    4.9 Length\
    \ of variant lists..................................16\n    4.10 Relation with\
    \ other negotiation schemes.................16\n   5  Variant descriptions.......................................17\n\
    \    5.1 Syntax...................................................17\n    5.2\
    \ URI......................................................17\n    5.3 Source-quality...........................................18\n\
    \    5.4 Type, charset, language, and length......................19\n    5.5\
    \ Features.................................................19\n    5.6 Description..............................................19\n\
    \    5.7 Extension-attribute......................................20\n   6  Feature\
    \ negotiation........................................20\n    6.1 Feature tags.............................................20\n\
    \    6.1.1 Feature tag values.....................................21\n    6.2\
    \ Feature sets.............................................21\n    6.3 Feature\
    \ predicates.......................................22\n    6.4 Features attribute.......................................24\n\
    \   7  Remote variant selection algorithms........................25\n    7.1\
    \ Version numbers..........................................25\n   8  Content negotiation\
    \ status codes and headers...............25\n    8.1 506 Variant Also Negotiates..............................25\n\
    \    8.2 Accept-Features..........................................26\n    8.3\
    \ Alternates...............................................27\n    8.4 Negotiate................................................28\n\
    \    8.5 TCN......................................................30\n    8.6\
    \ Variant-Vary.............................................30\n   9  Cache validators...........................................31\n\
    \    9.1 Variant list validators..................................31\n    9.2\
    \ Structured entity tags...................................31\n    9.3 Assigning\
    \ entity tags to variants........................32\n   10 Content negotiation\
    \ responses..............................32\n    10.1 List response...........................................33\n\
    \    10.2 Choice response.........................................34\n    10.3\
    \ Adhoc response..........................................37\n    10.4 Reusing\
    \ the Alternates header...........................38\n    10.5 Extracting a normal\
    \ response from a choice response.....39\n    10.6 Elaborate Vary headers..................................39\n\
    \    10.6.1 Construction of an elaborate Vary header..............40\n    10.6.2\
    \ Caching of an elaborate Vary header...................41\n    10.7 Adding an\
    \ Expires header for HTTP/1.0 compatibility.....41\n    10.8 Negotiation on content\
    \ encoding.........................41\n   11 User agent support for transparent\
    \ negotiation.............42\n    11.1 Handling of responses...................................42\n\
    \    11.2 Presentation of a transparently negotiated resource.....42\n   12 Origin\
    \ server support for transparent negotiation..........43\n    12.1 Requirements............................................43\n\
    \    12.2 Negotiation on transactions other than GET and HEAD.....45\n   13 Proxy\
    \ support for transparent negotiation..................45\n   14 Security and\
    \ privacy considerations........................46\n    14.1 Accept- headers revealing\
    \ personal information..........46\n    14.2 Spoofing of responses from variant\
    \ resources............47\n    14.3 Security holes revealed by negotiation..................47\n\
    \   15 Internationalization considerations........................47\n   16 Acknowledgments............................................47\n\
    \   17 References.................................................48\n   18 Authors'\
    \ Addresses.........................................48\n   19 Appendix: Example\
    \ of a local variant selection algorithm...49\n    19.1 Computing overall quality\
    \ values........................49\n    19.2 Determining the result..................................51\n\
    \    19.3 Ranking dimensions......................................51\n   20 Appendix:\
    \ feature negotiation examples.....................52\n    20.1 Use of feature\
    \ tags.....................................52\n    20.2 Use of numeric feature\
    \ tags.............................53\n    20.3 Feature tag design......................................53\n\
    \   21 Appendix: origin server implementation considerations......54\n    21.1\
    \ Implementation with a CGI script........................54\n    21.2 Direct\
    \ support by HTTP servers..........................55\n    21.3 Web publishing\
    \ tools....................................55\n   22 Appendix: Example of choice\
    \ response construction..........55\n   23 Full Copyright Statement...................................58\n"
- title: 1  Introduction
  contents:
  - "1  Introduction\n   HTTP allows web site authors to put multiple versions of\
    \ the same\n   information under a single URI.  Each of these versions is called\
    \ a\n   `variant'.  Transparent content negotiation is an extensible\n   negotiation\
    \ mechanism for automatically and efficiently retrieving\n   the best variant\
    \ when a GET or HEAD request is made.  This enables\n   the smooth deployment\
    \ of new web data formats and markup tags.\n   This specification defines transparent\
    \ content negotiation as an\n   extension on top of the HTTP/1.1 protocol [1].\
    \  However, use of this\n   extension does not require use of HTTP/1.1: transparent\
    \ content\n   negotiation can also be done if some or all of the parties are\n\
    \   HTTP/1.0 [2] systems.\n   Transparent content negotiation is called `transparent'\
    \ because it\n   makes all variants which exist inside the origin server visible\
    \ to\n   outside parties.\n     Note: Some members of the IETF are currently undertaking\
    \ a number\n     of activities which are loosely related to this experimental\n\
    \     protocol.  First, there is an effort to define a protocol-\n     independent\
    \ registry for feature tags.  The intention is that this\n     experimental protocol\
    \ will be one of the clients of the registry.\n     Second, some research is being\
    \ done on content negotiation systems\n     for other transport protocols (like\
    \ internet mail and internet fax)\n     and on generalized negotiation systems\
    \ for multiple transport\n     protocols.  At the time of writing, it is unclear\
    \ if or when this\n     research will lead to results in the form of complete\
    \ negotiation\n     system specifications.  It is also unclear to which extent\
    \ possible\n     future specifications can or will re-use elements of this\n \
    \    experimental protocol.\n"
- title: 1.1 Background
  contents:
  - "1.1 Background\n   The addition of content negotiation to the web infrastructure\
    \ has\n   been considered important since the early days of the web.  Among the\n\
    \   expected benefits of a sufficiently powerful system for content\n   negotiation\
    \ are\n     * smooth deployment of new data formats and markup tags will\n   \
    \    allow graceful evolution of the web\n     * eliminating the need to choose\
    \ between a `state of the art\n       multimedia homepage' and one which can be\
    \ viewed by all web users\n     * enabling good service to a wider range of browsing\n\
    \       platforms (from low-end PDA's to high-end VR setups)\n     * eliminating\
    \ error-prone and cache-unfriendly\n       User-Agent based negotiation\n    \
    \ * enabling construction of sites without `click here for the X\n       version'\
    \ links\n     * internationalization, and the ability to offer multi-lingual\n\
    \       content without a bias towards one language.\n"
- title: 2  Terminology
  contents:
  - "2  Terminology\n   The words \"MUST\", \"MUST NOT\", \"SHOULD\", \"SHOULD NOT\"\
    , and \"MAY\" in\n   this document are to be interpreted as described in RFC 2119\
    \ [4].\n   This specification uses the term `header' as an abbreviation for for\n\
    \   `header field in a request or response message'.\n"
- title: 2.1 Terms from HTTP/1.1
  contents:
  - "2.1 Terms from HTTP/1.1\n   This specification mostly uses the terminology of\
    \ the HTTP/1.1\n   specification [1].  For the convenience of the reader, this\
    \ section\n   reproduces some key terminology definition from [1].\n   request\n\
    \     An HTTP request message.\n   response\n     An HTTP response message.\n\
    \   resource\n     A network data object or service that can be identified by\
    \ a URI.\n     Resources may be available in multiple representations (e.g.\n\
    \     multiple languages, data formats, size, resolutions) or vary in\n     other\
    \ ways.\n   content negotiation\n     The mechanism for selecting the appropriate\
    \ representation when\n     servicing a request.\n   client\n     A program that\
    \ establishes connections for the purpose of sending\n     requests.\n   user\
    \ agent\n     The client which initiates a request.  These are often browsers,\n\
    \     editors, spiders (web-traversing robots), or other end user tools.\n   server\n\
    \     An application program that accepts connections in order to service\n  \
    \   requests by sending back responses.  Any given program may be\n     capable\
    \ of being both a client and a server; our use of these terms\n     refers only\
    \ to the role being performed by the program for a\n     particular connection,\
    \ rather than to the program's capabilities in\n     general.  Likewise, any server\
    \ may act as an origin server, proxy,\n     gateway, or tunnel, switching behavior\
    \ based on the nature of each\n     request.\n   origin server\n     The server\
    \ on which a given resource resides or is to be created.\n   proxy\n     An intermediary\
    \ program which acts as both a server and a client\n     for the purpose of making\
    \ requests on behalf of other clients.\n     Requests are serviced internally\
    \ or by passing them on, with\n     possible translation, to other servers.  A\
    \ proxy must implement\n     both the client and server requirements of this specification.\n\
    \   age\n     The age of a response is the time since it was sent by, or\n   \
    \  successfully validated with, the origin server.\n   fresh\n     A response\
    \ is fresh if its age has not yet exceeded its freshness\n     lifetime.\n"
- title: 2.2 New terms
  contents:
  - "2.2 New terms\n   transparently negotiable resource\n     A resource, identified\
    \ by a single URI, which has multiple\n     representations (variants) associated\
    \ with it.  When servicing a\n     request on its URI, it allows selection of\
    \ the best representation\n     using the transparent content negotiation mechanism.\
    \  A\n     transparently negotiable resource always has a variant list bound\n\
    \     to it, which can be represented as an Alternates header (defined in\n  \
    \   section 8.3).\n   variant list\n     A list containing variant descriptions,\
    \ which can be bound to a\n     transparently negotiable resource.\n   variant\
    \ description\n     A machine-readable description of a variant resource, usually\
    \ found\n     in a variant list.  A variant description contains the variant\n\
    \     resource URI and various attributes which describe properties of\n     the\
    \ variant.  Variant descriptions are defined in section 5.\n   variant resource\n\
    \     A resource from which a variant of a negotiable resource can be\n     retrieved\
    \ with a normal HTTP/1.x GET request, i.e. a GET request\n     which does not\
    \ use transparent content negotiation.\n   neighboring variant\n     A variant\
    \ resource is called a neighboring variant resource of some\n     transparently\
    \ negotiable HTTP resource if the variant resource has\n     a HTTP URL, and if\
    \ the absolute URL of the variant resource up to\n     its last slash equals the\
    \ absolute URL of the negotiable resource\n     up to its last slash, where equality\
    \ is determined with the URI\n     comparison rules in section 3.2.3 of [1]. \
    \ The property of being a\n     neighboring variant is important because of security\
    \ considerations\n     (section 14.2).  Not all variants of a negotiable resource\
    \ need to\n     be neighboring variants.  However, access to neighboring variants\n\
    \     can be more highly optimized by the use of remote variant selection\n  \
    \   algorithms (section 7) and choice responses (section 10.2).\n   remote variant\
    \ selection algorithm\n     A standardized algorithm by which a server can sometimes\
    \ choose a\n     best variant on behalf of a negotiating user agent.  The algorithm\n\
    \     typically computes whether the Accept- headers in the request\n     contain\
    \ sufficient information to allow a choice, and if so, which\n     variant is\
    \ the best variant.  The use of a remote algorithm can\n     speed up the negotiation\
    \ process.\n   list response\n     A list response returns the variant list of\
    \ the negotiable\n     resource, but no variant data.  It can be generated when\
    \ the server\n     does not want to, or is not allowed to, return a particular\
    \ best\n     variant for the request.  List responses are defined in section\n\
    \     10.1.\n   choice response\n     A choice response returns a representation\
    \ of the best variant for\n     the request, and may also return the variant list\
    \ of the negotiable\n     resource.  It can be generated when the server has sufficient\n\
    \     information to be able to choose the best variant on behalf the\n     user\
    \ agent, but may only be generated if this best variant is a\n     neighboring\
    \ variant.  Choice responses are defined in section 10.2.\n   adhoc response\n\
    \     An adhoc response can be sent by an origin server as an extreme\n     measure,\
    \ to achieve compatibility with a non-negotiating or buggy\n     client if this\
    \ compatibility cannot be achieved by sending a list\n     or choice response.\
    \  There are very little requirements on the\n     contents of an adhoc response.\
    \  Adhoc responses are defined in\n     section 10.3.\n   Accept- headers\n  \
    \   The request headers: Accept, Accept-Charset, Accept-Language, and\n     Accept-Features.\n\
    \   supports transparent content negotiation\n     From the viewpoint of an origin\
    \ server or proxy, a user agent\n     supports transparent content negotiation\
    \ if and only if it sends a\n     Negotiate header (section 8.4) which indicates\
    \ such support.\n   server-side override\n     If a request on a transparently\
    \ negotiated resource is made by a\n     client which supports transparent content\
    \ negotiation, an origin\n     server is said to perform a server-side override\
    \ if the server\n     ignores the directives in the Negotiate request header,\
    \ and instead\n     uses a custom algorithm to choose an appropriate response.\
    \  A\n     server-side override can sometimes be used to work around known\n \
    \    client bugs.  It could also be used by protocol extensions on top\n     of\
    \ transparent content negotiation.\n"
- title: 3  Notation
  contents:
  - "3  Notation\n   The version of BNF used in this document is taken from [1], and\
    \ many\n   of the nonterminals used are defined in [1].  Note that the\n   underlying\
    \ charset is US-ASCII.\n   One new BNF construct is added:\n      1%rule\n   stands\
    \ for one or more instances of \"rule\", separated by whitespace:\n      1%rule\
    \ =  rule *( 1*LWS rule )\n   This specification also introduces\n      number\
    \ = 1*DIGIT\n      short-float = 1*3DIGIT [ \".\" 0*3DIGIT ]\n   This specification\
    \ uses the same conventions as in [1] (see section\n   1.2 of [1]) for defining\
    \ the significance of each particular\n   requirement.\n"
- title: 4  Overview
  contents:
  - "4  Overview\n   This section gives an overview of transparent content negotiation.\n\
    \   It starts with a more general discussion of negotiation as provided\n   by\
    \ HTTP.\n"
- title: 4.1 Content negotiation
  contents:
  - "4.1 Content negotiation\n   HTTP/1.1 allows web site authors to put multiple\
    \ versions of the same\n   information under a single resource URI.  Each of these\
    \ versions is\n   called a `variant'. For example, a resource http://x.org/paper\
    \ could\n   bind to three different variants of a paper:\n         1. HTML, English\n\
    \         2. HTML, French\n         3. Postscript, English\n   Content negotiation\
    \ is the process by which the best variant is\n   selected if the resource is\
    \ accessed.  The selection is done by\n   matching the properties of the available\
    \ variants to the capabilities\n   of the user agent and the preferences of the\
    \ user.\n   It has always been possible under HTTP to have multiple\n   representations\
    \ available for one resource, and to return the most\n   appropriate representation\
    \ for each subsequent request.  However,\n   HTTP/1.1 is the first version of\
    \ HTTP which has provisions for doing\n   this in a cache-friendly way.  These\
    \ provisions include the Vary\n   response header, entity tags, and the If-None-Match\
    \ request header.\n"
- title: 4.2 HTTP/1.0 style negotiation scheme
  contents:
  - "4.2 HTTP/1.0 style negotiation scheme\n   The HTTP/1.0 protocol elements allow\
    \ for a negotiation scheme as\n   follows:\n      Server _____ proxy _____ proxy\
    \ _____ user\n      x.org        cache       cache       agent\n        < ----------------------------------\n\
    \        |      GET http://x.org/paper\n        |          Accept- headers\n \
    \     choose\n        |\n         ---------------------------------- >\n     \
    \               Best variant\n   When the resource is accessed, the user agent\
    \ sends (along with its\n   request) various Accept- headers which express the\
    \ user agent\n   capabilities and the user preferences.  Then the origin server\
    \ uses\n   these Accept- headers to choose the best variant, which is returned\n\
    \   in the response.\n   The biggest problem with this scheme is that it does\
    \ not scale well.\n   For all but the most minimal user agents, Accept- headers\
    \ expressing\n   all capabilities and preferences would be very large, and sending\n\
    \   them in every request would be hugely inefficient, in particular\n   because\
    \ only a small fraction of the resources on the web have\n   multiple variants.\n"
- title: 4.3 Transparent content negotiation scheme
  contents:
  - "4.3 Transparent content negotiation scheme\n   The transparent content negotiation\
    \ scheme eliminates the need to\n   send huge Accept- headers, and nevertheless\
    \ allows for a selection\n   process that always yields either the best variant,\
    \ or an error\n   message indicating that user agent is not capable of displaying\
    \ any\n   of the available variants.\n   Under the transparent content negotiation\
    \ scheme, the server sends a\n   list with the available variants and their properties\
    \ to the user\n   agent.  An example of a list with three variants is\n      {\"\
    paper.1\" 0.9 {type text/html} {language en}},\n      {\"paper.2\" 0.7 {type text/html}\
    \ {language fr}},\n      {\"paper.3\" 1.0 {type application/postscript} {language\
    \ en}}\n   The syntax and semantics of the variant descriptions in this list are\n\
    \   covered in section 5.  When the list is received, the user agent can\n   choose\
    \ the best variant and retrieve it.  Graphically, the\n   communication can be\
    \ represented as follows:\n      Server _____ proxy _____ proxy _____ user\n \
    \     x.org        cache       cache       agent\n        < ----------------------------------\n\
    \        |      GET http://x.org/paper\n        |\n        -----------------------------------\
    \ >         [list response]\n                  return of list            |\n \
    \                                        choose\n                            \
    \                |\n        < ----------------------------------\n        |  GET\
    \ http://x.org/paper.1\n        |\n         ----------------------------------\
    \ >         [normal response]\n                return of paper.1\n   The first\
    \ response returning the list of variants is called a `list\n   response'.  The\
    \ second response is a normal HTTP response: it does\n   not contain special content\
    \ negotiation related information.  Only\n   the user agent needs to know that\
    \ the second request actually\n   retrieves a variant.  For the other parties\
    \ in the communication, the\n   second transaction is indistinguishable from a\
    \ normal HTTP\n   transaction.\n   With this scheme, information about capabilities\
    \ and preferences is\n   only used by the user agent itself.  Therefore, sending\
    \ such\n   information in large Accept- headers is unnecessary.  Accept- headers\n\
    \   do have a limited use in transparent content negotiation however; the\n  \
    \ sending of small Accept- headers can often speed up the negotiation\n   process.\
    \ This is covered in section 4.4.\n   List responses are covered in section 10.1.\
    \  As an example, the list\n   response in the above picture could be:\n     HTTP/1.1\
    \ 300 Multiple Choices\n     Date: Tue, 11 Jun 1996 20:02:21 GMT\n     TCN: list\n\
    \     Alternates: {\"paper.1\" 0.9 {type text/html} {language en}},\n        \
    \         {\"paper.2\" 0.7 {type text/html} {language fr}},\n                \
    \ {\"paper.3\" 1.0 {type application/postscript}\n                     {language\
    \ en}}\n     Vary: negotiate, accept, accept-language\n     ETag: \"blah;1234\"\
    \n     Cache-control: max-age=86400\n     Content-Type: text/html\n     Content-Length:\
    \ 227\n     <h2>Multiple Choices:</h2>\n     <ul>\n     <li><a href=paper.1>HTML,\
    \ English version</a>\n     <li><a href=paper.2>HTML, French version</a>\n   \
    \  <li><a href=paper.3>Postscript, English version</a>\n     </ul>\n   The Alternates\
    \ header in the response contains the variant list.  The\n   Vary header is included\
    \ to ensure correct caching by plain HTTP/1.1\n   caches (see section 10.6). \
    \ The ETag header allows the response to be\n   revalidated by caches, the Cache-Control\
    \ header controls this\n   revalidation.  The HTML entity included in the response\
    \ allows the\n   user to select the best variant by hand if desired.\n"
- title: 4.4 Optimizing the negotiation process
  contents:
  - "4.4 Optimizing the negotiation process\n   The basic transparent negotiation\
    \ scheme involves two HTTP\n   transactions: one to retrieve the list, and a second\
    \ one to retrieve\n   the chosen variant.  There are however several ways to `cut\
    \ corners'\n   in the data flow path of the basic scheme.\n   First, caching proxies\
    \ can cache both variant lists and variants.\n   Such caching can reduce the communication\
    \ overhead, as shown in the\n   following example:\n      Server _____ proxy _____\
    \ proxy __________ user\n      x.org        cache       cache            agent\n\
    \                                 < --------------\n                         \
    \        |  GET ../paper\n                                 |\n               \
    \                has the list\n                               in cache\n     \
    \                            |\n                                  -------------\
    \  >  [list response]\n                                           list  |\n  \
    \                                               |\n                          \
    \                    choose\n                                                \
    \ |\n                     < --------------------------\n                     |\
    \   GET ../paper.1\n                     |\n                  has the variant\n\
    \                  in cache\n                     |\n                      --------------------------\
    \ >  [normal response]\n                         return of paper.1\n   Second,\
    \ the user agent can send small Accept- headers, which may\n   contain enough\
    \ information to allow the server to choose the best\n   variant and return it\
    \ directly.\n      Server _____ proxy _____ proxy _____ user\n      x.org    \
    \    cache       cache       agent\n        < ----------------------------------\n\
    \        |      GET http://x.org/paper\n        |       small Accept- headers\n\
    \        |\n      able to choose on\n      behalf of user agent\n        |\n \
    \        ---------------------------------- >    [choice response]\n         \
    \     return of paper.1 and list\n   This choosing based on small Accept- headers\
    \ is done with a `remote\n   variant selection algorithm'.  Such an algorithm\
    \ takes the variant\n   list and the Accept- headers as input.  It then computes\
    \ whether the\n   Accept- headers contain sufficient information to choose on\
    \ behalf of\n   the user agent, and if so, which variant is the best variant.\
    \  If the\n   best variant is a neighboring variant, it may be returned, together\n\
    \   with the variant list, in a choice response.\n   A server may only choose\
    \ on behalf of a user agent supporting\n   transparent content negotiation if\
    \ the user agent explicitly allows\n   the use of a particular remote variant\
    \ selection algorithm in the\n   Negotiate request header.  User agents with sophisticated\
    \ internal\n   variant selection algorithms may want to disallow a remote choice,\
    \ or\n   may want to allow it only when retrieving inline images.  If the\n  \
    \ local algorithm of the user agent is superior in only some difficult\n   areas\
    \ of negotiation, it is possible to enable the remote algorithm\n   for the easy\
    \ areas only.  More information about the use of a remote\n   variant selection\
    \ algorithm can be found in [3].\n   Choice responses are covered in section 10.2.\
    \  For example, the\n   choice response in the above picture could be:\n     HTTP/1.1\
    \ 200 OK\n     Date: Tue, 11 Jun 1996 20:05:31 GMT\n     TCN: choice\n     Content-Type:\
    \ text/html\n     Last-Modified: Mon, 10 Jun 1996 10:01:14 GMT\n     Content-Length:\
    \ 5327\n     Cache-control: max-age=604800\n     Content-Location: paper.1\n \
    \    Alternates: {\"paper.1\" 0.9 {type text/html} {language en}},\n         \
    \        {\"paper.2\" 0.7 {type text/html} {language fr}},\n                 {\"\
    paper.3\" 1.0 {type application/postscript}\n                     {language en}}\n\
    \     Etag: \"gonkyyyy;1234\"\n     Vary: negotiate, accept, accept-language\n\
    \     Expires: Thu, 01 Jan 1980 00:00:00 GMT\n     <title>A paper about ....\n\
    \   Finally, the above two kinds of optimization can be combined; a\n   caching\
    \ proxy which has the list will sometimes be able to choose on\n   behalf of the\
    \ user agent.  This could lead to the following\n   communication pattern:\n \
    \     Server _____ proxy _____ proxy __________ user\n      x.org        cache\
    \       cache            agent\n                                 < ---------------\n\
    \                                 |  GET ../paper\n                          \
    \       |  small Accept\n                                 |\n                \
    \              able to choose\n                                on behalf\n   \
    \                              |\n                     < ----------\n        \
    \             |  GET ../paper.1\n                     |\n                    \
    \  ---------- >   [normal response]\n                        paper.1  |\n    \
    \                              ---------------- >  [choice response]\n       \
    \                            paper.1 and list\n   Note that this cutting of corners\
    \ not only saves bandwidth, it also\n   eliminates delays due to packet round\
    \ trip times, and reduces the\n   load on the origin server.\n"
- title: 4.5 Downwards compatibility with non-negotiating user agents
  contents:
  - "4.5 Downwards compatibility with non-negotiating user agents\n   To handle requests\
    \ from user agents which do not support transparent\n   content negotiation, this\
    \ specification allows the origin server to\n   revert to a HTTP/1.0 style negotiation\
    \ scheme.  The specification of\n   heuristics for such schemes is beyond the\
    \ scope of this document.\n"
- title: 4.6 Retrieving a variant by hand
  contents:
  - "4.6 Retrieving a variant by hand\n   It is always possible for a user agent to\
    \ retrieve the variant list\n   which is bound to a negotiable resource.  The\
    \ user agent can use this\n   list to make available a menu of all variants and\
    \ their\n   characteristics to the user.  Such a menu allows the user to randomly\n\
    \   browse other variants, and makes it possible to manually correct any\n   sub-optimal\
    \ choice made by the automatic negotiation process.\n"
- title: 4.7 Dimensions of negotiation
  contents:
  - "4.7 Dimensions of negotiation\n   Transparent content negotiation defines four\
    \ dimensions of\n   negotiation:\n      1. Media type (MIME type)\n      2. Charset\n\
    \      3. Language\n      4. Features\n   The first three dimensions have traditionally\
    \ been present in HTTP.\n   The fourth dimension is added by this specification.\
    \  Additional\n   dimensions, beyond the four mentioned above, could be added\
    \ by future\n   specifications.\n   Negotiation on the content encoding of a response\
    \ (gzipped,\n   compressed, etc.) is left outside of the realm of transparent\n\
    \   negotiation.   See section 10.8 for more information.\n"
- title: 4.8 Feature negotiation
  contents:
  - "4.8 Feature negotiation\n   Feature negotiation intends to provide for all areas\
    \ of negotiation\n   not covered by the type, charset, and language dimensions.\
    \  Examples\n   are negotiation on\n      * HTML extensions\n      * Extensions\
    \ of other media types\n      * Color capabilities of the user agent\n      *\
    \ Screen size\n      * Output medium (screen, paper, ...)\n      * Preference\
    \ for speed vs. preference for graphical detail\n   The feature negotiation framework\
    \ (section 6) is the principal means\n   by which transparent negotiation offers\
    \ extensibility; a new\n   dimension of negotiation (really a sub-dimension of\
    \ the feature\n   dimension) can be added without the need for a new standards\
    \ effort\n   by the simple registration of a `feature tag'.\n"
- title: 4.9 Length of variant lists
  contents:
  - "4.9 Length of variant lists\n   As a general rule, variant lists should be short:\
    \ it is expected that\n   a typical transparently negotiable resource will have\
    \ 2 to 10\n   variants, depending on its purpose.  Variant lists should be short\n\
    \   for a number of reasons:\n     1. The user must be able to pick a variant\
    \ by hand to correct a\n        bad automatic choice, and this is more difficult\
    \ with a long\n        variant list.\n     2. A large number of variants will\
    \ decrease the efficiency of\n        internet proxy caches.\n     3. Long variant\
    \ lists will make some transparently negotiated\n        responses longer.\n \
    \  In general, it is not desirable to create a transparently negotiable\n   resource\
    \ with hundreds of variants in order to fine-tune the\n   graphical presentation\
    \ of a resource.  Any graphical fine-tuning\n   should be done, as much as possible,\
    \ by using constructs which act at\n   the user agent side, for example\n    \
    \  <center><img src=titlebanner.gif width=100%\n      alt=\"MegaBozo Corp\"></center>\n\
    \   In order to promote user agent side fine tuning, which is more\n   scalable\
    \ than fine tuning over the network, user agents which\n   implement a scripting\
    \ language for content rendering are encouraged\n   to make the availability of\
    \ this language visible for transparent\n   content negotiation, and to allow\
    \ rendering scripts to access the\n   capabilities and preferences data used for\
    \ content negotiation, as\n   far as privacy considerations permit this.\n"
- title: 4.10 Relation with other negotiation schemes
  contents:
  - "4.10 Relation with other negotiation schemes\n   The HTTP/1.x protocol suite\
    \ allows for many different negotiation\n   mechanisms.  Transparent content negotiation\
    \ specializes in scalable,\n   interoperable negotiation of content representations\
    \ at the HTTP\n   level.  It is intended that transparent negotiation can co-exist\
    \ with\n   other negotiation schemes, both open and proprietary, which cover\n\
    \   different application domains or work at different points in the\n   author-to-user\
    \ chain.  Ultimately, it will be up to the resource\n   author to decide which\
    \ negotiation mechanism, or combination of\n   negotiation mechanisms, is most\
    \ appropriate for the task at hand.\n"
- title: 5  Variant descriptions
  contents:
  - '5  Variant descriptions

    '
- title: 5.1 Syntax
  contents:
  - "5.1 Syntax\n   A variant can be described in a machine-readable way with a variant\n\
    \   description.\n       variant-description =\n                  \"{\" <\"> URI\
    \ <\"> source-quality *variant-attribute\"}\"\n       source-quality = qvalue\n\
    \       variant-attribute = \"{\" \"type\" media-type \"}\"\n                \
    \         | \"{\" \"charset\" charset \"}\"\n                         | \"{\"\
    \ \"language\"  1#language-tag \"}\"\n                         | \"{\" \"length\"\
    \ 1*DIGIT \"}\"\n                         | \"{\" \"features\" feature-list \"\
    }\"\n                         | \"{\" \"description\"\n                      \
    \               quoted-string [ language-tag ] \"}\"\n                       \
    \  | extension-attribute\n       extension-attribute = \"{\" extension-name extension-value\
    \ \"}\"\n       extension-name      = token\n       extension-value     = *( token\
    \ | quoted-string | LWS\n                              | extension-specials )\n\
    \       extension-specials  =\n                          <any element of tspecials\
    \ except <\"> and \"}\">\n   The feature-list syntax is defined in section 6.4.\n\
    \   Examples are\n      {\"paper.2\" 0.7 {type text/html} {language fr}}\n   \
    \   {\"paper.5\" 0.9 {type text/html} {features tables}}\n      {\"paper.1\" 0.001}\n\
    \   The various attributes which can be present in a variant description\n   are\
    \ covered in the subsections below.  Each attribute may appear only\n   once in\
    \ a variant description.\n"
- title: 5.2 URI
  contents:
  - "5.2 URI\n   The URI attribute gives the URI of the resource from which the\n\
    \   variant can be retrieved with a GET request.  It can be absolute or\n   relative\
    \ to the Request-URI.  The variant resource may vary (on the\n   Cookie request\
    \ header, for example), but MUST NOT engage in\n   transparent content negotiation\
    \ itself.\n"
- title: 5.3 Source-quality
  contents:
  - "5.3 Source-quality\n   The source-quality attribute gives the quality of the\
    \ variant, as a\n   representation of the negotiable resource, when this variant\
    \ is\n   rendered with a perfect rendering engine on the best possible output\n\
    \   medium.\n   If the source-quality is less than 1, it often expresses a quality\n\
    \   degradation caused by a lossy conversion to a particular data format.\n  \
    \ For example, a picture originally in JPEG form would have a lower\n   source\
    \ quality when translated to the XBM format, and a much lower\n   source quality\
    \ when translated to an ASCII-art variant.  Note\n   however, that degradation\
    \ is a function of the source; an original\n   piece of ASCII-art may degrade\
    \ in quality if it is captured in JPEG\n   form.\n   The source-quality could\
    \ also represent a level of quality caused by\n   skill of language translation,\
    \ or ability of the used media type to\n   capture the intended artistic expression.\n\
    \   Servers should use the following table a guide when assigning source\n   quality\
    \ values:\n      1.000  perfect representation\n      0.900  threshold of noticeable\
    \ loss of quality\n      0.800  noticeable, but acceptable quality reduction\n\
    \      0.500  barely acceptable quality\n      0.300  severely degraded quality\n\
    \      0.000  completely degraded quality\n   The same table can be used by local\
    \ variant selection algorithms (see\n   appendix 19) when assigning degradation\
    \ factors for different content\n   rendering mechanisms.  Note that most meaningful\
    \ values in this table\n   are close to 1.  This is due to the fact that quality\
    \ factors are\n   generally combined by multiplying them, not by adding them.\n\
    \   When assigning source-quality values, servers should not account for\n   the\
    \ size of the variant and its impact on transmission and rendering\n   delays;\
    \ the size of the variant should be stated in the length\n   attribute and any\
    \ size-dependent calculations should be done by the\n   variant selection algorithm.\
    \  Any constant rendering delay for a\n   particular media type (for example due\
    \ to the startup time of a\n   helper application) should be accounted for by\
    \ the user agent, when\n   assigning a quality factor to that media type.\n"
- title: 5.4 Type, charset, language, and length
  contents:
  - "5.4 Type, charset, language, and length\n   The type attribute of a variant description\
    \ carries the same\n   information as its Content-Type response header counterpart\
    \ defined\n   in [1], except for any charset information, which MUST be carried\
    \ in\n   the charset attribute.  For, example, the header\n      Content-Type:\
    \ text/html; charset=ISO-8859-4\n   has the counterpart attributes\n      {type\
    \ text/html} {charset ISO-8859-4}\n   The language and length attributes carry\
    \ the same information as\n   their Content-* response header counterparts in\
    \ [1].  The length\n   attribute, if present, MUST thus reflect the length of\
    \ the variant\n   alone, and not the total size of the variant and any objects\
    \ inlined\n   or embedded by the variant.\n   Though all of these attributes are\
    \ optional, it is often desirable to\n   include as many attributes as possible,\
    \ as this will increase the\n   quality of the negotiation process.\n      Note:\
    \ A server is not required to maintain a one-to-one\n      correspondence between\
    \ the attributes in the variant description\n      and the Content-* headers in\
    \ the variant response.  For example,\n      if the variant description contains\
    \ a language attribute, the\n      response does not necessarily have to contain\
    \ a Content-Language\n      header. If a Content-Language header is present, it\
    \ does not have\n      to contain an exact copy of the information in the language\n\
    \      attribute.\n"
- title: 5.5 Features
  contents:
  - "5.5 Features\n   The features attribute specifies how the presence or absence\
    \ of\n   particular feature tags in the user agent affects the overall quality\n\
    \   of the variant.  This attribute is covered in section 6.4.\n"
- title: 5.6 Description
  contents:
  - "5.6 Description\n   The description attribute gives a textual description of\
    \ the variant.\n   It can be included if the URI and normal attributes of a variant\
    \ are\n   considered too opaque to allow interpretation by the user.  If a user\n\
    \   agent is showing a menu of available variants compiled from a variant\n  \
    \ list, and if a variant has a description attribute, the user agent\n   SHOULD\
    \ show the description attribute of the variant instead of\n   showing the normal\
    \ attributes of the variant.  The description field\n   uses the UTF-8 character\
    \ encoding scheme [5], which is a superset of\n   US-ASCII, with \"\"%\" HEX HEX\"\
    \ encoding.  The optional language tag MAY\n   be used to specify the language\
    \ used in the description text.\n"
- title: 5.7 Extension-attribute
  contents:
  - "5.7 Extension-attribute\n   The extension-attribute allows future specifications\
    \ to incrementally\n   define dimensions of negotiation which cannot be created\
    \ by using the\n   feature negotiation framework, and eases content negotiation\n\
    \   experiments.  In experimental situations, servers MUST ONLY generate\n   extension-attributes\
    \ whose names start with \"x-\".  User agents SHOULD\n   ignore all extension\
    \ attributes they do not recognize.  Proxies MUST\n   NOT run a remote variant\
    \ selection algorithm if an unknown extension\n   attribute is present in the\
    \ variant list.\n"
- title: 6  Feature negotiation
  contents:
  - "6  Feature negotiation\n   This section defines the feature negotiation mechanism.\
    \  Feature\n   negotiation has been introduced in section 4.8.  Appendix 19 contains\n\
    \   examples of feature negotiation.\n"
- title: 6.1 Feature tags
  contents:
  - "6.1 Feature tags\n   A feature tag (ftag) identifies something which can be negotiated\
    \ on,\n   for example a property (feature) of a representation, a capability\n\
    \   (feature) of a user agent, or the preference of a user for a\n   particular\
    \ type of representation.  The use of feature tags need not\n   be limited to\
    \ transparent content negotiation, and not every feature\n   tag needs to be usable\
    \ in the HTTP transparent content negotiation\n   framework.\n      ftag = token\
    \ | quoted-string\n      Note: A protocol-independent system for feature tag registration\n\
    \      is currently being developed in the IETF.  This specification does\n  \
    \    not define any feature tags.  In experimental situations, the use\n     \
    \ of tags which start with \"x.\" is encouraged.\n   Feature tags are used in\
    \ feature sets (section 6.2) and in feature\n   predicates (section 6.3).  Feature\
    \ predicates are in turn used in\n   features attributes (section 6.4), which\
    \ are used in variant\n   descriptions (section 5).  Variant descriptions can\
    \ be transmitted in\n   Alternates headers (section 8.3).\n   The US-ASCII charset\
    \ is used for feature tags.  Feature tag\n   comparison is case-insensitive. \
    \ A token tag XYZ is equal to a\n   quoted-string tag \"XYZ\". Examples are\n\
    \      tables, fonts, blebber, wolx, screenwidth, colordepth\n   An example of\
    \ the use of feature tags in a variant description is:\n      {\"index.html\"\
    \ 1.0 {type text/html} {features tables frames}}\n   This specification follows\
    \ general computing practice in that it\n   places no restrictions on what may\
    \ be called a feature.  At the\n   protocol level, this specification does not\
    \ distinguish between\n   different uses of feature tags: a tag will be processed\
    \ in the same\n   way, no matter whether it identifies a property, capability,\
    \ or\n   preference.  For some tags, it may be fluid whether the tag\n   represents\
    \ a property, preference, or capability.  For example, in\n   content negotiation\
    \ on web pages, a \"textonly\" tag would identify a\n   capability of a text-only\
    \ user agent, but the user of a graphical\n   user agent may use this tag to specify\
    \ that text-only content is\n   preferred over graphical content.\n"
- title: 6.1.1 Feature tag values
  contents:
  - "6.1.1 Feature tag values\n   The definition of a feature tag may state that a\
    \ feature tag can have\n   zero, one, or more values associated with it.  These\
    \ values\n   specialize the meaning of the tag.  For example, a feature tag\n\
    \   `paper' could be associated with the values `A4' and `A5'.\n      tag-value\
    \  = token | quoted-string\n   The US-ASCII charset is used for feature tag values.\
    \  Equality\n   comparison for tag values MUST be done with a case-sensitive,\
    \ octet-\n   by-octet comparison, where any \"\"%\" HEX HEX\" encodings MUST be\n\
    \   processed as in [1].  A token value XYZ is equal to a quoted-string\n   value\
    \ \"XYZ\".\n"
- title: 6.2 Feature sets
  contents:
  - "6.2 Feature sets\n   The feature set of a user agent is a data structure which\
    \ records the\n   capabilities of the user agent and the preferences of the user.\n\
    \   Feature sets are used by local variant selection algorithms (see\n   appendix\
    \ 19 for an example).  A user agent can use the Accept-\n   Features header (section\
    \ 8.2) to make some of the contents of its\n   feature set known to remote variant\
    \ selection algorithms.\n   Structurally, a feature set is a possibly empty set,\
    \ containing\n   records of the form\n      ( feature tag , set of feature tag\
    \ values )\n   If a record with a feature tag is present in the set, this means\
    \ that\n   the user agent implements the corresponding capability, or that the\n\
    \   user has expressed the corresponding preference.\n   Each record in a feature\
    \ set has a, possibly empty, set of tag\n   values.  For feature tags which cannot\
    \ have values associated with\n   it, this set is always empty.  For feature tags\
    \ which can have zero,\n   one, or more values associated with it, this set contains\
    \ those\n   values currently associated with the tag.  If the set of a feature\n\
    \   tag T has the value V in it, it is said that `the tag T is present\n   with\
    \ the value V'.\n   This specification does not define a standard notation for\
    \ feature\n   sets.  An example of a very small feature set, in a mathematical\n\
    \   notation, is\n      { ( \"frames\" , { } ) ,\n        ( \"paper\"  , { \"\
    A4\" , \"A5\" } )\n      }\n   As feature registration is expected to be an ongoing\
    \ process, it is\n   generally not possible for a user agent to know the meaning\
    \ of all\n   feature tags it can possibly encounter in a variant description.\
    \  A\n   user agent SHOULD treat all features tags unknown to it as absent\n \
    \  from its feature set.\n   A user agent may change the contents of its feature\
    \ set depending on\n   the type of request, and may also update it to reflect\
    \ changing\n   conditions, for example a change in the window size.  Therefore,\
    \ when\n   considering feature negotiation, one usually talks about `the feature\n\
    \   set of the current request'.\n"
- title: 6.3 Feature predicates
  contents:
  - "6.3 Feature predicates\n   Feature predicates are predicates on the contents\
    \ of feature sets.\n   They appear in the features attribute of a variant description.\n\
    \      fpred = [ \"!\" ] ftag\n            | ftag ( \"=\" | \"!=\" ) tag-value\n\
    \            | ftag \"=\" \"[\" numeric-range \"]\"\n      numeric-range = [ number\
    \ ] \"-\" [ number ]\n   Feature predicates are used in features attributes (section\
    \ 6.4),\n   which are used in variant descriptions (section 5).  Variant\n   descriptions\
    \ can be transmitted in Alternates headers (section 8.3).\n   Examples of feature\
    \ predicates are\n      blebber, !blebber, paper=a4, colordepth=5, blex!=54,\n\
    \      dpi=[300-599], colordepth=[24-]\n   Using the feature set of the current\
    \ request, a user agent SHOULD\n   compute the truth value of the different feature\
    \ predicates as\n   follows.\n      ftag       true if the feature is present,\
    \ false otherwise\n      !ftag      true if the feature is absent, false otherwise\n\
    \      ftag=V     true if the feature is present with the value V,\n         \
    \        false otherwise,\n      ftag!=V    true if the feature is not present\
    \ with the value V,\n                 false otherwise,\n      ftag=[N-M] true\
    \ if the feature is present with at least one\n                 numeric value,\
    \ while the highest value with which it\n                 is present in the range\
    \ N-M, false otherwise.  If N\n                 is missing, the lower bound is\
    \ 0.  If M is missing,\n                 the upper bound is infinity.\n   As an\
    \ example, with the feature set\n       { ( \"blex\"       , { } ),\n        \
    \ ( \"colordepth\" , { \"5\" } ),\n         ( \"UA-media\"   , { \"stationary\"\
    \ } ),\n         ( \"paper\"      , { \"A4\", \"A3\" } ) ,\n         ( \"x-version\"\
    \  , { \"104\", \"200\" } )\n       }\n   the following predicates are true:\n\
    \   blex, colordepth=[4-], colordepth!=6, colordepth, !screenwidth, UA-\n   media=stationary,\
    \ UA-media!=screen, paper=A4, paper =!A0,\n   colordepth=[ 4 - 6 ], x-version=[100-300],\
    \ x-version=[200-300]\n   and the following predicates are false:\n      !blex,\
    \ blebber, colordepth=6, colordepth=foo, !colordepth,\n      screenwidth, screenwidth=640,\
    \ screenwidth!=640, x-version=99, UA-\n      media=screen, paper=A0, paper=a4,\
    \ x-version=[100-199], wuxta\n"
- title: 6.4 Features attribute
  contents:
  - "6.4 Features attribute\n      The features attribute, for which section 5.1 defines\
    \ the syntax\n      \"{\" \"features\" feature-list \"}\"\n   is used in a variant\
    \ description to specify how the presence or\n   absence of particular feature\
    \ tags in the user agent affects the\n   overall quality of the variant.\n   \
    \    feature-list = 1%feature-list-element\n       feature-list-element = ( fpred\
    \ | fpred-bag )\n                              [ \";\" [ \"+\" true-improvement\
    \  ]\n                                    [ \"-\" false-degradation ]\n      \
    \                        ]\n       fpred-bag = \"[\" 1%fpred \"]\"\n       true-improvement\
    \   =  short-float\n       false-degradation  =  short-float\n   Features attributes\
    \ are used in variant descriptions (section 5).\n   Variant descriptions can be\
    \ transmitted in Alternates headers\n   (section 8.3).\n   Examples are:\n   \
    \    {features !textonly [blebber !wolx] colordepth=3;+0.7}\n       {features\
    \ !blink;-0.5 background;+1.5 [blebber !wolx];+1.4-0.8}\n   The default value\
    \ for the true-improvement is 1.  The default value\n   for the false-degradation\
    \ is 0, or 1 if a true-improvement value is\n   given.\n   A user agent SHOULD,\
    \ and a remote variant selection algorithm MUST\n   compute the quality degradation\
    \ factor associated with the features\n   attribute by multiplying all quality\
    \ degradation factors of the\n   elements of the feature-list.  Note that the\
    \ result can be a factor\n   greater than 1.\n   A feature list element yields\
    \ its true-improvement factor if the\n   corresponding feature predicate is true,\
    \ or if at least one element\n   of the corresponding fpred-bag is true. The element\
    \ yields its\n   false-degradation factor otherwise.\n"
- title: 7  Remote variant selection algorithms
  contents:
  - "7  Remote variant selection algorithms\n   A remote variant selection algorithm\
    \ is a standardized algorithm by\n   which a server can choose a best variant\
    \ on behalf of a negotiating\n   user agent.  The use of a remote algorithm can\
    \ speed up the\n   negotiation process by eliminating a request-response round\
    \ trip.\n   A remote algorithm typically computes whether the Accept- headers\
    \ in\n   the request contain sufficient information to allow a choice, and if\n\
    \   so, which variant is the best variant.  This specification does not\n   define\
    \ any remote algorithms, but does define a mechanism to\n   negotiate on the use\
    \ of such algorithms.\n"
- title: 7.1 Version numbers
  contents:
  - "7.1 Version numbers\n   A version numbering scheme is used to distinguish between\
    \ different\n   remote variant selection algorithms.\n      rvsa-version = major\
    \ \".\" minor\n      major = 1*4DIGIT\n      minor = 1*4DIGIT\n   An algorithm\
    \ with the version number X.Y, with Y>0, MUST be downwards\n   compatible with\
    \ all algorithms from X.0 up to X.Y.  Downwards\n   compatibility means that,\
    \ if supplied with the same information, the\n   newer algorithm MUST make the\
    \ same choice, or a better choice, as the\n   old algorithm.  There are no compatibility\
    \ requirements between\n   algorithms with different major version numbers.\n"
- title: 8  Content negotiation status codes and headers
  contents:
  - "8  Content negotiation status codes and headers\n   This specification adds one\
    \ new HTTP status code, and introduces six\n   new HTTP headers.  It also extends\
    \ the semantics of an existing\n   HTTP/1.1 header.\n"
- title: 8.1 506 Variant Also Negotiates
  contents:
  - "8.1 506 Variant Also Negotiates\n   The 506 status code indicates that the server\
    \ has an internal\n   configuration error: the chosen variant resource is configured\
    \ to\n   engage in transparent content negotiation itself, and is therefore\n\
    \   not a proper end point in the negotiation process.\n"
- title: 8.2 Accept-Features
  contents:
  - "8.2 Accept-Features\n   The Accept-Features request header can be used by a user\
    \ agent to\n   give information about the presence or absence of certain features\
    \ in\n   the feature set of the current request.  Servers can use this\n   information\
    \ when running a remote variant selection algorithm.\n      Note: the name `Accept-Features'\
    \ for this header was chosen\n      because of symmetry considerations with other\
    \ Accept- headers,\n      even though the Accept-Features header will generally\
    \ not contain\n      an exhaustive list of features which are somehow `accepted'.\
    \  A\n      more accurate name of this header would have been `Feature-Set-\n\
    \      Info'.\n       Accept-Features = \"Accept-Features\" \":\"\n          \
    \         #( feature-expr *( \";\" feature-extension ) )\n       feature-expr\
    \ = [ \"!\" ] ftag\n                    | ftag ( \"=\" | \"!=\" ) tag-value\n\
    \                    | ftag \"=\" \"{\" tag-value \"}\"\n                    |\
    \ \"*\"\n       feature-extension = token [ \"=\" ( token | quoted-string ) ]\n\
    \   No feature extensions are defined in this specification.  An example\n   is:\n\
    \       Accept-Features: blex, !blebber, colordepth={5}, !screenwidth,\n     \
    \             paper = A4, paper!=\"A2\", x-version=104, *\n   The different feature\
    \ expressions have the following meaning:\n      ftag       ftag is present\n\
    \      !ftag      ftag is absent\n      ftag=V     ftag is present with the value\
    \ V\n      ftag!=V    ftag is present, but not with the value V\n      ftag={V}\
    \   ftag is present with the value V, and not with any\n                 other\
    \ values\n      *          the expressions in this header do not fully describe\n\
    \                 the feature set: feature tags not mentioned in this\n      \
    \           header may also be present, and, except for the case\n           \
    \      ftag={V}, tags may be present with more values than\n                 mentioned.\n\
    \   Absence of the Accept-Features header in a request is equivalent to\n   the\
    \ inclusion of\n      Accept-Features: *\n   By using the Accept-Features header,\
    \ a remote variant selection\n   algorithm can sometimes determine the truth value\
    \ of a feature\n   predicate on behalf of the user agent.  For example, with the\
    \ header\n       Accept-Features: blex, !blebber, colordepth={5}, !screenwidth,\n\
    \                  paper = A4, paper!=\"A2\", x-version=104, *\n   the algorithm\
    \ can determine that the following predicates are true:\n       blex, colordepth=[4-],\
    \ colordepth!=6, colordepth, !screenwidth,\n       paper=A4, colordepth=[4-6]\n\
    \   and that the following predicates are false:\n       !blex, blebber, colordepth=6,\
    \ colordepth=foo, !colordepth,\n       screenwidth, screenwidth=640, screenwidth!=640,\n\
    \   but the truth value of the following predicates cannot be\n   determined:\n\
    \       UA-media=stationary, UA-media!=screen, paper!=a0,\n       x-version=[100-300],\
    \ x-version=[200-300], x-version=99,\n       UA-media=screen, paper=A0, paper=a4,\
    \ x-version=[100-199], wuxta\n"
- title: 8.3 Alternates
  contents:
  - "8.3 Alternates\n   The Alternates response header is used to convey the list\
    \ of variants\n   bound to a negotiable resource.  This list can also include\n\
    \   directives for any content negotiation process.  If a response from a\n  \
    \ transparently negotiable resource includes an Alternates header, this\n   header\
    \ MUST contain the complete variant list bound to the negotiable\n   resource.\
    \  Responses from resources which do not support transparent\n   content negotiation\
    \ MAY also use Alternates headers.\n       Alternates = \"Alternates\" \":\" variant-list\n\
    \       variant-list = 1#( variant-description\n                        | fallback-variant\n\
    \                        | list-directive )\n       fallback-variant = \"{\" <\"\
    > URI <\"> \"}\"\n       list-directive = ( \"proxy-rvsa\" \"=\" <\"> 0#rvsa-version\
    \ <\"> )\n                        | extension-list-directive\n       extension-list-directive\
    \ =\n                        token [ \"=\" ( token | quoted-string ) ]\n   An\
    \ example is\n     Alternates: {\"paper.1\" 0.9 {type text/html} {language en}},\n\
    \                 {\"paper.2\" 0.7 {type text/html} {language fr}},\n        \
    \         {\"paper.3\" 1.0 {type application/postscript}\n                   \
    \  {language en}},\n                 proxy-rvsa=\"1.0, 2.5\"\n   Any relative\
    \ URI specified in a variant-description or fallback-\n   variant field is relative\
    \ to the request-URI.  Only one fallback-\n   variant field may be present.  If\
    \ the variant selection algorithm of\n   the user agent finds that all described\
    \ variants are unacceptable,\n   then it SHOULD choose the fallback variant, if\
    \ present, as the best\n   variant.  If the user agent computes the overall quality\
    \ values of\n   the described variants, and finds that several variants share\
    \ the\n   highest value, then the first variant with this value in the list\n\
    \   SHOULD be chosen as the best variant.\n   The proxy-rvsa directive restricts\
    \ the use of remote variant\n   selection algorithms by proxies. If present, a\
    \ proxy MUST ONLY use\n   algorithms which have one of the version numbers listed,\
    \ or have the\n   same major version number and a higher minor version number\
    \ as one of\n   the versions listed.  Any restrictions set by proxy-rvsa come\
    \ on top\n   of the restrictions set by the user agent in the Negotiate request\n\
    \   header.  The directive proxy-rvsa=\"\" will disable variant selection\n  \
    \ by proxies entirely.  Clients SHOULD ignore all extension-list-\n   directives\
    \ they do not understand.\n   A variant list may contain multiple differing descriptions\
    \ of the\n   same variant.  This can be convenient if the variant uses conditional\n\
    \   rendering constructs, or if the variant resource returns multiple\n   representations\
    \ using a multipart media type.\n"
- title: 8.4 Negotiate
  contents:
  - "8.4 Negotiate\n   The Negotiate request header can contain directives for any\
    \ content\n   negotiation process initiated by the request.\n      Negotiate =\
    \ \"Negotiate\" \":\" 1#negotiate-directive\n      negotiate-directive = \"trans\"\
    \n                          | \"vlist\"\n                          | \"guess-small\"\
    \n                          | rvsa-version\n                          | \"*\"\n\
    \                          | negotiate-extension\n      negotiate-extension =\
    \ token [ \"=\" token ]\n   Examples are\n      Negotiate: 1.0, 2.5\n      Negotiate:\
    \ *\n   The negotiate directives have the following meaning\n      \"trans\"\n\
    \        The user agent supports transparent content negotiation for\n       \
    \ the current request.\n      \"vlist\"\n        The user agent requests that\
    \ any transparently negotiated\n        response for the current request includes\
    \ an Alternates\n        header with the variant list bound to the negotiable\
    \ resource.\n        Implies \"trans\".\n      \"guess-small\"\n        The user\
    \ agent allows origin servers to run a custom algorithm\n        which guesses\
    \ the best variant for the request, and to return\n        this variant in a choice\
    \ response, if the resulting choice\n        response is smaller than or not much\
    \ larger than a list\n        response.  The definition of `not much larger' is\
    \ left to\n        origin server heuristics.  Implies \"vlist\" and \"trans\"\
    .\n      rvsa-version\n        The user agent allows origin servers and proxies\
    \ to run the\n        remote variant selection algorithm with the indicated version\n\
    \        number, or with the same major version number and a higher\n        minor\
    \ version number.  If the algorithm has sufficient\n        information to choose\
    \ a best, neighboring variant, the origin\n        server or proxy MAY return\
    \ a choice response with this\n        variant.  Implies \"trans\".\n      \"\
    *\"\n        The user agent allows origin servers and proxies to run any\n   \
    \     remote variant selection algorithm.  The origin server may\n        even\
    \ run algorithms which have not been standardized.  If the\n        algorithm\
    \ has sufficient information to choose a best,\n        neighboring variant, the\
    \ origin server or proxy MAY return a\n        choice response with this variant.\
    \  Implies \"trans\".\n   Servers SHOULD ignore all negotiate-directives they\
    \ do not\n   understand.  If the Negotiate header allows a choice between multiple\n\
    \   remote variant selection algorithms which are all supported by the\n   server,\
    \ the server SHOULD use some internal precedence heuristics to\n   select the\
    \ best algorithm.\n"
- title: 8.5 TCN
  contents:
  - "8.5 TCN\n   The TCN response header is used by a server to signal that the\n\
    \   resource is transparently negotiated.\n       TCN = \"TCN\" \":\" #( response-type\n\
    \                        | server-side-override-directive\n                  \
    \      | tcn-extension )\n       response-type = \"list\" | \"choice\" | \"adhoc\"\
    \n       server-side-override-directive = \"re-choose\" | \"keep\"\n       tcn-extension\
    \ = token [ \"=\" ( token | quoted-string ) ]\n   If the resource is not transparently\
    \ negotiated, a TCN header MUST\n   NOT be included in any response.  If the resource\
    \ is transparently\n   negotiated, a TCN header, which includes the response-type\
    \ value of\n   the response, MUST be included in every response with a 2xx status\n\
    \   code or any 3xx status code, except 304, in which it MAY be included.\n  \
    \ A TCN header MAY also be included, without a response-type value, in\n   other\
    \ responses from transparently negotiated resources.\n   A server-side override\
    \ directive MUST be included if the origin\n   server performed a server-side\
    \ override when choosing the response.\n   If the directive is \"re-choose\",\
    \ the server MUST include an\n   Alternates header with the variant bound to the\
    \ negotiable resource\n   in the response, and user agent SHOULD use its internal\
    \ variant\n   selection algorithm to choose, retrieve, and display the best variant\n\
    \   from this list.  If the directive is \"keep\" the user agent SHOULD NOT\n\
    \   renegotiate on the response, but display it directly, or act on it\n   directly\
    \ if it is a redirection response.\n   Clients SHOULD ignore all tcn-extensions\
    \ they do not understand.\n"
- title: 8.6 Variant-Vary
  contents:
  - "8.6 Variant-Vary\n   The Variant-Vary response header can be used in a choice\
    \ response to\n   record any vary information which applies to the variant data\
    \ (the\n   entity body combined with some of the entity headers) contained in\n\
    \   the response, rather than to the response as a whole.\n         Variant-Vary\
    \  = \"Variant-Vary\" \":\" ( \"*\" | 1#field-name )\n   Use of the Variant-Vary\
    \ header is discussed in section 10.2.\n"
- title: 9  Cache validators
  contents:
  - "9  Cache validators\n   To allow for correct and efficient caching and revalidation\
    \ of\n   negotiated responses, this specification extends the caching model of\n\
    \   HTTP/1.1 [1] in various ways.\n   This specification does not introduce a\
    \ `variant-list-max-age'\n   directive which explicitly bounds the freshness lifetime\
    \ of a cached\n   variant list, like the `max-age' Cache-Control directive bounds\
    \ the\n   freshness lifetime of a cached response.  However, this specification\n\
    \   does ensure that a variant list which is sent at a time T by the\n   origin\
    \ server will never be re-used without revalidation by\n   semantically transparent\
    \ caches after the time T+M.  This M is the\n   maximum of all freshness lifetimes\
    \ assigned (using max-age directives\n   or Expires headers) by the origin server\
    \ to\n      a. the responses from the negotiable resource itself, and\n      b.\
    \ the responses from its neighboring variant resources\n   If no freshness lifetimes\
    \ are assigned by the origin server, M is the\n   maximum of the freshness lifetimes\
    \ which were heuristically assigned\n   by all caches which can re-use the variant\
    \ list.\n"
- title: 9.1 Variant list validators
  contents:
  - "9.1 Variant list validators\n   A variant list validator is an opaque value which\
    \ acts as the cache\n   validator of a variant list bound to a negotiable resource.\n\
    \      variant-list-validator = <quoted-string not containing any \";\">\n   If\
    \ two responses contain the same variant list validator, a cache can\n   treat\
    \ the Alternates headers in these responses as equivalent (though\n   the headers\
    \ themselves need not be identical).\n"
- title: 9.2 Structured entity tags
  contents:
  - "9.2 Structured entity tags\n   A structured entity tag consists of a normal entity\
    \ tag of which the\n   opaque string is extended with a semicolon followed by\
    \ the text\n   (without the surrounding quotes) of a variant list validator:\n\
    \        normal      |  variant list  |   structured\n        entity tag  |  validator\
    \     |   entity tag\n       -------------+----------------+-----------------\n\
    \         \"etag\"     |     \"vlv\"      |   \"etag;vlv\"\n        W/\"etag\"\
    \    |     \"vlv\"      |  W/\"etag;vlv\"\n   Note that a structured entity tag\
    \ is itself also an entity tag.  The\n   structured nature of the tag allows caching\
    \ proxies capable of\n   transparent content negotiation to perform some optimizations\
    \ defined\n   in section 10.  When not performing such optimizations, a structured\n\
    \   tag SHOULD be treated as a single opaque value, according to the\n   general\
    \ rules in HTTP/1.1.  Examples of structured entity tags are:\n      \"xyzzy;1234\"\
    \  W/\"xyzzy;1234\"  \"gonkxxxx;1234\"  \"a;b;c;;1234\"\n   In the last example,\
    \ the normal entity tag is \"a;b;c;\" and the\n   variant list validator is \"\
    1234\".\n   If a transparently negotiated response includes an entity tag, it\n\
    \   MUST be a structured entity tag.  The variant list validator in the\n   structured\
    \ tag MUST act as a validator for the variant list contained\n   in the Alternates\
    \ header.  The normal entity tag in the structured\n   tag MUST act as a validator\
    \ of the entity body in the response and of\n   all entity headers except Alternates.\n"
- title: 9.3 Assigning entity tags to variants
  contents:
  - "9.3 Assigning entity tags to variants\n   To allow for correct revalidation of\
    \ transparently negotiated\n   responses by clients, origin servers SHOULD generate\
    \ all normal\n   entity tags for the neighboring variant resources of the negotiable\n\
    \   resource in such a way that\n     1. the same tag is never used by two different\
    \ variants,\n        unless this tag labels exactly the same entity on all occasions,\n\
    \     2. if one normal tag \"X\" is a prefix of another normal tag \"XY\",\n \
    \       then \"Y\" must never be a semicolon followed by a variant list\n    \
    \    validator.\n"
- title: 10 Content negotiation responses
  contents:
  - "10 Content negotiation responses\n   If a request on a transparently negotiated\
    \ resource yields a response\n   with a 2xx status code or any 3xx status code\
    \ except 304, this\n   response MUST always be either a list response, a choice\
    \ response, or\n   an adhoc response.  These responses MUST always include a TCN\
    \ header\n   which specifies their type.  Transparently negotiated responses with\n\
    \   other status codes MAY also include a TCN header.\n   The conditions under\
    \ which the different content negotiation\n   responses may be sent are defined\
    \ in section 12.1 for origin servers\n   and in section 13 for proxies.\n   After\
    \ having constructed a list, choice, or adhoc response, a server\n   MAY process\
    \ any If-No-Match or If-Range headers in the request\n   message and shorten the\
    \ response to a 304 (Not Modified) or 206\n   (Partial Content) response, following\
    \ the rules in the HTTP/1.1\n   specification [1].  In this case, the entity tag\
    \ of the shortened\n   response will identify it indirectly as a list, choice,\
    \ or adhoc\n   response.\n"
- title: 10.1 List response
  contents:
  - "10.1 List response\n   A list response returns the variant list of the negotiable\
    \ resource,\n   but no variant data.  It can be generated when the server does\
    \ not\n   want to, or is not allowed to, return a particular best variant for\n\
    \   the request.  If the user agent supports transparent content\n   negotiation,\
    \ the list response will cause it to select a best variant\n   and retrieve it.\n\
    \   A list response MUST contain (besides the normal headers required by\n   HTTP)\
    \ a TCN header which specifies the \"list\" response-type, the\n   Alternates\
    \ header bound to the negotiable resource, a Vary header and\n   (unless it was\
    \ a HEAD request) an entity body which allows the user\n   to manually select\
    \ the best variant.\n   An example of a list response is\n     HTTP/1.1 300 Multiple\
    \ Choices\n     Date: Tue, 11 Jun 1996 20:02:21 GMT\n     TCN: list\n     Alternates:\
    \ {\"paper.1\" 0.9 {type text/html} {language en}},\n                 {\"paper.2\"\
    \ 0.7 {type text/html} {language fr}},\n                 {\"paper.3\" 1.0 {type\
    \ application/postscript}\n                     {language en}}\n     Vary: negotiate,\
    \ accept, accept-language\n     ETag: \"blah;1234\"\n     Cache-control: max-age=86400\n\
    \     Content-Type: text/html\n     Content-Length: 227\n     <h2>Multiple Choices:</h2>\n\
    \     <ul>\n     <li><a href=paper.1>HTML, English version</a>\n     <li><a href=paper.2>HTML,\
    \ French version</a>\n     <li><a href=paper.3>Postscript, English version</a>\n\
    \     </ul>\n      Note: A list response can have any status code, but the 300\n\
    \      (Multiple Choices) code is the most appropriate one for HTTP/1.1\n    \
    \  clients.  Some existing versions of HTTP/1.0 clients are known to\n      silently\
    \ ignore 300 responses, instead of handling them according\n      to the HTTP/1.0\
    \ specification [2].  Servers should therefore be\n      careful in sending 300\
    \ responses to non-negotiating HTTP/1.0 user\n      agents, and in making these\
    \ responses cacheable.  The 200 (OK)\n      status code can be used instead.\n\
    \   The Vary header in the response SHOULD ensure correct handling by\n   plain\
    \ HTTP/1.1 caching proxies.  This header can either be\n      Vary: *\n   or a\
    \ more elaborate header; see section 10.6.1.\n   Only the origin server may construct\
    \ list responses.  Depending on\n   the status code, a list response is cacheable\
    \ unless indicated\n   otherwise.\n   According to the HTTP/1.1 specification\
    \ [1], a user agent which does\n   not support transparent content negotiation\
    \ will, when receiving a\n   list response with the 300 status code, display the\
    \ entity body\n   included in the response.  If the response contains a Location\n\
    \   header, however, the user agent MAY automatically redirect to this\n   location.\n\
    \   The handling of list responses by clients supporting transparent\n   content\
    \ negotiation is described in sections 11.1 and 13.\n"
- title: 10.2 Choice response
  contents:
  - "10.2 Choice response\n   A choice response returns a representation of the best\
    \ variant for\n   the request, and may also return the variant list of the negotiable\n\
    \   resource.  It can be generated when the server has sufficient\n   information\
    \ to be able to choose the best variant on behalf the user\n   agent, but may\
    \ only be generated if this best variant is a\n   neighboring variant.  For request\
    \ from user agents which do not\n   support transparent content negotiation, a\
    \ server may always generate\n   a choice response, provided that the variant\
    \ returned is a\n   neighboring variant.  The variant returned in a choice response\
    \ need\n   not necessarily be listed in the variant list bound to the negotiable\n\
    \   resource.\n   A choice response merges a normal HTTP response from the chosen\n\
    \   variant, a TCN header which specifies the \"choice\" response-type, and\n\
    \   a Content-Location header giving the location of the variant.\n   Depending\
    \ on the status code, a choice response is cacheable unless\n   indicated otherwise.\n\
    \   Origin servers and proxy caches MUST construct choice responses with\n   the\
    \ following algorithm (or any other algorithm which gives equal end\n   results\
    \ for the client).\n   In this algorithm, `the current Alternates header' refers\
    \ to the\n   Alternates header containing the variant list which was used to\n\
    \   choose the best variant, and `the current variant list validator'\n   refers\
    \ to the validator of this list.  Section 10.4 specifies how\n   these two items\
    \ can be obtained by a proxy cache.\n   The algorithm consists of four steps.\n\
    \     1. Construct a HTTP request message on the best variant resource\n     \
    \   by rewriting the request-URI and Host header (if appropriate) of\n       \
    \ the received request message on the negotiable resource.\n     2. Generate a\
    \ valid HTTP response message, but not one with the\n        304 (Not Modified)\
    \ code, for the request message constructed in\n        step 1.\n        In a\
    \ proxy cache, the response can be obtained from cache\n        memory, or by\
    \ passing the constructed HTTP request towards the\n        origin server.  If\
    \ the request is passed on, the proxy MAY add,\n        modify, or delete If-None-Match\
    \ and If-Range headers to optimize\n        the transaction with the upstream\
    \ server.\n           Note: the proxy should be careful not to add entity tags\
    \ of\n           non-neighboring variants to If-* (conditional) headers of the\n\
    \           request, as there are no global uniqueness requirements for\n    \
    \       these tags.\n     3. Only in origin servers: check for an origin server\n\
    \        configuration error. If the HTTP response message generated in\n    \
    \    step 2 contains a TCN header, then the best variant resource is\n       \
    \ not a proper end point in the transparent negotiation process,\n        and\
    \ a 506 (Variant Also Negotiates) error response message\n        SHOULD be generated\
    \ instead of going to step 4.\n     4. Add a number of headers to the HTTP response\
    \ message generated\n        in step 2.\n        a. Add a TCN header which specifies\
    \ the \"choice\"\n           response-type.\n        b. Add a Content-Location\
    \ header giving the location of the\n           chosen variant.  Delete any Content-Location\
    \ header which was\n           already present.\n              Note: According\
    \ to the HTTP/1.1 specification [1], if the\n              Content-Location header\
    \ contains a relative URI, this URI\n              is relative to the URI in the\
    \ Content-Base header, if\n              present, and relative to the request-URI\
    \ if no Content-\n              Base header is present.\n        c. If any Vary\
    \ headers are present in the response message\n           from step 2, add, for\
    \ every Vary header, a Variant-Vary\n           header with a copy of the contents\
    \ of this Vary header.\n        d. Delete any Alternates headers which are present\
    \ in in the\n           response.  Now, the current Alternates header MUST be\
    \ added\n           if this is required by the Negotiate request header, or if\n\
    \           the server returns \"re-choose\" in the TCN response header.\n   \
    \        Otherwise, the current Alternates header MAY be added.\n            \
    \  Note: It is usually a good strategy to always add the\n              current\
    \ Alternates header, unless it is very large\n              compared to the rest\
    \ of the response.\n        e. Add a Vary header to ensure correct handling by\
    \ plain\n           HTTP/1.1 caching proxies.  This header can either be\n   \
    \           Vary: *\n           or a more elaborate header, see section 10.6.\n\
    \        f. To ensure compatibility with HTTP/1.0 caching proxies which\n    \
    \       do not recognize the Vary header, an Expires header with a\n         \
    \  date in the past MAY be added. See section 10.7 for more\n           information.\n\
    \        g. If an ETag header is present in the response message from\n      \
    \     step 2, then extend the entity tag in that header with the\n           current\
    \ variant list validator, as specified in section 9.2.\n              Note: Step\
    \ g. is required even if the variant list itself\n              is not added in\
    \ step d.\n        h. Only in proxy caches: set the Age header of the response\
    \ to\n              max( variant_age , alternates_age )\n           where variant_age\
    \ is the age of the variant response obtained\n           in step 2, calculated\
    \ according to the rules in the HTTP/1.1\n           specification [1], and alternates_age\
    \ is the age of the\n           Alternates header added in step d, calculated\
    \ according to\n           the rules in section 10.4.\n   Note that a server can\
    \ shorten the response produced by the above\n   algorithm to a 304 (Not Modified)\
    \ response if an If-None-Match header\n   in the original request allows it. \
    \ If this is the case, an\n   implementation of the above algorithm can avoid\
    \ the unnecessary\n   internal construction of full response message in step 2,\
    \ it need\n   only construct the parts which end up in the final 304 response.\
    \  A\n   proxy cache which implements this optimization can sometimes generate\n\
    \   a legal 304 response even if it has not cached the variant data\n   itself.\n\
    \   An example of a choice response is:\n     HTTP/1.1 200 OK\n     Date: Tue,\
    \ 11 Jun 1996 20:05:31 GMT\n     TCN: choice\n     Content-Type: text/html\n \
    \    Last-Modified: Mon, 10 Jun 1996 10:01:14 GMT\n     Content-Length: 5327\n\
    \     Cache-control: max-age=604800\n     Content-Location: paper.1\n     Alternates:\
    \ {\"paper.1\" 0.9 {type text/html} {language en}},\n                 {\"paper.2\"\
    \ 0.7 {type text/html} {language fr}},\n                 {\"paper.3\" 1.0 {type\
    \ application/postscript}\n                     {language en}}\n     Etag: \"\
    gonkyyyy;1234\"\n     Vary: negotiate, accept, accept-language\n     Expires:\
    \ Thu, 01 Jan 1980 00:00:00 GMT\n     <title>A paper about ....\n"
- title: 10.3 Adhoc response
  contents:
  - "10.3 Adhoc response\n   An adhoc response can be sent by an origin server as\
    \ an extreme\n   measure, to achieve compatibility with a non-negotiating or buggy\n\
    \   client if this compatibility cannot be achieved by sending a list or\n   choice\
    \ response.  There are very little requirements on the contents\n   of an adhoc\
    \ response.  An adhoc response MUST have a TCN header which\n   specifies the\
    \ \"adhoc\" response-type, and a Vary header if the\n   response is cacheable.\
    \  It MAY contain the Alternates header bound to\n   the negotiable resource.\n\
    \   Any Vary header in the response SHOULD ensure correct handling by\n   plain\
    \ HTTP/1.1 caching proxies.  This header can either be\n        Vary: *\n   or\
    \ a more elaborate header, see section 10.6.1.  Depending on the\n   status code,\
    \ an adhoc response is cacheable unless indicated\n   otherwise.\n   As an example\
    \ of the use of an adhoc response, suppose that the\n   variant resource \"redirect-to-blah\"\
    \ yields redirection (302)\n   responses.  A choice response with this variant\
    \ could look as\n   follows:\n     HTTP/1.1 302 Moved Temporarily\n     Date:\
    \ Tue, 11 Jun 1996 20:02:28 GMT\n     TCN: choice\n     Content-location: redirect-to-blah\n\
    \     Location: http://blah.org/\n     Content-Type: text/html\n     Content-Length:\
    \ 62\n     This document is available <a href=http://blah.org/>here</a>.\n   Suppose\
    \ that the server knows that the receiving user agent has a\n   bug, which causes\
    \ it to crash on responses which contain both a\n   Content-Location and a Location\
    \ header.  The server could then work\n   around this bug by performing a server-side\
    \ override and sending the\n   following adhoc response instead:\n        HTTP/1.1\
    \ 302 Moved Temporarily\n        Date: Tue, 11 Jun 1996 20:02:28 GMT\n       \
    \ TCN: adhoc, keep\n        Location: http://blah.org/\n        Content-Type:\
    \ text/html\n        Content-Length: 62\n        This document is available <a\
    \ href=http://blah.org/>here</a>.\n"
- title: 10.4 Reusing the Alternates header
  contents:
  - "10.4 Reusing the Alternates header\n   If a proxy cache has available a negotiated\
    \ response which is\n   cacheable, fresh, and has ETag and Alternates headers,\
    \ then it MAY\n   extract the Alternates header and associated variant list validator\n\
    \   from the response, and reuse them (without unnecessary delay) to\n   negotiate\
    \ on behalf of the user agent (section 13) or to construct a\n   choice response\
    \ (section 10.2).  The age of the extracted Alternates\n   header is the age of\
    \ the response from which it is extracted,\n   calculated according to the rules\
    \ in the HTTP/1.1 specification [1].\n"
- title: 10.5 Extracting a normal response from a choice response
  contents:
  - "10.5 Extracting a normal response from a choice response\n   If a proxy receives\
    \ a choice response, it MAY extract and cache the\n   normal HTTP response contained\
    \ therein.  The normal response can be\n   extracted by taking a copy of the choice\
    \ response and then deleting\n   any Content-Location, Alternates, and Vary headers,\
    \ renaming any\n   Variant-Vary headers to Vary headers, and shortening the structured\n\
    \   entity tag in any ETag header to a normal entity tag.\n   This normal response\
    \ MAY be cached (as a HTTP response to the variant\n   request as constructed\
    \ in step 1. of section 10.2) and reused to\n   answer future direct requests\
    \ on the variant resource, according to\n   the rules in the HTTP/1.1 specification\
    \ [1].\n      Note: The caching of extracted responses can decrease the upstream\n\
    \      bandwidth usage with up to a factor 2, because two independent\n      HTTP/1.1\
    \ cache entries, one associated with the negotiable\n      resource URI and one\
    \ with the variant URI, are created in the same\n      transaction.  Without this\
    \ optimization, both HTTP/1.1 cache\n      entries can only be created by transmitting\
    \ the variant data\n      twice.\n   For security reasons (see section 14.2),\
    \ an extracted normal response\n   MUST NEVER be cached if belongs to a non-neighboring\
    \ variant\n   resource.  If the choice response claims to contain data for a non-\n\
    \   neighboring variant resource, the proxy SHOULD reject the choice\n   response\
    \ as a probable spoofing attempt.\n"
- title: 10.6 Elaborate Vary headers
  contents:
  - "10.6 Elaborate Vary headers\n   If a HTTP/1.1 [1] server can generate varying\
    \ responses for a request\n   on some resource, then the server MUST include a\
    \ Vary header in these\n   responses if they are cacheable.  This Vary header\
    \ is a signal to\n   HTTP/1.1 caches that something special is going on.  It prevents\
    \ the\n   caches from returning the currently chosen response for every future\n\
    \   request on the resource.\n   Servers engaging in transparent content negotiation\
    \ will generate\n   varying responses.  Therefore, cacheable list, choice, and\
    \ adhoc\n   responses MUST always include a Vary header.\n   The most simple Vary\
    \ header which can be included is\n       Vary: *\n   This header leaves the way\
    \ in which the response is selected by the\n   server completely unspecified.\n\
    \   A more elaborate Vary header MAY be used to allow for certain\n   optimizations\
    \ in HTTP/1.1 caches which do not have specific\n   optimizations for transparent\
    \ content negotiation, but which do cache\n   multiple variant responses for one\
    \ resource.  Such a more elaborate\n   Vary header lists all request headers which\
    \ can be used by the server\n   when selecting a response for a request on the\
    \ resource.\n"
- title: 10.6.1 Construction of an elaborate Vary header
  contents:
  - "10.6.1 Construction of an elaborate Vary header\n   Origin servers can construct\
    \ a more elaborate Vary header in the\n   following way.  First, start with the\
    \ header\n       Vary: negotiate\n   `negotiate' is always included because servers\
    \ use the information in\n   the Negotiate header when choosing between a list,\
    \ choice, or adhoc\n   response.\n   Then, if any of the following attributes\
    \ is present in any variant\n   description in the Alternates header, add the\
    \ corresponding header\n   name to the Vary header\n         attribute  |   header\
    \ name to add\n         -----------+---------------------\n          type    \
    \  |   accept\n          charset   |   accept-charset\n          language  | \
    \  accept-language\n          features  |   accept-features\n   The Vary header\
    \ constructed in this way specifies the response\n   variation which can be caused\
    \ by the use of a variant selection\n   algorithm in proxies.  If the origin server\
    \ will in some cases, for\n   example if contacted by a non-negotiating user agent,\
    \ use a custom\n   negotiation algorithm which takes additional headers into account,\n\
    \   these names of these headers SHOULD also be added to the Vary header.\n"
- title: 10.6.2 Caching of an elaborate Vary header
  contents:
  - "10.6.2 Caching of an elaborate Vary header\n   A proxy cache cannot construct\
    \ an elaborate vary header using the\n   method above, because this method requires\
    \ exact knowledge of any\n   custom algorithms present in the origin server. \
    \ However, when\n   extracting an Alternates header from a response (section 10.4)\
    \ caches\n   MAY also extract the Vary header in the response, and reuse it along\n\
    \   with the Alternates header.  A clean Vary header can however only be\n   extracted\
    \ if the variant does not vary itself, i.e. if a Variant-Vary\n   header is absent.\n"
- title: 10.7 Adding an Expires header for HTTP/1.0 compatibility
  contents:
  - "10.7 Adding an Expires header for HTTP/1.0 compatibility\n   To ensure compatibility\
    \ with HTTP/1.0 caching proxies which do not\n   recognize the Vary header, an\
    \ Expires header with a date in the past\n   can be added to the response, for\
    \ example\n        Expires: Thu, 01 Jan 1980 00:00:00 GMT\n   If this is done\
    \ by an origin server, the server SHOULD usually also\n   include a Cache-Control\
    \ header for the benefit of HTTP/1.1 caches,\n   for example\n              Cache-Control:\
    \ max-age=604800\n   which overrides the freshness lifetime of zero seconds specified\
    \ by\n   the included Expires header.\n      Note: This specification only claims\
    \ downwards compatibility with\n      the HTTP/1.0 proxy caches which implement\
    \ the HTTP/1.0\n      specification [2].  Some legacy proxy caches which return\
    \ the\n      HTTP/1.0 protocol version number do not honor the HTTP/1.0 Expires\n\
    \      header as specified in [2].  Methods for achieving compatibility\n    \
    \  with such proxy caches are beyond the scope of this specification.\n"
- title: 10.8 Negotiation on content encoding
  contents:
  - "10.8 Negotiation on content encoding\n   Negotiation on the content encoding\
    \ of a response is orthogonal to\n   transparent content negotiation.  The rules\
    \ for when a content\n   encoding may be applied are the same as in HTTP/1.1:\
    \ servers MAY\n   content-encode responses that are the result of transparent\
    \ content\n   negotiation whenever an Accept-Encoding header in the request allows\n\
    \   it.  When negotiating on the content encoding of a cacheable\n   response,\
    \ servers MUST add the accept-encoding header name to the\n   Vary header of the\
    \ response, or add `Vary: *'.\n   Servers SHOULD always be able to provide unencoded\
    \ versions of every\n   transparently negotiated response.  This means in particular\
    \ that\n   every variant in the variant list SHOULD at least be available in an\n\
    \   unencoded form.\n   Like HTTP/1.1, this specification allows proxies to encode\
    \ or decode\n   relayed or cached responses on the fly, unless explicitly forbidden\n\
    \   by a Cache-Control directive.  The encoded or decoded response still\n   contains\
    \ the same variant as far as transparent content negotiation\n   is concerned.\
    \  Note that HTTP/1.1 requires proxies to add a Warning\n   header if the encoding\
    \ of a response is changed.\n"
- title: 11 User agent support for transparent negotiation
  contents:
  - "11 User agent support for transparent negotiation\n   This section specifies\
    \ the requirements a user agent needs to satisfy\n   in order to support transparent\
    \ negotiation.  If the user agent\n   contains an internal cache, this cache MUST\
    \ conform to the rules for\n   proxy caches in section 13.\n"
- title: 11.1 Handling of responses
  contents:
  - "11.1 Handling of responses\n   If a list response is received when a resource\
    \ is accessed, the user\n   agent MUST be able to automatically choose, retrieve,\
    \ and display the\n   best variant, or display an error message if none of the\
    \ variants are\n   acceptable.\n   If a choice response is received when a resource\
    \ is accessed, the\n   usual action is to automatically display the enclosed entity.\n\
    \   However, if a remote variant selection algorithm which was enabled\n   could\
    \ have made a choice different from the choice the local\n   algorithm would make,\
    \ the user agent MAY apply its local algorithm to\n   any variant list in the\
    \ response, and automatically retrieve and\n   display another variant if the\
    \ local algorithm makes an other choice.\n   When receiving a choice response,\
    \ a user agent SHOULD check if\n   variant resource is a neighboring variant resource\
    \ of the negotiable\n   resource.  If this is not the case, the user agent SHOULD\
    \ reject the\n   choice response as a probable spoofing attempt and display an\
    \ error\n   message, for example by internally replacing the choice response with\n\
    \   a 502 (bad gateway) response.\n"
- title: 11.2 Presentation of a transparently negotiated resource
  contents:
  - "11.2 Presentation of a transparently negotiated resource\n   If the user agent\
    \ is displaying a variant which is not an embedded or\n   inlined object and which\
    \ is the result of transparent content\n   negotiation, the following requirements\
    \ apply.\n    1. The user agent SHOULD allow the user to review a list of all\n\
    \       variants bound to the negotiable resource, and to manually\n       retrieve\
    \ another variant if desired.  There are two general ways\n       of providing\
    \ such a list.  First, the information in the\n       Alternates header of the\
    \ negotiable resource could be used to\n       make an annotated menu of variants.\
    \  Second, the entity included\n       in a list response of the negotiable resource\
    \ could be displayed.\n       Note that a list response can be obtained by doing\
    \ a GET request\n       which only has the \"trans\" directive in the Negotiate\
    \ header.\n    2. The user agent SHOULD make available though its user interface\n\
    \       some indication that the resource being displayed is a negotiated\n  \
    \     resource instead of a plain resource.  It SHOULD also allow the\n      \
    \ user to examine the variant list included in the Alternates\n       header.\
    \  Such a notification and review mechanism is needed\n       because of privacy\
    \ considerations, see section 14.1.\n    3. If the user agent shows the URI of\
    \ the displayed information to\n       the user, it SHOULD be the negotiable resource\
    \ URI, not the\n       variant URI that is shown.  This encourages third parties,\
    \ who\n       want to refer to the displayed information in their own\n      \
    \ documents, to make a hyperlink to the negotiable resource as a\n       whole,\
    \ rather than to the variant resource which happens to be\n       shown.  Such\
    \ correct linking is vital for the interoperability of\n       content across\
    \ sites.  The user agent SHOULD however also provide\n       a means for reviewing\
    \ the URI of the particular variant which is\n       currently being displayed.\n\
    \    4. Similarly, if the user agent stores a reference to the\n       displayed\
    \ information for future use, for example in a hotlist,\n       it SHOULD store\
    \ the negotiable resource URI, not the variant URI.\n   It is encouraged, but\
    \ not required, that some of the above\n   functionality is also made available\
    \ for inlined or embedded objects,\n   and when a variant which was selected manually\
    \ is being displayed.\n"
- title: 12 Origin server support for transparent negotiation
  contents:
  - '12 Origin server support for transparent negotiation

    '
- title: 12.1 Requirements
  contents:
  - "12.1 Requirements\n   To implement transparent negotiation on a resource, the\
    \ origin server\n   MUST be able to send a list response when getting a GET request\
    \ on\n   the resource.  It SHOULD also be able to send appropriate list\n   responses\
    \ for HEAD requests.  When getting a request on a\n   transparently negotiable\
    \ resource, the origin server MUST NEVER\n   return a response with a 2xx status\
    \ code or any 3xx status code,\n   except 304, which is not a list, choice, or\
    \ adhoc response.\n   If the request includes a Negotiate header with a \"vlist\"\
    \ or \"trans\"\n   directive, but without any directive which allows the server\
    \ to\n   select a best variant, a list response MUST ALWAYS be sent, except\n\
    \   when the server is performing a server-side override for bug\n   compatibility.\
    \  If the request includes a Negotiate header with a\n   \"vlist\" or \"guess-small\"\
    \ directive, an Alternates header with the\n   variant list bound to the negotiable\
    \ resource MUST ALWAYS be sent in\n   any list, choice, or adhoc response, except\
    \ when the server is\n   performing a server-side override for bug compatibility.\n\
    \   If the Negotiate header allows it, the origin server MAY run a remote\n  \
    \ variant selection algorithm.  If the algorithm has sufficient\n   information\
    \ to choose a best variant, and if the best variant is a\n   neighboring variant,\
    \ the origin server MAY return a choice response\n   with this variant.\n   When\
    \ getting a request on a transparently negotiable resource from a\n   user agent\
    \ which does not support transparent content negotiation,\n   the origin server\
    \ MAY use a custom algorithm to select between\n   sending a list, choice, or\
    \ adhoc response.\n   The following table summarizes the rules above.\n     |Req\
    \ on   |Usr agnt|server-  |         Response may be:         |\n     |trans neg|capable\
    \ |side     +------+------+------+------+------+\n     |resource?|of TCN? |override?|list\
    \  |choice|adhoc |normal|error |\n     +---------+--------+---------+------+------+------+------+------+\n\
    \     |   Yes   |  Yes   |  No     |always|smt(*)|never |never |always|\n    \
    \ +---------+--------+---------+------+------+------+------+------+\n     |  \
    \ Yes   |  Yes   |  Yes    |always|always|always|never |always|\n     +---------+--------+---------+------+------+------+------+------+\n\
    \     |   Yes   |  No    |   -     |always|always|always|never |always|\n    \
    \ +---------+--------+---------+------+------+------+------+------+\n     |  \
    \ No    |   -    |   -     |never |never |never |always|always|\n     +---------+--------+---------+------+------+------+------+------+\n\
    \        (*) sometimes, when allowed by the Negotiate request header\n   Negotiability\
    \ is a binary property: a resource is either\n   transparently negotiated, or\
    \ it is not.  Origin servers SHOULD NOT\n   vary the negotiability of a resource,\
    \ or the variant list bound to\n   that resource, based on the request headers\
    \ which are received.  The\n   variant list and the property of being negotiated\
    \ MAY however change\n   through time.  The Cache-Control header can be used to\
    \ control the\n   propagation of such time-dependent changes through caches.\n\
    \   It is the responsibility of the author of the negotiable resource to\n   ensure\
    \ that all resources in the variant list serve the intended\n   content, and that\
    \ the variant resources do not engage in transparent\n   content negotiation themselves.\n"
- title: 12.2 Negotiation on transactions other than GET and HEAD
  contents:
  - "12.2 Negotiation on transactions other than GET and HEAD\n   If a resource is\
    \ transparently negotiable, this only has an impact on\n   the GET and HEAD transactions\
    \ on the resource.  It is not possible\n   (under this specification) to do transparent\
    \ content negotiation on\n   the direct result of a POST request.\n   However,\
    \ a POST request can return an unnegotiated 303 (See Other)\n   response which\
    \ causes the user agent to do a GET request on a second\n   resource.  This second\
    \ resource could then use transparent content\n   negotiation to return an appropriate\
    \ final response.  The figure\n   below illustrates this.\n      Server ______\
    \ proxy ______ proxy ______ user\n      x.org         cache        cache     \
    \   agent\n        < -------------------------------------\n        |     POST\
    \ http://x.org/cgi/submit\n        |     <form contents in request body>\n   \
    \     |\n        -------------------------------------- >\n              303 See\
    \ Other                    |\n              Location: http://x.org/result/OK |\n\
    \                                               |\n        < -------------------------------------\n\
    \        |     GET http://x.org/result/OK\n        |      small Accept- headers\n\
    \        |\n      able to choose on\n      behalf of user agent\n        |\n \
    \        ------------------------------------- >\n              choice response\
    \ with             |\n              ..result/OK.nl variant           |\n     \
    \                                      displays OK.nl\n   See the HTTP/1.1 specification\
    \ [1] for details on the 303 (See Other)\n   status code.  Note that this status\
    \ code is not understood by some\n   HTTP/1.0 clients.\n"
- title: 13 Proxy support for transparent negotiation
  contents:
  - "13 Proxy support for transparent negotiation\n   Transparent content negotiation\
    \ is an extension on top of HTTP/1.x.\n   It is designed to work through any proxy\
    \ which only implements the\n   HTTP/1.1 specification [1].  If Expires headers\
    \ are added as\n   discussed in section 10.7, negotiation will also work though\
    \ proxies\n   which implement HTTP/1.0 [2].  Thus, every HTTP/1.0 or HTTP/1.1\
    \ proxy\n   provides support for transparent content negotiation.  However, if\
    \ it\n   is to be claimed that a HTTP/1.x proxy offers transparent content\n \
    \  negotiation services, at least one of the specific optimizations\n   below\
    \ MUST be implemented.\n   An HTTP/1.x proxy MUST ONLY optimize (change) the HTTP\
    \ traffic\n   flowing through it in ways which are explicitly allowed by the\n\
    \   specification(s) it conforms to.  A proxy which supports transparent\n   content\
    \ negotiation on top of HTTP/1.x MAY perform the optimizations\n   allowed for\
    \ by HTTP/1.x.  In addition, it MAY perform three\n   additional optimizations,\
    \ defined below, on the HTTP traffic for\n   transparently negotiated resources\
    \ and their neighboring variant\n   resources.\n   First, when getting a request\
    \ on a transparently negotiable resource\n   from a user agent which supports\
    \ transparent content negotiation, the\n   proxy MAY return any cached, fresh\
    \ list response from that resource,\n   even if the selecting request headers,\
    \ as specified by the Vary\n   header, do not match.\n   Second, when allowed\
    \ by the user agent and origin server, a proxy MAY\n   reuse an Alternates header\
    \ taken from a previous response (section\n   10.4) to run a remote variant selection\
    \ algorithm.  If the algorithm\n   has sufficient information to choose a best\
    \ variant, and if the best\n   variant is a neighboring variant, the proxy MAY\
    \ return a choice\n   response with this variant.\n   Third, if a proxy receives\
    \ a choice response, it MAY extract and\n   cache the normal response embedded\
    \ therein, as described in section\n   10.5.\n"
- title: 14 Security and privacy considerations
  contents:
  - '14 Security and privacy considerations

    '
- title: 14.1 Accept- headers revealing personal information
  contents:
  - "14.1 Accept- headers revealing personal information\n   Accept- headers, in particular\
    \ Accept-Language headers, may reveal\n   information which the user would rather\
    \ keep private unless it will\n   directly improve the quality of service.  For\
    \ example, a user may not\n   want to send language preferences to sites which\
    \ do not offer multi-\n   lingual content.  The transparent content negotiation\
    \ mechanism\n   allows user agents to omit sending of the Accept-Language header\
    \ by\n   default, without adversely affecting the outcome of the negotiation\n\
    \   process if transparently negotiated multi-lingual content is\n   accessed.\n\
    \   However, even if Accept- headers are never sent, the automatic\n   selection\
    \ and retrieval of a variant by a user agent will reveal a\n   preference for\
    \ this variant to the server.  A malicious service\n   author could provide a\
    \ page with `fake' negotiability on (ethnicity-\n   correlated) languages, with\
    \ all variants actually being the same\n   English document, as a means of obtaining\
    \ privacy-sensitive\n   information.  Such a plot would however be visible to\
    \ an alert victim\n   if the list of available variants and their properties is\
    \ reviewed.\n   Some additional privacy considerations connected to Accept- headers\n\
    \   are discussed in [1].\n"
- title: 14.2 Spoofing of responses from variant resources
  contents:
  - "14.2 Spoofing of responses from variant resources\n   The caching optimization\
    \ in section 10.5 gives the implementer of a\n   negotiable resource control over\
    \ the responses cached for all\n   neighboring variant resources.  This is a security\
    \ problem if a\n   neighboring variant resource belongs to another author.  To\
    \ provide\n   security in this case, the HTTP server will have to filter the\n\
    \   Content-Location headers in the choice responses generated by the\n   negotiable\
    \ resource implementation.\n"
- title: 14.3 Security holes revealed by negotiation
  contents:
  - "14.3 Security holes revealed by negotiation\n   Malicious servers could use transparent\
    \ content negotiation as a\n   means of obtaining information about security holes\
    \ which may be\n   present in user agents.  This is a risk in particular for negotiation\n\
    \   on the availability of scripting languages and libraries.\n"
- title: 15 Internationalization considerations
  contents:
  - "15 Internationalization considerations\n   This protocol defines negotiation\
    \ facilities which can be used for\n   the internationalization of web content.\
    \  For the\n   internationalization of list response bodies (section 10.1), HTTP/1.0\n\
    \   style negotiation (section 4.2) can be used.\n"
- title: 16 Acknowledgments
  contents:
  - "16 Acknowledgments\n   Work on HTTP content negotiation has been done since at\
    \ least 1993.\n   The authors are unable to trace the origin of many of the ideas\n\
    \   incorporated in this document.  Many members of the HTTP working\n   group\
    \ have contributed to the negotiation model in this\n   specification.  The authors\
    \ wish to thank the individuals who have\n   commented on earlier versions of\
    \ this document, including Brian\n   Behlendorf, Daniel DuBois, Martin J. Duerst,\
    \ Roy T. Fielding, Jim\n   Gettys, Yaron Goland, Dirk van Gulik, Ted Hardie, Graham\
    \ Klyne, Scott\n   Lawrence, Larry Masinter, Jeffrey Mogul, Henrik Frystyk Nielsen,\n\
    \   Frederick G.M. Roeber, Paul Sutton, and Klaus Weide and Mark Wood.\n"
- title: 17 References
  contents:
  - "17 References\n   [1] Fielding, R., Gettys, J., Mogul, J., Frystyk, H., and\n\
    \       T. Berners-Lee, \"Hypertext Transfer Protocol -- HTTP/1.1\", RFC\n   \
    \    2068, January 1997.\n   [2] Berners-Lee, T., Fielding, R., and H. Frystyk,\
    \ \"Hypertext\n       Transfer Protocol -- HTTP/1.0\", RFC 1945, May 1996.\n \
    \  [3] Holtman, K., and A. Mutz, \"HTTP Remote Variant Selection\n       Algorithm\
    \ -- RVSA/1.0\", RFC 2296, March 1998.\n   [4] Bradner, S., \"Key words for use\
    \ in RFCs to Indicate Requirement\n       Levels\", BCP 14, RFC 2119, March 1997.\n\
    \   [5] Yergeau, F., \"UTF-8, a transformation format of Unicode and ISO\n   \
    \    10646\", RFC 2044, October 1996.\n"
- title: 18 Authors' Addresses
  contents:
  - "18 Authors' Addresses\n   Koen Holtman\n   Technische Universiteit Eindhoven\n\
    \   Postbus 513\n   Kamer HG 6.57\n   5600 MB Eindhoven (The Netherlands)\n  \
    \ EMail: koen@win.tue.nl\n   Andrew H. Mutz\n   Hewlett-Packard Company\n   1501\
    \ Page Mill Road 3U-3\n   Palo Alto CA 94304, USA\n   Fax +1 415 857 4691\n  \
    \ EMail: mutz@hpl.hp.com\n"
- title: '19 Appendix: Example of a local variant selection algorithm'
  contents:
  - "19 Appendix: Example of a local variant selection algorithm\n   A negotiating\
    \ user agent will choose the best variant from a variant\n   list with a local\
    \ variant selection algorithm.  This appendix\n   contains an example of such\
    \ an algorithm.\n   The inputs of the algorithm are a variant list from an Alternates\n\
    \   header, and an agent-side configuration database, which contains\n     - the\
    \ feature set of the current request,\n     - a collection of quality values assigned\
    \ to media types,\n       languages, and charsets for the current request, following\
    \ the\n       model of the corresponding HTTP/1.1 [1] Accept- headers,\n     -\
    \ a table which lists `forbidden' combinations of media types and\n       charsets,\
    \ i.e. combinations which cannot be displayed because of\n       some internal\
    \ user agent limitation.\n   The output of the algorithm is either the best variant,\
    \ or the\n   conclusion that none of the variants are acceptable.\n"
- title: 19.1 Computing overall quality values
  contents:
  - "19.1 Computing overall quality values\n   As a first step in the local variant\
    \ selection algorithm, the overall\n   qualities associated with all variant descriptions\
    \ in the list are\n   computed.\n   The overall quality Q of a variant description\
    \ is the value\n      Q = round5( qs * qt * qc * ql * qf * qa )\n   where rounds5\
    \ is a function which rounds a floating point value to 5\n   decimal places after\
    \ the point.  It is assumed that the user agent\n   can run on multiple platforms:\
    \ the rounding function makes the\n   algorithm independent of the exact characteristics\
    \ of the underlying\n   floating point hardware.\n   The factors qs, qt, qc, ql,\
    \ qf, and qa are determined as follows.\n      qs Is the source quality factor\
    \ in the variant description.\n      qt The media type quality factor is 1 if\
    \ there is no type\n         attribute in the variant description.  Otherwise,\
    \ it is the\n         quality value assigned to this type by the configuration\n\
    \         database.  If the database does not assign a value, then the\n     \
    \    factor is 0.\n      qc The charset quality factor is 1 if there is no charset\n\
    \         attribute in the variant description.  Otherwise, it is the\n      \
    \   quality value assigned to this charset by the configuration\n         database.\
    \  If the database does not assign a value, then the\n         factor is 0.\n\
    \      ql The language quality factor is 1 if there is no language\n         attribute\
    \ in the variant description.  Otherwise, it is the\n         highest quality\
    \ value the configuration database assigns to any\n         of the languages listed\
    \ in the language attribute.  If the\n         database does not assign a value\
    \ to any of the languages\n         listed, then the factor is 0.\n      qf The\
    \ features quality factor is 1 if there is no features\n         attribute in\
    \ the variant description.  Otherwise, it is the\n         quality degradation\
    \ factor computed for the features attribute\n         using the feature set of\
    \ the current request.\n      qa The quality adjustment factor is 0 if the variant\
    \ description\n         lists a media type - charset combination which is `forbidden'\n\
    \         by the table, and 1 otherwise.\n   As an example, if a variant list\
    \ contains the variant description\n     {\"paper.2\" 0.7 {type text/html} {language\
    \ fr}}\n   and if the configuration database contains the quality value\n   assignments\n\
    \     types:     text/html;q=1.0, type application/postscript;q=0.8\n     languages:\
    \ en;q=1.0, fr;q=0.5\n   then the local variant selection algorithm will compute\
    \ the overall\n   quality for the variant description as follows:\n     {\"paper.2\"\
    \ 0.7 {type text/html} {language fr}}\n                 |           |        \
    \         |\n                 |           |                 |\n              \
    \   V           V                 V\n       round5 ( 0.7   *     1.0        *\
    \      0.5 ) = 0.35000\n   With same configuration database, the variant list\n\
    \     {\"paper.1\" 0.9 {type text/html} {language en}},\n     {\"paper.2\" 0.7\
    \ {type text/html} {language fr}},\n     {\"paper.3\" 1.0 {type application/postscript}\
    \ {language en}}\n   would yield the following computations:\n       round5 (\
    \ qs  * qt  * qc  * ql  * qf  * qa ) = Q\n                ---   ---   ---   ---\
    \   ---   ---\n      paper.1:  0.9 * 1.0 * 1.0 * 1.0 * 1.0 * 1.0  = 0.90000\n\
    \      paper.1:  0.7 * 1.0 * 1.0 * 0.5 * 1.0 * 1.0  = 0.35000\n      paper.3:\
    \  1.0 * 0.8 * 1.0 * 1.0 * 1.0 * 1.0  = 0.80000\n"
- title: 19.2 Determining the result
  contents:
  - "19.2 Determining the result\n   Using all computed overall quality values, the\
    \ end result of the\n   local variant selection algorithm is determined as follows.\n\
    \   If all overall quality values are 0, then the best variant is the\n   fallback\
    \ variant, if there is one in the list, else the result is the\n   conclusion\
    \ that none of the variants are acceptable.\n   If at least one overall quality\
    \ value is greater than 0, then the\n   best variant is the variant which has\
    \ the description with the\n   highest overall quality value, or, if there are\
    \ multiple variant\n   descriptions which share the highest overall quality value,\
    \ the\n   variant of the first variant description in the list which has this\n\
    \   highest overall quality value.\n"
- title: 19.3 Ranking dimensions
  contents:
  - "19.3 Ranking dimensions\n   Consider the following variant list:\n     {\"paper.greek\"\
    \   1.0 {language el} {charset ISO-8859-7}},\n     {\"paper.english\" 1.0 {language\
    \ en} {charset ISO-8859-1}}\n   It could be the case that the user prefers the\
    \ language \"el\" over\n   \"en\", while the user agent can render \"ISO-8859-1\"\
    \ better than \"ISO-\n   8859-7\".  The result is that in the language dimension,\
    \ the first\n   variant is best, while the second variant is best in the charset\n\
    \   dimension.  In this situation, it would be preferable to choose the\n   first\
    \ variant as the best variant: the user settings in the language\n   dimension\
    \ should take precedence over the hard-coded values in the\n   charset dimension.\n\
    \   To express this ranking between dimensions, the user agent\n   configuration\
    \ database should have a higher spread in the quality\n   values for the language\
    \ dimension than for the charset dimension.\n   For example, with\n     languages:\
    \ el;q=1.0, en-gb;q=0.7, en;q=0.6, da;q=0, ...\n     charsets:  ISO-8859-1;q=1.0,\
    \ ISO-8859-7;q=0.95,\n                ISO-8859-5;q=0.97, unicode-1-1;q=0, ...\n\
    \   the first variant will have an overall quality of 0.95000, while the\n   second\
    \ variant will have an overall quality 0.70000.  This makes the\n   first variant\
    \ the best variant.\n"
- title: '20 Appendix: feature negotiation examples'
  contents:
  - "20 Appendix: feature negotiation examples\n   This appendix contains examples\
    \ of the use of feature tags in variant\n   descriptions.  The tag names used\
    \ here are examples only, they do not\n   in general reflect the tag naming scheme\
    \ proposed in [4].\n"
- title: 20.1 Use of feature tags
  contents:
  - "20.1 Use of feature tags\n   Feature tags can be used in variant lists to express\
    \ the quality\n   degradation associated with the presence or absence of certain\n\
    \   features.  One example is\n     {\"index.html.plain\" 0.7 },\n     {\"index.html\"\
    \       1.0 {features tables frames}}\n   Here, the \"{features tables frames}\"\
    \ part expresses that index.html\n   uses the features tagged as tables and frames.\
    \  If these features are\n   absent, the overall quality of index.html degrades\
    \ to 0.  Another\n   example is\n     {\"home.graphics\" 1.0 {features !textonly}},\n\
    \     {\"home.textonly\" 0.7 }\n   where the \"{features !textonly}\" part expresses\
    \ that home.graphics\n   requires the absence of the textonly feature.  If the\
    \ feature is\n   present, the overall quality of home.graphics degrades to 0.\n\
    \   The absence of a feature need not always degrade the overall quality\n   to\
    \ 0.  In the example\n     {\"x.html.1\" 1.0 {features fonts;-0.7}}\n   the absence\
    \ of the fonts feature degrades the quality with a factor\n   of 0.7.  Finally,\
    \ in the example\n      {\"y.html\" 1.0 {features [blebber wolx] }}\n   The \"\
    [blebber wolx]\" expresses that y.html requires the presence of\n   the blebber\
    \ feature or the wolx feature.  This construct can be used\n   in a number of\
    \ cases:\n     1. blebber and wolx actually tag the same feature, but they were\n\
    \        registered by different people, and some user agents say they\n     \
    \   support blebber while others say they support wolx.\n     2. blebber and wolx\
    \ are HTML tags of different vendors which\n        implement the same functionality,\
    \ and which are used together in\n        y.html without interference.\n     3.\
    \ blebber and wolx are HTML tags of different vendors which\n        implement\
    \ the same functionality, and y.html uses the tags in a\n        conditional HTML\
    \ construct.\n     4. blebber is a complicated HTML tag with only a sketchy\n\
    \        definition, implemented by one user agent vendor, and wolx\n        indicates\
    \ implementation of a well-defined subset of the blebber\n        tag by some\
    \ other vendor(s).  y.html uses only this well-defined\n        subset.\n"
- title: 20.2 Use of numeric feature tags
  contents:
  - "20.2 Use of numeric feature tags\n   As an example of negotiation in a numeric\
    \ area, the following variant\n   list describes four variants with title graphics\
    \ designed for\n   increasing screen widths:\n     {\"home.pda\"    1.0 {features\
    \ screenwidth=[-199] }},\n     {\"home.narrow\" 1.0 {features screenwidth=[200-599]\
    \ }},\n     {\"home.normal\" 1.0 {features screenwidth=[600-999] }},\n     {\"\
    home.wide\"   1.0 {features screenwidth=[1000-] }},\n     {\"home.normal\"}\n\
    \   The last element of the list specifies a safe default for user agents\n  \
    \ which do not implement screen width negotiation.  Such user agents\n   will\
    \ reject the first four variants as unusable, as they seem to rely\n   on a feature\
    \ which they do not understand.\n"
- title: 20.3 Feature tag design
  contents:
  - "20.3 Feature tag design\n   When designing a new feature tag, it is important\
    \ to take into\n   account that existing user agents, which do not recognize the\
    \ new tag\n   will treat the feature as absent.  In general, a new feature tag\n\
    \   needs to be designed in such a way that absence of the tag is the\n   default\
    \ case which reflects current practice.  If this design\n   principle is ignored,\
    \ the resulting feature tag will generally be\n   unusable.\n   As an example,\
    \ one could try to support negotiation between\n   monochrome and color content\
    \ by introducing a `color' feature tag,\n   the presence of which would indicate\
    \ the capability to display color\n   graphics.  However, if this new tag is used\
    \ in a variant list, for\n   example\n      {\"rainbow.gif\"      1.0 {features\
    \ color} }\n      {\"rainbow.mono.gif\" 0.6 {features !color}}\n   then existing\
    \ user agents, which would not recognize the color tag,\n   would all display\
    \ the monochrome rainbow.  The color tag is therefore\n   unusable in situations\
    \ where optimal results for existing user agents\n   are desired.  To provide\
    \ for negotiation in this area, one must\n   introduce a `monochrome' feature\
    \ tag; its presence indicates that the\n   user agent can only render (or the\
    \ user prefers to view) monochrome\n   graphics.\n"
- title: '21 Appendix: origin server implementation considerations'
  contents:
  - '21 Appendix: origin server implementation considerations

    '
- title: 21.1 Implementation with a CGI script
  contents:
  - "21.1 Implementation with a CGI script\n   Transparent content negotiation has\
    \ been designed to allow a broad\n   range of implementation options at the origin\
    \ server side.  A very\n   minimal implementation can be done using the CGI interface.\
    \  The CGI\n   script below is an example.\n      #!/bin/sh\n      cat - <<'blex'\n\
    \      TCN: list\n      Alternates: {\"stats.tables.html\" 1.0 {type text/html}\
    \ {features\n      tables}}, {\"stats.html\" 0.8 {type text/html}}, {\"stats.ps\"\
    \ 0.95\n      {type application/postscript}}\n      Vary: *\n      Content-Type:\
    \ text/html\n      <title>Multiple Choices for Web Statistics</title>\n      <h2>Multiple\
    \ Choices for Web Statistics:</h2>\n      <ul>\n      <li><a href=stats.tables.html>Version\
    \ with HTML tables</a>\n      <p>\n      <li><a href=stats.html>Version without\
    \ HTML tables</a>\n      <p>\n      <li><a href=stats.ps>Postscript version</a>\n\
    \      </ul>\n      blex\n   The Alternates header in the above script must be\
    \ read as a single\n   line.  The script always generates a list response with\
    \ the 200 (OK)\n   code, which ensures compatibility with non-negotiating HTTP/1.0\n\
    \   agents.\n"
- title: 21.2 Direct support by HTTP servers
  contents:
  - "21.2 Direct support by HTTP servers\n   Sophisticated HTTP servers could make\
    \ a transparent negotiation\n   module available to content authors.  Such a module\
    \ could incorporate\n   a remote variant selection algorithm and an implementation\
    \ of the\n   algorithm for generating choice responses (section 10.2).  The\n\
    \   definition of interfaces to such modules is beyond the scope of this\n   specification.\n"
- title: 21.3 Web publishing tools
  contents:
  - "21.3 Web publishing tools\n   Web publishing tools could automatically generate\
    \ several variants of\n   a document (for example the original TeX version, a\
    \ HTML version with\n   tables, a HTML version without tables, and a Postscript\
    \ version),\n   together with an appropriate variant list in the interface format\
    \ of\n   a HTTP server transparent negotiation module.  This would allow\n   documents\
    \ to be published as transparently negotiable resources.\n"
- title: '22 Appendix: Example of choice response construction'
  contents:
  - "22 Appendix: Example of choice response construction\n   The following is an\
    \ example of the construction of a choice response\n   by a proxy cache which\
    \ supports HTTP/1.1 and transparent content\n   negotiation.  The use of the HTTP/1.1\
    \ conditional request mechanisms\n   is also shown.\n   Assume that a user agent\
    \ has cached a variant list with the validator\n   \"1234\" for the negotiable\
    \ resource http://x.org/paper.  Also assume\n   that it has cached responses from\
    \ two neighboring variants, with the\n   entity tags \"gonkyyyy\" and W/\"a;b\"\
    .  Assume that all three user agent\n   cache entries are stale: they would need\
    \ to be revalidated before the\n   user agent can use them.  If http://x.org/paper\
    \ accessed in this\n   situation, the user agent could send the following request\
    \ to its\n   proxy cache:\n     GET /paper HTTP/1.1\n     Host: x.org\n     User-Agent:\
    \ WuxtaWeb/2.4\n     Negotiate: 1.0\n     Accept: text/html, application/postscript;q=0.4,\
    \ */*\n     Accept-Language: en\n     If-None-Match: \"gonkyyyy;1234\", W/\"a;b;1234\"\
    \n   Assume that the proxy cache has cached the same three items as the\n   user\
    \ agent, but that it has revalidated the variant list 8000 seconds\n   ago, so\
    \ that the list is still fresh for the proxy.  This means that\n   the proxy can\
    \ run a remote variant selection algorithm on the list\n   and the incoming request.\n\
    \   Assume that the remote algorithm is able to choose paper.html.en as\n   the\
    \ best variant.  The proxy can now construct a choice response,\n   using the\
    \ algorithm in section 10.2.  In steps 1 and 2 of the\n   algorithm, the proxy\
    \ can construct the following conditional request\n   on the best variant, and\
    \ send it to the origin server:\n     GET /paper.html.en HTTP/1.1\n     Host:\
    \ x.org\n     User-Agent: WuxtaWeb/2.4\n     Negotiate: 1.0\n     Accept: text/html,\
    \ application/postscript;q=0.4, */*\n     Accept-Language: en\n     If-None-Match:\
    \ \"gonkyyyy\", W/\"a;b\"\n     Via: 1.1 fred\n   On receipt of the response\n\
    \     HTTP/1.1 304 Not Modified\n     Date: Tue, 11 Jun 1996 20:05:31 GMT\n  \
    \   Etag: \"gonkyyyy\"\n   from the origin server, the proxy can use its freshly\
    \ revalidated\n   paper.html.en cache entry to expand the response to a non-304\n\
    \   response:\n     HTTP/1.1 200 OK\n     Date: Tue, 11 Jun 1996 20:05:31 GMT\n\
    \     Content-Type: text/html\n     Last-Modified: Mon, 10 Jun 1996 10:01:14 GMT\n\
    \     Content-Length: 5327\n     Cache-control: max-age=604800\n     Etag: \"\
    gonkyyyy\"\n     Via: 1.1 fred\n     Age: 0\n     <title>A paper about ....\n\
    \   Using this 200 response, the proxy can construct a choice response\n   in\
    \ step 4 of the algorithm:\n     HTTP/1.1 200 OK\n     Date: Tue, 11 Jun 1996\
    \ 20:05:31 GMT\n     TCN: choice\n     Content-Type: text/html\n     Last-Modified:\
    \ Mon, 10 Jun 1996 10:01:14 GMT\n     Content-Length: 5327\n     Cache-control:\
    \ max-age=604800\n     Content-Location: paper.html.en\n     Alternates: {\"paper.html.en\"\
    \ 0.9 {type text/html} {language en}},\n                 {\"paper.html.fr\" 0.7\
    \ {type text/html} {language fr}},\n                 {\"paper.ps.en\"   1.0 {type\
    \ application/postscript}\n                     {language en}}\n     Etag: \"\
    gonkyyyy;1234\"\n     Vary: negotiate, accept, accept-language\n     Expires:\
    \ Thu, 01 Jan 1980 00:00:00 GMT\n     Via: 1.1 fred\n     Age: 8000\n     <title>A\
    \ paper about ....\n   The choice response can subsequently be shortened to a\
    \ 304 response,\n   because of the If-None-Match header in the original request\
    \ from the\n   user agent.  Thus, the proxy can finally return\n     HTTP/1.1\
    \ 304 Not Modified\n     Date: Tue, 11 Jun 1996 20:05:31 GMT\n     Etag: \"gonkyyyy;1234\"\
    \n     Content-Location: paper.html.en\n     Vary: negotiate, accept, accept-language\n\
    \     Expires: Thu, 01 Jan 1980 00:00:00 GMT\n     Via: 1.1 fred\n     Age: 8000\n\
    \   to the user agent.\n"
- title: 23 Full Copyright Statement
  contents:
  - "23 Full Copyright Statement\n   Copyright (C) The Internet Society (1998).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
