- title: __initial_text__
  contents:
  - '                     Bundle Protocol Specification

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard of any kind.\n   Discussion\
    \ and suggestions for improvement are requested.\n   Distribution of this memo\
    \ is unlimited.\n"
- title: IESG Note
  contents:
  - "IESG Note\n   This RFC is not a candidate for any level of Internet Standard.\
    \  The\n   IETF disclaims any knowledge of the fitness of this RFC for any\n \
    \  purpose and in particular notes that the decision to publish is not\n   based\
    \ on IETF review for such things as security, congestion control,\n   or inappropriate\
    \ interaction with deployed protocols.  The RFC Editor\n   has chosen to publish\
    \ this document at its discretion.  Readers of\n   this document should exercise\
    \ caution in evaluating its value for\n   implementation and deployment.  See\
    \ RFC 3932 for more information.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes the end-to-end protocol, block formats,\
    \ and\n   abstract service description for the exchange of messages (bundles)\n\
    \   in Delay Tolerant Networking (DTN).\n   This document was produced within\
    \ the IRTF's Delay Tolerant\n   Networking Research Group (DTNRG) and represents\
    \ the consensus of all\n   of the active contributors to this group.  See http://www.dtnrg.org\n\
    \   for more information.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  3\n   2.  Requirements Notation  . . . . . . . . . . . . . . .\
    \ . . . . .  4\n   3.  Service Description  . . . . . . . . . . . . . . . . .\
    \ . . . .  5\n     3.1.  Definitions  . . . . . . . . . . . . . . . . . . . .\
    \ . . .  5\n     3.2.  Implementation Architectures . . . . . . . . . . . . .\
    \ . .  9\n     3.3.  Services Offered by Bundle Protocol Agents . . . . . . .\
    \ . 11\n   4.  Bundle Format  . . . . . . . . . . . . . . . . . . . . . . . .\
    \ 11\n     4.1.  Self-Delimiting Numeric Values (SDNVs) . . . . . . . . . . 12\n\
    \     4.2.  Bundle Processing Control Flags  . . . . . . . . . . . . . 13\n  \
    \   4.3.  Block Processing Control Flags . . . . . . . . . . . . . . 15\n    \
    \ 4.4.  Endpoint IDs . . . . . . . . . . . . . . . . . . . . . . . 16\n     4.5.\
    \  Formats of Bundle Blocks . . . . . . . . . . . . . . . . . 17\n       4.5.1.\
    \  Primary Bundle Block . . . . . . . . . . . . . . . . . 19\n       4.5.2.  Canonical\
    \ Bundle Block Format  . . . . . . . . . . . . 22\n       4.5.3.  Bundle Payload\
    \ Block . . . . . . . . . . . . . . . . . 23\n     4.6.  Extension Blocks . .\
    \ . . . . . . . . . . . . . . . . . . . 24\n     4.7.  Dictionary Revision  .\
    \ . . . . . . . . . . . . . . . . . . 24\n   5.  Bundle Processing  . . . . .\
    \ . . . . . . . . . . . . . . . . . 24\n     5.1.  Generation of Administrative\
    \ Records . . . . . . . . . . . 25\n     5.2.  Bundle Transmission  . . . . .\
    \ . . . . . . . . . . . . . . 26\n     5.3.  Bundle Dispatching . . . . . . .\
    \ . . . . . . . . . . . . . 26\n     5.4.  Bundle Forwarding  . . . . . . . .\
    \ . . . . . . . . . . . . 27\n       5.4.1.  Forwarding Contraindicated . . .\
    \ . . . . . . . . . . . 28\n       5.4.2.  Forwarding Failed  . . . . . . . .\
    \ . . . . . . . . . . 29\n     5.5.  Bundle Expiration  . . . . . . . . . . .\
    \ . . . . . . . . . 29\n     5.6.  Bundle Reception . . . . . . . . . . . . .\
    \ . . . . . . . . 30\n     5.7.  Local Bundle Delivery  . . . . . . . . . . .\
    \ . . . . . . . 31\n     5.8.  Bundle Fragmentation . . . . . . . . . . . . .\
    \ . . . . . . 32\n     5.9.  Application Data Unit Reassembly . . . . . . . .\
    \ . . . . . 33\n     5.10. Custody Transfer . . . . . . . . . . . . . . . . .\
    \ . . . . 34\n       5.10.1. Custody Acceptance . . . . . . . . . . . . . . .\
    \ . . . 34\n       5.10.2. Custody Release  . . . . . . . . . . . . . . . . .\
    \ . . 35\n     5.11. Custody Transfer Success . . . . . . . . . . . . . . . .\
    \ . 35\n     5.12. Custody Transfer Failure . . . . . . . . . . . . . . . . .\
    \ 35\n     5.13. Bundle Deletion  . . . . . . . . . . . . . . . . . . . . . 36\n\
    \     5.14. Discarding a Bundle  . . . . . . . . . . . . . . . . . . . 36\n  \
    \   5.15. Canceling a Transmission . . . . . . . . . . . . . . . . . 36\n    \
    \ 5.16. Polling  . . . . . . . . . . . . . . . . . . . . . . . . . 36\n   6. \
    \ Administrative Record Processing . . . . . . . . . . . . . . . 37\n     6.1.\
    \  Administrative Records . . . . . . . . . . . . . . . . . . 37\n       6.1.1.\
    \  Bundle Status Reports  . . . . . . . . . . . . . . . . 38\n       6.1.2.  Custody\
    \ Signals  . . . . . . . . . . . . . . . . . . . 41\n     6.2.  Generation of\
    \ Administrative Records . . . . . . . . . . . 44\n     6.3.  Reception of Custody\
    \ Signals . . . . . . . . . . . . . . . 44\n   7.  Services Required of the Convergence\
    \ Layer . . . . . . . . . . 44\n     7.1.  The Convergence Layer  . . . . . .\
    \ . . . . . . . . . . . . 44\n     7.2.  Summary of Convergence Layer Services\
    \  . . . . . . . . . . 45\n   8.  Security Considerations  . . . . . . . . . .\
    \ . . . . . . . . . 45\n   9.  IANA Considerations  . . . . . . . . . . . . .\
    \ . . . . . . . . 47\n   10. References . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . 47\n     10.1. Normative References . . . . . . . . . . . . .\
    \ . . . . . . 47\n     10.2. Informative References . . . . . . . . . . . . .\
    \ . . . . . 47\n   Appendix A.  Contributors  . . . . . . . . . . . . . . . .\
    \ . . . . 49\n   Appendix B.  Comments  . . . . . . . . . . . . . . . . . . .\
    \ . . . 49\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document describes version 6 of the Delay Tolerant\
    \ Networking\n   (DTN) \"bundle\" protocol (BP).  Delay Tolerant Networking is\
    \ an end-\n   to-end architecture providing communications in and/or through highly\n\
    \   stressed environments.  Stressed networking environments include\n   those\
    \ with intermittent connectivity, large and/or variable delays,\n   and high bit\
    \ error rates.  To provide its services, BP sits at the\n   application layer\
    \ of some number of constituent internets, forming a\n   store-and-forward overlay\
    \ network.  Key capabilities of BP include:\n   o  Custody-based retransmission\n\
    \   o  Ability to cope with intermittent connectivity\n   o  Ability to take advantage\
    \ of scheduled, predicted, and\n      opportunistic connectivity (in addition\
    \ to continuous\n      connectivity)\n   o  Late binding of overlay network endpoint\
    \ identifiers to\n      constituent internet addresses\n   For descriptions of\
    \ these capabilities and the rationale for the DTN\n   architecture, see [ARCH]\
    \ and [SIGC].  [TUT] contains a tutorial-level\n   overview of DTN concepts.\n\
    \   This is an experimental protocol, produced within the IRTF's Delay\n   Tolerant\
    \ Networking Research Group (DTNRG) and represents the\n   consensus of all of\
    \ the active contributors to this group.  If this\n   protocol is used on the\
    \ Internet, IETF standard protocols for\n   security and congestion control should\
    \ be used.\n   BP's location within the standard protocol stack is as shown in\n\
    \   Figure 1.  BP uses the \"native\" internet protocols for communications\n\
    \   within a given internet.  Note that \"internet\" in the preceding is\n   used\
    \ in a general sense and does not necessarily refer to TCP/IP.\n   The interface\
    \ between the common bundle protocol and a specific\n   internetwork protocol\
    \ suite is termed a \"convergence layer adapter\".\n   Figure 1 shows three distinct\
    \ transport and network protocols\n   (denoted T1/N1, T2/N2, and T3/N3).\n   +-----------+\
    \                                         +-----------+\n   |   BP app  |    \
    \                                     |   BP app  |\n   +---------v-|   +->>>>>>>>>>v-+\
    \     +->>>>>>>>>>v-+   +-^---------+\n   |    BP   v |   | ^    BP   v |    \
    \ | ^    BP   v |   | ^   BP    |\n   +---------v-+   +-^---------v-+     +-^---------v-+\
    \   +-^---------+\n   | Trans1  v |   + ^  T1/T2  v |     + ^  T2/T3  v |   |\
    \ ^  Trans3 |\n   +---------v-+   +-^---------v-+     +-^---------v +   +-^---------+\n\
    \   | Net1    v |   | ^  N1/N2  v |     | ^  N2/N3  v |   | ^  Net3   |\n   +---------v-+\
    \   +-^---------v +     +-^---------v-+   +-^---------+\n   |         >>>>>>>>^\
    \         >>>>>>>>>>^         >>>>>>>>^         |\n   +-----------+   +-------------+\
    \     +-------------+   +-----------+\n   |                      |           \
    \        |                      |\n   |<--- An internet  --->|               \
    \    |<--- An internet  --->|\n   |                      |                   |\
    \                      |\n                  Figure 1: The Bundle Protocol Sits\
    \ at\n                the Application Layer of the Internet Model\n   This document\
    \ describes the format of the protocol data units (called\n   bundles) passed\
    \ between entities participating in BP communications.\n   The entities are referred\
    \ to as \"bundle nodes\".  This document does\n   not address:\n   o  Operations\
    \ in the convergence layer adapters that bundle nodes use\n      to transport\
    \ data through specific types of internets.  (However,\n      the document does\
    \ discuss the services that must be provided by\n      each adapter at the convergence\
    \ layer.)\n   o  The bundle routing algorithm.\n   o  Mechanisms for populating\
    \ the routing or forwarding information\n      bases of bundle nodes.\n"
- title: 2.  Requirements Notation
  contents:
  - "2.  Requirements Notation\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n"
- title: 3.  Service Description
  contents:
  - '3.  Service Description

    '
- title: 3.1.  Definitions
  contents:
  - "3.1.  Definitions\n   Bundle -  A bundle is a protocol data unit of the DTN bundle\n\
    \      protocol.  Each bundle comprises a sequence of two or more\n      \"blocks\"\
    \ of protocol data, which serve various purposes.  Multiple\n      instances of\
    \ the same bundle (the same unit of DTN protocol data)\n      might exist concurrently\
    \ in different parts of a network --\n      possibly in different representations\
    \ -- in the memory local to\n      one or more bundle nodes and/or in transit\
    \ between nodes.  In the\n      context of the operation of a bundle node, a bundle\
    \ is an instance\n      of some bundle in the network that is in that node's local\
    \ memory.\n   Bundle payload -  A bundle payload (or simply \"payload\") is the\n\
    \      application data whose conveyance to the bundle's destination is\n    \
    \  the purpose for the transmission of a given bundle.  The terms\n      \"bundle\
    \ content\", \"bundle payload\", and \"payload\" are used\n      interchangeably\
    \ in this document.  The \"nominal\" payload for a\n      bundle forwarded in\
    \ response to a bundle transmission request is\n      the application data unit\
    \ whose location is provided as a\n      parameter to that request.  The nominal\
    \ payload for a bundle\n      forwarded in response to reception of that bundle\
    \ is the payload\n      of the received bundle.\n   Fragment -  A fragment is\
    \ a bundle whose payload block contains a\n      fragmentary payload.  A fragmentary\
    \ payload is either the first N\n      bytes or the last N bytes of some other\
    \ payload -- either a\n      nominal payload or a fragmentary payload -- of length\
    \ M, such that\n      0 < N < M.\n   Bundle node -  A bundle node (or, in the\
    \ context of this document,\n      simply a \"node\") is any entity that can send\
    \ and/or receive\n      bundles.  In the most familiar case, a bundle node is\
    \ instantiated\n      as a single process running on a general-purpose computer,\
    \ but in\n      general the definition is meant to be broader: a bundle node might\n\
    \      alternatively be a thread, an object in an object-oriented\n      operating\
    \ system, a special-purpose hardware device, etc.  Each\n      bundle node has\
    \ three conceptual components, defined below: a\n      \"bundle protocol agent\"\
    , a set of zero or more \"convergence layer\n      adapters\", and an \"application\
    \ agent\".\n   Bundle protocol agent -  The bundle protocol agent (BPA) of a node\
    \ is\n      the node component that offers the BP services and executes the\n\
    \      procedures of the bundle protocol.  The manner in which it does so\n  \
    \    is wholly an implementation matter.  For example, BPA\n      functionality\
    \ might be coded into each node individually; it might\n      be implemented as\
    \ a shared library that is used in common by any\n      number of bundle nodes\
    \ on a single computer; it might be\n      implemented as a daemon whose services\
    \ are invoked via inter-\n      process or network communication by any number\
    \ of bundle nodes on\n      one or more computers; it might be implemented in\
    \ hardware.\n   Convergence layer adapters -  A convergence layer adapter (CLA)\
    \ sends\n      and receives bundles on behalf of the BPA, utilizing the services\n\
    \      of some 'native' internet protocol that is supported in one of the\n  \
    \    internets within which the node is functionally located.  The\n      manner\
    \ in which a CLA sends and receives bundles is wholly an\n      implementation\
    \ matter, exactly as described for the BPA.\n   Application agent -  The application\
    \ agent (AA) of a node is the node\n      component that utilizes the BP services\
    \ to effect communication\n      for some purpose.  The application agent in turn\
    \ has two elements,\n      an administrative element and an application-specific\
    \ element.\n      The application-specific element of an AA constructs, requests\n\
    \      transmission of, accepts delivery of, and processes application-\n    \
    \  specific application data units; the only interface between the\n      BPA\
    \ and the application-specific element of the AA is the BP\n      service interface.\
    \  The administrative element of an AA constructs\n      and requests transmission\
    \ of administrative records (status\n      reports and custody signals), and it\
    \ accepts delivery of and\n      processes any custody signals that the node receives.\
    \  In addition\n      to the BP service interface, there is a (conceptual) private\n\
    \      control interface between the BPA and the administrative element\n    \
    \  of the AA that enables each to direct the other to take action\n      under\
    \ specific circumstances.  In the case of a node that serves\n      simply as\
    \ a \"router\" in the overlay network, the AA may have no\n      application-specific\
    \ element at all.  The application-specific\n      elements of other nodes' AAs\
    \ may perform arbitrarily complex\n      application functions, perhaps even offering\
    \ multiplexed DTN\n      communication services to a number of other applications.\
    \  As with\n      the BPA, the manner in which the AA performs its functions is\n\
    \      wholly an implementation matter; in particular, the administrative\n  \
    \    element of an AA might be built into the library or daemon or\n      hardware\
    \ that implements the BPA, and the application-specific\n      element of an AA\
    \ might be implemented either in software or in\n      hardware.\n   Bundle endpoint\
    \ -  A bundle endpoint (or simply \"endpoint\") is a set\n      of zero or more\
    \ bundle nodes that all identify themselves for BP\n      purposes by some single\
    \ text string, called a \"bundle endpoint ID\"\n      (or, in this document, simply\
    \ \"endpoint ID\"; endpoint IDs are\n      described in detail in Section 4.4\
    \ below).  The special case of an\n      endpoint that never contains more than\
    \ one node is termed a\n      \"singleton\" endpoint; every bundle node must be\
    \ a member of at\n      least one singleton endpoint.  Singletons are the most\
    \ familiar\n      sort of endpoint, but in general the endpoint notion is meant\
    \ to\n      be broader.  For example, the nodes in a sensor network might\n  \
    \    constitute a set of bundle nodes that identify themselves by a\n      single\
    \ common endpoint ID and thus form a single bundle endpoint.\n      *Note* too\
    \ that a given bundle node might identify itself by\n      multiple endpoint IDs\
    \ and thus be a member of multiple bundle\n      endpoints.\n   Forwarding - \
    \ When the bundle protocol agent of a node determines\n      that a bundle must\
    \ be \"forwarded\" to an endpoint, it causes the\n      bundle to be sent to all\
    \ of the nodes that the bundle protocol\n      agent currently believes are in\
    \ the \"minimum reception group\" of\n      that endpoint.  The minimum reception\
    \ group of an endpoint may be\n      any one of the following: (a) ALL of the\
    \ nodes registered in an\n      endpoint that is permitted to contain multiple\
    \ nodes (in which\n      case forwarding to the endpoint is functionally similar\
    \ to\n      \"multicast\" operations in the Internet, though possibly very\n \
    \     different in implementation); (b) ANY N of the nodes registered in\n   \
    \   an endpoint that is permitted to contain multiple nodes, where N\n      is\
    \ in the range from zero to the cardinality of the endpoint (in\n      which case\
    \ forwarding to the endpoint is functionally similar to\n      \"anycast\" operations\
    \ in the Internet); or (c) THE SOLE NODE\n      registered in a singleton endpoint\
    \ (in which case forwarding to\n      the endpoint is functionally similar to\
    \ \"unicast\" operations in\n      the Internet).  The nature of the minimum reception\
    \ group for a\n      given endpoint can be determined from the endpoint's ID (again,\n\
    \      see Section 4.4 below): for some endpoint ID \"schemes\", the nature\n\
    \      of the minimum reception group is fixed - in a manner that is\n      defined\
    \ by the scheme - for all endpoints identified under the\n      scheme; for other\
    \ schemes, the nature of the minimum reception\n      group is indicated by some\
    \ lexical feature of the \"scheme-specific\n      part\" of the endpoint ID, in\
    \ a manner that is defined by the\n      scheme.\n   Registration -  A registration\
    \ is the state machine characterizing a\n      given node's membership in a given\
    \ endpoint.  Any number of\n      registrations may be concurrently associated\
    \ with a given\n      endpoint, and any number of registrations may be concurrently\n\
    \      associated with a given node.  Any single registration must at any\n  \
    \    time be in one of two states: Active or Passive.  A registration\n      always\
    \ has an associated \"delivery failure action\", the action\n      that is to\
    \ be taken when a bundle that is \"deliverable\" (see\n      below) subject to\
    \ that registration is received at a time when the\n      registration is in the\
    \ Passive state.  Delivery failure action\n      must be one of the following:\n\
    \      *  defer \"delivery\" (see below) of the bundle subject to this\n     \
    \    registration until (a) this bundle is the least recently\n         received\
    \ of all bundles currently deliverable subject to this\n         registration\
    \ and (b) either the registration is polled or else\n         the registration\
    \ is in the Active state; or\n      *  \"abandon\" (see below) delivery of the\
    \ bundle subject to this\n         registration.\n      An additional implementation-specific\
    \ delivery deferral procedure\n      may optionally be associated with the registration.\
    \  While the\n      state of a registration is Active, reception of a bundle that\
    \ is\n      deliverable subject to this registration must cause the bundle to\n\
    \      be delivered automatically as soon as it is the least recently\n      received\
    \ bundle that is currently deliverable subject to the\n      registration.  While\
    \ the state of a registration is Passive,\n      reception of a bundle that is\
    \ deliverable subject to this\n      registration must cause delivery of the bundle\
    \ to be abandoned or\n      deferred as mandated by the registration's current\
    \ delivery\n      failure action; in the latter case, any additional delivery\n\
    \      deferral procedure associated with the registration must also be\n    \
    \  performed.\n   Delivery -  Upon reception, the processing of a bundle that\
    \ has been\n      sent to a given node depends on whether or not the receiving\
    \ node\n      is registered in the bundle's destination endpoint.  If it is, and\n\
    \      if the payload of the bundle is non-fragmentary (possibly as a\n      result\
    \ of successful payload reassembly from fragmentary payloads,\n      including\
    \ the original payload of the received bundle), then the\n      bundle is normally\
    \ \"delivered\" to the node's application agent\n      subject to the registration\
    \ characterizing the node's membership\n      in the destination endpoint.  A\
    \ bundle is considered to have been\n      delivered at a node subject to a registration\
    \ as soon as the\n      application data unit that is the payload of the bundle,\
    \ together\n      with the value of the bundle's \"Acknowledgement by application\
    \ is\n      requested\" flag and any other relevant metadata (an implementation\n\
    \      matter), has been presented to the node's application agent in a\n    \
    \  manner consistent with the state of that registration and, as\n      applicable,\
    \ the registration's delivery failure action.\n   Deliverability, Abandonment\
    \ -  A bundle is considered \"deliverable\"\n      subject to a registration if\
    \ and only if (a) the bundle's\n      destination endpoint is the endpoint with\
    \ which the registration\n      is associated, (b) the bundle has not yet been\
    \ delivered subject\n      to this registration, and (c) delivery of the bundle\
    \ subject to\n      this registration has not been abandoned.  To \"abandon\"\
    \ delivery\n      of a bundle subject to a registration is simply to declare it\
    \ no\n      longer deliverable subject to that registration; normally only\n \
    \     registrations' registered delivery failure actions cause\n      deliveries\
    \ to be abandoned.\n   Deletion, Discarding -  A bundle protocol agent \"discards\"\
    \ a bundle\n      by simply ceasing all operations on the bundle and functionally\n\
    \      erasing all references to it; the specific procedures by which\n      this\
    \ is accomplished are an implementation matter.  Bundles are\n      discarded\
    \ silently; i.e., the discarding of a bundle does not\n      result in generation\
    \ of an administrative record.  \"Retention\n      constraints\" are elements\
    \ of the bundle state that prevent a\n      bundle from being discarded; a bundle\
    \ cannot be discarded while it\n      has any retention constraints.  A bundle\
    \ protocol agent \"deletes\"\n      a bundle in response to some anomalous condition\
    \ by notifying the\n      bundle's report-to endpoint of the deletion (provided\
    \ such\n      notification is warranted; see Section 5.13 for details) and then\n\
    \      arbitrarily removing all of the bundle's retention constraints,\n     \
    \ enabling the bundle to be discarded.\n   Transmission -  A transmission is a\
    \ sustained effort by a node's\n      bundle protocol agent to cause a bundle\
    \ to be sent to all nodes in\n      the minimum reception group of some endpoint\
    \ (which may be the\n      bundle's destination or may be some intermediate forwarding\n\
    \      endpoint) in response to a transmission request issued by the\n      node's\
    \ application agent.  Any number of transmissions may be\n      concurrently undertaken\
    \ by the bundle protocol agent of a given\n      node.\n   Custody -  To \"accept\
    \ custody\" upon forwarding a bundle is to commit\n      to retaining a copy of\
    \ the bundle -- possibly re-forwarding the\n      bundle when necessary -- until\
    \ custody of that bundle is\n      \"released\".  Custody of a bundle whose destination\
    \ is a singleton\n      endpoint is released when either (a) notification is received\
    \ that\n      some other node has accepted custody of the same bundle; (b)\n \
    \     notification is received that the bundle has been delivered at the\n   \
    \   (sole) node registered in the bundle's destination endpoint; or\n      (c)\
    \ the bundle is explicitly deleted for some reason, such as\n      lifetime expiration.\
    \  The condition(s) under which custody of a\n      bundle whose destination is\
    \ not a singleton endpoint may be\n      released are not defined in this specification.\
    \  To \"refuse\n      custody\" of a bundle is to decide not to accept custody\
    \ of the\n      bundle.  A \"custodial node\" of a bundle is a node that has\n\
    \      accepted custody of the bundle and has not yet released that\n      custody.\
    \  A \"custodian\" of a bundle is a singleton endpoint whose\n      sole member\
    \ is one of the bundle's custodial nodes.\n"
- title: 3.2.  Implementation Architectures
  contents:
  - "3.2.  Implementation Architectures\n   The above definitions are intended to\
    \ enable the bundle protocol's\n   operations to be specified in a manner that\
    \ minimizes bias toward any\n   particular implementation architecture.  To illustrate\
    \ the range of\n   interoperable implementation models that might conform to this\n\
    \   specification, four example architectures are briefly described\n   below.\n\
    \   1.  Bundle protocol application server\n       A single bundle protocol application\
    \ server, constituting a\n       single bundle node, runs as a daemon process\
    \ on each computer.\n       The daemon's functionality includes all functions\
    \ of the bundle\n       protocol agent, all convergence layer adapters, and both\
    \ the\n       administrative and application-specific elements of the\n      \
    \ application agent.  The application-specific element of the\n       application\
    \ agent functions as a server, offering bundle protocol\n       service over a\
    \ local area network: it responds to remote\n       procedure calls from application\
    \ processes (on the same computer\n       and/or remote computers) that need to\
    \ communicate via the bundle\n       protocol.  The server supports its clients\
    \ by creating a new\n       (conceptual) node for each one and registering each\
    \ such node in\n       a client-specified endpoint.  The conceptual nodes managed\
    \ by the\n       server function as clients' bundle protocol service access\n\
    \       points.\n   2.  Peer application nodes\n       Any number of bundle protocol\
    \ application processes, each one\n       constituting a single bundle node, run\
    \ in ad-hoc fashion on each\n       computer.  The functionality of the bundle\
    \ protocol agent, all\n       convergence layer adapters, and the administrative\
    \ element of the\n       application agent is provided by a library to which each\
    \ node\n       process is dynamically linked at run time.  The application-\n\
    \       specific element of each node's application agent is node-\n       specific\
    \ application code.\n   3.  Sensor network nodes\n       Each node of the sensor\
    \ network is the self-contained\n       implementation of a single bundle node.\
    \  All functions of the\n       bundle protocol agent, all convergence layer adapters,\
    \ and the\n       administrative element of the application agent are implemented\n\
    \       in simplified form in Application-Specific Integrated Circuits\n     \
    \  (ASICs), while the application-specific element of each node's\n       application\
    \ agent is implemented in a programmable\n       microcontroller.  Forwarding\
    \ is rudimentary: all bundles are\n       forwarded on a hard-coded default route.\n\
    \   4.  Dedicated bundle router\n       Each computer constitutes a single bundle\
    \ node that functions\n       solely as a high-performance bundle forwarder. \
    \ Many standard\n       functions of the bundle protocol agent, the convergence\
    \ layer\n       adapters, and the administrative element of the application agent\n\
    \       are implemented in ASICs, but some functions are implemented in a\n  \
    \     high-speed processor to enable reprogramming as necessary.  The\n      \
    \ node's application agent has no application-specific element.\n       Substantial\
    \ non-volatile storage resources are provided, and\n       arbitrarily complex\
    \ forwarding algorithms are supported.\n"
- title: 3.3.  Services Offered by Bundle Protocol Agents
  contents:
  - "3.3.  Services Offered by Bundle Protocol Agents\n   The bundle protocol agent\
    \ of each node is expected to provide the\n   following services to the node's\
    \ application agent:\n   o  commencing a registration (registering a node in an\
    \ endpoint);\n   o  terminating a registration;\n   o  switching a registration\
    \ between Active and Passive states;\n   o  transmitting a bundle to an identified\
    \ bundle endpoint;\n   o  canceling a transmission;\n   o  polling a registration\
    \ that is in the passive state;\n   o  delivering a received bundle.\n"
- title: 4.  Bundle Format
  contents:
  - "4.  Bundle Format\n   Each bundle shall be a concatenated sequence of at least\
    \ two block\n   structures.  The first block in the sequence must be a primary\
    \ bundle\n   block, and no bundle may have more than one primary bundle block.\n\
    \   Additional bundle protocol blocks of other types may follow the\n   primary\
    \ block to support extensions to the bundle protocol, such as\n   the Bundle Security\
    \ Protocol [BSP].  At most one of the blocks in the\n   sequence may be a payload\
    \ block.  The last block in the sequence must\n   have the \"last block\" flag\
    \ (in its block processing control flags)\n   set to 1; for every other block\
    \ in the bundle after the primary\n   block, this flag must be set to zero.\n"
- title: 4.1.  Self-Delimiting Numeric Values (SDNVs)
  contents:
  - "4.1.  Self-Delimiting Numeric Values (SDNVs)\n   The design of the bundle protocol\
    \ attempts to reconcile minimal\n   consumption of transmission bandwidth with:\n\
    \   o  extensibility to address requirements not yet identified, and\n   o  scalability\
    \ across a wide range of network scales and payload\n      sizes.\n   A key strategic\
    \ element in the design is the use of self-delimiting\n   numeric values (SDNVs).\
    \  The SDNV encoding scheme is closely adapted\n   from the Abstract Syntax Notation\
    \ One Basic Encoding Rules for\n   subidentifiers within an object identifier\
    \ value [ASN1].  An SDNV is\n   a numeric value encoded in N octets, the last\
    \ of which has its most\n   significant bit (MSB) set to zero; the MSB of every\
    \ other octet in\n   the SDNV must be set to 1.  The value encoded in an SDNV\
    \ is the\n   unsigned binary number obtained by concatenating into a single bit\n\
    \   string the 7 least significant bits of each octet of the SDNV.\n   The following\
    \ examples illustrate the encoding scheme for various\n   hexadecimal values.\n\
    \   0xABC  : 1010 1011 1100\n            is encoded as\n            {1 00 10101}\
    \ {0 0111100}\n            = 10010101 00111100\n   0x1234 : 0001 0010 0011 0100\n\
    \          =    1 0010 0011 0100\n            is encoded as\n            {1 0\
    \ 100100} {0 0110100}\n            = 10100100 00110100\n   0x4234 : 0100 0010\
    \ 0011 0100\n          =  100 0010 0011 0100\n            is encoded as\n    \
    \        {1 000000 1} {1 0000100} {0 0110100}\n            = 10000001 10000100\
    \ 00110100\n   0x7F   : 0111 1111\n          =  111 1111\n            is encoded\
    \ as\n            {0 1111111}\n            = 01111111\n                      \
    \    Figure 2: SDNV Example\n   Note: Care must be taken to make sure that the\
    \ value to be encoded is\n   (in concept) padded with high-order zero bits to\
    \ make its bitwise\n   length a multiple of 7 before encoding.  Also note that,\
    \ while there\n   is no theoretical limit on the size of an SDNV field, the overhead\
    \ of\n   the SDNV scheme is 1:7, i.e., one bit of overhead for every 7 bits of\n\
    \   actual data to be encoded.  Thus, a 7-octet value (a 56-bit quantity\n   with\
    \ no leading zeroes) would be encoded in an 8-octet SDNV; an\n   8-octet value\
    \ (a 64-bit quantity with no leading zeroes) would be\n   encoded in a 10-octet\
    \ SDNV (one octet containing the high-order bit\n   of the value padded with six\
    \ leading zero bits, followed by nine\n   octets containing the remaining 63 bits\
    \ of the value). 148 bits of\n   overhead would be consumed in encoding a 1024-bit\
    \ RSA encryption key\n   directly in an SDNV.  In general, an N-bit quantity with\
    \ no leading\n   zeroes is encoded in an SDNV occupying ceil(N/7) octets, where\
    \ ceil\n   is the integer ceiling function.\n   Implementations of the bundle\
    \ protocol may handle as an invalid\n   numeric value any SDNV that encodes an\
    \ integer that is larger than\n   (2^64 - 1).\n   An SDNV can be used to represent\
    \ both very large and very small\n   integer values.  However, SDNV is clearly\
    \ not the best way to\n   represent every numeric value.  For example, an SDNV\
    \ is a poor way to\n   represent an integer whose value typically falls in the\
    \ range 128 to\n   255.  In general, though, we believe that SDNV representation\
    \ of\n   numeric values in bundle blocks yields the smallest block sizes\n   without\
    \ sacrificing scalability.\n"
- title: 4.2.  Bundle Processing Control Flags
  contents:
  - "4.2.  Bundle Processing Control Flags\n   The bundle processing control flags\
    \ field in the primary bundle block\n   of each bundle is an SDNV; the value encoded\
    \ in this SDNV is a string\n   of bits used to invoke selected bundle processing\
    \ control features.\n   The significance of the value in each currently defined\
    \ position of\n   this bit string is described here.  Note that in the figure\
    \ and\n   descriptions, the bit label numbers denote position (from least\n  \
    \ significant ('0') to most significant) within the decoded bit string,\n   and\
    \ not within the representation of the bits on the wire.  This is\n   why the\
    \ descriptions in this section and the next do not follow\n   standard RFC conventions\
    \ with bit 0 on the left; if fields are added\n   in the future, the SDNV will\
    \ grow to the left, and using this\n   representation allows the references here\
    \ to remain valid.\n            2                   1                   0\n  \
    \          0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0\n           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \           |Status Report|Class of Svc.|   General   |\n           +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \           Figure 3: Bundle Processing Control Flags Bit Layout\n   The bits\
    \ in positions 0 through 6 are flags that characterize the\n   bundle as follows:\n\
    \   0 --   Bundle is a fragment.\n   1 --   Application data unit is an administrative\
    \ record.\n   2 --   Bundle must not be fragmented.\n   3 --   Custody transfer\
    \ is requested.\n   4 --   Destination endpoint is a singleton.\n   5 --   Acknowledgement\
    \ by application is requested.\n   6 --   Reserved for future use.\n   The bits\
    \ in positions 7 through 13 are used to indicate the bundle's\n   class of service.\
    \  The bits in positions 8 and 7 constitute a two-bit\n   priority field indicating\
    \ the bundle's priority, with higher values\n   being of higher priority: 00 =\
    \ bulk, 01 = normal, 10 = expedited, 11\n   is reserved for future use.  Within\
    \ this field, bit 8 is the most\n   significant bit.  The bits in positions 9\
    \ through 13 are reserved for\n   future use.\n   The bits in positions 14 through\
    \ 20 are status report request flags.\n   These flags are used to request status\
    \ reports as follows:\n   14 --   Request reporting of bundle reception.\n   15\
    \ --   Request reporting of custody acceptance.\n   16 --   Request reporting\
    \ of bundle forwarding.\n   17 --   Request reporting of bundle delivery.\n  \
    \ 18 --   Request reporting of bundle deletion.\n   19 --   Reserved for future\
    \ use.\n   20 --   Reserved for future use.\n   If the bundle processing control\
    \ flags indicate that the bundle's\n   application data unit is an administrative\
    \ record, then the custody\n   transfer requested flag must be zero and all status\
    \ report request\n   flags must be zero.  If the custody transfer requested flag\
    \ is 1,\n   then the sending node requests that the receiving node accept custody\n\
    \   of the bundle.  If the bundle's source endpoint ID is \"dtn:none\" (see\n\
    \   below), then the bundle is not uniquely identifiable and all bundle\n   protocol\
    \ features that rely on bundle identity must therefore be\n   disabled: the bundle's\
    \ custody transfer requested flag must be zero,\n   the \"Bundle must not be fragmented\"\
    \ flag must be 1, and all status\n   report request flags must be zero.\n"
- title: 4.3.  Block Processing Control Flags
  contents:
  - "4.3.  Block Processing Control Flags\n   The block processing control flags field\
    \ in every block other than\n   the primary bundle block is an SDNV; the value\
    \ encoded in this SDNV\n   is a string of bits used to invoke selected block processing\
    \ control\n   features.  The significance of the values in all currently defined\n\
    \   positions of this bit string, in order from least significant\n   position\
    \ in the decoded bit string (labeled '0') to most significant\n   (labeled '6'),\
    \ is described here.\n                        0\n            6 5 4 3 2 1 0\n \
    \          +-+-+-+-+-+-+-+\n           |   Flags     |\n           +-+-+-+-+-+-+-+\n\
    \            Figure 4: Block Processing Control Flags Bit Layout\n      0 - Block\
    \ must be replicated in every fragment.\n      1 - Transmit status report if block\
    \ can't be processed.\n      2 - Delete bundle if block can't be processed.\n\
    \      3 - Last block.\n      4 - Discard block if it can't be processed.\n  \
    \    5 - Block was forwarded without being processed.\n      6 - Block contains\
    \ an EID-reference field.\n   For each bundle whose primary block's bundle processing\
    \ control flags\n   (see above) indicate that the bundle's application data unit\
    \ is an\n   administrative record, the \"Transmit status report if block can't\
    \ be\n   processed\" flag in the block processing flags field of every other\n\
    \   block in the bundle must be zero.\n   The 'Block must be replicated in every\
    \ fragment' bit in the block\n   processing flags must be set to zero on all blocks\
    \ that follow the\n   payload block.\n"
- title: 4.4.  Endpoint IDs
  contents:
  - "4.4.  Endpoint IDs\n   The destinations of bundles are bundle endpoints, identified\
    \ by text\n   strings termed \"endpoint IDs\" (see Section 3.1).  Each endpoint\
    \ ID\n   conveyed in any bundle block takes the form of a Uniform Resource\n \
    \  Identifier (URI; [URI]).  As such, each endpoint ID can be\n   characterized\
    \ as having this general structure:\n   < scheme name > : < scheme-specific part,\
    \ or \"SSP\" >\n   As used for the purposes of the bundle protocol, neither the\
    \ length\n   of a scheme name nor the length of an SSP may exceed 1023 bytes.\n\
    \   Bundle blocks cite a number of endpoint IDs for various purposes of\n   the\
    \ bundle protocol.  Many, though not necessarily all, of the\n   endpoint IDs\
    \ referred to in the blocks of a given bundle are conveyed\n   in the \"dictionary\"\
    \ byte array in the bundle's primary block.  This\n   array is simply the concatenation\
    \ of any number of null-terminated\n   scheme names and SSPs.\n   \"Endpoint ID\
    \ references\" are used to cite endpoint IDs that are\n   contained in the dictionary;\
    \ all endpoint ID citations in the primary\n   bundle block are endpoint ID references,\
    \ and other bundle blocks may\n   contain endpoint ID references as well.  Each\
    \ endpoint ID reference\n   is an ordered pair of SDNVs:\n   o  The first SDNV\
    \ contains the offset within the dictionary of the\n      first character of the\
    \ referenced endpoint ID's scheme name.\n   o  The second SDNV contains the offset\
    \ within the dictionary of the\n      first character of the referenced endpoint\
    \ ID's SSP.\n   This encoding enables a degree of block compression: when the\
    \ source\n   and report-to of a bundle are the same endpoint, for example, the\n\
    \   text of that endpoint's ID may be cited twice yet appear only once in\n  \
    \ the dictionary.\n   The scheme identified by the < scheme name > in an endpoint\
    \ ID is a\n   set of syntactic and semantic rules that fully explain how to parse\n\
    \   and interpret the SSP.  The set of allowable schemes is effectively\n   unlimited.\
    \  Any scheme conforming to [URIREG] may be used in a bundle\n   protocol endpoint\
    \ ID.  In addition, a single additional scheme is\n   defined by the present document:\n\
    \   o  The \"dtn\" scheme, which is used at minimum in the representation\n  \
    \    of the null endpoint ID \"dtn:none\".  The forwarding of a bundle to\n  \
    \    the null endpoint is never contraindicated, and the minimum\n      reception\
    \ group for the null endpoint is the empty set.\n   Note that, although the endpoint\
    \ IDs conveyed in bundle blocks are\n   expressed as URIs, implementations of\
    \ the BP service interface may\n   support expression of endpoint IDs in some\
    \ internationalized manner\n   (e.g., Internationalized Resource Identifiers (IRIs);\
    \ see [RFC3987]).\n"
- title: 4.5.  Formats of Bundle Blocks
  contents:
  - "4.5.  Formats of Bundle Blocks\n   This section describes the formats of the\
    \ primary block and payload\n   block.  Rules for processing these blocks appear\
    \ in Section 5 of this\n   document.\n   Note that supplementary DTN protocol\
    \ specifications (including, but\n   not restricted to, the Bundle Security Protocol\
    \ [BSP]) may require\n   that BP implementations conforming to those protocols\
    \ construct and\n   process additional blocks.\n   The format of the two basic\
    \ BP blocks is shown in Figure 5 below.\n   Primary Bundle Block\n   +----------------+----------------+----------------+----------------+\n\
    \   |    Version     |                  Proc. Flags (*)                 |\n  \
    \ +----------------+----------------+----------------+----------------+\n   |\
    \                          Block length (*)                         |\n   +----------------+----------------+---------------------------------+\n\
    \   |   Destination scheme offset (*) |     Destination SSP offset (*)  |\n  \
    \ +----------------+----------------+----------------+----------------+\n   |\
    \      Source scheme offset (*)   |        Source SSP offset (*)    |\n   +----------------+----------------+----------------+----------------+\n\
    \   |    Report-to scheme offset (*)  |      Report-to SSP offset (*)   |\n  \
    \ +----------------+----------------+----------------+----------------+\n   |\
    \    Custodian scheme offset (*)  |      Custodian SSP offset (*)   |\n   +----------------+----------------+----------------+----------------+\n\
    \   |                    Creation Timestamp time (*)                    |\n  \
    \ +---------------------------------+---------------------------------+\n   |\
    \             Creation Timestamp sequence number (*)                |\n   +---------------------------------+---------------------------------+\n\
    \   |                           Lifetime (*)                            |\n  \
    \ +----------------+----------------+----------------+----------------+\n   |\
    \                        Dictionary length (*)                      |\n   +----------------+----------------+----------------+----------------+\n\
    \   |                  Dictionary byte array (variable)                 |\n  \
    \ +----------------+----------------+---------------------------------+\n   |\
    \                      [Fragment offset (*)]                        |\n   +----------------+----------------+---------------------------------+\n\
    \   |              [Total application data unit length (*)]             |\n  \
    \ +----------------+----------------+---------------------------------+\n   Bundle\
    \ Payload Block\n   +----------------+----------------+----------------+----------------+\n\
    \   |  Block type    | Proc. Flags (*)|        Block length(*)          |\n  \
    \ +----------------+----------------+----------------+----------------+\n   /\
    \                     Bundle Payload (variable)                     /\n   +-------------------------------------------------------------------+\n\
    \                      Figure 5: Bundle Block Formats\n   (*) Notes:\n   The bundle\
    \ processing control (\"Proc.\") flags field in the Primary\n   Bundle Block is\
    \ an SDNV and is therefore variable length.  A three-\n   octet SDNV is shown\
    \ here for convenience in representation.\n   The block length field of the Primary\
    \ Bundle Block is an SDNV and is\n   therefore variable length.  A four-octet\
    \ SDNV is shown here for\n   convenience in representation.\n   Each of the eight\
    \ offset fields in the Primary Bundle Block is an\n   SDNV and is therefore variable\
    \ length.  Two-octet SDNVs are shown\n   here for convenience in representation.\n\
    \   The Creation Timestamp time field in the Primary Bundle Block is an\n   SDNV\
    \ and is therefore variable length.  A four-octet SDNV is shown\n   here for convenience\
    \ in representation.\n   The Creation Timestamp sequence number field in the Primary\
    \ Bundle\n   Block is an SDNV and is therefore variable length.  A four-octet\
    \ SDNV\n   is shown here for convenience in representation.\n   The Lifetime field\
    \ in the Primary Bundle Block is an SDNV and is\n   therefore variable length.\
    \  A four-octet SDNV is shown here for\n   convenience in representation.\n  \
    \ The dictionary length field of the Primary Bundle Block is an SDNV\n   and is\
    \ therefore variable length.  A four-octet SDNV is shown here\n   for convenience\
    \ in representation.\n   The fragment offset field of the Primary Bundle Block\
    \ is present only\n   if the Fragment flag in the block's processing flags byte\
    \ is set to\n   1.  It is an SDNV and is therefore variable length; a four-octet\
    \ SDNV\n   is shown here for convenience in representation.\n   The total application\
    \ data unit length field of the Primary Bundle\n   Block is present only if the\
    \ Fragment flag in the block's processing\n   flags byte is set to 1.  It is an\
    \ SDNV and is therefore variable\n   length; a four-octet SDNV is shown here for\
    \ convenience in\n   representation.\n   The block processing control (\"Proc.\"\
    ) flags field of the Payload\n   Block is an SDNV and is therefore variable length.\
    \  A one-octet SDNV\n   is shown here for convenience in representation.\n   The\
    \ block length field of the Payload Block is an SDNV and is\n   therefore variable\
    \ length.  A two-octet SDNV is shown here for\n   convenience in representation.\n"
- title: 4.5.1.  Primary Bundle Block
  contents:
  - "4.5.1.  Primary Bundle Block\n   The primary bundle block contains the basic\
    \ information needed to\n   route bundles to their destinations.  The fields of\
    \ the primary\n   bundle block are:\n   Version:   A 1-byte field indicating the\
    \ version of the bundle\n      protocol that constructed this block.  The present\
    \ document\n      describes version 0x06 of the bundle protocol.\n   Bundle Processing\
    \ Control Flags:   The Bundle Processing Control\n      Flags field is an SDNV\
    \ that contains the bundle processing control\n      flags discussed in Section\
    \ 4.2 above.\n   Block Length:   The Block Length field is an SDNV that contains\
    \ the\n      aggregate length of all remaining fields of the block.\n   Destination\
    \ Scheme Offset:   The Destination Scheme Offset field\n      contains the offset\
    \ within the dictionary byte array of the scheme\n      name of the endpoint ID\
    \ of the bundle's destination, i.e., the\n      endpoint containing the node(s)\
    \ at which the bundle is to be\n      delivered.\n   Destination SSP Offset: \
    \  The Destination SSP Offset field contains\n      the offset within the dictionary\
    \ byte array of the scheme-specific\n      part of the endpoint ID of the bundle's\
    \ destination.\n   Source Scheme Offset:   The Source Scheme Offset field contains\
    \ the\n      offset within the dictionary byte array of the scheme name of the\n\
    \      endpoint ID of the bundle's nominal source, i.e., the endpoint\n      nominally\
    \ containing the node from which the bundle was initially\n      transmitted.\n\
    \   Source SSP Offset:   The Source SSP Offset field contains the offset\n   \
    \   within the dictionary byte array of the scheme-specific part of\n      the\
    \ endpoint ID of the bundle's nominal source.\n   Report-to Scheme Offset:   The\
    \ Report-to Scheme Offset field contains\n      the offset within the dictionary\
    \ byte array of the scheme name of\n      the ID of the endpoint to which status\
    \ reports pertaining to the\n      forwarding and delivery of this bundle are\
    \ to be transmitted.\n   Report-to SSP Offset:   The Report-to SSP Offset field\
    \ contains the\n      offset within the dictionary byte array of the scheme-specific\n\
    \      part of the ID of the endpoint to which status reports pertaining\n   \
    \   to the forwarding and delivery of this bundle are to be\n      transmitted.\n\
    \   Custodian Scheme Offset:   The \"current custodian endpoint ID\" of a\n  \
    \    primary bundle block identifies an endpoint whose membership\n      includes\
    \ the node that most recently accepted custody of the\n      bundle upon forwarding\
    \ this bundle.  The Custodian Scheme Offset\n      field contains the offset within\
    \ the dictionary byte array of the\n      scheme name of the current custodian\
    \ endpoint ID.\n   Custodian SSP Offset:   The Custodian SSP Offset field contains\
    \ the\n      offset within the dictionary byte array of the scheme-specific\n\
    \      part of the current custodian endpoint ID.\n   Creation Timestamp:   The\
    \ creation timestamp is a pair of SDNVs that,\n      together with the source\
    \ endpoint ID and (if the bundle is a\n      fragment) the fragment offset and\
    \ payload length, serve to\n      identify the bundle.  The first SDNV of the\
    \ timestamp is the\n      bundle's creation time, while the second is the bundle's\
    \ creation\n      timestamp sequence number.  Bundle creation time is the time\
    \ --\n      expressed in seconds since the start of the year 2000, on the\n  \
    \    Coordinated Universal Time (UTC) scale [UTC] -- at which the\n      transmission\
    \ request was received that resulted in the creation of\n      the bundle.  Sequence\
    \ count is the latest value (as of the time at\n      which that transmission\
    \ request was received) of a monotonically\n      increasing positive integer\
    \ counter managed by the source node's\n      bundle protocol agent that may be\
    \ reset to zero whenever the\n      current time advances by one second.  A source\
    \ Bundle Protocol\n      Agent must never create two distinct bundles with the\
    \ same source\n      endpoint ID and bundle creation timestamp.  The combination\
    \ of\n      source endpoint ID and bundle creation timestamp therefore serves\n\
    \      to identify a single transmission request, enabling it to be\n      acknowledged\
    \ by the receiving application (provided the source\n      endpoint ID is not\
    \ \"dtn:none\").\n   Lifetime:   The lifetime field is an SDNV that indicates\
    \ the time at\n      which the bundle's payload will no longer be useful, encoded\
    \ as a\n      number of seconds past the creation time.  When the current time\n\
    \      is greater than the creation time plus the lifetime, bundle nodes\n   \
    \   need no longer retain or forward the bundle; the bundle may be\n      deleted\
    \ from the network.\n   Dictionary Length:   The Dictionary Length field is an\
    \ SDNV that\n      contains the length of the dictionary byte array.\n   Dictionary:\
    \   The Dictionary field is an array of bytes formed by\n      concatenating the\
    \ null-terminated scheme names and SSPs of all\n      endpoint IDs referenced\
    \ by any fields in this Primary Block\n      together with, potentially, other\
    \ endpoint IDs referenced by\n      fields in other TBD DTN protocol blocks. \
    \ Its length is given by\n      the value of the Dictionary Length field.\n  \
    \ Fragment Offset:   If the Bundle Processing Control Flags of this\n      Primary\
    \ block indicate that the bundle is a fragment, then the\n      Fragment Offset\
    \ field is an SDNV indicating the offset from the\n      start of the original\
    \ application data unit at which the bytes\n      comprising the payload of this\
    \ bundle were located.  If not, then\n      the Fragment Offset field is omitted\
    \ from the block.\n   Total Application Data Unit Length:   If the Bundle Processing\n\
    \      Control Flags of this Primary block indicate that the bundle is a\n   \
    \   fragment, then the Total Application Data Unit Length field is an\n      SDNV\
    \ indicating the total length of the original application data\n      unit of\
    \ which this bundle's payload is a part.  If not, then the\n      Total Application\
    \ Data Unit Length field is omitted from the\n      block.\n"
- title: 4.5.2.  Canonical Bundle Block Format
  contents:
  - "4.5.2.  Canonical Bundle Block Format\n   Every bundle block of every type other\
    \ than the primary bundle block\n   comprises the following fields, in this order:\n\
    \   o  Block type code, expressed as an 8-bit unsigned binary integer.\n     \
    \ Bundle block type code 1 indicates that the block is a bundle\n      payload\
    \ block.  Block type codes 192 through 255 are not defined\n      in this specification\
    \ and are available for private and/or\n      experimental use.  All other values\
    \ of the block type code are\n      reserved for future use.\n   o  Block processing\
    \ control flags, an unsigned integer expressed as\n      an SDNV.  The individual\
    \ bits of this integer are used to invoke\n      selected block processing control\
    \ features.\n   o  Block EID reference count and EID references (optional).  If\
    \ and\n      only if the block references EID elements in the primary block's\n\
    \      dictionary, the 'block contains an EID-reference field' flag in\n     \
    \ the block processing control flags is set to 1 and the block\n      includes\
    \ an EID reference field consisting of a count of EID\n      references expressed\
    \ as an SDNV followed by the EID references\n      themselves.  Each EID reference\
    \ is a pair of SDNVs.  The first\n      SDNV of each EID reference contains the\
    \ offset of a scheme name in\n      the primary block's dictionary, and the second\
    \ SDNV of each\n      reference contains the offset of a scheme-specific part\
    \ in the\n      dictionary.\n   o  Block data length, an unsigned integer expressed\
    \ as an SDNV.  The\n      Block data length field contains the aggregate length\
    \ of all\n      remaining fields of the block, i.e., the block-type-specific data\n\
    \      fields.\n   o  Block-type-specific data fields, whose format and order\
    \ are type-\n      specific and whose aggregate length in octets is the value\
    \ of the\n      block data length field.  All multi-byte block-type-specific data\n\
    \      fields are represented in network byte order.\n          +-----------+-----------+-----------+-----------+\n\
    \          |Block type | Block processing ctrl flags (SDNV)|\n          +-----------+-----------+-----------+-----------+\n\
    \          |            Block length  (SDNV)               |\n          +-----------+-----------+-----------+-----------+\n\
    \          /          Block body data (variable)           /\n          +-----------+-----------+-----------+-----------+\n\
    \             Figure 6: Block Layout without EID Reference List\n          +-----------+-----------+-----------+-----------+\n\
    \          |Block Type | Block processing ctrl flags (SDNV)|\n          +-----------+-----------+-----------+-----------+\n\
    \          |        EID Reference Count  (SDNV)            |\n          +-----------+-----------+-----------+-----------+\n\
    \          |  Ref_scheme_1 (SDNV)  |    Ref_ssp_1 (SDNV)   |\n          +-----------+-----------+-----------+-----------+\n\
    \          |  Ref_scheme_2 (SDNV)  |    Ref_ssp_2 (SDNV)   |\n          +-----------+-----------+-----------+-----------+\n\
    \          |            Block length  (SDNV)               |\n          +-----------+-----------+-----------+-----------+\n\
    \          /          Block body data (variable)           /\n          +-----------+-----------+-----------+-----------+\n\
    \             Figure 7: Block Layout Showing Two EID References\n"
- title: 4.5.3.  Bundle Payload Block
  contents:
  - "4.5.3.  Bundle Payload Block\n   The fields of the bundle payload block are:\n\
    \   Block Type:   The Block Type field is a 1-byte field that indicates\n    \
    \  the type of the block.  For the bundle payload block, this field\n      contains\
    \ the value 1.\n   Block Processing Control Flags:   The Block Processing Control\
    \ Flags\n      field is an SDNV that contains the block processing control flags\n\
    \      discussed in Section 4.3 above.\n   Block Length:   The Block Length field\
    \ is an SDNV that contains the\n      aggregate length of all remaining fields\
    \ of the block - which is\n      to say, the length of the bundle's payload.\n\
    \   Payload:   The Payload field contains the application data carried by\n  \
    \    this bundle.\n   That is, bundle payload blocks follow the canonical format\
    \ of the\n   previous section with the restriction that the 'block contains an\n\
    \   EID-reference field' bit of the block processing control flags is\n   never\
    \ set.  The block body data for payload blocks is the application\n   data carried\
    \ by the bundle.\n"
- title: 4.6.  Extension Blocks
  contents:
  - "4.6.  Extension Blocks\n   \"Extension blocks\" are all blocks other than the\
    \ primary and payload\n   blocks.  Because extension blocks are not defined in\
    \ the Bundle\n   Protocol specification (the present document), not all nodes\n\
    \   conforming to this specification will necessarily instantiate Bundle\n   Protocol\
    \ implementations that include procedures for processing (that\n   is, recognizing,\
    \ parsing, acting on, and/or producing) all extension\n   blocks.  It is therefore\
    \ possible for a node to receive a bundle that\n   includes extension blocks that\
    \ the node cannot process.\n   Whenever a bundle is forwarded that contains one\
    \ or more extension\n   blocks that could not be processed, the \"Block was forwarded\
    \ without\n   being processed\" flag must be set to 1 within the block processing\n\
    \   flags of each such block.  For each block flagged in this way, the\n   flag\
    \ may optionally be cleared (i.e., set to zero) by another node\n   that subsequently\
    \ receives the bundle and is able to process that\n   block; the specifications\
    \ defining the various extension blocks are\n   expected to define the circumstances\
    \ under which this flag may be\n   cleared, if any.\n"
- title: 4.7.  Dictionary Revision
  contents:
  - "4.7.  Dictionary Revision\n   Any strings (scheme names and SSPs) in a bundle's\
    \ dictionary that are\n   referenced neither from the bundle's primary block nor\
    \ from the block\n   EID reference field of any extension block may be removed\
    \ from the\n   dictionary at the time the bundle is forwarded.\n   Whenever removal\
    \ of a string from the dictionary causes the offsets\n   (within the dictionary\
    \ byte array) of any other strings to change,\n   all endpoint ID references that\
    \ refer to those strings must be\n   adjusted at the same time.  Note that these\
    \ references may be in the\n   primary block and/or in the block EID reference\
    \ fields of extension\n   blocks.\n"
- title: 5.  Bundle Processing
  contents:
  - "5.  Bundle Processing\n   The bundle processing procedures mandated in this section\
    \ and in\n   Section 6 govern the operation of the Bundle Protocol Agent and the\n\
    \   Application Agent administrative element of each bundle node.  They\n   are\
    \ neither exhaustive nor exclusive.  That is, supplementary DTN\n   protocol specifications\
    \ (including, but not restricted to, the Bundle\n   Security Protocol [BSP]) may\
    \ require that additional measures be\n   taken at specified junctures in these\
    \ procedures.  Such additional\n   measures shall not override or supersede the\
    \ mandated bundle protocol\n   procedures, except that they may in some cases\
    \ make these procedures\n   moot by requiring, for example, that implementations\
    \ conforming to\n   the supplementary protocol terminate the processing of a given\n\
    \   incoming or outgoing bundle due to a fault condition recognized by\n   that\
    \ protocol.\n"
- title: 5.1.  Generation of Administrative Records
  contents:
  - "5.1.  Generation of Administrative Records\n   All initial transmission of bundles\
    \ is in response to bundle\n   transmission requests presented by nodes' application\
    \ agents.  When\n   required to \"generate\" an administrative record (a bundle\
    \ status\n   report or a custody signal), the bundle protocol agent itself is\n\
    \   responsible for causing a new bundle to be transmitted, conveying\n   that\
    \ record.  In concept, the bundle protocol agent discharges this\n   responsibility\
    \ by directing the administrative element of the node's\n   application agent\
    \ to construct the record and request its\n   transmission as detailed in Section\
    \ 6 below.  In practice, the manner\n   in which administrative record generation\
    \ is accomplished is an\n   implementation matter, provided the constraints noted\
    \ in Section 6\n   are observed.\n   Under some circumstances, the requesting\
    \ of status reports could\n   result in an unacceptable increase in the bundle\
    \ traffic in the\n   network.  For this reason, the generation of status reports\
    \ is\n   mandatory only in one case, the deletion of a bundle for which\n   custody\
    \ transfer is requested.  In all other cases, the decision on\n   whether or not\
    \ to generate a requested status report is left to the\n   discretion of the bundle\
    \ protocol agent.  Mechanisms that could\n   assist in making such decisions,\
    \ such as pre-placed agreements\n   authorizing the generation of status reports\
    \ under specified\n   circumstances, are beyond the scope of this specification.\n\
    \   Notes on administrative record terminology:\n   o  A \"bundle reception status\
    \ report\" is a bundle status report with\n      the \"reporting node received\
    \ bundle\" flag set to 1.\n   o  A \"custody acceptance status report\" is a bundle\
    \ status report\n      with the \"reporting node accepted custody of bundle\"\
    \ flag set to\n      1.\n   o  A \"bundle forwarding status report\" is a bundle\
    \ status report with\n      the \"reporting node forwarded the bundle\" flag set\
    \ to 1.\n   o  A \"bundle delivery status report\" is a bundle status report with\n\
    \      the \"reporting node delivered the bundle\" flag set to 1.\n   o  A \"\
    bundle deletion status report\" is a bundle status report with\n      the \"reporting\
    \ node deleted the bundle\" flag set to 1.\n   o  A \"Succeeded\" custody signal\
    \ is a custody signal with the \"custody\n      transfer succeeded\" flag set\
    \ to 1.\n   o  A \"Failed\" custody signal is a custody signal with the \"custody\n\
    \      transfer succeeded\" flag set to zero.\n   o  The \"current custodian\"\
    \ of a bundle is the endpoint identified by\n      the current custodian endpoint\
    \ ID in the bundle's primary block.\n"
- title: 5.2.  Bundle Transmission
  contents:
  - "5.2.  Bundle Transmission\n   The steps in processing a bundle transmission request\
    \ are:\n   Step 1:   If custody transfer is requested for this bundle\n      transmission\
    \ and, moreover, custody acceptance by the source node\n      is required, then\
    \ either the bundle protocol agent must commit to\n      accepting custody of\
    \ the bundle -- in which case processing\n      proceeds from Step 2 -- or the\
    \ request cannot be honored and all\n      remaining steps of this procedure must\
    \ be skipped.  The bundle\n      protocol agent must not commit to accepting custody\
    \ of a bundle if\n      the conditions under which custody of the bundle may be\
    \ accepted\n      are not satisfied.  The conditions under which a node may accept\n\
    \      custody of a bundle whose destination is not a singleton endpoint\n   \
    \   are not defined in this specification.\n   Step 2:   Transmission of the bundle\
    \ is initiated.  An outbound\n      bundle must be created per the parameters\
    \ of the bundle\n      transmission request, with current custodian endpoint ID\
    \ set to\n      the null endpoint ID \"dtn:none\" and with the retention constraint\n\
    \      \"Dispatch pending\".  The source endpoint ID of the bundle must be\n \
    \     either the ID of an endpoint of which the node is a member or the\n    \
    \  null endpoint ID \"dtn:none\".\n   Step 3:   Processing proceeds from Step\
    \ 1 of Section 5.4.\n"
- title: 5.3.  Bundle Dispatching
  contents:
  - "5.3.  Bundle Dispatching\n   The steps in dispatching a bundle are:\n   Step\
    \ 1:   If the bundle's destination endpoint is an endpoint of\n      which the\
    \ node is a member, the bundle delivery procedure defined\n      in Section 5.7\
    \ must be followed.\n   Step 2:   Processing proceeds from Step 1 of Section 5.4.\n"
- title: 5.4.  Bundle Forwarding
  contents:
  - "5.4.  Bundle Forwarding\n   The steps in forwarding a bundle are:\n   Step 1:\
    \   The retention constraint \"Forward pending\" must be added to\n      the bundle,\
    \ and the bundle's \"Dispatch pending\" retention\n      constraint must be removed.\n\
    \   Step 2:   The bundle protocol agent must determine whether or not\n      forwarding\
    \ is contraindicated for any of the reasons listed in\n      Figure 12.  In particular:\n\
    \      *  The bundle protocol agent must determine which endpoint(s) to\n    \
    \     forward the bundle to.  The bundle protocol agent may choose\n         either\
    \ to forward the bundle directly to its destination\n         endpoint (if possible)\
    \ or to forward the bundle to some other\n         endpoint(s) for further forwarding.\
    \  The manner in which this\n         decision is made may depend on the scheme\
    \ name in the\n         destination endpoint ID but in any case is beyond the\
    \ scope of\n         this document.  If the agent finds it impossible to select\
    \ any\n         endpoint(s) to forward the bundle to, then forwarding is\n   \
    \      contraindicated.\n      *  Provided the bundle protocol agent succeeded\
    \ in selecting the\n         endpoint(s) to forward the bundle to, the bundle\
    \ protocol agent\n         must select the convergence layer adapter(s) whose\
    \ services\n         will enable the node to send the bundle to the nodes of the\n\
    \         minimum reception group of each selected endpoint.  The manner\n   \
    \      in which the appropriate convergence layer adapters are\n         selected\
    \ may depend on the scheme name in the destination\n         endpoint ID but in\
    \ any case is beyond the scope of this\n         document.  If the agent finds\
    \ it impossible to select\n         convergence layer adapters to use in forwarding\
    \ this bundle,\n         then forwarding is contraindicated.\n   Step 3:   If\
    \ forwarding of the bundle is determined to be\n      contraindicated for any\
    \ of the reasons listed in Figure 12, then\n      the Forwarding Contraindicated\
    \ procedure defined in Section 5.4.1\n      must be followed; the remaining steps\
    \ of Section 5 are skipped at\n      this time.\n   Step 4:   If the bundle's\
    \ custody transfer requested flag (in the\n      bundle processing flags field)\
    \ is set to 1, then the custody\n      transfer procedure defined in Section 5.10.2\
    \ must be followed.\n   Step 5:   For each endpoint selected for forwarding, the\
    \ bundle\n      protocol agent must invoke the services of the selected\n    \
    \  convergence layer adapter(s) in order to effect the sending of the\n      bundle\
    \ to the nodes constituting the minimum reception group of\n      that endpoint.\
    \  Determining the time at which the bundle is to be\n      sent by each convergence\
    \ layer adapter is an implementation\n      matter.\n      To keep from possibly\
    \ invalidating bundle security, the sequencing\n      of the blocks in a forwarded\
    \ bundle must not be changed as it\n      transits a node; received blocks must\
    \ be transmitted in the same\n      relative order as that in which they were\
    \ received.  While blocks\n      may be added to bundles as they transit intermediate\
    \ nodes,\n      removal of blocks that do not have their 'Discard block if it\n\
    \      can't be processed' flag in the block processing control flags set\n  \
    \    to 1 may cause security to fail.\n   Step 6:   When all selected convergence\
    \ layer adapters have informed\n      the bundle protocol agent that they have\
    \ concluded their data\n      sending procedures with regard to this bundle:\n\
    \      *  If the \"request reporting of bundle forwarding\" flag in the\n    \
    \     bundle's status report request field is set to 1, then a bundle\n      \
    \   forwarding status report should be generated, destined for the\n         bundle's\
    \ report-to endpoint ID.  If the bundle has the\n         retention constraint\
    \ \"custody accepted\" and all of the nodes in\n         the minimum reception\
    \ group of the endpoint selected for\n         forwarding are known to be unable\
    \ to send bundles back to this\n         node, then the reason code on this bundle\
    \ forwarding status\n         report must be \"forwarded over unidirectional link\"\
    ; otherwise,\n         the reason code must be \"no additional information\".\n\
    \      *  The bundle's \"Forward pending\" retention constraint must be\n    \
    \     removed.\n"
- title: 5.4.1.  Forwarding Contraindicated
  contents:
  - "5.4.1.  Forwarding Contraindicated\n   The steps in responding to contraindication\
    \ of forwarding for some\n   reason are:\n   Step 1:   The bundle protocol agent\
    \ must determine whether or not to\n      declare failure in forwarding the bundle\
    \ for this reason.  Note:\n      this decision is likely to be influenced by the\
    \ reason for which\n      forwarding is contraindicated.\n   Step 2:   If forwarding\
    \ failure is declared, then the Forwarding\n      Failed procedure defined in\
    \ Section 5.4.2 must be followed.\n      Otherwise, (a) if the bundle's custody\
    \ transfer requested flag (in\n      the bundle processing flags field) is set\
    \ to 1, then the custody\n      transfer procedure defined in Section 5.10 must\
    \ be followed; (b)\n      when -- at some future time - the forwarding of this\
    \ bundle ceases\n      to be contraindicated, processing proceeds from Step 5\
    \ of\n      Section 5.4.\n"
- title: 5.4.2.  Forwarding Failed
  contents:
  - "5.4.2.  Forwarding Failed\n   The steps in responding to a declaration of forwarding\
    \ failure for\n   some reason are:\n   Step 1:   If the bundle's custody transfer\
    \ requested flag (in the\n      bundle processing flags field) is set to 1, custody\
    \ transfer\n      failure must be handled.  Procedures for handling failure of\n\
    \      custody transfer for a bundle whose destination is not a singleton\n  \
    \    endpoint are not defined in this specification.  For a bundle\n      whose\
    \ destination is a singleton endpoint, the bundle protocol\n      agent must handle\
    \ the custody transfer failure by generating a\n      \"Failed\" custody signal\
    \ for the bundle, destined for the bundle's\n      current custodian; the custody\
    \ signal must contain a reason code\n      corresponding to the reason for which\
    \ forwarding was determined to\n      be contraindicated.  (Note that discarding\
    \ the bundle will not\n      delete it from the network, since the current custodian\
    \ still has\n      a copy.)\n   Step 2:   If the bundle's destination endpoint\
    \ is an endpoint of\n      which the node is a member, then the bundle's \"Forward\
    \ pending\"\n      retention constraint must be removed.  Otherwise, the bundle\
    \ must\n      be deleted: the bundle deletion procedure defined in Section 5.13\n\
    \      must be followed, citing the reason for which forwarding was\n      determined\
    \ to be contraindicated.\n"
- title: 5.5.  Bundle Expiration
  contents:
  - "5.5.  Bundle Expiration\n   A bundle expires when the current time is greater\
    \ than the bundle's\n   creation time plus its lifetime as specified in the primary\
    \ bundle\n   block.  Bundle expiration may occur at any point in the processing\
    \ of\n   a bundle.  When a bundle expires, the bundle protocol agent must\n  \
    \ delete the bundle for the reason \"lifetime expired\": the bundle\n   deletion\
    \ procedure defined in Section 5.13 must be followed.\n"
- title: 5.6.  Bundle Reception
  contents:
  - "5.6.  Bundle Reception\n   The steps in processing a bundle received from another\
    \ node are:\n   Step 1:   The retention constraint \"Dispatch pending\" must be\
    \ added\n      to the bundle.\n   Step 2:   If the \"request reporting of bundle\
    \ reception\" flag in the\n      bundle's status report request field is set to\
    \ 1, then a bundle\n      reception status report with reason code \"No additional\n\
    \      information\" should be generated, destined for the bundle's\n      report-to\
    \ endpoint ID.\n   Step 3:   For each block in the bundle that is an extension\
    \ block\n      that the bundle protocol agent cannot process:\n      *  If the\
    \ block processing flags in that block indicate that a\n         status report\
    \ is requested in this event, then a bundle\n         reception status report\
    \ with reason code \"Block unintelligible\"\n         should be generated, destined\
    \ for the bundle's report-to\n         endpoint ID.\n      *  If the block processing\
    \ flags in that block indicate that the\n         bundle must be deleted in this\
    \ event, then the bundle protocol\n         agent must delete the bundle for the\
    \ reason \"Block\n         unintelligible\"; the bundle deletion procedure defined\
    \ in\n         Section 5.13 must be followed and all remaining steps of the\n\
    \         bundle reception procedure must be skipped.\n      *  If the block processing\
    \ flags in that block do NOT indicate\n         that the bundle must be deleted\
    \ in this event but do indicate\n         that the block must be discarded, then\
    \ the bundle protocol\n         agent must remove this block from the bundle.\n\
    \      *  If the block processing flags in that block indicate NEITHER\n     \
    \    that the bundle must be deleted NOR that the block must be\n         discarded,\
    \ then the bundle protocol agent must set to 1 the\n         \"Block was forwarded\
    \ without being processed\" flag in the block\n         processing flags of the\
    \ block.\n   Step 4:   If the bundle's custody transfer requested flag (in the\n\
    \      bundle processing flags field) is set to 1 and the bundle has the\n   \
    \   same source endpoint ID, creation timestamp, and (if the bundle is\n     \
    \ a fragment) fragment offset and payload length as another bundle\n      that\
    \ (a) has not been discarded and (b) currently has the\n      retention constraint\
    \ \"Custody accepted\", custody transfer\n      redundancy must be handled.  Otherwise,\
    \ processing proceeds from\n      Step 5.  Procedures for handling redundancy\
    \ in custody transfer\n      for a bundle whose destination is not a singleton\
    \ endpoint are not\n      defined in this specification.  For a bundle whose destination\
    \ is\n      a singleton endpoint, the bundle protocol agent must handle\n    \
    \  custody transfer redundancy by generating a \"Failed\" custody\n      signal\
    \ for this bundle with reason code \"Redundant reception\",\n      destined for\
    \ this bundle's current custodian, and removing this\n      bundle's \"Dispatch\
    \ pending\" retention constraint.\n   Step 5:   Processing proceeds from Step\
    \ 1 of Section 5.3.\n"
- title: 5.7.  Local Bundle Delivery
  contents:
  - "5.7.  Local Bundle Delivery\n   The steps in processing a bundle that is destined\
    \ for an endpoint of\n   which this node is a member are:\n   Step 1:   If the\
    \ received bundle is a fragment, the application data\n      unit reassembly procedure\
    \ described in Section 5.9 must be\n      followed.  If this procedure results\
    \ in reassembly of the entire\n      original application data unit, processing\
    \ of this bundle (whose\n      fragmentary payload has been replaced by the reassembled\n\
    \      application data unit) proceeds from Step 2; otherwise, the\n      retention\
    \ constraint \"Reassembly pending\" must be added to the\n      bundle and all\
    \ remaining steps of this procedure are skipped.\n   Step 2:   Delivery depends\
    \ on the state of the registration whose\n      endpoint ID matches that of the\
    \ destination of the bundle:\n      *  If the registration is in the Active state,\
    \ then the bundle\n         must be delivered subject to this registration (see\
    \ Section 3.1\n         above) as soon as all previously received bundles that\
    \ are\n         deliverable subject to this registration have been delivered.\n\
    \      *  If the registration is in the Passive state, then the\n         registration's\
    \ delivery failure action must be taken (see\n         Section 3.1 above).\n \
    \  Step 3:   As soon as the bundle has been delivered:\n      *  If the \"request\
    \ reporting of bundle delivery\" flag in the\n         bundle's status report\
    \ request field is set to 1, then a bundle\n         delivery status report should\
    \ be generated, destined for the\n         bundle's report-to endpoint ID.  Note\
    \ that this status report\n         only states that the payload has been delivered\
    \ to the\n         application agent, not that the application agent has processed\n\
    \         that payload.\n      *  If the bundle's custody transfer requested flag\
    \ (in the bundle\n         processing flags field) is set to 1, custodial delivery\
    \ must be\n         reported.  Procedures for reporting custodial delivery for\
    \ a\n         bundle whose destination is not a singleton endpoint are not\n \
    \        defined in this specification.  For a bundle whose destination\n    \
    \     is a singleton endpoint, the bundle protocol agent must report\n       \
    \  custodial delivery by generating a \"Succeeded\" custody signal\n         for\
    \ the bundle, destined for the bundle's current custodian.\n"
- title: 5.8.  Bundle Fragmentation
  contents:
  - "5.8.  Bundle Fragmentation\n   It may at times be necessary for bundle protocol\
    \ agents to reduce the\n   sizes of bundles in order to forward them.  This might\
    \ be the case,\n   for example, if the endpoint to which a bundle is to be forwarded\
    \ is\n   accessible only via intermittent contacts and no upcoming contact is\n\
    \   long enough to enable the forwarding of the entire bundle.\n   The size of\
    \ a bundle can be reduced by \"fragmenting\" the bundle.  To\n   fragment a bundle\
    \ whose payload is of size M is to replace it with\n   two \"fragments\" -- new\
    \ bundles with the same source endpoint ID and\n   creation timestamp as the original\
    \ bundle -- whose payloads are the\n   first N and the last (M - N) bytes of the\
    \ original bundle's payload,\n   where 0 < N < M.  Note that fragments may themselves\
    \ be fragmented,\n   so fragmentation may in effect replace the original bundle\
    \ with more\n   than two fragments.  (However, there is only one 'level' of\n\
    \   fragmentation, as in IP fragmentation.)\n   Any bundle whose primary block's\
    \ bundle processing flags do NOT\n   indicate that it must not be fragmented may\
    \ be fragmented at any\n   time, for any purpose, at the discretion of the bundle\
    \ protocol\n   agent.\n   Fragmentation shall be constrained as follows:\n   o\
    \  The concatenation of the payloads of all fragments produced by\n      fragmentation\
    \ must always be identical to the payload of the\n      bundle that was fragmented.\
    \  Note that the payloads of fragments\n      resulting from different fragmentation\
    \ episodes, in different\n      parts of the network, may be overlapping subsets\
    \ of the original\n      bundle's payload.\n   o  The bundle processing flags\
    \ in the primary block of each fragment\n      must be modified to indicate that\
    \ the bundle is a fragment, and\n      both fragment offset and total application\
    \ data unit length must\n      be provided at the end of each fragment's primary\
    \ bundle block.\n   o  The primary blocks of the fragments will differ from that\
    \ of the\n      fragmented bundle as noted above.\n   o  The payload blocks of\
    \ fragments will differ from that of the\n      fragmented bundle as noted above.\n\
    \   o  All blocks that precede the payload block at the time of\n      fragmentation\
    \ must be replicated in the fragment with the lowest\n      offset.\n   o  All\
    \ blocks that follow the payload block at the time of\n      fragmentation must\
    \ be replicated in the fragment with the highest\n      offset.\n   o  If the\
    \ 'Block must be replicated in every fragment' bit is set to\n      1, then the\
    \ block must be replicated in every fragment.\n   o  If the 'Block must be replicated\
    \ in every fragment' bit is set to\n      zero, the block should be replicated\
    \ in only one fragment.\n   o  The relative order of all blocks that are present\
    \ in a fragment\n      must be the same as in the bundle prior to fragmentation.\n"
- title: 5.9.  Application Data Unit Reassembly
  contents:
  - "5.9.  Application Data Unit Reassembly\n   If the concatenation -- as informed\
    \ by fragment offsets and payload\n   lengths -- of the payloads of all previously\
    \ received fragments with\n   the same source endpoint ID and creation timestamp\
    \ as this fragment,\n   together with the payload of this fragment, forms a byte\
    \ array whose\n   length is equal to the total application data unit length in\
    \ the\n   fragment's primary block, then:\n   o  This byte array -- the reassembled\
    \ application data unit -- must\n      replace the payload of this fragment.\n\
    \   o  The \"Reassembly pending\" retention constraint must be removed from\n\
    \      every other fragment whose payload is a subset of the reassembled\n   \
    \   application data unit.\n   Note: reassembly of application data units from\
    \ fragments occurs at\n   destination endpoints as necessary; an application data\
    \ unit may also\n   be reassembled at some other endpoint on the route to the\n\
    \   destination.\n"
- title: 5.10.  Custody Transfer
  contents:
  - "5.10.  Custody Transfer\n   The conditions under which a node may accept custody\
    \ of a bundle\n   whose destination is not a singleton endpoint are not defined\
    \ in this\n   specification.\n   The decision as to whether or not to accept custody\
    \ of a bundle whose\n   destination is a singleton endpoint is an implementation\
    \ matter that\n   may involve both resource and policy considerations; however,\
    \ if the\n   bundle protocol agent has committed to accepting custody of the\n\
    \   bundle (as described in Step 1 of Section 5.2), then custody must be\n   accepted.\n\
    \   If the bundle protocol agent elects to accept custody of the bundle,\n   then\
    \ it must follow the custody acceptance procedure defined in\n   Section 5.10.1.\n"
- title: 5.10.1.  Custody Acceptance
  contents:
  - "5.10.1.  Custody Acceptance\n   Procedures for acceptance of custody of a bundle\
    \ whose destination is\n   not a singleton endpoint are not defined in this specification.\n\
    \   Procedures for acceptance of custody of a bundle whose destination is\n  \
    \ a singleton endpoint are defined as follows.\n   The retention constraint \"\
    Custody accepted\" must be added to the\n   bundle.\n   If the \"request reporting\
    \ of custody acceptance\" flag in the bundle's\n   status report request field\
    \ is set to 1, a custody acceptance status\n   report should be generated, destined\
    \ for the report-to endpoint ID of\n   the bundle.  However, if a bundle reception\
    \ status report was\n   generated for this bundle (Step 1 of Section 5.6), then\
    \ this report\n   should be generated by simply turning on the \"Reporting node\
    \ accepted\n   custody of bundle\" flag in that earlier report's status flags\
    \ byte.\n   The bundle protocol agent must generate a \"Succeeded\" custody signal\n\
    \   for the bundle, destined for the bundle's current custodian.\n   The bundle\
    \ protocol agent must assert the new current custodian for\n   the bundle.  It\
    \ does so by changing the current custodian endpoint ID\n   in the bundle's primary\
    \ block to the endpoint ID of one of the\n   singleton endpoints in which the\
    \ node is registered.  This may entail\n   appending that endpoint ID's null-terminated\
    \ scheme name and SSP to\n   the dictionary byte array in the bundle's primary\
    \ block, and in some\n   case it may also enable the (optional) removal of the\
    \ current\n   custodian endpoint ID's scheme name and/or SSP from the dictionary.\n\
    \   The bundle protocol agent may set a custody transfer countdown timer\n   for\
    \ this bundle; upon expiration of this timer prior to expiration of\n   the bundle\
    \ itself and prior to custody transfer success for this\n   bundle, the custody\
    \ transfer failure procedure detailed in\n   Section 5.12 must be followed.  The\
    \ manner in which the countdown\n   interval for such a timer is determined is\
    \ an implementation matter.\n   The bundle should be retained in persistent storage\
    \ if possible.\n"
- title: 5.10.2.  Custody Release
  contents:
  - "5.10.2.  Custody Release\n   Procedures for release of custody of a bundle whose\
    \ destination is\n   not a singleton endpoint are not defined in this specification.\n\
    \   When custody of a bundle is released, where the destination of the\n   bundle\
    \ is a singleton endpoint, the \"Custody accepted\" retention\n   constraint must\
    \ be removed from the bundle and any custody transfer\n   timer that has been\
    \ established for this bundle must be destroyed.\n"
- title: 5.11.  Custody Transfer Success
  contents:
  - "5.11.  Custody Transfer Success\n   Procedures for determining custody transfer\
    \ success for a bundle\n   whose destination is not a singleton endpoint are not\
    \ defined in this\n   specification.\n   Upon receipt of a \"Succeeded\" custody\
    \ signal at a node that is a\n   custodial node of the bundle identified in the\
    \ custody signal, where\n   the destination of the bundle is a singleton endpoint,\
    \ custody of the\n   bundle must be released as described in Section 5.10.2.\n"
- title: 5.12.  Custody Transfer Failure
  contents:
  - "5.12.  Custody Transfer Failure\n   Procedures for determining custody transfer\
    \ failure for a bundle\n   whose destination is not a singleton endpoint are not\
    \ defined in this\n   specification.  Custody transfer for a bundle whose destination\
    \ is a\n   singleton endpoint is determined to have failed at a custodial node\n\
    \   for that bundle when either (a) that node's custody transfer timer\n   for\
    \ that bundle (if any) expires or (b) a \"Failed\" custody signal for\n   that\
    \ bundle is received at that node.\n   Upon determination of custody transfer\
    \ failure, the action taken by\n   the bundle protocol agent is implementation-specific\
    \ and may depend\n   on the nature of the failure.  For example, if custody transfer\n\
    \   failure was inferred from expiration of a custody transfer timer or\n   was\
    \ asserted by a \"Failed\" custody signal with the \"Depleted storage\"\n   reason\
    \ code, the bundle protocol agent might choose to re-forward the\n   bundle, possibly\
    \ on a different route (Section 5.4).  Receipt of a\n   \"Failed\" custody signal\
    \ with the \"Redundant reception\" reason code,\n   on the other hand, might cause\
    \ the bundle protocol agent to release\n   custody of the bundle and to revise\
    \ its algorithm for computing\n   countdown intervals for custody transfer timers.\n"
- title: 5.13.  Bundle Deletion
  contents:
  - "5.13.  Bundle Deletion\n   The steps in deleting a bundle are:\n   Step 1:  \
    \ If the retention constraint \"Custody accepted\" currently\n      prevents this\
    \ bundle from being discarded, and the destination of\n      the bundle is a singleton\
    \ endpoint, then:\n      *  Custody of the node is released as described in Section\
    \ 5.10.2.\n      *  A bundle deletion status report citing the reason for deletion\n\
    \         must be generated, destined for the bundle's report-to endpoint\n  \
    \       ID.\n      Otherwise, if the \"request reporting of bundle deletion\"\
    \ flag in\n      the bundle's status report request field is set to 1, then a\n\
    \      bundle deletion status report citing the reason for deletion\n      should\
    \ be generated, destined for the bundle's report-to endpoint\n      ID.\n   Step\
    \ 2:   All of the bundle's retention constraints must be removed.\n"
- title: 5.14.  Discarding a Bundle
  contents:
  - "5.14.  Discarding a Bundle\n   As soon as a bundle has no remaining retention\
    \ constraints it may be\n   discarded.\n"
- title: 5.15.  Canceling a Transmission
  contents:
  - "5.15.  Canceling a Transmission\n   When requested to cancel a specified transmission,\
    \ where the bundle\n   created upon initiation of the indicated transmission has\
    \ not yet\n   been discarded, the bundle protocol agent must delete that bundle\
    \ for\n   the reason \"transmission cancelled\".  For this purpose, the procedure\n\
    \   defined in Section 5.13 must be followed.\n"
- title: 5.16.  Polling
  contents:
  - "5.16.  Polling\n   When requested to poll a specified registration that is in\
    \ the\n   Passive state, the bundle protocol agent must immediately deliver the\n\
    \   least recently received bundle that is deliverable subject to the\n   indicated\
    \ registration, if any.\n"
- title: 6.  Administrative Record Processing
  contents:
  - '6.  Administrative Record Processing

    '
- title: 6.1.  Administrative Records
  contents:
  - "6.1.  Administrative Records\n   Administrative records are standard application\
    \ data units that are\n   used in providing some of the features of the Bundle\
    \ Protocol.  Two\n   types of administrative records have been defined to date:\
    \ bundle\n   status reports and custody signals.\n   Every administrative record\
    \ consists of a four-bit record type code\n   followed by four bits of administrative\
    \ record flags, followed by\n   record content in type-specific format.  Record\
    \ type codes are\n   defined as follows:\n           +---------+--------------------------------------------+\n\
    \           |  Value  |                  Meaning                   |\n       \
    \    +=========+============================================+\n           |  0001\
    \   |  Bundle status report.                     |\n           +---------+--------------------------------------------+\n\
    \           |  0010   |  Custody signal.                           |\n       \
    \    +---------+--------------------------------------------+\n           | (other)\
    \ |  Reserved for future use.                  |\n           +---------+--------------------------------------------+\n\
    \                Figure 8: Administrative Record Type Codes\n           +---------+--------------------------------------------+\n\
    \           |  Value  |                  Meaning                   |\n       \
    \    +=========+============================================+\n           |  0001\
    \   |  Record is for a fragment; fragment        |\n           |         |  offset\
    \ and length fields are present.     |\n           +---------+--------------------------------------------+\n\
    \           | (other) |  Reserved for future use.                  |\n       \
    \    +---------+--------------------------------------------+\n              \
    \     Figure 9: Administrative Record Flags\n   All time values in administrative\
    \ records are UTC times expressed in\n   \"DTN time\" representation.  A DTN time\
    \ consists of an SDNV indicating\n   the number of seconds since the start of\
    \ the year 2000, followed by\n   an SDNV indicating the number of nanoseconds\
    \ since the start of the\n   indicated second.\n   The contents of the various\
    \ types of administrative records are\n   described below.\n"
- title: 6.1.1.  Bundle Status Reports
  contents:
  - "6.1.1.  Bundle Status Reports\n   The transmission of 'bundle status reports'\
    \ under specified\n   conditions is an option that can be invoked when transmission\
    \ of a\n   bundle is requested.  These reports are intended to provide\n   information\
    \ about how bundles are progressing through the system,\n   including notices\
    \ of receipt, custody transfer, forwarding, final\n   delivery, and deletion.\
    \  They are transmitted to the Report-to\n   endpoints of bundles.\n   +----------------+----------------+----------------+----------------+\n\
    \   |  Status Flags  |  Reason code   |      Fragment offset (*) (if\n   +----------------+----------------+----------------+----------------+\n\
    \       present)     |      Fragment length (*) (if present)            |\n  \
    \ +----------------+----------------+----------------+----------------+\n   |\
    \       Time of receipt of bundle X (a DTN time, if present)        |\n   +----------------+----------------+----------------+----------------+\n\
    \   |  Time of custody acceptance of bundle X (a DTN time, if present)  |\n  \
    \ +----------------+----------------+----------------+----------------+\n   |\
    \     Time of forwarding of bundle X (a DTN time, if present)       |\n   +----------------+----------------+----------------+----------------+\n\
    \   |      Time of delivery of bundle X (a DTN time, if present)        |\n  \
    \ +----------------+----------------+----------------+----------------+\n   |\
    \      Time of deletion of bundle X (a DTN time, if present)        |\n   +----------------+----------------+----------------+----------------+\n\
    \   |          Copy of bundle X's Creation Timestamp time (*)           |\n  \
    \ +----------------+----------------+----------------+----------------+\n   |\
    \     Copy of bundle X's Creation Timestamp sequence number (*)     |\n   +----------------+----------------+----------------+----------------+\n\
    \   |      Length of X's source endpoint ID (*)        |   Source\n   +----------------+---------------------------------+\
    \                +\n                        endpoint ID of bundle X (variable)\
    \             |\n   +----------------+----------------+----------------+----------------+\n\
    \                  Figure 10: Bundle Status Report Format\n   (*) Notes:\n   The\
    \ Fragment Offset field, if present, is an SDNV and is therefore\n   variable\
    \ length.  A three-octet SDNV is shown here for convenience in\n   representation.\n\
    \   The Fragment Length field, if present, is an SDNV and is therefore\n   variable\
    \ length.  A three-octet SDNV is shown here for convenience in\n   representation.\n\
    \   The Creation Timestamp fields replicate the Creation Timestamp fields\n  \
    \ in the primary block of the subject bundle.  As such they are SDNVs\n   (see\
    \ Section 4.5.1 above) and are therefore variable length.  Four-\n   octet SDNVs\
    \ are shown here for convenience in representation.\n   The source endpoint ID\
    \ length field is an SDNV and is therefore\n   variable length.  A three-octet\
    \ SDNV is shown here for convenience in\n   representation.\n   The fields in\
    \ a bundle status report are:\n   Status Flags:   A 1-byte field containing the\
    \ following flags:\n           +----------+--------------------------------------------+\n\
    \           |  Value   |                  Meaning                   |\n      \
    \     +==========+============================================+\n           |\
    \ 00000001 |  Reporting node received bundle.           |\n           +----------+--------------------------------------------+\n\
    \           | 00000010 |  Reporting node accepted custody of bundle.|\n      \
    \     +----------+--------------------------------------------+\n           |\
    \ 00000100 |  Reporting node forwarded the bundle.      |\n           +----------+--------------------------------------------+\n\
    \           | 00001000 |  Reporting node delivered the bundle.      |\n      \
    \     +----------+--------------------------------------------+\n           |\
    \ 00010000 |  Reporting node deleted the bundle.        |\n           +----------+--------------------------------------------+\n\
    \           | 00100000 |  Unused.                                   |\n      \
    \     +----------+--------------------------------------------+\n           |\
    \ 01000000 |  Unused.                                   |\n           +----------+--------------------------------------------+\n\
    \           | 10000000 |  Unused.                                   |\n      \
    \     +----------+--------------------------------------------+\n            \
    \  Figure 11: Status Flags for Bundle Status Reports\n   Reason Code:   A 1-byte\
    \ field explaining the value of the flags in\n      the status flags byte.  The\
    \ list of status report reason codes\n      provided here is neither exhaustive\
    \ nor exclusive; supplementary\n      DTN protocol specifications (including,\
    \ but not restricted to, the\n      Bundle Security Protocol [BSP]) may define\
    \ additional reason\n      codes.  Status report reason codes are defined as follows:\n\
    \           +---------+--------------------------------------------+\n       \
    \    |  Value  |                  Meaning                   |\n           +=========+============================================+\n\
    \           |  0x00   |  No additional information.                |\n       \
    \    +---------+--------------------------------------------+\n           |  0x01\
    \   |  Lifetime expired.                         |\n           +---------+--------------------------------------------+\n\
    \           |  0x02   |  Forwarded over unidirectional link.       |\n       \
    \    +---------+--------------------------------------------+\n           |  0x03\
    \   |  Transmission canceled.                    |\n           +---------+--------------------------------------------+\n\
    \           |  0x04   |  Depleted storage.                         |\n       \
    \    +---------+--------------------------------------------+\n           |  0x05\
    \   |  Destination endpoint ID unintelligible.   |\n           +---------+--------------------------------------------+\n\
    \           |  0x06   |  No known route to destination from here.  |\n       \
    \    +---------+--------------------------------------------+\n           |  0x07\
    \   |  No timely contact with next node on route.|\n           +---------+--------------------------------------------+\n\
    \           |  0x08   |  Block unintelligible.                     |\n       \
    \    +---------+--------------------------------------------+\n           | (other)\
    \ |  Reserved for future use.                  |\n           +---------+--------------------------------------------+\n\
    \                    Figure 12: Status Report Reason Codes\n   Fragment Offset:\
    \   If the bundle fragment bit is set in the status\n      flags, then the offset\
    \ (within the original application data unit)\n      of the payload of the bundle\
    \ that caused the status report to be\n      generated is included here.\n   Fragment\
    \ length:   If the bundle fragment bit is set in the status\n      flags, then\
    \ the length of the payload of the subject bundle is\n      included here.\n \
    \  Time of Receipt (if present):   If the bundle-received bit is set in\n    \
    \  the status flags, then a DTN time indicating the time at which the\n      bundle\
    \ was received at the reporting node is included here.\n   Time of Custody Acceptance\
    \ (if present):   If the custody-accepted\n      bit is set in the status flags,\
    \ then a DTN time indicating the\n      time at which custody was accepted at\
    \ the reporting node is\n      included here.\n   Time of Forward (if present):\
    \   If the bundle-forwarded bit is set in\n      the status flags, then a DTN\
    \ time indicating the time at which the\n      bundle was first forwarded at the\
    \ reporting node is included here.\n   Time of Delivery (if present):   If the\
    \ bundle-delivered bit is set\n      in the status flags, then a DTN time indicating\
    \ the time at which\n      the bundle was delivered at the reporting node is included\
    \ here.\n   Time of Deletion (if present):   If the bundle-deleted bit is set\
    \ in\n      the status flags, then a DTN time indicating the time at which the\n\
    \      bundle was deleted at the reporting node is included here.\n   Creation\
    \ Timestamp of Subject Bundle:  A copy of the creation\n      timestamp of the\
    \ bundle that caused the status report to be\n      generated.\n   Length of Source\
    \ Endpoint ID:   The length in bytes of the source\n      endpoint ID of the bundle\
    \ that caused the status report to be\n      generated.\n   Source Endpoint ID\
    \ text:   The text of the source endpoint ID of the\n      bundle that caused\
    \ the status report to be generated.\n"
- title: 6.1.2.  Custody Signals
  contents:
  - "6.1.2.  Custody Signals\n   Custody signals are administrative records that effect\
    \ custody\n   transfer operations.  They are transmitted to the endpoints that\
    \ are\n   the current custodians of bundles.\n   Custody signals have the following\
    \ format.\n   Custody signal regarding bundle 'X':\n   +----------------+----------------+----------------+----------------+\n\
    \   |     Status     |      Fragment offset (*) (if present)            |\n  \
    \ +----------------+----------------+----------------+----------------+\n   |\
    \                   Fragment length (*) (if present)                |\n   +----------------+----------------+----------------+----------------+\n\
    \   |                   Time of signal (a DTN time)                     |\n  \
    \ +----------------+----------------+----------------+----------------+\n   |\
    \          Copy of bundle X's Creation Timestamp time (*)           |\n   +----------------+----------------+----------------+----------------+\n\
    \   |     Copy of bundle X's Creation Timestamp sequence number (*)     |\n  \
    \ +----------------+----------------+----------------+----------------+\n   |\
    \      Length of X's source endpoint ID (*)        |   Source\n   +----------------+---------------------------------+\
    \                +\n                        endpoint ID of bundle X (variable)\
    \             |\n   +----------------+----------------+----------------+----------------+\n\
    \                     Figure 13: Custody Signal Format\n   (*) Notes:\n   The\
    \ Fragment Offset field, if present, is an SDNV and is therefore\n   variable\
    \ length.  A three-octet SDNV is shown here for convenience in\n   representation.\n\
    \   The Fragment Length field, if present, is an SDNV and is therefore\n   variable\
    \ length.  A four-octet SDNV is shown here for convenience in\n   representation.\n\
    \   The Creation Timestamp fields replicate the Creation Timestamp fields\n  \
    \ in the primary block of the subject bundle.  As such they are SDNVs\n   (see\
    \ Section 4.5.1 above) and are therefore variable length.  Four-\n   octet SDNVs\
    \ are shown here for convenience in representation.\n   The source endpoint ID\
    \ length field is an SDNV and is therefore\n   variable length.  A three-octet\
    \ SDNV is shown here for convenience in\n   representation.\n   The fields in\
    \ a custody signal are:\n   Status:   A 1-byte field containing a 1-bit \"custody\
    \ transfer\n      succeeded\" flag followed by a 7-bit reason code explaining\
    \ the\n      value of that flag.  Custody signal reason codes are defined as\n\
    \      follows:\n           +---------+--------------------------------------------+\n\
    \           |  Value  |                  Meaning                   |\n       \
    \    +=========+============================================+\n           |  0x00\
    \   |  No additional information.                |\n           +---------+--------------------------------------------+\n\
    \           |  0x01   |  Reserved for future use.                  |\n       \
    \    +---------+--------------------------------------------+\n           |  0x02\
    \   |  Reserved for future use.                  |\n           +---------+--------------------------------------------+\n\
    \           |  0x03   |  Redundant reception (reception by a node  |\n       \
    \    |         |  that is a custodial node for this bundle).|\n           +---------+--------------------------------------------+\n\
    \           |  0x04   |  Depleted storage.                         |\n       \
    \    +---------+--------------------------------------------+\n           |  0x05\
    \   |  Destination endpoint ID unintelligible.   |\n           +---------+--------------------------------------------+\n\
    \           |  0x06   |  No known route to destination from here.  |\n       \
    \    +---------+--------------------------------------------+\n           |  0x07\
    \   |  No timely contact with next node on route.|\n           +---------+--------------------------------------------+\n\
    \           |  0x08   |  Block unintelligible.                     |\n       \
    \    +---------+--------------------------------------------+\n           | (other)\
    \ |  Reserved for future use.                  |\n           +---------+--------------------------------------------+\n\
    \                    Figure 14: Custody Signal Reason Codes\n   Fragment offset:\
    \   If the bundle fragment bit is set in the status\n      flags, then the offset\
    \ (within the original application data unit)\n      of the payload of the bundle\
    \ that caused the status report to be\n      generated is included here.\n   Fragment\
    \ length:   If the bundle fragment bit is set in the status\n      flags, then\
    \ the length of the payload of the subject bundle is\n      included here.\n \
    \  Time of Signal:   A DTN time indicating the time at which the signal\n    \
    \  was generated.\n   Creation Timestamp of Subject Bundle:   A copy of the creation\n\
    \      timestamp of the bundle to which the signal applies.\n   Length of Source\
    \ Endpoint ID:   The length in bytes of the source\n      endpoint ID of the bundle\
    \ to which the signal applied.\n   Source Endpoint ID text:   The text of the\
    \ source endpoint ID of the\n      bundle to which the signal applies.\n"
- title: 6.2.  Generation of Administrative Records
  contents:
  - "6.2.  Generation of Administrative Records\n   Whenever the application agent's\
    \ administrative element is directed\n   by the bundle protocol agent to generate\
    \ an administrative record\n   with reference to some bundle, the following procedure\
    \ must be\n   followed:\n   Step 1:   The administrative record must be constructed.\
    \  If the\n      referenced bundle is a fragment, the administrative record must\n\
    \      have the Fragment flag set and must contain the fragment offset\n     \
    \ and fragment length fields.  The value of the fragment offset\n      field must\
    \ be the value of the referenced bundle's fragment\n      offset, and the value\
    \ of the fragment length field must be the\n      length of the referenced bundle's\
    \ payload.\n   Step 2:   A request for transmission of a bundle whose payload\
    \ is\n      this administrative record must be presented to the bundle\n     \
    \ protocol agent.\n"
- title: 6.3.  Reception of Custody Signals
  contents:
  - "6.3.  Reception of Custody Signals\n   For each received custody signal that\
    \ has the \"custody transfer\n   succeeded\" flag set to 1, the administrative\
    \ element of the\n   application agent must direct the bundle protocol agent to\
    \ follow the\n   custody transfer success procedure in Section 5.11.\n   For each\
    \ received custody signal that has the \"custody transfer\n   succeeded\" flag\
    \ set to 0, the administrative element of the\n   application agent must direct\
    \ the bundle protocol agent to follow the\n   custody transfer failure procedure\
    \ in Section 5.12.\n"
- title: 7.  Services Required of the Convergence Layer
  contents:
  - '7.  Services Required of the Convergence Layer

    '
- title: 7.1.  The Convergence Layer
  contents:
  - "7.1.  The Convergence Layer\n   The successful operation of the end-to-end bundle\
    \ protocol depends on\n   the operation of underlying protocols at what is termed\
    \ the\n   \"convergence layer\"; these protocols accomplish communication between\n\
    \   nodes.  A wide variety of protocols may serve this purpose, so long\n   as\
    \ each convergence layer protocol adapter provides a defined minimal\n   set of\
    \ services to the bundle protocol agent.  This convergence layer\n   service specification\
    \ enumerates those services.\n"
- title: 7.2.  Summary of Convergence Layer Services
  contents:
  - "7.2.  Summary of Convergence Layer Services\n   Each convergence layer protocol\
    \ adapter is expected to provide the\n   following services to the bundle protocol\
    \ agent:\n   o  sending a bundle to all bundle nodes in the minimum reception\n\
    \      group of the endpoint identified by a specified endpoint ID that\n    \
    \  are reachable via the convergence layer protocol; and\n   o  delivering to\
    \ the bundle protocol agent a bundle that was sent by\n      a remote bundle node\
    \ via the convergence layer protocol.\n   The convergence layer service interface\
    \ specified here is neither\n   exhaustive nor exclusive.  That is, supplementary\
    \ DTN protocol\n   specifications (including, but not restricted to, the Bundle\
    \ Security\n   Protocol [BSP]) may expect convergence layer adapters that serve\
    \ BP\n   implementations conforming to those protocols to provide additional\n\
    \   services.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   The bundle protocol has taken security into concern\
    \ from the outset\n   of its design.  It was always assumed that security services\
    \ would be\n   needed in the use of the bundle protocol.  As a result, the bundle\n\
    \   protocol security architecture and the available security services\n   are\
    \ specified in an accompanying document, the Bundle Security\n   Protocol specification\
    \ [BSP]; an informative overview of this\n   architecture is provided in [SECO].\n\
    \   The bundle protocol has been designed with the notion that it will be\n  \
    \ run over networks with scarce resources.  For example, the networks\n   might\
    \ have limited bandwidth, limited connectivity, constrained\n   storage in relay\
    \ nodes, etc.  Therefore, the bundle protocol must\n   ensure that only those\
    \ entities authorized to send bundles over such\n   constrained environments are\
    \ actually allowed to do so.  All\n   unauthorized entities should be prevented\
    \ from consuming valuable\n   resources.\n   Likewise, because of the potentially\
    \ long latencies and delays\n   involved in the networks that make use of the\
    \ bundle protocol, data\n   sources should be concerned with the integrity of\
    \ the data received\n   at the intended destination(s) and may also be concerned\
    \ with\n   ensuring confidentiality of the data as it traverses the network.\n\
    \   Without integrity, the bundle payload data might be corrupted while\n   in\
    \ transit without the destination able to detect it.  Similarly, the\n   data\
    \ source can be concerned with ensuring that the data can only be\n   used by\
    \ those authorized, hence the need for confidentiality.\n   Internal to the bundle-aware\
    \ overlay network, the bundle nodes should\n   be concerned with the authenticity\
    \ of other bundle nodes as well as\n   the preservation of bundle payload data\
    \ integrity as it is forwarded\n   between bundle nodes.\n   As a result, bundle\
    \ security is concerned with the authenticity,\n   integrity, and confidentiality\
    \ of bundles conveyed among bundle\n   nodes.  This is accomplished via the use\
    \ of three independent\n   security-specific bundle blocks, which may be used\
    \ together to\n   provide multiple bundle security services or independently of\
    \ one\n   another, depending on perceived security threats, mandated security\n\
    \   requirements, and security policies that must be enforced.\n   The Bundle\
    \ Authentication Block (BAB) ensures the authenticity and\n   integrity of bundles\
    \ on a hop-by-hop basis between bundle nodes.  The\n   BAB allows each bundle\
    \ node to verify a bundle's authenticity before\n   processing or forwarding the\
    \ bundle.  In this way, entities that are\n   not authorized to send bundles will\
    \ have unauthorized transmissions\n   blocked by security-aware bundle nodes.\n\
    \   Additionally, to provide \"security-source\" to \"security-destination\"\n\
    \   bundle authenticity and integrity, the Payload Security Block (PSB)\n   is\
    \ used.  A \"security-source\" may not actually be the origination\n   point of\
    \ the bundle but instead may be the first point along the path\n   that is security-aware\
    \ and is able to apply security services.  For\n   example, an enclave of networked\
    \ systems may generate bundles but\n   only their gateway may be required and/or\
    \ able to apply security\n   services.  The PSB allows any security-enabled entity\
    \ along the\n   delivery path, in addition to the \"security-destination\" (the\n\
    \   recipient counterpart to the \"security-source\"), to ensure the\n   bundle's\
    \ authenticity.\n   Finally, to provide payload confidentiality, the use of the\n\
    \   Confidentiality Block (CB) is available.  The bundle payload may be\n   encrypted\
    \ to provide \"security-source\" to \"security-destination\"\n   payload confidentiality/privacy.\
    \  The CB indicates the cryptographic\n   algorithm and key IDs that were used\
    \ to encrypt the payload.\n   Note that removal of strings from the dictionary\
    \ at a given point in\n   a bundle's end-to-end path, and attendant adjustment\
    \ of endpoint ID\n   references in the blocks of that bundle, may make it necessary\
    \ to re-\n   compute values in one or more of the bundle's security blocks.\n\
    \   Bundle security must not be invalidated by forwarding nodes even\n   though\
    \ they themselves might not use the Bundle Security Protocol.\n   In particular,\
    \ the sequencing of the blocks in a forwarded bundle\n   must not be changed as\
    \ it transits a node; received blocks must be\n   transmitted in the same relative\
    \ order as that in which they were\n   received.  While blocks may be added to\
    \ bundles as they transit\n   intermediate nodes, removal of blocks that do not\
    \ have their 'Discard\n   block if it can't be processed' flag in the block processing\
    \ control\n   flags set to 1 may cause security to fail.\n   Inclusion of the\
    \ Bundle Security Protocol in any Bundle Protocol\n   implementation is RECOMMENDED.\
    \  Use of the Bundle Security Protocol\n   in Bundle Protocol operations is OPTIONAL.\n"
- title: 9.  IANA Considerations
  contents:
  - "9.  IANA Considerations\n   The \"dtn:\" URI scheme has been provisionally registered\
    \ by IANA.  See\n   http://www.iana.org/assignments/uri-schemes.html for the latest\n\
    \   details.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [URI]      Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n\
    \              Resource Identifier (URI): Generic Syntax\", RFC 3986,\n      \
    \        STD 66, January 2005.\n   [URIREG]   Hansen, T., Hardie, T., and L. Masinter,\
    \ \"Guidelines and\n              Registration Procedures for New URI Schemes\"\
    , RFC 4395,\n              BCP 115, February 2006.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [ARCH]     V. Cerf et. al., \"Delay-Tolerant\
    \ Network Architecture\",\n              RFC 4838, April 2007.\n   [ASN1]    \
    \ \"Abstract Syntax Notation One (ASN.1), \"ASN.1 Encoding\n              Rules:\
    \ Specification of Basic Encoding Rules (BER),\n              Canonical Encoding\
    \ Rules (CER) and Distinguished Encoding\n              Rules (DER),\" ITU-T Rec.\
    \ X.690 (2002) | ISO/IEC 8825-\n              1:2002\", 2003.\n   [BSP]      Symington,\
    \ S., \"Bundle Security Protocol Specification\",\n              Work Progress,\
    \ October 2007.\n   [RFC3987]  Duerst, M. and M. Suignard, \"Internationalized\
    \ Resource\n              Identifiers (IRIs)\", RFC 3987, January 2005.\n   [SECO]\
    \     Farrell, S., Symington, S., Weiss, H., and P. Lovell,\n              \"\
    Delay-Tolerant Networking Security Overview\",\n              Work Progress, July\
    \ 2007.\n   [SIGC]     Fall, K., \"A Delay-Tolerant Network Architecture for\n\
    \              Challenged Internets\", SIGCOMM 2003 .\n   [TUT]      Warthman,\
    \ F., \"Delay-Tolerant Networks (DTNs): A\n              Tutorial\", <http://www.dtnrg.org>.\n\
    \   [UTC]      Arias, E. and B. Guinot, \"\"Coordinated universal time UTC:\n\
    \              historical background and perspectives\" in Journees\n        \
    \      systemes de reference spatio-temporels\", 2004.\n"
- title: Appendix A.  Contributors
  contents:
  - "Appendix A.  Contributors\n   This was an effort of the Delay Tolerant Networking\
    \ Research Group.\n   The following DTNRG participants contributed significant\
    \ technical\n   material and/or inputs: Dr. Vinton Cerf of Google, Scott Burleigh,\n\
    \   Adrian Hooke, and Leigh Torgerson of the Jet Propulsion Laboratory,\n   Michael\
    \ Demmer of the University of California at Berkeley, Robert\n   Durst, Keith\
    \ Scott, and Susan Symington of The MITRE Corporation,\n   Kevin Fall of Intel\
    \ Research, Stephen Farrell of Trinity College\n   Dublin, Peter Lovell of SPARTA,\
    \ Inc., Manikantan Ramadas of Ohio\n   University (most of Section 4.1), and Howard\
    \ Weiss of SPARTA, Inc.\n   (text of Section 8).\n"
- title: Appendix B.  Comments
  contents:
  - "Appendix B.  Comments\n   Please refer comments to dtn-interest@mailman.dtnrg.org.\
    \  The Delay\n   Tolerant Networking Research Group (DTNRG) Web site is located\
    \ at\n   http://www.dtnrg.org.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Keith L. Scott\n   The MITRE Corporation\n   7515 Colshire\
    \ Drive\n   McLean, VA  21102\n   US\n   Phone: +1 703 983 6547\n   Fax:   +1\
    \ 703 983 7142\n   EMail: kscott@mitre.org\n   Scott Burleigh\n   NASA Jet Propulsion\
    \ Laboratory\n   4800 Oak Grove Dr.\n   Pasadena, CA  91109-8099\n   US\n   Phone:\
    \ +1 818 393 3353\n   Fax:   +1 818 354 1075\n   EMail: Scott.Burleigh@jpl.nasa.gov\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78\
    \ and at www.rfc-editor.org/copyright.html, and\n   except as set forth therein,\
    \ the authors retain all their rights.\n   This document and the information contained\
    \ herein are provided on an\n   \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION\
    \ HE/SHE REPRESENTS\n   OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE\
    \ IETF TRUST AND\n   THE INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES,\
    \ EXPRESS\n   OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE\
    \ OF\n   THE INFORMATION HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n\
    \   WARRANTIES OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
