- contents:
  - '    Bidirectional Forwarding Detection (BFD) for Multipoint Networks

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document describes extensions to the Bidirectional Forwarding\n
    \  Detection (BFD) protocol for its use in multipoint and multicast\n   networks.\n
    \  This document updates RFC 5880.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   https://www.rfc-editor.org/info/rfc8562.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2019 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (https://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   4\n   2.  Keywords  . . . . . . . . . . . . . . . . . . . . . . .
    . . .   4\n   3.  Goals . . . . . . . . . . . . . . . . . . . . . . . . . . .
    .   5\n   4.  Overview  . . . . . . . . . . . . . . . . . . . . . . . . . .   5\n
    \  5.  Protocol Details  . . . . . . . . . . . . . . . . . . . . . .   5\n     5.1.
    \ Multipoint BFD Control Packets  . . . . . . . . . . . . .   6\n     5.2.  Session
    Model . . . . . . . . . . . . . . . . . . . . . .   6\n     5.3.  Session-Failure
    Semantics . . . . . . . . . . . . . . . .   6\n     5.4.  State Variables . .
    . . . . . . . . . . . . . . . . . . .   6\n       5.4.1.  New State Variable Values
    . . . . . . . . . . . . . .   6\n       5.4.2.  State Variable Initialization
    and Maintenance . . . .   7\n     5.5.  State Machine . . . . . . . . . . . .
    . . . . . . . . . .   7\n     5.6.  Session Establishment . . . . . . . . . .
    . . . . . . . .   8\n     5.7.  Discriminators and Packet Demultiplexing  . .
    . . . . . .   8\n     5.8.  Packet Consumption on Tails . . . . . . . . . . .
    . . . .   9\n     5.9.  Bringing Up and Shutting Down Multipoint BFD Service  .
    .   9\n     5.10. Timer Manipulation  . . . . . . . . . . . . . . . . . . .  10\n
    \    5.11. Detection Times . . . . . . . . . . . . . . . . . . . . .  10\n     5.12.
    State Maintenance for Down/AdminDown Sessions . . . . . .  11\n       5.12.1.
    \ MultipointHead Sessions  . . . . . . . . . . . . . .  11\n       5.12.2.  MultipointTail
    Sessions  . . . . . . . . . . . . . .  11\n     5.13. Base Specification Text
    Replacement . . . . . . . . . . .  11\n       5.13.1.  Reception of BFD Control
    Packets . . . . . . . . . .  12\n       5.13.2.  Demultiplexing BFD Control Packets
    . . . . . . . . .  15\n       5.13.3.  Transmitting BFD Control Packets . . .
    . . . . . . .  16\n   6.  Congestion Considerations . . . . . . . . . . . . .
    . . . . .  19\n   7.  IANA Considerations . . . . . . . . . . . . . . . . . .
    . . .  20\n   8.  Security Considerations . . . . . . . . . . . . . . . . . .
    .  20\n   9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  21\n
    \    9.1.  Normative References  . . . . . . . . . . . . . . . . . .  21\n     9.2.
    \ Informative References  . . . . . . . . . . . . . . . . .  22\n   Acknowledgments
    . . . . . . . . . . . . . . . . . . . . . . . . .  22\n   Contributors  . . .
    . . . . . . . . . . . . . . . . . . . . . . .  22\n   Authors' Addresses  . .
    . . . . . . . . . . . . . . . . . . . . .  23\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The Bidirectional Forwarding Detection (BFD) protocol [RFC5880]\n
    \  specifies a method for verifying unicast connectivity between a pair\n   of
    systems.  This document updates [RFC5880] by defining a new method\n   for using
    BFD.  This new method provides verification of multipoint\n   or multicast connectivity
    between a multipoint sender (the \"head\")\n   and a set of one or more multipoint
    receivers (the \"tails\").\n   As multipoint transmissions are inherently unidirectional,
    this\n   mechanism purports only to verify this unidirectional connectivity.\n
    \  Although this seems in conflict with the \"Bidirectional\" in BFD, the\n   protocol
    is capable of supporting this use case.  Use of BFD in\n   Demand mode allows
    a tail to monitor the availability of a multipoint\n   path even without the existence
    of some kind of a return path to the\n   head.  As an option, if a return path
    from a tail to the head exists,\n   the tail may notify the head of the lack of
    multipoint connectivity.\n   Details of tail notification to the head are outside
    the scope of\n   this document and are discussed in [RFC8563].\n   This application
    of BFD allows for the tails to detect a lack of\n   connectivity from the head.
    \ For some applications, such detection of\n   the failure at the tail is useful,
    for example, the use of multipoint\n   BFD to enable fast failure detection and
    faster failover in multicast\n   VPN as described in [MVPN-FAILOVER].  Due to
    its unidirectional\n   nature, virtually all options and timing parameters are
    controlled by\n   the head.\n   Throughout this document, the term \"multipoint\"
    is defined as a\n   mechanism by which one or more systems receive packets sent
    by a\n   single sender.  This specifically includes such things as IP\n   multicast
    and point-to-multipoint MPLS.\n   The term \"connectivity\" in this document is
    not being used in the\n   context of connectivity verification in a transport
    network but as an\n   alternative to \"continuity\", i.e., the existence of a
    forwarding path\n   between the sender and the receiver.\n   This document effectively
    updates and extends the base BFD\n   specification [RFC5880].\n"
  title: 1.  Introduction
- contents:
  - "2.  Keywords\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\",
    \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described
    in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all\n   capitals,
    as shown here.\n"
  title: 2.  Keywords
- contents:
  - "3.  Goals\n   The primary goal of this mechanism is to allow tails to rapidly\n
    \  detect the fact that multipoint connectivity from the head has\n   failed.\n
    \  Another goal is for the mechanism to work on any multicast\n   technology.\n
    \  A further goal is to support multiple, overlapping point-to-\n   multipoint
    paths, as well as multipoint-to-multipoint paths, and to\n   allow point-to-point
    BFD sessions to operate simultaneously among the\n   systems participating in
    multipoint BFD.\n   It is not a goal for this protocol to verify point-to-point\n
    \  bidirectional connectivity between the head and any tail.  This can\n   be
    done independently (and with no penalty in protocol overhead) by\n   using point-to-point
    BFD.\n"
  title: 3.  Goals
- contents:
  - "4.  Overview\n   The heart of this protocol is the periodic transmission of BFD\n
    \  Control packets along a multipoint path, from the head to all tails\n   on
    the path.  The contents of the BFD packets provide the means for\n   the tails
    to calculate the Detection Time for path failure.  If no\n   BFD Control packets
    are received by a tail for a Detection Time, the\n   tail declares that the path
    has failed.  For some applications, this\n   is the only mechanism necessary;
    the head can remain ignorant of the\n   status of connectivity to the tails.\n
    \  The head of a multipoint BFD session may wish to be alerted to the\n   tails'
    connectivity (or lack thereof).  Details of how the head keeps\n   track of tails
    and how tails alert their connectivity to the head are\n   outside the scope of
    this document and are discussed in [RFC8563].\n   Although this document describes
    a single head and a set of tails\n   spanned by a single multipoint path, the
    protocol is capable of\n   supporting (and discriminating between) more than one
    multipoint path\n   at both heads and tails, as described in Sections 5.7 and
    5.13.2.\n   Furthermore, the same head and tail may share multiple multipoint\n
    \  paths, and a multipoint path may have multiple heads.\n"
  title: 4.  Overview
- contents:
  - "5.  Protocol Details\n   This section describes the operation of Multipoint BFD
    in detail.\n"
  - contents:
    - "5.1.  Multipoint BFD Control Packets\n   Multipoint BFD Control packets (packets
      sent by the head over a\n   multipoint path) are explicitly marked as such,
      via the setting of\n   the Multipoint (M) bit [RFC5880].  This means that multipoint
      BFD\n   does not depend on the recipient of a packet to know whether the\n   packet
      was received over a multipoint path.  This can be useful in\n   scenarios where
      this information may not be available to the\n   recipient.\n"
    title: 5.1.  Multipoint BFD Control Packets
  - contents:
    - "5.2.  Session Model\n   Multipoint BFD is modeled as a set of sessions of different
      types.\n   The elements of procedure differ slightly for each type.\n   The
      head has a session of type MultipointHead, as defined in\n   Section 5.4.1,
      that is bound to a multipoint path.  Multipoint BFD\n   Control packets are
      sent by this session over the multipoint path,\n   and no BFD Control packets
      are received by it.\n   Each tail has a session of type MultipointTail, as defined
      in\n   Section 5.4.1, associated with a multipoint path.  These sessions\n   receive
      BFD Control packets from the head over the multipoint path.\n"
    title: 5.2.  Session Model
  - contents:
    - "5.3.  Session-Failure Semantics\n   The semantics of session failure is subtle
      enough to warrant further\n   explanation.\n   MultipointHead sessions cannot
      fail (since they are controlled\n   administratively).\n   If a MultipointTail
      session fails, it means that the tail definitely\n   has lost contact with the
      head (or the head has been administratively\n   disabled), and the tail may
      use mechanisms other than BFD, e.g.,\n   logging or NETCONF [RFC6241], to send
      a notification to the user.\n"
    title: 5.3.  Session-Failure Semantics
  - contents:
    - "5.4.  State Variables\n   Multipoint BFD introduces some new state variables
      and modifies the\n   usage of a few existing ones.\n"
    - contents:
      - "5.4.1.  New State Variable Values\n   A number of new values of the state
        variable bfd.SessionType are\n   added to the base BFD [RFC5880] and base
        Seamless Bidirectional\n   Forwarding Detection (S-BFD) [RFC7880] specifications
        in support of\n   multipoint BFD.\n      bfd.SessionType\n         The type
        of this session as defined in [RFC7880].  Newly added\n         values are:\n
        \           PointToPoint: Classic point-to-point BFD, as described in\n            [RFC5880].\n
        \           MultipointHead: A session on the head responsible for the\n            periodic
        transmission of multipoint BFD Control packets\n            along the multipoint
        path.\n            MultipointTail: A multipoint session on a tail.\n         This
        variable MUST be initialized to the appropriate type when\n         the session
        is created.\n"
      title: 5.4.1.  New State Variable Values
    - contents:
      - "5.4.2.  State Variable Initialization and Maintenance\n   Some state variables
        defined in Section 6.8.1 of [RFC5880] need to be\n   initialized or manipulated
        differently depending on the session type.\n      bfd.RequiredMinRxInterval\n
        \        This variable MUST be initialized to zero for session type\n         MultipointHead.\n
        \     bfd.DemandMode\n         This variable MUST be initialized to 1 for
        session type\n         MultipointHead and MUST be initialized to zero for
        session type\n         MultipointTail.\n"
      title: 5.4.2.  State Variable Initialization and Maintenance
    title: 5.4.  State Variables
  - contents:
    - "5.5.  State Machine\n   There are slight differences in how the BFD state machine
      works in\n   the multipoint application.  In particular, since there is a many-to-\n
      \  one mapping, three-way handshakes for session establishment and\n   teardown
      are neither possible nor appropriate.  As such, there is no\n   Init state.
      \ Sessions of type MultipointHead MUST NOT send BFD\n   Control packets with
      the State field being set to INIT, and those\n   packets MUST be ignored on
      receipt.\n   The following diagram provides an overview of the state machine
      for\n   session type MultipointTail.  The notation on each arc represents the\n
      \  state of the remote system (as received in the State field in the BFD\n   Control
      packet) or indicates the expiration of the Detection Timer.\n                         DOWN,
      ADMIN DOWN,\n                       +------+  TIMER               +------+\n
      \                 +----|      |<---------------------|      |----+\n             DOWN,|
      \   | DOWN |                      |  UP  |    |UP\n       ADMIN DOWN,+--->|
      \     |--------------------->|      |<---+\n            TIMER      +------+
      \         UP          +------+\n   Sessions of type MultipointHead never receive
      packets and have no\n   Detection Timer; as such, all state transitions are
      administratively\n   driven.\n"
    title: 5.5.  State Machine
  - contents:
    - "5.6.  Session Establishment\n   Unlike point-to-point BFD, multipoint BFD provides
      a form of the\n   discovery mechanism that enables tails to discover the head.
      \ The\n   minimum amount of a priori information required both on the head and\n
      \  tails is the binding to the multipoint path over which BFD is\n   running.
      \ The head transmits multipoint BFD packets on that path, and\n   the tails
      listen for BFD packets on that path.  All other information\n   can be determined
      dynamically.\n   A session of type MultipointHead is created for each multipoint
      path\n   over which the head wishes to run BFD.  This session runs in the\n
      \  Active role, per Section 6.1 of [RFC5880].  Except when\n   administratively
      terminating BFD service, this session is always in\n   state Up and always operates
      in Demand mode.  No received packets are\n   ever demultiplexed to the MultipointHead
      session.  In this sense, it\n   is a degenerate form of a session.\n   Sessions
      on the tail MAY be established dynamically, based on the\n   receipt of a multipoint
      BFD Control packet from the head, and are of\n   type MultipointTail.  Tail
      sessions always take the Passive role, per\n   Section 6.1 of [RFC5880].\n"
    title: 5.6.  Session Establishment
  - contents:
    - "5.7.  Discriminators and Packet Demultiplexing\n   The use of discriminators
      is somewhat different in multipoint BFD\n   than in point-to-point BFD.\n   The
      head sends multipoint BFD Control packets over the multipoint\n   path via the
      MultipointHead session with My Discriminator set to a\n   value bound to the
      multipoint path and with Your Discriminator set to\n   zero.\n   IP and MPLS
      multipoint tails MUST demultiplex BFD packets based on a\n   combination of
      the source address, My Discriminator, and the identity\n   of the multipoint
      path that the multipoint BFD Control packet was\n   received from.  Together
      they uniquely identify the head of the\n   multipoint path.  Bootstrapping a
      BFD session to multipoint MPLS\n   Label Switched Path (LSP) may use the control
      plane, e.g., as\n   described in [MVPN-FAILOVER], and is outside the scope of
      this\n   document.\n   Note that, unlike point-to-point sessions, the My Discriminator
      value\n   on the MultipointHead session MUST NOT be changed during the life
      of\n   a session.  This is a side effect of the more complex demultiplexing\n
      \  scheme.\n"
    title: 5.7.  Discriminators and Packet Demultiplexing
  - contents:
    - "5.8.  Packet Consumption on Tails\n   BFD packets received on tails for an
      IP multicast group MUST be\n   consumed by tails and MUST NOT be forwarded to
      receivers.  Nodes with\n   the BFD session of type MultipointTail MUST identify
      packets received\n   on an IP multipoint path as a BFD Control packet if the
      destination\n   UDP port value equals 3784.\n   For multipoint LSPs, when IP/UDP
      encapsulation of BFD Control packets\n   is used, MultipointTail MUST expect
      destination UDP port 3784.  The\n   destination IP address of a BFD Control
      packet MUST be in the\n   127.0.0.0/8 range for IPv4 or in the 0:0:0:0:0:FFFF:7F00:0/104
      range\n   for IPv6.  The use of these destination addresses is consistent with\n
      \  the explanations and usage in [RFC8029].  Packets identified as BFD\n   packets
      MUST be consumed by MultipointTail and demultiplexed as\n   described in Section
      5.13.2.  Use of other types of encapsulation of\n   the BFD control message
      over multipoint LSP is outside the scope of\n   this document.\n"
    title: 5.8.  Packet Consumption on Tails
  - contents:
    - "5.9.  Bringing Up and Shutting Down Multipoint BFD Service\n   Because there
      is no three-way handshake in multipoint BFD, a newly\n   started head (that
      does not have any previous state information\n   available) SHOULD start with
      bfd.SessionState set to Down, and\n   bfd.RequiredMinRxInterval MUST be set
      to zero in the MultipointHead\n   session.  The session SHOULD remain in this
      state for a time equal to\n   (bfd.DesiredMinTxInterval * bfd.DetectMult).  This
      will ensure that\n   all MultipointTail sessions are reset (so long as the restarted
      head\n   is using the same or a larger value of bfd.DesiredMinTxInterval than\n
      \  it did previously).\n   Multipoint BFD service is brought up by administratively
      setting\n   bfd.SessionState to Up in the MultipointHead session.\n   The head
      of a multipoint BFD session may wish to shut down its BFD\n   service in a controlled
      fashion.  This is desirable because the tails\n   need not wait for a Detection
      Time prior to declaring the multipoint\n   session to be down (and taking whatever
      action is necessary in that\n   case).\n   To shut down a multipoint session
      in a controlled fashion, the head\n   MUST administratively set bfd.SessionState
      in the MultipointHead\n   session to either Down or AdminDown and SHOULD set\n
      \  bfd.RequiredMinRxInterval to zero.  The session SHOULD send BFD\n   Control
      packets in this state for a period equal to\n   (bfd.DesiredMinTxInterval *
      bfd.DetectMult).  Alternatively, the head\n   MAY stop transmitting BFD Control
      packets and not send any more BFD\n   Control packets with the new state (Down
      or AdminDown).  Tails will\n   declare the multipoint session down only after
      the Detection Time\n   interval runs out.\n"
    title: 5.9.  Bringing Up and Shutting Down Multipoint BFD Service
  - contents:
    - "5.10.  Timer Manipulation\n   Because of the one-to-many mapping, a session
      of type MultipointHead\n   SHOULD NOT initiate a Poll Sequence in conjunction
      with timer value\n   changes.  However, to indicate a change in the packets,
      a\n   MultipointHead session MUST send packets with the P bit set.  A\n   MultipointTail
      session MUST NOT reply if the packet has the M and P\n   bits set and bfd.RequiredMinRxInterval
      set to zero.  Because the Poll\n   Sequence is not used, the tail cannot negotiate
      down MultpointHead's\n   transmit interval.  If the value of Desired Min TX
      Interval in the\n   BFD Control packet received by MultipointTail is too high
      (that\n   determination may change in time based on the current environment),\n
      \  it must be handled by the implementation and may be controlled by\n   local
      policy, e.g., close the MultipointTail session.\n   The MultipointHead, when
      changing the transmit interval to a higher\n   value, MUST send BFD Control
      packets with the P bit set at the old\n   transmit interval before using the
      higher value in order to avoid\n   false detection timeouts at the tails.  A
      MultipointHead session MAY\n   also wait some amount of time before making the
      changes to the\n   transmit interval (through configuration).\n   Change in
      the value of bfd.RequiredMinRxInterval is outside the scope\n   of this document
      and is discussed in [RFC8563].\n"
    title: 5.10.  Timer Manipulation
  - contents:
    - "5.11.  Detection Times\n   Multipoint BFD is inherently asymmetric.  As such,
      each session type\n   has a different approach to Detection Times.\n   Since
      MultipointHead sessions never receive packets, they do not\n   calculate a Detection
      Time.\n   MultipointTail sessions cannot influence the transmission rate of
      the\n   MultipointHead session using the Required Min Rx Interval field\n   because
      of its one-to-many nature.  As such, the Detection Time\n   calculation for
      a MultipointTail session does not use\n   bfd.RequiredMinRxInterval.  The Detection
      Time is calculated as the\n   product of the last received values of Desired
      Min TX Interval and\n   Detect Mult.\n   The value of bfd.DetectMult may be
      changed at any time on any session\n   type.\n"
    title: 5.11.  Detection Times
  - contents:
    - "5.12.  State Maintenance for Down/AdminDown Sessions\n   The length of time
      the session state is kept after the session goes\n   down determines how long
      the session will continue to send BFD\n   Control packets (since no packets
      can be sent after the session is\n   destroyed).\n"
    - contents:
      - "5.12.1.  MultipointHead Sessions\n   When a MultipointHead session transitions
        to states Down or\n   AdminDown, the state SHOULD be maintained for a period
        equal to\n   (bfd.DesiredMinTxInterval * bfd.DetectMult) to ensure that the
        tails\n   more quickly detect the session going down (by continuing to transmit\n
        \  BFD Control packets with the new state).\n"
      title: 5.12.1.  MultipointHead Sessions
    - contents:
      - "5.12.2.  MultipointTail Sessions\n   MultipointTail sessions MAY be destroyed
        immediately upon leaving Up\n   state, since the tail will transmit no packets.\n
        \  Otherwise, MultipointTail sessions SHOULD be maintained as long as\n   BFD
        Control packets are being received by it (which by definition\n   will indicate
        that the head is not Up).\n"
      title: 5.12.2.  MultipointTail Sessions
    title: 5.12.  State Maintenance for Down/AdminDown Sessions
  - contents:
    - "5.13.  Base Specification Text Replacement\n   The following sections are meant
      to replace the corresponding\n   sections in the base specification [RFC5880]
      to support BFD for\n   multipoint networks while not changing processing for
      point-to-point\n   BFD.\n"
    - contents:
      - "5.13.1.  Reception of BFD Control Packets\n   The following procedure replaces
        Section 6.8.6 of [RFC5880] entirely.\n   When a BFD Control packet is received,
        the following procedure MUST\n   be followed, in the order specified.  If
        the packet is discarded\n   according to these rules, processing of the packet
        MUST cease at that\n   point.\n      If the version number is not correct
        (1), the packet MUST be\n      discarded.\n      If the Length field is less
        than the minimum correct value (24 if\n      the A bit is clear, or 26 if
        the A bit is set), the packet MUST be\n      discarded.\n      If the Length
        field is greater than the payload of the\n      encapsulating protocol, the
        packet MUST be discarded.\n      If the Detect Mult field is zero, the packet
        MUST be discarded.\n      If the My Discriminator field is zero, the packet
        MUST be\n      discarded.\n      Demultiplex the packet to a session according
        to Section 5.13.2.\n      The result is either a session of the proper type,
        or the packet\n      is discarded (and packet processing MUST cease).\n      If
        the A bit is set and no authentication is in use (bfd.AuthType\n      is zero),
        the packet MUST be discarded.\n      If the A bit is clear and authentication
        is in use (bfd.AuthType\n      is nonzero), the packet MUST be discarded.\n
        \     If the A bit is set, the packet MUST be authenticated under the\n      rules
        of Section 6.7 of [RFC5880], based on the authentication\n      type in use
        (bfd.AuthType).  This may cause the packet to be\n      discarded.\n      Set
        bfd.RemoteDiscr to the value of My Discriminator.\n      Set bfd.RemoteState
        to the value of the State (Sta) field.\n      Set bfd.RemoteDemandMode to
        the value of the Demand (D) bit.\n      Set bfd.RemoteMinRxInterval to the
        value of Required Min RX\n      Interval.\n      If the Required Min Echo
        RX Interval field is zero, the\n      transmission of Echo packets, if any,
        MUST cease.\n      If a Poll Sequence is being transmitted by the local system
        and\n      the Final (F) bit in the received packet is set, the Poll Sequence\n
        \     MUST be terminated.\n      If bfd.SessionType is PointToPoint, update
        the transmit interval\n      as described in Section 6.8.2 of [RFC5880].\n
        \     If bfd.SessionType is PointToPoint, update the Detection Time as\n      described
        in Section 6.8.4 of [RFC5880].\n      Else\n         If bfd.SessionType is
        MultipointTail, then update the Detection\n         Time as the product of
        the last received values of Desired Min\n         TX Interval and Detect Mult,
        as described in Section 5.11 of\n         this specification.\n      If bfd.SessionState
        is AdminDown\n         Discard the packet\n      If the received State is
        AdminDown\n         If bfd.SessionState is not Down\n            Set bfd.LocalDiag
        to 3 (Neighbor signaled session down)\n            Set bfd.SessionState to
        Down\n      Else\n         If bfd.SessionState is Down\n            If bfd.SessionType
        is PointToPoint\n               If received State is Down\n                  Set
        bfd.SessionState to Init\n               Else if received State is Init\n
        \                 Set bfd.SessionState to Up\n            Else (bfd.SessionType
        is not PointToPoint)\n               If received State is Up\n                  Set
        bfd.SessionState to Up\n         Else if bfd.SessionState is Init\n            If
        received State is Init or Up\n               Set bfd.SessionState to Up\n
        \        Else (bfd.SessionState is Up)\n            If received State is Down\n
        \              Set bfd.LocalDiag to 3 (Neighbor signaled session down)\n               Set
        bfd.SessionState to Down\n      Check to see if Demand mode should become
        active or not (see\n      [RFC5880], Section 6.6).\n      If bfd.RemoteDemandMode
        is 1, bfd.SessionState is Up, and\n      bfd.RemoteSessionState is Up, Demand
        mode is active on the remote\n      system and the local system MUST cease
        the periodic transmission\n      of BFD Control packets (see Section 5.13.3).\n
        \     If bfd.RemoteDemandMode is zero, bfd.SessionState is not Up, or\n      bfd.RemoteSessionState
        is not Up, Demand mode is not active on the\n      remote system and the local
        system MUST send periodic BFD Control\n      packets (see Section 5.13.3).\n
        \     If the Poll (P) bit is set, and bfd.SessionType is PointToPoint,\n      send
        a BFD Control packet to the remote system with the Poll (P)\n      bit clear,
        and the Final (F) bit set (see Section 5.13.3).\n      If the packet was not
        discarded, it has been received for purposes\n      of the Detection Time
        expiration rules in Section 6.8.4 of\n      [RFC5880].\n"
      title: 5.13.1.  Reception of BFD Control Packets
    - contents:
      - "5.13.2.  Demultiplexing BFD Control Packets\n   This section is part of the
        replacement for Section 6.8.6 of\n   [RFC5880]; it is separated for clarity.\n
        \     If the Multipoint (M) bit is set\n         If the Your Discriminator
        field is nonzero, the packet MUST be\n         discarded.\n         Select
        a session based on the source address, My Discriminator,\n         and the
        identity of the multipoint path on which the multipoint\n         BFD Control
        packet was received.\n         If a session is found, and bfd.SessionType
        is not\n         MultipointTail, the packet MUST be discarded.\n         Else\n
        \           If a session is not found, a new session of type\n            MultipointTail
        MAY be created, or the packet MAY be\n            discarded.  This choice
        can be controlled by the local\n            policy, e.g., by setting a maximum
        number of MultipointTail\n            sessions.  Use of the local policy and
        the exact mechanism\n            of it are outside the scope of this specification.\n
        \     Else (Multipoint (M) bit is clear)\n         If the Your Discriminator
        field is nonzero\n            Select a session based on the value of Your
        Discriminator.\n            If no session is found, the packet MUST be discarded.\n
        \        Else (Your Discriminator is zero)\n            If the State field
        is not Down or AdminDown, the packet MUST\n            be discarded.\n            Otherwise,
        the session MUST be selected based on some\n            combination of other
        fields, possibly including source\n            addressing information, the
        My Discriminator field, and the\n            interface over which the packet
        was received.  The exact\n            method of selection is application specific
        and is thus\n            outside the scope of this specification.\n            If
        a matching session is found, and bfd.SessionType is not\n            PointToPoint,
        the packet MUST be discarded.\n            If a matching session is not found,
        a new session of type\n            PointToPoint MAY be created, or the packet
        MAY be discarded.\n            This choice MAY be controlled by a local policy
        and is\n            outside the scope of this specification.\n         If
        the State field is Init and bfd.SessionType is not\n         PointToPoint,
        the packet MUST be discarded.\n"
      title: 5.13.2.  Demultiplexing BFD Control Packets
    - contents:
      - "5.13.3.  Transmitting BFD Control Packets\n   The following procedure replaces
        Section 6.8.7 of [RFC5880] entirely.\n   With the exceptions listed in the
        remainder of this section, a system\n   MUST NOT transmit BFD Control packets
        at an interval less than the\n   larger of bfd.DesiredMinTxInterval and bfd.RemoteMinRxInterval,
        less\n   applied jitter (see below).  In other words, the system reporting
        the\n   slower rate determines the transmission rate.\n   The periodic transmission
        of BFD Control packets MUST be jittered on\n   a per-packet basis by up to
        25%; that is, the interval MUST be\n   reduced by a random value of 0 to 25%,
        in order to avoid self-\n   synchronization with other systems on the same
        subnetwork.  Thus, the\n   average interval between packets will be roughly
        12.5% less than that\n   negotiated.\n   If bfd.DetectMult is equal to 1,
        the interval between transmitted BFD\n   Control packets MUST be no more than
        90% of the negotiated\n   transmission interval and MUST be no less than 75%
        of the negotiated\n   transmission interval.  This is to ensure that, on the
        remote system,\n   the calculated Detection Time does not pass prior to the
        receipt of\n   the next BFD Control packet.\n   A system MUST NOT transmit
        any BFD Control packets if bfd.RemoteDiscr\n   is zero and the system is taking
        the Passive role.\n   A system MUST NOT transmit any BFD Control packets if
        bfd.SessionType\n   is MultipointTail.\n   A system MUST NOT periodically
        transmit BFD Control packets if Demand\n   mode is active on the remote system
        (bfd.RemoteDemandMode is 1,\n   bfd.SessionState is Up, and bfd.RemoteSessionState
        is Up), and a Poll\n   Sequence is not being transmitted.\n   A system MUST
        NOT periodically transmit BFD Control packets if\n   bfd.RemoteMinRxInterval
        is zero.\n   If bfd.SessionType is MultipointHead, the transmit interval MUST
        be\n   set to bfd.DesiredMinTxInterval (this should happen automatically,
        as\n   bfd.RemoteMinRxInterval will be zero).\n   If bfd.SessionType is not
        MultipointHead, the transmit interval MUST\n   be recalculated whenever bfd.DesiredMinTxInterval
        changes, or\n   whenever bfd.RemoteMinRxInterval changes, and is equal to
        the greater\n   of those two values.  See Sections 6.8.2 and 6.8.3 of [RFC5880]
        for\n   details on transmit timers.\n   A system MUST NOT set the Demand (D)
        bit if bfd.SessionType is\n   MultipointTail.\n   A system MUST NOT set the
        Demand (D) bit if bfd.SessionType is\n   PointToPoint unless bfd.DemandMode
        is 1, bfd.SessionState is Up, and\n   bfd.RemoteSessionState is Up.\n   If
        bfd.SessionType is PointToPoint or MultipointHead, a BFD Control\n   packet
        SHOULD be transmitted during the interval between periodic\n   Control packet
        transmissions when the contents of that packet would\n   differ from that
        in the previously transmitted packet (other than the\n   Poll (P) and Final
        (F) bits) in order to more rapidly communicate a\n   change in state.\n   The
        contents of transmitted BFD Control packets MUST be set as\n   follows:\n
        \     Version\n         Set to the current version number (1).\n      Diagnostic
        (Diag)\n         Set to bfd.LocalDiag.\n      State (Sta)\n         Set to
        the value indicated by bfd.SessionState.\n      Poll (P)\n         Set to
        1 if the local system is sending a Poll Sequence or is a\n         session
        of type MultipointHead soliciting the identities of the\n         tails, or
        zero if not.\n      Final (F)\n         Set to 1 if the local system is responding
        to a BFD Control\n         packet received with the Poll (P) bit set, or zero
        if not.\n      Control Plane Independent (C)\n         Set to 1 if the local
        system's BFD implementation is\n         independent of the control plane
        (it can continue to function\n         through a disruption of the control
        plane).\n      Authentication Present (A)\n         Set to 1 if authentication
        is in use in this session\n         (bfd.AuthType is nonzero), or zero if
        not.\n      Demand (D)\n         Set to bfd.DemandMode if bfd.SessionState
        is Up and\n         bfd.RemoteSessionState is Up.  Set to 1 if bfd.SessionType
        is\n         MultipointHead.  Otherwise, it is set to zero.\n      Multipoint
        (M)\n         Set to 1 if bfd.SessionType is MultipointHead.  Otherwise, it\n
        \        is set to zero.\n      Detect Mult\n         Set to bfd.DetectMult.\n
        \     Length\n         Set to the appropriate length, based on the fixed header
        length\n         (24) plus any Authentication Section.\n      My Discriminator\n
        \        Set to bfd.LocalDiscr.\n      Your Discriminator\n         Set to
        bfd.RemoteDiscr.\n      Desired Min TX Interval\n         Set to bfd.DesiredMinTxInterval.\n
        \     Required Min RX Interval\n         Set to bfd.RequiredMinRxInterval.\n
        \     Required Min Echo RX Interval\n         Set to zero if bfd.SessionType
        is MultipointHead or\n         MultipointTail.  Otherwise, set to the minimum
        required Echo\n         packet receive interval for this session.  If this
        field is set\n         to zero, the local system is unwilling or unable to
        loop back\n         BFD Echo packets to the remote system, and the remote
        system\n         will not send Echo packets.\n      Authentication Section\n
        \        Included and set according to the rules in Section 6.7 of\n         [RFC5880]
        if authentication is in use (bfd.AuthType is\n         nonzero).  Otherwise,
        this section is not present.\n"
      title: 5.13.3.  Transmitting BFD Control Packets
    title: 5.13.  Base Specification Text Replacement
  title: 5.  Protocol Details
- contents:
  - "6.  Congestion Considerations\n   As a foreword, although congestion can occur
    because of a number of\n   factors, it should be noted that high transmission
    rates are by\n   themselves subject to creating congestion either along the path
    or at\n   the tail end(s).  As such, as stated in [RFC5883]:\n      it is required
    that the operator correctly provision the rates at\n      which BFD is transmitted
    to avoid congestion (e.g link, I/O, CPU)\n      and false failure detection.\n
    \  Use of BFD in multipoint networks, as specified in this document,\n   over
    multiple hops requires consideration of the mechanisms to react\n   to network
    congestion.  Requirements stated in Section 7 of the BFD\n   base specification
    [RFC5880] equally apply to BFD in multipoint\n   networks and are repeated here:\n
    \     When BFD is used across multiple hops, a congestion control\n      mechanism
    MUST be implemented, and when congestion is detected,\n      the BFD implementation
    MUST reduce the amount of traffic it\n      generates.\n   The mechanism to control
    the load of BFD traffic MAY use BFD's\n   configuration interface to control BFD
    state variable\n   bfd.DesiredMinTxInterval.  However, such a control loop does
    not form\n   part of the BFD protocol itself, and its specification is thus\n
    \  outside the scope of this document.\n   Additional considerations apply to
    BFD in multipoint networks, as\n   specified in this document.  Indeed, because
    a tail does not transmit\n   any BFD Control packets to the head of the BFD session,
    such a head\n   node has no BFD-based mechanism and thus is not aware of the state
    of\n   the session at the tail.  In the absence of any other mechanism, the\n
    \  head of the session could thus continue to send packets towards the\n   tail(s)
    even though a link failure has happened.  In such a scenario,\n   when it is required
    for the head of the session to be aware of the\n   state of the tail of the session,
    it is RECOMMENDED to implement the\n   extension described in [RFC8563].\n"
  title: 6.  Congestion Considerations
- contents:
  - "7.  IANA Considerations\n   This document has no IANA actions.\n"
  title: 7.  IANA Considerations
- contents:
  - "8.  Security Considerations\n   The same security considerations as those described
    in [RFC5880]\n   apply to this document.  Additionally, implementations that create\n
    \  MultpointTail sessions dynamically upon receipt of multipoint BFD\n   Control
    packets MUST implement protective measures to prevent an\n   infinite number of
    MultipointTail sessions from being created.  Below\n   are some points to consider
    in such implementations.\n      If a multipoint BFD Control packet did not arrive
    on a multicast\n      path (e.g., on the expected interface, with the expected
    MPLS\n      label, etc.), a MultipointTail session should not be created.\n      If
    redundant streams are expected for a given multicast stream,\n      the implementations
    should not create more MultipointTail sessions\n      than the number of streams.
    \ Additionally, when the number of\n      MultipointTail sessions exceeds the
    number of expected streams,\n      the implementation should generate an alarm
    to users to indicate\n      the anomaly.\n      The implementation should have
    a reasonable upper bound on the\n      number of MultipointHead sessions that
    can be created, with the\n      upper bound potentially being computed based on
    the load these\n      would generate.\n      The implementation should have a
    reasonable upper bound on the\n      number of MultipointTail sessions that can
    be created, with the\n      upper bound potentially being computed based on the
    number of\n      multicast streams that the system is expecting.\n   If authentication
    is in use, the head and all tails may be configured\n   to have a common authentication
    key in order for the tails to\n   validate multipoint BFD Control packets.\n   Shared
    keys in multipoint scenarios allow any tail to spoof the head\n   from the viewpoint
    of any other tail.  For this reason, using shared\n   keys to authenticate BFD
    Control packets in multipoint scenarios is a\n   significant security exposure
    unless all tails can be trusted not to\n   spoof the head.  Otherwise, asymmetric
    message authentication would\n   be needed, e.g., protocols that use Timed Efficient
    Stream Loss-\n   Tolerant Authentication (TESLA) as described in [RFC4082].\n
    \  Applicability of the asymmetric message authentication to BFD for\n   multipoint
    networks is outside the scope of this specification and is\n   for further study.\n"
  title: 8.  Security Considerations
- contents:
  - '9.  References

    '
  - contents:
    - "9.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n
      \             DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n
      \  [RFC5880]  Katz, D. and D. Ward, \"Bidirectional Forwarding Detection\n              (BFD)\",
      RFC 5880, DOI 10.17487/RFC5880, June 2010,\n              <https://www.rfc-editor.org/info/rfc5880>.\n
      \  [RFC7880]  Pignataro, C., Ward, D., Akiya, N., Bhatia, M., and\n              S.
      Pallagatti, \"Seamless Bidirectional Forwarding\n              Detection (S-BFD)\",
      RFC 7880, DOI 10.17487/RFC7880, July\n              2016, <https://www.rfc-editor.org/info/rfc7880>.\n
      \  [RFC8029]  Kompella, K., Swallow, G., Pignataro, C., Ed., Kumar, N.,\n              Aldrin,
      S., and M. Chen, \"Detecting Multiprotocol Label\n              Switched (MPLS)
      Data-Plane Failures\", RFC 8029,\n              DOI 10.17487/RFC8029, March
      2017,\n              <https://www.rfc-editor.org/info/rfc8029>.\n   [RFC8174]
      \ Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n              2119
      Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n              May 2017,
      <https://www.rfc-editor.org/info/rfc8174>.\n"
    title: 9.1.  Normative References
  - contents:
    - "9.2.  Informative References\n   [MVPN-FAILOVER]\n              Morin, T.,
      Ed., Kebler, R., Ed., and G. Mirsky, Ed.,\n              \"Multicast VPN fast
      upstream failover\", Work in Progress,\n              draft-ietf-bess-mvpn-fast-failover-05,
      February 2019.\n   [RFC4082]  Perrig, A., Song, D., Canetti, R., Tygar, J.,
      and\n              B. Briscoe, \"Timed Efficient Stream Loss-Tolerant\n              Authentication
      (TESLA): Multicast Source Authentication\n              Transform Introduction\",
      RFC 4082, DOI 10.17487/RFC4082,\n              June 2005, <https://www.rfc-editor.org/info/rfc4082>.\n
      \  [RFC5883]  Katz, D. and D. Ward, \"Bidirectional Forwarding Detection\n              (BFD)
      for Multihop Paths\", RFC 5883, DOI 10.17487/RFC5883,\n              June 2010,
      <https://www.rfc-editor.org/info/rfc5883>.\n   [RFC6241]  Enns, R., Ed., Bjorklund,
      M., Ed., Schoenwaelder, J., Ed.,\n              and A. Bierman, Ed., \"Network
      Configuration Protocol\n              (NETCONF)\", RFC 6241, DOI 10.17487/RFC6241,
      June 2011,\n              <https://www.rfc-editor.org/info/rfc6241>.\n   [RFC8563]
      \ Katz, D., Ward, D., Pallagatti, S., Ed., and G. Mirsky,\n              Ed.,
      \"Bidirectional Forwarding Detection (BFD) Multipoint\n              Active
      Tails\", RFC 8563, DOI 10.17487/RFC8563, April 2019,\n              <https://www.rfc-editor.org/info/rfc8563>.\n"
    title: 9.2.  Informative References
  title: 9.  References
- contents:
  - "Acknowledgments\n   The authors would like to thank Nobo Akiya, Vengada Prasad
    Govindan,\n   Jeff Haas, Wim Henderickx, Gregory Mirsky, and Mingui Zhang who
    have\n   greatly contributed to this document.\n"
  title: Acknowledgments
- contents:
  - "Contributors\n   Rahul Aggarwal of Juniper Networks and George Swallow of Cisco\n
    \  Systems provided the initial idea for this specification and\n   contributed
    to its development.\n"
  title: Contributors
- contents:
  - "Authors' Addresses\n   Dave Katz\n   Juniper Networks\n   1194 N. Mathilda Ave.\n
    \  Sunnyvale, California  94089-1206\n   United States of America\n   Email: dkatz@juniper.net\n
    \  Dave Ward\n   Cisco Systems\n   170 West Tasman Dr.\n   San Jose, California
    \ 95134\n   United States of America\n   Email: wardd@cisco.com\n   Santosh Pallagatti
    (editor)\n   VMware\n   Email: santosh.pallagatti@gmail.com\n   Greg Mirsky (editor)\n
    \  ZTE Corp.\n   Email: gregimirsky@gmail.com\n"
  title: Authors' Addresses
