- title: __initial_text__
  contents:
  - ''
- title: Internet Research Task Force (IRTF)                              W. Eddy
  contents:
  - "Internet Research Task Force (IRTF)                              W. Eddy\n  \
    \         Using Self-Delimiting Numeric Values in Protocols\n"
- title: Abstract
  contents:
  - "Abstract\n   Self-Delimiting Numeric Values (SDNVs) have recently been introduced\n\
    \   as a field type in proposed Delay-Tolerant Networking protocols.\n   SDNVs\
    \ encode an arbitrary-length non-negative integer or arbitrary-\n   length bitstring\
    \ with minimum overhead.  They are intended to provide\n   protocol flexibility\
    \ without sacrificing economy and to assist in\n   future-proofing protocols under\
    \ development.  This document describes\n   formats and algorithms for SDNV encoding\
    \ and decoding, along with\n   notes on implementation and usage.  This document\
    \ is a product of the\n   Delay-Tolerant Networking Research Group and has been\
    \ reviewed by\n   that group.  No objections to its publication as an RFC were\
    \ raised.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Research Task Force\n   (IRTF).  The IRTF publishes the results\
    \ of Internet-related research\n   and development activities.  These results\
    \ might not be suitable for\n   deployment.  This RFC represents the consensus\
    \ of the Delay-Tolerant\n   Networking Research Group of the Internet Research\
    \ Task Force (IRTF).\n   Documents approved for publication by the IRSG are not\
    \ a candidate\n   for any level of Internet Standard; see Section 2 of RFC 5741.\n\
    \   Information about the current status of this document, any errata,\n   and\
    \ how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6256.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................2\n\
    \      1.1. Problems with Fixed-Value Fields ...........................3\n  \
    \    1.2. SDNVs for DTN Protocols ....................................4\n    \
    \  1.3. SDNV Usage .................................................5\n   2. Definition\
    \ of SDNVs .............................................6\n   3. Basic Algorithms\
    \ ................................................8\n      3.1. Encoding Algorithm\
    \ .........................................8\n      3.2. Decoding Algorithm .........................................9\n\
    \      3.3. Limitations of Implementations ............................10\n  \
    \ 4. Comparison to Alternatives .....................................10\n   5.\
    \ Security Considerations ........................................13\n   6. Acknowledgements\
    \ ...............................................13\n   7. Informative References\
    \ .........................................14\n   Appendix A. SDNV Python Source\
    \ Code ...............................15\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document is a product of the Internet Research Task\
    \ Force (IRTF)\n   Delay-Tolerant Networking (DTN) Research Group (DTNRG).  The\
    \ document\n   has received review and support within the DTNRG, as discussed\
    \ in the\n   Acknowledgements section of this document.\n   This document begins\
    \ by describing the drawbacks of using fixed-width\n   protocol fields.  It then\
    \ provides some background on the Self-\n   Delimiting Numeric Values (SDNVs)\
    \ proposed for use in DTN protocols,\n   and motivates their potential applicability\
    \ in other networking\n   protocols.  The DTNRG has created SDNVs to meet the\
    \ challenges it\n   attempts to solve, and it has been noted that SDNVs closely\
    \ resemble\n   certain constructs within ASN.1 and even older ITU protocols, so\
    \ the\n   problems are not new or unique to DTN.  SDNVs focus strictly on\n  \
    \ numeric values or bitstrings, while other mechanisms have been\n   developed\
    \ for encoding more complex data structures, such as ASN.1\n   encoding rules\
    \ and Haverty's Message Services Data Transmission\n   Protocol (MSDTP) [RFC0713].\
    \  Because of this focus, SDNVs can be\n   quickly implemented with only a small\
    \ amount of code.\n   SDNVs are tersely defined in both the Bundle Protocol [RFC5050]\
    \ and\n   Licklider Transmission Protocol (LTP) [RFC5326] specifications, due\n\
    \   to the flow of document production in the DTNRG.  This document\n   clarifies\
    \ and further explains the motivations and engineering\n   decisions behind SDNVs.\n"
- title: 1.1.  Problems with Fixed-Value Fields
  contents:
  - "1.1.  Problems with Fixed-Value Fields\n   Protocol designers commonly face an\
    \ optimization problem in\n   determining the proper size for header fields. \
    \ There is a strong\n   desire to keep fields as small as possible, in order to\
    \ reduce the\n   protocol's overhead and also allow for fast processing.  Since\n\
    \   protocols can be used for many years (even decades) after they are\n   designed,\
    \ and networking technology has tended to change rapidly, it\n   is not uncommon\
    \ for the use, deployment, or performance of a\n   particular protocol to be limited\
    \ or infringed upon by the length of\n   some header field being too short.  Two\
    \ well-known examples of this\n   phenomenon are the TCP-advertised receive window\
    \ and the IPv4 address\n   length.\n   TCP segments contain an advertised receive\
    \ window field that is fixed\n   at 16 bits [RFC0793], encoding a maximum value\
    \ of around 65\n   kilobytes.  The purpose of this value is to provide flow control,\
    \ by\n   allowing a receiver to specify how many sent bytes its peer can have\n\
    \   outstanding (unacknowledged) at any time, thus allowing the receiver\n   to\
    \ limit its buffer size.  As network speeds have grown by several\n   orders of\
    \ magnitude since TCP's inception, the combination of the 65\n   kilobyte maximum\
    \ advertised window and long round-trip times\n   prevented TCP senders from being\
    \ able to achieve the high throughput\n   that the underlying network supported.\
    \  This limitation was remedied\n   through the use of the Window Scale option\
    \ [RFC1323], which provides\n   a multiplier for the advertised window field.\
    \  However, the Window\n   Scale multiplier is fixed for the duration of the connection,\n\
    \   requires support from each end of a TCP connection, and limits the\n   precision\
    \ of the advertised receive window, so this is certainly a\n   less-than-ideal\
    \ solution.  Because of the field width limit in the\n   original design however,\
    \ the Window Scale is necessary for TCP to\n   reach high sending rates.\n   An\
    \ IPv4 address is fixed at 32 bits [RFC0791] (as a historical note,\n   an early\
    \ version of the IP header format specification in [IEN21]\n   used variable-length\
    \ addresses in multiples of 8 bits up to 120\n   bits).  Due to the way that subnetting\
    \ and assignment of address\n   blocks was performed, the number of IPv4 addresses\
    \ has been seen as a\n   limit to the growth of the Internet [Hain05].  Two divergent\
    \ paths to\n   solve this problem have been the use of Network Address Translators\n\
    \   (NATs) and the development of IPv6.  NATs have caused a number of\n   other\
    \ issues and problems [RFC2993], leading to increased complexity\n   and fragility,\
    \ as well as forcing workarounds to be engineered for\n   many other protocols\
    \ to function within a NATed environment.  The\n   IPv6 solution's transitional\
    \ work has been underway for several\n   years, but has still only just begun\
    \ to have visible impact on the\n   global Internet.\n   Of course, in both the\
    \ case of the TCP receive window and IPv4\n   address length, the field size chosen\
    \ by the designers seemed like a\n   good idea at the time.  The fields were more\
    \ than big enough for the\n   originally perceived usage of the protocols, and\
    \ yet were small\n   enough to allow the headers to remain compact and relatively\
    \ easy and\n   efficient to parse on machines of the time.  The fixed sizes that\n\
    \   were defined represented a trade-off between the scalability of the\n   protocol\
    \ versus the overhead and efficiency of processing.  In both\n   cases, these\
    \ engineering decisions turned out to be painfully\n   restrictive in the longer\
    \ term.\n"
- title: 1.2.  SDNVs for DTN Protocols
  contents:
  - "1.2.  SDNVs for DTN Protocols\n   In specifications for the DTN Bundle Protocol\
    \ (BP) [RFC5050] and\n   Licklider Transmission Protocol (LTP) [RFC5326], SDNVs\
    \ have been used\n   for several fields including identifiers, payload/header\
    \ lengths, and\n   serial (sequence) numbers.  SDNVs were developed for use in\
    \ these\n   types of fields, to avoid sending more bytes than needed, as well\
    \ as\n   avoiding fixed sizes that may not end up being appropriate.  For\n  \
    \ example, since LTP is intended primarily for use in long-delay\n   interplanetary\
    \ communications [RFC5325], where links may be fairly\n   low in capacity, it\
    \ is desirable to avoid the header overhead of\n   routinely sending a 64-bit\
    \ field where a 16-bit field would suffice.\n   Since many of the nodes implementing\
    \ LTP are expected to be beyond\n   the current range of human spaceflight, upgrading\
    \ their on-board LTP\n   implementations to use longer values if the defined fields\
    \ are found\n   to be too short would also be problematic.  Furthermore, extensions\n\
    \   similar in mechanism to TCP's Window Scale option are unsuitable for\n   use\
    \ in DTN protocols since, due to high delays, DTN protocols must\n   avoid handshaking\
    \ and configuration parameter negotiation to the\n   greatest extent possible.\
    \  All of these reasons make the choice of\n   SDNVs for use in DTN protocols\
    \ attractive.\n"
- title: 1.3.  SDNV Usage
  contents:
  - "1.3.  SDNV Usage\n   In short, an SDNV is simply a way of representing non-negative\n\
    \   integers (both positive integers of arbitrary magnitude and 0),\n   without\
    \ expending much unnecessary space.  This definition allows\n   SDNVs to represent\
    \ many common protocol header fields, such as:\n   o  Random identification fields\
    \ as used in the IPsec Security\n      Parameters Index or in IP headers for fragment\
    \ reassembly (Note:\n      the 16-bit IP ID field for fragment reassembly was\
    \ recently found\n      to be too short in some environments [RFC4963]).\n   o\
    \  Sequence numbers as in TCP or the Stream Control Transmission\n      Protocol\
    \ (SCTP).\n   o  Values used in cryptographic algorithms such as RSA keys, Diffie-\n\
    \      Hellman key agreement, or coordinates of points on elliptic\n      curves.\n\
    \   o  Message lengths as used in file transfer protocols.\n   o  Nonces and cookies.\n\
    \   As any bitfield can be interpreted as an unsigned integer, SDNVs can\n   also\
    \ encode arbitrary-length bitfields, including bitfields\n   representing signed\
    \ integers or other data types; however, this\n   document assumes SDNV encoding\
    \ and decoding in terms of unsigned\n   integers.  Implementations may differ\
    \ in the interface that they\n   provide to SDNV encoding and decoding functions,\
    \ in terms of whether\n   the values are numeric, bitfields, etc.; this detail\
    \ does not alter\n   the representation or algorithms described in this document.\n\
    \   The use of SDNVs rather than fixed-length fields gives protocol\n   designers\
    \ the ability to ameliorate the consequences of making\n   difficult-to-reverse\
    \ field-sizing decisions, as the SDNV format grows\n   and shrinks depending on\
    \ the particular value encoded.  SDNVs do not\n   necessarily provide optimal\
    \ encodings for values of any particular\n   length; however, they allow protocol\
    \ designers to avoid potential\n   blunders in assigning fixed lengths and remove\
    \ the complexity\n   involved with either negotiating field lengths or constructing\n\
    \   protocol extensions.  However, if SDNVs are used to encode bitfields,\n  \
    \ it is essential that the sender and receiver have a consistent\n   interpretation\
    \ of the decoded value.  This is discussed further in\n   Section 2.\n   To our\
    \ knowledge, at this time, no IETF transport or network-layer\n   protocol designed\
    \ for use outside of the DTN domain has proposed to\n   use SDNVs; however, there\
    \ is no inherent reason not to use SDNVs more\n   broadly in the future.  The\
    \ two examples cited here, of fields that\n   have proven too small in general\
    \ Internet protocols, are only a small\n   sampling of the much larger set of\
    \ similar instances that the authors\n   can think of.  Outside the Internet protocols,\
    \ within ASN.1 and\n   previous ITU protocols, constructs very similar to SDNVs\
    \ have been\n   used for many years due to engineering concerns very similar to\
    \ those\n   facing the DTNRG.\n   Many protocols use a Type-Length-Value method\
    \ for encoding variable-\n   length fields (e.g., TCP's options format or many\
    \ of the fields in\n   the Internet Key Exchange Protocol version 2 (IKEv2)).\
    \  An SDNV is\n   equivalent to combining the length and value portions of this\
    \ type of\n   field, with the overhead of the length portion amortized out over\
    \ the\n   bytes of the value.  The penalty paid for this in an SDNV may be\n \
    \  several extra bytes for long values (e.g., 1024-bit RSA keys).  See\n   Section\
    \ 4 for further discussion and a comparison.\n   As is shown in later sections,\
    \ for large values, the current SDNV\n   scheme is fairly inefficient in terms\
    \ of space (1/8 of the bits are\n   overhead) and not particularly easy to encode/decode\
    \ in comparison to\n   alternatives.  The best use of SDNVs may often be to define\
    \ the\n   Length field of a TLV structure to be an SDNV whose value is the\n \
    \  length of the TLV's Value field.  In this way, one can avoid forcing\n   large\
    \ numbers from being directly encoded as an SDNV, yet retain the\n   extensibility\
    \ that using SDNVs grants.\n"
- title: 2.  Definition of SDNVs
  contents:
  - "2.  Definition of SDNVs\n   Early in the work of the DTNRG, it was agreed that\
    \ the properties of\n   an SDNV were useful for DTN protocols.  The exact SDNV\
    \ format used by\n   the DTNRG evolved somewhat over time before the publication\
    \ of the\n   initial RFCs on LTP and BP.  An earlier version (see the initial\n\
    \   version of LTP Internet Draft [BRF04]) bore a resemblance to the\n   ASN.1\
    \ [ASN1] Basic Encoding Rules (BER) [X.690] for lengths (Section\n   8.1.3 of\
    \ X.690).  The current SDNV format is the one used by ASN.1\n   BER for encoding\
    \ tag identifiers greater than or equal to 31 (Section\n   8.1.2.4.2 of X.690).\
    \  A comparison between the current SDNV format\n   and the early SDNV format\
    \ is made in Section 4.\n   The format currently used is very simple.  Before\
    \ encoding, an\n   integer is represented as a left-to-right bitstring beginning\
    \ with\n   its most significant bit and ending with its least significant bit.\n\
    \   If the bitstring's length is not a multiple of 7, then the string is\n   left-padded\
    \ with zeros.  When transmitted, the bits are encoded into\n   a series of bytes.\
    \  The low-order 7 bits of each byte in the encoded\n   format are taken left-to-right\
    \ from the integer's bitstring\n   representation.  The most significant bit of\
    \ each byte specifies\n   whether it is the final byte of the encoded value (when\
    \ it holds a\n   0), or not (when it holds a 1).\n   For example:\n   o  1 (decimal)\
    \ is represented by the bitstring \"0000001\" and encoded\n      as the single\
    \ byte 0x01 (in hexadecimal).\n   o  128 is represented by the bitstring \"10000001\
    \ 00000000\" and\n      encoded as the bytes 0x81 followed by 0x00.\n   o  Other\
    \ values can be found in the test vectors of the source code\n      in Appendix\
    \ A.\n   To be perfectly clear, and avoid potential interoperability issues\n\
    \   (as have occurred with ASN.1 BER time values), we explicitly state\n   two\
    \ considerations regarding zero-padding. (1) When encoding SDNVs,\n   any leading\
    \ (most significant) zero bits in the input number might be\n   discarded by the\
    \ SDNV encoder.  Protocols that use SDNVs should not\n   rely on leading-zeros\
    \ being retained after encoding and decoding\n   operations. (2) When decoding\
    \ SDNVs, the relevant number of leading\n   zeros required to pad up to a machine\
    \ word or other natural data unit\n   might be added.  These are put in the most\
    \ significant positions in\n   order to not change the value of the number.  Protocols\
    \ using SDNVs\n   should consider situations where lost zero-padding may be\n\
    \   problematic.\n   The issues of zero-padding are particularly relevant where\
    \ an SDNV is\n   being used to represent a bitfield to be transmitted by a protocol.\n\
    \   The specification of the protocol and any associated IANA registry\n   should\
    \ specify the allocation and usage of bit positions within the\n   unencoded field.\
    \  Unassigned and reserved bits in the unencoded field\n   will be treated as\
    \ zeros by the SDNV encoding prior to transmission.\n   Assuming the bit positions\
    \ are numbered starting from 0 at the least\n   significant bit position in the\
    \ integer representation, then if\n   higher-numbered positions in the field contain\
    \ all zeros, the\n   encoding process may not transmit these bits explicitly (e.g.,\
    \ if all\n   the bit positions numbered 7 or higher are zeros, then the\n   transmitted\
    \ SDNV can consist of just one octet).  On reception, the\n   decoding process\
    \ will treat any untransmitted higher-numbered bits as\n   zeros.  To ensure correct\
    \ operation of the protocol, the sender and\n   receiver must have a consistent\
    \ interpretation of the width of the\n   bitfield.  This can be achieved in various\
    \ ways:\n   o  the bitfield width is implicitly defined by the version of the\n\
    \      protocol in use in the sender and receiver,\n   o  sending the width of\
    \ the bitfield explicitly in a separate item,\n   o  the higher-numbered bits\
    \ can be safely ignored by the receiver\n      (e.g., because they represent optimizations),\
    \ or\n   o  marking the highest-numbered bit by prepending a '1' bit to the\n\
    \      bitfield.\n   The protocol specification must record how the consistent\n\
    \   interpretation is achieved.\n   The SDNV encoding technique is also known\
    \ as Variable Byte Encoding\n   (see Section 5.3.1 of [Manning09]) and is equivalent\
    \ to Base-128\n   Elias Gamma Encoding (see Section 5.3.2 of [Manning09] and Section\n\
    \   3.5 of [Sayood02]).  However, the primary motivation for SDNVs is to\n   provide\
    \ an extensible protocol framework rather than optimal data\n   compression, which\
    \ is the motivation behind the other uses of the\n   technique.  [Manning09] points\
    \ out that the key feature of this\n   encoding is that it is \"prefix free\"\
    \ meaning that no code is a prefix\n   of any other, which is an alternative way\
    \ of expressing the self-\n   delimiting property.\n"
- title: 3.  Basic Algorithms
  contents:
  - "3.  Basic Algorithms\n   This section describes some simple algorithms for creating\
    \ and\n   parsing SDNV fields.  These may not be the most efficient algorithms\n\
    \   possible, however, they are easy to read, understand, and implement.\n   Appendix\
    \ A contains Python source code implementing the routines\n   described here.\
    \  The algorithms presented here are convenient for\n   converting between an\
    \ internal data block and serialized data stream\n   associated with a transmission\
    \ device.  Other approaches are possible\n   with different efficiencies and trade-offs.\n"
- title: 3.1.  Encoding Algorithm
  contents:
  - "3.1.  Encoding Algorithm\n   There is a very simple algorithm for the encoding\
    \ operation that\n   converts a non-negative integer (value n, of length 1+floor(log\
    \ n)\n   bits) into an SDNV.  This algorithm takes n as its only argument and\n\
    \   returns a string of bytes:\n   o  (Initial Step) Set a variable X to a byte\
    \ sharing the least\n      significant 7 bits of n, and with 0 in the most significant\
    \ bit,\n      and a variable Y to n, right-shifted by 7 bits.\n   o  (Recursion\
    \ Step) If Y == 0, return X.  Otherwise, set Z to the\n      bitwise-or of 0x80\
    \ with the 7 least significant bits of Y, and\n      append Z to X.  Right-shift\
    \ Y by 7 bits and repeat the Recursion\n      Step.\n   This encoding algorithm\
    \ has a time complexity of O(log n), since it\n   takes a number of steps equal\
    \ to ceil(n/7), and no additional space\n   beyond the size of the result (8/7\
    \ log n) is required.  One aspect of\n   this algorithm is that it assumes strings\
    \ can be efficiently appended\n   to new bytes.  One way to implement this is\
    \ to allocate a buffer for\n   the expected length of the result and fill that\
    \ buffer one byte at a\n   time from the right end.\n   If, for some reason, an\
    \ implementation requires an encoded SDNV to be\n   some specific length (possibly\
    \ related to a machine word), any\n   leftmost zero-padding included needs to\
    \ properly set the high-order\n   bit in each byte of padding.\n"
- title: 3.2.  Decoding Algorithm
  contents:
  - "3.2.  Decoding Algorithm\n   Decoding SDNVs is a more difficult operation than\
    \ encoding them, due\n   to the fact that no bound on the resulting value is known\
    \ until the\n   SDNV is parsed, at which point the value itself is already known.\n\
    \   This means that if space is allocated in advance to hold the value\n   that\
    \ results from decoding an SDNV, in general, it is not known\n   whether this\
    \ space will be large enough until it is 7 bits away from\n   being overflowed.\
    \  However, as specified in Section 3.3, protocols\n   using SDNVs must specify\
    \ the largest number of bits that an\n   implementation is expected to handle,\
    \ which mitigates this problem.\n   o  (Initial Step) Set the result to 0.  Set\
    \ an index to the first\n      byte of the encoded SDNV.\n   o  (Recursion Step)\
    \ Shift the result left 7 bits.  Add the low-order\n      7 bits of the value\
    \ at the index to the result.  If the high-order\n      bit under the pointer\
    \ is a 1, advance the index by one byte within\n      the encoded SDNV and repeat\
    \ the Recursion Step, otherwise return\n      the current value of the result.\n\
    \   This decoding algorithm takes no more additional space than what is\n   required\
    \ for the result (7/8 the length of the SDNV) and the pointer.\n   The complication\
    \ is that before the result can be left-shifted in the\n   Recursion Step, an\
    \ implementation needs to first make sure that this\n   will not cause any bits\
    \ to be lost, and re-allocate a larger piece of\n   memory for the result, if\
    \ required.  The pure time complexity is the\n   same as for the encoding algorithm\
    \ given, but if re-allocation is\n   needed due to the inability to predict the\
    \ size of the result,\n   decoding may be slower.\n   These decoding steps include\
    \ removal of any leftmost zero-padding\n   that might be used by an encoder to\
    \ create encodings of a certain\n   length.\n"
- title: 3.3.  Limitations of Implementations
  contents:
  - "3.3.  Limitations of Implementations\n   Because of efficiency considerations\
    \ or convenience of internal\n   representation of decoded integers, implementations\
    \ may choose to\n   limit the number of bits in SDNVs that they will handle. \
    \ To avoid\n   interoperability problems, any protocol that uses SDNVs must specify\n\
    \   the largest number of bits in an SDNV that an implementation of that\n   protocol\
    \ is expected to handle.\n   For example, Section 4.1 of [RFC5050] specifies that\
    \ implementations\n   of the DTN Bundle Protocol are not required to handle SDNVs\
    \ with more\n   than 64 bits in their unencoded value.  Accordingly, integer values\n\
    \   transmitted in SDNVs have an upper limit and SDNV-encoded flag fields\n  \
    \ must be limited to 64 bit positions in any future revisions of the\n   protocol\
    \ unless the restriction is altered.\n"
- title: 4.  Comparison to Alternatives
  contents:
  - "4.  Comparison to Alternatives\n   This section compares three alternative ways\
    \ of implementing the\n   concept of SDNVs: (1) the TLV scheme commonly used in\
    \ the Internet\n   family, and many other families of protocols, (2) the old style\
    \ of\n   SDNVs (both the SDNV-8 and SDNV-16) defined in an early stage of\n  \
    \ LTP's development [BRF04], and (3) the current SDNV format.\n   The TLV method\
    \ uses two fixed-length fields to hold the Type and\n   Length elements that then\
    \ imply the syntax and semantics of the Value\n   element.  This is only similar\
    \ to an SDNV in that the value element\n   can grow or shrink within the bounds\
    \ capable of being conveyed by the\n   Length field.  Two fundamental differences\
    \ between TLVs and SDNVs are\n   that through the Type element, TLVs also contain\
    \ some notion of what\n   their contents are semantically, while SDNVs are simply\
    \ generic non-\n   negative integers, and protocol engineers still have to choose\
    \ fixed-\n   field lengths for the Type and Length fields in the TLV format.\n\
    \   Some protocols use TLVs where the value conveyed within the Length\n   field\
    \ needs to be decoded into the actual length of the Value field.\n   This may\
    \ be accomplished through simple multiplication, left-\n   shifting, or a look-up\
    \ table.  In any case, this tactic limits the\n   granularity of the possible\
    \ Value lengths, and can contribute some\n   degree of bloat if Values do not\
    \ fit neatly within the available\n   decoded Lengths.\n   In the SDNV format\
    \ originally used by LTP, parsing the first byte of\n   the SDNV told an implementation\
    \ how much space was required to hold\n   the contained value.  There were two\
    \ different types of SDNVs defined\n   for different ranges of use.  The SDNV-8\
    \ type could hold values up to\n   127 in a single byte, while the SDNV-16 type\
    \ could hold values up to\n   32,767 in 2 bytes.  Both formats could encode values\
    \ requiring up to\n   N bytes in N+2 bytes, where N<127.  The major difference\
    \ between this\n   old SDNV format and the current SDNV format is that the new\
    \ format is\n   not as easily decoded as the old format was, but the new format\
    \ also\n   has absolutely no limitation on its length.\n   The advantage in ease\
    \ of parsing the old format manifests itself in\n   two aspects: (1) the size\
    \ of the value is determinable ahead of time,\n   in a way equivalent to parsing\
    \ a TLV, and (2) the actual value is\n   directly encoded and decoded, without\
    \ shifting and masking bits as is\n   required in the new format.  For these reasons,\
    \ the old format\n   requires less computational overhead to deal with, but is\
    \ also very\n   limited in that it can only hold a 1024-bit number, at maximum.\n\
    \   Since according to IETF Best Current Practices, an asymmetric\n   cryptography\
    \ key needed to last for a long term requires using moduli\n   of over 1228 bits\
    \ [RFC3766], this could be seen as a severe\n   limitation of the old style of\
    \ SDNVs, from which the currently used\n   style does not suffer.\n   Table 1\
    \ compares the maximum values that can be encoded into SDNVs of\n   various lengths\
    \ using the old SDNV-8/16 method and the current SDNV\n   method.  The only place\
    \ in this table where SDNV-16 is used rather\n   than SDNV-8 is in the 2-byte\
    \ row.  Starting with a single byte, the\n   two methods are equivalent, but when\
    \ using 2 bytes, the old method is\n   a more compact encoding by one bit.  From\
    \ 3 to 7 bytes of length\n   though, the current SDNV format is more compact,\
    \ since it only\n   requires one bit per byte of overhead, whereas the old format\
    \ used a\n   full byte.  Thus, at 8 bytes, both schemes are equivalent in\n  \
    \ efficiency since they both use 8 bits of overhead.  Up to 129 bytes,\n   the\
    \ old format is more compact than the current one, although after\n   this, limit\
    \ it becomes unusable.\n   +-------+---------------+-------------+---------------+-------------+\n\
    \   | Bytes |   SDNV-8/16   |     SDNV    |   SDNV-8/16   |     SDNV    |\n  \
    \ |       | Maximum Value |   Maximum   | Overhead Bits |   Overhead  |\n   |\
    \       |               |    Value    |               |     Bits    |\n   +-------+---------------+-------------+---------------+-------------+\n\
    \   |   1   |      127      |     127     |       1       |      1      |\n  \
    \ |       |               |             |               |             |\n   |\
    \   2   |     32,767    |    16,383   |       1       |      2      |\n   |  \
    \     |               |             |               |             |\n   |   3\
    \   |     65,535    |  2,097,151  |       8       |      3      |\n   |      \
    \ |               |             |               |             |\n   |   4   |\
    \    2^24 - 1   |   2^28 - 1  |       8       |      4      |\n   |       |  \
    \             |             |               |             |\n   |   5   |    2^32\
    \ - 1   |   2^35 - 1  |       8       |      5      |\n   |       |          \
    \     |             |               |             |\n   |   6   |    2^40 - 1\
    \   |   2^42 - 1  |       8       |      6      |\n   |       |              \
    \ |             |               |             |\n   |   7   |    2^48 - 1   |\
    \   2^49 - 1  |       8       |      7      |\n   |       |               |  \
    \           |               |             |\n   |   8   |    2^56 - 1   |   2^56\
    \ - 1  |       8       |      8      |\n   |       |               |         \
    \    |               |             |\n   |   9   |    2^64 - 1   |   2^63 - 1\
    \  |       8       |      9      |\n   |       |               |             |\
    \               |             |\n   |   10  |    2^72 - 1   |   2^70 - 1  |  \
    \     8       |      10     |\n   |       |               |             |    \
    \           |             |\n   |   16  |   2^120 - 1   |  2^112 - 1  |      \
    \ 8       |      16     |\n   |       |               |             |        \
    \       |             |\n   |   32  |   2^248 - 1   |  2^224 - 1  |       8  \
    \     |      32     |\n   |       |               |             |            \
    \   |             |\n   |   64  |   2^504 - 1   |  2^448 - 1  |       8      \
    \ |      64     |\n   |       |               |             |               |\
    \             |\n   |  128  |   2^1016 - 1  |  2^896 - 1  |       8       |  \
    \   128     |\n   |       |               |             |               |    \
    \         |\n   |  129  |   2^1024 - 1  |  2^903 - 1  |       8       |     129\
    \     |\n   |       |               |             |               |          \
    \   |\n   |  130  |      N/A      |  2^910 - 1  |      N/A      |     130    \
    \ |\n   |       |               |             |               |             |\n\
    \   |  256  |      N/A      |  2^1792 - 1 |      N/A      |     256     |\n  \
    \ +-------+---------------+-------------+---------------+-------------+\n    \
    \                              Table 1\n   Suggested usages of the SDNV format\
    \ that leverage its strengths and\n   limit the effects of its weaknesses are\
    \ discussed in Section 1.3.\n   Another aspect of the comparison between SDNVs\
    \ and alternatives using\n   fixed-length fields is the result of errors in transmission.\
    \  Bit-\n   errors in an SDNV can result in either errors in the decoded value,\n\
    \   or parsing errors in subsequent fields of the protocol.  In fixed-\n   length\
    \ fields, bit errors always result in errors to the decoded\n   value rather than\
    \ parsing errors in subsequent fields.  If the\n   decoded values from either\
    \ type of field encoding (SDNV or fixed-\n   length) are used as indexes, offsets,\
    \ or lengths of further fields in\n   the protocol, similar failures result.\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   The only security considerations with regard\
    \ to SDNVs are that code\n   that parses SDNVs should have bounds-checking logic\
    \ and be capable of\n   handling cases where an SDNV's value is beyond the code's\
    \ ability to\n   parse.  These precautions can prevent potential exploits involving\n\
    \   SDNV decoding routines.\n   Stephen Farrell noted that very early definitions\
    \ of SDNVs also\n   allowed negative integers.  This was considered a potential\
    \ security\n   hole, since it could expose implementations to underflow attacks\n\
    \   during SDNV decoding.  There is a precedent in that many existing TLV\n  \
    \ decoders map the Length field to a signed integer and are vulnerable\n   in\
    \ this way.  An SDNV decoder should be based on unsigned types and\n   not have\
    \ this issue.\n"
- title: 6.  Acknowledgements
  contents:
  - "6.  Acknowledgements\n   Scott Burleigh, Manikantan Ramadas, Michael Demmer,\
    \ Stephen Farrell,\n   and other members of the IRTF DTN Research Group contributed\
    \ to the\n   development and usage of SDNVs in DTN protocols.  George Jones and\n\
    \   Keith Scott from Mitre, Lloyd Wood, Gerardo Izquierdo, Joel Halpern,\n   Peter\
    \ TB Brett, Kevin Fall, and Elwyn Davies also contributed useful\n   comments\
    \ on and criticisms of this document.  DTNRG last call\n   comments on the document\
    \ were sent to the mailing list by Lloyd Wood,\n   Will Ivancic, Jim Wyllie, William\
    \ Edwards, Hans Kruse, Janico\n   Greifenberg, Teemu Karkkainen, Stephen Farrell,\
    \ and Scott Burleigh.\n   Further constructive comments from Dave Crocker, Lachlan\
    \ Andrew, and\n   Michael Welzl were incorporated.\n   Work on this document was\
    \ performed at NASA's Glenn Research Center,\n   in support of the NASA Space\
    \ Communications Architecture Working\n   Group (SCAWG), NASA's Earth Science\
    \ Technology Office (ESTO), and the\n   FAA/Eurocontrol Future Communications\
    \ Study (FCS) in the 2005-2007\n   time frame, while the editor was an employee\
    \ of Verizon Federal\n   Network Systems.\n"
- title: 7.  Informative References
  contents:
  - "7.  Informative References\n   [ASN1]       ITU-T Rec. X.680, \"Abstract Syntax\
    \ Notation One (ASN.1).\n                Specification of Basic Notation\", ISO/IEC\
    \ 8824-1:2002,\n                2002.\n   [BRF04]      Burleigh, S., Ramadas,\
    \ M., and S. Farrell, \"Licklider\n                Transmission Protocol\", Work\
    \ in Progress, May 2004.\n   [Hain05]     Hain, T., \"A Pragmatic Report on IPv4\
    \ Address Space\n                Consumption\", Internet Protocol Journal Vol.\
    \ 8, No. 3,\n                September 2005.\n   [IEN21]      Cerf, V. and J.\
    \ Postel, \"Specification of Internetwork\n                Transmission Control\
    \ Program: TCP Version 3\", Internet\n                Experimental Note 21, January\
    \ 1978.\n   [Manning09]  Manning, c., Raghavan, P., and H. Schuetze,\n       \
    \         \"Introduction to Information Retrieval\", Cambridge\n             \
    \   University Press ISBN-13: 978-0521865715, 2009,\n                <http://informationretrieval.org/>.\n\
    \   [RFC0713]    Haverty, J., \"MSDTP-Message Services Data Transmission\n   \
    \             Protocol\", RFC 713, April 1976.\n   [RFC0791]    Postel, J., \"\
    Internet Protocol\", STD 5, RFC 791,\n                September 1981.\n   [RFC0793]\
    \    Postel, J., \"Transmission Control Protocol\", STD 7,\n                RFC\
    \ 793, September 1981.\n   [RFC1323]    Jacobson, V., Braden, B., and D. Borman,\
    \ \"TCP Extensions\n                for High Performance\", RFC 1323, May 1992.\n\
    \   [RFC2993]    Hain, T., \"Architectural Implications of NAT\", RFC 2993,\n\
    \                November 2000.\n   [RFC3766]    Orman, H. and P. Hoffman, \"\
    Determining Strengths For\n                Public Keys Used For Exchanging Symmetric\
    \ Keys\", BCP 86,\n                RFC 3766, April 2004.\n   [RFC4963]    Heffner,\
    \ J., Mathis, M., and B. Chandler, \"IPv4\n                Reassembly Errors at\
    \ High Data Rates\", RFC 4963,\n                July 2007.\n   [RFC5050]    Scott,\
    \ K. and S. Burleigh, \"Bundle Protocol\n                Specification\", RFC\
    \ 5050, November 2007.\n   [RFC5325]    Burleigh, S., Ramadas, M., and S. Farrell,\
    \ \"Licklider\n                Transmission Protocol - Motivation\", RFC 5325,\n\
    \                September 2008.\n   [RFC5326]    Ramadas, M., Burleigh, S., and\
    \ S. Farrell, \"Licklider\n                Transmission Protocol - Specification\"\
    , RFC 5326,\n                September 2008.\n   [Sayood02]   Sayood, K., \"Lossless\
    \ Data Compression\", Academic\n                Press ISBN-13: 978-0126208610,\
    \ December 2002,\n                <http://books.google.co.uk/books?id=LjQiGwyabVwC>.\n\
    \   [X.690]      ITU-T Rec. X.690, \"Abstract Syntax Notation One (ASN.1).\n \
    \               Encoding Rules: Specification of Basic Encoding Rules\n      \
    \          (BER), Canonical Encoding Rules (CER) and Distinguished\n         \
    \       Encoding Rules (DER)\", ISO/IEC 8825-1:2002, 2002.\n"
- title: Appendix A.  SDNV Python Source Code
  contents:
  - "Appendix A.  SDNV Python Source Code\n   #  This code may be freely copied. \
    \ Attribution would be appreciated.\n   #\n   # sdnv_decode() takes a string argument\
    \ (s), which is assumed to be\n   #   an SDNV, and optionally a number (slen)\
    \ for the maximum number of\n   #   bytes to parse from the string.  The function\
    \ returns a pair of\n   #   the non-negative integer n that is the numeric value\
    \ encoded in\n   #   the SDNV, and integer that is the distance parsed into the\
    \ input\n   #   string.  If the slen argument is not given (or is not a non-zero\n\
    \   #   number) then, s is parsed up to the first byte whose high-order\n   #\
    \   bit is 0 -- the length of the SDNV portion of s does not have to\n   #   be\
    \ pre-computed by calling code.  If the slen argument is given\n   #   as a non-zero\
    \ value, then slen bytes of s are parsed.  The value\n   #   for n of -1 is returned\
    \ for any type of parsing error.\n   #\n   # NOTE: In python, integers can be\
    \ of arbitrary size.  In other\n   #   languages, such as C, SDNV-parsing routines\
    \ should take\n   #   precautions to avoid overflow (e.g., by using the Gnu MP\
    \ library,\n   #   or similar).\n   #\n   def sdnv_decode(s, slen=0):\n     n\
    \ = long(0)\n     for i in range(0, len(s)):\n       v = ord(s[i])\n       n =\
    \ n<<7\n       n = n + (v & 0x7F)\n       if v>>7 == 0:\n         slen = i+1\n\
    \         break\n       elif i == len(s)-1 or (slen != 0 and i > slen):\n    \
    \     n = -1 # reached end of input without seeing end of SDNV\n     return (n,\
    \ slen)\n   # sdnv_encode() returns the SDNV-encoded string that represents n.\n\
    \   #   An empty string is returned if n is not a non-negative integer\n   def\
    \ sdnv_encode(n):\n     r = \"\"\n     # validate input\n     if n >= 0 and (type(n)\
    \ in [type(int(1)), type(long(1))]):\n       flag = 0\n       done = False\n \
    \      while not done:\n         # encode lowest 7 bits from n\n         newbits\
    \ = n & 0x7F\n         n = n>>7\n         r = chr(newbits + flag) + r\n      \
    \   if flag == 0:\n           flag = 0x80\n         if n == 0:\n           done\
    \ = True\n     return r\n   # test cases from LTP and BP internet-drafts, only\
    \ print failures\n   def sdnv_test():\n     tests = [(0xABC, chr(0x95) + chr(0x3C)),\n\
    \              (0x1234, chr(0xA4) + chr (0x34)),\n              (0x4234, chr(0x81)\
    \ + chr(0x84) + chr(0x34)),\n              (0x7F, chr(0x7F))]\n     for tp in\
    \ tests:\n       # test encoding function\n       if sdnv_encode(tp[0]) != tp[1]:\n\
    \         print \"sdnv_encode fails on input %s\" % hex(tp[0])\n       # test\
    \ decoding function\n       if sdnv_decode(tp[1])[0] != tp[0]:\n         print\
    \ \"sdnv_decode fails on input %s, giving %s\" % \\\n               (hex(tp[0]),\
    \ sdnv_decode(tp[1]))\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Wesley M. Eddy\n   MTI Systems\n   NASA Glenn Research\
    \ Center\n   MS 500-ASRC; 21000 Brookpark Rd\n   Cleveland, OH  44135\n   Phone:\
    \ 216-433-6682\n   EMail: wes@mti-systems.com\n   Elwyn Davies\n   Folly Consulting\n\
    \   Soham\n   UK\n   Phone:\n   EMail: elwynd@folly.org.uk\n   URI:\n"
