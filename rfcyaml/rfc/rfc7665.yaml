- title: __initial_text__
  contents:
  - '              Service Function Chaining (SFC) Architecture

    '
- title: Abstract
  contents:
  - "Abstract\n   This document describes an architecture for the specification,\n\
    \   creation, and ongoing maintenance of Service Function Chains (SFCs)\n   in\
    \ a network.  It includes architectural concepts, principles, and\n   components\
    \ used in the construction of composite services through\n   deployment of SFCs,\
    \ with a focus on those to be standardized in the\n   IETF.  This document does\
    \ not propose solutions, protocols, or\n   extensions to existing protocols.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc7665.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2015 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   4\n     1.1.  Scope . . . . . . . . . . . . . . . . . . . . . .\
    \ . . . .   4\n     1.2.  Assumptions . . . . . . . . . . . . . . . . . . . .\
    \ . . .   5\n     1.3.  Specification of Requirements . . . . . . . . . . . .\
    \ . .   5\n     1.4.  Definition of Terms . . . . . . . . . . . . . . . . . .\
    \ .   6\n   2.  Architectural Concepts  . . . . . . . . . . . . . . . . . . .\
    \   8\n     2.1.  Service Function Chains . . . . . . . . . . . . . . . . .  \
    \ 8\n     2.2.  Service Function Chain Symmetry . . . . . . . . . . . . .   9\n\
    \     2.3.  Service Function Paths  . . . . . . . . . . . . . . . . .  10\n  \
    \     2.3.1.  Service Function Chains, Service Function Paths, and\n         \
    \      Rendered Service Path . . . . . . . . . . . . . . . .  11\n   3.  Architecture\
    \ Principles . . . . . . . . . . . . . . . . . . .  12\n   4.  Core SFC Architecture\
    \ Components  . . . . . . . . . . . . . .  13\n     4.1.  SFC Encapsulation .\
    \ . . . . . . . . . . . . . . . . . . .  14\n     4.2.  Service Function (SF)\
    \ . . . . . . . . . . . . . . . . . .  15\n     4.3.  Service Function Forwarder\
    \ (SFF)  . . . . . . . . . . . .  15\n       4.3.1.  Transport-Derived SFF . .\
    \ . . . . . . . . . . . . . .  17\n     4.4.  SFC-Enabled Domain  . . . . . .\
    \ . . . . . . . . . . . . .  17\n     4.5.  Network Overlay and Network Components\
    \  . . . . . . . . .  18\n     4.6.  SFC Proxy . . . . . . . . . . . . . . . .\
    \ . . . . . . . .  18\n     4.7.  Classification  . . . . . . . . . . . . . .\
    \ . . . . . . .  19\n     4.8.  Reclassification and Branching  . . . . . . .\
    \ . . . . . .  19\n     4.9.  Shared Metadata . . . . . . . . . . . . . . . .\
    \ . . . . .  20\n   5.  Additional Architectural Concepts . . . . . . . . . .\
    \ . . . .  21\n     5.1.  The Role of Policy  . . . . . . . . . . . . . . . .\
    \ . . .  21\n     5.2.  SFC Control Plane . . . . . . . . . . . . . . . . . .\
    \ . .  21\n     5.3.  Resource Control  . . . . . . . . . . . . . . . . . . .\
    \ .  22\n     5.4.  Infinite Loop Detection and Avoidance . . . . . . . . . .\
    \  23\n     5.5.  Load-Balancing Considerations . . . . . . . . . . . . . .  23\n\
    \     5.6.  MTU and Fragmentation Considerations  . . . . . . . . . .  24\n  \
    \   5.7.  SFC OAM . . . . . . . . . . . . . . . . . . . . . . . . .  25\n    \
    \ 5.8.  Resilience and Redundancy . . . . . . . . . . . . . . . .  26\n   6. \
    \ Security Considerations . . . . . . . . . . . . . . . . . . .  27\n   7.  References\
    \  . . . . . . . . . . . . . . . . . . . . . . . . .  29\n     7.1.  Normative\
    \ References  . . . . . . . . . . . . . . . . . .  29\n     7.2.  Informative\
    \ References  . . . . . . . . . . . . . . . . .  29\n   Acknowledgments . . .\
    \ . . . . . . . . . . . . . . . . . . . . . .  30\n   Contributors  . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . .  31\n   Authors' Addresses  . . .\
    \ . . . . . . . . . . . . . . . . . . . .  32\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   The delivery of end-to-end services often requires various\
    \ service\n   functions.  These include traditional network service functions\
    \ such\n   as firewalls and traditional IP Network Address Translators (NATs),\n\
    \   as well as application-specific functions.  The definition and\n   instantiation\
    \ of an ordered set of service functions and subsequent\n   \"steering\" of traffic\
    \ through them is termed Service Function\n   Chaining (SFC).\n   This document\
    \ describes an architecture used for the creation and\n   ongoing maintenance\
    \ of Service Function Chains (SFCs) in a network.\n   It includes architectural\
    \ concepts, principles, and components, with\n   a focus on those to be standardized\
    \ in the IETF.  SFCs enable\n   composite services that are constructed from one\
    \ or more service\n   functions.\n   An overview of the issues associated with\
    \ the deployment of end-to-\n   end service function chains, abstract sets of\
    \ service functions and\n   their ordering constraints that create a composite\
    \ service, and the\n   subsequent \"steering\" of traffic flows through said service\n\
    \   functions, is described in [RFC7498].\n   The current service function deployment\
    \ models are relatively static,\n   coupled to network topology and physical resources,\
    \ greatly reducing\n   or eliminating the ability of an operator to introduce\
    \ new services\n   or dynamically create service function chains.  This architecture\n\
    \   presents a model addressing the problematic aspects of existing\n   service\
    \ deployments, including topological independence and\n   configuration complexity.\n"
- title: 1.1.  Scope
  contents:
  - "1.1.  Scope\n   This document defines the architecture for Service Function Chaining\n\
    \   (SFC) as standardized in the IETF.  The SFC architecture is\n   predicated\
    \ on topological independence from the underlying forwarding\n   topology.\n \
    \  In this architecture, packets are classified on ingress for handling\n   by\
    \ the required set of Service Functions (SFs) in the SFC-enabled\n   domain and\
    \ are then forwarded through that set of functions for\n   processing by each\
    \ function in turn.  Packets may be reclassified as\n   a result of this processing.\n\
    \   The architecture described in this document is independent of the\n   planned\
    \ usage of the network and deployment context and thus, for\n   example, is applicable\
    \ to both fixed and mobile networks as well as\n   being useful in many data center\
    \ applications.\n   The architecture described herein is assumed to be applicable\
    \ to a\n   single network administrative domain.  While it is possible for the\n\
    \   architectural principles and components to be applied to inter-domain\n  \
    \ SFCs, these are left for future study.\n"
- title: 1.2.  Assumptions
  contents:
  - "1.2.  Assumptions\n   The following assumptions are made:\n   o  There is no\
    \ standard definition or characterization applicable to\n      all SFs, and thus\
    \ the architecture considers each SF as an opaque\n      processing element.\n\
    \   o  There is no global or standard list of SFs enabled in a given\n      administrative\
    \ domain.  The set of SFs enabled in a given domain\n      is a function of the\
    \ currently active services that may vary with\n      time and according to the\
    \ networking environment.\n   o  There is no global or standard SF chaining logic.\
    \  The ordered set\n      of SFs that needs to be applied to deliver a given service\
    \ is\n      specific to each administrative entity.\n   o  The chaining of SFs\
    \ and the criteria to invoke them are specific\n      to each administrative entity\
    \ that operates an SF-enabled domain.\n   o  Several SF chaining policies can\
    \ be simultaneously applied within\n      an administrative domain to meet various\
    \ business requirements.\n   o  The underlay is assumed to provide the necessary\
    \ connectivity to\n      interconnect the Service Function Forwarders (SFFs; see\n\
    \      Section 1.4), but the architecture places no constraints on how\n     \
    \ that connectivity is realized other than it have the required\n      bandwidth,\
    \ latency, and jitter to support the SFC.\n   o  No assumption is made on how\
    \ Forwarding Information Bases (FIBs)\n      and Routing Information Bases (RIBs)\
    \ of involved nodes are\n      populated.\n   o  How to bind traffic to a given\
    \ SF chain is policy-based.\n"
- title: 1.3.  Specification of Requirements
  contents:
  - "1.3.  Specification of Requirements\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in [RFC2119].\n"
- title: 1.4.  Definition of Terms
  contents:
  - "1.4.  Definition of Terms\n   Network Service:  An offering provided by an operator\
    \ that is\n        delivered using one or more service functions.  This may also\
    \ be\n        referred to as a \"composite service\".  The term \"service\" is\n\
    \        used to denote a \"network service\" in the context of this\n       \
    \ document.\n        Note: Beyond this document, the term \"service\" is overloaded\n\
    \        with varying definitions.  For example, to some a service is an\n   \
    \     offering composed of several elements within the operator's\n        network,\
    \ whereas for others a service, or more specifically a\n        network service,\
    \ is a discrete element such as a \"firewall\".\n        Traditionally, such services\
    \ (in the latter sense) host a set of\n        service functions and have a network\
    \ locator where the service\n        is hosted.\n   Classification:  Locally instantiated\
    \ matching of traffic flows\n        against policy for subsequent application\
    \ of the required set of\n        network service functions.  The policy may be\
    \ customer/network/\n        service specific.\n   Classifier:  An element that\
    \ performs Classification.\n   Service Function Chain (SFC):  A service function\
    \ chain defines an\n        ordered set of abstract service functions and ordering\n\
    \        constraints that must be applied to packets and/or frames and/or\n  \
    \      flows selected as a result of classification.  An example of an\n     \
    \   abstract service function is \"a firewall\".  The implied order\n        may\
    \ not be a linear progression as the architecture allows for\n        SFCs that\
    \ copy to more than one branch, and also allows for\n        cases where there\
    \ is flexibility in the order in which service\n        functions need to be applied.\
    \  The term \"service chain\" is often\n        used as shorthand for service\
    \ function chain.\n   Service Function (SF):  A function that is responsible for\
    \ specific\n        treatment of received packets.  A Service Function can act\
    \ at\n        various layers of a protocol stack (e.g., at the network layer\n\
    \        or other OSI layers).  As a logical component, a service\n        function\
    \ can be realized as a virtual element or be embedded in\n        a physical network\
    \ element.  One or more Service Functions can\n        be embedded in the same\
    \ network element.  Multiple occurrences\n        of the service function can\
    \ exist in the same administrative\n        domain.\n        One or more service\
    \ functions can be involved in the delivery of\n        added-value services.\
    \  A non-exhaustive list of abstract service\n        functions includes: firewalls,\
    \ WAN and application acceleration,\n        Deep Packet Inspection (DPI), Lawful\
    \ Intercept (LI), server load\n        balancing, NAT44 [RFC3022], NAT64 [RFC6146],\
    \ NPTv6 [RFC6296],\n        HOST_ID injection, HTTP Header Enrichment functions,\
    \ and TCP\n        optimizer.\n        An SF may be SFC encapsulation aware (that\
    \ is, it receives and\n        acts on information in the SFC encapsulation) or\
    \ unaware (in\n        which case, data forwarded to the SF does not contain the\
    \ SFC\n        encapsulation).  This is often referred to as \"SFC aware\" and\n\
    \        \"SFC unaware\", respectively.\n   Service Function Forwarder (SFF):\
    \  A service function forwarder is\n        responsible for forwarding traffic\
    \ to one or more connected\n        service functions according to information\
    \ carried in the SFC\n        encapsulation, as well as handling traffic coming\
    \ back from the\n        SF.  Additionally, an SFF is responsible for delivering\
    \ traffic\n        to a classifier when needed and supported, transporting traffic\n\
    \        to another SFF (in the same or different type of overlay), and\n    \
    \    terminating the Service Function Path (SFP).\n   Metadata:  Provides the\
    \ ability to exchange context information\n        between classifiers and SFs,\
    \ and among SFs.\n   Service Function Path (SFP):  The service function path is\
    \ a\n        constrained specification of where packets assigned to a certain\n\
    \        service function path must go.  While it may be so constrained\n    \
    \    as to identify the exact locations, it can also be less\n        specific.\
    \  The SFP provides a level of indirection between the\n        fully abstract\
    \ notion of service chain as a sequence of abstract\n        service functions\
    \ to be delivered, and the fully specified\n        notion of exactly which SFF/SFs\
    \ the packet will visit when it\n        actually traverses the network.  By allowing\
    \ the control\n        components to specify this level of indirection, the operator\n\
    \        may control the degree of SFF/SF selection authority that is\n      \
    \  delegated to the network.\n   SFC Encapsulation:  The SFC encapsulation provides,\
    \ at a minimum, SFP\n        identification, and is used by the SFC-aware functions,\
    \ such as\n        the SFF and SFC-aware SFs.  The SFC encapsulation is not used\n\
    \        for network packet forwarding.  In addition to SFP\n        identification,\
    \ the SFC encapsulation carries metadata including\n        data-plane context\
    \ information.\n   Rendered Service Path (RSP):  Within an SFP, packets themselves\
    \ are\n        of course transmitted from and to specific places in the\n    \
    \    network, visiting a specific sequence of SFFs and SFs.  This\n        sequence\
    \ of actual visits by a packet to specific SFFs and SFs\n        in the network\
    \ is known as the Rendered Service Path (RSP).\n        This definition is included\
    \ here for use by later documents,\n        such as when solutions may need to\
    \ discuss the actual sequence\n        of locations the packets visit.\n   SFC-Enabled\
    \ Domain:  A network or region of a network that implements\n        SFC.  An\
    \ SFC-enabled domain is limited to a single network\n        administrative domain.\n\
    \   SFC Proxy:  Removes and inserts SFC encapsulation on behalf of an\n      \
    \  SFC-unaware service function.  SFC proxies are logical elements.\n"
- title: 2.  Architectural Concepts
  contents:
  - "2.  Architectural Concepts\n   The following sections describe the foundational\
    \ concepts of service\n   function chaining and the SFC architecture.\n   Service\
    \ function chaining enables the creation of composite (network)\n   services that\
    \ consist of an ordered set of SFs that must be applied\n   to packets and/or\
    \ frames and/or flows selected as a result of\n   classification.  Each SF is\
    \ referenced using an identifier that is\n   unique within an SF-enabled domain.\n\
    \   Service function chaining is a concept that provides for more than\n   just\
    \ the application of an ordered set of SFs to selected traffic;\n   rather, it\
    \ describes a method for deploying SFs in a way that enables\n   dynamic ordering\
    \ and topological independence of those SFs as well as\n   the exchange of metadata\
    \ between participating entities.\n"
- title: 2.1.  Service Function Chains
  contents:
  - "2.1.  Service Function Chains\n   In most networks, services are constructed\
    \ as abstract sequences of\n   SFs that represent SFCs.  At a high level, an SFC\
    \ is an abstracted\n   view of a service that specifies the set of required SFs\
    \ as well as\n   the order in which they must be executed.  Graphs, as illustrated\
    \ in\n   Figure 1, define an SFC, where each graph node represents the\n   required\
    \ existence of at least one abstract SF.  Such graph nodes\n   (SFs) can be part\
    \ of zero, one, or many SFCs.  A given graph node\n   (SF) can appear one time\
    \ or multiple times in a given SFC.\n   SFCs can start from the origination point\
    \ of the service function\n   graph (i.e., node 1 in Figure 1), or from any subsequent\
    \ node in the\n   graph.  As shown, SFs may therefore become branching nodes in\
    \ the\n   graph, with those SFs selecting edges that move traffic to one or\n\
    \   more branches.  The top and middle graphs depict such a case, where a\n  \
    \ second classification event occurs after node 2, and a new graph is\n   selected\
    \ (i.e., node 3 instead of node 6).  The bottom graph\n   highlights the concept\
    \ of a cycle, in which a given SF (e.g., node 7\n   in the depiction) can be visited\
    \ more than once within a given\n   service chain.  An SFC can have more than\
    \ one terminus.\n     ,-+-.         ,---.          ,---.          ,---.\n    /\
    \     \\       /     \\        /     \\        /     \\\n   (   1   )+--->(  \
    \ 2   )+---->(   6   )+---->(   8   )\n    \\     /       \\     /        \\ \
    \    /        \\     /\n     `---'         `---'          `---'          `---'\n\
    \     ,-+-.         ,---.          ,---.          ,---.          ,---.\n    /\
    \     \\       /     \\        /     \\        /     \\        /     \\\n   (\
    \   1   )+--->(   2   )+---->(   3   )+---->(   7   )+---->(   9   )\n    \\ \
    \    /       \\     /        \\     /        \\     /        \\     /\n     `---'\
    \         `---'          `---'          `---'          `---'\n     ,-+-.     \
    \    ,---.          ,---.          ,---.          ,---.\n    /     \\       /\
    \     \\        /     \\        /     \\        /     \\\n   (   1   )+--->( \
    \  7   )+---->(   8   )+---->(   4   )+---->(   7   )\n    \\     /       \\ \
    \    /        \\     /        \\     /        \\     /\n     `---'         `---'\
    \          `---'          `---'          `---'\n                  Figure 1: Service\
    \ Function Chain Graphs\n   The concepts of classification, reclassification,\
    \ and branching are\n   covered in subsequent sections of this architecture (see\
    \ Sections 4.7\n   and 4.8).\n"
- title: 2.2.  Service Function Chain Symmetry
  contents:
  - "2.2.  Service Function Chain Symmetry\n   SFCs may be unidirectional or bidirectional.\
    \  A unidirectional SFC\n   requires that traffic be forwarded through the ordered\
    \ SFs in one\n   direction (sf1 -> sf2 -> sf3), whereas a bidirectional SFC requires\
    \ a\n   symmetric path (sf1 -> sf2 -> sf3 and sf3 -> sf2 -> sf1), and in\n   which\
    \ the SF instances are the same in opposite directions.  A hybrid\n   SFC has\
    \ attributes of both unidirectional and bidirectional SFCs;\n   that is to say\
    \ some SFs require symmetric traffic, whereas other SFs\n   do not process reverse\
    \ traffic or are independent of the\n   corresponding forward traffic.\n   SFCs\
    \ may contain cycles; that is traffic may need to traverse one or\n   more SFs\
    \ within an SFC more than once.  Solutions will need to ensure\n   suitable disambiguation\
    \ for such situations.\n   The architectural allowance that is made for SFPs that\
    \ delegate\n   choice to the network for which SFs and/or SFFs a packet will visit\n\
    \   creates potential issues here.  A solution that allows such\n   delegation\
    \ needs to also describe how the solution ensures that those\n   service chains\
    \ requiring service function chain symmetry can achieve\n   that.\n   Further,\
    \ there are state trade-offs in symmetry.  Symmetry may be\n   realized in several\
    \ ways depending on the SFF and classifier\n   functionality.  In some cases,\
    \ \"mirrored\" classification (i.e., from\n   Source to Destination and from Destination\
    \ to Source) policy may be\n   deployed, whereas in others shared state between\
    \ classifiers may be\n   used to ensure that symmetric flows are correctly identified,\
    \ then\n   steered along the required SFP.  At a high level, there are various\n\
    \   common cases.  In a non-exhaustive way, there can be for example:\n   o  A\
    \ single classifier (or a small number of classifiers), in which\n      case both\
    \ incoming and outgoing flows could be recognized at the\n      same classifier,\
    \ so the synchronization would be feasible by\n      internal mechanisms internal\
    \ to the classifier.\n   o  Stateful classifiers where several classifiers may\
    \ be clustered\n      and share state.\n   o  Fully distributed classifiers, where\
    \ synchronization needs to be\n      provided through unspecified means.\n   o\
    \  A classifier that learns state from the egress packets/flows that\n      is\
    \ then used to provide state for the return packets/flow.\n   o  Symmetry may\
    \ also be provided by stateful forwarding logic in the\n      SFF in some implementations.\n\
    \   This is a non-comprehensive list of common cases.\n"
- title: 2.3.  Service Function Paths
  contents:
  - "2.3.  Service Function Paths\n   A Service Function Path (SFP) is a mechanism\
    \ used by service chaining\n   to express the result of applying more granular\
    \ policy and\n   operational constraints to the abstract requirements of a service\n\
    \   chain (SFC).  This architecture does not mandate the degree of\n   specificity\
    \ of the SFP.  Architecturally, within the same SFC-enabled\n   domain, some SFPs\
    \ may be fully specified, selecting exactly which SFF\n   and which SF are to\
    \ be visited by packets using that SFP, while other\n   SFPs may be quite vague,\
    \ deferring to the SFF the decisions about the\n   exact sequence of steps to\
    \ be used to realize the SFC.  The\n   specificity may be anywhere in between\
    \ these extremes.\n   As an example of such an intermediate specificity, there\
    \ may be two\n   SFPs associated with a given SFC, where one SFP specifies that\
    \ any\n   order of SFF and SF may be used as long as it is within Data Center\n\
    \   1, and where the second SFP allows the same latitude, but only within\n  \
    \ Data Center 2.\n   Thus, the policies and logic of SFP selection or creation\
    \ (depending\n   upon the solution) produce what may be thought of as a constrained\n\
    \   version of the original SFC.  Since multiple policies may apply to\n   different\
    \ traffic that uses the same SFC, it also follows that there\n   may be multiple\
    \ SFPs associated with a single SFC.\n   The architecture allows for the same\
    \ SF to be reachable through\n   multiple SFFs.  In these cases, some SFPs may\
    \ constrain which SFF is\n   used to reach which SF, while some SFPs may leave\
    \ that decision to\n   the SFF itself.\n   Further, the architecture allows for\
    \ two or more SFs to be attached\n   to the same SFF, and possibly connected via\
    \ internal means allowing\n   more effective communication.  In these cases, some\
    \ solutions or\n   deployments may choose to use some form of internal inter-process\
    \ or\n   inter-VM messaging (communication behind the virtual switching\n   element)\
    \ that is optimized for such an environment.  This must be\n   coordinated with\
    \ the SFF so that it can properly perform its job.\n   Implementation details\
    \ of such mechanisms are considered out of scope\n   for this document, and can\
    \ include a spectrum of methods: for\n   example, situations including all next-hops\
    \ explicitly, others where\n   a list of possible next-hops is provided and the\
    \ selection is local,\n   or cases with just an identifier, where all resolution\
    \ is local.\n   This architecture also allows the same SF to be part of multiple\n\
    \   SFPs.\n"
- title: 2.3.1.  Service Function Chains, Service Function Paths, and Rendered
  contents:
  - "2.3.1.  Service Function Chains, Service Function Paths, and Rendered\n     \
    \   Service Path\n   As an example of this progressive refinement, consider a\
    \ Service\n   Function Chain (SFC) that states that packets using this chain should\n\
    \   be delivered to a firewall and a caching engine.\n   A Service Function Path\
    \ (SFP) could refine this, considering that\n   this architecture does not mandate\
    \ the degree of specificity an SFP\n   has to have.  It might specify that the\
    \ firewall and caching engine\n   are both to be in a specific data center (e.g.,\
    \ in DC1), or it might\n   specify exactly which instance of each firewall and\
    \ caching engine is\n   to be used.\n   The Rendered Service Path (RSP) is the\
    \ actual sequence of SFFs and\n   SFs that the packets will actually visit.  So\
    \ if the SFP picked the\n   DC, the RSP would be more specific.\n"
- title: 3.  Architecture Principles
  contents:
  - "3.  Architecture Principles\n   Service function chaining is predicated on several\
    \ key architectural\n   principles:\n   1.  Topological independence: No changes\
    \ to the underlay network\n       forwarding topology -- implicit, or explicit\
    \ -- are needed to\n       deploy and invoke SFs or SFCs.\n   2.  Plane separation:\
    \ Dynamic realization of SFPs is separated from\n       packet handling operations\
    \ (e.g., packet forwarding).\n   3.  Classification: Traffic that satisfies classification\
    \ rules is\n       forwarded according to a specific SFP.  For example,\n    \
    \   classification can be as simple as an explicit forwarding entry\n       that\
    \ forwards all traffic from one address into the SFP.\n       Multiple classification\
    \ points are possible within an SFC (i.e.,\n       forming a service graph), thus\
    \ enabling changes/updates to the\n       SFC by SFs.\n       Classification can\
    \ occur at varying degrees of granularity; for\n       example, classification\
    \ can use a 5-tuple, a transport port or\n       set of ports, part of the packet\
    \ payload, it can be the result of\n       high-level inspections, or it can come\
    \ from external systems.\n   4.  Shared Metadata: Metadata/context data can be\
    \ shared amongst SFs\n       and classifiers, between SFs, and between external\
    \ systems and\n       SFs (e.g., orchestration).\n       One use of metadata is\
    \ to provide and share the result of\n       classification (that occurs within\
    \ the SFC-enabled domain, or\n       external to it) along an SFP.  For example,\
    \ an external\n       repository might provide user/subscriber information to\
    \ a service\n       chain classifier.  This classifier could in turn impose that\n\
    \       information in the SFC encapsulation for delivery to the\n       requisite\
    \ SFs.  The SFs could in turn utilize the user/subscriber\n       information\
    \ for local policy decisions.  Metadata can also share\n       SF output along\
    \ the SFP.\n   5.  Service definition independence: The SFC architecture does\
    \ not\n       depend on the details of SFs themselves.\n   6.  Service function\
    \ chain independence: The creation, modification,\n       or deletion of an SFC\
    \ has no impact on other SFCs.  The same is\n       true for SFPs.\n   7.  Heterogeneous\
    \ control/policy points: The architecture allows SFs\n       to use independent\
    \ mechanisms (out of scope for this document) to\n       populate and resolve\
    \ local policy and (if needed) local\n       classification criteria.\n"
- title: 4.  Core SFC Architecture Components
  contents:
  - "4.  Core SFC Architecture Components\n   The SFC Architecture is built out of\
    \ architectural building blocks\n   that are logical components; these logical\
    \ components are\n   classifiers, Service Function Forwarders (SFFs), the Service\n\
    \   Functions (SFs) themselves, and SFC proxies.  While this architecture\n  \
    \ describes functionally distinct logical components and promotes\n   transport\
    \ independence, they could be realized and combined in\n   various ways in deployed\
    \ products, and could be combined with an\n   overlay.\n   They are interconnected\
    \ using the SFC encapsulation.  This results in\n   a high-level logical architecture\
    \ of an SFC-enabled domain that\n   comprises:\n      o . . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . . . . .\n      .  +--------------+       \
    \           +------------------~~~\n      .  |   Service    |       SFC      \
    \  |  Service  +---+   +---+\n      .  |Classification|  Encapsulation   | Function\
    \  |sf1|...|sfn|\n   +---->|   Function   |+---------------->|   Path    +---+\
    \   +---+\n      .  +--------------+                  +------------------~~~\n\
    \      . SFC-enabled Domain\n      o . . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . .\n               Figure 2: Service Function Chain Architecture\n\
    \   The following subsections provide details on each logical component\n   that\
    \ form the basis of the SFC architecture.  A detailed overview of\n   how some\
    \ of these architectural components interact is provided in\n   Figure 3:\n  \
    \        +----------------+                        +----------------+\n      \
    \    |   SFC-aware    |                        |  SFC-unaware   |\n          |Service\
    \ Function|                        |Service Function|\n          +-------+--------+\
    \                        +-------+--------+\n                  |             \
    \                            |\n            SFC Encapsulation                \
    \       No SFC Encapsulation\n                  |                  SFC       \
    \             |\n     +---------+  +----------------+ Encapsulation     +---------+\n\
    \     |SFC-Aware|-----------------+  \\     +------------|SFC Proxy|\n     | \
    \   SF   | ... ----------+  \\  \\   /             +---------+\n     +---------+\
    \                \\  \\  \\ /\n                               +-------+--------+\n\
    \                               |   SF Forwarder |\n                         \
    \      |      (SFF)     |\n                               +-------+--------+\n\
    \                                       |\n                               SFC\
    \ Encapsulation\n                                       |\n                  \
    \         ... SFC-enabled Domain ...\n                                       |\n\
    \                           Network Overlay Transport\n                      \
    \                 |\n                                   _,....._\n           \
    \                     ,-'        `-.\n                               /       \
    \       `.\n                              |     Network    |\n               \
    \               `.              /\n                                `.__     __,-'\n\
    \                                    `''''\n    Figure 3: SFC Architecture Components\
    \ After Initial Classification\n   Please note that the depiction in Figure 3\
    \ shows packets after\n   initial classification, and therefore includes the SFC\
    \ encapsulation.\n   Although not included in Figure 3, the classifier is an SFC\n\
    \   architectural component.\n"
- title: 4.1.  SFC Encapsulation
  contents:
  - "4.1.  SFC Encapsulation\n   The SFC encapsulation enables service function path\
    \ selection.  It\n   also enables the sharing of metadata/context information\
    \ when such\n   metadata exchange is required.\n   The SFC encapsulation carries\
    \ explicit information used to identify\n   the SFP.  However, the SFC encapsulation\
    \ is not a transport\n   encapsulation itself: it is not used to forward packets\
    \ within the\n   network fabric.  If packets need to flow between separate physical\n\
    \   platforms, the SFC encapsulation relies on an outer network\n   transport.\
    \  Transit forwarders -- such as router and switches --\n   forward SFC encapsulated\
    \ packets based on the outer (non-SFC)\n   encapsulation.\n   One of the key architecture\
    \ principles of SFC is that the SFC\n   encapsulation remain transport independent.\
    \  As such, any network\n   transport protocol may be used to carry the SFC encapsulated\
    \ traffic.\n"
- title: 4.2.  Service Function (SF)
  contents:
  - "4.2.  Service Function (SF)\n   The concept of an SF evolves; rather than being\
    \ viewed as a bump in\n   the wire, an SF becomes a resource within a specified\
    \ administrative\n   domain that is available for consumption as part of a composite\n\
    \   service.  SFs send/receive data to/from one or more SFFs.  SFC-aware\n   SFs\
    \ receive this traffic with the SFC encapsulation.\n   While the SFC architecture\
    \ defines the concept and specifies some\n   characteristics of a new encapsulation\
    \ -- the SFC encapsulation --\n   and several logical components for the construction\
    \ of SFCs, existing\n   SF implementations may not have the capabilities to act\
    \ upon or fully\n   integrate with the new SFC encapsulation.  In order to provide\
    \ a\n   mechanism for such SFs to participate in the architecture, an SFC\n  \
    \ proxy function is defined (see Section 4.6).  The SFC proxy acts as a\n   gateway\
    \ between the SFC encapsulation and SFC-unaware SFs.  The\n   integration of SFC-unaware\
    \ service functions is discussed in more\n   detail in the SFC proxy section.\n\
    \   This architecture allows an SF to be part of multiple SFPs and SFCs.\n"
- title: 4.3.  Service Function Forwarder (SFF)
  contents:
  - "4.3.  Service Function Forwarder (SFF)\n   The SFF is responsible for forwarding\
    \ packets and/or frames received\n   from the network to one or more SFs associated\
    \ with a given SFF using\n   information conveyed in the SFC encapsulation.  Traffic\
    \ from SFs\n   eventually returns to the same SFF, which is responsible for\n\
    \   injecting traffic back onto the network.  Some SFs, such as\n   firewalls,\
    \ could also consume a packet.\n   The collection of SFFs and associated SFs creates\
    \ a service-plane\n   overlay in which SFC-aware SFs, as well as SFC-unaware SFs\
    \ reside.\n   Within this service plane, the SFF component connects different\
    \ SFs\n   that form a service function path.\n   SFFs maintain the requisite SFP\
    \ forwarding information.  SFP\n   forwarding information is associated with a\
    \ service path identifier\n   that is used to uniquely identify an SFP.  The service\
    \ forwarding\n   state enables an SFF to identify which SFs of a given SFP should\
    \ be\n   applied, and in what order, as traffic flows through the associated\n\
    \   SFP.  While there may appear to the SFF to be only one available way\n   to\
    \ deliver the given SF, there may also be multiple choices allowed\n   by the\
    \ constraints of the SFP.\n   If there are multiple choices, the SFF needs to\
    \ preserve the property\n   that all packets of a given flow are handled the same\
    \ way, since the\n   SF may well be stateful.  Additionally, the SFF may preserve\
    \ the\n   handling of packets based on other properties on top of a flow, such\n\
    \   as a subscriber, session, or application instance identification.\n   The\
    \ SFF also has the information that allows it to forward packets to\n   the next\
    \ SFF after applying local service functions.  Again, while\n   there may be only\
    \ a single choice available, the architecture allows\n   for multiple choices\
    \ for the next SFF.  As with SFs, the solution\n   needs to operate such that\
    \ the behavior with regard to specific flows\n   (see the Rendered Service Path)\
    \ is stable.  The selection of\n   available SFs and next SFFs may be interwoven\
    \ when an SFF supports\n   multiple distinct service functions and the same service\
    \ function is\n   available at multiple SFFs.  Solutions need to be clear about\
    \ what is\n   allowed in these cases.\n   Even when the SFF supports and utilizes\
    \ multiple choices, the\n   decision as to whether to use flow-specific mechanisms\
    \ or coarser-\n   grained means to ensure that the behavior of specific flows\
    \ is stable\n   is a matter for specific solutions and specific implementations.\n\
    \   The SFF component has the following primary responsibilities:\n   1.  SFP\
    \ forwarding: Traffic arrives at an SFF from the network.  The\n       SFF determines\
    \ the appropriate SF the traffic should be forwarded\n       to via information\
    \ contained in the SFC encapsulation.  After SF\n       processing, the traffic\
    \ is returned to the SFF, and, if needed,\n       is forwarded to another SF associated\
    \ with that SFF.  If there is\n       another non-local (i.e., different SFF)\
    \ hop in the SFP, the SFF\n       further encapsulates the traffic in the appropriate\
    \ network\n       transport protocol and delivers it to the network for delivery\
    \ to\n       the next SFF along the path.  Related to this forwarding\n      \
    \ responsibility, an SFF should be able to interact with metadata.\n   2.  Terminating\
    \ SFPs: An SFC is completely executed when traffic has\n       traversed all required\
    \ SFs in a chain.  When traffic arrives at\n       the SFF after the last SF has\
    \ finished processing it, the final\n       SFF knows from the service forwarding\
    \ state that the SFC is\n       complete.  The SFF removes the SFC encapsulation\
    \ and delivers the\n       packet back to the network for forwarding.\n   3. \
    \ Maintaining flow state: In some cases, the SFF may be stateful.\n       It creates\
    \ flows and stores flow-centric information.  This state\n       information may\
    \ be used for a range of SFP-related tasks such as\n       ensuring consistent\
    \ treatment of all packets in a given flow,\n       ensuring symmetry, or for\
    \ state-aware SFC Proxy functionality\n       (see Section 4.8).\n"
- title: 4.3.1.  Transport-Derived SFF
  contents:
  - "4.3.1.  Transport-Derived SFF\n   SFP forwarding, as described above, directly\
    \ depends upon the use of\n   the service path information contained in the SFC\
    \ encapsulation.\n   However, existing implementations may not be able to act\
    \ on the SFC\n   encapsulation.  These platforms may opt to use existing transport\n\
    \   information, if it can be arranged, to provide explicit service path\n   information.\n\
    \   This results in the same architectural behavior and meaning for SFP\n   forwarding\
    \ and service function paths.  It is the responsibility of\n   the control components\
    \ to ensure that the transport path executed in\n   such a case is fully aligned\
    \ with the path identified by the\n   information in the service chaining encapsulation.\n"
- title: 4.4.  SFC-Enabled Domain
  contents:
  - "4.4.  SFC-Enabled Domain\n   Specific features may need to be enforced at the\
    \ boundaries of an\n   SFC-enabled domain, for example to avoid leaking SFC information.\n\
    \   Using the term \"node\" to refer generically to an entity that is\n   performing\
    \ a set of functions, in this context, an SFC boundary node\n   denotes a node\
    \ that connects one SFC-enabled domain to a node either\n   located in another\
    \ SFC-enabled domain or in a domain that is SFC-\n   unaware.\n   An SFC boundary\
    \ node can act as egress or ingress.  An SFC Egress\n   Node denotes an SFC boundary\
    \ node that handles traffic leaving the\n   SFC-enabled domain the Egress Node\
    \ belongs to.  Such a node is\n   required to remove any information specific\
    \ to the SFC Domain,\n   typically the SFC encapsulation.  Further, from a privacy\n\
    \   perspective, an SFC Egress Node is required to ensure that any\n   sensitive\
    \ information added as part of SFC gets removed.  In this\n   context, information\
    \ may be sensitive due to network concerns or end-\n   customer concerns.  An\
    \ SFC Ingress Node denotes an SFC boundary node\n   that handles traffic entering\
    \ the SFC-enabled domain.  In most\n   solutions and deployments this will need\
    \ to include a classifier, and\n   will be responsible for adding the SFC encapsulation\
    \ to the packet.\n   An SFC Proxy and corresponding SFC-unaware service function\
    \ (see\n   Figure 3) are inside the SFC-enabled domain.\n"
- title: 4.5.  Network Overlay and Network Components
  contents:
  - "4.5.  Network Overlay and Network Components\n   Underneath the SFF there are\
    \ components responsible for performing\n   the transport (overlay) forwarding.\
    \  They do not consult the SFC\n   encapsulation or inner payload for performing\
    \ this forwarding.  They\n   only consult the outer-transport encapsulation for\
    \ the transport\n   (overlay) forwarding.\n"
- title: 4.6.  SFC Proxy
  contents:
  - "4.6.  SFC Proxy\n   In order for the SFC architecture to support SFC-unaware\
    \ SFs (e.g.,\n   legacy service functions) a logical SFC proxy function may be\
    \ used.\n   This function sits between an SFF and one or more SFs to which the\n\
    \   SFF is directing traffic (see Figure 3).\n   The proxy accepts packets from\
    \ the SFF on behalf of the SF.  It\n   removes the SFC encapsulation, and then\
    \ uses a local attachment\n   circuit to deliver packets to SFC-unaware SFs. \
    \ It also receives\n   packets back from the SF, reapplies the SFC encapsulation,\
    \ and\n   returns them to the SFF for processing along the service function\n\
    \   path.\n   Thus, from the point of view of the SFF, the SFC proxy appears to\
    \ be\n   part of an SFC-aware SF.\n   Communication details between the SFF and\
    \ the SFC Proxy are the same\n   as those between the SFF and an SFC-aware SF.\
    \  The details of that\n   are not part of this architecture.  The details of\
    \ the communication\n   methods over the local attachment circuit between the\
    \ SFC proxy and\n   the SFC-unaware SF are dependent upon the specific behaviors\
    \ and\n   capabilities of that SFC-unaware SF, and thus are also out of scope\n\
    \   for this architecture.\n   Specifically, for traffic received from the SFF\
    \ intended for the SF\n   the proxy is representing, the SFC proxy:\n   o  Removes\
    \ the SFC encapsulation from SFC encapsulated packets.\n   o  Identifies the required\
    \ SF to be applied based on available\n      information including that carried\
    \ in the SFC encapsulation.\n   o  Selects the appropriate outbound local attachment\
    \ circuit through\n      which the next SF for this SFP is reachable.  This is\
    \ derived from\n      the identification of the SF carried in the SFC encapsulation,\
    \ and\n      may include local techniques.  Examples of a local attachment\n \
    \     circuit include, but are not limited to, VLAN, IP-in-IP, Layer 2\n     \
    \ Tunneling Protocol version 3 (L2TPv3), Generic Routing\n      Encapsulation\
    \ (GRE), and Virtual eXtensible Local Area Network\n      (VXLAN).\n   o  Forwards\
    \ the original payload via the selected local attachment\n      circuit to the\
    \ appropriate SF.\n   When traffic is returned from the SF:\n   o  Applies the\
    \ required SFC encapsulation.  The determination of the\n      encapsulation details\
    \ may be inferred by the local attachment\n      circuit through which the packet\
    \ and/or frame was received, or via\n      packet classification, or other local\
    \ policy.  In some cases,\n      packet ordering or modification by the SF may\
    \ necessitate\n      additional classification in order to reapply the correct\
    \ SFC\n      encapsulation.\n   o  Delivers the packet with the SFC encapsulation\
    \ to the SFF, as\n      would happen with packets returned from an SFC-aware SF.\n"
- title: 4.7.  Classification
  contents:
  - "4.7.  Classification\n   Traffic from the network that satisfies classification\
    \ criteria is\n   directed into an SFP and forwarded to the requisite service\n\
    \   function(s).  Classification is handled by a service classification\n   function;\
    \ initial classification occurs at the ingress to the SFC\n   domain.  The granularity\
    \ of the initial classification is determined\n   by the capabilities of the classifier\
    \ and the requirements of the SFC\n   policy.  For instance, classification might\
    \ be relatively coarse: all\n   packets from this port are subject to SFC policy\
    \ X and directed into\n   SFP A, or quite granular: all packets matching this\
    \ 5-tuple are\n   subject to SFC policy Y and directed into SFP B.\n   As a consequence\
    \ of the classification decision, the appropriate SFC\n   encapsulation is imposed\
    \ on the data, and a suitable SFP is selected\n   or created.  Classification\
    \ results in attaching the traffic to a\n   specific SFP.\n"
- title: 4.8.  Reclassification and Branching
  contents:
  - "4.8.  Reclassification and Branching\n   The SFC architecture supports reclassification\
    \ (or non-initial\n   classification) as well.  As packets traverse an SFP,\n\
    \   reclassification may occur -- typically performed by a classification\n  \
    \ function co-resident with a service function.  Reclassification may\n   result\
    \ in the selection of a new SFP, an update of the associated\n   metadata, or\
    \ both.  This is referred to as \"branching\".\n   For example, an initial classification\
    \ results in the selection of\n   SFP A: DPI_1 --> SLB_8.  However, when the DPI\
    \ service function is\n   executed, attack traffic is detected at the application\
    \ layer.  DPI_1\n   reclassifies the traffic as attack and alters the service\
    \ path to SFP\n   B, to include a firewall for policy enforcement: dropping the\n\
    \   traffic: DPI_1 --> FW_4.  Subsequent to FW_4, surviving traffic would\n  \
    \ be returned to the original SFF.  In this simple example, the DPI\n   service\
    \ function reclassifies the traffic based on local application\n   layer classification\
    \ capabilities (that were not available during the\n   initial classification\
    \ step).\n   When traffic arrives after being steered through an SFC-unaware SF,\n\
    \   the SFC Proxy must perform reclassification of traffic to determine\n   the\
    \ SFP.  The SFC Proxy is concerned with re-attaching information\n   for SFC-unaware\
    \ SFs, and a stateful SFC Proxy simplifies such\n   classification to a flow lookup.\n"
- title: 4.9.  Shared Metadata
  contents:
  - "4.9.  Shared Metadata\n   Sharing metadata allows the network to provide network-derived\n\
    \   information to the SFs, SF-to-SF information exchange, and the\n   sharing\
    \ of service-derived information to the network.  Some SFCs may\n   not require\
    \ metadata exchange.  SFC infrastructure enables the\n   exchange of this shared\
    \ data along the SFP.  The shared metadata\n   serves several possible roles within\
    \ the SFC architecture:\n   o  Allows elements that typically operate independently\
    \ (e.g., as\n      \"ships in the night\") to exchange information.\n   o  Encodes\
    \ information about the network and/or data for subsequent\n      use within the\
    \ SFP.\n   o  Creates an identifier used for policy binding by SFs.\n   Context\
    \ information can be derived in several ways:\n   o  External sources\n   o  Network\
    \ node classification\n   o  Service function classification\n"
- title: 5.  Additional Architectural Concepts
  contents:
  - "5.  Additional Architectural Concepts\n   There are a number of issues that solutions\
    \ need to address, and that\n   the architecture informs but does not determine.\
    \  This section lays\n   out some of those concepts.\n"
- title: 5.1.  The Role of Policy
  contents:
  - "5.1.  The Role of Policy\n   Much of the behavior of service chains is driven\
    \ by operator and per-\n   customer policy.  This architecture is structured to\
    \ isolate the\n   policy interactions from the data plane and control logic.\n\
    \   Specifically, it is assumed that the service chaining control plane\n   creates\
    \ the service paths.  The service chaining data plane is used\n   to deliver the\
    \ classified packets along the service chains to the\n   intended service functions.\n\
    \   Policy, in contrast, interacts with the system in other places.\n   Policies\
    \ and policy engines may monitor service functions to decide\n   if additional\
    \ (or fewer) instances of services are needed.  When\n   applicable, those decisions\
    \ may in turn result in interactions that\n   direct the control logic to change\
    \ the SFP placement or packet\n   classification rules.\n   Similarly, operator\
    \ service policy, often managed by Operations or\n   Business Support Systems\
    \ (OSS or BSS), will frequently determine what\n   service functions are available.\
    \  Operator service policies also\n   determine which sequences of functions are\
    \ valid and are to be used\n   or made available.\n   The offering of service\
    \ chains to customers, and the selection of\n   which service chain a customer\
    \ wishes to use, are driven by a\n   combination of operator and customer policies\
    \ using appropriate\n   portals in conjunction with the OSS and BSS tools.  These\
    \ selections\n   then drive the service chaining control logic, which in turn\n\
    \   establishes the appropriate packet classification rules.\n"
- title: 5.2.  SFC Control Plane
  contents:
  - "5.2.  SFC Control Plane\n   The SFC control plane is part of the overall SFC\
    \ architecture, and\n   this section describes its high-level functions.  However,\
    \ the\n   detailed definition of the SFC control plane is outside the scope of\n\
    \   this document.\n   The SFC control plane is responsible for constructing SFPs,\n\
    \   translating SFCs to forwarding paths, and propagating path\n   information\
    \ to participating nodes to achieve requisite forwarding\n   behavior to construct\
    \ the service overlay.  For instance, an SFC\n   construction may be static; selecting\
    \ exactly which SFFs and which\n   SFs from those SFFs are to be used, or it may\
    \ be dynamic, allowing\n   the network to perform some or all of the choices of\
    \ SFF or SF to use\n   to deliver the selected service chain within the constraints\n\
    \   represented by the service path.\n   In the SFC architecture, SFs are resources;\
    \ the control plane manages\n   and communicates their capabilities, availability,\
    \ and location in\n   fashions suitable for the transport and SFC operations in\
    \ use.  The\n   control plane is also responsible for the creation of the context\n\
    \   (see below).  The control plane may be distributed (using new or\n   existing\
    \ control-plane protocols), or be centralized, or a\n   combination of the two.\n\
    \   The SFC control plane provides the following functionality:\n   1.  An SFC-enabled\
    \ domain wide view of all available service function\n       resources as well\
    \ as the network locators through which they are\n       reachable.\n   2.  Uses\
    \ SFC policy to construct service function chains, and\n       associated SFPs.\n\
    \   3.  Selection of specific SFs for a requested SFC, either statically\n   \
    \    (using specific SFs) or dynamically (using service explicit SFs\n       at\
    \ the time of delivering traffic to them).\n   4.  Provides requisite SFC data-plane\
    \ information to the SFC\n       architecture components, most notably the SFF.\n\
    \   5.  Provides the metadata and usage information classifiers need so\n    \
    \   that they in turn can provide this metadata for appropriate\n       packets\
    \ in the data plane.\n   6.  When needed, provide information including policy\
    \ information to\n       other SFC elements to be able to properly interpret metadata.\n"
- title: 5.3.  Resource Control
  contents:
  - "5.3.  Resource Control\n   The SFC system may be responsible for managing all\
    \ resources\n   necessary for the SFC components to function.  This includes network\n\
    \   constraints used to plan and choose network path(s) between service\n   function\
    \ forwarders, network communication paths between service\n   function forwarders\
    \ and their attached service functions,\n   characteristics of the nodes themselves\
    \ such as memory, number of\n   virtual interfaces, routes, and instantiation,\
    \ configuration, and\n   deletion of SFs.\n   The SFC system will also be required\
    \ to reflect policy decisions\n   about resource control, as expressed by other\
    \ components in the\n   system.\n   While all of these aspects are part of the\
    \ overall system, they are\n   beyond the scope of this architecture.\n"
- title: 5.4.  Infinite Loop Detection and Avoidance
  contents:
  - "5.4.  Infinite Loop Detection and Avoidance\n   This SFC architecture is predicated\
    \ on topological independence from\n   the underlying forwarding topology.  Consequently,\
    \ a service topology\n   is created by service function paths or by the local\
    \ decisions of the\n   service function forwarders based on the constraints expressed\
    \ in the\n   SFP.  Due to the overlay constraints, the packet-forwarding path\
    \ may\n   need to visit the same SFF multiple times, and in some less common\n\
    \   cases may even need to visit the same SF more than once.  The Service\n  \
    \ Chaining solution needs to permit these limited and policy-compliant\n   loops.\
    \  At the same time, the solutions must ensure that indefinite\n   and unbounded\
    \ loops cannot be formed, as such would consume unbounded\n   resources without\
    \ delivering any value.\n   In other words, this architecture requires the solution\
    \ to prevent\n   infinite service function loops, even when service functions\
    \ may be\n   invoked multiple times in the same SFP.\n"
- title: 5.5.  Load-Balancing Considerations
  contents:
  - "5.5.  Load-Balancing Considerations\n   Supporting function elasticity and high-availability\
    \ should not\n   overly complicate SFC or lead to unnecessary scalability problems.\n\
    \   In the simplest case, where there is only a single function in the\n   SFP\
    \ (the next hop is either the destination address of the flow or\n   the appropriate\
    \ next hop to that destination), one could argue that\n   there may be no need\
    \ for SFC.\n   In the cases where the classifier is separate from the single\n\
    \   function or a function at the terminal address may need a sub-prefix\n   (e.g.,\
    \ finer-grained address information) or per-subscriber metadata,\n   a single\
    \ SFP exists (i.e., the metadata changes but the SFP does\n   not), regardless\
    \ of the number of potential terminal addresses for\n   the flow.  This is the\
    \ case of the simple load balancer.  See\n   Figure 4.\n                     \
    \       +---+    +---++--->web server\n                  source+-->|sff|+-->|sf1|+--->web\
    \ server\n                            +---+    +---++--->web server\n        \
    \              Figure 4: Simple Load Balancing\n   By extrapolation, in the case\
    \ where intermediary functions within a\n   chain had similar \"elastic\" behaviors,\
    \ we do not need separate chains\n   to account for this behavior -- as long as\
    \ the traffic coalesces to a\n   common next-hop after the point of elasticity.\n\
    \   In Figure 5, we have a chain of five service functions between the\n   traffic\
    \ source and its destination.\n                +---+ +---+ +---+   +---+ +---+\
    \ +---+\n                |sf2| |sf2| |sf3|   |sf3| |sf4| |sf4|\n             \
    \   +---+ +---+ +---+   +---+ +---+ +---+\n                  |     |     |   \
    \    |     |     |\n                  +-----+-----+       +-----+-----+\n    \
    \                    |                   |\n                        +        \
    \           +\n             +---+    +---+     +---+     +---+    +---+\n   source+-->|sff|+-->|sff|+--->|sff|+--->|sff|+-->|sff|+-->destination\n\
    \             +---+    +---+     +---+     +---+    +---+\n               +  \
    \                +                  +\n               |                  |   \
    \               |\n             +---+              +---+              +---+\n\
    \             |sf1|              |sf3|              |sf5|\n             +---+\
    \              +---+              +---+\n                         Figure 5: Load\
    \ Balancing\n   This would be represented as one service function path:\n   sf1\
    \ -> sf2 -> sf3 -> sf4 -> sf5.  The SFF is a logical element, which\n   may be\
    \ made up of one or multiple components.  In this architecture,\n   the SFF may\
    \ handle load distribution based on policy.\n   It can also be seen in the above\
    \ that the same service function may\n   be reachable through multiple SFFs, as\
    \ discussed earlier.  The\n   selection of which SFF to use to reach sf3 may be\
    \ made by the control\n   logic in defining the SFP, or may be left to the SFFs\
    \ themselves,\n   depending upon policy, solution, and deployment constraints.\
    \  In the\n   latter case, it needs to be assured that exactly one SFF takes\n\
    \   responsibility to steer traffic through sf3.\n"
- title: 5.6.  MTU and Fragmentation Considerations
  contents:
  - "5.6.  MTU and Fragmentation Considerations\n   This architecture prescribes that\
    \ additional information be added to\n   packets to identify service function\
    \ paths and often to represent\n   metadata.  It also envisions adding transport\
    \ information to carry\n   packets along service function paths, at least between\
    \ service\n   function forwarders.  This added information increases the size\
    \ of\n   the packet to be carried by service chaining.  Such additions could\n\
    \   potentially increase the packet size beyond the MTU supported on some\n  \
    \ or all of the media used in the service chaining domain.\n   Such packet size\
    \ increases can thus cause operational MTU problems.\n   Requiring fragmentation\
    \ and reassembly in an SFF would be a major\n   processing increase and might\
    \ be impossible with some transports.\n   Expecting service functions to deal\
    \ with packets fragmented by the\n   SFC function might be onerous even when such\
    \ fragmentation was\n   possible.  Thus, at the very least, solutions need to\
    \ pay attention\n   to the size cost of their approach.  There may be alternative\
    \ or\n   additional means available, although any solution needs to consider\n\
    \   the trade-offs.\n   These considerations apply to any generic architecture\
    \ that increases\n   the header size.  There are also more specific MTU considerations:\n\
    \   Effects on Path MTU Discovery (PMTUD) as well as deployment\n   considerations.\
    \  Deployments within a single administrative control\n   or even a single data\
    \ center complex can afford more flexibility in\n   dealing with larger packets,\
    \ and deploying existing mitigations that\n   decrease the likelihood of fragmentation\
    \ or discard.\n"
- title: 5.7.  SFC OAM
  contents:
  - "5.7.  SFC OAM\n   Operations, Administration, and Maintenance (OAM) tools are\
    \ an\n   integral part of the architecture.  These serve various purposes,\n \
    \  including fault detection and isolation, and performance management.\n   For\
    \ example, there are many advantages of SFP liveness detection,\n   including\
    \ status reporting, support for resiliency operations and\n   policies, and an\
    \ enhanced ability to balance load.\n   Service function paths create a services\
    \ topology, and OAM performs\n   various functions within this service layer.\
    \  Furthermore, SFC OAM\n   follows the same architectural principles of SFC in\
    \ general.  For\n   example, topological independence (including the ability to\
    \ run OAM\n   over various overlay technologies) and classification-based policy.\n\
    \   We can subdivide the SFC OAM architecture in two parts:\n   o  In-band: OAM\
    \ packets follow the same path and share fate with user\n      packets, within\
    \ the service topology.  For this, they also follow\n      the architectural principle\
    \ of consistent policy identifiers, and\n      use the same path IDs as the service\
    \ chain data packets.  Load\n      balancing and SFC encapsulation with packet\
    \ forwarding are\n      particularly important here.\n   o  Out-of-band: Reporting\
    \ beyond the actual data plane.  An\n      additional layer beyond the data-plane\
    \ OAM allows for additional\n      alerting and measurements.\n   This architecture\
    \ prescribes end-to-end SFP OAM functions, which\n   implies SFF understanding\
    \ of whether an in-band packet is an OAM or\n   user packet.  However, service\
    \ function validation is outside of the\n   scope of this architecture, and application-level\
    \ OAM is not what\n   this architecture prescribes.\n   Some of the detailed functions\
    \ performed by SFC OAM include fault\n   detection and isolation in a service\
    \ function path or a service\n   function, verification that connectivity using\
    \ SFPs is both effective\n   and directing packets to the intended service functions,\
    \ service path\n   tracing, diagnostic and fault isolation, alarm reporting, performance\n\
    \   measurement, locking and testing of service functions, validation\n   with\
    \ the control plane (see Section 5.2), and also allow for vendor-\n   specific\
    \ as well as experimental functions.  SFC should leverage and,\n   if needed,\
    \ extend relevant existing OAM mechanisms.\n"
- title: 5.8.  Resilience and Redundancy
  contents:
  - "5.8.  Resilience and Redundancy\n   As a practical operational requirement, any\
    \ service chaining solution\n   needs to be able to respond effectively, and usually\
    \ very quickly, to\n   failure conditions.  These may be failures of connectivity\
    \ in the\n   network between SFFs, failures of SFFs, or failures of SFs.  Per-SF\n\
    \   state (as, for example, stateful-firewall state) is the\n   responsibility\
    \ of the SF, and not addressed by this architecture.\n   Multiple techniques are\
    \ available to address this issue.  Solutions\n   can describe both what they\
    \ require and what they allow to address\n   failure.  Solutions can make use\
    \ of flexible specificity of service\n   function paths, if the SFF can be given\
    \ enough information in a\n   timely fashion to do this.  Solutions can also make\
    \ use of MAC- or\n   IP-level redundancy mechanisms such as Virtual Router Redundancy\n\
    \   Protocol (VRRP).  Also, particularly for SF failures, load balancers\n   co-located\
    \ with the SFF or as part of the service function delivery\n   mechanism can provide\
    \ such robustness.\n   Similarly, operational requirements imply resilience in\
    \ the face of\n   load changes.  While mechanisms for managing (e.g., monitoring,\n\
    \   instantiating, loading images, providing configuration to SFC\n   control,\
    \ deleting, etc.) virtual machines are out of scope for this\n   architecture,\
    \ solutions can and are aided by describing how they can\n   make use of scaling\
    \ mechanisms.\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   The architecture described here is different\
    \ from the current model,\n   and moving to the new model could lead to different\
    \ security\n   arrangements and modeling.  In the SFC architecture, a relatively\n\
    \   static topologically-dependent deployment model is replaced with the\n   chaining\
    \ of sets of service functions.  This can change the flow of\n   data through\
    \ the network, and the security and privacy considerations\n   of the protocol\
    \ and deployment will need to be reevaluated in light\n   of the new model.\n\
    \   Security considerations apply to the realization of this\n   architecture,\
    \ in particular to the documents that will define\n   protocols.  Such realization\
    \ ought to provide means to protect\n   against security and privacy attacks in\
    \ the areas hereby described.\n   Building from the categorization of [RFC7498],\
    \ we can largely divide\n   the security considerations into four areas:\n   Service\
    \ Overlay:  Underneath the service function forwarders, the\n        components\
    \ that are responsible for performing the transport\n        forwarding consult\
    \ the outer-transport encapsulation for\n        underlay forwarding.  Used transport\
    \ mechanisms should satisfy\n        the security requirements of the specific\
    \ SFC deployment.  These\n        requirements typically include varying degrees\
    \ of traffic\n        separation, protection against different attacks (e.g.,\n\
    \        spoofing, man-in-the-middle, brute-force, or insertion attacks),\n  \
    \      and can also include authenticity and integrity checking, and/or\n    \
    \    confidentiality provisions, for both the network overlay\n        transport\
    \ and traffic it encapsulates.\n   Boundaries:  Specific requirements may need\
    \ to be enforced at the\n        boundaries of an SFC-enabled domain.  These include,\
    \ for\n        example, to avoid leaking SFC information, and to protect its\n\
    \        borders against various forms of attacks.  If untrusted parties\n   \
    \     can inject packets that will be treated as being properly\n        classified\
    \ for service chaining, there are a large range of\n        attacks that can be\
    \ mounted against the resulting system.\n        Depending upon deployment details,\
    \ these likely include spoofing\n        packets from users and creating DDoS\
    \ and reflection attacks of\n        various kinds.  Thus, when transport mechanisms\
    \ are selected for\n        use with SFC, they MUST ensure that outside parties\
    \ cannot\n        inject SFC packets that will be accepted for processing into\
    \ the\n        domain.  This border security MUST include any tunnels to other\n\
    \        domains.  If those tunnels are to be used for SFC without\n        reclassification,\
    \ then the tunnel MUST include additional\n        techniques to ensure the integrity\
    \ and validity of such packets.\n   Classification:  Classification is used at\
    \ the ingress edge of an\n        SFC-enabled domain.  Policy for this classification\
    \ is done\n        using a plurality of methods.  Whatever method is used needs\
    \ to\n        consider a range of security issues.  These include appropriate\n\
    \        authentication and authorization of classification policy,\n        potential\
    \ confidentiality issues of that policy, protection\n        against corruption,\
    \ and proper application of policy with needed\n        segregation of application.\
    \  This includes proper controls on\n        the policies that drive the application\
    \ of the SFC encapsulation\n        and associated metadata to packets.  Similar\
    \ issues need to be\n        addressed if classification is performed within a\
    \ service\n        chaining domain, i.e., reclassification.\n   SFC Encapsulation:\
    \  The SFC encapsulation provides at a minimum SFP\n        identification, and\
    \ carries metadata.  An operator may consider\n        the SFC Metadata as sensitive.\
    \  From a privacy perspective, a\n        user may be concerned about the operator\
    \ revealing data about\n        (and not belonging to) the customer.  Therefore,\
    \ solutions\n        should consider whether there is a risk of sensitive information\n\
    \        slipping out of the operator's control.  Issues of information\n    \
    \    exposure should also consider flow analysis.  Further, when a\n        specific\
    \ metadata element is defined, it should be carefully\n        considered whether\
    \ origin authentication is needed for it.\n        A classifier may have privileged\
    \ access to information about a\n        packet or inside a packet (see Section\
    \ 3, item 4, and\n        Section 4.9) that is then communicated in the metadata.\
    \  The\n        threat of leaking this private data needs to be mitigated\n  \
    \      [RFC6973].  As one example, if private data is represented by an\n    \
    \    identifier, then a new identifier can be allocated, such that\n        the\
    \ mapping from the private data to the new identifier is not\n        broadly\
    \ shared.\n        Some metadata added to and carried in SFC packets is sensitive\n\
    \        for various reasons, including potentially revealing personally\n   \
    \     identifying information.  Realizations of the architecture MUST\n      \
    \  protect such information to ensure that it is handled with\n        suitable\
    \ care and precautions against inappropriate\n        dissemination.  This can\
    \ have implications to the data plane,\n        the control plane, or both.  Data-plane\
    \ protocol definitions for\n        SFC can include suitable provisions to protect\
    \ such information\n        for use when handling sensitive information, with\
    \ packet or SFP\n        granularity.  Equally, the control mechanisms used with\
    \ SFC can\n        have provisions to determine that such mechanisms are available,\n\
    \        and to ensure that they are used when needed.  Inability to do\n    \
    \    so needs to result in error indications to appropriate\n        management\
    \ systems.  In particular, when the control systems\n        know that sensitive\
    \ information may potentially be added to\n        packets at certain points on\
    \ certain service chains, the control\n        mechanism MUST verify that appropriate\
    \ protective treatment of\n        NSH information is available from the point\
    \ where the\n        information is added to the point where it will be removed.\
    \  If\n        such mechanisms are unavailable, error notifications SHOULD be\n\
    \        generated.\n   Additionally, SFC OAM functions need to not negatively\
    \ affect the\n   security considerations of an SFC-enabled domain.\n   Finally,\
    \ all entities (software or hardware) interacting with the\n   service chaining\
    \ mechanisms need to provide means of security against\n   malformed, poorly configured\
    \ (deliberate or not) protocol constructs\n   and loops.  These considerations\
    \ are largely the same as those in any\n   network, particularly an overlay network.\n"
- title: 7.  References
  contents:
  - '7.  References

    '
- title: 7.1.  Normative References
  contents:
  - "7.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n  \
    \            DOI 10.17487/RFC2119, March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n"
- title: 7.2.  Informative References
  contents:
  - "7.2.  Informative References\n   [Boucadair2014]\n              Boucadair, M.,\
    \ Jacquenet, C., Parker, R., Lopez, D.,\n              Guichard, J., and C. Pignataro,\
    \ \"Service Function\n              Chaining: Framework & Architecture\", Work\
    \ in Progress,\n              draft-boucadair-sfc-framework-02, February 2014.\n\
    \   [Quinn2014]\n              Quinn, P. and J. Halpern, \"Service Function Chaining\
    \ (SFC)\n              Architecture\", Work in Progress, draft-quinn-sfc-arch-05,\n\
    \              May 2014.\n   [RFC3022]  Srisuresh, P. and K. Egevang, \"Traditional\
    \ IP Network\n              Address Translator (Traditional NAT)\", RFC 3022,\n\
    \              DOI 10.17487/RFC3022, January 2001,\n              <http://www.rfc-editor.org/info/rfc3022>.\n\
    \   [RFC6146]  Bagnulo, M., Matthews, P., and I. van Beijnum, \"Stateful\n   \
    \           NAT64: Network Address and Protocol Translation from IPv6\n      \
    \        Clients to IPv4 Servers\", RFC 6146, DOI 10.17487/RFC6146,\n        \
    \      April 2011, <http://www.rfc-editor.org/info/rfc6146>.\n   [RFC6296]  Wasserman,\
    \ M. and F. Baker, \"IPv6-to-IPv6 Network Prefix\n              Translation\"\
    , RFC 6296, DOI 10.17487/RFC6296, June 2011,\n              <http://www.rfc-editor.org/info/rfc6296>.\n\
    \   [RFC6973]  Cooper, A., Tschofenig, H., Aboba, B., Peterson, J.,\n        \
    \      Morris, J., Hansen, M., and R. Smith, \"Privacy\n              Considerations\
    \ for Internet Protocols\", RFC 6973,\n              DOI 10.17487/RFC6973, July\
    \ 2013,\n              <http://www.rfc-editor.org/info/rfc6973>.\n   [RFC7498]\
    \  Quinn, P., Ed. and T. Nadeau, Ed., \"Problem Statement for\n              Service\
    \ Function Chaining\", RFC 7498,\n              DOI 10.17487/RFC7498, April 2015,\n\
    \              <http://www.rfc-editor.org/info/rfc7498>.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   The editors would like to thank Sam Aldrin, Alia Atlas, Nicolas\n\
    \   Bouthors, Stewart Bryant, Linda Dunbar, Alla Goldner, Ken Gray, Barry\n  \
    \ Greene, Anil Gunturu, David Harrington, Shunsuke Homma, Dave Hood,\n   Chris\
    \ Inacio, Nagendra Kumar, Hongyu Li, Andrew Malis, Guy\n   Meador III, Kengo Naito,\
    \ Thomas Narten, Ron Parker, Reinaldo Penno,\n   Naiming Shen, Xiaohu Xu, and\
    \ Lucy Yong for a thorough review and\n   useful comments.\n   The initial draft\
    \ of this document was the result of merging two\n   previous documents, and this\
    \ section lists the acknowledgments from\n   those documents.\n   From \"Service\
    \ Function Chaining (SFC) Architecture\" [Quinn2014]\n      The authors would\
    \ like to thank David Ward, Abhijit Patra, Nagaraj\n      Bagepalli, Darrel Lewis,\
    \ Ron Parker, Lucy Yong, and Christian\n      Jacquenet for their review and comments.\n\
    \   From \"Service Function Chaining (SF) - Framework and Architecture\"\n   [Boucadair2014]:\n\
    \      Many thanks to D. Abgrall, D. Minodier, Y. Le Goff, D. Cheng,\n      R.\
    \ White, and B. Chatras for their review and comments.\n"
- title: Contributors
  contents:
  - "Contributors\n   As noted above, this document is the result of merging two previous\n\
    \   documents.  This section lists those who provided important ideas and\n  \
    \ text that fed into this architecture.\n   The authors of \"Service Function\
    \ Chaining (SFC) - Framework and\n   Architecture\" [Boucadair2014] were:\n  \
    \    Mohamed Boucadair\n      Christian Jacquenet\n      Ron Parker\n      Diego\
    \ R. Lopez\n      Jim Guichard\n      Carlos Pignataro\n   The contributors were:\n\
    \      Parviz Yegani\n      Paul Quinn\n      Linda Dunbar\n   The authors of\
    \ \"Service Function Chaining (SFC) Architecture\"\n   [Quinn2014] were:\n   \
    \   Paul Quinn (editor)\n      Joel Halpern (editor)\n   The contributors were:\n\
    \      Puneet Agarwal\n      Andre Beliveau\n      Kevin Glavin\n      Ken Gray\n\
    \      Jim Guichard\n      Surendra Kumar\n      Darrel Lewis\n      Nic Leymann\n\
    \      Rajeev Manur\n      Thomas Nadeau\n      Carlos Pignataro\n      Michael\
    \ Smith\n      Navindra Yadav\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Joel Halpern (editor)\n   Ericsson\n   Email: jmh@joelhalpern.com\n\
    \   Carlos Pignataro (editor)\n   Cisco Systems, Inc.\n   Email: cpignata@cisco.com\n"
