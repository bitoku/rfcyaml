- title: __initial_text__
  contents:
  - ''
- title: Internet Research Task Force (IRTF)                             M. Mosko
  contents:
  - "Internet Research Task Force (IRTF)                             M. Mosko\n  \
    \            Content-Centric Networking (CCNx) Semantics\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes the core concepts of the Content-Centric\n\
    \   Networking (CCNx) architecture and presents a network protocol based\n   on\
    \ two messages: Interests and Content Objects.  It specifies the set\n   of mandatory\
    \ and optional fields within those messages and describes\n   their behavior and\
    \ interpretation.  This architecture and protocol\n   specification is independent\
    \ of a specific wire encoding.\n   The protocol also uses a control message called\
    \ an Interest Return,\n   whereby one system can return an Interest message to\
    \ the previous hop\n   due to an error condition.  This indicates to the previous\
    \ hop that\n   the current system will not respond to the Interest.\n   This document\
    \ is a product of the Information-Centric Networking\n   Research Group (ICNRG).\
    \  The document received wide review among\n   ICNRG participants.  Two full implementations\
    \ are in active use and\n   have informed the technical maturity of the protocol\
    \ specification.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This document is a product of the Internet Research Task\n   Force (IRTF).\
    \  The IRTF publishes the results of Internet-related\n   research and development\
    \ activities.  These results might not be\n   suitable for deployment.  This RFC\
    \ represents the consensus of the\n   Information-Centric Networking Research\
    \ Group of the Internet\n   Research Task Force (IRTF).  Documents approved for\
    \ publication by\n   the IRSG are not candidates for any level of Internet Standard;\
    \ see\n   Section 2 of RFC 7841.\n   Information about the current status of this\
    \ document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   https://www.rfc-editor.org/info/rfc8569.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2019 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   4\n     1.1.  Requirements Language . . . . . . . . . . . . . .\
    \ . . . .   5\n     1.2.  Architecture  . . . . . . . . . . . . . . . . . . .\
    \ . . .   5\n     1.3.  Protocol Overview . . . . . . . . . . . . . . . . . .\
    \ . .   6\n   2.  Protocol  . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ .  10\n     2.1.  Message Grammar . . . . . . . . . . . . . . . . . . . . .\
    \  10\n     2.2.  Consumer Behavior . . . . . . . . . . . . . . . . . . . .  14\n\
    \     2.3.  Publisher Behavior  . . . . . . . . . . . . . . . . . . .  15\n  \
    \   2.4.  Forwarder Behavior  . . . . . . . . . . . . . . . . . . .  16\n    \
    \   2.4.1.  Interest HopLimit . . . . . . . . . . . . . . . . . .  16\n      \
    \ 2.4.2.  Interest Aggregation  . . . . . . . . . . . . . . . .  17\n       2.4.3.\
    \  Content Store Behavior  . . . . . . . . . . . . . . .  19\n       2.4.4.  Interest\
    \ Pipeline . . . . . . . . . . . . . . . . . .  19\n       2.4.5.  Content Object\
    \ Pipeline . . . . . . . . . . . . . . .  20\n   3.  Names . . . . . . . . . .\
    \ . . . . . . . . . . . . . . . . . .  21\n     3.1.  Name Examples . . . . .\
    \ . . . . . . . . . . . . . . . . .  23\n     3.2.  Interest Payload ID . . .\
    \ . . . . . . . . . . . . . . . .  23\n   4.  Cache Control . . . . . . . . .\
    \ . . . . . . . . . . . . . . .  23\n   5.  Content Object Hash . . . . . . .\
    \ . . . . . . . . . . . . . .  24\n   6.  Link  . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . . .  24\n   7.  Hashes  . . . . . . . . . . . . . . .\
    \ . . . . . . . . . . . .  25\n   8.  Validation  . . . . . . . . . . . . . .\
    \ . . . . . . . . . . .  25\n     8.1.  Validation Algorithm  . . . . . . . .\
    \ . . . . . . . . . .  25\n     8.2.  Message Integrity Codes . . . . . . . .\
    \ . . . . . . . . .  26\n     8.3.  Message Authentication Codes  . . . . . .\
    \ . . . . . . . .  26\n     8.4.  Signature . . . . . . . . . . . . . . . . .\
    \ . . . . . . .  26\n   9.  Interest to Content Object Matching . . . . . . .\
    \ . . . . . .  28\n   10. Interest Return . . . . . . . . . . . . . . . . . .\
    \ . . . . .  29\n     10.1.  Message Format . . . . . . . . . . . . . . . . .\
    \ . . . .  30\n     10.2.  ReturnCode Types . . . . . . . . . . . . . . . . .\
    \ . . .  31\n     10.3.  Interest Return Protocol . . . . . . . . . . . . . .\
    \ . .  32\n       10.3.1.  No Route . . . . . . . . . . . . . . . . . . . . .\
    \ .  32\n       10.3.2.  HopLimit Exceeded  . . . . . . . . . . . . . . . . .\
    \  33\n       10.3.3.  Interest MTU Too Large . . . . . . . . . . . . . . .  33\n\
    \       10.3.4.  No Resources . . . . . . . . . . . . . . . . . . . .  33\n  \
    \     10.3.5.  Path Error . . . . . . . . . . . . . . . . . . . . .  33\n    \
    \   10.3.6.  Prohibited . . . . . . . . . . . . . . . . . . . . .  33\n      \
    \ 10.3.7.  Congestion . . . . . . . . . . . . . . . . . . . . .  34\n       10.3.8.\
    \  Unsupported Content Object Hash Algorithm  . . . . .  34\n       10.3.9.  Malformed\
    \ Interest . . . . . . . . . . . . . . . . .  34\n   11. IANA Considerations .\
    \ . . . . . . . . . . . . . . . . . . . .  34\n   12. Security Considerations\
    \ . . . . . . . . . . . . . . . . . . .  34\n   13. References  . . . . . . .\
    \ . . . . . . . . . . . . . . . . . .  37\n     13.1.  Normative References .\
    \ . . . . . . . . . . . . . . . . .  37\n     13.2.  Informative References .\
    \ . . . . . . . . . . . . . . . .  37\n   Authors' Addresses  . . . . . . . .\
    \ . . . . . . . . . . . . . . .  40\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document describes the principles of the CCNx architecture.\
    \  It\n   describes a network protocol that uses a hierarchical name to forward\n\
    \   requests and to match responses to requests.  It does not use\n   endpoint\
    \ addresses, such as Internet Protocol.  Restrictions in a\n   request can limit\
    \ the response by the public key of the response's\n   signer or the cryptographic\
    \ hash of the response.  Every CCNx\n   forwarder along the path does the name\
    \ matching and restriction\n   checking.  The CCNx protocol fits within the broader\
    \ framework of\n   Information-Centric Networking (ICN) protocols [RFC7927]. \
    \ This\n   document concerns the semantics of the protocol and is not dependent\n\
    \   on a specific wire encoding.  The CCNx Messages [RFC8609] document\n   describes\
    \ a type-length-value (TLV) wire-protocol encoding.  This\n   section introduces\
    \ the main concepts of CCNx, which are further\n   elaborated in the remainder\
    \ of the document.\n   The CCNx protocol derives from the early ICN work by Jacobson,\
    \ et al.\n   [nnc].  Jacobson's version of CCNx is known as the 0.x version (\"\
    CCNx\n   0.x\"), and the present work is known as the 1.0 version (\"CCNx 1.0\"\
    ).\n   There are two active implementations of CCNx 1.0.  The most complete\n\
    \   implementation is Community ICN (CICN) [cicn], a Linux Foundation\n   project\
    \ hosted at fd.io.  Another active implementation is CCN-lite\n   [ccn-lite],\
    \ with support for Internet of Things (IoT) systems and the\n   RIOT operating\
    \ system.  CCNx 0.x formed the basis of the Named Data\n   Networking (NDN) [ndn]\
    \ university project.\n   The current CCNx 1.0 specification diverges from CCNx\
    \ 0.x in a few\n   significant areas.  The most pronounced behavioral difference\
    \ between\n   CCNx 0.x and CCNx 1.0 is that CCNx 1.0 has a simpler response\n\
    \   processing behavior.  In both versions, a forwarder uses a\n   hierarchical\
    \ longest prefix match of a request name against the\n   forwarding information\
    \ base (FIB) to send the request through the\n   network to a system that can\
    \ issue a response.  A forwarder must then\n   match a response's name to a request's\
    \ name to determine the reverse\n   path and deliver the response to the requester.\
    \  In CCNx 0.x, the\n   Interest name may be a hierarchical prefix of the response\
    \ name,\n   which allows a form of Layer 3 (L3) content discovery.  In CCNx 1.0,\n\
    \   a response's name must exactly equal a request's name.  Content\n   discovery\
    \ is performed by a higher-layer protocol.\n   The selector protocol \"CCNx Selectors\"\
    \ [selectors] is an example of\n   using a higher-layer protocol on top of the\
    \ CCNx 1.0 L3 to perform\n   content discovery.  The selector protocol uses a\
    \ method similar to\n   the original CCNx 0.x techniques without requiring partial\
    \ name\n   matching of a response to a request in the forwarder.\n   This document\
    \ represents the consensus of the Information-Centric\n   Networking Research\
    \ Group (ICNRG).  It is the first ICN protocol from\n   the RG, created from the\
    \ early CCNx protocol [nnc] with significant\n   revision and input from the ICN\
    \ community and RG members.  This\n   document has received critical reading by\
    \ several members of the ICN\n   community and the RG.  The authors and RG chairs\
    \ approve of the\n   contents.  This document is sponsored under the IRTF, is\
    \ not issued\n   by the IETF, and is not an IETF standard.  This is an experimental\n\
    \   protocol and may not be suitable for any specific application.  The\n   specification\
    \ may change in the future.\n"
- title: 1.1.  Requirements Language
  contents:
  - "1.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted\
    \ as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear\
    \ in all\n   capitals, as shown here.\n"
- title: 1.2.  Architecture
  contents:
  - "1.2.  Architecture\n   We describe the architecture of the network in which CCNx\
    \ operates\n   and introduce certain terminology from [terminology].  The detailed\n\
    \   behavior of each component and message grammar is in Section 2.\n   A producer\
    \ (also called a \"publisher\") is an endpoint that\n   encapsulates content in\
    \ Content Objects for transport in the CCNx\n   network.  A producer has a public/private\
    \ keypair and signs (directly\n   or indirectly) the Content Objects.  Usually,\
    \ the producer's KeyId\n   (hash of the public key) is well known or may be derived\
    \ from the\n   producer's namespace via standard means.\n   A producer operates\
    \ within one or more namespaces.  A namespace is a\n   name prefix that is represented\
    \ in the forwarding information base\n   (FIB).  This allows a request to reach\
    \ the producer and fetch a\n   response (if one exists).\n   The FIB is a table\
    \ that tells a forwarder where to send a request.\n   It may point to a local\
    \ application, a local cache or Content Store,\n   or to a remote system.  If\
    \ there is no matching entry in the FIB, a\n   forwarder cannot process a request.\
    \  The detailed rules on name\n   matching to the FIB are given in Section 2.4.4.\
    \  An endpoint has a\n   FIB, though it may be a simple default route.  An intermediate\
    \ system\n   (i.e., a router) typically has a much larger FIB.  A core CCNx\n\
    \   forwarder, for example, would know all the global routes.\n   A consumer is\
    \ an endpoint that requests a name.  It is beyond the\n   scope of this document\
    \ to describe how a consumer learns of a name or\n   publisher KeyId; higher-layer\
    \ protocols built on top of CCNx handle\n   those tasks, such as search engines\
    \ or lookup services or well-known\n   names.  The consumer constructs a request,\
    \ called an Interest, and\n   forwards it via the endpoint's FIB.  The consumer\
    \ should get back\n   either a response (called a Content Object) that matches\
    \ the Interest\n   or a control message (called an Interest Return) that indicates\
    \ the\n   network cannot handle the request.\n   There are three ways to detect\
    \ errors in Interest handling.  An\n   Interest Return is a network control message\
    \ that indicates a low-\n   level error like \"no route\" or \"out of resources\"\
    .  If an Interest\n   arrives at a producer, but the producer does not have the\
    \ requested\n   content, the producer should send an application-specific error\n\
    \   message (e.g., a \"not found\" message).  Finally, a consumer may not\n  \
    \ receive anything; in which case, it should timeout and, depending on\n   the\
    \ application, retry the request or return an error to the\n   application.\n"
- title: 1.3.  Protocol Overview
  contents:
  - "1.3.  Protocol Overview\n   The goal of CCNx is to name content and retrieve\
    \ the content from the\n   network without binding it to a specific network endpoint.\
    \  A routing\n   system (specified separately) populates the FIB tables at each\
    \ CCNx\n   router with hierarchical name prefixes that point towards the content\n\
    \   producers under that prefix.  A request finds matching content along\n   those\
    \ paths, in which case a response carries the data, or, if no\n   match is found,\
    \ a control message indicates the failure.  A request\n   may further refine acceptable\
    \ responses with a restriction on the\n   response's signer and the cryptographic\
    \ hash of the response.  The\n   details of these restrictions are described below.\n\
    \   The CCNx name is a hierarchical series of name segments.  Each name\n   segment\
    \ has a type and zero or more bytes.  Matching two names is\n   done as a binary\
    \ comparison of the type and value, and is done\n   segment by segment.  The human-readable\
    \ form is defined under a URI\n   scheme \"ccnx:\" [ccnx-uri], though the canonical\
    \ encoding of a name is\n   a series of pairs (type, octet string).  There is\
    \ no requirement that\n   any name segment be human readable or UTF-8.  The first\
    \ few segments\n   in a name will be matched against the FIB, and a routing protocol\
    \ may\n   put its own restrictions on the routable name components (e.g., a\n\
    \   maximum length or character-encoding rules).  In principle, name\n   segments\
    \ and names have unbounded length, though in practice they are\n   limited by\
    \ the wire encoding and practical considerations imposed by\n   a routing protocol.\
    \  Note that in CCNx, name segments use binary\n   comparison, whereas in a URI,\
    \ the authority uses a case-insensitive\n   hostname (due to DNS).\n   The CCNx\
    \ name, as used by the forwarder, is purposefully left as a\n   general octet-encoded\
    \ type and value without any requirements on\n   human readability and character\
    \ encoding.  The reason for this is\n   that we are concerned with how a forwarder\
    \ processes names.  We\n   expect that applications, routing protocols, or other\
    \ higher layers\n   will apply their own conventions and restrictions on the allowed\
    \ name\n   segment types and name segment values.\n   CCNx is a request and response\
    \ protocol that fetches chunks of data\n   using a name.  The integrity of each\
    \ chunk may be directly asserted\n   through a digital signature or Message Authentication\
    \ Code (MAC), or,\n   alternatively, indirectly via hash chains.  Chunks may also\
    \ carry\n   weaker Message Integrity Codes (MICs) or no integrity protection\n\
    \   mechanism at all.  Because provenance information is carried with\n   each\
    \ chunk (or larger indirectly protected block), we no longer need\n   to rely\
    \ on host identities, such as those derived from TLS\n   certificates, to ascertain\
    \ the chunk legitimacy.  Therefore, data\n   integrity is a core feature of CCNx;\
    \ it does not rely on the data\n   transmission channel.  There are several options\
    \ for data\n   confidentiality, discussed later.\n   This document only defines\
    \ the general properties of CCNx names.  In\n   some isolated environments, CCNx\
    \ users may be able to use any name\n   they choose and either inject that name\
    \ (or prefix) into a routing\n   protocol or use other information foraging techniques.\
    \  In the\n   Internet environment, there will be policies around the formats\
    \ of\n   names and assignments of names to publishers, though those are not\n\
    \   specified here.\n   The key concept of CCNx is that a subjective name is\n\
    \   cryptographically bound to a fixed payload.  These publisher-\n   generated\
    \ bindings can therefore be cryptographically verified.  A\n   named payload is\
    \ thus the tuple {{Name, ExtraFields, Payload,\n   ValidationAlgorithm}, ValidationPayload},\
    \ where all fields in the\n   inner tuple are covered by the validation payload\
    \ (e.g., signature).\n   Consumers of this data can check the binding integrity\
    \ by recomputing\n   the same cryptographic hash and verifying the digital signature\
    \ in\n   ValidationPayload.\n   In addition to digital signatures (e.g., RSA),\
    \ CCNx also supports\n   message authentication codes (e.g., Hashed Message Authentication\n\
    \   Code (HMAC)) and message integrity codes (e.g., Cyclic Redundancy\n   Checks\
    \ (CRC)).  To maintain the cryptographic binding, there should\n   be at least\
    \ one object with a signature or authentication code, but\n   not all objects\
    \ require it.  For example, a first object with a\n   signature could refer to\
    \ other objects via a hash chain, a Merkle\n   tree, or a signed manifest.  The\
    \ later objects may not have any\n   validation and rely purely on the references.\
    \  The use of an\n   integrity code (e.g., CRC) is intended for detecting accidental\n\
    \   corruption in an Interest.\n   CCNx specifies a network protocol around Interests\
    \ (request messages)\n   and Content Objects (response messages) to move named\
    \ payloads.  An\n   Interest includes the Name field, which identifies the desired\n\
    \   response, and optional matching restrictions.  Restrictions limit the\n  \
    \ possible matching Content Objects.  Two restrictions exist: the Key\n   ID restriction\
    \ (KeyIdRestr) and Content Object Hash restriction\n   (ContentObjectHashRestr).\
    \  The first restriction on the KeyId limits\n   responses to those signed with\
    \ a ValidationAlgorithm KeyId field\n   equal to the restriction.  The second\
    \ is the Content Object Hash\n   restriction, which limits the response to one\
    \ where the cryptographic\n   hash of the entire named payload is equal to the\
    \ restriction.\n   Section 9 fully explains how these restrictions limit matching\
    \ of a\n   Content Object to an Interest.\n   The hierarchy of a CCNx name is\
    \ used for routing via the longest\n   matching prefix in a forwarder.  The longest\
    \ matching prefix is\n   computed name segment by name segment in the hierarchical\
    \ name, where\n   each name segment must be exactly equal to match.  There is\
    \ no\n   requirement that the prefix be globally routable.  Within a\n   deployment,\
    \ any local routing may be used, even one that only uses a\n   single flat (nonhierarchical)\
    \ name segment.\n   Another concept of CCNx is that there should be flow balance\
    \ between\n   Interest messages and Content Object messages.  At the network level,\n\
    \   an Interest traveling along a single path should elicit no more than\n   one\
    \ Content Object response.  If some node sends the Interest along\n   more than\
    \ one path, that node should consolidate the responses such\n   that only one\
    \ Content Object flows back towards the requester.  If an\n   Interest is sent\
    \ broadcast or multicast on a multiple-access media,\n   the sender should be\
    \ prepared for multiple responses unless some\n   other media-dependent mechanism\
    \ like gossip suppression or leader\n   election is used.\n   As an Interest travels\
    \ the forward path following the FIB, it\n   establishes state at each forwarder\
    \ such that a Content Object\n   response can trace its way back to the original\
    \ requester(s) without\n   the requester needing to include a routable return\
    \ address.  We use\n   the notional Pending Interest Table (PIT) as a method to\
    \ store state\n   that facilitates the return of a Content Object.\n   The notional\
    \ PIT stores the last hop of an Interest plus its Name\n   field and optional\
    \ restrictions.  This is the data required to match\n   a Content Object to an\
    \ Interest (see Section 9).  When a Content\n   Object arrives, it must be matched\
    \ against the PIT to determine which\n   entries it satisfies.  For each such\
    \ entry, at most one copy of the\n   Content Object is sent to each listed last\
    \ hop in the PIT entries.\n   An actual PIT is not mandated by this specification.\
    \  An\n   implementation may use any technique that gives the same external\n\
    \   behavior.  There are, for example, research papers that use\n   techniques\
    \ like label switching in some parts of the network to\n   reduce the per-node\
    \ state incurred by the PIT [dart].  Some\n   implementations store the PIT state\
    \ in the FIB, so there is not a\n   second table.\n   If multiple Interests with\
    \ the same {Name, [KeyIdRestr],\n   [ContentObjectHashRestr]} tuple arrive at\
    \ a node before a Content\n   Object matching the first Interest comes back, they\
    \ are grouped in\n   the same PIT entry and their last hops are aggregated (see\n\
    \   Section 2.4.2).  Thus, one Content Object might satisfy multiple\n   pending\
    \ Interests in a PIT.\n   In CCNx, higher-layer protocols are often called \"\
    name-based\n   protocols\" because they operate on the CCNx name.  For example,\
    \ a\n   versioning protocol might append additional name segments to convey\n\
    \   state about the version of payload.  A content discovery protocol\n   might\
    \ append certain protocol-specific name segments to a prefix to\n   discover content\
    \ under that prefix.  Many such protocols may exist\n   and apply their own rules\
    \ to names.  They may be layered with each\n   protocol encapsulating (to the\
    \ left) a higher layer's name prefix.\n   This document also describes a control\
    \ message called an Interest\n   Return.  A network element may return an Interest\
    \ message to a\n   previous hop if there is an error processing the Interest.\
    \  The\n   returned Interest may be further processed at the previous hop or\n\
    \   returned towards the Interest origin.  When a node returns an\n   Interest,\
    \ it indicates that the previous hop should not expect a\n   response from that\
    \ node for the Interest, i.e., there is no PIT entry\n   left at the returning\
    \ node for a Content Object to follow.\n   There are multiple ways to describe\
    \ larger objects in CCNx.\n   Aggregating L3 Content Objects into larger objects\
    \ is beyond the\n   scope of this document.  One proposed method, File-Like ICN\n\
    \   Collection (FLIC) [flic], uses a manifest to enumerate the pieces of\n   a\
    \ larger object.  Manifests are, themselves, Content Objects.\n   Another option\
    \ is to use a convention in the Content Object name, as\n   in the CCNx Chunking\
    \ [chunking] protocol where a large object is\n   broken into small chunks and\
    \ each chunk receives a special name\n   component indicating its serial order.\n\
    \   At the semantic level, described in this document, we do not address\n   fragmentation.\
    \  One experimental fragmentation protocol, BeginEnd\n   Fragments [befrags],\
    \ uses a multipoint PPP-style technique for use\n   over L2 interfaces with the\
    \ specification for CCNx Messages [RFC8609]\n   in TLV wire encoding.\n   With\
    \ these concepts, the remainder of the document specifies the\n   behavior of\
    \ a forwarder in processing Interest, Content Object, and\n   Interest Return\
    \ messages.\n"
- title: 2.  Protocol
  contents:
  - "2.  Protocol\n   This section defines the grammar of a CCNx Message (Interest,\
    \ Content\n   Object, or Interest Return).  It then presents typical behaviors\
    \ for\n   a consumer, a publisher, and a forwarder.  In the forwarder section,\n\
    \   there are detailed descriptions about how to handle the forwarder-\n   specific\
    \ topics, such as HopLimit and Content Store, along with\n   detailed processing\
    \ pipelines for Interest and Content Object\n   messages.\n"
- title: 2.1.  Message Grammar
  contents:
  - "2.1.  Message Grammar\n   The CCNx Message ABNF [RFC5234] grammar is shown in\
    \ Figure 1.  The\n   grammar does not include any encoding delimiters, such as\
    \ TLVs.\n   Specific wire encodings are given in a separate document.  If a\n\
    \   Validation section exists, the Validation Algorithm covers from the\n   Body\
    \ (BodyName or BodyOptName) through the end of the ValidationAlg\n   section.\
    \  The InterestLifetime, CacheTime, and Return Code fields\n   exist outside of\
    \ the validation envelope and may be modified.\n   HashType, PayloadType, and\
    \ Private Enterprise Number (PEN) need to\n   correspond to IANA values registered\
    \ in the \"CCNx Hash Function\n   Types\" and \"CCNx Payload Types\" registries\
    \ [ccnx-registry], as well\n   as the \"Private Enterprise Numbers\" registry\
    \ [eprise-numbers],\n   respectively.\n   The various fields, in alphabetical\
    \ order, are defined as:\n   AbsTime:  Absolute times are conveyed as the 64-bit\
    \ UTC time in\n      milliseconds since the epoch (standard POSIX time).\n   CacheTime:\
    \  The absolute time after which the publisher believes\n      there is low value\
    \ in caching the Content Object.  This is a\n      recommendation to caches (see\
    \ Section 4).\n   Cert:  Some applications may wish to embed an X.509 certificate\
    \ to\n      both validate the signature and provide a trust anchor.  The Cert\n\
    \      is a DER-encoded X.509 certificate.\n   ConObjField:  These are optional\
    \ fields that may appear in a Content\n      Object.\n   ConObjHash:  The value\
    \ of the Content Object Hash, which is the\n      SHA256-32 over the message from\
    \ the beginning of the body to the\n      end of the message.  Note that this\
    \ coverage area is different\n      from the ValidationAlg.  This value SHOULD\
    \ NOT be trusted across\n      domains (see Section 5).\n   ContentObjectHashRestr:\
    \  The Content Object Hash restriction.  A\n      Content Object must hash to\
    \ the same value as the restriction\n      using the same HashType.  The ContentObjectHashRestr\
    \ MUST use\n      SHA256-32.\n   ExpiryTime:  An absolute time after which the\
    \ Content Object should\n      be considered expired (see Section 4).\n   Hash:\
    \  Hash values carried in a Message carry a HashType to identify\n      the algorithm\
    \ used to generate the hash followed by the hash\n      value.  This form is to\
    \ allow hash agility.  Some fields may\n      mandate a specific HashType.\n \
    \  HashType:  The algorithm used to calculate a hash, which must\n      correspond\
    \ to one of the IANA \"CCNx Hash Function Types\"\n      [ccnx-registry].\n  \
    \ HopLimit:  Interest messages may loop if there are loops in the\n      forwarding\
    \ plane.  To eventually terminate loops, each Interest\n      carries a HopLimit\
    \ that is decremented after each hop and no\n      longer forwarded when it reaches\
    \ zero.  See Section 2.4.\n   InterestField:  These are optional fields that may\
    \ appear in an\n      Interest message.\n   KeyId:  An identifier for the key\
    \ used in the ValidationAlg.  See\n      Validation (Section 8) for a description\
    \ of how it is used for\n      MACs and signatures.\n   KeyIdRestr:  The KeyId\
    \ Restriction.  A Content Object must have a\n      KeyId with the same value\
    \ as the restriction.\n   KeyLink:  A Link (see Section 6) that names how to retrieve\
    \ the key\n      used to verify the ValidationPayload (see Section 8).\n   Lifetime:\
    \  The approximate time during which a requester is willing\n      to wait for\
    \ a response, usually measured in seconds.  It is not\n      strongly related\
    \ to the network round-trip time, though it must\n      necessarily be larger.\n\
    \   Name:  A name is made up of a nonempty first segment followed by zero\n  \
    \    or more additional segments, which may be of 0 length.  Name\n      segments\
    \ are opaque octet strings and are thus case sensitive if\n      encoding UTF-8.\
    \  An Interest MUST have a Name.  A Content Object\n      MAY have a Name (see\
    \ Section 9).  The segments of a name are said\n      to be complete if its segments\
    \ uniquely identify a single Content\n      Object.  A name is exact if its segments\
    \ are complete.  An\n      Interest carrying a full name is one that specifies\
    \ an exact name\n      and the Content Object Hash restriction of the corresponding\n\
    \      Content Object.\n   Payload:  The message's data, as defined by PayloadType.\n\
    \   PayloadType:  The format of the Payload field.  If missing, assume\n     \
    \ Data type (T_PAYLOADTYPE_DATA) [ccnx-registry].  Data type means\n      the\
    \ payload is opaque application bytes.  Key type\n      (T_PAYLOADTYPE_KEY [ccnx-registry])\
    \ means the payload is a DER-\n      encoded public key or X.509 certificate.\
    \  Link type\n      (T_PAYLOADTYPE_LINK [ccnx-registry]) means it is one or more\
    \ Links\n      (see Section 6).\n   PublicKey:  Some applications may wish to\
    \ embed the public key used\n      to verify the signature within the message\
    \ itself.  The PublickKey\n      is DER encoded.\n   RelTime:  A relative time,\
    \ measured in milliseconds.\n   ReturnCode:  States the reason an Interest message\
    \ is being returned\n      to the previous hop (see Section 10.2).\n   SigTime:\
    \  The absolute time (UTC milliseconds) when the signature was\n      generated.\
    \  The signature time only applies to the validation\n      algorithm; it does\
    \ not necessarily represent when the validated\n      message was created.\n \
    \  Vendor:  Vendor-specific opaque data.  The Vendor data includes the\n     \
    \ IANA Private Enterprise Numbers [eprise-numbers], followed by\n      vendor-specific\
    \ information.  CCNx allows vendor-specific data in\n      most locations of the\
    \ grammar.\n   Message       = Interest / ContentObject / InterestReturn\n   Interest\
    \      = IntHdr BodyName [Validation]\n   IntHdr        = HopLimit [Lifetime]\
    \ *Vendor\n   ContentObject = ConObjHdr BodyOptName [Validation]\n   ConObjHdr\
    \     = [CacheTime / ConObjHash] *Vendor\n   InterestReturn= ReturnCode Interest\n\
    \   BodyName      = Name Common\n   BodyOptName   = [Name] Common\n   Common \
    \       = *Field [Payload]\n   Validation    = ValidationAlg ValidationPayload\n\
    \   Name          = FirstSegment *Segment\n   FirstSegment  = 1*OCTET / Vendor\n\
    \   Segment       = *OCTET / Vendor\n   ValidationAlg = (RSA-SHA256 / EC-SECP-256K1\
    \ / EC-SECP-384R1 /\n                    HMAC-SHA256 / CRC32C) *Vendor\n   ValidationPayload\
    \ = 1*OCTET\n   PublicAlg     = KeyId [SigTime] [KeyLink] [PublicKey] [Cert]\n\
    \   RSA-SHA256    = PublicAlg\n   EC-SECP-256K1 = PublicAlg\n   EC-SECP-384R1\
    \ = PublicAlg\n   HMAC-SHA256   = KeyId [SigTime] [KeyLink]\n   CRC32C       \
    \ = [SigTime]\n   AbsTime       = 8OCTET ; 64-bit UTC msec since epoch\n   CacheTime\
    \     = AbsTime\n   ConObjField   = ExpiryTime / PayloadType\n   ConObjHash  \
    \  = Hash\n   ExpiryTime    = AbsTime\n   Field         = InterestField / ConObjField\
    \ / Vendor\n   Hash          = HashType 1*OCTET\n   HashType      = 2OCTET ; IANA\
    \ \"CCNx Hash Function Types\"\n   HopLimit      = OCTET\n   InterestField = KeyIdRestr\
    \ / ContentObjectHashRestr\n   KeyId         = Hash\n   KeyIdRestr    = Hash\n\
    \   KeyLink       = Link\n   Lifetime      = RelTime\n   Link          = Name\
    \ [KeyIdRestr] [ContentObjectHashRestr]\n   ContentObjectHashRestr  = Hash\n \
    \  Payload       = *OCTET\n   PayloadType   = OCTET ; IANA \"CCNx Payload Types\"\
    \n   PublicKey     = *OCTET ; DER-encoded public key\n   Cert          = *OCTET\
    \ ; DER-encoded X.509 Certificate\n   RelTime       = 1*OCTET ; msec\n   ReturnCode\
    \    = OCTET ; see Section 10.2\n   SigTime       = AbsTime\n   Vendor       \
    \ = PEN *OCTET\n   PEN           = 1*OCTET ; IANA \"Private Enterprise Number\"\
    \n                    Figure 1: CCNx Message ABNF Grammar\n"
- title: 2.2.  Consumer Behavior
  contents:
  - "2.2.  Consumer Behavior\n   To request a piece of content for a given {Name,\
    \ [KeyIdRest],\n   [ContentObjectHashRestr]} tuple, a consumer creates an Interest\n\
    \   message with those values.  It MAY add a validation section,\n   typically\
    \ only a CRC32C.  A consumer MAY put a Payload field in an\n   Interest to send\
    \ additional data to the producer beyond what is in\n   the name.  The name is\
    \ used for routing and may be remembered at each\n   hop in the notional PIT to\
    \ facilitate returning a Content Object;\n   storing large amounts of state in\
    \ the name could lead to high memory\n   requirements.  Because the payload is\
    \ not considered when forwarding\n   an Interest or matching a Content Object\
    \ to an Interest, a consumer\n   SHOULD put an Interest Payload ID (see Section\
    \ 3.2) as part of the\n   name to allow a forwarder to match Interests to Content\
    \ Objects and\n   avoid aggregating Interests with different payloads.  Similarly,\
    \ if a\n   consumer uses a MAC or a signature, it SHOULD also include a unique\n\
    \   segment as part of the name to prevent the Interest from being\n   aggregated\
    \ with other Interests or satisfied by a Content Object that\n   has no relation\
    \ to the validation.\n   The consumer SHOULD specify an InterestLifetime, which\
    \ is the length\n   of time the consumer is willing to wait for a response.  The\n\
    \   InterestLifetime is an application-scale time, not a network round-\n   trip\
    \ time (see Section 2.4.2).  If not present, the InterestLifetime\n   will use\
    \ a default value (2 seconds).\n   The consumer SHOULD set the Interest HopLimit\
    \ to a reasonable value\n   or use the default 255.  If the consumer knows the\
    \ distances to the\n   producer via routing, it SHOULD use that value.\n   A consumer\
    \ hands off the Interest to its first forwarder, which will\n   then forward the\
    \ Interest over the network to a publisher (or\n   replica) that may satisfy it\
    \ based on the name (see Section 2.4).\n   Interest messages are unreliable. \
    \ A consumer SHOULD run a transport\n   protocol that will retry the Interest\
    \ if it goes unanswered, up to\n   the InterestLifetime.  No transport protocol\
    \ is specified in this\n   document.\n   The network MAY send to the consumer\
    \ an Interest Return message that\n   indicates the network cannot fulfill the\
    \ Interest.  The ReturnCode\n   specifies the reason for the failure, such as\
    \ no route or congestion.\n   Depending on the ReturnCode, the consumer MAY retry\
    \ the Interest or\n   MAY return an error to the requesting application.\n   If\
    \ the content was found and returned by the first forwarder, the\n   consumer\
    \ will receive a Content Object.  The consumer uses the\n   following set of checks\
    \ to validate a received Content Object:\n   o  The consumer MUST ensure the Content\
    \ Object is properly formatted.\n   o  The consumer MUST verify that the returned\
    \ Content Object matches\n      one or more pending Interests as per Section 9.\n\
    \   o  If the Content Object is signed, the consumer SHOULD\n      cryptographically\
    \ verify the signature as per Section 8.  If it\n      does not have the corresponding\
    \ key, it SHOULD fetch the key, such\n      as from a key resolution service or\
    \ via the KeyLink.\n   o  If the signature has a SigTime, the consumer MAY use\
    \ that in\n      considering if the signature is valid.  For example, if the\n\
    \      consumer is asking for dynamically generated content, it should\n     \
    \ expect the SigTime not to be before the time the Interest was\n      generated.\n\
    \   o  If the Content Object is signed, the consumer SHOULD assert the\n     \
    \ trustworthiness of the signing key to the namespace.  Such an\n      assertion\
    \ is beyond the scope of this document, though one may use\n      traditional\
    \ PKI methods, a trusted key resolution service, or\n      methods like [trust].\n\
    \   o  The consumer MAY cache the Content Object for future use, up to\n     \
    \ the ExpiryTime if present.\n   o  The consumer MAY accept a Content Object off\
    \ the wire that is\n      expired.  A packet Content Object may expire while in\
    \ flight;\n      there is no requirement that forwarders drop expired packets\
    \ in\n      flight.  The only requirement is that Content Stores, caches, or\n\
    \      producers MUST NOT respond with an expired Content Object.\n"
- title: 2.3.  Publisher Behavior
  contents:
  - "2.3.  Publisher Behavior\n   This document does not specify the method by which\
    \ names populate a\n   FIB table at forwarders (see Section 2.4).  A publisher\
    \ is either\n   configured with one or more name prefixes under which it may create\n\
    \   content or it chooses its name prefixes and informs the routing layer\n  \
    \ to advertise those prefixes.\n   When a publisher receives an Interest, it SHOULD:\n\
    \   o  Verify that the Interest is part of the publisher's namespace(s).\n   o\
    \  If the Interest has a Validation section, verify it as per\n      Section 8.\
    \  Usually an Interest will only have a CRC32C, unless\n      the publisher application\
    \ specifically accommodates other\n      validations.  The publisher MAY choose\
    \ to drop Interests that\n      carry a Validation section if the publisher application\
    \ does not\n      expect those signatures, as this could be a form of computational\n\
    \      denial of service.  If the signature requires a key that the\n      publisher\
    \ does not have, it is NOT RECOMMENDED that the publisher\n      fetch the key\
    \ over the network unless it is part of the\n      application's expected behavior.\n\
    \   o  Retrieve or generate the requested Content Object and return it to\n  \
    \    the Interest's previous hop.  If the requested content cannot be\n      returned,\
    \ the publisher SHOULD reply with an Interest Return or a\n      Content Object\
    \ with application payload that says the content is\n      not available; this\
    \ Content Object should have a short ExpiryTime\n      in the future or not be\
    \ cacheable (i.e., an expiry time of 0).\n"
- title: 2.4.  Forwarder Behavior
  contents:
  - "2.4.  Forwarder Behavior\n   A forwarder routes Interest messages based on a\
    \ Forwarding\n   Information Base (FIB), returns Content Objects that match Interests\n\
    \   to the Interest's previous hop, and processes Interest Return control\n  \
    \ messages.  It may also keep a cache of Content Objects in the\n   notional Content\
    \ Store table.  This document does not specify the\n   internal behavior of a\
    \ forwarder, only these and other external\n   behaviors.\n   In this document,\
    \ we will use two processing pipelines: one for\n   Interests and one for Content\
    \ Objects.  Interest processing is made\n   up of checking for duplicate Interests\
    \ in the PIT (see\n   Section 2.4.2), checking for a cached Content Object in\
    \ the Content\n   Store (see Section 2.4.3), and forwarding an Interest via the\
    \ FIB.\n   Content Store processing is made up of checking for matching\n   Interests\
    \ in the PIT and forwarding to those previous hops.\n"
- title: 2.4.1.  Interest HopLimit
  contents:
  - "2.4.1.  Interest HopLimit\n   Interest looping is not prevented in CCNx.  An\
    \ Interest traversing\n   loops is eventually discarded using the hop-limit field\
    \ of the\n   Interest, which is decremented at each hop traversed by the Interest.\n\
    \   A loop may also terminate because the Interest is aggregated with its\n  \
    \ previous PIT entry along the loop.  In this case, the Content Object\n   will\
    \ be sent back along the loop and eventually return to a node that\n   already\
    \ forwarded the content, so it will likely not have a PIT entry\n   anymore. \
    \ When the content reaches a node without a PIT entry, it\n   will be discarded.\
    \  It may be that a new Interest or another looped\n   Interest will return to\
    \ that same node, in which case the node will\n   return a cached response to\
    \ make a new PIT entry, as below.\n   The HopLimit is the last resort method to\
    \ stop Interest loops where a\n   Content Object chases an Interest around a loop\
    \ and where the\n   intermediate nodes, for whatever reason, no longer have a\
    \ PIT entry\n   and do not cache the Content Object.\n   Every Interest MUST carry\
    \ a HopLimit.  An Interest received from a\n   local application MAY have a 0\
    \ HopLimit, which restricts the Interest\n   to other local sources.\n   When\
    \ an Interest is received from another forwarder, the HopLimit\n   MUST be positive,\
    \ otherwise the forwarder will discard the Interest.\n   A forwarder MUST decrement\
    \ the HopLimit of an Interest by at least 1\n   before it is forwarded.\n   If\
    \ the decremented HopLimit equals 0, the Interest MUST NOT be\n   forwarded to\
    \ another forwarder; it MAY be sent to a local publisher\n   application or serviced\
    \ from a local Content Store.\n   A RECOMMENDED HopLimit-processing pipeline is\
    \ below:\n   o  If Interest received from a remote system:\n      *  If received\
    \ HopLimit is 0, optionally send Interest Return\n         (HopLimit Exceeded),\
    \ and discard Interest.\n      *  Otherwise, decrement the HopLimit by 1.\n  \
    \ o  Process as per Content Store and Aggregation rules.\n   o  If the Interest\
    \ will be forwarded:\n      *  If the (potentially decremented) HopLimit is 0,\
    \ restrict\n         forwarding to the local system.\n      *  Otherwise, forward\
    \ as desired to local or remote systems.\n"
- title: 2.4.2.  Interest Aggregation
  contents:
  - "2.4.2.  Interest Aggregation\n   Interest aggregation is when a forwarder receives\
    \ an Interest message\n   that could be satisfied by the response to another Interest\
    \ message\n   already forwarded by the node, so the forwarder suppresses forwarding\n\
    \   the new Interest; it only records the additional previous hop so a\n   Content\
    \ Object sent in response to the first Interest will satisfy\n   both Interests.\n\
    \   CCNx uses an Interest aggregation rule that assumes the\n   InterestLifetime\
    \ is akin to a subscription time and is not a network\n   round-trip time.  Some\
    \ previous aggregation rules assumed the\n   lifetime was a round-trip time, but\
    \ this leads to problems of\n   expiring an Interest before a response comes if\
    \ the RTT is estimated\n   too short or interfering with an Automatic Repeat reQuest\
    \ (ARQ)\n   scheme that wants to retransmit an Interest but a prior Interest\n\
    \   overestimated the RTT.\n   A forwarder MAY implement an Interest aggregation\
    \ scheme.  If it does\n   not, then it will forward all Interest messages.  This\
    \ does not imply\n   that multiple, possibly identical, Content Objects will come\
    \ back.  A\n   forwarder MUST still satisfy all pending Interests, so one Content\n\
    \   Object could satisfy multiple similar Interests, even if the\n   forwarder\
    \ did not suppress duplicate Interest messages.\n   A RECOMMENDED Interest aggregation\
    \ scheme is:\n   o  Two Interests are considered \"similar\" if they have the\
    \ same Name,\n      KeyIdRestr, and ContentObjectHashRestr, where a missing optional\n\
    \      field in one must be missing in the other.\n   o  Let the notional value\
    \ InterestExpiry (a local value at the\n      forwarder) be equal to the receive\
    \ time plus the InterestLifetime\n      (or a platform-dependent default value\
    \ if not present).\n   o  An Interest record (PIT entry) is considered invalid\
    \ if its\n      InterestExpiry time is in the past.\n   o  The first reception\
    \ of an Interest MUST be forwarded.\n   o  A second or later reception of an Interest\
    \ similar to a valid\n      pending Interest from the same previous hop MUST be\
    \ forwarded.  We\n      consider these a retransmission request.\n   o  A second\
    \ or later reception of an Interest similar to a valid\n      pending Interest\
    \ from a new previous hop MAY be aggregated (not\n      forwarded).  If this Interest\
    \ has a larger HopLimit than the\n      pending Interest, it MUST be forwarded.\n\
    \   o  Aggregating an Interest MUST extend the InterestExpiry time of the\n  \
    \    Interest record.  An implementation MAY keep a single\n      InterestExpiry\
    \ time for all previous hops or MAY keep the\n      InterestExpiry time per previous\
    \ hop.  In the first case, the\n      forwarder might send a Content Object down\
    \ a path that is no\n      longer waiting for it, in which case the previous hop\
    \ (next hop of\n      the Content Object) would drop it.\n"
- title: 2.4.3.  Content Store Behavior
  contents:
  - "2.4.3.  Content Store Behavior\n   The Content Store is a special cache that\
    \ is an integral part of a\n   CCNx forwarder.  It is an optional component. \
    \ It serves to repair\n   lost packets and handle flash requests for popular content.\
    \  It could\n   be prepopulated or use opportunistic caching.  Because the Content\n\
    \   Store could serve to amplify an attack via cache poisoning, there are\n  \
    \ special rules about how a Content Store behaves.\n   1.  A forwarder MAY implement\
    \ a Content Store.  If it does, the\n       Content Store matches a Content Object\
    \ to an Interest via the\n       normal matching rules (see Section 9).\n   2.\
    \  If an Interest has a KeyId restriction, then the Content Store\n       MUST\
    \ NOT reply unless it knows the signature on the matching\n       Content Object\
    \ is correct.  It may do this by external knowledge\n       (i.e., in a managed\
    \ network or system with prepopulated caches)\n       or by having the public\
    \ key and cryptographically verifying the\n       signature.  A Content Store\
    \ is NOT REQUIRED to verify signatures;\n       if it does not, then it treats\
    \ these cases like a cache miss.\n   3.  If a Content Store chooses to verify\
    \ signatures, then it MAY do\n       so as follows.  If the public key is provided\
    \ in the Content\n       Object itself (i.e., in the PublicKey field) or in the\
    \ Interest,\n       the Content Store MUST verify that the public key's hash is\
    \ equal\n       to the KeyId and that it verifies the signature (see\n       Section\
    \ 8.4).  A Content Store MAY verify the digital signature\n       of a Content\
    \ Object before it is cached, but it is not required\n       to do so.  A Content\
    \ Store SHOULD NOT fetch keys over the\n       network.  If it cannot or has not\
    \ yet verified the signature, it\n       should treat the Interest as a cache\
    \ miss.\n   4.  If an Interest has a Content Object Hash restriction, then the\n\
    \       Content Store MUST NOT reply unless it knows the matching Content\n  \
    \     Object has the correct hash.  If it cannot verify the hash, then\n     \
    \  it should treat the Interest as a cache miss.\n   5.  It must obey the cache\
    \ control directives (see Section 4).\n"
- title: 2.4.4.  Interest Pipeline
  contents:
  - "2.4.4.  Interest Pipeline\n   1.  Perform the HopLimit check (see Section 2.4.1).\n\
    \   2.  If the Interest carries a validation, such as a MIC or a\n       signature\
    \ with an embedded public key or certificate, a forwarder\n       MAY validate\
    \ the Interest as per Section 8.  A forwarder SHOULD\n       NOT fetch keys via\
    \ a KeyLink.  If the forwarder drops an Interest\n       due to failed validation,\
    \ it MAY send an Interest Return\n       (Section 10.3.9).\n   3.  Determine if\
    \ the Interest can be aggregated as per Section 2.4.2.\n       If it can be, aggregate\
    \ and do not forward the Interest.\n   4.  If forwarding the Interest, check for\
    \ a hit in the Content Store\n       as per Section 2.4.3.  If a matching Content\
    \ Object is found,\n       return it to the Interest's previous hop.  This injects\
    \ the\n       Content Store as per Section 2.4.5.\n   5.  Look up the Interest\
    \ in the FIB.  Longest Prefix Match (LPM) is\n       performed name segment by\
    \ name segment (not byte or bit).  It\n       SHOULD exclude the Interest's previous\
    \ hop.  If a match is found,\n       forward the Interest.  If no match is found\
    \ or the forwarder\n       chooses not to forward due to a local condition (e.g.,\n\
    \       congestion), it SHOULD send an Interest Return message as per\n      \
    \ Section 10.\n"
- title: 2.4.5.  Content Object Pipeline
  contents:
  - "2.4.5.  Content Object Pipeline\n   1.  It is RECOMMENDED that a forwarder that\
    \ receives a Content Object\n       check that the Content Object came from an\
    \ expected previous hop.\n       An expected previous hop is one pointed to by\
    \ the FIB or one\n       recorded in the PIT as having had a matching Interest\
    \ sent that\n       way.\n   2.  A Content Object MUST be matched to all pending\
    \ Interests that\n       satisfy the matching rules (see Section 9).  Each satisfied\n\
    \       pending Interest MUST then be removed from the set of pending\n      \
    \ Interests.\n   3.  A forwarder SHOULD NOT send more than one copy of the received\n\
    \       Content Object to the same Interest previous hop.  It may happen,\n  \
    \     for example, that two Interests ask for the same Content Object\n      \
    \ in different ways (e.g., by name and by name and KeyId), and that\n       they\
    \ both come from the same previous hop.  It is normal to send\n       the same\
    \ Content Object multiple times on the same interface,\n       such as Ethernet,\
    \ if it is going to different previous hops.\n   4.  A Content Object SHOULD only\
    \ be put in the Content Store if it\n       satisfied an Interest (and passed\
    \ rule #1 above).  This is to\n       reduce the chances of cache poisoning.\n"
- title: 3.  Names
  contents:
  - "3.  Names\n   A CCNx name is a composition of name segments.  Each name segment\n\
    \   carries a label identifying the purpose of the name segment, and a\n   value.\
    \  For example, some name segments are general names and some\n   serve specific\
    \ purposes such as carrying version information or the\n   sequencing of many\
    \ chunks of a large object into smaller, signed\n   Content Objects.\n   There\
    \ are three different types of names in CCNx: prefix, exact, and\n   full names.\
    \  A prefix name is simply a name that does not uniquely\n   identify a single\
    \ Content Object, but rather a namespace or prefix of\n   an existing Content\
    \ Object name.  An exact name is one that uniquely\n   identifies the name of\
    \ a Content Object.  A full name is one that is\n   exact and is accompanied by\
    \ an explicit or implicit ConObjHash.  The\n   ConObjHash is explicit in an Interest\
    \ and implicit in a Content\n   Object.\n   Note that a forwarder does not need\
    \ to know any semantics about a\n   name.  It only needs to be able to match a\
    \ prefix to forward\n   Interests and match an exact or full name to forward Content\
    \ Objects.\n   It is not sensitive to the name segment types.\n   The name segment\
    \ labels specified in this document are given in\n   Table 1.  Name Segment is\
    \ a general name segment, typically occurring\n   in the routable prefix and user-specified\
    \ content name.  Interest\n   Payload ID is a name segment to identify the Interest's\
    \ payload.\n   Application Components are a set of name segment types reserved\
    \ for\n   application use.\n   +-------------+-----------------------------------------------------+\n\
    \   |     Type    | Description                                         |\n  \
    \ +-------------+-----------------------------------------------------+\n   |\
    \     Name    | A generic name segment that includes arbitrary      |\n   |  \
    \ Segment   | octets.                                             |\n   |    \
    \         |                                                     |\n   |   Interest\
    \  | An octet string that identifies the payload carried |\n   |  Payload ID |\
    \ in an Interest.  As an example, the Payload ID      |\n   |             | might\
    \ be a hash of the Interest Payload.  This      |\n   |             | provides\
    \ a way to differentiate between Interests   |\n   |             | based on the\
    \ payload solely through a name segment  |\n   |             | without having\
    \ to include all the extra bytes of    |\n   |             | the payload itself.\
    \                                 |\n   |             |                      \
    \                               |\n   | Application | An application-specific\
    \ payload in a name segment.  |\n   |  Components | An application may apply its\
    \ own semantics to these |\n   |             | components.  A good practice is\
    \ to identify the     |\n   |             | application in a name segment prior\
    \ to the          |\n   |             | application component segments.      \
    \               |\n   +-------------+-----------------------------------------------------+\n\
    \                     Table 1: CCNx Name Segment Types\n   At the lowest level,\
    \ a forwarder does not need to understand the\n   semantics of name segments;\
    \ it need only identify name segment\n   boundaries and be able to compare two\
    \ name segments (both label and\n   value) for equality.  The forwarder matches\
    \ names segment by segment\n   against its forwarding table to determine a next\
    \ hop.\n"
- title: 3.1.  Name Examples
  contents:
  - "3.1.  Name Examples\n   This section uses the CCNx URI [ccnx-uri] representation\
    \ of CCNx\n   names.  Note that as per the message grammar, an Interest must have\
    \ a\n   Name with at least one name segment that must have at least 1 octet\n\
    \   of value.  A Content Object must have a similar name or no name at\n   all.\
    \  The FIB, on the other hand, could have 0-length names (a\n   default route),\
    \ or a first name segment with no value, or a regular\n   name.\n   +--------------------------+----------------------------------------+\n\
    \   |           Name           | Description                            |\n  \
    \ +--------------------------+----------------------------------------+\n   |\
    \          ccnx:/          | A 0-length name, corresponds to a      |\n   |  \
    \                        | default route.                         |\n   |    \
    \                      |                                        |\n   |      \
    \ ccnx:/NAME=        | A name with 1 segment of 0 length,     |\n   |        \
    \                  | distinct from ccnx:/.                  |\n   |          \
    \                |                                        |\n   | ccnx:/NAME=foo/APP:0=bar\
    \ | A 2-segment name, where the first      |\n   |                          |\
    \ segment is of type NAME and the second |\n   |                          | segment\
    \ is of type APP:0.              |\n   +--------------------------+----------------------------------------+\n\
    \                        Table 2: CCNx Name Examples\n"
- title: 3.2.  Interest Payload ID
  contents:
  - "3.2.  Interest Payload ID\n   An Interest may also have a Payload field that\
    \ carries state about\n   the Interest but is not used to match a Content Object.\
    \  If an\n   Interest contains a payload, the Interest name should contain an\n\
    \   Interest Payload ID (IPID).  The IPID allows a PIT entry to correctly\n  \
    \ multiplex Content Objects in response to a specific Interest with a\n   specific\
    \ payload ID.  The IPID could be derived from a hash of the\n   payload or could\
    \ be a Globally Unique Identifier (GUID) or a nonce.\n   An optional Metadata\
    \ field defines the IPID field so other systems\n   can verify the IPID, such\
    \ as when it is derived from a hash of the\n   payload.  No system is required\
    \ to verify the IPID.\n"
- title: 4.  Cache Control
  contents:
  - "4.  Cache Control\n   CCNx supports two fields that affect cache control.  These\
    \ determine\n   how a cache or Content Store handles a Content Object.  They are\
    \ not\n   used in the fast path; they are only used to determine if a Content\n\
    \   Object can be injected onto the fast path in response to an Interest.\n  \
    \ The ExpiryTime is a field that exists within the signature envelope\n   of a\
    \ Validation Algorithm.  It is the UTC time in milliseconds after\n   which the\
    \ Content Object is considered expired and MUST no longer be\n   used to respond\
    \ to an Interest from a cache.  Stale content MAY be\n   flushed from the cache.\n\
    \   The Recommended Cache Time (RCT) is a field that exists outside the\n   signature\
    \ envelope.  It is the UTC time in milliseconds after which\n   the publisher\
    \ considers the Content Object to be of low value to\n   cache.  A cache SHOULD\
    \ discard it after the RCT, though it MAY keep\n   it and still respond with it.\
    \  A cache MAY also discard the Content\n   Object before the RCT time; there\
    \ is no contractual obligation to\n   remember anything.\n   This formulation\
    \ allows a producer to create a Content Object with a\n   long ExpiryTime but\
    \ short RCT and keep republishing the same signed\n   Content Object over and\
    \ over again by extending the RCT.  This allows\n   a form of \"phone home\" where\
    \ the publisher wants to periodically see\n   that the content is being used.\n"
- title: 5.  Content Object Hash
  contents:
  - "5.  Content Object Hash\n   CCNx allows an Interest to restrict a response to\
    \ a specific hash.\n   The hash covers the Content Object message body and the\
    \ validation\n   sections, if present.  Thus, if a Content Object is signed, its\
    \ hash\n   includes that signature value.  The hash does not include the fixed\n\
    \   or hop-by-hop headers of a Content Object.  Because it is part of the\n  \
    \ matching rules (see Section 9), the hash is used at every hop.\n   There are\
    \ two options for matching the Content Object Hash\n   restriction in an Interest.\
    \  First, a forwarder could compute for\n   itself the hash value and compare\
    \ it to the restriction.  This is an\n   expensive operation.  The second option\
    \ is for a border device to\n   compute the hash once and place the value in a\
    \ header (ConObjHash)\n   that is carried through the network.  The second option,\
    \ of course,\n   removes any security properties from matching the hash, so it\
    \ SHOULD\n   only be used within a trusted domain.  The header SHOULD be removed\n\
    \   when crossing a trust boundary.\n"
- title: 6.  Link
  contents:
  - "6.  Link\n   A Link is the tuple {Name, [KeyIdRestr], [ContentObjectHashRestr]}.\n\
    \   The information in a Link comprises the fields of an Interest that\n   would\
    \ retrieve the Link target.  A Content Object with PayloadType of\n   \"Link\"\
    \ is an object whose payload is one or more Links.  This tuple\n   may be used\
    \ as a KeyLink to identify a specific object with the\n   certificate-wrapped\
    \ key.  It is RECOMMENDED to include at least one\n   of either KeyId restriction\
    \ or Content Object Hash restriction.  If\n   neither restriction is present,\
    \ then any Content Object with a\n   matching name from any publisher could be\
    \ returned.\n"
- title: 7.  Hashes
  contents:
  - "7.  Hashes\n   Several protocol fields use cryptographic hash functions, which\
    \ must\n   be secure against attack and collisions.  Because these hash\n   functions\
    \ change over time, with better ones appearing and old ones\n   falling victim\
    \ to attacks, it is important that a CCNx protocol\n   implementation supports\
    \ hash agility.\n   In this document, we suggest certain hashes (e.g., SHA-256),\
    \ but a\n   specific implementation may use what it deems best.  The normative\n\
    \   CCNx Messages [RFC8609] specification should be taken as the\n   definition\
    \ of acceptable hash functions and uses.\n"
- title: 8.  Validation
  contents:
  - '8.  Validation

    '
- title: 8.1.  Validation Algorithm
  contents:
  - "8.1.  Validation Algorithm\n   The Validator consists of a ValidationAlgorithm\
    \ that specifies how to\n   verify the message and a ValidationPayload containing\
    \ the validation\n   output, e.g., the digital signature or MAC.  The ValidationAlgorithm\n\
    \   section defines the type of algorithm to use and includes any\n   necessary\
    \ additional information.  The validation is calculated from\n   the beginning\
    \ of the CCNx Message through the end of the\n   ValidationAlgorithm section (i.e.,\
    \ up to but not including the\n   validation payload).  We refer to this as the\
    \ validation region.  The\n   ValidationPayload is the integrity value bytes,\
    \ such as a MAC or\n   signature.\n   The CCNx Message Grammar (Section 2.1) shows\
    \ the allowed validation\n   algorithms and their structure.  In the case of a\
    \ Vendor algorithm,\n   the vendor may use any desired structure.  A Validator\
    \ can only be\n   applied to an Interest or a Content Object, not an Interest\
    \ Return.\n   An Interest inside an Interest Return would still have the original\n\
    \   validator, if any.\n   The grammar allows multiple Vendor extensions to the\
    \ validation\n   algorithm.  It is up to the vendor to describe the validation\
    \ region\n   for each extension.  A vendor may, for example, use a regular\n \
    \  signature in the validation algorithm, then append a proprietary MIC\n   to\
    \ allow for in-network error checking without using expensive\n   signature verification.\
    \  As part of this specification, we do not\n   allow for multiple Validation\
    \ Algorithm blocks apart from these\n   vendor methods.\n"
- title: 8.2.  Message Integrity Codes
  contents:
  - "8.2.  Message Integrity Codes\n   If the validation algorithm is CRC32C, then\
    \ the validation payload is\n   the output of the CRC over the validation region.\
    \  This validation\n   algorithm allows for an optional signature time (SigTime)\
    \ to\n   timestamp when the message was validated (calling it a \"signature\"\n\
    \   time is a slight misnomer, but we reuse the same field for this\n   purpose\
    \ between MICs, MACs, and signatures).\n   MICs are usually used with an Interest\
    \ to avoid accidental in-network\n   corruption.  They are usually not used on\
    \ Content Objects because the\n   objects are either signed or linked to by hash\
    \ chains, so the CRC32C\n   is redundant.\n"
- title: 8.3.  Message Authentication Codes
  contents:
  - "8.3.  Message Authentication Codes\n   If the validation algorithm is HMAC-SHA256,\
    \ then the validation\n   payload is the output of the HMAC over the validation\
    \ region.  The\n   validation algorithm requires a KeyId and allows for a signature\
    \ time\n   (SigTime) and KeyLink.\n   The KeyId field identifies the shared secret\
    \ used between two parties\n   to authenticate messages.  These secrets SHOULD\
    \ be derived from a key\n   exchange protocol such as [ccnx-ke].  The KeyId, for\
    \ a shared secret,\n   SHOULD be an opaque identifier not derived from the actual\
    \ key; an\n   integer counter, for example, is a good choice.\n   The signature\
    \ time is the timestamp when the authentication code was\n   computed and added\
    \ to the messages.\n   The KeyLink field in a MAC indicates how to negotiate keys\
    \ and should\n   point towards the key exchange endpoint.  The use of a key\n\
    \   negotiation algorithm is beyond the scope of this specification, and\n   a\
    \ key negotiation algorithm is not required to use this field.\n"
- title: 8.4.  Signature
  contents:
  - "8.4.  Signature\n   Signature-validation algorithms use public key cryptographic\n\
    \   algorithms such as RSA and the Elliptic Curve Digital Signature\n   Algorithm\
    \ (ECDSA).  This specification and the corresponding wire\n   encoding [RFC8609]\
    \ only support three specific signature algorithms:\n   RSA-SHA256, EC-SECP-256K1,\
    \ and EC-SECP-384R1.  Other algorithms may\n   be added in through other documents\
    \ or by using experimental or\n   vendor-validation algorithm types.\n   A signature\
    \ that is public key based requires a KeyId field and may\n   optionally carry\
    \ a signature time, an embedded public key, an\n   embedded certificate, and a\
    \ KeyLink.  The signature time behaves as\n   normal to timestamp when the signature\
    \ was created.  We describe the\n   use and relationship of the other fields here.\n\
    \   It is not common to use embedded certificates, as they can be very\n   large\
    \ and may have validity periods different than the validated\n   data.  The preferred\
    \ method is to use a KeyLink to the validating\n   certificate.\n   The KeyId\
    \ field in the ValidationAlgorithm identifies the public key\n   used to verify\
    \ the signature.  It is similar to a Subject Key\n   Identifier from X.509 (Section\
    \ 4.2.1.2 of [RFC5280]).  We define the\n   KeyId to be a cryptographic hash of\
    \ the public key in DER form.  All\n   implementations MUST support the SHA-256\
    \ digest as the KeyId hash.\n   The use of other algorithms for the KeyId is allowed,\
    \ and it will not\n   cause problems at a forwarder because the forwarder only\
    \ matches the\n   digest algorithm and digest output and does not compute the\
    \ digest\n   (see Section 9).  It may cause issues with a Content Store, which\n\
    \   needs to verify the KeyId and PublicKey match (see Section 2.4.3);\n   though\
    \ in this case, it only causes a cache miss and the Interest\n   would still be\
    \ forwarded to the publisher.  As long as the publisher\n   and consumers support\
    \ the hash, data will validate.\n   As per Section 9, a forwarder only matches\
    \ the KeyId to a KeyId\n   restriction.  It does not need to look at the other\
    \ fields such as\n   the public key, certificate, or KeyLink.\n   If a message\
    \ carries multiples of the KeyId, public key, certificate,\n   or KeyLink, an\
    \ endpoint (consumer, cache, or Content Store) MUST\n   ensure that any fields\
    \ it uses are consistent.  The KeyId MUST be the\n   corresponding hash of the\
    \ embedded public key or certificate public\n   key.  The hash function to use\
    \ is the KeyId's HashType.  If there is\n   both an embedded public key and a\
    \ certificate, the public keys MUST\n   be the same.\n   A message SHOULD NOT\
    \ have both a PublicKey and a KeyLink to a public\n   key, as that is redundant.\
    \  It MAY have a PublicKey and a KeyLink to\n   a certificate.\n   A KeyLink in\
    \ a first Content Object may point to a second Content\n   Object with a DER-encoded\
    \ public key in the PublicKey field and an\n   optional DER-encoded X.509 certificate\
    \ in the payload.  The second\n   Content Object's KeyId MUST equal the first\
    \ object's KeyId.  The\n   second object's PublicKey field MUST be the public\
    \ key corresponding\n   to the KeyId.  That key must validate both the first and\
    \ second\n   object's signature.  A DER-encoded X.509 certificate may be included\n\
    \   in the second object's payload and its embedded public key MUST match\n  \
    \ the PublicKey.  It must be issued by a trusted authority, preferably\n   specifying\
    \ the valid namespace of the key in the distinguished name.\n   The second object\
    \ MUST NOT have a KeyLink; we do not allow for\n   recursive key lookup.\n"
- title: 9.  Interest to Content Object Matching
  contents:
  - "9.  Interest to Content Object Matching\n   A Content Object satisfies an Interest\
    \ if and only if (a) the Content\n   Object name, if present, exactly matches\
    \ the Interest name, (b) the\n   ValidationAlgorithm KeyId of the Content Object\
    \ exactly equals the\n   Interest KeyId restriction, if present, and (c) the computed\
    \ Content\n   Object Hash exactly equals the Interest Content Object Hash\n  \
    \ restriction, if present.\n   The KeyId and KeyIdRestr use the Hash format (see\
    \ Section 2.1).  The\n   Hash format has an embedded HashType followed by the\
    \ hash value.\n   When comparing a KeyId and KeyIdRestr, one compares both the\
    \ HashType\n   and the value.\n   The matching rules are given by this predicate,\
    \ which, if it\n   evaluates true, means the Content Object matches the Interest.\
    \  Ni =\n   Name in the Interest (may not be empty), Ki = KeyIdRestr in the\n\
    \   Interest (may be empty), and Hi = ContentObjectHashRestr in the\n   Interest\
    \ (may be empty).  Likewise, No, Ko, and Ho are those\n   properties in the Content\
    \ Object, where No and Ko may be empty; Ho\n   always exists (it is an intrinsic\
    \ property of the Content Object).\n   For binary relations, we use \"&\" for\
    \ AND and \"|\" for OR.  We use \"E\"\n   for the EXISTS (not empty) operator\
    \ and \"!\" for the NOT EXISTS\n   operator.\n   As a special case, if the Content\
    \ Object Hash restriction in the\n   Interest specifies an unsupported hash algorithm,\
    \ then no Content\n   Object can match the Interest, so the system should drop\
    \ the Interest\n   and MAY send an Interest Return to the previous hop.  In this\
    \ case,\n   the predicate below will never get executed because the Interest is\n\
    \   never forwarded.  If the system is using the optional behavior of\n   having\
    \ a different system calculate the hash for it, then the system\n   may assume\
    \ all hash functions are supported and leave it to the other\n   system to accept\
    \ or reject the Interest.\n   (!No | (Ni=No)) & (!Ki | (Ki=Ko)) & (!Hi | (Hi=Ho))\
    \ & (E No | E Hi)\n   As one can see, there are two types of attributes one can\
    \ match.  The\n   first term depends on the existence of the attribute in the\
    \ Content\n   Object while the next two terms depend on the existence of the\n\
    \   attribute in the Interest.  The last term is the \"Nameless Object\"\n   restriction\
    \ that states that if a Content Object does not have a\n   Name, then it must\
    \ match the Interest on at least the Hash\n   restriction.\n   If a Content Object\
    \ does not carry the Content Object Hash as an\n   expressed field, it must be\
    \ calculated in network to match against.\n   It is sufficient within an autonomous\
    \ system to calculate a Content\n   Object Hash at a border router and carry it\
    \ via trusted means within\n   the autonomous system.  If a Content Object ValidationAlgorithm\
    \ does\n   not have a KeyId, then the Content Object cannot match an Interest\n\
    \   with a KeyId restriction.\n"
- title: 10.  Interest Return
  contents:
  - "10.  Interest Return\n   This section describes the process whereby a network\
    \ element may\n   return an Interest message to a previous hop if there is an\
    \ error\n   processing the Interest.  The returned Interest may be further\n \
    \  processed at the previous hop or returned towards the Interest\n   origin.\
    \  When a node returns an Interest, it indicates that the\n   previous hop should\
    \ not expect a response from that node for the\n   Interest, i.e., there is no\
    \ PIT entry left at the returning node.\n   The returned message maintains compatibility\
    \ with the existing TLV\n   packet format (a fixed header, optional hop-by-hop\
    \ headers, and the\n   CCNx Message body).  The returned Interest packet is modified\
    \ in only\n   two ways:\n   o  The PacketType is set to Interest Return to indicate\
    \ a Feedback\n      message.\n   o  The ReturnCode is set to the appropriate value\
    \ to signal the\n      reason for the return.\n   The specific encodings of the\
    \ Interest Return are specified in\n   [RFC8609].\n   A forwarder is not required\
    \ to send any Interest Return messages.\n   A forwarder is not required to process\
    \ any received Interest Return\n   message.  If a forwarder does not process Interest\
    \ Return messages,\n   it SHOULD silently drop them.\n   The Interest Return message\
    \ does not apply to a Content Object or any\n   other message type.\n   An Interest\
    \ Return message is a 1-hop message between peers.  It is\n   not propagated multiple\
    \ hops via the FIB.  An intermediate node that\n   receives an Interest Return\
    \ may take corrective actions or may\n   propagate its own Interest Return to\
    \ previous hops as indicated in\n   the reverse path of a PIT entry.\n"
- title: 10.1.  Message Format
  contents:
  - "10.1.  Message Format\n   The Interest Return message looks exactly like the\
    \ original Interest\n   message with the exception of the two modifications mentioned\
    \ above.\n   The PacketType is set to indicate the message is an Interest Return,\n\
    \   and the reserved byte in the Interest header is used as a Return\n   Code.\
    \  The numeric values for the PacketType and ReturnCodes are in\n   [RFC8609].\n"
- title: 10.2.  ReturnCode Types
  contents:
  - "10.2.  ReturnCode Types\n   This section defines the Interest Return ReturnCode\
    \ introduced in\n   this RFC.  The numeric values used in the packet are defined\
    \ in\n   [RFC8609].\n   +----------------------+--------------------------------------------+\n\
    \   | Name                 | Description                                |\n  \
    \ +----------------------+--------------------------------------------+\n   |\
    \ No Route (Section    | The returning forwarder has no route to    |\n   | 10.3.1)\
    \              | the Interest name.                         |\n   |          \
    \            |                                            |\n   | HopLimit Exceeded\
    \    | The HopLimit has decremented to 0 and      |\n   | (Section 10.3.2)   \
    \  | needs to forward the packet.               |\n   |                      |\
    \                                            |\n   | Interest MTU too     | The\
    \ Interest's MTU does not conform to the |\n   | large (Section       | required\
    \ minimum and would require         |\n   | 10.3.3)              | fragmentation.\
    \                             |\n   |                      |                 \
    \                           |\n   | No Resources         | The node does not have\
    \ the resources to    |\n   | (Section 10.3.4)     | process the Interest.   \
    \                   |\n   |                      |                           \
    \                 |\n   | Path error (Section  | There was a transmission error\
    \ when        |\n   | 10.3.5)              | forwarding the Interest along a route\
    \ (a   |\n   |                      | transient error).                      \
    \    |\n   |                      |                                          \
    \  |\n   | Prohibited (Section  | An administrative setting prohibits        |\n\
    \   | 10.3.6)              | processing this Interest.                  |\n  \
    \ |                      |                                            |\n   |\
    \ Congestion (Section  | The Interest was dropped due to congestion |\n   | 10.3.7)\
    \              | (a transient error).                       |\n   |          \
    \            |                                            |\n   | Unsupported\
    \ Content  | The Interest was dropped because it        |\n   | Object Hash  \
    \        | requested a Content Object Hash            |\n   | Algorithm (Section\
    \   | restriction using a hash algorithm that    |\n   | 10.3.8)             \
    \ | cannot be computed.                        |\n   |                      |\
    \                                            |\n   | Malformed Interest   | The\
    \ Interest was dropped because it did    |\n   | (Section 10.3.9)     | not correctly\
    \ parse.                       |\n   +----------------------+--------------------------------------------+\n\
    \                   Table 3: Interest Return Reason Codes\n"
- title: 10.3.  Interest Return Protocol
  contents:
  - "10.3.  Interest Return Protocol\n   This section describes the forwarder behavior\
    \ for the various Reason\n   codes for Interest Return.  A forwarder is not required\
    \ to generate\n   any of the codes, but if it does, it MUST conform to this\n\
    \   specification.\n   If a forwarder receives an Interest Return, it SHOULD take\
    \ these\n   standard corrective actions.  A forwarder is allowed to ignore\n \
    \  Interest Return messages, in which case its PIT entry would go\n   through\
    \ normal timeout processes.\n   o  Verify that the Interest Return came from a\
    \ next hop to which it\n      actually sent the Interest.\n   o  If a PIT entry\
    \ for the corresponding Interest does not exist, the\n      forwarder should ignore\
    \ the Interest Return.\n   o  If a PIT entry for the corresponding Interest does\
    \ exist, the\n      forwarder MAY do one of the following:\n      *  Try a different\
    \ forwarding path, if one exists, and discard the\n         Interest Return, or\n\
    \      *  Clear the PIT state and send an Interest Return along the\n        \
    \ reverse path.\n   If a forwarder tries alternate routes, it MUST ensure that\
    \ it does\n   not use the same path multiple times.  For example, it could keep\n\
    \   track of which next hops it has tried and not reuse them.\n   If a forwarder\
    \ tries an alternate route, it may receive a second\n   Interest Return, possibly\
    \ of a different type than the first Interest\n   Return.  For example, node A\
    \ sends an Interest to node B, which sends\n   a No Route return.  Node A then\
    \ tries node C, which sends a\n   Prohibited Interest Return.  Node A should choose\
    \ what it thinks is\n   the appropriate code to send back to its previous hop.\n\
    \   If a forwarder tries an alternate route, it should decrement the\n   Interest\
    \ Lifetime to account for the time spent thus far processing\n   the Interest.\n"
- title: 10.3.1.  No Route
  contents:
  - "10.3.1.  No Route\n   If a forwarder receives an Interest for which it has no\
    \ route, or for\n   which the only route is back towards the system that sent\
    \ the\n   Interest, the forwarder SHOULD generate a \"No Route\" Interest Return\n\
    \   message.\n   How a forwarder manages the FIB table when it receives a No Route\n\
    \   message is implementation dependent.  In general, receiving a No\n   Route\
    \ Interest Return should not cause a forwarder to remove a route.\n   The dynamic\
    \ routing protocol that installed the route should correct\n   the route, or the\
    \ administrator who created a static route should\n   correct the configuration.\
    \  A forwarder could suppress using that\n   next hop for some period of time.\n"
- title: 10.3.2.  HopLimit Exceeded
  contents:
  - "10.3.2.  HopLimit Exceeded\n   A forwarder MAY choose to send HopLimit Exceeded\
    \ messages when it\n   receives an Interest that must be forwarded off system\
    \ and the\n   HopLimit is 0.\n"
- title: 10.3.3.  Interest MTU Too Large
  contents:
  - "10.3.3.  Interest MTU Too Large\n   If a forwarder receives an Interest whose\
    \ MTU exceeds the prescribed\n   minimum, it MAY send an \"Interest MTU Too Large\"\
    \ message, or it may\n   silently discard the Interest.\n   If a forwarder receives\
    \ an \"Interest MTU Too Large\" response, it\n   SHOULD NOT try alternate paths.\
    \  It SHOULD propagate the Interest\n   Return to its previous hops.\n"
- title: 10.3.4.  No Resources
  contents:
  - "10.3.4.  No Resources\n   If a forwarder receives an Interest and it cannot process\
    \ the\n   Interest due to lack of resources, it MAY send an Interest Return. \
    \ A\n   lack of resources could mean the PIT is too large or that there is\n \
    \  some other capacity limit.\n"
- title: 10.3.5.  Path Error
  contents:
  - "10.3.5.  Path Error\n   If a forwarder detects an error forwarding an Interest,\
    \ such as over\n   a reliable link, it MAY send a Path-Error Interest Return indicating\n\
    \   that it was not able to send or repair a forwarding error.\n"
- title: 10.3.6.  Prohibited
  contents:
  - "10.3.6.  Prohibited\n   A forwarder may have administrative policies, such as\
    \ access control\n   lists (ACLs), that prohibit receiving or forwarding an Interest.\
    \  If\n   a forwarder discards an Interest due to a policy, it MAY send a\n  \
    \ Prohibited Interest Return to the previous hop.  For example, if\n   there is\
    \ an ACL that says \"/example/private\" can only come from\n   interface e0, but\
    \ the forwarder receives one from e1, the forwarder\n   must have a way to return\
    \ the Interest with an explanation.\n"
- title: 10.3.7.  Congestion
  contents:
  - "10.3.7.  Congestion\n   If a forwarder discards an Interest due to congestion,\
    \ it MAY send a\n   Congestion Interest Return to the previous hop.\n"
- title: 10.3.8.  Unsupported Content Object Hash Algorithm
  contents:
  - "10.3.8.  Unsupported Content Object Hash Algorithm\n   If a Content Object Hash\
    \ restriction specifies a hash algorithm the\n   forwarder cannot verify, the\
    \ Interest should not be accepted and the\n   forwarder MAY send an Interest Return\
    \ to the previous hop.\n"
- title: 10.3.9.  Malformed Interest
  contents:
  - "10.3.9.  Malformed Interest\n   If a forwarder detects a structural or syntactical\
    \ error in an\n   Interest, it SHOULD drop the Interest and MAY send an Interest\
    \ Return\n   to the previous hop.  This does not imply that any router must\n\
    \   validate the entire structure of an Interest.\n"
- title: 11.  IANA Considerations
  contents:
  - "11.  IANA Considerations\n   This document has no IANA actions.\n"
- title: 12.  Security Considerations
  contents:
  - "12.  Security Considerations\n   The CCNx protocol is an L3 network protocol,\
    \ which may also operate\n   as an overlay using other transports such as UDP\
    \ or other tunnels.\n   It includes intrinsic support for message authentication\
    \ via a\n   signature (e.g., RSA or elliptic curve) or message authentication\n\
    \   code (e.g., HMAC).  In lieu of an authenticator, it may instead use a\n  \
    \ message integrity check (e.g., SHA or CRC).  CCNx does not specify an\n   encryption\
    \ envelope; that function is left to a high-layer protocol\n   (e.g., [esic]).\n\
    \   The CCNx message format includes the ability to attach MICs (e.g.,\n   CRC32C),\
    \ MACs (e.g., HMAC), and signatures (e.g., RSA or ECDSA) to\n   all packet types.\
    \  This does not mean that it is a good idea to use\n   an arbitrary ValidationAlgorithm,\
    \ nor to include computationally\n   expensive algorithms in Interest packets,\
    \ as that could lead to\n   computational DoS attacks.  Applications should use\
    \ an explicit\n   protocol to guide their use of packet signatures.  As a general\n\
    \   guideline, an application might use a MIC on an Interest to detect\n   unintentionally\
    \ corrupted packets.  If one wishes to secure an\n   Interest, one should consider\
    \ using an encrypted wrapper and a\n   protocol that prevents replay attacks,\
    \ especially if the Interest is\n   being used as an actuator.  Simply using an\
    \ authentication code or\n   signature does not make an Interest secure.  There\
    \ are several\n   examples in the literature on how to secure ICN-style messaging\n\
    \   [mobile] [ace].\n   As an L3 protocol, this document does not describe how\
    \ one arrives at\n   keys or how one trusts keys.  The CCNx Content Object may\
    \ include a\n   public key or certificate embedded in the object or may use the\n\
    \   KeyLink field to point to a public key or certificate that\n   authenticates\
    \ the message.  One key-exchange specification is CCNxKE\n   [ccnx-ke] [mobile],\
    \ which is similar to the TLS 1.3 key exchange\n   except it is over the CCNx\
    \ L3 messages.  Trust is beyond the scope of\n   an L3 protocol and left to applications\
    \ or application frameworks.\n   The combination of an ephemeral key exchange\
    \ (e.g., CCNxKE [ccnx-ke])\n   and an encapsulating encryption (e.g., [esic])\
    \ provides the\n   equivalent of a TLS tunnel.  Intermediate nodes may forward\
    \ the\n   Interests and Content Objects but have no visibility inside.  It also\n\
    \   completely hides the internal names in those used by the encryption\n   layer.\
    \  This type of tunneling encryption is useful for content that\n   has little\
    \ or no cacheability, as it can only be used by someone with\n   the ephemeral\
    \ key.  Short-term caching may help with lossy links or\n   mobility, but long-term\
    \ caching is usually not of interest.\n   Broadcast encryption or proxy re-encryption\
    \ may be useful for content\n   with multiple uses over time or many consumers.\
    \  There is currently\n   no recommendation for this form of encryption.\n   The\
    \ specific encoding of messages will have security implications.\n   [RFC8609]\
    \ uses a type-length-value (TLV) encoding.  We chose to\n   compromise between\
    \ extensibility and unambiguous encodings of types\n   and lengths.  Some TLV\
    \ encodings use variable-length \"T\" and\n   variable-length \"L\" fields to\
    \ accommodate a wide gamut of values\n   while trying to be byte efficient.  Our\
    \ TLV encoding uses a fixed-\n   length 2-byte \"T\" and 2-byte \"L\".  Using\
    \ a fixed-length \"T\" and \"L\"\n   field solves two problems.  The first is\
    \ aliases.  If one is able to\n   encode the same value, such as %x02 and %x0002,\
    \ in different byte\n   lengths, then one must decide if they mean the same thing,\
    \ if they\n   are different, or if one is illegal.  If they are different, then\
    \ one\n   must always compare on the buffers, not the integer equivalents.  If\n\
    \   one is illegal, then one must validate the TLV encoding, every field\n   of\
    \ every packet at every hop.  If they are the same, then one has the\n   second\
    \ problem: how to specify packet filters.  For example, if a\n   name has 6 name\
    \ components, then there are 7 T's and 7 L's, each of\n   which might have up\
    \ to 4 representations of the same value.  That\n   would be 14 fields with 4\
    \ encodings each, or 1001 combinations.  It\n   also means that one cannot compare,\
    \ for example, a name via a memory\n   function as one needs to consider that\
    \ any embedded \"T\" or \"L\" might\n   have a different format.\n   The Interest\
    \ Return message has no authenticator from the previous\n   hop.  Therefore, the\
    \ payload of the Interest Return should only be\n   used locally to match an Interest.\
    \  A node should never forward that\n   Interest Payload as an Interest.  It should\
    \ also verify that it sent\n   the Interest in the Interest Return to that node\
    \ and not allow anyone\n   to negate Interest messages.\n   Caching nodes must\
    \ take caution when processing Content Objects.  It\n   is essential that the\
    \ Content Store obey the rules outlined in\n   Section 2.4.3 to avoid certain\
    \ types of attacks.  CCNx 1.0 has no\n   mechanism to work around an undesired\
    \ result from the network (there\n   are no \"excludes\"), so if a cache becomes\
    \ poisoned with bad content,\n   it might cause problems retrieving content. \
    \ There are three types of\n   access to content from a Content Store: unrestricted,\
    \ signature\n   restricted, and hash restricted.  If an Interest has no restrictions,\n\
    \   then the requester is not particular about what they get back, so any\n  \
    \ matching cached object is OK.  In the hash-restricted case, the\n   requester\
    \ is very specific about what they want and the Content Store\n   (and every forward\
    \ hop) can easily verify that the content matches\n   the request.  In the signature-restricted\
    \ case (often used for\n   initial manifest discovery), the requester only knows\
    \ the KeyId that\n   signed the content.  It is this case that requires the closest\n\
    \   attention in the Content Store to avoid amplifying bad data.  The\n   Content\
    \ Store must only respond with a Content Object if it can\n   verify the signature;\
    \ this means either the Content Object carries\n   the public key inside it or\
    \ the Interest carries the public key in\n   addition to the KeyId.  If that is\
    \ not the case, then the Content\n   Store should treat the Interest as a cache\
    \ miss and let an endpoint\n   respond.\n   A user-level cache could perform full\
    \ signature verification by\n   fetching a public key or certificate according\
    \ to the KeyLink.  That\n   is not, however, a burden we wish to impose on the\
    \ forwarder.  A\n   user-level cache could also rely on out-of-band attestation,\
    \ such as\n   the cache operator only inserting content that it knows has the\n\
    \   correct signature.\n   The CCNx grammar allows for hash-algorithm agility\
    \ via the HashType.\n   It specifies a short list of acceptable hash algorithms\
    \ that should\n   be implemented at each forwarder.  Some hash values only apply\
    \ to end\n   systems, so updating the hash algorithm does not affect forwarders;\n\
    \   they would simply match the buffer that includes the type-length-hash\n  \
    \ buffer.  Some fields, such as the ConObjHash, must be verified at\n   each hop,\
    \ so a forwarder (or related system) must know the hash\n   algorithm; it could\
    \ cause backward compatibility problems if the hash\n   type is updated.  [RFC8609]\
    \ is the authoritative source for per-\n   field-allowed hash types in that encoding.\n\
    \   A CCNx name uses binary matching whereas a URI uses a case-\n   insensitive\
    \ hostname.  Some systems may also use case-insensitive\n   matching of the URI\
    \ path to a resource.  An implication of this is\n   that human-entered CCNx names\
    \ will likely have case or non-ASCII\n   symbol mismatches unless one uses a consistent\
    \ URI normalization to\n   the CCNx name.  It also means that an entity that registers\
    \ a CCNx\n   routable prefix, say \"ccnx:/example.com\", would need separate\n\
    \   registrations for simple variations like \"ccnx:/Example.com\".  Unless\n\
    \   this is addressed in URI normalization and routing protocol\n   conventions,\
    \ there could be phishing attacks.\n   For a more general introduction to ICN-related\
    \ security concerns and\n   approaches, see [RFC7927] and [RFC7945].\n"
- title: 13.  References
  contents:
  - '13.  References

    '
- title: 13.1.  Normative References
  contents:
  - "13.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n  \
    \            DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n     \
    \         2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n        \
    \      May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n"
- title: 13.2.  Informative References
  contents:
  - "13.2.  Informative References\n   [ace]      Shang, W., Yu, Y., Liang, T., Zhang,\
    \ B., and L. Zhang,\n              \"NDN-ACE: Access Control for Constrained Environments\
    \ over\n              Named Data Networking\", NDN Technical Report NDN-0036,\n\
    \              December 2015, <http://new.named-data.net/\n              wp-content/uploads/2015/12/ndn-0036-1-ndn-ace.pdf>.\n\
    \   [befrags]  Mosko, M. and C. Tschudin, \"ICN \"Begin-End\" Hop by Hop\n   \
    \           Fragmentation\", Work in Progress, draft-mosko-icnrg-\n          \
    \    beginendfragment-02, December 2016.\n   [ccn-lite] Tschudin, C., et al.,\
    \ \"CCN-lite\", University of Basel,\n              2011-2019, <http://ccn-lite.net>.\n\
    \   [ccnx-ke]  Mosko, M., Uzun, E., and C. Wood, \"CCNx Key Exchange\n       \
    \       Protocol Version 1.0\", Work in Progress, draft-wood-icnrg-\n        \
    \      ccnxkeyexchange-02, March 2017.\n   [ccnx-registry]\n              IANA,\
    \ \"Content-Centric Networking (CCNx)\",\n              <https://www.iana.org/assignments/ccnx>.\n\
    \   [ccnx-uri] Mosko, M. and C. Wood, \"The CCNx URI Scheme\", Work in\n     \
    \         Progress, draft-mosko-icnrg-ccnxurischeme-01, April 2016.\n   [chunking]\
    \ Mosko, M., \"CCNx Content Object Chunking\", Work in\n              Progress,\
    \ draft-mosko-icnrg-ccnxchunking-02, June 2016.\n   [cicn]     FD.io, \"Community\
    \ ICN (CICN)\", February 2017,\n              <https://wiki.fd.io/index.php?title=Cicn&oldid=7191>.\n\
    \   [dart]     Garcia-Luna-Aceves, J. and M. Mirzazad-Barijough, \"A\n       \
    \       Light-Weight Forwarding Plane for Content-Centric\n              Networks\"\
    , International Conference on Computing,\n              Networking, and Communications\
    \ (ICNC),\n              DOI 10.1109/ICCNC.2016.7440637, February 2016,\n    \
    \          <https://arxiv.org/pdf/1603.06044.pdf>.\n   [eprise-numbers]\n    \
    \          IANA, \"IANA Private Enterprise Numbers\",\n              <https://www.iana.org/assignments/enterprise-numbers>.\n\
    \   [esic]     Mosko, M. and C. Wood, \"Encrypted Sessions In CCNx\n         \
    \     (ESIC)\", Work in Progress, draft-wood-icnrg-esic-01,\n              September\
    \ 2017.\n   [flic]     Tschudin, C. and C. Wood, \"File-Like ICN Collection\n\
    \              (FLIC)\", Work in Progress, draft-tschudin-icnrg-flic-03,\n   \
    \           March 2017.\n   [mobile]   Mosko, M., Uzun, E., and C. Wood, \"Mobile\
    \ Sessions in\n              Content-Centric Networks\", IFIP Networking Conference\n\
    \              (IFIP Networking) and Workshops,\n              DOI 10.23919/IFIPNetworking.2017.8264861,\
    \ June 2017,\n              <https://dl.ifip.org/db/conf/networking/\n       \
    \       networking2017/1570334964.pdf>.\n   [ndn]      UCLA, \"Named Data Networking\"\
    , 2019,\n              <https://www.named-data.net>.\n   [nnc]      Jacobson,\
    \ V., Smetters, D., Thornton, J., Plass, M.,\n              Briggs, N., and R.\
    \ Braynard, \"Networking Named Content\",\n              Proceedings of the 5th\
    \ International Conference on\n              Emerging Networking Experiments and\
    \ Technologies,\n              DOI 10.1145/1658939.1658941, December 2009,\n \
    \             <https://dx.doi.org/10.1145/1658939.1658941>.\n   [RFC5234]  Crocker,\
    \ D., Ed. and P. Overell, \"Augmented BNF for Syntax\n              Specifications:\
    \ ABNF\", STD 68, RFC 5234,\n              DOI 10.17487/RFC5234, January 2008,\n\
    \              <https://www.rfc-editor.org/info/rfc5234>.\n   [RFC5280]  Cooper,\
    \ D., Santesson, S., Farrell, S., Boeyen, S.,\n              Housley, R., and\
    \ W. Polk, \"Internet X.509 Public Key\n              Infrastructure Certificate\
    \ and Certificate Revocation List\n              (CRL) Profile\", RFC 5280, DOI\
    \ 10.17487/RFC5280, May 2008,\n              <https://www.rfc-editor.org/info/rfc5280>.\n\
    \   [RFC7927]  Kutscher, D., Ed., Eum, S., Pentikousis, K., Psaras, I.,\n    \
    \          Corujo, D., Saucez, D., Schmidt, T., and M. Waehlisch,\n          \
    \    \"Information-Centric Networking (ICN) Research\n              Challenges\"\
    , RFC 7927, DOI 10.17487/RFC7927, July 2016,\n              <https://www.rfc-editor.org/info/rfc7927>.\n\
    \   [RFC7945]  Pentikousis, K., Ed., Ohlman, B., Davies, E., Spirou, S.,\n   \
    \           and G. Boggia, \"Information-Centric Networking: Evaluation\n    \
    \          and Security Considerations\", RFC 7945,\n              DOI 10.17487/RFC7945,\
    \ September 2016,\n              <https://www.rfc-editor.org/info/rfc7945>.\n\
    \   [RFC8609]  Mosko, M., Solis, I., and C. Wood, \"Content-Centric\n        \
    \      Networking (CCNx) Messages in TLV Format\", RFC 8609,\n              DOI\
    \ 10.17487/RFC8609, July 2019,\n              <https://www.rfc-editor.org/info/rfc8609>.\n\
    \   [selectors]\n              Mosko, M., \"CCNx Selector Based Discovery\", Work\
    \ in\n              Progress, draft-mosko-icnrg-selectors-01, May 2019.\n   [terminology]\n\
    \              Wissingh, B., Wood, C., Afanasyev, A., Zhang, L., Oran,\n     \
    \         D., and C. Tschudin, \"Information-Centric Networking\n            \
    \  (ICN): CCN and NDN Terminology\", Work in Progress,\n              draft-irtf-icnrg-terminology-04,\
    \ June 2019.\n   [trust]    Tschudin, C., Uzun, E., and C. Wood, \"Trust in\n\
    \              Information-Centric Networking: From Theory to Practice\",\n  \
    \            25th International Conference on Computer Communication\n       \
    \       and Networks (ICCCN), DOI 10.1109/ICCCN.2016.7568589,\n              August\
    \ 2016, <https://doi.org/10.1109/ICCCN.2016.7568589>.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Marc Mosko\n   PARC, Inc.\n   Palo Alto, California  94304\n\
    \   United States of America\n   Phone: +01 650-812-4405\n   Email: marc.mosko@parc.com\n\
    \   Ignacio Solis\n   LinkedIn\n   Mountain View, California  94043\n   United\
    \ States of America\n   Email: nsolis@linkedin.com\n   Christopher A. Wood\n \
    \  University of California Irvine\n   Irvine, California  92697\n   United States\
    \ of America\n   Phone: +01 315-806-5939\n   Email: woodc1@uci.edu\n"
