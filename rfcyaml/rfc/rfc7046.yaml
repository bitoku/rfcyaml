- title: __initial_text__
  contents:
  - ''
- title: Internet Research Task Force (IRTF)                         M. Waehlisch
  contents:
  - "Internet Research Task Force (IRTF)                         M. Waehlisch\n  \
    \           A Common API for Transparent Hybrid Multicast\n"
- title: Abstract
  contents:
  - "Abstract\n   Group communication services exist in a large variety of flavors\
    \ and\n   technical implementations at different protocol layers.  Multicast\n\
    \   data distribution is most efficiently performed on the lowest\n   available\
    \ layer, but a heterogeneous deployment status of multicast\n   technologies throughout\
    \ the Internet requires an adaptive service\n   binding at runtime.  Today, it\
    \ is difficult to write an application\n   that runs everywhere and at the same\
    \ time makes use of the most\n   efficient multicast service available in the\
    \ network.  Facing\n   robustness requirements, developers are frequently forced\
    \ to use a\n   stable upper-layer protocol provided by the application itself.\
    \  This\n   document describes a common multicast API that is suitable for\n \
    \  transparent communication in underlay and overlay and that grants\n   access\
    \ to the different flavors of multicast.  It proposes an\n   abstract naming scheme\
    \ that uses multicast URIs, and it discusses\n   mapping mechanisms between different\
    \ namespaces and distribution\n   technologies.  Additionally, this document describes\
    \ the application\n   of this API for building gateways that interconnect current\
    \ Multicast\n   Domains throughout the Internet.  It reports on an implementation\
    \ of\n   the programming Interface, including service middleware.  This\n   document\
    \ is a product of the Scalable Adaptive Multicast (SAM)\n   Research Group.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This document is a product of the Internet Research Task\n   Force (IRTF).\
    \  The IRTF publishes the results of Internet-related\n   research and development\
    \ activities.  These results might not be\n   suitable for deployment.  This RFC\
    \ represents the consensus of the\n   Scalable Adaptive Multicast Research Group\
    \ of the Internet Research\n   Task Force (IRTF).  Documents approved for publication\
    \ by the IRSG\n   are not a candidate for any level of Internet Standard; see\
    \ Section 2\n   of RFC 5741.\n   Information about the current status of this\
    \ document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc7046.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2013 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n\
    \      1.1. Use Cases for the Common API ...............................6\n  \
    \    1.2. Illustrative Examples ......................................7\n    \
    \       1.2.1. Support of Multiple Underlying Technologies .........7\n      \
    \     1.2.2. Support of Multi-Resolution Multicast ...............9\n   2. Terminology\
    \ ....................................................10\n   3. Overview .......................................................10\n\
    \      3.1. Objectives and Reference Scenarios ........................10\n  \
    \    3.2. Group Communication API and Protocol Stack ................12\n    \
    \  3.3. Naming and Addressing .....................................14\n      3.4.\
    \ Namespaces ................................................15\n      3.5. Name-to-Address\
    \ Mapping ...................................15\n           3.5.1. Canonical Mapping\
    \ ..................................16\n           3.5.2. Mapping at End Points\
    \ ..............................16\n           3.5.3. Mapping at Inter-Domain\
    \ Multicast Gateways .........16\n      3.6. A Note on Explicit Multicast (Xcast)\
    \ ......................16\n      3.7. MTU Handling ..............................................17\n\
    \   4. Common Multicast API ...........................................18\n  \
    \    4.1. Notation ..................................................18\n    \
    \  4.2. URI Scheme Definition .....................................18\n      \
    \     4.2.1. Syntax .............................................18\n        \
    \   4.2.2. Semantic ...........................................19\n          \
    \ 4.2.3. Generic Namespaces .................................20\n           4.2.4.\
    \ Application-Centric Namespaces .....................20\n           4.2.5. Future\
    \ Namespaces ..................................20\n      4.3. Additional Abstract\
    \ Data Types ............................21\n           4.3.1. Interface ..........................................21\n\
    \           4.3.2. Membership Events ..................................21\n  \
    \    4.4. Group Management Calls ....................................22\n    \
    \       4.4.1. Create .............................................22\n      \
    \     4.4.2. Delete .............................................22\n        \
    \   4.4.3. Join ...............................................22\n          \
    \ 4.4.4. Leave ..............................................23\n           4.4.5.\
    \ Source Register ....................................23\n           4.4.6. Source\
    \ Deregister ..................................23\n      4.5. Send and Receive\
    \ Calls ....................................24\n           4.5.1. Send ...............................................24\n\
    \           4.5.2. Receive ............................................24\n  \
    \    4.6. Socket Options ............................................25\n    \
    \       4.6.1. Get Interfaces .....................................25\n      \
    \     4.6.2. Add Interface ......................................25\n        \
    \   4.6.3. Delete Interface ...................................26\n          \
    \ 4.6.4. Set TTL ............................................26\n           4.6.5.\
    \ Get TTL ............................................26\n           4.6.6. Atomic\
    \ Message Size ................................27\n      4.7. Service Calls .............................................27\n\
    \           4.7.1. Group Set ..........................................27\n  \
    \         4.7.2. Neighbor Set .......................................28\n    \
    \       4.7.3. Children Set .......................................28\n      \
    \     4.7.4. Parent Set .........................................28\n        \
    \   4.7.5. Designated Host ....................................29\n          \
    \ 4.7.6. Enable Membership Events ...........................29\n           4.7.7.\
    \ Disable Membership Events ..........................30\n           4.7.8. Maximum\
    \ Message Size ...............................30\n   5. Implementation .................................................30\n\
    \   6. IANA Considerations ............................................30\n  \
    \ 7. Security Considerations ........................................31\n   8.\
    \ Acknowledgements ...............................................31\n   9. References\
    \ .....................................................32\n      9.1. Normative\
    \ References ......................................32\n      9.2. Informative\
    \ References ....................................33\n   Appendix A. C Signatures\
    \ ..........................................35\n   Appendix B. Use Case for the\
    \ API ..................................37\n   Appendix C. Deployment Use Cases\
    \ for Hybrid Multicast .............38\n     C.1. DVMRP ......................................................38\n\
    \     C.2. PIM-SM .....................................................38\n  \
    \   C.3. PIM-SSM ....................................................39\n    \
    \ C.4. BIDIR-PIM ..................................................40\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Currently, group application programmers need to choose\
    \ the\n   distribution technology that the application will require at runtime.\n\
    \   There is no common communication Interface that abstracts multicast\n   transmission\
    \ and subscriptions from the deployment state at runtime,\n   nor has the use\
    \ of DNS for Group Addresses been established.  The\n   standard multicast socket\
    \ options [RFC3493] [RFC3678] are bound to an\n   IP version by not distinguishing\
    \ between the naming and addressing of\n   multicast identifiers.  Group communication,\
    \ however,\n   o  is commonly implemented in different flavors, such as any-source\n\
    \      multicast (ASM) vs. source-specific multicast (SSM),\n   o  is commonly\
    \ implemented on different layers (e.g., IP vs.\n      application-layer multicast),\
    \ and\n   o  may be based on different technologies on the same tier, as seen\n\
    \      with IPv4 vs. IPv6.\n   The objective of this document is to provide for\
    \ programmers a\n   universal access to group services.\n   Multicast application\
    \ development should be decoupled from\n   technological deployment throughout\
    \ the infrastructure.  It requires\n   a common multicast API that offers calls\
    \ to transmit and receive\n   multicast data independent of the supporting layer\
    \ and the underlying\n   technological details.  For inter-technology transmissions,\
    \ a\n   consistent view of multicast states is needed as well.  This document\n\
    \   describes an abstract group communication API and core functions\n   necessary\
    \ for transparent operations.  Specific implementation\n   guidelines with respect\
    \ to operating systems or programming languages\n   are out of scope for this\
    \ document.\n   In contrast to the standard multicast socket Interface, the API\n\
    \   introduced in this document abstracts naming from addressing.  Using\n   a\
    \ multicast address in the current socket API predefines the\n   corresponding\
    \ routing layer.  In this specification, the multicast\n   name used for joining\
    \ a group denotes an application-layer data\n   stream that is identified by a\
    \ multicast URI, independent of its\n   binding to a specific distribution technology.\
    \  Such a Group Name can\n   be mapped to variable routing identifiers.\n   The\
    \ aim of this common API is twofold:\n   o  Enable any application programmer\
    \ to implement group-oriented data\n      communication independent of the underlying\
    \ delivery mechanisms.\n      In particular, allow for a late binding of group\
    \ applications to\n      multicast technologies that makes applications efficient\
    \ but\n      robust with respect to deployment aspects.\n   o  Allow for flexible\
    \ namespace support in group addressing and\n      thereby separate naming and\
    \ addressing (or routing) schemes from\n      the application design.  This abstraction\
    \ not only decouples\n      programs from specific aspects of underlying protocols\
    \ but may\n      open application design to extend to specifically flavored group\n\
    \      services.\n   Multicast technologies may be of various peer-to-peer kinds,\
    \ IPv4 or\n   IPv6 network-layer multicast, or implemented by some other\n   application\
    \ service.  Corresponding namespaces may be IP addresses or\n   DNS naming, overlay\
    \ hashes, or other application-layer group\n   identifiers like <sip:*@peanuts.org>,\
    \ but they can also be names\n   independently defined by the applications.  Common\
    \ namespaces are\n   introduced later in this document but follow an open concept\
    \ suitable\n   for further extensions.\n   This document also discusses mapping\
    \ mechanisms between different\n   namespaces and forwarding technologies and\
    \ proposes expressions of\n   defaults for an intended binding.  Additionally,\
    \ the multicast API\n   provides internal Interfaces to access current multicast\
    \ states at\n   the host.  Multiple multicast protocols may run in parallel on\
    \ a\n   single host.  These protocols may interact to provide a gateway\n   function\
    \ that bridges data between different domains.  The usage of\n   this API at gateways\
    \ operating between current multicast instances\n   throughout the Internet is\
    \ described as well.  Finally, a report on\n   an implementation of the programming\
    \ Interface, including service\n   middleware, is presented.\n   This document\
    \ represents the consensus of the SAM Research Group.  It\n   has been reviewed\
    \ by the Research Group members active in the\n   specific area of work.  In addition,\
    \ this document has been\n   comprehensively reviewed by people who are not \"\
    in\" the Research\n   Group but are experts in the area.\n"
- title: 1.1.  Use Cases for the Common API
  contents:
  - "1.1.  Use Cases for the Common API\n   The following generic use cases can be\
    \ identified; these use cases\n   require an abstract common API for multicast\
    \ services:\n   Application Programming Independent of Technologies:  Application\n\
    \      programmers are provided with group primitives that remain\n      independent\
    \ of multicast technologies and their deployment in\n      target domains.  Thus,\
    \ for a given application, they can develop a\n      program that will run in\
    \ every deployment scenario.  The use of\n      Group Names in the form of abstract\
    \ metadata types allows\n      applications to remain namespace-agnostic in the\
    \ sense that the\n      resolution of namespaces and name-to-address mappings\
    \ may be\n      delegated to a system service at runtime.  Complexity is thereby\n\
    \      minimized, as developers need not care about how data is\n      distributed\
    \ in groups, while the system service can take advantage\n      of extended information\
    \ of the network environment as acquired at\n      startup.\n   Global Identification\
    \ of Groups:  Groups can be identified\n      independent of technological instantiations\
    \ and beyond deployment\n      domains.  Taking advantage of the abstract naming,\
    \ an application\n      can thus match data received from different Interface\
    \ technologies\n      (e.g., IPv4, IPv6, and overlays) to belong to the same group.\n\
    \      This not only increases flexibility -- an application may, for\n      instance,\
    \ combine heterogeneous multipath streams -- but also\n      simplifies the design\
    \ and implementation of gateways.\n   Uniform Access to Multicast Flavors:  The\
    \ URI naming scheme uniformly\n      supports different flavors of group communication,\
    \ such as\n      any-source multicast and source-specific multicast, and selective\n\
    \      broadcast, independent of their service instantiation.  The\n      traditional\
    \ SSM model, for instance, can experience manifold\n      support by directly\
    \ mapping the multicast URI (i.e.,\n      \"group@instantiation\") to an (S,G)\
    \ state on the IP layer, by first\n      resolving S for a subsequent Group Address\
    \ query, by transferring\n      this process to any of the various source-specific\
    \ overlay\n      schemes, or by delegating to a plain replication server.  The\n\
    \      application programmer can invoke any of these underlying\n      mechanisms\
    \ with the same line of code.\n   Simplified Service Deployment through Generic\
    \ Gateways:  The common\n      multicast API allows for an implementation of abstract\
    \ gateway\n      functions with mappings to specific technologies residing at\
    \ the\n      system level.  Generic gateways may provide a simple bridging\n \
    \     service and facilitate an inter-domain deployment of multicast.\n   Mobility-Agnostic\
    \ Group Communication:  Group naming and management\n      as foreseen in the\
    \ common multicast API remain independent of\n      locators.  Naturally, applications\
    \ stay unaware of any mobility-\n      related address changes.  Handover-initiated\
    \ re-addressing is\n      delegated to the mapping services at the system level\
    \ and may be\n      designed to smoothly interact with mobility management solutions\n\
    \      provided at the network or transport layer (see [RFC5757] for\n      mobility-related\
    \ aspects).\n"
- title: 1.2.  Illustrative Examples
  contents:
  - '1.2.  Illustrative Examples

    '
- title: 1.2.1.  Support of Multiple Underlying Technologies
  contents:
  - "1.2.1.  Support of Multiple Underlying Technologies\n   On a very high level,\
    \ the common multicast API provides the\n   application programmer with one single\
    \ Interface to manage multicast\n   content independent of the technology underneath.\
    \  Considering the\n   following simple example in Figure 1, a multicast source\
    \ S is\n   connected via IPv4 and IPv6.  It distributes one flow of multicast\n\
    \   content (e.g., a movie).  Receivers are connected via IPv4/v6 and\n   Overlay\
    \ Multicast (OM), respectively.\n    +-------+       +-------+               \
    \        +-------+\n    |   S   |       |  R1   |                       |  R3\
    \   |\n    +-------+       +-------+                       +-------+\n   v6| \
    \  v4|           |v4                             |OM\n     |     |          /\
    \                                |\n     |  ***| ***  ***/ **                \
    \          *** /***  ***  ***\n      \\*   |*   **  /**   *                  \
    \     *   /*   **   **   *\n      *\\   \\_______/_______*__v4__+-------+    \
    \  *   /                *\n       *\\    IPv4/v6      *       |  R2   |__OM__\
    \ *_/ Overlay Mcast  *\n      *  \\_________________*__v6__+-------+      *  \
    \                  *\n       *   **   **   **   *                       *    **\
    \   **   **  *\n        ***  ***  ***  ***                         ***  ***  ***\
    \  ***\n   Figure 1: Common Scenario: Source S Sends the Same Multicast Content\n\
    \                        via Different Technologies\n   Using the current BSD\
    \ socket API, the application programmer needs to\n   decide on the IP technologies\
    \ at coding time.  Additional\n   distribution techniques, such as overlay multicast,\
    \ must be\n   individually integrated into the application.  For each technology,\n\
    \   the application programmer needs to create a separate socket and\n   initiate\
    \ a dedicated join or send.  As the current socket API does\n   not distinguish\
    \ between Group Name and Group Address, the content\n   will be delivered multiple\
    \ times to the same receiver (cf. R2).\n   Whenever the source distributes content\
    \ via a technology that is not\n   supported by the receivers or its Internet\
    \ Service Provider (cf. R3),\n   a gateway is required.  Gateway functions rely\
    \ on a coherent view of\n   the Multicast Group states.\n   The common multicast\
    \ API simplifies programming of multicast\n   applications, as it abstracts content\
    \ distribution from specific\n   technologies.  In addition to calls that implement\
    \ the receiving and\n   sending of multicast data, the API provides service calls\
    \ to grant\n   access to internal multicast states at the host.  The API description\n\
    \   provided in this document defines a minimal set of programming\n   Interfaces\
    \ to the system components at the host to operate group\n   communication.  It\
    \ is left to specific implementations to provide\n   additional convenience functions\
    \ for programmers.\n   The implementation of content distribution for the example\
    \ shown in\n   Figure 1 may then look like:\n     //Initialize multicast socket\n\
    \     MulticastSocket m = new MulticastSocket();\n     //Associate all available\
    \ Interfaces\n     m.addInterface(getInterfaces());\n     //Subscribe to Multicast\
    \ Group\n     m.join(URI(\"ham:opaque:news@cnn.com\"));\n     //Send to Multicast\
    \ Group\n     m.send(URI(\"ham:opaque:news@cnn.com\"),message);\n            Send/receive\
    \ example using the common multicast API\n   The gateway function for R2 can be\
    \ implemented by service calls that\n   look like:\n     //Initialize multicast\
    \ socket\n     MulticastSocket m = new MulticastSocket();\n     //Check (a) host\
    \ is designated multicast node for this Interface\n     //      (b) receivers\
    \ exist\n     for all this.getInterfaces() {\n       if(designatedHost(this.interface)\
    \ &&\n            childrenSet(this.interface,\n               URI(\"ham:opaque:news@cnn.com\"\
    )) != NULL) {\n         m.addInterface(this.interface);\n       }\n     }\n  \
    \   while(true) {\n       m.send(URI(\"ham:opaque:news@cnn.com\"),message);\n\
    \     }\n              Gateway example using the common multicast API\n"
- title: 1.2.2.  Support of Multi-Resolution Multicast
  contents:
  - "1.2.2.  Support of Multi-Resolution Multicast\n   Multi-resolution multicast\
    \ adjusts the multicast stream to consider\n   heterogeneous end devices.  The\
    \ multicast data (e.g., available by\n   different compression levels) is typically\
    \ announced using multiple\n   multicast addresses that are unrelated to each\
    \ other.  Using the\n   common API, multi-resolution multicast can be implemented\n\
    \   transparently by an operator with the help of name-to-address\n   mapping,\
    \ or by systematic naming from a subscriber-centric\n   perspective.\n   Operator-Centric:\
    \  An operator deploys a domain-specific mapping.  In\n      this case, any multicast\
    \ receiver (e.g., mobile or DSL user)\n      subscribes to the same multicast\
    \ name, which will be resolved\n      locally to different multicast addresses.\
    \  In this case, each\n      Group Address represents a different level of data\
    \ quality.\n   Subscriber-Centric:  In a subscriber-centric example, the multicast\n\
    \      receiver chooses the quality in advance, based on a predefined\n      naming\
    \ syntax.  Consider a layered video stream \"blockbuster\"\n      available at\
    \ different qualities Q_i, each of which consists of\n      the base layer plus\
    \ the sum of EL_j, j <= i enhancement layers.\n      Each individual layer may\
    \ then be accessible by a name\n      \"EL_j.Q_i.blockbuster\", j <= i, while\
    \ a specific quality\n      aggregates the corresponding layers to \"Q_i.blockbuster\"\
    , and the\n      full-size movie may be just called \"blockbuster\".\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   This document uses the terminology as defined for the multicast\n\
    \   protocols discussed in [RFC2710], [RFC3376], [RFC3810], [RFC4601],\n   and\
    \ [RFC4604].  In addition, the following terms will be used:\n   Group Address:\
    \  A Group Address is a routing identifier.  It\n      represents a technological\
    \ specifier and thus reflects the\n      distribution technology in use.  Multicast\
    \ packet forwarding is\n      based on this address.\n   Group Name:  A Group\
    \ Name is an application identifier used by\n      applications to manage communication\
    \ in a Multicast Group (e.g.,\n      join/leave and send/receive).  The Group\
    \ Name does not predefine\n      any distribution technologies.  Even if it syntactically\n\
    \      corresponds to an address, it solely represents a logical\n      identifier.\n\
    \   Multicast Namespace:  A Multicast Namespace is a collection of\n      designators\
    \ (i.e., names or addresses) for groups that share a\n      common syntax.  Typical\
    \ instances of namespaces are IPv4 or IPv6\n      multicast addresses, overlay\
    \ group IDs, Group Names defined on the\n      application layer (e.g., SIP or\
    \ email), or some human-readable\n      string.\n   Interface:  An Interface is\
    \ a forwarding instance of a distribution\n      technology on a given node, for\
    \ example, the IP Interface\n      192.168.1.1 at an IPv4 host, or an overlay\
    \ routing Interface.\n   Multicast Domain:  A Multicast Domain hosts nodes and\
    \ routers of a\n      common, single multicast forwarding technology and is bound\
    \ to a\n      single namespace.\n   Inter-domain Multicast Gateway (IMG):  An\
    \ IMG is an entity that\n      interconnects different Multicast Domains.  Its\
    \ objective is to\n      forward data between these domains, e.g., between an\
    \ IP layer and\n      overlay multicast.\n"
- title: 3.  Overview
  contents:
  - '3.  Overview

    '
- title: 3.1.  Objectives and Reference Scenarios
  contents:
  - "3.1.  Objectives and Reference Scenarios\n   The default use case addressed in\
    \ this document targets applications\n   that participate in a group by using\
    \ some common identifier taken\n   from some common namespace.  This Group Name\
    \ is typically learned at\n   runtime from user interaction, such as the selection\
    \ of an IPTV\n   channel, or from dynamic session negotiations as used with the\n\
    \   Session Initiation Protocol (SIP) [RFC3261] or Peer-to-Peer SIP\n   (P2PSIP)\
    \ [SIP-RELOAD], but may as well have been predefined for an\n   application as\
    \ a common Group Name.  Technology-specific system\n   functions then transparently\
    \ map the Group Name to Group Addresses\n   such that\n   o  programmers can process\
    \ Group Names in their programs without the\n      need to consider technological\
    \ mappings that relate to designated\n      deployments in target domains;\n \
    \  o  applications can identify packets that belong to a logically named\n   \
    \   group, independent of the Interface technology used for sending\n      and\
    \ receiving packets; this shall also hold true for multicast\n      gateways.\n\
    \   This document considers two reference scenarios that cover the\n   following\
    \ hybrid deployment cases displayed in Figure 2:\n   1.  Multicast Domains running\
    \ the same multicast technology but\n       remaining isolated, possibly only\
    \ connected by network-layer\n       unicast.\n   2.  Multicast Domains running\
    \ different multicast technologies but\n       hosting nodes that are members\
    \ of the same Multicast Group.\n                                       +-------+\
    \         +-------+\n                                       | Member|        \
    \ | Member|\n                                       |  Foo  |         |   G  \
    \ |\n                                       +-------+         +-------+\n    \
    \                                         \\            /\n                  \
    \                         ***  ***  ***  ***\n                               \
    \           *   **   **   **   *\n                                         * \
    \                   *\n                                          *  Mcast Tech.\
    \ A   *\n                                         *                    *\n   \
    \                                       *   **   **   **   *\n               \
    \                            ***  ***  ***  ***\n   +-------+          +-------+\
    \                     |\n   | Member|          | Member|                 +-------+\n\
    \   |   G   |          |  Foo  |                 |  IMG  |\n   +-------+     \
    \     +-------+                 +-------+\n       |                |         \
    \                  |\n       ***  ***  ***  ***                 ***  ***  ***\
    \  ***\n      *   **   **   **   *               *   **   **   **   *\n     *\
    \                    *  +-------+  *                    *\n      *  Mcast Tech.\
    \ A   * --|  IMG  |-- *  Mcast Tech. B   *   +------+\n     *                \
    \    *  +-------+  *                    * -|Member|\n      *   **   **   **  \
    \ *               *   **   **   **   *   |  G   |\n       ***  ***  ***  *** \
    \                ***  ***  ***  ***    +------+\n    Figure 2: Reference Scenarios\
    \ for Hybrid Multicast, Interconnecting\n     Group Members from Isolated Homogeneous\
    \ and Heterogeneous Domains\n"
- title: 3.2.  Group Communication API and Protocol Stack
  contents:
  - "3.2.  Group Communication API and Protocol Stack\n   The group communication\
    \ API abstracts the socket concept and consists\n   of four parts.  Two parts\
    \ combine the essential communication\n   functions, while the remaining two offer\
    \ optional extensions for\n   enhanced monitoring and management:\n   Group Management\
    \ Calls:  provide the minimal API to instantiate an\n      abstract multicast\
    \ socket and manage group membership;\n   Send/Receive Calls:  provide the minimal\
    \ API to send and receive\n      multicast data in a technology-transparent fashion;\n\
    \   Socket Options:  provide extension calls for an explicit\n      configuration\
    \ of the multicast socket, such as setting hop limits\n      or associated Interfaces;\n\
    \   Service Calls:  provide extension calls that grant access to internal\n  \
    \    multicast states of an Interface, such as the Multicast Groups\n      under\
    \ subscription or the multicast forwarding information base.\n   Multicast applications\
    \ that use the common API require assistance\n   from a group communication stack.\
    \  This protocol stack serves two\n   needs:\n   o  It provides system-level support\
    \ to transfer the abstract\n      functions of the common API, including namespace\
    \ support, into\n      protocol operations at Interfaces.\n   o  It provides group\
    \ communication services across different\n      multicast technologies at the\
    \ local host.\n   A general initiation of a multicast communication in this setting\n\
    \   proceeds as follows:\n   1.  An application opens an abstract multicast socket.\n\
    \   2.  The application subscribes to / leaves / (de)registers a group\n     \
    \  using a Group Name.\n   3.  An intrinsic function of the stack maps the logical\
    \ group ID\n       (Group Name) to a technical group ID (Group Address).  This\n\
    \       function may make use of deployment-specific knowledge, such as\n    \
    \   available technologies and Group Address management in its\n       domain.\n\
    \   4.  Packet distribution proceeds to and from one or several\n       multicast-enabled\
    \ Interfaces.\n   The abstract multicast socket represents a group communication\n\
    \   channel composed of one or multiple Interfaces.  A socket may be\n   created\
    \ without explicit Interface association by the application,\n   which leaves\
    \ the choice of the underlying forwarding technology to\n   the group communication\
    \ stack.  However, an application may also bind\n   the socket to one or multiple\
    \ dedicated Interfaces and therefore\n   predefine the forwarding technology and\
    \ the Multicast Namespace(s) of\n   the Group Address(es).\n   Applications are\
    \ not required to maintain mapping states for Group\n   Addresses.  The group\
    \ communication stack accounts for the mapping of\n   the Group Name to the Group\
    \ Address(es) and vice versa.  Multicast\n   data passed to the application will\
    \ be augmented by the corresponding\n   Group Name.  Multiple multicast subscriptions\
    \ thus can be conducted\n   on a single multicast socket without the need for\
    \ Group Name encoding\n   on the application side.\n   Hosts may support several\
    \ multicast protocols.  The group\n   communication stack discovers available\
    \ multicast-enabled Interfaces.\n   It provides a minimal hybrid function that\
    \ bridges data between\n   different Interfaces and Multicast Domains.  The details\
    \ of service\n   discovery are out of scope for this document.\n   The extended\
    \ multicast functions can be implemented by middleware, as\n   conceptually presented\
    \ in Figure 3.\n        *-------*     *-------*\n        | App 1 |     | App 2\
    \ |\n        *-------*     *-------*\n            |             |\n        *---------------------*\
    \         ---|\n        |   Middleware        |            |\n        *---------------------*\
    \            |\n             |          |                  |\n        *---------*\
    \     |                  |\n        | Overlay |     |                   \\  Group\
    \ Communication\n        *---------*     |                   /  Stack\n      \
    \       |          |                  |\n             |          |           \
    \       |\n        *---------------------*            |\n        |   Underlay\
    \          |            |\n        *---------------------*         ---|\n   Figure\
    \ 3: Architecture of a Group Communication Stack with Middleware\n       Offering\
    \ Uniform Access to Multicast in Underlay and Overlay\n"
- title: 3.3.  Naming and Addressing
  contents:
  - "3.3.  Naming and Addressing\n   Applications use Group Names to identify groups.\
    \  Names can uniquely\n   determine a group in a global communication context\
    \ and hide\n   technological deployment for data distribution from the application.\n\
    \   In contrast, multicast forwarding operates on Group Addresses.  Even\n   though\
    \ both identifiers may be symbolically identical, they carry\n   different meanings.\
    \  They may also belong to different Multicast\n   Namespaces.  The namespace\
    \ of a Group Address reflects a routing\n   technology, while the namespace of\
    \ a Group Name represents the\n   context in which the application operates.\n\
    \   URIs [RFC3986] are a common way to represent namespace-specific\n   identifiers\
    \ in applications in the form of an abstract metadata type.\n   Throughout this\
    \ document, all Group Names follow a URI notation using\n   the syntax defined\
    \ in Section 4.2.  Examples are\n   ham:ip:224.1.2.3:5000 for a canonical IPv4\
    \ ASM group at UDP port 5000\n   and ham:sip:news@cnn.com for application-specific\
    \ naming with service\n   instantiator and default port selection.\n   An implementation\
    \ of the group communication stack can provide\n   convenience functions that\
    \ detect the namespace of a Group Name or\n   further optimize service instantiation.\
    \  In practice, such a library\n   would provide support for high-level data types\
    \ to the application,\n   similar to some versions of the current socket API (e.g.,\
    \ InetAddress\n   in Java).  Using this data type could implicitly determine the\n\
    \   namespace.  The details of automatic namespace identification or\n   service\
    \ handling are out of scope for this document.\n"
- title: 3.4.  Namespaces
  contents:
  - "3.4.  Namespaces\n   Namespace identifiers in URIs are placed in the scheme element\
    \ and\n   characterize syntax and semantics of the group identifier.  They\n \
    \  enable the use of convenience functions and high-level data types\n   while\
    \ processing URIs.  When used in names, they may indicate an\n   application context\
    \ or may facilitate a default mapping and a\n   recovery of names from addresses.\
    \  When used in addresses, they\n   characterize the group identifier's type.\n\
    \   In compliance with the URI concept, namespace schemes can be added.\n   Examples\
    \ of schemes are generic (see Section 4.2.3) or inherited from\n   applications\
    \ (see Section 4.2.4).\n"
- title: 3.5.  Name-to-Address Mapping
  contents:
  - "3.5.  Name-to-Address Mapping\n   The multicast communication paradigm requires\
    \ all group members to\n   subscribe to the same Group Name, taken from a common\
    \ Multicast\n   Namespace, and to thereby identify the group in a technology-agnostic\n\
    \   way.  Following this common API, a sender correspondingly registers a\n  \
    \ Group Name prior to transmission.\n   At communication end points, Group Names\
    \ require a mapping to Group\n   Addresses prior to service instantiation at the\
    \ Interfaces of the end\n   points.  Similarly, a mapping is needed at gateways\
    \ to consistently\n   translate between Group Addresses from different namespaces.\
    \  Two\n   requirements need to be met by a mapping function that translates\n\
    \   between Multicast Names and Addresses:\n   a.  For a given Group Name, identify\
    \ an Address that is appropriate\n       for a local distribution instance.\n\
    \   b.  For a given Group Address, invert the mapping to recover the\n       Group\
    \ Name.\n   In general, mappings can be complex and do not need to be invertible.\n\
    \   A mapping can be realized by embedding smaller namespaces into larger\n  \
    \ namespaces or selecting an arbitrary, unused ID in a smaller target\n   namespace.\
    \  For example, it is not obvious how to map a large\n   identifier space (e.g.,\
    \ IPv6) to a smaller, collision-prone set like\n   IPv4 (see [MCAST-v4v6-FRAMEWORK],\
    \ [MCAST-v4v6], and [RFC6219]).\n   Mapping functions can be stateless in some\
    \ contexts but may require\n   states in others.  The application of such functions\
    \ depends on the\n   cardinality of the namespaces, the structure of address spaces,\
    \ and\n   possible address collisions.  However, some namespaces facilitate a\n\
    \   canonical, invertible transformation to default address spaces.\n"
- title: 3.5.1.  Canonical Mapping
  contents:
  - "3.5.1.  Canonical Mapping\n   Some Multicast Namespaces defined in Section 3.4\
    \ can express a\n   canonical default mapping.  For example, ham:ip:224.1.2.3:5000\n\
    \   indicates the correspondence to 224.1.2.3 in the default IPv4\n   multicast\
    \ address space at port 5000.  This default mapping is bound\n   to a technology\
    \ and may not always be applicable, e.g., in the case\n   of address collisions.\
    \  Note that under canonical mapping, the\n   multicast URI can be completely\
    \ recovered from any data message\n   received within this group.\n"
- title: 3.5.2.  Mapping at End Points
  contents:
  - "3.5.2.  Mapping at End Points\n   Multicast listeners or senders require a name-to-address\
    \ conversion\n   for all technologies they actively run in a group.  Even though\
    \ a\n   mapping applies to the local Multicast Domain only, end points may\n \
    \  need to learn a valid Group Address from neighboring nodes, e.g.,\n   from\
    \ a gateway in the collision-prone IPv4 domain.  Once set, an end\n   point will\
    \ always be aware of the name-to-address correspondence and\n   thus can autonomously\
    \ invert the mapping.\n"
- title: 3.5.3.  Mapping at Inter-Domain Multicast Gateways
  contents:
  - "3.5.3.  Mapping at Inter-Domain Multicast Gateways\n   Multicast data may arrive\
    \ at an IMG via one technology and request\n   that the gateway re-address packets\
    \ for another distribution system.\n   At initial arrival, the IMG may not have\
    \ explicit knowledge of the\n   corresponding Multicast Group Name.  To perform\
    \ a consistent mapping,\n   the Group Name needs to be acquired.  It may have\
    \ been distributed at\n   source registration or may have been learned from a\
    \ neighboring node,\n   the details of which are beyond the scope of this document.\n"
- title: 3.6.  A Note on Explicit Multicast (Xcast)
  contents:
  - "3.6.  A Note on Explicit Multicast (Xcast)\n   In Explicit Multicast (Xcast)\
    \ [RFC5058], the multicast source\n   explicitly predefines the receivers.  From\
    \ a conceptual perspective,\n   Xcast is an additional distribution technology\
    \ (i.e., a new\n   technology-specific Interface) for this API.  Xcast requires\n\
    \   aggregated knowledge of receivers that is available at the origin of\n   the\
    \ distribution tree.  The instantiation part of the Group Name may\n   refer to\
    \ such a management instance and tree root, which can be the\n   source or some\
    \ co-located processor.\n   An implementation of Xcast then requires a topology-dependent\
    \ mapping\n   of the Group Name to the set of subscribers.  The defining details\
    \ of\n   this multi-destination mapping are out of scope for this document.\n"
- title: 3.7.  MTU Handling
  contents:
  - "3.7.  MTU Handling\n   This API considers a multi-technology scenario in which\
    \ different\n   technologies may have different Maximum Transmission Unit (MTU)\n\
    \   sizes.  Even if the MTU size between two hosts has been determined,\n   it\
    \ may change over time, as initiated by either the network (e.g.,\n   path changes)\
    \ or end hosts (e.g., Interface changes due to mobility).\n   The design of this\
    \ API is based on the objective of robust\n   communication and easy application\
    \ development.  MTU handling and the\n   implementation of fragmentation are thus\
    \ guided by the following\n   observations:\n   Application:  Application programmers\
    \ need a simple way to transmit\n      packets in a technology-agnostic fashion.\
    \  For this, it is\n      convenient at the time of coding to rely on a transparent\
    \ maximum\n      amount of data that can be sent in one message from a socket.\
    \  A\n      regular program flow should not be distracted by querying and\n  \
    \    changing MTU sizes.  Technically, the configuration of the maximum\n    \
    \  message size used by the application programmer may change and\n      disrupt\
    \ communication when (a) Interfaces are added or excluded or\n      (b) the path\
    \ MTU changes during transmission and thus disables the\n      corresponding Interfaces.\n\
    \   Middleware:  Middleware situated between application and technology\n    \
    \  Interfaces ensures a general packet-handling capability, which in\n      turn\
    \ prevents the application programmer from implementing\n      fragmentation.\
    \  A uniform maximum message size that cannot be\n      changed during runtime\
    \ shall be guaranteed by the group\n      communication stack (e.g., middleware).\
    \  Otherwise, this would\n      conflict with a technology-agnostic application.\n\
    \   Technology Interfaces:  Fragmentation requirements depend on the\n      technology\
    \ in use.  Hence, the (technology-bound) Interfaces need\n      to cope with MTU\
    \ sizes that may vary among Interfaces and along\n      different paths.\n   The\
    \ concept of this API also aims at guaranteeing a maximum message\n   size for\
    \ the application programmer, to thereby handle fragmentation\n   at the Interface\
    \ level, if needed.  Nevertheless, the application\n   programmer should be able\
    \ to determine the technology-specific atomic\n   message size to optimize data\
    \ distribution, or for other reasons.\n   The uniform maximum message size should\
    \ take realistic values (e.g.,\n   following IP clients) to enable smooth and\
    \ efficient services.  A\n   detailed selection scheme of MTU values is out of\
    \ scope for this\n   document.\n"
- title: 4.  Common Multicast API
  contents:
  - '4.  Common Multicast API

    '
- title: 4.1.  Notation
  contents:
  - "4.1.  Notation\n   The following description of the common multicast API is expressed\
    \ in\n   pseudo-syntax.  Variables that are passed to function calls are\n   declared\
    \ by \"in\", and return values are declared by \"out\".  A list of\n   elements\
    \ is denoted by \"<>\".  The pseudo-syntax assumes that lists\n   include an attribute\
    \ that represents the number of elements.\n   The corresponding C signatures are\
    \ defined in Appendix A.\n"
- title: 4.2.  URI Scheme Definition
  contents:
  - "4.2.  URI Scheme Definition\n   Multicast Names and Multicast Addresses used\
    \ in this API are\n   represented by a URI scheme that is specified in the following\n\
    \   subsections.  A corresponding ham-URI denotes a multicast channel and\n  \
    \ may be dereferenced to retrieve data published to that channel.\n"
- title: 4.2.1.  Syntax
  contents:
  - "4.2.1.  Syntax\n   The syntax of the multicast URI is specified using the Augmented\n\
    \   Backus-Naur Form (ABNF) [RFC5234] and is defined as follows:\n   ham-URI \
    \  = ham-scheme \":\" namespace \":\" group [ \"@\" instantiation ]\n      [ \"\
    :\" port ] [ \"/\" sec-credentials ]\n   ham-scheme      = \"ham\" ; hybrid adaptive\
    \ multicast\n   namespace       = ALPHA *( ALPHA / DIGIT / \"+\" / \"-\" / \"\
    .\" )\n   group           = \"*\" / 1*unreserved ; unreserved per [RFC3986]\n\
    \   instantiation   = 1*unreserved ; unreserved per [RFC3986]\n   port       \
    \     = 1*DIGIT\n   sec-credentials = alg \";\" val\n   alg             = 1*unreserved\
    \ ; unreserved per [RFC3986]\n   val             = 1*unreserved ; unreserved per\
    \ [RFC3986]\n   Percent-encoding is applied to distinguish between reserved and\n\
    \   unreserved assignments of the same character in the same ham-URI\n   component\
    \ (cf. [RFC3986]).\n"
- title: 4.2.2.  Semantic
  contents:
  - "4.2.2.  Semantic\n   The semantic of the different parts of the URI is defined\
    \ as follows:\n   ham-scheme:  refers to the specification of the assigned identifier\n\
    \      \"ham\".\n   namespace:  takes the role of the Multicast Namespace.  It\
    \ defines\n      the syntax of the group and instantiation part of the ham-URI.\
    \  A\n      basic syntax for these elements is specified in Section 4.2.1.\n \
    \     The namespace may further restrict the syntax of designators.\n      Example\
    \ namespaces are described in Sections 4.2.3 and 4.2.4.\n   group:  uniquely identifies\
    \ the group within the Multicast Namespace\n      given in the namespace.  The\
    \ literal \"*\" represents all members of\n      the Multicast Group.\n   instantiation:\
    \  identifies the entity that generates the instance of\n      the group (e.g.,\
    \ a SIP domain or a source in SSM, a dedicated\n      routing entity, or a named\
    \ processor that accounts for the group\n      communication), using syntax and\
    \ semantics as defined by the\n      namespace.  This parameter is optional. \
    \ Note that ambiguities\n      (e.g., identical node addresses in multiple overlay\
    \ instances) can\n      be distinguished by ports.\n   port:  identifies a specific\
    \ application at an instance of a group.\n      This parameter is optional.\n\
    \   sec-credentials:  used to implement security mechanisms (e.g., to\n      authorize\
    \ Multicast Group access or authenticate multicast\n      operations).  This parameter\
    \ is optional. \"alg\" represents the\n      security algorithm in use.  \"val\"\
    \ represents the actual value for\n      Authentication, Authorization, and Accounting\
    \ (AAA).  Note that\n      security credentials may carry a distinct technical\
    \ meaning w.r.t.\n      AAA schemes and may differ between group members.  Hence,\
    \ the\n      sec-credentials are not considered part of the Group Name.\n"
- title: 4.2.3.  Generic Namespaces
  contents:
  - "4.2.3.  Generic Namespaces\n   IP:  This namespace is comprised of regular IP\
    \ node naming, i.e., DNS\n      names and addresses taken from any version of\
    \ the Internet\n      Protocol.  The syntax of the group and instantiation follows\
    \ the\n      \"host\" definition in [RFC3986], Section 3.2.2.  A processor\n \
    \     dealing with the IP namespace is required to determine the syntax\n    \
    \  (DNS name, IP address, version) of the group and instantiation\n      expression.\n\
    \   SHA-2:  This namespace carries address strings compliant with SHA-2\n    \
    \  hash digests.  The syntax of the group and instantiation follows\n      the\
    \ \"val\" definition in [RFC6920], Section 3.  A processor\n      handling those\
    \ strings is required to determine the length of the\n      expressions and passes\
    \ appropriate values directly to a\n      corresponding overlay.\n   Opaque: \
    \ This namespace transparently carries strings without further\n      syntactical\
    \ information, meanings, or associated resolution\n      mechanisms.  The corresponding\
    \ syntax for the group and\n      instantiation part of the ham-URI is defined\
    \ in Section 4.2.1.\n"
- title: 4.2.4.  Application-Centric Namespaces
  contents:
  - "4.2.4.  Application-Centric Namespaces\n   SIP:  The SIP namespace is an example\
    \ of an application-layer scheme\n      that bears inherent group functions (conferencing).\
    \  SIP\n      conference URIs may be directly exchanged and interpreted at the\n\
    \      application, and mapped to Group Addresses at the system level to\n   \
    \   generate a corresponding Multicast Group.  The syntax of the group\n     \
    \ and instantiation is represented by the \"userinfo\" component\n      [RFC3261],\
    \ Section 25.1.\n   RELOAD:  This namespace covers address strings that are valid\
    \ in a\n      REsource LOcation And Discovery [RELOAD] overlay network.  A\n \
    \     processor handling those strings may pass these values directly to\n   \
    \   a corresponding overlay that may manage multicast distribution\n      according\
    \ to [RFC7019].\n"
- title: 4.2.5.  Future Namespaces
  contents:
  - "4.2.5.  Future Namespaces\n   The concept of the common multicast API allows\
    \ for any namespace that\n   complies with the superset syntax defined in Section\
    \ 4.2.1.  This\n   document specifies a basic set of Multicast Namespaces in\n\
    \   Sections 4.2.3 and 4.2.4.  If additional namespaces are needed in the\n  \
    \ future, a registry for those namespaces should be created and should\n   be\
    \ defined in a future document.  All namespaces defined in such a\n   document\
    \ should then also be assigned to the registry.\n"
- title: 4.3.  Additional Abstract Data Types
  contents:
  - '4.3.  Additional Abstract Data Types

    '
- title: 4.3.1.  Interface
  contents:
  - "4.3.1.  Interface\n   The Interface denotes the layer and instance on which the\n\
    \   corresponding call takes effect.  In agreement with [RFC3493], we\n   identify\
    \ an Interface by an identifier, which is a positive integer\n   starting at 1.\n\
    \   Properties of an Interface are stored in the following data\n   structure:\n\
    \       struct ifProp {\n         UnsignedInt if_index; /* 1, 2, ... */\n    \
    \     String        *ifName;  /* \"eth0\", \"eth1:1\", \"lo\", ... */\n      \
    \   String        *ifAddr;  /* \"1.2.3.4\", \"abc123\", ... */\n         String\
    \        *ifTech;  /* \"ip\", \"overlay\", ... */\n       };\n   The following\
    \ function retrieves all available Interfaces from the\n   system:\n       getInterfaces(out\
    \ Interface <ifs>);\n   It extends the functions for Interface identification\
    \ as defined in\n   [RFC3493], Section 4 and can be implemented by:\n       struct\
    \ ifProp(out IfProp <ifsProps>);\n"
- title: 4.3.2.  Membership Events
  contents:
  - "4.3.2.  Membership Events\n   A membership event is triggered by a multicast\
    \ state change that is\n   observed by the current node.  It is related to a specific\
    \ Group Name\n   and may be receiver or source oriented.\n       eventType {\n\
    \               joinEvent;\n               leaveEvent;\n               newSourceEvent;\n\
    \       };\n       event {\n              EventType event;\n              Uri\
    \ groupName;\n              Interface if;\n       };\n   An event will be created\
    \ by the group communication stack and passed\n   to applications that have registered\
    \ for events.\n"
- title: 4.4.  Group Management Calls
  contents:
  - '4.4.  Group Management Calls

    '
- title: 4.4.1.  Create
  contents:
  - "4.4.1.  Create\n   The create call initiates a multicast socket and provides\
    \ the\n   application programmer with a corresponding handle.  If no Interfaces\n\
    \   will be assigned based on the call, the default Interface will be\n   selected\
    \ and associated with the socket.  The call returns an error\n   code in the case\
    \ of failures, e.g., due to non-operational\n   communication middleware.\n  \
    \     createMSocket(in Interface <ifs>,\n                     out Socket s);\n\
    \   The ifs argument denotes a list of Interfaces (if_indexes) that will\n   be\
    \ associated with the multicast socket.  This parameter is optional.\n   On success,\
    \ a multicast socket identifier is returned; otherwise, it\n   is NULL.\n"
- title: 4.4.2.  Delete
  contents:
  - "4.4.2.  Delete\n   The delete call removes the multicast socket.\n       deleteMSocket(in\
    \ Socket s, out Int error);\n   The s argument identifies the multicast socket\
    \ for destruction.\n   On success, the out parameter error is 0; otherwise, -1\
    \ is returned.\n"
- title: 4.4.3.  Join
  contents:
  - "4.4.3.  Join\n   The join call initiates a subscription for the given Group Name.\n\
    \   Depending on the Interfaces that are associated with the socket, this\n  \
    \ may result in an IGMP / Multicast Listener Discovery (MLD) report or\n   overlay\
    \ subscription, for example.\n       join(in Socket s, in Uri groupName, out Int\
    \ error);\n   The s argument identifies the multicast socket.\n   The groupName\
    \ argument identifies the group.\n   On success, the out parameter error is 0;\
    \ otherwise, -1 is returned.\n"
- title: 4.4.4.  Leave
  contents:
  - "4.4.4.  Leave\n   The leave call results in an unsubscription for the given Group\
    \ Name.\n       leave(in Socket s, in Uri groupName, out Int error);\n   The s\
    \ argument identifies the multicast socket.\n   The groupName argument identifies\
    \ the group.\n   On success, the out parameter error is 0; otherwise, -1 is returned.\n"
- title: 4.4.5.  Source Register
  contents:
  - "4.4.5.  Source Register\n   The srcRegister call registers a source for a group\
    \ on all active\n   Interfaces of the socket s.  This call may assist group distribution\n\
    \   in some technologies -- for example, the creation of sub-overlays --\n   or\
    \ may facilitate a name-to-address mapping.  Likewise, it may remain\n   without\
    \ effect in some multicast technologies.\n       srcRegister(in Socket s, in Uri\
    \ groupName,\n                   out Interface <ifs>, out Int error);\n   The\
    \ s argument identifies the multicast socket.\n   The groupName argument identifies\
    \ the Multicast Group to which a\n   source intends to send data.\n   The ifs\
    \ argument points to the list of Interface indexes for which\n   the source registration\
    \ failed.  A NULL pointer is returned if the\n   list is empty.  This parameter\
    \ is optional.\n   If source registration succeeded for all Interfaces associated\
    \ with\n   the socket, the out parameter error is 0; otherwise, -1 is returned.\n"
- title: 4.4.6.  Source Deregister
  contents:
  - "4.4.6.  Source Deregister\n   The srcDeregister call indicates that a source\
    \ no longer intends to\n   send data to the Multicast Group.  This call may remain\
    \ without\n   effect in some multicast technologies.\n       srcDeregister(in\
    \ Socket s, in Uri groupName,\n                     out Interface <ifs>, out Int\
    \ error);\n   The s argument identifies the multicast socket.\n   The groupName\
    \ argument identifies the Multicast Group to which a\n   source has stopped sending\
    \ multicast data.\n   The ifs argument points to the list of Interfaces for which\
    \ the\n   source deregistration failed.  A NULL pointer is returned if the list\n\
    \   is empty.\n   If source deregistration succeeded for all Interfaces associated\
    \ with\n   the socket, the out parameter error is 0; otherwise, -1 is returned.\n"
- title: 4.5.  Send and Receive Calls
  contents:
  - '4.5.  Send and Receive Calls

    '
- title: 4.5.1.  Send
  contents:
  - "4.5.1.  Send\n   The send call passes multicast data destined for a Multicast\
    \ Name\n   from the application to the multicast socket.\n   It is worth noting\
    \ that it is the choice of the programmer to send\n   data via one socket per\
    \ group or to use a single socket for multiple\n   groups.\n       send(in Socket\
    \ s, in Uri groupName,\n            in Size msgLen, in Msg msgBuf,\n         \
    \   out Int error);\n   The s argument identifies the multicast socket.\n   The\
    \ groupName argument identifies the group to which data will be\n   sent.\n  \
    \ The msgLen argument holds the length of the message to be sent.\n   The msgBuf\
    \ argument passes the multicast data to the multicast\n   socket.\n   On success,\
    \ the out parameter error is 0; otherwise, -1 is returned.\n   A message that\
    \ is too long is indicated by an implementation-specific\n   error code (e.g.,\
    \ EMSGSIZE in C).\n"
- title: 4.5.2.  Receive
  contents:
  - "4.5.2.  Receive\n   The receive call passes multicast data and the corresponding\
    \ Group\n   Name to the application.  This may come in a blocking or non-blocking\n\
    \   variant.\n   It is worth noting that it is the choice of the programmer to\
    \ receive\n   data via one socket per group or to use a single socket for multiple\n\
    \   groups.\n       receive(in Socket s, out Uri groupName,\n               out\
    \ Size msgLen, out Msg msgBuf,\n               out Int error);\n   The s argument\
    \ identifies the multicast socket.\n   The groupName argument identifies the Multicast\
    \ Group for which data\n   was received.\n   The msgLen argument holds the length\
    \ of the received message.\n   The msgBuf argument points to the payload of the\
    \ received multicast\n   data.\n   On success, the out parameter error is 0; otherwise,\
    \ -1 is returned.\n   A message that is too long is indicated by an implementation-specific\n\
    \   error code (e.g., EMSGSIZE).\n"
- title: 4.6.  Socket Options
  contents:
  - "4.6.  Socket Options\n   The following calls configure an existing multicast\
    \ socket.\n"
- title: 4.6.1.  Get Interfaces
  contents:
  - "4.6.1.  Get Interfaces\n   The getInterfaces call returns an array of all available\
    \ multicast\n   communication Interfaces associated with the multicast socket.\n\
    \       getInterfaces(in Socket s,\n                     out Interface <ifs>,\
    \ out Int error);\n   The s argument identifies the multicast socket.\n   The\
    \ ifs argument points to an array of Interface index identifiers.\n   On success,\
    \ the out parameter error is 0; otherwise, -1 is returned.\n"
- title: 4.6.2.  Add Interface
  contents:
  - "4.6.2.  Add Interface\n   The addInterface call adds a distribution channel to\
    \ the socket.\n   This may be an overlay or underlay Interface, e.g., IPv6 or\n\
    \   Distributed Hash Table (DHT).  Multiple Interfaces of the same\n   technology\
    \ may be associated with the socket.\n       addInterface(in Socket s, in Interface\
    \ if,\n                    out Int error);\n   The s and if arguments identify\
    \ a multicast socket and Interface,\n   respectively.\n   On success, the value\
    \ 0 is returned; otherwise, -1 is returned.\n"
- title: 4.6.3.  Delete Interface
  contents:
  - "4.6.3.  Delete Interface\n   The delInterface call removes the Interface from\
    \ the multicast\n   socket.\n       delInterface(in Socket s, Interface if,\n\
    \                    out Int error);\n   The s and if arguments identify a multicast\
    \ socket and Interface,\n   respectively.\n   On success, the out parameter error\
    \ is 0; otherwise, -1 is returned.\n"
- title: 4.6.4.  Set TTL
  contents:
  - "4.6.4.  Set TTL\n   The setTTL call configures the maximum hop count for the\
    \ socket that\n   a multicast message is allowed to traverse.\n       setTTL(in\
    \ Socket s, in Int h,\n              in Interface <ifs>,\n              out Int\
    \ error);\n   The s and h arguments identify a multicast socket and the maximum\
    \ hop\n   count, respectively.\n   The ifs argument points to an array of Interface\
    \ index identifiers.\n   This parameter is optional.\n   On success, the out parameter\
    \ error is 0; otherwise, -1 is returned.\n"
- title: 4.6.5.  Get TTL
  contents:
  - "4.6.5.  Get TTL\n   The getTTL call returns the maximum hop count that a multicast\n\
    \   message is allowed to traverse for the interface bound to the socket.\n  \
    \     getTTL(in Socket s, in Interface if,\n              out Int h, out Int error);\n\
    \   The s argument identifies a multicast socket.\n   The if argument identifies\
    \ an interface that is bound to socket s.\n   The h argument holds the maximum\
    \ number of hops associated with the\n   interface.\n   On success, the out parameter\
    \ error is 0; otherwise, -1 is returned.\n"
- title: 4.6.6.  Atomic Message Size
  contents:
  - "4.6.6.  Atomic Message Size\n   The getAtomicMsgSize function returns the maximum\
    \ message size that\n   an application is allowed to transmit per socket at once\
    \ without\n   fragmentation.  This value depends on the Interfaces associated\
    \ with\n   the socket in use and thus may change during runtime.\n       getAtomicMsgSize(in\
    \ Socket s,\n                        out Int return);\n   On success, the function\
    \ returns a positive value of appropriate\n   message size; otherwise, -1 is returned.\n"
- title: 4.7.  Service Calls
  contents:
  - '4.7.  Service Calls

    '
- title: 4.7.1.  Group Set
  contents:
  - "4.7.1.  Group Set\n   The groupSet call returns all Multicast Groups registered\
    \ at a given\n   Interface.  This information can be provided by group management\n\
    \   states or routing protocols.  The return values distinguish between\n   sender\
    \ and listener states.\n       struct GroupSet {\n         Uri groupName; /* registered\
    \ Multicast Group */\n         Int type;       /* 0 = listener state, 1 = sender\
    \ state,\n                            2 = sender and listener state */\n     \
    \  }\n       groupSet(in Interface if,\n                out GroupSet <groupSet>,\
    \ out Int error);\n   The if argument identifies the Interface for which states\
    \ are\n   maintained.\n   The groupSet argument points to a list of group states.\n\
    \   On success, the out parameter error is 0; otherwise, -1 is returned.\n"
- title: 4.7.2.  Neighbor Set
  contents:
  - "4.7.2.  Neighbor Set\n   The neighborSet function returns the set of neighboring\
    \ nodes for a\n   given Interface as seen by the multicast routing protocol.\n\
    \       neighborSet(in Interface if,\n                   out Uri <neighborsAddresses>,\
    \ out Int error);\n   The if argument identifies the Interface for which information\n\
    \   regarding neighbors is requested.\n   The neighborsAddresses argument points\
    \ to a list of neighboring nodes\n   on a successful return.\n   On success, the\
    \ out parameter error is 0; otherwise, -1 is returned.\n"
- title: 4.7.3.  Children Set
  contents:
  - "4.7.3.  Children Set\n   The childrenSet function returns the set of child nodes\
    \ that receive\n   multicast data from a specified Interface for a given group.\
    \  For a\n   common multicast router, this call retrieves the multicast forwarding\n\
    \   information base per Interface.\n       childrenSet(in Interface if, in Uri\
    \ groupName,\n                   out Uri <childrenAddresses>, out Int error);\n\
    \   The if argument identifies the Interface for which information\n   regarding\
    \ children is requested.\n   The groupName argument defines the Multicast Group\
    \ for which\n   distribution is considered.\n   The childrenAddresses argument\
    \ points to a list of neighboring nodes\n   on a successful return.\n   On success,\
    \ the out parameter error is 0; otherwise, -1 is returned.\n"
- title: 4.7.4.  Parent Set
  contents:
  - "4.7.4.  Parent Set\n   The parentSet function returns the set of neighbors from\
    \ which the\n   current node receives multicast data at a given Interface for\
    \ the\n   specified group.\n       parentSet(in Interface if, in Uri groupName,\n\
    \                 out Uri <parentsAddresses>, out Int error);\n   The if argument\
    \ identifies the Interface for which information\n   regarding parents is requested.\n\
    \   The groupName argument defines the Multicast Group for which\n   distribution\
    \ is considered.\n   The parentsAddresses argument points to a list of neighboring\
    \ nodes\n   on a successful return.\n   On success, the out parameter error is\
    \ 0; otherwise, -1 is returned.\n"
- title: 4.7.5.  Designated Host
  contents:
  - "4.7.5.  Designated Host\n   The designatedHost function inquires about whether\
    \ this host has the\n   role of a designated forwarder (or querier), or not. \
    \ Such\n   information is provided by almost all multicast protocols to prevent\n\
    \   packet duplication, if multiple multicast instances provide service\n   on\
    \ the same subnet.\n       designatedHost(in Interface if, in Uri groupName\n\
    \                      out Int return);\n   The if argument identifies the Interface\
    \ for which information\n   regarding designated forwarding is requested.\n  \
    \ The groupName argument specifies the group for which the host may\n   attain\
    \ the role of designated forwarder.\n   The function returns 1 if the host is\
    \ a designated forwarder or\n   querier.  The return value -1 indicates an error.\
    \  Otherwise, 0 is\n   returned.\n"
- title: 4.7.6.  Enable Membership Events
  contents:
  - "4.7.6.  Enable Membership Events\n   The enableEvents function registers an application\
    \ at the group\n   communication stack to receive information about group changes.\n\
    \   State changes are the result of new receiver subscriptions or leaves,\n  \
    \ as well as source changes.  Upon receiving an event, the group\n   service may\
    \ obtain additional information from further service calls.\n       enableEvents();\n\
    \   Calling this function, the stack starts to pass membership events to\n   the\
    \ application.  Each event includes an event type identifier and a\n   Group Name\
    \ (cf. Section 4.3.2).\n   The multicast protocol does not have to support membership\
    \ tracking\n   in order to enable this feature.  This function can also be\n \
    \  implemented at the middleware layer.\n"
- title: 4.7.7.  Disable Membership Events
  contents:
  - "4.7.7.  Disable Membership Events\n   The disableEvents function deactivates\
    \ the information about group\n   state changes.\n       disableEvents();\n  \
    \ On success, the stack will not pass membership events to the\n   application.\n"
- title: 4.7.8.  Maximum Message Size
  contents:
  - "4.7.8.  Maximum Message Size\n   The getMaxMsgSize function returns the maximum\
    \ message size that an\n   application is allowed to transmit per socket at once.\
    \  This value is\n   statically guaranteed by the group communication stack.\n\
    \       getMaxMsgSize(out Int return);\n   On success, the function returns a\
    \ positive value of allowed message\n   size; otherwise, -1 is returned.\n"
- title: 5.  Implementation
  contents:
  - "5.  Implementation\n   A reference implementation of the Common API for Transparent\
    \ Hybrid\n   Multicast is available with the HAMcast stack [HAMcast-DEV] [GC2010]\n\
    \   [LCN2012].  This open-source software supports the multicast API (C++\n  \
    \ and Java library) for group application development, the middleware\n   as a\
    \ user space system service, and several multicast-technology\n   modules.  The\
    \ middleware is implemented in C++.\n   This API is verified and adjusted based\
    \ on the real-world experiences\n   gathered in the HAMcast project, and by additional\
    \ users of the\n   stack.\n"
- title: 6.  IANA Considerations
  contents:
  - "6.  IANA Considerations\n   This document specifies the \"ham\" URI scheme that\
    \ has been registered\n   by IANA as one of the \"Provisional URI Schemes\" according\
    \ to\n   [RFC4395].\n   URI scheme name        ham\n   Status                \
    \ provisional\n   URI scheme syntax      See Section 4.2.1.\n   URI scheme semantics\
    \   See Section 4.2.2.\n   Encoding               See Section 4.2.1\n   considerations\n\
    \   Applications/protocols The scheme is used by multicast applications\n   that\
    \ use this URI      to access multicast content.\n   scheme name\n   Interoperability\
    \       None\n   considerations\n   Security               See Section 7.\n  \
    \ considerations\n   Contact                Matthias Waehlisch, mw@link-lab.net\n\
    \   Author/Change          IRTF\n   controller\n   References             As specified\
    \ in this document.\n"
- title: 7.  Security Considerations
  contents:
  - "7.  Security Considerations\n   This document does not introduce additional messages\
    \ or novel\n   protocol operations.\n"
- title: 8.  Acknowledgements
  contents:
  - "8.  Acknowledgements\n   We would like to thank the HAMcast team at the HAW Hamburg\
    \ -- Nora\n   Berg, Gabriel Hege, Fabian Holler, Alexander Knauf, Sebastian\n\
    \   Meiling, Sebastian Woelke, and Sebastian Zagaria -- for many fruitful\n  \
    \ discussions and for their continuous critical feedback while\n   implementing\
    \ the common multicast API and hybrid multicast\n   middleware.  Special thanks\
    \ to Dominik Charousset of the HAMcast team\n   for in-depth perspectives on the\
    \ matter of code.  We gratefully\n   acknowledge WeeSan, Mario Kolberg, and John\
    \ Buford for reviewing and\n   their suggestions to improve the document.  We\
    \ would like to thank\n   the Name-Based Socket BoF (in particular Dave Thaler)\
    \ for clarifying\n   insights into the question of meta-function calls.  We thank\
    \ Lisandro\n   Zambenedetti Granville and Tony Li for very careful reviews of\
    \ the\n   pre-final versions of this document.  Barry Leiba and Graham Klyne\n\
    \   provided very constructive input to find a suitable URI scheme.  They\n  \
    \ are gratefully acknowledged.\n   This work is partially supported by the German\
    \ Federal Ministry of\n   Education and Research within the HAMcast project (see\n\
    \   <http://hamcast.realmv6.org>), which is part of G-Lab.\n"
- title: 9.  References
  contents:
  - '9.  References

    '
- title: 9.1.  Normative References
  contents:
  - "9.1.  Normative References\n   [RFC1075]  Waitzman, D., Partridge, C., and S.\
    \ Deering, \"Distance\n              Vector Multicast Routing Protocol\", RFC\
    \ 1075,\n              November 1988.\n   [RFC2710]  Deering, S., Fenner, W.,\
    \ and B. Haberman, \"Multicast\n              Listener Discovery (MLD) for IPv6\"\
    , RFC 2710,\n              October 1999.\n   [RFC3261]  Rosenberg, J., Schulzrinne,\
    \ H., Camarillo, G., Johnston,\n              A., Peterson, J., Sparks, R., Handley,\
    \ M., and E.\n              Schooler, \"SIP: Session Initiation Protocol\", RFC\
    \ 3261,\n              June 2002.\n   [RFC3376]  Cain, B., Deering, S., Kouvelas,\
    \ I., Fenner, B., and A.\n              Thyagarajan, \"Internet Group Management\
    \ Protocol,\n              Version 3\", RFC 3376, October 2002.\n   [RFC3493]\
    \  Gilligan, R., Thomson, S., Bound, J., McCann, J., and W.\n              Stevens,\
    \ \"Basic Socket Interface Extensions for IPv6\",\n              RFC 3493, February\
    \ 2003.\n   [RFC3678]  Thaler, D., Fenner, B., and B. Quinn, \"Socket Interface\n\
    \              Extensions for Multicast Source Filters\", RFC 3678,\n        \
    \      January 2004.\n   [RFC3810]  Vida, R. and L. Costa, \"Multicast Listener\
    \ Discovery\n              Version 2 (MLDv2) for IPv6\", RFC 3810, June 2004.\n\
    \   [RFC3986]  Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n   \
    \           Resource Identifier (URI): Generic Syntax\", STD 66,\n           \
    \   RFC 3986, January 2005.\n   [RFC4395]  Hansen, T., Hardie, T., and L. Masinter,\
    \ \"Guidelines and\n              Registration Procedures for New URI Schemes\"\
    , BCP 35,\n              RFC 4395, February 2006.\n   [RFC4601]  Fenner, B., Handley,\
    \ M., Holbrook, H., and I. Kouvelas,\n              \"Protocol Independent Multicast\
    \ - Sparse Mode (PIM-SM):\n              Protocol Specification (Revised)\", RFC\
    \ 4601, August 2006.\n   [RFC4604]  Holbrook, H., Cain, B., and B. Haberman, \"\
    Using Internet\n              Group Management Protocol Version 3 (IGMPv3) and\
    \ Multicast\n              Listener Discovery Protocol Version 2 (MLDv2) for Source-\n\
    \              Specific Multicast\", RFC 4604, August 2006.\n   [RFC5015]  Handley,\
    \ M., Kouvelas, I., Speakman, T., and L. Vicisano,\n              \"Bidirectional\
    \ Protocol Independent Multicast\n              (BIDIR-PIM)\", RFC 5015, October\
    \ 2007.\n   [RFC5058]  Boivie, R., Feldman, N., Imai, Y., Livens, W., and D.\n\
    \              Ooms, \"Explicit Multicast (Xcast) Concepts and Options\",\n  \
    \            RFC 5058, November 2007.\n   [RFC5234]  Crocker, D. and P. Overell,\
    \ \"Augmented BNF for Syntax\n              Specifications: ABNF\", STD 68, RFC\
    \ 5234, January 2008.\n   [RFC6920]  Farrell, S., Kutscher, D., Dannewitz, C.,\
    \ Ohlman, B.,\n              Keranen, A., and P. Hallam-Baker, \"Naming Things\
    \ with\n              Hashes\", RFC 6920, April 2013.\n"
- title: 9.2.  Informative References
  contents:
  - "9.2.  Informative References\n   [AMT]      Bumgardner, G., \"Automatic Multicast\
    \ Tunneling\", Work\n              in Progress, October 2013.\n   [GC2010]   Meiling,\
    \ S., Charousset, D., Schmidt, T., and M.\n              Waehlisch, \"System-assisted\
    \ Service Evolution for a Future\n              Internet - The HAMcast Approach\
    \ to Pervasive Multicast\",\n              Proc. IEEE GLOBECOM 2010 Workshops,\
    \ MCS 2010, pp. 913-917,\n              Piscataway, NJ, USA, IEEE Press, December\
    \ 2010.\n   [HAMcast-DEV]\n              \"HAMcast developers\",\n           \
    \   <http://hamcast.realmv6.org/developers>.\n   [LCN2012]  Meiling, S., Schmidt,\
    \ T., and M. Waehlisch, \"Large-Scale\n              Measurement and Analysis\
    \ of One-Way Delay in Hybrid\n              Multicast Networks\", Proc. 37th Annual\
    \ IEEE Conference on\n              Local Computer Networks (LCN 2012), Piscataway,\
    \ NJ, USA,\n              IEEE Press, October 2012.\n   [MCAST-v4v6]\n       \
    \       Venaas, S., Asaeda, H., SUZUKI, S., and T. Fujisaki, \"An\n          \
    \    IPv4 - IPv6 multicast translator\", Work in Progress,\n              December\
    \ 2010.\n   [MCAST-v4v6-FRAMEWORK]\n              Venaas, S., Li, X., and C. Bao,\
    \ \"Framework for IPv4/IPv6\n              Multicast Translation\", Work in Progress,\
    \ June 2011.\n   [RELOAD]   Jennings, C., Lowekamp, B., Ed., Rescorla, E., Baset,\
    \ S.,\n              and H. Schulzrinne, \"REsource LOcation And Discovery\n \
    \             (RELOAD) Base Protocol\", Work in Progress, February 2013.\n   [RFC5757]\
    \  Schmidt, T., Waehlisch, M., and G. Fairhurst, \"Multicast\n              Mobility\
    \ in Mobile IP Version 6 (MIPv6): Problem Statement\n              and Brief Survey\"\
    , RFC 5757, February 2010.\n   [RFC6219]  Li, X., Bao, C., Chen, M., Zhang, H.,\
    \ and J. Wu, \"The\n              China Education and Research Network (CERNET)\
    \ IVI\n              Translation Design and Deployment for the IPv4/IPv6\n   \
    \           Coexistence and Transition\", RFC 6219, May 2011.\n   [RFC7019]  Buford,\
    \ J. and M. Kolberg, \"Application-Layer Multicast\n              Extensions to\
    \ REsource LOcation And Discovery (RELOAD)\",\n              RFC 7019, September\
    \ 2013.\n   [SIP-RELOAD]\n              Jennings, C., Lowekamp, B., Rescorla,\
    \ E., Baset, S.,\n              Schulzrinne, H., and T. Schmidt, Ed., \"A SIP\
    \ Usage for\n              RELOAD\", Work in Progress, July 2013.\n"
- title: Appendix A.  C Signatures
  contents:
  - "Appendix A.  C Signatures\n   This section describes the C signatures of the\
    \ common multicast API\n   (Section 4).\n       int createMSocket(int* result,\
    \ size_t num_ifs,\n                         const uint32_t* ifs);\n       int\
    \ deleteMSocket(int s);\n       int join(int msock, const char* group_uri);\n\
    \       int leave(int msock, const char* group_uri);\n       int srcRegister(int\
    \ msock,\n                       const char* group_uri,\n                    \
    \   size_t num_ifs,\n                       uint32_t* ifs);\n       int srcDeregister(int\
    \ msock,\n                         const char* group_uri,\n                  \
    \       size_t num_ifs,\n                         uint32_t* ifs);\n       int\
    \ send(int msock,\n                const char* group_uri,\n                size_t\
    \ buf_len,\n                const void* buf);\n       int receive(int msock,\n\
    \                   const char* group_uri,\n                   size_t buf_len,\n\
    \                   void* buf);\n       int getInterfaces(int msock,\n       \
    \                  size_t* num_ifs,\n                         uint32_t** ifs);\n\
    \       int addInterface(int msock, uint32_t iface);\n       int delInterface(int\
    \ msock, uint32_t iface);\n       int setTTL(int msock, uint8_t value,\n     \
    \             size_t num_ifs, uint32_t* ifs);\n       int getTTL(int msock, uint8_t*\
    \ result);\n       int getAtomicMsgSize(int msock);\n       typedef struct {\n\
    \           char* group_uri; /* registered mcast group */\n           int type;\
    \ /* 0: listener state\n                        1: sender state\n            \
    \            2: sender and listener state */\n       }\n       GroupSet;\n   \
    \    int groupSet(uint32_t iface,\n                    size_t* num_groups,\n \
    \                   GroupSet** groups);\n       int neighborSet(uint32_t iface,\n\
    \                       const char* group_name,\n                       size_t*\
    \ num_neighbors,\n                       char** neighbor_uris);\n       int childrenSet(uint32_t\
    \ iface,\n                       const char* group_name,\n                   \
    \    size_t* num_children,\n                       char** children_uris);\n  \
    \     int parentSet(uint32_t iface,\n                     const char* group_name,\n\
    \                     size_t* num_parents,\n                     char** parents_uris);\n\
    \       int designatedHost(uint32_t iface,\n                          const char*\
    \ group_name);\n          typedef void (*MembershipEventCallback)\n          \
    \                           (int,          /* event type   */\n              \
    \                        uint32_t,     /* Interface id */\n                  \
    \                    const char*); /* group uri    */\n          int registerEventCallback(MembershipEventCallback\
    \ callback);\n          int enableEvents();\n          int disableEvents();\n\
    \       int getMaxMsgSize();\n"
- title: Appendix B.  Use Case for the API
  contents:
  - "Appendix B.  Use Case for the API\n   For the sake of readability, we demonstrate\
    \ development of\n   applications using the API based on a high-level Java-like\
    \ syntax; we\n   do not consider error handling.\n     -- Application above middleware:\n\
    \     //Initialize multicast socket;\n     //the middleware selects all available\
    \ Interfaces\n     MulticastSocket m = new MulticastSocket();\n     m.join(URI(\"\
    ham:ip:224.1.2.3:5000\"));\n     m.join(URI(\"ham:ip:[ff02:0:0:0:0:0:0:3]:6000\"\
    ));\n     m.join(URI(\"ham:sip:news@cnn.com\"));\n     -- Middleware:\n     join(URI\
    \ mcAddress) {\n       //Select Interfaces in use\n       for all this.interfaces\
    \ {\n         switch (interface.type) {\n           case \"ipv6\":\n         \
    \    //... map logical ID to routing address\n             Inet6Address rtAddressIPv6\
    \ = new Inet6Address();\n             mapNametoAddress(mcAddress,rtAddressIPv6);\n\
    \             interface.join(rtAddressIPv6);\n           case \"ipv4\":\n    \
    \         //... map logical ID to routing address\n             Inet4Address rtAddressIPv4\
    \ = new Inet4Address();\n             mapNametoAddress(mcAddress,rtAddressIPv4);\n\
    \             interface.join(rtAddressIPv4);\n           case \"sip-session\"\
    :\n             //... map logical ID to routing address\n             SIPAddress\
    \ rtAddressSIP = new SIPAddress();\n             mapNametoAddress(mcAddress,rtAddressSIP);\n\
    \             interface.join(rtAddressSIP);\n           case \"dht\":\n      \
    \       //... map logical ID to routing address\n             DHTAddress rtAddressDHT\
    \ = new DHTAddress();\n             mapNametoAddress(mcAddress,rtAddressDHT);\n\
    \             interface.join(rtAddressDHT);\n            //...\n         }\n \
    \      }\n     }\n"
- title: Appendix C.  Deployment Use Cases for Hybrid Multicast
  contents:
  - "Appendix C.  Deployment Use Cases for Hybrid Multicast\n   This section describes\
    \ the application of the defined API to\n   implement an IMG.\n"
- title: C.1.  DVMRP
  contents:
  - "C.1.  DVMRP\n   The following procedure describes a transparent mapping of a\n\
    \   DVMRP-based any-source multicast service to another many-to-many\n   multicast\
    \ technology, e.g., an overlay.\n   An arbitrary Distance Vector Multicast Routing\
    \ Protocol (DVMRP)\n   [RFC1075] router will not be informed of new receivers\
    \ but will learn\n   about new sources immediately.  The concept of DVMRP does\
    \ not provide\n   any central multicast instance.  Thus, the IMG can be placed\
    \ anywhere\n   inside the multicast region, but the IMG requires a DVMRP neighbor\n\
    \   connectivity.  Thus, the group communication stack used by the IMG is\n  \
    \ enhanced by a DVMRP implementation.  New sources in the underlay will\n   be\
    \ advertised based on the DVMRP flooding mechanism and received by\n   the IMG.\
    \  Based on this, the event \"new_source_event\" is created and\n   passed to\
    \ the application.  The relay agent initiates a corresponding\n   join in the\
    \ native network and forwards the received source data\n   towards the overlay\
    \ routing protocol.  Depending on the group states,\n   the data will be distributed\
    \ to overlay peers.\n   DVMRP establishes source-specific multicast trees.  Therefore,\
    \ a\n   graft message is only visible to DVMRP routers on the path from the\n\
    \   new receiver subnet to the source, but in general not to an IMG.  To\n   overcome\
    \ this problem, data of multicast senders in the overlay may\n   become noticeable\
    \ via the Source Register call, as well as by an IMG\n   that initiates an all-group\
    \ join in the overlay using the namespace\n   extension of the API.  Each IMG\
    \ is initially required to forward the\n   data received in the overlay to the\
    \ underlay, independent of native\n   multicast receivers.  Subsequent prunes\
    \ may limit unwanted data\n   distribution thereafter.\n"
- title: C.2.  PIM-SM
  contents:
  - "C.2.  PIM-SM\n   The following procedure describes a transparent mapping of a\n\
    \   PIM-SM-based any-source multicast service to another many-to-many\n   multicast\
    \ technology, e.g., an overlay.\n   The Protocol Independent Multicast - Sparse\
    \ Mode (PIM-SM) [RFC4601]\n   establishes rendezvous points (RPs).  These entities\
    \ receive listener\n   subscriptions and source registering of a domain.  For\
    \ a continuous\n   update, an IMG has to be co-located with an RP.  Whenever PIM\n\
    \   register messages are received, the IMG must signal internally a new\n   multicast\
    \ source using the event \"new_source_event\".  Subsequently,\n   the IMG joins\
    \ the group and a shared tree between the RP and the\n   sources will be established;\
    \ this shared tree may change to a source-\n   specific tree after PIM switches\
    \ to phase three.  Source traffic will\n   be forwarded to the RP based on the\
    \ IMG join, even if there are no\n   further receivers in the native Multicast\
    \ Domain.  Designated routers\n   of a PIM domain send receiver subscriptions\
    \ towards the PIM-SM RP.\n   The reception of such messages initiates the event\
    \ \"join_event\" at\n   the IMG, which initiates a join towards the overlay routing\
    \ protocol.\n   Overlay multicast data arriving at the IMG will then be transparently\n\
    \   forwarded in the underlay network and distributed through the RP\n   instance.\n"
- title: C.3.  PIM-SSM
  contents:
  - "C.3.  PIM-SSM\n   The following procedure describes a transparent mapping of\
    \ a\n   PIM-SSM-based source-specific multicast service to another\n   one-to-many\
    \ multicast technology, e.g., an overlay.\n   PIM Source-Specific Multicast (PIM-SSM)\
    \ is defined as part of PIM-SM\n   and admits source-specific joins (S,G) according\
    \ to the source-\n   specific host group model [RFC4604].  A multicast distribution\
    \ tree\n   can be established without the assistance of a rendezvous point.\n\
    \   Sources are not advertised within a PIM-SSM domain.  Consequently, an\n  \
    \ IMG cannot anticipate the local join inside a sender domain and\n   deliver\
    \ a priori the multicast data to the overlay instance.  If an\n   IMG of a receiver\
    \ domain initiates a group subscription via the\n   overlay routing protocol,\
    \ relaying multicast data fails, as data is\n   not available at the overlay instance.\
    \  The IMG instance of the\n   receiver domain thus has to locate the IMG instance\
    \ of the source\n   domain to trigger the corresponding join.  In agreement with\
    \ the\n   objectives of PIM-SSM, the signaling should not be flooded in the\n\
    \   underlay and overlay.\n   A solution can be to intercept the subscription\
    \ at both source sites\n   and receiver sites: To monitor multicast receiver subscriptions\n\
    \   (\"join_event\" or \"leave_event\") in the underlay, the IMG is placed on\n\
    \   the path towards the source, e.g., at a domain border router.  This\n   router\
    \ intercepts join messages and extracts the unicast source\n   address S, initializing\
    \ an IMG-specific join to S via regular\n   unicast.  Multicast data arriving\
    \ at the IMG of the sender domain can\n   be distributed via the overlay.  Discovering\
    \ the IMG of a multicast\n   sender domain may be implemented analogously to Automatic\
    \ Multicast\n   Tunneling [AMT] by anycast.  Consequently, the source address\
    \ S of\n   the group (S,G) should be built based on an anycast prefix.  The\n\
    \   corresponding IMG anycast address for a source domain is then derived\n  \
    \ from the prefix of S.\n"
- title: C.4.  BIDIR-PIM
  contents:
  - "C.4.  BIDIR-PIM\n   The following procedure describes a transparent mapping of\
    \ a\n   BIDIR-PIM-based any-source multicast service to another many-to-many\n\
    \   multicast technology, e.g., an overlay.\n   Bidirectional PIM [RFC5015] is\
    \ a variant of PIM-SM.  In contrast to\n   PIM-SM, the protocol pre-establishes\
    \ bidirectional shared trees per\n   group, connecting multicast sources and receivers.\
    \  The rendezvous\n   points are virtualized in BIDIR-PIM as an address to identify\
    \ on-tree\n   directions (up and down).  Routers with the best link towards the\n\
    \   (virtualized) rendezvous point address are selected as designated\n   forwarders\
    \ for a link-local domain and represent the actual\n   distribution tree.  The\
    \ IMG is to be placed at the RP link, where the\n   rendezvous point address is\
    \ located.  As source data in either case\n   will be transmitted to the RP link,\
    \ the BIDIR-PIM instance of the IMG\n   receives the data and can internally signal\
    \ new senders towards the\n   stack via the \"new_source_event\".  The first receiver\
    \ subscription\n   for a new group within a BIDIR-PIM domain needs to be transmitted\
    \ to\n   the RP to establish the first branching point.  Using the\n   \"join_event\"\
    , an IMG will thereby be informed of group requests from\n   its domain, which\
    \ are then delegated to the overlay.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Matthias Waehlisch\n   link-lab & FU Berlin\n   Hoenower\
    \ Str. 35\n   Berlin  10318\n   Germany\n   EMail: mw@link-lab.net\n   URI:  \
    \ http://www.inf.fu-berlin.de/~waehl\n   Thomas C. Schmidt\n   HAW Hamburg\n \
    \  Berliner Tor 7\n   Hamburg  20099\n   Germany\n   EMail: schmidt@informatik.haw-hamburg.de\n\
    \   URI:   http://inet.cpt.haw-hamburg.de/members/schmidt\n   Stig Venaas\n  \
    \ Cisco Systems\n   Tasman Drive\n   San Jose, CA  95134\n   USA\n   EMail: stig@cisco.com\n"
