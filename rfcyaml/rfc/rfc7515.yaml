- contents:
  - '                        JSON Web Signature (JWS)

    '
  title: __initial_text__
- contents:
  - "Abstract\n   JSON Web Signature (JWS) represents content secured with digital\n
    \  signatures or Message Authentication Codes (MACs) using JSON-based\n   data
    structures.  Cryptographic algorithms and identifiers for use\n   with this specification
    are described in the separate JSON Web\n   Algorithms (JWA) specification and
    an IANA registry defined by that\n   specification.  Related encryption capabilities
    are described in the\n   separate JSON Web Encryption (JWE) specification.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7515.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2015 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................4\n
    \     1.1. Notational Conventions .....................................4\n   2.
    Terminology .....................................................5\n   3. JSON
    Web Signature (JWS) Overview ...............................7\n      3.1. JWS
    Compact Serialization Overview .........................7\n      3.2. JWS JSON
    Serialization Overview ............................8\n      3.3. Example JWS ................................................8\n
    \  4. JOSE Header .....................................................9\n      4.1.
    Registered Header Parameter Names .........................10\n           4.1.1.
    \"alg\" (Algorithm) Header Parameter .................10\n           4.1.2. \"jku\"
    (JWK Set URL) Header Parameter ...............10\n           4.1.3. \"jwk\" (JSON
    Web Key) Header Parameter ..............11\n           4.1.4. \"kid\" (Key ID)
    Header Parameter ....................11\n           4.1.5. \"x5u\" (X.509 URL)
    Header Parameter .................11\n           4.1.6. \"x5c\" (X.509 Certificate
    Chain) Header Parameter ...11\n           4.1.7. \"x5t\" (X.509 Certificate SHA-1
    Thumbprint)\n                  Header Parameter ...................................12\n
    \          4.1.8. \"x5t#S256\" (X.509 Certificate SHA-256\n                  Thumbprint)
    Header Parameter .......................12\n           4.1.9. \"typ\" (Type) Header
    Parameter ......................12\n           4.1.10. \"cty\" (Content Type)
    Header Parameter .............13\n           4.1.11. \"crit\" (Critical) Header
    Parameter ................14\n      4.2. Public Header Parameter Names .............................14\n
    \     4.3. Private Header Parameter Names ............................14\n   5.
    Producing and Consuming JWSs ...................................15\n      5.1.
    Message Signature or MAC Computation ......................15\n      5.2. Message
    Signature or MAC Validation .......................16\n      5.3. String Comparison
    Rules ...................................17\n   6. Key Identification .............................................18\n
    \  7. Serializations .................................................19\n      7.1.
    JWS Compact Serialization .................................19\n      7.2. JWS
    JSON Serialization ....................................19\n           7.2.1. General
    JWS JSON Serialization Syntax ..............20\n           7.2.2. Flattened JWS
    JSON Serialization Syntax ............21\n   8. TLS Requirements ...............................................22\n
    \  9. IANA Considerations ............................................22\n      9.1.
    JSON Web Signature and Encryption Header\n           Parameters Registry .......................................23\n
    \          9.1.1. Registration Template ..............................23\n           9.1.2.
    Initial Registry Contents ..........................24\n      9.2. Media Type
    Registration ...................................26\n           9.2.1. Registry
    Contents ..................................26\n   10. Security Considerations
    .......................................27\n      10.1. Key Entropy and Random
    Values ............................27\n      10.2. Key Protection ...........................................28\n
    \     10.3. Key Origin Authentication ................................28\n      10.4.
    Cryptographic Agility ....................................28\n      10.5. Differences
    between Digital Signatures and MACs ..........28\n      10.6. Algorithm Validation
    .....................................29\n      10.7. Algorithm Protection .....................................29\n
    \     10.8. Chosen Plaintext Attacks .................................30\n      10.9.
    Timing Attacks ...........................................30\n      10.10. Replay
    Protection .......................................30\n      10.11. SHA-1 Certificate
    Thumbprints ...........................30\n      10.12. JSON Security Considerations
    ............................31\n      10.13. Unicode Comparison Security Considerations
    ..............31\n   11. References ....................................................32\n
    \     11.1. Normative References .....................................32\n      11.2.
    Informative References ...................................34\n   Appendix A.  JWS
    Examples .........................................36\n     A.1.  Example JWS Using
    HMAC SHA-256 ............................36\n       A.1.1.  Encoding ..............................................36\n
    \      A.1.2.  Validating ............................................38\n     A.2.
    \ Example JWS Using RSASSA-PKCS1-v1_5 SHA-256 ...............38\n       A.2.1.
    \ Encoding ..............................................38\n       A.2.2.  Validating
    ............................................42\n     A.3.  Example JWS Using ECDSA
    P-256 SHA-256 .....................42\n       A.3.1.  Encoding ..............................................42\n
    \      A.3.2.  Validating ............................................44\n     A.4.
    \ Example JWS Using ECDSA P-521 SHA-512 .....................45\n       A.4.1.
    \ Encoding ..............................................45\n       A.4.2.  Validating
    ............................................47\n     A.5.  Example Unsecured JWS
    .....................................47\n     A.6.  Example JWS Using General
    JWS JSON Serialization ..........48\n       A.6.1.  JWS Per-Signature Protected
    Headers ...................48\n       A.6.2.  JWS Per-Signature Unprotected Headers
    .................49\n       A.6.3.  Complete JOSE Header Values ...........................49\n
    \      A.6.4.  Complete JWS JSON Serialization Representation ........50\n     A.7.
    \ Example JWS Using Flattened JWS JSON Serialization ........51\n   Appendix B.
    \ \"x5c\" (X.509 Certificate Chain) Example ..............52\n   Appendix C.  Notes
    on Implementing base64url Encoding without\n                Padding ..............................................54\n
    \  Appendix D.  Notes on Key Selection ...............................55\n   Appendix
    E.  Negative Test Case for \"crit\" Header Parameter .......57\n   Appendix F.
    \ Detached Content .....................................57\n   Acknowledgements
    ..................................................58\n   Authors' Addresses ................................................58\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   JSON Web Signature (JWS) represents content secured with
    digital\n   signatures or Message Authentication Codes (MACs) using JSON-based\n
    \  [RFC7159] data structures.  The JWS cryptographic mechanisms provide\n   integrity
    protection for an arbitrary sequence of octets.  See\n   Section 10.5 for a discussion
    on the differences between digital\n   signatures and MACs.\n   Two closely related
    serializations for JWSs are defined.  The JWS\n   Compact Serialization is a compact,
    URL-safe representation intended\n   for space-constrained environments such as
    HTTP Authorization headers\n   and URI query parameters.  The JWS JSON Serialization
    represents JWSs\n   as JSON objects and enables multiple signatures and/or MACs
    to be\n   applied to the same content.  Both share the same cryptographic\n   underpinnings.\n
    \  Cryptographic algorithms and identifiers for use with this\n   specification
    are described in the separate JSON Web Algorithms (JWA)\n   [JWA] specification
    and an IANA registry defined by that\n   specification.  Related encryption capabilities
    are described in the\n   separate JSON Web Encryption (JWE) [JWE] specification.\n
    \  Names defined by this specification are short because a core goal is\n   for
    the resulting representations to be compact.\n"
  - contents:
    - "1.1.  Notational Conventions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT
      RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted
      as described in\n   \"Key words for use in RFCs to Indicate Requirement Levels\"
      [RFC2119].\n   The interpretation should only be applied when the terms appear
      in\n   all capital letters.\n   BASE64URL(OCTETS) denotes the base64url encoding
      of OCTETS, per\n   Section 2.\n   UTF8(STRING) denotes the octets of the UTF-8
      [RFC3629] representation\n   of STRING, where STRING is a sequence of zero or
      more Unicode\n   [UNICODE] characters.\n   ASCII(STRING) denotes the octets
      of the ASCII [RFC20] representation\n   of STRING, where STRING is a sequence
      of zero or more ASCII\n   characters.\n   The concatenation of two values A
      and B is denoted as A || B.\n"
    title: 1.1.  Notational Conventions
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   These terms are defined by this specification:\n   JSON Web
    Signature (JWS)\n      A data structure representing a digitally signed or MACed
    message.\n   JOSE Header\n      JSON object containing the parameters describing
    the cryptographic\n      operations and parameters employed.  The JOSE (JSON Object
    Signing\n      and Encryption) Header is comprised of a set of Header Parameters.\n
    \  JWS Payload\n      The sequence of octets to be secured -- a.k.a. the message.
    \ The\n      payload can contain an arbitrary sequence of octets.\n   JWS Signature\n
    \     Digital signature or MAC over the JWS Protected Header and the JWS\n      Payload.\n
    \  Header Parameter\n      A name/value pair that is member of the JOSE Header.\n
    \  JWS Protected Header\n      JSON object that contains the Header Parameters
    that are integrity\n      protected by the JWS Signature digital signature or
    MAC operation.\n      For the JWS Compact Serialization, this comprises the entire
    JOSE\n      Header.  For the JWS JSON Serialization, this is one component of\n
    \     the JOSE Header.\n   JWS Unprotected Header\n      JSON object that contains
    the Header Parameters that are not\n      integrity protected.  This can only
    be present when using the JWS\n      JSON Serialization.\n   Base64url Encoding\n
    \     Base64 encoding using the URL- and filename-safe character set\n      defined
    in Section 5 of RFC 4648 [RFC4648], with all trailing '='\n      characters omitted
    (as permitted by Section 3.2) and without the\n      inclusion of any line breaks,
    whitespace, or other additional\n      characters.  Note that the base64url encoding
    of the empty octet\n      sequence is the empty string.  (See Appendix C for notes
    on\n      implementing base64url encoding without padding.)\n   JWS Signing Input\n
    \     The input to the digital signature or MAC computation.  Its value\n      is
    ASCII(BASE64URL(UTF8(JWS Protected Header)) || '.' ||\n      BASE64URL(JWS Payload)).\n
    \  JWS Compact Serialization\n      A representation of the JWS as a compact,
    URL-safe string.\n   JWS JSON Serialization\n      A representation of the JWS
    as a JSON object.  Unlike the JWS\n      Compact Serialization, the JWS JSON Serialization
    enables multiple\n      digital signatures and/or MACs to be applied to the same
    content.\n      This representation is neither optimized for compactness nor URL-\n
    \     safe.\n   Unsecured JWS\n      A JWS that provides no integrity protection.
    \ Unsecured JWSs use\n      the \"alg\" value \"none\".\n   Collision-Resistant
    Name\n      A name in a namespace that enables names to be allocated in a\n      manner
    such that they are highly unlikely to collide with other\n      names.  Examples
    of collision-resistant namespaces include: Domain\n      Names, Object Identifiers
    (OIDs) as defined in the ITU-T X.660 and\n      X.670 Recommendation series, and
    Universally Unique IDentifiers\n      (UUIDs) [RFC4122].  When using an administratively
    delegated\n      namespace, the definer of a name needs to take reasonable\n      precautions
    to ensure they are in control of the portion of the\n      namespace they use
    to define the name.\n   StringOrURI\n      A JSON string value, with the additional
    requirement that while\n      arbitrary string values MAY be used, any value containing
    a \":\"\n      character MUST be a URI [RFC3986].  StringOrURI values are\n      compared
    as case-sensitive strings with no transformations or\n      canonicalizations
    applied.\n   The terms \"JSON Web Encryption (JWE)\", \"JWE Compact Serialization\",\n
    \  and \"JWE JSON Serialization\" are defined by the JWE specification\n   [JWE].\n
    \  The terms \"Digital Signature\" and \"Message Authentication Code (MAC)\"\n
    \  are defined by the \"Internet Security Glossary, Version 2\" [RFC4949].\n"
  title: 2.  Terminology
- contents:
  - "3.  JSON Web Signature (JWS) Overview\n   JWS represents digitally signed or
    MACed content using JSON data\n   structures and base64url encoding.  These JSON
    data structures MAY\n   contain whitespace and/or line breaks before or after
    any JSON values\n   or structural characters, in accordance with Section 2 of
    RFC 7159\n   [RFC7159].  A JWS represents these logical values (each of which
    is\n   defined in Section 2):\n   o  JOSE Header\n   o  JWS Payload\n   o  JWS
    Signature\n   For a JWS, the JOSE Header members are the union of the members
    of\n   these values (each of which is defined in Section 2):\n   o  JWS Protected
    Header\n   o  JWS Unprotected Header\n   This document defines two serializations
    for JWSs: a compact, URL-\n   safe serialization called the JWS Compact Serialization
    and a JSON\n   serialization called the JWS JSON Serialization.  In both\n   serializations,
    the JWS Protected Header, JWS Payload, and JWS\n   Signature are base64url encoded,
    since JSON lacks a way to directly\n   represent arbitrary octet sequences.\n"
  - contents:
    - "3.1.  JWS Compact Serialization Overview\n   In the JWS Compact Serialization,
      no JWS Unprotected Header is used.\n   In this case, the JOSE Header and the
      JWS Protected Header are the\n   same.\n   In the JWS Compact Serialization,
      a JWS is represented as the\n   concatenation:\n      BASE64URL(UTF8(JWS Protected
      Header)) || '.' ||\n      BASE64URL(JWS Payload) || '.' ||\n      BASE64URL(JWS
      Signature)\n   See Section 7.1 for more information about the JWS Compact\n
      \  Serialization.\n"
    title: 3.1.  JWS Compact Serialization Overview
  - contents:
    - "3.2.  JWS JSON Serialization Overview\n   In the JWS JSON Serialization, one
      or both of the JWS Protected\n   Header and JWS Unprotected Header MUST be present.
      \ In this case, the\n   members of the JOSE Header are the union of the members
      of the JWS\n   Protected Header and the JWS Unprotected Header values that are\n
      \  present.\n   In the JWS JSON Serialization, a JWS is represented as a JSON
      object\n   containing some or all of these four members:\n   o  \"protected\",
      with the value BASE64URL(UTF8(JWS Protected Header))\n   o  \"header\", with
      the value JWS Unprotected Header\n   o  \"payload\", with the value BASE64URL(JWS
      Payload)\n   o  \"signature\", with the value BASE64URL(JWS Signature)\n   The
      three base64url-encoded result strings and the JWS Unprotected\n   Header value
      are represented as members within a JSON object.  The\n   inclusion of some
      of these values is OPTIONAL.  The JWS JSON\n   Serialization can also represent
      multiple signature and/or MAC\n   values, rather than just one.  See Section
      7.2 for more information\n   about the JWS JSON Serialization.\n"
    title: 3.2.  JWS JSON Serialization Overview
  - contents:
    - "3.3.  Example JWS\n   This section provides an example of a JWS.  Its computation
      is\n   described in more detail in Appendix A.1, including specifying the\n
      \  exact octet sequences representing the JSON values used and the key\n   value
      used.\n   The following example JWS Protected Header declares that the encoded\n
      \  object is a JSON Web Token [JWT] and the JWS Protected Header and the\n   JWS
      Payload are secured using the HMAC SHA-256 [RFC2104] [SHS]\n   algorithm:\n
      \    {\"typ\":\"JWT\",\n      \"alg\":\"HS256\"}\n   Encoding this JWS Protected
      Header as BASE64URL(UTF8(JWS Protected\n   Header)) gives this value:\n     eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9\n
      \  The UTF-8 representation of the following JSON object is used as the\n   JWS
      Payload.  (Note that the payload can be any content and need not\n   be a representation
      of a JSON object.)\n     {\"iss\":\"joe\",\n      \"exp\":1300819380,\n      \"http://example.com/is_root\":true}\n
      \  Encoding this JWS Payload as BASE64URL(JWS Payload) gives this value\n   (with
      line breaks for display purposes only):\n     eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt\n
      \    cGxlLmNvbS9pc19yb290Ijp0cnVlfQ\n   Computing the HMAC of the JWS Signing
      Input ASCII(BASE64URL(UTF8(JWS\n   Protected Header)) || '.' || BASE64URL(JWS
      Payload)) with the HMAC\n   SHA-256 algorithm using the key specified in Appendix
      A.1 and\n   base64url-encoding the result yields this BASE64URL(JWS Signature)\n
      \  value:\n     dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk\n   Concatenating
      these values in the order Header.Payload.Signature with\n   period ('.') characters
      between the parts yields this complete JWS\n   representation using the JWS
      Compact Serialization (with line breaks\n   for display purposes only):\n     eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9\n
      \    .\n     eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt\n
      \    cGxlLmNvbS9pc19yb290Ijp0cnVlfQ\n     .\n     dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk\n
      \  See Appendix A for additional examples, including examples using the\n   JWS
      JSON Serialization in Sections A.6 and A.7.\n"
    title: 3.3.  Example JWS
  title: 3.  JSON Web Signature (JWS) Overview
- contents:
  - "4.  JOSE Header\n   For a JWS, the members of the JSON object(s) representing
    the JOSE\n   Header describe the digital signature or MAC applied to the JWS\n
    \  Protected Header and the JWS Payload and optionally additional\n   properties
    of the JWS.  The Header Parameter names within the JOSE\n   Header MUST be unique;
    JWS parsers MUST either reject JWSs with\n   duplicate Header Parameter names
    or use a JSON parser that returns\n   only the lexically last duplicate member
    name, as specified in\n   Section 15.12 (\"The JSON Object\") of ECMAScript 5.1
    [ECMAScript].\n   Implementations are required to understand the specific Header\n
    \  Parameters defined by this specification that are designated as \"MUST\n   be
    understood\" and process them in the manner defined in this\n   specification.
    \ All other Header Parameters defined by this\n   specification that are not so
    designated MUST be ignored when not\n   understood.  Unless listed as a critical
    Header Parameter, per\n   Section 4.1.11, all Header Parameters not defined by
    this\n   specification MUST be ignored when not understood.\n   There are three
    classes of Header Parameter names: Registered Header\n   Parameter names, Public
    Header Parameter names, and Private Header\n   Parameter names.\n"
  - contents:
    - "4.1.  Registered Header Parameter Names\n   The following Header Parameter
      names for use in JWSs are registered\n   in the IANA \"JSON Web Signature and
      Encryption Header Parameters\"\n   registry established by Section 9.1, with
      meanings as defined in the\n   subsections below.\n   As indicated by the common
      registry, JWSs and JWEs share a common\n   Header Parameter space; when a parameter
      is used by both\n   specifications, its usage must be compatible between the\n
      \  specifications.\n"
    - contents:
      - "4.1.1.  \"alg\" (Algorithm) Header Parameter\n   The \"alg\" (algorithm)
        Header Parameter identifies the cryptographic\n   algorithm used to secure
        the JWS.  The JWS Signature value is not\n   valid if the \"alg\" value does
        not represent a supported algorithm or\n   if there is not a key for use with
        that algorithm associated with the\n   party that digitally signed or MACed
        the content.  \"alg\" values\n   should either be registered in the IANA \"JSON
        Web Signature and\n   Encryption Algorithms\" registry established by [JWA]
        or be a value\n   that contains a Collision-Resistant Name.  The \"alg\" value
        is a case-\n   sensitive ASCII string containing a StringOrURI value.  This
        Header\n   Parameter MUST be present and MUST be understood and processed
        by\n   implementations.\n   A list of defined \"alg\" values for this use
        can be found in the IANA\n   \"JSON Web Signature and Encryption Algorithms\"
        registry established\n   by [JWA]; the initial contents of this registry are
        the values\n   defined in Section 3.1 of [JWA].\n"
      title: 4.1.1.  "alg" (Algorithm) Header Parameter
    - contents:
      - "4.1.2.  \"jku\" (JWK Set URL) Header Parameter\n   The \"jku\" (JWK Set URL)
        Header Parameter is a URI [RFC3986] that\n   refers to a resource for a set
        of JSON-encoded public keys, one of\n   which corresponds to the key used
        to digitally sign the JWS.  The\n   keys MUST be encoded as a JWK Set [JWK].
        \ The protocol used to\n   acquire the resource MUST provide integrity protection;
        an HTTP GET\n   request to retrieve the JWK Set MUST use Transport Layer Security\n
        \  (TLS) [RFC2818] [RFC5246]; and the identity of the server MUST be\n   validated,
        as per Section 6 of RFC 6125 [RFC6125].  Also, see\n   Section 8 on TLS requirements.
        \ Use of this Header Parameter is\n   OPTIONAL.\n"
      title: 4.1.2.  "jku" (JWK Set URL) Header Parameter
    - contents:
      - "4.1.3.  \"jwk\" (JSON Web Key) Header Parameter\n   The \"jwk\" (JSON Web
        Key) Header Parameter is the public key that\n   corresponds to the key used
        to digitally sign the JWS.  This key is\n   represented as a JSON Web Key
        [JWK].  Use of this Header Parameter is\n   OPTIONAL.\n"
      title: 4.1.3.  "jwk" (JSON Web Key) Header Parameter
    - contents:
      - "4.1.4.  \"kid\" (Key ID) Header Parameter\n   The \"kid\" (key ID) Header
        Parameter is a hint indicating which key\n   was used to secure the JWS.  This
        parameter allows originators to\n   explicitly signal a change of key to recipients.
        \ The structure of\n   the \"kid\" value is unspecified.  Its value MUST be
        a case-sensitive\n   string.  Use of this Header Parameter is OPTIONAL.\n
        \  When used with a JWK, the \"kid\" value is used to match a JWK \"kid\"\n
        \  parameter value.\n"
      title: 4.1.4.  "kid" (Key ID) Header Parameter
    - contents:
      - "4.1.5.  \"x5u\" (X.509 URL) Header Parameter\n   The \"x5u\" (X.509 URL)
        Header Parameter is a URI [RFC3986] that refers\n   to a resource for the
        X.509 public key certificate or certificate\n   chain [RFC5280] corresponding
        to the key used to digitally sign the\n   JWS.  The identified resource MUST
        provide a representation of the\n   certificate or certificate chain that
        conforms to RFC 5280 [RFC5280]\n   in PEM-encoded form, with each certificate
        delimited as specified in\n   Section 6.1 of RFC 4945 [RFC4945].  The certificate
        containing the\n   public key corresponding to the key used to digitally sign
        the JWS\n   MUST be the first certificate.  This MAY be followed by additional\n
        \  certificates, with each subsequent certificate being the one used to\n
        \  certify the previous one.  The protocol used to acquire the resource\n
        \  MUST provide integrity protection; an HTTP GET request to retrieve\n   the
        certificate MUST use TLS [RFC2818] [RFC5246]; and the identity of\n   the
        server MUST be validated, as per Section 6 of RFC 6125 [RFC6125].\n   Also,
        see Section 8 on TLS requirements.  Use of this Header\n   Parameter is OPTIONAL.\n"
      title: 4.1.5.  "x5u" (X.509 URL) Header Parameter
    - contents:
      - "4.1.6.  \"x5c\" (X.509 Certificate Chain) Header Parameter\n   The \"x5c\"
        (X.509 certificate chain) Header Parameter contains the\n   X.509 public key
        certificate or certificate chain [RFC5280]\n   corresponding to the key used
        to digitally sign the JWS.  The\n   certificate or certificate chain is represented
        as a JSON array of\n   certificate value strings.  Each string in the array
        is a\n   base64-encoded (Section 4 of [RFC4648] -- not base64url-encoded)
        DER\n   [ITU.X690.2008] PKIX certificate value.  The certificate containing\n
        \  the public key corresponding to the key used to digitally sign the\n   JWS
        MUST be the first certificate.  This MAY be followed by\n   additional certificates,
        with each subsequent certificate being the\n   one used to certify the previous
        one.  The recipient MUST validate\n   the certificate chain according to RFC
        5280 [RFC5280] and consider\n   the certificate or certificate chain to be
        invalid if any validation\n   failure occurs.  Use of this Header Parameter
        is OPTIONAL.\n   See Appendix B for an example \"x5c\" value.\n"
      title: 4.1.6.  "x5c" (X.509 Certificate Chain) Header Parameter
    - contents:
      - "4.1.7.  \"x5t\" (X.509 Certificate SHA-1 Thumbprint) Header Parameter\n   The
        \"x5t\" (X.509 certificate SHA-1 thumbprint) Header Parameter is a\n   base64url-encoded
        SHA-1 thumbprint (a.k.a. digest) of the DER\n   encoding of the X.509 certificate
        [RFC5280] corresponding to the key\n   used to digitally sign the JWS.  Note
        that certificate thumbprints\n   are also sometimes known as certificate fingerprints.
        \ Use of this\n   Header Parameter is OPTIONAL.\n"
      title: 4.1.7.  "x5t" (X.509 Certificate SHA-1 Thumbprint) Header Parameter
    - contents:
      - "4.1.8.  \"x5t#S256\" (X.509 Certificate SHA-256 Thumbprint) Header\n        Parameter\n
        \  The \"x5t#S256\" (X.509 certificate SHA-256 thumbprint) Header\n   Parameter
        is a base64url-encoded SHA-256 thumbprint (a.k.a. digest)\n   of the DER encoding
        of the X.509 certificate [RFC5280] corresponding\n   to the key used to digitally
        sign the JWS.  Note that certificate\n   thumbprints are also sometimes known
        as certificate fingerprints.\n   Use of this Header Parameter is OPTIONAL.\n"
      title: 4.1.8.  "x5t#S256" (X.509 Certificate SHA-256 Thumbprint) Header
    - contents:
      - "4.1.9.  \"typ\" (Type) Header Parameter\n   The \"typ\" (type) Header Parameter
        is used by JWS applications to\n   declare the media type [IANA.MediaTypes]
        of this complete JWS.  This\n   is intended for use by the application when
        more than one kind of\n   object could be present in an application data structure
        that can\n   contain a JWS; the application can use this value to disambiguate\n
        \  among the different kinds of objects that might be present.  It will\n
        \  typically not be used by applications when the kind of object is\n   already
        known.  This parameter is ignored by JWS implementations; any\n   processing
        of this parameter is performed by the JWS application.\n   Use of this Header
        Parameter is OPTIONAL.\n   Per RFC 2045 [RFC2045], all media type values,
        subtype values, and\n   parameter names are case insensitive.  However, parameter
        values are\n   case sensitive unless otherwise specified for the specific
        parameter.\n   To keep messages compact in common situations, it is RECOMMENDED
        that\n   producers omit an \"application/\" prefix of a media type value in
        a\n   \"typ\" Header Parameter when no other '/' appears in the media type\n
        \  value.  A recipient using the media type value MUST treat it as if\n   \"application/\"
        were prepended to any \"typ\" value not containing a\n   '/'.  For instance,
        a \"typ\" value of \"example\" SHOULD be used to\n   represent the \"application/example\"
        media type, whereas the media\n   type \"application/example;part=\"1/2\"\"
        cannot be shortened to\n   \"example;part=\"1/2\"\".\n   The \"typ\" value
        \"JOSE\" can be used by applications to indicate that\n   this object is a
        JWS or JWE using the JWS Compact Serialization or\n   the JWE Compact Serialization.
        \ The \"typ\" value \"JOSE+JSON\" can be\n   used by applications to indicate
        that this object is a JWS or JWE\n   using the JWS JSON Serialization or the
        JWE JSON Serialization.\n   Other type values can also be used by applications.\n"
      title: 4.1.9.  "typ" (Type) Header Parameter
    - contents:
      - "4.1.10.  \"cty\" (Content Type) Header Parameter\n   The \"cty\" (content
        type) Header Parameter is used by JWS applications\n   to declare the media
        type [IANA.MediaTypes] of the secured content\n   (the payload).  This is
        intended for use by the application when more\n   than one kind of object
        could be present in the JWS Payload; the\n   application can use this value
        to disambiguate among the different\n   kinds of objects that might be present.
        \ It will typically not be\n   used by applications when the kind of object
        is already known.  This\n   parameter is ignored by JWS implementations; any
        processing of this\n   parameter is performed by the JWS application.  Use
        of this Header\n   Parameter is OPTIONAL.\n   Per RFC 2045 [RFC2045], all
        media type values, subtype values, and\n   parameter names are case insensitive.
        \ However, parameter values are\n   case sensitive unless otherwise specified
        for the specific parameter.\n   To keep messages compact in common situations,
        it is RECOMMENDED that\n   producers omit an \"application/\" prefix of a
        media type value in a\n   \"cty\" Header Parameter when no other '/' appears
        in the media type\n   value.  A recipient using the media type value MUST
        treat it as if\n   \"application/\" were prepended to any \"cty\" value not
        containing a\n   '/'.  For instance, a \"cty\" value of \"example\" SHOULD
        be used to\n   represent the \"application/example\" media type, whereas the
        media\n   type \"application/example;part=\"1/2\"\" cannot be shortened to\n
        \  \"example;part=\"1/2\"\".\n"
      title: 4.1.10.  "cty" (Content Type) Header Parameter
    - contents:
      - "4.1.11.  \"crit\" (Critical) Header Parameter\n   The \"crit\" (critical)
        Header Parameter indicates that extensions to\n   this specification and/or
        [JWA] are being used that MUST be\n   understood and processed.  Its value
        is an array listing the Header\n   Parameter names present in the JOSE Header
        that use those extensions.\n   If any of the listed extension Header Parameters
        are not understood\n   and supported by the recipient, then the JWS is invalid.
        \ Producers\n   MUST NOT include Header Parameter names defined by this specification\n
        \  or [JWA] for use with JWS, duplicate names, or names that do not\n   occur
        as Header Parameter names within the JOSE Header in the \"crit\"\n   list.
        \ Producers MUST NOT use the empty list \"[]\" as the \"crit\"\n   value.
        \ Recipients MAY consider the JWS to be invalid if the critical\n   list contains
        any Header Parameter names defined by this\n   specification or [JWA] for
        use with JWS or if any other constraints\n   on its use are violated.  When
        used, this Header Parameter MUST be\n   integrity protected; therefore, it
        MUST occur only within the JWS\n   Protected Header.  Use of this Header Parameter
        is OPTIONAL.  This\n   Header Parameter MUST be understood and processed by
        implementations.\n   An example use, along with a hypothetical \"exp\" (expiration
        time)\n   field is:\n     {\"alg\":\"ES256\",\n      \"crit\":[\"exp\"],\n
        \     \"exp\":1363284000\n     }\n"
      title: 4.1.11.  "crit" (Critical) Header Parameter
    title: 4.1.  Registered Header Parameter Names
  - contents:
    - "4.2.  Public Header Parameter Names\n   Additional Header Parameter names can
      be defined by those using JWSs.\n   However, in order to prevent collisions,
      any new Header Parameter\n   name should either be registered in the IANA \"JSON
      Web Signature and\n   Encryption Header Parameters\" registry established by
      Section 9.1 or\n   be a Public Name (a value that contains a Collision-Resistant
      Name).\n   In each case, the definer of the name or value needs to take\n   reasonable
      precautions to make sure they are in control of the part\n   of the namespace
      they use to define the Header Parameter name.\n   New Header Parameters should
      be introduced sparingly, as they can\n   result in non-interoperable JWSs.\n"
    title: 4.2.  Public Header Parameter Names
  - contents:
    - "4.3.  Private Header Parameter Names\n   A producer and consumer of a JWS may
      agree to use Header Parameter\n   names that are Private Names (names that are
      not Registered Header\n   Parameter names (Section 4.1)) or Public Header Parameter
      names\n   (Section 4.2).  Unlike Public Header Parameter names, Private Header\n
      \  Parameter names are subject to collision and should be used with\n   caution.\n"
    title: 4.3.  Private Header Parameter Names
  title: 4.  JOSE Header
- contents:
  - '5.  Producing and Consuming JWSs

    '
  - contents:
    - "5.1.  Message Signature or MAC Computation\n   To create a JWS, the following
      steps are performed.  The order of the\n   steps is not significant in cases
      where there are no dependencies\n   between the inputs and outputs of the steps.\n
      \  1.  Create the content to be used as the JWS Payload.\n   2.  Compute the
      encoded payload value BASE64URL(JWS Payload).\n   3.  Create the JSON object(s)
      containing the desired set of Header\n       Parameters, which together comprise
      the JOSE Header (the JWS\n       Protected Header and/or the JWS Unprotected
      Header).\n   4.  Compute the encoded header value BASE64URL(UTF8(JWS Protected\n
      \      Header)).  If the JWS Protected Header is not present (which can\n       only
      happen when using the JWS JSON Serialization and no\n       \"protected\" member
      is present), let this value be the empty\n       string.\n   5.  Compute the
      JWS Signature in the manner defined for the\n       particular algorithm being
      used over the JWS Signing Input\n       ASCII(BASE64URL(UTF8(JWS Protected Header))
      || '.' ||\n       BASE64URL(JWS Payload)).  The \"alg\" (algorithm) Header Parameter\n
      \      MUST be present in the JOSE Header, with the algorithm value\n       accurately
      representing the algorithm used to construct the JWS\n       Signature.\n   6.
      \ Compute the encoded signature value BASE64URL(JWS Signature).\n   7.  If the
      JWS JSON Serialization is being used, repeat this process\n       (steps 3-6)
      for each digital signature or MAC operation being\n       performed.\n   8.
      \ Create the desired serialized output.  The JWS Compact\n       Serialization
      of this result is BASE64URL(UTF8(JWS Protected\n       Header)) || '.' || BASE64URL(JWS
      Payload) || '.' || BASE64URL(JWS\n       Signature).  The JWS JSON Serialization
      is described in\n       Section 7.2.\n"
    title: 5.1.  Message Signature or MAC Computation
  - contents:
    - "5.2.  Message Signature or MAC Validation\n   When validating a JWS, the following
      steps are performed.  The order\n   of the steps is not significant in cases
      where there are no\n   dependencies between the inputs and outputs of the steps.
      \ If any of\n   the listed steps fails, then the signature or MAC cannot be\n
      \  validated.\n   When there are multiple JWS Signature values, it is an application\n
      \  decision which of the JWS Signature values must successfully validate\n   for
      the JWS to be accepted.  In some cases, all must successfully\n   validate,
      or the JWS will be considered invalid.  In other cases,\n   only a specific
      JWS Signature value needs to be successfully\n   validated.  However, in all
      cases, at least one JWS Signature value\n   MUST successfully validate, or the
      JWS MUST be considered invalid.\n   1.  Parse the JWS representation to extract
      the serialized values for\n       the components of the JWS.  When using the
      JWS Compact\n       Serialization, these components are the base64url-encoded\n
      \      representations of the JWS Protected Header, the JWS Payload, and\n       the
      JWS Signature, and when using the JWS JSON Serialization,\n       these components
      also include the unencoded JWS Unprotected\n       Header value.  When using
      the JWS Compact Serialization, the JWS\n       Protected Header, the JWS Payload,
      and the JWS Signature are\n       represented as base64url-encoded values in
      that order, with each\n       value being separated from the next by a single
      period ('.')\n       character, resulting in exactly two delimiting period characters\n
      \      being used.  The JWS JSON Serialization is described in\n       Section
      7.2.\n   2.  Base64url-decode the encoded representation of the JWS Protected\n
      \      Header, following the restriction that no line breaks,\n       whitespace,
      or other additional characters have been used.\n   3.  Verify that the resulting
      octet sequence is a UTF-8-encoded\n       representation of a completely valid
      JSON object conforming to\n       RFC 7159 [RFC7159]; let the JWS Protected
      Header be this JSON\n       object.\n   4.  If using the JWS Compact Serialization,
      let the JOSE Header be\n       the JWS Protected Header.  Otherwise, when using
      the JWS JSON\n       Serialization, let the JOSE Header be the union of the
      members of\n       the corresponding JWS Protected Header and JWS Unprotected\n
      \      Header, all of which must be completely valid JSON objects.\n       During
      this step, verify that the resulting JOSE Header does not\n       contain duplicate
      Header Parameter names.  When using the JWS\n       JSON Serialization, this
      restriction includes that the same\n       Header Parameter name also MUST NOT
      occur in distinct JSON object\n       values that together comprise the JOSE
      Header.\n   5.  Verify that the implementation understands and can process all\n
      \      fields that it is required to support, whether required by this\n       specification,
      by the algorithm being used, or by the \"crit\"\n       Header Parameter value,
      and that the values of those parameters\n       are also understood and supported.\n
      \  6.  Base64url-decode the encoded representation of the JWS Payload,\n       following
      the restriction that no line breaks, whitespace, or\n       other additional
      characters have been used.\n   7.  Base64url-decode the encoded representation
      of the JWS Signature,\n       following the restriction that no line breaks,
      whitespace, or\n       other additional characters have been used.\n   8.  Validate
      the JWS Signature against the JWS Signing Input\n       ASCII(BASE64URL(UTF8(JWS
      Protected Header)) || '.' ||\n       BASE64URL(JWS Payload)) in the manner defined
      for the algorithm\n       being used, which MUST be accurately represented by
      the value of\n       the \"alg\" (algorithm) Header Parameter, which MUST be
      present.\n       See Section 10.6 for security considerations on algorithm\n
      \      validation.  Record whether the validation succeeded or not.\n   9.  If
      the JWS JSON Serialization is being used, repeat this process\n       (steps
      4-8) for each digital signature or MAC value contained in\n       the representation.\n
      \  10. If none of the validations in step 9 succeeded, then the JWS MUST\n       be
      considered invalid.  Otherwise, in the JWS JSON Serialization\n       case,
      return a result to the application indicating which of the\n       validations
      succeeded and failed.  In the JWS Compact\n       Serialization case, the result
      can simply indicate whether or not\n       the JWS was successfully validated.\n
      \  Finally, note that it is an application decision which algorithms may\n   be
      used in a given context.  Even if a JWS can be successfully\n   validated, unless
      the algorithm(s) used in the JWS are acceptable to\n   the application, it SHOULD
      consider the JWS to be invalid.\n"
    title: 5.2.  Message Signature or MAC Validation
  - contents:
    - "5.3.  String Comparison Rules\n   Processing a JWS inevitably requires comparing
      known strings to\n   members and values in JSON objects.  For example, in checking
      what\n   the algorithm is, the Unicode string \"alg\" will be checked against\n
      \  the member names in the JOSE Header to see if there is a matching\n   Header
      Parameter name.  The same process is then used to determine if\n   the value
      of the \"alg\" Header Parameter represents a supported\n   algorithm.\n   The
      JSON rules for doing member name comparison are described in\n   Section 8.3
      of RFC 7159 [RFC7159].  Since the only string comparison\n   operations that
      are performed are equality and inequality, the same\n   rules can be used for
      comparing both member names and member values\n   against known strings.\n   These
      comparison rules MUST be used for all JSON string comparisons\n   except in
      cases where the definition of the member explicitly calls\n   out that a different
      comparison rule is to be used for that member\n   value.  Only the \"typ\" and
      \"cty\" member values defined in this\n   specification do not use these comparison
      rules.\n   Some applications may include case-insensitive information in a case-\n
      \  sensitive value, such as including a DNS name as part of a \"kid\" (key\n
      \  ID) value.  In those cases, the application may need to define a\n   convention
      for the canonical case to use for representing the case-\n   insensitive portions,
      such as lowercasing them, if more than one\n   party might need to produce the
      same value so that they can be\n   compared.  (However, if all other parties
      consume whatever value the\n   producing party emitted verbatim without attempting
      to compare it to\n   an independently produced value, then the case used by
      the producer\n   will not matter.)\n   Also, see the JSON security considerations
      in Section 10.12 and the\n   Unicode security considerations in Section 10.13.\n"
    title: 5.3.  String Comparison Rules
  title: 5.  Producing and Consuming JWSs
- contents:
  - "6.  Key Identification\n   It is necessary for the recipient of a JWS to be able
    to determine\n   the key that was employed for the digital signature or MAC operation.\n
    \  The key employed can be identified using the Header Parameter methods\n   described
    in Section 4.1 or can be identified using methods that are\n   outside the scope
    of this specification.  Specifically, the Header\n   Parameters \"jku\", \"jwk\",
    \"kid\", \"x5u\", \"x5c\", \"x5t\", and \"x5t#S256\"\n   can be used to identify
    the key used.  These Header Parameters MUST\n   be integrity protected if the
    information that they convey is to be\n   utilized in a trust decision; however,
    if the only information used\n   in the trust decision is a key, these parameters
    need not be\n   integrity protected, since changing them in a way that causes
    a\n   different key to be used will cause the validation to fail.\n   The producer
    SHOULD include sufficient information in the Header\n   Parameters to identify
    the key used, unless the application uses\n   another means or convention to determine
    the key used.  Validation of\n   the signature or MAC fails when the algorithm
    used requires a key\n   (which is true of all algorithms except for \"none\")
    and the key used\n   cannot be determined.\n   The means of exchanging any shared
    symmetric keys used is outside the\n   scope of this specification.\n   Also,
    see Appendix D for notes on possible key selection algorithms.\n"
  title: 6.  Key Identification
- contents:
  - "7.  Serializations\n   JWSs use one of two serializations: the JWS Compact Serialization
    or\n   the JWS JSON Serialization.  Applications using this specification\n   need
    to specify what serialization and serialization features are\n   used for that
    application.  For instance, applications might specify\n   that only the JWS JSON
    Serialization is used, that only JWS JSON\n   Serialization support for a single
    signature or MAC value is used, or\n   that support for multiple signatures and/or
    MAC values is used.  JWS\n   implementations only need to implement the features
    needed for the\n   applications they are designed to support.\n"
  - contents:
    - "7.1.  JWS Compact Serialization\n   The JWS Compact Serialization represents
      digitally signed or MACed\n   content as a compact, URL-safe string.  This string
      is:\n      BASE64URL(UTF8(JWS Protected Header)) || '.' ||\n      BASE64URL(JWS
      Payload) || '.' ||\n      BASE64URL(JWS Signature)\n   Only one signature/MAC
      is supported by the JWS Compact Serialization\n   and it provides no syntax
      to represent a JWS Unprotected Header\n   value.\n"
    title: 7.1.  JWS Compact Serialization
  - contents:
    - "7.2.  JWS JSON Serialization\n   The JWS JSON Serialization represents digitally
      signed or MACed\n   content as a JSON object.  This representation is neither
      optimized\n   for compactness nor URL-safe.\n   Two closely related syntaxes
      are defined for the JWS JSON\n   Serialization: a fully general syntax, with
      which content can be\n   secured with more than one digital signature and/or
      MAC operation,\n   and a flattened syntax, which is optimized for the single
      digital\n   signature or MAC case.\n"
    - contents:
      - "7.2.1.  General JWS JSON Serialization Syntax\n   The following members are
        defined for use in top-level JSON objects\n   used for the fully general JWS
        JSON Serialization syntax:\n   payload\n      The \"payload\" member MUST
        be present and contain the value\n      BASE64URL(JWS Payload).\n   signatures\n
        \     The \"signatures\" member value MUST be an array of JSON objects.\n
        \     Each object represents a signature or MAC over the JWS Payload and\n
        \     the JWS Protected Header.\n   The following members are defined for
        use in the JSON objects that\n   are elements of the \"signatures\" array:\n
        \  protected\n      The \"protected\" member MUST be present and contain the
        value\n      BASE64URL(UTF8(JWS Protected Header)) when the JWS Protected\n
        \     Header value is non-empty; otherwise, it MUST be absent.  These\n      Header
        Parameter values are integrity protected.\n   header\n      The \"header\"
        member MUST be present and contain the value JWS\n      Unprotected Header
        when the JWS Unprotected Header value is non-\n      empty; otherwise, it
        MUST be absent.  This value is represented as\n      an unencoded JSON object,
        rather than as a string.  These Header\n      Parameter values are not integrity
        protected.\n   signature\n      The \"signature\" member MUST be present and
        contain the value\n      BASE64URL(JWS Signature).\n   At least one of the
        \"protected\" and \"header\" members MUST be present\n   for each signature/MAC
        computation so that an \"alg\" Header Parameter\n   value is conveyed.\n   Additional
        members can be present in both the JSON objects defined\n   above; if not
        understood by implementations encountering them, they\n   MUST be ignored.\n
        \  The Header Parameter values used when creating or validating\n   individual
        signature or MAC values are the union of the two sets of\n   Header Parameter
        values that may be present: (1) the JWS Protected\n   Header represented in
        the \"protected\" member of the signature/MAC's\n   array element, and (2)
        the JWS Unprotected Header in the \"header\"\n   member of the signature/MAC's
        array element.  The union of these sets\n   of Header Parameters comprises
        the JOSE Header.  The Header Parameter\n   names in the two locations MUST
        be disjoint.\n   Each JWS Signature value is computed using the parameters
        of the\n   corresponding JOSE Header value in the same manner as for the JWS\n
        \  Compact Serialization.  This has the desirable property that each JWS\n
        \  Signature value represented in the \"signatures\" array is identical to\n
        \  the value that would have been computed for the same parameter in the\n
        \  JWS Compact Serialization, provided that the JWS Protected Header\n   value
        for that signature/MAC computation (which represents the\n   integrity-protected
        Header Parameter values) matches that used in the\n   JWS Compact Serialization.\n
        \  In summary, the syntax of a JWS using the general JWS JSON\n   Serialization
        is as follows:\n     {\n      \"payload\":\"<payload contents>\",\n      \"signatures\":[\n
        \      {\"protected\":\"<integrity-protected header 1 contents>\",\n        \"header\":<non-integrity-protected
        header 1 contents>,\n        \"signature\":\"<signature 1 contents>\"},\n
        \      ...\n       {\"protected\":\"<integrity-protected header N contents>\",\n
        \       \"header\":<non-integrity-protected header N contents>,\n        \"signature\":\"<signature
        N contents>\"}]\n     }\n   See Appendix A.6 for an example JWS using the
        general JWS JSON\n   Serialization syntax.\n"
      title: 7.2.1.  General JWS JSON Serialization Syntax
    - contents:
      - "7.2.2.  Flattened JWS JSON Serialization Syntax\n   The flattened JWS JSON
        Serialization syntax is based upon the general\n   syntax but flattens it,
        optimizing it for the single digital\n   signature/MAC case.  It flattens
        it by removing the \"signatures\"\n   member and instead placing those members
        defined for use in the\n   \"signatures\" array (the \"protected\", \"header\",
        and \"signature\"\n   members) in the top-level JSON object (at the same level
        as the\n   \"payload\" member).\n   The \"signatures\" member MUST NOT be
        present when using this syntax.\n   Other than this syntax difference, JWS
        JSON Serialization objects\n   using the flattened syntax are processed identically
        to those using\n   the general syntax.\n   In summary, the syntax of a JWS
        using the flattened JWS JSON\n   Serialization is as follows:\n     {\n      \"payload\":\"<payload
        contents>\",\n      \"protected\":\"<integrity-protected header contents>\",\n
        \     \"header\":<non-integrity-protected header contents>,\n      \"signature\":\"<signature
        contents>\"\n     }\n   See Appendix A.7 for an example JWS using the flattened
        JWS JSON\n   Serialization syntax.\n"
      title: 7.2.2.  Flattened JWS JSON Serialization Syntax
    title: 7.2.  JWS JSON Serialization
  title: 7.  Serializations
- contents:
  - "8.  TLS Requirements\n   Implementations supporting the \"jku\" and/or \"x5u\"
    Header Parameters\n   MUST support TLS.  Which TLS version(s) ought to be implemented
    will\n   vary over time and depend on the widespread deployment and known\n   security
    vulnerabilities at the time of implementation.  At the time\n   of this writing,
    TLS version 1.2 [RFC5246] is the most recent\n   version.\n   To protect against
    information disclosure and tampering,\n   confidentiality protection MUST be applied
    using TLS with a\n   ciphersuite that provides confidentiality and integrity protection.\n
    \  See current publications by the IETF TLS working group, including RFC\n   6176
    [RFC6176], for guidance on the ciphersuites currently considered\n   to be appropriate
    for use.  Also, see \"Recommendations for Secure Use\n   of Transport Layer Security
    (TLS) and Datagram Transport Layer\n   Security (DTLS)\" [RFC7525] for recommendations
    on improving the\n   security of software and services using TLS.\n   Whenever
    TLS is used, the identity of the service provider encoded in\n   the TLS server
    certificate MUST be verified using the procedures\n   described in Section 6 of
    RFC 6125 [RFC6125].\n"
  title: 8.  TLS Requirements
- contents:
  - "9.  IANA Considerations\n   The following registration procedure is used for
    all the registries\n   established by this specification.\n   Values are registered
    on a Specification Required [RFC5226] basis\n   after a three-week review period
    on the jose-reg-review@ietf.org\n   mailing list, on the advice of one or more
    Designated Experts.\n   However, to allow for the allocation of values prior to
    publication,\n   the Designated Experts may approve registration once they are\n
    \  satisfied that such a specification will be published.\n   Registration requests
    sent to the mailing list for review should use\n   an appropriate subject (e.g.,
    \"Request to register header parameter:\n   example\").\n   Within the review
    period, the Designated Experts will either approve\n   or deny the registration
    request, communicating this decision to the\n   review list and IANA.  Denials
    should include an explanation and, if\n   applicable, suggestions as to how to
    make the request successful.\n   Registration requests that are undetermined for
    a period longer than\n   21 days can be brought to the IESG's attention (using
    the\n   iesg@ietf.org mailing list) for resolution.\n   Criteria that should be
    applied by the Designated Experts includes\n   determining whether the proposed
    registration duplicates existing\n   functionality, whether it is likely to be
    of general applicability or\n   useful only for a single application, and whether
    the registration\n   description is clear.\n   IANA must only accept registry
    updates from the Designated Experts\n   and should direct all requests for registration
    to the review mailing\n   list.\n   It is suggested that multiple Designated Experts
    be appointed who are\n   able to represent the perspectives of different applications
    using\n   this specification, in order to enable broadly informed review of\n
    \  registration decisions.  In cases where a registration decision could\n   be
    perceived as creating a conflict of interest for a particular\n   Expert, that
    Expert should defer to the judgment of the other\n   Experts.\n"
  - contents:
    - "9.1.  JSON Web Signature and Encryption Header Parameters Registry\n   This
      specification establishes the IANA \"JSON Web Signature and\n   Encryption Header
      Parameters\" registry for Header Parameter names.\n   The registry records the
      Header Parameter name and a reference to the\n   specification that defines
      it.  The same Header Parameter name can be\n   registered multiple times, provided
      that the parameter usage is\n   compatible between the specifications.  Different
      registrations of\n   the same Header Parameter name will typically use different
      Header\n   Parameter Usage Locations values.\n"
    - contents:
      - "9.1.1.  Registration Template\n   Header Parameter Name:\n      The name
        requested (e.g., \"kid\").  Because a core goal of this\n      specification
        is for the resulting representations to be compact,\n      it is RECOMMENDED
        that the name be short -- not to exceed 8\n      characters without a compelling
        reason to do so.  This name is\n      case sensitive.  Names may not match
        other registered names in a\n      case-insensitive manner unless the Designated
        Experts state that\n      there is a compelling reason to allow an exception.\n
        \  Header Parameter Description:\n      Brief description of the Header Parameter
        (e.g., \"Key ID\").\n   Header Parameter Usage Location(s):\n      The Header
        Parameter usage locations, which should be one or more\n      of the values
        \"JWS\" or \"JWE\".\n   Change Controller:\n      For Standards Track RFCs,
        list the \"IESG\".  For others, give the\n      name of the responsible party.
        \ Other details (e.g., postal\n      address, email address, home page URI)
        may also be included.\n   Specification Document(s):\n      Reference to the
        document or documents that specify the parameter,\n      preferably including
        URIs that can be used to retrieve copies of\n      the documents.  An indication
        of the relevant sections may also be\n      included but is not required.\n"
      title: 9.1.1.  Registration Template
    - contents:
      - "9.1.2.  Initial Registry Contents\n   This section registers the Header Parameter
        names defined in\n   Section 4.1 in this registry.\n   o  Header Parameter
        Name: \"alg\"\n   o  Header Parameter Description: Algorithm\n   o  Header
        Parameter Usage Location(s): JWS\n   o  Change Controller: IESG\n   o  Specification
        Document(s): Section 4.1.1 of RFC 7515\n   o  Header Parameter Name: \"jku\"\n
        \  o  Header Parameter Description: JWK Set URL\n   o  Header Parameter Usage
        Location(s): JWS\n   o  Change Controller: IESG\n   o  Specification Document(s):
        Section 4.1.2 of RFC 7515\n   o  Header Parameter Name: \"jwk\"\n   o  Header
        Parameter Description: JSON Web Key\n   o  Header Parameter Usage Location(s):
        JWS\n   o  Change Controller: IESG\n   o  Specification Document(s): Section
        4.1.3 of RFC 7515\n   o  Header Parameter Name: \"kid\"\n   o  Header Parameter
        Description: Key ID\n   o  Header Parameter Usage Location(s): JWS\n   o  Change
        Controller: IESG\n   o  Specification Document(s): Section 4.1.4 of RFC 7515\n
        \  o  Header Parameter Name: \"x5u\"\n   o  Header Parameter Description:
        X.509 URL\n   o  Header Parameter Usage Location(s): JWS\n   o  Change Controller:
        IESG\n   o  Specification Document(s): Section 4.1.5 of RFC 7515\n   o  Header
        Parameter Name: \"x5c\"\n   o  Header Parameter Description: X.509 Certificate
        Chain\n   o  Header Parameter Usage Location(s): JWS\n   o  Change Controller:
        IESG\n   o  Specification Document(s): Section 4.1.6 of RFC 7515\n   o  Header
        Parameter Name: \"x5t\"\n   o  Header Parameter Description: X.509 Certificate
        SHA-1 Thumbprint\n   o  Header Parameter Usage Location(s): JWS\n   o  Change
        Controller: IESG\n   o  Specification Document(s): Section 4.1.7 of RFC 7515\n
        \  o  Header Parameter Name: \"x5t#S256\"\n   o  Header Parameter Description:
        X.509 Certificate SHA-256 Thumbprint\n   o  Header Parameter Usage Location(s):
        JWS\n   o  Change Controller: IESG\n   o  Specification Document(s): Section
        4.1.8 of RFC 7515\n   o  Header Parameter Name: \"typ\"\n   o  Header Parameter
        Description: Type\n   o  Header Parameter Usage Location(s): JWS\n   o  Change
        Controller: IESG\n   o  Specification Document(s): Section 4.1.9 of RFC 7515\n
        \  o  Header Parameter Name: \"cty\"\n   o  Header Parameter Description:
        Content Type\n   o  Header Parameter Usage Location(s): JWS\n   o  Change
        Controller: IESG\n   o  Specification Document(s): Section 4.1.10 of RFC 7515\n
        \  o  Header Parameter Name: \"crit\"\n   o  Header Parameter Description:
        Critical\n   o  Header Parameter Usage Location(s): JWS\n   o  Change Controller:
        IESG\n   o  Specification Document(s): Section 4.1.11 of RFC 7515\n"
      title: 9.1.2.  Initial Registry Contents
    title: 9.1.  JSON Web Signature and Encryption Header Parameters Registry
  - contents:
    - '9.2.  Media Type Registration

      '
    - contents:
      - "9.2.1.  Registry Contents\n   This section registers the \"application/jose\"
        media type [RFC2046] in\n   the \"Media Types\" registry [IANA.MediaTypes]
        in the manner described\n   in RFC 6838 [RFC6838], which can be used to indicate
        that the content\n   is a JWS or JWE using the JWS Compact Serialization or
        the JWE\n   Compact Serialization.  This section also registers the \"application/\n
        \  jose+json\" media type in the \"Media Types\" registry, which can be\n
        \  used to indicate that the content is a JWS or JWE using the JWS JSON\n
        \  Serialization or the JWE JSON Serialization.\n   o  Type name: application\n
        \  o  Subtype name: jose\n   o  Required parameters: n/a\n   o  Optional parameters:
        n/a\n   o  Encoding considerations: 8bit; application/jose values are encoded\n
        \     as a series of base64url-encoded values (some of which may be the\n
        \     empty string), each separated from the next by a single period\n      ('.')
        character.\n   o  Security considerations: See the Security Considerations
        section\n      of RFC 7515.\n   o  Interoperability considerations: n/a\n
        \  o  Published specification: RFC 7515\n   o  Applications that use this
        media type: OpenID Connect, Mozilla\n      Persona, Salesforce, Google, Android,
        Windows Azure, Xbox One,\n      Amazon Web Services, and numerous others that
        use JWTs\n   o  Fragment identifier considerations: n/a\n   o  Additional
        information:\n         Magic number(s): n/a\n         File extension(s): n/a\n
        \        Macintosh file type code(s): n/a\n   o  Person & email address to
        contact for further information:\n      Michael B. Jones, mbj@microsoft.com\n
        \  o  Intended usage: COMMON\n   o  Restrictions on usage: none\n   o  Author:
        Michael B. Jones, mbj@microsoft.com\n   o  Change Controller: IESG\n   o  Provisional
        registration?  No\n   o  Type name: application\n   o  Subtype name: jose+json\n
        \  o  Required parameters: n/a\n   o  Optional parameters: n/a\n   o  Encoding
        considerations: 8bit; application/jose+json values are\n      represented
        as a JSON Object; UTF-8 encoding SHOULD be employed\n      for the JSON object.\n
        \  o  Security considerations: See the Security Considerations section\n      of
        RFC 7515\n   o  Interoperability considerations: n/a\n   o  Published specification:
        RFC 7515\n   o  Applications that use this media type: Nimbus JOSE + JWT library\n
        \  o  Fragment identifier considerations: n/a\n   o  Additional information:\n
        \        Magic number(s): n/a\n         File extension(s): n/a\n         Macintosh
        file type code(s): n/a\n   o  Person & email address to contact for further
        information:\n      Michael B. Jones, mbj@microsoft.com\n   o  Intended usage:
        COMMON\n   o  Restrictions on usage: none\n   o  Author: Michael B. Jones,
        mbj@microsoft.com\n   o  Change Controller: IESG\n   o  Provisional registration?
        \ No\n"
      title: 9.2.1.  Registry Contents
    title: 9.2.  Media Type Registration
  title: 9.  IANA Considerations
- contents:
  - "10.  Security Considerations\n   All of the security issues that are pertinent
    to any cryptographic\n   application must be addressed by JWS/JWE/JWK agents.
    \ Among these\n   issues are protecting the user's asymmetric private and symmetric\n
    \  secret keys and employing countermeasures to various attacks.\n   All the security
    considerations in \"XML Signature Syntax and\n   Processing Version 2.0\" [W3C.NOTE-xmldsig-core2-20130411],
    also apply\n   to this specification, other than those that are XML specific.\n
    \  Likewise, many of the best practices documented in \"XML Signature\n   Best
    Practices\" [W3C.NOTE-xmldsig-bestpractices-20130411] also apply\n   to this specification,
    other than those that are XML specific.\n"
  - contents:
    - "10.1.  Key Entropy and Random Values\n   Keys are only as strong as the amount
      of entropy used to generate\n   them.  A minimum of 128 bits of entropy should
      be used for all keys,\n   and depending upon the application context, more may
      be required.\n   Implementations must randomly generate public/private key pairs,
      MAC\n   keys, and padding values.  The use of inadequate pseudorandom number\n
      \  generators (PRNGs) to generate cryptographic keys can result in\n   little
      or no security.  An attacker may find it much easier to\n   reproduce the PRNG
      environment that produced the keys, searching the\n   resulting small set of
      possibilities rather than brute-force\n   searching the whole key space.  The
      generation of quality random\n   numbers is difficult.  RFC 4086 [RFC4086] offers
      important guidance\n   in this area.\n"
    title: 10.1.  Key Entropy and Random Values
  - contents:
    - "10.2.  Key Protection\n   Implementations must protect the signer's private
      key.  Compromise of\n   the signer's private key permits an attacker to masquerade
      as the\n   signer.\n   Implementations must protect the MAC key.  Compromise
      of the MAC key\n   may result in undetectable modification of the authenticated
      content.\n"
    title: 10.2.  Key Protection
  - contents:
    - "10.3.  Key Origin Authentication\n   The key management technique employed
      to obtain public keys must\n   authenticate the origin of the key; otherwise,
      it is unknown what\n   party signed the message.\n   Likewise, the key management
      technique employed to distribute MAC\n   keys must provide data origin authentication;
      otherwise, the contents\n   are delivered with integrity from an unknown source.\n"
    title: 10.3.  Key Origin Authentication
  - contents:
    - "10.4.  Cryptographic Agility\n   See Section 8.1 of [JWA] for security considerations
      on cryptographic\n   agility.\n"
    title: 10.4.  Cryptographic Agility
  - contents:
    - "10.5.  Differences between Digital Signatures and MACs\n   While MACs and digital
      signatures can both be used for integrity\n   checking, there are some significant
      differences between the security\n   properties that each of them provides.
      \ These need to be taken into\n   consideration when designing protocols and
      selecting the algorithms\n   to be used in protocols.\n   Both signatures and
      MACs provide for integrity checking -- verifying\n   that the message has not
      been modified since the integrity value was\n   computed.  However, MACs provide
      for origination identification only\n   under specific circumstances.  It can
      normally be assumed that a\n   private key used for a signature is only in the
      hands of a single\n   entity (although perhaps a distributed entity, in the
      case of\n   replicated servers); however, a MAC key needs to be in the hands
      of\n   all the entities that use it for integrity computation and checking.\n
      \  Validation of a MAC only provides corroboration that the message was\n   generated
      by one of the parties that knows the symmetric MAC key.\n   This means that
      origination can only be determined if a MAC key is\n   known only to two entities
      and the recipient knows that it did not\n   create the message.  MAC validation
      cannot be used to prove\n   origination to a third party.\n"
    title: 10.5.  Differences between Digital Signatures and MACs
  - contents:
    - "10.6.  Algorithm Validation\n   The digital signature representations for some
      algorithms include\n   information about the algorithm used inside the signature
      value.  For\n   instance, signatures produced with RSASSA-PKCS1-v1_5 [RFC3447]
      encode\n   the hash function used, and many libraries actually use the hash\n
      \  algorithm specified inside the signature when validating the\n   signature.
      \ When using such libraries, as part of the algorithm\n   validation performed,
      implementations MUST ensure that the algorithm\n   information encoded in the
      signature corresponds to that specified\n   with the \"alg\" Header Parameter.
      \ If this is not done, an attacker\n   could claim to have used a strong hash
      algorithm while actually using\n   a weak one represented in the signature value.\n"
    title: 10.6.  Algorithm Validation
  - contents:
    - "10.7.  Algorithm Protection\n   In some usages of JWS, there is a risk of algorithm
      substitution\n   attacks, in which an attacker can use an existing digital signature\n
      \  value with a different signature algorithm to make it appear that a\n   signer
      has signed something that it has not.  These attacks have been\n   discussed
      in detail in the context of Cryptographic Message Syntax\n   (CMS) [RFC6211].
      \ This risk arises when all of the following are\n   true:\n   o  Verifiers
      of a signature support multiple algorithms.\n   o  Given an existing signature,
      an attacker can find another payload\n      that produces the same signature
      value with a different algorithm.\n   o  The payload crafted by the attacker
      is valid in the application\n      context.\n   There are several ways for an
      application to mitigate algorithm\n   substitution attacks:\n   o  Use only
      digital signature algorithms that are not vulnerable to\n      substitution
      attacks.  Substitution attacks are only feasible if\n      an attacker can compute
      pre-images for a hash function accepted by\n      the recipient.  All JWA-defined
      signature algorithms use SHA-2\n      hashes, for which there are no known pre-image
      attacks, as of the\n      time of this writing.\n   o  Require that the \"alg\"
      Header Parameter be carried in the JWS\n      Protected Header.  (This is always
      the case when using the JWS\n      Compact Serialization and is the approach
      taken by CMS [RFC6211].)\n   o  Include a field containing the algorithm in
      the application\n      payload, and require that it be matched with the \"alg\"
      Header\n      Parameter during verification.  (This is the approach taken by\n
      \     PKIX [RFC5280].)\n"
    title: 10.7.  Algorithm Protection
  - contents:
    - "10.8.  Chosen Plaintext Attacks\n   Creators of JWSs should not allow third
      parties to insert arbitrary\n   content into the message without adding entropy
      not controlled by the\n   third party.\n"
    title: 10.8.  Chosen Plaintext Attacks
  - contents:
    - "10.9.  Timing Attacks\n   When cryptographic algorithms are implemented in
      such a way that\n   successful operations take a different amount of time than\n
      \  unsuccessful operations, attackers may be able to use the time\n   difference
      to obtain information about the keys employed.  Therefore,\n   such timing differences
      must be avoided.\n"
    title: 10.9.  Timing Attacks
  - contents:
    - "10.10.  Replay Protection\n   While not directly in scope for this specification,
      note that\n   applications using JWS (or JWE) objects can thwart replay attacks
      by\n   including a unique message identifier as integrity-protected content\n
      \  in the JWS (or JWE) message and having the recipient verify that the\n   message
      has not been previously received or acted upon.\n"
    title: 10.10.  Replay Protection
  - contents:
    - "10.11.  SHA-1 Certificate Thumbprints\n   A SHA-1 hash is used when computing
      \"x5t\" (X.509 certificate SHA-1\n   thumbprint) values, for compatibility reasons.
      \ Should an effective\n   means of producing SHA-1 hash collisions be developed
      and should an\n   attacker wish to interfere with the use of a known certificate
      on a\n   given system, this could be accomplished by creating another\n   certificate
      whose SHA-1 hash value is the same and adding it to the\n   certificate store
      used by the intended victim.  A prerequisite to\n   this attack succeeding is
      the attacker having write access to the\n   intended victim's certificate store.\n
      \  Alternatively, the \"x5t#S256\" (X.509 certificate SHA-256 thumbprint)\n
      \  Header Parameter could be used instead of \"x5t\".  However, at the\n   time
      of this writing, no development platform is known to support\n   SHA-256 certificate
      thumbprints.\n"
    title: 10.11.  SHA-1 Certificate Thumbprints
  - contents:
    - "10.12.  JSON Security Considerations\n   Strict JSON [RFC7159] validation is
      a security requirement.  If\n   malformed JSON is received, then the intent
      of the producer is\n   impossible to reliably discern.  Ambiguous and potentially\n
      \  exploitable situations could arise if the JSON parser used does not\n   reject
      malformed JSON syntax.  In particular, any JSON inputs not\n   conforming to
      the JSON-text syntax defined in RFC 7159 MUST be\n   rejected in their entirety
      by JSON parsers.\n   Section 4 of \"The JavaScript Object Notation (JSON) Data
      Interchange\n   Format\" [RFC7159] states, \"The names within an object SHOULD
      be\n   unique\", whereas this specification states that\n      The Header Parameter
      names within the JOSE Header MUST be unique;\n      JWS parsers MUST either
      reject JWSs with duplicate Header\n      Parameter names or use a JSON parser
      that returns only the\n      lexically last duplicate member name, as specified
      in\n      Section 15.12 (\"The JSON Object\") of ECMAScript 5.1 [ECMAScript].\n
      \  Thus, this specification requires that the \"SHOULD\" in Section 4 of\n   [RFC7159]
      be treated as a \"MUST\" by producers and that it be either\n   treated as a
      \"MUST\" or treated in the manner specified in ECMAScript\n   5.1 by consumers.
      \ Ambiguous and potentially exploitable situations\n   could arise if the JSON
      parser used does not enforce the uniqueness\n   of member names or returns an
      unpredictable value for duplicate\n   member names.\n   Some JSON parsers might
      not reject input that contains extra\n   significant characters after a valid
      input.  For instance, the input\n   \"{\"tag\":\"value\"}ABCD\" contains a valid
      JSON-text object followed by\n   the extra characters \"ABCD\".  Implementations
      MUST consider JWSs\n   containing such input to be invalid.\n"
    title: 10.12.  JSON Security Considerations
  - contents:
    - "10.13.  Unicode Comparison Security Considerations\n   Header Parameter names
      and algorithm names are Unicode strings.  For\n   security reasons, the representations
      of these names must be compared\n   verbatim after performing any escape processing
      (as per Section 8.3\n   of RFC 7159 [RFC7159]).  This means, for instance, that
      these JSON\n   strings must compare as being equal (\"sig\", \"\\u0073ig\"),
      whereas\n   these must all compare as being not equal to the first set or to
      each\n   other (\"SIG\", \"Sig\", \"si\\u0047\").\n   JSON strings can contain
      characters outside the Unicode Basic\n   Multilingual Plane.  For instance,
      the G clef character (U+1D11E) may\n   be represented in a JSON string as \"\\uD834\\uDD1E\".
      \ Ideally, JWS\n   implementations SHOULD ensure that characters outside the
      Basic\n   Multilingual Plane are preserved and compared correctly;\n   alternatively,
      if this is not possible due to these characters\n   exercising limitations present
      in the underlying JSON implementation,\n   then input containing them MUST be
      rejected.\n"
    title: 10.13.  Unicode Comparison Security Considerations
  title: 10.  Security Considerations
- contents:
  - '11.  References

    '
  - contents:
    - "11.1.  Normative References\n   [ECMAScript] Ecma International, \"ECMAScript
      Language Specification,\n                5.1 Edition\", ECMA 262, June 2011,\n
      \               <http://www.ecma-international.org/ecma-262/5.1/\n                ECMA-262.pdf>.\n
      \  [IANA.MediaTypes]\n                IANA, \"Media Types\",\n                <http://www.iana.org/assignments/media-types>.\n
      \  [ITU.X690.2008]\n                International Telecommunications Union,
      \"Information\n                Technology - ASN.1 encoding rules: Specification
      of\n                Basic Encoding Rules (BER), Canonical Encoding Rules\n                (CER)
      and Distinguished Encoding Rules (DER)\", ITU-T\n                Recommendation
      X.690, 2008.\n   [JWA]        Jones, M., \"JSON Web Algorithms (JWA)\", RFC
      7518,\n                DOI 10.17487/RFC7518, May 2015,\n                <http://www.rfc-editor.org/info/rfc7518>.\n
      \  [JWK]        Jones, M., \"JSON Web Key (JWK)\", RFC 7517,\n                DOI
      10.17487/RFC7517, May 2015,\n                <http://www.rfc-editor.org/info/rfc7517>.\n
      \  [RFC20]      Cerf, V., \"ASCII format for Network Interchange\",\n                STD
      80, RFC 20, DOI 10.17487/RFC0020, October 1969,\n                <http://www.rfc-editor.org/info/rfc20>.\n
      \  [RFC2045]    Freed, N. and N. Borenstein, \"Multipurpose Internet Mail\n
      \               Extensions (MIME) Part One: Format of Internet Message\n                Bodies\",
      RFC 2045, DOI 10.17487/RFC2045, November 1996,\n                <http://www.rfc-editor.org/info/rfc2045>.\n
      \  [RFC2046]    Freed, N. and N. Borenstein, \"Multipurpose Internet Mail\n
      \               Extensions (MIME) Part Two: Media Types\", RFC 2046,\n                DOI
      10.17487/RFC2046, November 1996,\n                <http://www.rfc-editor.org/info/rfc2046>.\n
      \  [RFC2119]    Bradner, S., \"Key words for use in RFCs to Indicate\n                Requirement
      Levels\", BCP 14, RFC 2119,\n                DOI 10.17487/RFC2119, March 1997,\n
      \               <http://www.rfc-editor.org/info/rfc2119>.\n   [RFC2818]    Rescorla,
      E., \"HTTP Over TLS\", RFC 2818,\n                DOI 10.17487/RFC2818, May
      2000,\n                <http://www.rfc-editor.org/info/rfc2818>.\n   [RFC3629]
      \   Yergeau, F., \"UTF-8, a transformation format of ISO\n                10646\",
      STD 63, RFC 3629, DOI 10.17487/RFC3629, November\n                2003, <http://www.rfc-editor.org/info/rfc3629>.\n
      \  [RFC3986]    Berners-Lee, T., Fielding, R., and L. Masinter, \"Uniform\n
      \               Resource Identifier (URI): Generic Syntax\", STD 66,\n                RFC
      3986, DOI 10.17487/RFC3986, January 2005,\n                <http://www.rfc-editor.org/info/rfc3986>.\n
      \  [RFC4648]    Josefsson, S., \"The Base16, Base32, and Base64 Data\n                Encodings\",
      RFC 4648, DOI 10.17487/RFC4648, October\n                2006, <http://www.rfc-editor.org/info/rfc4648>.\n
      \  [RFC4945]    Korver, B., \"The Internet IP Security PKI Profile of\n                IKEv1/ISAKMP,
      IKEv2, and PKIX\", RFC 4945,\n                DOI 10.17487/RFC4945, August 2007,\n
      \               <http://www.rfc-editor.org/info/rfc4945>.\n   [RFC4949]    Shirey,
      R., \"Internet Security Glossary, Version 2\",\n                FYI 36, RFC
      4949, DOI 10.17487/RFC4949, August 2007,\n                <http://www.rfc-editor.org/info/rfc4949>.\n
      \  [RFC5246]    Dierks, T. and E. Rescorla, \"The Transport Layer\n                Security
      (TLS) Protocol Version 1.2\", RFC 5246,\n                DOI 10.17487/RFC5246,
      August 2008,\n                <http://www.rfc-editor.org/info/rfc5246>.\n   [RFC5280]
      \   Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,\n                Housley,
      R., and W. Polk, \"Internet X.509 Public Key\n                Infrastructure
      Certificate and Certificate Revocation\n                List (CRL) Profile\",
      RFC 5280, DOI 10.17487/RFC5280, May\n                2008, <http://www.rfc-editor.org/info/rfc5280>.\n
      \  [RFC6125]    Saint-Andre, P. and J. Hodges, \"Representation and\n                Verification
      of Domain-Based Application Service\n                Identity within Internet
      Public Key Infrastructure Using\n                X.509 (PKIX) Certificates in
      the Context of Transport\n                Layer Security (TLS)\", RFC 6125,
      DOI 10.17487/RFC6125,\n                March 2011, <http://www.rfc-editor.org/info/rfc6125>.\n
      \  [RFC6176]    Turner, S. and T. Polk, \"Prohibiting Secure Sockets\n                Layer
      (SSL) Version 2.0\", RFC 6176,\n                DOI 10.17487/RFC6176, March
      2011,\n                <http://www.rfc-editor.org/info/rfc6176>.\n   [RFC7159]
      \   Bray, T., Ed., \"The JavaScript Object Notation (JSON)\n                Data
      Interchange Format\", RFC 7159,\n                DOI 10.17487/RFC7159, March
      2014,\n                <http://www.rfc-editor.org/info/rfc7159>.\n   [UNICODE]
      \   The Unicode Consortium, \"The Unicode Standard\",\n                <http://www.unicode.org/versions/latest/>.\n"
    title: 11.1.  Normative References
  - contents:
    - "11.2.  Informative References\n   [CanvasApp]  Facebook, \"Canvas Applications\",\n
      \               <http://developers.facebook.com/docs/authentication/\n                canvas>.\n
      \  [JSS]        Bradley, J. and N. Sakimura, Ed., \"JSON Simple Sign\",\n                September
      2010, <http://jsonenc.info/jss/1.0/>.\n   [JWE]        Jones, M. and J. Hildebrand,
      \"JSON Web Encryption\n                (JWE)\", RFC 7516, DOI 10.17487/RFC7516,
      May 2015,\n                <http://www.rfc-editor.org/info/rfc7516>.\n   [JWT]
      \       Jones, M., Bradley, J., and N. Sakimura, \"JSON Web Token\n                (JWT)\",
      RFC 7519, DOI 10.17487/RFC7519, May 2015,\n                <http://www.rfc-editor.org/info/rfc7519>.\n
      \  [MagicSignatures]\n                Panzer, J., Ed., Laurie, B., and D. Balfanz,
      \"Magic\n                Signatures\", January 2011,\n                <http://salmon-protocol.googlecode.com/svn/trunk/\n
      \               draft-panzer-magicsig-01.html>.\n   [RFC2104]    Krawczyk, H.,
      Bellare, M., and R. Canetti, \"HMAC:\n                Keyed-Hashing for Message
      Authentication\", RFC 2104,\n                DOI 10.17487/RFC2104, February
      1997,\n                <http://www.rfc-editor.org/info/rfc2104>.\n   [RFC3447]
      \   Jonsson, J. and B. Kaliski, \"Public-Key Cryptography\n                Standards
      (PKCS) #1: RSA Cryptography Specifications\n                Version 2.1\", RFC
      3447, DOI 10.17487/RFC3447, February\n                2003, <http://www.rfc-editor.org/info/rfc3447>.\n
      \  [RFC4086]    Eastlake 3rd, D., Schiller, J., and S. Crocker,\n                \"Randomness
      Requirements for Security\", BCP 106,\n                RFC 4086, DOI 10.17487/RFC4086,
      June 2005,\n                <http://www.rfc-editor.org/info/rfc4086>.\n   [RFC4122]
      \   Leach, P., Mealling, M., and R. Salz, \"A Universally\n                Unique
      IDentifier (UUID) URN Namespace\", RFC 4122,\n                DOI 10.17487/RFC4122,
      July 2005,\n                <http://www.rfc-editor.org/info/rfc4122>.\n   [RFC5226]
      \   Narten, T. and H. Alvestrand, \"Guidelines for Writing an\n                IANA
      Considerations Section in RFCs\", BCP 26, RFC 5226,\n                DOI 10.17487/RFC5226,
      May 2008,\n                <http://www.rfc-editor.org/info/rfc5226>.\n   [RFC6211]
      \   Schaad, J., \"Cryptographic Message Syntax (CMS)\n                Algorithm
      Identifier Protection Attribute\", RFC 6211,\n                DOI 10.17487/RFC6211,
      April 2011,\n                <http://www.rfc-editor.org/info/rfc6211>.\n   [RFC6838]
      \   Freed, N., Klensin, J., and T. Hansen, \"Media Type\n                Specifications
      and Registration Procedures\", BCP 13,\n                RFC 6838, DOI 10.17487/RFC6838,
      January 2013,\n                <http://www.rfc-editor.org/info/rfc6838>.\n   [RFC7525]
      \   Sheffer, Y., Holz, R., and P. Saint-Andre,\n                \"Recommendations
      for Secure Use of Transport Layer\n                Security (TLS) and Datagram
      Transport Layer Security\n                (DTLS)\", BCP 195, RFC 7525, DOI 10.17487/RFC7525,
      May\n                2015, <http://www.rfc-editor.org/info/rfc7525>.\n   [SHS]
      \       National Institute of Standards and Technology, \"Secure\n                Hash
      Standard (SHS)\", FIPS PUB 180-4, March 2012,\n                <http://csrc.nist.gov/publications/fips/fips180-4/\n
      \               fips-180-4.pdf>.\n   [W3C.NOTE-xmldsig-bestpractices-20130411]\n
      \               Hirsch, F. and P. Datta, \"XML Signature Best Practices\",\n
      \               World Wide Web Consortium Note\n                NOTE-xmldsig-bestpractices-20130411,
      April 2013,\n                <http://www.w3.org/TR/2013/\n                NOTE-xmldsig-bestpractices-20130411/>.\n
      \  [W3C.NOTE-xmldsig-core2-20130411]\n                Eastlake, D., Reagle,
      J., Solo, D., Hirsch, F.,\n                Roessler, T., Yiu, K., Datta, P.,
      and S. Cantor, \"XML\n                Signature Syntax and Processing Version
      2.0\", World Wide\n                Web Consortium Note NOTE-xmldsig-core2-20130411,
      April\n                2013,\n                <http://www.w3.org/TR/2013/NOTE-xmldsig-core2-20130411/>.\n"
    title: 11.2.  Informative References
  title: 11.  References
- contents:
  - "Appendix A.  JWS Examples\n   This section provides several examples of JWSs.
    \ While the first\n   three examples all represent JSON Web Tokens (JWTs) [JWT],
    the\n   payload can be any octet sequence, as shown in Appendix A.4.\n"
  - contents:
    - 'A.1.  Example JWS Using HMAC SHA-256

      '
    - contents:
      - "A.1.1.  Encoding\n   The following example JWS Protected Header declares
        that the data\n   structure is a JWT [JWT] and the JWS Signing Input is secured
        using\n   the HMAC SHA-256 algorithm.\n     {\"typ\":\"JWT\",\n      \"alg\":\"HS256\"}\n
        \  To remove potential ambiguities in the representation of the JSON\n   object
        above, the actual octet sequence representing UTF8(JWS\n   Protected Header)
        used in this example is also included below.  (Note\n   that ambiguities can
        arise due to differing platform representations\n   of line breaks (CRLF versus
        LF), differing spacing at the beginning\n   and ends of lines, whether the
        last line has a terminating line break\n   or not, and other causes.  In the
        representation used in this\n   example, the first line has no leading or
        trailing spaces, a CRLF\n   line break (13, 10) occurs between the first and
        second lines, the\n   second line has one leading space (32) and no trailing
        spaces, and\n   the last line does not have a terminating line break.)  The
        octets\n   representing UTF8(JWS Protected Header) in this example (using
        JSON\n   array notation) are:\n   [123, 34, 116, 121, 112, 34, 58, 34, 74,
        87, 84, 34, 44, 13, 10, 32,\n   34, 97, 108, 103, 34, 58, 34, 72, 83, 50,
        53, 54, 34, 125]\n   Encoding this JWS Protected Header as BASE64URL(UTF8(JWS
        Protected\n   Header)) gives this value:\n     eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9\n
        \  The JWS Payload used in this example is the octets of the UTF-8\n   representation
        of the JSON object below.  (Note that the payload can\n   be any base64url-encoded
        octet sequence and need not be a base64url-\n   encoded JSON object.)\n     {\"iss\":\"joe\",\n
        \     \"exp\":1300819380,\n      \"http://example.com/is_root\":true}\n   The
        following octet sequence, which is the UTF-8 representation used\n   in this
        example for the JSON object above, is the JWS Payload:\n   [123, 34, 105,
        115, 115, 34, 58, 34, 106, 111, 101, 34, 44, 13, 10,\n   32, 34, 101, 120,
        112, 34, 58, 49, 51, 48, 48, 56, 49, 57, 51, 56,\n   48, 44, 13, 10, 32, 34,
        104, 116, 116, 112, 58, 47, 47, 101, 120, 97,\n   109, 112, 108, 101, 46,
        99, 111, 109, 47, 105, 115, 95, 114, 111,\n   111, 116, 34, 58, 116, 114,
        117, 101, 125]\n   Encoding this JWS Payload as BASE64URL(UTF8(JWS Payload))
        gives this\n   value (with line breaks for display purposes only):\n     eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt\n
        \    cGxlLmNvbS9pc19yb290Ijp0cnVlfQ\n   Combining these as BASE64URL(UTF8(JWS
        Protected Header)) || '.' ||\n   BASE64URL(JWS Payload) gives this string
        (with line breaks for\n   display purposes only):\n     eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9\n
        \    .\n     eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt\n
        \    cGxlLmNvbS9pc19yb290Ijp0cnVlfQ\n   The resulting JWS Signing Input value,
        which is the ASCII\n   representation of above string, is the following octet
        sequence\n   (using JSON array notation):\n   [101, 121, 74, 48, 101, 88,
        65, 105, 79, 105, 74, 75, 86, 49, 81,\n   105, 76, 65, 48, 75, 73, 67, 74,
        104, 98, 71, 99, 105, 79, 105, 74,\n   73, 85, 122, 73, 49, 78, 105, 74, 57,
        46, 101, 121, 74, 112, 99, 51,\n   77, 105, 79, 105, 74, 113, 98, 50, 85,
        105, 76, 65, 48, 75, 73, 67,\n   74, 108, 101, 72, 65, 105, 79, 106, 69, 122,
        77, 68, 65, 52, 77, 84,\n   107, 122, 79, 68, 65, 115, 68, 81, 111, 103, 73,
        109, 104, 48, 100,\n   72, 65, 54, 76, 121, 57, 108, 101, 71, 70, 116, 99,
        71, 120, 108, 76,\n   109, 78, 118, 98, 83, 57, 112, 99, 49, 57, 121, 98,
        50, 57, 48, 73,\n   106, 112, 48, 99, 110, 86, 108, 102, 81]\n   HMACs are
        generated using keys.  This example uses the symmetric key\n   represented
        in JSON Web Key [JWK] format below (with line breaks\n   within values for
        display purposes only):\n     {\"kty\":\"oct\",\n      \"k\":\"AyM1SysPpbyDfgZld3umj1qzKObwVMkoqQ-EstJQLr_T-1qS0gZH75\n
        \          aKtMN3Yj0iPS4hcgUuTwjAzZr1Z9CAow\"\n     }\n   Running the HMAC
        SHA-256 algorithm on the JWS Signing Input with this\n   key yields this JWS
        Signature octet sequence:\n   [116, 24, 223, 180, 151, 153, 224, 37, 79, 250,
        96, 125, 216, 173,\n   187, 186, 22, 212, 37, 77, 105, 214, 191, 240, 91,
        88, 5, 88, 83,\n   132, 141, 121]\n   Encoding this JWS Signature as BASE64URL(JWS
        Signature) gives this\n   value:\n     dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk\n
        \  Concatenating these values in the order Header.Payload.Signature with\n
        \  period ('.') characters between the parts yields this complete JWS\n   representation
        using the JWS Compact Serialization (with line breaks\n   for display purposes
        only):\n     eyJ0eXAiOiJKV1QiLA0KICJhbGciOiJIUzI1NiJ9\n     .\n     eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt\n
        \    cGxlLmNvbS9pc19yb290Ijp0cnVlfQ\n     .\n     dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk\n"
      title: A.1.1.  Encoding
    - contents:
      - "A.1.2.  Validating\n   Since the \"alg\" Header Parameter is \"HS256\", we
        validate the HMAC\n   SHA-256 value contained in the JWS Signature.\n   To
        validate the HMAC value, we repeat the previous process of using\n   the correct
        key and the JWS Signing Input (which is the initial\n   substring of the JWS
        Compact Serialization representation up until\n   but not including the second
        period character) as input to the HMAC\n   SHA-256 function and then taking
        the output and determining if it\n   matches the JWS Signature (which is base64url
        decoded from the value\n   encoded in the JWS representation).  If it matches
        exactly, the HMAC\n   has been validated.\n"
      title: A.1.2.  Validating
    title: A.1.  Example JWS Using HMAC SHA-256
  - contents:
    - 'A.2.  Example JWS Using RSASSA-PKCS1-v1_5 SHA-256

      '
    - contents:
      - "A.2.1.  Encoding\n   The JWS Protected Header in this example is different
        from the\n   previous example in two ways.  First, because a different algorithm\n
        \  is being used, the \"alg\" value is different.  Second, for\n   illustration
        purposes only, the optional \"typ\" (type) Header\n   Parameter is not used.
        \ (This difference is not related to the\n   algorithm employed.)  The JWS
        Protected Header used is:\n     {\"alg\":\"RS256\"}\n   The octets representing
        UTF8(JWS Protected Header) in this example\n   (using JSON array notation)
        are:\n   [123, 34, 97, 108, 103, 34, 58, 34, 82, 83, 50, 53, 54, 34, 125]\n
        \  Encoding this JWS Protected Header as BASE64URL(UTF8(JWS Protected\n   Header))
        gives this value:\n     eyJhbGciOiJSUzI1NiJ9\n   The JWS Payload used in this
        example, which follows, is the same as\n   in the previous example.  Since
        the BASE64URL(JWS Payload) value will\n   therefore be the same, its computation
        is not repeated here.\n     {\"iss\":\"joe\",\n      \"exp\":1300819380,\n
        \     \"http://example.com/is_root\":true}\n   Combining these as BASE64URL(UTF8(JWS
        Protected Header)) || '.' ||\n   BASE64URL(JWS Payload) gives this string
        (with line breaks for\n   display purposes only):\n     eyJhbGciOiJSUzI1NiJ9\n
        \    .\n     eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt\n
        \    cGxlLmNvbS9pc19yb290Ijp0cnVlfQ\n   The resulting JWS Signing Input value,
        which is the ASCII\n   representation of above string, is the following octet
        sequence:\n   [101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 83, 85, 122,
        73,\n   49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51, 77, 105, 79, 105,\n
        \  74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67, 74, 108, 101, 72,\n   65,
        105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84, 107, 122, 79, 68,\n   65, 115,
        68, 81, 111, 103, 73, 109, 104, 48, 100, 72, 65, 54, 76,\n   121, 57, 108,
        101, 71, 70, 116, 99, 71, 120, 108, 76, 109, 78, 118,\n   98, 83, 57, 112,
        99, 49, 57, 121, 98, 50, 57, 48, 73, 106, 112, 48,\n   99, 110, 86, 108, 102,
        81]\n   This example uses the RSA key represented in JSON Web Key [JWK]\n
        \  format below (with line breaks within values for display purposes\n   only):\n
        \    {\"kty\":\"RSA\",\n      \"n\":\"ofgWCuLjybRlzo0tZWJjNiuSfb4p4fAkd_wWJcyQoTbji9k0l8W26mPddx\n
        \          HmfHQp-Vaw-4qPCJrcS2mJPMEzP1Pt0Bm4d4QlL-yRT-SFd2lZS-pCgNMs\n           D1W_YpRPEwOWvG6b32690r2jZ47soMZo9wGzjb_7OMg0LOL-bSf63kpaSH\n
        \          SXndS5z5rexMdbBYUsLA9e-KXBdQOS-UTo7WTBEMa2R2CapHg665xsmtdV\n           MTBQY4uDZlxvb3qCo5ZwKh9kG4LT6_I5IhlJH7aGhyxXFvUK-DWNmoudF8\n
        \          NAco9_h9iaGNj8q2ethFkMLs91kzk2PAcDTW9gb54h4FRWyuXpoQ\",\n      \"e\":\"AQAB\",\n
        \     \"d\":\"Eq5xpGnNCivDflJsRQBXHx1hdR1k6Ulwe2JZD50LpXyWPEAeP88vLNO97I\n
        \          jlA7_GQ5sLKMgvfTeXZx9SE-7YwVol2NXOoAJe46sui395IW_GO-pWJ1O0\n           BkTGoVEn2bKVRUCgu-GjBVaYLU6f3l9kJfFNS3E0QbVdxzubSu3Mkqzjkn\n
        \          439X0M_V51gfpRLI9JYanrC4D4qAdGcopV_0ZHHzQlBjudU2QvXt4ehNYT\n           CBr6XCLQUShb1juUO1ZdiYoFaFQT5Tw8bGUl_x_jTj3ccPDVZFD9pIuhLh\n
        \          BOneufuBiB4cS98l2SR_RQyGWSeWjnczT0QU91p1DhOVRuOopznQ\",\n      \"p\":\"4BzEEOtIpmVdVEZNCqS7baC4crd0pqnRH_5IB3jw3bcxGn6QLvnEtfdUdi\n
        \          YrqBdss1l58BQ3KhooKeQTa9AB0Hw_Py5PJdTJNPY8cQn7ouZ2KKDcmnPG\n           BY5t7yLc1QlQ5xHdwW1VhvKn-nXqhJTBgIPgtldC-KDV5z-y2XDwGUc\",\n
        \     \"q\":\"uQPEfgmVtjL0Uyyx88GZFF1fOunH3-7cepKmtH4pxhtCoHqpWmT8YAmZxa\n
        \          ewHgHAjLYsp1ZSe7zFYHj7C6ul7TjeLQeZD_YwD66t62wDmpe_HlB-TnBA\n           -njbglfIsRLtXlnDzQkv5dTltRJ11BKBBypeeF6689rjcJIDEz9RWdc\",\n
        \     \"dp\":\"BwKfV3Akq5_MFZDFZCnW-wzl-CCo83WoZvnLQwCTeDv8uzluRSnm71I3Q\n
        \          CLdhrqE2e9YkxvuxdBfpT_PI7Yz-FOKnu1R6HsJeDCjn12Sk3vmAktV2zb\n           34MCdy7cpdTh_YVr7tss2u6vneTwrA86rZtu5Mbr1C1XsmvkxHQAdYo0\",\n
        \     \"dq\":\"h_96-mK1R_7glhsum81dZxjTnYynPbZpHziZjeeHcXYsXaaMwkOlODsWa\n
        \          7I9xXDoRwbKgB719rrmI2oKr6N3Do9U0ajaHF-NKJnwgjMd2w9cjz3_-ky\n           NlxAr2v4IKhGNpmM5iIgOS1VZnOZ68m6_pbLBSp3nssTdlqvd0tIiTHU\",\n
        \     \"qi\":\"IYd7DHOhrWvxkwPQsRM2tOgrjbcrfvtQJipd-DlcxyVuuM9sQLdgjVk2o\n
        \          y26F0EmpScGLq2MowX7fhd_QJQ3ydy5cY7YIBi87w93IKLEdfnbJtoOPLU\n           W0ITrJReOgo1cq9SbsxYawBgfp_gh6A5603k2-ZQwVK0JKSHuLFkuQ3U\"\n
        \    }\n   The RSA private key is then passed to the RSA signing function,
        which\n   also takes the hash type, SHA-256, and the JWS Signing Input as\n
        \  inputs.  The result of the digital signature is an octet sequence,\n   which
        represents a big-endian integer.  In this example, it is:\n   [112, 46, 33,
        137, 67, 232, 143, 209, 30, 181, 216, 45, 191, 120, 69,\n   243, 65, 6, 174,
        27, 129, 255, 247, 115, 17, 22, 173, 209, 113, 125,\n   131, 101, 109, 66,
        10, 253, 60, 150, 238, 221, 115, 162, 102, 62, 81,\n   102, 104, 123, 0, 11,
        135, 34, 110, 1, 135, 237, 16, 115, 249, 69,\n   229, 130, 173, 252, 239,
        22, 216, 90, 121, 142, 232, 198, 109, 219,\n   61, 184, 151, 91, 23, 208,
        148, 2, 190, 237, 213, 217, 217, 112, 7,\n   16, 141, 178, 129, 96, 213, 248,
        4, 12, 167, 68, 87, 98, 184, 31,\n   190, 127, 249, 217, 46, 10, 231, 111,
        36, 242, 91, 51, 187, 230, 244,\n   74, 230, 30, 177, 4, 10, 203, 32, 4, 77,
        62, 249, 18, 142, 212, 1,\n   48, 121, 91, 212, 189, 59, 65, 238, 202, 208,
        102, 171, 101, 25, 129,\n   253, 228, 141, 247, 127, 55, 45, 195, 139, 159,
        175, 221, 59, 239,\n   177, 139, 93, 163, 204, 60, 46, 176, 47, 158, 58, 65,
        214, 18, 202,\n   173, 21, 145, 18, 115, 160, 95, 35, 185, 232, 56, 250, 175,
        132, 157,\n   105, 132, 41, 239, 90, 30, 136, 121, 130, 54, 195, 212, 14,
        96, 69,\n   34, 165, 68, 200, 242, 122, 122, 45, 184, 6, 99, 209, 108, 247,
        202,\n   234, 86, 222, 64, 92, 178, 33, 90, 69, 178, 194, 85, 102, 181, 90,\n
        \  193, 167, 72, 160, 112, 223, 200, 163, 42, 70, 149, 67, 208, 25, 238,\n
        \  251, 71]\n   Encoding the signature as BASE64URL(JWS Signature) produces
        this\n   value (with line breaks for display purposes only):\n     cC4hiUPoj9Eetdgtv3hF80EGrhuB__dzERat0XF9g2VtQgr9PJbu3XOiZj5RZmh7\n
        \    AAuHIm4Bh-0Qc_lF5YKt_O8W2Fp5jujGbds9uJdbF9CUAr7t1dnZcAcQjbKBYNX4\n     BAynRFdiuB--f_nZLgrnbyTyWzO75vRK5h6xBArLIARNPvkSjtQBMHlb1L07Qe7K\n
        \    0GarZRmB_eSN9383LcOLn6_dO--xi12jzDwusC-eOkHWEsqtFZESc6BfI7noOPqv\n     hJ1phCnvWh6IeYI2w9QOYEUipUTI8np6LbgGY9Fs98rqVt5AXLIhWkWywlVmtVrB\n
        \    p0igcN_IoypGlUPQGe77Rw\n   Concatenating these values in the order Header.Payload.Signature
        with\n   period ('.') characters between the parts yields this complete JWS\n
        \  representation using the JWS Compact Serialization (with line breaks\n
        \  for display purposes only):\n     eyJhbGciOiJSUzI1NiJ9\n     .\n     eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt\n
        \    cGxlLmNvbS9pc19yb290Ijp0cnVlfQ\n     .\n     cC4hiUPoj9Eetdgtv3hF80EGrhuB__dzERat0XF9g2VtQgr9PJbu3XOiZj5RZmh7\n
        \    AAuHIm4Bh-0Qc_lF5YKt_O8W2Fp5jujGbds9uJdbF9CUAr7t1dnZcAcQjbKBYNX4\n     BAynRFdiuB--f_nZLgrnbyTyWzO75vRK5h6xBArLIARNPvkSjtQBMHlb1L07Qe7K\n
        \    0GarZRmB_eSN9383LcOLn6_dO--xi12jzDwusC-eOkHWEsqtFZESc6BfI7noOPqv\n     hJ1phCnvWh6IeYI2w9QOYEUipUTI8np6LbgGY9Fs98rqVt5AXLIhWkWywlVmtVrB\n
        \    p0igcN_IoypGlUPQGe77Rw\n"
      title: A.2.1.  Encoding
    - contents:
      - "A.2.2.  Validating\n   Since the \"alg\" Header Parameter is \"RS256\", we
        validate the RSASSA-\n   PKCS1-v1_5 SHA-256 digital signature contained in
        the JWS Signature.\n   Validating the JWS Signature is a bit different from
        the previous\n   example.  We pass the public key (n, e), the JWS Signature
        (which is\n   base64url decoded from the value encoded in the JWS representation),\n
        \  and the JWS Signing Input (which is the initial substring of the JWS\n
        \  Compact Serialization representation up until but not including the\n   second
        period character) to an RSASSA-PKCS1-v1_5 signature verifier\n   that has
        been configured to use the SHA-256 hash function.\n"
      title: A.2.2.  Validating
    title: A.2.  Example JWS Using RSASSA-PKCS1-v1_5 SHA-256
  - contents:
    - 'A.3.  Example JWS Using ECDSA P-256 SHA-256

      '
    - contents:
      - "A.3.1.  Encoding\n   The JWS Protected Header for this example differs from
        the previous\n   example because a different algorithm is being used.  The
        JWS\n   Protected Header used is:\n     {\"alg\":\"ES256\"}\n   The octets
        representing UTF8(JWS Protected Header) in this example\n   (using JSON array
        notation) are:\n   [123, 34, 97, 108, 103, 34, 58, 34, 69, 83, 50, 53, 54,
        34, 125]\n   Encoding this JWS Protected Header as BASE64URL(UTF8(JWS Protected\n
        \  Header)) gives this value:\n     eyJhbGciOiJFUzI1NiJ9\n   The JWS Payload
        used in this example, which follows, is the same as\n   in the previous examples.
        \ Since the BASE64URL(JWS Payload) value\n   will therefore be the same, its
        computation is not repeated here.\n     {\"iss\":\"joe\",\n      \"exp\":1300819380,\n
        \     \"http://example.com/is_root\":true}\n   Combining these as BASE64URL(UTF8(JWS
        Protected Header)) || '.' ||\n   BASE64URL(JWS Payload) gives this string
        (with line breaks for\n   display purposes only):\n     eyJhbGciOiJFUzI1NiJ9\n
        \    .\n     eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt\n
        \    cGxlLmNvbS9pc19yb290Ijp0cnVlfQ\n   The resulting JWS Signing Input value,
        which is the ASCII\n   representation of above string, is the following octet
        sequence:\n   [101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 70, 85, 122,
        73,\n   49, 78, 105, 74, 57, 46, 101, 121, 74, 112, 99, 51, 77, 105, 79, 105,\n
        \  74, 113, 98, 50, 85, 105, 76, 65, 48, 75, 73, 67, 74, 108, 101, 72,\n   65,
        105, 79, 106, 69, 122, 77, 68, 65, 52, 77, 84, 107, 122, 79, 68,\n   65, 115,
        68, 81, 111, 103, 73, 109, 104, 48, 100, 72, 65, 54, 76,\n   121, 57, 108,
        101, 71, 70, 116, 99, 71, 120, 108, 76, 109, 78, 118,\n   98, 83, 57, 112,
        99, 49, 57, 121, 98, 50, 57, 48, 73, 106, 112, 48,\n   99, 110, 86, 108, 102,
        81]\n   This example uses the Elliptic Curve key represented in JSON Web Key\n
        \  [JWK] format below:\n     {\"kty\":\"EC\",\n      \"crv\":\"P-256\",\n
        \     \"x\":\"f83OJ3D2xF1Bg8vub9tLe1gHMzV76e8Tus9uPHvRVEU\",\n      \"y\":\"x_FEzRu9m36HLN_tue659LNpXW6pCyStikYjKIWI5a0\",\n
        \     \"d\":\"jpsQnnGQmL-YBIffH1136cspYG6-0iY7X1fCE9-E9LI\"\n     }\n   The
        Elliptic Curve Digital Signature Algorithm (ECDSA) private part d\n   is then
        passed to an ECDSA signing function, which also takes the\n   curve type,
        P-256, the hash type, SHA-256, and the JWS Signing Input\n   as inputs.  The
        result of the digital signature is the Elliptic Curve\n   (EC) point (R, S),
        where R and S are unsigned integers.  In this\n   example, the R and S values,
        given as octet sequences representing\n   big-endian integers are:\n   +--------+----------------------------------------------------------+\n
        \  | Result | Value                                                    |\n
        \  | Name   |                                                          |\n
        \  +--------+----------------------------------------------------------+\n
        \  | R      | [14, 209, 33, 83, 121, 99, 108, 72, 60, 47, 127, 21, 88, |\n
        \  |        | 7, 212, 2, 163, 178, 40, 3, 58, 249, 124, 126, 23, 129,  |\n
        \  |        | 154, 195, 22, 158, 166, 101]                             |\n
        \  | S      | [197, 10, 7, 211, 140, 60, 112, 229, 216, 241, 45, 175,  |\n
        \  |        | 8, 74, 84, 128, 166, 101, 144, 197, 242, 147, 80, 154,   |\n
        \  |        | 143, 63, 127, 138, 131, 163, 84, 213]                    |\n
        \  +--------+----------------------------------------------------------+\n
        \  The JWS Signature is the value R || S.  Encoding the signature as\n   BASE64URL(JWS
        Signature) produces this value (with line breaks for\n   display purposes
        only):\n     DtEhU3ljbEg8L38VWAfUAqOyKAM6-Xx-F4GawxaepmXFCgfTjDxw5djxLa8ISlSA\n
        \    pmWQxfKTUJqPP3-Kg6NU1Q\n   Concatenating these values in the order Header.Payload.Signature
        with\n   period ('.') characters between the parts yields this complete JWS\n
        \  representation using the JWS Compact Serialization (with line breaks\n
        \  for display purposes only):\n     eyJhbGciOiJFUzI1NiJ9\n     .\n     eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt\n
        \    cGxlLmNvbS9pc19yb290Ijp0cnVlfQ\n     .\n     DtEhU3ljbEg8L38VWAfUAqOyKAM6-Xx-F4GawxaepmXFCgfTjDxw5djxLa8ISlSA\n
        \    pmWQxfKTUJqPP3-Kg6NU1Q\n"
      title: A.3.1.  Encoding
    - contents:
      - "A.3.2.  Validating\n   Since the \"alg\" Header Parameter is \"ES256\", we
        validate the ECDSA\n   P-256 SHA-256 digital signature contained in the JWS
        Signature.\n   Validating the JWS Signature is a bit different from the previous\n
        \  examples.  We need to split the 64 member octet sequence of the JWS\n   Signature
        (which is base64url decoded from the value encoded in the\n   JWS representation)
        into two 32 octet sequences, the first\n   representing R and the second S.
        \ We then pass the public key (x, y),\n   the signature (R, S), and the JWS
        Signing Input (which is the initial\n   substring of the JWS Compact Serialization
        representation up until\n   but not including the second period character)
        to an ECDSA signature\n   verifier that has been configured to use the P-256
        curve with the\n   SHA-256 hash function.\n"
      title: A.3.2.  Validating
    title: A.3.  Example JWS Using ECDSA P-256 SHA-256
  - contents:
    - 'A.4.  Example JWS Using ECDSA P-521 SHA-512

      '
    - contents:
      - "A.4.1.  Encoding\n   The JWS Protected Header for this example differs from
        the previous\n   example because different ECDSA curves and hash functions
        are used.\n   The JWS Protected Header used is:\n     {\"alg\":\"ES512\"}\n
        \  The octets representing UTF8(JWS Protected Header) in this example\n   (using
        JSON array notation) are:\n   [123, 34, 97, 108, 103, 34, 58, 34, 69, 83,
        53, 49, 50, 34, 125]\n   Encoding this JWS Protected Header as BASE64URL(UTF8(JWS
        Protected\n   Header)) gives this value:\n     eyJhbGciOiJFUzUxMiJ9\n   The
        JWS Payload used in this example is the ASCII string \"Payload\".\n   The
        representation of this string is the following octet sequence:\n   [80, 97,
        121, 108, 111, 97, 100]\n   Encoding this JWS Payload as BASE64URL(JWS Payload)
        gives this value:\n     UGF5bG9hZA\n   Combining these as BASE64URL(UTF8(JWS
        Protected Header)) || '.' ||\n   BASE64URL(JWS Payload) gives this string:\n
        \    eyJhbGciOiJFUzUxMiJ9.UGF5bG9hZA\n   The resulting JWS Signing Input value,
        which is the ASCII\n   representation of above string, is the following octet
        sequence:\n   [101, 121, 74, 104, 98, 71, 99, 105, 79, 105, 74, 70, 85, 122,
        85,\n   120, 77, 105, 74, 57, 46, 85, 71, 70, 53, 98, 71, 57, 104, 90, 65]\n
        \  This example uses the Elliptic Curve key represented in JSON Web Key\n
        \  [JWK] format below (with line breaks within values for display\n   purposes
        only):\n     {\"kty\":\"EC\",\n      \"crv\":\"P-521\",\n      \"x\":\"AekpBQ8ST8a8VcfVOTNl353vSrDCLLJXmPk06wTjxrrjcBpXp5EOnYG_\n
        \          NjFZ6OvLFV1jSfS9tsz4qUxcWceqwQGk\",\n      \"y\":\"ADSmRA43Z1DSNx_RvcLI87cdL07l6jQyyBXMoxVg_l2Th-x3S1WDhjDl\n
        \          y79ajL4Kkd0AZMaZmh9ubmf63e3kyMj2\",\n      \"d\":\"AY5pb7A0UFiB3RELSD64fTLOSV_jazdF7fLYyuTw8lOfRhWg6Y6rUrPA\n
        \          xerEzgdRhajnu0ferB0d53vM9mE15j2C\"\n     }\n   The ECDSA private
        part d is then passed to an ECDSA signing function,\n   which also takes the
        curve type, P-521, the hash type, SHA-512, and\n   the JWS Signing Input as
        inputs.  The result of the digital signature\n   is the EC point (R, S), where
        R and S are unsigned integers.  In this\n   example, the R and S values, given
        as octet sequences representing\n   big-endian integers are:\n   +--------+----------------------------------------------------------+\n
        \  | Result | Value                                                    |\n
        \  | Name   |                                                          |\n
        \  +--------+----------------------------------------------------------+\n
        \  | R      | [1, 220, 12, 129, 231, 171, 194, 209, 232, 135, 233,     |\n
        \  |        | 117, 247, 105, 122, 210, 26, 125, 192, 1, 217, 21, 82,   |\n
        \  |        | 91, 45, 240, 255, 83, 19, 34, 239, 71, 48, 157, 147,     |\n
        \  |        | 152, 105, 18, 53, 108, 163, 214, 68, 231, 62, 153, 150,  |\n
        \  |        | 106, 194, 164, 246, 72, 143, 138, 24, 50, 129, 223, 133, |\n
        \  |        | 206, 209, 172, 63, 237, 119, 109]                        |\n
        \  | S      | [0, 111, 6, 105, 44, 5, 41, 208, 128, 61, 152, 40, 92,   |\n
        \  |        | 61, 152, 4, 150, 66, 60, 69, 247, 196, 170, 81, 193,     |\n
        \  |        | 199, 78, 59, 194, 169, 16, 124, 9, 143, 42, 142, 131,    |\n
        \  |        | 48, 206, 238, 34, 175, 83, 203, 220, 159, 3, 107, 155,   |\n
        \  |        | 22, 27, 73, 111, 68, 68, 21, 238, 144, 229, 232, 148,    |\n
        \  |        | 188, 222, 59, 242, 103]                                  |\n
        \  +--------+----------------------------------------------------------+\n
        \  The JWS Signature is the value R || S.  Encoding the signature as\n   BASE64URL(JWS
        Signature) produces this value (with line breaks for\n   display purposes
        only):\n     AdwMgeerwtHoh-l192l60hp9wAHZFVJbLfD_UxMi70cwnZOYaRI1bKPWROc-mZZq\n
        \    wqT2SI-KGDKB34XO0aw_7XdtAG8GaSwFKdCAPZgoXD2YBJZCPEX3xKpRwcdOO8Kp\n     EHwJjyqOgzDO7iKvU8vcnwNrmxYbSW9ERBXukOXolLzeO_Jn\n
        \  Concatenating these values in the order Header.Payload.Signature with\n
        \  period ('.') characters between the parts yields this complete JWS\n   representation
        using the JWS Compact Serialization (with line breaks\n   for display purposes
        only):\n     eyJhbGciOiJFUzUxMiJ9\n     .\n     UGF5bG9hZA\n     .\n     AdwMgeerwtHoh-l192l60hp9wAHZFVJbLfD_UxMi70cwnZOYaRI1bKPWROc-mZZq\n
        \    wqT2SI-KGDKB34XO0aw_7XdtAG8GaSwFKdCAPZgoXD2YBJZCPEX3xKpRwcdOO8Kp\n     EHwJjyqOgzDO7iKvU8vcnwNrmxYbSW9ERBXukOXolLzeO_Jn\n"
      title: A.4.1.  Encoding
    - contents:
      - "A.4.2.  Validating\n   Since the \"alg\" Header Parameter is \"ES512\", we
        validate the ECDSA\n   P-521 SHA-512 digital signature contained in the JWS
        Signature.\n   Validating this JWS Signature is very similar to the previous\n
        \  example.  We need to split the 132-member octet sequence of the JWS\n   Signature
        into two 66-octet sequences, the first representing R and\n   the second S.
        \ We then pass the public key (x, y), the signature (R,\n   S), and the JWS
        Signing Input to an ECDSA signature verifier that has\n   been configured
        to use the P-521 curve with the SHA-512 hash\n   function.\n"
      title: A.4.2.  Validating
    title: A.4.  Example JWS Using ECDSA P-521 SHA-512
  - contents:
    - "A.5.  Example Unsecured JWS\n   The following example JWS Protected Header
      declares that the encoded\n   object is an Unsecured JWS:\n     {\"alg\":\"none\"}\n
      \  Encoding this JWS Protected Header as BASE64URL(UTF8(JWS Protected\n   Header))
      gives this value:\n     eyJhbGciOiJub25lIn0\n   The JWS Payload used in this
      example, which follows, is the same as\n   in the previous examples.  Since
      the BASE64URL(JWS Payload) value\n   will therefore be the same, its computation
      is not repeated here.\n     {\"iss\":\"joe\",\n      \"exp\":1300819380,\n      \"http://example.com/is_root\":true}\n
      \  The JWS Signature is the empty octet string and BASE64URL(JWS\n   Signature)
      is the empty string.\n   Concatenating these values in the order Header.Payload.Signature
      with\n   period ('.') characters between the parts yields this complete JWS\n
      \  representation using the JWS Compact Serialization (with line breaks\n   for
      display purposes only):\n     eyJhbGciOiJub25lIn0\n     .\n     eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt\n
      \    cGxlLmNvbS9pc19yb290Ijp0cnVlfQ\n     .\n"
    title: A.5.  Example Unsecured JWS
  - contents:
    - "A.6.  Example JWS Using General JWS JSON Serialization\n   This section contains
      an example using the general JWS JSON\n   Serialization syntax.  This example
      demonstrates the capability for\n   conveying multiple digital signatures and/or
      MACs for the same\n   payload.\n   The JWS Payload used in this example is the
      same as that used in the\n   examples in Appendix A.2 and Appendix A.3 (with
      line breaks for\n   display purposes only):\n     eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGFt\n
      \    cGxlLmNvbS9pc19yb290Ijp0cnVlfQ\n   Two digital signatures are used in this
      example: the first using\n   RSASSA-PKCS1-v1_5 SHA-256 and the second using
      ECDSA P-256 SHA-256.\n   For the first, the JWS Protected Header and key are
      the same as in\n   Appendix A.2, resulting in the same JWS Signature value;
      therefore,\n   its computation is not repeated here.  For the second, the JWS\n
      \  Protected Header and key are the same as in Appendix A.3, resulting\n   in
      the same JWS Signature value; therefore, its computation is not\n   repeated
      here.\n"
    - contents:
      - "A.6.1.  JWS Per-Signature Protected Headers\n   The JWS Protected Header
        value used for the first signature is:\n     {\"alg\":\"RS256\"}\n   Encoding
        this JWS Protected Header as BASE64URL(UTF8(JWS Protected\n   Header)) gives
        this value:\n     eyJhbGciOiJSUzI1NiJ9\n   The JWS Protected Header value
        used for the second signature is:\n     {\"alg\":\"ES256\"}\n   Encoding this
        JWS Protected Header as BASE64URL(UTF8(JWS Protected\n   Header)) gives this
        value:\n     eyJhbGciOiJFUzI1NiJ9\n"
      title: A.6.1.  JWS Per-Signature Protected Headers
    - contents:
      - "A.6.2.  JWS Per-Signature Unprotected Headers\n   Key ID values are supplied
        for both keys using per-signature Header\n   Parameters.  The two JWS Unprotected
        Header values used to represent\n   these key IDs are:\n     {\"kid\":\"2010-12-29\"}\n
        \  and\n     {\"kid\":\"e9bc097a-ce51-4036-9562-d2ade882db0d\"}\n"
      title: A.6.2.  JWS Per-Signature Unprotected Headers
    - contents:
      - "A.6.3.  Complete JOSE Header Values\n   Combining the JWS Protected Header
        and JWS Unprotected Header values\n   supplied, the JOSE Header values used
        for the first and second\n   signatures, respectively, are:\n     {\"alg\":\"RS256\",\n
        \     \"kid\":\"2010-12-29\"}\n   and\n     {\"alg\":\"ES256\",\n      \"kid\":\"e9bc097a-ce51-4036-9562-d2ade882db0d\"}\n"
      title: A.6.3.  Complete JOSE Header Values
    - contents:
      - "A.6.4.  Complete JWS JSON Serialization Representation\n   The complete JWS
        JSON Serialization for these values is as follows\n   (with line breaks within
        values for display purposes only):\n     {\n      \"payload\":\n       \"eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGF\n
        \       tcGxlLmNvbS9pc19yb290Ijp0cnVlfQ\",\n      \"signatures\":[\n       {\"protected\":\"eyJhbGciOiJSUzI1NiJ9\",\n
        \       \"header\":\n         {\"kid\":\"2010-12-29\"},\n        \"signature\":\n
        \        \"cC4hiUPoj9Eetdgtv3hF80EGrhuB__dzERat0XF9g2VtQgr9PJbu3XOiZj5RZ\n
        \         mh7AAuHIm4Bh-0Qc_lF5YKt_O8W2Fp5jujGbds9uJdbF9CUAr7t1dnZcAcQjb\n
        \         KBYNX4BAynRFdiuB--f_nZLgrnbyTyWzO75vRK5h6xBArLIARNPvkSjtQBMHl\n
        \         b1L07Qe7K0GarZRmB_eSN9383LcOLn6_dO--xi12jzDwusC-eOkHWEsqtFZES\n
        \         c6BfI7noOPqvhJ1phCnvWh6IeYI2w9QOYEUipUTI8np6LbgGY9Fs98rqVt5AX\n
        \         LIhWkWywlVmtVrBp0igcN_IoypGlUPQGe77Rw\"},\n       {\"protected\":\"eyJhbGciOiJFUzI1NiJ9\",\n
        \       \"header\":\n         {\"kid\":\"e9bc097a-ce51-4036-9562-d2ade882db0d\"},\n
        \       \"signature\":\n         \"DtEhU3ljbEg8L38VWAfUAqOyKAM6-Xx-F4GawxaepmXFCgfTjDxw5djxLa8IS\n
        \         lSApmWQxfKTUJqPP3-Kg6NU1Q\"}]\n     }\n"
      title: A.6.4.  Complete JWS JSON Serialization Representation
    title: A.6.  Example JWS Using General JWS JSON Serialization
  - contents:
    - "A.7.  Example JWS Using Flattened JWS JSON Serialization\n   This section contains
      an example using the flattened JWS JSON\n   Serialization syntax.  This example
      demonstrates the capability for\n   conveying a single digital signature or
      MAC in a flattened JSON\n   structure.\n   The values in this example are the
      same as those in the second\n   signature of the previous example in Appendix
      A.6.\n   The complete JWS JSON Serialization for these values is as follows\n
      \  (with line breaks within values for display purposes only):\n     {\n      \"payload\":\n
      \      \"eyJpc3MiOiJqb2UiLA0KICJleHAiOjEzMDA4MTkzODAsDQogImh0dHA6Ly9leGF\n        tcGxlLmNvbS9pc19yb290Ijp0cnVlfQ\",\n
      \     \"protected\":\"eyJhbGciOiJFUzI1NiJ9\",\n      \"header\":\n       {\"kid\":\"e9bc097a-ce51-4036-9562-d2ade882db0d\"},\n
      \     \"signature\":\n       \"DtEhU3ljbEg8L38VWAfUAqOyKAM6-Xx-F4GawxaepmXFCgfTjDxw5djxLa8IS\n
      \       lSApmWQxfKTUJqPP3-Kg6NU1Q\"\n     }\n"
    title: A.7.  Example JWS Using Flattened JWS JSON Serialization
  title: Appendix A.  JWS Examples
- contents:
  - "Appendix B.  \"x5c\" (X.509 Certificate Chain) Example\n   The JSON array below
    is an example of a certificate chain that could\n   be used as the value of an
    \"x5c\" (X.509 certificate chain) Header\n   Parameter, per Section 4.1.6 (with
    line breaks within values for\n   display purposes only):\n     [\"MIIE3jCCA8agAwIBAgICAwEwDQYJKoZIhvcNAQEFBQAwYzELMAkGA1UEBhMCVVM\n
    \      xITAfBgNVBAoTGFRoZSBHbyBEYWRkeSBHcm91cCwgSW5jLjExMC8GA1UECxMoR2\n       8gRGFkZHkgQ2xhc3MgMiBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTAeFw0wNjExM\n
    \      TYwMTU0MzdaFw0yNjExMTYwMTU0MzdaMIHKMQswCQYDVQQGEwJVUzEQMA4GA1UE\n       CBMHQXJpem9uYTETMBEGA1UEBxMKU2NvdHRzZGFsZTEaMBgGA1UEChMRR29EYWR\n
    \      keS5jb20sIEluYy4xMzAxBgNVBAsTKmh0dHA6Ly9jZXJ0aWZpY2F0ZXMuZ29kYW\n       RkeS5jb20vcmVwb3NpdG9yeTEwMC4GA1UEAxMnR28gRGFkZHkgU2VjdXJlIENlc\n
    \      nRpZmljYXRpb24gQXV0aG9yaXR5MREwDwYDVQQFEwgwNzk2OTI4NzCCASIwDQYJ\n       KoZIhvcNAQEBBQADggEPADCCAQoCggEBAMQt1RWMnCZM7DI161+4WQFapmGBWTt\n
    \      wY6vj3D3HKrjJM9N55DrtPDAjhI6zMBS2sofDPZVUBJ7fmd0LJR4h3mUpfjWoqV\n       Tr9vcyOdQmVZWt7/v+WIbXnvQAjYwqDL1CBM6nPwT27oDyqu9SoWlm2r4arV3aL\n
    \      GbqGmu75RpRSgAvSMeYddi5Kcju+GZtCpyz8/x4fKL4o/K1w/O5epHBp+YlLpyo\n       7RJlbmr2EkRTcDCVw5wrWCs9CHRK8r5RsL+H0EwnWGu1NcWdrxcx+AuP7q2BNgW\n
    \      JCJjPOq8lh8BJ6qf9Z/dFjpfMFDniNoW1fho3/Rb2cRGadDAW/hOUoz+EDU8CAw\n       EAAaOCATIwggEuMB0GA1UdDgQWBBT9rGEyk2xF1uLuhV+auud2mWjM5zAfBgNVH\n
    \      SMEGDAWgBTSxLDSkdRMEXGzYcs9of7dqGrU4zASBgNVHRMBAf8ECDAGAQH/AgEA\n       MDMGCCsGAQUFBwEBBCcwJTAjBggrBgEFBQcwAYYXaHR0cDovL29jc3AuZ29kYWR\n
    \      keS5jb20wRgYDVR0fBD8wPTA7oDmgN4Y1aHR0cDovL2NlcnRpZmljYXRlcy5nb2\n       RhZGR5LmNvbS9yZXBvc2l0b3J5L2dkcm9vdC5jcmwwSwYDVR0gBEQwQjBABgRVH\n
    \      SAAMDgwNgYIKwYBBQUHAgEWKmh0dHA6Ly9jZXJ0aWZpY2F0ZXMuZ29kYWRkeS5j\n       b20vcmVwb3NpdG9yeTAOBgNVHQ8BAf8EBAMCAQYwDQYJKoZIhvcNAQEFBQADggE\n
    \      BANKGwOy9+aG2Z+5mC6IGOgRQjhVyrEp0lVPLN8tESe8HkGsz2ZbwlFalEzAFPI\n       UyIXvJxwqoJKSQ3kbTJSMUA2fCENZvD117esyfxVgqwcSeIaha86ykRvOe5GPLL\n
    \      5CkKSkB2XIsKd83ASe8T+5o0yGPwLPk9Qnt0hCqU7S+8MxZC9Y7lhyVJEnfzuz9\n       p0iRFEUOOjZv2kWzRaJBydTXRE4+uXR21aITVSzGh6O1mawGhId/dQb8vxRMDsx\n
    \      uxN89txJx9OjxUUAiKEngHUuHqDTMBqLdElrRhjZkAzVvb3du6/KFUJheqwNTrZ\n       EjYx8WnM25sgVjOuH0aBsXBTWVU+4=\",\n
    \     \"MIIE+zCCBGSgAwIBAgICAQ0wDQYJKoZIhvcNAQEFBQAwgbsxJDAiBgNVBAcTG1Z\n       hbGlDZXJ0IFZhbGlkYXRpb24gTmV0d29yazEXMBUGA1UEChMOVmFsaUNlcnQsIE\n
    \      luYy4xNTAzBgNVBAsTLFZhbGlDZXJ0IENsYXNzIDIgUG9saWN5IFZhbGlkYXRpb\n       24gQXV0aG9yaXR5MSEwHwYDVQQDExhodHRwOi8vd3d3LnZhbGljZXJ0LmNvbS8x\n
    \      IDAeBgkqhkiG9w0BCQEWEWluZm9AdmFsaWNlcnQuY29tMB4XDTA0MDYyOTE3MDY\n       yMFoXDTI0MDYyOTE3MDYyMFowYzELMAkGA1UEBhMCVVMxITAfBgNVBAoTGFRoZS\n
    \      BHbyBEYWRkeSBHcm91cCwgSW5jLjExMC8GA1UECxMoR28gRGFkZHkgQ2xhc3MgM\n       iBDZXJ0aWZpY2F0aW9uIEF1dGhvcml0eTCCASAwDQYJKoZIhvcNAQEBBQADggEN\n
    \      ADCCAQgCggEBAN6d1+pXGEmhW+vXX0iG6r7d/+TvZxz0ZWizV3GgXne77ZtJ6XC\n       APVYYYwhv2vLM0D9/AlQiVBDYsoHUwHU9S3/Hd8M+eKsaA7Ugay9qK7HFiH7Eux\n
    \      6wwdhFJ2+qN1j3hybX2C32qRe3H3I2TqYXP2WYktsqbl2i/ojgC95/5Y0V4evLO\n       tXiEqITLdiOr18SPaAIBQi2XKVlOARFmR6jYGB0xUGlcmIbYsUfb18aQr4CUWWo\n
    \      riMYavx4A6lNf4DD+qta/KFApMoZFv6yyO9ecw3ud72a9nmYvLEHZ6IVDd2gWMZ\n       Eewo+YihfukEHU1jPEX44dMX4/7VpkI+EdOqXG68CAQOjggHhMIIB3TAdBgNVHQ\n
    \      4EFgQU0sSw0pHUTBFxs2HLPaH+3ahq1OMwgdIGA1UdIwSByjCBx6GBwaSBvjCBu\n       zEkMCIGA1UEBxMbVmFsaUNlcnQgVmFsaWRhdGlvbiBOZXR3b3JrMRcwFQYDVQQK\n
    \      Ew5WYWxpQ2VydCwgSW5jLjE1MDMGA1UECxMsVmFsaUNlcnQgQ2xhc3MgMiBQb2x\n       pY3kgVmFsaWRhdGlvbiBBdXRob3JpdHkxITAfBgNVBAMTGGh0dHA6Ly93d3cudm\n
    \      FsaWNlcnQuY29tLzEgMB4GCSqGSIb3DQEJARYRaW5mb0B2YWxpY2VydC5jb22CA\n       QEwDwYDVR0TAQH/BAUwAwEB/zAzBggrBgEFBQcBAQQnMCUwIwYIKwYBBQUHMAGG\n
    \      F2h0dHA6Ly9vY3NwLmdvZGFkZHkuY29tMEQGA1UdHwQ9MDswOaA3oDWGM2h0dHA\n       6Ly9jZXJ0aWZpY2F0ZXMuZ29kYWRkeS5jb20vcmVwb3NpdG9yeS9yb290LmNybD\n
    \      BLBgNVHSAERDBCMEAGBFUdIAAwODA2BggrBgEFBQcCARYqaHR0cDovL2NlcnRpZ\n       mljYXRlcy5nb2RhZGR5LmNvbS9yZXBvc2l0b3J5MA4GA1UdDwEB/wQEAwIBBjAN\n
    \      BgkqhkiG9w0BAQUFAAOBgQC1QPmnHfbq/qQaQlpE9xXUhUaJwL6e4+PrxeNYiY+\n       Sn1eocSxI0YGyeR+sBjUZsE4OWBsUs5iB0QQeyAfJg594RAoYC5jcdnplDQ1tgM\n
    \      QLARzLrUc+cb53S8wGd9D0VmsfSxOaFIqII6hR8INMqzW/Rn453HWkrugp++85j\n       09VZw==\",\n
    \     \"MIIC5zCCAlACAQEwDQYJKoZIhvcNAQEFBQAwgbsxJDAiBgNVBAcTG1ZhbGlDZXJ\n       0IFZhbGlkYXRpb24gTmV0d29yazEXMBUGA1UEChMOVmFsaUNlcnQsIEluYy4xNT\n
    \      AzBgNVBAsTLFZhbGlDZXJ0IENsYXNzIDIgUG9saWN5IFZhbGlkYXRpb24gQXV0a\n       G9yaXR5MSEwHwYDVQQDExhodHRwOi8vd3d3LnZhbGljZXJ0LmNvbS8xIDAeBgkq\n
    \      hkiG9w0BCQEWEWluZm9AdmFsaWNlcnQuY29tMB4XDTk5MDYyNjAwMTk1NFoXDTE\n       5MDYyNjAwMTk1NFowgbsxJDAiBgNVBAcTG1ZhbGlDZXJ0IFZhbGlkYXRpb24gTm\n
    \      V0d29yazEXMBUGA1UEChMOVmFsaUNlcnQsIEluYy4xNTAzBgNVBAsTLFZhbGlDZ\n       XJ0IENsYXNzIDIgUG9saWN5IFZhbGlkYXRpb24gQXV0aG9yaXR5MSEwHwYDVQQD\n
    \      ExhodHRwOi8vd3d3LnZhbGljZXJ0LmNvbS8xIDAeBgkqhkiG9w0BCQEWEWluZm9\n       AdmFsaWNlcnQuY29tMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDOOnHK5a\n
    \      vIWZJV16vYdA757tn2VUdZZUcOBVXc65g2PFxTXdMwzzjsvUGJ7SVCCSRrCl6zf\n       N1SLUzm1NZ9WlmpZdRJEy0kTRxQb7XBhVQ7/nHk01xC+YDgkRoKWzk2Z/M/VXwb\n
    \      P7RfZHM047QSv4dk+NoS/zcnwbNDu+97bi5p9wIDAQABMA0GCSqGSIb3DQEBBQU\n       AA4GBADt/UG9vUJSZSWI4OB9L+KXIPqeCgfYrx+jFzug6EILLGACOTb2oWH+heQ\n
    \      C1u+mNr0HZDzTuIYEZoDJJKPTEjlbVUjP9UNV+mWwD5MlM/Mtsq2azSiGM5bUMM\n       j4QssxsodyamEwCW/POuZ6lcg5Ktz885hZo+L7tdEy8W9ViH0Pd\"]\n"
  title: Appendix B.  "x5c" (X.509 Certificate Chain) Example
- contents:
  - "Appendix C.  Notes on Implementing base64url Encoding without Padding\n   This
    appendix describes how to implement base64url encoding and\n   decoding functions
    without padding based upon standard base64\n   encoding and decoding functions
    that do use padding.\n   To be concrete, example C# code implementing these functions
    is shown\n   below.  Similar code could be used in other languages.\n     static
    string base64urlencode(byte [] arg)\n     {\n       string s = Convert.ToBase64String(arg);
    // Regular base64 encoder\n       s = s.Split('=')[0]; // Remove any trailing
    '='s\n       s = s.Replace('+', '-'); // 62nd char of encoding\n       s = s.Replace('/',
    '_'); // 63rd char of encoding\n       return s;\n     }\n     static byte []
    base64urldecode(string arg)\n     {\n       string s = arg;\n       s = s.Replace('-',
    '+'); // 62nd char of encoding\n       s = s.Replace('_', '/'); // 63rd char of
    encoding\n       switch (s.Length % 4) // Pad with trailing '='s\n       {\n         case
    0: break; // No pad chars in this case\n         case 2: s += \"==\"; break; //
    Two pad chars\n         case 3: s += \"=\"; break; // One pad char\n         default:
    throw new System.Exception(\n           \"Illegal base64url string!\");\n       }\n
    \      return Convert.FromBase64String(s); // Standard base64 decoder\n     }\n
    \  As per the example code above, the number of '=' padding characters\n   that
    needs to be added to the end of a base64url-encoded string\n   without padding
    to turn it into one with padding is a deterministic\n   function of the length
    of the encoded string.  Specifically, if the\n   length mod 4 is 0, no padding
    is added; if the length mod 4 is 2, two\n   '=' padding characters are added;
    if the length mod 4 is 3, one '='\n   padding character is added; if the length
    mod 4 is 1, the input is\n   malformed.\n   An example correspondence between
    unencoded and encoded values\n   follows.  The octet sequence below encodes into
    the string below,\n   which when decoded, reproduces the octet sequence.\n   3
    236 255 224 193\n   A-z_4ME\n"
  title: Appendix C.  Notes on Implementing base64url Encoding without Padding
- contents:
  - "Appendix D.  Notes on Key Selection\n   This appendix describes a set of possible
    algorithms for selecting\n   the key to be used to validate the digital signature
    or MAC of a JWS\n   or for selecting the key to be used to decrypt a JWE.  This
    guidance\n   describes a family of possible algorithms rather than a single\n
    \  algorithm, because in different contexts, not all the sources of keys\n   will
    be used, they can be tried in different orders, and sometimes\n   not all the
    collected keys will be tried; hence, different algorithms\n   will be used in
    different application contexts.\n   The steps below are described for illustration
    purposes only;\n   specific applications can and are likely to use different algorithms\n
    \  or perform some of the steps in different orders.  Specific\n   applications
    will frequently have a much simpler method of\n   determining the keys to use,
    as there may be one or two key selection\n   methods that are profiled for the
    application's use.  This appendix\n   supplements the normative information on
    key location in Section 6.\n   These algorithms include the following steps.  Note
    that the steps\n   can be performed in any order and do not need to be treated
    as\n   distinct.  For example, keys can be tried as soon as they are found,\n
    \  rather than collecting all the keys before trying any.\n   1.  Collect the
    set of potentially applicable keys.  Sources of keys\n       may include:\n       *
    \ Keys supplied by the application protocol being used.\n       *  Keys referenced
    by the \"jku\" (JWK Set URL) Header Parameter.\n       *  The key provided by
    the \"jwk\" (JSON Web Key) Header Parameter.\n       *  The key referenced by
    the \"x5u\" (X.509 URL) Header Parameter.\n       *  The key provided by the \"x5c\"
    (X.509 certificate chain) Header\n          Parameter.\n       *  Other applicable
    keys available to the application.\n       The order for collecting and trying
    keys from different key\n       sources is typically application dependent.  For
    example,\n       frequently, all keys from a one set of locations, such as local\n
    \      caches, will be tried before collecting and trying keys from\n       other
    locations.\n   2.  Filter the set of collected keys.  For instance, some\n       applications
    will use only keys referenced by \"kid\" (key ID) or\n       \"x5t\" (X.509 certificate
    SHA-1 thumbprint) parameters.  If the\n       application uses the JWK \"alg\"
    (algorithm), \"use\" (public key\n       use), or \"key_ops\" (key operations)
    parameters, keys with\n       inappropriate values of those parameters would be
    excluded.\n       Additionally, keys might be filtered to include or exclude keys\n
    \      with certain other member values in an application-specific\n       manner.
    \ For some applications, no filtering will be applied.\n   3.  Order the set of
    collected keys.  For instance, keys referenced\n       by \"kid\" (key ID) or
    \"x5t\" (X.509 certificate SHA-1 thumbprint)\n       parameters might be tried
    before keys with neither of these\n       values.  Likewise, keys with certain
    member values might be\n       ordered before keys with other member values.  For
    some\n       applications, no ordering will be applied.\n   4.  Make trust decisions
    about the keys.  Signatures made with keys\n       not meeting the application's
    trust criteria would not be\n       accepted.  Such criteria might include, but
    is not limited to,\n       the source of the key, whether the TLS certificate
    validates for\n       keys retrieved from URLs, whether a key in an X.509 certificate\n
    \      is backed by a valid certificate chain, and other information\n       known
    by the application.\n   5.  Attempt signature or MAC validation for a JWS or decryption
    of a\n       JWE with some or all of the collected and possibly filtered and/\n
    \      or ordered keys.  A limit on the number of keys to be tried might\n       be
    applied.  This process will normally terminate following a\n       successful
    validation or decryption.\n   Note that it is reasonable for some applications
    to perform signature\n   or MAC validation prior to making a trust decision about
    a key, since\n   keys for which the validation fails need no trust decision.\n"
  title: Appendix D.  Notes on Key Selection
- contents:
  - "Appendix E.  Negative Test Case for \"crit\" Header Parameter\n   Conforming
    implementations must reject input containing critical\n   extensions that are
    not understood or cannot be processed.  The\n   following JWS must be rejected
    by all implementations, because it\n   uses an extension Header Parameter name
    \"http://example.invalid/\n   UNDEFINED\" that they do not understand.  Any other
    similar input, in\n   which the use of the value \"http://example.invalid/UNDEFINED\"
    is\n   substituted for any other Header Parameter name not understood by the\n
    \  implementation, must also be rejected.\n   The JWS Protected Header value for
    this JWS is:\n     {\"alg\":\"none\",\n      \"crit\":[\"http://example.invalid/UNDEFINED\"],\n
    \     \"http://example.invalid/UNDEFINED\":true\n     }\n   The complete JWS that
    must be rejected is as follows (with line\n   breaks for display purposes only):\n
    \    eyJhbGciOiJub25lIiwNCiAiY3JpdCI6WyJodHRwOi8vZXhhbXBsZS5jb20vVU5ERU\n     ZJTkVEIl0sDQogImh0dHA6Ly9leGFtcGxlLmNvbS9VTkRFRklORUQiOnRydWUNCn0.\n
    \    RkFJTA.\n"
  title: Appendix E.  Negative Test Case for "crit" Header Parameter
- contents:
  - "Appendix F.  Detached Content\n   In some contexts, it is useful to integrity-protect
    content that is\n   not itself contained in a JWS.  One way to do this is to create
    a JWS\n   in the normal fashion using a representation of the content as the\n
    \  payload but then delete the payload representation from the JWS and\n   send
    this modified object to the recipient rather than the JWS.  When\n   using the
    JWS Compact Serialization, the deletion is accomplished by\n   replacing the second
    field (which contains BASE64URL(JWS Payload))\n   value with the empty string;
    when using the JWS JSON Serialization,\n   the deletion is accomplished by deleting
    the \"payload\" member.  This\n   method assumes that the recipient can reconstruct
    the exact payload\n   used in the JWS.  To use the modified object, the recipient\n
    \  reconstructs the JWS by re-inserting the payload representation into\n   the
    modified object and uses the resulting JWS in the usual manner.\n   Note that
    this method needs no support from JWS libraries, as\n   applications can use this
    method by modifying the inputs and outputs\n   of standard JWS libraries.\n"
  title: Appendix F.  Detached Content
- contents:
  - "Acknowledgements\n   Solutions for signing JSON content were previously explored
    by Magic\n   Signatures [MagicSignatures], JSON Simple Sign [JSS], and Canvas\n
    \  Applications [CanvasApp], all of which influenced this document.\n   Thanks
    to Axel Nennker for his early implementation and feedback on\n   the JWS and JWE
    specifications.\n   This specification is the work of the JOSE working group,
    which\n   includes dozens of active and dedicated participants.  In particular,\n
    \  the following individuals contributed ideas, feedback, and wording\n   that
    influenced this specification:\n   Dirk Balfanz, Richard Barnes, Brian Campbell,
    Alissa Cooper, Breno de\n   Medeiros, Stephen Farrell, Yaron Y. Goland, Dick Hardt,
    Joe\n   Hildebrand, Jeff Hodges, Russ Housley, Edmund Jay, Tero Kivinen, Ben\n
    \  Laurie, Ted Lemon, James Manger, Matt Miller, Kathleen Moriarty, Tony\n   Nadalin,
    Hideki Nara, Axel Nennker, John Panzer, Ray Polk, Emmanuel\n   Raviart, Eric Rescorla,
    Pete Resnick, Jim Schaad, Paul Tarjan, Hannes\n   Tschofenig, and Sean Turner.\n
    \  Jim Schaad and Karen O'Donoghue chaired the JOSE working group and\n   Sean
    Turner, Stephen Farrell, and Kathleen Moriarty served as\n   Security Area Directors
    during the creation of this specification.\n"
  title: Acknowledgements
- contents:
  - "Authors' Addresses\n   Michael B. Jones\n   Microsoft\n   EMail: mbj@microsoft.com\n
    \  URI:   http://self-issued.info/\n   John Bradley\n   Ping Identity\n   EMail:
    ve7jtb@ve7jtb.com\n   URI:   http://www.thread-safe.com/\n   Nat Sakimura\n   Nomura
    Research Institute\n   EMail: n-sakimura@nri.co.jp\n   URI:   http://nat.sakimura.org/\n"
  title: Authors' Addresses
