- title: __initial_text__
  contents:
  - '                    GPS-Based Addressing and Routing

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  This memo does not specify an Internet standard of any\n   kind.\
    \  Discussion and suggestions for improvement are requested.\n   Distribution\
    \ of this memo is unlimited.\n   This document describes a possible experiment\
    \ with geographic\n   addresses.  It uses several specific IP addresses and domain\
    \ names in\n   the discussion as concrete examples to aid in understanding the\n\
    \   concepts.  Please note that these addresses and names are not\n   registered,\
    \ assigned, allocated, or delegated to the use suggested\n   here.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.      Introduction......................................\
    \    2\n   1b.             General Architecture......................    3\n \
    \  1c.             Scenarios of Usage: Interface Issues......    3\n   2.    \
    \  Addressing Model..................................    4\n   2a.           \
    \  Using GPS for Destination Addresses.......    5\n   3.      Routing...........................................\
    \    7\n   3a.              GPS Multicast Routing Scheme (GPSM)......    7\n \
    \  3a-i.                   Multicast Trees...................    8\n   3a-ii.\
    \                  Determining the GPS Multicast\n                           Addressing........................\
    \   10\n   3a-iii.                 Building Multicast Trees..........   11\n \
    \  3a-iv.                  Routing...........................   12\n   3a-v. \
    \                  DNS Issues........................   12\n   3a-vi.        \
    \          Estimations.......................   12\n   3b.              \"Last\
    \ Mile\"  Routing.....................   13\n   3b-i.                   Application\
    \ Level Filtering.......   13\n   3b-ii.                  Multicast Filtering...............\
    \   13\n   3b-iii.                 Computers on Fixed Networks.......   14\n \
    \  3c.              Geometric Routing Scheme (GEO)...........   14\n   3c-i. \
    \                  Routing Overview..................   14\n   3c-ii.        \
    \          Supporting Long-Duration GPScasts.   16\n   3c-iii.               \
    \  Discovering A Router's Service Area  17\n   3c-iv.                  Hierarchical\
    \ Router Structure and\n                           Multicast Groups..................\
    \   18\n   3c-v.                   Routing Optimizations.............   19\n \
    \  3c-vi.                  Router-Failure Recovery Scheme....   19\n   3c-vii.\
    \                 Domain Name Service Issues........   20\n   4.      Router Daemon\
    \ and Host Library....................   21\n   4a.             GPS Address Library\
    \ - SendToGPS().........   21\n   4b.             Establishing A Default GPS Router.........\
    \   22\n   4c.             GPSRouteD.................................   22\n \
    \  4c-i.                  Configuration......................   23\n   4d.   \
    \          Multicast Address Resolution Protocol (MARP) 23\n   4e.           \
    \  Internet GPS Management Protocol (IGPSMP).   24\n   5.      Working Without\
    \ GPS Information...................   25\n   5a.             Users Without GPS\
    \ Modules.................   25\n   5b.             Buildings block GPS radio\
    \ frequencies\n                   What then?................................ \
    \  25\n   6.      Application Layer Solution........................   25\n  \
    \ 7.      Reliability.......................................   26\n   8.     \
    \ Security Considerations...........................   27\n   9.      References........................................\
    \   27\n   10.     Authors' Addresses................................   27\n"
- title: 1.      Introduction
  contents:
  - "1.      Introduction\n   In the near future GPS will be widely used allowing\
    \ a broad variety\n   of location dependent services such as direction giving,\
    \ navigation,\n   etc. In this document we propose a family of protocols and addressing\n\
    \   methods to integrate GPS into the Internet Protocol to enable the\n   creation\
    \ of location dependent services such as:\n     o     Multicasting selectively\
    \ only to specific geographical\n           regions defined by latitude and longitude.\
    \ For example,\n           sending an emergency message to everyone who is currently\n\
    \           in a specific area, such as a building or train station.\n     o \
    \    Providing a given service only to clients who are within a\n           certain\
    \ geographic range from the server (which may be mobile\n           itself), say\
    \ within 2 miles.\n     o     Advertising a given service in a range restricted\
    \ way, say,\n           within 2 miles from the server,\n     o     Providing\
    \ contiguous information services for mobile users\n           when information\
    \ depends on the user's location. In\n           particular providing location\
    \ dependent book-marks, which\n           provides the user with any important\
    \ information which\n           happens to be local (within a certain range) possibly\n\
    \           including other mobile servers.\n   The solutions which we present\
    \ are flexible (scalable) in terms of\n   the target accuracy of the GPS. We also\
    \ discuss cases when GPS cannot\n   be used (like inside buildings).\n   The main\
    \ challenge is to integrate the concept of physical location\n   into the current\
    \ design of the Internet which relies on logical\n   addressing.  We see the following\
    \ general families of solutions:\n      a) Unicast IP routing extended to deal\
    \ with GPS addresses\n      b) GPS-Multicast solution\n      c) Application Layer\
    \ Solution using extended DNS\n   The first two solutions are presented in this\
    \ memo. We only sketch\n   the third solution.\n"
- title: 1b. General Architecture
  contents:
  - "1b. General Architecture\n   We will assume a general cellular architecture with\
    \ base stations\n   called Mobile Support Stations (MSS). We will consider a wide\
    \ variety\n   of cells, including outdoor and indoor cells. We will discuss both\n\
    \   cases when the mobile client has a GPS card on his machine and cases\n   when\
    \ the GPS card does not work (i.e. - inside buildings).\n   We will assume that\
    \ each MSS covers a cell with a well defined range\n   specified as a polygon\
    \ of spatial coordinates and that the MSS is\n   aware of its own range.\n"
- title: 1c. Scenarios of Usage and Interface Issues
  contents:
  - "1c. Scenarios of Usage and Interface Issues\n   Below, we list some possible\
    \ scenarios of usage for the geographic\n   messaging.\n   Consider an example\
    \ situation, of an area of land near a river.\n   During a severe rain storm,\
    \ the local authorities may wish to send a\n   flood warning to all people living\
    \ within a hundred meters of the\n   river.\n   For the interface to such messaging\
    \ system we propose to use a zoom-\n   able map similar to the U.S. Census Bureau's\
    \ Tiger Map Service.  This\n   map would allow a user to view a geographical area\
    \ at varying degrees\n   of magnitude.  He could then use a pointing device, such\
    \ as a mouse,\n   to draw a bounding polygon around the area which will receive\
    \ the\n   message to be sent.  The computer would then translate the drawn\n \
    \  polygon into GPS coordinates and use those coordinates when sending\n   and\
    \ routing the message.  Geographical regions specified using this\n   zoom-able\
    \ map could be stored and recalled at a later time.  This\n   zoom-able map is\
    \ analogous to the IP address books found in many\n   email programs.\n   To continue\
    \ with the above example, local officials would call up a\n   map containing the\
    \ river in danger of overflowing.  They would then\n   hand-draw a bounding polygon\
    \ around all of the areas at least a\n   hundred yards from the river.  They would\
    \ specify this to be the\n   destination for a flood warning email to all residents\
    \ in the area.\n   The warning email would then be sent. Similar applications\
    \ include\n   traffic management (for example, reaching vehicles which are stuck\
    \ in\n   traffic) and security enforcement.\n   Other applications involve general\
    \ client server applications where\n   servers are selected on the basis of the\
    \ geographic distance. For\n   example, one may be interested in finding out all\
    \ car dealers within\n   2 miles from his/her location.  This leads to an extension\
    \ of the Web\n   concept in which location and distance play important roles in\n\
    \   selecting information. We are currently in the process of\n   implementing\
    \ location dependent book-marks (hot lists) in which pages\n   associated with\
    \ static and mobile servers which are present within a\n   certain distance from\
    \ the client are displayed on the client's\n   terminal.\n"
- title: 2.      Addressing Model
  contents:
  - "2.      Addressing Model\n   Two-dimensional GPS positioning offers latitude\
    \ and longitude\n   information as a four dimensional vector:\n              <Direction,\
    \ hours, minutes, seconds>\n   where Direction is one of the four basic values:\
    \ N, S, W, E; hours\n   ranges from 0 to 180 (for latitude) and 0 to 90 for longitude,\
    \ and,\n   finally, minutes and seconds range from 0 to 60.\n   Thus <W, 122,\
    \ 56, 89> is an example of longitude and <N, 85, 66, 43>\n   is an example of\
    \ latitude.\n   Four bytes of addressing space (one byte for each of the four\n\
    \   dimensions) are necessary to store latitude and four bytes are also\n   sufficient\
    \ to store longitude. Thus eight bytes total are necessary\n   to address the\
    \ whole surface of earth with precision down to 0.1\n   mile!  Notice that if\
    \ we desired precision down to 0.001 mile (1.8\n   meters) then we would need\
    \ just five bytes for each component, or ten\n   bytes together for the full address\
    \ (as military versions provide).\n   The future version of IP (IP v6) will certainly\
    \ have a sufficient\n   number of bits in its addressing space to provide an address\
    \ for even\n   smaller GPS addressable units.  In this proposal, however, we assume\n\
    \   the current version of IP (IP v4) and we make sure that we manage the\n  \
    \ addressing space more economically than that.  We will call the\n   smallest\
    \ GPS addressable unit a GPS-square.\n"
- title: 2a.     Using GPS for Destination Addresses
  contents:
  - "2a.     Using GPS for Destination Addresses\n   A destination GPS address would\
    \ be represented by one of the\n   following:\n     o     Some closed polygon\
    \ such as:\n                   circle( center point, radius )\n              \
    \     polygon( point1, point2, point3, ... , pointn)\n           where each point\
    \ would be expressed using GPS-square\n           addresses.  This notation would\
    \ send a message to anyone\n           within the specified geographical area\
    \ defined by the closed\n           polygon.\n     o     site-name as a geographic\
    \ access path\n           This notation would simulate the postal mail service.\
    \  In\n           this manner, a message can be sent to a specific site  by\n\
    \           specifying its location in terms of real-world names\n           such\
    \ as the name of a specific site, city, township,\n           county, state, etc.\
    \  This format would make use of the\n           directory service detailed later.\n\
    \   For example, if we were to send a message to city hall in Fresno,\n   California,\
    \ we could send it by specifying either a bounding polygon\n   or the mail address.\
    \  If we specify a bounding polygon, then we could\n   specify the GPS limits\
    \ of the city hall as a series of connected\n   lines that form a closed polygon\
    \ surrounding it.  Since we have a\n   list of connected lines, we just have to\
    \ record the endpoints of the\n   lines.  Therefore the address of the city hall\
    \ in Fresno could look\n   like:\n     polygon([N 45 58 23, W 34 56 12], [N 23\
    \ 45 56, W 12 23 34], ... )\n   Alternatively, since city hall in Fresno  is a\
    \ well-defined\n   geographical area, it would be simpler to merely name the\n\
    \   destination. This would be done by specifying \"postal-like\" address\n  \
    \ such as city_hall.Fresno.California.USA.\n   For \"ad hoc\" specified areas\
    \ such as, say a quad between 5th and 6th\n   Avenue and 43 and 46 street in New\
    \ York, the polygon addressing will\n   be used.\n   Unfortunately, we will not\
    \ be able to assume that we have enough\n   addressing space available in the\
    \ IP packet addressing space to\n   address all GPS squares. Instead we will propose\
    \ a solution which is\n   flexible in terms of the smallest GPS addressable units\
    \ which we call\n   atoms.  In our solution, a smaller available addressing space\
    \ (in the\n   IP packet) will translate into bigger atoms.  Obviously, we can\
    \ use\n   as precise addressing as we want to in the body of the geographic\n\
    \   messages - the space limitations apply only to the IP addressing\n   space.\n\
    \   By a geographic address we mean an IP address assigned to a\n   geographic\
    \ area or point of interest.  Our solution will be flexible\n   in terms of the\
    \ geographic addressing space.\n   Below, we will use the following two terms:\n\
    \     o     Atoms: for smallest geographic  areas which have\n           geographic\
    \ address.\n           Thus, atoms could be as small as GPS squares but could\
    \ be\n           larger\n     o     Partitions: These are larger, geographical\
    \ areas, which will\n           also have a geographic address. A state, county,\
    \ town etc.\n           may constitute a partition. A partition will contain a\
    \ number\n           of atoms.\n   Here are some examples of possible atoms and\
    \ partitions:\n     o     A rectangle, defined by truncating either longitude\
    \ or\n           latitude part of the GPS address by skipping one or more\n  \
    \         least significant digits\n     o     A circle, centered in a specific\
    \ GPS address with a\n           prespecified radius.\n     o     Irregular shapes\
    \ such as administrative domains: states,\n           counties, townships, boroughs,\
    \ cities etc\n   Partitions and Atoms (which are of course special atomic partitions)\n\
    \   will therefore have geographic addresses which will be used by\n   routers.\
    \ Areas of smaller size than atoms, or of \"irregular shape\"\n   will not have\
    \ corresponding geographic addresses and will have to\n   handled with the help\
    \ of application layer.\n"
- title: 3.      Routing
  contents:
  - "3.      Routing\n   Let us now describe the suggested routing schemes responsible\
    \ for\n   delivering a message to any geographical destination.\n   We will distinguish\
    \ between two legs of the connection from the\n   sender to the receiver: the\
    \ first leg from the sender to the MSS\n   (base station) and the second leg from\
    \ the MSS to the receiver\n   residing in its cell.  Our two solutions will differ\
    \ on the first leg\n   of the connection and use the same options for the second\
    \ leg, which\n   we call \"last mile\".\n"
- title: 3a.     GPS-Multicast Routing Scheme
  contents:
  - "3a.     GPS-Multicast Routing Scheme\n   Here, we discuss the first leg of routing:\
    \ from the sender to the\n   MSS. We start with the multicasting solution.\n \
    \  Each partition and atom is mapped to a multicast address. The exact\n   form\
    \ of this mapping is discussed further in this subsection.  We\n   first sketch\
    \ the basic idea.\n   This solution provides flexible mix of the multicast and\
    \ application\n   level filtering for the geographic addressing.  The key idea\
    \ here is\n   to approximate the addressing polygon of the smallest partition\
    \ which\n   contains it and using the multicast address corresponding to that\n\
    \   partition as the IP address of that message. The original polygon is\n   a\
    \ part of the packet's body and the exact matching is done on the\n   application\
    \ layer in the second leg of the route.\n   How is the multicast routing performed?\n"
- title: 3a-i.           Multicast Trees
  contents:
  - "3a-i.           Multicast Trees\n   The basic idea for the first level of routing\
    \ using multicast is to\n   have each base station join multicast groups for all\
    \ partitions which\n   intersect its range.  Thus, MSS is not only aware of its\
    \ own range\n   but also has a complete information about system defined partitions\n\
    \   which its range intersects. This information can be obtained upon MSS\n  \
    \ installation, from the geographic database stored as a part of DNS.\n   If the\
    \ proper multicast trees are constructed (using for example link\n   state multicast\
    \ protocol) than the sender can simply determine the\n   multicast address of\
    \ the partition which covers the original polygon\n   he wants to send his message\
    \ to, use this multicast address as the\n   address on the packet and put the\
    \ original polygon specification into\n   the packet content.  In this way, multicast\
    \ will assure that the\n   packet will be delivered to the proper MSS.\n   Example\n\
    \   For instance the MSS in New Brunswick may have its range intersect\n   the\
    \ following atoms and partitions: Busch, College Avenue, Douglass\n   and Livingston\
    \ Campuses of Rutgers University (atoms), New Brunswick\n   downtown area (atom),\
    \ the Middlesex county partition and the NJ state\n   partition. Each of these\
    \ atoms and partitions will be mapped into a\n   multicast address and the New\
    \ Brunswick's MSS will have to join all\n   such multicast groups.\n   The message\
    \ will be then specified and sent as follows:\n   The user will obtain the map\
    \ of the New Brunswick area possibly from\n   the DNS extended properly with relevant\
    \ maps. He will specify the\n   intended destination by drawing a polygon on the\
    \ map which will be\n   translated into the sequence of coordinates. In the same\
    \ time the\n   polygon will be \"approximated\" by the smallest partition which\n\
    \   contains that polygon. The multicast address corresponding to that\n   partition\
    \ will be the IP address for packets carrying our message.\n   The exact destination\
    \ polygon will be a part of each packet's body.\n   In this way the packet will\
    \ be delivered using multicast routing to\n   the set of MSS which are members\
    \ of the specified multicast group\n   (that is all MSS whose ranges intersect\
    \ the given partition). Each\n   such MSS now will follow the \"last mile\" routing\
    \ which is described\n   in detail, further in the proposal. Briefly speaking,\
    \ the MSS could\n   then multicast the message further on the same multicast address\
    \ and\n   the client will perform the final filtering o application layer,\n \
    \  matching its location (obtained from GPS) with the polygon specified\n   in\
    \ the packet's body.  Other solutions based entirely on multicasting\n   are also\
    \ possible as described below.\n   End_Example\n   However, things cannot be as\
    \ simple as described.  For such a large\n   potential number of multicast groups\
    \ if we build entire multicast\n   trees, the routing tables could  be too large.\
    \  Fortunately it is not\n   necessary to build complete multicast trees. Indeed,\
    \ it in not\n   important to know precise location of each atom in California,\
    \ from a\n   remote location, say in NJ.\n   Thus, we modify our simple solution\
    \ by implementing the following\n   intuition:\n   The smaller is the size of\
    \ the partition (atom) the more locally is\n   the information about that partition\
    \ (atom) propagated.\n   Thus, only multicast group membership for very large\
    \ partitions will\n   be propagated across the whole country.\n   For example,\
    \ a base station in Menlo Park, California can intersect\n   several atoms ) and\
    \ several larger  which cover Menlo Park, such say\n   a partition which covers\
    \ the entire San Mateo county, next which\n   cover the entire California and\
    \ finally next which may cover the\n   entire west coast.  This base station will\
    \ have to join multicast\n   groups which correspond to all these rectangles.\
    \ However, only the\n   information about multicast group corresponding to the\
    \ West Coast\n   partition will be propagated to the East Coast routers.\n   However,\
    \ a simple address aggregation scheme in which only a \"more\n   significant portion\"\
    \ of address propagates far away would not work.\n   Indeed, in this case a remote\
    \ router, say in NJ, could have several\n   aggregate links leading to California\
    \ - in fact, in the worst case,\n   all its links could point to California since\
    \ it could have received\n   a routing information to some location in California\
    \ on any of those\n   links.\n   To avoid this, for each partition we distinguish\
    \ one or a few MSS\n   which act as designated router(s) for that partition. \
    \ For example,\n   the California partition, may have only three designated routers,\
    \ one\n   in Eureka, another in Sacramento and yet another in LA. Only the\n \
    \  routing entries from the designated routers would be aggregated into\n   the\
    \ aggregate address for California. Information coming from other\n   city routers\
    \ will simply be dropped and not aggregated at all. This,\n   in addition to a\
    \ standard selection of the shortest routes, would\n   restrict the number of\
    \ links which lead to an aggregate address.  In\n   particular, when there is\
    \ only one designated router per partition,\n   there would only be one aggregate\
    \ link in any router. This could lead\n   to non-optimal routing but will solve\
    \ the problem of redundant links.\n   Even with a designated routers, it may happen\
    \ that the same packet\n   will arrive at a given base station more than once\
    \ due to different\n   alternative routes. Thus, a proper mechanism for discarding\
    \ redundant\n   copies of the same packet should still be in place.  In fact,\
    \ due to\n   the possible intersections between ranges of the base stations the\n\
    \   possibility of receiving redundant copies of the same packets always\n   exist\
    \ and has to be dealt with as a part of any solution.\n"
- title: 3a-ii.         Determining the geographic Multicast Addressing
  contents:
  - "3a-ii.         Determining the geographic Multicast Addressing\n   Here we describe\
    \ more specifically, the proposed addressing scheme\n   and the corresponding\
    \ routing.\n   The addressing will be hierarchical.  We will use the following\n\
    \   convention - each multicast address corresponding to a partitions or\n   an\
    \ atoms will have the following format:\n                            1111.GPS.S.C.x\n\
    \   where GPS is the specific code corresponding to the geographic\n   addressing\
    \ subspace of the overall multicast addressing space. The S,\n   C and x parts\
    \ are described below:\n      S  - Encoding of the state.\n           Each state\
    \ partition will have the address S/0/0.\n      C  - County within a state.\n\
    \           Each county partition having the address S/C/0.\n      x  - Atom \
    \ within a county.\n   where 0's refer to the sequences of 0 bits on positions\
    \ corresponding\n   to the  \"C part\"  and \"x part\" of address.\n   For example\
    \ if GPS part is 6 bit,s which gives 1/64 of existing\n   multicast addresses\
    \ to the geographic addressing we have 22 bits\n   left.  The S part will take\
    \ first 6 bits, C part next 6 bits (say)\n   and then the next 10 bits encode\
    \  different atoms (within a county).\n   Thus, in our terminology the proposed\
    \ addressing scheme has two types\n   of partitions: states and counties.\n  \
    \ We will assume that the GPS network will consist of all base stations\n   (MSS)\
    \ in addition the rest of the fixed network infrastructure. The\n   designated\
    \ GPS routers however, will only be selected from the\n   population of MSS. \
    \ Specifically, there will be state dedicated and\n   county dedicated routers.\n\
    \   The concept of the designation will be implemented as follows.  From\n   the\
    \ set of all MSS, only certain MSS will play a role of designated\n   routers\
    \ for county  and state partitions.  Non-designated MSS will\n   only join multicast\
    \ groups which correspond to the GPS atoms but not\n   GPS partitions that they\
    \ intersect. The MSS which is a designated\n   router for a county partition will\
    \ join the multicast group of the\n   county in which it is located, but not the\
    \ state. Finally the state\n   designated router will also join the multicast\
    \ address corresponding\n   to the state it is located in.\n"
- title: 3a-iii.  Building Multicast Trees
  contents:
  - "3a-iii.  Building Multicast Trees\n   We assume that each router has geographic\
    \ information attached to it\n   - in the same format as we use for multicast\
    \ mapping, S/C/x - it\n   encodes the atom that contains the router.\n   The multicast\
    \ tree is built by a router propagating its multicast\n   memberships to the neighboring\
    \ routers. A given router will only\n   retain certain addresses though, to follow\
    \ the intuition of not\n   retaining a specific information which is far away.\n\
    \   This is done as follows: the router (not necessarily the MSS based\n   router)\
    \ with the address S/C/x will only retain addresses about\n   S'/0/0, S/C'/0 for\
    \ S' and C' different from S and C and S/C/x for all\n   x.  Thus, it will drop\
    \ all the addresses of the form S'/C'/y for all\n   S' different that S except\
    \ those with C'=0 and y=0, as well as all\n   the addresses of the form S/C'/y\
    \ with C' different from C except\n   those with y=0.  Hence, these addresses\
    \ will not be forwarded any\n   further either.\n   Thus, notice that only the\
    \ information coming from designated routers\n   will be forwarded further away,\
    \ since the non-designated routers are\n   not allowed to join the multicast groups\
    \ which correspond to the\n   states and counties. Consequently, their multicast\
    \ membership\n   information will be not be propagated.\n   In this way a router\
    \ at S/C/x will not bother about specific\n   locations within S'/C'/y since they\
    \ are \"too far\".\n   Notice that this service may not be provided everywhere\
    \ so we may not\n   have to use all multicast addresses even within those assigned\
    \ for\n   geographic addresses.\n   Notice also that all of this is flexible -\
    \ if we have more multicast\n   addresses available (IP v 6) we will get more\
    \ precise addressing due\n   to smaller atoms.\n"
- title: 3a-iv.           GPS Routing
  contents:
  - "3a-iv.           GPS Routing\n   Given a packet we always look for the \"closest\"\
    \ match in the routing\n   table. If there is a complete match we follow such\
    \ a link, if not we\n   follow the address with the x-part 0'd in (county address)\
    \ if there\n   is none with the county which agrees with the destination county\
    \ than\n   we look at the entry which agrees with the state part of the\n   destination\
    \ address.\n"
- title: 3a-v.          DNS Issues
  contents:
  - "3a-v.          DNS Issues\n   How does the client find out the multicast address\
    \ on which the\n   packet is to be sent?  We assume that the local name server\
    \ has the\n   complete state/county hierarchy and that each county map can be\n\
    \   provided possibly with the \"grid\" of atoms and partitions already\n   clearly\
    \ marked.\n   Points of interests within a county can be attached multicast address\n\
    \   just as atoms. Then a given base station would have to join multicast\n  \
    \ groups of the points of interests that it covers.\n   The final stage is for\
    \ the receiver to look at the polygon (point of\n   interest) which is encoded\
    \ in the body of the multicast packet and\n   decide on the basis of its own GPS\
    \ location if this packet is to be\n   received or not. Doing it on the application\
    \ layer simplifies many\n   routing issues. There is a tradeoff, however, specially\
    \ when we have\n   very short S/C/x addresses and base stations which do not cover\
    \ the\n   given polygon in fact are reached unnecessarily.  This may happen and\n\
    \   it needs to be determined what is the number of the multicast\n   addresses\
    \ which are necessary to reduce this \"false\" alarms to the\n   minimum.\n"
- title: 3a-vi.                Estimations
  contents:
  - "3a-vi.                Estimations\n   Assume average cell size of, say, 2km x\
    \ 2km and the average state\n   size: say 200,000 square km, the average county\
    \ size: say 4,000\n   square km.\n   A reasonable size of the atom  is around\
    \ the size of the cell since\n   then we do not hit wrong cells too often.\n \
    \  Therefore we need the x addressing part of the S/C/x to encode\n   4,000/4\
    \ cells: 1.000 atoms. Thus we need 10 bits for x part. With 6\n   bits for the\
    \ state and 6 bits for the county that gives 22 bits which\n   is 1/64 of the\
    \ total IP v4 multicast addressing space.\n   With IPv6 we will have, of course,\
    \ much more addressing space which\n   we can use for the GPS multicast routing.\n"
- title: 3b.  "Last Mile"  Routing
  contents:
  - "3b.  \"Last Mile\"  Routing\n   Multicasting will be used for the last mile routing\
    \ in both our\n   solutions (i.e the one just discussed and the geometric routing\n\
    \   solution described next), but in different ways.\n"
- title: 3b-i.           Application Level Filtering
  contents:
  - "3b-i.           Application Level Filtering\n   The MSS will forward the geographic\
    \ message on its wireless link\n   under a multicast address. This multicast address\
    \ will either be the\n   same for all locations in the range of the MSS's cell\
    \ or, there will\n   be several addresses corresponding to atoms which intersect\
    \ the given\n   cell. Additionally, a complete GPS address (for example in the\
    \ form\n   of the polygon) will be provided in the body of the packet and the\n\
    \   exact address matching will be performed on the application layer.\n   The\
    \ receiver, knowing its GPS position uses it to match against the\n   polygon\
    \ address. The GPS position can be obtained by the receiver\n   either from the\
    \ GPS card or, indoors, from the indoor base station\n   which itself knows its\
    \ GPS position as a part of configuration file.\n"
- title: 3b-ii.          Multicast Filtering
  contents:
  - "3b-ii.          Multicast Filtering\n   In multicast level filtering, the base\
    \ station assigns a temporary\n   multicast address to the addressing polygon\
    \ in a message.  It will\n   send out a directive on the cell's specially assigned\
    \ multicast\n   address. All mobile clients who reside in that cell are members\
    \ of\n   that special multicast group (one per MSS). The directive sent by the\n\
    \   MSS will contain the pair consisting of  the temporary multicast\n   address\
    \ together with the polygon. To improve the reliability this\n   message will\
    \ be multicast several times. The clients, knowing their\n   GPS positions will\
    \ than join the temporary multicast groups if their\n   current locations are\
    \ within the advertised polygon.  The MSS will\n   then send out the real message\
    \ using the temporary multicast address.\n   The temporary multicast address would\
    \ be cached for a period of time.\n   If more packets for the same polygon arrive\
    \ in a short period of\n   time, they will be sent out on the same multicast address.\
    \ If not,\n   then the multicast address is dropped and purged from the cache.\n\
    \   Filtering on the client's station is then performed entirely on the\n   IP\
    \ level. This solution introduces additional delay (needed to join\n   the temporary\
    \ multicast group) but reduces the number of irrelevant\n   packets received by\
    \ the client. This especially important for very\n   long messages.\n"
- title: 3b-iii.         Computers on Fixed Networks
  contents:
  - "3b-iii.         Computers on Fixed Networks\n   Fixed-network computers should\
    \ also monitor all of the mandatory\n   multicast addresses for their site and\
    \ GPS square.  In this manner,\n   the fixed computers will also receive messages\
    \ sent to specific GPS-\n   addresses.\n   Modified base stations would still\
    \ be in charge of multicasting the\n   messages to the computers.  These base\
    \ stations would have the same\n   GPS-routing functionality as the mobile computer\
    \ base stations.\n   Their main difference would be that the mobile computer base\
    \ stations\n   would use radio frequencies to multicast their messages and the\
    \ fixed\n   network base stations use the local Ethernet or Token Ring network.\n\
    \   The next scheme differs from the GPS multicast scheme described above\n  \
    \ only on the first leg of the route, from the sender to the MSS. The\n   \"last\
    \ mile\" from the MSS to the final destination will have the same\n   options\
    \ as described above.\n"
- title: 3c.             Geometric Routing Scheme (GEO)
  contents:
  - "3c.             Geometric Routing Scheme (GEO)\n   The Geometric Routing Scheme\
    \ (GEO) uses the polygonal geographic\n   destination information in the GPScast\
    \ header directly for routing.\n   GEO routing is going to be implemented in the\
    \ Internet Protocol (IP)\n   Network layer in a manner similar to the way multicast\
    \ routing was\n   first implemented.  That is, a virtual network which uses GPS\n\
    \   addresses for routing will be overlayed onto the current IP\n   internetwork.\
    \  We would accomplish this by creating our own GPS-\n   address routers.  These\
    \ routers would use tunnels to ship data\n   packets between them and between\
    \ the routers and base stations.\n"
- title: 3c-i.           Routing Overview
  contents:
  - "3c-i.           Routing Overview\n   Sending a GPScast message involves three\
    \ steps: sending the message,\n   shuttling the message between routers, and receiving\
    \ the message.\n   Sending a GPScast message is very similar to sending a UDP\
    \ datagram.\n   The programmer would use the GPScast library routine SendToGPS().\n\
    \   Among other parameters, this routine will accept the GPS polygonal\n   destination\
    \ address and the body of the message.  The SendToGPS()\n   routine will encapsulate\
    \ the GPScast message in a UDP datagram and\n   send it to the class E address\
    \ 240.0.0.0.  Previously, the system\n   administrator will have specified in\
    \ the /etc/rc.local or /etc/rc.ip\n   file a route command that will specify that\
    \ packets with the address\n   240.0.0.0 will instead be sent to the address of\
    \ the local GPS\n   router.  This will have the effect of sending the datagram\
    \ to the\n   nearest GPS router.\n   Before explaining how the GPS routers shuttle\
    \ the GPScast message to\n   its destination, an introduction to routers and their\
    \ different parts\n   is in order.  For scalability purposes, GPS routers are\
    \ arranged in a\n   hierarchical fashion.  Each layer would correspond to a distinct\n\
    \   geographic area, such as a state or a city.  At the top would be\n   country-wide\
    \ routers in charge of moving messages from one end of the\n   country to another.\
    \  At the bottom would be campus or department\n   routers in charge of moving\
    \ messages between the base stations.  See\n   Figure 1.\n                   \
    \                Country-Router(s)\n                                   /     \
    \         \\\n                           State-Router(s)\n                   \
    \        /             \\\n                     City-Router(s)\n             \
    \         /      \\\n                Router        Router\n               /  |\
    \   \\      |    \\\n           Base  Base  Base   Base  Base\n   Figure 1: Hierarchy\
    \ of routers.\n   A GPS router essentially consists of three parts: a service\
    \ area\n   table containing the geographic area serviced by the router and each\n\
    \   of its hierarchical children, a hashed cache of previous actions, and\n  \
    \ a table containing the IP addresses of at least the router's children\n   and\
    \ the router's parent.  In the case of a bottom-layer campus\n   router, the service\
    \ area table will contain polygons describing the\n   geographic reach of each\
    \ child base station's cell.  The polygon\n   created from the union of all of\
    \ the router's child base stations'\n   polygons defines the service area of the\
    \ router.\n   Once the datagram arrives at a GPS router, the router strips the\n\
    \   datagram off, thereby, leaving it with the original GPScast message.\n   First\
    \ the router must determine if it services any part of the area\n   of the destination\
    \ polygon.  To do this, the router finds the\n   intersection between the destination\
    \ polygon and the polygon\n   describing the router's service area.  The polygon\
    \ intersection\n   algorithm used is described by O'Rourke in his paper, A New\
    \ Linear\n   Algorithm for Intersecting Convex Polygons.  This algorithm requires\n\
    \   order N-squared time in the worst case.  If the intersection result\n   is\
    \ null, then the router simply sends the message to its parent\n   router.\n \
    \          ------ Destination Polygon\n           | A  |\n       --------------\n\
    \       |   | B  |   | Router's Service Area Polygon\n       --------------\n\
    \           | C  |\n           ------\n   Figure 2: Polygon Difference\n   However,\
    \ if the result is not null, then the router does service the\n   area described\
    \ by the intersection polygon.  The router now subtracts\n   its service area\
    \ from the destination polygon and sends the rest to\n   it's parent router. \
    \ This subtraction step is actually a by-product\n   of the intersection algorithm.\
    \  Using the example in Figure 2, the\n   destination polygon and the router's\
    \ service area polygon intersect\n   at the region labeled B.  Therefore, the\
    \ router will subtract out the\n   B section and send the remaining sections A\
    \ and C to its parent\n   router.\n   Continuing with the example, the router\
    \ now uses the intersection\n   polygon B to to determine which base station (or\
    \ stations) will\n   receive the GPScast message.  The router finds the intersection\n\
    \   between the region B and the polygon of each base station's cell.\n   Those\
    \ base station polygons which intersect the region B will be sent\n   the GPScast\
    \ message.  Processes on Mobile Hosts serviced by these\n   base stations will\
    \ now use the routine RecvFromGPS() to receive the\n   GPScast message.\n"
- title: 3c-ii.  Supporting Long-Duration GPScasts
  contents:
  - "3c-ii.  Supporting Long-Duration GPScasts\n   Most likely, there will be a need\
    \ to support sending real-time\n   continuous media to a GPS destination.  This\
    \ continuous media could\n   be an audio GPScast or a video GPScast.  This would\
    \ require that\n   jitter be reduced in order to minimize disturbing artifacts\
    \ in the\n   audio or video playback.  Continually checking the destination\n\
    \   geometry of each packet would incur unnecessary delays and may\n   promote\
    \ jitter.\n   Therefore, the router will keep a hashed cache of the latest GPScast\n\
    \   packets and their destinations.  Each cache item will be hashed using\n  \
    \ the Sender Identification included in the header of GPScast messages\n   as\
    \ the key.  Each cache item will contain a time stamp and a list of\n   the next\
    \ hops for that GPScast.  When the time stamp exceeds a\n   certain limit, then\
    \ the cache item will be dropped.  The list of next\n   hops is a list of the\
    \ IP addresses of the base stations, peer\n   routers, and parent router which\
    \ are to receive a copy of the GPScast\n   messages.\n   When a router receives\
    \ a GPScast packet, it will use the incoming\n   packet's Sender Id as a key into\
    \ the hashed cache.  If this is not\n   the first packet to arrive for this destination\
    \ and if the timer on\n   the hash table entry has not yet expired, then the hashed\
    \ cache will\n   return a list of all of the destination addresses to which copies\
    \ of\n   the packet must be sent.  Copies of the packet are sent to all of\n \
    \  these destinations and the hash entry's time stamp is updated.\n   If no hash\
    \ table entry is found (i.e.- this is the first packet\n   encountered for this\
    \ destination address), then the normal geometry\n   checking routine would take\
    \ over.  A new cache entry is made\n   recording all of the next-hop destination\
    \ addresses of the GPScast.\n   In this manner, if several other packets with\
    \ the same GPS\n   destination follow this first packet, the router can use the\
    \ hash\n   table to look-up the destination base stations instead of calculating\n\
    \   it using geometry.\n"
- title: 3c-iii.          Discovering A Router's Service Area
  contents:
  - "3c-iii.          Discovering A Router's Service Area\n   When the router is initiated,\
    \ it will consult its configuration file.\n   One of the items it will find in\
    \ the file will be the multicast\n   address of the base station group to which\
    \ all of its child base\n   stations are members.  The router will join this group\
    \ and then send\n   out Service Area Query messages to this multicast group periodically\n\
    \   to discover and to refresh its knowledge of its children base\n   stations\
    \ and the geographical areas serviced by them.\n   Queries are issued infrequently\
    \ (no more than once every five\n   minutes) so as to keep the IGPSMP overhead\
    \ on the network very low.\n   However, since the query is issued using unreliable\
    \ multicast\n   datagrams, there is a chance that some base stations may not receive\n\
    \   the query.  This is important in two cases: when a child node fails\n   and\
    \ when a router first boots up.  The case of a failed child node\n   will be explained\
    \ later.  However, when a router first boots up, it\n   can issue several queries\
    \ in a small amount of time in order to\n   guarantee that base stations will\
    \ receive the query and to,\n   therefore, build up its knowledge about its child\
    \ base stations\n   quickly.\n   Base stations respond to a Service Area Query\
    \ by issuing a Service\n   Area Report.  This report is issued on the same multicast\
    \ group\n   address that all of the base stations have joined.  The report\n \
    \  contains the geographical service area of the base station.  In order\n   to\
    \ avoid a sudden congestion of reports being sent at the same time,\n   each base\
    \ station will initiate a random delay timer.  Only when the\n   timer expires\
    \ will the base station send its report.\n   For every base station that responds,\
    \ the router will create an IP\n   tunnel between it and the base station.  This\
    \ tunnel will carry the\n   GPScast packet traffic between the base station and\
    \ the router.  Each\n   responding base station and its geographic area of service\
    \ will also\n   be included in the router's geometric routing table as a possible\n\
    \   destination for GPScast packets.  Any base station that does not\n   respond\
    \ for ten continuous Service Area Queries will be considered\n   unreachable and\
    \ will be dropped from the routing table.\n"
- title: 3c-iv.         Hierarchical Router Structure and Multicast Groups
  contents:
  - "3c-iv.         Hierarchical Router Structure and Multicast Groups\n         \
    \              R5----------------------R6\n                    /      \\     \
    \           /     \\\n                  R1---------R2           R3---------R4\n\
    \                / | \\      / | \\        / | \\      / | \\\n              \
    \ b1 b2 b3   b4 b5 b6     b7 b8 b9 b10 b11 b12\n   Figure 3: Two peer routers\
    \ (R5 and R6) cooperatively servicing four\n                   child routers (R1\
    \ - R4).\n   For scalability purposes, a hierarchy of routers is used to transport\n\
    \   messages from a sender to a receiver.  Each layer of peer routers\n   would\
    \ have its own multicast group address for the exchange of\n   Service Area Queries\
    \ and Reports between the peer routers.  However,\n   routers in distinct subtrees\
    \ need not know about the routers in other\n   subtrees.  Therefore, multicast\
    \ group addresses will also differ\n   between hierarchy subtrees.  See figure\
    \ 3.  For instance, routers R1\n   and R2 would share a multicast group and would\
    \ know about each other.\n   At the same time, routers R3 and R4 would share a\
    \ different multicast\n   group and would know about each other.  However, routers\
    \ R1 and R2\n   would not know about R3 and R4, and vice versa.\n   But how will\
    \ the router know the location and number of its peer\n   routers and who its\
    \ parent router is?  As mentioned before, the\n   router consults its configuration\
    \ file upon start-up.  Included in\n   this configuration file will be the the\
    \ address of its parent router\n   and the multicast group address that the peer\
    \ routers will use.  This\n   peer multicast group address will be used in the\
    \ same manner as the\n   base station multicast group address.  It will be used\
    \ to send and\n   receive Service Area Queries and Reports between the parent\
    \ router\n   and the peer routers.  There is only one difference.  When a router\n\
    \   sends a Service Area Report, in addition to reporting its\n   geographical\
    \ service area, a router will include the multicast\n   address of its children\
    \ base stations.  The reason for this is\n   explained in the router-failure recovery\
    \ scheme described below.\n"
- title: 3c-v.          Routing Optimizations
  contents:
  - "3c-v.          Routing Optimizations\n   The optimization described here attempts\
    \ to reduce the latency of a\n   GPScast.  It does so by reducing the the number\
    \ of hops a packet must\n   traverse before finding its destination.  The intuition\
    \ behind the\n   idea is this:  instead of going to the parent router and then\
    \ to the\n   sibling, simply go to the sibling directly.  As an additional\n \
    \  benefit, this method prevents the parent router from becoming a\n   bottleneck\
    \ or a point of failure in the routing scheme.\n   In this optimization, when\
    \ a router attempts to determine who will\n   receive the GPS packet, it considers\
    \ its peer routers as if they were\n   also its children in the routing hierarchy.\
    \  This means that the\n   router will consider its service area to be the union\
    \ of the service\n   areas of its children and its peer routers.  Also, when the\n\
    \   destination polygon intersects the router's service area polygon, the\n  \
    \ router will forward a copy of the GPScast packet to any child or peer\n   router\
    \ whose geographic service area contains or touches the packet's\n   GPS destination\
    \ polygon.\n   However, before it sends a copy of the packet to a peer router,\
    \ it\n   first finds the polygon:\n                               P = D /\\ S\n\
    \   where D stands for the packet's destination GPS polygon, S is the\n   polygon\
    \ representing the service area of the peer router, and P is\n   the polygon that\
    \ represents the intersection of D and S.  The polygon\n   P is substituted for\
    \ the destination polygon D in the packet and only\n   then is the packet forwarded\
    \ to the peer router.  This is necessary\n   because the peer router will be using\
    \ that same routing algorithm.\n   Therefore, if the peer router receives a packet\
    \ with the original\n   destination polygon D, it will also route copies of the\
    \ packet to all\n   of its qualifying peer routers causing a chain of packet copies\
    \ being\n   bounced back and forth.\n"
- title: 3c-vi.          Router-Failure Recovery Scheme
  contents:
  - "3c-vi.          Router-Failure Recovery Scheme\n   In the case of a router failure,\
    \ the system should be able to route\n   around the failed router and continue\
    \ to service GPScast messages.\n   The responsibility of detecting whether a router\
    \ has failed or not\n   falls to the parent router.  Using Figure 3 as an example\
    \ router\n   hierarchy, the parent router R5 periodically sends out Service Area\n\
    \   Query IGPSMP messages on its children's multicast group address.\n   Thus,\
    \ the child routers R1 and R2 will both receive this query.\n   Normally, both\
    \ routers will respond with a Service Area Report\n   message.  This message contains\
    \ a polygon describing their service\n   areas and the multicast group address\
    \ of their children.\n   However, if a router, R1, does not respond to ten continuous\
    \ queries,\n   then it must be considered to have failed.  Upon detecting this,\
    \ the\n   parent router R5 will send a Set Service Area message to the child\n\
    \   router, R2 telling it to assume responsibility for the base stations\n   underneath\
    \ the failed R1 router.  In this Set Service Area message,\n   the parent router\
    \ includes the multicast group address of R1's\n   children.  The R2 router uses\
    \ this multicast address to learn the\n   service areas and IP addresses of R1's\
    \ children.  The R2 router then\n   issues a Service Area Report advertising its\
    \ new enlarged service\n   area responsibilities.  All peer and parent routers\
    \ will then update\n   their routing tables to include this new information. \
    \ When the\n   failed router, R1, restarts, it will declare that it is alive and\n\
    \   that it is again servicing its area.  All routers will then again\n   update\
    \ their routing tables.\n   In the case that there is no parent router, such as\
    \ at the top of the\n   routing hierarchy, then each peer router will keep track\
    \ of its\n   neighbors.  If a neighbor router fails, then the first neighbor\n\
    \   router to declare that it is taking over the base stations for the\n   failed\
    \ router will take responsibility.  The rest continues as\n   before.\n"
- title: 3c-vii.   Domain Name Service Issues
  contents:
  - "3c-vii.   Domain Name Service Issues\n   Domain Name Servers (DNS) could be used\
    \ to facilitate the use of GPS\n   geographic addressing for sites of interest.\
    \  The aim is to describe\n   specific geographic sites in a more natural and\
    \ real-world manner\n   using a postal-service like addressing method.  Essentially,\
    \ the DNS\n   would resolve a postal-service like address, such as\n   City_Hall.New_York_City.New_York,\
    \ into the IP address of the GPS\n   router responsible for that site.  The GPS\
    \ router would then route\n   the message to all available recipients in the site.\n\
    \   The DNS would be used when a message is sent using the\n              site-code.city-code.state-code.country-code\n\
    \   addressing scheme.  The DNS would evaluate the address in reverse\n   starting\
    \ with the country code, then the state code, etc.  This is\n   the same method\
    \ used currently by the IP DNS service to return IP\n   addresses based on the\
    \ country or geographic domains.\n"
- title: 4.  Router Daemon and Host Library
  contents:
  - '4.  Router Daemon and Host Library

    '
- title: 4a. GPS Address Library - SendToGPS()
  contents:
  - "4a. GPS Address Library - SendToGPS()\n   A library for GPS address routing will\
    \ be constructed.  The main\n   routines contained in this library will be the\
    \ SendToGPS() and\n   RecvFromGPS() commands.  SendToGPS() has the following syntax:\n\
    \   SendToGPS(int socket, GPS-Address *address, char *message, int size)\n   where\
    \ socket is a previously created datagram socket, address is a\n   filled GPS-Address\
    \ structure with the following form:\n   typedef _GPS-Address {\n           enum\
    \ { point, circle, polygon } type;\n           char *mail-address;\n         \
    \  struct\n           {\n                   enum { North, South, West, East }\
    \ dir;\n                   int hours, minutes, seconds;\n           } *points;\n\
    \   } GPS-Address;\n   and message and size specify the actual message and its\
    \ size.  The\n   SendToGPS() routine will take the GPS-addressed message, encapsulate\n\
    \   it in an IP packet, and then send it as a normal IP datagram.  The\n   message\
    \ is encapsulated in the following manner:\n              --------------------------------------------------------\n\
    \              |  IP Header with destination address set to 240.0.0.0 |\n    \
    \          --------------------------------------------------------\n        \
    \      |  Sender Identifier                                   |\n            \
    \  --------------------------------------------------------\n              | \
    \ Address Type  - Circle|Polygon                      |\n              --------------------------------------------------------\n\
    \              |  Actual GPS Address (see below)                      |\n    \
    \          --------------------------------------------------------\n        \
    \      |  Body of Message                                     |\n            \
    \  --------------------------------------------------------\n   where the Sender\
    \ Identifier would consist of a combination of the\n   sender's process id, host\
    \ IP address, and the center of the\n   destination polygon.  The Actual Address\
    \ would be one of the\n   following:\n   circle  - single GPS address and range\
    \ measured in centiminutes.\n   polygon - list of GPS addresses terminated by\
    \ the  impossible\n                address: N 255 255 255.\n   RecvFromGPS() has\
    \ the following syntax:\n   RecvFromGPS(int socket,GPS-Address *address,char *message,int\
    \ size)\n   where socket is a previously created datagram socket, address is an\n\
    \   empty GPS-Address structure, and message and size specify message\n   buffer\
    \ and its size.\n"
- title: 4b. Establishing A Default GPS Router
  contents:
  - "4b. Establishing A Default GPS Router\n   The default GPS router is determined\
    \ using the unicast routing table\n   found in the UNIX kernel.  The local system\
    \ administrator will have\n   previously adjusted the table so that all GPScast\
    \ messages are sent\n   to the local GPS router.  However, if there is no route\
    \ for GPScast\n   messages in the table, then all messages will, by default, be\
    \ sent to\n   the default gateway.  If the default gateway does not support GPScast\n\
    \   messages, then all attempts to send a GPScast will return an error.\n   By\
    \ default, all GPScast messages will initially have as their\n   destination the\
    \ class E address 240.0.0.0.  A route will be added to\n   the kernel routing\
    \ table by the system administrator for this\n   address.  The route will specify\
    \ the location of the local GPS\n   router.  The \"route\" command will be used\
    \ to affect the routing table\n   and it can be placed in the /etc/rc.local or\
    \ /etc/rc.ip files so that\n   it will take effect each time the computer is booted.\
    \  For example,\n   to specify that GPScast messages addressed to 240.0.0.0 should,\
    \ by\n   default, be sent to the router which resides on a computer on the\n \
    \  same subnet with local address 128.6.5.53, use the following:\n           \
    \   /etc/route add host 240.0.0.0 128.6.5.53 0\n   If the default destination\
    \ for GPScast messages is a host that does\n   not support GPS addressing, then\
    \ Network Unreachable errors will be\n   returned to any process attempting to\
    \ route GPScasts through that\n   host.\n"
- title: 4c. GPSRouteD
  contents:
  - "4c. GPSRouteD\n   In order to provide the capability of GPS address routing throughout\n\
    \   an IPv4-based internetwork, special-purpose routers will be created\n   to\
    \ support GPS address routing on top of the current Internet.  These\n   routers,\
    \ which will be called GPSRouteD, will use virtual point-to-\n   point links called\
    \ tunnels in order to connect two GPSRouteDs\n   together over regular unicast\
    \ networks.  The tunnels work by\n   encapsulating the GPS address messages in\
    \ IP datagrams and then\n   transmitting the message to the host on the other\
    \ end of the tunnel.\n   In this manner, the GPS address messages look like normal\
    \ unicast\n   packets to all IPv4 routers in between the two GPS address routers.\n\
    \   At the end of the tunnel, the receiving GPSRouteD removes the GPS\n   address\
    \ message from the datagram and continues the routing process.\n   By using tunnels,\
    \ the GPS routers can be established as a virtual\n   internetwork throughout\
    \ the current Internet without regard for the\n   physical properties of the underlying\
    \ networks.  Moreover, the use of\n   tunnels means that the host on which the\
    \ router daemon is running\n   need not be connected to more than one subnet in\
    \ order for the router\n   to forward GPS messages.  This virtual internetwork\
    \ would be\n   responsible for routing GPS address messages only.  This virtual\n\
    \   network, however, is not intended to be a permanent solution and is\n   only\
    \ intended to provide a means of supporting GPS address routing\n   until it gains\
    \ wider acceptance and support in the Internet\n   infrastructure.\n"
- title: 4c-i.   Configuration
  contents:
  - "4c-i.   Configuration\n   When a GPSRouteD initially executes, it first checks\
    \ the file\n   /etc/GPSRouteD.conf for configuration commands to add tunnel and\n\
    \   multicast links to other GPS address routers.  There are two kinds of\n  \
    \ configuration commands:\n           multicast  <multicast-address> <peer|child>\n\
    \           tunnel  <local-addr> <remote-addr>\n                   <parent|peer|child|host>\
    \ <service-area>\n   The tunnel command is used to create a tunnel between the\
    \ local host\n   on which the GPSRouteD executes and a remote host on which another\n\
    \   GPSRouteD executes. The tunnel must be set up in the GPSRouteD.conf\n   files\
    \ at both ends before it will be used.\n   The multicast command tells the router\
    \ which multicast addresses to\n   join.  These addresses will carry IGPSMP messages\
    \ and replies.  The\n   router will use these IGPSMP messages to build up and\
    \ keep current\n   its own internal routing table.\n"
- title: 4d.     Multicast Address Resolution Protocol (MARP)
  contents:
  - "4d.     Multicast Address Resolution Protocol (MARP)\n   Of course, this begs\
    \ the question, how will the individual computers\n   know which multicast addresses\
    \ to join?  For example, an MH would\n   have to join the multicast address of\
    \ its current cell so that it can\n   receive GPScast messages (using application-level\
    \ filtering) or\n   directions to join other multicast groups (using multicast\n\
    \   filtering).  We have designed a protocol called Multicast Address\n   Resolution\
    \ Protocol (MARP) that works the same way as Reverse Address\n   Resolution Protocol\
    \ (RARP).  However, instead of returning the IP\n   address of the MH, it will\
    \ return multicast group address of the cell\n   the MH is currently in.  The\
    \ MH would then join this multicast group.\n"
- title: 4e.     Internet GPS Management Protocol (IGPSMP)
  contents:
  - "4e.     Internet GPS Management Protocol (IGPSMP)\n   The Internet GPS Management\
    \ Protocol (IGPSMP) is used by GPS routers\n   to report, query, and inform their\
    \ router counterparts about their\n   geographical service areas.  The IGPSMP\
    \ will also be used to verify\n   that routers are correctly functioning.\n  \
    \ The vocabulary of IGPSMP will consist of six words:\n   o       set service\
    \ area - Used by the parent router to set the\n             geographic service\
    \ area of a router.  This is needed in\n             order to automatically respond\
    \ to router failure or new\n             router boot-up.\n   o       confirm service\
    \ area - confirms that a router has received\n             its service area.\n\
    \   o       geographical service area query - This message will be used\n    \
    \         by a router to build up its geographical routing table.\n          \
    \   It is sent to all routers on the same level.\n   o       service area report\
    \ - This message is sent in response to a\n            query request.  It contains\
    \ a bounding closed polygon\n            described using GPS coordinates which\
    \ contains the service\n            area for the router.\n   o       ping - This\
    \ message is sent periodically to ascertain whether\n             the router is\
    \ currently functioning properly.  Usually sent\n             by the parent router\
    \ in the hierarchy tree.\n   o       alive signal - Usually sent as a reply to\
    \ the ping message.\n             Used by a router to indicate that it is functioning\n\
    \             correctly.  It is also sent immediately after a router\n       \
    \      boots.\n   All of IGPSMP messages will be sent on an all-routers multicast\n\
    \   address for a particular hierarchy level.  The exact multicast\n   address\
    \ can be set in the router configuration file.\n   Note that for the GPS-Multicast\
    \ routing scheme, the time-to-live\n   value of the service area reports will\
    \ be varied in order to control\n   the distribution of the information.  In GPS-Multicast\
    \ routing, only\n   the multicast group membership for very large partitions will\
    \ be\n   distributed throughout the country.  Smaller partition may only be\n\
    \   distributed to neighbor routers.\n"
- title: 5.      Working Without GPS Information
  contents:
  - '5.      Working Without GPS Information

    '
- title: 5a.     Users Without GPS Modules
  contents:
  - "5a.     Users Without GPS Modules\n   Mobile users without GPS modules can still\
    \ participate - though at a\n   very reduced level.  When an MH enters a cell,\
    \ it can use an MARP to\n   discover the local multicast group for that cell or\
    \ atom.  As the\n   user roams from cell to cell, the mobile host can keep track\
    \ of the\n   current cell that the user is in and adds or drops the multicast\n\
    \   groups pertaining to those cells.  The user's GPS address can be set\n   to\
    \ be the center of the current cell.\n"
- title: 5b.     Buildings block GPS radio frequencies.  What then?
  contents:
  - "5b.     Buildings block GPS radio frequencies.  What then?\n   Each room can\
    \ have a radio beacon placed on the ceiling.  The beacon\n   will be weak enough\
    \ so that it will not penetrate walls.  Each radio\n   beacon will have its own\
    \ GPS-address associated with it which it will\n   broadcast.  When a mobile user\
    \ enters a room, his MH will detect the\n   beacon and read the beacon's GPS address.\
    \  The GPS-address of the MH\n   will be set to the GPS-address of the beacon.\
    \  The MH will then use\n   this beacon's GPS address in order to perform any\
    \ message filtering\n   that it needs to do.  Now the mobile user can have a GPS-address\n\
    \   associated with him even though he is indoors and his GPS-module is\n   useless.\n"
- title: 6.      Application Layer Solution
  contents:
  - "6.      Application Layer Solution\n   In this subsection we sketch a third solution\
    \ which relies more\n   heavily on the DNS.\n   In the application layer solution\
    \ the geographic information is added\n   to the DNS which provides the full directory\
    \ information down to the\n   level of the IP address of each base station and\
    \ its area of coverage\n   represented as a polygon of coordinates.\n   A new\
    \ first level domain - \"geographic\" is added to the set of first\n   level domains.\
    \ The second level domain names include states, the\n   third, counties and finally,\
    \ the fourth: polygons  of coordinates, or\n   so called points of interests.\
    \ We can also allow, polygons to occur\n   as elements of second, third domains\
    \ to enable sending messages to\n   larger areas.\n   Thus a typical geographic\
    \ address can look like\n   city-hall-Palo-Alto.San-Mateo-County.California.geographic\n\
    \   or\n   Polygon.San-Mateo-County.California.geographic\n   where Polygon is\
    \ a sequence of coordinates.\n   This geographic address is resolved in a similar\
    \ way as the standard\n   domain addresses are resolved today into a set of IP\
    \ addresses of\n   base stations which cover that geographic area. There are several\n\
    \   possibilities here:\n   a. A set of unicast messages is sent to all base stations\n\
    \   corresponding to the IP addresses returned by the DNS. Each base\n   station\
    \ then forwards the message using either of the two last link\n   solutions: application\
    \ level or network level filtering.\n   b. All the base stations join the temporary\
    \ multicast group for the\n   geographic area specified in the message. In this\
    \ way we may avoid\n   sending the same message across the same link several times.\
    \ Thus,\n   after the set of relevant base stations is determined by the DNS,\
    \ the\n   temporary multicast group is established and all packets with that\n\
    \   multicast address are sent on that multicast address.\n   c. Only one, central\
    \ to the polygon base station is returned by the\n   DNS just as in the IP unicast\
    \ solution.  However that \"central\" base\n   station will have to forward messages\
    \ to the other base stations\n   within the  polygon.\n   Notice that we should\
    \ distinguish between \"small area\" and \"wide\n   area\" geographic mail. The\
    \ \"small area\" mail will be most common  and\n   will most likely involve just\
    \ one base station, favoring a simple\n   form of solution (a).\n"
- title: 7.      Reliability
  contents:
  - "7.      Reliability\n   Should the geographic messages be acknowledged?\n   Since\
    \ we have no control if  users are present in the target\n   geographic area where\
    \ the mail is distributed we do not see a need\n   for individual acknowledgments\
    \ from the message recipients.  However,\n   we believe that the base stations\
    \ (MSS) covering the target area of\n   geographic mail should acknowledge the\
    \ messages.\n   Typically only a few base stations will be involved since typically\n\
    \   we will not cover very broad geographic areas anyway.  We assume that\n  \
    \ the base stations, additionally to forwarding the the messages on\n   their\
    \ wireless interfaces will buffer them, either to periodically\n   multicast them\
    \ (emergency response) or to provide them to users who\n   just entered a cell\
    \ and download the \"emergency stack\" of messages\n   for that area as a part\
    \ of the service hand-off protocol.\n"
- title: 8.      Security Considerations
  contents:
  - "8.      Security Considerations\n   Some method of determining who has permission\
    \ to send messages to a\n   large geographical area is needed.  For instance,\
    \ perhaps only the\n   mayor of New York City has permission to send a message\
    \ to all of New\n   York City.\n"
- title: 9.      References
  contents:
  - "9.      References\n   Deering, S., \"Host Extensions for IP Multicasting\",\
    \ STD 5, RFC 1112,\n   August 1989.\n   S. Deering. Multicast Routing in a Datagram\
    \ Internetwork. Ph.D.\n   Thesis, Stanford University, (December 1991).\n   J.\
    \ O'Rourke, C.B. Chien, T. Olson, and D. Naddor, A new linear\n   algorithm for\
    \ intersecting convex polygons, Computer Graphics and\n   Image Processing  19,\
    \ 384-391 (1982).\n   J. Ioannidis, D. Duchamp, and G. Q. Maquire. IP-Based Protocols\
    \ for\n   Mobile Internetworking. Proc. of ACM SIGCOMM Symposium on\n   Communication,\
    \ Architectures and Protocols, pages 235-245,\n   (September, 1991).\n"
- title: 10.      Authors' Addresses
  contents:
  - "10.      Authors' Addresses\n      Tomasz Imielinski and Julio C. Navas\n   \
    \   Computer Science Department\n      Busch Campus\n      Rutgers, The State\
    \ University\n      Piscataway, NJ\n      08855\n      Phone:  908-445-3551\n\
    \      EMail:  {imielins,navas}@cs.rutgers.edu\n"
