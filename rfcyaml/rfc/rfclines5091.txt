This document specifies two mathematical algorithms for identity based encryption (IBE).
Due to its specialized nature, this document experienced limited review within the IETF.
Readers of this RFC should carefully evaluate its value for implementation and deployment.
This document describes the algorithms that implement Boneh Franklin (BF) and Boneh Boyen (BB1) Identity based Encryption.
This document is in part based on IBCS #1 v2 of Voltage Security's Identity based Cryptography Standards (IBCS) documents, from which some irrelevant sections have been removed to create the content of this document.
This document provides a set of specifications for implementing identity based encryption (IBE) systems based on bilinear pairings.
Two cryptosystems are described: the IBE system proposed by Boneh and Franklin (BF) [BF], and the IBE system proposed by Boneh and Boyen (BB1)
Fully secure and practical implementations are described for each system, comprising the core IBE algorithms as well as ancillary hybrid components used to achieve security against active attacks.
These specifications are restricted to a family of supersingular elliptic curves over finite fields of large prime characteristic, referred to as "type 1" curves (see Section 2.1).
Implementations based on other types of curves currently fall outside the scope of this document.
IBE is a public key technology, but one which varies from other public key technologies in a slight, yet significant way.
In particular, IBE keys are calculated instead of being generated randomly, which leads to a different architecture for a system using IBE than for a system using other public key technologies.
An overview of these differences and how a system using IBE works is given in [IBEARCH].
Identity based encryption (IBE) is a public key encryption technology that allows a public key to be calculated from an identity, and the corresponding private key to be calculated from the public key.
Calculation of both the public and private keys in an IBE based system can occur as needed, resulting in just in time key material.
This contrasts with other public key systems [P1363], in which keys are generated randomly and distributed prior to secure communication commencing.
The ability to calculate a recipient's public key, in particular, eliminates the need for the sender and receiver in an IBE based messaging system to interact with each other, either directly or through a proxy such as a directory server, before sending secure messages.
This document describes an IBE based messaging system and how the components of the system work together.
The components required for a complete IBE messaging system are the following:  a Private key Generator (PKG).
The PKG contains the cryptographic material, known as a master secret, for generating an individual's IBE private key.
A PKG accepts an IBE user's private key request, and after successfully authenticating them in some way, returns the IBE private key.
a Public Parameter Server (PPS).
IBE System Parameters include publicly sharable cryptographic material, known as IBE public parameters, and policy information for the PKG.
A PPS provides a well known location for secure distribution of IBE public parameters and policy information for the IBE PKG.
A logical architecture would be to have a PKG/PPS per name space, such as a DNS zone.
The organization that controls the DNS zone would also control the PKG/PPS and thus the determination of which PKG/PSS to use when creating public and private keys for the organization's members.
In this case the PPS URI can be uniquely created by the form of the identity that it supports.
This architecture would make it clear which set of public parameters to use and where to retrieve them for a given identity.
IBE encrypted messages can use standard message formats, such as the Cryptographic Message Syntax (CMS) [CMS].
How to use IBE with CMS is described in [IBECMS].
Note that IBE algorithms are used only for encryption, so if digital signatures are required, they will need to be provided by an additional mechanism.
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [KEYWORDS].
Sending a Message That Is Encrypted Using IBE
In order to send an encrypted message, an IBE user must perform the following steps: 1.
Obtain the recipient's public parameters.
The recipient's IBE public parameters allow the creation of unique public and private keys.
A user of an IBE system is capable of calculating the public key of a recipient after he obtains the public parameters for their IBE system.
Once the public parameters are obtained, IBE encrypted messages can be sent.
Construct and send an IBE encrypted message.
All that is needed, in addition to the IBE public parameters, is the recipient's identity in order to generate their public key for use in encrypting messages to them.
When this identity is the same as the identity that a message would be addressed to, then no more information is needed from a user to send someone a secure message than is needed to send them an unsecured message.
This is one of the major benefits of an IBE based secure messaging system.
Examples of identities can be an individual, group, or role identifiers.
Sender Obtains Recipient's Public Parameters
The sender of a message obtains the IBE public parameters that he needs for calculating the IBE public key of the recipient from a PPS that is hosted at a well known URI.
The IBE public parameters contain all of the information that the sender needs to create an IBE encrypted message except for the identity of the recipient.
[IBEARCH] describes the URI where a PPS is located, the format of IBE public parameters, and how to obtain them.
The URI from which users obtain IBE public parameters MUST be authenticated in some way; PPS servers MUST support Transport Layer Security (TLS) 1.1 [TLS] to satisfy this requirement and MUST verify that the subject name in the server certificate matches the URI of the PPS.
[IBEARCH] also describes the way in which identity formats are defined and a minimum interoperable format that all PPSs and PKGs MUST support.
This step is shown below in Figure 1.
The sender of an IBE encrypted message selects the PPS and corresponding PKG based on his local security policy.
Different PPSs may provide public parameters that specify different IBE algorithms or different key strengths, for example, or require the use of PKGs that require different levels of authentication before granting IBE private keys.
Construct and Send an IBE Encrypted Message
To IBE encrypt a message, the sender chooses a content encryption key (CEK) and uses it to encrypt his message and then encrypts the CEK with the recipient's IBE public key (for example, as described in [CMS]).
This operation is shown below in Figure 2.
This document describes the algorithms needed to implement two forms of IBE.
[IBECMS] describes how to use the Cryptographic Message Syntax (CMS) to encapsulate the encrypted message along with the IBE information that the recipient needs to decrypt the message.
Recipient's Identity and IBE Public Parameters Figure 2.
Using an IBE Public Key Algorithm to Encrypt 1.2.
Receiving and Viewing an IBE Encrypted Message
In order to read an encrypted message, a recipient of an IBE encrypted message parses the message (for example, as described in [IBECMS]).
This gives him the URI he needs to obtain the IBE public parameters required to perform IBE calculations as well as the identity that was used to encrypt the message.
Next, the recipient must carry out the following steps: 1.
Obtain the recipient's public parameters.
An IBE system's public parameters allow it to uniquely create public and private keys.
The recipient of an IBE encrypted message can decrypt an IBE encrypted message if he has both the IBE public parameters and the necessary IBE private key.
The PPS can also provide the URI of the PKG where the recipient of an IBE encrypted message can obtain the IBE private keys.
Obtain the IBE private key from the PKG.
To decrypt an IBE encrypted message, in addition to the IBE public parameters, the recipient needs to obtain the private key that corresponds to the public key that the sender used.
The IBE private key is obtained after successfully authenticating to a private key generator (PKG), a trusted third party that calculates private keys for users.
The recipient receives the IBE private key over an HTTPS connection.
The URI of a PKG MUST be authenticated in some way; PKG servers MUST support TLS 1.1 [TLS] to satisfy this requirement.
Decrypt the IBE encrypted message.
The IBE private key decrypts the CEK, which is then used to decrypt encrypted message.
The PKG may allow users other than the intended recipient to receive some IBE private keys.
Giving a mail filtering appliance permission to obtain IBE private keys on behalf of users, for example, can allow the appliance to decrypt and scan encrypted messages for viruses or other malicious features.
Recipient Obtains Public Parameters from PPS Before he can perform any IBE calculations related to the message that he has received, the recipient of an IBE encrypted message needs to obtain the IBE public parameters that were used in the encryption operation.
This operation is shown below in Figure 3.
Requesting IBE Public Parameters 1.2.2.
Recipient Obtains IBE Private Key from PKG
To obtain an IBE private key, the recipient of an IBE encrypted message provides the IBE public key used to encrypt the message and their authentication credentials to a PKG and requests the private key that corresponds to the IBE public key.
Section 4 of this document defines the protocol for communicating with a PKG as well as a minimum interoperable way to authenticate to a PKG that all IBE implementations MUST support.
Because the security of IBE private keys is vital to the overall security of an IBE system, IBE private keys MUST be transported to recipients over a secure protocol.
PKGs MUST support TLS 1.1 [TLS] for transport of IBE private keys.
This operation is shown below in Figure 4.
IBE Private Key Request   Recipient
PKG   IBE Private Key Figure 4.
Obtaining an IBE Private Key 1.2.3.
Recipient Decrypts IBE Encrypted Message
After obtaining the necessary IBE private key, the recipient uses that IBE private key, and the corresponding IBE public parameters, to decrypt the CEK.
This operation is shown below in Figure 5.
He then uses the CEK to decrypt the encrypted message content (for example, as specified in [IBECMS]).
IBE encrypted CEK   Recipient   CEK
IBE Private Key and IBE Public Parameters Figure 5.
Using an IBE Public Key Algorithm to Decrypt 2.
This section summarizes the notions and definitions regarding identity based cryptosystems on elliptic curves.
The reader is referred to [ECC] for the mathematical background and to [BF], [IBEARCH] regarding all notions pertaining to identity based encryption.
F p denotes finite field of prime characteristic p
; F p^2 denotes its extension field of degree 2.
Let E/F p: y^2   x^3
a   x   b be an elliptic curve over F p.
For an extension of degree 2,
Let q be a prime such that E(F p) has a cyclic subgroup G1' of order
Let G1'' be a cyclic subgroup of E(F p^2) of order q, and G2 be a cyclic subgroup of (F p^2)  of order
Under these conditions, a mathematical construction known as the Tate pairing provides an efficiently computable map e: G1' x G1''
G2 that is linear in both arguments and believed hard to invert [BF].
e(A, phi(B)), called the modified Tate pairing.
We generically call a pairing either the Tate pairing e or the modified Tate pairing e', depending on the chosen elliptic curve used in a particular implementation.
The following additional notation is used throughout this document.
A 512 bit to 7680 bit prime, which is the order of the finite field F p. F p
The base finite field of order p over which the elliptic curve of interest E/F p is defined.
The size of the set G. F
The multiplicative group of the non zero elements in the field F; e.g., (F p)  is the multiplicative group of the finite field F p. E/F p
The equation of an elliptic curve over the field F p, which, when p is neither 2 nor 3, is of the form E/F p: y^2   x^3
a   x   b, for specified a, b in F p. 0
The null element of any additive group of points on an elliptic curve, also called the point at infinity.
The additive group of points of affine coordinates (x, y), with x,
y in F p, that satisfy the curve equation E/F p, including the point at infinity 0.
A 160 bit to 512 bit prime that is the order of the cyclic subgroup of interest in E(F p).
The embedding degree of the cyclic subgroup of order q in E(F p).
For type 1 curves this is always equal to 2.
The extension field of degree 2 of the field F p. E(F p^2)
The group of points of affine coordinates in F p^2 satisfying the curve equation E/F p, including the point at infinity 0.
The additive group of integers modulo
The base 2 logarithm function, so that 2^lg(x)
The term "object identifier" will be abbreviated "OID."
The following conventions are assumed for curve operations.
If A and B are two points on a curve E, their sum is denoted as A   B. Point multiplication If A is a point on a curve, and n an integer, the result of adding A to itself a total of n times is denoted [n]A. The following class of elliptic curves is exclusively considered for pairing operations in the present version of this document, which are referred to as "type 1" curves.
The class of curves of type 1 is defined as the class of all elliptic curves of equation E/F p: y^2   x^3   1 for all primes p congruent to 11 modulo 12.
This class forms a subclass of the class of supersingular curves.
These curves satisfy #E(F p)
that x   (y^2 1)^(1/3) (mod p).
Type 1 curves always have an embedding degree k   2.
Groups of points on type 1 curves are plentiful and easy to construct by random selection of a prime p of the appropriate form.
Therefore, rather than to standardize upon a small set of common values of p, it is henceforth assumed that all type 1 curves are freshly generated at random for the given cryptographic application
(an example of such generation will be given in Algorithm 5.1.2 (BFsetup1) or Algorithm 6.1.2 (BBsetup1)).
Implementations based on different classes of curves are currently unsupported.
We assume that the following concrete representations of mathematical objects are used.
Base field elements The p elements of the base field F p are represented directly using the integers from 0 to p 1.
The p^2 elements of the extension field F p^2 are represented as ordered pairs of elements of F p.
An ordered pair (a 0, a 1) is interpreted as the complex number a 0
This allows operations on elements of F p^2 to be implemented as follows.
Suppose that a   (a 0, a 1) and b   (b 0, b 1) are elements of F p^2.
Elliptic curve points Points in E(F p^2) with the point P
(x, y) in F p^2
x F p^2 satisfying the curve equation E/F p.  Points not equal to 0 are internally represented using the affine coordinates (x, y),
where x and y are elements of F p^2.
The following terminology is used to describe an IBE system.
The public parameters are a set of common, system wide parameters generated and published by the private key generator (PKG).
The master secret is the master key generated and privately kept by the key server and used to generate the private keys of the users.
An identity is an arbitrary string, usually a human readable unambiguous designator of a system user, possibly augmented with a time stamp and other attributes.
A public key is a string that is algorithmically derived from an identity.
The derivation may be performed by anyone, autonomously.
A private key is issued by the key server to correspond to a given identity (and the public key that derives from it) under the published set of public parameters.
Plaintext Plaintext is an unencrypted representation, or in the clear, of any block of data to be transmitted securely.
For the present purposes, plaintexts are typically session keys, or sets of session keys, for further symmetric encryption and authentication purposes.
Ciphertext Ciphertext is an encrypted representation of any block of data, including plaintext, to be transmitted securely.
This section describes algorithms for performing all needed basic arithmetic operations on elliptic curves.
The presentation is specialized to the type of curves under consideration for simplicity of implementation.
General algorithms may be found in [ECC].
The Group Action in Affine Coordinates 3.1.1.
Implementation for Type 1 Curves Algorithm 3.1.1 (PointDouble1): adds a point to itself on a type 1 elliptic curve.
A point A in E(F p^2), with A
An elliptic curve E/F p: y^2   x^3
If A   0 or y   0, then return 0 2.
Algorithm 3.1.2 (PointAdd1): adds two points on a type 1 elliptic curve.
A point A in E(F p^2), with A
(x A, y A) or 0
A point B in E(F p^2), with B
(x B, y B) or 0
An elliptic curve E/F p: y^2   x^3
If A   0, return B 2.
If B   0, return A 3.
If y A    y B, return 0 (b)
Else return [2]A computed using Algorithm 3.1.1 (PointDouble1) 4.
: (a) Let lambda   (y B y A)
(b) Let x'   lambda^2 x A x B (c) Let y'
(SignedWindowDecomposition): computes the signed m ary window representation of a positive integer [ECC].
An integer k > 0, where k has the binary representation
{Sum(k j   2^j, for j   0 to l} where each k j is either 0 or 1 and k
An integer window bit size r
An integer d and the unique d element sequence {(b i, e i), for i   0 to d 1} such that k
i   2^(e i), for i   0 to d 1}, each b
j <  r 1 and each e
i is a non negative integer Method: 1.
While j <  l, do: (a)
k j   0, then: i. Let j
Else: i. Let t   min{l, j   r 1} ii.
> 2^(r 1), then: A. Let
Let j   t   1 4.
scalar multiplication on an elliptic curve using the signed m ary window method.
A point A in E(F p^2)
An integer l > 0
An elliptic curve E/F p: y^2   x^3
The point [l]A Method: 1.  (Window decomposition) (a
) Let r > 0 be an integer (fixed) bit wise window size,
l where l   {Sum(l j   2^j), for j   0 to len l} is the binary expansion of l, where len l   Ceiling(lg(l)) (c) Compute (d, {(b i, e i), for i   0 to d 1}   SignedWindowDecomposition(l, r), the signed 2^r ary window representation of l using Algorithm 3.2.1 (SignedWindowDecomposition) 2.
A (b) Let A 2   [2]A, using Algorithm 3.1.1 (PointDouble1) (c)
For i   1 to 2^(r 2) 1, do:
A 2 using Algorithm 3.1.2 (PointAdd1)
Let Q   A (b (d 1)) 3.
For i   d 2 to 0 by  1, do: i.
e i)]Q, using repeated applications of Algorithm 3.1.1 (PointDouble1)
If b i > 0, then: A.
Q   Q   A (b i) using Algorithm 3.1.2
Else: A. Let Q   Q A ( (b i))
using Algorithm 3.1.2 (PointAdd1) (b)
using repeated applications of Algorithm 3.1.1 (PointDouble1)
Operations in Jacobian Projective Coordinates 3.3.1.
Implementation for Type 1 Curves Algorithm 3.3.1 (ProjectivePointDouble1): adds a point to itself in Jacobian projective coordinates for type 1 curves.
x, y, z)   A in E(F p^2)
An elliptic curve E/F p: y^2   x^3
The point [2]A in Jacobian projective coordinates Method: 1.
If z   0 or y   0, return (0, 1, 0)   0, otherwise: 2.
Let lambda 2   y^2 5.
Let x'   lambda 1^2 2   lambda 3 7.
Let y'   lambda 1   (lambda 3 x')
Algorithm 3.3.2 (ProjectivePointAccumulate1): adds a point in affine coordinates to an accumulator in Jacobian projective coordinates, for type 1 curves.
x A, y A, z A)
A in E(F p^2) in Jacobian projective coordinates
A point (x B, y B)
An elliptic curve E/F p: y^2   x^3
A   B in Jacobian projective coordinates
x B, y B, 1)
Let lambda 2   lambda 1
If lambda 3   0, then return (0, 1, 0), otherwise: 6.
Let lambda 6   lambda 4 lambda 5 9.
Let x'   lambda 6^2 lambda 7
Return (x', y', z') 3.4.
Divisors on Elliptic Curves 3.4.1.
Implementation in F p^2 for Type 1 Curves Algorithm 3.4.1 (EvalVertical1): evaluates the divisor of a vertical line on a type 1 elliptic curve.
A point B in E(F p^2) with B !
A point A in E(F p)
A description of a type 1 elliptic curve E/F p Output:  An element of F p^2 that is the divisor of the vertical line going through A evaluated at B Method: 1.
Return r Algorithm 3.4.2 (EvalTangent1): evaluates the divisor of a tangent on a type 1 elliptic curve.
A point B in E(F p^2) with B !
A point A in E(F p)
A description of a type 1 elliptic curve E/F p Output:  An element of F p^2 that is the divisor of the line tangent to A evaluated at B Method: 1.
If A   0, return 1 (b)
(x A)^2 (b) Let b
A (c) Let c    b
Return r Algorithm 3.4.3 (EvalLine1): evaluates the divisor of a line on a type 1 elliptic curve.
A point B in E(F p^2) with B !
Two points A', A'' in E(F p)
A description of a type 1 elliptic curve E/F p Output:  An element of F p^2 that is the divisor of the line going through A' and A'' evaluated at B Method: 1.
If A'   0, return EvalVertical1(B, A'')
using Algorithm 3.4.1 (EvalVertical1) (b)
using Algorithm 3.4.1 (EvalVertical1) (c)
using Algorithm 3.4.1 (EvalVertical1) (d)
If A'   A'', return EvalTangent1(B, A')
x A' (c) Let c    b
Tate Pairing Calculation Algorithm 3.5.1 (Tate): computes the Tate pairing on an elliptic curve.
A of order q in E(F p)
A point B of order q in E(F p^2)
A description of an elliptic curve E/F p such that E(F p) and E(F p^2) have a subgroup of order q Output:
The value e(A, B) in F p^2, computed using the Miller algorithm Method: 1.
For a type 1 curve E, execute Algorithm 3.5.2 (TateMillerSolinas)
The Miller Algorithm for Type 1 Curves Algorithm 3.5.2 (TateMillerSolinas): computes the Tate pairing on a type 1 elliptic curve.
A of order q in E(F p)
A point B of order q in E(F p^2)
A description of a type 1 supersingular elliptic curve E/F p such that E(F p) and E(F p^2) have a subgroup of Solinas prime order q where q
c, where c and s are limited to the values
The value e(A, B) in F p^2, computed using the Miller algorithm Method: 1.
) Let v num   1 in F p^2
(b) Let v den   1 in F p^2 (c)
Let V   (x V , y V , z V )
(x A, y A, 1) in (F p)^3, being the representation of (x A, y A)
A using Jacobian projective coordinates (d) Let t num   1 in F p^2
Let t den   1 in F p^2 2.
(Calculation of the (s   2^b) contribution) (a) (Repeated doublings)
For n   0 to b 1:
i. Let t num   t num^2 ii.
Let t den   t den^2 iii.
Let t num   t num   EvalTangent1(B,
z V^2, y V / z V^3))
Let V   (x V , y V , z V )
[2]V  using Algorithm 3.3.1 (ProjectivePointDouble1) v. Let t den   t den   EvalVertical1(B,
(Normalization) i. Let V b
(x (V b) , y (V b))
in (F p)^2, resulting in a point V b in E(F p)
t den B. Let v den   v den
z V^2, y V / z V^3)))
using Algorithm 3.4.1 (EvalVertical1) ii.
num B. Let v den
v den   t den 3.
(Calculation of the 2^a contribution) (a) (Repeated doublings)
For n   b to a 1
: i. Let t num   t num^2 ii.
Let t den   t den^2 iii.
Let t num   t num   EvalTangent1(B,
z V^2, y V / z V^3)))
Let V   (x V , y V , z V)
[2]V  using Algorithm 3.3.1 (ProjectivePointDouble1) v. Let t den   t den   EvalVertical1(B,
z V^2, y V / z V^3)))
using Algorithm 3.4.1 (EvalVertical1) (b)
(x (V a) , y (V a))
in (F p)^2, resulting in a point V a in E(F p)
(Accumulation) i. Let v num   v
Let v den   v den   t den 4.
(Correction for the (s   2^b) and (c) contributions) (a
) Let v num   v num   EvalLine1(B, V a, V b) using Algorithm 3.4.3 (EvalLine1)
(b) Let v den   v den
using Algorithm 3.4.1 (EvalVertical1) (c)
If c    1, then: i. Let v den   v den   EvalVertical1(B,
) Let eta   (p^2 1) / q 6.
(a) Return (v num / v den)^eta 4.
This section describes a number of supporting algorithms for encoding and hashing.
Hashing to an Integer Range HashToRange(s, n, hashfcn) takes a string s, an integer n, and a cryptographic hash function hashfcn as input and returns an integer in the range 0 to n 1 by cryptographic hashing.
The input n MUST be less than 2^(hashlen), where hashlen is the number of octets comprising the output of the hash function hashfcn.
HashToRange is based on Merkle's method for hashing [MERKLE], which is provably as secure as the underlying hash function hashfcn.
Algorithm 4.1.1 (HashToRange): cryptographically hashes strings to integers in a range.
A string s of length  s  octets
A positive integer n represented as Ceiling(lg(n) / 8) octets.
A cryptographic hash function hashfcn Output:  A positive integer v in the range 0 to n 1
Let hashlen be the number of octets comprising the output of hashfcn 2.
Let v 0   0 3.
0x00...00, a string of null octets with a length of hashlen 4.
For i   1 to 2, do: (a)
octet string concatenation of the strings h (i 1) and s
hashfcn(t i), which is a hashlen octet string resulting from the hash algorithm hashfcn on the input t
i (c) Let a i
i) be the integer in the range 0 to 256^hashlen 1
denoted by the raw octet string h i interpreted in the unsigned big endian convention (d)
v (i 1)   a i 5.
Let v   v l (mod n)
Pseudo Random Byte Generation by Hashing 4.2.1.
Keyed Pseudo Random Bytes Generator HashBytes(b, p, hashfcn) takes an integer b, a string p, and a cryptographic hash function hashfcn as input and returns a b octet pseudo random string r as output.
The value of b MUST be less than or equal to the number of bytes in the output of hashfcn.
HashBytes is based on Merkle's method for hashing [MERKLE], which is provably as secure as the underlying hash function hashfcn.
Algorithm 4.2.1 (HashBytes): keyed cryptographic pseudo random bytes generator.
An integer b  A string p  A cryptographic hash function hashfcn Output:  A string r comprising b octets Method: 1.
Let hashlen be the number of octets comprising the output of hashfcn 2.
0x00...00, a string of null octets with a length of hashlen 4.
For each i in 1 to l, do: (a) Let h
where h i    K is the (2   hashlen)
octet concatenation of h i and K 6.
), i.e., r is formed as the concatenation of the r i, truncated to the desired number of octets 4.3.
Canonical Encodings of Extension Field Elements 4.3.1.
Encoding an Extension Element as a String Canonical(p, k, o, v) takes an element v in F p^k, and returns a canonical octet string of fixed length representing v.
The parameter MUST be either 0 or 1, and specifies the ordering of the encoding.
Algorithm 4.3.1 (Canonical): encodes elements of an extension field F p^2 as strings.
An element v in F p^2
A description of F p^2
An ordering parameter o, either 0 or 1 Output:
A fixed length string s representing v Method: 1.
For a type 1 curve, execute Algorithm 4.3.2
Type 1 Curve Implementation Canonical1(p, o, v) takes an element v in F p^2 and returns a canonical representation of v as an octet string s of fixed size.
The parameter MUST be either 0 or 1, and specifies the ordering of the encoding.
Algorithm 4.3.2 (Canonical1): canonically represents elements of an extension field F p^2.
An element v in F p^2
A description of p, where p is congruent to 3 modulo 4
A ordering parameter o, either 0 or 1 Output:
A string s of size 2
/ 8), the number of octets needed to represent integers in Z p 2.
i, where i^2    1 3.
Let a (256^l) be the big endian zero padded fixed length octet string representation of a in Z p 4.
Let b (256^l) be the big endian zero padded fixed length octet string representation of b in Z p 5.
Depending on the choice of ordering o: (a)
If   0, then let s
Hashing onto a Subgroup of an Elliptic Curve 4.4.1.
Hashing a String onto a Subgroup of an Elliptic Curve HashToPoint(E, p, q, id, hashfcn) takes an identity string id, the description of a subgroup of prime order q in E(F p) or E(F p^2), and a cryptographic hash function hashfcn and returns a point
Q id of order q in E(F p) or E(F p^2).
Algorithm 4.4.1 (HashToPoint): cryptographically hashes strings to points on elliptic curves.
A cryptographic hash function hashfcn Output:
(x, y) of order q n E(F p)
For a type 1 curve E, execute Algorithm 4.4.2 (HashToPoint1
q, id, hashfcn) takes an identity string id and the description of a subgroup of order q in E(F p),
where E: y^2   x^3   1 with p congruent to 11 modulo 12, and returns a point
Q id of order q in E(F p) that is calculated using the cryptographic hash function hashfcn.
The parameters p, q and hashfcn MUST be part of a valid set of public parameters as defined in Section 5.1.2 or Section 6.1.2.
Algorithm 4.4.2 (HashToPoint1): cryptographically hashes strings to points on type 1 curves.
Input:  A prime p  A prime q
A cryptographic hash function hashfcn Output:
Q id of order q in E(F p)
HashToRange(id, p, hashfcn), using Algorithm 4.1.1 (HashToRange), an element of F p 2.
(y^2 1)^((2   p 1) / 3) modulo p, an element of F p 3.
(x, y), a non zero point in E(F p)
/ q ]Q', a point of order q in E(F p) 4.5.
Regular or Modified Tate Pairing Pairing(E, p, q, A, B) takes two points A and B, both of order q, and, in the type 1 case, returns the modified pairing e'(A, phi(B)) in F p^2 where A and B are both in E(F p).
Algorithm 4.5.1 (Pairing): computes the regular or modified Tate pairing depending on the curve type.
A description of an elliptic curve E/F p such that E(F p) and E(F p^2) have a subgroup of order
Two points A and B of order q in E(F p) or E(F p^2)
On supersingular curves, the value of e'(A, B) in F p^2 where A and B are both in E(F p
If E is a type 1 curve, execute Algorithm 4.5.2
Curve Implementation Algorithm 4.5.2 (Pairing1): computes the modified Tate pairing on type 1 curves.
The values of p and q MUST be part of a valid set of public parameters as defined in Section 5.1.2 or Section 6.1.2.
1 where p is congruent to 11 modulo 12 and E(F p) has a subgroup of order
Two points A and B of order q in E(F p) Output:
The value of e'(A, B)
e(A, phi(B)) in F p^2
as follows: (a) Let (x, y) in
F p x F p be the coordinates of B in E(F p)
Compute the Tate pairing e(A, B')
in F p^2 using the Miller method, as in Algorithm 3.5.1 (Tate) described in Section 3.5 4.6.
Ratio of Bilinear Pairings 4.6.1.
Ratio of Regular or Modified Tate Pairings PairingRatio(E, p, q, A, B, C, D) takes four points as input and computes the ratio of the two bilinear pairings, Pairing(E, p, q, A, B)
/ Pairing(E, p, q, C, D), or, equivalently, the product, Pairing(E, p, q, A, B)
Pairing(E, p, q, C,  D).
On type 1 curves, all four points are of order q in E(F p), and the result is an element of order q in the extension field F p^2 .
The motivation for this algorithm is that the ratio of two pairings can be calculated more efficiently than by computing each pairing separately and dividing one into the other, since certain calculations that would normally appear in each of the two pairings can be combined and carried out at once.
Such calculations include the repeated doublings in steps 2(a)i, 2(a)ii, 3(a)i, and 3(a)ii of Algorithm 3.5.2 (TateMillerSolinas), as well as the final exponentiation in step 6(a) of Algorithm 3.5.2 (TateMillerSolinas).
(PairingRatio): computes the ratio of two regular or modified Tate pairings depending on the curve type.
A description of an elliptic curve E/F p such that E(F p) and E(F p^2) have a subgroup of order
A, B, C, and D, of order q in E(F p) or E(F p^2)
On supersingular curves, the value of e'(A, B) / e'(C, D) in F p^2 where A, B, C, D are all in E(F p) Method: 1.
If E is a type 1 curve, execute Algorithm 4.6.2 (PairingRatio1)
Type 1 Curve Implementation Algorithm 4.6.2 (PairingRatio1): computes the ratio of two modified Tate pairings on type 1 curves.
The values of p and q MUST be part of a valid set of public parameters as defined in Section 5.1.2 or Section 6.1.2.
curve E/F p: y^2   x^3   1, where p is congruent to 11 modulo 12 and E(F p) has a subgroup of order
A, B, C, and D of order q in E(F p) Output:
The value of e'(A, B) / e'(C, D)
e( C, phi(D)), in F p^2
The step by step description of the optimized algorithm is omitted in this normative specification The correct result can always be obtained, although more slowly, by computing the product of pairings Pairing1(E, p, q, A, B)
Pairing1(E, p, q,  C, D) by using two invocations of Algorithm 4.5.2 (Pairing1).
The Boneh Franklin BF Cryptosystem
This chapter describes the algorithms constituting the Boneh Franklin identity based cryptosystem as described in [BF].
Master Secret and Public Parameter Generation Algorithm 5.1.1 (BFsetup): randomly selects a master secret and the associated public parameters.
A security parameter n (MUST take values either 1024, 2048, 3072, 7680, 15360)
Output:  A set of public parameters (version, E, p, q, P, P pub, hashfcn)
A corresponding master secret s
Depending on the selected type t: (a)
If version   2, then execute Algorithm 5.1.2 (BFsetup1) 2.
The resulting master secret and public parameters are separately encoded as per the application protocol requirements 5.1.2.
Type 1 Curve Implementation BFsetup1 takes a security parameter n as input.
For type 1 curves, the scale of n corresponds to the modulus bit size believed [BF] of comparable security in the classical Diffie Hellman or RSA public key cryptosystems.
Algorithm 5.1.2 (BFsetup1): establishes a master secret and public parameters for type 1 curves.
Input:  A security parameter n, which MUST be either 1024, 2048, 3072,
A set of common public parameters (version, p, q, P, Ppub, hashfcn)
A corresponding master secret s
Set the version to version   2.
Determine the subordinate security parameters n p and n q as follows:
If n   1024, then let n p   512, n q   160, hashfcn   1.3.14.3.2.26
If n   2048, then let n p   1024, n q   224, hashfcn   2.16.840.1.101.3.4.2.4
If n   3072, then let n p   1536, n q   256, hashfcn   2.16.840.1.101.3.4.2.1
If n   7680, then let n p   3840, n q   384, hashfcn   2.16.840.1.101.3.4.2.2
If n   15360, then let n p   7680, n q   512, hashfcn   2.16.840.1.101.3.4.2.3
Construct the elliptic curve and its subgroup of interest, as follows: (a) Select an arbitrary n q bit Solinas prime q
(b) Select a random integer r such that p
q 1 is an n p bit prime 4.
Select a point P of order q in E(F p), as follows:
(a) Select a random point
on the curve E/F p: y^2   x^3   1 (mod p)
[12   r]P' (c) If P   0, then start over in step 3a 5.
Determine the master secret and the public parameters as follows:
(a) Select a random integer
s in the range 2 to q 1
(version, E, p, q, P, P pub) are the public parameters where E: y^2   x^3   1 is represented by the OID 2.16.840.1.114334.1.1.1.1.
The integer s is the master secret 5.2.
Public Key Derivation from an Identity and Public Parameters BFderivePubl takes an identity string id and a set of public parameters, and it returns a point
The public parameters used MUST be a valid set of public parameters as defined by Section 5.1.2.
Algorithm 5.2.1 (BFderivePubl): derives the public key corresponding to an identity string.
A set of public parameters (version, E, p, q, P, P pub, hashfcn) Output:  A point Q id of order q in E(F p) or E(F p^2)
HashToPoint(E, p, q, id, hashfcn), using Algorithm 4.4.1 (HashToPoint) 5.3.
Private Key Extraction from an Identity, a Set of Public Parameters and a Master Secret BFextractPriv takes an identity string id, a set of public parameters, and corresponding master secret, and it returns a point
The public parameters used MUST be a valid set of public parameters as defined by Section 5.1.2.
Algorithm 5.3.1 (BFextractPriv): extracts the private key corresponding to an identity string.
A set of public parameters (version, E, p, q, P, P pub, hashfcn) Output:  A point
S id of order q in E(F p)
HashToPoint(E, p, q, id, hashfcn)
using Algorithm 4.4.1 (HashToPoint) 2.
Using an Identity and Public Parameters BFencrypt takes three inputs: a public parameter block, an identity id, and a plaintext m.
The plaintext MUST be a random symmetric session key.
The public parameters used MUST be a valid set of public parameters as defined by Section 5.1.2.
Algorithm 5.4.1 (BFencrypt): encrypts a random session key for an identity string.
A plaintext string m of size  m
A recipient identity string i
A set of public parameters (version, E, p, q, P, P pub, hashfcn) Output:  A ciphertext tuple (U, V, W) in E(F p)
Let hashlen be the length of the output of the cryptographic hash function hashfcn from the public parameters.
HashToPoint(E, p, q, id, hashfcn), using Algorithm 4.4.1 (HashToPoint), which results in a point of order q in E(F p) 3.
Select a random hashlen bit vector rho, represented as (hashlen / 8)
octet string in big endian convention 4.
hashfcn(m), a hashlen octet string resulting from applying the hashfcn algorithm to the input m 5.
Let l   HashToRange(rho    t, q, hashfcn), an integer in the range 0 to q 1 resulting from applying Algorithm 4.1.1 (HashToRange) to the (2   hashlen) octet concatenation of rho and t 6.
Let U   [l]P, which is a point of order q in E(F p) 7.
Let theta   Pairing(E, p, q, P pub, Q id), which is an element of the extension field F p^2 obtained using the modified Tate pairing of Algorithm 4.5.1 (Pairing)
Let theta'   theta^l, which is theta raised to the power of l in F p^2 9.
Let z   Canonical(p, k, 0, theta'), using Algorithm 4.3.1 (Canonical), the result of which is a canonical string representation of theta' 10.
hashfcn(z) using the hashfcn hashing algorithm, the result of which is a hashlen octet string 11.
Let V   w XOR rho, which is the hashlen octet long bit wise XOR of w and rho 12.
Let W   HashBytes( m , rho, hashfcn)
XOR m, which is the bit wise XOR of m with the first  m  octets of the pseudo random bytes produced by Algorithm 4.2.1 (HashBytes) with seed rho 13.
The ciphertext is the triple (U, V, W) 5.5.
Decrypt an Encrypted Session Key Using Public Parameters, a Private Key BFdecrypt takes three inputs: a public parameter block, a private key block key, and a ciphertext parsed as (U', V', W').
The public parameters used MUST be a valid set of public parameters as defined by Section 5.1.2.
Algorithm 5.5.1 (BFdecrypt): decrypts an encrypted session key using a private key.
S id of order q in E(F p)
A ciphertext triple (U, V, W) in E(F p)
A set of public parameters (version, E, p, q, P, P pub, hashfcn) Output:  A decrypted plaintext m, or an invalid ciphertext flag Method: 1.
Let hashlen be the length of the output of the hash function hashlen measured in octets 2.
Let theta   Pairing(E, p ,q, U, S id) by applying the modified Tate pairing of Algorithm 4.5.1 (Pairing)
Let z   Canonical(p, k, 0, theta) using Algorithm 4.3.1 (Canonical),
the result of which is a canonical string representation of theta 4.
hashfcn(z) using the hashfcn hashing algorithm, the result of which is a hashlen octet string 5.
w XOR V, the bit wise XOR of w and V 6.
Let m   HashBytes( W , rho, hashfcn) XOR W, which is the bit wise XOR of m with the first  W  octets of the pseudo random bytes produced by Algorithm 4.2.1 (HashBytes) with seed rho 7.
hashfcn(m) using the hashfcn algorithm 8.
Let l   HashToRange(rho    t, q, hashfcn) using Algorithm 4.1.1 (HashToRange)
octet concatenation of rho and t 9.
If this is the case, then the decrypted plaintext m is returned (b)
Otherwise, the ciphertext is rejected and no plaintext is returned 6.
The Boneh Boyen BB1 Cryptosystem
This section describes the algorithms constituting the first of the two Boneh Boyen identity based cryptosystems proposed in [BB1].
The description follows the practical implementation given in [BB1].
Generate a Master Secret and Public Parameters Algorithm 6.1.1 (BBsetup).
Randomly selects a set of master secrets and the associated public parameters.
An integer security parameter n (MUST take values either 1024, 2048, 3072, 7680, or 15360
) Output:  A set of public parameters
A corresponding master secret Method: 1.
Depending on the version: (a)
If version   2, then execute Algorithm 6.1.2 (BBsetup1)
Type 1 Curve Implementation BBsetup1 takes a security parameter n as input.
For type 1 curves, n corresponds to the modulus bit size believed [BF] of comparable security in the classical Diffie Hellman or RSA public key cryptosystems.
For this implementation, n MUST be one of 1024, 2048, 3072, 7680 or 15360, which correspond to the equivalent bit security levels of 80, 112, 128, 192 and 256 bits respectively.
Algorithm 6.1.2 (BBsetup1): randomly establishes a master secret and public parameters for type 1 curves.
A security parameter n, either 1024, 2048, 3072, 7680, or 15360 Output:
A set of public parameters (version, k, E, p, q, P, P 1, P 2, P 3, v, hashfcn)
A corresponding triple of master secrets (alpha, beta, gamma) Method: 1.
Determine the subordinate security parameters n p and n q as follows:
If n   1024, then let n p   512, n q   160, hashfcn   1.3.14.3.2.26
If n   2048, then let n p   1024, n q   224, hashfcn   2.16.840.1.101.3.4.2.4
If n   3072, then let n p   1536, n q   256, hashfcn   2.16.840.1.101.3.4.2.1
If n   7680, then let n p   3840, n q   384, hashfcn   2.16.840.1.101.3.4.2.2
If n   15360, then let n p   7680, n q   512, hashfcn   2.16.840.1.101.3.4.2.3
Construct the elliptic curve and its subgroup of interest as follows:
Select a random n q bit Solinas prime q
(b) Select a random integer r, such that p
q 1 is an n p bit prime 3.
Select a point P of order q in E(F p), as follows:
(a) Select a random point
on the curve E/F p: y^2   x^3   1 (mod p)
If P   0, then start over in step 3a 4.
Determine the master secret and the public parameters as follows: (a)
Select three random integers alpha, beta, gamma, each of them in the range 1 to q 1
[gamma]P (e) Let v   Pairing(E, p, q, P 1, P 2), which is an element of the extension field F p^2 obtained using the modified Tate pairing of Algorithm 4.5.1 (Pairing)
(version, E, p, q, P, P 1, P 2, P 3, v, hashfcn) are the public parameters 6.
(alpha, beta, gamma) constitute the master secret 6.2.
Derive a Public Key from an Identity and Public Parameters
Takes an identity string id and a set of public parameters and returns an integer h id.
The public parameters used MUST be a valid set of public parameters as defined by Section 6.1.2.
(BBderivePubl): derives the public key corresponding to an identity string.
The public parameters used MUST be a valid set of public parameters as defined by Section 6.1.2.
A set of common public parameters (version, k, E, p, q, P,
P 1, P 2, P 3, v, hashfcn) Output:
HashToRange(id, q, hashfcn), using Algorithm 4.1.1 (HashToRange) 6.3.
Extract a Private Key from an Identity, Public Parameters and a Master Secret BBextractPriv takes an identity string id, a set of public parameters, and corresponding master secrets, and it returns a private key consisting of two points D 0 and D 1.
The public parameters used MUST be a valid set of public parameters as defined by Section 6.1.2.
Algorithm 6.3.1 (BBextractPriv): extracts the private key corresponding to an identity string.
A set of public parameters (version, k, E, p, q, P,
P 1, P 2, P 3, v, hashfcn) Output:
A pair of points (D 0, D 1), each of which has order q in E(F p)
Select a random integer r in the range 1 to q 1 2.
Calculate the point D 0 as follows:
HashToRange(id, q, hashfcn) using Algorithm 4.1.1 (HashToRange)
id   gamma) in F q (c)
Calculate the point D 1 as follows:
The pair of points (D 0, D 1) constitutes the private key for id 6.4.
Public Parameters BBencrypt takes three inputs: a set of public parameters, an identity id, and a plaintext m.
The plaintext MUST be a random session key.
The public parameters used MUST be a valid set of public parameters as defined by Section 6.1.2.
Algorithm 6.4.1 (BBencrypt): encrypts a session key for an identity string.
A plaintext string m of size  m
A recipient identity string i
A set of public parameters (version, k, E, p, q, P,
P 1, P 2, P 3, v, hashfcn) Output:
A ciphertext tuple (u, C 0, C 1, y) in F q x E(F p)
Select a random integer s in the range 1 to q 1 2.
Let w   v^s, which is v raised to the power of s in F p^2, the result is an element of order q in F p^2 3.
Calculate the point C 0 as follows:
Calculate the point C 1 as follows:
HashToRange(id, q, hashfcn) using Algorithm 4.1.1 (HashToRange)
h id in F q (c)
[y]P 1   [s]P 3 5.
Obtain canonical string representations of certain elements: (a)
Let psi   Canonical(p, k, 1, w) using Algorithm 4.3.1 (Canonical), the result of which is a canonical octet string representation of
/ 8), the number of octets needed to represent integers in F p, and represent each of these F p elements as a big endian zero padded octet string of fixed length l:
(256^l) to represent the x coordinate of C 0 (
(256^l) to represent the y coordinate of C 0 (
x 1) (256^l) to represent the x coordinate of C 1 (y 1) (256^l) to represent the y coordinate of C 1 6.
Encrypt the message m into the string y as follows: (a) Compute an encryption key h 0 as a two pass hash of w
i. Let zeta   hashfcn(psi) using the hashing algorithm hashfcn ii.
using the hashing algorithm hashfcn iii.
the concatenation of the previous two hashfcn outputs (b) Let y   HashBytes( m , h', hashfcn)
XOR m, which is the bit wise XOR of m with the first  m  octets of the pseudo  random bytes produced by Algorithm 4.2.1 (HashBytes) with seed h' 7.
Create the integrity check tag u
a one time pad h'' as a dual pass hash of the representation of (w, C 0, C 1, y):
psi be the concatenation of y and the five indicated strings in the specified order ii.
hashfcn(sigma) using the hashing algorithm hashfcn iii.
Let mu   hashfcn(eta    sigma) using the hashfcn hashing algorithm iv.
, the concatenation of the previous two outputs of hashfcn (b) Build the tag u as the encryption of the integer
s with the one time pad h'':
i. Let rho   HashToRange(h'', q, hashfcn) to get an integer in Z q ii.
Let u   s   rho (mod q) 8.
The complete ciphertext is given by the quadruple (u, C 0, C 1, y) 6.5.
Decrypt Using Public Parameters and
Private Key BBdecrypt takes three inputs: a set of public parameters (version, k, E, p, q, P, P 1, P 2, P 3, v, hashfcn), a private key (D 0, D 1), and a ciphertext (u, C 0, C 1, y).
It outputs a message m, or signals an error if the ciphertext is invalid for the given key.
The public parameters used MUST be a valid set of public parameters as defined by Section 6.1.2.
(BBdecrypt): decrypts a ciphertext using public parameters and a private key.
A private key given as a pair of points
(D 0, D 1) of order q in E(F p)
A ciphertext quadruple (u, C 0, C 1, y) in Z q x E(F p)
A set of public parameters (version, k, E, p, q, P,
P 1, P 2, P 3, v, hashfcn) Output:
A decrypted plaintext m, or an invalid ciphertext flag Method: 1.
Let w   PairingRatio(E, p, q, C 0, D 0, C 1, D 1), which computes the ratio of two Tate pairings (modified, for type 1 curves) as specified in Algorithm 4.6.1 (PairingRatio) 2.
Obtain canonical string representations of certain elements: (a)
Let psi   Canonical(p, k, 1, w) using Algorithm 4.3.1 (Canonical); the result is a canonical octet string representation of w (b) Let l
/ 8), the number of octets needed to represent integers in F p, and represent each of these F p elements as a big endian zero padded octet string of fixed length l:
(256^l) to represent the x coordinate of C 0 (
(256^l) to represent the y coordinate of C 0 (
x 1) (256^l) to represent the x coordinate of C 1 (y 1) (256^l) to represent the y coordinate of C 1 3.
Decrypt the message m from the string y as follows: (a) Compute the decryption key h' as a dual pass hash of w
i. Let zeta   hashfcn(psi) using the hashing algorithm hashfcn ii.
using the hashing algorithm hashfcn iii.
xi    zeta, the concatenation of the previous two hashfcn outputs
XOR y, which is the bit wise XOR of y with the first  y  octets of the pseudo  random bytes produced by Algorithm 4.2.1 (HashBytes) with seed h' 4.
Obtain the integrity check tag u as follows:
the one time pad h'' as a dual pass hash of the representation of (w, C 0, C 1, y):
psi be the concatenation of y and the five indicated strings in the specified order ii.
hashfcn(sigma) using the hashing algorithm hashfcn iii.
Let mu   hashfcn(eta    sigma) using the hashing algorithm hashfcn iv.
mu    eta, the concatenation of the previous two hashfcn outputs
(b) Unblind the encryption randomization integer s from the tag
i. Let rho   HashToRange(h'', q, hashfcn) to get an integer in Z q ii.
Let s   u rho (mod q
Verify the ciphertext consistency according to the decrypted values:
(a) Test whether the equality w
(b) Test whether the equality C 0
Adjudication and final output: (a)
If either of the tests performed in step 5 fails, the ciphertext is rejected, and no decryption is output (b)
Otherwise, i.e., when both tests performed in step 5 succeed, the decrypted message is the output 7.
The following data can be used to verify the correct operation of selected algorithms that are defined in this document.
E/F p: y^2   x^3   1
54:68:69:73:20:41:53:43:49:49:20:73:74:72:69:6e:67:20:77:69:74 :68:6f:75:74:20:6e:75:6c:6c:2d:74:65:72:6d:69:6e:61:74:6f:72 ("This ASCII string without null terminator")
(SHA 1) Output: v   0x79317c1610c1fc018e9c53d89d59c108cd518608 7.3.
E/F p: y^2   x^3   1
Q id   (0x22fa1207e0d19e1a4825009e0e88e35eb57ba79391498f59, 0x982d29acf942127e0f01c881b5ec1b5fe23d05269f538836) 7.5.
Note: the following values can also be used to test Algorithm 5.5.1 (BFdecrypt).
Using the random value rho
, we get the following output: U   (0x1b5f6c461497acdfcbb6d6613ad515430c8b3fa23b61c585e9a541b199e 2a6cb, 0x9bdfbed1ae664e51e3d4533359d733ac9a600b61048a7d899104e826a0ec 4fa4)
, we get the following output:
D 1   (0x8d7a72ad06909bb3bb29b67676d935018183a905e7e8cb18, 0x2b346c6801c1db638f270af915a21054f16044ab67f6c40e) 7.8.
) Note: the following values can also be used to test Algorithm 5.5.1 (BFdecrypt).
2 E: y^2   x^3   1 p   0x91bbe2be1c8950750784befffffffffffff6e441d41e12fb
v   (0x38f91032de6847a89fc3c83e663ed0c21c8f30ce65c0d7d3, 0x44b9aa10849cc8d8987ef2421770a340056745da8b99fba2) hashfcn   1.3.14.3.2.26
Using the random value s
, we get the following output:
This section defines the ASN.1 module for the encodings discussed in this document.
IBCS { joint iso itu t(2)
This version only supports IBE using   type 1 curves, i.e., the curve y^2   x^3
IBCS1 defines the algorithms used to implement IBE   ibcs1
An elliptic curve is specified by an OID.
A type1curve is defined by the equation y^2   x^3   1.
An FpPoint can either represent an element of   F p^2 or an element of (F p)^2.
joint iso itu t(2)country(16) us(840)
joint iso itu t(2)country(16) us(840)
joint iso itu t(2)country(16) us(840)
The only version currently supported is version 2.
The values p and q define a subgroup of E(F p) of order
A BF private key is a point on an elliptic curve,   which is an FpPoint.
The only version supported is version 2.
A BF master secret is an integer.
The only version supported is version 2.
The only version supported is version 2.
Encoding of a BB1 public parameters block.
The version is currently fixed to 2.
The only version supported is version 2.
The only version supported is version 2.
The only version supported is version 2.
This document describes cryptographic algorithms.
We assume that the security provided by such algorithms depends entirely on the secrecy of the relevant private key, and for an adversary to defeat the security provided by the algorithms, he will need to perform computationally intensive cryptanalytic attacks to recover the private key.
We assume that users of the algorithms described in this document will require one of five levels of cryptographic strength: the equivalent of 80 bits, 112 bits, 128 bits, 192 bits or, 256 bits.
The 80 bit level is suitable for legacy applications and SHOULD NOT be used to protect information whose useful life extends past the year 2010.
The 112 bit level is suitable for use in key transport of Triple DES keys and should be adequate to protect information whose useful life extends up to the year 2030.
The 128 bit levels and higher are suitable for use in the transport of Advanced Encryption Standard (AES) keys of the corresponding length or less and are adequate to protect information whose useful life extends past the year 2030.
Table 1 summarizes the security parameters for the BF and BB1 algorithms that will attain these levels of security.
In this table,  p  represents the number of bits in a prime number p, and  q  represents the number of bits in a subprime q.
This table assumes that a Type 1 supersingular curve is used.
512 Table 1: Sizes of BF and BB1 Parameters Required to Attain Standard Levels of Bit Security [SP800 57].
If an IBE key is used to transport a symmetric key that provides more bits of security than the bit strength of the IBE key, users should understand that the security of the system is then limited by the strength of the weaker IBE key.
So if an IBE key that provides 112 bits of security is used to transport a 128 bit AES key, then the security provided is limited by the 112 bits of security of the IBE key.
Note that this document specifies the use of the National Institute of Standards and Technology (NIST)
to hash identities to either a point on an elliptic curve or an integer.
Recent attacks on SHA 1
[SHA] have discovered ways to find collisions with less work than the expected 2^80 hashes required based on the size of the output of the hash function alone.
If an attacker can find a collision, then they could use the colliding preimages to create two identities that have the same IBE private key.
The practical use of such a SHA 1 [SHA] collision is extremely unlikely, however.
Identities are typically not random strings like the preimages of a hash collision would be.
In particular, this is true if IBE is used as described in [IBECMS], in which components of an identity are defined to be an e mail address, a validity period, and a URI.
In this case, the unpredictable results of a collision are extremely unlikely to fit the format of a valid identity, and thus, are of no use to an attacker.
Any protocol using IBE MUST define an identity in a way that makes collisions in a hash function essentially useless to an attacker.
Because random strings are rarely used as identities, this requirement should not be unduly difficult to fulfill.
The randomness of the random values that are required by the cryptographic algorithms is vital to the security provided by the algorithms.
Any implementation of these algorithms MUST use a source of random values that provides an adequate level of security.
Appropriate algorithms to generate such values include [FIPS186 2] and [X9.62].
This will ensure that the random values used to mask plaintext messages in Sections 5.4 and 6.4 are not reused with a significant probability.
The strength of a system using the algorithms described in this document relies on the strength of the mechanism used to authenticate a user requesting a private key from a PKG, as described in step 2 of Section 1.2 of this document.
This is analogous to the way in which the strength of a system using digital certificates [X.509] is limited by the strength of the authentication required of users before certificates are granted to them.
In either case, a weak mechanism for authenticating users will result in a weak system that relies on the technology.
A system that uses the algorithms described in this document MUST require users to authenticate in a way that is suitably strong, particularly if IBE private keys will be used for authentication.
Note that IBE systems have different properties than other asymmetric cryptographic schemes when it comes to key recovery.
If a master secret is maintained on a secure PKG, then the PKG and any administrator with the appropriate level of access will be able to create arbitrary private keys, so that controls around such administrators and logging of all actions performed by such administrators
SHOULD be part of a functioning IBE system.
On the other hand, it is also possible to create IBE private keys using a master secret and to then destroy the master secret, making any key recovery impossible.
If this property is not desired, an administrator of an IBE system SHOULD require that the format of the identity used by the system contain a component that is short lived.
The format of identity that is defined in [IBECMS], for example, contains information about the time period of validity of the key that will be calculated from the identity.
Such an identity can easily be changed to allow the rekeying of users if their IBE private key is somehow compromised.
