- contents:
  - '          Partial Lock Remote Procedure Call (RPC) for NETCONF

    '
  title: __initial_text__
- contents:
  - "Abstract\n   The Network Configuration protocol (NETCONF) defines the lock and\n
    \  unlock Remote Procedure Calls (RPCs), used to lock entire\n   configuration
    datastores.  In some situations, a way to lock only\n   parts of a configuration
    datastore is required.  This document\n   defines a capability-based extension
    to the NETCONF protocol for\n   locking portions of a configuration datastore.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2009 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the BSD License.\n   This document may contain material from
    IETF Documents or IETF\n   Contributions published or made publicly available
    before November\n   10, 2008.  The person(s) controlling the copyright in some
    of this\n   material may not have granted the IETF Trust the right to allow\n
    \  modifications of such material outside the IETF Standards Process.\n   Without
    obtaining an adequate license from the person(s) controlling\n   the copyright
    in such materials, this document may not be modified\n   outside the IETF Standards
    Process, and derivative works of it may\n   not be created outside the IETF Standards
    Process, except to format\n   it for publication as an RFC or to translate it
    into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  3\n     1.1.  Definition of Terms  . . . . . . . . . . . . . . .
    . . . .  3\n   2.  Partial Locking Capability . . . . . . . . . . . . . . . .
    . .  3\n     2.1.  Overview . . . . . . . . . . . . . . . . . . . . . . . . .
    \ 3\n       2.1.1.  Usage Scenarios  . . . . . . . . . . . . . . . . . . .  4\n
    \    2.2.  Dependencies . . . . . . . . . . . . . . . . . . . . . . .  5\n     2.3.
    \ Capability Identifier  . . . . . . . . . . . . . . . . . .  5\n     2.4.  New
    Operations . . . . . . . . . . . . . . . . . . . . . .  5\n       2.4.1.  <partial-lock>
    . . . . . . . . . . . . . . . . . . . .  5\n       2.4.2.  <partial-unlock> .
    . . . . . . . . . . . . . . . . . . 10\n     2.5.  Modifications to Existing Operations
    . . . . . . . . . . . 10\n     2.6.  Interactions with Other Capabilities . .
    . . . . . . . . . 11\n       2.6.1.  Candidate Configuration Capability . . .
    . . . . . . . 11\n       2.6.2.  Confirmed Commit Capability  . . . . . . . .
    . . . . . 11\n       2.6.3.  Distinct Startup Capability  . . . . . . . . . .
    . . . 11\n   3.  Security Considerations  . . . . . . . . . . . . . . . . . .
    . 12\n   4.  IANA Considerations  . . . . . . . . . . . . . . . . . . . . . 12\n
    \  5.  Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . 13\n   6.
    \ References . . . . . . . . . . . . . . . . . . . . . . . . . . 13\n     6.1.
    \ Normative References . . . . . . . . . . . . . . . . . . . 13\n     6.2.  Informative
    References . . . . . . . . . . . . . . . . . . 13\n   Appendix A.  XML Schema
    for Partial Locking (Normative)  . . . . . 14\n   Appendix B.  YANG Module for
    Partial Locking (Non-Normative) . . . 17\n   Appendix C.  Usage Example - Reserving
    Nodes for Future\n                Editing (Non-Normative) . . . . . . . . . .
    . . . . . 19\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The [NETCONF] protocol describes the lock and unlock operations
    that\n   operate on entire configuration datastores.  Often, multiple\n   management
    sessions need to be able to modify the configuration of a\n   managed device in
    parallel.  In these cases, locking only parts of a\n   configuration datastore
    is needed.  This document defines a\n   capability-based extension to the NETCONF
    protocol to support partial\n   locking of the NETCONF running datastore using
    a mechanism based on\n   the existing XPath filtering mechanisms.\n"
  - contents:
    - "1.1.  Definition of Terms\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT
      RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted
      as described in BCP\n   14, [RFC2119].\n   Additionally, the following terms
      are defined:\n   o  Instance Identifier: an XPath expression identifying a specific\n
      \     node in the conceptual XML datastore.  It contains an absolute\n      path
      expression in abbreviated syntax, where predicates are used\n      only to specify
      values for nodes defined as keys to distinguish\n      multiple instances.\n
      \  o  Scope of the lock: initially, the set of nodes returned by the\n      XPath
      expressions in a successful partial-lock operation.  The set\n      might be
      modified if some of the nodes are deleted by the session\n      owning the lock.\n
      \  o  Protected area: the set of nodes that are protected from\n      modification
      by the lock.  This set consists of nodes in the scope\n      of the lock and
      nodes in subtrees under them.\n"
    title: 1.1.  Definition of Terms
  title: 1.  Introduction
- contents:
  - '2.  Partial Locking Capability

    '
  - contents:
    - "2.1.  Overview\n   The :partial-lock capability indicates that the device supports
      the\n   locking of its configuration with a more limited scope than a\n   complete
      configuration datastore.  The scope to be locked is\n   specified by using restricted
      or full XPath expressions.  Partial\n   locking only affects configuration data
      and only the running\n   datastore.  The candidate or the start-up datastore
      are not affected.\n   The system MUST ensure that configuration resources covered
      by the\n   lock are not modified by other NETCONF or non-NETCONF management\n
      \  operations such as Simple Network Management Protocol (SNMP) and the\n   Command
      Line Interface (CLI).\n   The duration of the partial lock begins when the partial
      lock is\n   granted and lasts until (1) either the corresponding <partial-unlock>\n
      \  operation succeeds or (2) the NETCONF session terminates.\n   A NETCONF session
      MAY have multiple parts of the running datastore\n   locked using partial lock
      operations.\n   The <partial-lock> operation returns a lock-id to identify each\n
      \  successfully acquired lock.  The lock-id is unique at any given time\n   for
      a NETCONF server for all partial-locks granted to any NETCONF or\n   non-NETCONF
      sessions.\n"
    - contents:
      - "2.1.1.  Usage Scenarios\n   In the following, we describe a few scenarios
        for partial locking.\n   Besides the two described here, there are many other
        usage scenarios\n   possible.\n"
      - contents:
        - "2.1.1.1.  Multiple Managers Handling the Writable Running Datastore with\n
          \         Overlapping Sections\n   Multiple managers are handling the same
          NETCONF agent simultaneously.\n   The agent is handled via the writable
          running datastore.  Each\n   manager has his or her own task, which might
          involve the modification\n   of overlapping sections of the datastore.\n
          \  After collecting and analyzing input and preparing the NETCONF\n   operations
          off-line, the manager locks the areas that are important\n   for his task
          using one single <partial-lock> operation.  The manager\n   executes a number
          of <edit-config> operations to modify the\n   configuration, then releases
          the partial-lock.  The lock should be\n   held for the shortest possible
          time (e.g., seconds rather than\n   minutes).  The manager should collect
          all human input before locking\n   anything.  As each manager locks only
          a part of the data model,\n   usually multiple operators can execute the
          <edit-config> operations\n   simultaneously.\n"
        title: 2.1.1.1.  Multiple Managers Handling the Writable Running Datastore
          with
      - contents:
        - "2.1.1.2.  Multiple Managers Handling the Writable Running Datastore,\n
          \         Distinct Management Areas\n   Multiple managers are handling the
          same NETCONF agent simultaneously.\n   The agent is handled via the writable
          running datastore.  The agent's\n   data model contains a number of well-defined
          separate areas that can\n   be configured without impacting other areas.
          \ An example can be a\n   server with multiple applications running on it,
          or a number of\n   network elements with a common NETCONF agent for management.\n
          \  Each manager has his or her own task, which does not involve the\n   modification
          of overlapping sections of the datastore.\n   The manager locks his area
          with a <partial-lock> operation, uses a\n   number of <edit-config> commands
          to modify it, and later releases the\n   lock.  As each manager has his
          functional area assigned to him, and\n   he locks only that area, multiple
          managers can edit the configuration\n   simultaneously.  Locks can be held
          for extended periods (e.g.,\n   minutes, hours), as this will not hinder
          other managers.\n   This scenario assumes that the global lock operation
          from [NETCONF]\n   is not used.\n"
        title: 2.1.1.2.  Multiple Managers Handling the Writable Running Datastore,
      title: 2.1.1.  Usage Scenarios
    title: 2.1.  Overview
  - contents:
    - "2.2.  Dependencies\n   The device MUST support restricted XPath expressions
      in the select\n   element, as described in Section 2.4.1.  Optionally, if the
      :xpath\n   capability is also supported (as defined in [NETCONF], Section 8.9.\n
      \  \"XPath Capability\"), the device MUST also support using any XPath 1.0\n
      \  expression in the select element.\n"
    title: 2.2.  Dependencies
  - contents:
    - "2.3.  Capability Identifier\n   urn:ietf:params:netconf:capability:partial-lock:1.0\n"
    title: 2.3.  Capability Identifier
  - contents:
    - '2.4.  New Operations

      '
    - contents:
      - "2.4.1.  <partial-lock>\n   The <partial-lock> operation allows the client
        to lock a portion of\n   the running datastore.  The portion to lock is specified
        with XPath\n   expressions in the \"select\" elements in the <partial-lock>
        operation.\n   Each XPath expression MUST return a node set.\n   When a NETCONF
        session holds a lock on a node, no other session or\n   non-NETCONF mechanism
        of the system can change that node or any node\n   in the hierarchy of nodes
        beneath it.\n   Locking a node protects the node itself and the complete subtree\n
        \  under the node from modification by others.  The set of locked nodes\n
        \  is called the scope of the lock, while all the locked nodes and the\n   nodes
        in the subtrees under them make up the protected area.\n   The XPath expressions
        are evaluated only once: at lock time.\n   Thereafter, the scope of the lock
        is maintained as a set of nodes,\n   i.e., the returned nodeset, and not by
        the XPath expression.  If the\n   configuration data is later altered in a
        way that would make the\n   original XPath expressions evaluate to a different
        set of nodes, this\n   does not affect the scope of the partial lock.\n   Let's
        say the agent's data model includes a list of interface nodes.\n   If the
        XPath expression in the partial-lock operation covers all\n   interface nodes
        at locking, the scope of the lock will be maintained\n   as the list of interface
        nodes at the time when the lock was granted.\n   If someone later creates
        a new interface, this new interface will not\n   be included in the locked-nodes
        list created previously so the new\n   interface will not be locked.\n   A
        <partial-lock> operation MUST be handled atomically by the NETCONF\n   server.
        \ The server either locks all requested parts of the datastore\n   or none.
        \ If during the <partial-lock> operation one of the requested\n   parts cannot
        be locked, the server MUST unlock all parts that have\n   already been locked
        during that operation.\n   If a node in the scope of the lock is deleted by
        the session owning\n   the lock, it is removed from the scope of the lock,
        so any other\n   session or non-NETCONF mechanism can recreate it.  If all
        nodes in\n   the scope of the lock are deleted, the lock will still be present.\n
        \  However, its scope will become empty (since the lock will not cover\n   any
        nodes).\n   A NETCONF server that supports partial locking MUST be able to
        grant\n   multiple simultaneous partial locks to a single NETCONF session.
        \ If\n   the protected area of the individual locks overlap, nodes in the\n
        \  common area MUST be protected until all of the overlapping locks are\n
        \  released.\n   A <partial-lock> operation MUST fail if:\n   o  Any NETCONF
        session (including the current session) owns the\n      global lock on the
        running datastore.\n   o  Any part of the area to be protected is already
        locked (or\n      protected by partial locking) by another management session,\n
        \     including other NETCONF sessions using <partial-lock> or any other\n
        \     non-NETCONF management method.\n   o  The requesting user is not successfully
        authenticated.\n   o  The NETCONF server implements access control and the
        locking user\n      does not have sufficient access rights.  The exact handling
        of\n      access rights is outside the scope of this document, but it is\n
        \     assumed that there is an access control system that MAY deny or\n      allow
        the <partial-lock> operation.\n   The <partial-lock> operation is designed
        for simplicity, so when a\n   partial lock is executed, you get what you asked
        for: a set of nodes\n   that are locked for writing.\n   As a consequence,
        users must observe the following:\n   o  Locking does not affect read operations.\n
        \  o  If part of the running datastore is locked, this has no effect on\n
        \     any unlocked parts of the datastore.  If this is a problem (e.g.,\n
        \     changes depend on data values or nodes outside the protected part\n
        \     of the datastore), these nodes SHOULD be included in the protected\n
        \     area of the lock.\n   o  Configuration data can be edited both inside
        and outside the\n      protected area of a lock.  It is the responsibility
        of the NETCONF\n      client application to lock all relevant parts of the
        datastore\n      that are crucial for a specific management action.\n   Note:
        The <partial-lock> operation does not modify the global <lock>\n   operation
        defined in the base NETCONF protocol [NETCONF].  If part of\n   the running
        datastore is already locked by <partial-lock>, then a\n   global lock for
        the running datastore MUST fail even if the global\n   lock is requested by
        the NETCONF session that owns the partial lock.\n"
      - contents:
        - "2.4.1.1.  Parameters, Results, Examples\n   Parameters:\n   select:  One
          or more 'select' elements, each containing an XPath\n            expression.
          \ The XPath expression is evaluated in a context\n            where the
          context node is the root of the server's\n            conceptual data model,
          and the set of namespace declarations\n            are those in scope on
          the select element.\n   The nodes returned from the select expressions are
          reported in the\n       rpc-reply message.\n   Each select expression MUST
          return a node set, and at least one of\n       the node sets MUST be non-empty.\n
          \  If the device supports the :xpath capability, any valid XPath 1.0\n       expression
          can be used.  If the device does not support the\n       :xpath capability,
          the XPath expression MUST be limited to an\n       Instance Identifier expression.
          \ An Instance Identifier is an\n       absolute path expression in abbreviated
          syntax, where predicates\n       are used only to specify values for nodes
          defined as keys to\n       distinguish multiple instances.\n   Example:
          Lock virtual router 1 and interface eth1\n    <nc:rpc\n      xmlns=\"urn:ietf:params:xml:ns:netconf:partial-lock:1.0\"\n
          \     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n      message-id=\"135\">\n
          \       <partial-lock>\n            <select xmlns:rte=\"http://example.com/ns/route\">\n
          \               /rte:routing/rte:virtualRouter[rte:routerName='router1']\n
          \           </select>\n            <select xmlns:if=\"http://example.com/ns/interface\">\n
          \               /if:interfaces/if:interface[if:id='eth1']\n            </select>\n
          \        </partial-lock>\n    </nc:rpc>\n    <nc:rpc-reply\n      xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n
          \     xmlns=\"urn:ietf:params:xml:ns:netconf:partial-lock:1.0\"\n      message-id=\"135\">\n
          \       <lock-id>127</lock-id>\n        <locked-node xmlns:rte=\"http://example.com/ns/route\">\n
          \           /rte:routing/rte:virtualRouter[rte:routerName='router1']\n        </locked-node>\n
          \       <locked-node xmlns:if=\"http://example.com/ns/interface\">\n            /if:interfaces/if:interface[if:id='eth1']\n
          \       </locked-node>\n    </nc:rpc-reply>\n   Note: The XML Schema in
          [NETCONF] has a known bug that requires the\n   <data> XML element in a
          <rpc-reply>.  This means that the above\n   examples will not validate using
          the XML Schema found in [NETCONF].\n   Positive Response:\n   If the device
          was able to satisfy the request, an <rpc-reply> is sent\n   with a <lock-id>
          element (lock identifier) in the <rpc-reply>\n   element.  A list of locked
          nodes is also returned in Instance\n   Identifier format.\n   Negative Response:\n
          \  If any select expression is an invalid XPath expression, the <error-\n
          \  tag> is 'invalid-value'.\n   If any select expression returns something
          other than a node set, the\n   <error-tag> is 'invalid-value', and the <error-app-tag>
          is 'not-a-\n   node-set'.\n   If all the select expressions return an empty
          node set, the <error-\n   tag> is 'operation-failed', and the <error-app-tag>
          is 'no-matches'.\n   If the :xpath capability is not supported and the XPath
          expression is\n   not an Instance Identifier, the <error-tag> is 'invalid-value',
          the\n   <error-app-tag> is 'invalid-lock-specification'.\n   If access control
          denies the partial lock, the <error-tag> is\n   'access-denied'.  Access
          control SHOULD be checked before checking\n   for conflicting locks to avoid
          giving out information about other\n   sessions to an unauthorized client.\n
          \  If a lock is already held by another session on any node within the\n
          \  subtrees to be locked, the <error-tag> element is 'lock-denied' and\n
          \  the <error-info> element includes the <session-id> of the lock owner.\n
          \  If the lock is held by a non-NETCONF session, a <session-id> of 0\n   (zero)
          SHOULD be included.  The same error response is returned if\n   the requesting
          session already holds the (global) lock for the\n   running datastore.\n
          \  If needed, the returned session-id may be used to <kill-session> the\n
          \  NETCONF session holding the lock.\n"
        title: 2.4.1.1.  Parameters, Results, Examples
      - contents:
        - "2.4.1.2.  Deadlock Avoidance\n   As with most locking systems, it is possible
          that two management\n   sessions trying to lock different parts of the configuration
          could\n   become deadlocked.  To avoid this situation, clients SHOULD lock\n
          \  everything they need in one operation.  If locking fails, the client\n
          \  MUST back-off, release any previously acquired locks, and SHOULD\n   retry
          the procedure after waiting some randomized time interval.\n"
        title: 2.4.1.2.  Deadlock Avoidance
      title: 2.4.1.  <partial-lock>
    - contents:
      - "2.4.2.  <partial-unlock>\n   The operation unlocks the parts of the running
        datastore that were\n   previously locked using <partial-lock> during the
        same session.  The\n   operation unlocks the parts that are covered by the
        lock identified\n   by the lock-id parameter.  In case of multiple potentially\n
        \  overlapping locks, only the lock identified by the lock-id is\n   removed.\n
        \  Parameters:\n   lock-id:  Identity of the lock to be unlocked.  This lock-id
        MUST\n             have been received as a response to a lock request by the\n
        \            manager during the current session, and MUST NOT have been\n
        \            sent in a previous unlock request.\n   Example: Unlock a previously
        created lock\n      <nc:rpc xmlns=\"urn:ietf:params:xml:ns:netconf:partial-lock:1.0\"\n
        \       xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n        message-id=\"136\">\n
        \         <partial-unlock>\n            <lock-id>127</lock-id>\n          </partial-unlock>\n
        \     </nc:rpc>\n   Positive Response:\n   If the device was able to satisfy
        the request, an <rpc-reply> is sent\n   that contains an <ok> element.  A
        positive response MUST be sent even\n   if all of the locked parts of the
        datastore have already been\n   deleted.\n   Negative Response:\n   If the
        <lock-id> parameter does not identify a lock that is owned by\n   the session,
        an 'invalid-value' error is returned.\n"
      title: 2.4.2.  <partial-unlock>
    title: 2.4.  New Operations
  - contents:
    - "2.5.  Modifications to Existing Operations\n   A successful partial lock will
      cause a subsequent operation to fail\n   if that operation attempts to modify
      nodes in the protected area of\n   the lock and is executed in a NETCONF session
      other than the session\n   that has been granted the lock.  The <error-tag>
      'in-use' and the\n   <error-app-tag> 'locked' is returned.  All operations that
      modify the\n   running datastore are affected, including: <edit-config>, <copy-\n
      \  config>, <delete-config>, <commit>, and <discard-changes>.  If\n   partial
      lock prevents <edit-config> from modifying some data, but the\n   operation
      includes the continue-on-error option, modification of\n   other parts of the
      datastore, which are not protected by partial\n   locking, might still succeed.\n
      \  If the datastore contains nodes locked by partial lock, this will\n   cause
      the (global) <lock> operation to fail.  The <error-tag> element\n   'lock-denied'
      and an <error-info> element including the <session-id>\n   of the lock owner
      will be returned.  If the lock is held by a non-\n   NETCONF session, a <session-id>
      of 0 (zero) is returned.\n   All of these operations are affected only if they
      are targeting the\n   running datastore.\n"
    title: 2.5.  Modifications to Existing Operations
  - contents:
    - '2.6.  Interactions with Other Capabilities

      '
    - contents:
      - "2.6.1.  Candidate Configuration Capability\n   The candidate datastore cannot
        be locked using the <partial-lock>\n   operation.\n"
      title: 2.6.1.  Candidate Configuration Capability
    - contents:
      - "2.6.2.  Confirmed Commit Capability\n   If:\n   o  a partial lock is requested
        for the running datastore, and\n   o  the NETCONF server implements the :confirmed-commit
        capability,\n      and\n   o  there was a recent confirmed <commit> operation
        where the\n      confirming <commit> operation has not been received\n   then
        the lock MUST be denied, because if the confirmation does not\n   arrive,
        the running datastore MUST be rolled back to its state before\n   the commit.
        \ The NETCONF server might therefore need to modify the\n   configuration.\n
        \  In this case, the <error-tag> 'in-use' and the <error-app-tag>\n   'outstanding-confirmed-commit'
        is returned.\n"
      title: 2.6.2.  Confirmed Commit Capability
    - contents:
      - "2.6.3.  Distinct Startup Capability\n   The startup datastore cannot be locked
        using the <partial-lock>\n   operation.\n"
      title: 2.6.3.  Distinct Startup Capability
    title: 2.6.  Interactions with Other Capabilities
  title: 2.  Partial Locking Capability
- contents:
  - "3.  Security Considerations\n   The same considerations are relevant as for the
    base NETCONF protocol\n   [NETCONF]. <partial-lock> and <partial-unlock> RPCs
    MUST only be\n   allowed for an authenticated user. <partial-lock> and <partial-\n
    \  unlock> RPCs SHOULD only be allowed for an authorized user.  However,\n   as
    NETCONF access control is not standardized and not a mandatory\n   part of a NETCONF
    implementation, it is strongly recommended, but\n   OPTIONAL (although nearly
    all implementations include some kind of\n   access control).\n   A lock (either
    a partial lock or a global lock) might prevent other\n   users from configuring
    the system.  The following mechanisms are in\n   place to prevent the misuse of
    this possibility:\n      A user, that is not successfully authenticated, MUST
    NOT be\n      granted a partial lock.\n      Only an authorized user SHOULD be
    able to request a partial lock.\n      The partial lock is automatically released
    when a session is\n      terminated regardless of how the session ends.\n      The
    <kill-session> operation makes it possible to terminate other\n      users' sessions.\n
    \     The NETCONF server MAY log partial lock requests in an audit\n      trail.\n
    \  A lock that is hung for some reason (e.g., a broken TCP connection\n   that
    the server has not yet recognized) can be released using another\n   NETCONF session
    by explicitly killing the session owning that lock\n   using the <kill-session>
    operation.\n   Partial locking is not an authorization mechanism; it SHOULD NOT
    be\n   used to provide security or access control.  Partial locking SHOULD\n   only
    be used as a mechanism for providing consistency when multiple\n   managers are
    trying to configure the node.  It is vital that users\n   easily understand the
    exact scope of a lock.  This is why the scope\n   is determined when granting
    a lock and is not modified thereafter.\n"
  title: 3.  Security Considerations
- contents:
  - "4.  IANA Considerations\n   This document registers one capability identifier
    URN from the\n   \"Network Configuration Protocol (NETCONF) Capability URNs\"
    registry,\n   and one URI for the NETCONF XML namespace in the \"IETF XML registry\"\n
    \  [RFC3688].  Note that the capability URN is compliant to [NETCONF],\n   Section
    10.3.\n   Index           Capability Identifier\n   -------------   ---------------------------------------------------\n
    \  :partial-lock   urn:ietf:params:netconf:capability:partial-lock:1.0\n   URI:
    urn:ietf:params:xml:ns:netconf:partial-lock:1.0\n   Registrant Contact: The IESG.\n
    \  XML: N/A, the requested URI is an XML namespace.\n"
  title: 4.  IANA Considerations
- contents:
  - "5.  Acknowledgements\n   Thanks to Andy Bierman, Sharon Chisholm, Phil Shafer,
    David\n   Harrington, Mehmet Ersue, Wes Hardaker, Juergen Schoenwaelder, Washam\n
    \  Fan, and many other members of the NETCONF WG for providing important\n   input
    to this document.\n"
  title: 5.  Acknowledgements
- contents:
  - '6.  References

    '
  - contents:
    - "6.1.  Normative References\n   [NETCONF]  Enns, R., \"NETCONF Configuration
      Protocol\", RFC 4741,\n              December 2006.\n   [RFC2119]  Bradner,
      S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\",
      BCP 14, RFC 2119, March 1997.\n   [RFC3688]  Mealling, M., \"The IETF XML Registry\",
      BCP 81, RFC 3688,\n              January 2004.\n"
    title: 6.1.  Normative References
  - contents:
    - "6.2.  Informative References\n   [YANG]     Bjorklund, M., \"YANG - A data
      modeling language for\n              NETCONF\", Work in Progress, December 2009.\n"
    title: 6.2.  Informative References
  title: 6.  References
- contents:
  - "Appendix A.  XML Schema for Partial Locking (Normative)\n   The following XML
    Schema defines the <partial-lock> and <partial-\n   unlock> operations:\n   <CODE
    BEGINS>\n"
  - '<?xml version="1.0" encoding="UTF-8"?>

    '
  - "<xs:schema xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n    xmlns=\"urn:ietf:params:xml:ns:netconf:partial-lock:1.0\"\n
    \   xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n    targetNamespace=\"urn:ietf:params:xml:ns:netconf:partial-lock:1.0\"\n
    \   elementFormDefault=\"qualified\" attributeFormDefault=\"unqualified\">\n    <xs:annotation>\n
    \       <xs:documentation>\n            Schema defining the partial-lock and unlock
    operations.\n            organization \"IETF NETCONF Working Group\"\n            contact\n
    \           Netconf Working Group\n            Mailing list: netconf@ietf.org\n
    \           Web: http://www.ietf.org/html.charters/netconf-charter.html\n            Balazs
    Lengyel\n            balazs.lengyel@ericsson.com\n            revision 2009-10-19\n
    \           description Initial version, published as RFC 5717.\n        </xs:documentation>\n
    \   </xs:annotation>\n    <xs:import namespace=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n
    \       schemaLocation=\"urn:ietf:params:xml:ns:netconf:base:1.0\"/>\n    <xs:simpleType
    name=\"lock-id-type\">\n        <xs:annotation>\n            <xs:documentation>\n
    \               A number identifying a specific\n                partial-lock
    granted to a session.\n                It is allocated by the system, and SHOULD\n
    \               be used in the unlock operation.\n            </xs:documentation>\n
    \       </xs:annotation>\n        <xs:restriction base=\"xs:unsignedInt\"/>\n
    \   </xs:simpleType>\n    <xs:complexType name=\"partialLockType\">\n        <xs:annotation>\n
    \           <xs:documentation>\n                A NETCONF operation that locks
    parts of\n                  the running datastore.\n            </xs:documentation>\n
    \       </xs:annotation>\n        <xs:complexContent>\n            <xs:extension
    base=\"nc:rpcOperationType\">\n                <xs:sequence>\n                    <xs:element
    name=\"select\" type=\"xs:string\"\n                        maxOccurs=\"unbounded\">\n
    \                       <xs:annotation>\n                          <xs:documentation>\n
    \                           XPath expression that specifies the scope\n                            of
    the lock.  An Instance Identifier\n                            expression must
    be used unless the :xpath\n                            capability is supported
    in which case any\n                            XPath 1.0 expression is allowed.\n
    \                         </xs:documentation>\n                        </xs:annotation>\n
    \                   </xs:element>\n                </xs:sequence>\n            </xs:extension>\n
    \       </xs:complexContent>\n    </xs:complexType>\n    <xs:complexType name=\"partialUnLockType\">\n
    \       <xs:annotation>\n            <xs:documentation>\n                A NETCONF
    operation that releases a previously acquired\n                partial-lock.\n
    \           </xs:documentation>\n        </xs:annotation>\n        <xs:complexContent>\n
    \           <xs:extension base=\"nc:rpcOperationType\">\n                <xs:sequence>\n
    \                   <xs:element name=\"lock-id\" type=\"lock-id-type\">\n                        <xs:annotation>\n
    \                         <xs:documentation>\n                            Identifies
    the lock to be released.  MUST\n                            be the value received
    in the response to\n                            the partial-lock operation.\n
    \                         </xs:documentation>\n                        </xs:annotation>\n
    \                   </xs:element>\n                </xs:sequence>\n            </xs:extension>\n
    \       </xs:complexContent>\n    </xs:complexType>\n    <!-- <partial-lock> operation
    -->\n    <xs:element name=\"partial-lock\" type=\"partialLockType\"\n        substitutionGroup=\"nc:rpcOperation\"/>\n
    \   <!-- <partial-unlock> operation -->\n    <xs:element name=\"partial-unlock\"
    type=\"partialUnLockType\"\n        substitutionGroup=\"nc:rpcOperation\"/>\n
    \   <!-- reply to <partial-lock> -->\n    <xs:complexType name=\"contentPartInPartialLockReplyType\">\n
    \       <xs:annotation>\n            <xs:documentation>\n                The content
    of the reply to a successful\n                partial-lock request MUST conform
    to this complex type.\n            </xs:documentation>\n        </xs:annotation>\n
    \       <xs:sequence>\n            <xs:element name=\"lock-id\" type=\"lock-id-type\">\n
    \             <xs:annotation>\n                <xs:documentation>\n                  Identifies
    the lock to be released.  Must be the value\n                  received in the
    response to a partial-lock operation.\n                </xs:documentation>\n              </xs:annotation>\n
    \           </xs:element>\n            <xs:element name=\"locked-node\" type=\"xs:string\"\n
    \               maxOccurs=\"unbounded\">\n                <xs:annotation>\n                    <xs:documentation>\n
    \                       List of locked nodes in the running datastore.\n                    </xs:documentation>\n
    \               </xs:annotation>\n            </xs:element>\n        </xs:sequence>\n
    \   </xs:complexType>\n"
  - "</xs:schema>\n   <CODE ENDS>\n"
  title: Appendix A.  XML Schema for Partial Locking (Normative)
- contents:
  - "Appendix B.  YANG Module for Partial Locking (Non-Normative)\n   The following
    YANG module defines the <partial-lock> and <partial-\n   unlock> operations.  The
    YANG language is defined in [YANG].\n   <CODE BEGINS>\n"
  - "module ietf-netconf-partial-lock {\n  namespace urn:ietf:params:xml:ns:netconf:partial-lock:1.0;\n
    \ prefix pl;\n  organization \"IETF Network Configuration (netconf) Working Group\";\n
    \ contact\n   \"Netconf Working Group\n    Mailing list: netconf@ietf.org\n    Web:
    http://www.ietf.org/html.charters/netconf-charter.html\n    Balazs Lengyel\n    Ericsson\n
    \   balazs.lengyel@ericsson.com\";\n  description\n   \"This YANG module defines
    the <partial-lock> and\n    <partial-unlock> operations.\";\n  revision 2009-10-19
    {\n    description\n     \"Initial version, published as RFC 5717.\";\n  }\n  typedef
    lock-id-type {\n    type uint32;\n    description\n     \"A number identifying
    a specific partial-lock granted to a session.\n      It is allocated by the system,
    and SHOULD be used in the\n      partial-unlock operation.\";\n  }\n  rpc partial-lock
    {\n    description\n     \"A NETCONF operation that locks parts of the running
    datastore.\";\n    input {\n      leaf-list select {\n        type string;\n        min-elements
    1;\n        description\n         \"XPath expression that specifies the scope
    of the lock.\n          An Instance Identifier expression MUST be used unless
    the\n          :xpath capability is supported, in which case any XPath 1.0\n          expression
    is allowed.\";\n      }\n    }\n    output {\n      leaf lock-id {\n        type
    lock-id-type;\n        description\n         \"Identifies the lock, if granted.
    \ The lock-id SHOULD be\n          used in the partial-unlock rpc.\";\n      }\n
    \     leaf-list locked-node {\n        type instance-identifier;\n        min-elements
    1;\n        description\n         \"List of locked nodes in the running datastore\";\n
    \     }\n    }\n  }\n  rpc partial-unlock {\n    description\n     \"A NETCONF
    operation that releases a previously acquired\n      partial-lock.\";\n    input
    {\n      leaf lock-id {\n        type lock-id-type;\n        description\n         \"Identifies
    the lock to be released.  MUST be the value\n          received in the response
    to a partial-lock operation.\";\n      }\n    }\n  }\n"
  - "}\n   <CODE ENDS>\n"
  title: Appendix B.  YANG Module for Partial Locking (Non-Normative)
- contents:
  - "Appendix C.  Usage Example - Reserving Nodes for Future Editing\n             (Non-Normative)\n
    \  Partial lock cannot be used to lock non-existent nodes, which would\n   effectively
    attempt to reserve them for future use.  To guarantee\n   that a node cannot be
    created by some other session, the parent node\n   should be locked, the top-level
    node of the new subtree created, and\n   then locked with another <partial-lock>
    operation.  After this, the\n   lock on the parent node should be removed.\n   In
    this section, an example illustrating the above is given.\n   We want to create
    <user> Joe under <users>, and start editing it.\n   Editing might take a number
    of minutes.  We want to immediately lock\n   Joe so no one will touch it before
    we are finished with the editing.\n   We also want to minimize locking other parts
    of the running datastore\n   as multiple managers might be adding users near simultaneously.\n
    \  First, we check what users are already defined.\n   Step 1 - Read existing
    users\n   <rpc message-id=\"101\"\n       xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n
    \    <get-config>\n       <source>\n         <running/>\n       </source>\n       <filter
    type=\"subtree\">\n         <top xmlns=\"http://example.com/users\">\n           <users/>\n
    \        </top>\n       </filter>\n     </get-config>\n   </rpc>\n   The NETCONF
    server sends the following reply.\n   Step 2 - Receiving existing data\n   <rpc-reply
    message-id=\"101\"\n        xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n
    \    <data>\n       <top xmlns=\"http://example.com/users\">\n         <users>\n
    \          <user>\n             <name>fred</name>\n             <phone>8327</phone>\n
    \          </user>\n         </users>\n       </top>\n     </data>\n   </rpc-reply>\n
    \  We want to add the new user Joe and immediately lock him using\n   partial
    locking.  The way to do this, is to first lock all <user>\n   nodes by locking
    the <users> node.\n   Note that if we would lock all the <user> nodes using the
    select\n   expression '/usr:top/usr:users/usr:user'; this would not lock the new\n
    \  user Joe, which we will create after locking.  So we rather have to\n   lock
    the <users> node.\n   Step 3 - Lock users\n   <nc:rpc\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n
    \    xmlns=\"urn:ietf:params:xml:ns:netconf:partial-lock:1.0\"\n         message-id=\"102\">\n
    \    <partial-lock>\n       <select xmlns:usr=\"http://example.com/users\">\n
    \        /usr:top/usr:users\n       </select>\n     </partial-lock>\n   </nc:rpc>\n
    \  The NETCONF server grants the partial lock.  The scope of the lock\n   includes
    only the <users> node.  The lock protects the <users> node\n   and all <user>
    nodes below it from modification (by other sessions).\n   Step 4 - Receive lock\n
    \  <nc:rpc-reply\n     xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n
    \    xmlns=\"urn:ietf:params:xml:ns:netconf:partial-lock:1.0\"\n     message-id=\"102\">\n
    \      <lock-id>1</lock-id>\n       <locked-node xmlns:usr=\"http://example.com/users\">\n
    \          /usr:top/usr:users\n       </locked-node>\n   </nc:rpc-reply>\n   Next
    we create user Joe.  Joe is protected by the lock received\n   above, as it is
    under the subtree rooted at the <users> node.\n   Step 5 - Create user Joe\n   <rpc
    message-id=\"103\"\n        xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n
    \    <edit-config>\n       <target>\n         <running/>\n       </target>\n       <config>\n
    \        <top xmlns:usr=\"http://example.com/users\">\n           <users>\n             <user>\n
    \              <name>Joe</name>\n             </user>\n           </users>\n         </top>\n
    \      </config>\n     </edit-config>\n   </rpc>\n   We receive a positive reply
    to the <edit-config> (not shown).  Next\n   we request a lock, that locks only
    <user> Joe, and release the lock\n   on the <users> node.  This will allow other
    managers to create\n   additional new users.\n   Step 6 - Lock user Joe\n   <nc:rpc\n
    \    xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:partial-lock:1.0\"\n
    \        message-id=\"104\">\n     <partial-lock>\n       <select xmlns:usr=\"http://example.com/users\">\n
    \        /usr:top/usr:users/user[usr:name=\"Joe\"]\"\n       </select>\n     </partial-lock>\n
    \  </nc:rpc>\n   The NETCONF server grants the partial lock.  The scope of this
    second\n   lock includes only the <user> node with name Joe.  The lock protects\n
    \  all data below this particular <user> node.\n   Step 7 - Receive lock\n   <nc:rpc-reply\n
    \    xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n     xmlns=\"urn:ietf:params:xml:ns:netconf:partial-lock:1.0\"\n
    \    message-id=\"104\">\n       <lock-id>2</lock-id>\n       <locked-node xmlns:usr=\"http://example.com/users\">\n
    \          /usr:top/usr:users/user[usr:name=\"Joe\"]\"\n       </locked-node>\n
    \  </nc:rpc-reply>\n   The scope of the second lock is the <user> node Joe.  It
    protects\n   this <user> node and any data below it (e.g., phone number).  At
    this\n   point of time, these nodes are protected both by the first and second\n
    \  lock.  Next, we unlock the other <user>s and the <users> node, to\n   allow
    other managers to work on them.  We still keep the second lock,\n   so the <user>
    node Joe and the subtree below is still protected.\n   Step 8 - Release lock on
    <users>\n   <nc:rpc xmlns=\"urn:ietf:params:xml:ns:netconf:partial-lock:1.0\"\n
    \      xmlns:nc=\"urn:ietf:params:xml:ns:netconf:base:1.0\"\n       message-id=\"105\">\n
    \    <partial-unlock>\n       <lock-id>1</lock-id>\n     </partial-unlock>\n   </nc:rpc>\n"
  title: Appendix C.  Usage Example - Reserving Nodes for Future Editing
- contents:
  - "Authors' Addresses\n   Balazs Lengyel\n   Ericsson\n   EMail: balazs.lengyel@ericsson.com\n
    \  Martin Bjorklund\n   Tail-f Systems\n   EMail: mbj@tail-f.com\n"
  title: Authors' Addresses
