- title: __initial_text__
  contents:
  - '         Interoperability Rules for Multicast Routing Protocols

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   The rules described in this document will allow efficient\n   interoperation\
    \ among multiple independent multicast routing domains.\n   Specific instantiations\
    \ of these rules are given for the DVMRP,\n   MOSPF, PIM-DM, PIM-SM, and CBT multicast\
    \ routing protocols, as well\n   as for IGMP-only links.  Future versions of these\
    \ protocols, and any\n   other multicast routing protocols, may describe their\n\
    \   interoperability procedure by stating how the rules described herein\n   apply\
    \ to them.\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   To allow sources and receivers inside multiple autonomous\
    \ multicast\n   routing domains (or \"regions\") to communicate, the domains must\
    \ be\n   connected by multicast border routers (MBRs).  To prevent black holes\n\
    \   or routing loops among domains, we assume that these domains are\n   organized\
    \ into one of the following topologies:\n   o  A tree (or star) topology (figure\
    \ 1) with a backbone domain at the\n      root, stub domains at the leaves, and\
    \ possibly \"transit\" domains\n      as branches between the root and the leaves.\
    \  Each pair of\n      adjacent domains is connected by one or more MBRs.  The\
    \ root of\n      each subtree of domains receives all globally-scoped traffic\n\
    \      originated anywhere within the subtree, and forwards traffic to\n     \
    \ its parent and children where needed.  Each parent domain's MBR\n      injects\
    \ a default route into its child domains, while child\n      domains' MBRs inject\
    \ actual (but potentially aggregated) routes\n      into parent domains.  Thus,\
    \ the arrows in the figure indicate both\n      the direction in which the default\
    \ route points, as well as the\n      direction in which all globally-scoped traffic\
    \ is sent.\n                                 +--------+\n                    \
    \      +----|        |----+\n          +---+    +---+  |  ===>      <===  |\n\
    \          |   |    |   |  +----|   #    |----+\n          |   |    | # |    \
    \ +-----#------+\n          | # |  +---#-------|     v      |-----------+\n  \
    \       +--#----|   v       |            |           |-----+\n         |  v  ===>\
    \        ===> Backbone <===        <===   |\n         +-------|   ^       |  \
    \          |     ^     |-----+\n                 +---#-------|     ^      |-----#-----+\n\
    \                   | # |     +-----#------+ |   #    |-----+\n              \
    \     |   |       |   #    |   |       <===   |\n                   +---+   +---|\
    \        |   |        |-----+\n                           | ===>       |   +--------+\n\
    \                           +---+--------+\n                 Figure 1: Tree Topology\
    \ of Domains\n   o  An arbitrary topology, in which a higher level (inter-domain)\n\
    \      routing protocol, such as HDVMRP [1] or BGMP [9], is used to\n      calculate\
    \ paths among domains.  Each pair of adjacent domains is\n      connected by one\
    \ or more MBRs.\n   Section 2 describes rules allowing interoperability between\
    \ existing\n   multicast routing protocols [2,3,4,5,6], and reduces the\n   interoperability\
    \ problem from O(N^2) potential protocol interactions,\n   to just N (1 per protocol)\
    \ instantiations of the same set of\n   invariant rules.  This document specifically\
    \ applies to Multicast\n   Border Routers (MBRs) which meet the following assumptions:\n\
    \   o  The MBR consists of two or more active multicast routing\n      components,\
    \ each running an instance of some multicast routing\n      protocol.  No assumption\
    \ is made about the type of multicast\n      routing protocol (e.g., broadcast-and-prune\
    \ vs. explicit-join) any\n      component runs, or the nature of a \"component\"\
    .  Multiple\n      components running the same protocol are allowed.\n   o  The\
    \ router is configured to forward packets between two or more\n      independent\
    \ domains.  The router has one or more active interfaces\n      in each domain,\
    \ and one component per domain.  The router also has\n      an inter-component\
    \ \"alert dispatcher\", which we cover in Section\n      3.\n   o  Only one multicast\
    \ routing protocol is active per interface (we do\n      not consider mixed multicast\
    \ protocol LANs).  Each interface on\n      which multicast is enabled is thus\
    \ \"owned\" by exactly one of the\n      components.\n   o  All components share\
    \ a common forwarding cache of (S,G) entries,\n      which are created when data\
    \ packets are received, and can be\n      deleted at any time.  Only the component\
    \ owning an interface may\n      change information about that interface in the\
    \ forwarding cache.\n      Each forwarding cache entry has a single incoming interface\
    \ (iif)\n      and a list of outgoing interfaces (oiflist).  Each component\n\
    \      typically keeps a separate multicast routing table with any type\n    \
    \  of entries.\n   Note that the guidelines in this document are implementation-\n\
    \   independent.  The same rules given in Section 2 apply in some form,\n   regardless\
    \ of the implementation.  For example, they apply to each of\n   the following\
    \ architectural models:\n   o  Single process (e.g., GateD): Several routing components\
    \ in the\n      same user-space process, running on top of a multicast-capable\n\
    \      kernel.\n   o  Multiple peer processes: Several routing components, each\
    \ as a\n      separate user-space process, all sitting on top of a multicast-\n\
    \      capable kernel, with N*(N-1) interaction channels.\n   o  Multiple processes\
    \ with arbiter: Multiple independent peer routing\n      component processes which\
    \ interact with each other and with the\n      kernel solely through an independent\
    \ arbitration daemon.\n   o  Monolith: Several routing components which are part\
    \ of the\n      \"kernel\" itself.\n   We describe all interactions between components\
    \ in terms of \"alerts\".\n   The nature of an alert is implementation-dependent\
    \ (e.g., it may\n   consist of a simple function call, writing to shared memory,\
    \ use of\n   IPC, or some other method) but alerts of some form exist in every\n\
    \   model. Similarly, the originator of an alert is also implementation-\n   dependent;\
    \ for example, alerts may be originated by a component\n   effecting a change,\
    \ by an independent arbiter, or by the kernel.\n"
- title: 1.1.  Specification Language
  contents:
  - "1.1.  Specification Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119.\n"
- title: 2.  Requirements
  contents:
  - "2.  Requirements\n   To insure that a MBR fitting the above assumptions exhibits\
    \ correct\n   interdomain routing behavior, each MBR component MUST adhere to\
    \ the\n   following rules:\n   Rule 1: All components must agree on which component\
    \ owns the\n           incoming interface (iif) for a forwarding cache entry.\
    \ This\n           component, which we call the \"iif owner\" is determined by\
    \ the\n           dispatcher (see Section 3).  The incoming component may\n  \
    \         select ANY interface it owns as the iif according to its own\n     \
    \      rules.\n   When a routing change occurs which causes the iif to change\
    \ to an\n   interface owned by a different component, both the component\n   previously\
    \ owning the entry's iif and the component afterwards owning\n   the entry's iif\
    \ MUST notice the change (so the first can prune\n   upstream and the second can\
    \ join/graft upstream, for example).\n   Typically, noticing such changes will\
    \ happen as a result of normal\n   protocol behavior.\n   Rule 2: The component\
    \ owning an interface specifies the criteria for\n           which packets received\
    \ on that interface are to be accepted\n           or dropped (e.g., whether to\
    \ perform an RPF check, and what\n           scoped boundaries exist on that interface).\
    \  Once a packet is\n           accepted, however, it is processed according to\
    \ the\n           forwarding rules of all components.\n   Furthermore, some multicast\
    \ routing protocols (e.g. PIM) also require\n   the ability to react to packets\
    \ received on the \"wrong\" interface. To\n   support these protocols, an MBR\
    \ must allow a component to place any\n   of its interfaces in \"WrongIf Alert\
    \ Mode\".  If a packet arrives on\n   such an interface, and is not accepted according\
    \ to Rule 2, then the\n   component owning the interface MUST be alerted [(S,G)\
    \ WrongIf alert].\n   Typically, WrongIf alerts must be rate-limited.\n   Rule\
    \ 3: Whenever a new (S,G) forwarding cache entry is to be created\n          \
    \ (e.g., upon accepting a packet destined to a non-local\n           group), all\
    \ components MUST be alerted [(S,G) Creation alert]\n           so that they can\
    \ set the forwarding state on their own\n           outgoing interfaces (oifs)\
    \ before the packet is forwarded.\n   Note that (S,G) Creation alerts are not\
    \ necessarily generated by one\n   of the protocol components themselves.\n  \
    \ Rule 4: When a component removes the last oif from an (S,G)\n           forwarding\
    \ cache entry whose iif is owned by another\n           component, or when such\
    \ an (S,G) forwarding cache entry is\n           created with an empty oif list,\
    \ the component owning the iif\n           MUST be alerted [(S,G) Prune alert]\
    \ (so it can send a prune,\n           for example).\n   Rule 5: When the first\
    \ oif is added to an (S,G) forwarding cache\n           entry whose iif is owned\
    \ by another component, the component\n           owning the iif MUST be alerted\
    \ [(S,G) Join alert] (so it can\n           send a join or graft, for example).\n\
    \   The oif list in rules 4 and 5 must also logically include any virtual\n  \
    \ encapsulation interfaces such as those used for tunneling or for\n   sending\
    \ encapsulated packets to an RP/core.\n   Rule 6: Unless a component reports the\
    \ aggregate group membership in\n           the direction of its interfaces, it\
    \ MUST be a \"wildcard\n           receiver\" for all sources whose RPF interface\
    \ is owned by\n           another component (\"externally-reached\" sources).\
    \  In\n           addition, a component MUST be a \"wildcard receiver\" for all\n\
    \           sources whose RPF interface is owned by that component\n         \
    \  (\"internally-reached\" sources) if any other component of the\n          \
    \ MBR is a wildcard receiver for externally-reached sources;\n           this\
    \ will happen naturally as a result of Rule 5 when it\n           receives a (*,*)\
    \ Join alert.\n   For example, if the backbone does not keep global membership\n\
    \   information, all MBR components in the backbone in a tree topology of\n  \
    \ domains, as well as all components owning the RPF interface towards\n   the\
    \ backbone are wildcard receivers for externally-reached sources.\n   MBRs need\
    \ not be wildcard receivers (for internally- or externally-\n   reached sources)\
    \ if a higher-level routing protocol, such as BGMP, is\n   used for routing between\
    \ domains.\n"
- title: 2.1.  Deleting Forwarding Cache Entries
  contents:
  - "2.1.  Deleting Forwarding Cache Entries\n   Special care must be taken to follow\
    \ Rules 4 and 5 when forwarding\n   cache entries can be deleted at will.  Specifically,\
    \ a component must\n   be able to determine when the combined oiflist for (S,G)\
    \ goes from\n   null to non-null, and vice versa.\n   This can be done in any\
    \ implementation-specific manner, including,\n   but not limited to, the following\
    \ possibilities:\n   o  Whenever a component would modify the oiflist of a single\n\
    \      forwarding cache entry if one existed, one is first created.  The\n   \
    \   oiflist is then modified and Rules 4 and 5 applied after an (S,G)\n      Creation\
    \ alert is sent to all components and all components have\n      updated the oiflist.\
    \  OR,\n   o  When a forwarding cache entry is to be deleted, a new alert [(S,G)\n\
    \      Deletion alert] is sent to all components, and the entry is only\n    \
    \  deleted if all components then grant permission.  Each component\n      could\
    \ then grant permission only if it had no (S,G) route table\n      entry.\n"
- title: 2.2.  Additional Recommendation
  contents:
  - "2.2.  Additional Recommendation\n   Using (*,G) Join alerts and (*,G) Prune alerts\
    \ can reduce bandwidth\n   usage by avoiding broadcast-and-prune behavior among\
    \ domains when it\n   is unnecessary.  This optimization requires that each component\
    \ be\n   able to determine which other components are interested in any given\n\
    \   group.\n   Although this may be done in any implementation-dependent method,\
    \ one\n   example would be to maintain a common table (which we call the\n   Component-Group\
    \ Table) indexed by group-prefix, listing which\n   components are interested\
    \ in each group(prefix).  Thus, any\n   components which are wildcard receivers\
    \ for externally-reached\n   sources (i.e., those whose RPF interface is owned\
    \ by another\n   component) would be listed in all entries of this table, including\
    \ a\n   default entry.  This table is thus loosely analogous to a forwarding\n\
    \   cache of (*,G) entries, except that no distinction is made between\n   incoming\
    \ and outgoing interfaces.\n"
- title: 3.  Alert Dispatchers
  contents:
  - "3.  Alert Dispatchers\n   We assume that each MBR has an \"alert dispatcher\"\
    .  The dispatcher is\n   responsible for selecting, for each (S,G) entry in the\
    \ shared\n   forwarding cache, the component owning the iif.  It is also\n   responsible\
    \ for selecting to which component(s) a given alert should\n   be sent.\n"
- title: 3.1.  The "Interop" Dispatcher
  contents:
  - "3.1.  The \"Interop\" Dispatcher\n   We describe here rules that may be used\
    \ in the absence of any inter-\n   domain multicast routing protocol, to enable\
    \ interoperability in a\n   tree topology of domains.  If an inter-domain multicast\
    \ routing\n   protocol is in use, another dispatcher should be used instead. \
    \ The\n   Interop dispatcher does not own any interfaces.\n   To select the iif\
    \ of an (S,G) entry, the iif owner is the component\n   owning the next-hop interface\
    \ towards S in the multicast RIB.\n   The \"iif owner\" of (*,G) and (*,*) entries\
    \ is the Interop dispatcher\n   itself.  This allows the Interop dispatcher to\
    \ receive relevant\n   alerts without owning any interfaces.\n"
- title: 3.1.1.  Processing Alerts
  contents:
  - "3.1.1.  Processing Alerts\n   If the Interop dispatcher receives an (S,G) Creation\
    \ alert, it adds\n   no interfaces to the entry's oif list, since it owns none.\n\
    \   When the Interop dispatcher receives a (*,G) Prune alert, the\n   following\
    \ actions are taken, depending on the number of components N\n   which want to\
    \ receive data for G.  If N has just changed from 2 to 1,\n   a (*,G) Prune alert\
    \ is sent to the remaining component. If N has just\n   changed from 1 to 0, a\
    \ (*,G) Prune alert is sent to ALL components\n   other than the 1.\n   When the\
    \ Interop dispatcher receives a (*,G) Join alert, the\n   following actions are\
    \ taken, depending on the number of components N\n   which want to receive data\
    \ for G.  If N has just changed from 0 to 1,\n   a (*,G) Join alert is sent to\
    \ ALL components other than the 1.  If N\n   has just changed from 1 to 2, a (*,G)\
    \ Join alert is sent to the\n   original (1) component.\n"
- title: 3.2.  "BGMP" Dispatcher
  contents:
  - "3.2.  \"BGMP\" Dispatcher\n   This dispatcher can be used with an inter-domain\
    \ multicast routing\n   protocol (such as BGMP) which allows global (S,G) and\
    \ (*,G) trees.\n   The iif owner of an (S,G) entry is the component owning the\
    \ next-hop\n   interface towards S in the multicast RIB.\n   The iif owner of\
    \ a (*,G) entry is the component owning the next-hop\n   interface towards G in\
    \ the multicast RIB.\n"
- title: 3.2.1.  Processing Alerts
  contents:
  - "3.2.1.  Processing Alerts\n   This dispatcher simply forwards all (S,G) and (*,G)\
    \ alerts to the iif\n   owner of the associated entry.\n"
- title: 4.  Multicast Routing Protocol Components
  contents:
  - "4.  Multicast Routing Protocol Components\n   In this section, we describe how\
    \ the rules in section 2 apply to\n   current versions of various protocols. \
    \ Future versions, and\n   additional protocols, should describe how these rules\
    \ apply in a\n   separate document.\n"
- title: 4.1.  DVMRP
  contents:
  - "4.1.  DVMRP\n   In this section we describe how the rules in section 2 apply\
    \ to\n   DVMRP.  We assume that the reader is familiar with normal DVMRP\n   behavior\
    \ as specified in [2].\n   As with all broadcast-and-prune protocols, DVMRP components\
    \ are\n   automatically wildcard receivers for internally-reached sources.\n \
    \  Unless some form of Domain-Wide-Reports (DWRs) [10] (synonymous with\n   Regional-Membership-Reports\
    \ as described in [1]) are added to DVMRP\n   in the future, all DVMRP components\
    \ also act as wildcard receivers\n   for externally-reached sources.  If DWRs\
    \ are available for the\n   domain, then a DVMRP component acts as a wildcard\
    \ receiver for\n   externally-reached sources only if internally-reached domains\
    \ exist\n   which do not support some form of DWRs.\n   One simple heuristic to\
    \ approximate DWRs is to assume that if there\n   are any internally-reached members,\
    \ then at least one of them is a\n   sender.  With this heuristic, the presense\
    \ of any (S,G) state for\n   internally-reached sources can be used instead. \
    \ Sending a data\n   packet to a group is then equivalent to sending a DWR for\
    \ the group.\n"
- title: 4.1.1.  Generating Alerts
  contents:
  - "4.1.1.  Generating Alerts\n   A (*,*) Join alert is sent to the iif owner of\
    \ the (*,*) entry (e.g.,\n   the Interop dispatcher) when the first component\
    \ becomes a wildcard\n   receiver for external sources.  This may occur when a\
    \ DVMRP component\n   starts up which does not support some form of DWRs.\n  \
    \ A (*,*) Prune alert is sent to the iif owner of the (*,*) entry\n   (e.g., the\
    \ Interop dispatcher) when all components are no longer\n   wildcard receivers\
    \ for external sources.  This may occur when a DVMRP\n   component which does\
    \ not support some form of DWRs shuts down.\n   An (S,G) Prune alert is sent to\
    \ the component owning the iif for a\n   forwarding cache entry whenever the last\
    \ oif is removed from the\n   entry, and the iif is owned by another component.\
    \  In DVMRP, this may\n   happen when:\n      o  A DVMRP (S,G) Prune message is\
    \ received on the logical\n         interface.\n   An (S,G) Join alert is sent\
    \ to the component owning the iif for a\n   forwarding cache entry whenever the\
    \ first logical oif is added to an\n   entry, and the iif is owned by another\
    \ component.  In DVMRP, this may\n   happen when any of the following occur:\n\
    \      o  The oif's prune timer expires, or\n      o  A DVMRP (S,G) Graft message\
    \ is received on the logical\n         interface, or\n      o  IGMP [7] notifies\
    \ DVMRP that directly-connected members of G\n         now exist on the interface.\n\
    \   When it is known, for a group G, that there are no longer any members\n  \
    \ in the DVMRP domain which receive data for externally-reached sources\n   from\
    \ the local router, a (*,G) Prune alert is sent to the \"iif owner\"\n   for (*,G)\
    \ according to the dispatcher.  In DVMRP, this may happen\n   when:\n      o \
    \ The DWR for G times out, or\n      o  The members-are-senders approximation\
    \ is being used and the\n         last (S,G) entry for G is timed out.\n   When\
    \ it is first known that there are members of a group G in the\n   DVMRP domain,\
    \ a (*,G) Join alert is sent to the \"iif owner\" of (*,G).\n   In DVMRP, this\
    \ may happen when either of the following occurs:\n      o  A DWR is received\
    \ for G, or\n      o  The members-are-senders approximation is being used and\
    \ a data\n         packet for G is received on one of the component's interfaces.\n"
- title: 4.1.2.  Processing Alerts
  contents:
  - "4.1.2.  Processing Alerts\n   When a DVMRP component receives an (S,G) Creation\
    \ alert, it adds all\n   the component's interfaces to the entry's oif list (according\
    \ to\n   normal DVMRP behavior) EXCEPT:\n      o  the iif,\n      o  interfaces\
    \ without local members of the entry's group, and for\n         which DVMRP (S,G)\
    \ Prune messages have been received from all\n         downstream dependent neighbors.\n\
    \      o  interfaces for which the router is not the designated forwarder\n  \
    \       for S,\n      o  and interfaces with scoped boundaries covering the group.\n\
    \   When a DVMRP component receives an (S,G) Prune alert, and the\n   forwarding\
    \ cache entry's oiflist is empty, it sends a DVMRP (S,G)\n   Prune message to\
    \ the upstream neighbor according to normal DVMRP\n   behavior.\n   When a DVMRP\
    \ component receives a (*,G) or (*,*) Prune alert, it is\n   treated as if an\
    \ (S,G) Prune alert were received for every existing\n   DVMRP (S,G) entry covered.\
    \  In addition, if DWRs are being used, a\n   DWR Leave message is sent within\
    \ its domain.\n   When a DVMRP component receives an (S,G) Join alert, and a prune\
    \ was\n   previously sent upstream, it sends a DVMRP (S,G) Graft message to the\n\
    \   upstream neighbor according to normal DVMRP behavior.\n   When a DVMRP component\
    \ receives a (*,G) or (*,*) Join alert, it is\n   treated as if an (S,G) Join\
    \ alert were received for every existing\n   DVMRP (S,G) entry covered.  In addition,\
    \ if DWRs are being used, the\n   component sends a DWR Join message within its\
    \ domain.\n"
- title: 4.2.  MOSPF
  contents:
  - "4.2.  MOSPF\n   In this section we describe how the rules in section 2 apply\
    \ to\n   MOSPF.  We assume that the reader is familiar with normal MOSPF\n   behavior\
    \ as specified in [3].  We note that MOSPF allows joining and\n   pruning entire\
    \ groups, but not individual sources within groups.\n   Although interoperability\
    \ between MOSPF and dense-mode protocols\n   (such as DVMRP) is specified in [3],\
    \ we describe here how an MOSPF\n   implementation may interoperate with all other\
    \ multicast routing\n   protocols.\n   An MOSPF component acts as a wildcard receiver\
    \ for internally-reached\n   sources if and only if any other component is a wildcard\
    \ receiver for\n   externally-reached sources.  An MOSPF component acts as a wildcard\n\
    \   receiver for externally-reached sources only if internally-reached\n   domains\
    \ exist which do not support some form of Domain-Wide-Reports\n   (DWRs) [10].\
    \  Since MOSPF floods membership information throughout\n   the domain, MOSPF\
    \ itself is considered to support a form of DWRs\n   natively.\n"
- title: 4.2.1.  Generating Alerts
  contents:
  - "4.2.1.  Generating Alerts\n   A (*,*) Join alert is sent to the iif owner of\
    \ the (*,*) entry (e.g.,\n   the Interop dispatcher) when the first component\
    \ becomes a wildcard\n   receiver for external sources.  This may occur when an\
    \ MOSPF\n   component starts up and decides to act in this role.\n   A (*,*) Prune\
    \ alert is sent to the iif owner of the (*,*) entry\n   (e.g., the Interop dispatcher)\
    \ when all components are no longer\n   wildcard receivers for external sources.\
    \  This may occur when an\n   MOSPF component which was acting in this role shuts\
    \ down.\n   When it is known that there are no longer any members of a group G\
    \ in\n   the MOSPF domain, a (*,G) Prune alert is sent to the \"iif owner\" for\n\
    \   (*,G) according to the dispatcher.  In MOSPF, this may happen when\n   either:\n\
    \      o  IGMP notifies MOSPF that there are no longer any directly-\n       \
    \  connected group members on an interface, or\n      o  Any router's group-membership-LSA\
    \ for G is aged out.\n      When it is first known that there are members of a\
    \ group G in the\n      MOSPF domain, a (*,G) Join alert is sent to the \"iif\
    \ owner\" of\n      (*,G), according to the dispatcher.  In MOSPF, this may happen\n\
    \      when any of the following occur:\n      o  IGMP notifies MOSPF that directly-connected\
    \ group members now\n         exist on the interface, or\n      o  A group-membership-LSA\
    \ is received for G.\n"
- title: 4.2.2.  Processing Alerts
  contents:
  - "4.2.2.  Processing Alerts\n   When an MOSPF component receives an (S,G) Creation\
    \ alert, it\n   calculates the shortest path tree for the MOSPF domain, and adds\
    \ the\n   downstream interfaces to the entry's oif list according to normal\n\
    \   MOSPF behavior.\n   When an MOSPF component receives an (S,G) Prune alert,\
    \ the alert is\n   ignored, since MOSPF can only prune entire groups at a time.\n\
    \   When an MOSPF component receives a (*,G) Prune alert, and there are\n   no\
    \ directly-connected members on any MOSPF interface, the router\n   \"prematurely\
    \ ages\" out its group-membership-LSA for G in the MOSPF\n   domain according\
    \ to normal MOSPF behavior.\n   When an MOSPF component receives either an (S,G)\
    \ Join alert or a\n   (*,G) Join alert, and G was not previously included in the\
    \ router's\n   group-membership-LSA (and the component is not a wildcard multicast\n\
    \   receiver), it originates a group-membership-LSA in the MOSPF domain\n   according\
    \ to normal MOSPF behavior.\n   When an MOSPF component receives a (*,*) Prune\
    \ alert, it ceases to be\n   a wildcard multicast receiver in its domain.\n  \
    \ When an MOSPF component receives a (*,*) Join alert, it becomes a\n   wildcard\
    \ multicast receiver in its domain.\n"
- title: 4.3.  PIM-DM
  contents:
  - "4.3.  PIM-DM\n   In this section we describe how the rules in section 2 apply\
    \ to\n   Dense-mode PIM.  We assume that the reader is familiar with normal\n\
    \   PIM-DM behavior as specified in [6].\n   As with all broadcast-and-prune protocols,\
    \ PIM-DM components are\n   automatically wildcard receivers for internally-reached\
    \ sources.\n   Unless some form of Domain-Wide-Reports (DWRs) [10] are added to\n\
    \   PIM-DM in the future, all PIM-DM components also act as wildcard\n   receivers\
    \ for externally-reached sources.  If DWRs are available for\n   the domain, then\
    \ a PIM-DM component acts as a wildcard receiver for\n   externally-reached sources\
    \ only if internally-reached domains exist\n   which do not support some form\
    \ of DWRs.\n   One simple heuristic to approximate DWRs is to assume that if there\n\
    \   are any internally-reached members, then at least one of them is a\n   sender.\
    \  With this heuristic, the presense of any (S,G) state for\n   internally-reached\
    \ sources can be used instead.  Sending a data\n   packet to a group is then equivalent\
    \ to sending a DWR for the group.\n"
- title: 4.3.1.  Generating Alerts
  contents:
  - "4.3.1.  Generating Alerts\n   A (*,*) Join alert is sent to the iif owner of\
    \ the (*,*) entry (e.g.,\n   the Interop dispatcher) when the first component\
    \ becomes a wildcard\n   receiver for external sources.  This may occur when a\
    \ PIM-DM\n   component starts up which does not support some form of DWRs.\n \
    \  A (*,*) Prune alert is sent to the iif owner of the (*,*) entry\n   (e.g.,\
    \ the Interop dispatcher) when all components are no longer\n   wildcard receivers\
    \ for external sources.  This may occur when a PIM-\n   DM component which does\
    \ not support some form of DWRs shuts down.\n   A (S,G) Prune alert is sent to\
    \ the component owning the iif for a\n   forwarding cache entry whenever the last\
    \ oif is removed from the\n   forwarding cache entry, and the iif is owned by\
    \ another component. In\n   PIM-DM, this may happen when:\n      o  A PIM (S,G)\
    \ Join/Prune message with S in the prune list is\n         received on a point-to-point\
    \ interface.\n      o  The Oif-Timer in an (S,G) route table entry expires.\n\
    \      o  A PIM (S,G) Assert message from a preferred neighbor is\n         received\
    \ on the interface.\n   A (S,G) Join alert is sent to the component owning the\
    \ iif for a\n   forwarding cache entry whenever the first oif is added to an entry,\n\
    \   and the iif is owned by another component.  In PIM-DM, this may\n   happen\
    \ when any of the following occur:\n      o  The oif's prune timer expires, or\n\
    \      o  A PIM-DM (S,G) Graft message is received on the interface, or\n    \
    \  o  IGMP notifies PIM-DM that directly-connected group members now\n       \
    \  exist on the interface.\n   When it is known that there are no longer any members\
    \ of a group G in\n   the PIM-DM domain which receive data for externally-reached\
    \ sources\n   from the local router, a (*,G) Prune alert is sent to the \"iif\
    \ owner\"\n   for (*,G) according to the dispatcher.  In PIM-DM, this may happen\n\
    \   when:\n      o  The DWR for G times out.\n      o  The members-are-senders\
    \ approximation is being used and PIM-\n         DM's last (S,G) entry for G is\
    \ timed out.\n   When it is first known that there are members of a group G in\
    \ the\n   PIM-DM domain, a (*,G) Join alert is sent to the \"iif owner\" of\n\
    \   (*,G), according to the dispatcher.  In PIM-DM, this may happen when\n   either\
    \ of the following occurs:\n      o  A DWR is received for G.\n      o  The members-are-senders\
    \ approximation is being used and a data\n         packet for G is received on\
    \ one of the component's interfaces.\n"
- title: 4.3.2.  Processing Alerts
  contents:
  - "4.3.2.  Processing Alerts\n   When a PIM-DM component receives an (S,G) Creation\
    \ alert, it adds the\n   component's interfaces to the entry's oif list (according\
    \ to normal\n   PIM-DM behavior) EXCEPT:\n      o  the iif,\n      o  leaf networks\
    \ without local members of the entry's group,\n      o  and interfaces with scoped\
    \ boundaries covering the group.\n   When a PIM-DM component receives an (S,G)\
    \ Prune alert, and the\n   forwarding cache entry's oiflist is empty, it sends\
    \ a PIM-DM (S,G)\n   Prune message to the upstream neighbor according to normal\
    \ PIM-DM\n   behavior.\n   When a PIM-DM component receives a (*,G) or (*,*) Prune\
    \ alert, it is\n   treated as if an (S,G) Prune alert were received for every\
    \ matching\n   (S,G) entry.\n   When a PIM-DM component receives an (S,G) Join\
    \ alert, and an (S,G)\n   prune was previously sent upstream, it sends a PIM-DM\
    \ (S,G) Graft\n   message to the upstream neighbor according to normal PIM-DM\
    \ behavior.\n   When a PIM-DM component receives a (*,G) or (*,*) Join alert,\
    \ then\n   for each matching (S,G) entry in the PIM-DM routing table for which\
    \ a\n   prune was previously sent upstream, it sends a PIM-DM (S,G) Graft\n  \
    \ message to the upstream neighbor according to normal PIM-DM behavior.\n   In\
    \ addition, if DWR's are being used, the component sends a DWR Join\n   message\
    \ within its domain.\n"
- title: 4.4.  PIM-SM
  contents:
  - "4.4.  PIM-SM\n   In this section we describe how the rules in section 2 apply\
    \ to\n   Sparse-mode PIM.  We assume that the reader is familiar with normal\n\
    \   PIM-SM behavior, as specified in [4].\n   To achieve correct PIM-SM behavior\
    \ within the domain, the PIM-SM\n   domain MUST be convex so that Bootstrap messages\
    \ reach all routers in\n   the domain.  That is, the shortest-path route from\
    \ any internal\n   router to any other internal router must lie entirely within\
    \ the PIM\n   domain.\n   Unless some form of Domain-Wide-Reports (DWRs) [10]\
    \ are added to\n   PIM-SM in the future, all PIM-SM components act as wildcard\
    \ receivers\n   for externally-reached sources.  If DWRs are available for the\n\
    \   domain, then a PIM-SM component acts as a wildcard receiver for\n   externally-reached\
    \ sources only if internally-reached domains exist\n   which do not support some\
    \ form of DWRs.\n   A PIM-SM component acts as a wildcard receiver for internally-reached\n\
    \   sources if and only if any other component is a wildcard receiver for\n  \
    \ externally-reached sources.  It does this by periodically sending\n   (*,*,RP)\
    \ Joins to all RPs for non-local groups (for example,\n   239.x.x.x is considered\
    \ locally-scoped, and PIM-SM components do not\n   send (*,*,RP) Joins to RPs\
    \ supporting only that portion of the\n   address space).  The period is set according\
    \ to standard PIM-SM rules\n   for periodic Join/Prune messages.\n   To properly\
    \ instantiate Rule 1, whenever PIM creates a PIM (S,G)\n   entry for an externally-reached\
    \ source, and the next hop towards S is\n   reached via an interface owned by\
    \ another component, the iif should\n   always point towards S and not towards\
    \ the RP for G.  In addition,\n   the Border-bit is set in all PIM Register messages\
    \ for this entry.\n   Finally, the PIM-SM component acts as a DR for externally-reached\n\
    \   receivers in terms of being able to switch to the shortest-path tree\n   for\
    \ internally-reached sources.\n"
- title: 4.4.1.  Generating Alerts
  contents:
  - "4.4.1.  Generating Alerts\n   A (*,*) Join alert is sent to the iif owner of\
    \ the (*,*) entry (e.g.,\n   the Interop dispatcher) when the first component\
    \ becomes a wildcard\n   receiver for external sources.  This may occur when a\
    \ PIM-SM\n   component starts up and decides to act in this role.\n   A (*,*)\
    \ Prune alert is sent to the iif owner of the (*,*) entry\n   (e.g., the Interop\
    \ dispatcher) when all components are no longer\n   wildcard receivers for external\
    \ sources.  This may occur when a PIM-\n   SM component which was acting in this\
    \ role shuts down.\n   A (S,G) Prune alert is sent to the component owning the\
    \ iif for a\n   forwarding cache entry whenever the last oif is removed from the\n\
    \   entry and the iif is owned by another component.  In PIM-SM, this may\n  \
    \ happen when:\n      o  A PIM (S,G) Join/Prune message with S in the prune list\
    \ is\n         received on a point-to-point interface, or\n      o  A PIM (S,G)\
    \ Assert from a preferred neighbor was received on\n         the interface, or\n\
    \      o  A PIM Register-Stop message is received for (S,G), or\n      o  The\
    \ interface's Oif-Timer for PIM's (S,G) route table entry\n         expires.\n\
    \      o  The Entry-Timer for PIM's (S,G) route table entry expires.\n   When\
    \ it is known that there are no longer any members of a group G in\n   the PIM-SM\
    \ domain which receive data for externally-reached sources\n   from the local\
    \ router, a (*,G) Prune alert is sent to the \"iif owner\"\n   for (*,G) according\
    \ to the dispatcher.  In PIM-SM, this may happen\n   when:\n      o  A PIM (*,G)\
    \ Join/Prune message with G in the prune list is\n         received on a point-to-point\
    \ interface, or\n      o  A PIM (*,G) Assert from a preferred neighbor was received\
    \ on\n         the interface, or\n      o  IGMP notifies PIM-SM that directly-connected\
    \ members no longer\n         exist on the interface.\n      o  The Entry-Timer\
    \ for PIM's (*,G) route table entry expires.\n   A (S,G) Join alert is sent to\
    \ the component owning the iif for a\n   forwarding cache entry whenever the first\
    \ logical oif is added to an\n   entry and the iif is owned by another component.\
    \  In PIM-SM, this may\n   happen when any of the following occur:\n      o  A\
    \ PIM (S,G) Join/Prune message is received on the interface, or\n      o  The\
    \ Register-Suppression-Timer for (S,G) expires, or\n      o  The Entry-Timer for\
    \ an (S,G) negative-cache state route table\n         entry expires.\n   When\
    \ it is first known that there are members of a group G in the\n   PIM-SM domain,\
    \ a (*,G) Join alert is sent to the \"iif owner\" of\n   (*,G), according to the\
    \ dispatcher.  In PIM-SM, this may happen when\n   any of the following occur:\n\
    \      o  A PIM (*,G) Join/Prune message is received on the interface, or\n  \
    \    o  A PIM (*,*,RP) Join/Prune message is received on the interface,\n    \
    \     or\n      o  (*,G) negative cache state expires, or\n      o  IGMP notifies\
    \ PIM that directly-connected group members now\n         exist on the interface.\n"
- title: 4.4.2.  Processing Alerts
  contents:
  - "4.4.2.  Processing Alerts\n   When a PIM-SM component receives an (S,G) Creation\
    \ alert, it does a\n   longest match search ((S,G), then (*,G), then (*,*,RP))\
    \ in its\n   multicast routing table.  All outgoing interfaces of that entry are\n\
    \   then added to the forwarding cache entry.  Unless the PIM-SM\n   component\
    \ owns the iif, the oiflist is also modified to support\n   sending PIM Registers\
    \ with the Border-bit set to the corresponding\n   RP.\n   When a PIM-SM component\
    \ receives an (S,G) Prune alert, and the\n   forwarding cache entry's oiflist\
    \ is empty, then for each PIM (S,G)\n   state entry covered, it sends an (S,G)\
    \ Join/Prune message with S in\n   the prune list to the upstream neighbor according\
    \ to normal PIM-SM\n   behavior.\n   When a PIM-SM component receives a (*,G)\
    \ Prune alert, it sends a\n   (*,G) Join/Prune message with G in the prune list\
    \ to the upstream\n   neighbor towards the RP for G, according to normal PIM-SM\
    \ behavior.\n   When a PIM-SM component receives an (S,G) Join alert, it sends\
    \ an\n   (S,G) Join/Prune message to the next-hop neighbor towards S, and\n  \
    \ resets the (S,G) Entry-timer, according to normal PIM-SM behavior.\n   When\
    \ a PIM-SM component receives a (*,G) Join alert, then it sends a\n   (*,G) Join/Prune\
    \ message to the next-hop neighbor towards the RP for\n   G, and resets the (*,G)\
    \ Entry-timer, according to normal PIM-SM\n   behavior.\n   When a PIM-SM component\
    \ receives a (*,*) Join alert, then it sends\n   (*,*,RP) Join/Prune messages\
    \ towards each RP.\n   When a PIM-SM component receives a (*,*) Prune alert, then\
    \ it sends a\n   (*,*,RP) Prune towards each RP.\n"
- title: 4.5.  CBTv2
  contents:
  - "4.5.  CBTv2\n   In this section we describe how the rules in section 2 apply\
    \ to\n   CBTv2.  We assume that the reader is familiar with normal CBTv2\n   behavior\
    \ as specified in [5]. We note that, like MOSPF, CBTv2 allows\n   joining and\
    \ pruning entire groups, but not individual sources within\n   groups.\n   Interoperability\
    \ between a single CBTv2 stub domain and a DVMRP\n   backbone is outlined in [8].\
    \  Briefly, CBTv2 MBR components are\n   statically configured such that, whenever\
    \ an external route exists\n   between two or more MBRs, one is designated as\
    \ the primary, and the\n   others act as non-forwarding (to prevent duplicate\
    \ packets) backups.\n   Thus, a CBTv2 domain must not serve as transit between\
    \ two domains if\n   another route between them exists.\n   We now describe how\
    \ a CBTv2 implementation may extend this to\n   interoperate with all other multicast\
    \ routing protocols.  A CBTv2\n   component acts as a wildcard receiver for internally-reached\
    \ sources\n   if and only if any other component is a wildcard receiver for\n\
    \   externally-reached sources.  It does this by sending JOIN-REQUESTs\n   for\
    \ all non-local group ranges to all known cores, as described in\n   [8].\n  \
    \ Unless some form of Domain-Wide-Reports (DWRs) [10] are added to\n   CBTv2 in\
    \ the future, all CBTv2 components act as wildcard receivers\n   for externally-reached\
    \ sources.  If DWRs are available for the\n   domain, then a CBTv2 component acts\
    \ as a wildcard receiver for\n   externally-reached sources only if internally-reached\
    \ domains exist\n   which do not support some form of DWRs.\n"
- title: 4.5.1.  Generating Alerts
  contents:
  - "4.5.1.  Generating Alerts\n   A (*,*) Join alert is sent to the iif owner of\
    \ the (*,*) entry (e.g.,\n   the Interop dispatcher) when the first component\
    \ becomes a wildcard\n   receiver for external sources.  This may occur when a\
    \ PIM-SM\n   component starts up and decides to act in this role.\n   A (*,*)\
    \ Prune alert is sent to the iif owner of the (*,*) entry\n   (e.g., the Interop\
    \ dispatcher) when all components are no longer\n   wildcard receivers for external\
    \ sources.  This may occur when a PIM-\n   SM component which was acting in this\
    \ role shuts down.\n   When the last oif is removed from the core tree for G,\
    \ a (*,G) Prune\n   alert is sent to the \"iif owner\" for (*,G) according to\
    \ the\n   dispatcher.  Since CBTv2 always sends all data to the core, the only\n\
    \   time this can occur after the entry is created is when the MBR is the\n  \
    \ core.  In this case, the last oif is removed from the entry when:\n      o \
    \ A QUIT-REQUEST is received on the logical interface, and there\n         are\
    \ no directly-connected members present on the interface, or\n      o  IGMP notifies\
    \ CBT that there are no longer directly-connected\n         members present on\
    \ the interface, and the interface is not a\n         CBT child interface for\
    \ group G.\n   When the first CBT outgoing interface is added to an existing core\n\
    \   tree, a (*,G) Join alert is sent to the \"iif owner\" of (*,G)\n   according\
    \ to the dispatcher.  Since CBTv2 always sends all data to\n   the core, the only\
    \ time these can occur, other than when the entry is\n   created, is when the\
    \ MBR is the core.  In this case, the first\n   logical oif is added to an entry\
    \ when:\n      o  A JOIN-REQUEST for G is received on the interface, or\n    \
    \  o  IGMP notifies CBT that directly-connected group members now\n         exist\
    \ on the interface.\n"
- title: 4.5.2.  Processing Alerts
  contents:
  - "4.5.2.  Processing Alerts\n   When a CBTv2 component receives an (S,G) Creation\
    \ alert, and the\n   router is functioning as the designated BR, any CBT interfaces\
    \ which\n   are on the tree for G are added to the forwarding cache entry's oif\n\
    \   list (according to normal CBTv2 behavior).\n   When a CBTv2 component receives\
    \ an (S,G) Prune alert, the alert is\n   ignored, since CBTv2 cannot prune specific\
    \ sources.  Thus, it will\n   continue to receive packets from S since it must\
    \ receive packets from\n   other sources in group G.\n   When a CBTv2 component\
    \ receives a (*,G) Prune alert, and the router\n   is not the primary core for\
    \ G, and the only CBT on-tree interface is\n   the interface towards the core,\
    \ it sends a QUIT-REQUEST to the next-\n   hop neighbor towards the core, according\
    \ to normal CBTv2 behavior.\n   When a CBTv2 component receives either an (S,G)\
    \ Join alert or a (*,G)\n   Join alert, and the router is not the primary core\
    \ for G, and the\n   router is not already on the core-tree for G, it sends a\
    \ CBT (*,G)\n   JOIN-REQUEST to the next-hop neighbor towards the core, according\
    \ to\n   normal CBTv2 behavior.\n"
- title: 4.6.  IGMP-only links
  contents:
  - "4.6.  IGMP-only links\n   In this section we describe how the rules in section\
    \ 2 apply to a\n   link which is not within any routing domain, and hence no routing\n\
    \   protocol messages are exchanged and the interface is not owned by any\n  \
    \ multicast routing protocol component.  We assume that the reader is\n   familiar\
    \ with normal IGMP behavior as specified in [7].  We note that\n   IGMPv2 allows\
    \ joining and pruning entire groups, but not individual\n   sources within groups.\n\
    \   An IGMP-only \"component\" may only own a single interface; hence an\n   IGMP-only\
    \ domain only consists of a single link.  Since an IGMP-only\n   component can\
    \ only act as a wildcard receiver for internally-reached\n   sources if all internally-reached\
    \ sources are directly-connected,\n   then either the IGMP-only domain (link)\
    \ must be a stub domain, or\n   else there must be no other components which are\
    \ wildcard receivers\n   for externally-reached sources.\n"
- title: 4.6.1.  Generating Alerts
  contents:
  - "4.6.1.  Generating Alerts\n   When it is known that there are no longer any directly-connected\n\
    \   members of a group G on the IGMP-only interface, a (*,G) Prune alert\n   is\
    \ sent to the \"iif owner\" for (*,G) according to the dispatcher.  In\n   IGMP,\
    \ this may happen when:\n      o  The group membership times out.\n   When it\
    \ is first known that there are directly-connected members of a\n   group G on\
    \ the interface, a (*,G) Join alert is sent to the \"iif\n   owner\" of (*,G),\
    \ according to the dispatcher.  In IGMP, this may\n   happen when any of the following\
    \ occur:\n      o  A Membership Report is received for G.\n"
- title: 4.6.2.  Processing Alerts
  contents:
  - "4.6.2.  Processing Alerts\n   When an IGMP-only component receives an (S,G) Creation\
    \ alert, and\n   there are directly-connected members of G present on its interface,\n\
    \   it adds the interface to the entry's oif list.\n   When an IGMP-only component\
    \ receives an (S,G) Prune alert, the alert\n   is ignored, since IGMP can only\
    \ prune entire groups at a time.\n   When an IGMP-only component receives a (*,G)\
    \ Prune alert, the router\n   leaves the group G, sending an IGMP Leave message\
    \ if it was the last\n   reporter, according to normal IGMPv2 behavior.\n   When\
    \ an IGMP-only component receives a (*,*) Prune alert, it leaves\n   promiscuous\
    \ multicast mode.\n   When an IGMP-only component receives either an (S,G) Join\
    \ alert or a\n   (*,G) Join alert, and the component was not previously a member\
    \ of G\n   on the IGMP-only interface (and the component is not a wildcard\n \
    \  receiver for internally reached sources), it joins the group on the\n   interface,\
    \ causing it to send an unsolicited Membership Report\n   according to normal\
    \ IGMP behavior.\n   When an IGMP-only component receives a (*,*) Join alert,\
    \ it enters\n   promiscuous multicast mode.\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   All operations described herein are internal\
    \ to multicast border\n   routers.  The rules described herein do not change the\
    \ security\n   issues underlying individual multicast routing protcols.  Allowing\n\
    \   different protocols to interact, however, means that security\n   weaknesses\
    \ of any particular protocol may also apply to the other\n   protocols as a result.\n"
- title: 6. References
  contents:
  - "6. References\n   [1]   Ajit S. Thyagarajan and Stephen E. Deering.  Hierarchical\n\
    \         distance-vector multicast routing for the MBone.  In\n         \"Proceedings\
    \ of the ACM SIGCOMM\", pages 60--66, October 1995.\n   [2]   Pusateri, T., \"\
    Distance Vector Multicast Routing Protocol\",\n         Work in Progress.\n  \
    \ [3]   Moy, J., \"Multicast Extensions to OSPF\", RFC 1584, March 1994.\n   [4]\
    \   Estrin, D., Farinacci, D., Helmy, A., Thaler, D., Deering, S.,\n         Handley,\
    \ M., Jacobson, V., Liu, C., Sharma, P. and L. Wei,\n         \"Protocol Independent\
    \ Multicast-Sparse Mode (PIM-SM): Protocol\n         Specification\", RFC 2362,\
    \ June 1998.\n   [5]   Ballardie, A., \"Core Based Trees (CBT version 2) Multicast\n\
    \         Routing\", RFC 2189, September 1997.\n   [6]   Estrin, Farinacci, Helmy,\
    \ Jacobson, and Wei, \"Protocol\n         Independent Multicast (PIM), Dense Mode\
    \ Protocol\n         Specification\", Work in Progress.\n   [7]   Fenner, W.,\
    \ \"Internet Group Management Protocol, Version 2\",\n         RFC 2236, November\
    \ 1997.\n   [8]   Ballardie, A., \"Core Based Tree (CBT) Multicast Border Router\n\
    \         Specification\", Work in Progress.\n   [9]   Thaler, D., Estrin, D.\
    \ and D. Meyer, \"Border Gateway Multicast\n         Protocol (BGMP): Protocol\
    \ Specification\", Work in Progress.\n   [10]  Fenner, W., \"Domain Wide Multicast\
    \ Group Membership Reports\",\n         Work in Progress.\n"
- title: 7.  Author's Address
  contents:
  - "7.  Author's Address\n   Dave Thaler\n   Microsoft\n   One Microsoft Way\n  \
    \ Redmond, WA 98052\n   Phone: (425) 703-8835\n   EMail: dthaler@microsoft.com\n"
- title: 8.  Full Copyright Statement
  contents:
  - "8.  Full Copyright Statement\n   Copyright (C) The Internet Society (1999). \
    \ All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
