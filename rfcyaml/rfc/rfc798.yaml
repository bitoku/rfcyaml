- title: __initial_text__
  contents:
  - '              DECODING FACSIMILE DATA FROM THE RAPICOM 450

    '
- title: I.   Introduction
  contents:
  - "I.   Introduction\n   This note  describes  the  implementation  of  a  program\
    \  to  decode\n   facsimile  data from the Rapicom  450 facsimile (fax) machine\
    \ into an\n   ordinary  bitmap.  This bitmap can then be displayed on other devices\n\
    \   or edited  and then encoded  back into the Rapicom  450  format.   In\n  \
    \ order  to do this,  it  was  necessary  to  understand  the  how  the\n   encoding/decoding\
    \  process  works  within  the  fax  machine  and  to\n   duplicate  that process\
    \  in a program.  This algorithm is descibed in\n   an article  by Weber  [1]\
    \ as well as in a memo by Mills [2], however,\n   more information  than is presented\
    \  in these papers  is necessary to\n   successfully decode the data.\n   The\
    \ program  was written  in L10 as a subsystem  of  NLS  running  on\n   TOPS20.\
    \   The fax machine  is interfaced  to  TOPS20  as  a  terminal\n   through a\
    \ microprocessor-based interface called FAXIE.\n   Grateful  acknowledgment  is\
    \ made to Steve  Treadwell  of  University\n   College,  London and Jon Postel\
    \ of Information Sciences Institute for\n   their assistance.\n"
- title: II.  Interface to TOPS20
  contents:
  - "II.  Interface to TOPS20\n   The fax machine  is connected  to a microprocessor-based\
    \  unit called\n   FAXIE,  designed  and built by Steve Casner  and  Bob  Parker.\
    \   More\n   detailed  information  can be  found  in  reference  [3].   FAXIE\
    \  is\n   connected  to TOPS20  over a terminal line, and a program was written\n\
    \   to read  data  over  this  line and store it in a file.  The decoding\n  \
    \ program reads the fax data from this file.\n   The data comes from the fax machine\
    \  serially.  FAXIE reads this data\n   into an 8-bit shift register  and sends\
    \ the 8-bit byte  (octet)  over\n   the terminal line.  Since the fax machine\
    \ assigns MARK to logical 0's\n   and SPACE to logical  1's  (which  is  backward\
    \  from  RS232),  FAXIE\n   complements  each bit in the octet.   The data is\
    \ sent to  TOPS20  in\n   octets,  the most significant bit first.  If you read\
    \ each octet from\n   most significant  bit to least significant  bit in  the\
    \  order  FAXIE\n   sends  the data to TOPS20,  you would be reading the data\
    \ in the same\n   order in comes into FAXIE from the fax machine.\n   The standard\
    \  for storing  Rapicom 450 Facsimile Data is described in\n   RFC 769 [4].  \
    \ According  to this standard,  each octet  coming  from\n   FAXIE must be complemented\
    \ and inverted (i.e. invert the order of the\n   bits in the octet).   Thus, \
    \ the receiving  program  did this  before\n"
- title: DECODING FACSIMILE DATA                                          RFC 798
  contents:
  - 'DECODING FACSIMILE DATA                                          RFC 798

    '
- title: II. Interface to TOPS20
  contents:
  - "II. Interface to TOPS20                                                 \n  \
    \ storing  the data in a file.   When the decoding  program  reads this\n   file,\
    \  it must invert  and complement  each octet before  reading the\n   data.\n\
    \   Each data block  from the fax machine  is 585 bits long.   The end of\n  \
    \ this  data  is padded  with  7 0's to make  592 bits  or  74  octets.\n   According\
    \  to RFC 769,  this data is stored  in a file preceded  by a\n   length octet\
    \ and a command octet.  The possible commands are:\n      56 (70 octal)--This\
    \  is a Set-Up  block  (the first  block  of the\n      file, contains information\
    \ about the fax image)\n      57 (71 octal)--This is a data block (the rest of\
    \ the blocks in the\n      file except for the last one)\n      58 (72 octal)--End\
    \ command (the last block of the file)\n   The length field tells how many octets\
    \ in this block and is always 76\n   (114 octal) except for the END command which\
    \ can be 2 (no data).  The\n   length and command octets are NOT inverted and\
    \ complemented.\n   Below is a diagram of each block in the file:\n      +--------+--------+--------+--------+--------+--------+--------\n\
    \      | length | command|  data  |  data  |  ...   |        |\n      +--------+--------+--------+--------+--------+--------+--------\n"
- title: III. The Rapicom 450 Encoding Algorithm
  contents:
  - "III. The Rapicom 450 Encoding Algorithm\n   An ordinary  8 1/2\"  by 11\"  document\
    \  is made  up of about 2100 scan\n   lines,  each line has 1726 pels (picture\
    \  elements)  in it.  Each pel\n   can be either black (1) or white (0).\n   The\
    \ Rapicom  450 has three picture  quality  modes.   In fine  detail\n   mode,\
    \  all of the document  is encoded.   In quality  mode only every\n   other  scan\
    \ line is encoded  and it is intended  that  these  missing\n   lines are filled\
    \  in on playback  by replicating  the previous  line.\n   There is also express\
    \ mode, where only every third line is encoded.\n"
- title: RFC 798                                          DECODING FACSIMILE DATA
  contents:
  - "RFC 798                                          DECODING FACSIMILE DATA\n  \
    \                               III. The Rapicom 450 Encoding Algorithm\n   Data\
    \ is encoded  two lines at a time, using a special two dimensional\n   run-length\
    \ encoding scheme.  There are 1726 pels on top and 1726 pels\n   on the bottom.\
    \   Each pair (top-bottom)  of pels is called  a column.\n   For  each  of  the\
    \  1726  columns  you  can  have  any  one  of  four\n   configurations (called\
    \ states):\n              column\n           (top-bottom)        pels        \
    \ state\n           ------------        ----         ------\n               W-W\
    \             0,0            0\n               W-B             0,1           \
    \ 1\n               B-W             1,0            2\n               B-B     \
    \        1,1            3\n   The  encoding   algorithm   can  be   described\
    \   in   terms   of   a\n   non-deterministic finite-state automaton shown in\
    \ Fig. 1 (after Mills\n   [2]).   You start out in a state (0-3) and transform\
    \ to another state\n   by emitting  the appropriate  bits  marked  along  the\
    \  arcs  of  the\n   diagram.   For example,  suppose  you are in state  1 (WB).\
    \  To go to\n   state  2 (BW), you would output the bits 101 (binary); to go to\
    \ state\n   0 (WW)  you would output the bits 1000.  Note that the number of bits\n\
    \   on each transition is variable.\n   In states  0 (WW) and 3 (BB), a special\
    \ run length encoding scheme is\n   used.   There are two state variables  associated\
    \  with each of these\n   states.   One variable  is a run-length  counter and\
    \ the other is the\n   field  length  (in bits)  of this counter.   Upon entry\
    \  to either of\n   these  two  states,  the  counter  is  initialized  to  zero\
    \  and  is\n   incremented  for every additional  column  of the same state. \
    \ At the\n   end of the run,  this counter  is transmitted,  extending  with \
    \ high\n   order  zeros  if necessary.   If the count  fills up the field, it\
    \ is\n   transmitted,  the field length  is incremented  by one, and the count\n\
    \   starts  again.   This count  is called  the run length word and it is\n  \
    \ between 2 and 7 bits long.\n   For example,  suppose  we are in state  0 (WW)\
    \ and the run length for\n   this state  (refered to as the white run length)\
    \ is 3.  Suppose there\n   are three 0's in a row.  The first 0 was encoded when\
    \ we came to this\n   state,  there  are two more 0's that must be encoded.  \
    \ Thus we would\n   send a 010 (binary).   Similarly, if there are seven 0's in\
    \ a row, we\n   would send a 110, but eight 0's would be sent by 111 followed\
    \ by 0000\n   and the white run length becomes 4.  (Ten 0's would be encoded as\
    \ 111\n   followed by 0010 and the white run length would be 4).\n"
- title: DECODING FACSIMILE DATA                                          RFC 798
  contents:
  - 'DECODING FACSIMILE DATA                                          RFC 798

    '
- title: III. The Rapicom 450 Encoding Algorithm
  contents:
  - "III. The Rapicom 450 Encoding Algorithm                                 \n  \
    \                                0100\n            ------------------------>-----------------------------------\n\
    \            |                                                          |\n  \
    \          |    -------------------<-------------------------------   |\n    \
    \        |   |                  1                               |   |\n      \
    \      |   V                                                  |   |\n      ----------------\
    \                       -----------------     |   |\n      |              |  \
    \                     |               |     |   |\n      |              |    \
    \      010          |               |     |   |\n   |->|      2       |---------------------->|\
    \       1       |->|  |   |\n   |  |              |                       |  \
    \             |  |  |   |\n  0|  |     B-W      |          101          |    \
    \  W-B      |  |1 |   |\n   |<-|              |<----------------------|      \
    \         |<-|  |   |\n      |              |                       |        \
    \       |     |   |\n      |              |                 ----->|          \
    \     |     |   |\n      ----------------                 |     -----------------\
    \     |   |\n          |   ^                        |      |     |   ^       \
    \   |   |\n          |   |     ------------>------|      |     |   |         \
    \ |   |\n          |   |     |           1             |     |   |          |\
    \   |\n          |   |     |                         |     |   |          ^  \
    \ V\n          |   |     |                         |     |   |          |   |\n\
    \      0111|   |1    |                         | 1000|   |1         |   |\n  \
    \        |   |     |                         |     |   |          |   |\n    \
    \      |   |     |                         |     |   |          |   |\n      \
    \    |   |     |                         |     |   |          |   |\n        \
    \  |   |     |            1011         |     |   |          |   |\n          |\
    \   |     |    ----------<-----------     |   |          |   |\n          V  \
    \ |     |    |                          V   |          |   |\n      ----------------\
    \   |                   -----------------     |   |\n      |              |<---\
    \                   |               |     |   |\n      |              |      \
    \    0            |               |     |   |\n      |      3       |<----------------------|\
    \       0       |------   |\n      |              |                       |  \
    \             |         |\n      |     B-B      |                       |    \
    \  W-W      |         |\n      |              |---------------------->|      \
    \         |<---------\n      |              |          0            |        \
    \       |\n      |              |                       |               |\n  \
    \    ----------------                       -----------------\n          |   \
    \ ^                                   |    ^\n          |    |               \
    \                    |    |\n          ------                                \
    \   ------\n           run                                      run\n        \
    \                       Figure 1.\n     Non-deterministic finite-state machine\
    \ diagram for RAPICOM 450\n"
- title: RFC 798                                          DECODING FACSIMILE DATA
  contents:
  - "RFC 798                                          DECODING FACSIMILE DATA\n  \
    \                               III. The Rapicom 450 Encoding Algorithm\n   Run\
    \ length word lengths must be between 2 and 7.  The field length is\n   decremented\
    \ if the run is encoded in one word and:\n      1.  If the run length is 3 and\
    \ the highest order bit is 0.\n      2.  Or, if the run length is 4, 5, 6, or\
    \ 7 and the highest order 2\n      bits are 0.\n   In addition to all this, there\
    \ is a special rule to follow if the run\n   occupies at least two run words (and\
    \ can involve incrementing the run\n   word  size)  and the run ends  exactly\
    \ at the end of a scan line.  In\n   this case, the last word of the run is tested\
    \ for decrement as if the\n   previous words in the run did not exist.\n   An\
    \ Example:\n      To confirm  the reader's  understanding of the encoding procedure,\n\
    \      suppose  we had the following  portion  of  a  document  (1=black,\n  \
    \    0=white):\n         top row:      0 1 1 1 1 1 0 0 0 0 0 1 1 0 0 0 ...\n \
    \        bottom row:   1 1 1 1 1 0 0 0 0 0 0 0 0 1 0 0 ...\n         -----------\
    \   -------------------------------\n         state:        1 3 3 3 3 2 0 0 0\
    \ 0 0 2 2 1 0 0 ...\n      Suppose  also that the black  run field length is 2,\
    \ the white run\n      length  is 3,  and the state  is  1.   (This  example \
    \ comes  from\n      reference [1].)\n      This portion would be encoded as:\n\
    \         1 1011 11 000 1 0100 100 1 0 010 1000 ...\n      NOTE:  It turns out\
    \ that the Rapicom 450 sends the bits of a field\n      in reverse  order.   This\
    \ will be  discussed  in  the  section  V.\n      However,  since each run length\
    \  field is sent reversed, the above\n      encoded bit pattern would actually\
    \ be sent as:\n         1 1011 11 000 1 0100 001 1 0 010 1000 ...\n          \
    \                     ^\n                               |-this is actually 100\
    \ reversed\n"
- title: DECODING FACSIMILE DATA                                          RFC 798
  contents:
  - 'DECODING FACSIMILE DATA                                          RFC 798

    '
- title: III. The Rapicom 450 Encoding Algorithm
  contents:
  - "III. The Rapicom 450 Encoding Algorithm                                 \n  \
    \ Another Example:\n      This example  illustrates the rule for decrementing\
    \ the run length\n      word lengths:\n         top row:      0 1 1 0 0 1 1 1\
    \ 1 1 0 0 ...\n         bottom row:   1 1 1 1 1 0 1 1 1 1 1 0 ...\n         -----------\
    \   -----------------------\n         state:        1 3 3 1 1 2 3 3 3 3 1 0 ...\n\
    \      Here, let us suppose that the black run field length is now 4, the\n  \
    \    white is still 3, and the state is 1.\n      This portion would be encoded\
    \ as:\n         1 1011 0001 1 1 101 0111 011 1 1000 ...\n                  ^ \
    \               ^\n                  |-goes to 3      |-blk cnt goes to 2\n  \
    \    When we reverse  the order of the run fields, the bit pattern that\n    \
    \  is actually sent is:\n         1 1011 1000 1 1 101 0111 110 1 1000 ...\n  \
    \               ^\n                 |-this is actually 0001 reversed, etc.\n"
- title: IV.  The Setup Block and the Data Header
  contents:
  - "IV.  The Setup Block and the Data Header\n   Each data block from the fax machine\
    \ is 585 bits long.  The number of\n   blocks  in a  picture  is  variable  and\
    \  depends  on  the  size  and\n   characteristics of the picture.  It should\
    \ be emphasized that a block\n   can end in the middle  of a scan  line of the\
    \ document.  There can in\n   fact be many scan lines in a block.\n   The 585\
    \ bit data  block  is composed  of a 24 bit sync  code which is\n   used to recognize\
    \ the beginning of a block, a 37 bit header, 512 bits\n   of actual data, and\
    \ a 12 bit CRC checksum:\n      ------------------------------------------------------------------\n\
    \      |  24-bit  |    37-bit   |         512-bit         |    12-bit   |\n  \
    \    |sync code |    header   |           data          |   checksum  |\n    \
    \  ------------------------------------------------------------------\n   The\
    \ number  of useful  data bits is variable and can be between 0 and\n   512 (although\
    \ there are always 512 bits there, some of them are to be\n   ignored).  The number\
    \ of data bits to be used is given in the header.\n"
- title: RFC 798                                          DECODING FACSIMILE DATA
  contents:
  - "RFC 798                                          DECODING FACSIMILE DATA\n  \
    \                               IV. The Setup Block and the Data Header\n   The\
    \ 37 bits of header is composed of:\n      ------------------------------------------------------------------\n\
    \      | 2-bit |5-bit|  10-bit  |   12-bit  |  3-bit   |   3-bit  |2-bit|\n  \
    \    |seq num|flags|data count| x position|black size|white size|state|\n    \
    \  ------------------------------------------------------------------\n   An explanation\
    \ of these fields follows:\n      IMPORTANT  NOTE:   Most (but not all)  of these\
    \ fields are sent by\n      the fax machine  in REVERSE  ORDER.  The order of\
    \ each n-bit field\n      must be inverted.\n      Sync code\n         This is\
    \ used to synchronize  on each block.   The value of this\n         24 bit field\
    \ is 30474730 octal (not reversed).\n      Sequence number\n         This number\
    \  cycles through 0, 1, 2, 3 for the data blocks.  It\n         is 0 for the Set-Up\
    \ block (not reversed).\n      Flags\n         Each of these flags are 1 bit wide:\n\
    \            Run\n               Purpose unknown, it always seems to be 1.\n \
    \           Cofb\n               Purpose unknown, it always seems to be 0.\n \
    \           Rpt\n               1 for Set-Up  blocks (which are repeated when\
    \ coming from\n               the fax machine  though only one of them is transfered\
    \ by\n               FAXIE  to TOPS20  and stored  in the file) and 0 for data\n\
    \               blocks.\n            Spare\n               Purpose unknown, doesn't\
    \ matter.\n"
- title: DECODING FACSIMILE DATA                                          RFC 798
  contents:
  - 'DECODING FACSIMILE DATA                                          RFC 798

    '
- title: IV. The Setup Block and the Data Header
  contents:
  - "IV. The Setup Block and the Data Header                                 \n  \
    \          Sub\n               1 if this is a Set-Up block.\n      Data Count\n\
    \         Number of useful bits to use out of the 512 data bits.  NOT ALL\n  \
    \       of the 512 data bits are used,  only this number of them.  This\n    \
    \     number can be 0 (usually in one of the first data blocks) which\n      \
    \   means to throw away this block. (This field is reversed!)\n      X Position\n\
    \         Current  position on the scan line, a value between 0 and 1725.\n  \
    \       If this number  is greater  than where the previous  block left\n    \
    \     off,  the intervening  space should be filled with white (0's).\n      \
    \   If this number  is less than where the previous block left off,\n        \
    \ set the X position  to this value  and replace  the  overlapped\n         data\
    \ with the new data from this  block.   If  this  number  is\n         greater\
    \  than 1726,  ignore  this field and continue from where\n         the previous\
    \ block left off. (This field is reversed!)\n      Black Size\n         The size\
    \ of the black  run length  field, must be between 2 and\n         7.   This is\
    \ the correct  value  for the black  size.   It  may\n         differ  from what\
    \ was found  at the end of the previous  block.\n         (This field is reversed!)\n\
    \      White Size\n         The size of the white  run length  field, must be\
    \ between 2 and\n         7.   It may differ  from  what  was found  at the  end\
    \  of  the\n         previous block. (This field is reversed!)\n      State\n\
    \         The current  state.   This is the correct state.  It may differ\n  \
    \       from the state at the end of the previous block. (This field is\n    \
    \     not reversed.)\n      Data\n         512 bits of the actual  encoding  of\
    \ the document.   NOT ALL of\n         this data is used in general,  only the\
    \ amount specified by the\n"
- title: RFC 798                                          DECODING FACSIMILE DATA
  contents:
  - "RFC 798                                          DECODING FACSIMILE DATA\n  \
    \                               IV. The Setup Block and the Data Header\n    \
    \     data count.   If this is a set  up  block,  the  data  contains\n      \
    \   information about the type of document (see below).\n      Checksum\n    \
    \     CRC  checksum   on   the   entire   block.    Uses   polynomial\n      \
    \   x**12+x**8+x**7+x**5+x**3+1.\n   In a setup block, the data portion of the\
    \ data block consists of:\n      -----------------------------------------------------------\n\
    \      |   6-bit |    5-bit  |   1-bit  |  20-bits  |  480-bits\n      |   flags\
    \ |    spare  |multi page|  of zeros |  1's and 0's\n      -----------------------------------------------------------\n\
    \   Specifically these are:\n      6 flags (each are 1 bit):\n         Start bit\n\
    \            Always 0.\n         Speed\n            Is 1 if express mode.\n  \
    \       Detail\n            Is 1 if detail  mode.  (NOTE:  If the Detail and Speed\
    \ flags\n            are both 0, then data is in Quality mode).\n         14 inch\
    \ paper\n            is 1 if 14 inch paper length.\n         5.5 inch paper\n\
    \            is 1 if 5.5 inch  paper length.  (NOTE: If the 14 inch and 5\n  \
    \          inch flags are both 0, then paper length is 11 inch).\n         paper\
    \ present\n            is 1 if paper is present at scanner (should be always 1).\n"
- title: DECODING FACSIMILE DATA                                          RFC 798
  contents:
  - 'DECODING FACSIMILE DATA                                          RFC 798

    '
- title: IV. The Setup Block and the Data Header
  contents:
  - "IV. The Setup Block and the Data Header                                 \n  \
    \    Spare:\n         These 5 bits can be any value.\n      Multi-page:\n    \
    \     1 if multi page mode\n      Rest of data of set-up block:\n         The\
    \ above  fields are followed by twenty 0 bits and the rest of\n         the 512\
    \ bits of the block are alternating 0's and 1's.\n   There  are a number of important\
    \ points to be remembered in regard to\n   the header  of a data block.   First\
    \  of all,  the  data  count,  the\n   x-position, and the black and white run\
    \ sizes must be read IN REVERSE\n   ORDER.   The reason for this is that the fax\
    \ machine sends these bits\n   in reverse  order.  However, the sequence number\
    \ and the state fields\n   ARE NOT REVERSED.  In addition to this, each run field\
    \ in the data IS\n   REVERSED.   This reversing  of  the  bits  in  each  n-bit\
    \  field  is\n   completely  separate  from the reversing  and complementing \
    \ of  each\n   octet mentioned earlier.\n   Second, only the first n bits, where\
    \ n is the value of the data count\n   field  (remember its reversed!), of the\
    \ data is valid, the rest is to\n   be ignored.  If n is zero, the whole block\
    \ is to be ignored.\n   Third,  if the x position  is beyond where the last block\
    \ ended, fill\n   the space  between  where  the last block  ended  and the  current\
    \  x\n   postion  with white (0's).  If the x postition is less then where the\n\
    \   last block ended,  replace  the overlapped  data with the data in the\n  \
    \ new block.   If the x postition  is greater  than 1726, ignore it and\n   continue\
    \ from where the previous block left off.\n   Fourth,  the black  size,  white\
    \  size  (reversed),  and  state  (not\n   reversed!)  given in the header  are\
    \ the correct  values even if they\n   disagree with the end of the previous block.\n\
    \   Finally,  the sequence  number  (not reversed)  should  count through\n  \
    \ 0,1,2,3.  If it does not, a block is missing.\n"
- title: RFC 798                                          DECODING FACSIMILE DATA
  contents:
  - "RFC 798                                          DECODING FACSIMILE DATA\n  \
    \                                             V. The Decoding Algorithm\n"
- title: V.   The Decoding Algorithm
  contents:
  - "V.   The Decoding Algorithm\n   Upon first  glance  at the finite  state  diagram\
    \ in Figure 1, it may\n   seem that it would be difficult  to create a decoding\
    \ procedure.  For\n   example,  if you are in the WW state, and the next bit is\
    \ a 1, how do\n   you know  whether to do a transition to WB or BW?  The answer\
    \ to this\n   is to recognize  that every arc out of the BW state begins with\
    \ 0 and\n   every arc out of WB begins with 1.  Thus, if you are in the WW state,\n\
    \   and the next  bit is 1,  followed  by a 0,  you know  to go to the BW\n  \
    \ state.   If the next bit is 1, followed by a 1, you know to go to the\n   WB\
    \ state.\n   In writing  the decoding program it was necessary to have two ways\
    \ of\n   reading the next bit in the data stream.  The first way reads the bit\n\
    \   and \"consumes\"  it,  i.e.  increments the bit pointer to point at the\n\
    \   next bit.   The other  way does not \"consume\"  it.   Below  are  four\n\
    \   statements  which show how  to  decode  fax  data.   The  numbers  in\n  \
    \ parentheses  are not to be consumed, that is to say they will be read\n   again\
    \ in making the next transition.\n      If I am in state BW (2) and the next bits\
    \ are:\n         0 (0):             go to BW\n         0111:              go to\
    \ BB\n         010 (1):           go to WB\n         0100:              go to\
    \ WW\n      If I am in state WB (1) and the next bits are:\n         1 (1):  \
    \           go to WB\n         1000:              go to WW\n         101 (0):\
    \           go to BW\n         1011:              go to BB\n      If I am in state\
    \  WW (0),  then  first  go through  the run length\n      algorithm, then if\
    \ the next bits are:\n         0:                 go to BB\n         1 (0):  \
    \           go to BW\n         1 (1):             go to WB\n      If I am in state\
    \  BB (3),  then  first  go through  the run length\n      algorithm, then if\
    \ the next bits are:\n         0:                 go to WW\n         1 (0):  \
    \           go to BW\n         1 (1):             go to  WB\n      For the run\
    \ length  algorithm,  remember, look at the next n bits,\n      where  n is the\
    \ length  of either  the black  or white  run length\n"
- title: DECODING FACSIMILE DATA                                          RFC 798
  contents:
  - 'DECODING FACSIMILE DATA                                          RFC 798

    '
- title: V. The Decoding Algorithm
  contents:
  - "V. The Decoding Algorithm                                               \n  \
    \    word,  REVERSE  the bits,  and  output  that  many  BB's  or  WW's\n    \
    \  (depending  on whether black or white run).  If the field is full,\n      increment\
    \  the size of the word, and get that many bits more, i.e.\n      get the next\
    \ n+1 bits,  etc.  Also, the run length word length can\n      be decremented\
    \ according to the rules given in section III.\n      You always  go through the\
    \ run length even if there is only one WW\n      or BB, in this case, the run\
    \ field will be 0.\n      Let us look at the first example given in section III.\
    \  Suppose we\n      want to decode the bits:  110111100010100100100101000...\
    \  (we have\n      already reversed the run lengths to make things easier).\n\
    \      We are in state  1 (WB)  and the black run length word length is 2\n  \
    \    and the white  length  is 3.   We get these  initial values either\n    \
    \  from the block header,  or by remembering  them from the  previous\n      transitions\
    \  if this is not the start  of the block.  According to\n      our rules, we\
    \ would parse this string as follows:\n         1(1) 1011 11 000 1(0) 0100 100\
    \ 1(0) 0(0) 010(1) 1000...\n      The numbers  in parentheses  are numbers  that\
    \ were read  but  not\n      \"consumed\",  thus the next number  in the sequence\
    \  is the same as\n      the one in parentheses.   First,  we see a 1 and that\
    \ the next bit\n      is a 1,  this  means  that we go to WB.  Then we have a\
    \ 1011 which\n      means  to go to BB.   Then we do a run, we have a 11 followed\
    \ by a\n      000 which  means the black run length gets incremented by 1 (it\
    \ is\n      now 3)  and we get 3 MORE  BB's.   Now we have  a 1 followed  by 0\n\
    \      which  means  go to BW.   Next a 0100 which is WW.  Then we have a\n  \
    \    run, 100, which means four more WW's.  We keep going like this and\n    \
    \  we get the original  bit pattern  given  in the first  example  of\n      section\
    \ III.\n      It is important  to always  start fresh  when  dealing  with  each\n\
    \      block.   There  are many reasons  for this.   The  first  is  that\n  \
    \    sometimes blocks are dropped, and you can recover from this if you\n    \
    \  resynchronize  at the start of each block.  Also, if at the end of\n      the\
    \ previous  block, there is about to be a transition, instead of\n      making\
    \  it at the beginning  of the next block,  the  fax  machine\n      gives  the\
    \ new state in the header of the next block and goes from\n      there.   Thus\
    \ it is important to always start at whatever state is\n      given  in the header,\
    \  and to align  yourself  at  the  current  X\n      position given there also.\n\
    \      Sometimes,  while decoding a block, a bit pattern will occur which\n"
- title: RFC 798                                          DECODING FACSIMILE DATA
  contents:
  - "RFC 798                                          DECODING FACSIMILE DATA\n  \
    \                                             V. The Decoding Algorithm\n    \
    \  does not correspond  to any transition.  If this happens, the rest\n      of\
    \ the block may be bad and should be discarded.\n      The decoding  program decodes\
    \ the fax data block by block until it\n      comes to an END command in the data,\
    \ or runs out of data.\n"
- title: VI.  Program Performance
  contents:
  - "VI.  Program Performance\n   The L10 NLS program takes about two CPU minutes\
    \ to run on TOPS20 on a\n   DEC KL10 to decode the average document in fine detail\
    \ mode.  In this\n   mode,  the picture  is about  1726 by 2100 pels,  and takes\
    \ about 204\n   disk pages to store.\n   We have a program  which displays bit\
    \ maps on an HP graphics terminal\n   and have been able to display  portions\
    \ of documents.  (not all of an\n   8.5\"  by 11\"  document  will fit in the\
    \ display).   We  can  use  the\n   terminal's  zoom capability  to look at very\
    \ small  portions  of  the\n   document.\n"
- title: DECODING FACSIMILE DATA                                          RFC 798
  contents:
  - 'DECODING FACSIMILE DATA                                          RFC 798

    '
- title: References
  contents:
  - "References                                                              \n"
- title: References
  contents:
  - "References\n   [1]  Weber,  D.  R.,  \"An Adaptive  Run Length  Encoding  Algorithm\"\
    ,\n   International   Conference   on  Communications,  ICC-75,  IEEE,  San\n\
    \   Francisco, California, June 1975.\n   [2]   Mills,   D.   L.,   \"Rapicom\
    \   450  Facsimile  Data  Decoding\",\n   WP2097/MD33E, COMSAT Laboratories, Washington\
    \ D.C., undated.\n   [3]  Casner,  S.  L.,   \"Faxie\",   ISI Internal Memo, USC/Information\n\
    \   Sciences Institute, February 1980.\n   [4]  Postel,  Jon,  \"Rapicom  450\
    \ Facsimile  File Format\",  RFC  769,\n   USC/Information Sciences Institute,\
    \ September 1980.\n"
- title: RFC 798                                          DECODING FACSIMILE DATA
  contents:
  - "RFC 798                                          DECODING FACSIMILE DATA\n  \
    \                                                              Appendix\n"
- title: Appendix
  contents:
  - "Appendix\n   In this appendix  is given  the first portion of the data which\
    \ comes\n   from the fax machine,  this same data in RFC 769 format,  and some\
    \ of\n   this data decoded  into a bitmap.   The data is represented  in octal\n\
    \   octets.\n   The following  is data of the form which comes out of the fax\
    \ machine\n   with length and command octets added:\n      114  70 142 171 330\
    \  13 377 377 377 371  53 200   0   5 125 125\n      125 125 125 125 125 125 125\
    \ 125 125 125 125 125 125 125 125 125\n      125 125 125 125 125 125 125 125 125\
    \ 125 125 125 125 125 125 125\n      125 125 125 125 125 125 125 125 125 125 125\
    \ 125 125 125 125 125\n      125 125 125 125 125 125 125 125 125 121  21 261 114\
    \  71 142 171\n      330  40   0 102 326 270 152  42  42  44 111   0  42 151 267\
    \ 122\n      366 110 237 102 211 365 111 171 336  51 244 247 377 377 111 362\n\
    \      177 377 377 377 377 377 377 377 377 376 104 213 241  41 111 377\n     \
    \ 111 337 377 377 377 377 377 377 377 377 377 377 377 163 301 361\n      377 377\
    \ 377 377 360 177  12   0 114  71 142 171 330 141 137 177\n      377 344  10 \
    \  0 160  23 301 160 137 376 204 352 135  27 353 264\n        0  70 100   7  20\
    \  75   0   0   0   0   0 344   0   0   0   0\n        0   0   0   0  34 275 \
    \  0   0   0   0   0   0   0   0   0   0\n        0   0   0   0   7  41 310  34\
    \ 200   0   0 344   0   0   0  71\n       13 331 204   0 114  71 142 171 330 241\
    \ 137  26 302 160   0  16\n      100  71   0 370 270 271   0 162   0  71 174 134\
    \ 100 162   0  34\n      234 200 344   7 156 100   1 310  16 107  43 323 263 220\
    \ 365 313\n      327  57 377 325 331  36  56  47 325 324 344   3 227  40  71 \
    \ 35\n      200   1 310   1 313 220   0   0   7 241 330   0   0 137 342 200\n\
    \      114  71 142 171 330 340  77  40 142 160   0   0   0   0 162  71\n     \
    \  73 162 376 276 234 277 376  67 265 301  16  20 171   1 311 313\n      346 377\
    \ 321  75 256 113 245 377 262 160 136 247  13 251 350 374\n      270 236 235 217\
    \ 136 203 220  75 166 166 364 177 305 366  72 107\n       63 330 352 345 313 320\
    \  71  34 270  46  57   0\n   The following is the same data after put into RFC\
    \ 769 format (with\n   each data octet reversed and complemented):\n      114\
    \  70 271 141 344  57   0   0   0 140  53 376 377 137 125 125\n      125 125 125\
    \ 125 125 125 125 125 125 125 125 125 125 125 125 125\n      125 125 125 125 125\
    \ 125 125 125 125 125 125 125 125 125 125 125\n      125 125 125 125 125 125 125\
    \ 125 125 125 125 125 125 125 125 125\n      125 125 125 125 125 125 125 125 125\
    \ 165 167 162 114  71 271 141\n      344 373 377 275 224 342 251 273 273 333 155\
    \ 377 273 151  22 265\n      220 355   6 275 156 120 155 141 204 153 332  32 \
    \  0   0 155 260\n        1   0   0   0   0   0   0   0   0 200 335  56 172 173\
    \ 155   0\n"
- title: DECODING FACSIMILE DATA                                          RFC 798
  contents:
  - 'DECODING FACSIMILE DATA                                          RFC 798

    '
- title: Appendix
  contents:
  - "Appendix                                                                \n  \
    \    155   4   0   0   0   0   0   0   0   0   0   0   0  61 174 160\n       \
    \ 0   0   0   0 360   1 257 377 114  71 271 141 344 171   5   1\n        0 330\
    \ 357 377 361  67 174 361   5 200 336 250 105  27  50 322\n      377 343 375 \
    \ 37 367 103 377 377 377 377 377 330 377 377 377 377\n      377 377 377 377 307\
    \ 102 377 377 377 377 377 377 377 377 377 377\n      377 377 377 377  37 173 354\
    \ 307 376 377 377 330 377 377 377 143\n       57 144 336 377 114  71 271 141 344\
    \ 172   5 227 274 361 377 217\n      375 143 377 340 342 142 377 261 377 143 301\
    \ 305 375 261 377 307\n      306 376 330  37 211 375 177 354 217  35  73  64 \
    \ 62 366 120  54\n       24  13   0 124 144 207 213  33 124 324 330  77  26 373\
    \ 143 107\n      376 177 354 177  54 366 377 377  37 172 344 377 377   5 270 376\n\
    \      114  71 271 141 344 370   3 373 271 361 377 377 377 377 261 143\n     \
    \  43 261 200 202 306   2 200  23 122 174 217 367 141 177 154  54\n      230 \
    \  0 164 103 212  55 132   0 262 361 205  32  57 152 350 300\n      342 206 106\
    \  16 205  76 366 103 221 221 320   1 134 220 243  35\n       63 344 250 130 \
    \ 54 364 143 307 342 233  13 377\n   The following is the first part of the expanded\
    \ bitmap of this data\n   (there are about 4 scan lines here, or 2 pairs of scan\
    \ lines):\n      177 377 377 377 377 377 377 377 377 377 377 377 377 377 377 377\n\
    \      377 377 377 377 377 377 377 377 377 377 377 377 377 377 377 377\n     \
    \ 377 377 377 377 377 377 377 377 377 377 377 377 377 377 377 377\n      377 377\
    \ 377 377 377 377 367 377 377 377 377 377 377 377 377 377\n      377 377 377 377\
    \ 377 377 377 377 377 377 377 377 377 377 377 377\n      377 377 377 377 377 377\
    \ 377 377 377 377 377 377 377 377 377 377\n      337 377 377 377 377 377 377 377\
    \ 377 377 377 377 377 377 377 377\n      377 377 377 377 377 377 377 377 377 377\
    \ 377 377 377 377 377 377\n      377 377 377 377 377 377 377 377 377 377 377 377\
    \ 377 377 377 377\n      377 377 377 377 377 377 377 377 377 377 377 377 377 377\
    \ 377 377\n      377 377 377 377 377 377 377 377 377 377 377 377 377 377 377 377\n\
    \      377 377 377 377 377 377 377 377 377 377 377 377 377 377 377 377\n     \
    \ 377 377 377 377 377 377 377 377 377 377 377 377 377 377 377 377\n      377 377\
    \ 377 377 377 377 377 374   0   4 327 377 377 377 377 377\n      374 377 356 377\
    \ 177   0  10   0 201 200   0   0   0   0 100   0\n        0   0   0   0   0 \
    \  0   1 140   0   0   0   0   0   0   0   0\n        0   0   0   0   0   0 204\
    \  10   0   0  10   0   0   0 100   0\n       20  10   7 250   2   0  57 100 100\
    \   2 100 100 164   0  20  21\n       31 310 153 137 377 377 377 377 177  32 176\
    \ 344   2 200 216   0\n        4   0 240   0   0  14  70   0   0   0   0   0 \
    \  2  47 137 336\n      137 377 377 377 377 375 377 372  20 140  45 376 377 377\
    \ 377 237\n      377 276 357 377 377 377 227 345 314 175  63 215 202   6 347 143\n\
    \      377 337 376  70 371 370 352 300 213 373 371 377 377 343  73 334\n     \
    \   0 207 315   3  33 111 377 167 337 377   1 323 365 177 377 177\n      377 374\
    \ 377 135 377 377 365  67 343  55 377 377 377 377 357 377\n      377 377 377 377\
    \ 377 377 203 377 236 175 376 236 337 273 347 377\n"
- title: RFC 798                                          DECODING FACSIMILE DATA
  contents:
  - "RFC 798                                          DECODING FACSIMILE DATA\n  \
    \                                                              Appendix\n    \
    \  376  77 377 377 377 377 377 377 377 377 377 377 300   0   0   0\n      200\
    \ 102 177 377 277 377 377 377 376 377 366 365 173 302  12   0\n       40 200 \
    \  0   0   0   4 100   0   0   0   0   0   0   2   5 354\n        0   0   0  \
    \ 0   0   0   0   0   4   0  10   0   0   0 200  10\n       40  20   1   0 100\
    \   0 140   0  20 210 101 374   3 200 155 304\n        0   6 100 103 376   0 120\
    \ 121  31 332 243 177 377 377 377 377\n      377 233 377 354   0 241 217   1 \
    \ 30   0 240   0   0  12 150 202\n       40   0   0   0  62  47 157 376 173 373\
    \ 377 377 377 377 377 377\n       20 141 321 376 377 377 377 327 377 376 377 377\
    \ 377 377 237 216\n      316 375 167 215 202   6 300 143 377 237 374  70 175 330\
    \ 377 304\n      255 373 153 377 377 353 377 104   0 267 315 203  13 311 177 377\n\
    \      377 377   1 223 367 377 373 167 377 376  77 137 377 345 165  67\n     \
    \  43  51 277 377 277 377 357 377 377 377 373 177 377 377 223 377\n      366 175\
    \ 376 234 377 271 347 377 376 157 377 377 377 377 377 377\n      377 377 377 377\
    \ 340   0   0   0   0   0 177 377  37 377 377 377\n      377 376 367 357 272 300\
    \   2   0   4   0   0   0   0   0   0   0\n        0   0   0   0  20   0   1 144\
    \   0   0   0   0   0   0   4   4\n        0   0 100   2 100  10 201  10   0 \
    \ 20  75   0   0  40 142   0\n        0  74 341 234 103   4 157 300   0   2  \
    \ 0 141 372   0   0  20\n       30 376  55 277 177 377 377 367 377 371 376 100\
    \  15  61  16 200\n       30   0  40   0   0   0 311 200  24   0   0   0  62 \
    \ 55 377 316\n      367 347 377 357 377 377 377 377 170 305   5 276 377 377 377\
    \ 357\n      377 377 377 377 377 177 377 377 357 177 377  76 207 246 340 147\n\
    \      376 336 356  10  17 320 105 235 275 377 377 373 377 347 335 317\n     \
    \  50  77 377 353  75 333 377 377 377 377 363 337 343 277 356 171\n        7 357\
    \  76 216 377 211 207 176 257 217 377 377 367 357 357 277\n      377 357 377 377\
    \ 377 375 367 377 377 377 377 375 377 377 356 377\n      366 377 377 377 377 377\
    \ 377 377 377 377 377 377 340   0   0   0\n        0  44 373 377  77 377 377 177\
    \ 177 377 377 337 376 170 173   0\n        0   0 100   0   1  10   0   0   0 \
    \  0   0 200 160   0 223 160\n      300   0   0   0   0   0   0   6 100 220  \
    \ 0   0 140   4   3  30\n      121  20 351 300 206  74 167   0  30  64  41 234\
    \ 172  30 175 300\n        4  32   4 345 367 200 103  60 177 372 177 233 377 377\
    \ 377 377\n      376 125 207 210 233  21 364 361 277   1  50  16 140 120  41 335\n\
    \      377 306 214  10  67 377 373 377 377 377 377 377 377 367 377 377\n     \
    \ 377 363 277 377 377 377 377 377 267 177 377 377 377 377 377 237\n      377 377\
    \ 377  77 377 377 355 373\n"
