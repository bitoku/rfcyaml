- title: __initial_text__
  contents:
  - ''
- title: Independent Submission                                        C. Schmitt
  contents:
  - "Independent Submission                                        C. Schmitt\n  \
    \         TinyIPFIX for Smart Meters in Constrained Networks\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies the TinyIPFIX protocol that is used for\n\
    \   transmitting smart-metering data in constrained networks such as IPv6\n  \
    \ over Low-Power Wireless Personal Area Networks (6LoWPAN, RFC 4944).\n   TinyIPFIX\
    \ is derived from IP Flow Information Export (RFC 7011) and\n   adopted to the\
    \ needs of constrained networks.  This document\n   specifies how the TinyIPFIX\
    \ Data and Template Records are transmitted\n   in constrained networks such as\
    \ 6LoWPAN and how TinyIPFIX data can be\n   converted into data that is not TinyIPFIX\
    \ in a proxy device.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This is a contribution to\
    \ the RFC Series, independently of any other\n   RFC stream.  The RFC Editor has\
    \ chosen to publish this document at\n   its discretion and makes no statement\
    \ about its value for\n   implementation or deployment.  Documents approved for\
    \ publication by\n   the RFC Editor are not a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 7841.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   https://www.rfc-editor.org/info/rfc8272.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2017 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   3\n     1.1.  Document Structure  . . . . . . . . . . . . . . .\
    \ . . . .   3\n   2.  Terminology . . . . . . . . . . . . . . . . . . . . . .\
    \ . . .   4\n   3.  Constraints . . . . . . . . . . . . . . . . . . . . . . .\
    \ . .   6\n     3.1.  Hardware Constraints  . . . . . . . . . . . . . . . . .\
    \ .   6\n     3.2.  Energy Constraints  . . . . . . . . . . . . . . . . . . .\
    \   7\n     3.3.  Packet Size Constraints . . . . . . . . . . . . . . . . .  \
    \ 7\n     3.4.  Transport Protocol Constraints  . . . . . . . . . . . . .   8\n\
    \   4.  Application Scenarios for TinyIPFIX . . . . . . . . . . . . .   9\n  \
    \ 5.  Architecture for TinyIPFIX  . . . . . . . . . . . . . . . . .  11\n   6.\
    \  TinyIPFIX Message Format  . . . . . . . . . . . . . . . . . .  14\n     6.1.\
    \  TinyIPFIX Message Header  . . . . . . . . . . . . . . . .  15\n     6.2.  TinyIPFIX\
    \ Set . . . . . . . . . . . . . . . . . . . . . .  18\n     6.3.  TinyIPFIX Template\
    \ Record Format  . . . . . . . . . . . .  19\n     6.4.  Field Specifier Format\
    \  . . . . . . . . . . . . . . . . .  20\n     6.5.  TinyIPFIX Data Record Format\
    \  . . . . . . . . . . . . . .  21\n   7.  TinyIPFIX Mediation . . . . . . . .\
    \ . . . . . . . . . . . . .  21\n     7.1.  Expanding the Message Header  . .\
    \ . . . . . . . . . . . .  24\n     7.2.  Translating the Set Headers . . . .\
    \ . . . . . . . . . . .  25\n     7.3.  Expanding the Template Record Header \
    \ . . . . . . . . . .  25\n   8.  Template Management . . . . . . . . . . . .\
    \ . . . . . . . . .  25\n     8.1.  TCP/SCTP  . . . . . . . . . . . . . . . .\
    \ . . . . . . . .  26\n     8.2.  UDP . . . . . . . . . . . . . . . . . . . .\
    \ . . . . . . .  26\n   9.  Security Considerations . . . . . . . . . . . . .\
    \ . . . . . .  26\n   10. IANA Considerations . . . . . . . . . . . . . . . .\
    \ . . . . .  26\n   11. References  . . . . . . . . . . . . . . . . . . . . .\
    \ . . . .  27\n     11.1.  Normative References . . . . . . . . . . . . . . .\
    \ . . .  27\n     11.2.  Informative References . . . . . . . . . . . . . . .\
    \ . .  28\n   Acknowledgments . . . . . . . . . . . . . . . . . . . . . . . .\
    \ .  29\n   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .\
    \  30\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Smart meters that form a constrained wireless network need\
    \ an\n   application-layer protocol that allows the efficient transmission of\n\
    \   metering data from the devices to a central analysis device.  The\n   meters\
    \ used to build such networks are usually equipped with low-cost\n   and low-power\
    \ hardware.  This leads to constraints in computational\n   capacities, available\
    \ memory, and networking resources.\n   The devices are often battery powered\
    \ and are expected to run for a\n   long time without having the possibility of\
    \ recharging themselves.\n   In order to save energy, smart meters often power\
    \ off their wireless\n   networking device.  Hence, they don't have a steady network\n\
    \   connection; they are only part of the wireless network as needed when\n  \
    \ there is data to be exported.  A push protocol like TinyIPFIX, where\n   data\
    \ is transmitted autonomically from the meters to one or more\n   collectors,\
    \ is suitable for reporting metering data in such networks.\n   TinyIPFIX is derived\
    \ from IPFIX [RFC7011]; therefore, it inherits\n   most of IPFIX's properties.\
    \  One of these properties is the\n   separation of data and its data description\
    \ by encoding the former in\n   Data Sets and the latter in Template Sets.\n \
    \  Transforming TinyIPFIX to IPFIX as per [RFC7011] is very simple and\n   can\
    \ be done on the border between the constrained network and the\n   more general\
    \ network.  The transformation between one form of IPFIX\n   data into another\
    \ is known as \"IPFIX Mediation\" [RFC5982].  Hence,\n   smart-metering networks\
    \ that are based on TinyIPFIX can be easily\n   integrated into an existing IPFIX\
    \ measurement infrastructure.\n"
- title: 1.1.  Document Structure
  contents:
  - "1.1.  Document Structure\n   Section 2 introduces the terminology used in this\
    \ document.\n   Afterwards, hardware and software constraints in constrained\n\
    \   networks, which will motivate our modifications to the IPFIX\n   protocol,\
    \ are discussed in Section 3.  Section 4 describes the\n   application scenarios\
    \ and Section 5 describes the architecture for\n   TinyIPFIX.  Section 6 defines\
    \ the TinyIPFIX protocol itself and\n   discusses the differences between TinyIPFIX\
    \ and IPFIX.  The Mediation\n   Process from TinyIPFIX to IPFIX is described in\
    \ Section 7.  Section 8\n   defines the process of Template Management on the\
    \ Exporter and the\n   Collector.  Section 9 and Section 10 discuss the security\
    \ and IANA\n   considerations for TinyIPFIX.\n"
- title: 2.  Terminology
  contents:
  - "2.  Terminology\n   Most of the terms used in this document are defined in [RFC7011].\n\
    \   Each of these terms begins with a capital letter.  Most of the terms\n   that\
    \ are defined for IPFIX can be used to describe TinyIPFIX.  This\n   document\
    \ uses the term \"IPFIX\" to refer to IPFIX as defined in\n   [RFC7011] and the\
    \ term TinyIPFIX for the protocol specified in this\n   draft document assuming\
    \ constrained networks.  The prefix \"Tiny\" is\n   added to IPFIX to distinguish\
    \ between the IPFIX version and the\n   TinyIPFIX version.\n   The terms IPFIX\
    \ Message, IPFIX Device, Set, Data Set, Template Set,\n   Data Record, Template\
    \ Record, Collecting Process, Collector,\n   Exporting Process, and Exporter are\
    \ defined as in [RFC7011].  The\n   term IPFIX Mediator is defined in [RFC5982].\
    \  The terms Intermediate\n   Process, IPFIX Proxy, IPFIX Concentrator are defined\
    \ in [RFC6183].\n   All the terms above have been adapted from the IPFIX definitions.\
    \  As\n   they keep a similar notion but in a different context of constrained\n\
    \   networks, the term \"TinyIPFIX\" now precedes the defined terms.\n   The term\
    \ \"smart meter\" is used to refer to constrained devices like\n   wireless sensor\
    \ nodes, motes, or any other kind of small constrained\n   device that can be\
    \ part of a network that is based on IEEE 802.15.4\n   and 6LoWPAN [RFC4944].\n\
    \   TinyIPFIX Exporting Process\n      The TinyIPFIX Exporting Process is a process\
    \ that exports\n      TinyIPFIX Records.\n   TinyIPFIX Exporter\n      A TinyIPFIX\
    \ Exporter is device that contains at least one\n      TinyIPFIX Exporting Process.\n\
    \   TinyIPFIX Collecting Process\n      The TinyIPFIX Collecting Process is a\
    \ process inside a device that\n      is able to receive and process TinyIPFIX\
    \ Records.\n   TinyIPFIX Collector\n      A TinyIPFIX Collector is a device that\
    \ contains at least one\n      TinyIPFIX Collecting Process.\n   TinyIPFIX Device\n\
    \      A TinyIPFIX Device is a device that contains one or more TinyIPFIX\n  \
    \    Collectors or one or more TinyIPFIX Exporters.\n   TinyIPFIX Smart Meter\n\
    \      A TinyIPFIX Smart Meter is a device that contains the\n      functionality\
    \ of a TinyIPFIX Device.  It is usually equipped with\n      one or more sensors\
    \ that meter a physical quantity, like power\n      consumption, temperature,\
    \ or physical tampering with the device.\n      Every TinyIPFIX Smart Meter MUST\
    \ at least contain a TinyIPFIX\n      Exporting Process.  It MAY contain a TinyIPFIX\
    \ Collecting Process\n      in order to work as a TinyIPFIX Proxy or TinyIPFIX\
    \ Concentrator.\n   TinyIPFIX Data Record\n      A TinyIPFIX Data Record equals\
    \ an IPFIX Data Record in [RFC7011].\n      The term is used to distinguish between\
    \ IPFIX and TinyIPFIX\n      throughout this document.\n   TinyIPFIX Template\
    \ Record\n      A TinyIPFIX Template Record is similar to an IPFIX Template Record\n\
    \      in [RFC7011].  The Template Record Header is substituted with a\n     \
    \ TinyIPFIX Template Record Header and is otherwise equal to a\n      Template\
    \ Record.  See Section 6.3.\n   TinyIPFIX Set\n      The TinyIPFIX Set is a group\
    \ of TinyIPFIX Data Records or\n      TinyIPFIX Template Records with a TinyIPFIX\
    \ Set Header.  Its\n      format is defined in Section 6.2.\n   TinyIPFIX Data\
    \ Set\n      The TinyIPFIX Data Set is a TinyIPFIX Set that contains TinyIPFIX\n\
    \      Data Records.\n   TinyIPFIX Template Set\n      A TinyIPFIX Template Set\
    \ is a TinyIPFIX Set that contains\n      TinyIPFIX Template Records.\n   TinyIPFIX\
    \ Message\n      The TinyIPFIX Message is a message originated by a TinyIPFIX\n\
    \      Exporter.  It is composed of a TinyIPFIX Message Header and one or\n  \
    \    more TinyIPFIX Sets.  The TinyIPFIX Message Format is defined in\n      Section\
    \ 6.\n   TinyIPFIX Intermediate Process\n      A TinyIPFIX Intermediate Process\
    \ is an IPFIX Intermediate Process\n      that can handle TinyIPFIX Messages.\n\
    \   TinyIPFIX Proxy\n      A TinyIPFIX Proxy is an IPFIX Proxy that can handle\
    \ TinyIPFIX\n      Messages.\n   TinyIPFIX Concentrator\n      A TinyIPFIX Concentrator\
    \ is device that can handle TinyIPFIX\n      Messages (e.g., pre-process them)\
    \ and is not constrained.\n   TinyIPFIX Proxy\n      A TinyIPFIX Proxy is an IPFIX\
    \ Proxy that can handle TinyIPFIX\n      Messages and is not constrained.\n  \
    \ A TinyIPFIX Transport Session is defined by the communication between\n   a\
    \ TinyIPFIX Exporter (identified by an 6LoWPAN-Address, the Transport\n   Protocol,\
    \ and the Transport Port) and a TinyIPFIX Collector\n   (identified by the same\
    \ properties).\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\"\
    , \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described\
    \ in\n   BCP 14 [RFC2119] [RFC8174] when, and only when, they appear in all\n\
    \   capitals, as shown here.\n"
- title: 3.  Constraints
  contents:
  - '3.  Constraints

    '
- title: 3.1.  Hardware Constraints
  contents:
  - "3.1.  Hardware Constraints\n   The target devices for TinyIPFIX are usually equipped\
    \ with low-cost\n   hardware; therefore, they face several constraints concerning\
    \ CPU and\n   memory [Schmitt09].  For example, the IRIS mote from Crossbow\n\
    \   Technologies, Inc. has a size of 58 x 32 x 7 mm (without a battery\n   pack)\
    \ [IRIS].  Thus, there is little space for a micro-controller,\n   memory (128\
    \ kb program flash, 512 kb measurement serial flash, 8 kb\n   RAM, 4 kb configuration\
    \ EEPROM), and radio-frequency transceiver,\n   which are located on the board.\
    \  The TelosB motes produced by\n   Crossbow Technologies, Inc. [TelosB] and ADVANTIC\
    \ SISTEMAS Y\n   SERVICIOS S.L.  [Advantic] are similar sized, but offering more\n\
    \   memory (48 kb flash, 1024 kb serial, flash, 10 kb RAM, 16 kb\n   configuration\
    \ EEPROM).  The same holds for OpenMote, but the offering\n   is 512 kb flash\
    \ and 32 kb RAM [openMote].\n   Network protocols used on such hardware need to\
    \ respect these\n   constraints.  They must be simple to implement using little\
    \ code and\n   little run-time memory and should produce little overhead when\n\
    \   encoding the application payload.\n"
- title: 3.2.  Energy Constraints
  contents:
  - "3.2.  Energy Constraints\n   Smart meters that are battery powered have hard\
    \ energy constraints\n   [Schmitt09].  If two AA 2800-mAh batteries power the\
    \ mote, they\n   contain approximately 30,240 Joule of energy.  If they run out\
    \ of\n   power, their battery has to be changed, which means physical\n   manipulation\
    \ to the device is necessary.  Therefore, using as little\n   energy as possible\
    \ for network communication is desired.\n   A smart-metering device can save a\
    \ lot of energy, if it powers down\n   its radio-frequency transceiver.  Such\
    \ devices do not have permanent\n   network connectivity; they are only part of\
    \ the network as needed.  A\n   push protocol, where only one side is sending\
    \ data, is suitable for\n   transmitting application data under such circumstances.\
    \  As the\n   communication is unidirectional, a meter can completely power down\n\
    \   its radio-frequency transceivers as long as it does not have any data\n  \
    \ to send.  If the metering device is able to keep a few measurements\n   in memory,\
    \ and if real-time metering is not a requirement, the\n   TinyIPFIX Data Records\
    \ can be pushed less frequently, therefore\n   saving some more energy on the\
    \ radio-frequency transceivers.\n"
- title: 3.3.  Packet Size Constraints
  contents:
  - "3.3.  Packet Size Constraints\n   TinyIPFIX is mainly targeted for the use in\
    \ 6LoWPAN networks, which\n   are based on IEEE 802.15.4 [RFC4944].  However,\
    \ the protocol can also\n   be used to transmit data in other networks when a\
    \ mediator is used\n   for translating the TinyIPFIX data into the data format\
    \ used in the\n   other network (e.g., IPFIX).  And the protocol is able to map\
    \ the\n   6LoWPAN addresses to the addresses used in the other network.  This\n\
    \   operation typically consists of per-message re-encapsulation and/or\n   re-encoding.\
    \  As defined [RFC4944], IEEE 802.15.4 starts from a\n   maximum physical layer\
    \ packet size of 127 octets (aMaxPHYPacketSize)\n   and a maximum frame overhead\
    \ of 25 octets (aMaxFrameOverhead),\n   leaving a maximum frame size of 102 octets\
    \ at the media access\n   control (MAC) layer.  On the other hand, IPv6 defines\
    \ a minimum MTU\n   of 1280 octets.  Hence, fragmentation has to be implemented\
    \ in order\n   to transmit such large packets.  While fragmentation allows the\n\
    \   transmission of large messages, its use is problematic in networks\n   with\
    \ high packet loss because the complete message has to be\n   discarded if only\
    \ a single fragment gets lost.\n   TinyIPFIX enhances IPFIX by a header-compression\
    \ scheme, which allows\n   the header size overhead to be significantly reduced.\
    \  Additionally,\n   the overall TinyIPFIX Message size is reduced, which reduces\
    \ the need\n   for fragmentation.\n"
- title: 3.4.  Transport Protocol Constraints
  contents:
  - "3.4.  Transport Protocol Constraints\n   The IPFIX standard [RFC7011] defines\
    \ several transport protocol\n   bindings for the transmission of IPFIX Messages.\
    \  Stream Control\n   Transmission Protocol (SCTP) support is REQUIRED for any\
    \ IPFIX Device\n   to achieve standard conformance [RFC7011], and its use is highly\n\
    \   recommended.  However, sending IPFIX over UDP and TCP MAY also be\n   implemented.\n\
    \   This transport protocol recommendation is not suitable for TinyIPFIX.\n  \
    \ A header compression scheme that allows a compression of an IPv6\n   header\
    \ from 40 octets down to 2 octets is defined in 6LoWPAN.  There\n   is a similar\
    \ compression scheme for UDP, but there is no such\n   compression for TCP or\
    \ SCTP headers.  If header compression can be\n   employed, more space for application\
    \ payload is available.\n   Therefore, using UDP on the transport layer for transmitting\n\
    \   TinyIPFIX Messages is RECOMMENDED.  Furthermore, TCP or SCTP are\n   currently\
    \ not supported on some platforms, like on TinyOS [Harvan08].\n   Hence, UDP may\
    \ be the only option.\n   Every TinyIPFIX Exporter and Collector MUST implement\
    \ UDP transport-\n   layer support for transmitting data in a constrained network\n\
    \   environment.  It MAY also offer TCP or SCTP support.  In the case in\n   which\
    \ TCP or SCTP MAY be used, power consumption will grow and the\n   available size\
    \ of application payload compared to the use of UDP May\n   be reduced.  If TinyIPFIX\
    \ is transmitted over a unconstrained\n   network, using SCTP as a transport-layer\
    \ protocol is RECOMMENDED.\n   TinyIPFIX works independent of the target environment,\
    \ because it\n   MUST only be ensured that all intermediate devices can understand\n\
    \   TinyIPFIX and be able to extract needed packet information (e.g., IP\n   destination\
    \ address).  TinyIPFIX messages can be included in other\n   transport protocols\
    \ in the payload whenever is necessary, making\n   TinyIPFIX highly flexible and\
    \ usable for different communication\n   protocols (e.g., Constrained Application\
    \ Protocol (CoAP), UDP, TCP).\n   TinyIPFIX itself just specifies a messages format\
    \ for the collected\n   data to be transmitted.\n   The constraints on UDP usage\
    \ given in Section 6.2 of [RFC5153] apply\n   to TinyIPFIX as well.  TinyIPFIX\
    \ is not intended for use over the\n   open Internet.  In general, the networks\
    \ on which it runs are\n   considered dedicated for sensor operations and are\
    \ under the control\n   of a single administrative domain.\n"
- title: 4.  Application Scenarios for TinyIPFIX
  contents:
  - "4.  Application Scenarios for TinyIPFIX\n   TinyIPFIX is derived from IPFIX [RFC7011];\
    \ therefore, it is a\n   unidirectional push protocol assuming UDP usage.  This\
    \ means all\n   communication that employs TinyIPFIX is unidirectional from an\n\
    \   Exporting Process to a Collecting Process.  Hence, TinyIPFIX only\n   fits\
    \ for application scenarios where meters transmit data to one or\n   more Collectors.\
    \  In case pull requests should also be supported by\n   TinyIPFIX, it is RECOMMENDED\
    \ not to change the code of TinyIPFIX much\n   to get along with the restricted\
    \ memory available [Schmitt2017].\n   Meaning including just a one bit field,\
    \ called type, to distinguish\n   between push and pull messages would be feasible,\
    \ but the filtering\n   SHOULD be done by the gateway and not by the constrained\
    \ device;\n   meaning if a pull is performed, the constrained device is triggered\n\
    \   to create a TinyIPFIX message immediately as usual, set the type\n   field\
    \ to one instead of zero (for a push message), and send message\n   to the gateway.\
    \  At the gateway, the filtering is performed based on\n   the pull request.\n\
    \   If TinyIPFIX is used over UDP, as recommended, packet loss can occur.\n  \
    \ Furthermore, if an initial Template Message gets lost, and is\n   therefore\
    \ unknown to the Collector, all TinyIPFIX Data Sets that\n   reference this Template\
    \ cannot be decoded.  Hence, all these Messages\n   are lost if they are not cached\
    \ by the Collector.  It should be clear\n   to an application developer that TinyIPFIX\
    \ can only be used over UDP\n   if these TinyIPFIX Message losses are not a problem.\
    \  To avoid this\n   loss, it is RECOMMENDED to repeat the Template Message periodically,\n\
    \   keeping in mind that a Template never changes for a constrained\n   device\
    \ after deployment.  Even when Template Messages become lost in\n   the network,\
    \ the data can be manually translated later when the\n   Template Messages is\
    \ re-sent.  Including an acknowledgement mechanism\n   is NOT RECOMMENDED due\
    \ to overhead, because this would require\n   storage of any sent data on the\
    \ constrained devices until it was\n   acknowledged.  In critical applications,\
    \ it is RECOMMENDED to repeat\n   the Template Message more often.\n   TinyIPFIX\
    \ over UDP is especially not a suitable protocol for\n   applications where sensor\
    \ data trigger policy decisions or\n   configuration updates for which packet\
    \ loss is not tolerable.\n   Applications that use smart sensors for accounting\
    \ purposes for long-\n   term measurements can benefit from the use of TinyIPFIX.\
    \  One\n   application for IPFIX is long-term monitoring of large physical\n \
    \  volumes.  In [Tolle05], Tolle et al. built a system for monitoring a\n   \"\
    70-meter tall redwood tree, at a density interval of 5 minutes in\n   time and\
    \ 2 meters in space\".  The sensor node infrastructure was\n   deployed to measure\
    \ the air temperature, relative humidity, and\n   photosynthetically active solar\
    \ radiation over a long-term period.\n   TinyIPFIX is a good fit for such scenarios.\
    \  Data can be measured by\n   the sensors of the TinyIPFIX Smart Meter over several\
    \ 5-minute time\n   intervals; the measurements can be accumulated into a single\n\
    \   TinyIPFIX Message.  As soon as enough measurements are stored in the\n   TinyIPFIX\
    \ Message, e.g., if the TinyIPFIX Message size fills the\n   available payload\
    \ in a single IEEE 802.15.4 packet, the wireless\n   transceiver can be activated\
    \ and the TinyIPFIX Message can be\n   exported to a TinyIPFIX Collector.\n  \
    \ Similar sensor networks have been built to monitor the habitat of\n   animals,\
    \ e.g., in the \"Great Duck Island Project\" [GreatDuck]\n   [SMPC04].  The purpose\
    \ of the sensor network was to monitor the birds\n   by deploying sensors in and\
    \ around their burrows.  The measured\n   sensor data was collected and stored\
    \ in a database for offline\n   analysis and visualization.  Again, the sensors\
    \ can perform their\n   measurements periodically, accumulate the sensor data,\
    \ and export\n   them to a TinyIPFIX Collector.\n   Other application scenarios\
    \ for TinyIPFIX could be applications where\n   sensor networks are used for long-term\
    \ structural health monitoring\n   in order to investigate long-term weather conditions\
    \ on the structure\n   of a building.  For example, a smart-metering network has\
    \ been built\n   to monitor the structural health of the Golden Gate Bridge [Kim07].\n\
    \   If a sensor network is deployed to perform a long-term measurement of\n  \
    \ the structural integrity, TinyIPFIX can be used to collect the\n   sensor-measurement\
    \ data.\n   If an application developer wants to decide whether to use TinyIPFIX\n\
    \   for transmitting data from smart meters, he must take the following\n   considerations\
    \ into account:\n   1.  The application should require a push protocol by default.\
    \  The\n       timing intervals of when to push data should be predefined before\n\
    \       deployment.  The property above allows a TinyIPFIX Smart Meter to\n  \
    \     turn off its wireless device in order to save energy, as it does\n     \
    \  not have to receive any data.\n   2.  If real-time reporting is not required,\
    \ the application might\n       benefit from combining several measurements into\
    \ a single\n       TinyIPFIX Message, causing delay but lowering traffic in the\n\
    \       network.  TinyIPFIX easily allow the combination of several\n       measurements\
    \ into a single TinyIPFIX Message (or a single\n       packet).  This combination\
    \ can happen on the TinyIPFIX Smart\n       Meter that combines several of its\
    \ own measurements.  Or, it can\n       happen within a multi-hop wireless network\
    \ where one IPFIX Proxy\n       combines several TinyIPFIX Messages into a single\
    \ TinyIPFIX\n       Message before forwarding them.\n   3.  The application must\
    \ accept potential packet loss.  TinyIPFIX\n       only fits for applications\
    \ where metering data is stored for\n       accounting purposes and not for applications\
    \ where the sensor\n       data triggers configuration changes or policy decisions,\
    \ except\n       when Message loss is acceptable for some reason.\n   4.  The\
    \ application must not require per-message export timestamps\n       (e.g., for\
    \ auditing).  TinyIPFIX removes export timestamps,\n       generally only useful\
    \ for Template Management operations, which\n       it also does not support,\
    \ from IPFIX.  This is a minor\n       inconvenience, since per-record timestamp\
    \ Information Elements\n       are also available in IPFIX.\n"
- title: 5.  Architecture for TinyIPFIX
  contents:
  - "5.  Architecture for TinyIPFIX\n   The TinyIPFIX architecture is similar to the\
    \ IPFIX architecture,\n   which is described in [RFC5470].  The most common deployment\
    \ of\n   TinyIPFIX Smart Meters is shown in Figure 1, where each TinyIPFIX\n \
    \  Smart Meter can have different sensors available (e.g., IRIS:\n   Temperature,\
    \ Humidity, Sound; TelosB: Temperature, Bridgeness,\n   Humidity, GPS) building\
    \ the sensor data.\n        +------------------------+     +------------------------+\n\
    \        |     TinyIPFIX Device   | ... |     TinyIPFIX Device   |\n        |\
    \   [Exporting Process]  |     |   [Exporting Process]  |\n        +------------------------+\
    \     +------------------------+\n                  |                        \
    \          |\n        TinyIPFIX |                                  | TinyIPFIX\n\
    \                  |                                  |\n                  v \
    \                                 v\n                  +----------------------------------+\n\
    \                                  |\n                                  v\n  \
    \                    +----------------------------+\n                      | \
    \   TinyIPFIX Collector     |\n                      |  [Collecting Process(es)]\
    \  |\n                      +----------------------------+\n                 \
    \                 |\n                                  v\n                   \
    \     +-----------------------+\n                        |                   \
    \    |\n                        v                       v\n               +----------------+\
    \     +----------------+\n               |[*Application 1]| ... |[*Application\
    \ n]|\n               +----------------+     +----------------+\n            \
    \  Figure 1: Direct Transmission between TinyIPFIX\n                         Devices\
    \ and Applications\n   A TinyIPFIX Smart Meter (S.M.) receives measurement data\
    \ from its\n   internal sensors to create its TinyIPFIX Messages.  Then, it encodes\n\
    \   the results into a TinyIPFIX Message using a TinyIPFIX Exporting\n   Process\
    \ and exports this TinyIPFIX Message to one or more TinyIPFIX\n   Collectors.\
    \  The TinyIPFIX Collector runs one or more applications\n   that process the\
    \ collected sensor data.  The TinyIPFIX Collector can\n   be deployed on unconstrained\
    \ devices at the constrained network\n   border.\n   A second way to deploy TinyIPFIX\
    \ Smart Meter can employ accumulation\n   on TinyIPFIX Messages during their journey\
    \ through the constrained\n   network as shown in Figure 2.  This accumulation\
    \ can be performed by\n   TinyIPFIX Concentrators.  Such devices must have enough\
    \ resources to\n   perform the accumulation.\n      +------------------------+\
    \     +------------------------+\n      |     TinyIPFIX Device   | ... |     TinyIPFIX\
    \ Device   |\n      |   [Exporting Process]  |     |   [Exporting Process]  |\n\
    \      +------------------------+     +------------------------+\n           \
    \     |                                  |\n      TinyIPFIX |                \
    \                  | TinyIPFIX\n                |                            \
    \      |\n                v                                  v\n             \
    \   +----------------------------------+\n                                  |\n\
    \                                  v\n                      +------------------------+\n\
    \                      | TinyIPFIX Concentrator |\n                      |  [Collecting\
    \  Process] |\n                      |  [Exporting Process]   |\n            \
    \          +------------------------+\n                                  |\n \
    \                       TinyIPFIX |\n                                  |\n   \
    \                               v\n                     +--------------------------+\n\
    \                     |        Collector         |\n                     | [Collecting\
    \ Process(es)] |\n                     +--------------------------+\n        \
    \            Figure 2: Accumulation of TinyIPFIX\n   TinyIPFIX Smart Meters send\
    \ their data to a TinyIPFIX Concentrator,\n   which needs to have enough storage\
    \ space to store the incoming data.\n   If the TinyIPFIX Concentrator is hosted\
    \ in a TinyIPFIX Smart Meter,\n   it MAY also be able to collect data from it\
    \ sensors, if activated.\n   It may also accumulate the incoming data with its\
    \ own measurement\n   data.  The accumulated data can then be re-exported to one\
    \ or more\n   Collectors.  In that case, the TinyIPFIX Concentrator can be viewed\n\
    \   as receiving data from multiple Smart Meters: one locally and some\n   remotely.\n\
    \   The last deployment, shown in Figure 3, employs another TinyIPFIX\n   Mediation\
    \ process.\n        +-------------------------+     +-------------------------+\n\
    \        |   Remote Smart Meter    |     |    Local Smart Meter    |\n       \
    \ +-------------------------+     +-------------------------+\n        |    TinyIPFIX\
    \ Device     |     |    TinyIPFIX Device     |\n        |   [Exporting Process]\
    \   |     |   [Exporting Process]   |\n        +-------------------------+   \
    \  +-------------------------+\n                             |               |\n\
    \                   TinyIPFIX |               | TinyIPFIX\n                  \
    \           |               |\n                             v               v\n\
    \                        +-------------------------+\n                       \
    \ | TinyIPFIX Concentrator  |\n                        |  [Collecting  Process]\
    \  |\n                        +-------------------------+\n                  \
    \     Figure 3: TinyIPFIX Mediator\n   In this deployment, the TinyIPFIX Smart\
    \ Meters transmit their\n   TinyIPFIX Messages to one node, e.g., the base station,\
    \ which\n   translates the TinyIPFIX Messages to IPFIX Messages.  The IPFIX\n\
    \   Messages can then be exported into an existing IPFIX infrastructure.\n   The\
    \ Mediation process from TinyIPFIX to IPFIX is described in\n   Section 7.\n"
- title: 6.  TinyIPFIX Message Format
  contents:
  - "6.  TinyIPFIX Message Format\n   A TinyIPFIX IPFIX Message starts with a TinyIPFIX\
    \ Message Header,\n   followed by one or more TinyIPFIX Sets.  The TinyIPFIX Sets\
    \ can be\n   either of type TinyIPFIX Template Set or of type TinyIPFIX Data Set.\n\
    \   A TinyIPFIX Message MUST only contain one type of TinyIPFIX Set.  The\n  \
    \ format of the TinyIPFIX Message is shown in Figure 4.\n           +----------------------------------------------------+\n\
    \           | TinyIPFIX Message Header                           |\n         \
    \  +----------------------------------------------------+\n           | TinyIPFIX\
    \ Set                                      |\n           +----------------------------------------------------+\n\
    \           | TinyIPFIX Set                                      |\n         \
    \  +----------------------------------------------------+\n           ...\n  \
    \         +----------------------------------------------------+\n           |\
    \ TinyIPFIX Set                                      |\n           +----------------------------------------------------+\n\
    \                    Figure 4: TinyIPFIX Message Format\n"
- title: 6.1.  TinyIPFIX Message Header
  contents:
  - "6.1.  TinyIPFIX Message Header\n   The TinyIPFIX Message Header is derived from\
    \ the IPFIX Message\n   Header, with some optimization using field compression.\
    \  The IPFIX\n   Message Header from [RFC7011] is shown in Figure 5.\n    0  \
    \                 1                   2                   3\n    0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |       Version Number          |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Export Time                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                     Sequence Number                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Observation ID                           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                      Figure 5: IPFIX Message Header\n   The length of the IPFIX\
    \ Message Header is 16 octets, and every IPFIX\n   Message has to be started with\
    \ it.  The TinyIPFIX Message Header\n   needs to be smaller due to the packet\
    \ size constraints discussed in\n   Section 3.3.  The TinyIPFIX Header consists\
    \ of a fixed part of three\n   octets as shown in Figure 6, followed by a variable\
    \ part as shown in\n   Figures 7 to 10.\n      0                   1         \
    \          2                   3\n      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     |E|E| SetID |        Length     | Sequence      | Ext. Sequence |\n    \
    \ |1|2|Lookup |                   | Number        |  Number       |\n     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \     | Ext. SetID    |\n     +-+-+-+-+-+-+-+-+\n             Figure 6: Format\
    \ of the TinyIPFIX Message Header\n                    including Fixed and Optional\
    \ Parts\n   The fixed part has a length of 3 octets and consists of the \"E1\"\
    \n   field (1 bit), the \"E2\" field (1 bit), the \"SetID Lookup\" field (4\n\
    \   bits), the \"Length\" field (10 bits), and the \"Sequence Number\" field\n\
    \   (8 bits).  The variable part has a variable length defined by the\n   \"E1\"\
    \ and \"E2\" fields in the fixed header.  The four variants are\n   illustrated\
    \ in Figure 7 to Figure 10 below.\n     0                   1                \
    \   2\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |0|0| SetID |        Length     | Sequence      |\n    | | |Lookup |    \
    \               | Number        |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Figure 7: TinyIPFIX Message Header Format if E1 = E2 = 0\n     0      \
    \             1                   2                   3\n     0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |1|0| SetID |        Length     | Sequence      | Ext. SetID    |\n    |\
    \ | |Lookup |                   | Number        |               |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Figure 8: TinyIPFIX Message Header Format if E1 = 1 and E2 = 0\n     0\
    \                   1                   2                   3\n     0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |E|E| SetID |        Length     | Sequence      | Ext. Sequenz  |\n    |1|2|Lookup\
    \ |                   | Number        |  Number       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      Figure 9: TinyIPFIX Message Header Format if E1 = 0 and E2 = 1\n     0\
    \                   1                   2                   3\n     0 1 2 3 4\
    \ 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |1|1| SetID |        Length     | Sequence      | Ext. Sequenz  |\n    |\
    \ | |Lookup |                   | Number        |  Number       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    | Ext. SetID    |\n    +-+-+-+-+-+-+-+-+\n      Figure 10: TinyIPFIX Message\
    \ Header Format if E1 = E2 = 1\n   The fixed header fields are defined as follows\
    \ [Kothmayr10]\n   [Schmitt2014]:\n   E1 and E2\n      The bits marked \"E1\"\
    \ and \"E2\" control the presence of the field\n      \"Ext.  SetID\" and the\
    \ presence of the field \"Ext.  Sequence\n      Number\", respectively.\n    \
    \  In case E1 = E2 = 0, the TinyIPFIX Message Header has the format\n      shown\
    \ in Figure 7.  The fields Extended Sequence Number and\n      Extended SetID\
    \ MUST NOT be present.\n      When E1 = 1, the extended SetID field MUST be present.\
    \  Custom\n      SetIDs can be specified in the extended SetID field, setting\
    \ all\n      SetID Lookup bits to 1 (cf.  Figure 8.)  When evaluated, the value\n\
    \      specified in the extended SetID field is shifted left by 8 bits to\n  \
    \    prevent collisions with the reserved SetIDs 0-255.  To reference\n      these,\
    \ shifting can be disabled by setting all SetID lookup bits\n      to 1.\n   \
    \   Depending on the application, sampling rates might be larger than\n      in\
    \ typical constrained networks (e.g., Wireless Sensor Networks\n      (WSNs),\
    \ Cyber-Physical-Systems (CPS)); thus, they may have a large\n      quantity of\
    \ records per packet.  In order to make TinyIPFIX\n      applicable for those\
    \ cases, E2 = 1 is set (cf.  Figure 9).  This\n      means the Extended Sequence\
    \ Number field MUST be present, offering\n      8-bit more sequence numbers as\
    \ usual.  Depending on the\n      constrained network settings, the combination\
    \ E1 = E2 = 1 is also\n      possible, resulting in the maximum TinyIPFIX Message\
    \ header shown\n      in Figure 10 where the Extended Sequence Number field and\
    \ Extended\n      SetID field MUST both be present.\n   SetID Lookup\n      This\
    \ field acts as a lookup field for the SetIDs and provides\n      shortcuts to\
    \ often used SetIDs.  Four values are defined:\n      Value = 0; Look up extended\
    \ SetID field, Shifting enabled.\n      Value = 1; SetID = 2 and message contains\
    \ a Template definition.\n      Value = 2; SetID = 256 and message contains Data\
    \ Record for\n      Template 256.  This places special importance on a single\
    \ template\n      ID, but, since most sensor nodes only define a single template\n\
    \      directly after booting and continue to stream data with this\n      template\
    \ ID during the whole session lifetime, this shorthand is\n      useful for this\
    \ case.\n      Value = 3-14; SetIDs are reserved for future extensions.\n    \
    \  Value = 15; look up extended SetID field, shifting enabled.\n   Length\n  \
    \    The length field has a fixed length of 10 bits.\n   Sequence Number\n   \
    \   Due to the low sampling rate in typical WSNs, the \"Sequence\n      Number\"\
    \ field is only one byte long.  However, some applications\n      may have a large\
    \ quantity of records per packet.  In this case,\n      the sequence field can\
    \ be extended to 16 bit by setting the E2-bit\n      to 1.\n   Since TinyIPFIX\
    \ packets are always transported via a network\n   protocol, which specifies the\
    \ source of the packet, the \"Observation\n   Domain\" can be equated with the\
    \ source of a TinyIPFIX packet.\n   Therefore, this IPFIX field has been removed\
    \ from the TinyIPFIX\n   Header.  Should an application require explicit Observation\
    \ Domain\n   information, each Data Record in the TinyIPFIX data message may\n\
    \   contain an Observation Domain ID Information Element; see Section 3.1\n  \
    \ of [RFC7011].  The version field has been removed since the SetID\n   lookup\
    \ field provides room for future extensions.  The specification\n   of a 32-bit\
    \ timestamp in seconds would require the time\n   synchronization across a wireless-sensor\
    \ network and produces too\n   much overhead.  Thus, the \"Export Time\" field\
    \ has been removed.  If\n   applications should require a concrete observation\
    \ time (e.g.,\n   timestamp), it is RECOMMENDED to include it as a separate Information\n\
    \   Element in the TinyIPFIX Records.\n"
- title: 6.2.  TinyIPFIX Set
  contents:
  - "6.2.  TinyIPFIX Set\n   A TinyIPFIX Set is a set of TinyIPFIX Template or TinyIPFIX\
    \ Data\n   Records.  Depending on the TinyIPFIX Record type, the TinyIPFIX Set\n\
    \   can be either a TinyIPFIX Template Set or a TinyIPFIX Data Set. Every\n  \
    \ TinyIPFIX Set starts with a TinyIPFIX Set Header and is followed by\n   one\
    \ or more TinyIPFIX Records.\n   The IPFIX Set Header consists of a 2-octet \"\
    Set ID\" field and a\n   2-octet \"Length\" field.  These two fields are compressed\
    \ to 1 octet\n   each for the TinyIPFIX Set Header.  The format of the TinyIPFIX\
    \ Set\n   Header is shown in Figure 11.\n    0                   1\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |  Tiny\
    \ Set ID  |    Length     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    Figure\
    \ 11: TinyIPFIX Set Header\n   The two fields are defined as follows:\n   TinyIPFIX\
    \ Set ID\n      The \"Tiny Set ID\" identifies the type of data that is transported\n\
    \      in the TinyIPFIX Set. A TinyIPFIX Template Set is identified by\n     \
    \ TinyIPFIX Set ID 2.  This corresponds to the Template Set IDs that\n      are\
    \ used by IPFIX [RFC7011].  TinyIPFIX Set ID number 3 MUST NOT\n      be used,\
    \ as Options Templates are not supported; a TinyIPFIX\n      Collector MUST ignore\
    \ and SHOULD log any Set with Set ID 3.  All\n      values from 4 to 127 are reserved\
    \ for future use.  Values above\n      127 are used for TinyIPFIX Data Sets.\n\
    \   Length\n      The \"Length\" Field contains the total length of the TinyIPFIX\
    \ Set,\n      including the TinyIPFIX Set Header.\n"
- title: 6.3.  TinyIPFIX Template Record Format
  contents:
  - "6.3.  TinyIPFIX Template Record Format\n   The format of the TinyIPFIX Template\
    \ Records is shown in Figure 12.\n   The TinyIPFIX Template Record starts with\
    \ a TinyIPFIX Template Record\n   Header and this is followed by one or more Field\
    \ Specifiers.  The\n   Field Specifier format is defined as in Section 6.4 and\
    \ is identical\n   to the Field Specifier definition in [RFC7011].\n         \
    \  +--------------------------------------------------+\n           | TinyIPFIX\
    \ Template Record Header                 |\n           +--------------------------------------------------+\n\
    \           | Field Specifier                                  |\n           +--------------------------------------------------+\n\
    \           | Field Specifier                                  |\n           +--------------------------------------------------+\n\
    \           ...\n           +--------------------------------------------------+\n\
    \           | Field Specifier                                  |\n           +--------------------------------------------------+\n\
    \                   Figure 12: TinyIPFIX Template Format\n   The format of the\
    \ TinyIPFIX Template Record Header is shown in\n   Figure 13.\n    0         \
    \          1\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   | Template ID |  Field Count  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Figure\
    \ 13: TinyIPFIX Template Record Header\n   TinyIPFIX Template ID\n      Each TinyIPFIX\
    \ Template Record must have a unique TinyIPFIX\n      Template ID (Comp.  Temp\
    \ ID) between 128 and 255.  The TinyIPFIX\n      Template ID must be unique for\
    \ the given TinyIPFIX Transport\n      Session.\n   Field Count\n      The number\
    \ of fields placed in the TinyIPFIX Template Record.\n"
- title: 6.4.  Field Specifier Format
  contents:
  - "6.4.  Field Specifier Format\n   The type and length of the transmitted data\
    \ is encoded in Field\n   Specifiers within TinyIPFIX Template Records.  The Field\
    \ Specifier is\n   shown in Figure 14 and is identical with the Field Specifier\
    \ that was\n   defined for IPFIX [RFC7011].\n    0                   1       \
    \            2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8\
    \ 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |E|  Information Element ident. |        Field Length           |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |                      Enterprise Number                        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                 Figure 14: TinyIPFIX Data Field Specifier\n   Where:\n   E\n\
    \      Enterprise bit.  This is the first bit of the Field Specifier.  If\n  \
    \    this bit is zero, the Information Element Identifier identifies an\n    \
    \  IETF-specified Information Element, and the four-octet Enterprise\n      Number\
    \ field MUST NOT be present.  If this bit is one, the\n      Information Element\
    \ Identifier identifies an enterprise-specific\n      Information Element, and\
    \ the Enterprise Number field MUST be\n      present.\n   Information Element\
    \ Identifier\n      A numeric value that represents the type of Information Element.\n\
    \   Field Length\n      The length of the corresponding encoded Information Element,\
    \ in\n      octets.  Refer to [RFC7012].  The value 65535 is illegal in\n    \
    \  TinyIPFIX, as variable-length Information Elements are not\n      supported.\n\
    \   Enterprise Number\n      IANA Private Enterprise Number of the authority defining\
    \ the\n      Information Element identifier in this Template Record.\n   Vendors\
    \ can easily define their own data model by registering a\n   Enterprise ID with\
    \ IANA.  Using their own Enterprise ID, they can use\n   any ID in the way they\
    \ want them to use.\n"
- title: 6.5.  TinyIPFIX Data Record Format
  contents:
  - "6.5.  TinyIPFIX Data Record Format\n   The Data Records are sent in TinyIPFIX\
    \ Data Sets.  The format of the\n   Data Records is shown in Figure 15 and matches\
    \ the Data Record format\n   from IPFIX.\n   +--------------------------------------------------+\n\
    \   | Field Value                                      |\n   +--------------------------------------------------+\n\
    \   | Field Value                                      |\n   +--------------------------------------------------+\n\
    \   ...\n   +--------------------------------------------------+\n   | Field Value\
    \                                      |\n   +--------------------------------------------------+\n\
    \               Figure 15: Data Record Format\n"
- title: 7.  TinyIPFIX Mediation
  contents:
  - "7.  TinyIPFIX Mediation\n   There are two types of TinyIPFIX Intermediate Processes.\
    \  The first\n   one can occur on the transition between a constrained network\
    \ (e.g.,\n   6LoWPAN) and the unconstrained network.  This mediation changes the\n\
    \   network and transport protocol from 6LoWPAN preferring UDP to\n   IP/(SCTP|TCP|UDP)\
    \ and is shown in Figure 16.\n                   +-----------------------+\n \
    \                  |    TinyIPFIX Device   |\n                   | [Exporting\
    \ Process]   |\n                   +-----------------------+\n               \
    \                      |\n                           TinyIPFIX |\n           \
    \        over 6LoWPAN/UDP  |\n                                     v\n       \
    \           +-------------------------+\n                  |   TinyIPFIX mediator\
    \    |\n                  |   [Collecting Process]  |\n                  |   [Exporting\
    \ Process]   |\n                  +-------------------------+\n              \
    \                       |\n                  TinyIPFIX          |\n          \
    \        IP/(UDP/SCTP|TCP)  |\n                                     v\n      \
    \            +--------------------------+\n                  |      Collector\
    \           |\n                  | [Collecting Process(es)] |\n              \
    \    +--------------------------+\n          Figure 16: Translation from TinyIPFIX\
    \ over 6LoWPAN/UDP\n                    to TinyIPFIX over IP/(SCTP|TCP|UDP)\n\
    \   The mediator removes the TinyIPFIX Messages from the 6LoWPAN/UDP\n   packets\
    \ and wraps them into the new network and transport protocols.\n   Templates MUST\
    \ be managed the same way as in the constrained\n   environment after the translation\
    \ to IP/(SCTP|UDP|TCP) (see\n   Section 8).\n   The second type of mediation transforms\
    \ TinyIPFIX into IPFIX.  This\n   process MUST be combined with the transport\
    \ protocol mediation as\n   shown in Figure 17.\n                        +-----------------------+\n\
    \                        |    TinyIPFIX Device   |\n                        |\
    \ [Exporting Process]   |\n                        +-----------------------+\n\
    \                                          |\n                               \
    \ TinyIPFIX |\n                                          |\n                 \
    \                         v\n                        +-------------------------+\n\
    \                        |   TinyIPFIX mediator    |\n                       \
    \ |   [Collecting Process]  |\n                        |   [Exporting Process]\
    \   |\n                        +-------------------------+\n                 \
    \                         |\n                              IPFIX       |\n   \
    \                     IP/(UDP/SCTP|TCP) |\n                                  \
    \        v\n                        +--------------------------+\n           \
    \             |      Collector           |\n                        | [Collecting\
    \ Process(es)] |\n                        +--------------------------+\n     \
    \        Figure 17: Transformation from TinyIPFIX to IPFIX\n   This mediation\
    \ can also be performed by an IPFIX Collector before\n   parsing the IPFIX message\
    \ as shown in Figure 18.  There is no need\n   for a parser from TinyIPFIX to\
    \ IPFIX if such a mediation process can\n   be employed in front of an existing\
    \ IPFIX collector.\n   +------------------------+                  +----------------------+\n\
    \   |     TinyIPFIX Device   |    TinyIPFIX     |     IPFIX Mediator   |\n   |\
    \ [Exporting Processes]  |----------------->| [Collecting Process] |\n   +------------------------+\
    \                  |  [Exporting Process] |\n                                \
    \               |         |            |\n                                   \
    \            |         |IPFIX       |\n                                      \
    \         |         |            |\n                                         \
    \      |         v            |\n                                            \
    \   |   Collector          |\n                                               |\
    \ [Collecting Process] |\n                                               +----------------------+\n\
    \             Figure 18: Transformation from TinyIPFIX to IPFIX\n   The TinyIPFIX\
    \ Mediation Process has to translate the TinyIPFIX\n   Message Header, the TinyIPFIX\
    \ Set Headers, and the TinyIPFIX Template\n   Record Header into their counterparts\
    \ in IPFIX.  Afterwards, the new\n   IPFIX Message Length needs to be calculated\
    \ and inserted into the\n   IPFIX Message header.\n"
- title: 7.1.  Expanding the Message Header
  contents:
  - "7.1.  Expanding the Message Header\n   The fields of the IPFIX Message Header\
    \ that are shown in Figure 5 can\n   be determined from a TinyIPFIX Message Header\
    \ as follows:\n   Version\n      This is always 0x000a.\n   Length\n      The\
    \ IPFIX Message Length can only be calculated after the complete\n      TinyIPFIX\
    \ Message has been translated.  The new length can be\n      calculated by adding\
    \ the length of the IPFIX Message Header, which\n      is 16 octets, and the length\
    \ of all Sets that are contained in the\n      IPFIX Message.\n   Export Time\n\
    \      The \"Export Time\" MUST be generated by the Mediator, and contains\n \
    \     the time in seconds since 00:00 UTC Jan 1, 1970, at which the\n      IPFIX\
    \ Message leaves the Mediator.\n   Sequence Number\n      If the TinyIPFIX Sequence\
    \ Number has a length of 4 octets, the\n      original value MUST be used for\
    \ the IPFIX Message.  If the\n      TinyIPFIX Sequence Number has a size of one\
    \ or two octets, the\n      TinyIPFIX Mediator MUST expand the TinyIPFIX Sequence\
    \ Number into\n      a four octet field.  If the TinyIPFIX Sequence Number was\
    \ omitted,\n      the Mediator needs to calculate the Sequence Number as per\n\
    \      [RFC7011].\n   Observation Domain ID\n      Since the Observation Domain\
    \ ID is used to scope templates in\n      IPFIX, it MUST be set to a unique value\
    \ per TinyIPFIX Exporting\n      Process, using either a mapping algorithmically\
    \ determined by the\n      Intermediate Process or directly configured by an administrator.\n"
- title: 7.2.  Translating the Set Headers
  contents:
  - "7.2.  Translating the Set Headers\n   Both fields in the TinyIPFIX Set Header\
    \ have a size of 1 octet and\n   need to be expanded:\n   Set ID\n      The field\
    \ needs to be expanded from 1 octet to 2 octets.  If the\n      Set ID is below\
    \ 128, no recalculation needs to be performed.  This\n      is because all IDs\
    \ below 128 are reserved for special messages and\n      match the IDs used in\
    \ IPFIX.  The TinyIPFIX Set IDs starting with\n      128 identify TinyIPFIX Data\
    \ Sets.  Therefore, every TinyIPFIX Set\n      ID above number 127 needs to be\
    \ incremented by number 128 because\n      IPFIX Data Set IDs are numbered above\
    \ 255.\n   Set Length\n      The field needs to be expanded from one octet to\
    \ two octets.  It\n      needs to be recalculated by adding a value of 2 octets\
    \ to match\n      the additional size of the Set Header.  For each TinyIPFIX\n\
    \      Template Record that is contained in the TinyIPFIX Set, 2 more\n      octets\
    \ need to be added to the length.\n"
- title: 7.3.  Expanding the Template Record Header
  contents:
  - "7.3.  Expanding the Template Record Header\n   Both fields in the TinyIPFIX Template\
    \ Record Header have a length of\n   one octet and therefore need translation:\n\
    \   Template ID\n      The field needs to be expanded from one octet to two octets.\
    \  The\n      Template ID needs to be increased by a value of 128.\n   Field Count\n\
    \      The field needs to be expanded from one octet to 2 octets.\n"
- title: 8.  Template Management
  contents:
  - "8.  Template Management\n   As with IPFIX, TinyIPFIX Template Management depends\
    \ on the transport\n   protocol used.  If TCP or SCTP is used, it can be ensured\
    \ that\n   TinyIPFIX Templates are delivered reliably.  If UDP is used,\n   reliability\
    \ cannot be guaranteed: template loss can occur.  If a\n   Template is lost on\
    \ its way to the Collector, any following TinyIPFIX\n   Data Records that refer\
    \ to this TinyIPFIX Template cannot be decoded.\n   Template Withdrawals are not\
    \ supported in TinyIPFIX.  This is\n   generally not a problem, because most sensor\
    \ nodes only define a\n   single static template directly after booting.\n"
- title: 8.1.  TCP/SCTP
  contents:
  - "8.1.  TCP/SCTP\n   If TCP or SCTP is used for the transmission of TinyIPFIX,\
    \ Template\n   Management MUST be performed as defined in [RFC7011] for IPFIX,\
    \ with\n   the exception of Template Withdrawals, which are not supported in\n\
    \   TinyIPFIX.  Template Withdrawals MUST NOT be sent by TinyIPFIX\n   Exporters.\n"
- title: 8.2.  UDP
  contents:
  - "8.2.  UDP\n   All specifications for Template Management from [RFC7011] apply\n\
    \   unless specified otherwise in this document.\n   TinyIPFIX Templates MUST\
    \ be sent by a TinyIPFIX Exporter before any\n   TinyIPFIX Data Set that refers\
    \ to the TinyIPFIX Template is\n   transmitted.  TinyIPFIX Templates are not expected\
    \ to change over\n   time in TinyIPFIX and, thus, they should be pre-shared. \
    \ TinyIPFIX\n   Devices have a default setup when deployed; after booting, they\n\
    \   announce their TinyIPFIX Template directly to the network and MAY\n   repeat\
    \ it if UDP is used.  Hence, a TinyIPFIX Template that has been\n   sent once\
    \ MAY NOT be withdrawn and MUST NOT expire.  If a TinyIPFIX\n   Smart Meter wants\
    \ to use another TinyIPFIX Template, it MUST use a\n   new TinyIPFIX Template\
    \ ID for the TinyIPFIX Template.\n   While UDP is used, reliable transport of\
    \ TinyIPFIX Templates cannot\n   be, guaranteed and TinyIPFIX Templates can be\
    \ lost.  A TinyIPFIX\n   Exporter MUST expect TinyIPFIX Template loss.  Therefore,\
    \ it MUST\n   re-send its TinyIPFIX Templates periodically.  A TinyIPFIX Template\n\
    \   MUST be re-sent after a fixed number N of TinyIPFIX Messages that\n   contain\
    \ TinyIPFIX Data Sets referring to the TinyIPFIX Template.  The\n   number N MUST\
    \ be configured by the application developer.\n   Retransmission and the specification\
    \ of N can be avoided if TinyIPFIX\n   Exporter and TinyIPFIX Collector use pre-shared\
    \ templates.\n"
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   The same security considerations as for the IPFIX\
    \ Protocol [RFC7011]\n   apply.\n"
- title: 10.  IANA Considerations
  contents:
  - "10.  IANA Considerations\n   This document does not require any IANA actions.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n  \
    \            DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC4944]  Montenegro, G., Kushalnagar, N., Hui, J., and D. Culler,\n    \
    \          \"Transmission of IPv6 Packets over IEEE 802.15.4\n              Networks\"\
    , RFC 4944, DOI 10.17487/RFC4944, September 2007,\n              <https://www.rfc-editor.org/info/rfc4944>.\n\
    \   [RFC5153]  Boschi, E., Mark, L., Quittek, J., Stiemerling, M., and P.\n  \
    \            Aitken, \"IP Flow Information Export (IPFIX) Implementation\n   \
    \           Guidelines\", RFC 5153, DOI 10.17487/RFC5153, April 2008,\n      \
    \        <https://www.rfc-editor.org/info/rfc5153>.\n   [RFC5470]  Sadasivan,\
    \ G., Brownlee, N., Claise, B., and J. Quittek,\n              \"Architecture\
    \ for IP Flow Information Export\", RFC 5470,\n              DOI 10.17487/RFC5470,\
    \ March 2009,\n              <https://www.rfc-editor.org/info/rfc5470>.\n   [RFC5982]\
    \  Kobayashi, A., Ed. and B. Claise, Ed., \"IP Flow\n              Information\
    \ Export (IPFIX) Mediation: Problem Statement\",\n              RFC 5982, DOI\
    \ 10.17487/RFC5982, August 2010,\n              <https://www.rfc-editor.org/info/rfc5982>.\n\
    \   [RFC6183]  Kobayashi, A., Claise, B., Muenz, G., and K. Ishibashi,\n     \
    \         \"IP Flow Information Export (IPFIX) Mediation: Framework\",\n     \
    \         RFC 6183, DOI 10.17487/RFC6183, April 2011,\n              <https://www.rfc-editor.org/info/rfc6183>.\n\
    \   [RFC7011]  Claise, B., Ed., Trammell, B., Ed., and P. Aitken,\n          \
    \    \"Specification of the IP Flow Information Export (IPFIX)\n             \
    \ Protocol for the Exchange of Flow Information\", STD 77,\n              RFC\
    \ 7011, DOI 10.17487/RFC7011, September 2013,\n              <https://www.rfc-editor.org/info/rfc7011>.\n\
    \   [RFC7012]  Claise, B., Ed. and B. Trammell, Ed., \"Information Model\n   \
    \           for IP Flow Information Export (IPFIX)\", RFC 7012,\n            \
    \  DOI 10.17487/RFC7012, September 2013,\n              <https://www.rfc-editor.org/info/rfc7012>.\n\
    \   [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n     \
    \         2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n        \
    \      May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [Advantic] ADVANTIC SISTEMAS Y SERVICIOS S.L.,\n\
    \              <https://www.advanticsys.com/>, 2017.\n   [GreatDuck]\n       \
    \       Mainwaring, A., Polastre, J., Szewczyk, R., Culler, D.,\n            \
    \  and J. Anderson, \"Wireless Sensor Networks for Habitat\n              Monitoring\"\
    , In Proceedings of the 1st ACM international\n              workshop on Wireless\
    \ sensor networks and applications ACM,\n              pp. 88-97, DOI 10.1145/570738.570751,\
    \ 2002.\n   [Harvan08] Harvan, M. and J. Schoenwaelder, \"TinyOS Motes on the\n\
    \              Internet: IPv6 over 802.15.4 (6LoWPAN)\",\n              DOI 10.1515/piko.2008.0042,\
    \ December 2008.\n   [IRIS]     Memsic, \"Data Sheet IRIS\", 2017,\n         \
    \     <http://www.memsic.com/userfiles/files/Datasheets/WSN/\n              IRIS_Datasheet.pdf>.\n\
    \   [Kim07]    Kim, S., Pakzad, S., Culler, D., Demmel, J., Fenves, G.,\n    \
    \          Glaser, S., and M. Turon, \"Health monitoring of civil\n          \
    \    infrastructures using wireless sensor networks\",\n              Proceedings\
    \ of the 6th international conference on\n              Information processing\
    \ in sensor networks (IPSN\n              2007), Cambridge, MA, ACM Press, pp.\
    \ 254-263,\n              DOI 10.1145/1236360.1236395, April 2007.\n   [Kothmayr10]\n\
    \              Kothmayr, T., \"Data Collection in Wireless Sensor Networks\n \
    \             for Autonomic Home Networking\", Bachelor Thesis, Technical\n  \
    \            University of Munich, Munich, Germany, January 2010.\n   [openMote]\
    \ openMote Technologies S.L., 2017, <http://openmote.com>.\n   [Schmitt09]\n \
    \             Schmitt, C. and G. Carle, \"Applications for Wireless\n        \
    \      Sensor Networks\", Handbook of Research on P2P and Grid\n             \
    \ Systems for Service-Oriented Computing: Models,\n              Methodologies\
    \ and Applications, Edited by Antonopoulos N.,\n              Exarchakos G., Li\
    \ M., and A. Liotta, Information Science\n              Publishing, Chapter 46,\
    \ pp. 1076-1091,\n              ISBN: 978-1615206865, 2010.\n   [Schmitt2014]\n\
    \              Schmitt, C., Kothmayr, T., Ertl, B., Hu, W., Braun, L.,\n     \
    \         and G. Carle, \"TinyIPFIX: An efficient application\n              protocol\
    \ for data exchange in cyber physical systems\",\n              Computer Communications,\
    \ ELSEVIER, Vol. 74, pp. 63-76,\n              DOI 10.1016/j.comcom.2014.05.012,\
    \ 2016.\n   [Schmitt2017]\n              Schmitt, C., Anliker, C., and B. Stiller,\
    \ \"Efficient and\n              Secure Pull Requests for Emergency Cases Using\
    \ a Mobile\n              Access Framework\", Managing the Web of Things: Linking\
    \ the\n              Real World to the Web, Edited by Sheng, M., Qin, Y., Yao,\n\
    \              L., and B. Benatallah, Morgen Kaufmann (imprint of\n          \
    \    Elsevier), Chapter 8, pp. 229-247,\n              ISBN: 978-0-12-809764-9,\
    \ 2017.\n   [SMPC04]   Szewczyk, R., Mainwaring, A., Polastre, J., and D. Culler,\n\
    \              \"An analysis of a large scale habitat monitoring\n           \
    \   application\", Proceedings of the 2nd international\n              conference\
    \ on Embedded networked sensor systems (SenSys\n              04), DOI 10.1145/1031495.1031521,\
    \ November 2004.\n   [TelosB]   Memsic, \"Data Sheet TelosB\", 2017,\n       \
    \       <http://www.memsic.com/userfiles/files/DataSheets/WSN/\n             \
    \ telosb_datasheet.pdf>.\n   [Tolle05]  Tolle, G., Polastre, J., Szewczyk, R.,\
    \ Culler, D., Turner,\n              N., Tu, K., Burgess, S., Dawnson, T., Buonadonna,\
    \ P., Gay,\n              D., and W. Hong, \"A macroscope in the redwoods\",\n\
    \              Proceedings of the 3rd international conference on\n          \
    \    Embedded networked sensor systems (SenSys 05),\n              DOI 10.1145/1098918.1098925,\
    \ November 2005.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   Many thanks to Lothar Braun, Georg Carle, and Benoit Claise,\
    \ who\n   contributed significant work to earlier draft versions of this work,\n\
    \   especially to the document titled \"Compressed IPFIX for Smart Meters\n  \
    \ in Constrained Networks\".\n   Many thanks to Thomas Kothmayr, Michael Meister,\
    \ and Livio Sgier, who\n   implemented TinyIPFIX (except the mediator) for TinyOS\
    \ 2.x and\n   Contiki 2.7/3.0 for 3 different sensor platforms (IRIS, TelosB,\
    \ and\n   OpenMote).\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Corinna Schmitt\n   University of Zurich\n   Department\
    \ of Informatics\n   Communication Systems Group\n   Binzmuehlestrasse 14\n  \
    \ Zurich  8050\n   Switzerland\n   Email: schmitt@ifi.uzh.ch\n   Burkhard Stiller\n\
    \   University of Zurich\n   Department of Informatics\n   Communication Systems\
    \ Group\n   Binzmuehlestrasse 14\n   Zurich  8050\n   Switzerland\n   Email: stiller@ifi.uzh.ch\n\
    \   Brian Trammell\n   Swiss Federal Institute of Technology\n   Gloriastrasse\
    \ 35\n   Zurich  8092\n   Switzerland\n   Email: ietf@trammell.ch\n"
