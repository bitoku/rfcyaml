- title: __initial_text__
  contents:
  - '                      Routing Information Protocol

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This RFC describes an existing protocol for exchanging\
    \ routing\n   information among gateways and other hosts.  It is intended to be\n\
    \   used as a basis for developing gateway software for use in the\n   Internet\
    \ community.  Distribution of this memo is unlimited.\n                      \
    \       Table of Contents\n   1. Introduction                                \
    \                     2\n        1.1. Limitations of the protocol            \
    \                   4\n        1.2. Organization of this document            \
    \                 4\n   2. Distance Vector Algorithms                        \
    \               5\n        2.1. Dealing with changes in topology             \
    \            11\n        2.2. Preventing instability                         \
    \          12\n             2.2.1. Split horizon                             \
    \        14\n             2.2.2. Triggered updates                           \
    \      15\n   3. Specifications for the protocol                             \
    \    16\n        3.1. Message formats                                        \
    \  18\n        3.2. Addressing considerations                                20\n\
    \        3.3. Timers                                                   23\n  \
    \      3.4. Input processing                                         24\n    \
    \         3.4.1. Request                                           25\n      \
    \       3.4.2. Response                                          26\n        3.5.\
    \ Output Processing                                        28\n        3.6. Compatibility\
    \                                            31\n   4. Control functions     \
    \                                          31\n"
- title: Overview
  contents:
  - "Overview\n   This memo is intended to do the following things:\n      - Document\
    \ a protocol and algorithms that are currently in\n        wide use for routing,\
    \ but which have never been formally\n        documented.\n      - Specify some\
    \ improvements in the algorithms which will\n        improve stability of the\
    \ routes in large networks.  These\n        improvements do not introduce any\
    \ incompatibility with\n        existing implementations.  They are to be incorporated\
    \ into\n        all implementations of this protocol.\n      - Suggest some optional\
    \ features to allow greater\n        configurability and control.  These features\
    \ were developed\n        specifically to solve problems that have shown up in\
    \ actual\n        use by the NSFnet community.  However, they should have more\n\
    \        general utility.\n   The Routing Information Protocol (RIP) described\
    \ here is loosely\n   based on the program \"routed\", distributed with the 4.3\
    \ Berkeley\n   Software Distribution.  However, there are several other\n   implementations\
    \ of what is supposed to be the same protocol.\n   Unfortunately, these various\
    \ implementations disagree in various\n   details.  The specifications here represent\
    \ a combination of features\n   taken from various implementations.  We believe\
    \ that a program\n   designed according to this document will interoperate with\
    \ routed,\n   and with all other implementations of RIP of which we are aware.\n\
    \   Note that this description adopts a different view than most existing\n  \
    \ implementations about when metrics should be incremented.  By making\n   a corresponding\
    \ change in the metric used for a local network, we\n   have retained compatibility\
    \ with other existing implementations.  See\n   section 3.6 for details on this\
    \ issue.\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   This memo describes one protocol in a series of routing protocols\n\
    \   based on the Bellman-Ford (or distance vector) algorithm.  This\n   algorithm\
    \ has been used for routing computations in computer networks\n   since the early\
    \ days of the ARPANET.  The particular packet formats\n   and protocol described\
    \ here are based on the program \"routed\", which\n   is included with the Berkeley\
    \ distribution of Unix.  It has become a\n   de facto standard for exchange of\
    \ routing information among gateways\n   and hosts.  It is implemented for this\
    \ purpose by most commercial\n   vendors of IP gateways.  Note, however, that\
    \ many of these vendors\n   have their own protocols which are used among their\
    \ own gateways.\n   This protocol is most useful as an \"interior gateway protocol\"\
    .  In a\n   nationwide network such as the current Internet, it is very unlikely\n\
    \   that a single routing protocol will used for the whole network.\n   Rather,\
    \ the network will be organized as a collection of \"autonomous\n   systems\"\
    .  An autonomous system will in general be administered by a\n   single entity,\
    \ or at least will have some reasonable degree of\n   technical and administrative\
    \ control.  Each autonomous system will\n   have its own routing technology. \
    \ This may well be different for\n   different autonomous systems.  The routing\
    \ protocol used within an\n   autonomous system is referred to as an interior\
    \ gateway protocol, or\n   \"IGP\".  A separate protocol is used to interface\
    \ among the autonomous\n   systems.  The earliest such protocol, still used in\
    \ the Internet, is\n   \"EGP\" (exterior gateway protocol).  Such protocols are\
    \ now usually\n   referred to as inter-AS routing protocols.  RIP was designed\
    \ to work\n   with moderate-size networks using reasonably homogeneous technology.\n\
    \   Thus it is suitable as an IGP for many campuses and for regional\n   networks\
    \ using serial lines whose speeds do not vary widely.  It is\n   not intended\
    \ for use in more complex environments.  For more\n   information on the context\
    \ into which RIP is expected to fit, see\n   Braden and Postel [3].\n   RIP is\
    \ one of a class of algorithms known as \"distance vector\n   algorithms\".  The\
    \ earliest description of this class of algorithms\n   known to the author is\
    \ in Ford and Fulkerson [6].  Because of this,\n   they are sometimes known as\
    \ Ford-Fulkerson algorithms.  The term\n   Bellman-Ford is also used.  It comes\
    \ from the fact that the\n   formulation is based on Bellman's equation, the basis\
    \ of \"dynamic\n   programming\".  (For a standard introduction to this area,\
    \ see [1].)\n   The presentation in this document is closely based on [2].  This\
    \ text\n   contains an introduction to the mathematics of routing algorithms.\n\
    \   It describes and justifies several variants of the algorithm\n   presented\
    \ here, as well as a number of other related algorithms.  The\n   basic algorithms\
    \ described in this protocol were used in computer\n   routing as early as 1969\
    \ in the ARPANET.  However, the specific\n   ancestry of this protocol is within\
    \ the Xerox network protocols.  The\n   PUP protocols (see [4]) used the Gateway\
    \ Information Protocol to\n   exchange routing information.  A somewhat updated\
    \ version of this\n   protocol was adopted for the Xerox Network Systems (XNS)\n\
    \   architecture, with the name Routing Information Protocol.  (See [7].)\n  \
    \ Berkeley's routed is largely the same as the Routing Information\n   Protocol,\
    \ with XNS addresses replaced by a more general address\n   format capable of\
    \ handling IP and other types of address, and with\n   routing updates limited\
    \ to one every 30 seconds.  Because of this\n   similarity, the term Routing Information\
    \ Protocol (or just RIP) is\n   used to refer to both the XNS protocol and the\
    \ protocol used by\n   routed.\n   RIP is intended for use within the IP-based\
    \ Internet.  The Internet\n   is organized into a number of networks connected\
    \ by gateways.  The\n   networks may be either point-to-point links or more complex\
    \ networks\n   such as Ethernet or the ARPANET.  Hosts and gateways are presented\n\
    \   with IP datagrams addressed to some host.  Routing is the method by\n   which\
    \ the host or gateway decides where to send the datagram.  It may\n   be able\
    \ to send the datagram directly to the destination, if that\n   destination is\
    \ on one of the networks that are directly connected to\n   the host or gateway.\
    \  However, the interesting case is when the\n   destination is not directly reachable.\
    \  In this case, the host or\n   gateway attempts to send the datagram to a gateway\
    \ that is nearer the\n   destination.  The goal of a routing protocol is very\
    \ simple: It is to\n   supply the information that is needed to do routing.\n"
- title: 1.1. Limitations of the protocol
  contents:
  - "1.1. Limitations of the protocol\n   This protocol does not solve every possible\
    \ routing problem.  As\n   mentioned above, it is primary intended for use as\
    \ an IGP, in\n   reasonably homogeneous networks of moderate size.  In addition,\
    \ the\n   following specific limitations should be mentioned:\n      - The protocol\
    \ is limited to networks whose longest path\n        involves 15 hops.  The designers\
    \ believe that the basic\n        protocol design is inappropriate for larger\
    \ networks.  Note\n        that this statement of the limit assumes that a cost\
    \ of 1\n        is used for each network.  This is the way RIP is normally\n \
    \       configured.  If the system administrator chooses to use\n        larger\
    \ costs, the upper bound of 15 can easily become a\n        problem.\n      -\
    \ The protocol depends upon \"counting to infinity\" to resolve\n        certain\
    \ unusual situations.  (This will be explained in the\n        next section.)\
    \  If the system of networks has several\n        hundred networks, and a routing\
    \ loop was formed involving\n        all of them, the resolution of the loop would\
    \ require\n        either much time (if the frequency of routing updates were\n\
    \        limited) or bandwidth (if updates were sent whenever\n        changes\
    \ were detected).  Such a loop would consume a large\n        amount of network\
    \ bandwidth before the loop was corrected.\n        We believe that in realistic\
    \ cases, this will not be a\n        problem except on slow lines.  Even then,\
    \ the problem will\n        be fairly unusual, since various precautions are taken\
    \ that\n        should prevent these problems in most cases.\n      - This protocol\
    \ uses fixed \"metrics\" to compare alternative\n        routes.  It is not appropriate\
    \ for situations where routes\n        need to be chosen based on real-time parameters\
    \ such a\n        measured delay, reliability, or load.  The obvious\n       \
    \ extensions to allow metrics of this type are likely to\n        introduce instabilities\
    \ of a sort that the protocol is not\n        designed to handle.\n"
- title: 1.2. Organization of this document
  contents:
  - "1.2. Organization of this document\n   The main body of this document is organized\
    \ into two parts, which\n   occupy the next two sections:\n      2   A conceptual\
    \ development and justification of distance vector\n          algorithms in general.\n\
    \      3   The actual protocol description.\n   Each of these two sections can\
    \ largely stand on its own.  Section 2\n   attempts to give an informal presentation\
    \ of the mathematical\n   underpinnings of the algorithm.  Note that the presentation\
    \ follows a\n   \"spiral\" method.  An initial, fairly simple algorithm is described.\n\
    \   Then refinements are added to it in successive sections.  Section 3\n   is\
    \ the actual protocol description.  Except where specific references\n   are made\
    \ to section 2, it should be possible to implement RIP\n   entirely from the specifications\
    \ given in section 3.\n"
- title: 2. Distance Vector Algorithms
  contents:
  - "2. Distance Vector Algorithms\n   Routing is the task of finding a path from\
    \ a sender to a desired\n   destination.  In the IP \"Catenet model\" this reduces\
    \ primarily to a\n   matter of finding gateways between networks.  As long as\
    \ a message\n   remains on a single network or subnet, any routing problems are\n\
    \   solved by technology that is specific to the network.  For example,\n   the\
    \ Ethernet and the ARPANET each define a way in which any sender\n   can talk\
    \ to any specified destination within that one network.  IP\n   routing comes\
    \ in primarily when messages must go from a sender on one\n   such network to\
    \ a destination on a different one.  In that case, the\n   message must pass through\
    \ gateways connecting the networks.  If the\n   networks are not adjacent, the\
    \ message may pass through several\n   intervening networks, and the gateways\
    \ connecting them.  Once the\n   message gets to a gateway that is on the same\
    \ network as the\n   destination, that network's own technology is used to get\
    \ to the\n   destination.\n   Throughout this section, the term \"network\" is\
    \ used generically to\n   cover a single broadcast network (e.g., an Ethernet),\
    \ a point to\n   point line, or the ARPANET.  The critical point is that a network\
    \ is\n   treated as a single entity by IP.  Either no routing is necessary (as\n\
    \   with a point to point line), or that routing is done in a manner that\n  \
    \ is transparent to IP, allowing IP to treat the entire network as a\n   single\
    \ fully-connected system (as with an Ethernet or the ARPANET).\n   Note that the\
    \ term \"network\" is used in a somewhat different way in\n   discussions of IP\
    \ addressing.  A single IP network number may be\n   assigned to a collection\
    \ of networks, with \"subnet\" addressing being\n   used to describe the individual\
    \ networks.  In effect, we are using\n   the term \"network\" here to refer to\
    \ subnets in cases where subnet\n   addressing is in use.\n   A number of different\
    \ approaches for finding routes between networks\n   are possible.  One useful\
    \ way of categorizing these approaches is on\n   the basis of the type of information\
    \ the gateways need to exchange in\n   order to be able to find routes.  Distance\
    \ vector algorithms are\n   based on the exchange of only a small amount of information.\
    \  Each\n   entity (gateway or host) that participates in the routing protocol\
    \ is\n   assumed to keep information about all of the destinations within the\n\
    \   system.  Generally, information about all entities connected to one\n   network\
    \ is summarized by a single entry, which describes the route to\n   all destinations\
    \ on that network.  This summarization is possible\n   because as far as IP is\
    \ concerned, routing within a network is\n   invisible.  Each entry in this routing\
    \ database includes the next\n   gateway to which datagrams destined for the entity\
    \ should be sent.\n   In addition, it includes a \"metric\" measuring the total\
    \ distance to\n   the entity.  Distance is a somewhat generalized concept, which\
    \ may\n   cover the time delay in getting messages to the entity, the dollar\n\
    \   cost of sending messages to it, etc.  Distance vector algorithms get\n   their\
    \ name from the fact that it is possible to compute optimal\n   routes when the\
    \ only information exchanged is the list of these\n   distances.  Furthermore,\
    \ information is only exchanged among entities\n   that are adjacent, that is,\
    \ entities that share a common network.\n   Although routing is most commonly\
    \ based on information about\n   networks, it is sometimes necessary to keep track\
    \ of the routes to\n   individual hosts.  The RIP protocol makes no formal distinction\n\
    \   between networks and hosts.  It simply describes exchange of\n   information\
    \ about destinations, which may be either networks or\n   hosts.  (Note however,\
    \ that it is possible for an implementor to\n   choose not to support host routes.\
    \  See section 3.2.)  In fact, the\n   mathematical developments are most conveniently\
    \ thought of in terms\n   of routes from one host or gateway to another.  When\
    \ discussing the\n   algorithm in abstract terms, it is best to think of a routing\
    \ entry\n   for a network as an abbreviation for routing entries for all of the\n\
    \   entities connected to that network.  This sort of abbreviation makes\n   sense\
    \ only because we think of networks as having no internal\n   structure that is\
    \ visible at the IP level.  Thus, we will generally\n   assign the same distance\
    \ to every entity in a given network.\n   We said above that each entity keeps\
    \ a routing database with one\n   entry for every possible destination in the\
    \ system.  An actual\n   implementation is likely to need to keep the following\
    \ information\n   about each destination:\n      - address: in IP implementations\
    \ of these algorithms, this\n        will be the IP address of the host or network.\n\
    \      - gateway: the first gateway along the route to the\n        destination.\n\
    \      - interface: the physical network which must be used to reach\n       \
    \ the first gateway.\n      - metric: a number, indicating the distance to the\n\
    \        destination.\n      - timer: the amount of time since the entry was last\
    \ updated.\n   In addition, various flags and other internal information will\n\
    \   probably be included.  This database is initialized with a\n   description\
    \ of the entities that are directly connected to the\n   system.  It is updated\
    \ according to information received in messages\n   from neighboring gateways.\n\
    \   The most important information exchanged by the hosts and gateways is\n  \
    \ that carried in update messages.  Each entity that participates in\n   the routing\
    \ scheme sends update messages that describe the routing\n   database as it currently\
    \ exists in that entity.  It is possible to\n   maintain optimal routes for the\
    \ entire system by using only\n   information obtained from neighboring entities.\
    \  The algorithm used\n   for that will be described in the next section.\n  \
    \ As we mentioned above, the purpose of routing is to find a way to get\n   datagrams\
    \ to their ultimate destinations.  Distance vector algorithms\n   are based on\
    \ a table giving the best route to every destination in\n   the system.  Of course,\
    \ in order to define which route is best, we\n   have to have some way of measuring\
    \ goodness.  This is referred to as\n   the \"metric\".\n   In simple networks,\
    \ it is common to use a metric that simply counts\n   how many gateways a message\
    \ must go through.  In more complex\n   networks, a metric is chosen to represent\
    \ the total amount of delay\n   that the message suffers, the cost of sending\
    \ it, or some other\n   quantity which may be minimized.  The main requirement\
    \ is that it\n   must be possible to represent the metric as a sum of \"costs\"\
    \ for\n   individual hops.\n   Formally, if it is possible to get from entity\
    \ i to entity j directly\n   (i.e., without passing through another gateway between),\
    \ then a cost,\n   d(i,j), is associated with the hop between i and j.  In the\
    \ normal\n   case where all entities on a given network are considered to be the\n\
    \   same, d(i,j) is the same for all destinations on a given network, and\n  \
    \ represents the cost of using that network.  To get the metric of a\n   complete\
    \ route, one just adds up the costs of the individual hops\n   that make up the\
    \ route.  For the purposes of this memo, we assume\n   that the costs are positive\
    \ integers.\n   Let D(i,j) represent the metric of the best route from entity\
    \ i to\n   entity j.  It should be defined for every pair of entities.  d(i,j)\n\
    \   represents the costs of the individual steps.  Formally, let d(i,j)\n   represent\
    \ the cost of going directly from entity i to entity j.  It\n   is infinite if\
    \ i and j are not immediate neighbors. (Note that d(i,i)\n   is infinite.  That\
    \ is, we don't consider there to be a direct\n   connection from a node to itself.)\
    \  Since costs are additive, it is\n   easy to show that the best metric must\
    \ be described by\n             D(i,i) = 0,                      all i\n     \
    \        D(i,j) = min [d(i,k) + D(k,j)],  otherwise\n                       k\n\
    \   and that the best routes start by going from i to those neighbors k\n   for\
    \ which d(i,k) + D(k,j) has the minimum value.  (These things can\n   be shown\
    \ by induction on the number of steps in the routes.)  Note\n   that we can limit\
    \ the second equation to k's that are immediate\n   neighbors of i.  For the others,\
    \ d(i,k) is infinite, so the term\n   involving them can never be the minimum.\n\
    \   It turns out that one can compute the metric by a simple algorithm\n   based\
    \ on this.  Entity i gets its neighbors k to send it their\n   estimates of their\
    \ distances to the destination j.  When i gets the\n   estimates from k, it adds\
    \ d(i,k) to each of the numbers.  This is\n   simply the cost of traversing the\
    \ network between i and k.  Now and\n   then i compares the values from all of\
    \ its neighbors and picks the\n   smallest.\n   A proof is given in [2] that this\
    \ algorithm will converge to the\n   correct estimates of D(i,j) in finite time\
    \ in the absence of topology\n   changes.  The authors make very few assumptions\
    \ about the order in\n   which the entities send each other their information,\
    \ or when the min\n   is recomputed.  Basically, entities just can't stop sending\
    \ updates\n   or recomputing metrics, and the networks can't delay messages\n\
    \   forever.  (Crash of a routing entity is a topology change.)  Also,\n   their\
    \ proof does not make any assumptions about the initial estimates\n   of D(i,j),\
    \ except that they must be non-negative.  The fact that\n   these fairly weak\
    \ assumptions are good enough is important.  Because\n   we don't have to make\
    \ assumptions about when updates are sent, it is\n   safe to run the algorithm\
    \ asynchronously.  That is, each entity can\n   send updates according to its\
    \ own clock.  Updates can be dropped by\n   the network, as long as they don't\
    \ all get dropped.  Because we don't\n   have to make assumptions about the starting\
    \ condition, the algorithm\n   can handle changes.  When the system changes, the\
    \ routing algorithm\n   starts moving to a new equilibrium, using the old one\
    \ as its starting\n   point.  It is important that the algorithm will converge\
    \ in finite\n   time no matter what the starting point.  Otherwise certain kinds\
    \ of\n   changes might lead to non-convergent behavior.\n   The statement of the\
    \ algorithm given above (and the proof) assumes\n   that each entity keeps copies\
    \ of the estimates that come from each of\n   its neighbors, and now and then\
    \ does a min over all of the neighbors.\n   In fact real implementations don't\
    \ necessarily do that.  They simply\n   remember the best metric seen so far,\
    \ and the identity of the\n   neighbor that sent it.  They replace this information\
    \ whenever they\n   see a better (smaller) metric.  This allows them to compute\
    \ the\n   minimum incrementally, without having to store data from all of the\n\
    \   neighbors.\n   There is one other difference between the algorithm as described\
    \ in\n   texts and those used in real protocols such as RIP: the description\n\
    \   above would have each entity include an entry for itself, showing a\n   distance\
    \ of zero.  In fact this is not generally done.  Recall that\n   all entities\
    \ on a network are normally summarized by a single entry\n   for the network.\
    \  Consider the situation of a host or gateway G that\n   is connected to network\
    \ A.  C represents the cost of using network A\n   (usually a metric of one).\
    \  (Recall that we are assuming that the\n   internal structure of a network is\
    \ not visible to IP, and thus the\n   cost of going between any two entities on\
    \ it is the same.)  In\n   principle, G should get a message from every other\
    \ entity H on\n   network A, showing a cost of 0 to get from that entity to itself.\
    \  G\n   would then compute C + 0 as the distance to H.  Rather than having G\n\
    \   look at all of these identical messages, it simply starts out by\n   making\
    \ an entry for network A in its table, and assigning it a metric\n   of C.  This\
    \ entry for network A should be thought of as summarizing\n   the entries for\
    \ all other entities on network A.  The only entity on\n   A that can't be summarized\
    \ by that common entry is G itself, since\n   the cost of going from G to G is\
    \ 0, not C.  But since we never need\n   those 0 entries, we can safely get along\
    \ with just the single entry\n   for network A.  Note one other implication of\
    \ this strategy: because\n   we don't need to use the 0 entries for anything,\
    \ hosts that do not\n   function as gateways don't need to send any update messages.\
    \  Clearly\n   hosts that don't function as gateways (i.e., hosts that are connected\n\
    \   to only one network) can have no useful information to contribute\n   other\
    \ than their own entry D(i,i) = 0.  As they have only the one\n   interface, it\
    \ is easy to see that a route to any other network\n   through them will simply\
    \ go in that interface and then come right\n   back out it.  Thus the cost of\
    \ such a route will be greater than the\n   best cost by at least C.  Since we\
    \ don't need the 0 entries, non-\n   gateways need not participate in the routing\
    \ protocol at all.\n   Let us summarize what a host or gateway G does.  For each\
    \ destination\n   in the system, G will keep a current estimate of the metric\
    \ for that\n   destination (i.e., the total cost of getting to it) and the identity\n\
    \   of the neighboring gateway on whose data that metric is based.  If\n   the\
    \ destination is on a network that is directly connected to G, then\n   G simply\
    \ uses an entry that shows the cost of using the network, and\n   the fact that\
    \ no gateway is needed to get to the destination.  It is\n   easy to show that\
    \ once the computation has converged to the correct\n   metrics, the neighbor\
    \ that is recorded by this technique is in fact\n   the first gateway on the path\
    \ to the destination.  (If there are\n   several equally good paths, it is the\
    \ first gateway on one of them.)\n   This combination of destination, metric,\
    \ and gateway is typically\n   referred to as a route to the destination with\
    \ that metric, using\n   that gateway.\n   The method so far only has a way to\
    \ lower the metric, as the existing\n   metric is kept until a smaller one shows\
    \ up.  It is possible that the\n   initial estimate might be too low.  Thus, there\
    \ must be a way to\n   increase the metric.  It turns out to be sufficient to\
    \ use the\n   following rule: suppose the current route to a destination has metric\n\
    \   D and uses gateway G.  If a new set of information arrived from some\n   source\
    \ other than G, only update the route if the new metric is\n   better than D.\
    \  But if a new set of information arrives from G\n   itself, always update D\
    \ to the new value.  It is easy to show that\n   with this rule, the incremental\
    \ update process produces the same\n   routes as a calculation that remembers\
    \ the latest information from\n   all the neighbors and does an explicit minimum.\
    \  (Note that the\n   discussion so far assumes that the network configuration\
    \ is static.\n   It does not allow for the possibility that a system might fail.)\n\
    \   To summarize, here is the basic distance vector algorithm as it has\n   been\
    \ developed so far.  (Note that this is not a statement of the RIP\n   protocol.\
    \  There are several refinements still to be added.)  The\n   following procedure\
    \ is carried out by every entity that participates\n   in the routing protocol.\
    \  This must include all of the gateways in\n   the system.  Hosts that are not\
    \ gateways may participate as well.\n       - Keep a table with an entry for every\
    \ possible destination\n        in the system.  The entry contains the distance\
    \ D to the\n        destination, and the first gateway G on the route to that\n\
    \        network.  Conceptually, there should be an entry for the\n        entity\
    \ itself, with metric 0, but this is not actually\n        included.\n      -\
    \ Periodically, send a routing update to every neighbor.  The\n        update\
    \ is a set of messages that contain all of the\n        information from the routing\
    \ table.  It contains an entry\n        for each destination, with the distance\
    \ shown to that\n        destination.\n      - When a routing update arrives from\
    \ a neighbor G', add the\n        cost associated with the network that is shared\
    \ with G'.\n        (This should be the network over which the update arrived.)\n\
    \        Call the resulting distance D'.  Compare the resulting\n        distances\
    \ with the current routing table entries.  If the\n        new distance D' for\
    \ N is smaller than the existing value D,\n        adopt the new route.  That\
    \ is, change the table entry for N\n        to have metric D' and gateway G'.\
    \  If G' is the gateway\n        from which the existing route came, i.e., G'\
    \ = G, then use\n        the new metric even if it is larger than the old one.\n"
- title: 2.1. Dealing with changes in topology
  contents:
  - "2.1. Dealing with changes in topology\n   The discussion above assumes that the\
    \ topology of the network is\n   fixed.  In practice, gateways and lines often\
    \ fail and come back up.\n   To handle this possibility, we need to modify the\
    \ algorithm slightly.\n   The theoretical version of the algorithm involved a\
    \ minimum over all\n   immediate neighbors.  If the topology changes, the set\
    \ of neighbors\n   changes.  Therefore, the next time the calculation is done,\
    \ the\n   change will be reflected.  However, as mentioned above, actual\n   implementations\
    \ use an incremental version of the minimization.  Only\n   the best route to\
    \ any given destination is remembered.  If the\n   gateway involved in that route\
    \ should crash, or the network\n   connection to it break, the calculation might\
    \ never reflect the\n   change.  The algorithm as shown so far depends upon a\
    \ gateway\n   notifying its neighbors if its metrics change.  If the gateway\n\
    \   crashes, then it has no way of notifying neighbors of a change.\n   In order\
    \ to handle problems of this kind, distance vector protocols\n   must make some\
    \ provision for timing out routes.  The details depend\n   upon the specific protocol.\
    \  As an example, in RIP every gateway that\n   participates in routing sends\
    \ an update message to all its neighbors\n   once every 30 seconds.  Suppose the\
    \ current route for network N uses\n   gateway G.  If we don't hear from G for\
    \ 180 seconds, we can assume\n   that either the gateway has crashed or the network\
    \ connecting us to\n   it has become unusable.  Thus, we mark the route as invalid.\
    \  When we\n   hear from another neighbor that has a valid route to N, the valid\n\
    \   route will replace the invalid one.  Note that we wait for 180\n   seconds\
    \ before timing out a route even though we expect to hear from\n   each neighbor\
    \ every 30 seconds.  Unfortunately, messages are\n   occasionally lost by networks.\
    \  Thus, it is probably not a good idea\n   to invalidate a route based on a single\
    \ missed message.\n   As we will see below, it is useful to have a way to notify\
    \ neighbors\n   that there currently isn't a valid route to some network.  RIP,\
    \ along\n   with several other protocols of this class, does this through a\n\
    \   normal update message, by marking that network as unreachable.  A\n   specific\
    \ metric value is chosen to indicate an unreachable\n   destination; that metric\
    \ value is larger than the largest valid\n   metric that we expect to see.  In\
    \ the existing implementation of RIP,\n   16 is used.  This value is normally\
    \ referred to as \"infinity\", since\n   it is larger than the largest valid metric.\
    \  16 may look like a\n   surprisingly small number.  It is chosen to be this\
    \ small for reasons\n   that we will see shortly.  In most implementations, the\
    \ same\n   convention is used internally to flag a route as invalid.\n"
- title: 2.2. Preventing instability
  contents:
  - "2.2. Preventing instability\n   The algorithm as presented up to this point will\
    \ always allow a host\n   or gateway to calculate a correct routing table.  However,\
    \ that is\n   still not quite enough to make it useful in practice.  The proofs\n\
    \   referred to above only show that the routing tables will converge to\n   the\
    \ correct values in finite time.  They do not guarantee that this\n   time will\
    \ be small enough to be useful, nor do they say what will\n   happen to the metrics\
    \ for networks that become inaccessible.\n   It is easy enough to extend the mathematics\
    \ to handle routes becoming\n   inaccessible.  The convention suggested above\
    \ will do that.  We\n   choose a large metric value to represent \"infinity\"\
    .  This value must\n   be large enough that no real metric would ever get that\
    \ large.  For\n   the purposes of this example, we will use the value 16.  Suppose\
    \ a\n   network becomes inaccessible.  All of the immediately neighboring\n  \
    \ gateways time out and set the metric for that network to 16.  For\n   purposes\
    \ of analysis, we can assume that all the neighboring gateways\n   have gotten\
    \ a new piece of hardware that connects them directly to\n   the vanished network,\
    \ with a cost of 16.  Since that is the only\n   connection to the vanished network,\
    \ all the other gateways in the\n   system will converge to new routes that go\
    \ through one of those\n   gateways.  It is easy to see that once convergence\
    \ has happened, all\n   the gateways will have metrics of at least 16 for the\
    \ vanished\n   network.  Gateways one hop away from the original neighbors would\
    \ end\n   up with metrics of at least 17; gateways two hops away would end up\n\
    \   with at least 18, etc.  As these metrics are larger than the maximum\n   metric\
    \ value, they are all set to 16.  It is obvious that the system\n   will now converge\
    \ to a metric of 16 for the vanished network at all\n   gateways.\n   Unfortunately,\
    \ the question of how long convergence will take is not\n   amenable to quite\
    \ so simple an answer.  Before going any further, it\n   will be useful to look\
    \ at an example (taken from [2]).  Note, by the\n   way, that what we are about\
    \ to show will not happen with a correct\n   implementation of RIP.  We are trying\
    \ to show why certain features\n   are needed.  Note that the letters correspond\
    \ to gateways, and the\n   lines to networks.\n            A-----B\n         \
    \    \\   / \\\n              \\ /  |\n               C  /    all networks have\
    \ cost 1, except\n               | /     for the direct link from C to D, which\n\
    \               |/      has cost 10\n               D\n               |<=== target\
    \ network\n   Each gateway will have a table showing a route to each network.\n\
    \   However, for purposes of this illustration, we show only the routes\n   from\
    \ each gateway to the network marked at the bottom of the diagram.\n         \
    \   D:  directly connected, metric 1\n            B:  route via D, metric 2\n\
    \            C:  route via B, metric 3\n            A:  route via B, metric 3\n\
    \   Now suppose that the link from B to D fails.  The routes should now\n   adjust\
    \ to use the link from C to D.  Unfortunately, it will take a\n   while for this\
    \ to this to happen.  The routing changes start when B\n   notices that the route\
    \ to D is no longer usable.  For simplicity, the\n   chart below assumes that\
    \ all gateways send updates at the same time.\n   The chart shows the metric for\
    \ the target network, as it appears in\n   the routing table at each gateway.\n\
    \        time ------>\n        D: dir, 1   dir, 1   dir, 1   dir, 1  ...  dir,\
    \ 1   dir, 1\n        B: unreach  C,   4   C,   5   C,   6       C,  11   C, \
    \ 12\n        C: B,   3   A,   4   A,   5   A,   6       A,  11   D,  11\n   \
    \     A: B,   3   C,   4   C,   5   C,   6       C,  11   C,  12\n        dir\
    \ = directly connected\n        unreach = unreachable\n   Here's the problem:\
    \  B is able to get rid of its failed route using a\n   timeout mechanism.  But\
    \ vestiges of that route persist in the system\n   for a long time.  Initially,\
    \ A and C still think they can get to D\n   via B.  So, they keep sending updates\
    \ listing metrics of 3.  In the\n   next iteration, B will then claim that it\
    \ can get to D via either A\n   or C.  Of course, it can't.  The routes being\
    \ claimed by A and C are\n   now gone, but they have no way of knowing that yet.\
    \  And even when\n   they discover that their routes via B have gone away, they\
    \ each think\n   there is a route available via the other.  Eventually the system\n\
    \   converges, as all the mathematics claims it must.  But it can take\n   some\
    \ time to do so.  The worst case is when a network becomes\n   completely inaccessible\
    \ from some part of the system.  In that case,\n   the metrics may increase slowly\
    \ in a pattern like the one above until\n   they finally reach infinity.  For\
    \ this reason, the problem is called\n   \"counting to infinity\".\n   You should\
    \ now see why \"infinity\" is chosen to be as small as\n   possible.  If a network\
    \ becomes completely inaccessible, we want\n   counting to infinity to be stopped\
    \ as soon as possible.  Infinity\n   must be large enough that no real route is\
    \ that big.  But it\n   shouldn't be any bigger than required.  Thus the choice\
    \ of infinity\n   is a tradeoff between network size and speed of convergence\
    \ in case\n   counting to infinity happens.  The designers of RIP believed that\
    \ the\n   protocol was unlikely to be practical for networks with a diameter\n\
    \   larger than 15.\n   There are several things that can be done to prevent problems\
    \ like\n   this.  The ones used by RIP are called \"split horizon with poisoned\n\
    \   reverse\", and \"triggered updates\".\n"
- title: 2.2.1. Split horizon
  contents:
  - "2.2.1. Split horizon\n   Note that some of the problem above is caused by the\
    \ fact that A and\n   C are engaged in a pattern of mutual deception.  Each claims\
    \ to be\n   able to get to D via the other.  This can be prevented by being a\
    \ bit\n   more careful about where information is sent.  In particular, it is\n\
    \   never useful to claim reachability for a destination network to the\n   neighbor(s)\
    \ from which the route was learned.  \"Split horizon\" is a\n   scheme for avoiding\
    \ problems caused by including routes in updates\n   sent to the gateway from\
    \ which they were learned.  The \"simple split\n   horizon\" scheme omits routes\
    \ learned from one neighbor in updates\n   sent to that neighbor.  \"Split horizon\
    \ with poisoned reverse\"\n   includes such routes in updates, but sets their\
    \ metrics to infinity.\n   If A thinks it can get to D via C, its messages to\
    \ C should indicate\n   that D is unreachable.  If the route through C is real,\
    \ then C either\n   has a direct connection to D, or a connection through some\
    \ other\n   gateway.  C's route can't possibly go back to A, since that forms\
    \ a\n   loop.  By telling C that D is unreachable, A simply guards against\n \
    \  the possibility that C might get confused and believe that there is a\n   route\
    \ through A.  This is obvious for a point to point line.  But\n   consider the\
    \ possibility that A and C are connected by a broadcast\n   network such as an\
    \ Ethernet, and there are other gateways on that\n   network.  If A has a route\
    \ through C, it should indicate that D is\n   unreachable when talking to any\
    \ other gateway on that network.  The\n   other gateways on the network can get\
    \ to C themselves.  They would\n   never need to get to C via A.  If A's best\
    \ route is really through C,\n   no other gateway on that network needs to know\
    \ that A can reach D.\n   This is fortunate, because it means that the same update\
    \ message that\n   is used for C can be used for all other gateways on the same\
    \ network.\n   Thus, update messages can be sent by broadcast.\n   In general,\
    \ split horizon with poisoned reverse is safer than simple\n   split horizon.\
    \  If two gateways have routes pointing at each other,\n   advertising reverse\
    \ routes with a metric of 16 will break the loop\n   immediately.  If the reverse\
    \ routes are simply not advertised, the\n   erroneous routes will have to be eliminated\
    \ by waiting for a timeout.\n   However, poisoned reverse does have a disadvantage:\
    \ it increases the\n   size of the routing messages.  Consider the case of a campus\
    \ backbone\n   connecting a number of different buildings.  In each building,\
    \ there\n   is a gateway connecting the backbone to a local network.  Consider\n\
    \   what routing updates those gateways should broadcast on the backbone\n   network.\
    \  All that the rest of the network really needs to know about\n   each gateway\
    \ is what local networks it is connected to.  Using simple\n   split horizon,\
    \ only those routes would appear in update messages sent\n   by the gateway to\
    \ the backbone network.  If split horizon with\n   poisoned reverse is used, the\
    \ gateway must mention all routes that it\n   learns from the backbone, with metrics\
    \ of 16.  If the system is\n   large, this can result in a large update message,\
    \ almost all of whose\n   entries indicate unreachable networks.\n   In a static\
    \ sense, advertising reverse routes with a metric of 16\n   provides no additional\
    \ information.  If there are many gateways on\n   one broadcast network, these\
    \ extra entries can use significant\n   bandwidth.  The reason they are there\
    \ is to improve dynamic behavior.\n   When topology changes, mentioning routes\
    \ that should not go through\n   the gateway as well as those that should can\
    \ speed up convergence.\n   However, in some situations, network managers may\
    \ prefer to accept\n   somewhat slower convergence in order to minimize routing\
    \ overhead.\n   Thus implementors may at their option implement simple split horizon\n\
    \   rather than split horizon with poisoned reverse, or they may provide\n   a\
    \ configuration option that allows the network manager to choose\n   which behavior\
    \ to use.  It is also permissible to implement hybrid\n   schemes that advertise\
    \ some reverse routes with a metric of 16 and\n   omit others.  An example of\
    \ such a scheme would be to use a metric of\n   16 for reverse routes for a certain\
    \ period of time after routing\n   changes involving them, and thereafter omitting\
    \ them from updates.\n"
- title: 2.2.2. Triggered updates
  contents:
  - "2.2.2. Triggered updates\n   Split horizon with poisoned reverse will prevent\
    \ any routing loops\n   that involve only two gateways.  However, it is still\
    \ possible to end\n   up with patterns in which three gateways are engaged in\
    \ mutual\n   deception.  For example, A may believe it has a route through B,\
    \ B\n   through C, and C through A.  Split horizon cannot stop such a loop.\n\
    \   This loop will only be resolved when the metric reaches infinity and\n   the\
    \ network involved is then declared unreachable.  Triggered updates\n   are an\
    \ attempt to speed up this convergence.  To get triggered\n   updates, we simply\
    \ add a rule that whenever a gateway changes the\n   metric for a route, it is\
    \ required to send update messages almost\n   immediately, even if it is not yet\
    \ time for one of the regular update\n   message.  (The timing details will differ\
    \ from protocol to protocol.\n   Some distance vector protocols, including RIP,\
    \ specify a small time\n   delay, in order to avoid having triggered updates generate\
    \ excessive\n   network traffic.)  Note how this combines with the rules for\n\
    \   computing new metrics.  Suppose a gateway's route to destination N\n   goes\
    \ through gateway G.  If an update arrives from G itself, the\n   receiving gateway\
    \ is required to believe the new information, whether\n   the new metric is higher\
    \ or lower than the old one.  If the result is\n   a change in metric, then the\
    \ receiving gateway will send triggered\n   updates to all the hosts and gateways\
    \ directly connected to it.  They\n   in turn may each send updates to their neighbors.\
    \  The result is a\n   cascade of triggered updates.  It is easy to show which\
    \ gateways and\n   hosts are involved in the cascade.  Suppose a gateway G times\
    \ out a\n   route to destination N.  G will send triggered updates to all of its\n\
    \   neighbors.  However, the only neighbors who will believe the new\n   information\
    \ are those whose routes for N go through G.  The other\n   gateways and hosts\
    \ will see this as information about a new route\n   that is worse than the one\
    \ they are already using, and ignore it.\n   The neighbors whose routes go through\
    \ G will update their metrics and\n   send triggered updates to all of their neighbors.\
    \  Again, only those\n   neighbors whose routes go through them will pay attention.\
    \  Thus, the\n   triggered updates will propagate backwards along all paths leading\
    \ to\n   gateway G, updating the metrics to infinity.  This propagation will\n\
    \   stop as soon as it reaches a portion of the network whose route to\n   destination\
    \ N takes some other path.\n   If the system could be made to sit still while\
    \ the cascade of\n   triggered updates happens, it would be possible to prove\
    \ that\n   counting to infinity will never happen.  Bad routes would always be\n\
    \   removed immediately, and so no routing loops could form.\n   Unfortunately,\
    \ things are not so nice.  While the triggered updates\n   are being sent, regular\
    \ updates may be happening at the same time.\n   Gateways that haven't received\
    \ the triggered update yet will still be\n   sending out information based on\
    \ the route that no longer exists.  It\n   is possible that after the triggered\
    \ update has gone through a\n   gateway, it might receive a normal update from\
    \ one of these gateways\n   that hasn't yet gotten the word.  This could reestablish\
    \ an orphaned\n   remnant of the faulty route.  If triggered updates happen quickly\n\
    \   enough, this is very unlikely.  However, counting to infinity is\n   still\
    \ possible.\n"
- title: 3. Specifications for the protocol
  contents:
  - "3. Specifications for the protocol\n   RIP is intended to allow hosts and gateways\
    \ to exchange information\n   for computing routes through an IP-based network.\
    \  RIP is a distance\n   vector protocol.  Thus, it has the general features described\
    \ in\n   section 2.  RIP may be implemented by both hosts and gateways.  As in\n\
    \   most IP documentation, the term \"host\" will be used here to cover\n   either.\
    \  RIP is used to convey information about routes to\n   \"destinations\", which\
    \ may be individual hosts, networks, or a special\n   destination used to convey\
    \ a default route.\n   Any host that uses RIP is assumed to have interfaces to\
    \ one or more\n   networks.  These are referred to as its \"directly-connected\n\
    \   networks\".  The protocol relies on access to certain information\n   about\
    \ each of these networks.  The most important is its metric or\n   \"cost\". \
    \ The metric of a network is an integer between 1 and 15\n   inclusive.  It is\
    \ set in some manner not specified in this protocol.\n   Most existing implementations\
    \ always use a metric of 1.  New\n   implementations should allow the system administrator\
    \ to set the cost\n   of each network.  In addition to the cost, each network\
    \ will have an\n   IP network number and a subnet mask associated with it.  These\
    \ are to\n   be set by the system administrator in a manner not specified in this\n\
    \   protocol.\n   Note that the rules specified in section 3.2 assume that there\
    \ is a\n   single subnet mask applying to each IP network, and that only the\n\
    \   subnet masks for directly-connected networks are known.  There may be\n  \
    \ systems that use different subnet masks for different subnets within\n   a single\
    \ network.  There may also be instances where it is desirable\n   for a system\
    \ to know the subnets masks of distant networks.  However,\n   such situations\
    \ will require modifications of the rules which govern\n   the spread of subnet\
    \ information.  Such modifications raise issues of\n   interoperability, and thus\
    \ must be viewed as modifying the protocol.\n   Each host that implements RIP\
    \ is assumed to have a routing table.\n   This table has one entry for every destination\
    \ that is reachable\n   through the system described by RIP.  Each entry contains\
    \ at least\n   the following information:\n      - The IP address of the destination.\n\
    \      - A metric, which represents the total cost of getting a\n        datagram\
    \ from the host to that destination.  This metric is\n        the sum of the costs\
    \ associated with the networks that\n        would be traversed in getting to\
    \ the destination.\n      - The IP address of the next gateway along the path\
    \ to the\n        destination.  If the destination is on one of the\n        directly-connected\
    \ networks, this item is not needed.\n      - A flag to indicate that information\
    \ about the route has\n        changed recently.  This will be referred to as\
    \ the \"route\n        change flag.\"\n      - Various timers associated with\
    \ the route.  See section 3.3\n        for more details on them.\n   The entries\
    \ for the directly-connected networks are set up by the\n   host, using information\
    \ gathered by means not specified in this\n   protocol.  The metric for a directly-connected\
    \ network is set to the\n   cost of that network.  In existing RIP implementations,\
    \ 1 is always\n   used for the cost.  In that case, the RIP metric reduces to\
    \ a simple\n   hop-count.  More complex metrics may be used when it is desirable\
    \ to\n   show preference for some networks over others, for example because of\n\
    \   differences in bandwidth or reliability.\n   Implementors may also choose\
    \ to allow the system administrator to\n   enter additional routes.  These would\
    \ most likely be routes to hosts\n   or networks outside the scope of the routing\
    \ system.\n   Entries for destinations other these initial ones are added and\n\
    \   updated by the algorithms described in the following sections.\n   In order\
    \ for the protocol to provide complete information on routing,\n   every gateway\
    \ in the system must participate in it.  Hosts that are\n   not gateways need\
    \ not participate, but many implementations make\n   provisions for them to listen\
    \ to routing information in order to\n   allow them to maintain their routing\
    \ tables.\n"
- title: 3.1. Message formats
  contents:
  - "3.1. Message formats\n   RIP is a UDP-based protocol.  Each host that uses RIP\
    \ has a routing\n   process that sends and receives datagrams on UDP port number\
    \ 520.\n   All communications directed at another host's RIP processor are sent\n\
    \   to port 520.  All routing update messages are sent from port 520.\n   Unsolicited\
    \ routing update messages have both the source and\n   destination port equal\
    \ to 520.  Those sent in response to a request\n   are sent to the port from which\
    \ the request came.  Specific queries\n   and debugging requests may be sent from\
    \ ports other than 520, but\n   they are directed to port 520 on the target machine.\n\
    \   There are provisions in the protocol to allow \"silent\" RIP processes.\n\
    \   A silent process is one that normally does not send out any messages.\n  \
    \ However, it listens to messages sent by others.  A silent RIP might\n   be used\
    \ by hosts that do not act as gateways, but wish to listen to\n   routing updates\
    \ in order to monitor local gateways and to keep their\n   internal routing tables\
    \ up to date.  (See [5] for a discussion of\n   various ways that hosts can keep\
    \ track of network topology.)  A\n   gateway that has lost contact with all but\
    \ one of its networks might\n   choose to become silent, since it is effectively\
    \ no longer a gateway.\n   However, this should not be done if there is any chance\
    \ that\n   neighboring gateways might depend upon its messages to detect that\n\
    \   the failed network has come back into operation.  (The 4BSD routed\n   program\
    \ uses routing packets to monitor the operation of point-to-\n   point links.)\n\
    \   The packet format is shown in Figure 1.\n      Format of datagrams containing\
    \ network information.  Field sizes\n      are given in octets.  Unless otherwise\
    \ specified, fields contain\n      binary integers, in normal Internet order with\
    \ the most-significant\n      octet first.  Each tick mark represents one bit.\n\
    \       0                   1                   2                   3 3\n    \
    \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      | command (1)   | version (1)   |      must be zero (2)         |\n   \
    \   +---------------+---------------+-------------------------------+\n      |\
    \ address family identifier (2) |      must be zero (2)         |\n      +-------------------------------+-------------------------------+\n\
    \      |                         IP address (4)                        |\n   \
    \   +---------------------------------------------------------------+\n      |\
    \                        must be zero (4)                       |\n      +---------------------------------------------------------------+\n\
    \      |                        must be zero (4)                       |\n   \
    \   +---------------------------------------------------------------+\n      |\
    \                          metric (4)                           |\n      +---------------------------------------------------------------+\n\
    \                                      .\n                                   \
    \   .\n                                      .\n      The portion of the datagram\
    \ from address family identifier through\n      metric may appear up to 25 times.\
    \  IP address is the usual 4-octet\n      Internet address, in network order.\n\
    \                          Figure 1.   Packet format\n   Every datagram contains\
    \ a command, a version number, and possible\n   arguments.  This document describes\
    \ version 1 of the protocol.\n   Details of processing the version number are\
    \ described in section\n   3.4.  The command field is used to specify the purpose\
    \ of this\n   datagram.  Here is a summary of the commands implemented in version\n\
    \   1:\n   1 - request     A request for the responding system to send all or\n\
    \                   part of its routing table.\n   2 - response    A message containing\
    \ all or part of the sender's\n                   routing table.  This message\
    \ may be sent in response\n                   to a request or poll, or it may\
    \ be an update message\n                   generated by the sender.\n   3 - traceon\
    \     Obsolete.  Messages containing this command are to be\n                \
    \   ignored.\n   4 - traceoff    Obsolete.  Messages containing this command are\
    \ to be\n                   ignored.\n   5 - reserved    This value is used by\
    \ Sun Microsystems for its own\n                   purposes.  If new commands\
    \ are added in any\n                   succeeding version, they should begin with\
    \ 6.\n                   Messages containing this command may safely be\n    \
    \               ignored by implementations that do not choose to\n           \
    \        respond to it.\n   For request and response, the rest of the datagram\
    \ contains a list of\n   destinations, with information about each.  Each entry\
    \ in this list\n   contains a destination network or host, and the metric for\
    \ it.  The\n   packet format is intended to allow RIP to carry routing information\n\
    \   for several different protocols.  Thus, each entry has an address\n   family\
    \ identifier to indicate what type of address is specified in\n   that entry.\
    \  This document only describes routing for Internet\n   networks.  The address\
    \ family identifier for IP is 2.  None of the\n   RIP implementations available\
    \ to the author implement any other type\n   of address.  However, to allow for\
    \ future development,\n   implementations are required to skip entries that specify\
    \ address\n   families that are not supported by the implementation.  (The size\
    \ of\n   these entries will be the same as the size of an entry specifying an\n\
    \   IP address.) Processing of the message continues normally after any\n   unsupported\
    \ entries are skipped.  The IP address is the usual\n   Internet address, stored\
    \ as 4 octets in network order.  The metric\n   field must contain a value between\
    \ 1 and 15 inclusive, specifying the\n   current metric for the destination, or\
    \ the value 16, which indicates\n   that the destination is not reachable.  Each\
    \ route sent by a gateway\n   supercedes any previous route to the same destination\
    \ from the same\n   gateway.\n   The maximum datagram size is 512 octets.  This\
    \ includes only the\n   portions of the datagram described above.  It does not\
    \ count the IP\n   or UDP headers.  The commands that involve network information\
    \ allow\n   information to be split across several datagrams.  No special\n  \
    \ provisions are needed for continuations, since correct results will\n   occur\
    \ if the datagrams are processed individually.\n"
- title: 3.2. Addressing considerations
  contents:
  - "3.2. Addressing considerations\n   As indicated in section 2, distance vector\
    \ routing can be used to\n   describe routes to individual hosts or to networks.\
    \  The RIP protocol\n   allows either of these possibilities.  The destinations\
    \ appearing in\n   request and response messages can be networks, hosts, or a\
    \ special\n   code used to indicate a default address.  In general, the kinds\
    \ of\n   routes actually used will depend upon the routing strategy used for\n\
    \   the particular network.  Many networks are set up so that routing\n   information\
    \ for individual hosts is not needed.  If every host on a\n   given network or\
    \ subnet is accessible through the same gateways, then\n   there is no reason\
    \ to mention individual hosts in the routing tables.\n   However, networks that\
    \ include point to point lines sometimes require\n   gateways to keep track of\
    \ routes to certain hosts.  Whether this\n   feature is required depends upon\
    \ the addressing and routing approach\n   used in the system.  Thus, some implementations\
    \ may choose not to\n   support host routes.  If host routes are not supported,\
    \ they are to\n   be dropped when they are received in response messages.  (See\
    \ section\n   3.4.2.)\n   The RIP packet formats do not distinguish among various\
    \ types of\n   address.  Fields that are labeled \"address\" can contain any of\
    \ the\n   following:\n      host address\n      subnet number\n      network number\n\
    \      0, indicating a default route\n   Entities that use RIP are assumed to\
    \ use the most specific\n   information available when routing a datagram.  That\
    \ is, when routing\n   a datagram, its destination address must first be checked\
    \ against the\n   list of host addresses.  Then it must be checked to see whether\
    \ it\n   matches any known subnet or network number.  Finally, if none of\n  \
    \ these match, the default route is used.\n   When a host evaluates information\
    \ that it receives via RIP, its\n   interpretation of an address depends upon\
    \ whether it knows the subnet\n   mask that applies to the net.  If so, then it\
    \ is possible to\n   determine the meaning of the address.  For example, consider\
    \ net\n   128.6.  It has a subnet mask of 255.255.255.0.  Thus 128.6.0.0 is a\n\
    \   network number, 128.6.4.0 is a subnet number, and 128.6.4.1 is a host\n  \
    \ address.  However, if the host does not know the subnet mask,\n   evaluation\
    \ of an address may be ambiguous.  If there is a non-zero\n   host part, there\
    \ is no clear way to determine whether the address\n   represents a subnet number\
    \ or a host address.  As a subnet number\n   would be useless without the subnet\
    \ mask, addresses are assumed to\n   represent hosts in this situation.  In order\
    \ to avoid this sort of\n   ambiguity, hosts must not send subnet routes to hosts\
    \ that cannot be\n   expected to know the appropriate subnet mask.  Normally hosts\
    \ only\n   know the subnet masks for directly-connected networks.  Therefore,\n\
    \   unless special provisions have been made, routes to a subnet must not\n  \
    \ be sent outside the network of which the subnet is a part.\n   This filtering\
    \ is carried out by the gateways at the \"border\" of the\n   subnetted network.\
    \  These are gateways that connect that network with\n   some other network. \
    \ Within the subnetted network, each subnet is\n   treated as an individual network.\
    \  Routing entries for each subnet\n   are circulated by RIP.  However, border\
    \ gateways send only a single\n   entry for the network as a whole to hosts in\
    \ other networks.  This\n   means that a border gateway will send different information\
    \ to\n   different neighbors.  For neighbors connected to the subnetted\n   network,\
    \ it generates a list of all subnets to which it is directly\n   connected, using\
    \ the subnet number.  For neighbors connected to other\n   networks, it makes\
    \ a single entry for the network as a whole, showing\n   the metric associated\
    \ with that network.  (This metric would normally\n   be the smallest metric for\
    \ the subnets to which the gateway is\n   attached.)\n   Similarly, border gateways\
    \ must not mention host routes for hosts\n   within one of the directly-connected\
    \ networks in messages to other\n   networks.  Those routes will be subsumed by\
    \ the single entry for the\n   network as a whole.  We do not specify what to\
    \ do with host routes\n   for \"distant\" hosts (i.e., hosts not part of one of\
    \ the directly-\n   connected networks).  Generally, these routes indicate some\
    \ host that\n   is reachable via a route that does not support other hosts on\
    \ the\n   network of which the host is a part.\n   The special address 0.0.0.0\
    \ is used to describe a default route.  A\n   default route is used when it is\
    \ not convenient to list every\n   possible network in the RIP updates, and when\
    \ one or more closely-\n   connected gateways in the system are prepared to handle\
    \ traffic to\n   the networks that are not listed explicitly.  These gateways\
    \ should\n   create RIP entries for the address 0.0.0.0, just as if it were a\n\
    \   network to which they are connected.  The decision as to how gateways\n  \
    \ create entries for 0.0.0.0 is left to the implementor.  Most\n   commonly, the\
    \ system administrator will be provided with a way to\n   specify which gateways\
    \ should create entries for 0.0.0.0.  However,\n   other mechanisms are possible.\
    \  For example, an implementor might\n   decide that any gateway that speaks EGP\
    \ should be declared to be a\n   default gateway.  It may be useful to allow the\
    \ network administrator\n   to choose the metric to be used in these entries.\
    \  If there is more\n   than one default gateway, this will make it possible to\
    \ express a\n   preference for one over the other.  The entries for 0.0.0.0 are\n\
    \   handled by RIP in exactly the same manner as if there were an actual\n   network\
    \ with this address.  However, the entry is used to route any\n   datagram whose\
    \ destination address does not match any other network\n   in the table.  Implementations\
    \ are not required to support this\n   convention.  However, it is strongly recommended.\
    \  Implementations\n   that do not support 0.0.0.0 must ignore entries with this\
    \ address.\n   In such cases, they must not pass the entry on in their own RIP\n\
    \   updates.  System administrators should take care to make sure that\n   routes\
    \ to 0.0.0.0 do not propagate further than is intended.\n   Generally, each autonomous\
    \ system has its own preferred default\n   gateway.  Thus, routes involving 0.0.0.0\
    \ should generally not leave\n   the boundary of an autonomous system.  The mechanisms\
    \ for enforcing\n   this are not specified in this document.\n"
- title: 3.3. Timers
  contents:
  - "3.3. Timers\n   This section describes all events that are triggered by timers.\n\
    \   Every 30 seconds, the output process is instructed to generate a\n   complete\
    \ response to every neighboring gateway.  When there are many\n   gateways on\
    \ a single network, there is a tendency for them to\n   synchronize with each\
    \ other such that they all issue updates at the\n   same time.  This can happen\
    \ whenever the 30 second timer is affected\n   by the processing load on the system.\
    \  It is undesirable for the\n   update messages to become synchronized, since\
    \ it can lead to\n   unnecessary collisions on broadcast networks.  Thus, implementations\n\
    \   are required to take one of two precautions.\n      - The 30-second updates\
    \ are triggered by a clock whose rate\n        is not affected by system load\
    \ or the time required to\n        service the previous update timer.\n      -\
    \ The 30-second timer is offset by addition of a small random\n        time each\
    \ time it is set.\n   There are two timers associated with each route, a \"timeout\"\
    \ and a\n   \"garbage-collection time\".  Upon expiration of the timeout, the\
    \ route\n   is no longer valid.  However, it is retained in the table for a short\n\
    \   time, so that neighbors can be notified that the route has been\n   dropped.\
    \  Upon expiration of the garbage-collection timer, the route\n   is finally removed\
    \ from the tables.\n   The timeout is initialized when a route is established,\
    \ and any time\n   an update message is received for the route.  If 180 seconds\
    \ elapse\n   from the last time the timeout was initialized, the route is\n  \
    \ considered to have expired, and the deletion process which we are\n   about\
    \ to describe is started for it.\n   Deletions can occur for one of two reasons:\
    \ (1) the timeout expires,\n   or (2) the metric is set to 16 because of an update\
    \ received from the\n   current gateway.  (See section 3.4.2 for a discussion\
    \ processing\n   updates from other gateways.)  In either case, the following\
    \ events\n   happen:\n      - The garbage-collection timer is set for 120 seconds.\n\
    \      - The metric for the route is set to 16 (infinity).  This\n        causes\
    \ the route to be removed from service.\n      - A flag is set noting that this\
    \ entry has been changed, and\n        the output process is signalled to trigger\
    \ a response.\n   Until the garbage-collection timer expires, the route is included\
    \ in\n   all updates sent by this host, with a metric of 16 (infinity).  When\n\
    \   the garbage-collection timer expires, the route is deleted from the\n   tables.\n\
    \   Should a new route to this network be established while the garbage-\n   collection\
    \ timer is running, the new route will replace the one that\n   is about to be\
    \ deleted.  In this case the garbage-collection timer\n   must be cleared.\n \
    \  See section 3.5 for a discussion of a delay that is required in\n   carrying\
    \ out triggered updates.  Although implementation of that\n   delay will require\
    \ a timer, it is more natural to discuss it in\n   section 3.5 than here.\n"
- title: 3.4. Input processing
  contents:
  - "3.4. Input processing\n   This section will describe the handling of datagrams\
    \ received on UDP\n   port 520.  Before processing the datagrams in detail, certain\
    \ general\n   format checks must be made.  These depend upon the version number\n\
    \   field in the datagram, as follows:\n      0   Datagrams whose version number\
    \ is zero are to be ignored.\n          These are from a previous version of the\
    \ protocol, whose\n          packet format was machine-specific.\n      1   Datagrams\
    \ whose version number is one are to be processed\n          as described in the\
    \ rest of this specification.  All fields\n          that are described above\
    \ as \"must be zero\" are to be checked.\n          If any such field contains\
    \ a non-zero value, the entire\n          message is to be ignored.\n      >1\
    \  Datagrams whose version number are greater than one are\n          to be processed\
    \ as described in the rest of this\n          specification.  All fields that\
    \ are described above as\n          \"must be zero\" are to be ignored.  Future\
    \ versions of the\n          protocol may put data into these fields.  Version\
    \ 1\n          implementations are to ignore this extra data and process\n   \
    \       only the fields specified in this document.\n   After checking the version\
    \ number and doing any other preliminary\n   checks, processing will depend upon\
    \ the value in the command field.\n"
- title: 3.4.1. Request
  contents:
  - "3.4.1. Request\n   Request is used to ask for a response containing all or part\
    \ of the\n   host's routing table.  [Note that the term host is used for either\n\
    \   host or gateway, in most cases it would be unusual for a non-gateway\n   host\
    \ to send RIP messages.]  Normally, requests are sent as\n   broadcasts, from\
    \ a UDP source port of 520.  In this case, silent\n   processes do not respond\
    \ to the request.  Silent processes are by\n   definition processes for which\
    \ we normally do not want to see routing\n   information.  However, there may\
    \ be situations involving gateway\n   monitoring where it is desired to look at\
    \ the routing table even for\n   a silent process.  In this case, the request\
    \ should be sent from a\n   UDP port number other than 520.  If a request comes\
    \ from port 520,\n   silent processes do not respond.  If the request comes from\
    \ any other\n   port, processes must respond even if they are silent.\n   The\
    \ request is processed entry by entry.  If there are no entries, no\n   response\
    \ is given.  There is one special case.  If there is exactly\n   one entry in\
    \ the request, with an address family identifier of 0\n   (meaning unspecified),\
    \ and a metric of infinity (i.e., 16 for current\n   implementations), this is\
    \ a request to send the entire routing table.\n   In that case, a call is made\
    \ to the output process to send the\n   routing table to the requesting port.\n\
    \   Except for this special case, processing is quite simple.  Go down\n   the\
    \ list of entries in the request one by one.  For each entry, look\n   up the\
    \ destination in the host's routing database.  If there is a\n   route, put that\
    \ route's metric in the metric field in the datagram.\n   If there isn't a route\
    \ to the specified destination, put infinity\n   (i.e., 16) in the metric field\
    \ in the datagram.  Once all the entries\n   have been filled in, set the command\
    \ to response and send the\n   datagram back to the port from which it came.\n\
    \   Note that there is a difference in handling depending upon whether\n   the\
    \ request is for a specified set of destinations, or for a complete\n   routing\
    \ table.  If the request is for a complete host table, normal\n   output processing\
    \ is done.  This includes split horizon (see section\n   2.2.1) and subnet hiding\
    \ (section 3.2), so that certain entries from\n   the routing table will not be\
    \ shown.  If the request is for specific\n   entries, they are looked up in the\
    \ host table and the information is\n   returned.  No split horizon processing\
    \ is done, and subnets are\n   returned if requested.  We anticipate that these\
    \ requests are likely\n   to be used for different purposes.  When a host first\
    \ comes up, it\n   broadcasts requests on every connected network asking for a\
    \ complete\n   routing table.  In general, we assume that complete routing tables\n\
    \   are likely to be used to update another host's routing table.  For\n   this\
    \ reason, split horizon and all other filtering must be used.\n   Requests for\
    \ specific networks are made only by diagnostic software,\n   and are not used\
    \ for routing.  In this case, the requester would want\n   to know the exact contents\
    \ of the routing database, and would not\n   want any information hidden.\n"
- title: 3.4.2. Response
  contents:
  - "3.4.2. Response\n   Responses can be received for several different reasons:\n\
    \      response to a specific query\n      regular updates\n      triggered updates\
    \ triggered by a metric change\n   Processing is the same no matter how responses\
    \ were generated.\n   Because processing of a response may update the host's routing\
    \ table,\n   the response must be checked carefully for validity.  The response\n\
    \   must be ignored if it is not from port 520.  The IP source address\n   should\
    \ be checked to see whether the datagram is from a valid\n   neighbor.  The source\
    \ of the datagram must be on a directly-connected\n   network.  It is also worth\
    \ checking to see whether the response is\n   from one of the host's own addresses.\
    \  Interfaces on broadcast\n   networks may receive copies of their own broadcasts\
    \ immediately.  If\n   a host processes its own output as new input, confusion\
    \ is likely,\n   and such datagrams must be ignored (except as discussed in the\
    \ next\n   paragraph).\n   Before actually processing a response, it may be useful\
    \ to use its\n   presence as input to a process for keeping track of interface\
    \ status.\n   As mentioned above, we time out a route when we haven't heard from\n\
    \   its gateway for a certain amount of time.  This works fine for routes\n  \
    \ that come from another gateway.  It is also desirable to know when\n   one of\
    \ our own directly-connected networks has failed.  This document\n   does not\
    \ specify any particular method for doing this, as such\n   methods depend upon\
    \ the characteristics of the network and the\n   hardware interface to it.  However,\
    \ such methods often involve\n   listening for datagrams arriving on the interface.\
    \  Arriving\n   datagrams can be used as an indication that the interface is working.\n\
    \   However, some caution must be used, as it is possible for interfaces\n   to\
    \ fail in such a way that input datagrams are received, but output\n   datagrams\
    \ are never sent successfully.\n   Now that the datagram as a whole has been validated,\
    \ process the\n   entries in it one by one.  Again, start by doing validation.\
    \  If the\n   metric is greater than infinity, ignore the entry.  (This should\
    \ be\n   impossible, if the other host is working correctly.  Incorrect\n   metrics\
    \ and other format errors should probably cause alerts or be\n   logged.)  Then\
    \ look at the destination address.  Check the address\n   family identifier. \
    \ If it is not a value which is expected (e.g., 2\n   for Internet addresses),\
    \ ignore the entry.  Now check the address\n   itself for various kinds of inappropriate\
    \ addresses.  Ignore the\n   entry if the address is class D or E, if it is on\
    \ net 0 (except for\n   0.0.0.0, if we accept default routes) or if it is on net\
    \ 127 (the\n   loopback network).  Also, test for a broadcast address, i.e.,\n\
    \   anything whose host part is all ones on a network that supports\n   broadcast,\
    \ and ignore any such entry.  If the implementor has chosen\n   not to support\
    \ host routes (see section 3.2), check to see whether\n   the host portion of\
    \ the address is non-zero; if so, ignore the entry.\n   Recall that the address\
    \ field contains a number of unused octets.  If\n   the version number of the\
    \ datagram is 1, they must also be checked.\n   If any of them is nonzero, the\
    \ entry is to be ignored.  (Many of\n   these cases indicate that the host from\
    \ which the message came is not\n   working correctly.  Thus some form of error\
    \ logging or alert should\n   be triggered.)\n   Update the metric by adding the\
    \ cost of the network on which the\n   message arrived.  If the result is greater\
    \ than 16, use 16.  That is,\n      metric = MIN (metric + cost, 16)\n   Now look\
    \ up the address to see whether this is already a route for\n   it.  In general,\
    \ if not, we want to add one.  However, there are\n   various exceptions.  If\
    \ the metric is infinite, don't add an entry.\n   (We would update an existing\
    \ one, but we don't add new entries with\n   infinite metric.)  We want to avoid\
    \ adding routes to hosts if the\n   host is part of a net or subnet for which\
    \ we have at least as good a\n   route.  If neither of these exceptions applies,\
    \ add a new entry to\n   the routing database.  This includes the following actions:\n\
    \      - Set the destination and metric to those from the datagram.\n      - Set\
    \ the gateway to be the host from which the datagram\n        came.\n      - Initialize\
    \ the timeout for the route. If the garbage-\n        collection timer is running\
    \ for this route, stop it. (See\n        section 3.3 for a discussion of the timers.)\n\
    \      - Set the route change flag, and signal the output process to\n       \
    \ trigger an update (see 3.5).\n   If there is an existing route, first compare\
    \ gateways.  If this\n   datagram is from the same gateway as the existing route,\
    \ reinitialize\n   the timeout.  Next compare metrics.  If the datagram is from\
    \ the same\n   gateway as the existing route and the new metric is different than\n\
    \   the old one, or if the new metric is lower than the old one, do the\n   following\
    \ actions:\n      - adopt the route from the datagram.  That is, put the new\n\
    \        metric in, and set the gateway to be the host from which\n        the\
    \ datagram came.\n      - Initialize the timeout for the route.\n      - Set the\
    \ route change flag, and signal the output process to\n        trigger an update\
    \ (see 3.5).\n      - If the new metric is 16 (infinity), the deletion process\
    \ is\n        started.\n   If the new metric is 16 (infinity), this starts the\
    \ process for\n   deleting the route.  The route is no longer used for routing\
    \ packets,\n   and the deletion timer is started (see section 3.3).  Note that\
    \ a\n   deletion is started only when the metric is first set to 16.  If the\n\
    \   metric was already 16, then a new deletion is not started.  (Starting\n  \
    \ a deletion sets a timer.  The concern is that we do not want to reset\n   the\
    \ timer every 30 seconds, as new messages arrive with an infinite\n   metric.)\n\
    \   If the new metric is the same as the old one, it is simplest to do\n   nothing\
    \ further (beyond reinitializing the timeout, as specified\n   above).  However,\
    \ the 4BSD routed uses an additional heuristic here.\n   Normally, it is senseless\
    \ to change to a route with the same metric\n   as the existing route but a different\
    \ gateway.  If the existing route\n   is showing signs of timing out, though,\
    \ it may be better to switch to\n   an equally-good alternative route immediately,\
    \ rather than waiting\n   for the timeout to happen.  (See section 3.3 for a discussion\
    \ of\n   timeouts.)  Therefore, if the new metric is the same as the old one,\n\
    \   routed looks at the timeout for the existing route.  If it is at\n   least\
    \ halfway to the expiration point, routed switches to the new\n   route.  That\
    \ is, the gateway is changed to the source of the current\n   message.  This heuristic\
    \ is optional.\n   Any entry that fails these tests is ignored, as it is no better\
    \ than\n   the current route.\n"
- title: 3.5. Output Processing
  contents:
  - "3.5. Output Processing\n   This section describes the processing used to create\
    \ response\n   messages that contain all or part of the routing table.  This\n\
    \   processing may be triggered in any of the following ways:\n      - by input\
    \ processing when a request is seen.  In this case,\n        the resulting message\
    \ is sent to only one destination.\n      - by the regular routing update.  Every\
    \ 30 seconds, a\n        response containing the whole routing table is sent to\n\
    \        every neighboring gateway.  (See section 3.3.)\n      - by triggered\
    \ updates.  Whenever the metric for a route is\n        changed, an update is\
    \ triggered.  (The update may be\n        delayed; see below.)\n   Before describing\
    \ the way a message is generated for each directly-\n   connected network, we\
    \ will comment on how the destinations are chosen\n   for the latter two cases.\
    \  Normally, when a response is to be sent to\n   all destinations (that is, either\
    \ the regular update or a triggered\n   update is being prepared), a response\
    \ is sent to the host at the\n   opposite end of each connected point-to-point\
    \ link, and a response is\n   broadcast on all connected networks that support\
    \ broadcasting.  Thus,\n   one response is prepared for each directly-connected\
    \ network and sent\n   to the corresponding (destination or broadcast) address.\
    \  In most\n   cases, this reaches all neighboring gateways.  However, there are\n\
    \   some cases where this may not be good enough.  This may involve a\n   network\
    \ that does not support broadcast (e.g., the ARPANET), or a\n   situation involving\
    \ dumb gateways.  In such cases, it may be\n   necessary to specify an actual\
    \ list of neighboring hosts and\n   gateways, and send a datagram to each one\
    \ explicitly.  It is left to\n   the implementor to determine whether such a mechanism\
    \ is needed, and\n   to define how the list is specified.\n   Triggered updates\
    \ require special handling for two reasons.  First,\n   experience shows that\
    \ triggered updates can cause excessive loads on\n   networks with limited capacity\
    \ or with many gateways on them.  Thus\n   the protocol requires that implementors\
    \ include provisions to limit\n   the frequency of triggered updates.  After a\
    \ triggered update is\n   sent, a timer should be set for a random time between\
    \ 1 and 5\n   seconds.  If other changes that would trigger updates occur before\n\
    \   the timer expires, a single update is triggered when the timer\n   expires,\
    \ and the timer is then set to another random value between 1\n   and 5 seconds.\
    \  Triggered updates may be suppressed if a regular\n   update is due by the time\
    \ the triggered update would be sent.\n   Second, triggered updates do not need\
    \ to include the entire routing\n   table.  In principle, only those routes that\
    \ have changed need to be\n   included.  Thus messages generated as part of a\
    \ triggered update must\n   include at least those routes that have their route\
    \ change flag set.\n   They may include additional routes, or all routes, at the\
    \ discretion\n   of the implementor; however, when full routing updates require\n\
    \   multiple packets, sending all routes is strongly discouraged.  When a\n  \
    \ triggered update is processed, messages should be generated for every\n   directly-connected\
    \ network.  Split horizon processing is done when\n   generating triggered updates\
    \ as well as normal updates (see below).\n   If, after split horizon processing,\
    \ a changed route will appear\n   identical on a network as it did previously,\
    \ the route need not be\n   sent; if, as a result, no routes need be sent, the\
    \ update may be\n   omitted on that network.  (If a route had only a metric change,\
    \ or\n   uses a new gateway that is on the same network as the old gateway,\n\
    \   the route will be sent to the network of the old gateway with a\n   metric\
    \ of infinity both before and after the change.)  Once all of\n   the triggered\
    \ updates have been generated, the route change flags\n   should be cleared.\n\
    \   If input processing is allowed while output is being generated,\n   appropriate\
    \ interlocking must be done.  The route change flags should\n   not be changed\
    \ as a result of processing input while a triggered\n   update message is being\
    \ generated.\n   The only difference between a triggered update and other update\n\
    \   messages is the possible omission of routes that have not changed.\n   The\
    \ rest of the mechanisms about to be described must all apply to\n   triggered\
    \ updates.\n   Here is how a response datagram is generated for a particular\n\
    \   directly-connected network:\n   The IP source address must be the sending\
    \ host's address on that\n   network.  This is important because the source address\
    \ is put into\n   routing tables in other hosts.  If an incorrect source address\
    \ is\n   used, other hosts may be unable to route datagrams.  Sometimes\n   gateways\
    \ are set up with multiple IP addresses on a single physical\n   interface.  Normally,\
    \ this means that several logical IP networks are\n   being carried over one physical\
    \ medium.  In such cases, a separate\n   update message must be sent for each\
    \ address, with that address as\n   the IP source address.\n   Set the version\
    \ number to the current version of RIP.  (The version\n   described in this document\
    \ is 1.)  Set the command to response.  Set\n   the bytes labeled \"must be zero\"\
    \ to zero.  Now start filling in\n   entries.\n   To fill in the entries, go down\
    \ all the routes in the internal\n   routing table.  Recall that the maximum datagram\
    \ size is 512 bytes.\n   When there is no more space in the datagram, send the\
    \ current message\n   and start a new one.  If a triggered update is being generated,\
    \ only\n   entries whose route change flags are set need be included.\n   See\
    \ the description in Section 3.2 for a discussion of problems\n   raised by subnet\
    \ and host routes.  Routes to subnets will be\n   meaningless outside the network,\
    \ and must be omitted if the\n   destination is not on the same subnetted network;\
    \ they should be\n   replaced with a single route to the network of which the\
    \ subnets are\n   a part.  Similarly, routes to hosts must be eliminated if they\
    \ are\n   subsumed by a network route, as described in the discussion in\n   Section\
    \ 3.2.\n   If the route passes these tests, then the destination and metric are\n\
    \   put into the entry in the output datagram.  Routes must be included\n   in\
    \ the datagram even if their metrics are infinite.  If the gateway\n   for the\
    \ route is on the network for which the datagram is being\n   prepared, the metric\
    \ in the entry is set to 16, or the entire entry\n   is omitted.  Omitting the\
    \ entry is simple split horizon.  Including\n   an entry with metric 16 is split\
    \ horizon with poisoned reverse.  See\n   Section 2.2 for a more complete discussion\
    \ of these alternatives.\n"
- title: 3.6. Compatibility
  contents:
  - "3.6. Compatibility\n   The protocol described in this document is intended to\
    \ interoperate\n   with routed and other existing implementations of RIP.  However,\
    \ a\n   different viewpoint is adopted about when to increment the metric\n  \
    \ than was used in most previous implementations.  Using the previous\n   perspective,\
    \ the internal routing table has a metric of 0 for all\n   directly-connected\
    \ networks.  The cost (which is always 1) is added\n   to the metric when the\
    \ route is sent in an update message.  By\n   contrast, in this document directly-connected\
    \ networks appear in the\n   internal routing table with metrics equal to their\
    \ costs; the metrics\n   are not necessarily 1.  In this document, the cost is\
    \ added to the\n   metrics when routes are received in update messages.  Metrics\
    \ from\n   the routing table are sent in update messages without change (unless\n\
    \   modified by split horizon).\n   These two viewpoints result in identical update\
    \ messages being sent.\n   Metrics in the routing table differ by a constant one\
    \ in the two\n   descriptions.  Thus, there is no difference in effect.  The change\n\
    \   was made because the new description makes it easier to handle\n   situations\
    \ where different metrics are used on directly-attached\n   networks.\n   Implementations\
    \ that only support network costs of one need not\n   change to match the new\
    \ style of presentation.  However, they must\n   follow the description given\
    \ in this document in all other ways.\n"
- title: 4. Control functions
  contents:
  - "4. Control functions\n   This section describes administrative controls.  These\
    \ are not part\n   of the protocol per se.  However, experience with existing\
    \ networks\n   suggests that they are important.  Because they are not a necessary\n\
    \   part of the protocol, they are considered optional.  However, we\n   strongly\
    \ recommend that at least some of them be included in every\n   implementation.\n\
    \   These controls are intended primarily to allow RIP to be connected to\n  \
    \ networks whose routing may be unstable or subject to errors.  Here\n   are some\
    \ examples:\n   It is sometimes desirable to limit the hosts and gateways from\
    \ which\n   information will be accepted.  On occasion, hosts have been\n   misconfigured\
    \ in such a way that they begin sending inappropriate\n   information.\n   A number\
    \ of sites limit the set of networks that they allow in update\n   messages. \
    \ Organization A may have a connection to organization B\n   that they use for\
    \ direct communication.  For security or performance\n   reasons A may not be\
    \ willing to give other organizations access to\n   that connection.  In such\
    \ cases, A should not include B's networks in\n   updates that A sends to third\
    \ parties.\n   Here are some typical controls.  Note, however, that the RIP protocol\n\
    \   does not require these or any other controls.\n      - a neighbor list - the\
    \ network administrator should be able\n        to define a list of neighbors\
    \ for each host.  A host would\n        accept response messages only from hosts\
    \ on its list of\n        neighbors.\n      - allowing or disallowing specific\
    \ destinations - the network\n        administrator should be able to specify\
    \ a list of\n        destination addresses to allow or disallow.  The list would\n\
    \        be associated with a particular interface in the incoming\n        or\
    \ outgoing direction.  Only allowed networks would be\n        mentioned in response\
    \ messages going out or processed in\n        response messages coming in.  If\
    \ a list of allowed\n        addresses is specified, all other addresses are disallowed.\n\
    \        If a list of disallowed addresses is specified, all other\n        addresses\
    \ are allowed.\n"
- title: REFERENCES and BIBLIOGRAPHY
  contents:
  - "REFERENCES and BIBLIOGRAPHY\n   [1] Bellman, R. E., \"Dynamic Programming\",\
    \ Princeton University\n       Press, Princeton, N.J., 1957.\n   [2] Bertsekas,\
    \ D. P., and Gallaher, R. G., \"Data Networks\",\n       Prentice-Hall, Englewood\
    \ Cliffs, N.J., 1987.\n   [3] Braden, R., and Postel, J., \"Requirements for Internet\
    \ Gateways\",\n       USC/Information Sciences Institute, RFC-1009, June 1987.\n\
    \   [4] Boggs, D. R., Shoch, J. F., Taft, E. A., and Metcalfe, R. M.,\n      \
    \ \"Pup: An Internetwork Architecture\", IEEE Transactions on\n       Communications,\
    \ April 1980.\n   [5] Clark, D. D., \"Fault Isolation and Recovery,\" MIT-LCS,\
    \ RFC-816,\n       July 1982.\n   [6] Ford, L. R. Jr., and Fulkerson, D. R., \"\
    Flows in Networks\",\n       Princeton University Press, Princeton, N.J., 1962.\n\
    \   [7] Xerox Corp., \"Internet Transport Protocols\", Xerox System\n       Integration\
    \ Standard XSIS 028112, December 1981.\n"
