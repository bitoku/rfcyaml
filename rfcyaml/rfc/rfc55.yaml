- title: __initial_text__
  contents:
  - "                A Prototypical Implementation of the NCP\n   While involved in\
    \ attempting to specify the formal protocol, we also\n   attempted to formulate\
    \ a prototypical NCP in an Algol-like language.\n   After some weeks of concentrated\
    \ effort, the project was abandoned as\n   we realized that the code was becoming\
    \ unreadable.  We still,\n   however, felt the need to demonstrate our conception\
    \ of how an NCP\n   might be implemented; we felt that this would help suggest\
    \ solutions\n   for problems that might arise in trying to mold the formal\n \
    \  specifications into an existing system.  This document is that\n   attempt\
    \ to specify in a prose format what an NCP could look like.\n   There are obvious\
    \ limitations on a project of this nature.  We do\n   not, and cannot, know all\
    \ of the quirks of the various systems that\n   must write an NCP.  We are forced\
    \ to make some assumptions about the\n   environment, system calls, and the like.\
    \  We have tried to be as\n   general as possible, but no doubt many sites will\
    \ have completely\n   different ways of conceptualizing the NCP.  There is great\
    \ difficulty\n   involved in conveying our concepts and the mechanisms that deal\
    \ with\n   these concepts to people who have wholly different ways of looking\
    \ at\n   things.  We have, however, benefited greatly by trying to actually\n\
    \   code this program for our fictitious machine.  Many unforeseen\n   problems\
    \ surfaced during the coding, and we hope that by issuing this\n   document we\
    \ can help to alleviate similar problems which may arise in\n   individual cases.\n\
    \   There is, of course, absolutely no requirement to implement anything\n   which\
    \ is contained in this document.  The only rigid rules which an\n   NCP _must_\
    \ conform to are stated in NWG/RFC#54.  This description is\n   intended only\
    \ as an example, _not_ as a model.\n   In the discussion which follows we first\
    \ describe the environment to\n   be assumed and postulate a set of system calls.\
    \  We discuss the\n   overall architecture of the NCP and the tables that will\
    \ be used to\n   hold relevant information.  Narratives of network operations\
    \ follow.\n   A state diagram is then presented as a convenient method for\n \
    \  conceptualizing the cause-effect sequencing of events.  The detailed\n   processing\
    \ of each type of network event (system calls or incoming\n   network messages)\
    \ is then discussed.\n"
- title: II. Environment
  contents:
  - "II. Environment\n   We assume that the host will have a time-sharing operating\
    \ system in\n   which the CPU is shared by processes.\n   We envision that each\
    \ process is tagged with a user number.  There\n   may be more than one process\
    \ with the same user number; if so, they\n   should all be cooperating with respect\
    \ to using the network.\n   We envision that each process contains a set of ports\
    \ which are\n   unique to the process.  These ports are used for input to or output\n\
    \   from the process, from or to files, devices, or other processes.\n   We also\
    \ envision that a process is not put to sleep (i.e., blocked or\n   dismissed)\
    \ when it attempts to LISTEN or CONNECT.  Instead it is\n   informed when some\
    \ action is complete.  Of course, a process may\n   dismiss itself so that it\
    \ wakes up only on some external event.\n   To engage in network activity, a process\
    \ attaches a local socket to\n   one of its ports.  Sockets are identified by\
    \ user number, host and\n   AEN; a socket is local to a process if the user numbers\
    \ of the two\n   match and they are in the same host.  Thus, a process need only\n\
    \   specify an AEN when it is referring to a local socket.\n   Each port has a\
    \ status which is modified by system calls and\n   concurrent events outside the\
    \ process (e.g., a 'close connection'\n   command from a foreign host).  The process\
    \ may look at a port's\n   status as any time (via the STATUS system call).\n\
    \   We assume a one-to-one correspondence between ports and sockets.\n"
- title: III. System Calls
  contents:
  - "III. System Calls\n   These are typical system calls which a user process might\
    \ execute.\n         We use the notation\n                  SYSCALL (ARG1, ARG2....)\n\
    \         where\n                  SYSCALL is the name of the system call\n  \
    \       and\n                  ARGk, etc. are the parameters of the system call.\n\
    \   CONNECT (P, AEN, FS, CR)\n         P        specifies a port of the process\n\
    \         AEN      specifies a local socket; the user number and host are\n  \
    \                implicit\n         FS       specifies a socket with any user\
    \ number in any hose,\n                  and with any AEN\n         CR       the\
    \ condition code returned\n      CONNECT attempts to attach the local socket specified\
    \ by AEN to\n      the port P and to initiate a connection with a specific foreign\n\
    \      socket, FS.  Possible values of CR are:\n         CR=OK          The CONNECT\
    \ was legal and the socket FS is being\n                        contacted.  When\
    \ the connection is established\n                        or refused the status\
    \ will be updated.\n         CR = BUSY      The local socket is in use (illegal\
    \ command\n                        sequence).\n         CR = BADSKT    The socket\
    \ specification was illegal.\n         CR = NOROOM    Local host's resources are\
    \ exhausted.\n         CR = HOMOSEX   Incorrect send/receive pair\n         CR\
    \ = IMP DEAD  Our imp has died\n         CR = LINK DEAD The link to the foreign\
    \ host is dead because:\n                        1. the foreign Imp is dead,\n\
    \                        2. the foreign host is dead, or\n                   \
    \     3. the foreign NCP does not respond.\n   LISTEN (P, AEN, CR)\n         P\
    \             specifies a port of the process\n         AEN           specifies\
    \ a local socket\n         CR            the condition code returned\n      The\
    \ local socket specified by AEN is attached to port P.  If there\n      is a pending\
    \ call, it is processed; otherwise, no action is taken.\n      When a call comes\
    \ in, the user will be notified.  After examining\n      the call, he may either\
    \ accept or refuse it.  Possible values of\n      CR are:\n         CR = OK  \
    \       Connection begun, listening\n         CR = BUSY\n         CR = NOROOM\n\
    \         CR = IMP DEAD\n         CR = LINK DEAD\n   ACCEPT (P, CR)\n        \
    \ P       specifies a port of the process\n         CR      the condition code\
    \ returned\n      Accept implies that the user process has inspected the foreign\n\
    \      socket to determine who is calling and will accept the call.\n      (Note:\
    \ an interesting alternative defines ACCEPT as the implicit\n      default condition.\
    \  Thus any incoming RFC automatically satisfies\n      a LISTEN.)  Possible values\
    \ of CR are:\n         CR = BADSKT\n         CR = NOROOM\n         CR = IMP DEAD\n\
    \         CR = LINK DEAD\n         CR = BADCOMM   Illegal command sequence. (E.g.,\
    \ Accept issued\n                        before a LISTEN.\n         CR = PREMCLS\
    \   Foreign user aborted connection after RFC was\n                        locally\
    \ received but before Accept was executed.\n   TRANSMIT (P, BUFF, BITSRQST, BITSACC,\
    \ CR)\n         P        specifies a port of the process\n         BUFF     specifies\
    \ the text buffer for transmission\n         BITSRQST specifies the length to\
    \ be transmitted in bits\n         BITSACC  returns the number of bits actually\
    \ transmitted\n         CR       the condition code returned\n       Transmission\
    \ takes place.   Possible values for CR are:\n         CR = OK\n         CR =\
    \ IMP DEAD\n         CR = LINK DEAD\n         CR = NOT OPEN  Connection is not\
    \ open (illegal command\n                        sequence).\n         CR = BAD\
    \ BOUND BITSRQST out of bounds (e.g., for a receive\n                        socket\
    \ BUFF was shorter than BITSRQST\n                        indicated).\n   INT\
    \ (P, CR)\n         P       specifies the local socket of this process\n     \
    \    CR      the condition code returned\n      The process on the other (foreign)\
    \ side of this port is to be\n      interrupted.  Possible values of CR are:\n\
    \         CR = OK\n         CR = BADSKT\n         CR = BADCOMM\n         CR =\
    \ IMP DEAD\n         CR = LINK DEAD\n   STATUS (P, RTAB, CR)\n         P     \
    \  specifies a port of this process\n         RTAB    the returned rendezvous\
    \ table entry\n         CR      the condition code returned\n      The relevant\
    \ fields of the rendezvous table entry associated with\n      this port are returned\
    \ in RTAB.  This is the mechanism a user\n      process employs for monitoring\
    \ the state of a connection.\n      Possible values of CR are:\n         CR =\
    \ OK\n         CR = BADSKT\n   CLOSE (P, CR)\n         P       specifies a port\
    \ of this process\n         CR      the condition code returned\n      Activity\
    \ on the connection attached to this port stops, the\n      connection is broken\
    \ and the port becomes free for other use.\n      Possible values of CR are:\n\
    \         CR = OK\n         CR = BADSKT\n         CR = BADCOMM\n         CR =\
    \ IMP DEAD\n         CR = LINK DEAD\n"
- title: IV.  The NCP - Gross Structure
  contents:
  - "IV.  The NCP - Gross Structure\n   We view the NCP as having five component programs,\
    \ several\n   associative tables, and some queues and buffers.\n      The Component\
    \ Programs (see Fig. 4.1)\n      1. The Input Handler\n         This is an interrupt-driven\
    \ routine.  It initiates Imp-to-Host\n         transmission into a resident buffer\
    \ and wakes up the input\n         interpreter when transmission is complete.\n\
    \      2. The Output Handler\n         This is an interrupt-driven output routine.\
    \  It initiates Host-\n         to-Imp transmission out of a resident buffer and\
    \ wakes up the\n         output scheduler when transmission is complete.\n   \
    \   3. The Input Interpreter\n         This program decides whether the input\
    \ is a regular message\n         intended for a user, a network control message,\
    \ an Imp-to Host\n         message, or an error.  For each class of message this\
    \ program\n         invokes a subroutine to take the appropriate action.\n   \
    \   4. The Output Scheduler\n         Three classes of messages are sent to the\
    \ Imp\n            (a) Host-to-Imp messages\n            (b) Control messages\n\
    \            (c) Regular messages\n         We believe that a priority should\
    \ be imposed among these\n         classes.  The priority we suggest is the ordering\
    \ above.  The\n         output scheduler selects the highest priority message\
    \ and\n         passes it to the output handler.\n         Host-to-Imp messages\
    \ are processed first come first served.\n         Control messages are processed\
    \ individually by host, each host\n         being taken in turn.  A control message\
    \ queue for each foreign\n         host is provided.  When any particular host\
    \ is scheduled for\n         output, as many control commands for that host as\
    \ will fit are\n         concatenated into a single message.  Regular messages\
    \ are\n         processed in groups by host and link, each unique combination\n\
    \         being taken in turn.\n      5. The System Call Interpreter\n       \
    \  This program interprets requests from the user.  Each system\n         call\
    \ has a corresponding routine which takes the appropriate\n         action.\n\
    \      The two interesting components are the input interpreter and the\n    \
    \  system call interpreter.  These are similar in that the input\n      interpreter\
    \ services foreign requests and the system call\n      interpreter services local\
    \ requests.\n      The diagram in Figure 4.1  is our conception of the Network\n\
    \      Control Program.  Squishy amoeba-like objects represent component\n   \
    \   programs, cylinders represent queues, and the arrows represent\n      data\
    \ paths.  In this simplified diagram tables are not shown.\n      [\"Amoeba-like\"\
    \ objects in original hand drawing are now firm\n      rectangular boxes: Ed.]\n\
    \      The abbreviated labels in the figure have the following meanings:\n   \
    \         HIQ       -     Host-to-Imp Queue\n            OCCQ      -     Output\
    \ Control Command Queue\n            DQ        -     Data Queue\n            IHBUF\
    \     -     Input Handler Buffer\n            OHBUF     -     Output Handler Buffer\n\
    \             ____________\n            |    USER    |    STRUCTURE OF THE NETWORK\
    \ CONTROL PROGRAM\n            |____________|\n               ^      |       \
    \               Fig. 4.1\n          _____|______V____\n         |            \
    \     |\n         |     System      |\n         |      Call       |\n        \
    \ |   Interpreter   |\n         |_________________|              _____________\n\
    \            ^  |      |                  |             |\n            |  |  \
    \    |  +---------------|    Input    |\n            |  |      |  |         +-----|\
    \ Interpreter |\n            |  |      |  |         |     |             |\n  \
    \          |  V      V  V         V      -------------\n          |======| |=========|\
    \ |=======|     |      ^\n          | D Q  | | O C C Q | | H I Q |     |     \
    \ |\n          |======| |=========| |=======|     |      |\n            |  ^ \
    \       |          |         |      |\n            |  |        |          |  \
    \       |      |\n            |  +--------)----------)---------+      |\n    \
    \        |           |          |                |\n            +-------+   |\
    \   +------+                |\n                  __V___V___V__               \
    \      |\n                 |             |                    |\n            \
    \     |   Output    |                    |\n                 |  Scheduler  | \
    \                   |\n                 |_____________|                    |\n\
    \                        |                           |\n                     \
    \   V                           |\n                  (===========)           \
    \    (===========)\n                  ( O H B U F )               ( I H B U F\
    \ )\n                  (===========)               (===========)\n           \
    \             |                           ^\n                  ______V______ \
    \              ______|______\n                 |             |             | \
    \            |\n                 |   Output    |             |    Input    |\n\
    \                 |   Handler   |             |   Handler   |\n              \
    \   |             |             |             |\n                  -------------\
    \               -------------\n                        |                     \
    \      ^\n                        |                           |\n            \
    \            +----------+    +-----------+\n                                 \
    \  |    |\n                               ____V____|____\n                   \
    \           |              |\n                              |     I M P    |\n\
    \                              |______________|\n"
- title: V. Tables in the NCP
  contents:
  - "V. Tables in the NCP\n   We envision that the bulk of the NCP's data base is\
    \ in associative\n   tables.  By \"associative\" we mean that there is some lookup\
    \ routine\n   which is presented with a key and either returns successfully with\
    \ a\n   pointer to the corresponding entry, or fails if no entry corresponds\n\
    \   to the key.  The major tables are as follows:\n      1. The Rendezvous Table\n\
    \         This table holds the attributes of a connection.  The table is\n   \
    \      accessed by the local socket, but other tables may have\n         pointers\
    \ to existing entries.\n         The components of an entry are:\n           \
    \ (a) Local Socket\n            (b) Foreign Socket\n            (c) Link\n   \
    \         (d) Connection State\n            (e) Flow State\n            (f) Data\
    \ Queue\n            (g) Call Queue\n            (h) Port Pointer\n          \
    \  (i) Their Buffer Size (only needed on the send side)\n            (j) Error\
    \ State\n         An entry is created when either a CONNECT or a LISTEN system\n\
    \         call is executed or when a request for connection is received.\n   \
    \      Various fields remain unused until after the connection is\n         established.\n\
    \      2. The Input Link Table\n         The input interpreter uses the concatenation\
    \ of the foreign\n         host and link as a key into the input table.  The table\
    \ is used\n         in processing a user-destined message on an incoming link\
    \ by\n         providing a pointer into the rendezvous table.\n      3. The Output\
    \ Link Table\n         The input interpreter uses the output link table to access\
    \ the\n         flow state as RFNM's return from transmitted messages.  The\n\
    \         output link table is keyed by host and link and provides a\n       \
    \  pointer into the rendezvous table.\n      4. The Port Table\n         The system\
    \ call interpreter uses the concatenation of the\n         process identification\
    \ and the port identification as a key to\n         obtain a pointer into the\
    \ rendezvous table.\n      5. The Output Control Command Table\n         The system\
    \ call interpreter and the input interpreter use this\n         table to make\
    \ entries in the appropriate output control command\n         queues.  Commands\
    \ are queued in separate table entries\n         corresponding to foreign hosts.\
    \  Before output the contents of\n         the queue are concatenated into a large\
    \ control message.  The\n         components of an entry are:\n            (a)\
    \  Host\n            (b)  Output Control Command Queue\n      6. The Output Request\
    \ Queue\n         This queue contains an entry for each connection which has data\n\
    \         requiring transmission to the net.  There is only one entry per\n  \
    \       connection, which is deleted when the last packet of data is\n       \
    \  transmitted and is entered whenever a user makes a system\n         request\
    \ for data transmission.\n         The entry is re-inserted if transmission is\
    \ not completed\n         (message too long) or is prevented by the flow control\n\
    \         mechanism.  The only component of an entry is a local socket.\n    \
    \  7. The Host Live Table\n         This is a simple table listing the hosts which\
    \ are alive.  This\n         table is checked before establishing a connection\
    \ and before\n         sending any data to ensure that the destination host actually\n\
    \         exists.  At present the protocol does not define the procedure\n   \
    \      to be followed for the Host up/Host down conditions.  See\n         NWG/RFC#57.\n\
    \      8. The Link Assignment Table\n         Link numbers are assigned by the\
    \ receiver.  This table records\n         which links are free and can, therefore,\
    \ be assigned.\n"
- title: VI.  Informal Description of Network Operations
  contents:
  - "VI.  Informal Description of Network Operations\n   We present here narratives\
    \ describing the operation conducted during\n   the three major phases of network\
    \ usage: opening, flow control, and\n   closing.\n   A. Opening\n      In order\
    \ to establish a connection for data transmission, a pair\n      of RFC's must\
    \ be exchanged.  An RTS must go from the receive-side\n      to the send-side,\
    \ and an STR must be issued by the send-side to\n      the receive-side.  In addition,\
    \ the receive-side, in its RTS, must\n      specify a link number.  These RFC's\
    \ (RFC is a generic term\n      encompassing RTS and STR) may be issued in any\
    \ time sequence.  A\n      provision must also be made for queuing pending calls\
    \ (i.e., RFC's\n      which have not been dealt with by the user program).  Thus,\
    \ when a\n      user is finished with a connection, he may choose to examine the\n\
    \      next pending call from another process and decide to either accept\n  \
    \    or refuse the request for connection.  A problem develops because\n     \
    \ the user may not choose to examine his pending calls; thus they\n      will\
    \ merely serve to occupy queue space in the NCP.  Several\n      alternative solutions\
    \ to this problem will be mentioned later.\n      Utilizing the framework of the\
    \ prototype system calls described\n      above, we envision at least four temporal\
    \ sequences for obtaining\n      a successfully opened connection:\n         1.\
    \ The user may issue a LISTEN, indicating he is willing to\n            consider\
    \ connecting to anyone who sends him an RFC.  When an\n            RFC comes in\
    \ the user is notified.  The user then decides\n            whether he wishes\
    \ to connect to this socket and issues an\n            ACCEPT or a CLOSE on the\
    \ basis of that decision.  A CLOSE '\n            refuses' the connection, as\
    \ discussed under \"Closing.\"  An\n            ACCEPT indicates he is willing\
    \ to connect; an RFC is issued,\n            and the connection becomes fully\
    \ opened.\n         2. Upon processing a user request for a LISTEN, the NCP\n\
    \            discovers that a pending call exists for that local socket.\n   \
    \         The user is immediately notified, and he may ACCEPT or\n           \
    \ CLOSE, as above.\n         3. The user issues a CONNECT, specifying a particular\
    \ foreign\n            socket that he would like to connect to.  An RFC is issued.\n\
    \            If the foreign process accepts the request, it answers by\n     \
    \       returning an RFC.  When this acknowledging RFC is received,\n        \
    \    the connection is opened.\n         4. When presented with a CONNECT, the\
    \ NCP may discover that a\n            pending call exists from the specified\
    \ foreign socket to the\n            local socket in question.  An acknowledging\
    \ RFC is issued\n            and the connection is opened.\n      In all of the\
    \ above cases the user is notified when the connection\n      is opened, but data\
    \ flow cannot begin until buffer space is\n      allocated and an ALL command\
    \ is transmitted.\n      Any of these connection scenarios will be interrupted\
    \ if a CLS\n      comes in, as discussed under \"Closing.\"\n         1. Pending\
    \ Call Queues\n            It is essential that some form of queuing for pending\
    \ RFC's\n            be implemented.  A simple way to see this is to examine a\n\
    \            typical LISTEN-CONNECT sequence.  One side issues a LISTEN,\n   \
    \         the other a CONNECT.  If the LISTEN is issued before the RFC\n     \
    \       coming from the remote CONNECT arrives, all is fine.\n            However,\
    \ due to the asynchronous nature of the net, we can\n            never guarantee\
    \ that this sequence of events will occur.  If\n            calls are not queued,\
    \ and the RFC comes in before the LISTEN\n            is issued, it will be refused;\
    \ if it arrives later, it will\n            be accepted.  Thus we have an extremely\
    \ ambiguous situation.\n            Unless one has infinite queue space, it is\
    \ desirable that\n            some mechanism for purging the queues of old RFC's\
    \ which the\n            user never bothered to examine.  An obvious but informal\n\
    \            method is to note the time when each RFC is entered into the\n  \
    \          queue, and then periodically refuse all RFC's which have\n        \
    \    exceeded some arbitrary time limit.  Another thought, which\n           \
    \ probably should be included within the context of any\n            scheme, is\
    \ for the NCP to send a CLS on all outstanding\n            connections or pending\
    \ calls when a user logs out or blows\n            up.\n            The scheme\
    \ which is utilized in this description may seem at\n            first blush to\
    \ be non-intuitive; but we feel it is more\n            realistic than other proposals.\
    \  Basically, when a CONNECT\n            is issued, the NCP assumes that this\
    \ socket wishes to talk\n            to the specified foreign socket and to that\
    \ socket only.  It\n            therefore purges from the pending call queue all\
    \ non-\n            matching RFC's by sending back CLS's.  Similarly, when the\n\
    \            connection is in the RFC-SEND state (a CONNECT has been\n       \
    \     issued), all non-matching RFC's are refused.  If a LISTEN-\n           \
    \ ACCEPT or LISTEN- CLOSE sequence is executed, the remainder\n            of\
    \ the pending calls are not removed from the queue, in the\n            expectation\
    \ that the user may wish to accept these requests\n            in the future.\n\
    \            Although the latter method may seem to be arbitrary and/or\n    \
    \        unnecessarily restrictive, we have not yet concocted a\n            scenario\
    \ which would be prohibited by this method, assuming\n            that we are\
    \ dealing with a competent programmer (i.e., one\n            who is wary of race\
    \ conditions and the asynchronous nature\n            of the net).  Of course\
    \ whatever scheme or schemes a\n            particular site chooses is highly\
    \ implementation dependent;\n            we suggest that some provision for the\
    \ queuing of RFC's be\n            provided for a period of time at least of the\
    \ order of\n            magnitude that they are retained in the CONNECT-clear\
    \ scheme\n            mentioned above.\n   B. Flow Control\n      Meaningful data\
    \ can only flow on a connection when it is fully\n      opened (i.e., two RFC's\
    \ have been exchanged and closing has not\n      begun).  We assume that the NCP's\
    \ have a buffer for receiving\n      incoming data and that there is some meaningful\
    \ quantity which\n      they can advertise (on a per connection basis) indicating\
    \ the size\n      message they can handle.  We further assume that the sending\
    \ side\n      regulates its transmission according to the advertisements of that\n\
    \      size.\n      When a connection is opened, a cell (called 'Their Size')\
    \ is set\n      to zero.  The receive-side will decide how much space it can\n\
    \      allocate and send an ALL message specifying that space.  The\n      send-side\
    \ will increment 'Their Size' by the allocated space and\n      will then be able\
    \ to send messages of length less than or equal to\n      'Their Size' When messages\
    \ are transmitted, the length of the\n      message is subtracted from 'Their\
    \ Size'.  When the receive-side\n      allocates more buffer space (e.g. when\
    \ a message is taken by the\n      user, thus freeing some system buffer space),\
    \ the number of bits\n      released is sent to the send-side via an ALL message.\n\
    \      Thus, 'Their Size' is never allowed to become negative and no\n      transmission\
    \ can take place if 'Their Size' equals zero.\n      Notice that the lengths specified\
    \ in ALL messages are increments\n      not the absolute size of the receiving\
    \ buffer.  This is\n      necessitated  by the full duplex nature of the flow\
    \ control\n      protocol.  The length field of the ALL message can be 32 bits\
    \ long\n      (note: this is an unsigned integer), thus providing the facility\n\
    \      for essentially an infinite \"bit sink\", if that may ever be\n      desired.\n\
    \   C. Closing\n      Just as two RFC's are required to open a connection, two\
    \ CLS's are\n      required to close a connection.  Closing occurs under various\n\
    \      circumstances and serves several purposes.  To simplify the\n      analysis\
    \ of race conditions, we distinguish four cases: aborting,\n      refusing, termination\
    \ by receiver, termination by sender.\n      A user \"aborts\" a connection when\
    \ he issues a CONNECT and then a\n      CLOSE before the CONNECT is acknowledged.\
    \  Typically a user will\n      abort following an extended wait for the acknowledgment;\
    \ his\n      system may also abort for him if he blows up.\n      A user \"refuses\"\
    \ a connection when he issues a LISTEN and, after\n      being notified of a prospective\
    \ caller, issues a CLOSE.  Any\n      requests for connection to a socket which\
    \ is expecting a call from\n      a particular socket are also refused.\n    \
    \  After a connection is established, either side may terminate.  The\n      required\
    \ sequence of events suggests that attempts to CLOSE by the\n      receive-side\
    \ should be viewed as \"requests\" which are always\n      honored as soon as\
    \ possible by the send-side.  Any data which has\n      not yet been passed to\
    \ the user, or which continues over the\n      network, is discarded.  Requests\
    \ to CLOSE by the send-side are\n      honored as soon as all data transmission\
    \ is complete.\n         1. Aborting\n            We may distinguish three cases:\n\
    \            a) In the simplest case, we send an RFC followed later by a\n   \
    \            CLS.  The other side responds with a CLS and the attempt\n      \
    \         to connect ends.\n            b) The foreign process may accept the\
    \ connection\n               concurrently with the local process aborting it.\
    \  In this\n               case, the foreign process will believe the local process\n\
    \               is terminating an open connection.\n            c) The foreign\
    \ process may refuse the connection\n               concurrently with the local\
    \ process aborting it.  In this\n               case, the foreign process will\
    \ believe the local process\n               is acknowledging its refusal.\n  \
    \       2. Refusing\n            After an RFC is received, the local host may\
    \ respond with an\n            RFC or a CLS, or it may fail to respond.  (The\
    \ local host\n            may have already sent its own RFC, etc.)  If the local\
    \ host\n            sends a CLS, the local host is said to be \"refusing\" the\n\
    \            request for connection.\n            We require that CLS commands\
    \ be exchanged to close a\n            connection, so it is necessary for the\
    \ local host to\n            maintain the rendezvous table entry until an acknowledging\n\
    \            CLS is returned.\n         3. Terminating by the Sender\n       \
    \     When the user on the send side issues a CLOSE system call,\n           \
    \ his NCP must accept it immediately, but may not send out a\n            CLS\
    \ command until all the data in the local buffers has been\n            passed\
    \ to the foreign host.  It is thus necessary to test\n            for both 'buffer-empty'\
    \ and\n            'RFNM-received' before sending the CLS command.  As usual,\n\
    \            the CLS must be acknowledged before the entry may be\n          \
    \  deleted.\n         4. Terminating by the Receiver\n            When the user\
    \ on the receive side issues a CLOSE system\n            call, his NCP accepts\
    \ and sends the CLS command immediately.\n            Data may still arrive, however,\
    \ and this data should be\n            discarded.  The send side, upon receiving\
    \ the CLS, should\n            immediately terminate the data flow.\n"
- title: VII. Connection Status
  contents:
  - "VII. Connection Status\n   An excellent mechanism for describing the sequence\
    \ of events required\n   to establish and terminate a connection involves a state\
    \ diagram.  We\n   may assume that each socket can be associated with a state\
    \ machine,\n   and that this state machine may, at any time, be in one of ten\n\
    \   possible states.  In any state, certain network events cause the\n   connection\
    \ status to enter another state; other events are ignored;\n   still others are\
    \ error.  A transition may also involve the local NCP\n   performing some action.\
    \  Figure 7.1 depicts the state machine.\n   Circles [now boxes: Ed] represent\
    \ states (described below); arrows\n   show legal transitions between states.\
    \  The labels on the arrows\n   identify the event which caused them (note that\
    \ CLOSE is a system\n   call, CLS is a control command).  Phrases after slashes\
    \ denote the\n   action which should  be performed while traveling over that arrow.\n\
    \   The arrow labeled '[E]RFC' (found between states 0 and 1) represents\n   the\
    \ condition that whenever a connection enters the CLOSED state, the\n   pending\
    \ call queue for that connection is checked [Original was\n   backwards \"E\"\
    : Ed.]\n   If any pending calls exist in the queue, the connection moves to the\n\
    \   PENDING state.  If an RFC is received for a socket in the CLOSED\n   state,\
    \ it is also moved along this path to the PENDING state.  Events\n   and the actions\
    \ they cause are described in sections VIII and IX\n   below.  Descriptions of\
    \ the ten states follow:\n      (0) CLOSED\n          The local socket is not\
    \ attached to any port and no user has\n          requested a connection with\
    \ it.  (The table entry is non-\n          existent).\n      (1) PENDING CALL\n\
    \          The socket is not attached to any port but one or more\n          requests\
    \ for connection have been received.  A LISTEN system\n          call will be\
    \ satisfied immediately by the first entry in the\n          pending call queue\
    \ for a matching request; all other pending\n          calls are deleted.\n  \
    \    (2) LISTENING\n          The socket is attached to a port.  We are waiting\
    \ for a user\n          to request connection with this socket.\n      (3) RFC-RCVD\n\
    \          We are listening and an RFC was received.  The local user has\n   \
    \       been informed of the pending call.  He must respond with\n          either\
    \ a CLOSE or an ACCEPT.\n      (4) ABORT\n          We have notified the user\
    \ that his LISTEN has been satisfied\n          but he has not yet responded;\
    \ if during this time the foreign\n          user aborts the connection by sending\
    \ a CLS, we send a CLS to\n          acknowledge the abort and mark the fact with\
    \ this state.  When\n          the user accepts or refuses the call, we can inform\
    \ him the\n          connection has been prematurely terminated.\n      (5) RFC-SENT\n\
    \          This state is entered when:\n          a)  The local user has attached\
    \ this socket to a port by\n              issuing a CONNECT.\n          b)  An\
    \ RFC has been sent, and\n          c)  No reply has been received.\n        \
    \  When the user issues a CONNECT the pending call queue is\n          searched.\n\
    \          If a matching RFC is not found, the queue is deleted and this\n   \
    \       state is entered.  As new RFC's arrive they are compared with\n      \
    \    our user's request.  If they do not match, the RFC is\n          immediately\
    \ refused.  If the RFC matches, it completes the\n          initialization process\
    \ and the connection enters the OPEN\n          state.\n      (6) OPEN\n     \
    \     RFC's have been exchanged and the connection is securely\n          established.\
    \  Transmission may begin following receipt of an\n          ALL command from\
    \ the receive side, and will then proceed\n          subject to flow control.\n\
    \      (7) CLS-WAIT\n          After the local user has executed a CLOSE, and\
    \ we have issued\n          a CLS, we must wait for an acknowledging CLS before\
    \ the\n          connection can be completely closed.   If the appropriate CLS\n\
    \          has not already been received, this state is entered.\n      (8) DATA-WAIT\n\
    \          If we are on the send side and the local user executes a CLOSE\n  \
    \        system call, a CLS cannot be issued if our data buffer is not\n     \
    \     empty or if a RFNM for the last data message is outstanding.\n         \
    \ The connection enters this state to wait for these conditions\n          to\
    \ be fulfilled.  Upon completion and acknowledgement of\n          output a CLS\
    \ may be issued and the connection enters the CLS-\n          WAIT state, waiting\
    \ for the acknowledging CLS.   If a CLS\n          arrives while in the DATA-WAIT\
    \ state we clear our buffer (the\n          CLS came from a receive socket, indicating\
    \ it is no longer\n          interested in our data) and enter the RFNM-WAIT state\
    \ to wait\n          for the network to clear.\n      (9) RFNM-WAIT\n        \
    \  If we are on the send side and a CLS command arrives, we\n          cannot\
    \ issue an acknowledging CLS if we have not received the\n          RFNM for our\
    \ last data message.  We enter this state to await\n          the RFNM, and cease\
    \ all further data transmission.  When the\n          RFNM comes in, a CLS may\
    \ then be issued, and the connection\n          will be closed.\n            \
    \          ______________\n                     |              |       CLOSE\n\
    \      CONN/          |    CLOSED    |<---------------------------+\n      send\
    \ RFC       |     (0)      |       LISTEN               |\n    +----------------|\
    \              |-----------------------+    |\n    |                |______________|\
    \                       |    |\n    |                     |    ^             \
    \               |    |\n    |              [E]RFC |    |  CLS/send CLS       \
    \       |    |\n    |                  ___V____|____                     ___V____|____\n\
    \    |  non-matching   |             |                   |             |\n   \
    \ |  CONN/send RFC  |   PENDING   | LISTEN        RFC |  LISTENING  |\n    | \
    \  +-------------|    (1)      |----------+   +----|     (2)     |\n    |   |\
    \             |_____________|          |   |    |_____________|\n    |   |   \
    \    matching     |                 |   |\n ___V___V_____  CONN/send RFC|    \
    \           __V___V______\n"
- title: '|             |              |     ACCEPT/  |             | CLS/'
  contents:
  - '|             |              |     ACCEPT/  |             | CLS/

    '
- title: '|   RFC-SENT  | RFC          |     send RFC |   RFC-RECD  | send CLS'
  contents:
  - '|   RFC-SENT  | RFC          |     send RFC |   RFC-RECD  | send CLS

    '
- title: '|     (5)     |----------+   |   +----------|     (3)     |---------+'
  contents:
  - '|     (5)     |----------+   |   +----------|     (3)     |---------+

    '
- title: '|_____________|          |   |   |          |_____________|         |'
  contents:
  - "|_____________|          |   |   |          |_____________|         |\n   | \
    \  |                 |   |   |               |                  |\n   |   |  \
    \            ___V___V___V___  SND&CLOSE |   ____________   |\n   |   |    RCV&CLS/\
    \ |               |-----------)->|            |  |\n   |   |    send CLS |   \
    \   OPEN     | SND&CLS   |  |  DATA-WAIT |  |\n   |   |   +---------|      (6)\
    \      |--------+  |  |    (8)     |  |\n   |   |   |         |_______________|\
    \        |  |  |____________|  |\n   |   |   |      RCV&CLOSE/ |             \
    \   |  |   |              |\n   |   |   |       send CLS  |                | \
    \ |   |              |\n   |   |   |                 |                |  |   |\
    \ CLS          |\n   |   |   |           ______V______          |  |   |     \
    \         |\n   |   |   |   CLOSE/ |             |CLOSE/   |  |   |          \
    \    |\n   |   |   |  send CLS|   CLS-WAIT  |send CLS |  |   |              |\n\
    \   |   +---)--------->|     (8)     |<--------)--+   |              |\n   | \
    \      |          |_____________|         |      |              |\n   |      \
    \ |                 |             ___V______V_       ______V___\n   |       |\
    \                 |            |            |     |          |\n   |       | \
    \                |            |  RFNM-WAIT |     |   ABORT  |\n   |       |  \
    \           CLS |            |     (9)    |     |    (4)   |\n   |       |   \
    \              |            |____________|     |__________|\n   |       |    \
    \             |                   |                 |\n   |       |          \
    \ ______V_______  RFNM/     |                 |\n   |       |          |     \
    \         | send CLS  |                 |\n   |  CLS/ +--------->|    CLOSED \
    \   |<----------+                 |\n   | send CLS         |     (0)      |  \
    \              ACCEPT|CLOSE |\n   +----------------->|              |<----------------------------+\n\
    \                      |______________|\n                         Figure 7.1\n\
    \                  Connection State Diagram\n"
- title: VIII.  Algorithms for the Input Interpreter
  contents:
  - "VIII.  Algorithms for the Input Interpreter\n   The following is a concise description\
    \ of the NCP's responses to\n   incoming network commands.  CS always indicates\
    \ Connection State.\n   Note, CLOSE is a system call executed by the local user\
    \ process, and\n   CLS is a network command.\n   NOP\n      Discard.\n   RFC (RTS\
    \ or STR)\n      If no entry exists, create one with status = PENDING CALL, and\n\
    \      queue the message.\n      If CS = LISTENING, then queue the entry, enter\
    \ the RFC-RCVD state,\n      and inform the user of the request.\n      If CS\
    \ = RFC-SENT but the new RFC does not match the request,\n      refuse the RFC.\n\
    \      In all other cases, check the RFC for a match.  If none exists,\n     \
    \ queue the RFC.  If the RFC matches, then if:\n         CS = RFC-SENT, we enter\
    \ the OPEN state.\n         CS = CLOSE-WAIT, the RFC is ignored.\n         otherwise,\
    \ the request is illegal in all states which indicate\n         it has already\
    \ been received (these states are 1,3,4,6,8,9).\n      In any case, if processing\
    \ the RFC causes an overflow condition\n      (resources are exhausted), refuse\
    \ the connection (send a CLS).\n   CLS\n      The pending call queue is searched.\
    \  If the CLS doesn't match the\n      current request, but does match some other\
    \ request, then delete\n      that request and issue a CLS.  If there is no match,\
    \ the CLS is\n      ignored.\n      If the CLS matches the current request, and\
    \ CS =\n         PENDING, then delete the current request.  If the request queue\n\
    \            is empty, delete the entry; otherwise, leave the entry\n        \
    \    alone.\n         RFC-RCVD, Issue a CLS and enter the ABORT state.\n     \
    \    ABORT, ignore.\n         RFC-SENT, issue a CLS.  If the pending call queue\
    \ is empty\n            delete the entry, else enter the PENDING state.\n    \
    \     OPEN, If we are on the receive side, response is identical to\n        \
    \    the response for RFC-SENT.  If we are on the send side,\n            clear\
    \ the data queue, and if a RFNM is still pending enter\n            the RFNM-WAIT\
    \ state.  Otherwise response is identical to the\n            response for RFC-SENT.\n\
    \         CLS-WAIT, Issue a CLS and if the pending call queue is empty,\n    \
    \        delete the entry, otherwise CS = PENDING.\n         DATA-WAIT, clear\
    \ the data queue and enter the RFNM-WAIT state.\n            A matching CLS cannot\
    \ occur in the CLOSED or LISTENING\n            states.\n   ERR\n      Errors\
    \ are queued for later attention by system programmers, and\n      are considered\
    \ to be a system error in the host that originated\n      the exchange.  (Not\
    \ associated with any state).\n   ECO\n      The op code is changed to ERP and\
    \ retransmitted (Not associated\n      with any state).\n   ERP\n      Upon receipt\
    \ of an ERP, the system passes the text of the command\n      back to the process\
    \ which issued the ECO.\n   INR, INS\n      These commands are enabled only in\
    \ the OPEN state.  Upon receiving\n      an INTERRUPT, the system causes an event\
    \ to be sent to the\n      associated process.  An INTERRUPT is ignored in the\
    \ CLS-WAIT,\n      DATA-WAIT, and RFNM-WAIT states.  In any other state it is\
    \ an\n      error.\n   ALL\n      ALLOCATE is valid only in the OPEN state, and\
    \ may be sent only to\n      a send socket.  The NCP increments the 'Their Size'\
    \ field in the\n      associated rendezvous table entry by the size specified\
    \ in the\n      ALLOCATE command.\n      In the CLS-WAIT and DATA-WAIT states\
    \ this command is ignored; in\n      any other state it is an error.\n   Data-RFNM\n\
    \      If in the OPEN state, mark the Flow Control Status field in the\n     \
    \    appropriate rendezvous table entry as RFNM-RECVD, and send more\n       \
    \  data if required.\n      If in the DATA-WAIT state, maintenance the Flow Control\
    \ Status.\n         If the data queue is empty issue a CLS and enter the CLS-WAIT\n\
    \         state; otherwise, transmit the next message.\n      If in the RFNM-WAIT\
    \ state, maintenance the Flow Control Status and\n         issue a CLS.  If the\
    \ Pending Call queue is empty delete the\n         rendezvous table entry, otherwise\
    \ CS = PENDING.\n      A Data-RFNM is an error in all other states.\n"
- title: IX.  Algorithms for the System Call Interpreter
  contents:
  - "IX.  Algorithms for the System Call Interpreter\n   Each System Call is discussed,\
    \ giving the state changes it may\n   effect:\n   CONNECT\n      If there is no\
    \ entry, create one, issue an RFC, and enter the\n         RFC-SENT state.\n \
    \     If CS = PENDING, search the queue and reject all non-matching\n        \
    \ requests.  If no match is found issue an RFC and enter the\n         RFC-SENT\
    \ state.  If a match is found, issue an RFC and enter\n         the OPEN state.\
    \  Transmission can commence as soon as buffer\n         space has been allocated.\n\
    \      In any other state this command is illegal.\n   LISTEN\n      If an entry\
    \ doesn't exist, create one, and enter the LISTENING\n         state.\n      If\
    \ CS = PENDING, inform the user and enter the RFC-RCVD state.\n      In any other\
    \ state this command is illegal.\n   ACCEPT\n      If CS = RFC-RCVD, then issue\
    \ an RFC and enter the OPEN state.\n         Data transmission can occur as soon\
    \ as buffer space is\n         allocated.\n      If CS = ABORT, inform the user\
    \ of the premature termination of the\n         connection.  If the pending call\
    \ queue is empty, delete the\n         entry; otherwise, enter the PENDING state.\n\
    \      This command cannot be legally executed in any other state.\n   CLOSE\n\
    \         If CS =\n      LISTENING, then delete the entry.\n      RFC-RCVD, then\
    \ issue a CLS and enter the CLS-WAIT state.\n      ABORT, inform the user of the\
    \ premature termination of the\n         connection.  If the pending call queue\
    \ is empty, delete the\n         entry; otherwise, enter the PENDING state.\n\
    \      RFC-SENT, then issue a CLS and enter the CLS-WAIT state.\n      OPEN, if\
    \ we are on the send side, and the data queue is not empty,\n         or if a\
    \ Data-RFNM is still outstanding, enter the DATA-WAIT\n         state; otherwise,\
    \ issue a CLS and enter the CLS-WAIT state.\n      CLS-WAIT, issuing a CLOSE in\
    \ this state is a USER ERROR.\n      DATA-WAIT, issuing a CLOSE in this state\
    \ is also an illegal\n         sequence.\n      RFNM-WAIT, ignore the CLOSE.\n\
    \      A valid CLOSE cannot be issued if an entry does not exist, or if a\n  \
    \       socket is in the PENDING state.\n           [ This RFC was put into machine\
    \ readable form for entry   ]\n           [ into the online RFC archives by Anthony\
    \ Anderberg 5/00 ]\n"
