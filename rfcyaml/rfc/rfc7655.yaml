- contents:
  - '                     RTP Payload Format for G.711.0

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document specifies the Real-time Transport Protocol (RTP)\n
    \  payload format for ITU-T Recommendation G.711.0.  ITU-T Rec. G.711.0\n   defines
    a lossless and stateless compression for G.711 packet\n   payloads typically used
    in IP networks.  This document also defines a\n   storage mode format for G.711.0
    and a media type registration for the\n   G.711.0 RTP payload format.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7655.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2015 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   4\n   2.  Requirements Language . . . . . . . . . . . . . . . . .
    . . .   4\n   3.  G.711.0 Codec Background  . . . . . . . . . . . . . . . . .
    .   4\n     3.1.  General Information and Use of the ITU-T G.711.0 Codec  .   4\n
    \    3.2.  Key Properties of G.711.0 Design  . . . . . . . . . . . .   6\n     3.3.
    \ G.711 Input Frames to G.711.0 Output Frames . . . . . . .   8\n       3.3.1.
    \ Multiple G.711.0 Output Frames per RTP Payload\n               Considerations
    \ . . . . . . . . . . . . . . . . . . .   9\n   4.  RTP Header and Payload  .
    . . . . . . . . . . . . . . . . . .  10\n     4.1.  G.711.0 RTP Header  . . .
    . . . . . . . . . . . . . . . .  10\n     4.2.  G.711.0 RTP Payload . . . . .
    . . . . . . . . . . . . . .  12\n       4.2.1.  Single G.711.0 Frame per RTP Payload
    Example  . . . .  12\n       4.2.2.  G.711.0 RTP Payload Definition  . . . . .
    . . . . . .  13\n         4.2.2.1.  G.711.0 RTP Payload Encoding Process  . .
    . . . .  14\n       4.2.3.  G.711.0 RTP Payload Decoding Process  . . . . . .
    . .  15\n       4.2.4.  G.711.0 RTP Payload for Multiple Channels . . . . . .
    \ 17\n   5.  Payload Format Parameters . . . . . . . . . . . . . . . . . .  19\n
    \    5.1.  Media Type Registration . . . . . . . . . . . . . . . . .  20\n     5.2.
    \ Mapping to SDP Parameters . . . . . . . . . . . . . . . .  22\n     5.3.  Offer/Answer
    Considerations . . . . . . . . . . . . . . .  22\n     5.4.  SDP Examples  . .
    . . . . . . . . . . . . . . . . . . . .  23\n       5.4.1.  SDP Example 1 . .
    . . . . . . . . . . . . . . . . . .  23\n       5.4.2.  SDP Example 2 . . . .
    . . . . . . . . . . . . . . . .  23\n   6.  G.711.0 Storage Mode Conventions and
    Definition . . . . . . .  24\n     6.1.  G.711.0 PLC Frame . . . . . . . . . .
    . . . . . . . . . .  24\n     6.2.  G.711.0 Erasure Frame . . . . . . . . . .
    . . . . . . . .  25\n     6.3.  G.711.0 Storage Mode Definition . . . . . . .
    . . . . . .  26\n   7.  IANA Considerations . . . . . . . . . . . . . . . . .
    . . . .  27\n   8.  Security Considerations . . . . . . . . . . . . . . . . .
    . .  27\n   9.  Congestion Control  . . . . . . . . . . . . . . . . . . . . .
    \ 28\n   10. References  . . . . . . . . . . . . . . . . . . . . . . . . .  29\n
    \    10.1.  Normative References . . . . . . . . . . . . . . . . . .  29\n     10.2.
    \ Informative References . . . . . . . . . . . . . . . . .  30\n   Acknowledgements
    \ . . . . . . . . . . . . . . . . . . . . . . . .  31\n   Contributors  . . .
    . . . . . . . . . . . . . . . . . . . . . . .  31\n   Authors' Addresses  . .
    . . . . . . . . . . . . . . . . . . . . .  31\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The International Telecommunication Union (ITU-T) Recommendation\n
    \  G.711.0 [G.711.0] specifies a stateless and lossless compression for\n   G.711
    packet payloads typically used in Voice over IP (VoIP)\n   networks.  This document
    specifies the Real-time Transport Protocol\n   (RTP) RFC 3550 [RFC3550] payload
    format and storage modes for this\n   compression.\n"
  title: 1.  Introduction
- contents:
  - "2.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
    \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
    and \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC
    2119 [RFC2119].\n"
  title: 2.  Requirements Language
- contents:
  - "3.  G.711.0 Codec Background\n   ITU-T Recommendation G.711.0 [G.711.0] is a
    lossless and stateless\n   compression mechanism for ITU-T Recommendation G.711
    [G.711] and thus\n   is not a \"codec\" in the sense of \"lossy\" codecs typically
    carried by\n   RTP.  When negotiated end-to-end, ITU-T Rec. G.711.0 is negotiated
    as\n   if it were a codec, with the understanding that ITU-T Rec. G.711.0\n   losslessly
    encoded the underlying (lossy) G.711 Pulse Code Modulation\n   (PCM) sample representation
    of an audio signal.  For this reason,\n   ITU-T Rec. G.711.0 will be interchangeably
    referred to in this\n   document as a \"lossless data compression algorithm\"
    or a \"codec\",\n   depending on context.  Within this document, individual G.711
    PCM\n   samples will be referred to as \"G.711 symbols\" or just \"symbols\" for\n
    \  brevity.\n   This section describes the ITU-T Recommendation G.711 [G.711]
    codec,\n   its properties, typical uses cases, and its key design properties.\n"
  - contents:
    - "3.1.  General Information and Use of the ITU-T G.711.0 Codec\n   ITU-T Recommendation
      G.711 is the benchmark standard for narrowband\n   telephony.  It has been successful
      for many decades because of its\n   proven voice quality, ubiquity, and utility.
      \ A new ITU-T\n   recommendation, G.711.0, has been established for defining
      a\n   stateless and lossless compression for G.711 packet payloads\n   typically
      used in VoIP networks.  ITU-T Rec. G.711.0 is also known as\n   ITU-T Rec. G.711
      Annex A [G.711-A1], as ITU-T Rec. G.711 Annex A is\n   effectively a pointer
      ITU-T Rec. G.711.0.  Henceforth in this\n   document, ITU-T Rec. G.711.0 will
      simply be referred to as \"G.711.0\"\n   and ITU-T Rec. G.711 simply as \"G.711\".\n
      \  G.711.0 may be employed end-to-end, in which case the RTP payload\n   format
      specification and use is nearly identical to the G.711 RTP\n   specification
      found in RFC 3551 [RFC3551].  The only significant\n   difference for G.711.0
      is the required use of a dynamic payload type\n   (the static PT of 0 or 8 is
      presently almost always used with G.711\n   even though dynamic assignment of
      other payload types is allowed) and\n   the recommendation not to use Voice
      Activity Detection (see\n   Section 4.1).\n   G.711.0, being both lossless and
      stateless, may also be employed as a\n   lossless compression mechanism for
      G.711 payloads anywhere between\n   end systems that have negotiated use of
      G.711.  Because the only\n   significant difference between the G.711 RTP payload
      format header\n   and the G.711.0 payload format header defined in this document
      is the\n   payload type, a G.711 RTP packet can be losslessly converted to a\n
      \  G.711.0 RTP packet simply by compressing the G.711 payload (thus\n   creating
      a G.711.0 payload), changing the payload type to the dynamic\n   value desired
      and copying all the remaining G.711 RTP header fields\n   into the corresponding
      G.711.0 RTP header.  In a similar manner, the\n   corresponding decompression
      of the G.711.0 RTP packet thus created\n   back to the original source G.711
      RTP packet can be accomplished by\n   losslessly decompressing the G.711.0 payload
      back to the original\n   source G.711 payload, changing the payload type back
      to the payload\n   type of the original G.711 RTP packet and copying all the
      remaining\n   G.711.0 RTP header fields into the corresponding G.711 RTP header.\n
      \  As a packet produced by the compression and decompression as\n   described
      above is indistinguishable in every detail to the source\n   G.711 packet, such
      compression can be made invisible to the end\n   systems.  Specification of
      how systems on the path between the end\n   systems discover each other and
      negotiate the use of G.711.0\n   compression as described in this paragraph
      is outside the scope of\n   this document.\n   It is informative to note that
      G.711.0, being both lossless and\n   stateless, can be employed multiple times
      (e.g., on multiple,\n   individual hops or series of hops) of a given flow with
      no\n   degradation of quality relative to end-to-end G.711.  Stated another\n
      \  way, multiple \"lossless transcodes\" from/to G.711.0/G.711 do not\n   affect
      voice quality as typically occurs with lossy transcodes to/\n   from dissimilar
      codecs.\n   Lastly, it is expected that G.711.0 will be used as an archival\n
      \  format for recorded G.711 streams.  Therefore, a G.711.0 Storage Mode\n   Format
      is also included in this document.\n"
    title: 3.1.  General Information and Use of the ITU-T G.711.0 Codec
  - contents:
    - "3.2.  Key Properties of G.711.0 Design\n   The fundamental design of G.711.0
      resulted from the desire to\n   losslessly encode and compress frames of G.711
      symbols independent of\n   what types of signals those G.711 frames contained.
      \ The primary\n   G.711.0 use case is for G.711 encoded, zero-mean, acoustic
      signals\n   (such as speech and music).\n   G.711.0 attributes are below:\n
      \  A1  Compression for zero-mean acoustic signals: G.711.0 was designed\n         as
      its primary use case for the compression of G.711 payloads\n         that contained
      \"speech\" or other zero-mean acoustic signals.\n         G.711.0 obtains greater
      than 50% average compression in service\n         provider environments [ICASSP].\n
      \  A2  Lossless for any G.711 payload: G.711.0 was designed to be\n         lossless
      for any valid G.711 payload - even if the payload\n         consisted of apparently
      random G.711 symbols (e.g., a modem or\n         FAX payload).  G.711.0 could
      be used for \"aggregate 64 kbps\n         G.711 channels\" carried over IP without
      explicit concern if a\n         subset of these channels happened to be carrying
      something\n         other than voice or general audio.  To the extent that a\n
      \        particular channel carried something other than voice or\n         general
      audio, G.711.0 ensured that it was carried losslessly,\n         if not significantly
      compressed.\n   A3  Stateless: Compression of a frame of G.711 symbols was only
      to be\n         dependent on that frame and not on any prior frame.  Although\n
      \        greater compression is usually available by observing a longer\n         history
      of past G.711 symbols, it was decided that the\n         compression design
      would be stateless to completely eliminate\n         error propagation common
      in many lossy codec designs (e.g.,\n         ITU-T Rec. G.729 [G.729] and ITU-T
      Rec. G.722 [G.722]).  That\n         is, the decoding process need not be concerned
      about lost prior\n         packets because the decompression of a given G.711.0
      frame is\n         not dependent on potentially lost prior G.711.0 frames.  Owing\n
      \        to this stateless property, the frames input to the G.711.0\n         encoder
      may be changed \"on-the-fly\" (a 5 ms encoding could be\n         followed by
      a 20 ms encoding).\n   A4  Self-describing: This property is defined as the
      ability to\n         determine how many source G.711 samples are contained within\n
      \        the G.711.0 frame solely by information contained within the\n         G.711.0
      frame.  Generally, the number of source G.711 symbols\n         can be determined
      by decoding the initial octets of the\n         compressed G.711.0 frame (these
      octets are called \"prefix\n         codes\" in the standard).  A G.711.0 decoder
      need not know how\n         many symbols are contained in the original G.711
      frame (e.g.,\n         parameter ptime in the Session Description Protocol (SDP)\n
      \        [RFC4566]), as it is able to decompress the G.711.0 frame\n         presented
      to it without signaling knowledge.\n   A5  Accommodate G.711 payload sizes typically
      used in IP: G.711 input\n         frames of length typically found in VoIP applications
      represent\n         SDP ptime values of 5 ms, 10 ms, 20 ms, 30 ms, or 40 ms.\n
      \        Because the dominant sampling frequency for G.711 is 8000\n         samples
      per second, G.711.0 was designed to compress G.711\n         input frames of
      40, 80, 160, 240, or 320 samples.\n   A6  Bounded expansion: Since attribute
      A2 above requires G.711.0 to\n         be lossless for any payload (which could
      consist of any\n         combination of octets with each octet spanning the
      entire space\n         of 2^8 values), by definition there exists at least one\n
      \        potential G.711 payload that must be \"uncompressible\".  Since\n         the
      quantum of compression is an octet, the minimum expansion\n         of such
      an uncompressible payload was designed to be the\n         minimum possible
      of one octet.  Thus, G.711.0 \"compressed\"\n         frames can be of length
      one octet to X+1 octets, where X is the\n         size of the input G.711 frame
      in octets.  G.711.0 can therefore\n         be viewed as a Variable Bit Rate
      (VBR) encoding in which the\n         size of the G.711.0 output frame is a
      function of the G.711\n         symbols input to it.\n   A7  Algorithmic delay:
      G.711.0 was designed to have the algorithmic\n         delay equal to the time
      represented by the number of samples in\n         the G.711 input frame (i.e.,
      no \"look-ahead\").\n   A8  Low Complexity: Less than 1.0 Weighted Million Operations
      Per\n         Second (WMOPS) average and low memory footprint (~5k octets\n
      \        RAM, ~5.7k octets ROM, and ~3.6 basic operations) [ICASSP]\n         [G.711.0].\n
      \  A9  Both A-law and mu-law supported: G.711 has two operating laws,\n         A-law
      and mu-law.  These two laws are also known as PCMA and\n         PCMU in RTP
      applications [RFC3551].\n   These attributes generally make it trivial to compress
      a G.711 input\n   frame consisting of 40, 80, 160, 240, or 320 samples.  After
      the\n   input frame is presented to a G.711.0 encoder, a G.711.0 \"self-\n   describing\"
      output frame is produced.  The number of samples\n   contained within this frame
      is easily determined at the G.711.0\n   decoder by virtue of attribute A4.  The
      G.711.0 decoder can decode\n   the G.711.0 frame back to a G.711 frame by using
      only data within the\n   G.711.0 frame.\n   Lastly we note that losing a G.711.0
      encoded packet is identical in\n   effect to losing a G.711 packet (when using
      RTP); this is because a\n   G.711.0 payload, like the corresponding G.711 payload,
      is stateless.\n   Thus, it is anticipated that existing G.711 Packet Loss Concealment\n
      \  (PLC) mechanisms will be employed when a G.711.0 packet is lost and\n   an
      identical MOS degradation relative to G.711 loss will be achieved.\n"
    title: 3.2.  Key Properties of G.711.0 Design
  - contents:
    - "3.3.  G.711 Input Frames to G.711.0 Output Frames\n   G.711.0 is a lossless
      and stateless compression of G.711 frames.\n   Figure 1 depicts this where \"A\"
      is the process of G.711.0 encoding\n   and \"B\" is the process of G.711.0 decoding.\n
      \   |--------------------------|  A   |------------------------------|\n    |
      \   G.711 Input Frame     |----->|     G.711.0 Output Frame     |\n    |       of
      X Octets        |      |  containing 1 to X+1 Octets  |\n    | (where X MUST
      be 40, 80, |      | (precise value dependent on  |\n    | 160, 240, or 320 octets)
      |<-----| G.711.0 ability to compress) |\n    |__________________________|  B
      \  |______________________________|\n   Figure 1: 1:1 Mapping from G.711 Input
      Frame to G.711.0 Output Frame\n   Note that the mapping is 1:1 (lossless) in
      both directions, subject\n   to two constraints.  The first constraint is that
      the input frame\n   provided to the G.711.0 encoder (process \"A\") has a specific
      number\n   of input G.711 symbols consistent with attribute A5 (40, 80, 160,\n
      \  240, or 320 octets).  The second constraint is that the companding\n   law
      used to create the G.711 input frame (A-law or mu-law) must be\n   known, consistent
      with attribute A9.\n   Subject to these two constraints, the input G.711 frame
      is processed\n   by the G.711.0 encoder (\"process A\") and produces a \"self-describing\"\n
      \  G.711.0 output frame, consistent with attribute A4.  Depending on the\n   source
      G.711 symbols, the G.711.0 output frame can contain anywhere\n   from 1 to X+1
      octets, where X is the number of input G.711 symbols.\n   Compression results
      for virtually every zero-mean acoustic signal\n   encoded by G.711.0.\n   Since
      the G.711.0 output frame is \"self-describing\", a G.711.0\n   decoder (process
      \"B\") can losslessly reproduce the original G.711\n   input frame with only
      the knowledge of which companding law was used\n   (A-law or mu-law).  The first
      octet of a G.711.0 frame is called the\n   \"Prefix Code\" octet; the information
      within this octet conveys how\n   many G.711 symbols the decoder is to create
      from a given G.711.0\n   input frame (i.e., 0, 40, 80, 160, 240, or 320).  The
      Prefix Code\n   value of 0x00 is used to denote zero G.711 source symbols, which\n
      \  allows the use of 0x00 as a payload padding octet (described later in\n   Section
      3.3.1).\n   Since G.711.0 was designed with typical G.711 payload lengths as
      a\n   design constraint (attribute A5), this lossless encoding can be\n   performed
      only with knowledge of the companding law being used.  This\n   information
      is anticipated to be signaled in SDP and is described\n   later in this document.\n
      \  If the original inputs were known to be from a zero-mean acoustic\n   signal
      coded by G.711, an intelligent G.711.0 encoder could infer the\n   G.711 companding
      law in use (via G.711 input signal amplitude\n   histogram statistics).  Likewise,
      an intelligent G.711.0 decoder\n   producing G.711 from the G.711.0 frames could
      also infer which\n   encoding law is in use.  Thus, G.711.0 could be designed
      for use in\n   applications that have limited stream signaling between the G.711\n
      \  endpoints (i.e., they only know \"G.711 at 8k sampling is being used\",\n
      \  but nothing more).  Such usage is not further described in this\n   document.
      \ Additionally, if the original inputs were known to come\n   from zero-mean
      acoustic signals, an intelligent G.711.0 encoder could\n   tell if the G.711.0
      payload had been encrypted -- as the symbols\n   would not have the distribution
      expected in either companding law and\n   would appear random.  Such determination
      is also not further\n   discussed in this document.\n   It is easily seen that
      this process is 1:1 and that lossless\n   compression based on G.711.0 can be
      employed multiple times, as the\n   original G.711 input symbols are always
      reproduced with 100%\n   fidelity.\n"
    - contents:
      - "3.3.1.  Multiple G.711.0 Output Frames per RTP Payload Considerations\n   As
        a general rule, G.711.0 frames containing more source G.711\n   symbols (from
        a given channel) will typically result in higher\n   compression, but there
        are exceptions to this rule.  A G.711.0\n   encoder may choose to encode 20
        ms of input G.711 symbols as: 1) a\n   single 20 ms G.711.0 frame, or 2) as
        two 10 ms G.711.0 frames, or 3)\n   any other combination of 5 ms or 10 ms
        G.711.0 frames -- depending on\n   which encoding resulted in fewer bits.
        \ As an example, an intelligent\n   encoder might encode 20 ms of G.711 symbols
        as two 10 ms G.711.0\n   frames if the first 10 ms was \"silence\" and two
        G.711.0 frames took\n   fewer bits than any other possible encoding combination
        of G.711.0\n   frame sizes.\n   During the process of G.711.0 standardization,
        it was recognized that\n   although it is sometimes advantageous to encode
        integer multiples of\n   40 G.711 symbols in whatever input symbol format
        resulted in the most\n   compression (as per above), the simplest choice is
        to encode the\n   entire ptime's worth of input G.711 symbols into one G.711.0
        frame\n   (if the ptime supported it).  This is especially so since the larger\n
        \  number of source G.711 symbols typically resulted in the highest\n   compression
        anyway and there is added complexity in searching for\n   other possibilities
        (involving more G.711.0 frames) that were\n   unlikely to produce a more bit
        efficient result.\n   The design of ITU-T Rec. G.711.0 [G.711.0] foresaw the
        possibility of\n   multiple G.711.0 input frames in that the decoder was defined
        to\n   decode what it refers to as an incoming \"bit stream\".  For this\n
        \  specification, the bit stream is the G.711.0 RTP payload itself.\n   Thus,
        the decoder will take the G.711.0 RTP payload and will produce\n   an output
        frame containing the original G.711 symbols independent of\n   how many G.711.0
        frames were present in it.  Additionally, any number\n   of 0x00 padding octets
        placed between the G.711.0 frames will be\n   silently (and safely) ignored
        by the G.711.0 decoding process\n   Section 4.2.3).\n   To recap, a G.711.0
        encoder may choose to encode incoming G.711\n   symbols into one or more than
        one G.711.0 frames and put the\n   resultant frame(s) into the G.711.0 RTP
        payload.  Zero or more 0x00\n   padding octets may also be included in the
        G.711.0 RTP payload.  The\n   G.711.0 decoder, being insensitive to the number
        of G.711.0 encoded\n   frames that are contained within it, will decode the
        G.711.0 RTP\n   payload into the source G.711 symbols.  Although examples
        of single\n   or multiple G.711 frame cases are illustrated in Section 4.2,
        the\n   multiple G.711.0 frame cases MUST be supported and there is no need\n
        \  for negotiation (SDP or otherwise) required for it.\n"
      title: 3.3.1.  Multiple G.711.0 Output Frames per RTP Payload Considerations
    title: 3.3.  G.711 Input Frames to G.711.0 Output Frames
  title: 3.  G.711.0 Codec Background
- contents:
  - "4.  RTP Header and Payload\n   In this section, we describe the precise format
    for G.711.0 frames\n   carried via RTP.  We begin with an RTP header description
    relative to\n   G.711, then provide two G.711.0 payload examples.\n"
  - contents:
    - "4.1.  G.711.0 RTP Header\n   Relative to G.711 RTP headers, the utilization
      of G.711.0 does not\n   create any special requirements with respect to the
      contents of the\n   RTP packet header.  The only significant difference is that
      the\n   payload type (PT) RTP header field MUST have a value corresponding to\n
      \  the dynamic payload type assigned to the flow.  This is in contrast\n   to
      most current uses of G.711 that typically use the static payload\n   assignment
      of PT = 0 (PCMU) or PT = 8 (PCMA) [RFC3551] even though\n   the negotiation
      and use of dynamic payload types is allowed for\n   G.711.  With the exception
      of rare PT exhaustion cases, the existing\n   G.711 PT values of 0 and 8 MUST
      NOT be used for G.711.0 (helping to\n   avoid possible payload confusion with
      G.711 payloads).\n   Voice Activity Detection (VAD) SHOULD NOT be used when
      G.711.0 is\n   negotiated because G.711.0 obtains high compression during \"VAD\n
      \  silence intervals\" and one of the advantages of G.711.0 over G.711\n   with
      VAD is the lack of any VAD-inducing artifacts in the received\n   signal.  However,
      if VAD is employed, the Marker bit (M) MUST be set\n   in the first packet of
      a talkspurt (the first packet after a silence\n   period in which packets have
      not been transmitted contiguously as per\n   rules specified in [RFC3551] for
      G.711 payloads).  This definition,\n   being consistent with the G.711 RTP VAD
      use, further allows lossless\n   transcoding between G.711 RTP packets and G.711.0
      RTP packets as\n   described in Section 3.1.\n   With this introduction, the
      RTP packet header fields are defined as\n   follows:\n      V - As per [RFC3550]\n
      \     P - As per [RFC3550]\n      X - As per [RFC3550]\n      CC - As per [RFC3550]\n
      \     M - As per [RFC3550] and [RFC3551]\n      PT - The assignment of an RTP
      payload type for the format defined\n      in this memo is outside the scope
      of this document.  The RTP\n      profiles in use currently mandate binding
      the payload type\n      dynamically for this payload format (e.g., see [RFC3550]
      and\n      [RFC4585]).\n      SN - As per [RFC3550]\n      timestamp - As per
      [RFC3550]\n      SSRC - As per [RFC3550]\n      CSRC - As per [RFC3550]\n   V
      (version bits), P (padding bit), X (extension bit), CC (CSRC\n   count), M (marker
      bit), PT (payload type), SN (sequence number),\n   timestamp, SSRC (synchronizing
      source) and CSRC (contributing\n   sources) are as defined in [RFC3550] and
      are as typically used with\n   G.711.  PT (payload type) is as defined in [RFC3551].\n"
    title: 4.1.  G.711.0 RTP Header
  - contents:
    - "4.2.  G.711.0 RTP Payload\n   This section defines the G.711.0 RTP payload
      and illustrates it by\n   means of two examples.\n   The first example, in Section
      4.2.1, depicts the case in which\n   carrying only one G.711.0 frame in the
      RTP payload is desired.  This\n   case is expected to be the dominant use case
      and is shown separately\n   for the purposes of clarity.\n   The second example,
      in Section 4.2.2, depicts the general case in\n   which carrying one or more
      G.711.0 frames in the RTP payload is\n   desired.  This is the actual definition
      of the G.711.0 RTP payload.\n"
    - contents:
      - "4.2.1.  Single G.711.0 Frame per RTP Payload Example\n   This example depicts
        a single G.711.0 frame in the RTP payload.  This\n   is expected to be the
        dominant RTP payload case for G.711.0, as the\n   G.711.0 encoding process
        supports the SDP packet times (ptime and\n   maxptime, see [RFC4566]) commonly
        used when G.711 is transported in\n   RTP.  Additionally, as mentioned previously,
        larger G.711.0 frames\n   generally compress more effectively than a multiplicity
        of smaller\n   G.711.0 frames.\n   The following figure illustrates the single
        G.711.0 frame per RTP\n   payload case.\n                 |-------------------|-------------------|\n
        \                | One G.711.0 Frame | Zero or more 0x00 |\n                 |
        \                  |   Padding Octets  |\n                 |___________________|___________________|\n
        \           Figure 2: Single G.711.0 Frame in RTP Payload Case\n   Encoding
        Process: A single G.711.0 frame is inserted into the RTP\n   payload.  The
        amount of time represented by the G.711 symbols\n   compressed in the G.711.0
        frame MUST correspond to the ptime signaled\n   for applications using SDP.
        \ Although generally not desired, padding\n   desired in the RTP payload after
        the G.711.0 frame MAY be created by\n   placing one or more 0x00 octets after
        the G.711.0 frame.  Such\n   padding may be desired based on the Security
        Considerations (see\n   Section 8).\n   Decoding Process: Passing the entire
        RTP payload to the G.711.0\n   decoder is sufficient for the G.711.0 decoder
        to create the source\n   G.711 symbols.  Any padding inserted after the G.711.0
        frame (i.e.,\n   the 0x00 octets) present in the RTP payload is silently ignored
        by\n   the G.711.0 decoding process.  The decoding process is fully\n   described
        in Section 4.2.3.\n"
      title: 4.2.1.  Single G.711.0 Frame per RTP Payload Example
    - contents:
      - "4.2.2.  G.711.0 RTP Payload Definition\n   This section defines the G.711.0
        RTP payload and illustrates the case\n   in which one or more G.711.0 frames
        are to be placed in the payload.\n   All G.711.0 RTP decoders MUST support
        the general case described in\n   this section (rationale presented previously
        in Section 3.3.1).\n   Note that since each G.711.0 frame is self-describing
        (see Attribute\n   A4 in Section 3.2), the individual G.711.0 frames in the
        RTP payload\n   need not represent the same duration of time (i.e., a 5 ms
        G.711.0\n   frame could be followed by a 20 ms G.711.0 frame).  Owing to this,\n
        \  the amount of time represented in the RTP payload MAY be any integer\n
        \  multiple of 5 ms (as 5 ms is the smallest interval of time that can\n   be
        represented in a G.711.0 frame).\n   The following figure illustrates the
        one or more G.711.0 frames per\n   RTP payload case where the number of G.711.0
        frames placed in the RTP\n   payload is N.  We note that when N is equal to
        1, this case is\n   identical to the previous example.\n       |----------|---------|----------|---------|----------------|\n
        \      | First    | Second  |          | Nth     | Zero or more   |\n       |
        G.711.0  | G.711.0 |   ...    | G.711.0 |     0x00       |\n       | Frame
        \   | Frame   |          | Frame   | Padding Octets |\n       |__________|_________|__________|_________|________________|\n
        \        Figure 3: One or More G.711.0 Frames in RTP Payload Case\n   We note
        here that when we have multiple G.711.0 frames, the\n   individual frames
        can be, and generally are, of different lengths.\n   The decoding process
        described in Section 4.2.3 is used to determine\n   the frame boundaries.\n
        \  Encoding Process: One or more G.711.0 frames are placed in the RTP\n   payload
        simply by concatenating the G.711.0 frames together.  The\n   amount of time
        represented by the G.711 symbols compressed in all the\n   G.711.0 frames
        in the RTP payload MUST correspond to the ptime\n   signaled for applications
        using SDP.  Although not generally desired,\n   padding in the RTP payload
        SHOULD be placed after the last G.711.0\n   frame in the payload and MAY be
        created by placing one or more 0x00\n   octets after the last G.711.0 frame.
        \ Such padding may be desired\n   based on security considerations (see Section
        8).  Additional details\n   about the encoding process and considerations
        are specified later in\n   Section 4.2.2.1.\n   Decoding Process: As G.711.0
        frames can be of varying length, the\n   payload decoding process described
        in Section 4.2.3 is used to\n   determine where the individual G.711.0 frame
        boundaries are.  Any\n   padding octets inserted before or after any G.711.0
        frame in the RTP\n   payload is silently (and safely) ignored by the G.711.0
        decoding\n   process specified in Section 4.2.3.\n"
      - contents:
        - "4.2.2.1.  G.711.0 RTP Payload Encoding Process\n   ITU-T G.711.0 supports
          five possible input frame lengths: 40, 80,\n   160, 240, and 320 samples
          per frame, and the rationale for choosing\n   those lengths was given in
          the description of property A5 in\n   Section 3.2.  Assuming a frequency
          of 8000 samples per second, these\n   lengths correspond to input frames
          representing 5 ms, 10 ms, 20 ms,\n   30 ms, or 40 ms.  So while the standard
          assumed the input \"bit\n   stream\" consisted of G.711 symbols of some
          integer multiple of 5 ms\n   in length, it did not specify exactly what
          frame lengths to use as\n   input to the G.711.0 encoder itself.  The intent
          of this section is\n   to provide some guidance for the selection.\n   Consider
          a typical IETF use case of 20 ms (160 octets) of G.711 input\n   samples
          represented in a G.711.0 payload and signaled by using the\n   SDP parameter
          ptime.  As described in Section 3.3.1, the simplest way\n   to encode these
          160 octets is to pass the entire 160 octets to the\n   G.711.0 encoder,
          resulting in precisely one G.711.0 compressed frame,\n   and put that singular
          frame into the G.711.0 RTP payload.  However,\n   neither the ITU-T G.711.0
          standard nor this IETF payload format\n   mandates this.  In fact, 20 ms
          of input G.711 symbols can be encoded\n   as 1, 2, 3, or 4 G.711.0 frames
          in any one of six combinations (i.e.,\n   {20ms}, {10ms:10ms}, {10ms:5ms:5ms},
          {5ms:10ms:5ms}, {5ms:5ms:10ms},\n   {5ms:5ms:5ms:5ms}) and any of these
          combinations would decompress\n   into the same source 160 G.711 octets.
          \ As an aside, we note that the\n   first octet of any G.711.0 frame will
          be the prefix code octet and\n   information in this octet determines how
          many G.711 symbols are\n   represented in the G.711.0 frame.\n   Notwithstanding
          the above, we expect one of two encodings to be used\n   by implementers:
          the simplest possible (one 160-byte input to the\n   G.711.0 encoder that
          usually results in the highest compression) or\n   the combination of possible
          input frames to a G.711.0 encoder that\n   results in the highest compression
          for the payload.  The explicit\n   mention of this issue in this IETF document
          was deemed important\n   because the ITU-T G.711.0 standard is silent on
          this issue and there\n   is a desire for this issue to be documented in
          a formal Standards\n   Developing Organization (SDO) document (i.e., here).\n"
        title: 4.2.2.1.  G.711.0 RTP Payload Encoding Process
      title: 4.2.2.  G.711.0 RTP Payload Definition
    - contents:
      - "4.2.3.  G.711.0 RTP Payload Decoding Process\n   The G.711.0 decoding process
        is a standard part of G.711.0 bit stream\n   decoding and is implemented in
        the ITU-T Rec. G.711.0 reference code.\n   The decoding process algorithm
        described in this section is a slight\n   enhancement of the ITU-T reference
        code to explicitly accommodate RTP\n   padding (as described above).\n   Before
        describing the decoding, we note here that the largest\n   possible G.711.0
        frame is created whenever the largest number of\n   G.711 symbols is encoded
        (320 from Section 3.2, property A5) and\n   these 320 symbols are \"uncompressible\"
        by the G.711.0 encoder.  In\n   this case (via property A6 in Section 3.2),
        the G.711.0 output frame\n   will be 321 octets long.  We also note that the
        value 0x00 chosen for\n   the optional padding cannot be the first octet of
        a valid ITU-T Rec.\n   G.711.0 frame (see [G.711.0]).  We also note that whenever
        more than\n   one G.711.0 frame is contained in the RTP payload, decoding
        of the\n   individual G.711.0 frames will occur multiple times.\n   For the
        decoding algorithm below, let N be the number of octets in\n   the RTP payload
        (i.e., excluding any RTP padding, but including any\n   RTP payload padding),
        let P equal the number of RTP payload octets\n   processed by the G.711.0
        decoding process, let K be the number of\n   G.711 symbols presently in the
        output buffer, let Q be the number of\n   octets contained in the G.711.0
        frame being processed, and let \"!=\"\n   represent not equal to.  The keyword
        \"STOP\" is used below to indicate\n   the end of the processing of G.711.0
        frames in the RTP payload.  The\n   algorithm below assumes an output buffer
        for the decoded G.711 source\n   symbols of length sufficient to accommodate
        the expected number of\n   G.711 symbols and an input buffer of length 321
        octets.\n   G.711.0 RTP Payload Decoding Heuristic:\n   H1  Initialization
        of counters: Initialize P, the number of processed\n         octets counter,
        to zero.  Initialize K, the counter for how\n         many G.711 symbols are
        in the output buffer, to zero.\n         Initialize N to the number of octets
        in the RTP payload\n         (including any RTP payload padding).  Go to H2.\n
        \  H2  Read internal buffer: Read min{320+1, (N-P)-1} octets into the\n         internal
        buffer from the (P+1) octet of the RTP payload.  We\n         note at this
        point, N-P octets have yet to be processed and\n         that 320+1 octets
        is the largest possible G.711.0 frame.  Also\n         note that in the common
        case of zero-based array indexing of a\n         uint8 array of octets, that
        this operation will read octets\n         from index P through index [min{320+1,
        (N-P)}] from the RTP\n         payload.  Go to H3.\n   H3  Analyze the first
        octet in the internal buffer: If this octet is\n         0x00 (a padding octet),
        go to H4; otherwise, go to H5 (process\n         a G.711.0 frame).\n   H4
        \ Process padding octet (no G.711 symbols generated): Increment the\n         processed
        packets counter by one (set P = P + 1).  If the\n         result of this increment
        results in P >= N, then STOP (as all\n         RTP Payload octets have been
        processed); otherwise, go to H2.\n   H5  Process an individual G.711.0 frame
        (produce G.711 samples in the\n         output frame): Pass the internal buffer
        to the G.711.0 decoder.\n         The G.711.0 decoder will read the first
        octet (called the\n         \"prefix code\" octet in ITU-T Rec. G.711.0 [G.711.0])
        to\n         determine the number of source G.711 samples M are contained
        in\n         this G.711.0 frame.  The G.711.0 decoder will produce exactly
        M\n         G.711 source symbols (M can only have values of 0, 40, 80, 160,\n
        \        240, or 320).  If K = 0, these M symbols will be the first in\n         the
        output buffer and are placed at the beginning of the output\n         buffer.
        \ If K != 0, concatenate these M symbols with the prior\n         symbols
        in the output buffer (there are K prior symbols in the\n         buffer).
        \ Set K = K + M (as there are now this many G.711\n         source symbols
        in the output buffer).  The G.711.0 decoder will\n         have consumed some
        number of octets, Q, in the internal buffer\n         to produce the M G.711
        symbols.  Increment the number of\n         payload octets processed counter
        by this quantity (set P = P +\n         Q).  If the result of this increment
        results in P >= N, then\n         STOP (as all RTP Payload octets have been
        processed);\n         otherwise, go to H2.\n   At this point, the output buffer
        will contain precisely K G.711\n   source symbols that should correspond to
        the ptime signaled if SDP\n   was used and the encoding process was without
        error.  If ptime was\n   signaled via SDP and the number of G.711 symbols
        in the output buffer\n   is something other than what corresponds to ptime,
        the packet MUST be\n   discarded unless other system design knowledge allows
        for otherwise\n   (e.g., occasional 5 ms clock slips causing one more or one
        less\n   G.711.0 frame than nominal to be in the payload).  Lastly, due to
        the\n   buffer reads in H2 being bounded (to 321 octets or less), N being\n
        \  bounded to the size of the G.711.0 RTP payload, and M being bounded\n   to
        the number of source G.711 symbols, there is no buffer overrun\n   risk.\n
        \  We also note, as an aside, that the algorithm above (and the ITU-T\n   G.711.0
        reference code) accommodates padding octets (0x00) placed\n   anywhere between
        G.711.0 frames in the RTP payload as well as prior\n   to or after any or
        all G.711.0 frames.  The ITU-T G.711.0 reference\n   code does not have Steps
        H3 and H4 as separate steps (i.e., Step H5\n   immediately follows H2) at
        the added computational cost of some\n   additional buffer passing to/from
        the G.711.0 frame decoder\n   functions.  That is, the G.711.0 decoder in
        the reference code\n   \"silently ignores\" 0x00 padding octets at the beginning
        of what it\n   believes to be a frame boundary encoded by G.711.0.  Thus,
        Steps H3\n   and H4 above are an optimization over the reference code shown
        for\n   clarity.\n   If the decoder is at a playout endpoint location, this
        G.711 buffer\n   SHOULD be used in the same manner as a received G.711 RTP
        payload\n   would have been used (passed to a playout buffer, to a PLC\n   implementation,
        etc.).\n   We explicitly note that a framing error condition will result\n
        \  whenever the buffer sent to a G.711.0 decoder does not begin with a\n   valid
        first G.711.0 frame octet (i.e., a valid G.711.0 prefix code or\n   a 0x00
        padding octet).  The expected result is that the decoder will\n   not produce
        the desired/correct G.711 source symbols.  However, as\n   already noted,
        the output returned by the G.711.0 decoder will be\n   bounded (to less than
        321 octets per G.711.0 decode request) and if\n   the number of the (presumed)
        G.711 symbols produced is known to be in\n   error, the decoded output MUST
        be discarded.\n"
      title: 4.2.3.  G.711.0 RTP Payload Decoding Process
    - contents:
      - "4.2.4.  G.711.0 RTP Payload for Multiple Channels\n   In this section, we
        describe the use of multiple \"channels\" of G.711\n   data encoded by G.711.0
        compression.\n   The dominant use of G.711 in RTP transport has been for single\n
        \  channel use cases.  For this case, the above G.711.0 encoding and\n   decoding
        process is used.  However, the multiple channel case for\n   G.711.0 (a frame-based
        compression) is different from G.711 (a\n   sample-based encoding) and is
        described separately here.\n   Section 4 of RFC 3551 [RFC3551] provides guidelines
        for encoding\n   audio channels and Section 4.1 of RFC 3551 [RFC3551] for
        the ordering\n   of the channels within the RTP payload.  The ordering guidelines
        in\n   Section 4.1 of RFC 3551 SHOULD be used unless an application-specific\n
        \  channel ordering is more appropriate.\n   An implicit assumption in RFC
        3551 is that all the channel data\n   multiplexed into an RTP payload MUST
        represent the same physical time\n   span.  The case for G.711.0 is no different;
        the underlying G.711\n   data for all channels in a G.711.0 RTP payload MUST
        span the same\n   interval in time (e.g., the same \"ptime\" for a SDP-specified
        codec\n   negotiation).\n   Section 4.2 of RFC 3551 provides guidelines for
        sample-based\n   encodings such as G.711.  This guidance is tantamount to
        interleaving\n   the individual samples in that they SHOULD be packed in consecutive\n
        \  octets.\n   RFC 3551 provides guidelines for frame-based encodings in which
        the\n   frames are interleaved.  However, this guidance stems from the stated\n
        \  assumption that \"the frame size for the frame-oriented codecs is\n   given\".
        \ However, this assumption is not valid for G.711.0 in that\n   individual
        consecutive G.711.0 frames (as per Section 4.2.2 of this\n   document) can:\n
        \  1.  represent different time spans (e.g., two 5 ms G.711.0 frames in\n
        \      lieu of one 10 ms G.711.0 frame), and\n   2.  be of different lengths
        in octets (and typically are).\n   Therefore, a different, but also simple,
        concatenation-based approach\n   is specified in this RFC.\n   For the multiple
        channel G.711.0 case, each G.711 channel is\n   independently encoded into
        one or more G.711.0 frames defined here as\n   a \"G.711.0 channel superframe\".
        \ Each one of these superframes is\n   identical to the multiple G.711.0 frame
        case illustrated in Figure 3\n   of Section 4.2.2 in which each superframe
        can have one or more\n   individual G.711.0 frames within it.  Then each G.711.0
        channel\n   superframe is concatenated -- in channel order -- into a G.711.0
        RTP\n   payload.  Then, if optional G.711.0 padding octets (0x00) are\n   desired,
        it is RECOMMENDED that these octets are placed after the\n   last G.711.0
        channel superframe.  As per above, such padding may be\n   desired based on
        Security Considerations (see Section 8).  This is\n   depicted in Figure 4.\n
        \          |----------|---------|----------|---------|---------|\n           |
        First    | Second  |          | Nth     | Zero    |\n           | G.711.0
        \ | G.711.0 |   ...    | G.711.0 | or more |\n           | Channel  | Channel
        |          | Channel | 0x00    |\n           | Super-   | Super-  |          |
        Super   | Padding |\n           | Frame    | Frame   |          | Frame   |
        Octets  |\n           |__________|_________|__________|_________|_________|\n
        \      Figure 4: Multiple G.711.0 Channel Superframes in RTP Payload\n   We
        note that although the individual superframes can be of different\n   lengths
        in octets (and usually are), the number of G.711 source\n   symbols represented
        -- in compressed form -- in each channel\n   superframe is identical (since
        all the channels represent the\n   identically same time interval).\n   The
        G.711.0 decoder at the receiving end simply decodes the entire\n   G.711.0
        (multiple channel) payload into individual G.711 symbols.  If\n   M such G.711
        symbols result and there were N channels, then the first\n   M/N G.711 samples
        would be from the first channel, the second M/N\n   G.711 samples would be
        from the second channel, and so on until the\n   Nth set of G.711 samples
        are found.  Similarly, if the number of\n   channels was not known, but the
        payload \"ptime\" was known, one could\n   infer (knowing the sampling rate)
        how many G.711 symbols each channel\n   contained; then, with this knowledge,
        the number of channels of data\n   contained in the payload could be determined.
        \ When SDP is used, the\n   number of channels is known because the optional
        parameter is a MUST\n   when there is more than one channel negotiated (see
        Section 5.1).\n   Additionally, when SDP is used, the parameter ptime is a
        RECOMMENDED\n   optional parameter.  We note that if both parameters channels
        and\n   ptime are known, one could provide a check for the other and the\n
        \  converse.  Whichever algorithm is used to determine the number of\n   channels,
        if the length of the source G.711 symbols in the payload\n   (M) is not an
        integer multiple of the number of channels (N), then\n   the packet SHOULD
        be discarded.\n   Lastly, we note that although any padding for the multiple
        channel\n   G.711.0 payload is RECOMMENDED to be placed at the end of the\n
        \  payload, the G.711.0 decoding algorithm described in Section 4.2.3\n   will
        successfully decode the payload in Figure 4 if the 0x00 padding\n   octet
        is placed anywhere before or after any individual G.711.0 frame\n   in the
        RTP payload.  The number of padding octets introduced at any\n   G.711.0 frame
        boundary therefore does not affect the number M of the\n   source G.711 symbols
        produced.  Thus, the decision for padding MAY be\n   made on a per-superframe
        basis.\n"
      title: 4.2.4.  G.711.0 RTP Payload for Multiple Channels
    title: 4.2.  G.711.0 RTP Payload
  title: 4.  RTP Header and Payload
- contents:
  - "5.  Payload Format Parameters\n   This section defines the parameters that may
    be used to configure\n   optional features in the G.711.0 RTP transmission.\n
    \  The parameters defined here are a part of the media subtype\n   registration
    for the G.711.0 codec.  Mapping of the parameters into\n   SDP RFC 4566 [RFC4566]
    is also provided for those applications that\n   use SDP.\n"
  - contents:
    - "5.1.  Media Type Registration\n   Type name: audio\n   Subtype name: G711-0\n
      \  Required parameters:\n      clock rate: The RTP timestamp clock rate, which
      is equal to the\n      sampling rate.  The typical rate used with G.711 encoding
      is 8000,\n      but other rates may be specified.  The default rate is 8000.\n
      \     complaw: This format-specific parameter, specified on the \"a=fmtp:\n
      \     line\", indicates the companding law (A-law or mu-law) employed.\n      This
      format-specific parameter, as per RFC 4566 [RFC4566], is\n      given unchanged
      to the media tool using this format.  The case-\n      insensitive values are
      \"complaw=al\" or \"complaw=mu\" are used for\n      A-law and mu-law, respectively.\n
      \  Optional parameters:\n      channels: See RFC 4566 [RFC4566] for definition.
      \ Specifies how\n      many audio streams are represented in the G.711.0 payload
      and MUST\n      be present if the number of channels is greater than one.  This\n
      \     parameter defaults to 1 if not present (as per RFC 4566) and is\n      typically
      a non-zero, small-valued positive integer.  It is\n      expected that implementations
      that specify multiple channels will\n      also define a mechanism to map the
      channels appropriately within\n      their system design; otherwise, the channel
      order specified in\n      Section 4.1 of RFC 3551 [RFC3551] will be assumed
      (e.g., left,\n      right, center).  Similar to the usual interpretation in
      RFC 3551\n      [RFC3551], the number of channels SHALL be a non-zero, positive\n
      \     integer.\n      maxptime: See RFC 4566 [RFC4566] for definition.\n      ptime:
      See RFC 4566 [RFC4566] for definition.  The inclusion of\n      \"ptime\" is
      RECOMMENDED and SHOULD be in the SDP unless there is an\n      application-specific
      reason not to include it (e.g., an\n      application that has a variable ptime
      on a packet-by-packet\n      basis).  For constant ptime applications, it is
      considered good\n      form to include \"ptime\" in the SDP for session diagnostic\n
      \     purposes.  For the constant ptime multiple channel case described\n      in
      Section 4.2.2, the inclusion of \"ptime\" can provide a desirable\n      payload
      check.\n   Encoding considerations:\n      This media type is framed binary
      data (see Section 4.8 in RFC 6838\n      [RFC6838]) compressed as per ITU-T
      Rec. G.711.0.\n   Security considerations:\n      See Section 8.\n   Interoperability
      considerations: none\n   Published specification:\n      ITU-T Rec. G.711.0
      and RFC 7655 (this document).\n   Applications that use this media type:\n      Although
      initially conceived for VoIP, the use of G.711.0, like\n      G.711 before it,
      may find use within audio and video streaming\n      and/or conferencing applications
      for the audio portion of those\n      applications.\n   Additional information:\n
      \  The following applies to stored-file transfer methods:\n         Magic numbers:
      #!G7110A\\n or #!G7110M\\n (for A-law or MU-law\n         encodings respectively,
      see Section 6).\n         File Extensions: None\n         Macintosh file type
      code: None\n         Object identifier or OIL: None\n   Person & email address
      to contact for further information:\n      Michael A. Ramalho <mramalho@cisco.com>
      or <mar42@cornell.edu>\n   Intended usage: COMMON\n   Restrictions on usage:\n
      \     This media type depends on RTP framing, and hence is only defined\n      for
      transfer via RTP [RFC3550].  Transport within other framing\n      protocols
      is not defined at this time.\n   Author: Michael A.  Ramalho\n   Change controller:\n
      \     IETF Payload working group delegated from the IESG.\n"
    title: 5.1.  Media Type Registration
  - contents:
    - "5.2.  Mapping to SDP Parameters\n   The information carried in the media type
      specification has a\n   specific mapping to fields in SDP, which is commonly
      used to describe\n   an RTP session.  When SDP is used to specify sessions employing\n
      \  G.711.0, the mapping is as follows:\n   o  The media type (\"audio\") goes
      in SDP \"m=\" as the media name.\n   o  The media subtype (\"G711-0\") goes
      in SDP \"a=rtpmap\" as the\n      encoding name.\n   o  The required parameter
      \"rate\" also goes in \"a=rtpmap\" as the clock\n      rate.\n   o  The parameters
      \"ptime\" and \"maxptime\" go in the SDP \"a=ptime\" and\n      \"a=maxptime\"
      attributes, respectively.\n   o  Remaining parameters go in the SDP \"a=fmtp\"
      attribute by copying\n      them directly from the media type string as a semicolon-separated\n
      \     list of parameter=value pairs.\n"
    title: 5.2.  Mapping to SDP Parameters
  - contents:
    - "5.3.  Offer/Answer Considerations\n   The following considerations apply when
      using the SDP offer/answer\n   mechanism [RFC3264] to negotiate the \"channels\"
      attribute.\n   o  If the offering endpoint specifies a value for the optional\n
      \     channels parameter that is greater than one, and the answering\n      endpoint
      both understands the parameter and cannot support that\n      value requested,
      the answer MUST contain the optional channels\n      parameter with the highest
      value it can support.\n   o  If the offering endpoint specifies a value for
      the optional\n      channels parameter, the answer MUST contain the optional
      channels\n      parameter unless the only value the answering endpoint can support\n
      \     is one, in which case the answer MAY contain the optional channels\n      parameter
      with a value of 1.\n   o  If the offering endpoint specifies a value for the
      ptime parameter\n      that the answering endpoint cannot support, the answer
      MUST\n      contain the optional ptime parameter.\n   o  If the offering endpoint
      specifies a value for the maxptime\n      parameter that the answering endpoint
      cannot support, the answer\n      MUST contain the optional maxptime parameter.\n"
    title: 5.3.  Offer/Answer Considerations
  - contents:
    - "5.4.  SDP Examples\n   The following examples illustrate how to signal G.711.0
      via SDP.\n"
    - contents:
      - "5.4.1.  SDP Example 1\n         m=audio RTP/AVP 98\n         a=rtpmap:98
        G711-0/8000\n         a=fmtp:98 complaw=mu\n   In the above example, the dynamic
        payload type 98 is mapped to\n   G.711.0 via the \"a=rtpmap\" parameter.  The
        mandatory \"complaw\" is on\n   the \"a=fmtp\" parameter line.  Note that
        neither optional parameters\n   \"ptime\" nor \"channels\" is present; although,
        it is generally good\n   form to include \"ptime\" in the SDP if the session
        is a constant ptime\n   session for diagnostic purposes.\n"
      title: 5.4.1.  SDP Example 1
    - contents:
      - "5.4.2.  SDP Example 2\n   The following example illustrates an offering endpoint
        requesting 2\n   channels, but the answering endpoint can only support (or
        render) one\n   channel.\n   Offer:\n         m=audio RTP/AVP 98\n         a=rtpmap:98
        G711-0/8000/2\n         a=ptime:20\n         a=fmtp:98 complaw=al\n   Answer:\n
        \        m=audio RTP/AVP 98\n         a=rtpmap: 98 G711-0/8000/1\n         a=ptime:
        20\n         a=fmtp:98 complaw=al\n   In this example, the offer had an optional
        channels parameter.  The\n   answer must have the optional channels parameter
        also unless the\n   value in the answer is one.  Shown here is when the answer
        explicitly\n   contains the channels parameter (it need not have and it would
        be\n   interpreted as one channel).  As mentioned previously, it is\n   considered
        good form to include \"ptime\" in the SDP for session\n   diagnostic purposes
        if the session is a constant ptime session.\n"
      title: 5.4.2.  SDP Example 2
    title: 5.4.  SDP Examples
  title: 5.  Payload Format Parameters
- contents:
  - "6.  G.711.0 Storage Mode Conventions and Definition\n   The G.711.0 storage mode
    definition in this section is similar to\n   many other IETF codecs (e.g., iLBC
    RFC 3951 [RFC3951] and EVRC-NW RFC\n   6884 [RFC6884]), and is essentially a concatenation
    of individual\n   G.711.0 frames.\n   We note that something must be stored for
    any G.711.0 frames that are\n   not received at the receiving endpoint, no matter
    what the cause.  In\n   this section, we describe two mechanisms, a \"G.711.0
    PLC Frame\" and a\n   \"G.711.0 Erasure Frame\".  These G.711.0 PLC and G.711.0
    Erasure\n   Frames are described prior to the G.711.0 storage mode definition
    for\n   clarity.\n"
  - contents:
    - "6.1.  G.711.0 PLC Frame\n   When G.711 RTP payloads are not received by a rendering
      endpoint, a\n   PLC mechanism is typically employed to \"fill in\" the missing
      G.711\n   symbols with something that is auditorially pleasing; thus, the loss\n
      \  may be not noticed by a listener.  Such a PLC mechanism for G.711 is\n   specified
      in ITU-T Rec. G.711 - Appendix 1 [G.711-AP1].\n   A natural extension when creating
      G.711.0 frames for storage\n   environments is to employ such a PLC mechanism
      to create G.711\n   symbols for the span of time in which G.711.0 payloads were
      not\n   received -- and then to compress the resulting \"G.711 PLC symbols\"\n
      \  via G.711.0 compression.  The G.711.0 frame(s) created by such a\n   process
      are called \"G.711.0 PLC Frames\".\n   Since PLC mechanisms are designed to
      render missing audio data with\n   the best fidelity and intelligibility, G.711.0
      frames created via\n   such processing is likely best for most recording situations
      (such as\n   voicemail storage) unless there is a requirement not to fabricate\n
      \  (audio) data not actually received.\n   After such PLC G.711 symbols have
      been generated and then encoded by\n   a G.711.0 encoder, the resulting frames
      may be stored in G.711.0\n   frame format.  As a result, there is nothing to
      specify here -- the\n   G.711.0 PLC frames are stored as if they were received
      by the\n   receiving endpoint.  In other words, PLC-generated G.711.0 frames\n
      \  appear as \"normal\" or \"ordinary\" G.711.0 frames in the storage mode\n
      \  file.\n"
    title: 6.1.  G.711.0 PLC Frame
  - contents:
    - "6.2.  G.711.0 Erasure Frame\n   \"Erasure Frames\", or equivalently \"Null
      Frames\", have been designed\n   for many frame-based codecs since G.711 was
      standardized.  These\n   null/erasure frames explicitly represent data from
      incoming audio\n   that were either not received by the receiving system or
      represent\n   data that a transmitting system decided not to send.  Transmitting\n
      \  systems may choose not to send data for a variety of reasons (e.g.,\n   not
      enough wireless link capacity in radio-based systems) and can\n   choose to
      send a \"null frame\" in lieu of the actual audio.  It is\n   also envisioned
      that erasure frames would be used in storage mode\n   applications for specific
      archival purposes where there is a\n   requirement not to fabricate audio data
      that was not actually\n   received.\n   Thus, a G.711.0 erasure frame is a representation
      of the amount of\n   time in G.711.0 frames that were not received or not encoded
      by the\n   transmitting system.\n   Prior to defining a G.711.0 erasure frame,
      it is beneficial to note\n   what many G.711 RTP systems send when the endpoint
      is \"muted\".  When\n   muted, many of these systems will send an entire G.711
      payload of\n   either 0+ or 0- (i.e., one of the two levels closest to \"analog
      zero\"\n   in either G.711 companding law).  Next we note that a desirable\n
      \  property for a G.711.0 erasure frame is for \"non-G.711.0 Erasure\n   Frame-aware\"
      endpoints to be able to playback a G.711.0 erasure frame\n   with the existing
      G.711.0 ITU-T reference code.\n   A G.711.0 Erasure Frame is defined as any
      G.711.0 frame for which the\n   corresponding G.711 sample values are either
      the value 0++ or the\n   value 0-- for the entirety of the G.711.0 frame.  The
      levels of 0++\n   and 0-- are defined to be the two levels above or below analog
      zero,\n   respectively.  An entire frame of value 0++ or 0-- is expected to
      be\n   extraordinarily rare when the frame was in fact generated by a\n   natural
      signal, as analog inputs such as speech and music are zero-\n   mean and are
      typically acoustically coupled to digital sampling\n   systems.  Note that the
      playback of a G.711.0 frame characterized as\n   an erasure frame is auditorially
      equivalent to a muted signal (a very\n   low value constant).\n   These G.711.0
      erasure frames can be reasonably characterized as null\n   or erasure frames
      while meeting the desired playback goal of being\n   decoded by the G.711.0
      ITU-T reference code.  Thus, similarly to\n   G.711 PLC frames, the G.711.0
      erasure frames appear as \"normal\" or\n   \"ordinary\" G.711.0 frames in the
      storage mode format.\n"
    title: 6.2.  G.711.0 Erasure Frame
  - contents:
    - "6.3.  G.711.0 Storage Mode Definition\n   The storage format is used for storing
      G.711.0 encoded frames.  The\n   format for the G.711.0 storage mode file defined
      by this RFC is shown\n   below.\n          |---------------------------|----------|--------------|\n
      \         |       Magic Number        |          |              |\n          |
      \                          |  Version | Concatenated |\n          | \"#!G7110A\\n\"
      (for A-law)  |   Octet  |   G.711.0    |\n          |            or             |
      \         |    Frames    |\n          | \"#!G7110M\\n\" (for mu-law) |  \"0x00\"
      \ |              |\n          |___________________________|__________|______________|\n
      \                  Figure 5: G.711.0 Storage Mode Format\n   The storage mode
      file consists of a magic number and a version octet\n   followed by the individual
      G.711.0 frames concatenated together.\n   The magic number for G.711.0 A-law
      corresponds to the ASCII character\n   string \"#!G7110A\\n\", i.e., \"0x23
      0x21 0x47 0x37 0x31 0x31 0x30 0x41\n   0x0A\".  Likewise, the magic number for
      G.711.0 MU-law corresponds to\n   the ASCII character string \"#!G7110M\\n\",
      i.e., \"0x23 0x21 0x47 0x37\n   0x31 0x31 0x4E 0x4D 0x0A\".\n   The version
      number octet allows for the future specification of other\n   G.711.0 storage
      mode formats.  The specification of other storage\n   mode formats may be desirable
      as G.711.0 frames are of variable\n   length and a future format may include
      an indexing methodology that\n   would enable playout far into a long G.711.0
      recording without the\n   necessity of decoding all the G.711.0 frames since
      the beginning of\n   the recording.  Other future format specification may include
      support\n   for multiple channels, metadata, and the like.  For these reasons,
      it\n   was determined that a versioning strategy was desirable for the\n   G.711.0
      storage mode definition specified by this RFC.  This RFC only\n   specifies
      Version 0 and thus the value of \"0x00\" MUST be used for the\n   storage mode
      defined by this RFC.\n   The G.711.0 codec data frames, including any necessary
      erasure or PLC\n   frames, are stored in consecutive order concatenated together
      as\n   shown in Section 4.2.2.  As the Version 0 storage mode only supports\n
      \  a single channel, the RTP payload format supporting multiple channels\n   defined
      in Section 4.2.4 is not supported in this storage mode\n   definition.\n   To
      decode the individual G.711.0 frames, the algorithm presented in\n   Section
      4.2.2 may be used to decode the individual G.711.0 frames.\n   If the version
      octet is determined not to be zero, the remainder of\n   the payload MUST NOT
      be passed to the G.711.0 decoder, as the ITU-T\n   G.711.0 reference decoder
      can only decode concatenated G.711.0 frames\n   and has not been designed to
      decode elements in yet to be specified\n   future storage mode formats.\n"
    title: 6.3.  G.711.0 Storage Mode Definition
  title: 6.  G.711.0 Storage Mode Conventions and Definition
- contents:
  - "7.  IANA Considerations\n   One media type (audio/G711-0) has been defined and
    registered in\n   IANA's \"Media Types\" registry.  See Section 5.1 for details.\n"
  title: 7.  IANA Considerations
- contents:
  - "8.  Security Considerations\n   RTP packets using the payload format defined
    in this specification\n   are subject to the security considerations discussed
    in the RTP\n   specification [RFC3550], and in any applicable RTP profile (such
    as\n   RTP/AVP [RFC3551], RTP/AVPF [RFC4585], RTP/SAVP [RFC3711], or RTP/\n   SAVPF
    [RFC5124].  However, as \"Securing the RTP Protocol Framework:\n   Why RTP Does
    Not Mandate a Single Media Security Solution\" [RFC7202]\n   discusses, it is
    not a responsibility of the RTP payload format to\n   discuss or mandate what
    solutions are used to meet the basic security\n   goals like confidentiality,
    integrity, and source authenticity for\n   RTP in general.  This responsibility
    lays on anyone using RTP in an\n   application.  They can find guidance on available
    security mechanisms\n   and important considerations in \"Options for Securing
    RTP Sessions\"\n   [RFC7201].  Applications SHOULD use one or more appropriate
    strong\n   security mechanisms.  The rest of this Security Considerations\n   section
    discusses the security impacting properties of the playload\n   format itself.\n
    \  Because the data compression used with this payload format is applied\n   end-to-end,
    any encryption needs to be performed after compression.\n   Note that end-to-end
    security with either authentication, integrity,\n   or confidentiality protection
    will prevent a network element not\n   within the security context from performing
    media-aware operations\n   other than discarding complete packets.  To allow any
    (media-aware)\n   intermediate network element to perform its operations, it is\n
    \  required to be a trusted entity that is included in the security\n   context
    establishment.\n   G.711.0 has no known denial-of-service (DoS) attacks due to
    decoding,\n   as data posing as a desired G711.0 payload will be decoded into\n
    \  something (as per the decoding algorithm) with a finite amount of\n   computation.
    \ This is due to the decompression algorithm having a\n   finite worst-case processing
    path (no infinite computational loops\n   are possible).  We also note that the
    data read by the G.711.0\n   decoder is controlled by the length of the individual
    encoded G.711.0\n   frame(s) contained in the RTP payload.  The decoding algorithm\n
    \  specified previously in Section 4.2.3 ensures that the G.711.0\n   decoder
    will not read beyond the length of the internal buffer\n   specified (which is
    in turn specified to be no greater than the\n   largest possible G.711.0 frame
    of 321 octets).  Therefore, a G.711.0\n   payload does not carry \"active content\"
    that could impose malicious\n   side-effects upon the receiver.\n   G.711.0 is
    a VBR audio codec.  There have been recent concerns with\n   VBR speech codecs
    where a passive observer can identify phrases from\n   a standard speech corpus
    by means of the lengths produced by the\n   encoder even when the payload is encrypted
    [IEEE].  In this paper, it\n   was determined that some Code-Excited Linear Prediction
    (CELP) codecs\n   would produce discrete packet lengths for some phonemes.\n   Furthermore,
    with the use of appropriately designed Hidden Markov\n   Models (HMMs), such a
    system could predict phrases with unexpected\n   accuracy.  One CELP codec studied,
    SPEEX, had the property that\n   produced 21 different packet lengths in its wideband
    mode, and these\n   packet lengths probabilistically mapped to phonemes that an
    HMM\n   system could be trained on.  In this paper, it was determined that a\n
    \  mitigation technique would be to pad the output of the encoder with\n   random
    padding lengths to the effect: 1) that more discrete payload\n   sizes would result,
    and 2) that the probabilistic mapping to phonemes\n   would become less clear.
    \ As G.711 is not a speech-model-based codec,\n   neither is G.711.0.  A G.711.0
    encoding, during talking periods,\n   produces frames of varying frame lengths
    that are not likely to have\n   a strong mapping to phonemes.  Thus, G.711.0 is
    not expected to have\n   this same vulnerability.  It should be noted that \"silence\"
    (only one\n   value of G.711 in the entire G.711 input frame) or \"near silence\"\n
    \  (only a few G.711 values) is easily detectable as G.711.0 frame\n   lengths
    or one or a few octets.  If one desires to mitigate for\n   silence/non-silence
    detection, statistically variable padding should\n   be added to G.711.0 frames
    that resulted in very small G.711.0 frames\n   (less than about 20% of the symbols
    of the corresponding G.711 input\n   frame).  Methods of introducing padding in
    the G.711.0 payloads have\n   been provided in the G.711.0 RTP payload definition
    in Section 4.2.2.\n"
  title: 8.  Security Considerations
- contents:
  - "9.  Congestion Control\n   The G.711 codec is a Constant Bit Rate (CBR) codec
    that does not have\n   a means to regulate the bitrate.  The G.711.0 lossless
    compression\n   algorithm typically compresses the G.711 CBR stream into a lower-\n
    \  bandwidth VBR stream.  However, being lossless, it does not possess\n   means
    of further reducing the bitrate beyond the compression result\n   based on G.711.0.
    \ The G.711.0 RTP payloads can be made arbitrarily\n   large by means of adding
    optional padding bytes (subject only to MTU\n   limitations).\n   Therefore, there
    are no explicit ways to regulate the bit rate of the\n   transmissions outlined
    in this RTP payload format except by means of\n   modulating the number of optional
    padding bytes in the RTP payload.\n"
  title: 9.  Congestion Control
- contents:
  - '10.  References

    '
  - contents:
    - "10.1.  Normative References\n   [G.711]     ITU-T, \"Pulse Code Modulation
      (PCM) of Voice\n               Frequencies\", ITU-T Recommendation G.711 PCM,
      1988.\n   [G.711-A1]  ITU-T, \"New Annex A on Lossless Encoding of PCM Frames\",\n
      \              ITU-T Recommendation G.711 Amendment 1, 2009.\n   [G.711-AP1]
      ITU-T, \"A high quality low-complexity algorithm for\n               packet
      loss concealment with G.711\", ITU-T\n               Recommendation G.711 AP1,
      1999.\n   [G.711.0]   ITU-T, \"Lossless Compression of G.711 Pulse Code\n               Modulation\",
      ITU-T Recommendation G.711 LC PCM, 2009.\n   [RFC2119]   Bradner, S., \"Key
      words for use in RFCs to Indicate\n               Requirement Levels\", BCP
      14, RFC 2119,\n               DOI 10.17487/RFC2119, March 1997,\n               <http://www.rfc-editor.org/info/rfc2119>.\n
      \  [RFC3264]   Rosenberg, J. and H. Schulzrinne, \"An Offer/Answer Model\n               with
      Session Description Protocol (SDP)\", RFC 3264,\n               DOI 10.17487/RFC3264,
      June 2002,\n               <http://www.rfc-editor.org/info/rfc3264>.\n   [RFC3550]
      \  Schulzrinne, H., Casner, S., Frederick, R., and V.\n               Jacobson,
      \"RTP: A Transport Protocol for Real-Time\n               Applications\", STD
      64, RFC 3550, DOI 10.17487/RFC3550,\n               July 2003, <http://www.rfc-editor.org/info/rfc3550>.\n
      \  [RFC3551]    Schulzrinne, H. and S. Casner, \"RTP Profile for Audio\n               and
      Video Conferences with Minimal Control\", STD 65,\n               RFC 3551,
      DOI 10.17487/RFC3551, July 2003,\n               <http://www.rfc-editor.org/info/rfc3551>.\n
      \  [RFC3711]   Baugher, M., McGrew, D., Naslund, M., Carrara, E., and K.\n               Norrman,
      \"The Secure Real-time Transport Protocol\n               (SRTP)\", RFC 3711,
      DOI 10.17487/RFC3711, March 2004,\n               <http://www.rfc-editor.org/info/rfc3711>.\n
      \  [RFC3951]   Andersen, S., Duric, A., Astrom, H., Hagen, R., Kleijn,\n               W.,
      and J. Linden, \"Internet Low Bit Rate Codec (iLBC)\",\n               RFC 3951,
      DOI 10.17487/RFC3951, December 2004,\n               <http://www.rfc-editor.org/info/rfc3951>.\n
      \  [RFC4566]   Handley, M., Jacobson, V., and C. Perkins, \"SDP: Session\n               Description
      Protocol\", RFC 4566, DOI 10.17487/RFC4566,\n               July 2006, <http://www.rfc-editor.org/info/rfc4566>.\n
      \  [RFC4585]   Ott, J., Wenger, S., Sato, N., Burmeister, C., and J.\n               Rey,
      \"Extended RTP Profile for Real-time Transport\n               Control Protocol
      (RTCP)-Based Feedback (RTP/AVPF)\",\n               RFC 4585, DOI 10.17487/RFC4585,
      July 2006,\n               <http://www.rfc-editor.org/info/rfc4585>.\n   [RFC5124]
      \  Ott, J. and E. Carrara, \"Extended Secure RTP Profile for\n               Real-time
      Transport Control Protocol (RTCP)-Based\n               Feedback (RTP/SAVPF)\",
      RFC 5124, DOI 10.17487/RFC5124,\n               February 2008, <http://www.rfc-editor.org/info/rfc5124>.\n
      \  [RFC6838]   Freed, N., Klensin, J., and T. Hansen, \"Media Type\n               Specifications
      and Registration Procedures\", BCP 13,\n               RFC 6838, DOI 10.17487/RFC6838,
      January 2013,\n               <http://www.rfc-editor.org/info/rfc6838>.\n   [RFC6884]
      \  Fang, Z., \"RTP Payload Format for the Enhanced Variable\n               Rate
      Narrowband-Wideband Codec (EVRC-NW)\", RFC 6884,\n               DOI 10.17487/RFC6884,
      March 2013,\n               <http://www.rfc-editor.org/info/rfc6884>.\n   [RFC7201]
      \  Westerlund, M. and C. Perkins, \"Options for Securing RTP\n               Sessions\",
      RFC 7201, DOI 10.17487/RFC7201, April 2014,\n               <http://www.rfc-editor.org/info/rfc7201>.\n
      \  [RFC7202]   Perkins, C. and M. Westerlund, \"Securing the RTP\n               Framework:
      Why RTP Does Not Mandate a Single Media\n               Security Solution\",
      RFC 7202, DOI 10.17487/RFC7202, April\n               2014, <http://www.rfc-editor.org/info/rfc7202>.\n"
    title: 10.1.  Normative References
  - contents:
    - "10.2.  Informative References\n   [G.722]     ITU-T, \"7 kHz audio-coding within
      64 kbit/s\", ITU-T\n               Recommendation G.722, 1988.\n   [G.729]     ITU-T,
      \"Coding of speech at 8 kbit/s using conjugate-\n               structure algebraic-code-excited
      linear prediction\n               (CS-ACELP)\", ITU-T Recommendation G.729,
      2007.\n   [ICASSP]    Harada, N., Yamamoto, Y., Moriya, T., Hiwasaki, Y.,\n
      \              Ramalho, M., Netsch, L., Stachurski, J., Miao, L.,\n               Taddei,
      H., and F. Qi, \"Emerging ITU-T Standard G.711.0 -\n               Lossless
      Compression of G.711 Pulse Code Modulation,\n               International Conference
      on Acoustics Speech and Signal\n               Processing (ICASSP), 2010, ISBN
      978-1-4244-4244-4295-9\",\n               March 2010.\n   [IEEE]      Wright,
      C., Ballard, L., Coull, S., Monrose, F., and G.\n               Masson, \"Spot
      Me if You Can: Uncovering Spoken Phrases in\n               Encrypted VoIP Conversations,
      IEEE Symposium on Security\n               and Privacy, 2008, ISBN: 978-0-7695-3168-7\",
      May 2008.\n"
    title: 10.2.  Informative References
  title: 10.  References
- contents:
  - "Acknowledgements\n   There have been many people contributing to G.711.0 in the
    course of\n   its development.  The people listed here deserve special mention:\n
    \  Takehiro Moriya, Claude Lamblin, Herve Taddei, Simao Campos, Yusuke\n   Hiwasaki,
    Jacek Stachurski, Lorin Netsch, Paul Coverdale, Patrick\n   Luthi, Paul Barrett,
    Jari Hagqvist, Pengjun (Jeff) Huang, John Gibbs,\n   Yutaka Kamamoto, and Csaba
    Kos.  The review and oversight by the IETF\n   Payload working group chairs Ali
    Begen and Roni Even during the\n   development of this RFC is appreciated.  Additionally,
    the careful\n   review by Richard Barnes, the extensive review by David Black,
    and\n   the reviews provided by the IESG are likewise very much appreciated.\n"
  title: Acknowledgements
- contents:
  - "Contributors\n   The authors thank everyone who have contributed to this document.\n
    \  The people listed here deserve special mention: Ali Begen, Roni Even,\n   and
    Hadriel Kaplan.\n"
  title: Contributors
- contents:
  - "Authors' Addresses\n   Michael A. Ramalho (editor)\n   Cisco Systems, Inc.\n
    \  6310 Watercrest Way Unit 203\n   Lakewood Ranch, FL  34202\n   United States\n
    \  Phone: +1 919 476 2038\n   Email: mramalho@cisco.com\n   Paul E. Jones\n   Cisco
    Systems, Inc.\n   7025 Kit Creek Road\n   Research Triangle Park, NC  27709\n
    \  United States\n   Phone: +1 919 476 2048\n   Email: paulej@packetizer.com\n
    \  Noboru Harada\n   NTT Communications Science Labs\n   3-1 Morinosato-Wakamiya\n
    \  Atsugi, Kanagawa  243-0198\n   Japan\n   Phone: +81 46 240 3676\n   Email:
    harada.noboru@lab.ntt.co.jp\n   Muthu Arul Mozhi Perumal\n   Ericsson\n   Ferns
    Icon\n   Doddanekundi, Mahadevapura\n   Bangalore, Karnataka  560037\n   India\n
    \  Phone: +91 9449288768\n   Email: muthu.arul@gmail.com\n   Lei Miao\n   Huawei
    Technologies Co. Ltd\n   Q22-2-A15R, Environment Protection Park\n   No. 156 Beiqing
    Road\n   HaiDian District\n   Beijing  100095\n   China\n   Phone: +86 1059728300\n
    \  Email: lei.miao@huawei.com\n"
  title: Authors' Addresses
