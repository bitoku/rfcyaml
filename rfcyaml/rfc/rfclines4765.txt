The content of this RFC was at one time considered by the IETF, but the working group concluded before this work was approved as a standards track protocol.
This RFC is not a candidate for any level of Internet Standard.
The IETF disclaims any knowledge of the fitness of this RFC for any purpose and in particular notes that the decision to publish is not based on complete IETF review for such things as security, congestion control, or inappropriate interaction with deployed protocols.
The IESG has chosen to publish this document in order to document the work as it was when the working group concluded and to encourage experimentation and development of the technology.
Readers of this RFC should exercise caution in evaluating its value for implementation and deployment.
Abstract The purpose of the Intrusion Detection Message Exchange Format (IDMEF) is to define data formats and exchange procedures for sharing information of interest to intrusion detection and response systems and to the management systems that may need to interact with them.
This document describes a data model to represent information exported by intrusion detection systems and explains the rationale for using this model.
An implementation of the data model in the Extensible Markup Language (XML) is presented, an XML Document Type Definition is developed, and examples are provided.
The Intrusion Detection Message Exchange Format (IDMEF)
[2] is intended to be a standard data format that automated intrusion detection systems can use to report alerts about events that they deem suspicious.
The development of this standard format will enable interoperability among commercial, open source, and research systems, allowing users to mix and match the deployment of these systems according to their strong and weak points to obtain an optimal implementation.
The most obvious place to implement the IDMEF is in the data channel between an intrusion detection analyzer (or "sensor") and the manager (or "console") to which it sends alarms.
But there are other places where the IDMEF can be useful:
a single database system that could store the results from a variety of intrusion detection products would make it possible for data analysis and reporting activities to be performed on "the whole picture" instead of just a part of it;  an event correlation system that could accept alerts from a variety of intrusion detection products would be capable of performing more sophisticated cross correlation and cross  confirmation calculations than one that is limited to a single product;  a graphical user interface that could display alerts from a variety of intrusion detection products would enable the user to monitor all of the products from a single screen, and require him or her to learn only one interface, instead of several; and  a common data exchange format would make it easier for different organizations (users, vendors, response teams, law enforcement) to not only exchange data, but also communicate about it.
The diversity of uses for the IDMEF needs to be considered when selecting its method of implementation.
About the IDMEF Data Model
The IDMEF data model is an object oriented representation of the alert data sent to intrusion detection managers by intrusion detection analyzers.
Problems Addressed by the Data Model
The data model addresses several problems associated with representing intrusion detection alert data:  Alert information is inherently heterogeneous.
Some alerts are defined with very little information, such as origin, destination, name, and time of the event.
Other alerts provide much more information, such as ports or services, processes, user information, and so on.
The data model that represents this information must be flexible to accommodate different needs.
An object oriented model is naturally extensible via aggregation and subclassing.
If an implementation of the data model extends it with new classes, either by aggregation or subclassing, an implementation that does not understand these extensions will still be able to understand the subset of information that is defined by the data model.
Subclassing and aggregation provide extensibility while preserving the consistency of the model.
Intrusion detection environments are different.
Some analyzers detect attacks by analyzing network traffic; others use operating system logs or application audit trail information.
Alerts for the same attack, sent by analyzers with different information sources, will not contain the same information.
The data model defines support classes that accommodate the differences in data sources among analyzers.
In particular, the notions of source and target for the alert are represented by the combination of Node, Process, Service, and User classes.
Depending on the environment, one may install a lightweight analyzer that provides little information in its alerts, or a more complex analyzer that will have a greater impact on the running system but provide more detailed alert information.
The data model must allow for conversion to formats used by tools other than intrusion detection analyzers, for the purpose of further processing the alert information.
The data model defines extensions to the basic Document Type Definition (DTD) that allow carrying both simple and complex alerts.
Extensions are accomplished through subclassing or association of new classes.
Depending on the kind of network or operating system used, attacks will be observed and reported with different characteristics.
The data model should accommodate these differences.
Significant flexibility in reporting is provided by the Node and Service support classes.
If additional information must be reported, subclasses may be defined that extend the data model with additional attributes.
Commercial vendor objectives are different.
For various reasons, vendors may wish to deliver more or less information about certain types of attacks.
The object oriented approach allows this flexibility while the subclassing rules preserve the integrity of the model.
The data model was designed to provide a standard representation of alerts in an unambiguous fashion, and to permit the relationship between simple and complex alerts to be described.
The goal of the data model is to provide a standard representation of the information that an intrusion detection analyzer reports when it detects an occurrence of some unusual event(s).
These alerts may be simple or complex, depending on the capabilities of the analyzer that creates them.
The design of the data model is content driven.
This means that new objects are introduced to accommodate additional content, not semantic differences between alerts.
This is an important goal, as the task of classifying and naming computer vulnerabilities is both extremely difficult and very subjective.
The data model must be unambiguous.
This means that while we allow analyzers to be more or less precise than one another (i.e., one analyzer may report more information about an event than another)
, we do not allow them to produce contradictory information in two alerts describing the same event (i.e., the common subset of information reported by both analyzers must be identical and inserted in the same placeholders within the alert data structure).
Of course, it is always possible to insert all "interesting" information about an event in extension fields of the alert instead of in the fields where it belongs; however, such practice reduces interoperability and should be avoided whenever possible.
Relationship between Alerts Intrusion detection alerts can be transmitted at several levels.
This document applies to the entire range, from very simple alerts (e.g., those alerts that are the result of a single action or operation in the system, such as a failed login report) to very complex ones (e.g., the aggregation of several events causing an alert to be generated).
As such, the data model must provide a way for complex alerts that aggregate several simple alerts to identify those simple alerts in the complex alert's content.
1.2.  About the IDMEF XML Implementation Two implementations of the IDMEF were originally proposed to the Intrusion Detection Working Group (IDWG):
one using the Structure of Management Information (SMI) to describe a Simple Network Management Protocol (SNMP) MIB, and the other using a DTD to describe XML documents.
These proposed implementations were reviewed by the IDWG at its September 1999 and February 2000 meetings; it was decided at the February meeting that the XML solution was best at fulfilling the IDWG requirements.
The Extensible Markup Language (XML) [3] is a simplified version of the Standard Generalized Markup Language (SGML), a syntax for specifying text markup defined by the ISO 8879 standard.
XML is gaining widespread attention as a language for representing and exchanging documents and data on the Internet, and as the solution to most of the problems inherent in HyperText Markup Language (HTML).
XML was published as a recommendation by the World Wide Web Consortium (W3C) on February 10, 1998.
XML is a metalanguage   a language for describing other languages   that enables an application to define its own markup.
XML allows the definition of customized markup languages for different types of documents and different applications.
This differs from HTML, in which there is a fixed set of identifiers with preset meanings that must be "adapted" for specialized uses.
Both XML and HTML use elements (tags)
But where "<p>" always means "paragraph" in HTML, it may mean "paragraph", "person", "price", or "platypus" in XML, or it might have no meaning at all, depending on the particular application.
XML provides both a syntax for declaring document markup and structure (i.e., defining elements and attributes, specifying the order in which they appear, and so on) and a syntax for using that markup in documents.
Because markup declarations look radically different from markup, many people are confused as to which syntax is called XML.
The answer is that they both are, because they are actually both part of the same language.
For clarity in this document, we will use the terms "XML" and "XML documents" when speaking in the general case, and the term "IDMEF markup" when speaking specifically of the elements (tags) and attributes that describe IDMEF messages.
The publication of XML was followed by the publication of a second recommendation [4] by the World Wide Web Consortium, defining the use of namespaces in XML documents.
An XML namespace is a collection of names, identified by a Uniform Resource Identifier (URI) [5].
When using namespaces, each tag is identified with the namespace it comes from, allowing tags from different namespaces with the same names to occur in the same document.
For example, a single document could contain both "usa:football" and "europe:football" tags, each with different meanings.
In anticipation of the widespread use of XML namespaces, this memo includes the definition of the URI to be used to identify the IDMEF namespace.
Rationale for Implementing IDMEF in XML XML based applications are being used or developed for a wide variety of purposes, including electronic data interchange in a variety of fields, financial data interchange, electronic business cards, calendar and scheduling, enterprise software distribution, web "push" technology, and markup languages for chemistry, mathematics, music, molecular dynamics, astronomy, book and periodical publishing, web publishing, weather observations, real estate transactions, and many others.
XML's flexibility makes it a good choice for these applications; that same flexibility makes it a good choice for implementing the IDMEF as well.
Other, more specific reasons for choosing XML to implement the IDMEF are:  XML allows a custom language to be developed specifically for the purpose of describing intrusion detection alerts.
It also defines a standard way to extend this language, either for later revisions of this document ("standard" extensions) or for vendor specific use ("non standard" extensions).
Software tools for processing XML documents are widely available, in both commercial and open source forms.
Numerous tools and APIs for parsing and/or validating XML are available in a variety of languages, including Java, C, C , Tcl, Perl, Python, and GNU Emacs Lisp.
Widespread access to tools will make adoption of the IDMEF by product developers easier, and hopefully, faster.
XML meets IDMEF Requirement 5.1 [2], that message formats support full internationalization and localization.
The XML standard requires support for both the UTF 8 and UTF 16 encodings of ISO/ IEC 10646 (Universal Multiple Octet Coded Character Set, "UCS") and Unicode, making all XML applications (and
therefore all IDMEF  compliant applications) compatible with these common character encodings.
XML also provides support for specifying, on a per element basis, the language in which the element's content is written, making IDMEF easy to adapt to "Natural Language Support" versions of a product.
XML meets IDMEF Requirement 5.2 [2], that message formats must support filtering and aggregation.
XML's integration with XSL, a style language, allows messages to be combined, discarded, and rearranged.
Ongoing XML development projects, in the W3C and elsewhere, will provide object oriented extensions, database support, and other useful features.
If implemented in XML, the IDMEF immediately gains these features as well.
XML is free, with no license, no license fees, and no royalties.
Notices and Conventions Used in This Document
The keywords "MUST", "MUST NOT", "REQUIRED", "SHALL", "
SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 [1].
An "IDMEF compliant application" is a program or program component, such as an analyzer or manager, that reads and/or writes messages in the format specified by this memo.
An "IDMEF document" is a message that adheres to the requirements specified by this memo and that is exchanged by two or more IDMEF applications.
"IDMEF message" is another term for an "IDMEF document".
Notational Conventions and Formatting Issues
This document uses three notations:
Unified Modeling Language to describe the data model [14], XML to describe the markup used in IDMEF documents, and IDMEF markup to represent the documents themselves.
This section describes IDMEF XML document formatting rules.
Most of these rules are "inherited" from the rules for formatting XML documents.
The format of an IDMEF XML document prolog is described in the following sections.
XML Declaration IDMEF documents being exchanged between IDMEF compliant applications MUST begin with an XML declaration, and MUST specify the XML version in use.
Specification of the encoding in use is RECOMMENDED.
An IDMEF message SHOULD therefore start with: <?
xml version "1.0" encoding "UTF 8"?
IDMEF Message version "1.0" xmlns:idmef "http://iana.org/idmef"/
> IDMEF compliant applications MAY choose to omit the XML declaration internally to conserve space, adding it only when the message is sent to another destination (e.g., a web browser).
This practice is NOT RECOMMENDED unless it can be accomplished without loss of each message's version and encoding information.
In order to be valid (see Section 6.1), an XML document must contain a document type definition.
However, this represents significant overhead to an IDMEF compliant application, both in the bandwidth it consumes as well as the requirements it places on the XML processor (not only to parse the declaration itself, but also to parse the DTD it references).
Implementors MAY decide, therefore, to have analyzers and managers agree out of band on the particular document type definition they will be using to exchange messages (the standard one as defined here, or one with extensions), and then omit the document type definition from IDMEF messages.
The method for negotiating this agreement is outside the scope of this document.
Note that great care must be taken in negotiating any such agreements, as the manager may have to accept messages from many different analyzers, each using a DTD with a different set of extensions.
Character Data Processing in IDMEF
For portability reasons, IDMEF compliant applications SHOULD NOT use, and IDMEF messages SHOULD NOT be encoded in, character encodings other than UTF 8 and UTF 16.
Consistent with the XML standard, if no encoding is specified for an IDMEF message, UTF 8 is assumed.
The ASCII character set is a subset of the UTF 8 encoding, and therefore may be used to encode IDMEF messages.
Per the XML standard, IDMEF documents encoded in UTF 16 MUST begin with the Byte Order Mark described by ISO/IEC 10646 Annex E and Unicode Appendix B (the "ZERO WIDTH NO BREAK SPACE" character, #xFEFF).
All IDMEF elements MUST support the "xml:space" attribute.
IDMEF compliant applications MUST specify the language in which their contents are encoded; in general this can be done by specifying the "xml:lang" attribute for the top level element and letting all other elements "inherit" that definition [10].
IDMEF Data Types Within an XML IDMEF message
, all data will be expressed as "text" (as opposed to "binary"), since XML is a text formatting language.
We provide typing information for the attributes of the classes in the data model, however, to convey to the reader the type of data that the model expects for each attribute.
Each data type in the model has specific formatting requirements in an XML IDMEF message; these requirements are set forth in this section.
Integers Integer attributes are represented by the INTEGER data type.
Integer data MUST be encoded in Base 10 or Base 16.
Base 16 integer encoding uses the digits '0' through '9' and 'a' through 'f' (or their uppercase equivalents), and is preceded by the characters "0x".
Real Numbers Real (floating point)
attributes are represented by the REAL data type.
Real data MUST be encoded in Base 10.
An exponent part consists of an 'e' or 'E', followed by an optional sign, followed by one or more decimal digits.
IDMEF compliant applications MUST support both the '.'
Characters and Strings Single character attributes are represented by the CHARACTER data type.
Multi character attributes of known length are represented by the STRING data type.
Character and string data have no special formatting requirements, other than the need to occasionally use character references (see Section 3.2.3.1 and Section 3.2.3.2) to represent special characters.
Bytes Binary data is represented by the BYTE (and BYTE[]) data type.
Binary data MUST be encoded in its entirety using base64.
Enumerated Types Enumerated types are represented by the ENUM data type, and consist of an ordered list of acceptable values.
Date Time Strings Date time strings are represented by the DATETIME data type.
Each date time string identifies a particular instant in time; ranges are not supported.
Date time strings are formatted according to a subset of ISO 8601: 2000 [6], as show below.
Section references in parentheses refer to sections of the ISO 8601:2000 standard [6].
Dates MUST be formatted as follows:
YYYY MM DD where YYYY is the four digit year
, MM is the two digit month (01 12), and DD is the two digit day (01 31).
(Section 5.2.1.1, "Complete representation   Extended format".)
Times MUST be formatted as follows:
mm:ss where hh is the two digit hour (00 24)
, mm is the two digit minute (00 59), and ss is the two digit second (00 60).
(Section 5.3.1.1, "Complete representation   Extended format".)
Note that midnight has two representations, 00:00:00 and 24:00:00.
Both representations MUST be supported by IDMEF  compliant applications; however, the 00:00:00 representation SHOULD be used whenever possible.
Note also that this format accounts for leap seconds.
Positive leap seconds are inserted between 23:59:59Z and 24:00:00Z and are represented as 23:59:60Z.  Negative leap seconds are achieved by the omission of 23:59:59Z.  IDMEF compliant applications MUST support leap seconds.
Times MAY be formatted to include a decimal fraction of seconds, as follows:
As many digits as necessary may follow the decimal sign (at least one digit must follow the decimal sign).
Decimal fractions of hours and minutes are not supported.
(Section 5.3.1.3, "Representation of decimal fractions".)
Note that the number of digits in the fraction part does not imply anything about accuracy
i.e., "00.100000", "00,1000", and "00.1" are all equivalent.
Times MUST be formatted to include (a) an indication that the time is in Coordinated Universal Time (UTC) or (b) an indication of the difference between the specified time and Coordinated Universal Time.
Times in UTC MUST be formatted by appending the letter 'Z' to the time string as follows:
mm:ss,ssZ (Section 5.3.3, "Coordinated Universal Time (UTC)   Extended format".)
Following the sign, the number of hours and minutes representing the different from UTC is appended, as follows:
The difference from UTC MUST be specified in both hours and minutes, even if the minutes component is 0.
A "difference" of " 00:00" is equivalent to UTC.
(Section 5.3.4.2, "Local time and the difference with Coordinated Universal Time   Extended Format".)
Date time strings are created by joining the date and time strings with the letter 'T', as shown below:
ss,ss hh:mm (Section 5.4.1, "Complete representation   Extended format".)
In summary, IDMEF date time strings MUST adhere to one of the nine templates identified in Paragraph 5, above.
NTP Timestamps NTP timestamps are represented by the NTPSTAMP data type and are described in detail in [7] and [8].
An NTP timestamp is a 64 bit unsigned fixed point number.
The integer part is in the first 32 bits, and the fraction part is in the last 32 bits.
See also Section 6.4 for more information on NTP timestamps.
Port Lists Port lists are represented by the PORTLIST data type and consist of a comma separated list of numbers (individual integers) and ranges (N M means ports N through M, inclusive).
Any combination of numbers and ranges may be used in a single list.
For example, "5 25,37,42,43,53,69 119,123 514".
There are two types of unique identifiers used in this specification.
Both types are represented by STRING data types.
These identifiers are implemented as attributes on the relevant XML elements, and they must have unique values as follows: 1.
The Analyzer class' (Section 4.2.4.1) "analyzerid" attribute, if specified, MUST have a value that is unique across all analyzers in the intrusion detection environment.
The "analyzerid" attribute is not required to be globally unique, only unique within the intrusion detection environment of which the analyzer is a member.
It is permissible for two analyzers, in different intrusion detection environments, to have the same value for "analyzerid".
The default value is "0", which indicates that the analyzer cannot generate unique identifiers.
The Alert and Heartbeat messages (Sections 4.2.2, 4.2.3) must be uniquely identified by the couple (analyzerid,messageid), if the analyzer supports the generation of message identifiers.
The Classification, Source, Target, Node, User, Process, Service, File, Address, and UserId classes' (Sections 4.2.4.2, 4.2.4.3, 4.2.4.4, 4.2.7.2, 4.2.7.3, 4.2.7.4, 4.2.7.5, 4.2.7.6, 4.2.7.2.1, and 4.2.7.3.1) "ident" attribute, if specified, MUST have a value that is unique across all messages sent by the individual analyzer.
The "ident" attribute value MUST be unique for each particular combination of data identifying an object, not for each object.
Objects may have more than one "ident" value associated with them.
For example, an identification of a host by name would have one value, while an identification of that host by address would have another value, and an identification of that host by both name and address would have still another value.
Furthermore, different analyzers may produce different values for the same information.
The "ident" attribute by itself provides a unique identifier only among all the "ident" values sent by a particular analyzer.
But when combined with the "analyzerid" value for the analyzer, a value that is unique across the intrusion detection environment is created.
Again, there is no requirement for global uniqueness.
The default value is "0", which indicates that the analyzer cannot generate unique identifiers.
The specification of methods for creating the unique values contained in these attributes is outside the scope of this document.
The IDMEF Data Model and DTD
In this section, the individual components of the IDMEF data model are explained in detail.
Unified Modeling Language (UML) diagrams of the model are provided to show how the components are related to each other, and relevant sections of the IDMEF DTD are presented to show how the model is translated into XML.
The relationship between the principal components of the data model is shown in Figure 1 (occurrence indicators and attributes are omitted).
The top level class for all IDMEF messages is IDMEF Message; each type of message is a subclass of this top level class.
There are presently two types of messages defined: Alerts and Heartbeats.
Within each message, subclasses of the message class are used to provide the detailed information carried in the message.
It is important to note that the data model does not specify how an alert should be classified or identified.
For example, a port scan may be identified by one analyzer as a single attack against multiple targets, while another analyzer might identify it as multiple attacks from a single source.
However, once an analyzer has determined the type of alert it plans to send, the data model dictates how that alert should be formatted.
Figure 1: Data Model Overview 4.2.
The individual classes are described in the following sections.
All IDMEF messages are instances of the IDMEF Message class; it is the top level class of the IDMEF data model, as well as the IDMEF DTD.
There are currently two types (subclasses) of IDMEF Message: Alert and Heartbeat.
The IDMEF Message class has a single attribute: version
The version of the IDMEF Message specification (this document) this message conforms to.
Applications specifying a value for this attribute MUST specify the value "1.0".
The Alert Class Generally, every time an analyzer detects an event that it has been configured to look for, it sends an Alert message to its manager(s).
Depending on the analyzer, an Alert message may correspond to a single detected event or multiple detected events.
Alerts occur asynchronously in response to outside events.
An Alert message is composed of several aggregate classes, as shown in Figure 2.
The aggregate classes themselves are described in Section 4.2.4, Section 4.2.5, and Section 4.2.6.
The aggregate classes that make up Alert are: Analyzer Exactly one.
Identification information for the analyzer that originated the alert.
The time the alert was created.
Of the three times that may be provided with an Alert, this is the only one that is required.
The "name" of the alert, or other information allowing the manager to determine what it is.
The time the event(s) leading up to the alert was detected.
In the case of more than one event, the time the first event was detected.
In some circumstances, this may not be the same value as CreateTime.
The current time on the analyzer (see Section 6.3).
The source(s) of the event(s) leading up to the alert.
The target(s) of the event(s) leading up to the alert.
Information about the impact of the event, actions taken by the analyzer in response to it, and the analyzer's confidence in its evaluation.
Information included by the analyzer that does not fit into the data model.
This may be an atomic piece of data, or a large amount of data provided through an extension to the IDMEF (see Section 5).
Alert is represented in the IDMEF DTD as follows: <!
; > The Alert class has one attribute: messageid Optional.
A unique identifier for the alert; see Section 3.2.9.
The ToolAlert class carries additional information related to the use of attack tools or malevolent programs such as Trojan horses and can be used by the analyzer when it is able to identify these tools.
It is intended to group one or more previously sent alerts together, to say "these alerts were all the result of someone using this tool".
The ToolAlert class is composed of three aggregate classes, as shown in Figure 3.
The aggregate classes that make up ToolAlert are: name Exactly one.
The reason for grouping the alerts together, for example, the name of a particular tool.
The command or operation that the tool was asked to perform, for example, a BackOrifice ping.
The list of alert identifiers that are related to this alert.
Because alert identifiers are only unique across the alerts sent by a single analyzer, the optional "analyzerid" attribute of "alertident" should be used to identify the analyzer that a particular alert came from.
If the "analyzerid" is not provided, the alert is assumed to have come from the same analyzer that is sending the ToolAlert.
This is represented in the IDMEF DTD as follows: <!
ATTLIST ToolAlert %attlist.global; > 4.2.2.2.
The CorrelationAlert Class The CorrelationAlert class carries additional information related to the correlation of alert information.
It is intended to group one or more previously sent alerts together, to say "these alerts are all related".
The CorrelationAlert class is composed of two aggregate classes, as shown in Figure 4.
The aggregate classes that make up CorrelationAlert are: name Exactly one.
The reason for grouping the alerts together, for example, a particular correlation method.
The list of alert identifiers that are related to this alert.
Because alert identifiers are only unique across the alerts sent by a single analyzer, the optional "analyzerid" attribute of "alertident" should be used to identify the analyzer that a particular alert came from.
If the "analyzerid" is not provided, the alert is assumed to have come from the same analyzer that is sending the CorrelationAlert.
This is represented in the IDMEF DTD as follows.
The OverflowAlert carries additional information related to buffer overflow attacks.
It is intended to enable an analyzer to provide the details of the overflow attack itself.
The OverflowAlert class is composed of three aggregate classes, as shown in Figure 5.
The aggregate classes that make up OverflowAlert are: program Exactly one.
The program that the overflow attack attempted to run (NOTE: this is not the program that was attacked).
The size, in bytes, of the overflow (i.e., the number of bytes the attacker sent).
Some or all of the overflow data itself (dependent on how much the analyzer can capture).
This is represented in the IDMEF DTD as follows: <!
( program, size?, buffer? )
ATTLIST OverflowAlert %attlist.global; > 4.2.3.
The Heartbeat Class Analyzers use Heartbeat messages to indicate their current status to managers.
Heartbeats are intended to be sent in a regular period, say, every ten minutes or every hour.
The receipt of a Heartbeat message from an analyzer indicates to the manager that the analyzer is up and running; lack of a Heartbeat message (or more likely, lack of some number of consecutive Heartbeat messages) indicates that the analyzer or its network connection has failed.
All managers MUST support the receipt of Heartbeat messages; however, the use of these messages by analyzers is OPTIONAL.
Developers of manager software SHOULD permit the software to be configured on a per analyzer basis to use/not use Heartbeat messages.
A Heartbeat message is composed of several aggregate classes, as shown in Figure 6.
The aggregate classes themselves are described in Sections 4.2.4 and 4.2.5.
The aggregate classes that make up Heartbeat are: Analyzer Exactly one.
Identification information for the analyzer that originated the heartbeat.
The time the heartbeat was created.
The interval in seconds at which heartbeats are generated.
The current time on the analyzer (see Section 6.3).
Information included by the analyzer that does not fit into the data model.
This may be an atomic piece of data or a large amount of data provided through an extension to the IDMEF (see Section 5).
This is represented in the IDMEF DTD as follows: <!
; > The Heartbeat class has one attribute: messageid Optional.
A unique identifier for the heartbeat; see Section 3.2.9.
The core classes   Analyzer, Source, Target, Classification, and AdditionalData   are the main parts of Alerts and Heartbeats, as shown in Figure 7.
: The Core Classes 4.2.4.1.
The Analyzer Class The Analyzer class identifies the analyzer from which the Alert or Heartbeat message originates.
Only one analyzer may be encoded for each alert or heartbeat, and that MUST be the analyzer at which the alert or heartbeat originated.
Although the IDMEF data model does not prevent the use of hierarchical intrusion detection systems (where alerts get relayed up the tree), it does not provide any way to record the identity of the "relay" analyzers along the path from the originating analyzer to the manager that ultimately receives the alert.
The Analyzer class is composed of three aggregate classes, as shown in Figure 8.
The aggregate classes that make up Analyzer are: Node Zero or one.
Information about the host or device on which the analyzer resides (network address, network name, etc.).
Information about the process in which the analyzer is executing.
Information about the analyzer from which the message may have gone through.
The idea behind this mechanism is that when a manager receives an alert and wants to forward it to another analyzer, it needs to substitute the original analyzer information with its own.
To preserve the original analyzer information, it may be included in the new analyzer definition.
This will allow analyzer path tracking.
This is represented in the IDMEF DTD as follows: <!
; > The Analyzer class has eight attributes: analyzerid Optional (but see below).
A unique identifier for the analyzer; see Section 3.2.9.
This attribute is only "partially" optional.
If the analyzer makes use of the "ident" attributes on other classes to provide unique identifiers for those objects, then it MUST also provide a valid "analyzerid" attribute.
This requirement is dictated by the uniqueness requirements of the "ident" attribute (they are unique only within the context of a particular "analyzerid").
If the analyzer does not make use of the "ident" attributes, however, it may also omit the "analyzerid" attribute.
An explicit name for the analyzer that may be easier to understand than the analyzerid.
The manufacturer of the analyzer software and/or hardware.
The model name/number of the analyzer software and/or hardware.
The version number of the analyzer software and/or hardware.
The class of analyzer software and/or hardware.
On POSIX 1003.1 compliant systems, this is the value returned in utsname.sysname by the uname() system call, or the output of the "uname  s" command.
On POSIX 1003.1 compliant systems, this is the value returned in utsname.release by the uname() system call, or the output of the "uname  r" command.
The "manufacturer", "model", "version", and "class" attributes' contents are vendor specific, but may be used together to identify different types of analyzers (and perhaps make determinations about the contents to expect in other vendor specific fields of IDMEF messages).
The Classification class provides the "name" of an alert, or other information allowing the manager to determine what it is.
This name is chosen by the alert provider.
The Classification class is composed of one aggregate class, as shown in Figure 9.
The aggregate class that makes up Classification is: Reference Zero or more.
Information about the message, pointing to external documentation sites
, that will provide background information about the alert.
This is represented in the IDMEF DTD as follows: <!
> The Classification class has two attributes: ident Optional.
A unique identifier for this classification; see Section 3.2.9.
A vendor provided string identifying the Alert message.
The Source class contains information about the possible source(s) of the event(s) that generated an alert.
An event may have more than one source (e.g., in a distributed denial of service attack).
The Source class is composed of four aggregate classes, as shown in Figure 10.
The aggregate classes that make up Source are: Node Zero or one.
Information about the host or device that appears to be causing the events (network address, network name, etc.).
Information about the user that appears to be causing the event(s).
Information about the process that appears to be causing the event(s).
Information about the network service involved in the event(s).
This is represented in the IDMEF DTD as follows: <!
( Node?, User?, Process?, Service? )
A unique identifier for this source; see Section 3.2.9.
An indication of whether the source is, as far as the analyzer can determine, a spoofed address used for hiding the real origin of the attack.
The permitted values for this attribute are shown below.
The default value is "unknown".
May be used by a network based analyzer with multiple interfaces to indicate which interface this source was seen on.
The Target class contains information about the possible target(s) of the event(s) that generated an alert.
An event may have more than one target (e.g., in the case of a port sweep).
The Target class is composed of four aggregate classes, as shown in Figure 11.
The aggregate classes that make up Target are: Node Zero or one.
Information about the host or device at which the event(s) (network address, network name, etc.) is being directed.
Information about the user at which the event(s) is being directed.
Information about the process at which the event(s) is being directed.
Information about the network service involved in the event(s).
Information about file(s) involved in the event(s).
This is represented in the IDMEF DTD as follows: <!
A unique identifier for this target, see Section 3.2.9.
An indication of whether the target is, as far as the analyzer can determine, a decoy.
The permitted values for this attribute are shown below.
The default value is "unknown".
May be used by a network based analyzer with multiple interfaces to indicate which interface this target was seen on.
The Assessment Class The Assessment class is used to provide the analyzer's assessment of an event   its impact, actions taken in response, and confidence.
The Assessment class is composed of three aggregate classes, as shown in Figure 12.
The aggregate classes that make up Assessment are: Impact Zero or one.
The analyzer's assessment of the impact of the event on the target(s).
The action(s) taken by the analyzer in response to the event.
A measurement of the confidence the analyzer has in its evaluation of the event.
This is represented in the IDMEF DTD as follows: <!
( Impact?, Action , Confidence? )
ATTLIST Assessment %attlist.global; > 4.2.4.6.
The AdditionalData Class The AdditionalData class is used to provide information that cannot be represented by the data model.
AdditionalData can be used to provide atomic data (integers, strings, etc.)
in cases where only small amounts of additional information need to be sent; it can also be used to extend the data model and the DTD to support the transmission of complex data (such as packet headers).
Detailed instructions for extending the data model and the DTD are provided in Section 5.
The AdditionalData element is declared in the IDMEF DTD as follows: <!
#IMPLIED %attlist.global; > The AdditionalData class has one attribute: meaning Optional.
A string describing the meaning of the element content.
These values will be vendor/implementation dependent; the method for ensuring that managers understand the strings sent by analyzers is outside the scope of this specification.
A list of acceptable meaning keywords is not within the scope of the document, although later versions may undertake to establish such a list.
The data model provides three classes for representing time.
These classes are elements of the Alert and Heartbeat classes.
The time classes are represented in the IDMEF DTD as follows: <!
If the date and time represented by the element content and the NTP timestamp differ (should "never" happen), the value in the NTP timestamp MUST be used.
The CreateTime class is used to indicate the date and time the alert or heartbeat was created by the analyzer.
The DetectTime Class The DetectTime class is used to indicate the date and time that the event(s) producing an alert was detected by the analyzer.
In the case of more than one event, it is the time that the first event was detected.
(This may or may not be the same time as CreateTime; analyzers are not required to send alerts immediately upon detection).
The AnalyzerTime Class The AnalyzerTime class is used to indicate the current date and time on the analyzer.
Its values should be filled in as late as possible in the message transmission process, ideally immediately before placing the message "on the wire".
The use of <AnalyzerTime> to perform rudimentary time synchronization between analyzers and managers is discussed in Section 6.3.
The data model provides three types of "assessments" that an analyzer can make about an event.
These classes are aggregates of the Assessment class.
The Impact class is used to provide the analyzer's assessment of the impact of the event on the target(s).
It is represented in the IDMEF DTD as follows: <!
severity An estimate of the relative severity of the event.
The permitted values are shown below.
There is no default value.
An indication of whether the analyzer believes the attempt that the event describes was successful or not.
The permitted values are shown below.
There is no default value.
The type of attempt represented by this event, in relatively broad categories.
The permitted values are shown below.
The default value is "other".
The element itself may be empty, or may contain a textual description of the impact, if the analyzer is able to provide additional details.
The Action class is used to describe any actions taken by the analyzer in response to the event.
Is is represented in the IDMEF DTD as follows: <!
( block installed   notification sent   taken offline   other ) "
The permitted values are shown below.
The default value is "other".
The element itself may be empty, or may contain a textual description of the action, if the analyzer is able to provide additional details.
The Confidence class is used to represent the analyzer's best estimate of the validity of its analysis.
It is represented in the IDMEF DTD as follows: <!
; > The Confidence class has one attribute: rating The analyzer's rating of its analytical validity.
The permitted values are shown below.
The default value is "numeric".
This element should be used only when the analyzer can produce meaningful information.
Systems that can output only a rough heuristic should use "low", "medium", or "high" as the rating value.
In this case, the element content should be omitted.
Systems capable of producing reasonable probability estimates should use "numeric" as the rating value and include a numeric confidence value in the element content.
This numeric value should reflect a posterior probability (the probability that an attack has occurred given the data seen by the detection system and the model used by the system).
It is a floating point number between 0.0 and 1.0, inclusive.
The number of digits should be limited to those representable by a single precision floating point value, and may be represented as described in Section 3.2.2.
It should be noted that different types of analyzers may compute confidence values in different ways and that in many cases, confidence values from different analyzers should not be compared (for example, if the analyzers use different methods of computing or representing confidence, or are of different types or configurations).
Care should be taken when implementing systems that process confidence values (such as event correlators) not to make comparisons or assumptions that cannot be supported by the system's knowledge of the environment in which it is working.
The support classes make up the major parts of the core classes, and are shared between them.
The Reference class provides the "name" of an alert, or other information allowing the manager to determine what it is.
The Reference class is composed of two aggregate classes, as shown in Figure 13.
The aggregate classes that make up Reference are: name Exactly one.
The name of the alert, from one of the origins listed below.
A URL at which the manager (or the human operator of the manager) can find additional information about the alert.
The document pointed to by the URL may include an in depth description of the attack, appropriate countermeasures, or other information deemed relevant by the vendor.
This is represented in the IDMEF DTD as follows: <!
The Reference class has two attributes: origin Required.
The source from which the name of the alert originates.
The permitted values for this attribute are shown below.
The default value is "unknown".
The meaning of the reference, as understood by the alert provider.
This field is only valid if the value of the <origin> attribute is set to "vendor specific" or "user specific".
The Node Class The Node class is used to identify hosts and other network devices (routers, switches, etc.).
The Node class is composed of three aggregate classes, as shown in Figure 14.
The aggregate classes that make up Node are: location Zero or one.
The location of the equipment.
The name of the equipment.
This information MUST be provided if no Address information is given.
The network or hardware address of the equipment.
Unless a name (above) is provided, at least one address must be specified.
This is represented in the IDMEF DTD as follows: <!
A unique identifier for the node; see Section 3.2.9.
The "domain" from which the name information was obtained, if relevant.
The permitted values for this attribute are shown in the table below.
The default value is "unknown".
(See also Section 10 for extensions to the table.)
Domain unknown or not relevant
The Address class is used to represent network, hardware, and application addresses.
The Address class is composed of two aggregate classes, as shown in Figure 15.
The aggregate classes that make up Address are: address Exactly one.
The format of this data is governed by the category attribute.
The network mask for the address, if appropriate.
This is represented in the IDMEF DTD as follows: <!
ipv6 net mask ) "
; > The Address class has four attributes: ident Optional.
A unique identifier for the address; see Section 3.2.9.
The type of address represented.
The permitted values for this attribute are shown below.
The default value is "unknown".
IBM Shared Network Architecture (SNA)
ipv6 net mask   IPv6 network address, slash,
The name of the Virtual LAN to which the address belongs.
The number of the Virtual LAN to which the address belongs.
The User Class The User class is used to describe users.
It is primarily used as a "container" class for the UserId aggregate class, as shown in Figure 16.
The aggregate class contained in User is: UserId One or more.
Identification of a user, as indicated by its type attribute (see Section 4.2.7.3.1).
This is represented in the IDMEF DTD as follows: <!
A unique identifier for the user; see Section 3.2.9.
The type of user represented.
The permitted values for this attribute are shown below.
The default value is "unknown".
The UserId Class The UserId class provides specific information about a user.
More than one UserId can be used within the User class to indicate attempts to transition from one user to another, or to provide complete information about a user's (or process') privileges.
The UserId class is composed of two aggregate classes, as shown in Figure 17.
The aggregate classes that make up UserId are: name Zero or one.
A user or group name.
A user or group number.
This is represented in the IDMEF DTD as follows: <!
; > The UserId class has three attributes: ident Optional.
A unique identifier for the user id, see Section 3.2.9.
The type of user information represented.
The permitted values for this attribute are shown below.
The default value is "original user".
associated with a file permission.
The tty the user is using.
The Process class is used to describe processes being executed on sources, targets, and analyzers.
The Process class is composed of five aggregate classes, as shown in Figure 18.
The aggregate classes that make up Process are: name Exactly one.
The name of the program being executed.
This is a short name; path and argument information are provided elsewhere.
The process identifier of the process.
The full path of the program being executed.
A command line argument to the program.
Multiple arguments may be specified (they are assumed to have occurred in the same order they are provided) with multiple uses of arg.
An environment string associated with the process; generally of the format "VARIABLE value".
Multiple environment strings may be specified with multiple uses of env.
This is represented in the IDMEF DTD as follows: <!
path?, arg , env  )
; > The Process class has one attribute: ident Optional.
A unique identifier for the process; see Section 3.2.9.
The Service Class The Service class describes network services on sources and targets.
It can identify services by name, port, and protocol.
When Service occurs as an aggregate class of Source, it is understood that the service is one from which activity of interest is originating; and that the service is "attached" to the Node, Process, and User information also contained in Source.
Likewise, when Service occurs as an aggregate class of Target, it is understood that the service is one to which activity of interest is being directed; and that the service is "attached" to the Node, Process, and User information also contained in Target.
If Service occurs in both Source and Target, then information in both locations should be the same.
If information is the same in both locations and implementers wish to carry it in only one location, they should specify it as an aggregate of the Target class.
The Service class is composed of four aggregate classes, as shown in Figure 19.
The aggregate classes that make up Service are: name Zero or one.
The name of the service.
Whenever possible, the name from the IANA list of well known ports SHOULD be used.
The port number being used.
A list of port numbers being used; see Section 3.2.8 for formatting rules.
If a portlist is given, the iana protocol number and iana protocol name MUST apply to all the elements of the list.
Additional information about the protocol being used.
The intent of the protocol field is to carry additional information related to the protocol being used when the <Service> attributes iana protocol number or/and iana protocol name are filed.
A Service MUST be specified as either (a) a name or a port or (b) a portlist.
The protocol is optional in all cases, but no other combinations are permitted.
Service is represented in the IDMEF DTD as follows: <!
#IMPLIED iana protocol number CDATA
; > The Service class has four attributes: ident Optional.
A unique identifier for the service; see Section 3.2.9.
The WebService class carries additional information related to web traffic.
The WebService class is composed of four aggregate classes, as shown in Figure 20.
The aggregate classes that make up WebService are: url Exactly one.
The URL in the request.
The CGI script in the request, without arguments.
http method Zero or one.
The HTTP method (PUT, GET) used in the request.
The arguments to the CGI script.
This is represented in the IDMEF DTD as follows: <!
The SNMPService class carries additional information related to SNMP traffic.
The aggregate classes composing SNMPService must be interpreted as described in RFC 3411 [15] and RFC 3584 [16].
The SNMPService class is composed of eight aggregate classes, as shown in Figure 21.
The aggregate classes that make up SNMPService are: oid Zero or one.
The object identifier in the request.
The SNMP version, typically 0 for SNMPv1, 1 for SNMPv2c, 2 for SNMPv2u and SNMPv2 , and 3 for SNMPv3; see RFC 3411 [15] Section 5 for appropriate values.
The identification of the security model in use, typically 0 for any, 1 for SNMPv1, 2 for SNMPv2c, and 3 for USM; see RFC 3411 [15] Section 5 for appropriate values.
The object's security name; see RFC 3411 [15] Section 3.2.2.
The security level of the SNMP request; see RFC 3411 [15] Section 3.4.3.
The object's context name; see RFC 3411 [15] Section 3.3.3.
The object's context engine identifier; see RFC 3411 [15] Section 3.3.2.
The command sent to the SNMP server (GET, SET, etc.).
If other fields of an SNMP message are available and should be incorporated in the IDMEF alert, they must be located in the additionaldata structure with the meaning being an object definition defined in RFC 3411
[15] Section 5 and the value located within the additionaldata payload.
This is represented in the IDMEF DTD as follows: <!
, contextName?, contextEngineID?, command? )
ATTLIST SNMPService %attlist.global; > 4.2.7.6.
The File class provides specific information about a file or other file like object that has been created, deleted, or modified on the target.
The description can provide either the file settings prior to the event or the file settings at the time of the event, as specified using the "category" attribute.
The File class is composed of eleven aggregate classes, as shown in Figure 22.
The aggregate classes that make up File are: name Exactly one.
The name of the file to which the alert applies, not including the path to the file.
The full path to the file, including the name.
The path name should be represented in as "universal" a manner as possible, to facilitate processing of the alert.
For Windows systems, the path should be specified using the Universal Naming Convention (UNC) for remote files, and using a drive letter for local files (e.g., "C:\boot.ini").
For Unix systems, paths on network file systems should use the name of the mounted resource instead of the local mount point (e.g., "fileserver:/usr/local/bin/foo").
The mount point can be provided using the <Linkage> element.
create time Zero or one.
Time the file was created.
Note that this is  not  the Unix "st ctime" file attribute (which is not file creation time).
The Unix "st ctime" attribute is contained in the "Inode" class.
modify time Zero or one.
Time the file was last modified.
access time Zero or one.
Time the file was last accessed.
data size Zero or one.
The size of the data, in bytes.
Typically what is meant when referring to file size.
On Unix UFS file systems, this value corresponds to stat.st size.
On Windows NTFS, this value corresponds to Valid Data Length (VDL).
disk size Zero or one.
The physical space on disk consumed by the file, in bytes.
On Unix UFS file systems, this value corresponds to 512   stat.st blocks.
On Windows NTFS, this value corresponds to End of File (EOF).
Access permissions on the file.
File system objects to which this file is linked (other references for the file).
Inode information for this file (relevant to Unix).
Checksum information for this file.
This is represented in the IDMEF DTD as follows: <!
; > The File class has four attributes (one required and three optional): ident Optional.
A unique identifier for this file; see Section 3.2.9.
The context for the information being provided.
The permitted values are shown below.
There is no default value.
The type of file system the file resides on.
This attribute governs how path names and other attributes are interpreted.
16 bit Windows FAT File System
32 bit Windows FAT File System
The type of file, as a mime type.
The FileAccess Class The FileAccess class represents the access permissions on a file.
The representation is intended to be useful across operating systems.
The FileAccess class is composed of two aggregate classes, as shown in Figure 23.
The aggregate classes that make up FileAccess are: UserId Exactly one.
The user (or group) to which these permissions apply.
The value of the "type" attribute must be "user privs", "group privs", or "other privs" as appropriate.
Other values for "type" MUST NOT be used in this context.
The permitted values are shown below.
There is no default value.
On Unix, the owner of the file always has "changePermissions" access, even if no other access is allowed for that user.
"Full Control" in Windows is represented by enumerating the permissions it contains.
The "executeAs" string represents the set user id and set group id features in Unix.
This is represented in the IDMEF DTD as follows: <!
The Linkage Class The Linkage class represents file system connections between the file described in the <File> element and other objects in the file system.
For example, if the <File> element is a symbolic link or shortcut, then the <Linkage> element should contain the name of the object the link points to.
Further information can be provided about the object in the <Linkage> element with another <File> element, if appropriate.
The Linkage class is composed of three aggregate classes, as shown in Figure 24.
The aggregate classes that make up Linkage are: name Exactly one.
The name of the file system object, not including the path.
The full path to the file system object, including the name.
The path name should be represented in as "universal" a manner as possible, to facilitate processing of the alert.
File> element may be used in place of the <name> and <path> elements if additional information about the file is to be included.
This is represented in the IDMEF DTD as follows: <!
shortcut   stream   symbolic link ) "
The permitted values are shown below.
There is no default value.
The Inode Class The Inode class is used to represent the additional information contained in a Unix file system i node.
The Inode class is composed of six aggregate classes, as shown in Figure 25.
The aggregate classes that make up Inode are: change time Zero or one.
The time of the last inode change, given by the st ctime element of "struct stat".
major device Zero or one.
The major device number of the device the file resides on.
minor device Zero or one.
The minor device number of the device the file resides on.
c major device Zero or one.
The major device of the file itself, if it is a character special device.
c minor device Zero or one.
The minor device of the file itself, if it is a character special device.
Note that <number>, <major device>, and
<minor device> must be given together, and the <c major device> and <c minor device> must be given together.
This is represented in the IDMEF DTD as follows: <!
The Checksum class represents checksum information associated with the file.
This checksum information can be provided by file integrity checkers, among others.
The checksum class is composed of two aggregate classes, as shown in Figure 26.
The aggregate classes that make up Checksum are: value Exactly one.
The value of the checksum.
The key to the checksum, if appropriate.
This is represented in the IDMEF DTD as follows: <!
" ( MD4   MD5   SHA1   SHA2 256
The cryptographic algorithm used for the computation of the checksum.
The permitted values are shown below.
There is no default value.
The SHA2 algorithm with 256 bits length.
The SHA2 algorithm with 384 bits length.
The SHA2 algorithm with 512 bits length.
The CRC algorithm with 32 bits length.
As intrusion detection systems evolve, the IDMEF data model and DTD will have to evolve along with them.
To allow new features to be added as they are developed, both the data model and the DTD can be extended as described in this section.
As these extensions mature, they can then be incorporated into future versions of the specification.
There are two mechanisms for extending the IDMEF data model, inheritance and aggregation:
Inheritance denotes a superclass/subclass type of relationship where the subclass inherits all the attributes, operations, and relationships of the superclass.
This type of relationship is also called a "is a" or "kind of" relationship.
Subclasses may have additional attributes or operations that apply only to the subclass and not to the superclass.
Aggregation is a form of association in which the whole is related to its parts.
This type of relationship is also referred to as a "part of" relationship.
In this case, the aggregate class contains all of its own attributes and as many of the attributes associated with its parts as required and specified by occurrence indicators.
Of the two mechanisms, inheritance is preferred, because it preserves the existing data model structure and also preserves the operations (methods) executed on the classes of the structure.
Note that the rules for extending the IDMEF DTD (see below)
set limits on the places where extensions to the data model may be made.
There are two ways to extend the IDMEF DTD: 1.
The AdditionalData class (see Section 4.2.4.6) allows implementors to include arbitrary "atomic" data items (integers, strings, etc.)
in an Alert or Heartbeat message.
This approach SHOULD be used whenever possible.
See Section 7.4 and Section 7.5.
The AdditionalData class allows implementors to extend the IDMEF DTD with additional DTD "modules" that describe arbitrarily complex data types and relationships.
The remainder of this section describes this extension method.
To extend the IDMEF DTD with a new DTD "module", the following steps MUST be followed: 1.
The document declaration MUST define a DTD location that defines the namespace and contains the location of the extension DTD, and then reference that namespace.
Multiple extensions may be included by defining multiple namespaces and DTD locations, and referencing them.
Extension DTDs MUST declare all of their elements and attributes in a separate XML namespace.
Extension DTDs MUST NOT declare any elements or attributes in the "idmef" or default namespaces.
Extensions MUST only be included in IDMEF Alert and Heartbeat messages under an <AdditionalData> element whose "type" attribute contains the value "xml".
For example: In this example, the "vendorco" namespace is defined and then referenced, causing the DTD for the extension to be read by the XML parser.
<idmef:IDMEF Message version "1.0" xmlns:xsi "http://www.w3.org/2001/XMLSchema instance" xmlns:idmef "http://iana.org/idmef" xmlns:vendorco "http://vendor.com/idmef"
AdditionalData type "xml" meaning "VendorExtension"
> <idmef:xml> <vendorco:TestVendor a "attribute of example" xmlns:vendorco "http://vendor.com/idmef" xsi:schemaLocation "http://vendor.com/idmef http://v.com/vidmef.xsd"
TestVendor> </idmef:xml> </idmef:AdditionalData> </idmef:Alert> </idmef:
See Section 7.8 for another example of extending the IDMEF DTD.
This section discusses some of the special considerations that must be taken into account by implementors of the IDMEF.
It is expected that IDMEF compliant applications will not normally include the IDMEF DTD itself in their communications.
Instead, the DTD will be referenced in the document type definition in the IDMEF message.
Such IDMEF documents will be well formed and valid as defined in [3].
Other IDMEF documents will be specified that do not include the document prolog (e.g., entries in an IDMEF format database).
Such IDMEF documents will be well formed but not valid.
Validity further implies that not only is the document well formed, but it also follows specific rules (contained in the Document Type Definition) about which elements are "legal" in the document, how those elements nest within other elements, and so on (e.g., a "chapter" does not begin in the middle of a "title").
A document cannot be valid unless it references a DTD.
XML processors are required to be able to parse any well formed document, valid or not.
The purpose of validation is to make the processing of that document (what's done with the data after it's parsed) easier.
Without validation, a document may contain elements in nonsense order, elements "invented" by the author that the processing application doesn't understand, and so forth.
IDMEF documents MUST be well formed.
IDMEF documents SHOULD be valid whenever both possible and practical.
On occasion, an IDMEF compliant application may receive a well  formed, or even well formed and valid, IDMEF message containing tags that it does not understand.
The tags may be either:  Recognized as "legitimate" (a valid document), but the application does not know the semantic meaning of the element's content; or  Not recognized at all.
IDMEF compliant applications MUST continue to process IDMEF messages that contain unknown tags, provided that such messages meet the well  formedness requirement of Section 6.1.
It is up to the individual application to decide how to process (or ignore)
any content from the unknown elements(s).
Analyzer Manager Time Synchronization Synchronization of time of day clocks between analyzers and managers is outside the scope of this document.
However, the following comments and suggestions are offered: 1.
Whenever possible, all analyzers and managers should have their time of day clocks synchronized to an external source such as NTP [7] or SNTP [8]
Global Positioning System (GPS), Geosynchronous Operational Environmental Satellite (GOES), NIST radio station WWV clocks, or some other reliable time standard.
When external time synchronization is not possible, the IDMEF provides the <AnalyzerTime> element, which may be used to perform rudimentary time synchronization (see below).
IDMEF compliant applications SHOULD permit the user to enable/ disable
the <AnalyzerTime> method of time synchronization as a configuration option.
A number of caveats apply to the use of <AnalyzerTime> for time synchronization: 1.
<AnalyzerTime> works best in a "flat" environment where analyzers report up to a single level of managers.
When a tree topology of high level managers, intermediate relays, and analyzers is used, the problem becomes more complex.
When intermediate message relays (managers or otherwise) are involved, two scenarios are possible:
The intermediaries may forward entire IDMEF messages, or may perform aggregation or correlation, but MUST NOT inject delay.
In this case, time synchronization is end to end between the analyzer and the highest level manager.
The intermediaries may inject delay, due to storage or additional processing.
In this case, time synchronization MUST be performed at each hop.
This means each intermediary must decompose the IDMEF message, adjust all time values, and then reconstruct the message before sending it on.
When the environment is mixed, with some analyzers and managers using external time synchronization and some not, all managers and intermediaries must perform <AnalyzerTime> synchronization.
This is because determining whether or not compensation is actually needed between two parties rapidly becomes very complex, and requires knowledge of other parts of the topology.
If an alert can take alternate paths, or be stored in multiple locations, the recorded times may be different depending on the path taken.
The above being said, <AnalyzerTime> synchronization is probably still better than nothing in many environments.
To implement this type of synchronization, the following procedure is suggested: 1.
When an analyzer or manager sends an IDMEF message, it should place the current value of its time of day clock in an <AnalyzerTime> element.
This should occur as late as possible in the message transmission process, ideally right before the message is "put on the wire".
When a manager receives an IDMEF message, it should compute the difference between its own time of day clock and the time in the <AnalyzerTime> element of the message.
This difference should then be used to adjust the times in the <CreateTime> and <DetectTime> elements (NTP timestamps should also be adjusted).
If the manager is an intermediary and sends the IDMEF message on to a higher level manager, and hop by hop synchronization is in effect, it should regenerate the <AnalyzerTime> value to contain the value of its own time of day clock.
NTP Timestamp Wrap Around From [8]
: Note that, since some time in 1968 (second 2,147,483,648) the most significant bit (bit 0 of the integer part) has been set and that the 64 bit field will overflow some time in 2036 (second 4,294,967,296).
Should NTP or SNTP be in use in 2036, some external means will be necessary to qualify time relative to 1900 and time relative to 2036 (and other multiples of 136 years).
There will exist a 200 picosecond interval, henceforth ignored, every 136 years when the 64 bit field will be 0, which by convention is interpreted as an invalid or unavailable timestamp.
IDMEF compliant applications MUST NOT send a zero valued NTP timestamp unless they mean to indicate that it is invalid or unavailable.
If an IDMEF compliant application must send an IDMEF message at the time of rollover, the application should wait for 200 picoseconds until the timestamp will have a non zero value.
Also from [8]: As the NTP timestamp format has been in use for the last 17 years, it remains a possibility that it will be in use 40 years from now when the seconds field overflows.
As it is probably inappropriate to archive NTP timestamps before bit 0 was set in 1968, a convenient way to extend the useful life of NTP timestamps is the following convention: If bit 0 is set, the UTC time is in the range 1968 2036 and UTC time is reckoned from 0h 0
m 0s UTC on 1 January 1900.
If bit 0 is not set, the time is in the range 2036 2104 and UTC time is reckoned from 6h 28m 16s UTC on 7 February 2036.
Note that when calculating the correspondence, 2000 is not a leap year.
Note also that leap seconds are not counted in the reckoning.
IDMEF compliant applications in use after 2036 02 07T06:28:16Z MUST adhere to the above convention.
Digital Signatures Standard XML digital signature processing rules and syntax are specified in [13].
XML Signatures provide integrity, message authentication, and/or signer authentication services for data of any type, whether located within the XML that includes the signature or elsewhere.
The IDMEF requirements document [2] assigns responsibility for message integrity and authentication to the communications protocol, not the message format.
However, in situations where IDMEF messages are exchanged over other, less secure protocols, or in cases where the digital signatures must be archived for later use, the inclusion of digital signatures within an IDMEF message itself may be desirable.
Specifications for the use of digital signatures within IDMEF messages are outside the scope of this document.
However, if such functionality is needed, use of the XML Signature standard is RECOMMENDED.
The examples shown in this section demonstrate how the IDMEF is used to encode alert data.
These examples are for illustrative purposes only, and do not necessarily represent the only (or even the "best") way to encode these particular alerts.
These examples should not be taken as guidelines on how alerts should be classified.
The following examples show how some common denial of service attacks could be represented in the IDMEF.
The "teardrop" Attack Network based detection of the "teardrop" attack.
This shows the basic format of an alert.
xml version "1.0" encoding "UTF 8"?
> <idmef:IDMEF Message xmlns:idmef "http://iana.org/idmef" version "1.0"> <idmef:Alert messageid "abc123456789"> <idmef:Analyzer analyzerid "hq dmz analyzer01"> <idmef:Node category "dns">
> 2000 03 09T10:01:25.93464 05:00 </idmef:CreateTime
> <idmef:Source ident "a1b2c3d4"> <idmef:Node ident "a1b2c3d4 001" category "dns"> <idmef:name>badguy.example.net</idmef:name> <idmef:Address ident "a1b2c3d4 002" category "ipv4 net mask"> <idmef:
Node> </idmef:Source> <idmef:Target ident "d1c2b3a4"> <idmef:
Node ident "d1c2b3a4 001" category "dns"
> <idmef:Address category "ipv4 addr hex"> <idmef:address>0xde796f70</idmef:address> </idmef:Address> </idmef:Node> </idmef:Target> <idmef:Classification text "
Teardrop detected"> <idmef:Reference origin "bugtraqid"
The "ping of death" Attack Network based detection of the "ping of death" attack.
Note the identification of multiple targets, and the identification of the source as a spoofed address.
The URL has been cut to fit the IETF formating requirements.
xml version "1.0" encoding "UTF 8"?
> <idmef:IDMEF Message version "1.0" xmlns:idmef "http://iana.org/idmef"> <idmef:Alert messageid "abc123456789"> <idmef:Analyzer analyzerid "bc sensor01"
> <idmef:name>sensor.example.com</idmef:name> </idmef:Node> </idmef:Analyzer> <idmef:CreateTime ntpstamp "
09T10:01:25.93464Z </idmef:CreateTime> <idmef:Source ident "a1a2" spoofed "yes"
> <idmef:Node ident "a1a2 1"> <idmef:Address ident "a1a2
2" category "ipv4 addr"> <idmef:
:Node> </idmef:Source> <idmef:Target ident "b3b4"> <idmef:Node> <idmef:
" category "ipv4 addr"> <idmef:
Node ident "c5c6 1" category "nisplus"
> <idmef:name>lollipop</idmef:name> </idmef:Node> </idmef:Target> <idmef:Target ident "d7d8"> <idmef:Node ident "d7d8 1"> <idmef:location>Cabinet B10</idmef:location> <idmef:name>Cisco.router.b10</idmef:name> </idmef:Node> </idmef:Target> <idmef:Classification text "Ping of death
detected"> <idmef:Reference origin "cve"> <idmef:name
http://www.cve.mitre.org/cgi bin/ cvename.cgi?name CVE 1999
The following examples show how some common port scanning attacks could be represented in the IDMEF.
Connection to a Disallowed Service Host based detection of a policy violation (attempt to obtain information via "finger").
Note the identification of the target service, as well as the originating user (obtained, e.g., through RFC 1413 [11]).
xml version "1.0" encoding "UTF 8"?
> <idmef:IDMEF Message version "1.0" xmlns:idmef "http://iana.org/idmef"> <idmef:Alert messageid "abc123456789"> <idmef:Analyzer analyzerid "bc sensor01"
> <idmef:name>sensor.example.com</idmef:name> </idmef:Node> </idmef:Analyzer> <idmef:CreateTime ntpstamp "0xbc72541d.0x00000000"
03 09T18:47:25 02:00 </idmef:CreateTime> <idmef:
Source ident "a123"> <idmef:Node ident "a123 01"> <idmef:Address ident "a123 02" category "ipv4 addr"> <idmef:
User ident "q987 03" category "
> <idmef:UserId ident "q987 04" type "target user"> <idmef:name
Service ident "a123 03"> <idmef:
> <idmef:Node ident "z456 01" category "nis"> <idmef:name>myhost</idmef:name> <idmef:
Address ident "z456 02" category "ipv4 addr"> <idmef:
:Target> <idmef:Classification text "Portscan"> <idmef:Reference origin "vendor specific"> <idmef:name
<idmef:Reference origin "vendor specific" meaning "general documentation"> <idmef:name>
Simple Port Scanning Network based detection of a port scan.
This shows detection by a single analyzer; see Section 7.5 for the same attack as detected by a correlation engine.
Note the use of <portlist> to show the ports that were scanned.
xml version "1.0" encoding "UTF 8"?
> <idmef:IDMEF Message version "1.0" xmlns:idmef "http://iana.org/idmef"> <idmef:Alert messageid "abc123456789"> <idmef:Analyzer analyzerid "hq dmz analyzer62"> <idmef:
:name> </idmef:Node> </idmef:Analyzer> <idmef:CreateTime ntpstamp "0xbc72b2b4.0x00000000"
08:00 </idmef:CreateTime> <idmef:Source ident "abc01"> <idmef:Node ident "abc01 01"> <idmef:Address ident "abc01 02" category "ipv4 addr"> <idmef:
:Node> </idmef:Source> <idmef:Target ident "def01"
Node ident "def01 01" category "dns"
:name> <idmef:Address ident "def01 02" category "ipv4 addr"> <idmef:
Service ident "def01 03"> <idmef:portlist>5
25,37,42,43,53,69 119,123 514 </idmef:portlist> </idmef:Service> </idmef:Target> <idmef:Classification text "simple portscan"
> <idmef:Reference origin "vendor specific"> <idmef:name>portscan</idmef:name> <idmef:url>http://www.vendor.com/portscan</idmef
The following examples show how some common local host attacks could be represented in the IDMEF.
The "loadmodule" Attack Host based detection of the "loadmodule" exploit.
This attack involves tricking the "loadmodule" program into running another program; since "loadmodule" is set user id "root", the executed program runs with super user privileges.
Note the use of <User> and <Process> to identify the user attempting the exploit and how he's doing it.
xml version "1.0" encoding "UTF 8"?
> <idmef:IDMEF Message version "1.0" xmlns:idmef "http://iana.org/idmef"> <idmef:Alert messageid "abc123456789"> <idmef:Analyzer analyzerid "bc fs sensor13"
<idmef:Source ident "a1a2"> <idmef:User ident "a1a2 01" category "
os device"> <idmef:UserId ident "a1a2 02" type "original user"> <idmef:name>joe</idmef:name> <idmef:
UserId> </idmef:User> <idmef:Process ident "a1a2 03"> <idmef:name>loadmodule</idmef:name> <idmef:
> <idmef:Node ident "z3z4 01" category "dns"> <idmef:name>fileserver.example.com</idmef:name> </idmef:Node> </idmef:Target> <idmef:Classification text "Loadmodule attack" ident "loadmodule"> <idmef:Reference origin "bugtraqid"
> <idmef:name>33</idmef:name> <idmef:url>http://www.securityfocus.com</idmef:url> </idmef:Reference> </idmef:Classification> </idmef:Alert> </idmef:
The Intrusion Detection System (IDS) could also indicate that the target user is the "root" user, and show the attempted command; the alert might then look like: <?
xml version "1.0" encoding "UTF 8"?
> <idmef:IDMEF Message version "1.0" xmlns:idmef "http://iana.org/idmef"> <idmef:Alert messageid "abc123456789"> <idmef:Analyzer analyzerid "bc fs sensor13"
<idmef:Source ident "a1a2"> <idmef:User ident "a1a2 01" category "
os device"> <idmef:UserId ident "a1a2 02" type "original user"> <idmef:name>joe</idmef:name> <idmef:
UserId> </idmef:User> <idmef:Process ident "a1a2 03"> <idmef:name>loadmodule</idmef:name> <idmef:
> <idmef:Node ident "z3z4 01" category "dns"> <idmef:name>fileserver.example.com</idmef:name> </idmef:Node> <idmef:User ident "z3z4 02" category "
> <idmef:UserId ident "z3z4 03" type "target user"> <idmef:name>root</idmef:name> <idmef:
number>0</idmef:number> </idmef:UserId> </idmef:User> <idmef:Process ident "z3z4 04"> <idmef:name
Note that the identification of the classification is used.
The "phf" Attack Network based detection of the "phf" attack.
Note the use of the <WebService> element to provide more details about this particular attack.
xml version "1.0" encoding "UTF 8"?
> <idmef:IDMEF Message version "1.0" xmlns:idmef "http://iana.org/idmef"> <idmef:Alert messageid "abc123456789"> <idmef:Analyzer analyzerid "bc sensor01"
> <idmef:name>sensor.example.com</idmef:name> </idmef:Node> </idmef:Analyzer> <idmef:CreateTime ntpstamp "0xbc71e980.0x00000000"
"> <idmef:Node ident "abc123 001"> <idmef:Address ident "abc123 002" category "ipv4 addr"> <idmef:
Service ident "abc123 003"> <idmef:
Service> </idmef:Source> <idmef:Target ident "xyz789"> <idmef:Node ident "xyz789 001" category "dns"
:name> <idmef:Address ident "xyz789 002
" category "ipv4 addr"> <idmef:
<idmef:WebService> <idmef:url> http://www.example.com/cgi bin/phf?/etc/group </idmef:url
Service> </idmef:Target> <idmef:Classification text "phf attack"
> <idmef:url> http://www.securityfocus.com/bid/629 </idmef:url> </idmef:Reference> </idmef:Classification> </idmef:Alert> </idmef:
File Modification Host based detection of a race condition attack.
Note the use of the <File> to provide information about the files that are used to perform the attack.
xml version "1.0" encoding "UTF 8"?
> <idmef:IDMEF Message version "1.0" xmlns:idmef "http://iana.org/idmef"
<idmef:Analyzer analyzerid "bids 192.0.2.1" ostype "Linux" osversion "2.2.16 3"
> <idmef:Node category "hosts"> <idmef:name>etude</idmef:name> <idmef:Address category "ipv4 addr"> <idmef:
address>192.0.2.1</idmef:address> </idmef:Address> </idmef:Node> </idmef:Analyzer> <idmef:
/idmef:CreateTime> <idmef:Source spoofed "no"> <idmef:Node
> <idmef:location>console</idmef:location> <idmef:Address category "ipv4 addr"> <idmef:
address>192.0.2.1</idmef:address> </idmef:Address> </idmef:Node> </idmef:Source> <idmef:Target decoy "no"> <idmef:
> <idmef:Address category "ipv4 addr"> <idmef:
address>192.0.2.1</idmef:address> </idmef:Address> </idmef:Node> <idmef:User category "os device"> <idmef:UserId type "original user"> <idmef:
UserId> <idmef:UserId type "current user"> <idmef:name>fred</idmef:name>
UserId> <idmef:UserId type "user privs"> <idmef:
File category "current" fstype "tmpfs"> <idmef:name>xxx000238483</idmef:name> <idmef:path>/tmp/
xxx000238483</idmef:path> <idmef:FileAccess> <idmef:UserId type "user privs"> <idmef:name>alice</idmef:
FileAccess> <idmef:FileAccess> <idmef:UserId type "group privs"> <idmef:name>user</idmef:name> <idmef:number>42</idmef:number> </idmef:
FileAccess> <idmef:FileAccess> <idmef:UserId type "other privs"> <idmef:name>world</idmef:name> </idmef:
FileAccess> <idmef:Linkage category "symbolic link"> <idmef:name>passwd</idmef:name> <idmef:path>/etc/passwd</idmef:path> </idmef:Linkage> </idmef:File> </idmef:Target> <idmef:Classification text "DOM race condition"
> <idmef:Reference origin "vendor specific"> <idmef:name>DOM race condition</idmef:name> <idmef:url>file://attack info/race.html </idmef:url> </idmef:Reference> </idmef:Classification> </idmef:Alert> </idmef:
In this example, logins are restricted to daytime hours.
The alert reports a violation of this policy that occurs when a user logs in a little after 10:00 pm.
Note the use of <AdditionalData> to provide information about the policy being violated.
xml version "1.0" encoding "UTF 8"?
> <idmef:IDMEF Message version "1.0" xmlns:idmef "http://iana.org/idmef"> <idmef:Alert messageid "abc123456789"> <idmef:Analyzer analyzerid "bc
> <idmef:name>dialserver.example.com</idmef:name> </idmef:Node> </idmef:Analyzer> <idmef:CreateTime ntpstamp "0xbc72e7ef.0x00000000"
> 2000 03 09T22:18:07 05:00 </idmef:CreateTime> <idmef:Source ident "s01"> <idmef:Node ident "s01 1"> <idmef:Address category "ipv4 addr"> <idmef:
address>127.0.0.1</idmef:address> </idmef:Address> </idmef:Node> <idmef:Service ident "s01 2
"> <idmef:port>4325</idmef:port> </idmef:Service> </idmef:Source> <idmef:Target ident "t01"
Node ident "t01 1" category "dns"
User ident "t01 2" category "
> <idmef:UserId ident "t01 3" type "current user"
<idmef:Classification text "Login policy violation"> <idmef:Reference origin "user specific"> <idmef:name>out of hours
:name> <idmef:url>http://my.company.com/policies </idmef:url> </idmef:Reference> </idmef:Classification> <idmef:AdditionalData type "date time" meaning "
/idmef:AdditionalData> <idmef:AdditionalData type "date time" meaning "stop time"> <idmef:date time>2000 03 09T19:30:00
The following example shows how the port scan alert from Section 7.2.2 could be represented if it had been detected and sent from a correlation engine, instead of a single analyzer.
xml version "1.0" encoding "UTF 8"?
> <idmef:IDMEF Message version "1.0" xmlns:idmef "http://iana.org/idmef"> <idmef:Alert messageid "abc123456789"> <idmef:Analyzer analyzerid "bc corr 01"
Node ident "a1 1"> <idmef:
Address ident "a1 2" category "ipv4 addr"> <idmef:
:Node> </idmef:Source> <idmef:Target ident "a2"
> <idmef:Node ident "a2 1" category "dns"
:name> <idmef:Address ident "a2 2" category "ipv4 addr"
Service ident "a2 3"> <idmef:portlist>5
25,37,42,43,53,69 119,123 514 </idmef:portlist> </idmef:Service> </idmef:Target> <idmef:Classification text "Portscan"
> <idmef:Reference origin "vendor specific"> <idmef:name>portscan</idmef:name> <idmef:url>http://www.vendor.com/portscan</idmef
<idmef:name>multiple ports in short time</idmef:name> <idmef:
<idmef:alertident>123456786</idmef:alertident> <idmef:alertident analyzerid "a1b2c3d4">987654321 </idmef:alertident> <idmef:alertident analyzerid "a1b2c3d4">987654322 </idmef:alertident> </idmef:CorrelationAlert> </idmef:Alert> </idmef:IDMEF Message> 7.6.
Analyzer Assessments Host based detection of a successful unauthorized acquisition of root access through the eject buffer overflow.
Note the use of <Assessment> to provide information about the analyzer's evaluation of and reaction to the attack.
xml version "1.0" encoding "UTF 8"?
> <idmef:IDMEF Message version "1.0" xmlns:idmef "http://iana.org/idmef"
/idmef:CreateTime> <idmef:Source spoofed "no"> <idmef:Node
> <idmef:location>console</idmef:location> <idmef:Address category "ipv4 addr"> <idmef:
address>192.0.2.1</idmef:address> </idmef:Address> </idmef:Node> </idmef:Source> <idmef:Target decoy "no"> <idmef:
> <idmef:Address category "ipv4 addr"> <idmef:
address>192.0.2.1</idmef:address> </idmef:Address> </idmef:Node> <idmef:User category "os device"> <idmef:UserId type "original user"> <idmef:
UserId> <idmef:UserId type "current user"> <idmef:name>root</idmef:name> <idmef:
UserId> <idmef:UserId type "user privs"> <idmef:
Action> <idmef:Action category "block installed"> disabled user (fred) </idmef:Action> <idmef:Action category "taken offline"> logout user (fred)
This example shows a Heartbeat message that provides "I'm alive and working" information to the manager.
Note the use of <AdditionalData> elements, with "meaning" attributes, to provide some additional information.
xml version "1.0" encoding "UTF 8"?
> <idmef:IDMEF Message version "
Heartbeat messageid "abc123456789"> <idmef:Analyzer analyzerid "hq dmz analyzer01"> <idmef:Node category "dns">
analyzer01.example.com</idmef:name> </idmef:Node> </idmef:Analyzer> <idmef:CreateTime ntpstamp "0xbc722ebe.0x00000000"
03 09T14:07:58Z </idmef:CreateTime> <idmef:AdditionalData type "real" meaning "%memused"> <idmef:
AdditionalData type "real" meaning "%diskused"> <idmef:real>87.1</idmef:real> </idmef:AdditionalData> </idmef:
The following example shows how to extend the IDMEF DTD.
In the example, the VendorCo company has decided it wants to add geographic information to the Node class.
To do this, VendorCo creates a Document Type Definition or DTD that defines how their class will be formatted:
xsd "http://www.w3.org/2001/XMLSchema" xmlns:vendorco "http://vendor.com/idmef" targetNamespace "http://vendor.com/idmef" elementFormDefault "qualified"
<xsd:documentation> Intrusion Detection Message Exchange Format (IDMEF) Extension for geographic information </xsd
attribute name "node ident" type "xsd:integer" use "required"/
NodeGeography class will contain the geographic data in three aggregate classes, VendorCo:latitude, VendorCo:longitude, and VendorCo:elevation.
To associate the information in this class with a particular node, the "VendorCo:node ident" attribute is provided; it must contain the same value as the "ident" attribute on the relevant Node element.
To make use of this DTD now, VendorCo follows the rules in Section 5.2 and defines a parameter entity called "x vendorco" within the Document Type Definition, and then references this entity.
In the alert, the VendorCo elements are included under the AdditionalData element, with a "type" attribute of "xml", as shown below.
xml version "1.0" encoding "UTF 8"?
> <idmef:IDMEF Message version "1.0" xmlns:xsi "http://www.w3.org/2001/XMLSchema instance" xmlns:idmef "http://iana.org/idmef" xmlns:vendorco "http://v.com/idmef" xsi:schemaLocation "http://v.com/idmef http://v.com/geo.xsd"> <idmef:Alert messageid "abc123456789"> <idmef:Analyzer analyzerid "hq dmz analyzer01"> <idmef:Node category "dns">
> 2000 03 09T10:01:25.93464 05:00 </idmef:CreateTime
> <idmef:Source ident "a1b2c3d4"> <idmef:Node ident "a1b2c3d4 001" category "dns"> <idmef:name>badguy.example.net</idmef:name> <idmef:Address ident "a1b2c3d4 002" category "ipv4 net mask"> <idmef:
Node> </idmef:Source> <idmef:Target ident "d1c2b3a4"> <idmef:
Node ident "d1c2b3a4 001" category "dns"
> <idmef:Address category "ipv4 addr hex"> <idmef:address>0xde796f70</idmef:address> </idmef:Address> </idmef:Node> </idmef:Target> <idmef:Classification text "Teardrop"> <idmef:Reference origin "bugtraqid"> <idmef:
:Classification> <idmef:AdditionalData type "xml" meaning "node geo info"
> <idmef:xml> <vendorco:NodeGeography xmlns:vendorco "http://vendor.com/idmef" xsi:schemaLocation
"http://v.com/idmef http://v.com/geo.xsd" vendorco:node ident "
NodeGeography> </idmef:xml> </idmef:AdditionalData> </idmef:Alert> </idmef:
The IDMEF Document Type Definition (Normative) <?
xml version "1.0" encoding "UTF 8"?
Attributes of the IDMEF element.
In general, the fixed values of   these attributes will change each time a new version of the DTD   is released.
These are the "XML" attributes that   every element should have.
Space handling, language, and name   space.
Values for the Action.category attribute.
Values for the Address.category attribute.
ipv6 net mask ) "
Values for the AdditionalData.type attribute.
Values for the Impact.completion attribute.
Values for the File.category attribute.
Values for the UserId.type attribute.
Values for the Impact.type attribute.
Values for the Linkage.category attribute.
shortcut   stream   symbolic link ) "
Values for the Checksum.algorithm attribute
" ( MD4   MD5   SHA1   SHA2 256
Values for the Node.category attribute.
Values for the Reference.origin attribute.
Values for the Confidence.rating attribute.
Values for the Impact.severity attribute.
Values for the User.category attribute.
Values for yes/no attributes such as Source.spoofed and   Target.decoy.
( program, size?, buffer? )
( Node?, User?, Process?, Service? )
( Impact?, Action , Confidence? )
path?, arg , env  )
#IMPLIED iana protocol number CDATA
, contextName?, contextEngineID?, command? )
Simple elements with no sub elements and no special   attributes.
End of IDMEF DTD   9.
This document describes a data representation for exchanging security related information between intrusion detection system implementations.
Although there are no security concerns directly applicable to the format of this data, the data itself may contain security sensitive information whose confidentiality, integrity, and/or availability may need to be protected.
This suggests that the systems used to collect, transmit, process, and store this data should be protected against unauthorized use and that the data itself should be protected against unauthorized access.
The means for achieving this protection are outside the scope of this document.
Section 5 of [2] describes the required and recommended security characteristics of the transmission protocol that will be used to deliver IDMEF data from analyzers to managers.
These requirements include message confidentiality, message integrity, non repudiation, and avoidance of duplicate messages.
Both standard and proposed protocols exist that provide these features.
Where a protocol that does not meet the requirements of Section 5 of [2] is used to exchange IDMEF messages, it may be desirable to use digital signatures to certify the integrity of these messages; this is discussed in Section 6.5 of this document.
IANA Considerations Section 5 describes how to use the AdditionalData class to include arbitrary "atomic" data items in an IDMEF message, as well as how AdditionalData may be used to extend the DTD itself by adding new classes and attributes.
From time to time, it may be desirable to move an extension from its private or local use status (as all extensions made via the above mechanism are) to "standard" status that should be supported by all implementations.
This may be accomplished as described in this section.
Adding Values to Existing Attributes Several of the attributes specified in this document have lists of permissible values that they may contain.
To allow the addition of new values to these lists, the IANA created a repository for attribute values called "Intrusion Detection Message Exchange Format (IDMEF) Attribute Values".
Following the policies outlined in [9], this repository is "Specification Required" by RFC.
Section 10.1.1 describes the initial values for this repository.
To create a new attribute, you MUST publish an RFC to document the type.
In the RFC, include a copy of the registration template found in Section 10.1.2 of this document.
Put the template in your IANA Considerations section, filling in the appropriate fields.
You MUST describe any interoperability and security issues in your document.
When adding a new attribute value to the repository, the IANA shall assign the next rank number in numerical sequence for the value.
Attribute Registrations IDMEF Class Name:
Reference IDMEF Attribute Name:  origin Registered Values:
Source IDMEF Attribute Name:  spoofed Registered Values:
unknown   Accuracy of target information unknown
The element content is a date time string
Impact IDMEF Attribute Name:  severity Registered Values:
Impact IDMEF Attribute Name:  completion Registered Values:
The attempt was not successful
Action IDMEF Attribute Name:  category Registered Values:
Confidence IDMEF Attribute Name:  rating Registered Values:
Node IDMEF Attribute Name:  category Registered Values:
Domain unknown or not relevant
Windows 2000 Advanced Directory Services
IBM Shared Network Architecture (SNA)
ipv6 net mask   IPv6 network address, slash, network mask
User IDMEF Attribute Name:  category Registered Values:
UserId IDMEF Attribute Name:  category Registered Values:
associated with a file permission.
File IDMEF Attribute Name:  category Registered Values:
File IDMEF Attribute Name:  fstype Registered Values:
16 bit Windows FAT File System
32 bit Windows FAT File System
FileAccess IDMEF Attribute Name:  permission Registered Values:
Linkage IDMEF Attribute Name:  category Registered Values:
Checksum IDMEF Attribute Name:  algorithm Registered Values:
The SHA2 algorithm with 256 bits length.
The SHA2 algorithm with 384 bits length.
The SHA2 algorithm with 512 bits length.
The CRC algorithm with 32 bits length.
Registration Template IDMEF Class Name: <provide the name of the class that contains the attribute to which you want to add a new value, e.g., "Address"> IDMEF
<provide the name of the attribute to which you want to add a new value, e.g., "category"> New Attribute Value to Be Defined: <provide the name of the new attribute value that you want to add, e.g., "sneaker net"
> Meaning of New Attribute Value:
<describe in detail what the attribute value means
i.e., if an analyzer sends this value, what is it telling the receiver of the information?
Contact Person and E Mail Address:
<your name and e mail address> 10.2.
Adding New Attributes and Classes
To the extent possible, the IDMEF classes and attributes specified in this document have been designed to accommodate all current and near  future needs.
Although it is recognized that the addition of new classes, as well as the addition of new attributes to existing classes, will be necessary in the future, these actions should not be taken lightly.
Any addition of new attributes or classes should only be undertaken when the current classes and attributes simply cannot be used to represent the information in a "clean" way   and such additions should only be made to represent generally useful types of data.
Vendor specific information, obscure information provided by only a particular type of analyzer or used only by a particular type of manager, "pet" attributes, and the like are not good reasons to make class and attribute additions.
At the time this RFC was written, the first anticipated case for which new classes and attributes will need to be added is to handle host based intrusion detection systems.
However, such additions should not be made until some level of consensus has been reached about the set of data that will be provided by these systems.
Following the policies outlined in [9], the addition of new classes and attributes to the IDMEF requires "IETF Consensus".
To add new attributes or classes, you MUST publish an RFC to document them, and get that RFC approved by the IESG.
Typically, the IESG will seek input on prospective additions from appropriate persons (e.g., a relevant working group if one exists).
You MUST describe any interoperability and security issues in your document.
The IDMEF Schema Definition (Non normative) <?
<xsd:documentation> Intrusion Detection Message Exchange Format (IDMEF)
This section did namespace magic and is not needed with XSD validation.
Values for the Action.category attribute.
simpleType name "action category"> <xsd:restriction base "xsd:
<xsd:enumeration value "notification sent" /
Values for the Address.category attribute.
<xsd:simpleType name "address category"> <xsd:restriction base "xsd:
<xsd:enumeration value "ipv4 addr hex" />
<xsd:enumeration value "ipv4 net mask" />
<xsd:enumeration value "ipv6 addr hex" />
<xsd:enumeration value "ipv6 net mask" /
Values for the Impact.severity attribute.
<xsd:simpleType name "impact severity"> <xsd:restriction base "xsd:
token"> <xsd:enumeration value "info" /
Values for the Impact.completion attribute.
<xsd:simpleType name "impact completion"> <xsd:restriction base "xsd:
token"> <xsd:enumeration value "failed" />
Values for the Impact.type attribute.
<xsd:simpleType name "impact type"> <xsd:restriction base "xsd:
token"> <xsd:enumeration value "admin" />
Values for the File.category attribute.
<xsd:simpleType name "file category"> <xsd:restriction base "xsd:
token"> <xsd:enumeration value "current"  /
<xsd:simpleType name "file permission"> <xsd:restriction base "xsd:
> <xsd:enumeration value "search" />
Values for the Id.type attribute.
<xsd:enumeration value "original user" />
<xsd:enumeration value "current group" />
Values for the Linkage.category attribute.
<xsd:simpleType name "linkage category"> <xsd:restriction base "xsd:
<xsd:enumeration value "reparse point" />
<xsd:enumeration value "symbolic link" /
Values for the Checksum.algorithm attribute
<xsd:enumeration value "SHA2 256" />
<xsd:enumeration value "SHA2 384" />
<xsd:enumeration value "SHA2 512" />
<xsd:enumeration value "CRC 32" />
Values for the Node.category attribute.
<xsd:simpleType name "node category"> <xsd:restriction base "xsd:
token"> <xsd:enumeration value "unknown"  /
Values for the reference.origin attribute.
<xsd:simpleType name "reference origin"> <xsd:restriction base "xsd:
token"> <xsd:enumeration value "unknown" />
Values for the Confidence.rating attribute.
:simpleType name "confidence rating"> <xsd:restriction base "xsd:
Values for the User.category attribute.
<xsd:simpleType name "user category"> <xsd:restriction base "xsd:token">
/ Values for the additionaldata.type attribute.
<xsd:simpleType name "additionaldata type"> <xsd:restriction base "xsd:
Values for yes/no attributes such as Source.spoofed and   Target.decoy.
yes no type"> <xsd:restriction base "xsd:
token"> <xsd:enumeration value "unknown" />
restriction base "xsd:string"> <xsd:pattern value "[0 9]{1,5}(\
restriction base "xsd:string"> <xsd:pattern value "
The IDMEF Message element and the types of messages it can include.
complexType> <xsd:element name "IDMEF Message" type "idmef:IDMEF Message" />
<xsd:element name "Analyzer" type "idmef:Analyzer" /
element name "CreateTime" type "idmef:TimeWithNtpstamp" /
<xsd:element name "DetectTime" type "idmef:TimeWithNtpstamp" minOccurs "0" maxOccurs "1" />
<xsd:element name "AnalyzerTime" type "idmef:TimeWithNtpstamp" minOccurs "0" maxOccurs "1" />
<xsd:element name "Source" type "idmef:Source" minOccurs "
element name "Classification" type "idmef:Classification" />
element name "Assessment" type "idmef:Assessment" minOccurs "0" maxOccurs "1
> <xsd:element name "ToolAlert" type "idmef:ToolAlert" />
<xsd:element name "OverflowAlert" type "idmef:OverflowAlert" /
<xsd:element name "AdditionalData" type "idmef:AdditionalData" minOccurs "0" maxOccurs "unbounded" /
complexType> <xsd:element name "Alert" type "idmef:Alert" />
<xsd:element name "Analyzer" type "idmef:Analyzer" /
element name "CreateTime" type "idmef:TimeWithNtpstamp" /
element name "HeartbeatInterval" type "xsd:integer" minOccurs "0" maxOccurs "1
<xsd:element name "AdditionalData" type "idmef:AdditionalData" minOccurs "0" maxOccurs "unbounded" /
Subclasses of the Alert class that provide more data for specific types of alerts.
element name "alertident" type "idmef:Alertident" minOccurs "1" maxOccurs "unbounded" /
<xsd:element name "program" type "xsd:string" /
<xsd:element name "alertident" type "idmef:Alertident" minOccurs "1" maxOccurs "unbounded" /
This element allows an alert to include additional information that cannot be encoded elsewhere in the data model.
> <xsd:restriction base "xsd:string"> <xsd:minLength value "1"/>
:element> <xsd:element name "date time" type "xsd:dateTime" />
element name "integer" type "xsd:integer" />
<xsd:element name "ntpstamp" type "idmef:ntpstamp" /
<xsd:element name "portlist" type "idmef:port list" /
<xsd:element name "real" type "xsd:decimal" />
"byte string" type "xsd:hexBinary" /
<xsd:element name "xml" type "idmef:xmltext" /
<xsd:attribute name "type" type "idmef:additionaldata type" />
<xsd:attribute name "meaning" type "xsd:string" /
Elements related to identifying entities analyzers (the senders of these messages), sources (of attacks), and targets (of attacks).
<xsd:element name "Node" type "idmef:
Node" minOccurs "0" maxOccurs "1
<xsd:element name "Analyzer" type "idmef:Analyzer" minOccurs "0" maxOccurs "1" /
<xsd:attribute name "analyzerid" type "xsd:string" default "0" /
> <xsd:attribute name "name" type "xsd:string" /
> <xsd:attribute name "manufacturer" type "xsd:string" /
> <xsd:attribute name "model" type "xsd:string" /
:attribute name "ostype" type "xsd:string" /
<xsd:element name "Node" type "idmef:
Node" minOccurs "0" maxOccurs "1
<xsd:element name "Process" type "idmef:Process" minOccurs "0" maxOccurs "1" />
<xsd:element name "Service" type "idmef:Service" minOccurs "0" maxOccurs "1" /
<xsd:attribute name "ident" type "xsd:string" default "0" /
> <xsd:attribute name "spoofed" type "idmef:
yes no type" default "unknown" />
<xsd:element name "Node" type "idmef:
Node" minOccurs "0" maxOccurs "1
<xsd:element name "Process" type "idmef:Process" minOccurs "0" maxOccurs "1" />
<xsd:element name "Service" type "idmef:Service" minOccurs "0" maxOccurs "1" />
<xsd:element name "File" type "idmef:File" minOccurs "0" maxOccurs "unbounded" /
<xsd:attribute name "ident" type "xsd:string" default "0" /
> <xsd:attribute name "decoy" type "idmef:yes no type" default "unknown" />
Support elements used for providing detailed info about entities addresses, names, etc.
<xsd:attribute name "ident" type "xsd:string" default "0" /
> <xsd:attribute name "category" type "idmef:address category" default "unknown" />
<xsd:attribute name "vlan name" type "
<xsd:element name "Impact" type "idmef:Impact" minOccurs "0
element name "Action" type "idmef:Action" minOccurs "
<xsd:attribute name "origin" type "idmef:reference origin" default "unknown" />
<xsd:attribute name "meaning" type "xsd:string" /
<xsd:element name "Reference" type "idmef:Reference" minOccurs "0" maxOccurs "unbounded" /
<xsd:attribute name "ident" type "xsd:string" default "0" /
<xsd:element name "name" type "xsd:string" /
time" type "xsd:dateTime" minOccurs "0" maxOccurs "1" /
<xsd:element name "modify time" type "xsd:dateTime
" minOccurs "0" maxOccurs "1
"access time" type "xsd:dateTime" minOccurs "0" maxOccurs "1" /
element name "data size" type "xsd:integer" minOccurs "0" maxOccurs "1
element name "disk size" type "xsd:integer" minOccurs "0" maxOccurs "1
<xsd:element name "Linkage" type "idmef:Linkage" minOccurs "0" maxOccurs "unbounded" />
<xsd:element name "Inode" type "idmef:
Inode" minOccurs "0" maxOccurs "1
<xsd:attribute name "ident" type "xsd:string" default "0" /
> <xsd:attribute name "category" type "idmef:file category" use "required" />
<xsd:attribute name "fstype" type "
<xsd:element name "UserId" type "idmef:UserId" />
<xsd:element name "permission" type "idmef:Permission" minOccurs "1" maxOccurs "unbounded" /
<xsd:element name "change time" type "xsd:string" minOccurs "0" maxOccurs "1" />
sequence minOccurs "0" maxOccurs "1"
sequence minOccurs "0" maxOccurs "1"
<xsd:element name "name" type "xsd:string" /
<xsd:attribute name "category" type "idmef:linkage category" use "required" /
element name "key" type "xsd:string" minOccurs "0" maxOccurs "1" /
<xsd:element name "location" type "xsd:string" minOccurs "0" maxOccurs "1" />
<xsd:element name "Address" type "idmef:Address" minOccurs "0" maxOccurs "unbounded" /
<xsd:attribute name "ident" type "xsd:string" default "0" /
element name "pid" type "xsd:integer" minOccurs "0" maxOccurs "1
element name "arg" type "xsd:string" minOccurs "0" maxOccurs "unbounded" />
element name "env" type "xsd:string" minOccurs "0" maxOccurs "unbounded" /
element name "port" type "xsd:integer" minOccurs "0" maxOccurs "1" /
element name "port" type "xsd:integer" />
<xsd:element name "name" type "xsd:string" minOccurs "0" maxOccurs "1" /
<xsd:element name "portlist" type "idmef:port list" /
element name "protocol" type "xsd:string" minOccurs "0" maxOccurs "1" />
<xsd:element name "SNMPService" type "idmef:SNMPService" minOccurs "0" maxOccurs "1" />
<xsd:element name "WebService" type "idmef:WebService" minOccurs "0" maxOccurs "1" /
<xsd:attribute name "ident" type "xsd:string" default "0" /
:attribute name "ip version" type "xsd:integer" />
:attribute name "iana protocol number" type "xsd:integer" />
<xsd:attribute name "iana protocol name" type "
<xsd:element name "url" type "xsd:anyURI" /
> <xsd:element name "cgi" type "xsd:string" minOccurs "0" maxOccurs "1" />
"http method" type "xsd:string" minOccurs "0" maxOccurs "1" />
element name "arg" type "xsd:string" minOccurs "0" maxOccurs "unbounded" /
element name "oid" type "xsd:string" minOccurs "0" maxOccurs "1" />
element name "messageProcessingModel" type "xsd:integer" minOccurs "0" maxOccurs "1
element name "securityModel" type "xsd:integer" minOccurs "0" maxOccurs "1
element name "securityName" type "xsd:string" minOccurs "0" maxOccurs "1" />
element name "securityLevel" type "xsd:integer" minOccurs "0" maxOccurs "1
" type "xsd:string" minOccurs "0" maxOccurs "1" />
<xsd:element name "contextEngineID" type "xsd:string" minOccurs "0" maxOccurs "1" />
element name "command" type "xsd:string" minOccurs "0" maxOccurs "1" /
<xsd:element name "UserId" type "idmef:UserId" minOccurs "1" maxOccurs "unbounded" /
<xsd:attribute name "ident" type "xsd:string" default "0" /
> <xsd:attribute name "category" type "idmef:user category" default "unknown" /
element name "number" type "xsd:integer" minOccurs "0" maxOccurs "1" /
element name "number" type "xsd:integer" />
<xsd:element name "name" type "xsd:string" minOccurs "0" maxOccurs "1" /
<xsd:attribute name "ident" type "xsd:string" default "0" /
> <xsd:attribute name "type" type "idmef:id type" default "original user" />
Simple elements with sub elements or attributes of a special nature.
<xsd:attribute name "completion" type "idmef:impact completion" />
<xsd:attribute name "type" type "idmef:impact type" default "other" /
<xsd:complexContent mixed "true"> <xsd:restriction base "xsd:anyType
<xsd:any namespace "##other" processContents "lax" minOccurs "0" maxOccurs "unbounded" /
