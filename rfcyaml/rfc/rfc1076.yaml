- title: __initial_text__
  contents:
  - "                  HEMS Monitoring and Control Language\n                    \
    \       TABLE OF CONTENTS\n"
- title: 1.   Status of This Memo                                               1
  contents:
  - "1.   Status of This Memo                                               1\n  \
    \   Introduction                                                      2\n"
- title: 2.   Overview and Scope                                                2
  contents:
  - '2.   Overview and Scope                                                2

    '
- title: 3.   Overview of Query Processor Operation                             4
  contents:
  - '3.   Overview of Query Processor Operation                             4

    '
- title: 4.   Encoding of Queries and Responses                                 5
  contents:
  - '4.   Encoding of Queries and Responses                                 5

    '
- title: 4.1  Notation Used in This Proposal                                    5
  contents:
  - '4.1  Notation Used in This Proposal                                    5

    '
- title: 5.   Data Organization                                                 6
  contents:
  - '5.   Data Organization                                                 6

    '
- title: 5.1  Example Data Tree                                                 7
  contents:
  - '5.1  Example Data Tree                                                 7

    '
- title: 5.2  Arrays                                                            8
  contents:
  - '5.2  Arrays                                                            8

    '
- title: 6.   Components of a Query                                             9
  contents:
  - '6.   Components of a Query                                             9

    '
- title: 7.   Reply to a Query                                                 10
  contents:
  - '7.   Reply to a Query                                                 10

    '
- title: 8.   Query Language                                                   12
  contents:
  - '8.   Query Language                                                   12

    '
- title: 8.1  Moving Around in the Data Tree                                   14
  contents:
  - '8.1  Moving Around in the Data Tree                                   14

    '
- title: 8.2  Retrieving Data                                                  15
  contents:
  - '8.2  Retrieving Data                                                  15

    '
- title: 8.3  Data Attributes                                                  16
  contents:
  - '8.3  Data Attributes                                                  16

    '
- title: 8.4  Examining Memory                                                 18
  contents:
  - '8.4  Examining Memory                                                 18

    '
- title: '8.5  Control Operations:  Modifying the Data Tree                     19'
  contents:
  - '8.5  Control Operations:  Modifying the Data Tree                     19

    '
- title: '8.6  Associative Data Access:  Filters                                21'
  contents:
  - '8.6  Associative Data Access:  Filters                                21

    '
- title: 8.7  Terminating a Query                                              26
  contents:
  - '8.7  Terminating a Query                                              26

    '
- title: 9.   Extending the Set of Values                                      27
  contents:
  - '9.   Extending the Set of Values                                      27

    '
- title: 10.  Authorization                                                    27
  contents:
  - '10.  Authorization                                                    27

    '
- title: 11.  Errors                                                           28
  contents:
  - '11.  Errors                                                           28

    '
- title: I.   ASN.1 Descriptions of Query Language Components                  29
  contents:
  - 'I.   ASN.1 Descriptions of Query Language Components                  29

    '
- title: I.1  Operation Codes                                                  30
  contents:
  - 'I.1  Operation Codes                                                  30

    '
- title: I.2  Error Returns                                                    31
  contents:
  - 'I.2  Error Returns                                                    31

    '
- title: I.3  Filters                                                          33
  contents:
  - 'I.3  Filters                                                          33

    '
- title: I.4  Attributes                                                       34
  contents:
  - 'I.4  Attributes                                                       34

    '
- title: I.5  VendorSpecific                                                   36
  contents:
  - 'I.5  VendorSpecific                                                   36

    '
- title: II.  Implementation Hints                                             36
  contents:
  - 'II.  Implementation Hints                                             36

    '
- title: III. Obtaining a Copy of the ASN.1 Specification                      42
  contents:
  - 'III. Obtaining a Copy of the ASN.1 Specification                      42

    '
- title: 1. STATUS OF THIS MEMO
  contents:
  - "1. STATUS OF THIS MEMO\n   This RFC specifies a query language for monitoring\
    \ and control of\n   network entities.  This RFC supercedes RFC-1023, extending\
    \ the query\n   language and providing more discussion of the underlying issues.\n\
    \   This language is a component of the High-Level Entity Monitoring\n   System\
    \ (HEMS) described in RFC-1021 and RFC-1022.  Readers may wish\n   to consult\
    \ these RFCs when reading this memo.  RFC-1024 contains\n   detailed assignments\
    \ of numbers and structures used in this system.\n   Portions of RFC-1024 that\
    \ define query language structures are\n   superceded by definitions in this memo.\
    \  This memo assumes a\n   knowledge of the ISO data encoding standard, ASN.1.\n\
    \   Distribution of this memo is unlimited.\n"
- title: INTRODUCTION
  contents:
  - "INTRODUCTION\n   This RFC specifies the design of a general-purpose, yet efficient,\n\
    \   monitoring and control language for managing network entities.  The\n   data\
    \ in the entity is modeled as a hierarchy and specific items are\n   named by\
    \ giving the path from the root of the tree.  Most items are\n   read-only, but\
    \ some can be \"set\" in order to perform control\n   operations.  Both requests\
    \ and responses are represented using the\n   ISO ASN.1 data encoding rules.\n"
- title: 2. OVERVIEW AND SCOPE
  contents:
  - "2. OVERVIEW AND SCOPE\n   The basic model of monitoring and control used in this\
    \ memo is that a\n   query is sent to a monitored entity and the entity sends\
    \ back a\n   response.  The term query is used in the database sense -- it may\n\
    \   request information, modify data, or both.  We will use gateway-\n   oriented\
    \ examples, but it should be understood that this query-\n   response mechanism\
    \ is applicable to any IP entity.\n   In particular, there is no notion of an\
    \ interactive \"conversation\" as\n   in SMTP [RFC-821] or FTP [RFC-959].  A query\
    \ is a complete request\n   that stands on its own and elicits a complete response.\n\
    \   In order to design the query language, we had to define a model for\n   the\
    \ data to be retrieved by the queries, which required some\n   understanding of\
    \ and assumptions to be made about the data.  We ended\n   up with a fairly flexible\
    \ data model, which places few limits on the\n   type or size of the data.\n \
    \  Wherever possible, we give motivations for the design decisions or\n   assumptions\
    \ that led to particular features or definitions.  Some of\n   the important global\
    \ considerations and assumptions are:\n         - The query processor should place\
    \ as little computational\n           burden on the monitored entity as possible.\n\
    \         - It should not be necessary for a monitored entity to store\n     \
    \      the complete query.  Nothing in the query language should\n           preclude\
    \ an implementation from being able to process the\n           query on the fly,\
    \ producing portions of the response while\n           the query is still being\
    \ read and parsed.  There may be\n           other constraints that require large\
    \ amounts of data to be\n           buffered, but the query language design must\
    \ not be one.\n         - It is assumed that there is some mechanism to transport\
    \ a\n           sequence of octets to a query processor within the\n         \
    \  monitored entity and that there is some mechanism to return\n           a sequence\
    \ of octets to the entity making the query.  In\n           HEMS, this is provided\
    \ by HEMP and its underlying transport\n           layer.  The query language\
    \ design is independent of these\n           details, however, and could be grafted\
    \ onto some other\n           protocol.\n         - The data model must provide\
    \ organization for the data, so\n           that it can be conveniently named.\n\
    \         - Much of the data to be monitored will be contained in\n          \
    \ tables.  Some tables may contain other tables.  The query\n           language\
    \ should be able to deal with such tables.\n         - We don't provide capabilities\
    \ for data reduction in the\n           query language.  We will provide for data\
    \ selection, for\n           example, only retrieving certain table entries, but\
    \ we will\n           not provide general facilities for processing data, such\
    \ as\n           computing averages.\n         - Because one monitoring center\
    \ may be querying many\n           (possibly hetrogenous) hosts, it must be possible\
    \ to write\n           generic queries that can be sent to all hosts, and have\
    \ the\n           query elicit as much information as is available from each\n\
    \           host.  i.e., queries must not be aborted just because they\n     \
    \      requested non-existent data.\n   There were some assumptions that we specifically\
    \ did not make:\n         - It is up to the implementation to choose what degree\
    \ of\n           concurrency will be allowed when processing queries.  By\n  \
    \         locking only portions of the database, it should be\n           possible\
    \ to achieve good concurrency while still preventing\n           deadlock.\n \
    \        - This specification makes no statement about the use of the\n      \
    \     \"definite\" and \"indefinite\" length forms in ASN.1.  There\n        \
    \   is currently some debate about this usage in the ISO\n           community;\
    \ implementors should note the recommendations in\n           the ASN.1 specification.\n\
    \   Other RFCs associated with HEMS are:\n      RFC-1021        Overview;\n  \
    \    RFC-1022        Transport protocol and message encapsulation;\n      RFC-1024\
    \        Precise data definitions.\n   The rest of this report is organized as\
    \ follows:\n      Section 3       Gives a brief overview of the data model and\
    \ the\n                      operation of the query processor.\n      Section\
    \ 4       Describes the encoding used for queries and\n                      responses,\
    \ and the notation used to represent them\n                      in this report.\n\
    \      Section 5       Describes how the data is organized in the\n          \
    \            monitored entity, and the view provided of it by\n              \
    \        the query processor.\n      Section 6       Describes the basic data\
    \ types that may be given\n                      to the query processor as input.\n\
    \      Section 7       Describes how a reply to a query is organized.\n      Section\
    \ 8       Describes the operations available in the query\n                  \
    \    language.\n      Section 9       Describes how the set of data in the tree\
    \ may be\n                      extended.\n      Section 10      Describes how\
    \ authorization issues affect the\n                      execution of a query.\n\
    \      Section 11      Describes how errors are reported, and their\n        \
    \              effect on the processing of the query.\n      Appendix I      Gives\
    \ precise ASN.1 definitions of the data types\n                      used by the\
    \ query processor.\n      Appendix II     Gives extensive implementation hints\
    \ for the core\n                      of the query processor.\n"
- title: 3. OVERVIEW OF QUERY PROCESSOR OPERATION
  contents:
  - "3. OVERVIEW OF QUERY PROCESSOR OPERATION\n   In this section, we give an overview\
    \ of the operation of the query\n   processor, to provide a framework for the\
    \ later sections.\n   The query language models the manageable data as a tree,\
    \ with each\n   branch representing a different aspect of the entity, such as\n\
    \   different layers of protocols.  Subtrees are further divided to\n   provide\
    \ additional structure to the data.  The leaves of the tree\n   contain the actual\
    \ data.\n   Given this data representation, the task of the query processor is\
    \ to\n   traverse this tree and retrieve (or modify) data specified in a\n   query.\
    \  A query consists of instructions to move around in the tree\n   and to retrieve\
    \ (or modify) named data.  The result of a query is an\n   exact image of the\
    \ parts of the tree that the query processor\n   visited.\n   The query processor\
    \ is very simple -- it only understands eight\n   commands, most of which share\
    \ the same structure.  It is helpful to\n   think of the query processor as an\
    \ automaton that walks around in the\n   tree, directed by commands in the query.\
    \  As it moves around, it\n   copies the tree structure it traverses to the query\
    \ result.  Data\n   that is requested by the query is copied into the result as\
    \ well.\n   Data that is changed by a query is copied into the result after the\n\
    \   modification is made.\n"
- title: 4. ENCODING OF QUERIES AND RESPONSES
  contents:
  - "4. ENCODING OF QUERIES AND RESPONSES\n   Both queries and responses are encoded\
    \ using the representation\n   defined in ISO Standard ASN.1 (Abstract Syntax\
    \ Notation 1).  ASN.1\n   represents data as sequences of <tag,length,contents>\
    \ triples that\n   are encoded as a stream of octets.  The data tuples may be\n\
    \   recursively nested to represent structured data such as arrays or\n   records.\
    \  For a full description, see the ISO standards IS 8824 and\n   IS 8825.  See\
    \ appendix for information about obtaining these\n   documents.\n"
- title: 4.1 Notation Used in This Proposal
  contents:
  - "4.1 Notation Used in This Proposal\n   The notation used in this memo is similar\
    \ to that used in ASN.1, but\n   less formal, smaller, and (hopefully) easier\
    \ to read.  We will refer\n   to a <tag,length,contents> tuple as a \"data object\"\
    .  In this RFC, we\n   will not be concerned with the details of the object lengths.\
    \  They\n   exist in the actual ASN.1 encoding, but will be omitted in the\n \
    \  examples here.\n   Data objects that have no internal ASN.1 structure such\
    \ as integer or\n   octet string are referred to as \"simple types\" or \"simple\
    \ objects\".\n   Objects which are constructed out of other ASN.1 data objects\
    \ will be\n   referred to as \"composite types\" or \"composite objects\".\n \
    \  The notation\n       ID(value)\n   represents a simple object whose tag is\
    \ \"ID\" with the given value.  A\n   composite object is represented as\n   \
    \    ID{ ... contents ... }\n   where contents is a sequence of data objects.\
    \  The contents may\n   include both simple and structured types, so the structure\
    \ is fully\n   recursive.\n   The difference between simple and composite types\
    \ is close to the\n   meaning of the \"constructor\" bit in ASN.1.  For the uses\
    \ here, the\n   distinction is made based upon the semantics of the data, not\
    \ the\n   representation.  Therefore, even though an OctetString can be\n   represented\
    \ in ASN.1 using either constructed or non-constructed\n   forms, it is conceptually\
    \ a simple type, with no internal structure,\n   and will always be written as\n\
    \       ID(\"some arbitrary string\")\n   in this RFC.\n   There are situations\
    \ where it is necessary to specify a type but give\n   no value, such as when\
    \ referring to the name of the data.  In this\n   situation, the same notation\
    \ is used, but with the value omitted:\n       ID   or  ID()   or   ID{}\n   Such\
    \ objects have zero length and no contents.  The latter two forms\n   are used\
    \ when a distinction is being made between simple and\n   composite data, but\
    \ the difference is just notation -- the\n   representation is the same.\n   ASN.1\
    \ distinguishes between four \"classes\" of tags: universal,\n   application-specific,\
    \ context-dependent, and reserved.  HEMS and this\n   query language use the first\
    \ three.  Universal tags are assigned in\n   the ASN.1 standard and its addendums\
    \ for common types, and are\n   understood by any application using ASN.1.  Application-specific\
    \ tags\n   are limited in scope to a particular application.  These are used for\n\
    \   \"well-known\" identifiers that must be recognizable in any context,\n   such\
    \ as derived data types.  Finally, context-dependent tags are used\n   for objects\
    \ whose meaning is dependent upon where they are\n   encountered.  Most tags that\
    \ identify data are context-dependent.\n"
- title: 5. DATA ORGANIZATION
  contents:
  - "5. DATA ORGANIZATION\n   Data in a monitored entity is modeled as a hierarchy.\n\
    \   Implementations are not required to organize the data internally as a\n  \
    \ hierarchy, but they must provide this view of the data through the\n   query\
    \ language.  A hierarchy offers useful structure for the\n   following operations:\n\
    \   Organization    A hierarchy allows related data to be grouped\n          \
    \         together in a natural way.\n   Naming          The name of a piece of\
    \ data is just the path from the\n                   root to the data of interest.\n\
    \   Mapping onto ASN.1\n                   ASN.1 can easily represent a hierarchy\
    \ by using a\n                   \"constructor\" type as an envelope for an entire\n\
    \                   subtree.\n   Efficient Representation\n                  \
    \ Hierarchical structures are compact and can be\n                   traversed\
    \ quickly.\n   Safe Locking    If it is necessary to lock part of the hierarchy\
    \ (for\n                   example, when doing an update), locking an entire\n\
    \                   subtree can be done efficiently and safely, with no\n    \
    \               danger of deadlock.\n   We will use the term \"data tree\" to\
    \ refer to this entire structure.\n   Note that this internal model is completely\
    \ independent of the\n   external ASN.1 representation -- any other suitable representation\n\
    \   would do.  For the sake of efficiency, we do make a one-to-one\n   mapping\
    \ between ASN.1 tags and the (internal) names of the nodes.\n   The same could\
    \ be done for any other external representation.\n   Each node in the hierarchy\
    \ must have names for its component parts.\n   Although we would normally think\
    \ of names as being ASCII strings such\n   as \"input errors\", the actual name\
    \ is just an ASN.1 tag.  Such names\n   are small integers (typically, less than\
    \ 30) and so can easily be\n   mapped by the monitored entity onto its internal\
    \ representation.\n   We use the term \"dictionary\" to mean an internal node\
    \ in the\n   hierarchy.  Leaf nodes contain the actual data.  A dictionary may\n\
    \   contain both leaf nodes and other dictionaries.\n"
- title: 5.1 Example Data Tree
  contents:
  - "5.1 Example Data Tree\n   Here is a possible organization of the hierarchy in\
    \ an entity that\n   has several network interfaces and does IP routing.  The\
    \ exact\n   organization of data in entities is specified in RFC-1024.  This\n\
    \   skeletal data tree will be used throughout this RFC in query\n   examples.\n\
    \          System {\n                  name                            -- host\
    \ name\n                  clock-msec                      -- msec since boot\n\
    \                  interfaces                      -- # of interfaces\n      \
    \            memory\n                  }\n          Interfaces {             \
    \               -- one per interface\n                  InterfaceData{ address,\
    \ mtu, netMask, ARP{...}, ... }\n                  InterfaceData{ address, mtu,\
    \ netMask, ARP{...}, ... }\n                                  :\n            \
    \      }\n          IPRouting {\n                  Entry{ ip-addr, interface,\
    \ cost, ... }\n                  Entry{ ip-addr, interface, cost, ... }\n    \
    \                              :\n                  }\n      There are three top-level\
    \ dictionaries in this hierarchy (System,\n      Interfaces, and IPRouting) and\
    \ three other dictionary types\n      (InterfaceData, Entry, and ARP), each with\
    \ multiple instances.\n      The \"name\" of the clock in this entity would be:\n\
    \          system{ clock-msec }\n      and the name of a routing table entry's\
    \ IP address would be:\n          IPRouting{ Entry{ ip-addr } }.\n      More than\
    \ one piece of data can be named by a single ASN.1 object.\n      The entire collection\
    \ of system information is named by:\n          system\n      and the name of\
    \ a routing table's IP address and cost would be:\n          IPRouting{ Entry{\
    \ ip-addr, cost } }.\n"
- title: 5.2 Arrays
  contents:
  - "5.2 Arrays\n   There is one sub-type of a dictionary that is used as the basis\
    \ for\n   tables of objects with identical types.  We call these dictionaries\n\
    \   arrays.  In the example above, the dictionaries for interfaces,\n   routing\
    \ tables, and ARP tables are all arrays.\n   In the examples above, the \"ip-addr\"\
    \ and \"cost\" fields are named.  In\n   fact, these names refer to the field\
    \ values for ALL of the routing\n   table entries -- the name doesn't (and can't)\
    \ specify which routing\n   table entry is intended.  This ambiguity is a problem\
    \ wherever data\n   is organized in tables.  If there was a meaningful index for\
    \ such\n   tables (e.g., \"routing table entry #1\"), there would be no problem.\n\
    \   Unfortunately, there usually isn't such an index.  The solution to\n   this\
    \ problem requires that the data be accessed on the basis of some\n   of its content.\
    \  Filters, discussed in section 8.6, provide this\n   mechanism.\n   The primary\
    \ difference between arrays and plain dictionaries is that\n   arrays may contain\
    \ only one type of item, while dictionaries, in\n   general, will contain many\
    \ different types of items.  For example,\n   the dictionary IPRouting (which\
    \ is an array) will contain only items\n   of type Entry.\n   The fact that these\
    \ objects are viewed externally as arrays or tables\n   does not mean that they\
    \ are represented in an implementation as\n   linear lists of objects.  Any collection\
    \ of same-typed objects is\n   viewed as an array, even though it might be stored\
    \ internally in some\n   other format, for example, as a hash table.\n"
- title: 6. COMPONENTS OF A QUERY
  contents:
  - "6. COMPONENTS OF A QUERY\n   A HEMS query consists of a sequence of ASN.1 objects,\
    \ interpreted by\n   a simple stack-based interpreter.  [Although we define the\
    \ query\n   language in terms of the operations of a stack machine, the language\n\
    \   does not require an implementation to use a stack machine.  This is a\n  \
    \ well-understood model, and is easy to implement.]  One ASN.1 tag is\n   reserved\
    \ for operation codes; all other tags indicate data that will\n   eventually be\
    \ used by an operation.  These objects are pushed onto\n   the stack when received.\
    \  Opcodes are immediately executed and may\n   remove or add items to the stack.\
    \  Because ASN.1 itself provides\n   tags, very little needs to be done to the\
    \ incoming ASN.1 objects to\n   make them suitable for use by the query interpreter.\n\
    \   Each ASN.1 object in a query will fit into one of the following\n   categories:\n\
    \   Opcode    An opcode tells the query interpreter to perform an action.\n  \
    \           They are described in detail in section 8.  Opcodes are\n        \
    \     represented by an application-specific type whose value\n             determines\
    \ the operation.\n   Template  These are objects that name one or more items in\
    \ the data\n             tree.  Named items may be either simple items (leaf nodes)\n\
    \             or entire dictionaries, in which case the entire subtree\n     \
    \        \"underneath\" the dictionary is understood.  Templates are\n       \
    \      used to select specific data to be retrieved from the data\n          \
    \   tree.  A template may be either simple or structured,\n             depending\
    \ upon what it is naming.  A template only names\n             the data -- there\
    \ are no values contained in it.  Therefore\n             the leaf objects in\
    \ a template will all have a length of\n             zero.\n             Examples\
    \ of very simple templates are:\n                 name()   or   System{}\n   \
    \          Each of these is just one ASN.1 data object, with zero\n          \
    \   length.  The first names a single data item in the \"System\"\n          \
    \   dictionary (and must appear in that context), and the\n             second\
    \ names the entire \"System\" dictionary.  A more\n             complex template\
    \ such as:\n                 Interfaces{ InterfaceData{ address, netMask, ARP\
    \ } }\n             names two simple data items and a dictionary, iterated over\n\
    \             all occurrences of \"InterfaceData\" within the Interfaces\n   \
    \          array.\n   Path      A path is a special case of a template that names\
    \ only a\n             single node in the tree.  It specifies a path down into\
    \ the\n             dictionary tree and names exactly one node in the\n      \
    \       dictionary tree.\n   Value     These are used to give data values when\
    \ needed in a query,\n             for example, when changing a value in the data\
    \ tree.  A\n             value can be thought of as either a filled-in template\
    \ or\n             as the ASN.1 representation some part of the data tree.\n \
    \  Filter    A boolean expression that can be executed in the context of\n   \
    \          a particular dictionary that is used to select or not\n           \
    \  select items in the dictionary.  The expressions consist of\n             the\
    \ primitives \"equal\", \"greater-or-equal\",\n             \"less-or-equal\"\
    , and \"present\" possibly joined by \"and\",\n             \"or\", and \"not\"\
    .  (See section 8.6.)\n   Values, Paths, and Templates usually have names in the\
    \ context-\n   dependent class, except for a few special cases, which are in the\n\
    \   application-specific class.\n"
- title: 7. REPLY TO A QUERY
  contents:
  - "7. REPLY TO A QUERY\n   The data returned to the monitoring entity is a sequence\
    \ of ASN.1\n   data items.  Conceptually, the reply is a subset of the data tree,\n\
    \   where the query selects which portions are to be included.  This is\n   exactly\
    \ true for data retrieval requests, and essentially true for\n   data modification\
    \ requests -- the reply contains the data after it\n   has been modified.  The\
    \ key point is that the data in a reply\n   represents the state of the data tree\
    \ immediately after the query was\n   executed.\n   The sequence of the data is\
    \ determined by the sequence of query\n   language operations and the order of\
    \ data items within Templates and\n   Values given as input to these operations.\
    \  If a query requests data\n   from two of the top-level dictionaries in the\
    \ data tree, by giving\n   two templates such as:\n          System{ name, interfaces\
    \ }\n          Interfaces{\n                  InterfaceData { address, netMask,\
    \ mtu }\n                  }\n   then the response will consist of two ASN.1 data\
    \ objects, as follows:\n          System {\n                  name(\"system name\"\
    ),\n                  interfaces(2)\n                  }\n          Interfaces\
    \ {\n                  InterfaceData { address(36.8.0.1),\n                  \
    \                netMask(FFFF0000),\n                                  mtu(1500)\n\
    \                                  }\n                  InterfaceData { address(10.1.0.1),\n\
    \                                  mtu(1008),\n                              \
    \    netMask(FF000000)\n                                  }\n                \
    \  }\n   With few exceptions, each of the data items in the hierarchy is named\n\
    \   in the context-specific ASN.1 type space.  Because of this, the\n   returned\
    \ objects must be fully qualified.  For example, the name of\n   the entity must\
    \ always be returned encapsulated inside an ASN.1\n   object for \"System\". \
    \ If it were not, there would be no way to tell\n   if the object that was returned\
    \ was \"name\" inside the \"System\"\n   dictionary or \"address\" inside the\
    \ \"interfaces\" dictionary (assuming\n   in this case that \"name\" and \"address\"\
    \ were assigned the same integer\n   as their ASN.1 tags).\n   Having fully-qualified\
    \ data simplifies decoding of the data at the\n   receiving end and allows the\
    \ tags to be locally chosen.  Definitions\n   for tags within routing tables won't\
    \ conflict with definitions for\n   tags within interfaces.  Therefore, the people\
    \ doing the name\n   assignments are less constrained.  In addition, most of the\n\
    \   identifiers will be fairly small integers, which is an advantage\n   because\
    \ ASN.1 can fit tag numbers up to 30 in a one-octet tag field.\n   Larger numbers\
    \ require a second octet.\n   If data is requested that doesn't exist, either\
    \ because the tag is\n   not defined, or because an implementation doesn't provide\
    \ that data\n   (such as when the data is optional), the response will contain\
    \ an\n   ASN.1 object that is empty.  The tag will be the same as in the\n   query,\
    \ and the object will have a length of zero.\n   The same response is given if\
    \ the requested data does exist, but the\n   invoker of the query does not have\
    \ authorization to access it.  See\n   section 10 for more discussion of authorization\
    \ mechanisms.\n   This allows completely generic queries to be composed without\
    \ regard\n   to whether the data is defined or implemented at all of the entities\n\
    \   that will receive the query.  All of the available data will be\n   returned,\
    \ without generating errors that might otherwise terminate\n   the processing\
    \ of the query.\n"
- title: 8. QUERY LANGUAGE
  contents:
  - "8. QUERY LANGUAGE\n   The query language is designed to be expressive enough\
    \ to write\n   useful queries with, yet simple enough to be easy to implement.\
    \  The\n   query processor should be as simple and fast as possible, in order\
    \ to\n   avoid placing a burden on the monitored entity, which may be a\n   critical\
    \ node such as a gateway.\n   Although queries are formed in a flexible way using\
    \ what we term a\n   \"language\", this is not a programming language.  There\
    \ are operations\n   that operate on data, but most other features of programming\n\
    \   languages are not present.  In particular:\n         - Programs are not stored\
    \ in the query processor.\n         - The only form of temporary storage is a\
    \ stack, of limited\n           depth.\n         - There are no subroutines.\n\
    \         - There are no explicit control structures defined in the\n        \
    \   language.\n   The central element of the language is the stack.  It may contain\n\
    \   templates, (and therefore paths), values, and filters taken from the\n   query.\
    \  In addition, it can contain dictionaries (and therefore\n   arrays) from the\
    \ data tree.  At the beginning of a query, it contains\n   one item, the root\
    \ dictionary.\n   The overall operation consists of reading ASN.1 objects from\
    \ the\n   input stream.  All objects that aren't opcodes are pushed onto the\n\
    \   stack as soon as they are read.  Each opcode is executed immediately\n   and\
    \ may remove items from the stack, may generate ASN.1 objects and\n   send them\
    \ to the output stream, and may leave items on the stack.\n   Because each input\
    \ object is dealt with immediately, portions of the\n   response may be generated\
    \ while the query is still being received.\n   In the descriptions below, operator\
    \ names are in capital letters,\n   preceded by the arguments used from the stack\
    \ and followed by results\n   left on the stack.  For example:\n   OP        \
    \                     a b   OP   a t\n             means that the OP operator\
    \ takes <a> and <b> off of the\n             stack and leaves <t> on the stack.\
    \  Most of the operators\n             in the query language leave the first operand\
    \ (<a> in this\n             example) on the stack for future use.\n   If both\
    \ <a> and <b> were received as part of the query (as opposed to\n   being calculated\
    \ by previous operations), then this part of the query\n   would have consisted\
    \ of the sequence:\n       <a>\n       <b>\n       OP\n   So, like other stack-based\
    \ languages, the arguments and operators\n   must be presented in postfix order,\
    \ with an operator following its\n   operands.\n   Here is a summary of all of\
    \ the operators defined in the query\n   language.  Most of the operators can\
    \ take several different sets of\n   operands and behave differently based upon\
    \ the operand types.\n   Details and examples are given later.\n   BEGIN     \
    \              dict1 path   BEGIN   dict1 dict\n                    array path\
    \ filter   BEGIN   array dict\n             Move down in the data tree, establishing\
    \ a context for\n             future operations.\n   END                     \
    \      dict   END   --\n             Undo the most recent BEGIN.\n   GET     \
    \                      dict   GET   dict\n                        dict template\
    \   GET   dict\n                array template filter   GET   array\n        \
    \     Retrieve data from the data tree.\n   GET-ATTRIBUTES\n                 \
    \                dict   GET-ATTRIBUTES   dict\n                        dict template\
    \   GET-ATTRIBUTES   dict\n                array template filter   GET-ATTRIBUTES\
    \   array\n             Retrieve attribute information about data in the data\
    \ tree.\n   GET-RANGE   dict path start length   GET-RANGE   dict\n          \
    \   Retrieve a subrange of an OctetString.  Used for reading\n             memory.\n\
    \   SET                     dict value   SET   dict\n                   array\
    \ value filter   SET   array\n             Change values in the data tree, possibly\
    \ performing control\n             functions.\n   CREATE                 array\
    \ value   CREATE   dict\n             Create new table entries.\n   DELETE   \
    \             array filter   DELETE   array\n             Delete table entries.\n\
    \   These operators are defined so that it is impossible to generate an\n   invalid\
    \ query response.  Since a response is supposed to be a\n   snapshot of a portion\
    \ (or portions) of the data tree, it is important\n   that only data that is actually\
    \ in the tree be put in the response.\n   Two features of the language help guarantee\
    \ this:\n      - Data is put in the response directly from the tree (by\n    \
    \    GET-*).  Data does not go from the tree to the stack and\n        then into\
    \ the response.\n      - Dictionaries on the stack are all derived from the initial,\n\
    \        root dictionary.  The operations that manipulate\n        dictionaries\
    \ (BEGIN and END) also update the response with\n        the new location in the\
    \ tree.\n"
- title: 8.1 Moving Around in the Data Tree
  contents:
  - "8.1 Moving Around in the Data Tree\n   The initial point of reference in the\
    \ data tree is the root.  That\n   is, operators name data starting at the root\
    \ of the tree.  It is\n   useful to be able to move to some other dictionary in\
    \ the tree and\n   then name data from that point.  The BEGIN operator moves down\
    \ in the\n   tree and END undoes the last unmatched BEGIN.\n   BEGIN is used for\
    \ two purposes:\n      - By moving to a dictionary closer to the data of interest,\n\
    \        the name of the data can be shorter than if the full name\n        (from\
    \ the root) were given.\n      - It is used to establish a context for filtered\
    \ operations\n        to operate in.  Filters are discussed in section 8.6.\n\
    \   BEGIN                   dict1 path   BEGIN    dict1 dict\n             Follow\
    \ <path> down the dictionary starting from <dict1>.\n             Push the final\
    \ dictionary named by <path> onto the stack.\n             <path> must name a\
    \ dictionary (not a leaf node).  At the\n             same time, produce the beginning\
    \ octets of an ASN.1 object\n             corresponding to the new dictionary.\
    \  It is up to the\n             implementation to choose between using the \"\
    indefinite\n             length\" representation or the \"definite length\" form\
    \ and\n             going back and filling the length in later.\n   END      \
    \                     dict   END   --\n             Pop <dict> off of the stack\
    \ and terminate the open ASN.1\n             object(s) started by the matching\
    \ BEGIN.  Must be paired\n             with a BEGIN.  If an END operation pops\
    \ the root dictionary\n             off of the stack, the query is terminated.\n\
    \   <path> must point to a regular dictionary.  If any part of it refers\n   to\
    \ a non-existent node, if it points to a leaf node, or if it refers\n   to a node\
    \ inside an array-type dictionary, then it is in error, and\n   the query is terminated\
    \ immediately.\n   An additional form of BEGIN, which takes a filter argument,\
    \ is\n   described later.\n"
- title: 8.2 Retrieving Data
  contents:
  - "8.2 Retrieving Data\n   The basic model that all of the data retrieval operations\
    \ follow is\n   that they take a template and fill in the leaf nodes of the template\n\
    \   with the appropriate data values.\n   GET                  dict template \
    \  GET   dict\n             Emit an ASN.1 object with the same \"shape\" as the\
    \ given\n             template, except with values filled in for each node.  The\n\
    \             first ASN.1 tag of <template> should refer to an object in\n   \
    \          <dict>.  If a dictionary tag is supplied anywhere in\n            \
    \ <template>, the entire dictionary contents are emitted to\n             the\
    \ response.  Any items in the template that are not in\n             <dictionary>\
    \ (or its components) are represented as objects\n             with a length of\
    \ zero.\n                                 dict   GET   dict\n             If there\
    \ is no template, get all of the items in the\n             dictionary.  This\
    \ is equivalent to providing a template\n             that lists all of the items\
    \ in the dictionary.\n   An additional form of GET, which takes a filter argument,\
    \ is\n   described later.\n   Here is an example of using the BEGIN operator to\
    \ move down the data\n   tree to the TCP dictionary and then using the GET operator\
    \ to\n   retrieve 5 data values from the TCP Stats dictionary:\n       IPTransport{\
    \ TCP } BEGIN\n       Stats{ octetsIn, octetsOut, inputPkts, outputPkts, badtag\
    \ } GET\n       END\n   This might return:\n       IPTransport{ TCP\n        \
    \   Stats{ octetsIn(13255), octetsOut(82323),\n                  inputPkts(9213),\
    \ outputPkts(12425), badtag() }\n       }\n   \"badtag\" is a tag value that is\
    \ undefined.  No value is returned for\n   it, indicating that there is no data\
    \ value associated with it.\n"
- title: 8.3 Data Attributes
  contents:
  - "8.3 Data Attributes\n   Although ASN.1 \"self-describes\" the structure and syntax\
    \ of the data,\n   it gives no information about what the data means.  For example,\
    \ by\n   looking at the raw data, it is possible to tell that an item is of\n\
    \   type [context 5] and is 4 octets long.  That does not tell how to\n   interpret\
    \ the data (is this an integer, an IP address, or a 4-\n   character string?)\
    \ or what the data means (IP address of what?).\n   Even if the data were \"tagged\"\
    , in ASN.1 parlance, that would only\n   give the base type (e.g., IP-address\
    \ or counter) and not the meaning.\n   Most of the time, this information will\
    \ come from RFC-1024, which\n   defines the ASN.1 tags and their precise meaning.\
    \  When extensions\n   have been made, it may not be possible to get documentation\
    \ on the\n   extensions.  (Extensions are discussed in section 9.)\n   The GET-ATTRIBUTES\
    \ operator is similar to the GET operator, but\n   returns a set of attributes\
    \ describing the data rather than the data\n   itself.  This information is intended\
    \ to be sufficient to let a human\n   understand the meaning of the data and to\
    \ let a sophisticated\n   application treat the data appropriately.  Such an application\
    \ could\n   use the attribute information to format the data on a display and\n\
    \   decide whether it is appropriate to subtract one sample from another.\n  \
    \ Some of the attributes are textual descriptions to help a human\n   understand\
    \ the nature of the data and provide meaningful labels for\n   it.  Extensive\
    \ descriptions of standard data are optional, since they\n   are defined in RFC-1024.\
    \  Complete descriptions of extensions must be\n   available, even if they are\
    \ documented in a user's manual.  Network\n   firefighters may not have a current\
    \ manual handy when the network is\n   broken.\n   The format of the attributes\
    \ is not as simple as the format of the\n   data itself.  It isn't possible to\
    \ use the data's tag, since that\n   would look exactly like the data itself.\
    \  The format is:\n       Attributes ::= [APPLICATION 3] IMPLICIT SEQUENCE {\n\
    \               tagASN1         [0] IMPLICIT INTEGER,\n               valueFormat\
    \     [1] IMPLICIT INTEGER,\n               longDesc        [2] IMPLICIT IA5String\
    \ OPTIONAL,\n               shortDesc       [3] IMPLICIT IA5String OPTIONAL,\n\
    \               unitsDesc       [4] IMPLICIT IA5String OPTIONAL,\n           \
    \    precision       [5] IMPLICIT INTEGER OPTIONAL,\n               properties\
    \      [6] IMPLICIT BITSTRING OPTIONAL,\n               valueSet        [7] IMPLICIT\
    \ SET OF valueDesc OPTIONAL\n               }\n   The GET-ATTRIBUTES operator\
    \ is similar to the GET operator.  The\n   major difference is that dictionaries\
    \ named in the template do not\n   elicit data for the entire subtree.\n   GET-ATTRIBUTES\n\
    \                        dict template   GET-ATTRIBUTES   dict\n             Emit\
    \ a single ASN.1 Attributes object for each of the\n             objects named\
    \ in <template>.  For each of these, the\n             tagASN1 field will be set\
    \ to the corresponding tag from the\n             template.  The rest of the fields\
    \ are set as appropriate\n             for the data object.  Any items in the\
    \ template that are\n             not in <dictionary> (or its components) elicit\
    \ an\n             Attributes object with a valueFormat of NULL, and no other\n\
    \             descriptive information.\n   or\n                              \
    \   dict   GET-ATTRIBUTES   dict\n             If there is no template, emit Attribute\
    \ objects for all of\n             the items in the dictionary.  This is equivalent\
    \ to\n             providing a template that lists all of the items in the\n \
    \            dictionary.  This allows a complete list of a dictionary's\n    \
    \         contents to be obtained.\n   An additional form of GET-ATTRIBUTES, which\
    \ takes a filter argument,\n   is described later.\n   Here is an example of using\
    \ the GET-ATTRIBUTES operator to request\n   attributes for three objects in the\
    \ System dictionary:\n       System{ name, badtag, clock-msec } GET-ATTRIBUTES\n\
    \   \"badtag\" is some unknown tag.  The result might be:\n       System{\n  \
    \             Attributes{\n                       tagASN1(name),\n           \
    \            valueFormat(IA5String),\n                       longDesc(\"The primary\
    \ hostname.\"),\n                       shortDesc(\"hostname\")\n            \
    \   },\n               Attributes{\n                       tagASN1(badtag), valueFormat(NULL)\n\
    \               }\n               Attributes{\n                       tagASN1(clock-msec),\n\
    \                       valueFormat(Integer),\n                       longDesc(\"\
    milliseconds since boot\"),\n                       shortDesc(\"uptime\"), unitsDesc(\"\
    ms\")\n                       precision(4294967296),\n                       properties(1)\n\
    \               }\n   Note that in this example \"name\" and \"clock-msec\" are\
    \ integer values\n   for the ASN.1 tags for the two data items.  \"badtag\" is\
    \ an integer\n   value that has no corresponding name in this context.\n   There\
    \ will always be exactly as many Attributes items in the result\n   as there are\
    \ objects in the template.  Attributes objects for items\n   which do not exist\
    \ in the entity will have a valueFormat of NULL and\n   none of the optional elements\
    \ will appear.\n       [ A much cleaner method would be to store the attributes\
    \ as\n       sub-components of the data item of interest.  For example,\n    \
    \   requesting\n           System{ clock-msec }  GET\n       would normally just\
    \ get the value of the data.  Asking for an\n       additional layer down the\
    \ tree would now get its attributes:\n           System{ clock-msec{ shortDesc,\
    \ unitsDesc }  GET\n       would get the named attributes.  (The attributes would\
    \ be\n       named with application-specific tags.)  Unfortunately, ASN.1\n  \
    \     doesn't provide a notation to describe this type of\n       organization.\
    \  So, we're stuck with the GET-ATTRIBUTES\n       operator.  However, if a cleaner\
    \ organization were possible,\n       this decision would have been made differently.\
    \ ]\n"
- title: 8.4 Examining Memory
  contents:
  - "8.4 Examining Memory\n   Even with the ability to symbolically access all of\
    \ this information\n   in an entity, there will still be times when it is necessary\
    \ to get\n   to very low levels and examine memory, as in remote debugging\n \
    \  operations.  The building blocks outlined so far can easily be\n   extended\
    \ to allow memory to be examined.\n   Memory is modeled as an ordinary object\
    \ in the data tree, with an\n   ASN.1 representation of OctetString.  Because\
    \ of the variety of\n   addressing architectures in existence, the conversion\
    \ from the\n   internal memory model to OctetString is very machine-dependent.\
    \  The\n   only simple case is for byte-addressed machines with 8 bits per byte.\n\
    \   Each address space in an entity is represented by one \"memory\" data\n  \
    \ item.  In a one-address-space situation, this dictionary will\n   probably be\
    \ in \"System\" dictionary.  If each process has its own\n   address space, then\
    \ one \"memory\" item might exist for each process.\n   Again, this is very machine-dependent.\n\
    \   Although the GET-RANGE operator is provided primarily for the purpose\n  \
    \ of retrieving the contents of memory, it can be used on any object\n   whose\
    \ base type is OctetString.\n   GET-RANGE   dict path start length   GET-RANGE\
    \   dict\n             Get <length> elements of the OctetString, starting at\n\
    \             <start>.  <start> and <length> are both ASN.1 INTEGER type.\n  \
    \           <path>, starting from <dict>, must specify a node\n             representing\
    \ memory, or some other OctetString.\n   The returned data may not be <length>\
    \ octets long, since it may take\n   more than one octet to represent one memory\
    \ location.\n   Memory items in the data tree are special in that they will not\n\
    \   automatically be returned when the entire contents of a dictionary\n   are\
    \ requested.  e.g., If memory is part of the \"System\" dictionary,\n   then the\
    \ query\n       System GET\n   will emit the entire contents of the System dictionary,\
    \ but not the\n   memory item.\n"
- title: '8.5 Control Operations:  Modifying the Data Tree'
  contents:
  - "8.5 Control Operations:  Modifying the Data Tree\n   All of the operators defined\
    \ so far only allow data in an entity to\n   be retrieved.  By replacing the template\
    \ argument used in the GET\n   operators with a value, data in the entity can\
    \ be changed.  Very few\n   items in the data tree can be changed; those that\
    \ can are noted in\n   RFC-1024.\n   Values in the data tree can modified in order\
    \ to change configuration\n   parameters, patch routing tables, etc.  Control\
    \ functions, such as\n   bringing an interface \"down\" or \"up\", do not usually\
    \ map directly to\n   changing a value.  In such cases, an item in the tree can\
    \ be defined\n   to have arbitrary side-effects when a value is assigned to it.\n\
    \   Control operations then consist of \"setting\" this item to an\n   appropriate\
    \ command code.  Reading the value of such an item might\n   return the current\
    \ status.  Again, details of such data tree items\n   are given in RFC-1024.\n\
    \   This \"virtual command-and-status register\" model is very powerful,\n   and\
    \ can be extended by an implementation to provide whatever controls\n   are needed.\
    \  It has the advantage that the control function is\n   associated with the controlled\
    \ object in the data tree.  In addition,\n   no additional language features are\
    \ required to support control\n   functions, and the same operations used to locate\
    \ data for retrieval\n   are used to describe what is being controlled.\n   For\
    \ all of the control and data modification operations, the fill-\n   in-the-blank\
    \ model used for data retrieval is extended: the response\n   to an operation\
    \ is the affected part of the data tree, after the\n   operation has been executed.\
    \  Therefore, for normal execution, SET\n   and CREATE will return the object\
    \ given as an argument, and DELETE\n   will return nothing (because the affected\
    \ portion was deleted).\n   SET                     dict value   SET   dict\n\
    \             Set the value(s) of data in the entity to the value(s)\n       \
    \      given in <value>.  The result will be the value of the data\n         \
    \    after the SET.  Attempting to set a non-settable item will\n            \
    \ not produce an error, but will yield a result in the reply\n             different\
    \ from what was sent.\n   CREATE                 array value   CREATE   dict\n\
    \             Insert a new entry into <array>.  Depending upon the\n         \
    \    context, there may be severe restrictions about what\n             constitutes\
    \ a valid <value>.  The result will be the actual\n             item added to\
    \ the <array>.  Note that only one item can be\n             added per CREATE\
    \ operation.\n   DELETE                array filter   DELETE   array\n       \
    \      Delete the entry(s) in <array> that match <filter>.\n             Filters\
    \ are described later in this document.  Normally, no\n             data items\
    \ will be produced in the response, but if any of\n             the items that\
    \ matched the filter could not be deleted,\n             they will be returned\
    \ in the response.\n   An additional form of SET, which takes a filter argument,\
    \ is\n   described later.\n   Here is an example of attempting to use SET to change\
    \ the number of\n   interfaces in an entity:\n       System{ interfaces(5) } SET\n\
    \   Since that is not a settable parameter, the result would be:\n       System{\
    \ interfaces(2) }\n   giving the old value.\n   Here is an example of how CREATE\
    \ would be used to add a routing table\n   entry for net for 128.89.0.0.\n   \
    \    IPRouting BEGIN                   -- get dictionary\n       Entries{ DestAddr(128.89.0.0),\
    \ ... }    -- entry to insert\n       CREATE\n       END                     \
    \            -- finished with dict\n   The result would be what was added:\n \
    \      IPRouting{ Entries{ DestAddr(128.89.0.0), ... } }\n   The results in the\
    \ response of these operators is consistent of the\n   global model of the response:\
    \  it contains a subset of the data in\n   the tree immediately after the query\
    \ is executed.\n   Note that CREATE and DELETE only operate on arrays, and then\
    \ only on\n   arrays that are specifically intended for it.  For example, it is\n\
    \   quite reasonable to add and remove entries from routing tables or ARP\n  \
    \ tables, both of which are arrays.  However, it doesn't make sense to\n   add\
    \ or remove entries in the \"Interfaces\" dictionary, since the\n   contents of\
    \ that array is dictated by the hardware.  For each array\n   in the data tree,\
    \ RFC-1024 indicates whether CREATE and DELETE are\n   valid.\n   CREATE and DELETE\
    \ are always invalid in non-array contexts.  If\n   DELETE were allowed on monitored\
    \ data, then the deleted data would\n   become unmonitorable to the entire world.\
    \  Conversely, if it were\n   possible to CREATE arbitrary dictionary entries,\
    \ there would be no\n   way to give such entries any meaning.  Even with the data\
    \ in place,\n   there is nothing that would couple the data to the operation of\
    \ the\n   monitored entity. [Creation and deletion would also add considerable\n\
    \   complication to an implementation, because without them, all of the\n   data\
    \ structures that represent the data tree are essentially static,\n   with the\
    \ exception of dynamic tables such as the ones mentioned,\n   which already have\
    \ mechanisms in place for adding and removing\n   entries.]\n"
- title: '8.6 Associative Data Access:  Filters'
  contents:
  - "8.6 Associative Data Access:  Filters\n   One problem that has not been dealt\
    \ with was alluded to earlier: When\n   dealing with array data, how do you specify\
    \ one or more entries based\n   upon some value in the array entries?  Consider\
    \ the situation where\n   there are several interfaces.  The data might be organized\
    \ as:\n       Interfaces {                            -- one per interface\n \
    \              InterfaceData { address, mtu, netMask, ARP{...}, ... }\n      \
    \         InterfaceData { address, mtu, netMask, ARP{...}, ... }\n           \
    \                    :\n               }\n   If you only want information about\
    \ one interface (perhaps because\n   there is an enormous amount of data about\
    \ each), then you have to\n   have some way to name it.  One possibility would\
    \ be to just number\n   the interfaces and refer to the desired interface as\n\
    \       InterfaceData(3)\n   for the third one.\n   But this is not sufficient,\
    \ because interface numbers may change over\n   time, perhaps from one reboot\
    \ to the next.  It is even worse when\n   dealing with arrays with many elements,\
    \ such as routing tables, TCP\n   connections, etc.  Large, changing arrays are\
    \ probably the more\n   common case, in fact.  Because of the lack of utility\
    \ of indexing in\n   this context, there is no general mechanism provided in the\
    \ language\n   for indexing.\n   A better scheme is to select objects based upon\
    \ some value contained\n   in them, such as the IP address.  The query language\
    \ uses filters to\n   select specific table entries that an operator will operate\
    \ on.  The\n   operators BEGIN, GET, GET-ATTRIBUTES, SET, and DELETE can take\
    \ a\n   filter argument that restricts their operation to entries that match\n\
    \   the filter.\n   A filter is a boolean expression that is executed for each\
    \ element in\n   an array.  If an array entry \"matches\" the filter (i.e., if\
    \ the filter\n   produces a \"true\" result), then it is used by the operation.\
    \  A\n   filter expression is very restricted: it can only compare data\n   contained\
    \ in the array element and the comparisons are only against\n   constants.  Comparisons\
    \ may be connected by AND, OR and NOT\n   operators.\n   The ASN.1 definition\
    \ of a filter is:\n       Filter          ::= [APPLICATION 2] CHOICE {\n     \
    \                          present         [0] DataPath,\n                   \
    \            equal           [1] DataValue,\n                               greaterOrEqual\
    \  [2] DataValue,\n                               lessOrEqual     [3] DataValue,\n\
    \                               and             [4] SEQUENCE OF Filter,\n    \
    \                           or              [5] SEQUENCE OF Filter,\n        \
    \                       not             [6] Filter\n                         \
    \      }\n       DataPath        ::= ANY                 -- Path with no value\n\
    \       DataValue       ::= ANY                 -- Single data value\n   This\
    \ definition is similar to the filters used in the ISO monitoring\n   protocol\
    \ (CMIP) and was derived from that specification.\n   \"DataPath\" is the name\
    \ of a single data item; \"DataValue\" is the\n   value of a single data item.\
    \  The three comparisons are all of the\n   form \"data OP constant\", where \"\
    data\" is the value from the tree,\n   \"constant\" is the value from the filter\
    \ expression, and \"OP\" is one\n   of equal, greater-than-or-equal, or less-than-or-equal.\
    \  The last\n   operation, \"present\", tests to see if the named item exists\
    \ in the\n   data tree.  By its nature, it requires no value, so only a path needs\n\
    \   to be given.\n   Here is an example of a filter that matches an Interface\
    \ whose IP\n   address is 10.1.0.1:\n       Filter{ equal{ address(10.0.0.51)\
    \ } }\n   Note that the name of the data to be compared is relative to the\n \
    \  \"InterfaceData\" dictionary.\n   Each operator, when given a filter argument,\
    \ takes an array\n   (dictionary containing only one type of item) as its first\
    \ argument.\n   In the current example, this would be \"Interfaces\".  The items\
    \ in it\n   are all of type \"InterfaceData\".  This tag is referred to as the\n\
    \   \"iteration tag\".\n   Before a filtered operation is used, BEGIN must be\
    \ used to put the\n   array (dictionary) on top of the stack, to establish it\
    \ as the\n   context that the filter iterates over.  The general operation of\
    \ a\n   filtered operation is then:\n         1. Iterate over the items in the\
    \ array.\n         2. For each element in the array, execute the filter.\n   \
    \      3. If the filter succeeds, do the requested operation\n            (GET/SET/etc.)\
    \ on the matched element, using the\n            template/value/path as input\
    \ to the operation.  At this\n            point, the execution of the operation\
    \ is the same as in\n            the non-filtered case.\n   This is a model of\
    \ operation; actual implementations may take\n   advantage of whatever lookup\
    \ techniques are available for the\n   particular table (array) involved.\n  \
    \ Therefore, there are three inputs to a filtered operation:\n         1. The\
    \ \"current dictionary\" on the stack.  This is the\n            array-type dictionary\
    \ to be searched, set by an earlier\n            BEGIN.\n         2. A filter,\
    \ to test each item in the array.  Each path or\n            value mentioned in\
    \ the filter must be named in the context\n            of an item in the array,\
    \ as if it was the current\n            dictionary.  For example, in the case\
    \ where a filtered\n            operation iterates over the set of \"InterfaceData\"\
    \ items\n            in the \"Interfaces\" array, each value or path in the\n\
    \            filter should name an item in the \"InterfaceData\"\n           \
    \ dictionary, such as \"address\".\n         3. A template, path, or value associated\
    \ with the operation\n            to be performed.  The leading ASN.1 tag in this\
    \ must match\n            the iteration tag.  In the current example where the\n\
    \            filter is searching the \"Interfaces\" dictionary, the first\n  \
    \          tag in the template/tag/value must be \"InterfaceData\".\n   The operators\
    \ which take filters as arguments are:\n   BEGIN            array path filter\
    \   BEGIN   array dict\n             Find a dictionary in <array> that matches\
    \ <filter>.  Use\n             that as the starting point for <path> and push\
    \ the\n             dictionary corresponding to <path> onto the stack.  If more\n\
    \             than one dictionary matches <filter>, then any of the\n        \
    \     matches may be used.  This specification does not state how\n          \
    \   the choice is made.  At least one dictionary must match; it\n            \
    \ is an error if there are no matches.  (Perhaps it should be\n             an\
    \ error for there to be multiple matches; actual\n             experience is needed\
    \ to decide.)\n   GET          array template filter   GET   array\n         \
    \    For each item in <array> that matches <filter>, fill in the\n           \
    \  template with values from the data tree and emit the\n             result.\
    \  The first tag of <template> must be equal to the\n             iteration tag.\
    \  Selected parts of matched items are emitted\n             based upon <template>,\
    \ just as in a non-filtered GET\n             operation.\n   GET-ATTRIBUTES\n\
    \                array template filter   GET-ATTRIBUTES   array\n            \
    \ Same as GET, except emit attributes rather than data\n             values.\n\
    \   SET             array value filter   SET   array\n             Same as GET,\
    \ except set the values in <value> rather than\n             retrieving values.\
    \  Several values in the data tree will be\n             changed if the filter\
    \ matches more than one item in the\n             array.\n   DELETE          \
    \      array filter   DELETE   array\n             Delete the entry(s) in <array>\
    \ that match <filter>.\n   Notes about filter execution:\n      - Expressions\
    \ are executed by inorder tree traversal.\n      - Since the filter operations\
    \ are all GETs and comparisons,\n        there are no side-effects to filter execution,\
    \ so an\n        implementation is free to execute only as much of the\n     \
    \   filter as required to produce a result (e.g., don't execute\n        the rest\
    \ of an AND if the first comparison turns out to be\n        false).\n      -\
    \ It is not an error for a filter to test a data item that\n        isn't in the\
    \ data tree.  In this situation, the comparison\n        just fails (is false).\
    \  This means that filters don't need\n        to test for the existence of optional\
    \ data before\n        attempting to compare it.\n   Here is an example of how\
    \ filtering would be used to obtain the input\n   and output packet counts for\
    \ the interface with IP address 10.0.0.51.\n       Interfaces BEGIN          \
    \            -- dictionary\n       InterfaceData{ pktsIn, pktsOut }      -- template\n\
    \       Filter{ equal{ address(10.0.0.51) } }\n       GET\n       END        \
    \                           -- finished with dict\n   The returned value would\
    \ be something like:\n       Interfaces{                             -- BEGIN\n\
    \         InterfaceData{ pktsIn(1345134), pktsOut(1023729) }\n               \
    \                                -- GET\n       }                            \
    \           -- END\n   The annotations indicate which part of the response is\
    \ generated by\n   the different operators in the query.\n   Here is an example\
    \ of accessing a table contained within some other\n   table.  Suppose we want\
    \ to get at the ARP table for the interface\n   with IP address 36.8.0.1 and retrieve\
    \ the entire ARP entry for the\n   host with IP address 36.8.0.23.  In order to\
    \ retrieve a single entry\n   in the ARP table (using a filtered GET), a BEGIN\
    \ must be used to get\n   down to the ARP table.  Since the ARP table is contained\
    \ within the\n   Interfaces dictionary (an array), a filtered BEGIN must be used.\n\
    \       Interfaces BEGIN                        -- dictionary\n       InterfaceData{\
    \ ARP }                    -- path\n       Filter{ equal{ address(36.8.0.1) }\
    \ }    -- filter\n       BEGIN                                   -- filtered BEGIN\n\
    \       -- Now in ARP table for 38.0.0.1; get entry for 38.8.0.23.\n       addrMap\
    \                                 -- whole entry\n       Filter{ equal{ ipAddr(36.8.0.23)\
    \ } }    -- filter\n       GET                                     -- filtered\
    \ GET\n       END\n       END\n   The result would be:\n       Interfaces{   \
    \                          -- first BEGIN\n         InterfaceData{ ARP{      \
    \             -- second BEGIN\n           addrMap{ ipAddr(36.8.0.23), physAddr(..)\
    \ } -- from GET\n         } }                                   -- first END\n\
    \       }                                       -- second END\n   Note which parts\
    \ of the output are generated by different parts of\n   the query.\n   Here is\
    \ an example of how the SET operator would be used to shut down\n   the interface\
    \ with ip-address 10.0.0.51 by changing its status to\n   \"down\".\n       Interfaces\
    \ BEGIN                    -- get dictionary\n       Interface{ Status(down) }\
    \           -- value to set\n       Filter{ equal{ IP-addr(10.0.0.51) } }\n  \
    \     SET\n       END\n   If the SET is successful, the result would be:\n   \
    \    Interfaces{                             -- BEGIN\n           Interface{ Status(down)\
    \ }           -- from SET\n       }                                       -- END\n"
- title: 8.7 Terminating a Query
  contents:
  - "8.7 Terminating a Query\n   A query is implicitly terminated when there are no\
    \ more ASN.1 objects\n   to be processed by the interpreter.  For a perfectly-formed\
    \ query,\n   the interpreter would be back in the state it was when it started:\n\
    \   the stack would have only the root dictionary on it, and all of the\n   ASN.1\
    \ objects in the result would be terminated.\n   If there are still \"open\" ASN.1\
    \ objects in the result (caused by\n   leaving ENDs off of the query), then these\
    \ are closed, as if a\n   sufficient number of ENDs were provided.  This condition\
    \ would be\n   indicated by the existence of dictionaries other than the root\n\
    \   dictionary on the stack.\n   If an extra END is received that would pop the\
    \ root dictionary off of\n   the stack, the query is terminated immediately. \
    \ No error is\n   generated.\n"
- title: 9. EXTENDING THE SET OF VALUES
  contents:
  - "9. EXTENDING THE SET OF VALUES\n   There are two ways to extend the set of values\
    \ understood by the\n   query language.  The first is to register the data and\
    \ its meaning\n   and get an ASN.1 tag assigned for it.  This is the preferred\
    \ method\n   because it makes that data specification available for everyone to\n\
    \   use.\n   The second method is to use the VendorSpecific application type to\n\
    \   \"wrap\" the vendor-specific data.  Wherever an implementation defines\n \
    \  data that is not in RFC-1024, the \"VendorSpecific\" tag should be used\n \
    \  to label a dictionary containing the vendor-specific data.  For\n   example,\
    \ if a vendor had some data associated with interfaces that\n   was too strange\
    \ to get standard numbers assigned for, they could,\n   instead represent the\
    \ data like this:\n          interfaces {\n                  interface {\n   \
    \                       in-pkts, out-pkts, ...\n                          VendorSpecific\
    \ { ephemeris, declination }\n                          }\n                  }\n\
    \   In this case, ephemeris and declination correspond to two context-\n   dependent\
    \ tags assigned by the vendor for their non-standard data.\n   If the vendor-specific\
    \ method is chosen, the private data MUST have\n   descriptions available through\
    \ the GET-ATTRIBUTES operator.  Even\n   with this descriptive ability, the preferred\
    \ method is to get\n   standard numbers assigned if possible.\n"
- title: 10. AUTHORIZATION
  contents:
  - "10. AUTHORIZATION\n   This specification does not state what type of authorization\
    \ system\n   is used, if any.  Different systems may have needs for different\n\
    \   mechanisms (authorization levels, capability sets, etc.), and some\n   systems\
    \ may not care about authorization at all.  The only effect\n   that an authorization\
    \ system has on a query is to restrict what data\n   items in the tree may be\
    \ retrieved or modified.\n   Therefore, there are no explicit query language features\
    \ that deal\n   with protection.  Instead, protection mechanisms are implicit\
    \ and may\n   make some of the data invisible (for GET) or non-writable (for SET):\n\
    \      - Each query runs with some level of authorization or set of\n        capabilities,\
    \ determined by its environment (HEMS and the\n        HEMP header).\n      -\
    \ Associated with each data item in the data tree is some\n        sort of test\
    \ to determine if a query's authorization should\n        grant it access to the\
    \ item.\n   Authorization tests are only applied to query language operations\n\
    \   that retrieve information (GET, GET-ATTRIBUTES, and GET-RANGE) or\n   modify\
    \ it (SET, CREATE, DELETE).  An authorization system must not\n   affect the operation\
    \ of BEGIN and END.  In particular, the\n   authorization must not hide entire\
    \ dictionaries, because that would\n   make a BEGIN on such a dictionary fail,\
    \ terminating the entire query.\n"
- title: 11. ERRORS
  contents:
  - "11. ERRORS\n   If some particular information is requested but is not available,\
    \ it\n   will be returned as \"no-value\" by giving the ASN.1 length as 0.\n \
    \  When there is any other kind of error, such as having improper\n   arguments\
    \ on the top of the stack or trying to execute BEGIN when the\n   path doesn't\
    \ refer to a dictionary, an ERROR object is emitted.\n   The contents of this\
    \ object identify the exact nature of the error:\n          Error ::= [APPLICATION\
    \ 0] IMPLICIT SEQUENCE {\n                  errorCode       INTEGER,\n       \
    \           errorInstance   INTEGER,\n                  errorOffset     INTEGER\n\
    \                  errorDescription IA5String,\n                  errorOp    \
    \     INTEGER,\n                  }\n   errorCode identifies what the error was,\
    \ and errorInstance is an\n   implementation-dependent code that gives a more\
    \ precise indication of\n   where the error occured.  errorOffset is the location\
    \ within the\n   query where the error occurred.  If an operation was being executed,\n\
    \   errorOp contains its operation code, otherwise zero.\n   errorDescription\
    \ is a text string that can be printed that gives some\n   description of the\
    \ error.  It will at least describe the errorCode,\n   but may also give details\
    \ implied by errorInstance.  Detailed\n   definitions of all of the fields are\
    \ given in appendix I.2.\n   Since there may be several unterminated ASN.1 objects\
    \ in progress at\n   the time the error occurs, each one must be terminated. \
    \ Each\n   unterminated object will be closed with a copy of the ERROR object.\n\
    \   Depending upon the type of length encoding used for this object, this\n  \
    \ will involve filling the value for the length (definite length form)\n   or\
    \ emitting two zero octets (indefinite length form).  After all\n   objects are\
    \ terminated, a final copy of the ERROR object will be\n   emitted.  This structure\
    \ guarantees that the error will be noticed at\n   every level of interpretation\
    \ on the receiving end.\n   In summary, if there was an error before any ASN.1\
    \ objects were\n   generated, then the result would simply be:\n       error{...}\n\
    \   If a couple of ASN.1 objects were unterminated when the error\n   occurred,\
    \ the result might look like:\n       interfaces{\n            interface { name(...)\
    \ type(...) error{...} }\n            error{...}\n            }\n       error{...}\n\
    \   It would be possible to define a \"WARNING\" object that has a similar\n \
    \  (or same) format as ERROR, but that would be used to annotate\n   responses\
    \ when a non-fatal \"error\" occurs, such as attempting to\n   SET/CREATE/DELETE\
    \ and the operation is denied.  This would be an\n   additional complication,\
    \ and we left it out in the interests of\n   simplicity.\n"
- title: I. ASN.1 DESCRIPTIONS OF QUERY LANGUAGE COMPONENTS
  contents:
  - "I. ASN.1 DESCRIPTIONS OF QUERY LANGUAGE COMPONENTS\n   A query consists of a\
    \ sequence of ASN.1 objects, as follows:\n       Query := IMPLICIT SEQUENCE of\
    \ QueryElement;\n       QueryElement ::= CHOICE {\n               Operation,\n\
    \               Filter,\n               Template,\n               Path,\n    \
    \           InputValue\n               }\n   Operation and Filter are defined\
    \ below.  The others are:\n       Template        ::= any\n       Path       \
    \     ::= any\n       InputValue      ::= any\n   These three are all similar,\
    \ but have different restrictions on their\n   structure:\n   Template       \
    \ Specifies a portion of the tree, naming one or more\n                   values,\
    \ but not containing any values.\n   Path            Specifies a single path from\
    \ one point in the tree to\n                   another, naming exactly one value,\
    \ but not containing\n                   a value.\n   InputValue      Gives a\
    \ value to be used by a query language\n                   operator.\n   A query\
    \ response consists of a sequence of ASN.1 objects, as follows:\n       Response\
    \ := IMPLICIT SEQUENCE of ResponseElement;\n       ResponseElement ::= CHOICE\
    \ {\n               ResultValue,\n               Error\n               }\n   Error\
    \ is defined below.  The others are:\n       ResultValue     ::= any\n   ResultValue\
    \ is similar to Template, above:\n   ResultValue     Specifies a portion of the\
    \ tree, naming and\n                   containing one or more values.\n   The\
    \ distinctions between these are elaborated in section 6.\n"
- title: I.1 Operation Codes
  contents:
  - "I.1 Operation Codes\n   Operation codes are all encoded in a single application-specific\n\
    \   type, whose value determines the operation to be performed.  The\n   definition\
    \ is:\n       Operation ::= [APPLICATION 1] IMPLICIT INTEGER {\n             \
    \  reserved(0),\n               begin(1),\n               end(2),\n          \
    \     get(3),\n               get-attributes(4),\n               get-range(5),\n\
    \               set(6),\n               create(7),\n               delete(8)\n\
    \               }\n"
- title: I.2 Error Returns
  contents:
  - "I.2 Error Returns\n   An Error object is returned within a reply when an error\
    \ is\n   encountered during the processing of a query.  Note that the\n   definition\
    \ this object is similar to that of the HEMP protocol error\n   structure.  The\
    \ error codes have been selected to keep the code\n   spaces distinct between\
    \ the two.  This is intended to ease the\n   processing of error messages.  See\
    \ section 11 for more information.\n       Error ::= [APPLICATION 0] IMPLICIT\
    \ SEQUENCE {\n               errorCode       INTEGER,\n               errorInstance\
    \   INTEGER,\n               errorOffset     INTEGER\n               errorDescription\
    \ IA5String,\n               errorOp         INTEGER,\n               }\n   The\
    \ fields are defined as follows:\n   errorCode       Identifies the general cause\
    \ of the error.\n   errorInstance   An implementation-dependent code that gives\
    \ a more\n                   precise indication of where the error occured in\
    \ the\n                   query processor.  This is most useful when internal\n\
    \                   errors are reported.\n   errorOffset     The location within\
    \ the query where the error was\n                   detected.  The first octet\
    \ of the query is numbered\n                   zero.\n   errorOp         If an\
    \ operation was being executed, this contains its\n                   operation\
    \ code, otherwise zero.\n   errorDescription\n                   A text string\
    \ that can be printed that gives some\n                   description of the error.\
    \  It will at least describe\n                   the errorCode, but may also give\
    \ details implied by\n                   errorInstance.\n   Some errors are associated\
    \ with the execution of specific operations,\n   and others with the overall operation\
    \ of the query interpreter.  The\n   errorCodes are split into two groups.\n \
    \  The first group deals with overall interpreter operation.  Except for\n   \"\
    unknown operation\", these do not set errorOp.\n   100             Other error.\n\
    \                   Any error not listed below.\n   101             Format error.\n\
    \                   An error has been detected in the format of the input\n  \
    \                 stream, preventing further interpretation of the\n         \
    \          query.\n   102             System error.\n                   The query\
    \ processor has failed in some way due to an\n                   internal error.\n\
    \   103             Stack overflow.\n                   Too many items were pushed\
    \ on the stack.\n   104             Unknown operation.\n                   The\
    \ operation code is invalid.  errorOp is set.\n   The second group is errors that\
    \ are associated with the execution of\n   particular operations.  errorOp will\
    \ always be set for these.\n   200             Other operation error.\n      \
    \             Any error, associated with an operation, not listed\n          \
    \         below.\n   201             Stack underflow.\n                   An operation\
    \ expected to see some number of operands\n                   on the stack, and\
    \ there were fewer items on the\n                   stack.\n   202           \
    \  Operand error.\n                   An operation expected to see certain operand\
    \ types on\n                   the stack, and something else was there.\n   203\
    \             Invalid path for BEGIN.\n                   A path given for BEGIN\
    \ was invalid, because some\n                   element in the path didn't exist.\n\
    \   204             Non-dictionary for BEGIN.\n                   A path given\
    \ for BEGIN was invalid, because the given\n                   node was a leaf\
    \ node, not a dictionary.\n   205             BEGIN on array element.\n      \
    \             The path specified an array element.  The path must\n          \
    \         point at a single, unique, node.  A filtered BEGIN\n               \
    \    should have been used.\n   206             Empty filter for BEGIN.\n    \
    \               The filter for a BEGIN didn't match any array\n              \
    \     element.\n   207             Filtered operation on non-array.\n        \
    \           A filtered operation was attempted on a regular\n                \
    \   dictionary.  Filters can only be used on arrays.\n   208             Index\
    \ out of bounds.\n                   The starting address or length for a GET-RANGE\n\
    \                   operation went outside the bounds for the given\n        \
    \           object.\n   209             Bad object for GET-RANGE.\n          \
    \         GET-RANGE can only be applied to objects whose base\n              \
    \     type is OctetString.\n   This list is probably not quite complete, and would\
    \ need to be\n   extended, based upon implementation experience.\n"
- title: I.3 Filters
  contents:
  - "I.3 Filters\n   Many of the operations can take a filter argument to select among\n\
    \   elements in an array.  They are discussed in section 8.6.\n        Filter\
    \          ::= [APPLICATION 2] CHOICE {\n                               present\
    \         [0] DataPath,\n                               equal           [1] DataValue,\n\
    \                               greaterOrEqual  [2] DataValue,\n             \
    \                  lessOrEqual     [3] DataValue,\n                          \
    \     and             [4] SEQUENCE OF Filter,\n                              \
    \ or              [5] SEQUENCE OF Filter,\n                               not\
    \             [6] Filter\n                               }\n       DataPath  \
    \      ::= ANY                 -- Path with no value\n       DataValue       ::=\
    \ ANY                 -- Single data value\n   A filter is executed by inorder\
    \ traversal of its ASN.1 structure.\n   The basic filter operations are:\n   present\
    \         tests for the existence of a particular data item in\n             \
    \      the data tree\n   equal           tests to see if the named data item is\
    \ equal to the\n                   given value.\n   greaterOrEqual  tests to see\
    \ if the named data item is greater than\n                   or equal to the given\
    \ value.\n   lessOrEqual     tests to see if the named data item is less than\
    \ or\n                   equal to the given value.\n   These may be combined with\
    \ \"and\", \"or\", and \"not\" operators to form\n   arbitrary boolean expressions.\
    \  The \"and\" and \"or\" operators will\n   take any number of terms.  Terms\
    \ are only evaluated up to the point\n   where the outcome of the expression is\
    \ determined (i.e., an \"and\"\n   term's value is false or an \"or\" term's value\
    \ is true).\n"
- title: I.4 Attributes
  contents:
  - "I.4 Attributes\n   One or more Attributes structure is returned by the GET-ATTRIBUTES\n\
    \   operator.  This structure provides descriptive information about\n   items\
    \ in the data tree.  See the discussion in section 8.3.\n       Attributes ::=\
    \ [APPLICATION 3] IMPLICIT SEQUENCE {\n               tagASN1         [0] IMPLICIT\
    \ INTEGER,\n               valueFormat     [1] IMPLICIT INTEGER,\n           \
    \    longDesc        [2] IMPLICIT IA5String OPTIONAL,\n               shortDesc\
    \       [3] IMPLICIT IA5String OPTIONAL,\n               unitsDesc       [4] IMPLICIT\
    \ IA5String OPTIONAL,\n               precision       [5] IMPLICIT INTEGER OPTIONAL,\n\
    \               properties      [6] IMPLICIT BITSTRING OPTIONAL,\n           \
    \    valueSet        [7] IMPLICIT SET OF valueDesc OPTIONAL\n               }\n\
    \       valueDesc ::= IMPLICIT SEQUENCE {\n               value           [0]\
    \ ANY,        -- Single data value\n               desc            [1] IA5String\n\
    \               }\n   The meanings of the various attributes are given below.\n\
    \   tagASN1         The ASN.1 tag for this object.  This attribute is\n      \
    \             required.\n   valueFormat     The underlying ASN.1 type of the object\
    \ (e.g.,\n                   SEQUENCE or OCTETSTRING or Counter).  This is not\n\
    \                   just the tag number, but the entire tag, as it would\n   \
    \                appear in an ASN.1 object.  As such, it includes the\n      \
    \             class, which should be either UNIVERSAL or\n                   APPLICATION.\
    \  Applications receiving this should\n                   ignore the constructor\
    \ bit.  This attribute is\n                   required.\n   longDesc        A\
    \ potentially lengthy text description which fully\n                   defines\
    \ the object.  This attribute is optional for\n                   objects defined\
    \ in this memo and required for\n                   entity-specific objects.\n\
    \   shortDesc       A short mnemonic string of less than 15 characters,\n    \
    \               suitable for labeling the value on a display.  This\n        \
    \           attribute is optional.\n   unitsDesc       A short string used for\
    \ integer values to indicate\n                   the units in which the value\
    \ is measured (e.g., \"ms\",\n                   \"sec\", \"pkts\", etc.).  This\
    \ attribute is optional.\n   precision       For Counter objects, the value at\
    \ which the Counter\n                   will roll-over.  Required for all Counter\
    \ objects.\n   properties      A bitstring of boolean properties of the object.\
    \  If\n                   the bit is on, it has the given property.  This\n  \
    \                 attribute is optional.  The bits currently defined\n       \
    \            are:\n                   0   If true, the difference between two\
    \ values of\n                       this object is significant.  For example,\
    \ the\n                       changes of a packet count is always significant,\n\
    \                       it always conveys information.  In this case, the\n  \
    \                     0 bit would be set.  On the other hand, the\n          \
    \             difference between two readings of a queue length\n            \
    \           may be meaningless.\n                   1   If true, the value may\
    \ be modified with SET,\n                       CREATE, and DELETE.  Applicability\
    \ of CREATE and\n                       DELETE depends upon whether the object\
    \ is in an\n                       array.\n                   2   If true, the\
    \ object is a dictionary, and a BEGIN\n                       may be used on it.\
    \  If false, the object is leaf\n                       node in the data tree.\n\
    \                   3   If true, the object is an array-type dictionary,\n   \
    \                    and filters may be used to traverse it.  (Bit 2\n       \
    \                will be true also.)\n   valueSet        For data that is defined\
    \ as an ASN.1 CHOICE type (an\n                   enumerated type), this gives\
    \ descriptions for each of\n                   the possible values that the data\
    \ object may assume.\n                   Each valueDesc is a <value,description>\
    \ pair.  This\n                   information is especially important for control\n\
    \                   items, which are very likely to appear in\n              \
    \     VendorSpecific dictionaries, exactly the situation\n                   where\
    \ descriptive information is needed.\n"
- title: I.5 VendorSpecific
  contents:
  - "I.5 VendorSpecific\n   See the discussion in section 9.\n       VendorSpecific\
    \          ::= [APPLICATION 4] IMPLICIT SET\n                                \
    \       of ANY\n"
- title: II. IMPLEMENTATION HINTS
  contents:
  - "II. IMPLEMENTATION HINTS\n   Although it is not normally in the spirit of RFCs\
    \ to define an\n   implementation, the authors feel that some suggestions will\
    \ be useful\n   to implementors of the query language.  This list is not meant\
    \ to be\n   complete, but merely to give some hints about how the authors imagine\n\
    \   that the query processor might be implemented efficiently.\n      - It should\
    \ be understood that the stack is of very limited\n        depth.  Because of\
    \ the nature of the query language, it can\n        get only about 4 entries (for\
    \ arguments) plus the depth of\n        the tree (up to one BEGIN per level in\
    \ the tree).  This\n        comes out to about a dozen entries in the stack, a\
    \ modest\n        requirement.\n      - The stack is an abstraction -- it should\
    \ be implemented\n        with pointers, not by copying dictionaries, etc.\n \
    \     - An object-oriented approach should make implementation\n        fairly\
    \ easy.  Changes to the \"shape\" if the data items\n        (which will certainly\
    \ occur, early on) will also be easier\n        to make.\n      - Only a few \"\
    messages\" need to be understood by objects.  By\n        having pointers to action\
    \ routines for each basic operation\n        (GET,SET,...) associated with each\
    \ node in the tree, common\n        routines (e.g., emit a long integer located\
    \ at address X)\n        can be shared, and special routines (e.g., set the interface\n\
    \        state for interface X) can be implemented in a common\n        framework.\
    \  Higher levels need know nothing about what data\n        is being dealt with.\n\
    \      - Most interesting objects are dictionaries, each of which\n        can\
    \ be implemented using pointers to the data and procedure\n        \"hooks\" to\
    \ perform specific operations such as GET, SET,\n        filtering, etc.\n   \
    \   - The hardest part is actually extracting the data from\n        existing\
    \ TCP/IP implementations that weren't designed with\n        detailed monitoring\
    \ in mind.  Query processors interfacing\n        to a UNIX kernel will have to\
    \ make many system calls in\n        order to extract some of the more intricate\
    \ structures,\n        such as routing tables.  This should be less of a problem\n\
    \        if a system is designed with easy monitoring as a goal.\n"
- title: A Skeletal Implementation
  contents:
  - "A Skeletal Implementation\n   This section gives a rather detailed example of\
    \ the core of a query\n   processor.  This code has not been tested, and is intended\
    \ only to\n   give implementors ideas about how to tackle some aspects of query\n\
    \   processor implementation with finesse, rather than brute force.\n   The suggested\
    \ architecture is for each dictionary to have a\n   \"traverse\" routine associated\
    \ with it, which is called when any sort\n   of operation has to be done on that\
    \ dictionary.  Most nodes will\n   share the same traversal routine, but array\
    \ dictionaries will usually\n   have routines that know about whatever special\
    \ lookup mechanisms are\n   required.\n   Non-dictionary nodes would have two\
    \ routines, \"action\", and\n   \"compare\", which implement query language operations\
    \ and filter\n   comparisons, respectively.  Most nodes would share these routines.\n\
    \   For example, there should be one \"action\" routine that does query\n   language\
    \ operations on 32-bit integers, and another that works on\n   16-bit integers,\
    \ etc.\n   Any traversal procedure would take arguments like:\n       traverse(node,\
    \ mask, op, filter)\n               Treenode        node;   /* generic node-in-tree\
    \ */\n               ASN             mask;   /* internal ASN.1 form */\n     \
    \          enum opset      op;     /* what to do */\n               Filter   \
    \       filter; /* zero if no filter */\n       enum opset { begin, get, set,\
    \ create, delete, geta,\n                       c_le, c_ge, c_eq, c_exist };\n\
    \   The traversal procedure is called whenever anything must be done\n   within\
    \ a dictionary.  The arguments are:\n   node            the current dictionary.\n\
    \   mask            is either the template, path, or value, depending\n      \
    \             upon the operation being performed.  The top-level\n           \
    \        identifier of this object will be looked up in the\n                \
    \   context of <node>.\n   op              is the operation to be performed, either\
    \ one of the\n                   basic operations, or a filter operation.\n  \
    \ filter          is the filter to be applied, or zero if none.  There\n     \
    \              will be no filter when <op> is a filter-comparison\n          \
    \         operation.\n   The general idea is that the traversal proc associated\
    \ with a node\n   has all of the knowledge about how to get around in this subtree\n\
    \   encoded within it.  Hopefully, this will be the only place this\n   knowledge\
    \ is coded.  Here is a skeleton of the \"standard\" traversal\n   proc, written\
    \ mostly in C.\n   When the query processor needs to execute a \"GET\" operation,\
    \ it would\n   just call:\n       traverse(current, template, GET, 0)\n   Notes\
    \ about this example:\n      - This traversal routine handles either query language\n\
    \        operations (GET, SET, etc.) or low-level filter operations.\n       \
    \ Separate routines could be defined for the two classes of\n        operations,\
    \ but they do much of the same work.\n      - Dictionary nodes have a <traversal>\
    \ proc defined.\n      - Leaf nodes have an <action> proc, which implement GET,\
    \ SET,\n        GET-ATTRIBUTES, CREATE, and DELETE, and a <compare> proc,\n  \
    \      which performs low-level filter comparisons.\n      - In the generic routine,\
    \ the filter argument is unused,\n        because the generic routine isn't used\
    \ for array\n        dictionaries, and only array dictionaries use filters.\n\
    \      - An ASN type contains the top level tag and a list of\n        sub-components.\n\
    \      - size(mask) takes an ASN.1 object and tells how many\n        sub-items\
    \ are in it.  Zero means that this is a simple\n        object.\n      - lookup(node,\
    \ tag) looks up a tag in the given (tree)node,\n        returning a pointer to\
    \ the node.  If the tag doesn't exist\n        in that node, a pointer to a special\
    \ node \"NullItem\" is\n        returned.  NullItem looks like a leaf node and\
    \ has procs\n        that perform the correct action for non-existent data.\n\
    \      - This example does not do proper error handling, or ASN.1\n        generation,\
    \ both of which would require additional code in\n        this routine.\n    \
    \   /*\n        *  For op = GET/SET/etc, return:\n        *              true\
    \ on error, otherwise false.\n        *  When op is a filter operation, return:\n\
    \        *              the result of the comparison.\n        */\n       int\
    \ std_traverse(node, mask, op, filter)\n           Treenode    node;   /* current\
    \ node */\n           ASN         mask;   /* internal ASN.1 form */\n        \
    \   enum opset  op;     /* what to do */\n           Filter      filter; /* unused\
    \ in this routine */\n       {\n           ASN         item;\n           Treenode\
    \    target;\n           boolean     rv = false;\n           extern Treenode NullItem;\n\
    \           if (filter != null) {\n               error(...);\n              \
    \ return true;\n           }\n           target = lookup(node, mask.tag);\n  \
    \         /*  We are at the leaf of the template/path/value.  */\n           if\
    \ (size(mask) == 0)\n               switch (op)\n               {\n          \
    \     case BEGIN:\n                   /*  non-existent node, or leaf node  */\n\
    \                   if (target == NullItem || target.traverse == 0) {\n      \
    \                 error(...);\n                       return true;\n         \
    \              }\n                   else {\n                       begin(node,\
    \ mask.tag);\n                       return false;\n                       }\n\
    \               case GET:       case SET:       case GETA:\n               case\
    \ GETR:      case CREATE:    case DELETE:\n                   /*  A leaf in the\
    \ mask specifies entire directory.\n                       For GET, traverse the\
    \ entire subtree.  */\n                   if (target.traverse)\n             \
    \          if (op == GET) {\n                           foreach subnode in target\n\
    \                               /*  Need to test to not GET memory.  */\n    \
    \                           rv |= (*target.traverse)\n                       \
    \                (target, subnode.tag, op, 0);\n                           return\
    \ rv;\n                       }\n                       else if (op == SET)  \
    \   /*  no-op  */\n                           return false;\n                \
    \       else if (op != GETA) {\n                           error(...);\n     \
    \                      return true;\n                       }\n              \
    \     /*  We're at a leaf in both the mask and the tree.\n                   \
    \    Just execute the operation.\n                   */\n                   else\
    \ {\n                       if (op == BEGIN) {  /*  Can't begin on leaf  */\n\
    \                           error(...);\n                           return true;\n\
    \                       else\n                           return (*target.action)(target,\
    \ mask, op);\n                       }\n                   }  /* else */\n   \
    \            default:        /*  Comparison ops.  */\n                   return\
    \ (*target.compare)(target, mask, op);\n               }  /* switch */\n     \
    \      /*  We only get here if mask has structure.  */\n           /*  can't have\
    \ multiple targets for BEGIN  */\n           if (op == BEGIN && size(mask) !=\
    \ 1) {\n               error(...);\n               return true;\n           }\n\
    \           /*  or for a single filter operation.  */\n           if (op is comparison\
    \ && size(mask) != 1) {\n               error(...);\n               return false;\n\
    \           }\n           /*  Iterate over the components in mask  */\n      \
    \     foreach item in mask\n           {\n               if (target.traverse)\
    \    /*  traverse subtree.  */\n                   rv |= (*component.traverse)(component,\
    \ item, op, 0);\n               else                    /*  leaf node, at last.\
    \  */\n                   if (op is comparison)\n                       return\
    \ (*target.compare)(target, mask, op);\n                   else\n            \
    \           return (*target.action)(target, mask, op);\n           } /* foreach\
    \ */\n           return rv;\n       }  /* std_traverse */\n   Here is a bare skeleton\
    \ of an array-type dictionary's traversal proc.\n       int array_traverse(node,\
    \ mask, op, filter)\n           Treenode    node;   /* current node */\n     \
    \      ASN         mask;   /* internal ASN.1 form */\n           enum opset  op;\
    \     /* what to do */\n           Filter      filter; /* unused in this routine\
    \ */\n       {\n           Treenode    target;\n           boolean     rv = false;\n\
    \           extern Treenode NullItem;\n           /*  Didn't find that key.  */\n\
    \           if (mask.tag != this array's iteration tag)\n               return\
    \ false;\n           if (op == BEGIN && filter == null) {\n               error(...);\n\
    \               return 1;\n           }\n           /*  The implementation of\
    \ this loop is the major trick!  */\n           /*  Needs to stop after first\
    \ filter success on BEGIN.  */\n           foreach target in node {\n        \
    \       if (filter == null ||           /*  if no filter, or */\n            \
    \       ExecFilter(target, filter)) /* if it succeeds  */\n                  \
    \ rv |= (target.traverse*)(target, mask, op, 0);\n           }\n       }  /* array_traverse\
    \ */\n   Object-oriented programming languages, such as C++, Modula, and Ada,\n\
    \   are well suited to this style of implementation.  There should be no\n   particular\
    \ difficulty with using a conventional language such as C or\n   Pascal, however.\n"
- title: III. OBTAINING A COPY OF THE ASN.1 SPECIFICATION
  contents:
  - "III. OBTAINING A COPY OF THE ASN.1 SPECIFICATION\n   Copies of ISO Standard ASN.1\
    \ (Abstract Syntax Notation 1) are\n   available from the following source.  It\
    \ comes in two parts; both are\n   needed:\n       IS 8824 -- Specification (meaning,\
    \ notation)\n       IS 8825 -- Encoding Rules (representation)\n   They are available\
    \ from:\n       Omnicom Inc.\n       115 Park St, S.E.          (new address as\
    \ of March, 1987)\n       Vienna, VA  22180\n       (703) 281-1135\n"
