- title: __initial_text__
  contents:
  - '                        TP/IX: The Next Internet

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard.  Discussion and\n  \
    \ suggestions for improvement are requested.  Please refer to the\n   current\
    \ edition of the \"IAB Official Protocol Standards\" for the\n   standardization\
    \ state and status of this protocol.  Distribution of\n   this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   The first version of this memo, describing a possible next generation\n\
    \   of Internet protocols, was written by the present author in the\n   summer\
    \ and fall of 1989, and circulated informally, including to the\n   IESG, in December\
    \ 1989.  A further informal note on the addressing,\n   called \"Toasternet Part\
    \ II\", was circulated on the IETF mail list\n   during March of 1992.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.       Introduction . . . . . . . . . . . . . . . . .\
    \ . . . 3\n   1.1       Objectives  . . . . . . . . . . . . . . . . . . . . 5\n\
    \   1.2       Philosophy  . . . . . . . . . . . . . . . . . . . . 6\n   2.   \
    \    Internet numbers . . . . . . . . . . . . . . . . . . 6\n   2.1       Is 64\
    \ Bits Enough?  . . . . . . . . . . . . . . . . 6\n   2.2       Why version 7?\
    \  . . . . . . . . . . . . . . . . . . 7\n   2.3       The version 7 IP address\
    \  . . . . . . . . . . . . . 7\n   2.4       AD numbers  . . . . . . . . . . .\
    \ . . . . . . . . . 8\n   2.5       Mapping of version 4 numbers  . . . . . .\
    \ . . . . . 8\n   3.       IP: Internet datagram protocol . . . . . . . . . .\
    \ . 9\n   3.1       IP datagram header format . . . . . . . . . . . .  10\n  \
    \ 3.1.1       Version . . . . . . . . . . . . . . . . . . . .  10\n   3.1.2  \
    \     Header length . . . . . . . . . . . . . . . . .  10\n   3.1.3       Time\
    \ to live  . . . . . . . . . . . . . . . . .  10\n   3.1.4       Total datagram\
    \ length . . . . . . . . . . . . .  11\n   3.1.5       Forward route identifier\
    \  . . . . . . . . . . .  11\n   3.1.6       Destination . . . . . . . . . . .\
    \ . . . . . . .  11\n   3.1.7       Source  . . . . . . . . . . . . . . . . .\
    \ . . .  11\n   3.1.8       Protocol  . . . . . . . . . . . . . . . . . . .  11\n\
    \   3.1.9       Checksum  . . . . . . . . . . . . . . . . . . .  11\n   3.1.10\
    \      Options . . . . . . . . . . . . . . . . . . . .  11\n   3.2       Option\
    \ Format . . . . . . . . . . . . . . . . . .  12\n   3.2.1       Class (C) . .\
    \ . . . . . . . . . . . . . . . . .  12\n   3.2.2       Copy on fragmentation\
    \ (F) . . . . . . . . . . .  13\n   3.2.3       Type  . . . . . . . . . . . .\
    \ . . . . . . . . .  13\n   3.2.4       Length  . . . . . . . . . . . . . . .\
    \ . . . . .  13\n   3.2.5       Option data . . . . . . . . . . . . . . . . .\
    \ .  13\n   3.3       IP options  . . . . . . . . . . . . . . . . . . .  13\n\
    \   3.3.1       Null  . . . . . . . . . . . . . . . . . . . . .  13\n   3.3.2\
    \       Fragment  . . . . . . . . . . . . . . . . . . .  14\n   3.3.3       Last\
    \ Fragment . . . . . . . . . . . . . . . . .  14\n   3.3.4       Don't Fragment\
    \  . . . . . . . . . . . . . . . .  15\n   3.3.5       Don't Convert . . . . .\
    \ . . . . . . . . . . . .  15\n   3.4       Forward route identifier  . . . .\
    \ . . . . . . . .  15\n   3.4.1       Procedure description . . . . . . . . .\
    \ . . . .  15\n   3.4.2       Flows . . . . . . . . . . . . . . . . . . . . .\
    \  17\n   3.4.3       Mobile hosts  . . . . . . . . . . . . . . . . .  17\n  \
    \ 4.       TCP: Transport protocol  . . . . . . . . . . . . .  18\n   4.1    \
    \   TCP segment header format . . . . . . . . . . . .  18\n   4.1.1       Data\
    \ offset . . . . . . . . . . . . . . . . . .  19\n   4.1.2       MBZ . . . . .\
    \ . . . . . . . . . . . . . . . . .  19\n   4.1.3       Flags . . . . . . . .\
    \ . . . . . . . . . . . . .  19\n   4.1.4       Checksum  . . . . . . . . . .\
    \ . . . . . . . . .  19\n   4.1.5       Source port . . . . . . . . . . . . .\
    \ . . . . .  20\n   4.1.6       Destination port  . . . . . . . . . . . . . .\
    \ .  20\n   4.1.7       Sequence  . . . . . . . . . . . . . . . . . . .  20\n\
    \   4.1.8       Acknowledgement . . . . . . . . . . . . . . . .  20\n   4.1.9\
    \       Window  . . . . . . . . . . . . . . . . . . . .  20\n   4.1.10      Options\
    \ . . . . . . . . . . . . . . . . . . . .  20\n   4.2       Port numbers  . .\
    \ . . . . . . . . . . . . . . . .  20\n   4.3       TCP options . . . . . . .\
    \ . . . . . . . . . . . .  21\n   4.3.1       Option Format . . . . . . . . .\
    \ . . . . . . . .  21\n   4.3.2       Null  . . . . . . . . . . . . . . . . .\
    \ . . . .  21\n   4.3.3       Maximum Segment Size  . . . . . . . . . . . . .\
    \  21\n   4.3.4       Urgent Pointer  . . . . . . . . . . . . . . . .  21\n  \
    \ 4.3.5       32 Bit rollover . . . . . . . . . . . . . . . .  21\n   5.     \
    \  UDP: User Datagram protocol  . . . . . . . . . . .  22\n   5.1       UDP header\
    \ format . . . . . . . . . . . . . . . .  22\n   5.1.1       Data offset . . .\
    \ . . . . . . . . . . . . . . .  22\n   5.1.2       MBZ . . . . . . . . . . .\
    \ . . . . . . . . . . .  22\n   5.1.3       Checksum  . . . . . . . . . . . .\
    \ . . . . . . .  22\n   5.1.4       Source port . . . . . . . . . . . . . . .\
    \ . . .  22\n   5.1.5       Destination port  . . . . . . . . . . . . . . .  22\n\
    \   5.1.6       Options . . . . . . . . . . . . . . . . . . . .  23\n   6.   \
    \    ICMP . . . . . . . . . . . . . . . . . . . . . . .  23\n   6.1       ICMP\
    \ header format  . . . . . . . . . . . . . . .  23\n   6.2       Conversion failed\
    \ ICMP message  . . . . . . . . .  23\n   7.       Notes on the domain system\
    \ . . . . . . . . . . . .  25\n   7.1       A records . . . . . . . . . . . .\
    \ . . . . . . . .  25\n   7.2       PTR zone  . . . . . . . . . . . . . . . .\
    \ . . . .  25\n   8.       Conversion between version 4 and version 7 . . . .\
    \  25\n   8.1       Version 4 IP address extension option . . . . . .  26\n  \
    \ 8.1.1     Option format . . . . . . . . . . . . . . . . . .  26\n   8.2    \
    \  Fragmented datagrams . . . . . . . . . . . . . . .  26\n   8.3      Where does\
    \ the conversion happen?  . . . . . . . .  27\n   8.4      Hybrid IPv4 systems\
    \  . . . . . . . . . . . . . . .  28\n   8.5      Maximum segment size in TCP\
    \  . . . . . . . . . . .  28\n   8.6      Forwarding and redirects . . . . . .\
    \ . . . . . . .  28\n   8.7      Design considerations  . . . . . . . . . . .\
    \ . . .  28\n   8.8      Conversion from IPv4 to IPv7 . . . . . . . . . . .  29\n\
    \   8.9      Conversion from IPv7 to IPv4 . . . . . . . . . . .  30\n   8.10 \
    \    Conversion from TCPv4 to TCPv7 . . . . . . . . . .  31\n   8.11     Conversion\
    \ from TCPv7 to TCPv4 . . . . . . . . . .  32\n   8.12     ICMP conversion  .\
    \ . . . . . . . . . . . . . . . .  33\n   9.       Postscript . . . . . . . .\
    \ . . . . . . . . . . . .  33\n   10.      References . . . . . . . . . . . .\
    \ . . . . . . . .  34\n   11.      Security Considerations  . . . . . . . . .\
    \ . . . .  35\n   12.      Author's Address . . . . . . . . . . . . . . . . .\
    \  35\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This memo presents the specification for version 7 of the\
    \ Internet\n   Protocol, as well as version 7 of the TCP and the user datagram\n\
    \   protocol.  Version 7 has been designed to address several major\n   problems\
    \ that have arisen as version 4 has evolved and been deployed,\n   and to make\
    \ a major step forward in the datagram switching and\n   forwarding architecture\
    \ of the Internet.\n   The major problems are threefold.  First, the address space\
    \ of\n   version 4 is now seen to be too small.  While it was viewed as being\n\
    \   almost impossibly large when version 4 was designed, two things have\n   occurred\
    \ to create a problem.  The first is a success crisis:  the\n   internet protocols\
    \ have been more widely used and accepted than their\n   designers anticipated.\
    \  Also, technology has moved forward, putting\n   microprocessors into devices\
    \ not anticipated except as future dreams\n   a decade ago.\n   The second major\
    \ problem is a perceived routing explosion.  The\n   present routing architecture\
    \ of the internet calls for routing each\n   organization's network independently.\
    \  It is becoming increasingly\n   clear that this does not scale to a universal\
    \ internet.  While it is\n   possible to route several billion networks in a flat,\
    \ structureless\n   domain, it is not desireable.\n   There is also the political\
    \ administrative issue of assigning network\n   numbers to organizations.  The\
    \ version 4 administrative system calls\n   for organizations to request network\
    \ assignments from a single\n   authority.  While to some extent this has been\
    \ alleviated by\n   reserving blocks to delegated assignments, the address space\
    \ is not\n   large enough to do this in the necessary general case, with large\n\
    \   blocks allocated to (e.g.) national authority.\n   The third problem is the\
    \ increasing bandwidth of the networks and of\n   the applications possible on\
    \ the network.  The TCP, while having\n   proven useful on an unprecedented range\
    \ of network speeds, is now the\n   limiting factor at the highest speeds, due\
    \ to restrictions of window\n   size, sequence-space, and port numbers.  These\
    \ limitations can all be\n   addressed by increasing the sizes of the relevant\
    \ fields.  See\n   [RFC1323].\n   There is also an opportunity to move the technology\
    \ forward, and take\n   advantage of a combination of the best features of the\
    \ hop-by-hop\n   connectionless forwarding of version 4 (and CLNP) as well as\
    \ the\n   pre-established paths of version 5 (and, e.g., the OSI CONS).\n   Internet\
    \ Version 7 includes four major areas of improvement, while at\n   the same time\
    \ retaining interoperation with version 4 with a small\n   amount of conversion\
    \ knowledge imposed on version 7 hosts and\n   routers.\n      o  It increases\
    \ the address fields to 64 bits, with sufficient\n         space for visible future\
    \ expansion of the internet.\n      o  It adds a numbering layer for administrations,\
    \ above the\n         organization or network layer, as well as providing more\n\
    \         space for subnetting within organizations.\n      o  It increases the\
    \ range of speeds and network path delays over\n         which the TCP will operate\
    \ satisfactorily, as well as the\n         number of transactions in bounded time\
    \ that can be served by\n         a host.\n      o  Finally, it provides a forward\
    \ route identifier in each\n         datagram, to support extremely fast path,\
    \ circuit, or\n         flow-based forwarding, or any desired combination, while\n\
    \         preserving hop-by-hop connectivity.\n   The result is not just a movement\
    \ sideways, deploying a new network\n   layer protocol to patch current problems.\
    \  It is a significant step\n   forward for network layer technology,\n"
- title: 1.1  Objectives
  contents:
  - "1.1  Objectives\n   The following are some of the objectives of the design.\n\
    \  o  Use what has been learned from the IP version 4 protocol, fixing\n     things\
    \ that are troublesome, and not fixing that which is not\n     broken.\n  o  Retain\
    \ the essential \"look and feel\" of the Internet protocol\n     suite.  It has\
    \ been very successful, and one doesn't argue with\n     success.\n  o  Not introduce\
    \ concepts that the Internet has shown do not belong\n     in the protocol definition.\
    \  Best example:  we do not want to add\n     any kind of routing information\
    \ into the addressing, other than\n     the administrative hierarchy that has\
    \ sometimes proved useful.\n     Note that the one feature in version 4 addressing\
    \ (the class\n     system) designed to aid routing is now the most serious single\n\
    \     problem.\n  o  Allow current hosts to interoperate, if not universally,\
    \ at least\n     within an organization or larger area for the indefinite future.\n\
    \     There will be version 4 hosts for 10-15 years into the future,\n     the\
    \ Internet must remain on good terms with them.\n  o  Likewise, we must not impose\
    \ the new version, telling sites they\n     must convert to stay connected.  People\
    \ resist imposed solutions.\n     It must not be marketed as something different\
    \ from IPv4; the\n     differences must be down-played at every opportunity.\n\
    \  o  The design must allow individual hosts and routers to be upgraded\n    \
    \ effectively at random, with no transition plan constraints.\n  o  The design\
    \ must not require renumbering the Internet.  The\n     administrative work already\
    \ accomplished is immense, if it is to\n     be done again it will be in assigning\
    \ NSAPs.\n  o  It must allow IPv4 hosts to interoperate without any reduction\
    \ in\n     function, without any modification to their software or\n     configuration.\
    \  (Universal connectivity will be lost by IPv4\n     hosts, but they must be\
    \ able to continue operating within their\n     organization at least.)\n  o \
    \ It must permit network layer state-free translation of datagrams\n     between\
    \ IPv4 and IPv7; this is important to the previous point,\n     and essential\
    \ to early testing and transitional deployment.\n  o  It must be a competent alternative\
    \ to CLNP.\n  o  It must not involve changing the semantics of the network layer\n\
    \     service in any way that invalidates the huge amount of work that\n     has\
    \ gone into understanding how TCP (for example) functions in\n     the net, and\
    \ the implementation of that understanding.\n  o  It must be defined Real Soon;\
    \ the window of opportunity is almost\n     closed.  It will take vendors 3 years\
    \ to deploy from the time the\n     standard is rock-solid concrete.\n   I believe\
    \ all of these are accomplishable in a consistent, well-\n   engineered solution,\
    \ and all are essential to the survival of the\n   Internet.\n"
- title: 1.2  Philosophy
  contents:
  - "1.2  Philosophy\n   Protocols should become simpler as they evolve.\n"
- title: 2.  Internet numbers
  contents:
  - "2.  Internet numbers\n   The version 4 numbering system has proven to be very\
    \ flexible,\n   (mostly) expandable, and simple.  In short:  it works.  There\
    \ are two\n   problems, neither serious when this specification was first developed\n\
    \   in 1988 and 1989, but have as expected become more serious:\n      o  The\
    \ division into network, and then subnet, is insufficient.\n         Almost all\
    \ sites need a network assignment large enough to\n         subnet.  At the top\
    \ of the hierarchy, there is a need to\n         assign administrative domains.\n\
    \      o  As bit-packing is done to accomplish the desired network\n         structure,\
    \ the 32 bit limit causes more and more aggravation.\n"
- title: 2.1  Is 64 Bits Enough?
  contents:
  - "2.1  Is 64 Bits Enough?\n   Consider:  (thought experiment) 32 bits presently\
    \ numbers \"all\" of\n   the computers in the world, and another 32 bits could\
    \ be used to\n   number all of the bytes of on-line storage on each computer.\
    \  (Most\n   have a lot less than 4 gigabytes on-line, the ones that have more\n\
    \   could be notionally assigned more than one address.)\n   So: 64 bits is enough\
    \ to number every byte of online storage in\n   existence today, in a hierarchical\
    \ structured numbering plan.\n   Another way of looking at 64 bits:  it is more\
    \ than 2 billion\n   addresses for each person on the planet.  Even if I have\n\
    \   microprocessors in my shirt buttons I'm not going to have that many.\n   32\
    \ bits, on the other hand, was never going to be sufficient:  there\n   are more\
    \ than 2^32 people.\n"
- title: 2.2  Why version 7?
  contents:
  - "2.2  Why version 7?\n   It was clearly recognized at the start of this project\
    \ in 1988 that\n   making the address 64 bits implies a new IP header format,\
    \ which was\n   called either \"TP/IX\" or \"IP version 7\"; there wasn't anything\
    \ magic\n   about the number 7, I made it up.  Version 4 is the familiar current\n\
    \   version of IP.  Version 5 is the experimental ST (Stream) protocol.\n   ST-II,\
    \ a newer version of ST, uses the same version number, something\n   I was not\
    \ aware of until recently; I suspected it might have been\n   allocated 6.  Besides,\
    \ I liked 7.\n   Apparently (as reported by Bob Braden) the IAB followed much\
    \ the same\n   logic, and may have had the idea planted by the mention of version\
    \ 7\n   in the \"Toasternet Part II\" memo.  The IAB in June 1992 floated a\n\
    \   proposal that CLNP, or a CLNP-based design, be Internet Version 7.\n   (And\
    \ promptly got themselves toasted.) However, close inspection of\n   the bits\
    \ shows that CLNP is clearly version 8.\n"
- title: 2.3  The version 7 IP address
  contents:
  - "2.3  The version 7 IP address\n   The Version 7 IP 64 bit address looks like:\n\
    \    +-------+-------+-------+-------+-------+-------+-------+-------+\n    |\
    \      Admin Domain     |        Network        |     Host      |\n    +-------+-------+-------+-------+-------+-------+-------+-------+\n\
    \   Note:  the boundary between \"network\" and \"host\" is no more fixed\n  \
    \ than it is today; each (sub)network will have its own mask.  Just as\n   the\
    \ mask today can be anywhere from FF00 0000 (8/24) to FFFF FFFC\n   (30/2), the\
    \ mask for the 64 bit address can reasonably be FFFF FF00\n   0000 0000 (24/40)\
    \ to FFFF FFFF FFFF FFFC (62/2).\n   The AD (Administrative Domain), identifies\
    \ an administration which\n   may be a service provider, a national administration,\
    \ or a large\n   multi-organization (e.g.  a government).  The idea is that there\n\
    \   should not be more than a few hundred of these at first, and\n   eventually\
    \ thousands or tens of thousands at most.  (But note that we\n   do not introduce\
    \ a hard limit of 2^16 here; this estimate may be off\n   by a few orders of magnitude.)\
    \ Since only 1/4th of the address space\n   is initially used (first two bits\
    \ are 01), the remainder can then be\n   allocated in the future with more information\
    \ available.\n   Most individual organizations would not be ADs.  In the short\
    \ term,\n   ADs are known to the \"core routing\"; it pays to keep the number\n\
    \   smallish, a few thousand given current routing technology.  In the\n   long\
    \ term, this is not necessary.  Big administrations (i.e., with\n   tens of millions\
    \ of networks) get small blocks where needed, or\n   additional single AD numbers\
    \ when needed.\n   While the AD may be used for last resort routing (with a 24/40\
    \ mask),\n   it is primarily only an administrative device.  Most routing will\
    \ be\n   done on the entire 48 bit AD+network number, or sub and super-sets of\n\
    \   those numbers.  (I.e., masks between about 32/32 and 56/8.)\n   Some ADs (e.g.,\
    \ NSF) may make permanent assignments; others (such as\n   a telephone company\
    \ defining a network number for each subscriber\n   line) may tie the assignment\
    \ to such a subscription.  But in no case\n   does this require traffic to be\
    \ routed via the AD.\n"
- title: 2.4  AD numbers
  contents:
  - "2.4  AD numbers\n   AD numbers are allocated out of the same numbering space\
    \ as network\n   numbers.  This means that a version 4 address can be distinguished\n\
    \   from the first 32 bits of a version 7 address.  This is useful to\n   help\
    \ prevent the inadvertent use of the first half of the longer\n   address by a\
    \ version 4 host.\n   There is a non-trivial amount of software that assumes that\
    \ an \"int\"\n   is the same size and shape as an IP address, and does things\
    \ like\n   \"ipaddr = *(int *)ptr\".  This usage has always been incorrect, but\n\
    \   does occur with disturbing frequency.  As IPv7 8 byte addresses\n   appear\
    \ in the application layers, this software will find those\n   addresses unreachable;\
    \ this is preferable to interacting with a\n   random host.\n   One possible method\
    \ would be to allocate ADs in the range 96.0.0 to\n   192.255.255, using the top\
    \ 1/4 of the version 4 class A space.  It is\n   probably best to allocate the\
    \ first component downwards from 192, so\n   that the boundary between class A\
    \ and AD can be moved if desired\n   later.  This initial allocation provides\
    \ for 2031616 ADs, many more\n   than there should be even in full deployment.\n\
    \   Eventually, both AD and network will use the full 24 bit space\n   available\
    \ to them.  Knowledge of the AD range should not be coded\n   into software. \
    \ If it was coded in, that software would break when\n   the entire 24 bit space\
    \ is used for ADs.  (This lesson should have\n   been learned from CIDR.)\n"
- title: 2.5  Mapping of version 4 numbers
  contents:
  - "2.5  Mapping of version 4 numbers\n   Initially, all existing Internet numbers\
    \ are defined as belonging to\n   the NSF/Internet AD, number 192.0.0.\n   The\
    \ mapping from/to version 4 IP addresses:\n    +-------+-------+-------+-------+-------+-------+-------+-------+\n\
    \    |      Admin Domain     |        Network        |     Host      |\n    +-------+-------+-------+-------+-------+-------+-------+-------+\n\
    \     [  fixed at A0 00 00  ] [ 1st 24 bits of V4 IP]   [1]   [last 8]\n   So,\
    \ for example, 192.42.95.15 (V4) becomes 192.0.0.192.42.95.1.15.\n   And the \"\
    standard\" loopback interface address becomes\n   192.0.0.127.0.0.1.1 (I can see\
    \ explaining that in 2015 to someone\n   born in 1995.)\n   The present protocol\
    \ multicast (192.0.0.224.x.y.1.z) and loopback\n   addresses are permanently allocated\
    \ in the NSF AD.\n"
- title: '3.  IP:  Internet datagram protocol'
  contents:
  - "3.  IP:  Internet datagram protocol\n   The Internet datagram protocol is revised\
    \ to expand some fields (most\n   notably the addresses), while removing and relegating\
    \ to options all\n   fields not universally useful (imperative) in every datagram\
    \ in every\n   environment.\n   This results in some simplification, a length\
    \ less than twice the\n   size of IPv4 even though most fields are doubled in\
    \ size, and an\n   expanded space for options.\n   There is also a change in the\
    \ option philosophy from IPv4:  it\n   specified that implementation of options\
    \ was not optional, what was\n   optional was the existence of options in any\
    \ given datagram.  This is\n   changed in IPv7:  no option need be implemented\
    \ to be fully\n   conformant.  However, implementations must understand the option\n\
    \   classes; and a future Host Requirements specification for hosts and\n   routers\
    \ used in the \"connected Internet\" may require some options in\n   its profile,\
    \ e.g., Fragment would probably be required.\n   Digression:  In IPv4, options\
    \ are often \"considered harmful\".  It is\n   the opinion of the present author\
    \ that this is because they are\n   rarely needed, and not designed to be processed\
    \ rapidly on most\n   architectures.  This leads to little or no attempt to improve\n\
    \   performance in implementations, while at the same time enormous\n   effort\
    \ is dedicated to optimization of the no-option case.  IPv7 is\n   expected to\
    \ be different on both counts.\n   Fields are always aligned on their own size;\
    \ the 64 bit fields on 64\n   bit intervals from the start of the datagram.\n\
    \   Options are all 32 bit aligned, and the null option can be used to\n   push\
    \ a subsequent option (or the transport layer header) into 64 bit\n   or 64+32\
    \ off-phase alignment as desired.\n"
- title: 3.1  IP datagram header format
  contents:
  - "3.1  IP datagram header format\n     0                   1                  \
    \ 2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |version|     header length     |        time to live           |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |        total datagram length                                  |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    +\
    \        forward route identifier                               +\n    |     \
    \                                                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    +\
    \        destination address                                    +\n    |     \
    \                                                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    +\
    \        source address                                         +\n    |     \
    \                                                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |        protocol               |           checksum            |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |        options                                                |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   A description of each field follows.\n"
- title: 3.1.1  Version
  contents:
  - "3.1.1  Version\n   This document describes version 7 of the protocol.\n"
- title: 3.1.2  Header length
  contents:
  - "3.1.2  Header length\n   The header length is a 12 bit count of the number of\
    \ 32 bit words in\n   the IPv7 header.  This allows a header to be (theoretically\
    \ at least)\n   up to 16380 bytes in length.\n"
- title: 3.1.3  Time to live
  contents:
  - "3.1.3  Time to live\n   The time to live is a 16 bit count, nominally in 1/16\
    \ seconds.  Each\n   hop is required to decrement TTL by at least one.\n   This\
    \ definition should allow continuation of the useful (even though\n   not entirely\
    \ valid) interpretation of TTL as a hop count, while we\n   move to faster networks\
    \ and routers.  (The most familiar use is by\n   \"traceroute\", which really\
    \ ought to be directly implemented by one or\n   more ICMP messages.)\n   The\
    \ scale factor converts the usual version 4 default TTL into a\n   larger number\
    \ of hops.  This is desireable because the forward route\n   architecture of version\
    \ 7 enables the construction of simpler, faster\n   switches, and this may cause\
    \ the network diameter to increase.\n"
- title: 3.1.4  Total datagram length
  contents:
  - "3.1.4  Total datagram length\n   The 32 bit length of the entire datagram in\
    \ octets.  A datagram can\n   therefore be up to 4294967295 bytes in overall length.\
    \  Particular\n   networks will normally impose lower limits.\n"
- title: 3.1.5  Forward route identifier
  contents:
  - "3.1.5  Forward route identifier\n   The identifier from the routing protocol\
    \ to be used by the next hop\n   router to find its next hop.  (A more complete\
    \ description is given\n   below.)\n"
- title: 3.1.6  Destination
  contents:
  - "3.1.6  Destination\n   The 64 bit IPv7 destination address.\n"
- title: 3.1.7  Source
  contents:
  - "3.1.7  Source\n   The 64 bit IPv7 source address.\n"
- title: 3.1.8  Protocol
  contents:
  - "3.1.8  Protocol\n   The transport layer protocol, e.g., TCP is 6.  The present\
    \ code space\n   for this layer of demultiplexing is about half full.  Expanding\
    \ it to\n   16 bits, allowing 65535 registered \"transport\" layers seems prudent.\n"
- title: 3.1.9  Checksum
  contents:
  - "3.1.9  Checksum\n   The checksum is a 16 bit checksum of the entire IP header,\
    \ using the\n   familiar algorithm used in IPv4.\n"
- title: 3.1.10  Options
  contents:
  - "3.1.10  Options\n   Options may follow.  They are variable length, and always\
    \ 32 bit\n   aligned, as discussed previously.\n"
- title: 3.2  Option Format
  contents:
  - "3.2  Option Format\n   Each option begins with a 32 bit header:\n     0     \
    \              1                   2                   3\n     0 1 2 3 4 5 6 7\
    \ 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    | C |F|    type                 |   length                      |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |        option data                 ...          |   padding   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   A description of each field:\n"
- title: 3.2.1  Class (C)
  contents:
  - "3.2.1  Class (C)\n   This field tells implementations what to do with datagrams\
    \ containing\n   options they do not understand.  No implementation is required\
    \ to\n   implement (i.e., understand) any given option by the TCP/IP\n   specification\
    \ itself.\n   Classes:\n       0        use or forward and include this option\
    \ unmodified\n       1        use this datagram, but do not forward the datagram\n\
    \       2        discard, or forward and include this option unmodified\n    \
    \   3        discard this datagram\n   A host receiving a datagram addressed to\
    \ itself will use it if there\n   are no unknown options of class 2 or 3.  A router\
    \ receiving a\n   datagram not addressed to it will forward the datagram if and\
    \ only if\n   there are no unknown options of class 1 or 3.  (The astute reader\n\
    \   will note that the bits can also be seen as having individual\n   interpretations,\
    \ one allowing use even if unknown, one allowing\n   forwarding if unknown.)\n\
    \   Note that classes 0 and 2 are imperative:  if the datagram is\n   forwarded,\
    \ the unknown option must be included.\n   Class and type are entirely orthogonal,\
    \ different implementations\n   might use different classes for the same option,\
    \ except where\n   restricted by the option definition.\n   Also note that for\
    \ options that are known (implemented by) the host\n   or router, the class has\
    \ no meaning; the option definition totally\n   determines the behavior.  (Although\
    \ it should be noted that the\n   option might explicitly define a class dependent\
    \ behavior.)\n"
- title: 3.2.2  Copy on fragmentation (F)
  contents:
  - "3.2.2  Copy on fragmentation (F)\n   If the F bit is set, this option must be\
    \ copied into all fragments\n   when a datagram is fragmented.  If the F bit is\
    \ reset (zero), the\n   option must only be copied into the first (zero-offset)\
    \ fragment.\n"
- title: 3.2.3  Type
  contents:
  - "3.2.3  Type\n   The type field identifies the particular option, types being\n\
    \   registered as well known values in the internet.  A few of the\n   options\
    \ with their types are described below.\n"
- title: 3.2.4  Length
  contents:
  - "3.2.4  Length\n   Length of the option data, in bytes.\n"
- title: 3.2.5  Option data
  contents:
  - "3.2.5  Option data\n   Variable length specified by the length field, plus 0-3\
    \ bytes of\n   zeros to pad to a 32 bit boundary.  Fields within the option data\n\
    \   that are 64 bits long are normally placed on the assumption that the\n   option\
    \ header is off-phase aligned, the usual case when the option is\n   the only\
    \ one present, and immediately follows the IP header.\n"
- title: 3.3  IP options
  contents:
  - "3.3  IP options\n   The following sections describe the options defined to emulate\
    \ IPv4\n   features, or necessary in the basic structure of the protocol.\n"
- title: 3.3.1  Null
  contents:
  - "3.3.1  Null\n   The null option, type 0, provides for a space filler in the option\n\
    \   area.  The data may be of any size, including 0 bytes (perhaps the\n   most\
    \ useful case.)\n   It may be used to change alignment of the following options\
    \ or to\n   replace an option being deleted, by setting type to 0 and class to\
    \ 0,\n   leaving the length and content of the data unmodified.  (Note that\n\
    \   this implies that options must not contain \"secret\" data, relying on\n \
    \  class 3 to prevent the data from leaving the domain of routers that\n   understand\
    \ the option.)\n   Null is normally class 0, and need not be implemented to serve\
    \ its\n   function.\n"
- title: 3.3.2  Fragment
  contents:
  - "3.3.2  Fragment\n   Fragment (type 1) indicates that the datagram is part of\
    \ a complete\n   IP datagram.  It is always class 2.\n   The data consists of\
    \ (one of) the 64 bit IP address(es) of the router\n   doing the fragmentation,\
    \ a 64 bit datagram ID generated by that\n   router, and a 32 bit fragment offset.\
    \  The IDs should be generated so\n   as to be very likely unique over a period\
    \ of time larger than the TCP\n   MSL (maximum segment lifetime).  (The TCP ISN\
    \ (initial sequence\n   number) generator might be used to initialize the ID generator\
    \ in a\n   router.)\n     0                   1                   2          \
    \         3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9\
    \ 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    | C |F|    type                 |   length                      |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    +\
    \          fragmenting router IP address                        +\n    |     \
    \                                                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    +\
    \          datagram ID                                          +\n    |     \
    \                                                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |          offset                                               |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   If a datagram must be refragmented, the original 128 bit address+ID\n   is\
    \ preserved, so that the datagram can be reassembled from any\n   sufficient set\
    \ of the resulting fragments.  The 64 bits fields are\n   positioned so that they\
    \ are aligned in the usual case of the fragment\n   option following the IP header.\n\
    \   A router implementing Fragment (doing fragmentation) must recognize\n   the\
    \ Don't Fragment option.\n"
- title: 3.3.3  Last Fragment
  contents:
  - "3.3.3  Last Fragment\n   Last Fragment (type 2) has the same format as Fragment,\
    \ but implies\n   that this datagram is the last fragment needed to reassemble\
    \ the\n   original datagram.\n   Note that an implementation can reasonably add\
    \ arriving datagrams\n   with Fragment to a cache, and then attempt a reassembly\
    \ when a\n   datagram with Last Fragment arrives (and the the total length is\n\
    \   known); this will work well when datagrams are not reordered in the\n   network.\n"
- title: 3.3.4  Don't Fragment
  contents:
  - "3.3.4  Don't Fragment\n   This option (type 3, class 0) indicates that the datagram\
    \ may not be\n   fragmented.  If it can not be forwarded without fragmentation,\
    \ it is\n   discarded, and the appropriate ICMP message sent.  (Unless, of\n \
    \  course, the datagram is an ICMP message.) There is no data present.\n"
- title: 3.3.5  Don't Convert
  contents:
  - "3.3.5  Don't Convert\n   The Don't Convert option prohibits conversion from IPv7\
    \ to IPv4\n   protocol, requiring instead that the datagram be discarded and an\n\
    \   ICMP message sent (conversion failed/don't convert set).  It is type\n   4,\
    \ usually class 0, and must be implemented by any router\n   implementing conversion.\
    \  A host is under no such constraint; like\n   any protocol specification, only\
    \ the \"bits on the wire\" can be\n   specified, the host receiving the datagram\
    \ may convert it as part of\n   its procedure.  There is no data present in this\
    \ option.\n"
- title: 3.4  Forward route identifier
  contents:
  - "3.4  Forward route identifier\n   Each IP datagram carries a 64 bit field, called\
    \ \"forward route\n   identifier\", that is updated (if the information is available)\
    \ at\n   each hop.  This field's value is derived from the routing protocol\n\
    \   (e.g., RAP [RFC1476]).  It is used to expedite routing decisions by\n   preserving\
    \ knowledge where possible between consecutive routers.  It\n   can also be used\
    \ to make datagrams stay within reserved flows and\n   mobile-host tunnels where\
    \ required.\n"
- title: 3.4.1  Procedure description
  contents:
  - "3.4.1  Procedure description\n   Consider 3 routers, A, B, and C.  Traffic is\
    \ passing through them,\n   between two other hosts (or networks), X and Y, packets\
    \ are going\n   XABCY and YCBAX.  Consider only one direction:  routing info flowing\n\
    \   from C to A, to provide a route from A to C.  The same thing will be\n   happening\
    \ in the other direction.\n   An explanation of the notation:\n     R(r,d,i,h)\
    \    A route that means: \"from router r, to go toward\n                   final\
    \ destination d, replace the forward route\n                   identifier in the\
    \ packet with i, and take next\n                   hop h.\"\n     Ri(r,d)    \
    \   An opaque (outside of router r) identifier, that can\n                   be\
    \ used by r to find R(r,d,...).\n     Flowi(r,rt)   An opaque (outside of router\
    \ r) identifier, that\n                   router r can use to find a flow or tunnel\
    \ with which\n                   the datagram is associated, and from that the\
    \ route\n                   rt on which the flow or tunnel is built, as well as\n\
    \                   the Flowi() for the subsequent hop.\n     Ri(Dgram)     The\
    \ forward route identifier in a datagram.\n   Router C announces a route R(C,Y,0,Y)\
    \ to router B.  It includes in it\n   an identifier Ri(C,Y) internal to C, that\
    \ will allow C to find the\n   route rapidly.  (A table index, or an actual memory\
    \ address.)\n   Router B creates a route R(B,Y,Ri(C,Y),C) via router C, it announces\n\
    \   it to A, including an identifier Ri(B,Y), internal to B, and used by\n   A\
    \ as an opaque object.\n   Router A creates a route R(A,Y,Ri(B,Y),B) via router\
    \ B.  It has no\n   one to announce it to.\n   Now:  X originates a datagram addressed\
    \ to Y.  It has no routing\n   information, and sets Ri(Dgram) to zero.  It forwards\
    \ the datagram to\n   router A (X's default gateway).\n   A finds no valid Ri(Dgram),\
    \ and looks up the destination (Y) in its\n   routing tables.  It finds R(A,Y,Ri(B,Y),B),\
    \ sets Ri(Dgram) <-\n   Ri(B,Y), and forwards the datagram to B.\n   Router B\
    \ looks at Ri(Dgram) which directly identifies the next hop\n   route R(B,Ri(C,Y),C),\
    \ sets Ri(Dgram) <- Ri(C,Y) and forwards it to\n   router C.\n   Router C looks\
    \ at Ri(Dgram) which directly locates R(C,0,Y), sets\n   Ri(Dgram) <- 0 and forwards\
    \ to Y.\n   Y recognizes its own address in Dest(Dgram), ignores Ri(Dgram).\n\
    \   Of course, the routers will validate the Ri's received, particularily\n  \
    \ if they are memory addresses (e.g., M(a) < Ri < M(b), Ri mod N == 0),\n   and\
    \ probably check that the route in fact describes the destination\n   of the datagram.\
    \  If the Ri is invalid, the router must use the\n   ordinary method of finding\
    \ a route (i.e., what it would have done if\n   Ri was 0), and silently ignore\
    \ the invalid Ri.\n   When a route has been aggregated at some router, implicitly\
    \ or\n   explicitly, it will find that the incoming Ri(Dgram) at most can\n  \
    \ identify the aggregation, and it must make a decision; the forwarded\n   datagram\
    \ then contains the Ri for the specific route.  (Note this may\n   happen well\
    \ upstream of the point at which the routes actually\n   diverge.)\n   This allows\
    \ all cooperating routers to make immediate forwarding\n   decisions, without\
    \ any searching of tables or caches once the\n   datagram has entered the routing\
    \ domain.  If the host participates in\n   the routing, at least to the extent\
    \ of acquiring the initial Ri\n   required from the first router, then only routers\
    \ that have done\n   aggregations need make decisions.  (If the routing changes\
    \ with\n   datagrams in flight, some router will be required to make a decision\n\
    \   to re-rail each datagram.)\n"
- title: 3.4.2  Flows
  contents:
  - "3.4.2  Flows\n   If a \"flow\" is to be set up, the identifiers are replaced\
    \ by\n   Flowi(router,route), where each router's structure for the flow\n   contains\
    \ a pointer to the route on which the flow is built.\n   Datagrams can drop out\
    \ of the flow at some point, and can be inserted\n   either by the originating\
    \ host or by a cooperating router near the\n   originator.  Since the forward\
    \ route identifier field is opaque to\n   the sending router, and implicitly meaningful\
    \ only to the next hop\n   router, use for flows (or similar optimizations) need\
    \ not be\n   otherwise defined by the protocol.  (One presumes that a router\n\
    \   issuing both Ri's and Flowi's will take care to make sure that it can\n  \
    \ distinguish them by some private method.)\n   If a flow has been set up by a\
    \ restricted target RAP route\n   announcement, it is no different from a route\
    \ in the implementation.\n   If this announcement originates from the host itself,\
    \ the Ri in\n   incoming datagrams can be used to determine whether they followed\
    \ the\n   flow, or to optimize delivery of the datagrams to the next layer\n \
    \  protocol.\n"
- title: 3.4.3  Mobile hosts
  contents:
  - "3.4.3  Mobile hosts\n   First, a definition:  A \"mobile host\" is a host that\
    \ can move around,\n   connecting via different networks at different times, while\n\
    \   maintaining open TCP connections.  It is distinguished from a\n   \"portable\
    \ host\", which is simply a host that can appear in various\n   places in the\
    \ net, without continuity.  A portable host can be\n   implemented by assigning\
    \ a new address for each location (more or\n   less automatically), and arranging\
    \ to update the domain system.\n   Supporting truly mobile hosts is the more interesting\
    \ problem.\n   To implement mobile host support in a general way, either some\
    \ layer\n   of the protocol suite must provide network-wide routing, or the\n\
    \   datagrams must be tunnelled from the \"home\" network of the host to\n   its\
    \ present location.  In the real network, some combination of these\n   is probable:\
    \  most of the net will forward datagrams toward the home\n   network, and then\
    \ the datagrams will follow a specific host route to\n   the mobile host.\n  \
    \ The requirement on the routing system is that it must be able to\n   propagate\
    \ a host route at least to the home network; any other\n   distribution is useful\
    \ optimization.  When a host route is propagated\n   by RAP as a targeted route,\
    \ and the routers use the resulting Ri's,\n   the datagram follows an effective\
    \ tunnel to the mobile host.  (Not a\n   real tunnel, in the strict sense; the\
    \ datagrams are following an\n   actual route at the network protocol layer.)\n\
    \   As explained in RAP [RFC14XX-RAP], a targeted route can be issued\n   when\
    \ desired; in particular, it can be triggered by the establishment\n   of a TCP\
    \ connection or by the arrival of datagrams that do not carry\n   an Ri indicating\
    \ that they have followed a (non-tunnel) route.\n"
- title: '4.  TCP:  Transport protocol'
  contents:
  - "4.  TCP:  Transport protocol\n   Internet version 7 expands the sizes of the\
    \ sequence and\n   acknowledgement fields, the window, and the port numbers. \
    \ This is to\n   remove limitations in version 4 that begin to restrict throughput\
    \ at\n   (for example) the bandwidth of FDDI and round trip delay of more than\n\
    \   60 milliseconds.  At gigabit speeds and delays typical of\n   international\
    \ links, the version 4 TCP would be a serious limitation.\n   See [RFC1323].\n\
    \   The port numbers are also expanded.  This alleviates the problem of\n   going\
    \ through the entire port number range with a rapid sequence of\n   transactions\
    \ in less than the lifetime of datagrams in the network.\n"
- title: 4.1  TCP segment header format
  contents:
  - "4.1  TCP segment header format\n   The 64 bit fields (sequence and acknowledgement)\
    \ in the TCP header\n   are off-phase aligned, in anticipation of the usual case\
    \ of the TCP\n   header following the 9 32-bit word IP header.  If IP options\
    \ add up\n   to an odd number of 32 bit words, a null option may be added to push\n\
    \   the transport header to off-phase alignment.\n     0                   1 \
    \                  2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |  data offset  | MBZ |A|P|R|S|F|           checksum            |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |        source port                                            |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |        destination port                                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    +\
    \        sequence number                                        +\n    |     \
    \                                                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |                                                               |\n    +\
    \        acknowledgement number                                 +\n    |     \
    \                                                          |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |        window                                                 |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |        options                          ...                   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   A description of each field:\n"
- title: 4.1.1  Data offset
  contents:
  - "4.1.1  Data offset\n   An 8 bit count of the number of 32 bit words in the TCP\
    \ header,\n   including any options.\n"
- title: 4.1.2  MBZ
  contents:
  - "4.1.2  MBZ\n   Reserved bits, must be zero, and must be ignored.\n"
- title: 4.1.3  Flags
  contents:
  - "4.1.3  Flags\n   These are the protocol state flags, use exactly as in TCPv4,\
    \ except\n   that there is no urgent data flag.\n"
- title: 4.1.4  Checksum
  contents:
  - "4.1.4  Checksum\n   This is a 16 bit checksum of the segment.  The pseudo-header\
    \ used in\n   the checksum consists of the destination address, the source address,\n\
    \   the protocol field (constant 6 for TCP), and the 32 bit length of the\n  \
    \ TCP segment.\n"
- title: 4.1.5  Source port
  contents:
  - "4.1.5  Source port\n   The source port number, a 32 bit identifier.  See the\
    \ section on port\n   numbers below.\n"
- title: 4.1.6  Destination port.
  contents:
  - "4.1.6  Destination port.\n   The 32 bit destination port number.\n"
- title: 4.1.7  Sequence
  contents:
  - "4.1.7  Sequence\n   A 64 bit sequence number, the sequence number of the first\
    \ octet of\n   user data in the segment.\n   The ISN (Initial Sequence Number)\
    \ generator used in TCPv4 is used in\n   TCPv7, with the 32 bit value loaded into\
    \ both the high and low 32\n   bits of the TCPv7 sequence number.  This provides\
    \ reasonable behavior\n   when the 32 bit rollover option is used (see below)\
    \ for TCPv4\n   interoperation.  V7 hosts must implement the full 64 bit sequence\n\
    \   number rollover.\n"
- title: 4.1.8  Acknowledgement
  contents:
  - "4.1.8  Acknowledgement\n   The 64 bit acknowledgement number, acknowledging receipt\
    \ of octets up\n   to but not including the octet identified.  Valid if the A\
    \ flag is\n   set, if A is reset (0), this field should be zero, and must be\n\
    \   ignored.\n"
- title: 4.1.9  Window
  contents:
  - "4.1.9  Window\n   The 32 bit offered window.\n"
- title: 4.1.10  Options
  contents:
  - "4.1.10  Options\n   TCP options, some of which are documented below.\n"
- title: 4.2  Port numbers
  contents:
  - "4.2  Port numbers\n   Port numbers are divided into several ranges:  (all numbers\
    \ are\n   decimal)\n    0             reserved\n    1-32767       Internet registered\
    \ (\"well-known\") protocols\n    32768-98303   reserved, to allow TCPv7-TCPv4\
    \ conversion\n    98304 up      dynamic assignment\n   It must also be remembered\
    \ that hosts are free to dynamically assign\n   for active connections any port\
    \ not actually in use by that host:\n   hosts must not reject connections because\
    \ the \"client\" port is in the\n   registered range.\n"
- title: 4.3  TCP options
  contents:
  - '4.3  TCP options

    '
- title: 4.3.1  Option Format
  contents:
  - "4.3.1  Option Format\n   Each option begins with a 32 bit header:\n     0   \
    \                1                   2                   3\n     0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |        type                   |   length                      |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |        option data                 ...          |   padding   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: 4.3.2  Null
  contents:
  - "4.3.2  Null\n   The null option (type = 0), is to be ignored.\n"
- title: 4.3.3  Maximum Segment Size
  contents:
  - "4.3.3  Maximum Segment Size\n   Maximum segment size (type = 1) specifies the\
    \ largest segment that\n   the other TCP should send, in terms of the number of\
    \ data octets.\n   When sent on a SYN segment, it is mandatory; if sent on any\
    \ other\n   segment it is advisory.\n   Data is one 32 bit word specifying the\
    \ size in octets.\n"
- title: 4.3.4  Urgent Pointer
  contents:
  - "4.3.4  Urgent Pointer\n   The urgent pointer (type = 2) emulates the urgent field\
    \ in TCPv4.\n   Its presence is equivalent to the U flag being set.  The data\
    \ is a 64\n   bit sequence number identifying the last octet of urgent data. \
    \ (Not\n   an offset, as in v4.)\n"
- title: 4.3.5  32 Bit rollover
  contents:
  - "4.3.5  32 Bit rollover\n   The 32 bit rollover option (type = 3) indicates that\
    \ only the low\n   order 32 bits of the sequence and acknowledgement packets are\n\
    \   significant in the packet.\n   This is necessary because a converting internet\
    \ layer gateway has no\n   retained state, and cannot properly set the high order\
    \ bits.  This\n   option must be implemented by version 7 hosts that want to\n\
    \   interoperate with version 4 hosts.\n"
- title: '5.  UDP:  User Datagram protocol'
  contents:
  - "5.  UDP:  User Datagram protocol\n   The user datagram protocol is also expanded\
    \ to include larger port\n   numbers, for reasons similar to the TCP.\n"
- title: 5.1  UDP header format
  contents:
  - "5.1  UDP header format\n     0                   1                   2      \
    \             3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |  data offset  |     MBZ       |           checksum            |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |        source port                                            |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |        destination port                                       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |        options                          ...                   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   A description of each field:\n"
- title: 5.1.1  Data offset
  contents:
  - "5.1.1  Data offset\n   An 8 bit count of the number of 32 bit words in the UDP\
    \ header,\n   including any options.\n"
- title: 5.1.2  MBZ
  contents:
  - "5.1.2  MBZ\n   Reserved bits, must be zero, and must be ignored.\n"
- title: 5.1.3  Checksum
  contents:
  - "5.1.3  Checksum\n   This is a 16 bit checksum of the datagram.  The pseudo-header\
    \ used in\n   the checksum consists of the destination address, the source,\n\
    \   address, and the protocol field (constant 17 for UDP), and the 32 bit\n  \
    \ length of the user datagram.\n"
- title: 5.1.4  Source port
  contents:
  - "5.1.4  Source port\n   The source port number, a 32 bit identifier.  See the\
    \ section on TCP\n   port numbers above.\n"
- title: 5.1.5  Destination port.
  contents:
  - "5.1.5  Destination port.\n   The 32 bit destination port number.\n"
- title: 5.1.6  Options
  contents:
  - "5.1.6  Options\n   UDP options, none are presently defined.\n"
- title: 6.  ICMP
  contents:
  - "6.  ICMP\n   The ICMP protocol is very similar to ICMPv4, in some cases not\n\
    \   requiring any conversion.\n   The complication is that IP datagrams are nested\
    \ within ICMP\n   messages, and must be converted.  This is discussed later.\n"
- title: 6.1  ICMP header format
  contents:
  - "6.1  ICMP header format\n     0                   1                   2     \
    \              3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |     type      |     code      |           checksum            |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |        type-specific parameter                                |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |        type-specific data               ...                   |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   Type and code are well-known values, defined in [RFC792].  The codes\n   have\
    \ meaning only within a particular type, they are not orthogonal.\n   The next\
    \ 32 bit word is usually defined for the specific type,\n   sometimes it is unused.\n\
    \   For many types, the data consists of a nested IP datagram, usually\n   truncated,\
    \ which is a copy of the datagram causing the event being\n   reported.  In IPv4,\
    \ the nested datagram consists of the IP header,\n   and another 64 bits (at least)\
    \ of the original datagram.\n   For IPv7, the nested datagram must include the\
    \ IP header plus 96 bits\n   of the remaining datagram (thus including the port\
    \ numbers within TCP\n   and UDP), and should include the first 256 bytes of the\
    \ datagram.\n   I.e., in most cases where the original datagram was not large,\
    \ it\n   will return the entire datagram.\n"
- title: 6.2  Conversion failed ICMP message
  contents:
  - "6.2  Conversion failed ICMP message\n   The introduction of network layer conversion\
    \ requires a new message\n   type, to report conversion errors.  Note that an\
    \ invalid datagram\n   should result in the sending of some other ICMP message\
    \ (e.g.,\n   parameter problem) or the silent discarding of the datagram.  This\n\
    \   message is only sent when a valid datagram cannot be converted.\n   Note:\
    \  implementations are not expected to, and should not, check the\n   validity\
    \ of incoming datagrams just to accomplish this; it simply\n   means that an error\
    \ detected during conversion that is known to be an\n   actual error in the incoming\
    \ datagram should be reported as such, not\n   as a conversion failure.\n   Note\
    \ that the conversion failed ICMP message may be sent in either\n   the IPv4 or\
    \ IPv7 domain; it is a valid ICMP message type for IPv4.\n     0             \
    \      1                   2                   3\n     0 1 2 3 4 5 6 7 8 9 0 1\
    \ 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |     type      |     code      |           checksum            |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |        pointer to problem area                                |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |        copy of datagram that could not be converted ....      |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The type for Conversion Failed is 31.\n   The codes are:\n        0      \
    \ Unknown/unspecified error\n        1       Don't Convert option present\n  \
    \      2       Unknown mandatory option present\n        3       Known unsupported\
    \ option present\n        4       Unsupported transport protocol\n        5  \
    \     Overall length exceeded\n        6       IP header length exceeded\n   \
    \     7       Transport protocol > 255\n        8       Port conversion out of\
    \ range\n        9       Transport header length exceeded\n        10      32\
    \ Bit Rollover missing and ACK set\n        11      Unknown mandatory transport\
    \ option present\n   The use of code 0 should be avoided, any other condition\
    \ found by\n   implementors should be assigned a new code requested from IANA.\
    \  When\n   code 0 is used, it is particularily important that the pointer be\
    \ set\n   properly.\n   The pointer is an offset from the start of the original\
    \ datagram to\n   the beginning of the offending field.\n   The data is part of\
    \ the datagram that could not be converted.  It\n   must be at least the IP and\
    \ transport headers, and must include the\n   field pointed to by the previous\
    \ parameter.  For code 4, the\n   transport header is probably not identifiable;\
    \ the data should\n   include 256 bytes of the original datagram.\n"
- title: 7.  Notes on the domain system
  contents:
  - '7.  Notes on the domain system

    '
- title: 7.1  A records
  contents:
  - "7.1  A records\n   Address records will be added to the IN (Internet) zone with\
    \ IPv7\n   addresses for all hosts as IPv7 is deployed.  Eventually the IPv4\n\
    \   addresses will be removed.  As mentioned above, the AD\n   (Administrative\
    \ Domain) space is initially assigned so that the first\n   4 octets of a v7 address\
    \ cannot be confused with a v4 address (or,\n   rather, the confusion will be\
    \ to no effect.)\n   For example:\n   DELTA.Process.COM.      A       192.42.95.68\n\
    \                           A       192.0.0.192.42.95.1.68\n   It is important\
    \ that the A record be used, to avoid the cache\n   consistancy problem that would\
    \ arise when different records had\n   different remaining TTLs.\n   Note that\
    \ if an unmodified version of the more popular public domain\n   nameserver is\
    \ a secondary for a zone containing IPv7 addresses, it\n   will erroneously issue\
    \ RRs with only the first four bytes.  (I.e.,\n   192.0.0.192 in the example.)\
    \ This is another reason to ensure that\n   the AD numbers are initially reserved\
    \ out of the IPv4 network number\n   space.  Eventually, zones with IPv7 addresses\
    \ would be expected to be\n   served only by upgraded servers.\n"
- title: 7.2  PTR zone
  contents:
  - "7.2  PTR zone\n   The inverse (PTR) zone is .#, with the IPv7 address (reversed).\n\
    \   I.e., just like .IN-ADDR.ARPA, but with .# instead.\n   This respects the\
    \ difference in actual authority:  the NSF/DDN NIC is\n   the authority for the\
    \ entire space rooted in .IN-ADDR.ARPA.  in the\n   v4 Internet, while in the\
    \ new Internet it holds the authority only\n   for the AD 0.0.192.#.  (Plus, of\
    \ course, any other ADs assigned to it\n   over time.)\n"
- title: 8.  Conversion between version 4 and version 7
  contents:
  - "8.  Conversion between version 4 and version 7\n   As noted in the description\
    \ of datagram format, it is possible to\n   provide a mostly-transparent bridge\
    \ between version 4 and version 7.\n   This discusses TCP and ICMP at the session/transport\
    \ layer; UDP is a\n   subset of the TCP conversion.  Most protocols at this layer\
    \ will\n   probably need no translation; however it will probably be necessary\n\
    \   to specify exactly which will have translations done.\n   New protocols at\
    \ the session/transport layer defined over IPv7 should\n   have protocol numbers\
    \ greater than 255, and will not be translated to\n   IPv4.\n   Most of the translations\
    \ should consist of copying various fields,\n   verifying fixed values in the\
    \ datagram being translated, and setting\n   fixed values in the datagram being\
    \ produced.  In general, the\n   checksum must be verified first, and then a new\
    \ checksum computed for\n   the generated datagram.\n"
- title: 8.1  Version 4 IP address extension option
  contents:
  - "8.1  Version 4 IP address extension option\n   A new option is defined for IP\
    \ version 4, to carry the extended\n   addresses of IPv7.  This will be particularily\
    \ useful in the initial\n   testing of IPv7, during a time when most of the fabric\
    \ of the\n   internet is IPv4.  An IPv7 host will be able to connect to another\n\
    \   IPv7 host anywhere in the internet even though most of the paths and\n   routers\
    \ are IPv4, and still use the full addressing.  This will\n   continue to work\
    \ until non-unique network numbers are assigned, by\n   which time most of the\
    \ infrastructure should be IPv7.\n"
- title: 8.1.1  Option format
  contents:
  - "8.1.1  Option format\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |  type (147)   | length = 10   |     source IPv7 AD number     |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |  ...          | src 7th octet |     destination IPv7 AD       |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \    |  number ...   | dst 7th octet |\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The source and destination are in IPv4 order (source first), for\n   consistancy.\
    \  The type code is 147.\n"
- title: 8.2  Fragmented datagrams
  contents:
  - "8.2  Fragmented datagrams\n   Datagrams that have been fragmented must be reassembled\
    \ by the\n   converting host or router before conversion.  Where the conversion\
    \ is\n   being done by the destination host (i.e.,  the case of a v7 host\n  \
    \ receiving v4 datagrams), this is similar to the present fragmentation\n   model.\n\
    \   When it is being done by an intermediate router (acting as an\n   internetwork\
    \ layer gateway) the router should use all of source,\n   destination, and datagram\
    \ ID for identification of IPv4 fragments;\n   note that destination is used implicitly\
    \ in the usual reassembly at\n   the destination.  When reassembling an IPv7 datagram,\
    \ the 128 bit\n   fragment ID is used as usual.\n   If the fragments take different\
    \ paths through the net, and arrive at\n   different conversion points, the datagram\
    \ is lost.\n"
- title: 8.3  Where does the conversion happen?
  contents:
  - "8.3  Where does the conversion happen?\n   The objective of conversion is to\
    \ be able to upgrade systems, both\n   hosts and routers, in whatever order desired\
    \ by their owners.\n   Organizations must be able to upgrade any given system\
    \ without\n   reconfiguration or modification of any other; and IPv4 hosts must\
    \ be\n   able to interoperate essentially forever.  (IPv4 routers will\n   probably\
    \ be effectively eliminated at some point, except where they\n   exist in their\
    \ own remote or isolated corners.)\n   Each TCP/IP v7 system, whether host or\
    \ router, must be able to\n   recognize adjacent systems in the topology that\
    \ are (only) v4, and\n   call the appropriate conversion routine just before sending\
    \ the\n   datagram.\n   Digression:  I believe v7 hosts will get much better performance\
    \ by\n   doing everything internally in v7, and using conversion to filter\n \
    \  datagrams when necessary.  This keeps the usual code path simple,\n   with\
    \ only a \"hook\" right after receiving to convert incoming IPv4\n   datagrams,\
    \ and just before sending to convert to IPv4.  Routers may\n   prefer to keep\
    \ datagrams in their incoming version, at least until\n   after the routing decision\
    \ is made, and then doing the conversion\n   only if necessary.  In either case,\
    \ this is an implementation\n   specific decision.\n   It must be noted that any\
    \ forwarding system may convert datagrams to\n   IPv7, then back to IPv4, even\
    \ if that loses information such as\n   unknown options.  The reverse is not acceptable:\
    \  a system that\n   receives an IPv7 datagram should not convert it to IPv4,\
    \ then back to\n   IPv7 on forwarding.\n   The preferred method for identifying\
    \ which hosts require conversion\n   is to ARP first for the IPv7 address, and\
    \ then again if no response\n   is received, for the IPv4 address.  The reservation\
    \ of ADs out of the\n   v4 network number space is useful again here, protecting\
    \ hosts that\n   fail to properly use the ARP address length fields.\n   On networks\
    \ where ARP is not normally used, the method is to assume\n   that a remote system\
    \ is v7.  If an IPv7 datagram is received from it,\n   the assumption is confirmed.\
    \  If, after a short time, no IPv7\n   datagram is received, a v7 ICMP echo is\
    \ sent.  If a reply is received\n   (in either version) the assumption is confirmed.\n\
    \   If no reply is recieved, the remote system is assumed not to\n   understand\
    \ IPv7, and datagrams are converted to IPv4 just before\n   transmitting them.\n\
    \   Implementations should also provide for explicit configuration where\n   desired.\n"
- title: 8.4  Hybrid IPv4 systems
  contents:
  - "8.4  Hybrid IPv4 systems\n   In the course of implementing IPv7, especially in\
    \ constrained\n   environments such as small terminal servers, it may be useful\
    \ to\n   implement the IPv4 address extension option directly, thereby\n   regaining\
    \ universal connectivity.\n   This may also be a useful interim step for vendors\
    \ not prepared to do\n   a major rework of an implementation; but it is important\
    \ not to get\n   stalled in this step.\n   A hybrid IPv4 + address extension system\
    \ does not have to implement\n   the conversion, it places this onus on its neighbors.\
    \  It may itself\n   have an address with the subnet extension (7th byte) not\
    \ equal to 1.\n   The implication of hybrid systems is that it is not valid to\
    \ assume\n   that a host with a IPv7 address is a native IPv7 implementation.\n"
- title: 8.5  Maximum segment size in TCP
  contents:
  - "8.5  Maximum segment size in TCP\n   It is probably advisable for IPv4 implementations\
    \ to reduce the MSS\n   offered by a small amount where possible, to avoid fragmentation\
    \ when\n   datagrams are converted to IPv7.  This arises when IPv4 hosts are\n\
    \   communicating through an IPv7 infrastructure, with the same MTU as\n   the\
    \ local networks of the hosts.\n"
- title: 8.6  Forwarding and redirects
  contents:
  - "8.6  Forwarding and redirects\n   It may be important for a router to not send\
    \ ICMP redirects when it\n   finds that it must do a conversion as part of forwarding\
    \ the\n   datagram.  In this case, the hosts involved may not be able to\n   interact\
    \ directly.  The IPv7 host could ignore the redirect, but this\n   results in\
    \ an unpleasant level of noise as the sequence continually\n   recurs.\n"
- title: 8.7  Design considerations
  contents:
  - "8.7  Design considerations\n   The conversion is designed to be fairly efficient\
    \ in implementation,\n   especially on RISC architectures, assuming they can either\
    \ do a\n   conditional move (or store), or do a short forward branch without\n\
    \   losing the instruction cache.  The other conditional branches in the\n   body\
    \ of the code are usually not-taken out to the failure/discard\n   case.\n   Handling\
    \ options does involve a loop and a dispatch (case) operation.\n   The options\
    \ in IPv4 are more difficult to handle, not being designed\n   for speed on a\
    \ 32 bit aligned RISCish architecture, but they do not\n   occur often, except\
    \ perhaps the address extension option.\n   For CISC machines, the same considerations\
    \ will lead to fairly\n   efficient code.\n   The conversion code must be extremely\
    \ careful to be robust when\n   presented with invalid input; in particular, it\
    \ may be presented with\n   truncated transport layer headers when called recursively\
    \ from the\n   ICMP conversion.\n"
- title: 8.8  Conversion from IPv4 to IPv7
  contents:
  - "8.8  Conversion from IPv4 to IPv7\n   Individual steps in the conversion; the\
    \ order is in most cases not\n   significant.\n      o  Verify checksum.\n   \
    \   o  Verify fragment offset is 0, MF flag is 0.\n      o  Verify version is\
    \ 4.\n      o  Extend TTL to 16 bits, multiply by 16.\n      o  Set forward route\
    \ identifier to 0.\n      o  Set first 3 octets of destination to AD (i.e., 192.0.0),\
    \ copy\n         first three octets from v4 address, set next octet to 1, copy\n\
    \         last octet.  (This can be done with shift/mask/or operations\n     \
    \    on most architectures.)\n      o  Do the same translation on source address.\n\
    \      o  Copy protocol, set high 8 bits to zero.\n      o  If DF flag set, add\
    \ Don't Fragment option.\n      o  If Address Extension option present, copy ADs\
    \ and subnet\n         extension numbers into destination and source.\n      o\
    \  Convert other options where possible.  If an unknown option\n         with\
    \ copy-on-fragment is found, fail.  If copy-on-fragment is\n         not set,\
    \ ignore the option.  I.e., the flag is (ab)used as an\n         indicator of\
    \ whether the option is mandatory.\n      o  Compute new IP header length.\n \
    \     o  Convert session/transport layer (TCP) header and data.\n      o  Compute\
    \ new overall datagram length.\n      o  Calculate IPv7 checksum.\n"
- title: 8.9  Conversion from IPv7 to IPv4
  contents:
  - "8.9  Conversion from IPv7 to IPv4\n   The steps to convert IPv7 to IPv4 follow.\
    \  Note that the converting\n   router or host is partly in the role of destination\
    \ host; it checks\n   both bits of class in IP options, and (as in the other direction)\n\
    \   must reassemble fragmented datagrams.\n      o  Verify checksum.\n      o\
    \  Verify version is 7\n      o  Set type-of-service to 0 (there may be an option\
    \ defined,\n         that will be handled later).\n      o  If length is greater\
    \ than (about) 65563, fail.  (That number\n         is not a typographical error.\
    \  Note that the IPv7+TCPv7\n         headers add up to 28 bytes more than the\
    \ corresponding v4\n         headers in the usual case.) This check is only to\
    \ avoid\n         useless work, the precise check is later.\n      o  Generate\
    \ an ID (using an ISN based sequence generator,\n         possibly also based\
    \ on destination or source or both).\n      o  Set flags and fragment field to\
    \ 0.\n      o  Divide TTL by 16, if zero, fail (send ICMP Time Exceeded).\n  \
    \       If greater that 255, set to 255.\n      o  If next layer protocol is greater\
    \ than 255, fail.  Else copy.\n      o  Copy first 3 octets and 8th octet of destination\
    \ to\n         destination address.\n      o  Same for source address.\n     \
    \ o  Generate v4 address extension option.  (If enabled; this\n         probably\
    \ should be a configuration option, should default to\n         on.)\n      o\
    \  Process v7 options.  If any unknown options of class not 0\n         found,\
    \ fail.\n      o  If Don't Fragment option found, set DF flag.\n      o  If Don't\
    \ Convert option found, fail.\n      o  Convert other options where possible,\
    \ or fail.\n      o  Compute new IP header length.  This may fail (too large),\n\
    \         fail conversion if so.\n      o  Convert session/transport layer (e.g.,\
    \ TCP).\n      o  Compute new overall datagram length.  If greater than 65535,\n\
    \         fail.\n      o  Compute IPv4 checksum.\n"
- title: 8.10  Conversion from TCPv4 to TCPv7
  contents:
  - "8.10  Conversion from TCPv4 to TCPv7\n      o  Subtract header words from v4\
    \ checksum.  (Note that this is\n         actually done with one's complement\
    \ addition.)\n      o  Copy flags (except for Urgent).\n      o  If source port\
    \ is less than 32768 (a sign condition test will\n         suffice on most architectures),\
    \ copy it.  If equal or\n         greater, add 65536.\n      o  Same operation\
    \ on destination port.\n      o  Copy sequence to low 32 bits, set high to 0.\n\
    \      o  Copy acknowledgement to low 32 bits, set high to 0.\n      o  Copy window.\
    \  (The TCPv4 performance extension [RFC1323]\n         window-scale cannot be\
    \ used, as it would require state; we\n         use the basic window offered.)\n\
    \      o  Add 32 bit rollover option.\n      o  Convert maximum segment size option\
    \ if present.\n      o  Compute data offset and copy data.\n      o  Add header\
    \ words into saved checksum.  It is important not to\n         recompute the checksum\
    \ over the data; it must remain an\n         end-to-end checksum.\n      o  Return\
    \ to IP layer conversion.\n"
- title: 8.11  Conversion from TCPv7 to TCPv4
  contents:
  - "8.11  Conversion from TCPv7 to TCPv4\n      o  Subtract header from v7 checksum.\n\
    \      o  If source port is greater than 65535, subtract 65536.  If\n        \
    \ result is still greater than 65535, fail.  (Send ICMP\n         conversion failed/port\
    \ conversion out of range.  The sending\n         host may then reset its port\
    \ number generator to 98304.)\n      o  Same translation for destination port.\n\
    \      o  Copy low 32 bits of sequence number.\n      o  If A bit set, copy low\
    \ 32 bits of acknowledgement.\n      o  Copy flags.\n      o  If window is greater\
    \ than 61440, set it to 24576.  If less,\n         copy it unchanged.  (Rationale\
    \ for the 24K figure:  this has\n         been found to be a good default for\
    \ IPv4 hosts.  If the IPv7\n         host is offering a very large window, the\
    \ IPv4 host probably\n         isn't prepared to play at that level.)\n      o\
    \  Process options.  If 32 Bit Rollover is not present, and A\n         flag is\
    \ set, fail.  (Send ICMP conversion failed/32 bit\n         Rollover missing.)\n\
    \      o  If Urgent is present, compute offset.  If in segment, set U\n      \
    \   flag and offset field.  If not, ignore.\n      o  Convert Maximum Segment\
    \ Size option.  If greater than 16384,\n         set to 16384.\n      o  Compute\
    \ new data offset.\n      o  Add header words into v4 checksum.\n      o  Return\
    \ to IP layer conversion.\n"
- title: 8.12  ICMP conversion
  contents:
  - "8.12  ICMP conversion\n   ICMP messages are converted by copying the type and\
    \ code into the new\n   packet, and copying the other type-specific fields directly.\n\
    \   If the message contains an encapsulated, and usually truncated, IP\n   datagram,\
    \ the conversion routine is called recursively to translate\n   it as far as possible.\
    \  There are some special considerations:\n      o  The encapsulated datagram\
    \ is less likely to be valid, given\n         that it did generate an error of\
    \ some kind.\n      o  The conversion should attempt to complete all fields\n\
    \         available, even if some would cause failures in the general\n      \
    \   case.  Note, in particular, that in the course of converting\n         a datagram,\
    \ when a failure occurs, an ICMP message\n         (conversion failed) is sent;\
    \ this message itself may\n         immediately require conversion.  Part of that\
    \ conversion will\n         involve converting the original datagram.\n      o\
    \  Conditions such as overall datagram length too large are not\n         checked.\n\
    \      o  The AD and subnet byte assumed in the nested conversion may\n      \
    \   not be sensible if the IPv4 address extension option is not\n         present\
    \ and the datagram has strayed from the expected AD.\n         (Not unlikely,\
    \ given that we know a priori that some error\n         occured.)\n      o  The\
    \ conversion must be very sure not to make another\n         recursive call if\
    \ the nested datagram is an ICMP message.\n         (This should not occur, but\
    \ obviously may.)\n      o  It is probably impossible to generate a correct transport\n\
    \         layer checksum in the nested datagram.  The conversion may\n       \
    \  prefer to just zero the checksum field.  Likewise, validating\n         the\
    \ original checksum is pointless.\n   It may be best in a given implementation\
    \ to have a separate code path\n   for the nested conversion, that handles these\
    \ issues out of the\n   optimized usual path.\n"
- title: 9.  Postscript
  contents:
  - "9.  Postscript\n   The present version of TCP/IP has been a success partly by\
    \ accident,\n   for reasons that weren't really designed in.  Perhaps the most\n\
    \   significant is the low level of network integration required to make\n   it\
    \ work.\n   We must be careful to retain the successful ingredients, even where\n\
    \   we may be unaware of them.  Tread lightly, and use all that we have\n   learned,\
    \ especially about not changing things that work.\n   This document has described\
    \ a fairly conservative step forward, with\n   clear extensibility for future\
    \ developments, but without jumping into\n   the abyss.\n"
- title: 10.  References
  contents:
  - "10.  References\n   [RFC768]    Postel, J., \"User Datagram Protocol\", STD 6,\
    \ RFC 768,\n               USC/Information Sciences Institute, August 1980.\n\
    \   [RFC791]    Postel, J., \"Internet Protocol - DARPA Internet Program\n   \
    \            Protocol Specification\", STD 5, RFC 791, DARPA,\n              \
    \ September 1981.\n   [RFC792]    Postel, J., \"Internet Control Message Protocol\
    \ -\n               DARPA Internet Program Protocol Specification\"\n        \
    \       STD 5, RFC 792, USC/Information Sciences Institute,\n               September\
    \ 1981.\n   [RFC793]    Postel, J., \"Transmission Control Protocol - DARPA\n\
    \               Internet Program Protocol Specification\", STD 7, RFC 793,\n \
    \              USC/Information Sciences Institute, September 1981.\n   [RFC801]\
    \    Postel, J., \"NCP/TCP Transition Plan\", USC/Information\n              \
    \ Sciences Institute, November 1981.\n   [RFC1287]   Clark, D., Chapin, L., Cerf,\
    \ V., Braden, R., and\n               R. Hobby, \"Towards the Future Internet\
    \ Architecture\", RFC\n               1287, MIT, BBN, CNRI, ISI, UCDavis, December\
    \ 1991.\n   [RFC1323]   Jacobson, V., Braden, R, and D. Borman, \"TCP Extensions\n\
    \               for High Performance\", RFC 1323, LBL, USC/Information\n     \
    \          Sciences Institute, Cray Research, May 1992.\n   [RFC1335]   Wang,\
    \ Z., and J. Crowcroft, A Two-Tier Address Structure\n               for the Internet:\
    \ A Solution to the Problem of Address\n               Space Exhaustion\", RFC\
    \ 1335, University College London,\n               May 1992.\n   [RFC1338]   Fuller,\
    \ V., Li, T., Yu, J., and K. Varadhan,\n               \"Supernetting: an Address\
    \ Assignment and Aggregation\n               Strategy\", RFC 1338, BARRNet, cicso,\
    \ Merit, OARnet,\n               June 1992.\n   [RFC1347]   Callon, R., \"TCP\
    \ and UDP with Bigger Addresses (TUBA),\n               A Simple Proposal for\
    \ Internet Addressing and Routing\",\n               RFC 1347, DEC, June 1992.\n\
    \   [RFC1476]   Ullmann, R., \"RAP: Internet Route Access Protocol\",\n      \
    \         RFC 1476, Process Software Corporation, June 1993.\n   [RFC1379]   Braden,\
    \ R., \"Extending TCP for Transactions -- Concepts\",\n               RFC 1379,\
    \ USC/Information Sciences Institute,\n               November 1992.\n"
- title: 11.  Security Considerations
  contents:
  - "11.  Security Considerations\n   Security issues are not discussed in this memo.\n"
- title: 12.  Author's Address
  contents:
  - "12.  Author's Address\n   Robert Ullmann\n   Process Software Corporation\n \
    \  959 Concord Street\n   Framingham, MA 01701\n   USA\n   Phone: +1 508 879 6994\
    \ x226\n   Email: Ariel@Process.COM\n"
