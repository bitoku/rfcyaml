- contents:
  - '          Dynamic Symmetric Key Provisioning Protocol (DSKPP)

    '
  title: __initial_text__
- contents:
  - "Abstract\n   The Dynamic Symmetric Key Provisioning Protocol (DSKPP) is a client-\n
    \  server protocol for initialization (and configuration) of symmetric\n   keys
    to locally and remotely accessible cryptographic modules.  The\n   protocol can
    be run with or without private key capabilities in the\n   cryptographic modules
    and with or without an established public key\n   infrastructure.\n   Two variations
    of the protocol support multiple usage scenarios.\n   With the four-pass variant,
    keys are mutually generated by the\n   provisioning server and cryptographic module;
    provisioned keys are\n   not transferred over-the-wire or over-the-air.  The two-pass
    variant\n   enables secure and efficient download and installation of pre-\n   generated
    symmetric keys to a cryptographic module.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6063.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2010 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n   This document may contain
    material from IETF Documents or IETF\n   Contributions published or made publicly
    available before November\n   10, 2008.  The person(s) controlling the copyright
    in some of this\n   material may not have granted the IETF Trust the right to
    allow\n   modifications of such material outside the IETF Standards Process.\n
    \  Without obtaining an adequate license from the person(s) controlling\n   the
    copyright in such materials, this document may not be modified\n   outside the
    IETF Standards Process, and derivative works of it may\n   not be created outside
    the IETF Standards Process, except to format\n   it for publication as an RFC
    or to translate it into languages other\n   than English.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................6\n
    \     1.1. Key Words ..................................................6\n      1.2.
    Version Support ............................................6\n      1.3. Namespace
    Identifiers ......................................7\n           1.3.1. Defined
    Identifiers .................................7\n           1.3.2. Identifiers
    Defined in Related Specifications .......7\n           1.3.3. Referenced Identifiers
    ..............................8\n   2. Terminology .....................................................8\n
    \     2.1. Definitions ................................................8\n      2.2.
    Notation ..................................................10\n      2.3. Abbreviations
    .............................................11\n   3. DSKPP Overview .................................................11\n
    \     3.1. Protocol Entities .........................................12\n      3.2.
    Basic DSKPP Exchange ......................................12\n           3.2.1.
    User Authentication ................................12\n           3.2.2. Protocol
    Initiated by the DSKPP Client .............14\n           3.2.3. Protocol Triggered
    by the DSKPP Server .............16\n           3.2.4. Variants ...........................................17\n
    \                 3.2.4.1. Criteria for Using the Four-Pass Variant ..17\n                  3.2.4.2.
    Criteria for Using the Two-Pass Variant ...18\n      3.3. Status Codes ..............................................18\n
    \     3.4. Basic Constructs ..........................................20\n           3.4.1.
    User Authentication Data (AD) ......................20\n                  3.4.1.1.
    Authentication Code Format ................20\n                  3.4.1.2. User
    Authentication Data Calculation ......23\n           3.4.2. The DSKPP One-Way
    Pseudorandom Function,\n                  DSKPP-PRF ..........................................24\n
    \          3.4.3. The DSKPP Message Hash Algorithm ...................24\n   4.
    Four-Pass Protocol Usage .......................................25\n      4.1.
    The Key Agreement Mechanism ...............................25\n           4.1.1.
    Data Flow ..........................................25\n           4.1.2. Computation
    ........................................27\n      4.2. Message Flow ..............................................28\n
    \          4.2.1. KeyProvTrigger .....................................28\n           4.2.2.
    KeyProvClientHello .................................29\n           4.2.3. KeyProvServerHello
    .................................30\n           4.2.4. KeyProvClientNonce .................................32\n
    \          4.2.5. KeyProvServerFinished ..............................34\n   5.
    Two-Pass Protocol Usage ........................................35\n      5.1.
    Key Protection Methods ....................................36\n           5.1.1.
    Key Transport ......................................36\n           5.1.2. Key
    Wrap ...........................................37\n           5.1.3. Passphrase-Based
    Key Wrap ..........................37\n      5.2. Message Flow ..............................................38\n
    \          5.2.1. KeyProvTrigger .....................................38\n           5.2.2.
    KeyProvClientHello .................................39\n           5.2.3. KeyProvServerFinished
    ..............................43\n   6. Protocol Extensions ............................................44\n
    \     6.1. The ClientInfoType Extension ..............................45\n      6.2.
    The ServerInfoType Extension ..............................45\n   7. Protocol
    Bindings ..............................................45\n      7.1. General
    Requirements ......................................45\n      7.2. HTTP/1.1 Binding
    for DSKPP ................................46\n           7.2.1. Identification
    of DSKPP Messages ...................46\n           7.2.2. HTTP Headers .......................................46\n
    \          7.2.3. HTTP Operations ....................................47\n           7.2.4.
    HTTP Status Codes ..................................47\n           7.2.5. HTTP
    Authentication ................................47\n           7.2.6. Initialization
    of DSKPP ............................47\n           7.2.7. Example Messages ...................................48\n
    \  8. DSKPP XML Schema ...............................................49\n      8.1.
    General Processing Requirements ...........................49\n      8.2. Schema
    ....................................................49\n   9. Conformance Requirements
    .......................................58\n   10. Security Considerations .......................................59\n
    \     10.1. General ..................................................59\n      10.2.
    Active Attacks ...........................................60\n           10.2.1.
    Introduction ......................................60\n           10.2.2. Message
    Modifications .............................60\n           10.2.3. Message Deletion
    ..................................61\n           10.2.4. Message Insertion .................................62\n
    \          10.2.5. Message Replay ....................................62\n           10.2.6.
    Message Reordering ................................62\n           10.2.7. Man
    in the Middle .................................63\n      10.3. Passive Attacks
    ..........................................63\n      10.4. Cryptographic Attacks
    ....................................63\n      10.5. Attacks on the Interaction
    between DSKPP and User\n            Authentication ...........................................64\n
    \     10.6. Miscellaneous Considerations .............................65\n           10.6.1.
    Client Contributions to K_TOKEN Entropy ...........65\n           10.6.2. Key
    Confirmation ..................................65\n           10.6.3. Server Authentication
    .............................65\n           10.6.4. User Authentication ...............................66\n
    \          10.6.5. Key Protection in Two-Pass DSKPP ..................66\n           10.6.6.
    Algorithm Agility .................................67\n   11. Internationalization
    Considerations ...........................68\n   12. IANA Considerations ...........................................68\n
    \     12.1. URN Sub-Namespace Registration ...........................68\n      12.2.
    XML Schema Registration ..................................69\n      12.3. MIME
    Media Type Registration .............................69\n      12.4. Status Code
    Registration .................................70\n      12.5. DSKPP Version Registration
    ...............................70\n      12.6. PRF Algorithm ID Sub-Registry ............................70\n
    \          12.6.1. DSKPP-PRF-AES .....................................71\n           12.6.2.
    DSKPP-PRF-SHA256 ..................................71\n      12.7. Key Container
    Registration ...............................72\n   13. Intellectual Property Considerations
    ..........................73\n   14. Contributors ..................................................73\n
    \  15. Acknowledgements ..............................................73\n   16.
    References ....................................................74\n      16.1.
    Normative References .....................................74\n      16.2. Informative
    References ...................................76\n   Appendix A.  Usage Scenarios
    ......................................78\n     A.1.  Single Key Request ........................................78\n
    \    A.2.  Multiple Key Requests .....................................78\n     A.3.
    \ User Authentication .......................................78\n     A.4.  Provisioning
    Time-Out Policy ............................78\n     A.5.  Key Renewal ...............................................79\n
    \    A.6.  Pre-Loaded Key Replacement ..............................79\n     A.7.
    \ Pre-Shared Manufacturing Key ............................79\n     A.8.  End-to-End
    Protection of Key Material ...................80\n   Appendix B.  Examples .............................................80\n
    \    B.1.  Trigger Message ...........................................80\n     B.2.
    \ Four-Pass Protocol ......................................81\n       B.2.1.  <KeyProvClientHello>
    without a Preceding Trigger ......81\n       B.2.2.  <KeyProvClientHello> Assuming
    a Preceding Trigger .....82\n       B.2.3.  <KeyProvServerHello> Without a Preceding
    Trigger ......83\n       B.2.4.  <KeyProvServerHello> Assuming Key Renewal .............84\n
    \      B.2.5.  <KeyProvClientNonce> Using Default Encryption .........85\n       B.2.6.
    \ <KeyProvServerFinished> Using Default Encryption ......85\n     B.3.  Two-Pass
    Protocol .......................................86\n       B.3.1.  Example Using
    the Key Transport Method ................86\n       B.3.2.  Example Using the
    Key Wrap Method .....................90\n       B.3.3.  Example Using the Passphrase-Based
    Key Wrap Method ..94\n   Appendix C.  Integration with PKCS #11 ............................98\n
    \    C.1.  The Four-Pass Variant ...................................98\n     C.2.
    \ The Two-Pass Variant ....................................98\n   Appendix D.
    \ Example of DSKPP-PRF Realizations .................101\n     D.1.  Introduction
    .............................................101\n     D.2.  DSKPP-PRF-AES ..........................................101\n
    \      D.2.1.  Identification .......................................101\n       D.2.2.
    \ Definition ...........................................101\n       D.2.3.  Example
    ..............................................102\n     D.3.  DSKPP-PRF-SHA256
    .......................................103\n       D.3.1.  Identification .......................................103\n
    \      D.3.2.  Definition ...........................................103\n       D.3.3.
    \ Example ..............................................104\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   Symmetric-key-based cryptographic systems (e.g., those providing\n
    \  authentication mechanisms such as one-time passwords and challenge-\n   response)
    offer performance and operational advantages over public\n   key schemes.  Such
    use requires a mechanism for the provisioning of\n   symmetric keys providing
    equivalent functionality to mechanisms such\n   as the Certificate Management
    Protocol (CMP) [RFC4210] and\n   Certificate Management over CMS (CMC) [RFC5272]
    in a Public Key\n   Infrastructure.\n   Traditionally, cryptographic modules have
    been provisioned with keys\n   during device manufacturing, and the keys have
    been imported to the\n   cryptographic server using, e.g., a CD-ROM disc shipped
    with the\n   devices.  Some vendors also have proprietary provisioning protocols,\n
    \  which often have not been publicly documented (the Cryptographic\n   Token
    Key Initialization Protocol (CT-KIP) is one exception\n   [RFC4758]).\n   This
    document describes the Dynamic Symmetric Key Provisioning\n   Protocol (DSKPP),
    a client-server protocol for provisioning symmetric\n   keys between a cryptographic
    module (corresponding to DSKPP Client)\n   and a key provisioning server (corresponding
    to DSKPP Server).\n   DSKPP provides an open and interoperable mechanism for initializing\n
    \  and configuring symmetric keys to cryptographic modules that are\n   accessible
    over the Internet.  The description is based on the\n   information contained
    in [RFC4758], and contains specific\n   enhancements, such as user authentication
    and support for the\n   [RFC6030] format for transmission of keying material.\n
    \  DSKPP has two principal protocol variants.  The four-pass protocol\n   variant
    permits a symmetric key to be established that includes\n   randomness contributed
    by both the client and the server.  The two-\n   pass protocol requires only one
    round trip instead of two and permits\n   a server specified key to be established.\n"
  - contents:
    - "1.1.  Key Words\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
      \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and
      \"OPTIONAL\" in this\n   document are to be interpreted as described in [RFC2119].\n"
    title: 1.1.  Key Words
  - contents:
    - "1.2.  Version Support\n   There is a provision made in the syntax for an explicit
      version\n   number.  Only version \"1.0\" is currently specified.\n   The purpose
      for versioning the protocol is to provide a mechanism by\n   which changes to
      required cryptographic algorithms (e.g., SHA-256)\n   and attributes (e.g.,
      key size) can be deployed without disrupting\n   existing implementations; likewise,
      outdated implementations can be\n   de-commissioned without disrupting operations
      involving newer\n   protocol versions.\n   The numbering scheme for DSKPP versions
      is \"<major>.<minor>\".  The\n   major and minor numbers MUST be treated as
      separate integers and each\n   number MAY be incremented higher than a single
      digit.  Thus, \"DSKPP\n   2.4\" would be a lower version than \"DSKPP 2.13\",
      which in turn would\n   be lower than \"DSKPP 12.3\".  Leading zeros (e.g.,
      \"DSKPP 6.01\") MUST\n   be ignored by recipients and MUST NOT be sent.\n   The
      major version number should be incremented only if the data\n   formats or security
      algorithms have changed so dramatically that an\n   older version implementation
      would not be able to interoperate with a\n   newer version (e.g., removing support
      for a previously mandatory-to-\n   implement algorithm now found to be insecure).
      \ The minor version\n   number indicates new capabilities (e.g., introducing
      a new algorithm\n   option) and MUST be ignored by an entity with a smaller
      minor version\n   number but be used for informational purposes by the entity
      with the\n   larger minor version number.\n"
    title: 1.2.  Version Support
  - contents:
    - "1.3.  Namespace Identifiers\n   This document uses Uniform Resource Identifiers
      (URIs) [RFC3986] to\n   identify resources, algorithms, and semantics.\n"
    - contents:
      - "1.3.1.  Defined Identifiers\n   The XML namespace [XMLNS] URI for Version
        1.0 of DSKPP is:\n   \"urn:ietf:params:xml:ns:keyprov:dskpp\"\n   References
        to qualified elements in the DSKPP schema defined herein\n   use the prefix
        \"dskpp\", but any prefix is allowed.\n"
      title: 1.3.1.  Defined Identifiers
    - contents:
      - "1.3.2.  Identifiers Defined in Related Specifications\n   This document relies
        on qualified elements already defined in the\n   Portable Symmetric Key Container
        [RFC6030] namespace, which is\n   represented by the prefix \"pskc\" and declared
        as:\n   xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\"\n"
      title: 1.3.2.  Identifiers Defined in Related Specifications
    - contents:
      - "1.3.3.  Referenced Identifiers\n   Finally, the DSKPP syntax presented in
        this document relies on\n   algorithm identifiers defined in the XML Signature
        [XMLDSIG]\n   namespace:\n   xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\n
        \  References to algorithm identifiers in the XML Signature namespace\n   are
        represented by the prefix \"ds\".\n"
      title: 1.3.3.  Referenced Identifiers
    title: 1.3.  Namespace Identifiers
  title: 1.  Introduction
- contents:
  - '2.  Terminology

    '
  - contents:
    - "2.1.  Definitions\n   Terms are defined below as they are used in this document.
      \ The same\n   terms may be defined differently in other documents.\n   Authentication
      Code (AC):  User Authentication Code comprised of a\n      string of hexadecimal
      characters known to the device and the\n      server and containing at a minimum
      a client identifier and a\n      password.  This ClientID/password combination
      is used only once\n      and may have a time limit, and then discarded.\n   Authentication
      Data (AD):  User Authentication Data that is derived\n      from the Authentication
      Code (AC)\n   Client ID:  An identifier that the DSKPP Server uses to locate
      the\n      real username or account identifier on the server.  It can be a\n
      \     short random identifier that is unrelated to any real usernames.\n   Cryptographic
      Module:  A component of an application, which enables\n      symmetric key cryptographic
      functionality\n   Device:  A physical piece of hardware, or a software framework,
      that\n      hosts symmetric key cryptographic modules\n   Device ID (DeviceID):
      \ A unique identifier for the device that houses\n      the cryptographic module,
      e.g., a mobile phone\n   DSKPP Client:  Manages communication between the symmetric
      key\n      cryptographic module and the DSKPP Server\n   DSKPP Server:  The
      symmetric key provisioning server that\n      participates in the DSKPP run\n
      \  DSKPP Server ID (ServerID):  The unique identifier of a DSKPP Server\n   Key
      Agreement:  A key establishment protocol whereby two or more\n      parties
      can agree on a key in such a way that both influence the\n      outcome\n   Key
      Confirmation:  The assurance of the rightful participants in a\n      key-establishment
      protocol that the intended recipient of the\n      shared key actually possesses
      the shared key\n   Key Issuer:  An organization that issues symmetric keys to
      end-users\n   Key Package (KP):  An object that encapsulates a symmetric key
      and\n      its configuration data\n   Key ID (KeyID):  A unique identifier for
      the symmetric key\n   Key Protection Method (KPM):  The key transport method
      used during\n      two-pass DSKPP\n   Key Protection Method List (KPML):  The
      list of key protection\n      methods supported by a cryptographic module\n
      \  Key Provisioning Server:  A lifecycle management system that provides\n      a
      key issuer with the ability to provision keys to cryptographic\n      modules
      hosted on end-users' devices\n   Key Transport:  A key establishment procedure
      whereby the DSKPP\n      Server selects and encrypts the keying material and
      then sends the\n      material to the DSKPP Client [NIST-SP800-57]\n   Key Transport
      Key:  The private key that resides on the cryptographic\n      module.  This
      key is paired with the DSKPP Client's public key,\n      which the DSKPP Server
      uses to encrypt keying material during key\n      transport [NIST-SP800-57]\n
      \  Key Type:  The type of symmetric key cryptographic methods for which\n      the
      key will be used (e.g., Open AUTHentication HMAC-Based One-\n      Time Password
      (OATH HOTP) or RSA SecurID authentication, AES\n      encryption, etc.)\n   Key
      Wrapping:  A method of encrypting keys for key transport\n      [NIST-SP800-57]\n
      \  Key Wrapping Key:  A symmetric key encrypting key used for key\n      wrapping
      [NIST-SP800-57]\n   Keying Material:  The data necessary (e.g., keys and key\n
      \     configuration data) necessary to establish and maintain\n      cryptographic
      keying relationships [NIST-SP800-57]\n   Manufacturer's Key:  A unique master
      key pre-issued to a hardware\n      device, e.g., a smart card, during the manufacturing
      process.  If\n      present, this key may be used by a cryptographic module
      to derive\n      secret keys\n   Protocol Run:  Complete execution of the DSKPP
      that involves one\n      exchange (two-pass) or two exchanges (four-pass)\n
      \  Security Attribute List (SAL):  A payload that contains the DSKPP\n      version,
      DSKPP variant (four- or two-pass), key package formats,\n      key types, and
      cryptographic algorithms that the cryptographic\n      module is capable of
      supporting\n"
    title: 2.1.  Definitions
  - contents:
    - "2.2.  Notation\n   ||                    String concatenation\n   [x]                   Optional
      element x\n   A ^ B                 Exclusive-OR operation on strings A and
      B\n                         (where A and B are of equal length)\n   <XMLElement>
      \         A typographical convention used in the body of\n                         the
      text\n   DSKPP-PRF(k,s,dsLen)  A keyed pseudorandom function\n   E(k,m)                Encryption
      of m with the key k\n   K                     Key used to encrypt R_C (either
      K_SERVER or\n                         K_SHARED), or in MAC or DSKPP_PRF computations\n
      \  K_AC                  Secret key that is derived from the\n                         Authentication
      Code and used for user\n                         authentication purposes\n   K_MAC
      \                Secret key derived during a DSKPP exchange for\n                         use
      with key confirmation\n   K_MAC'                A second secret key used for
      server\n                         authentication\n   K_PROV                A
      provisioning master key from which two keys\n                         are derived:
      K_TOKEN and K_MAC\n   K_SERVER              Public key of the DSKPP Server;
      used for\n                         encrypting R_C in the four-pass protocol\n
      \                        variant\n   K_SHARED              Secret key that is
      pre-shared between the DSKPP\n                         Client and the DSKPP
      Server; used for\n                         encrypting R_C in the four-pass protocol\n
      \                        variant\n   K_TOKEN               Secret key that is
      established in a\n                         cryptographic module using DSKPP\n
      \  R                     Pseudorandom value chosen by the DSKPP Client\n                         and
      used for MAC computations\n   R_C                   Pseudorandom value chosen
      by the DSKPP Client\n                         and used as input to the generation
      of K_TOKEN\n   R_S                   Pseudorandom value chosen by the DSKPP
      Server\n                         and used as input to the generation of K_TOKEN\n
      \  URL_S                 DSKPP Server address, as a URL\n"
    title: 2.2.  Notation
  - contents:
    - "2.3.  Abbreviations\n   AC      Authentication Code\n   AD      Authentication
      Data\n   DSKPP   Dynamic Symmetric Key Provisioning Protocol\n   HTTP    Hypertext
      Transfer Protocol\n   KP      Key Package\n   KPM     Key Protection Method\n
      \  KPML    Key Protection Method List\n   MAC     Message Authentication Code\n
      \  PC      Personal Computer\n   PDU     Protocol Data Unit\n   PKCS    Public
      Key Cryptography Standards\n   PRF     Pseudorandom Function\n   PSKC    Portable
      Symmetric Key Container\n   SAL     Security Attribute List (see Section 2.1)\n
      \  TLS     Transport Layer Security\n   URL     Uniform Resource Locator\n   USB
      \    Universal Serial Bus\n   XML     eXtensible Markup Language\n"
    title: 2.3.  Abbreviations
  title: 2.  Terminology
- contents:
  - "3.  DSKPP Overview\n   The following sub-sections provide a high-level view of
    protocol\n   internals and how they interact with external provisioning\n   applications.
    \ Usage scenarios are provided in Appendix A.\n"
  - contents:
    - "3.1.  Protocol Entities\n   A DSKPP provisioning transaction has three entities:\n
      \  Server:   The DSKPP provisioning server.\n   Cryptographic Module:  The cryptographic
      module to which the\n      symmetric keys are to be provisioned, e.g., an authentication\n
      \     token.\n   Client:  The DSKPP Client that manages communication between
      the\n      cryptographic module and the key provisioning server.\n   The principal
      syntax is XML [XML] and it is layered on a transport\n   mechanism such as HTTP
      [RFC2616] and HTTP Over TLS [RFC2818].  While\n   it is highly desirable for
      the entire communication between the DSKPP\n   Client and server to be protected
      by means of a transport providing\n   confidentiality and integrity protection
      such as HTTP over Transport\n   Layer Security (TLS), such protection is not
      sufficient to protect\n   the exchange of the symmetric key data between the
      server and the\n   cryptographic module and DSKPP is designed to permit implementations\n
      \  that satisfy this requirement.\n   The server only communicates to the client.
      \ As far as the server is\n   concerned, the client and cryptographic module
      may be considered to\n   be a single entity.\n   From a client-side security
      perspective, however, the client and the\n   cryptographic module are separate
      logical entities and may in some\n   implementations be separate physical entities
      as well.\n   It is assumed that a device will host an application layered above\n
      \  the cryptographic module, and this application will manage\n   communication
      between the DSKPP Client and cryptographic module.  The\n   manner in which
      the communicating application will transfer DSKPP\n   elements to and from the
      cryptographic module is transparent to the\n   DSKPP Server.  One method for
      this transfer is described in\n   [CT-KIP-P11].\n"
    title: 3.1.  Protocol Entities
  - contents:
    - '3.2.  Basic DSKPP Exchange

      '
    - contents:
      - "3.2.1.  User Authentication\n   In a DSKPP message flow, the user has obtained
        a new hardware or\n   software device embedded with a cryptographic module.
        \ The goal of\n   DSKPP is to provision the same symmetric key and related
        information\n   to the cryptographic module and the key management server,
        and\n   associate the key with the correct username (or other account\n   identifier)
        on the server.  To do this, the DSKPP Server MUST\n   authenticate the user
        to be sure he is authorized for the new key.\n   User authentication occurs
        within the protocol itself *after* the\n   DSKPP Client initiates the first
        message.  In this case, the DSKPP\n   Client MUST have access to the DSKPP
        Server URL.\n   Alternatively, a DSKPP web service or other form of web application\n
        \  can authenticate a user *before* the first message is exchanged.  In\n
        \  this case, the DSKPP Server MUST trigger the DSKPP Client to initiate\n
        \  the first message in the protocol transaction.\n"
      title: 3.2.1.  User Authentication
    - contents:
      - "3.2.2.  Protocol Initiated by the DSKPP Client\n   In the following example,
        the DSKPP Client first initiates DSKPP, and\n   then the user is authenticated
        using a Client ID and Authentication\n   Code.\n   Crypto       DSKPP                          DSKPP
        \   Key Provisioning\n   Module       Client                         Server
        \       Server\n    |             |                              |             |\n
        \   |             |                              |     +---------------+\n
        \   |             |                              |     |Server creates |\n
        \   |             |                              |     |and stores     |\n
        \   |             |                              |     |Client ID and  |\n
        \   |             |                              |     |Auth. Code and |\n
        \   |             |                              |     |delivers them  |\n
        \   |             |                              |     |to user out-of-|\n
        \   |             |                              |     |band.          |\n
        \   |             |                              |     +---------------+\n
        \   |             |                              |             |\n    |  +----------------------+
        \                 |             |\n    |  |User enters Client ID,|                  |
        \            |\n    |  |Auth. Code, and URL   |                  |             |\n
        \   |  +----------------------+                  |             |\n    |             |
        \                             |             |\n    |             |<-- 1. TLS
        handshake with --->|             |\n    |             |        server auth.
        \         |             |\n    |             |                              |
        \            |\n    |             | 2. <KeyProvClientHello> ---->|     User
        -->|\n    |             |                              |     Auth.   |\n    |
        \            |<-- [3. <KeyProvServerHello>] |             |\n    |             |
        \                             |             |\n    |             | [4. <KeyProvClientNonce>]
        -->|             |\n    |             |                              |             |\n
        \   |             |<- 5. <KeyProvServerFinished> |             |\n    |             |
        \                             |             |\n    |             |                              |
        \            |\n    |<-- Key      |                              |      Key
        -->|\n    |    Package  |                              |   Package   |\n                      Figure
        1: Basic DSKPP Exchange\n   Before DSKPP begins:\n   o  The Authentication
        Code is generated by the DSKPP Server, and\n      delivered to the user via
        an out-of-band trustworthy channel\n      (e.g., a paper slip delivered by
        IT department staff).\n   o  The user typically enters the Client ID and Authentication
        Code\n      manually, possibly on a device with only a numeric keypad.  Thus,\n
        \     they are often short numeric values (for example, 8 decimal\n      digits).
        \ However, the DSKPP Server is free to generate them in\n      any way it
        wishes.\n   o  The DSKPP Client needs the URL [RFC3986] of the DSKPP Server\n
        \     (which is not user specific or secret, and may be pre-configured\n      somehow),
        and a set of trust anchors for verifying the server\n      certificate.\n
        \  o  There must be an account for the user that has an identifier and\n      long-term
        username (or other account identifier) to which the\n      token will be associated.
        \ The DSKPP Server will use the Client ID\n      to find the corresponding
        Authentication Code for user\n      authentication.\n   In Step 1, the client
        establishes a TLS connection, authenticates the\n   server (that is, validates
        the certificate, and compares the host\n   name in the URL with the certificate)
        as described in Section 3.1 of\n   [RFC2818].\n   Next, the DSKPP Client and
        DSKPP Server exchange DSKPP messages\n   (which are sent over HTTPS).  In
        these messages:\n   o  The client and server negotiate which cryptographic
        algorithms\n      they want to use, which algorithms are supported for protecting\n
        \     DSKPP messages, and other DSKPP details.\n   o  The client sends the
        Client ID to the server, and proves that it\n      knows the corresponding
        Authentication Code.\n   o  The client and server agree on a secret key (token
        key or\n      K_TOKEN); depending on the negotiated protocol variant, this
        is\n      either a fresh key derived during the DSKPP run (called \"four-pass\n
        \     variant\", since it involves four DSKPP messages) or is generated\n
        \     by (or pre-exists on) the server and transported to the client\n      (called
        \"two-pass variant\" in the rest of this document, since it\n      involves
        two DSKPP messages).\n   o  The server sends a \"key package\" to the client.
        \ The package only\n      includes the key itself in the case of the \"two-pass
        variant\";\n      with either variant, the key package contains attributes
        that\n      influence how the provisioned key will be later used by the\n
        \     cryptographic module and cryptographic server.  The exact contents\n
        \     depend on the cryptographic algorithm (e.g., for a one-time\n      password
        algorithm that supports variable-length OTP values, the\n      length of the
        OTP value would be one attribute in the key\n      package).\n   After the
        protocol run has been successfully completed, the\n   cryptographic modules
        stores the contents of the key package.\n   Likewise, the DSKPP provisioning
        server stores the contents of the\n   key package with the cryptographic server,
        and associates these with\n   the correct username.  The user can now use
        the their device to\n   perform symmetric-key based operations.\n   The exact
        division of work between the cryptographic module and the\n   DSKPP Client
        -- and key Provisioning server and DSKPP Server -- are\n   not specified in
        this document.  The figure above shows one possible\n   case, but this is
        intended for illustrative purposes only.\n"
      title: 3.2.2.  Protocol Initiated by the DSKPP Client
    - contents:
      - "3.2.3.  Protocol Triggered by the DSKPP Server\n   In the first message flow
        (previous section), the Client ID and\n   Authentication Code were delivered
        to the client by some out-of-band\n   means (such as paper sent to the user).\n
        \  Web           DSKPP                          DSKPP            Web\n   Browser
        \      Client                         Server          Server\n     |              |
        \                             |               |\n     |<-------- HTTPS browsing
        + some kind of user auth. --------->|\n     |              |                              |
        \              |\n     | some HTTP request ----------------------------------------->|\n
        \    |              |                              |\n     |              |
        \                             |<------------->|\n     |              |                              |
        \              |\n     |<----------------------- HTTP response with <KeyProvTrigger>
        |\n     |              |                              |               |\n
        \    | Trigger ---->|                              |               |\n     |
        \             |                              |               |\n     |              |<--
        1. TLS handshake with --->|               |\n     |              |        server
        auth.          |               |\n     |              |                              |
        \              |\n     |              |     ... continues...         |               |\n
        \         Figure 2: DSKPP Exchange with Web-Based Authentication\n   In the
        second message flow, the user first authenticates to a web\n   server (for
        example, an IT department's \"self-service\" Intranet\n   page), using an
        ordinary web browser and some existing credentials.\n   The user then requests
        (by clicking a link or submitting a form)\n   provisioning of a new key to
        the cryptographic module.  The web\n   server will reply with a <KeyProvTrigger>
        message that contains the\n   Client ID, Authentication Code, and URL of the
        DSKPP Server.  This\n   information is also needed by the DSKPP Server; how
        the web server\n   and DSKPP Server interact is beyond the scope of this document.\n
        \  The <KeyProvTrigger> message is sent in an HTTP response, and it is\n   marked
        with MIME type \"application/dskpp+xml\".  It is assumed the web\n   browser
        has been configured to recognize this MIME type; the browser\n   will start
        the DSKPP Client and provide it with the <KeyProvTrigger>\n   message.\n   The
        DSKPP Client then contacts the DSKPP Server and uses the Client\n   ID and
        Authentication Code (from the <KeyProvTrigger> message) the\n   same way as
        in the first message flow.\n"
      title: 3.2.3.  Protocol Triggered by the DSKPP Server
    - contents:
      - "3.2.4.  Variants\n   As noted in the previous section, once the protocol
        has started, the\n   client and server MAY engage in either a two-pass or
        four-pass\n   message exchange.  The four-pass and two-pass protocols are\n
        \  appropriate in different deployment scenarios.  The biggest\n   differentiator
        between the two is that the two-pass protocol supports\n   transport of an
        existing key to a cryptographic module, while the\n   four-pass involves key
        generation on-the-fly via key agreement.  In\n   either case, both protocol
        variants support algorithm agility through\n   the negotiation of encryption
        mechanisms and key types at the\n   beginning of each protocol run.\n"
      - contents:
        - "3.2.4.1.  Criteria for Using the Four-Pass Variant\n   The four-pass protocol
          is needed under one or more of the following\n   conditions:\n   o  Policy
          requires that both parties engaged in the protocol jointly\n      contribute
          entropy to the key.  Enforcing this policy mitigates\n      the risk of
          exposing a key during the provisioning process as the\n      key is generated
          through mutual agreement without being\n      transferred over-the-air or
          over-the-wire.  It also mitigates risk\n      of exposure after the key
          is provisioned, as the key will not be\n      vulnerable to a single point
          of attack in the system.\n   o  A cryptographic module does not have private
          key capabilities.\n   o  The cryptographic module is hosted by a device
          that neither was\n      pre-issued with a manufacturer's key or other form
          of pre-shared\n      key (as might be the case with a smart card or Subscriber
          Identity\n      Module (SIM) card) nor has a keypad that can be used for
          entering\n      a passphrase (such as present on a mobile phone).\n"
        title: 3.2.4.1.  Criteria for Using the Four-Pass Variant
      - contents:
        - "3.2.4.2.  Criteria for Using the Two-Pass Variant\n   The two-pass protocol
          is needed under one or more of the following\n   conditions:\n   o  Pre-existing
          (i.e., legacy) keys must be provisioned via transport\n      to the cryptographic
          module.\n   o  The cryptographic module is hosted on a device that was pre-issued\n
          \     with a manufacturer's key (such as may exist on a smart card), or\n
          \     other form of pre-shared key (such as may exist on a SIM-card),\n
          \     and is capable of performing private key operations.\n   o  The cryptographic
          module is hosted by a device that has a built-in\n      keypad with which
          a user may enter a passphrase, useful for\n      deriving a key wrapping
          key for distribution of keying material.\n"
        title: 3.2.4.2.  Criteria for Using the Two-Pass Variant
      title: 3.2.4.  Variants
    title: 3.2.  Basic DSKPP Exchange
  - contents:
    - "3.3.  Status Codes\n   Upon transmission or receipt of a message for which
      the Status\n   attribute's value is not \"Success\" or \"Continue\", the default\n
      \  behavior, unless explicitly stated otherwise below, is that both the\n   DSKPP
      Server and the DSKPP Client MUST immediately terminate the\n   DSKPP run.  DSKPP
      Servers and DSKPP Clients MUST delete any secret\n   values generated as a result
      of failed runs of DSKPP.  Session\n   identifiers MAY be retained from successful
      or failed protocol runs\n   for replay detection purposes, but such retained
      identifiers MUST NOT\n   be reused for subsequent runs of the protocol.\n   When
      possible, the DSKPP Client SHOULD present an appropriate error\n   message to
      the user.\n   These status codes are valid in all DSKPP Response messages unless\n
      \  explicitly stated otherwise:\n   Continue:  The DSKPP Server is ready for
      a subsequent request from\n      the DSKPP Client.  It cannot be sent in the
      server's final\n      message.\n   Success:  Successful completion of the DSKPP
      session.  It can only be\n      sent in the server's final message.\n   Abort:
      \ The DSKPP Server rejected the DSKPP Client's request for\n      unspecified
      reasons.\n   AccessDenied:  The DSKPP Client is not authorized to contact this\n
      \     DSKPP Server.\n   MalformedRequest:  The DSKPP Server failed to parse
      the DSKPP\n      Client's request.\n   UnknownRequest:  The DSKPP Client made
      a request that is unknown to\n      the DSKPP Server.\n   UnknownCriticalExtension:
      \ A DSKPP extension marked as \"Critical\"\n      could not be interpreted by
      the receiving party.\n   UnsupportedVersion:  The DSKPP Client used a DSKPP
      version not\n      supported by the DSKPP Server.  This error is only valid
      in the\n      DSKPP Server's first response message.\n   NoSupportedKeyTypes:
      \ \"NoSupportedKeyTypes\" indicates that the DSKPP\n      Client only suggested
      key types that are not supported by the\n      DSKPP Server.  This error is
      only valid in the DSKPP Server's\n      first response message.\n   NoSupportedEncryptionAlgorithms:
      \ The DSKPP Client only suggested\n      encryption algorithms that are not
      supported by the DSKPP Server.\n      This error is only valid in the DSKPP
      Server's first response\n      message.\n   NoSupportedMacAlgorithms:  The DSKPP
      Client only suggested MAC\n      algorithms that are not supported by the DSKPP
      Server.  This error\n      is only valid in the DSKPP Server's first response
      message.\n   NoProtocolVariants:  The DSKPP Client did not suggest a required\n
      \     protocol variant (either two-pass or four-pass).  This error is\n      only
      valid in the DSKPP Server's first response message.\n   NoSupportedKeyPackages:
      \ The DSKPP Client only suggested key package\n      formats that are not supported
      by the DSKPP Server.  This error is\n      only valid in the DSKPP Server's
      first response message.\n   AuthenticationDataMissing:  The DSKPP Client didn't
      provide\n      Authentication Data that the DSKPP Server required.\n   AuthenticationDataInvalid:
      \ The DSKPP Client supplied User\n      Authentication Data that the DSKPP Server
      failed to validate.\n   InitializationFailed:  The DSKPP Server could not generate
      a valid\n      key given the provided data.  When this status code is received,\n
      \     the DSKPP Client SHOULD try to restart DSKPP, as it is possible\n      that
      a new run will succeed.\n   ProvisioningPeriodExpired:  The provisioning period
      set by the DSKPP\n      Server has expired.  When the status code is received,
      the DSKPP\n      Client SHOULD report the reason for key initialization failure
      to\n      the user and the user MUST register with the DSKPP Server to\n      initialize
      a new key.\n"
    title: 3.3.  Status Codes
  - contents:
    - "3.4.  Basic Constructs\n   The following calculations are used in both DSKPP
      variants.\n"
    - contents:
      - "3.4.1.  User Authentication Data (AD)\n   User Authentication Data (AD) is
        derived from a Client ID and\n   Authentication Code that the user enters
        before the first DSKPP\n   message is sent.\n   Note: The user will typically
        enter the Client ID and Authentication\n   Code manually, possibly on a device
        with only numeric keypad.  Thus,\n   they are often short numeric values (for
        example, 8 decimal digits).\n   However, the DSKPP Server is free to generate
        them in any way it\n   wishes.\n"
      - contents:
        - "3.4.1.1.  Authentication Code Format\n   AC is encoded in Type-Length-Value
          (TLV) format.  The format consists\n   of a minimum of two TLVs and a variable
          number of additional TLVs,\n   depending on implementation.\n   The TLV
          fields are defined as follows:\n   Type (1 character)        A hexadecimal
          character identifying the\n                             type of information
          contained in the Value\n                             field.\n   Length (2
          characters)     Two hexadecimal characters indicating the\n                             length
          of the Value field to follow.  The\n                             field value
          MAY be up to 255 characters.\n                             The Length value
          00 MAY be used to specify\n                             custom tags without
          any field values.\n   Value (variable length)   A variable-length string
          of hexadecimal\n                             characters containing the instance-specific\n
          \                            information for this TLV.\n   The following
          table summarizes the TLVs defined in this document.\n   Optional TLVs are
          allowed for vendor-specific extensions with the\n   constraint that the
          high bit MUST be set to indicate a vendor-\n   specific type.  Other TLVs
          are left for later revisions of this\n   protocol.\n   +------+------------+-------------------------------------------+\n
          \  | Type | TLV Name   | Conformance | Example Usage               |\n   +------+------------+-------------------------------------------+\n
          \  |  1   | Client ID  | Mandatory   | { \"AC00000A\" }              |\n
          \  +------+------------+-------------+-----------------------------+\n   |
          \ 2   | Password   | Mandatory   | { \"3582AF0C3E\" }            |\n   +------+------------+-------------+-----------------------------+\n
          \  |  3   | Checksum   | Optional    | { \"4D5\" }                   |\n
          \  +------+------------+-------------+-----------------------------+\n   The
          Client ID is a mandatory TLV that represents the requester's\n   identifier
          of maximum length 255.  The value is represented as a\n   string of hexadecimal
          characters that identifies the key request.\n   For example, suppose Client
          ID is set to \"AC00000A\", the Client ID\n   TLV in the AC will be represented
          as \"108AC00000A\".\n   The Password is a mandatory TLV the contains a one-time
          use shared\n   secret known by the user and the Provisioning Server.  The
          Password\n   value is unique and SHOULD be a random string to make AC more\n
          \  difficult to guess.  The string MUST contain hexadecimal characters\n
          \  only.  For example, suppose password is set to \"3582AF0C3E\", then the\n
          \  Password TLV would be \"20A3582AF0C3E\".\n   The Checksum is an OPTIONAL
          TLV, which is generated by the issuing\n   server and sent to the user as
          part of the AC.  If the TLV is\n   provided, the checksum value MUST be
          computed using the CRC16\n   algorithm [ISO3309].  When the user enters
          the AC, the typed AC\n   string of characters is verified with the checksum
          to ensure it is\n   correctly entered by the user.  For example, suppose
          the AC with\n   combined Client ID tag and Password tag is set to\n   \"108AC00000A20A3582AF0C3E\",
          then the CRC16 calculation would generate\n   a checksum of 0x356, resulting
          in a Checksum TLV of \"334D5\".  The\n   complete AC string in this example
          would be\n   \"108AC00000A20A3582AF0C3E3034D5\".\n   Although this specification
          recommends using hexadecimal characters\n   only for the AC at the application's
          user interface layer and making\n   the TLV triples non-transparent to the
          user as described in the\n   example above; implementations MAY additionally
          choose to use other\n   printable Unicode characters [UNICODE] at the application's
          user\n   interface layer in order to meet specific local, context or usability\n
          \  requirements.  When non-hexadecimal characters are desired at the\n   user
          interface layer such as when other printable US-ASCII characters\n   or
          international characters are used, SASLprep [RFC4013] MUST be used\n   to
          normalize user input before converting it to a string of\n   hexadecimal
          characters.  For example, if a given application allows\n   the use of any
          printable US-ASCII characters and extended ASCII\n   characters for Client
          ID and Password fields, and the Client ID is\n   set to \"myclient!D\" and
          the associated Password is set to\n   \"mYpas&#rD\", the user enters through
          the keyboard or other means a\n   Client ID of \"myclient!D\" and a Password
          of \"mYpas&#rD\" in separate\n   form fields or as instructed by the provider.
          \ The application's\n   layer processing user input MUST then convert the
          values entered by\n   the user to the following string for use in the protocol:\n
          \  \"1146D79636C69656E7421442126D5970617326237244\" (note that in this\n
          \  example the Checksum TLV is not added).\n   The example is explained
          further below in detail:\n   Assume that the raw Client ID value or the
          value entered by the use\n   is: myclient!ID\n   The Client ID value as
          characters names is:\n      U+006D LATIN SMALL LETTER M character\n      U+0079
          LATIN SMALL LETTER Y character\n      U+0063 LATIN SMALL LETTER C character\n
          \     U+006C LATIN SMALL LETTER L character\n      U+0069 LATIN SMALL LETTER
          I character\n      U+0065 LATIN SMALL LETTER E character\n      U+006E LATIN
          SMALL LETTER N character\n      U+0074 LATIN SMALL LETTER T character\n
          \     U+0021 EXCLAMATION MARK character (!)\n      U+0044 LATIN CAPITAL
          LETTER D character\n   The UTF-8 conversion of the Client ID value is: 6D
          79 63 6C 69 65 6E\n   74 21 44\n   The length of the Client ID value in
          hexadecimal characters is: 14\n   The TLV presentation of the Client ID
          field is:\n   1146D79636C69656E742144\n   The raw Password value or the
          value entered by the user is: mYpas&#rD\n   The Password value as character
          names is:\n      U+006D LATIN SMALL LETTER M character\n      U+0059 LATIN
          LARGE LETTER Y character\n      U+0070 LATIN SMALL LETTER P character\n
          \     U+0061 LATIN SMALL LETTER A character\n      U+0073 LATIN SMALL LETTER
          S character\n      U+0026 AMPERSAND character (&)\n      U+0023 POUND SIGN
          character (#)\n      U+0072 LATIN SMALL LETTER R character\n      U+0044
          LATIN LARGE LETTER D character\n   The UTF-8 conversion of the password
          value is: 6D 59 70 61 73 26 23\n   72 44\n   The length of the password
          value in hexadecimal characters is: 12\n   The TLV presentation of the password
          field is: 2126D5970617326237244\n   The combined Client ID and password
          fields value or the AC value is:\n   1146D79636C69656E7421442126D5970617326237244\n"
        title: 3.4.1.1.  Authentication Code Format
      - contents:
        - "3.4.1.2.  User Authentication Data Calculation\n   The Authentication Data
          consists of a Client ID (extracted from the\n   AC) and a value, which is
          derived from AC as follows (refer to\n   Section 3.4.2 for a description
          of DSKPP-PRF in general and\n   Appendix D for a description of DSKPP-PRF-AES):\n
          \  MAC = DSKPP-PRF(K_AC, AC->ClientID||URL_S||R_C||[R_S], 16)\n   In four-pass
          DSKPP, the cryptographic module uses R_C, R_S, and URL_S\n   to calculate
          the MAC, where URL_S is the URL the DSKPP Client uses\n   when contacting
          the DSKPP Server.  In two-pass DSKPP, the\n   cryptographic module does
          not have access to R_S, therefore only R_C\n   is used in combination with
          URL_S to produce the MAC.  In either\n   case, K_AC MUST be derived from
          AC->password as follows [PKCS-5]:\n   K_AC = PBKDF2(AC->password, R_C ||
          K, iter_count, 16)\n   One of the following values for K MUST be used:\n
          \  a.  In four-pass:\n       *  The public key of the DSKPP Server (K_SERVER),
          or (in the pre-\n          shared key variant) the pre-shared key between
          the client and\n          the server (K_SHARED).\n   b.  In two-pass:\n
          \      *  The public key of the DSKPP Client, or the public key of the\n
          \         device when a device certificate is available.\n       *  The
          pre-shared key between the client and the server\n          (K_SHARED).\n
          \      *  A passphrase-derived key.\n   The iteration count, iter_count,
          MUST be set to at least 100,000\n   except in the last two two-pass cases
          (where K is set to K_SHARED or\n   a passphrase-derived key), in which case
          iter_count MUST be set to 1.\n"
        title: 3.4.1.2.  User Authentication Data Calculation
      title: 3.4.1.  User Authentication Data (AD)
    - contents:
      - "3.4.2.  The DSKPP One-Way Pseudorandom Function, DSKPP-PRF\n   Regardless
        of the protocol variant employed, there is a requirement\n   for a cryptographic
        primitive that provides a deterministic\n   transformation of a secret key
        k and a varying length octet string s\n   to a bit string of specified length
        dsLen.\n   This primitive must meet the same requirements as for a keyed hash\n
        \  function: it MUST take an arbitrary length input and generate an\n   output
        that is one way and collision free (for a definition of these\n   terms, see,
        e.g., [FAQ]).  Further, its output MUST be unpredictable\n   even if other
        outputs for the same key are known.\n   From the point of view of this specification,
        DSKPP-PRF is a \"black-\n   box\" function that, given the inputs, generates
        a pseudorandom value\n   and MAY be realized by any appropriate and competent
        cryptographic\n   technique.  Appendix D contains two example realizations
        of DSKPP-\n   PRF.\n   DSKPP-PRF(k, s, dsLen)\n   Input:\n   k     secret
        key in octet string format\n   s     octet string of varying length consisting
        of variable data\n         distinguishing the particular string being derived\n
        \  dsLen desired length of the output\n   Output:\n   DS    pseudorandom string,
        dsLen octets long\n   For the purposes of this document, the secret key k
        MUST be at least\n   16 octets long.\n"
      title: 3.4.2.  The DSKPP One-Way Pseudorandom Function, DSKPP-PRF
    - contents:
      - "3.4.3.  The DSKPP Message Hash Algorithm\n   When sending its last message
        in a protocol run, the DSKPP Server\n   generates a MAC that is used by the
        client for key confirmation.\n   Computation of the MAC MUST include a hash
        of all DSKPP messages sent\n   by the client and server during the transaction.
        \ To compute a\n   message hash for the MAC given a sequence of DSKPP messages
        msg_1,\n   ..., msg_n, the following operations MUST be carried out:\n   a.
        \ The sequence of messages contains all DSKPP Request and Response\n       messages
        up to but not including this message.\n   b.  Re-transmitted messages are
        removed from the sequence of\n       messages.\n       Note: The resulting
        sequence of messages MUST be an alternating\n       sequence of DSKPP Request
        and DSKPP Response messages\n   c.  The contents of each message is concatenated
        together.\n   d.  The resultant string is hashed using SHA-256 in accordance
        with\n       [FIPS180-SHA].\n"
      title: 3.4.3.  The DSKPP Message Hash Algorithm
    title: 3.4.  Basic Constructs
  title: 3.  DSKPP Overview
- contents:
  - "4.  Four-Pass Protocol Usage\n   This section describes the methods and message
    flow that comprise the\n   four-pass protocol variant.  Four-pass DSKPP depends
    on a client-\n   server key agreement mechanism.\n"
  - contents:
    - "4.1.  The Key Agreement Mechanism\n   With four-pass DSKPP, the symmetric key
      that is the target of\n   provisioning, is generated on-the-fly without being
      transferred\n   between the DSKPP Client and DSKPP Server.  The data flow and\n
      \  computation are described below.\n"
    - contents:
      - "4.1.1.  Data Flow\n   A sample data flow showing key generation during the
        four-pass\n   protocol is shown in Figure 3.\n   +----------------------+
        \                 +----------------------+\n   |    +------------+    |                  |
        \                     |\n   |    | Server key |    |                  |                      |\n
        \  | +<-|  Public    |------>------------->-------------+---------+ |\n   |
        |  |  Private   |    |                  |          |         | |\n   | |  +------------+
        \   |                  |          |         | |\n   | |        |           |
        \                 |          |         | |\n   | V        V           |                  |
        \         V         V |\n   | |   +---------+      |                  |        +---------+
        | |\n   | |   | Decrypt |<-------<-------------<-----------| Encrypt | | |\n
        \  | |   +---------+      |                  |        +---------+ | |\n   |
        |      |  +--------+ |                  |            ^       | |\n   | |      |
        \ | Server | |                  |            |       | |\n   | |      |  |
        Random |--->------------->------+  +----------+  | |\n   | |      |  +--------+
        |                  |   |  | Client   |  | |\n   | |      |      |      |                  |
        \  |  | Random   |  | |\n   | |      |      |      |                  |   |
        \ +----------+  | |\n   | |      |      |      |                  |   |        |
        \      | |\n   | |      V      V      |                  |   V        V       |
        |\n   | |   +------------+   |                  | +------------+     | |\n
        \  | +-->|  DSKPP PRF |   |                  | |  DSKPP PRF |<----+ |\n   |
        \    +------------+   |                  | +------------+       |\n   |           |
        \         |                  |       |              |\n   |           V          |
        \                 |       V              |\n   |       +-------+      |                  |
        \  +-------+          |\n   |       |  Key  |      |                  |   |
        \ Key  |          |\n   |       +-------+      |                  |   +-------+
        \         |\n   |       +-------+      |                  |   +-------+          |\n
        \  |       |Key Id |-------->------------->------|Key Id |          |\n   |
        \      +-------+      |                  |   +-------+          |\n   +----------------------+
        \                 +----------------------+\n         DSKPP Server                              DSKPP
        Client\n    Figure 3: Principal Data Flow for DSKPP Key Generation Using Public\n
        \                               Server Key\n   The inclusion of the two random
        nonces (R_S and R_C) in the key\n   generation provides assurance to both
        sides (the cryptographic module\n   and the DSKPP Server) that they have contributed
        to the key's\n   randomness and that the key is unique.  The inclusion of
        the\n   encryption key (K) ensures that no man in the middle may be present,\n
        \  or else the cryptographic module will end up with a key different\n   from
        the one stored by the legitimate DSKPP Server.\n   Conceptually, although
        R_C is one pseudorandom string, it may be\n   viewed as consisting of two
        components, R_C1 and R_C2, where R_C1 is\n   generated during the protocol
        run, and R_C2 can be pre-generated and\n   loaded on the cryptographic module
        before the device is issued to the\n   user.  In that case, the latter string,
        R_C2, SHOULD be unique for\n   each cryptographic module.\n   A man in the
        middle (in the form of corrupt client software or a\n   mistakenly contacted
        server) may present his own public key to the\n   cryptographic module.  This
        will enable the attacker to learn the\n   client's version of K_TOKEN.  However,
        the attacker is not able to\n   persuade the legitimate server to derive the
        same value for K_TOKEN,\n   since K_TOKEN is a function of the public key
        involved, and the\n   attacker's public key must be different than the correct
        server's (or\n   else the attacker would not be able to decrypt the information\n
        \  received from the client).  Therefore, once the attacker is no longer\n
        \  \"in the middle,\" the client and server will detect that they are \"out\n
        \  of sync\" when they try to use their keys.  In the case of encrypting\n
        \  R_C with K_SERVER, it is therefore important to verify that K_SERVER\n
        \  really is the legitimate server's key.  One way to do this is to\n   independently
        validate a newly generated K_TOKEN against some\n   validation service at
        the server (e.g., using a connection\n   independent from the one used for
        the key generation).\n"
      title: 4.1.1.  Data Flow
    - contents:
      - "4.1.2.  Computation\n   In four-pass DSKPP, the client and server both generate
        K_TOKEN and\n   K_MAC by deriving them from a provisioning key (K_PROV) using
        the\n   DSKPP-PRF (refer to Section 3.4.2) as follows:\n   K_PROV = DSKPP-PRF(k,s,dsLen),
        where\n       k = R_C (i.e., the secret random value chosen by the DSKPP\n
        \      Client)\n       s = \"Key generation\" || K || R_S (where K is the
        key used to\n       encrypt R_C and R_S is the random value chosen by the
        DSKPP\n       Server)\n       dsLen = (desired length of K_PROV whose first
        half constitutes\n       K_MAC and second half constitutes K_TOKEN)\n   Then,
        K_TOKEN and K_MAC are derived from K_PROV, where\n       K_PROV = K_MAC ||
        K_TOKEN\n   When computing K_PROV, the derived keys, K_MAC and K_TOKEN, MAY
        be\n   subject to an algorithm-dependent transform before being adopted as
        a\n   key of the selected type.  One example of this is the need for parity\n
        \  in DES keys.\n   Note that this computation pertains to four-pass DSKPP
        only.\n"
      title: 4.1.2.  Computation
    title: 4.1.  The Key Agreement Mechanism
  - contents:
    - "4.2.  Message Flow\n   The four-pass protocol flow consists of two message
      exchanges:\n   1:  Pass 1 = <KeyProvClientHello>, Pass 2 = <KeyProvServerHello>\n
      \  2:  Pass 3 = <KeyProvClientNonce>, Pass 4 = <KeyProvServerFinished>\n   The
      first pair of messages negotiate cryptographic algorithms and\n   exchange nonces.
      \ The second pair of messages establishes a symmetric\n   key using mutually
      authenticated key agreement.\n   The purpose and content of each message are
      described below.  XML\n   format and examples are in Section 8 and Appendix
      B.\n"
    - contents:
      - "4.2.1.  KeyProvTrigger\n           DSKPP Client                         DSKPP
        Server\n           ------------                         ------------\n                                [<---]
        \      AD, [DeviceID],\n                                            [KeyID],
        [URL_S]\n   When this message is sent:\n      The \"trigger\" message is optional.
        \ The DSKPP Server sends this\n      message after the following out-of-band
        steps are performed:\n      1.  A user directed their browser to a key provisioning
        web\n          application and signs in (i.e., authenticates).\n      2.  The
        user requests a key.\n      3.  The web application processes the request
        and returns an\n          Authentication Code to the user, e.g., in response
        to an\n          enrollment request via a secure web session.\n      4.  The
        web application retrieves the Authentication Code from the\n          user
        (possibly by asking the user to enter it using a web\n          form, or alternatively
        by the user selecting a URL in which\n          the Authentication Code is
        embedded).\n      5.  The web application derives Authentication Data (AD)
        from the\n          Authentication Code as described in Section 3.4.1.\n      6.
        \ The web application passes AD, and possibly a DeviceID\n          (identifies
        a particular device to which the key is to be\n          provisioned) and/or
        KeyID (identifies a key that will be\n          replaced) to the DSKPP Server.\n
        \  Purpose of this message:\n      To start a DSKPP session: The DSKPP Server
        uses this message to\n      trigger a client-side application to send the
        first DSKPP message.\n      To provide a way for the key provisioning system
        to get the DSKPP\n      Server URL to the DSKPP Client.\n      So the key
        provisioning system can point the DSKPP Client to a\n      particular cryptographic
        module that was pre-configured in the\n      DSKPP provisioning server.\n
        \     In the case of key renewal, to identify the key to be replaced.\n   What
        is contained in this message:\n      AD MUST be provided to allow the DSKPP
        Server to authenticate the\n      user before completing the protocol run.\n
        \     A DeviceID MAY be included to allow a key provisioning application\n
        \     to bind the provisioned key to a specific device.\n      A KeyID MAY
        be included to allow the key provisioning application\n      to identify a
        key to be replaced, e.g., in the case of key\n      renewal.\n      The Server
        URL MAY be included to allow the key provisioning\n      application to inform
        the DSKPP Client of which server to contact.\n"
      title: 4.2.1.  KeyProvTrigger
    - contents:
      - "4.2.2.  KeyProvClientHello\n           DSKPP Client                         DSKPP
        Server\n           ------------                         ------------\n           SAL,
        [AD],\n           [DeviceID], [KeyID]     --->\n   When this message is sent:\n
        \     When a DSKPP Client first connects to a DSKPP Server, it is\n      required
        to send the <KeyProvClientHello> as its first message.\n      The client can
        also send a <KeyProvClientHello> in response to a\n      <KeyProvTrigger>.\n
        \  What is contained in this message:\n      The Security Attribute List (SAL)
        included with\n      <KeyProvClientHello> contains the combinations of DSKPP
        versions,\n      variants, key package formats, key types, and cryptographic\n
        \     algorithms that the DSKPP Client supports in order of the client's\n
        \     preference (favorite choice first).\n      If <KeyProvClientHello> was
        preceded by a <KeyProvTrigger>, then\n      this message MUST also include
        the Authentication Data (AD),\n      DeviceID, and/or KeyID that was provided
        with the trigger.\n      If <KeyProvClientHello> was not preceded by a <KeyProvTrigger>,\n
        \     then this message MAY contain a DeviceID that was pre-shared with\n
        \     the DSKPP Server, and a key ID associated with a key previously\n      provisioned
        by the DSKPP provisioning server.\n   Application note:\n      If this message
        is preceded by trigger message <KeyProvTrigger>,\n      then the application
        will already have AD available (see\n      Section 4.2.1).  However, if this
        message was not preceded by\n      <KeyProvTrigger>, then the application
        MUST retrieve the User\n      Authentication Code, possibly by prompting the
        user to manually\n      enter their Authentication Code, e.g., on a device
        with only a\n      numeric keypad.\n      The application MUST also derive
        Authentication Data (AD) from the\n      Authentication Code, as described
        in Section 3.4.1, and save it\n      for use in its next message, <KeyProvClientNonce>.\n
        \  How the DSKPP Server uses this message:\n      The DSKPP Server will look
        for an acceptable combination of DSKPP\n      version, variant (in this case,
        four-pass), key package format,\n      key type, and cryptographic algorithms.
        \ If the DSKPP Client's SAL\n      does not match the capabilities of the
        DSKPP Server, or does not\n      comply with key provisioning policy, then
        the DSKPP Server will\n      set the Status attribute to something other than
        \"Continue\".\n      Otherwise, the Status attribute will be set to \"Continue\".\n
        \     If included in <KeyProvClientHello>, the DSKPP Server will\n      validate
        the Authentication Data (AD), DeviceID, and KeyID.  The\n      DSKPP Server
        MUST NOT accept the DeviceID unless the server sent\n      the DeviceID in
        a preceding trigger message.  Note that it is also\n      legitimate for a
        DSKPP Client to initiate the DSKPP run without\n      having received a <KeyProvTrigger>
        message from a server, but in\n      this case any provided DeviceID MUST
        NOT be accepted by the DSKPP\n      Server unless the server has access to
        a unique key for the\n      identified device and that key will be used in
        the protocol.\n"
      title: 4.2.2.  KeyProvClientHello
    - contents:
      - "4.2.3.  KeyProvServerHello\n           DSKPP Client                         DSKPP
        Server\n           ------------                         ------------\n                                 <---
        \   SAL, R_S, [K], [MAC]\n   When this message is sent:\n      The DSKPP Server
        will send this message in response to a\n      <KeyProvClientHello> message
        after it looks for an acceptable\n      combination of DSKPP version, variant
        (in this case, four-pass),\n      key package format, key type, and set of
        cryptographic algorithms.\n      If it could not find an acceptable combination,
        then it will still\n      send the message, but with a failure status.\n   Purpose
        of this message:\n      With this message, the context for the protocol run
        is set.\n      Furthermore, the DSKPP Server uses this message to transmit
        a\n      random nonce, which is required for each side to agree upon the\n
        \     same symmetric key (K_TOKEN).\n   What is contained in this message:\n
        \     A status attribute equivalent to the server's return code to\n      <KeyProvClientHello>.
        \ If the server found an acceptable set of\n      attributes from the client's
        SAL, then it sets status to Continue\n      and returns an SAL (selected from
        the SAL that it received in\n      <KeyProvClientHello>).  The Server's SAL
        specifies the DSKPP\n      version and variant (in this case, four-pass),
        key type,\n      cryptographic algorithms, and key package format that the
        DSKPP\n      Client MUST use for the remainder of the protocol run.\n      A
        random nonce (R_S) for use in generating a symmetric key through\n      key
        agreement; the length of R_S may depend on the selected key\n      type.\n
        \     A key (K) for the DSKPP Client to use for encrypting the client\n      nonce
        included with <KeyProvClientNonce>.  K represents the\n      server's public
        key (K_SERVER) or a pre-shared secret key\n      (K_SHARED).\n      A MAC
        MUST be present if a key is being renewed so that the DSKPP\n      Client
        can confirm that the replacement key came from a trusted\n      server.  This
        MAC MUST be computed using DSKPP-PRF (see\n      Section 3.4.2), where the
        input parameter k MUST be set to the\n      existing MAC key K_MAC' (i.e.,
        the value of the MAC key that\n      existed before this protocol run; the
        implementation MAY specify\n      K_MAC' to be the value of the K_TOKEN that
        is being replaced), and\n      input parameter dsLen MUST be set to the length
        of R_S.\n   How the DSKPP Client uses this message:\n      When the Status
        attribute is not set to \"Continue\", this indicates\n      failure and the
        DSKPP Client MUST abort the protocol.\n      If successful execution of the
        protocol will result in the\n      replacement of an existing key with a newly
        generated one, the\n      DSKPP Client MUST verify the MAC provided in <KeyProvServerHello>.\n
        \     The DSKPP Client MUST terminate the DSKPP session if the MAC does\n
        \     not verify, and MUST delete any nonces, keys, and/or secrets\n      associated
        with the failed run.\n      If the Status attribute is set to \"Continue\",
        the cryptographic\n      module generates a random nonce (R_C) using the cryptographic\n
        \     algorithm specified in the SAL.  The length of the nonce R_C will\n
        \     depend on the selected key type.\n      Encrypt R_C using K and the
        encryption algorithm included in the\n      SAL.\n   The method the DSKPP
        Client MUST use to encrypt R_C:\n      If K is equivalent to K_SERVER (i.e.,
        the public key of the DSKPP\n      Server), then an RSA encryption scheme
        from PKCS #1 [PKCS-1] MAY\n      be used.  If K is equivalent to K_SERVER,
        then the cryptographic\n      module SHOULD verify the server's certificate
        before using it to\n      encrypt R_C as described in [RFC2818], Section 3.1,
        and [RFC5280].\n      If K is equivalent to K_SHARED, the DSKPP Client MAY
        use the\n      DSKPP-PRF to avoid dependence on other algorithms.  In this
        case,\n      the client uses K_SHARED as input parameter k (K_SHARED SHOULD
        be\n      used solely for this purpose) as follows:\n      dsLen = len(R_C),
        where \"len\" is the length of R_C\n      DS = DSKPP-PRF(K_SHARED, \"Encryption\"
        || R_S, dsLen)\n      This will produce a pseudorandom string DS of length
        equal to R_C.\n      Encryption of R_C MAY then be achieved by XOR-ing DS
        with R_C:\n      E(DS, R_C) = DS ^ R_C\n      The DSKPP Server will then perform
        the reverse operation to\n      extract R_C from E(DS, R_C).\n"
      title: 4.2.3.  KeyProvServerHello
    - contents:
      - "4.2.4.  KeyProvClientNonce\n           DSKPP Client                         DSKPP
        Server\n           ------------                         ------------\n           E(K,R_C),
        AD          --->\n   When this message is sent:\n      The DSKPP Client will
        send this message immediately following a\n      <KeyProvServerHello> message
        whose status was set to \"Continue\".\n   Purpose of this message:\n      With
        this message the DSKPP Client transmits User Authentication\n      Data (AD)
        and a random nonce encrypted with the DSKPP Server's key\n      (K).  The
        client's random nonce is required for each side to agree\n      upon the same
        symmetric key (K_TOKEN).\n   What is contained in this message:\n      Authentication
        Data (AD) that was derived from an Authentication\n      Code entered by the
        user before <KeyProvClientHello> was sent\n      (refer to Section 3.2).\n
        \     The DSKPP Client's random nonce (R_C), which was encrypted as\n      described
        in Section 4.2.3.\n   How the DSKPP Server uses this message:\n      The DSKPP
        Server MUST use AD to authenticate the user.  If\n      authentication fails,
        then the DSKPP Server MUST set the return\n      code to a failure status.\n
        \     If user authentication passes, the DSKPP Server decrypts R_C using\n
        \     its key (K).  The decryption method is based on whether K that was\n
        \     transmitted to the client in <KeyProvServerHello> was equal to the\n
        \     server's public key (K_SERVER) or a pre-shared key (K_SHARED)\n      (refer
        to Section 4.2.3 for a description of how the DSKPP Client\n      encrypts
        R_C).\n      After extracting R_C, the DSKPP Server computes K_TOKEN using
        a\n      combination of the two random nonces R_S and R_C and its\n      encryption
        key, K, as described in Section 4.1.2.  The particular\n      realization
        of DSKPP-PRF (e.g., those defined in Appendix D)\n      depends on the MAC
        algorithm contained in the <KeyProvServerHello>\n      message.  The DSKPP
        Server then generates a key package that\n      contains key usage attributes
        such as expiry date and length.  The\n      key package MUST NOT include K_TOKEN
        since in the four-pass\n      variant K_TOKEN is never transmitted between
        the DSKPP Server and\n      Client.  The server stores K_TOKEN and the key
        package with the\n      user's account on the cryptographic server.\n      Finally,
        the server generates a key confirmation MAC that the\n      client will use
        to avoid a false \"Commit\" message that would cause\n      the cryptographic
        module to end up in state in which the server\n      does not recognize the
        stored key.\n   The MAC used for key confirmation MUST be calculated as follows:\n
        \     msg_hash = SHA-256(msg_1, ..., msg_n)\n      dsLen = len(msg_hash)\n
        \     MAC = DSKPP-PRF (K_MAC, \"MAC 1 computation\" || msg_hash, dsLen)\n
        \     where\n      MAC The DSKPP Pseudorandom Function defined in Section
        3.4.2 is\n          used to compute the MAC.  The particular realization of
        DSKPP-\n          PRF (e.g., those defined in Appendix D) depends on the MAC\n
        \         algorithm contained in the <KeyProvServerHello> message.  The\n
        \         MAC MUST be computed using the existing MAC key (K_MAC), and a\n
        \         string that is formed by concatenating the (ASCII) string \"MAC\n
        \         1 computation\" and a msg_hash.\n      K_MAC  The key derived from
        K_PROV, as described in Section 4.1.2.\n      msg_hash  The message hash (defined
        in Section 3.4.3) of messages\n                msg_1, ..., msg_n.\n"
      title: 4.2.4.  KeyProvClientNonce
    - contents:
      - "4.2.5.  KeyProvServerFinished\n           DSKPP Client                         DSKPP
        Server\n           ------------                         ------------\n                                  <---
        \              KP, MAC\n   When this message is sent:\n      The DSKPP Server
        will send this message after authenticating the\n      user and, if authentication
        passed, generating K_TOKEN and a key\n      package, and associating them
        with the user's account on the\n      cryptographic server.\n   Purpose of
        this message:\n      With this message, the DSKPP Server confirms generation
        of the key\n      (K_TOKEN) and transmits the associated identifier and application-\n
        \     specific attributes, but not the key itself, in a key package to\n      the
        client for protocol completion.\n   What is contained in this message:\n      A
        status attribute equivalent to the server's return code to\n      <KeyProvClientNonce>.
        \ If user authentication passed, and the\n      server successfully computed
        K_TOKEN, generated a key package, and\n      associated them with the user's
        account on the cryptographic\n      server, then it sets the Status attribute
        to \"Success\".\n      If the Status attribute is set to \"Success\", then
        this message\n      acts as a \"Commit\" message, instructing the cryptographic
        module\n      to store the generated key (K_TOKEN) and associate the given
        key\n      identifier with this key.  As such, a key package (KP) MUST be\n
        \     included in this message, which holds an identifier for the\n      generated
        key (but not the key itself) and additional\n      configuration, e.g., the
        identity of the DSKPP Server, key usage\n      attributes, etc.  The default
        symmetric key package format MUST be\n      based on the Portable Symmetric
        Key Container (PSKC) defined in\n      [RFC6030].  Alternative formats MAY
        include [RFC6031], PKCS #12\n      [PKCS-12], or PKCS #5 XML [PKCS-5-XML]
        format.\n      With KP, the server includes a key confirmation MAC that the\n
        \     client uses to avoid a false \"Commit\" message.  The MAC algorithm\n
        \     is the same DSKPP-PRF that was sent in the <KeyProvServerHello>\n      message.\n
        \  How the DSKPP Client uses this message:\n      When the Status attribute
        is not set to \"Success\", this indicates\n      failure and the DSKPP Client
        MUST abort the protocol.\n      After receiving a <KeyProvServerFinished>
        message with Status =\n      \"Success\", the DSKPP Client MUST verify the
        key confirmation MAC\n      that was transmitted with this message.  The DSKPP
        Client MUST\n      terminate the DSKPP session if the MAC does not verify,
        and MUST,\n      in this case, also delete any nonces, keys, and/or secrets\n
        \     associated with the failed run of the protocol.\n      If <KeyProvServerFinished>
        has Status = \"Success\", and the MAC was\n      verified, then the DSKPP
        Client MUST calculate K_TOKEN from the\n      combination of the two random
        nonces R_S and R_C and the server's\n      encryption key, K, as described
        in Section 4.1.2.  The DSKPP-PRF\n      is the same one used for MAC computation.
        \ The DSKPP Client\n      associates the key package contained in <KeyProvServerFinished>\n
        \     with the generated key, K_TOKEN, and stores this data permanently\n
        \     on the cryptographic module.\n      After this operation, it MUST NOT
        be possible to overwrite the key\n      unless knowledge of an authorizing
        key is proven through a MAC on\n      a later <KeyProvServerHello> (and <KeyProvServerFinished>)\n
        \     message.\n"
      title: 4.2.5.  KeyProvServerFinished
    title: 4.2.  Message Flow
  title: 4.  Four-Pass Protocol Usage
- contents:
  - "5.  Two-Pass Protocol Usage\n   This section describes the methods and message
    flow that comprise the\n   two-pass protocol variant.  Two-pass DSKPP is essentially
    a transport\n   of keying material from the DSKPP Server to the DSKPP Client.
    \ The\n   DSKPP Server transmits keying material in a key package formatted in\n
    \  accordance with [RFC6030], [RFC6031], PKCS #12 [PKCS-12], or PKCS #5\n   XML
    [PKCS-5-XML].\n   The keying material includes a provisioning master key, K_PROV,
    from\n   which the DSKPP Client derives two keys: the symmetric key to be\n   established
    in the cryptographic module, K_TOKEN, and a key, K_MAC,\n   used for key confirmation.
    \ The keying material also includes key\n   usage attributes, such as expiry date
    and length.\n   The DSKPP Server encrypts K_PROV to ensure that it is not exposed
    to\n   any other entity than the DSKPP Server and the cryptographic module\n   itself.
    \ The DSKPP Server uses any of three key protection methods to\n   encrypt K_PROV:
    Key Transport, Key Wrap, and Passphrase-Based Key\n   Wrap Key Protection methods.\n
    \  While the DSKPP Client and server may negotiate the key protection\n   method
    to use, the actual key protection is carried out in the\n   KeyPackage.  The format
    of a KeyPackage specifies how a key should be\n   protected using the three key
    protection methods.  The following\n   KeyPackage formats are defined for DSKPP:\n
    \  o  PSKC Key Container [RFC6030] at\n      urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container\n
    \  o  SKPC Key Container [RFC6031] at\n      urn:ietf:params:xml:ns:keyprov:dskpp:skpc-key-container\n
    \  o  PKCS12 Key Container [PKCS-12] at\n      urn:ietf:params:xml:ns:keyprov:dskpp:pkcs12-key-container\n
    \  o  PKCS5-XML Key Container [PKCS-5-XML] at\n      urn:ietf:params:xml:ns:keyprov:dskpp:pkcs5-xml-key-container\n
    \  Each of the key protection methods is described below.\n"
  - contents:
    - "5.1.  Key Protection Methods\n   This section introduces three key protection
      methods for the two-pass\n   variant.  Additional methods MAY be defined by
      external entities or\n   through the IETF process.\n"
    - contents:
      - "5.1.1.  Key Transport\n   Purpose of this method:\n      This method is intended
        for PKI-capable devices.  The DSKPP Server\n      encrypts keying material
        and transports it to the DSKPP Client.\n      The server encrypts the keying
        material using the public key of\n      the DSKPP Client, whose private key
        part resides in the\n      cryptographic module.  The DSKPP Client decrypts
        the keying\n      material and uses it to derive the symmetric key, K_TOKEN.\n
        \  This method is identified with the following URN:\n      urn:ietf:params:xml:schema:keyprov:dskpp:transport\n
        \  The DSKPP Server and Client MUST support the following mechanism:\n      http://www.w3.org/2001/04/xmlenc#rsa-1_5
        encryption mechanism\n      defined in [XMLENC].\n"
      title: 5.1.1.  Key Transport
    - contents:
      - "5.1.2.  Key Wrap\n   Purpose of this method:\n      This method is ideal
        for pre-keyed devices, e.g., SIM cards.  The\n      DSKPP Server encrypts
        keying material using a pre-shared key\n      wrapping key and transports
        it to the DSKPP Client.  The DSKPP\n      Client decrypts the keying material,
        and uses it to derive the\n      symmetric key, K_TOKEN.\n   This method is
        identified with the following URN:\n      urn:ietf:params:xml:schema:keyprov:dskpp:wrap\n
        \  The DSKPP Server and Client MUST support all of the following key\n   wrapping
        mechanisms:\n   AES128 KeyWrap\n      Refer to id-aes128-wrap in [RFC3394]
        and\n      http://www.w3.org/2001/04/xmlenc#kw-aes128 in [XMLENC]\n   AES128
        KeyWrap with Padding\n      Refer to id-aes128-wrap-pad in [RFC5649] and\n
        \     http://www.w3.org/2001/04/xmlenc#kw-aes128 in [XMLENC]\n   AES-CBC-128\n
        \     Refer to [FIPS197-AES] and\n      http://www.w3.org/2001/04/xmlenc#aes128-cbc
        in [XMLENC]\n"
      title: 5.1.2.  Key Wrap
    - contents:
      - "5.1.3.  Passphrase-Based Key Wrap\n   Purpose of this method:\n      This
        method is a variation of the Key Wrap Method that is\n      applicable to
        constrained devices with keypads, e.g., mobile\n      phones.  The DSKPP Server
        encrypts keying material using a\n      wrapping key derived from a user-provided
        passphrase, and\n      transports the encrypted material to the DSKPP Client.
        \ The DSKPP\n      Client decrypts the keying material, and uses it to derive
        the\n      symmetric key, K_TOKEN.\n      To preserve the property of not
        exposing K_TOKEN to any other\n      entity than the DSKPP Server and the
        cryptographic module itself,\n      the method SHOULD be employed only when
        the device contains\n      facilities (e.g., a keypad) for direct entry of
        the passphrase.\n   This method is identified with the following URN:\n      urn:ietf:params:xml:schema:keyprov:dskpp:passphrase-wrap\n
        \  The DSKPP Server and Client MUST support the following:\n      *  The PBES2
        password-based encryption scheme defined in [PKCS-5]\n         (and identified
        as\n         http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbes2
        in\n         [PKCS-5-XML]).\n      *  The PBKDF2 passphrase-based key derivation
        function also\n         defined in [PKCS-5] (and identified as\n         http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5#pbkdf2\n
        \        in [PKCS-5-XML]).\n      *  All of the following key wrapping mechanisms:\n
        \        AES128 KeyWrap\n            Refer to id-aes128-wrap in [RFC3394]
        and\n            http://www.w3.org/2001/04/xmlenc#kw-aes128 in [XMLENC]\n
        \        AES128 KeyWrap with Padding\n            Refer to id-aes128-wrap-pad
        in [RFC5649] and\n            http://www.w3.org/2001/04/xmlenc#kw-aes128 in
        [XMLENC]\n         AES-CBC-128\n            Refer to [FIPS197-AES] and\n            http://www.w3.org/2001/04/xmlenc#aes128-cbc
        in [XMLENC]\n"
      title: 5.1.3.  Passphrase-Based Key Wrap
    title: 5.1.  Key Protection Methods
  - contents:
    - "5.2.  Message Flow\n   The two-pass protocol flow consists of one exchange:\n
      \  1:  Pass 1 = <KeyProvClientHello>, Pass 2 = <KeyProvServerFinished>\n   Although
      there is no exchange of the <ServerHello> message or the\n   <ClientNonce> message,
      the DSKPP Client is still able to specify\n   algorithm preferences and supported
      key types in the\n   <KeyProvClientHello> message.\n   The purpose and content
      of each message are described below.  XML\n   format and examples are in Section
      8 and Appendix B.\n"
    - contents:
      - "5.2.1.  KeyProvTrigger\n   The trigger message is used in exactly the same
        way for the two-pass\n   variant as for the four-pass variant; refer to Section
        4.2.1.\n"
      title: 5.2.1.  KeyProvTrigger
    - contents:
      - "5.2.2.  KeyProvClientHello\n           DSKPP Client                         DSKPP
        Server\n           ------------                         ------------\n           SAL,
        AD, R_C,\n           [DeviceID], [KeyID],\n           KPML                   --->\n
        \  When this message is sent:\n      When a DSKPP Client first connects to
        a DSKPP Server, it is\n      required to send the <KeyProvClientHello> as
        its first message.\n      The client can also send <KeyProvClientHello> in
        response to a\n      <KeyProvTrigger> message.\n   Purpose of this message:\n
        \     With this message, the DSKPP Client specifies its algorithm\n      preferences
        and supported key types as well as which DSKPP\n      versions, protocol variants
        (in this case \"two-pass\"), key package\n      formats, and key protection
        methods that it supports.\n      Furthermore, the DSKPP Client facilitates
        user authentication by\n      transmitting the Authentication Data (AD) that
        was provided by the\n      user before the first DSKPP message was sent.\n
        \  Application note:\n      This message MUST send User Authentication Data
        (AD) to the DSKPP\n      Server.  If this message is preceded by trigger message\n
        \     <KeyProvTrigger>, then the application will already have AD\n      available
        (see Section 4.2.1).  However, if this message was not\n      preceded by
        <KeyProvTrigger>, then the application MUST retrieve\n      the User Authentication
        Code, possibly by prompting the user to\n      manually enter their Authentication
        Code, e.g., on a device with\n      only a numeric keypad.  The application
        MUST also derive\n      Authentication Data (AD) from the Authentication Code,
        as\n      described in Section 3.4.1, and save it for use in its next\n      message,
        <KeyProvClientNonce>.\n   What is contained in this message:\n      The Security
        Attribute List (SAL) included with\n      <KeyProvClientHello> contains the
        combinations of DSKPP versions,\n      variants, key package formats, key
        types, and cryptographic\n      algorithms that the DSKPP Client supports
        in order of the client's\n      preference (favorite choice first).\n      Authentication
        Data (AD) that was either included with\n      <KeyProvTrigger>, or generated
        as described in the \"Application\n      Note\" above.\n      The DSKPP Client's
        random nonce (R_C), which was used by the\n      client when generating AD.
        \ By inserting R_C into the DSKPP\n      session, the DSKPP Client is able
        to ensure the DSKPP Server is\n      live before committing the key.\n      If
        <KeyProvClientHello> was preceded by a <KeyProvTrigger>, then\n      this
        message MUST also include the DeviceID and/or KeyID that was\n      provided
        with the trigger.  Otherwise, if a trigger message did\n      not precede
        <KeyProvClientHello>, then this message MAY include a\n      DeviceID that
        was pre-shared with the DSKPP Server, and MAY\n      contain a key ID associated
        with a key previously provisioned by\n      the DSKPP provisioning server.\n
        \     The list of key protection methods (KPML) that the DSKPP Client\n      supports.
        \ Each item in the list MAY include an encryption key\n      \"payload\" for
        the DSKPP Server to use to protect keying material\n      that it sends back
        to the client.  The payload MUST be of type\n      <ds:KeyInfoType> ([XMLDSIG]).
        \ For each key protection method, the\n      allowable choices for <ds:KeyInfoType>
        are:\n      *  Key Transport\n         Only those choices of <ds:KeyInfoType>
        that identify a public\n         key (i.e., <ds:KeyName>, <ds:KeyValue>, <ds:X509Data>,
        or <ds:\n         PGPData>).  The <ds:X509Certificate> option of the <ds:\n
        \        X509Data> alternative is RECOMMENDED when the public key\n         corresponding
        to the private key on the cryptographic module\n         has been certified.\n
        \     *  Key Wrap\n         Only those choices of <ds:KeyInfoType> that identify
        a\n         symmetric key (i.e., <ds:KeyName> and <ds:KeyValue>).  The <ds:\n
        \        KeyName> alternative is RECOMMENDED.\n      *  Passphrase-Based Key
        Wrap\n         The <ds:KeyName> option MUST be used and the key name MUST\n
        \        identify the passphrase that will be used by the server to\n         generate
        the key wrapping key.  The identifier and passphrase\n         components
        of <ds:KeyName> MUST be set to the Client ID and\n         Authentication
        Code components of AD (same AD as contained in\n         this message).\n
        \  How the DSKPP Server uses this message:\n      The DSKPP Server will look
        for an acceptable combination of DSKPP\n      version, variant (in this case,
        two-pass), key package format, key\n      type, and cryptographic algorithms.
        \ If the DSKPP Client's SAL\n      does not match the capabilities of the
        DSKPP Server, or does not\n      comply with key provisioning policy, then
        the DSKPP Server will\n      set the Status attribute to something other than
        \"Success\".\n      Otherwise, the Status attribute will be set to \"Success\".\n
        \     The DSKPP Server will validate the DeviceID and KeyID if included\n
        \     in <KeyProvClientHello>.  The DSKPP Server MUST NOT accept the\n      DeviceID
        unless the server sent the DeviceID in a preceding\n      trigger message.
        \ Note that it is also legitimate for a DSKPP\n      Client to initiate the
        DSKPP run without having received a\n      <KeyProvTrigger> message from a
        server, but in this case any\n      provided DeviceID MUST NOT be accepted
        by the DSKPP Server unless\n      the server has access to a unique key for
        the identified device\n      and that key will be used in the protocol.\n
        \     The DSKPP Server MUST use AD to authenticate the user.  If\n      authentication
        fails, then the DSKPP Server MUST set the return\n      code to a failure
        status, and MUST, in this case, also delete any\n      nonces, keys, and/or
        secrets associated with the failed run of the\n      protocol.\n      If user
        authentication passes, the DSKPP Server generates a key\n      K_PROV.  In
        the two-pass case, wherein the client does not have\n      access to R_S,
        K_PROV is randomly generated solely by the DSKPP\n      Server wherein K_PROV
        MUST consist of two parts of equal length,\n      i.e.,\n         K_PROV =
        K_MAC || K_TOKEN\n      The length of K_TOKEN (and hence also the length of
        K_MAC) is\n      determined by the type of K_TOKEN, which MUST be one of the
        key\n      types supported by the DSKPP Client.  In cases where the desired\n
        \     key length for K_TOKEN is different from the length of K_MAC for\n      the
        underlying MAC algorithm, the greater length of the two MUST\n      be chosen
        to generate K_PROV.  The actual MAC key is truncated\n      from the resulting
        K_MAC when it is used in the MAC algorithm when\n      K_MAC is longer than
        necessary in order to match the desired\n      K_TOKEN length.  If K_TOKEN
        is longer than needed in order to\n      match the K_MAC length, the provisioning
        server and the receiving\n      client must determine the actual secret key
        length from the target\n      key algorithm and store only the truncated portion
        of the K_TOKEN.\n      The truncation MUST take the beginning bytes of the
        desired length\n      from K_TOKEN or K_MAC for the actual key.  For example,
        when a\n      provisioning server provisions an event based HOTP secret key
        with\n      length 20 and MAC algorithm DSKPP-PRF-SHA256 (Appendix D), K_PROV\n
        \     length will be 64.  The derived K_TOKEN and K_MAC will each\n      consist
        of 32 bytes.  The actual HOTP key should be the first 20\n      bytes of the
        K_TOKEN.\n      Once K_PROV is computed, the DSKPP Server selects one of the
        key\n      protection methods from the DSKPP Client's KPML, and uses that\n
        \     method and corresponding payload to encrypt K_PROV.  The DSKPP\n      Server
        generates a key package to transport the key encryption\n      method information
        and the encrypted provisioning key (K_PROV).\n      The encrypted data format
        is subject to the choice supported by\n      the selected key package.  The
        key package MUST specify and use\n      the selected key protection method
        and the key information that\n      was received in <KeyProvClientHello>.
        \ The key package also\n      includes key usage attributes such as expiry
        date and length.  The\n      server stores the key package and K_TOKEN with
        a user account on\n      the cryptographic server.\n      The server generates
        a MAC for key confirmation, which the client\n      will use to avoid a false
        \"Commit\" message that would cause the\n      cryptographic module to end
        up in state in which the server does\n      not recognize the stored key.\n
        \     In addition, if an existing key is being renewed, the server\n      generates
        a second MAC that it will return to the client as server\n      Authentication
        Data (AD) so that the DSKPP Client can confirm that\n      the replacement
        key came from a trusted server.\n   The method the DSKPP Server MUST use to
        calculate the key\n   confirmation MAC:\n      msg_hash = SHA-256(msg_1, ...,
        msg_n)\n      dsLen = len(msg_hash)\n      MAC = DSKPP-PRF (K_MAC, \"MAC 1
        computation\" || msg_hash ||\n      ServerID, dsLen)\n      where\n      MAC
        \        The MAC MUST be calculated using the already\n                  established
        MAC algorithm and MUST be computed on the\n                  (ASCII) string
        \"MAC 1 computation\", msg_hash, and\n                  ServerID using the
        existing MAC key K_MAC.\n      K_MAC       The key that is derived from K_PROV,
        which the DSKPP\n                  Server MUST provide to the cryptographic
        module.\n      msg_hash    The message hash, defined in Section 3.4.3, of\n
        \                 messages msg_1, ..., msg_n.\n      ServerID    The identifier
        that the DSKPP Server MUST include in\n                  the <KeyPackage>
        element of <KeyProvServerFinished>.\n      If DSKPP-PRF (defined in Section
        3.4.2) is used as the MAC\n      algorithm, then the input parameter s MUST
        consist of the\n      concatenation of the (ASCII) string \"MAC 1 computation\",
        msg_hash,\n      and ServerID, and the parameter dsLen MUST be set to the
        length of\n      msg_hash.\n   The method the DSKPP Server MUST use to calculate
        the server\n   authentication MAC:\n      The MAC MUST be computed on the
        (ASCII) string \"MAC 2\n      computation\", the server identifier ServerID,
        and R, using a pre-\n      existing MAC key K_MAC' (the MAC key that existed
        before this\n      protocol run).  Note that the implementation may specify
        K_MAC' to\n      be the value of the K_TOKEN that is being replaced.\n      If
        DSKPP-PRF is used as the MAC algorithm, then the input\n      parameter s
        MUST consist of the concatenation of the (ASCII)\n      string \"MAC 2 computation\"
        ServerID, and R.  The parameter dsLen\n      MUST be set to at least 16 (i.e.,
        the length of the MAC MUST be at\n      least 16 octets):\n      dsLen >=
        16\n      MAC = DSKPP-PRF (K_MAC', \"MAC 2 computation\" || ServerID || R,\n
        \     dsLen)\n      The MAC algorithm MUST be the same as the algorithm used
        by the\n      DSKPP Server to calculate the key confirmation MAC.\n"
      title: 5.2.2.  KeyProvClientHello
    - contents:
      - "5.2.3.  KeyProvServerFinished\n          DSKPP Client                         DSKPP
        Server\n           ------------                         ------------\n                                  <---
        \          KP, MAC, AD\n   When this message is sent:\n      The DSKPP Server
        will send this message after authenticating the\n      user and, if authentication
        passed, generating K_TOKEN and a key\n      package, and associating them
        with the user's account on the\n      cryptographic server.\n   Purpose of
        this message:\n      With this message, the DSKPP Server transports a key
        package\n      containing the encrypted provisioning key (K_PROV) and key
        usage\n      attributes.\n   What is contained in this message:\n      A Status
        attribute equivalent to the server's return code to\n      <KeyProvClientHello>.
        \ If the server found an acceptable set of\n      attributes from the client's
        SAL, then it sets Status to\n      \"Success\".\n      The confirmation message
        MUST include the Key Package (KP) that\n      holds the DSKPP Server's ID,
        key ID, key type, encrypted\n      provisioning key (K_PROV), encryption method,
        and additional\n      configuration information.  The default symmetric key
        package\n      format MUST be based on the Portable Symmetric Key Container\n
        \     (PSKC) defined in [RFC6030].  Alternative formats MAY include\n      [RFC6031],
        PKCS #12 [PKCS-12], or PKCS #5 XML [PKCS-5-XML].\n      This message MUST
        include a MAC that the DSKPP Client will use for\n      key confirmation.
        \ This key confirmation MAC is calculated using\n      the \"MAC 1 computation\"
        as described in the previous section.\n      Finally, if an existing key is
        being replaced, then this message\n      MUST also include a server authentication
        MAC (calculated using\n      the \"MAC 2 computation\" as described in the
        previous section),\n      which is passed as AD to the DSKPP Client.\n   How
        the DSKPP Client uses this message:\n      After receiving a <KeyProvServerFinished>
        message with Status =\n      \"Success\", the DSKPP Client MUST verify both
        MACs (MAC and AD).\n      The DSKPP Client MUST terminate the DSKPP run if
        either MAC does\n      not verify, and MUST, in this case, also delete any
        nonces, keys,\n      and/or secrets associated with the failed run of the
        protocol.\n      If <KeyProvServerFinished> has Status = \"Success\" and the
        MACs\n      were verified, then the DSKPP Client MUST extract K_PROV from
        the\n      provided key package, and derive K_TOKEN.  Finally, the DSKPP\n
        \     Client initializes the cryptographic module with K_TOKEN and the\n      corresponding
        key usage attributes.  After this operation, it MUST\n      NOT be possible
        to overwrite the key unless knowledge of an\n      authorizing key is proven
        through a MAC on a later\n      <KeyProvServerFinished> message.\n"
      title: 5.2.3.  KeyProvServerFinished
    title: 5.2.  Message Flow
  title: 5.  Two-Pass Protocol Usage
- contents:
  - "6.  Protocol Extensions\n   DSKPP has been designed to be extensible.  The sub-sections
    below\n   define two extensions that are included with the DSKPP schema.  Since\n
    \  it is possible that the use of extensions will harm interoperability,\n   protocol
    designers are advised to carefully consider the use of\n   extensions.  For example,
    if a particular implementation relies on\n   the presence of a proprietary extension,
    then it may not be able to\n   interoperate with independent implementations that
    have no knowledge\n   of this extension.\n   Extensions may be sent with any DSKPP
    message using the\n   ExtensionsType.  The ExtensionsType type is a list of Extensions\n
    \  containing type-value pairs that define optional features supported\n   by
    a DSKPP Client or server.  Each extension MAY be marked as\n   Critical by setting
    the Critical attribute of the Extension to\n   \"true\".  Unless an extension
    is marked as Critical, a receiving party\n   need not be able to interpret it;
    a receiving party is always free to\n   disregard any (non-critical) extensions.\n"
  - contents:
    - "6.1.  The ClientInfoType Extension\n   The ClientInfoType extension MAY contain
      any client-specific data\n   required of an application.  This extension MAY
      be present in a\n   <KeyProvClientHello> or <KeyProvClientNonce> message.  When
      present,\n   this extension MUST NOT be marked as Critical.\n   DSKPP Servers
      MUST support this extension.  DSKPP Servers MUST NOT\n   attempt to interpret
      the data it carries and, if received, MUST\n   include it unmodified in the
      current protocol run's next server\n   response.  DSKPP Servers need not retain
      the ClientInfoType data.\n"
    title: 6.1.  The ClientInfoType Extension
  - contents:
    - "6.2.  The ServerInfoType Extension\n   The ServerInfoType extension MAY contain
      any server-specific data\n   required of an application, e.g., state information.
      \ This extension\n   is only valid in <KeyProvServerHello> messages for which
      the Status\n   attribute is set to \"Continue\".  When present, this extension
      MUST\n   NOT be marked as Critical.\n   DSKPP Clients MUST support this extension.
      \ DSKPP Clients MUST NOT\n   attempt to interpret the data it carries and, if
      received, MUST\n   include it unmodified in the current protocol run's next
      client\n   request (i.e., the <KeyProvClientNonce> message).  DSKPP Clients
      need\n   not retain the ServerInfoType data.\n"
    title: 6.2.  The ServerInfoType Extension
  title: 6.  Protocol Extensions
- contents:
  - '7.  Protocol Bindings

    '
  - contents:
    - "7.1.  General Requirements\n   DSKPP assumes a reliable transport.\n"
    title: 7.1.  General Requirements
  - contents:
    - "7.2.  HTTP/1.1 Binding for DSKPP\n   This section presents a binding of the
      previous messages to HTTP/1.1\n   [RFC2616].  This HTTP binding is mandatory
      to implement, although\n   newer versions of the specification might define
      additional bindings\n   in the future.  Note that the HTTP client will normally
      be different\n   from the DSKPP Client (i.e., the HTTP client will \"proxy\"
      DSKPP\n   messages from the DSKPP Client to the DSKPP Server).  Likewise, on\n
      \  the HTTP server side, the DSKPP Server MAY receive DSKPP message from\n   a
      \"front-end\" HTTP server.  The DSKPP Server will be identified by a\n   specific
      URL, which may be pre-configured, or provided to the client\n   during initialization.\n"
    - contents:
      - "7.2.1.  Identification of DSKPP Messages\n   The MIME type for all DSKPP
        messages MUST be\n   application/dskpp+xml\n"
      title: 7.2.1.  Identification of DSKPP Messages
    - contents:
      - "7.2.2.  HTTP Headers\n   In order to avoid caching of responses carrying
        DSKPP messages by\n   proxies, the following holds:\n   o  When using HTTP/1.1,
        requesters SHOULD:\n      *  Include a Cache-Control header field set to \"no-cache,
        no-\n         store\".\n      *  Include a Pragma header field set to \"no-cache\".\n
        \  o  When using HTTP/1.1, responders SHOULD:\n      *  Include a Cache-Control
        header field set to \"no-cache, no-must-\n         revalidate, private\".\n
        \     *  Include a Pragma header field set to \"no-cache\".\n      *  NOT
        include a Validator, such as a Last-Modified or ETag\n         header.\n   To
        handle content negotiation, HTTP requests MAY include an HTTP\n   Accept header
        field.  This header field SHOULD should be identified\n   using the MIME type
        specified in Section 7.2.1.  The Accept header\n   MAY include additional
        content types defined by future versions of\n   this protocol.\n   There are
        no other restrictions on HTTP headers, besides the\n   requirement to set
        the Content-Type header value to the MIME type\n   specified in Section 7.2.1.\n"
      title: 7.2.2.  HTTP Headers
    - contents:
      - "7.2.3.  HTTP Operations\n   Persistent connections as defined in HTTP/1.1
        are OPTIONAL.  DSKPP\n   requests are mapped to HTTP requests with the POST
        method.  DSKPP\n   responses are mapped to HTTP responses.\n   For the four-pass
        DSKPP, messages within the protocol run are bound\n   together.  In particular,
        <KeyProvServerHello> is bound to the\n   preceding <KeyProvClientHello> by
        being transmitted in the\n   corresponding HTTP response. <KeyProvServerHello>
        MUST have a\n   SessionID attribute, and the SessionID attribute of the subsequent\n
        \  <KeyProvClientNonce> message MUST be identical.\n   <KeyProvServerFinished>
        is then once again bound to the rest through\n   HTTP (and possibly through
        a SessionID).\n"
      title: 7.2.3.  HTTP Operations
    - contents:
      - "7.2.4.  HTTP Status Codes\n   A DSKPP HTTP responder that refuses to perform
        a message exchange\n   with a DSKPP HTTP requester SHOULD return a 403 (Forbidden)
        response.\n   In this case, the content of the HTTP body is not significant.
        \ In\n   the case of an HTTP error while processing a DSKPP request, the HTTP\n
        \  server MUST return a 500 (Internal Server Error) response.  This type\n
        \  of error SHOULD be returned for HTTP-related errors detected before\n   control
        is passed to the DSKPP processor, or when the DSKPP processor\n   reports
        an internal error (for example, the DSKPP XML namespace is\n   incorrect,
        or the DSKPP schema cannot be located).  If a request is\n   received that
        is not a DSKPP Client message, the DSKPP responder MUST\n   return a 400 (Bad
        request) response.\n   In these cases (i.e., when the HTTP response code is
        4xx or 5xx), the\n   content of the HTTP body is not significant.\n   Redirection
        status codes (3xx) apply as usual.\n   Whenever the HTTP POST is successfully
        invoked, the DSKPP HTTP\n   responder MUST use the 200 status code and provide
        a suitable DSKPP\n   message (possibly with DSKPP error information included)
        in the HTTP\n   body.\n"
      title: 7.2.4.  HTTP Status Codes
    - contents:
      - "7.2.5.  HTTP Authentication\n   No support for HTTP/1.1 authentication is
        assumed.\n"
      title: 7.2.5.  HTTP Authentication
    - contents:
      - "7.2.6.  Initialization of DSKPP\n   If a user requests key initialization
        in a browsing session, and if\n   that request has an appropriate Accept header
        (e.g., to a specific\n   DSKPP Server URL), the DSKPP Server MAY respond by
        sending a DSKPP\n   initialization message in an HTTP response with Content-Type
        set\n   according to Section 7.2.1 and response code set to 200 (OK).  The\n
        \  initialization message MAY carry data in its body, such as the URL\n   for
        the DSKPP Client to use when contacting the DSKPP Server.  If the\n   message
        does carry data, the data MUST be a valid instance of a\n   <KeyProvTrigger>
        element.\n   Note that if the user's request was directed to some other resource,\n
        \  the DSKPP Server MUST NOT respond by combining the DSKPP content type\n
        \  with response code 200.  In that case, the DSKPP Server SHOULD\n   respond
        by sending a DSKPP initialization message in an HTTP response\n   with Content-Type
        set according to Section 7.2.1 and response code\n   set to 406 (Not Acceptable).\n"
      title: 7.2.6.  Initialization of DSKPP
    - contents:
      - "7.2.7.  Example Messages\n   a.  Initialization from DSKPP Server:\n       HTTP/1.1
        200 OK\n       Cache-Control: no-store\n       Content-Type: application/dskpp+xml\n
        \      Content-Length: <some value>\n       DSKPP initialization data in XML
        form...\n   b.  Initial request from DSKPP Client:\n       POST http://example.com/cgi-bin/DSKPP-server
        HTTP/1.1\n       Cache-Control: no-cache, no-store\n       Pragma: no-cache\n
        \      Host: www.example.com\n       Content-Type: application/dskpp+xml\n
        \      Content-Length: <some value>\n       DSKPP data in XML form (supported
        version, supported\n       algorithms...)\n   c.  Initial response from DSKPP
        Server:\n       HTTP/1.1 200 OK\n       Cache-Control: no-cache, no-must-revalidate,
        private\n       Pragma: no-cache\n       Content-Type: application/dskpp+xml\n
        \      Content-Length: <some value>\n       DSKPP data in XML form (server
        random nonce, server public key,\n       ...)\n"
      title: 7.2.7.  Example Messages
    title: 7.2.  HTTP/1.1 Binding for DSKPP
  title: 7.  Protocol Bindings
- contents:
  - '8.  DSKPP XML Schema

    '
  - contents:
    - "8.1.  General Processing Requirements\n   Some DSKPP elements rely on the parties
      being able to compare\n   received values with stored values.  Unless otherwise
      noted, all\n   elements that have the XML schema \"xs:string\" type, or a type
      derived\n   from it, MUST be compared using an exact binary comparison.  In\n
      \  particular, DSKPP implementations MUST NOT depend on case-insensitive\n   string
      comparisons, normalization or trimming of white space, or\n   conversion of
      locale-specific formats such as numbers.\n   Implementations that compare values
      that are represented using\n   different character encodings MUST use a comparison
      method that\n   returns the same result as converting both values to the Unicode\n
      \  character encoding [UNICODE] and then performing an exact binary\n   comparison.\n
      \  No collation or sorting order for attributes or element values is\n   defined.
      \ Therefore, DSKPP implementations MUST NOT depend on\n   specific sorting orders
      for values.\n"
    title: 8.1.  General Processing Requirements
  - contents:
    - "8.2.  Schema\n    <?xml version=\"1.0\" encoding=\"utf-8\"?>\n    <xs:schema\n
      \      xmlns:xs=\"http://www.w3.org/2001/XMLSchema\"\n       xmlns:dskpp=\"urn:ietf:params:xml:ns:keyprov:dskpp\"\n
      \      xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\"\n       xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\n
      \      targetNamespace=\"urn:ietf:params:xml:ns:keyprov:dskpp\"\n       elementFormDefault=\"qualified\"
      attributeFormDefault=\"unqualified\"\n          version=\"1.0\">\n       <xs:import
      namespace=\"http://www.w3.org/2000/09/xmldsig#\"\n          schemaLocation=\n
      \         \"http://www.w3.org/TR/2002/REC-xmldsig-core-20020212/\n          xmldsig-core-schema.xsd\"/>\n
      \      <xs:import namespace=\"urn:ietf:params:xml:ns:keyprov:pskc\"\n          schemaLocation=\"keyprov-pskc-1.0.xsd\"/>\n
      \      <xs:complexType name=\"AbstractRequestType\" abstract=\"true\">\n          <xs:annotation>\n
      \            <xs:documentation> Basic types </xs:documentation>\n          </xs:annotation>\n
      \         <xs:attribute name=\"Version\" type=\"dskpp:VersionType\"\n             use=\"required\"/>\n
      \      </xs:complexType>\n       <xs:complexType name=\"AbstractResponseType\"
      abstract=\"true\">\n          <xs:annotation>\n             <xs:documentation>
      Basic types </xs:documentation>\n          </xs:annotation>\n          <xs:attribute
      name=\"Version\" type=\"dskpp:VersionType\"\n             use=\"required\"/>\n
      \         <xs:attribute name=\"SessionID\" type=\"dskpp:IdentifierType\" />\n
      \         <xs:attribute name=\"Status\" type=\"dskpp:StatusCode\"\n             use=\"required\"/>\n
      \      </xs:complexType>\n       <xs:simpleType name=\"VersionType\">\n          <xs:restriction
      base=\"xs:string\">\n             <xs:pattern value=\"\\d{1,2}\\.\\d{1,3}\"
      />\n          </xs:restriction>\n       </xs:simpleType>\n       <xs:simpleType
      name=\"IdentifierType\">\n          <xs:restriction base=\"xs:string\">\n             <xs:maxLength
      value=\"128\" />\n          </xs:restriction>\n       </xs:simpleType>\n       <xs:simpleType
      name=\"StatusCode\">\n          <xs:restriction base=\"xs:string\">\n             <xs:enumeration
      value=\"Continue\" />\n             <xs:enumeration value=\"Success\" />\n             <xs:enumeration
      value=\"Abort\" />\n             <xs:enumeration value=\"AccessDenied\" />\n
      \            <xs:enumeration value=\"MalformedRequest\" />\n             <xs:enumeration
      value=\"UnknownRequest\" />\n             <xs:enumeration value=\"UnknownCriticalExtension\"
      />\n             <xs:enumeration value=\"UnsupportedVersion\" />\n             <xs:enumeration
      value=\"NoSupportedKeyTypes\" />\n             <xs:enumeration value=\"NoSupportedEncryptionAlgorithms\"
      />\n             <xs:enumeration value=\"NoSupportedMacAlgorithms\" />\n             <xs:enumeration
      value=\"NoProtocolVariants\" />\n             <xs:enumeration value=\"NoSupportedKeyPackages\"
      />\n             <xs:enumeration value=\"AuthenticationDataMissing\" />\n             <xs:enumeration
      value=\"AuthenticationDataInvalid\" />\n             <xs:enumeration value=\"InitializationFailed\"
      />\n             <xs:enumeration value=\"ProvisioningPeriodExpired\" />\n          </xs:restriction>\n
      \      </xs:simpleType>\n       <xs:complexType name=\"DeviceIdentifierDataType\">\n
      \         <xs:choice>\n             <xs:element name=\"DeviceId\" type=\"pskc:DeviceInfoType\"
      />\n             <xs:any namespace=\"##other\" processContents=\"strict\" />\n
      \         </xs:choice>\n       </xs:complexType>\n       <xs:simpleType name=\"PlatformType\">\n
      \         <xs:restriction base=\"xs:string\">\n             <xs:enumeration
      value=\"Hardware\" />\n             <xs:enumeration value=\"Software\" />\n
      \            <xs:enumeration value=\"Unspecified\" />\n          </xs:restriction>\n
      \      </xs:simpleType>\n       <xs:complexType name=\"TokenPlatformInfoType\">\n
      \         <xs:attribute name=\"KeyLocation\"\n             type=\"dskpp:PlatformType\"/>\n
      \         <xs:attribute name=\"AlgorithmLocation\"\n             type=\"dskpp:PlatformType\"/>\n
      \      </xs:complexType>\n       <xs:simpleType name=\"NonceType\">\n          <xs:restriction
      base=\"xs:base64Binary\">\n             <xs:minLength value=\"16\" />\n          </xs:restriction>\n
      \      </xs:simpleType>\n       <xs:complexType name=\"AlgorithmsType\">\n          <xs:sequence
      maxOccurs=\"unbounded\">\n             <xs:element name=\"Algorithm\" type=\"dskpp:AlgorithmType\"/>\n
      \         </xs:sequence>\n       </xs:complexType>\n       <xs:simpleType name=\"AlgorithmType\">\n
      \         <xs:restriction base=\"xs:anyURI\" />\n       </xs:simpleType>\n       <xs:complexType
      name=\"ProtocolVariantsType\">\n          <xs:sequence>\n             <xs:element
      name=\"FourPass\" minOccurs=\"0\" />\n             <xs:element name=\"TwoPass\"\n
      \               type=\"dskpp:KeyProtectionDataType\" minOccurs=\"0\"/>\n          </xs:sequence>\n
      \      </xs:complexType>\n       <xs:complexType name=\"KeyProtectionDataType\">\n
      \         <xs:annotation>\n             <xs:documentation xml:lang=\"en\">\n
      \               This element is only valid for two-pass DSKPP.\n             </xs:documentation>\n
      \         </xs:annotation>\n          <xs:sequence maxOccurs=\"unbounded\">\n
      \           <xs:element name=\"SupportedKeyProtectionMethod\"\n               type=\"xs:anyURI\"/>\n
      \           <xs:element name=\"Payload\"\n               type=\"dskpp:PayloadType\"
      minOccurs=\"0\"/>\n          </xs:sequence>\n       </xs:complexType>\n       <xs:complexType
      name=\"PayloadType\">\n          <xs:choice>\n             <xs:element name=\"Nonce\"
      type=\"dskpp:NonceType\" />\n             <xs:any namespace=\"##other\" processContents=\"strict\"/>\n
      \         </xs:choice>\n       </xs:complexType>\n       <xs:complexType name=\"KeyPackagesFormatType\">\n
      \         <xs:sequence maxOccurs=\"unbounded\">\n             <xs:element name=\"KeyPackageFormat\"\n
      \               type=\"dskpp:KeyPackageFormatType\"/>\n          </xs:sequence>\n
      \      </xs:complexType>\n       <xs:simpleType name=\"KeyPackageFormatType\">\n
      \         <xs:restriction base=\"xs:anyURI\" />\n       </xs:simpleType>\n       <xs:complexType
      name=\"AuthenticationDataType\">\n          <xs:annotation>\n             <xs:documentation
      xml:lang=\"en\">\n                Authentication Data contains a MAC.\n             </xs:documentation>\n
      \         </xs:annotation>\n          <xs:sequence>\n             <xs:element
      name=\"ClientID\"\n                type=\"dskpp:IdentifierType\" minOccurs=\"0\"/>\n
      \            <xs:choice>\n                <xs:element name=\"AuthenticationCodeMac\"\n
      \                  type=\"dskpp:AuthenticationMacType\"/>\n                <xs:any
      namespace=\"##other\" processContents=\"strict\" />\n             </xs:choice>\n
      \         </xs:sequence>\n       </xs:complexType>\n       <xs:complexType name=\"AuthenticationMacType\">\n
      \         <xs:sequence>\n             <xs:element minOccurs=\"0\" name=\"Nonce\"\n
      \               type=\"dskpp:NonceType\"/>\n             <xs:element minOccurs=\"0\"
      name=\"IterationCount\"\n                type=\"xs:int\"/>\n             <xs:element
      name=\"Mac\" type=\"dskpp:MacType\" />\n          </xs:sequence>\n       </xs:complexType>\n
      \      <xs:complexType name=\"MacType\">\n          <xs:simpleContent>\n             <xs:extension
      base=\"xs:base64Binary\">\n                <xs:attribute name=\"MacAlgorithm\"
      type=\"xs:anyURI\"/>\n             </xs:extension>\n          </xs:simpleContent>\n
      \      </xs:complexType>\n       <xs:complexType name=\"KeyPackageType\">\n
      \         <xs:sequence>\n             <xs:element minOccurs=\"0\" name=\"ServerID\"\n
      \               type=\"xs:anyURI\"/>\n             <xs:element minOccurs=\"0\"
      name=\"KeyProtectionMethod\"\n                type=\"xs:anyURI\" />\n             <xs:choice>\n
      \               <xs:element name=\"KeyContainer\"\n                   type=\"pskc:KeyContainerType\"/>\n
      \               <xs:any namespace=\"##other\" processContents=\"strict\"/>\n
      \            </xs:choice>\n          </xs:sequence>\n       </xs:complexType>\n
      \      <xs:complexType name=\"InitializationTriggerType\">\n          <xs:sequence>\n
      \            <xs:element minOccurs=\"0\" name=\"DeviceIdentifierData\"\n                type=\"dskpp:DeviceIdentifierDataType\"
      />\n             <xs:element minOccurs=\"0\" name=\"KeyID\"\n                type=\"xs:base64Binary\"/>\n
      \            <xs:element minOccurs=\"0\" name=\"TokenPlatformInfo\"\n                type=\"dskpp:TokenPlatformInfoType\"
      />\n             <xs:element name=\"AuthenticationData\"\n                type=\"dskpp:AuthenticationDataType\"
      />\n             <xs:element minOccurs=\"0\" name=\"ServerUrl\"\n                type=\"xs:anyURI\"/>\n
      \            <xs:any minOccurs=\"0\" namespace=\"##other\"\n                processContents=\"strict\"
      />\n          </xs:sequence>\n       </xs:complexType>\n       <xs:complexType
      name=\"ExtensionsType\">\n          <xs:annotation>\n             <xs:documentation>
      Extension types </xs:documentation>\n          </xs:annotation>\n          <xs:sequence
      maxOccurs=\"unbounded\">\n             <xs:element name=\"Extension\"\n                type=\"dskpp:AbstractExtensionType\"/>\n
      \         </xs:sequence>\n       </xs:complexType>\n       <xs:complexType name=\"AbstractExtensionType\"
      abstract=\"true\">\n          <xs:attribute name=\"Critical\" type=\"xs:boolean\"
      />\n       </xs:complexType>\n       <xs:complexType name=\"ClientInfoType\">\n
      \         <xs:complexContent mixed=\"false\">\n             <xs:extension base=\"dskpp:AbstractExtensionType\">\n
      \               <xs:sequence>\n                   <xs:element name=\"Data\"
      type=\"xs:base64Binary\"/>\n                </xs:sequence>\n             </xs:extension>\n
      \         </xs:complexContent>\n       </xs:complexType>\n       <xs:complexType
      name=\"ServerInfoType\">\n          <xs:complexContent mixed=\"false\">\n             <xs:extension
      base=\"dskpp:AbstractExtensionType\">\n                <xs:sequence>\n                   <xs:element
      name=\"Data\" type=\"xs:base64Binary\"/>\n                </xs:sequence>\n             </xs:extension>\n
      \         </xs:complexContent>\n       </xs:complexType>\n       <xs:element
      name=\"KeyProvTrigger\"\n          type=\"dskpp:KeyProvTriggerType\">\n          <xs:annotation>\n
      \            <xs:documentation> DSKPP PDUs </xs:documentation>\n          </xs:annotation>\n
      \      </xs:element>\n       <xs:complexType name=\"KeyProvTriggerType\">\n
      \         <xs:annotation>\n          <xs:documentation xml:lang=\"en\">\n             Message
      used to trigger the device to initiate a\n             DSKPP run.\n          </xs:documentation>\n
      \         </xs:annotation>\n          <xs:sequence>\n             <xs:choice>\n
      \               <xs:element name=\"InitializationTrigger\"\n                   type=\"dskpp:InitializationTriggerType\"
      />\n                <xs:any namespace=\"##other\" processContents=\"strict\"/>\n
      \            </xs:choice>\n          </xs:sequence>\n          <xs:attribute
      name=\"Version\" type=\"dskpp:VersionType\"/>\n       </xs:complexType>\n       <xs:element
      name=\"KeyProvClientHello\"\n          type=\"dskpp:KeyProvClientHelloPDU\">\n
      \         <xs:annotation>\n             <xs:documentation>KeyProvClientHello
      PDU</xs:documentation>\n          </xs:annotation>\n       </xs:element>\n       <xs:complexType
      name=\"KeyProvClientHelloPDU\">\n          <xs:annotation>\n             <xs:documentation
      xml:lang=\"en\">\n                Message sent from DSKPP Client to DSKPP Server
      to\n                initiate a DSKPP session.\n             </xs:documentation>\n
      \         </xs:annotation>\n          <xs:complexContent mixed=\"false\">\n
      \            <xs:extension base=\"dskpp:AbstractRequestType\">\n                <xs:sequence>\n
      \                  <xs:element minOccurs=\"0\" name=\"DeviceIdentifierData\"\n
      \                     type=\"dskpp:DeviceIdentifierDataType\" />\n                   <xs:element
      minOccurs=\"0\" name=\"KeyID\"\n                      type=\"xs:base64Binary\"
      />\n                   <xs:element minOccurs=\"0\" name=\"ClientNonce\"\n                      type=\"dskpp:NonceType\"
      />\n                   <xs:element name=\"SupportedKeyTypes\"\n                      type=\"dskpp:AlgorithmsType\"
      />\n                   <xs:element name=\"SupportedEncryptionAlgorithms\"\n
      \                     type=\"dskpp:AlgorithmsType\" />\n                   <xs:element
      name=\"SupportedMacAlgorithms\"\n                      type=\"dskpp:AlgorithmsType\"
      />\n                   <xs:element minOccurs=\"0\"\n                      name=\"SupportedProtocolVariants\"\n
      \                     type=\"dskpp:ProtocolVariantsType\" />\n                   <xs:element
      minOccurs=\"0\" name=\"SupportedKeyPackages\"\n                      type=\"dskpp:KeyPackagesFormatType\"
      />\n                   <xs:element minOccurs=\"0\" name=\"AuthenticationData\"\n
      \                     type=\"dskpp:AuthenticationDataType\" />\n                   <xs:element
      minOccurs=\"0\" name=\"Extensions\"\n                      type=\"dskpp:ExtensionsType\"
      />\n                </xs:sequence>\n             </xs:extension>\n          </xs:complexContent>\n
      \      </xs:complexType>\n       <xs:element name=\"KeyProvServerHello\"\n          type=\"dskpp:KeyProvServerHelloPDU\">\n
      \         <xs:annotation>\n             <xs:documentation>KeyProvServerHello
      PDU</xs:documentation>\n          </xs:annotation>\n       </xs:element>\n       <xs:complexType
      name=\"KeyProvServerHelloPDU\">\n          <xs:annotation>\n             <xs:documentation
      xml:lang=\"en\">\n                Response message sent from DSKPP Server to
      DSKPP Client\n                in four-pass DSKPP.\n             </xs:documentation>\n
      \         </xs:annotation>\n          <xs:complexContent mixed=\"false\">\n
      \            <xs:extension base=\"dskpp:AbstractResponseType\">\n                <xs:sequence
      minOccurs=\"0\">\n                   <xs:element name=\"KeyType\"\n                      type=\"dskpp:AlgorithmType\"/>\n
      \                  <xs:element name=\"EncryptionAlgorithm\"\n                      type=\"dskpp:AlgorithmType\"
      />\n                   <xs:element name=\"MacAlgorithm\"\n                      type=\"dskpp:AlgorithmType\"/>\n
      \                  <xs:element name=\"EncryptionKey\"\n                      type=\"ds:KeyInfoType\"/>\n
      \                  <xs:element name=\"KeyPackageFormat\"\n                      type=\"dskpp:KeyPackageFormatType\"
      />\n                   <xs:element name=\"Payload\" type=\"dskpp:PayloadType\"/>\n
      \                  <xs:element minOccurs=\"0\" name=\"Extensions\"\n                      type=\"dskpp:ExtensionsType\"
      />\n                   <xs:element minOccurs=\"0\" name=\"Mac\"\n                      type=\"dskpp:MacType\"/>\n
      \               </xs:sequence>\n             </xs:extension>\n          </xs:complexContent>\n
      \      </xs:complexType>\n       <xs:element name=\"KeyProvClientNonce\"\n          type=\"dskpp:KeyProvClientNoncePDU\">\n
      \         <xs:annotation>\n             <xs:documentation>KeyProvClientNonce
      PDU</xs:documentation>\n          </xs:annotation>\n       </xs:element>\n       <xs:complexType
      name=\"KeyProvClientNoncePDU\">\n          <xs:annotation>\n             <xs:documentation
      xml:lang=\"en\">\n                Response message sent from DSKPP Client to\n
      \               DSKPP Server in a four-pass DSKPP session.\n             </xs:documentation>\n
      \         </xs:annotation>\n          <xs:complexContent mixed=\"false\">\n
      \            <xs:extension base=\"dskpp:AbstractRequestType\">\n                <xs:sequence>\n
      \                  <xs:element name=\"EncryptedNonce\"\n                      type=\"xs:base64Binary\"/>\n
      \                  <xs:element minOccurs=\"0\" name=\"AuthenticationData\"\n
      \                     type=\"dskpp:AuthenticationDataType\" />\n                   <xs:element
      minOccurs=\"0\" name=\"Extensions\"\n                      type=\"dskpp:ExtensionsType\"
      />\n                </xs:sequence>\n                <xs:attribute name=\"SessionID\"\n
      \                  type=\"dskpp:IdentifierType\" use=\"required\"/>\n             </xs:extension>\n
      \         </xs:complexContent>\n       </xs:complexType>\n       <xs:element
      name=\"KeyProvServerFinished\"\n          type=\"dskpp:KeyProvServerFinishedPDU\">\n
      \         <xs:annotation>\n             <xs:documentation>\n                KeyProvServerFinished
      PDU\n             </xs:documentation>\n          </xs:annotation>\n       </xs:element>\n
      \      <xs:complexType name=\"KeyProvServerFinishedPDU\">\n          <xs:annotation>\n
      \            <xs:documentation xml:lang=\"en\">\n                Final message
      sent from DSKPP Server to DSKPP Client in\n                a DSKPP session.
      \ A MAC value serves for key\n                confirmation, and optional AuthenticationData
      serves for\n                server authentication.\n             </xs:documentation>\n
      \         </xs:annotation>\n          <xs:complexContent mixed=\"false\">\n
      \            <xs:extension base=\"dskpp:AbstractResponseType\">\n                <xs:sequence
      minOccurs=\"0\">\n                   <xs:element name=\"KeyPackage\"\n                      type=\"dskpp:KeyPackageType\"
      />\n                   <xs:element minOccurs=\"0\" name=\"Extensions\"\n                      type=\"dskpp:ExtensionsType\"
      />\n                   <xs:element name=\"Mac\" type=\"dskpp:MacType\" />\n
      \                  <xs:element minOccurs=\"0\" name=\"AuthenticationData\"\n
      \                     type=\"dskpp:AuthenticationMacType\" />\n                </xs:sequence>\n
      \            </xs:extension>\n          </xs:complexContent>\n       </xs:complexType>\n
      \    </xs:schema>\n"
    title: 8.2.  Schema
  title: 8.  DSKPP XML Schema
- contents:
  - "9.  Conformance Requirements\n   In order to assure that all implementations
    of DSKPP can\n   interoperate, the DSKPP Server:\n   a.  MUST implement the four-pass
    variation of the protocol\n       (Section 4)\n   b.  MUST implement the two-pass
    variation of the protocol (Section 5)\n   c.  MUST support user authentication
    (Section 3.2.1)\n   d.  MUST support the following key derivation functions:\n
    \      *  DSKPP-PRF-AES DSKPP-PRF realization (Appendix D)\n       *  DSKPP-PRF-SHA256
    DSKPP-PRF realization (Appendix D)\n   e.  MUST support the following encryption
    mechanisms for protection\n       of the client nonce in the four-pass protocol:\n
    \      *  Mechanism described in Section 4.2.4\n   f.  MUST support one of the
    following encryption algorithms for\n       symmetric key operations, e.g., key
    wrap:\n       *  KW-AES128 without padding; refer to\n          http://www.w3.org/2001/04/xmlenc#kw-aes128
    in [XMLENC]\n       *  KW-AES128 with padding; refer to\n          http://www.w3.org/2001/04/xmlenc#kw-aes128
    in [XMLENC] and\n          [RFC5649]\n       *  AES-CBC-128; refer to [FIPS197-AES]\n
    \  g.  MUST support the following encryption algorithms for asymmetric\n       key
    operations, e.g., key transport:\n       *  RSA Encryption Scheme [PKCS-1]\n   h.
    \ MUST support the following integrity/KDF MAC functions:\n       *  DSKPP-PRF-AES
    (Appendix D)\n       *  DSKPP-PRF-SHA256 (Appendix D)\n   i.  MUST support the
    PSKC key package [RFC6030]; all three PSKC key\n       protection methods (Key
    Transport, Key Wrap, and Passphrase-Based\n       Key Wrap) MUST be implemented\n
    \  j.  MAY support the ASN.1 key package as defined in [RFC6031]\n   DSKPP Clients
    MUST support either the two-pass or the four-pass\n   variant of the protocol.
    \ DSKPP Clients MUST fulfill all requirements\n   listed in item (c) - (j).\n
    \  Finally, implementations of DSKPP MUST bind DSKPP messages to\n   HTTP/1.1
    as described in Section 7.2.\n   Of course, DSKPP is a security protocol, and
    one of its major\n   functions is to allow only authorized parties to successfully\n
    \  initialize a cryptographic module with a new symmetric key.\n   Therefore,
    a particular implementation may be configured with any of\n   a number of restrictions
    concerning algorithms and trusted\n   authorities that will prevent universal
    interoperability.\n"
  title: 9.  Conformance Requirements
- contents:
  - '10.  Security Considerations

    '
  - contents:
    - "10.1.  General\n   DSKPP is designed to protect generated keying material from
      exposure.\n   No entities other than the DSKPP Server and the cryptographic
      module\n   will have access to a generated K_TOKEN if the cryptographic\n   algorithms
      used are of sufficient strength and, on the DSKPP Client\n   side, generation
      and encryption of R_C and generation of K_TOKEN take\n   place as specified
      in the cryptographic module.  This applies even if\n   malicious software is
      present in the DSKPP Client.  However, as\n   discussed in the following sub-sections,
      DSKPP does not protect\n   against certain other threats resulting from man-in-the-middle\n
      \  attacks and other forms of attacks.  DSKPP MUST, therefore, be run\n   over
      a transport providing confidentiality and integrity, such as\n   HTTP over Transport
      Layer Security (TLS) with a suitable ciphersuite\n   [RFC2818], when such threats
      are a concern.  Note that TLS\n   ciphersuites with anonymous key exchanges
      are not suitable in those\n   situations [RFC5246].\n"
    title: 10.1.  General
  - contents:
    - '10.2.  Active Attacks

      '
    - contents:
      - "10.2.1.  Introduction\n   An active attacker MAY attempt to modify, delete,
        insert, replay, or\n   reorder messages for a variety of purposes including
        service denial\n   and compromise of generated keying material.\n"
      title: 10.2.1.  Introduction
    - contents:
      - "10.2.2.  Message Modifications\n   Modifications to a <KeyProvTrigger> message
        will either cause denial\n   of service (modifications of any of the identifiers
        or the\n   Authentication Code) or will cause the DSKPP Client to contact
        the\n   wrong DSKPP Server.  The latter is in effect a man-in-the-middle\n
        \  attack and is discussed further in Section 10.2.7.\n   An attacker may
        modify a <KeyProvClientHello> message.  This means\n   that the attacker could
        indicate a different key or device than the\n   one intended by the DSKPP
        Client, and could also suggest other\n   cryptographic algorithms than the
        ones preferred by the DSKPP Client,\n   e.g., cryptographically weaker ones.
        \ The attacker could also suggest\n   earlier versions of DSKPP, in case these
        versions have been shown to\n   have vulnerabilities.  These modifications
        could lead to an attacker\n   succeeding in initializing or modifying another
        cryptographic module\n   than the one intended (i.e., the server assigning
        the generated key\n   to the wrong module) or gaining access to a generated
        key through the\n   use of weak cryptographic algorithms or protocol versions.
        \ DSKPP\n   implementations MAY protect against the latter by having strict\n
        \  policies about what versions and algorithms they support and accept.\n
        \  The former threat (assignment of a generated key to the wrong module)\n
        \  is not possible when the shared-key variant of DSKPP is employed\n   (assuming
        existing shared keys are unique per cryptographic module),\n   but is possible
        in the public key variation.  Therefore, DSKPP\n   Servers MUST NOT accept
        unilaterally provided device identifiers in\n   the public key variation.
        \ This is also indicated in the protocol\n   description.  In the shared-key
        variation, however, an attacker may\n   be able to provide the wrong identifier
        (possibly also leading to the\n   incorrect user being associated with the
        generated key) if the\n   attacker has real-time access to the cryptographic
        module with the\n   identified key.  The result of this attack could be that
        the\n   generated key is associated with the correct cryptographic module
        but\n   the module is associated with the incorrect user.  See Section 10.5\n
        \  for a further discussion of this threat and possible countermeasures.\n
        \  An attacker may also modify a <KeyProvServerHello> message.  This\n   means
        that the attacker could indicate different key types,\n   algorithms, or protocol
        versions than the legitimate server would,\n   e.g., cryptographically weaker
        ones.  The attacker may also provide a\n   different nonce than the one sent
        by the legitimate server.  Clients\n   MAY protect against the former through
        strict adherence to policies\n   regarding permissible algorithms and protocol
        versions.  The latter\n   (wrong nonce) will not constitute a security problem,
        as a generated\n   key will not match the key generated on the legitimate
        server.  Also,\n   whenever the DSKPP run would result in the replacement
        of an existing\n   key, the <Mac> element protects against modifications of
        R_S.\n   Modifications of <KeyProvClientNonce> messages are also possible.
        \ If\n   an attacker modifies the SessionID attribute, then, in effect, a\n
        \  switch to another session will occur at the server, assuming the new\n
        \  SessionID is valid at that time on the server.  It still will not\n   allow
        the attacker to learn a generated K_TOKEN since R_C has been\n   wrapped for
        the legitimate server.  Modifications of the\n   <EncryptedNonce> element,
        e.g., replacing it with a value for which\n   the attacker knows an underlying
        R'C, will not result in the client\n   changing its pre-DSKPP state, since
        the server will be unable to\n   provide a valid MAC in its final message
        to the client.  The server\n   MAY, however, end up storing K'TOKEN rather
        than K_TOKEN.  If the\n   cryptographic module has been associated with a
        particular user, then\n   this could constitute a security problem.  For a
        further discussion\n   about this threat, and a possible countermeasure, see
        Section 10.5\n   below.  Note that use of TLS does not protect against this
        attack if\n   the attacker has access to the DSKPP Client (e.g., through malicious\n
        \  software, \"Trojans\") [RFC5246].\n   Finally, attackers may also modify
        the <KeyProvServerFinished>\n   message.  Replacing the <Mac> element will
        only result in denial of\n   service.  Replacement of any other element may
        cause the DSKPP Client\n   to associate, e.g., the wrong service with the
        generated key.  DSKPP\n   SHOULD be run over a transport providing confidentiality
        and\n   integrity when this is a concern.\n"
      title: 10.2.2.  Message Modifications
    - contents:
      - "10.2.3.  Message Deletion\n   Message deletion will not cause any other harm
        than denial of\n   service, since a cryptographic module MUST NOT change its
        state\n   (i.e., \"commit\" to a generated key) until it receives the final\n
        \  message from the DSKPP Server and successfully has processed that\n   message,
        including validation of its MAC.  A deleted\n   <KeyProvServerFinished> message
        will not cause the server to end up\n   in an inconsistent state vis-a-vis
        the cryptographic module if the\n   server implements the suggestions in Section
        10.5.\n"
      title: 10.2.3.  Message Deletion
    - contents:
      - "10.2.4.  Message Insertion\n   An active attacker may initiate a DSKPP run
        at any time, and suggest\n   any device identifier.  DSKPP Server implementations
        MAY receive some\n   protection against inadvertently initializing a key or
        inadvertently\n   replacing an existing key or assigning a key to a cryptographic\n
        \  module by initializing the DSKPP run by use of the <KeyProvTrigger>.\n
        \  The <AuthenticationData> element allows the server to associate a\n   DSKPP
        run e.g., with an earlier user-authenticated session.  The\n   security of
        this method, therefore, depends on the ability to protect\n   the <AuthenticationData>
        element in the DSKPP initialization message.\n   If an eavesdropper is able
        to capture this message, he may race the\n   legitimate user for a key initialization.
        \ DSKPP over a transport\n   providing confidentiality and integrity, coupled
        with the\n   recommendations in Section 10.5, is RECOMMENDED when this is
        a\n   concern.\n   Insertion of other messages into an existing protocol run
        is seen as\n   equivalent to modification of legitimately sent messages.\n"
      title: 10.2.4.  Message Insertion
    - contents:
      - "10.2.5.  Message Replay\n   During four-pass DSKPP, attempts to replay a
        previously recorded\n   DSKPP message will be detected, as the use of nonces
        ensures that\n   both parties are live.  For example, a DSKPP Client knows
        that a\n   server it is communicating with is \"live\" since the server MUST\n
        \  create a MAC on information sent by the client.\n   The same is true for
        two-pass DSKPP thanks to the requirement that\n   the client sends R in the
        <KeyProvClientHello> message and that the\n   server includes R in the MAC
        computation.\n"
      title: 10.2.5.  Message Replay
    - contents:
      - "10.2.6.  Message Reordering\n   An attacker may attempt to re-order four-pass
        DSKPP messages but this\n   will be detected, as each message is of a unique
        type.  Note: Message\n   re-ordering attacks cannot occur in two-pass DSKPP
        since each party\n   sends at most one message each.\n"
      title: 10.2.6.  Message Reordering
    - contents:
      - "10.2.7.  Man in the Middle\n   In addition to other active attacks, an attacker
        posing as a man in\n   the middle may be able to provide his own public key
        to the DSKPP\n   Client.  This threat and countermeasures to it are discussed
        in\n   Section 4.1.1.  An attacker posing as a man in the middle may also
        be\n   acting as a proxy and, hence, may not interfere with DSKPP runs but\n
        \  still learn valuable information; see Section 10.3.\n"
      title: 10.2.7.  Man in the Middle
    title: 10.2.  Active Attacks
  - contents:
    - "10.3.  Passive Attacks\n   Passive attackers may eavesdrop on DSKPP runs to
      learn information\n   that later on may be used to impersonate users, mount
      active attacks,\n   etc.\n   If DSKPP is not run over a transport providing
      confidentiality, a\n   passive attacker may learn:\n   o  What cryptographic
      modules a particular user possesses\n   o  The identifiers of keys on those
      cryptographic modules and other\n      attributes pertaining to those keys,
      e.g., the lifetime of the\n      keys\n   o  DSKPP versions and cryptographic
      algorithms supported by a\n      particular DSKPP Client or server\n   o  Any
      value present in an <extension> that is part of\n      <KeyProvClientHello>\n
      \  Whenever the above is a concern, DSKPP MUST be run over a transport\n   providing
      confidentiality.  If man-in-the-middle attacks for the\n   purposes described
      above are a concern, the transport MUST also offer\n   server-side authentication.\n"
    title: 10.3.  Passive Attacks
  - contents:
    - "10.4.  Cryptographic Attacks\n   An attacker with unlimited access to an initialized
      cryptographic\n   module may use the module as an \"oracle\" to pre-compute
      values that\n   later on may be used to impersonate the DSKPP Server.  Section
      4.1.1\n   contains a discussion of this threat and steps RECOMMENDED to protect\n
      \  against it.\n   Implementers are advised that cryptographic algorithms become
      weaker\n   with time.  As new cryptographic techniques are developed and\n   computing
      performance improves, the work factor to break a particular\n   cryptographic
      algorithm will reduce.  Therefore, cryptographic\n   algorithm implementations
      SHOULD be modular allowing new algorithms\n   to be readily inserted.  That
      is, implementers SHOULD be prepared to\n   regularly update the algorithms in
      their implementations.\n"
    title: 10.4.  Cryptographic Attacks
  - contents:
    - "10.5.  Attacks on the Interaction between DSKPP and User Authentication\n   If
      keys generated in DSKPP will be associated with a particular user\n   at the
      DSKPP Server (or a server trusted by, and communicating with\n   the DSKPP Server),
      then in order to protect against threats where an\n   attacker replaces a client-provided
      encrypted R_C with his own R'C\n   (regardless of whether the public key variation
      or the shared-secret\n   variation of DSKPP is employed to encrypt the client
      nonce), the\n   server SHOULD NOT commit to associate a generated K_TOKEN with
      the\n   given cryptographic module until the user simultaneously has proven\n
      \  both possession of the device that hosts the cryptographic module\n   containing
      K_TOKEN and some out-of-band provided authenticating\n   information (e.g.,
      an Authentication Code).  For example, if the\n   cryptographic module is a
      one-time password token, the user could be\n   required to authenticate with
      both a one-time password generated by\n   the cryptographic module and an out-of-band
      provided Authentication\n   Code in order to have the server \"commit\" to the
      generated OTP value\n   for the given user.  Preferably, the user SHOULD perform
      this\n   operation from another host than the one used to initialize keys on\n
      \  the cryptographic module, in order to minimize the risk of malicious\n   software
      on the client interfering with the process.\n   Note: This scenario, wherein
      the attacker replaces a client-provided\n   R_C with his own R'C, does not apply
      to two-pass DSKPP as the client\n   does not provide any entropy to K_TOKEN.
      \ The attack as such (and its\n   countermeasures) still applies to two-pass
      DSKPP, however, as it\n   essentially is a man-in-the-middle attack.\n   Another
      threat arises when an attacker is able to trick a user into\n   authenticating
      to the attacker rather than to the legitimate service\n   before the DSKPP run.
      \ If successful, the attacker will then be able\n   to impersonate the user
      towards the legitimate service, and\n   subsequently receive a valid DSKPP trigger.
      \ If the public key\n   variant of DSKPP is used, this may result in the attacker
      being able\n   to (after a successful DSKPP run) impersonate the user.  Ordinary\n
      \  precautions MUST, therefore, be in place to ensure that users\n   authenticate
      only to legitimate services.\n"
    title: 10.5.  Attacks on the Interaction between DSKPP and User Authentication
  - contents:
    - '10.6.  Miscellaneous Considerations

      '
    - contents:
      - "10.6.1.  Client Contributions to K_TOKEN Entropy\n   In four-pass DSKPP,
        both the client and the server provide\n   randomizing material to K_TOKEN,
        in a manner that allows both parties\n   to verify that they did contribute
        to the resulting key.  In the two-\n   pass DSKPP version defined herein,
        only the server contributes to the\n   entropy of K_TOKEN.  This means that
        a broken or compromised\n   (pseudo)random number generator in the server
        may cause more damage\n   than it would in the four-pass variant.  Server
        implementations\n   SHOULD therefore take extreme care to ensure that this
        situation does\n   not occur.\n"
      title: 10.6.1.  Client Contributions to K_TOKEN Entropy
    - contents:
      - "10.6.2.  Key Confirmation\n   four-pass DSKPP Servers provide key confirmation
        through the MAC on\n   R_C in the <KeyProvServerFinished> message.  In the
        two-pass DSKPP\n   variant described herein, key confirmation is provided
        by the MAC\n   including R, using K_MAC.\n"
      title: 10.6.2.  Key Confirmation
    - contents:
      - "10.6.3.  Server Authentication\n   DSKPP Servers MUST authenticate themselves
        whenever a successful\n   DSKPP two-pass protocol run would result in an existing
        K_TOKEN being\n   replaced by a K_TOKEN', or else a denial-of-service attack
        where an\n   unauthorized DSKPP Server replaces a K_TOKEN with another key
        would\n   be possible.  In two-pass DSKPP, servers authenticate by including\n
        \  the AuthenticationDataType extension containing a MAC as described in\n
        \  Section 5 for two-pass DSKPP.\n   Whenever a successful DSKPP two-pass
        protocol run would result in an\n   existing K_TOKEN being replaced by a K_TOKEN',
        the DSKPP Client and\n   Server MUST do the following to prevent a denial-of-service
        attack\n   where an unauthorized DSKPP Server replaces a K_TOKEN with another\n
        \  key:\n   o  The DSKPP Server MUST use the AuthenticationDataType extension
        to\n      transmit a second MAC, calculated as described in Section 5.2.2.\n
        \  o  The DSKPP Client MUST authenticate the server using the MAC\n      contained
        in the AuthenticationDataType extension received from\n      the DSKPP Server
        to which it is connected.\n"
      title: 10.6.3.  Server Authentication
    - contents:
      - "10.6.4.  User Authentication\n   A DSKPP Server MUST authenticate a client
        to ensure that K_TOKEN is\n   delivered to the intended device.  The following
        measures SHOULD be\n   considered:\n   o  When an Authentication Code is used
        for client authentication, a\n      password dictionary attack on the Authentication
        Data is possible.\n   o  The length of the Authentication Code when used over
        a non-secure\n      channel SHOULD be longer than what is used over a secure
        channel.\n      When a device, e.g., some mobile phones with small screens,
        cannot\n      handle a long Authentication Code in a user-friendly manner,
        DSKPP\n      SHOULD rely on a secure channel for communication.\n   o  In
        the case that a non-secure channel has to be used, the\n      Authentication
        Code SHOULD be sent to the server MAC'd as\n      specified in Section 3.4.1.
        \ The Authentication Code and nonce\n      value MUST be strong enough to
        prevent offline brute-force\n      recovery of the Authentication Code from
        the Hashed MAC (HMAC)\n      data.  Given that the nonce value is sent in
        plaintext format over\n      a non-secure transport, the cryptographic strength
        of the\n      Authentication Data depends more on the quality of the\n      Authentication
        Code.\n   o  When the Authentication Code is sent from the DSKPP Server to
        the\n      device in a DSKPP initialization trigger message, an eavesdropper\n
        \     may be able to capture this message and race the legitimate user\n      for
        a key initialization.  To prevent this, the transport layer\n      used to
        send the DSKPP trigger MUST provide confidentiality and\n      integrity,
        e.g. a secure browser session.\n"
      title: 10.6.4.  User Authentication
    - contents:
      - "10.6.5.  Key Protection in Two-Pass DSKPP\n   Three key protection methods
        are defined for the different usages of\n   two-pass DSKPP, which MUST be
        supported by a key package format, such\n   as [RFC6030] and [RFC6031].  Therefore,
        key protection in the two-\n   pass DSKPP is dependent upon the security of
        the key package format\n   selected for a protocol run.  Some considerations
        for the Passphrase-\n   Based Key Wrap method follow.\n   The Passphrase-Based
        Key Wrap method SHOULD depend upon the PBKDF2\n   function from [PKCS-5] to
        generate an encryption key from a\n   passphrase and salt string.  It is important
        to note that passphrase-\n   based encryption is generally limited in the
        security that it\n   provides despite the use of salt and iteration count
        in PBKDF2 to\n   increase the complexity of attack.  Implementations SHOULD
        therefore\n   take additional measures to strengthen the security of the\n
        \  Passphrase-Based Key Wrap method.  The following measures SHOULD be\n   considered
        where applicable:\n   o  The passphrase is the same as the one-time password
        component of\n      the Authentication Code (see Section 3.4.1) for a description
        of\n      the AC format).  The passphrase SHOULD be selected well, and usage\n
        \     guidelines such as the ones in [NIST-PWD] SHOULD be taken into\n      account.\n
        \  o  A different passphrase SHOULD be used for every key initialization\n
        \     wherever possible (the use of a global passphrase for a batch of\n      cryptographic
        modules SHOULD be avoided, for example).  One way to\n      achieve this is
        to use randomly generated passphrases.\n   o  The passphrase SHOULD be protected
        well if stored on the server\n      and/or on the cryptographic module and
        SHOULD be delivered to the\n      device's user using secure methods.\n   o
        \ User pre-authentication SHOULD be implemented to ensure that\n      K_TOKEN
        is not delivered to a rogue recipient.\n   o  The iteration count in PBKDF2
        SHOULD be high to impose more work\n      for an attacker using brute-force
        methods (see [PKCS-5] for\n      recommendations).  However, it MUST be noted
        that the higher the\n      count, the more work is required on the legitimate
        cryptographic\n      module to decrypt the newly delivered K_TOKEN.  Servers
        MAY use\n      relatively low iteration counts to accommodate devices with\n
        \     limited processing power such as some PDA and cell phones when\n      other
        security measures are implemented and the security of the\n      Passphrase-Based
        Key Wrap method is not weakened.\n   o  TLS [RFC5246] SHOULD be used where
        possible to protect a two-pass\n      protocol run.  Transport level security
        provides a second layer of\n      protection for the newly generated K_TOKEN.\n"
      title: 10.6.5.  Key Protection in Two-Pass DSKPP
    - contents:
      - "10.6.6.  Algorithm Agility\n   Many protocols need to be algorithm agile.
        \ One reason for this is\n   that in the past many protocols had fixed sized
        fields for\n   information such as hash outputs, keys, etc.  This is not the
        case\n   for DSKPP, except for the key size in the computation of DSKPP-PRF.\n
        \  Another reason was that protocols did not support algorithm\n   negotiation.
        \ This is also not the case for DSKPP, except for the use\n   of SHA-256 in
        the MAC confirmation message.  Updating the key size\n   for DSKPP-PRF or
        the MAC confirmation message algorithm will require\n   a new version of the
        protocol, which is supported with the Version\n   attribute.\n"
      title: 10.6.6.  Algorithm Agility
    title: 10.6.  Miscellaneous Considerations
  title: 10.  Security Considerations
- contents:
  - "11.  Internationalization Considerations\n   DSKPP is meant for machine-to-machine
    communications; as such, its\n   elements are tokens not meant for direct human
    consumption.  DSKPP\n   exchanges information using XML.  All XML processors are
    required to\n   understand UTF-8 [RFC3629] encoding, and therefore all DSKPP Clients\n
    \  and servers MUST understand UTF-8 encoded XML.  Additionally, DSKPP\n   Servers
    and clients MUST NOT encode XML with encodings other than\n   UTF-8.\n"
  title: 11.  Internationalization Considerations
- contents:
  - "12.  IANA Considerations\n   This document requires several IANA registrations,
    detailed below.\n"
  - contents:
    - "12.1.  URN Sub-Namespace Registration\n   This section registers a new XML
      namespace,\n   \"urn:ietf:params:xml:ns:keyprov:dskpp\" per the guidelines in\n
      \  [RFC3688]:\n   URI:  urn:ietf:params:xml:ns:keyprov:dskpp\n   Registrant
      Contact:\n      IETF, KEYPROV Working Group (keyprov@ietf.org), Andrea Doherty\n
      \     (andrea.doherty@rsa.com)\n   XML:\n      BEGIN\n         <?xml version=\"1.0\"?>\n
      \        <!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Strict//EN\"\n            \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd\">\n
      \        <html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\">\n         <head>\n
      \           <title>DSKPP Messages</title>\n         </head>\n         <body>\n
      \           <h1>Namespace for DSKPP Messages</h1>\n            <h2>urn:ietf:params:xml:ns:keyprov:dskpp</h2>\n
      \           <p>See RFC 6063</p>\n         </body>\n         </html>\n      END\n"
    title: 12.1.  URN Sub-Namespace Registration
  - contents:
    - "12.2.  XML Schema Registration\n   This section registers an XML schema as
      per the guidelines in\n   [RFC3688].\n   URI:  urn:ietf:params:xml:ns:keyprov:dskpp\n
      \  Registrant Contact:\n      IETF, KEYPROV Working Group (keyprov@ietf.org),
      Andrea Doherty\n      (andrea.doherty@rsa.com)\n   Schema:\n      The XML for
      this schema can be found as the entirety of Section 8\n      of this document.\n"
    title: 12.2.  XML Schema Registration
  - contents:
    - "12.3.  MIME Media Type Registration\n   This section registers the \"application/dskpp+xml\"
      MIME type:\n   To:  ietf-types@iana.org\n   Subject:  Registration of MIME media
      type application/dskpp+xml\n   MIME media type name:  application\n   MIME subtype
      name:  dskpp+xml\n   Required parameters:  (none)\n   Optional parameters:  charset\n
      \     Indicates the character encoding of enclosed XML.\n   Encoding considerations:
      \ Uses XML, which can employ 8-bit\n      characters, depending on the character
      encoding used.  See\n      [RFC3023], Section 3.2.  Implementations need to
      support UTF-8\n      [RFC3629].\n   Security considerations:  This content type
      is designed to carry\n      protocol data related to key management.  Security
      mechanisms are\n      built into the protocol to ensure that various threats
      are dealt\n      with.  Refer to Section 10 of RFC 6063 for more details\n   Interoperability
      considerations:  None\n   Published specification:  RFC 6063.\n   Applications
      that use this media type:  Protocol for key exchange.\n   Additional information:\n
      \     Magic Number(s): (none)\n      File extension(s): .xmls\n      Macintosh
      File Type Code(s): (none)\n   Person & email address to contact for further
      information:\n      Andrea Doherty (andrea.doherty@rsa.com)\n   Intended usage:
      \ LIMITED USE\n   Author/Change controller:  The IETF\n   Other information:
      \ This media type is a specialization of\n      application/xml [RFC3023], and
      many of the considerations\n      described there also apply to application/dskpp+xml.\n"
    title: 12.3.  MIME Media Type Registration
  - contents:
    - "12.4.  Status Code Registration\n   This section registers status codes included
      in each DSKPP response\n   message.  The status codes are defined in the schema
      in the\n   <StatusCode> type definition contained in the XML schema in\n   Section
      8.  The following summarizes the registry:\n   Related Registry:\n      KEYPROV
      DSKPP Registries, Status codes for DSKPP\n   Defining RFC:\n      RFC 6063.\n
      \  Registration/Assignment Procedures:\n      Following the policies outlined
      in [RFC3575], the IANA policy for\n      assigning new values for the status
      codes for DSKPP MUST be\n      \"Specification Required\" and their meanings
      MUST be documented in\n      an RFC or in some other permanent and readily available
      reference,\n      in sufficient detail that interoperability between independent\n
      \     implementations is possible.  No mechanism to mark entries as\n      \"deprecated\"
      is envisioned.  It is possible to update entries from\n      the registry.\n
      \  Registrant Contact:\n      IETF, KEYPROV working group (keyprov@ietf.org),\n
      \     Andrea Doherty (andrea.doherty@rsa.com)\n"
    title: 12.4.  Status Code Registration
  - contents:
    - "12.5.  DSKPP Version Registration\n   This section registers DSKPP version
      numbers.  The registry has the\n   following structure:\n   +-------------------------------------------+\n
      \  |  DSKPP Version    | Specification         |\n   +-------------------------------------------+\n
      \  |  1.0              | This document         |\n   +-------------------------------------------+\n
      \  Standards action is required to define new versions of DSKPP.  It is\n   not
      envisioned to deprecate, delete, or modify existing DSKPP\n   versions.\n"
    title: 12.5.  DSKPP Version Registration
  - contents:
    - "12.6.  PRF Algorithm ID Sub-Registry\n   This specification relies on a cryptographic
      primitive, called\n   \"DSKPP-PRF\" that provides a deterministic transformation
      of a secret\n   key k and a varying length octet string s to a bit string of\n
      \  specified length dsLen.  From the point of view of this\n   specification,
      DSKPP-PRF is a \"black-box\" function that, given the\n   inputs, generates
      a pseudorandom value that can be realized by any\n   appropriate and competent
      cryptographic technique.  Section 3.4.2\n   provides two realizations of DSKPP-PRF,
      DSKPP-PRF-AES, and DSKPP-PRF-\n   SHA256.\n   This section registers the identifiers
      associated with these\n   realizations.  PRF Algorithm ID Sub-registries are
      to be subject to\n   \"Specification Required\" as per RFC 5226 [RFC5226].  Updates
      MUST be\n   documented in an RFC or in some other permanent and readily available\n
      \  reference, in sufficient detail that interoperability between\n   independent
      implementations is possible.\n   Expert approval is required to deprecate a
      sub-registry.  Once\n   deprecated, the PRF Algorithm ID SHOULD NOT be used
      in any new\n   implementations.\n"
    - contents:
      - "12.6.1.  DSKPP-PRF-AES\n   This section registers the following in the IETF
        XML namespace\n   registry.\n   Common Name:\n      DSKPP-PRF-AES\n   URI:\n
        \     urn:ietf:params:xml:ns:keyprov:dskpp:prf-aes-128\n   Identifier Definition:\n
        \     The DSKPP-PRF-AES algorithm realization is defined in\n      Appendix
        D.2.2 of this document.\n   Registrant Contact:\n      IETF, KEYPROV working
        group (keyprov@ietf.org),\n      Andrea Doherty (andrea.doherty@rsa.com)\n"
      title: 12.6.1.  DSKPP-PRF-AES
    - contents:
      - "12.6.2.  DSKPP-PRF-SHA256\n   This section registers the following in the
        IETF XML namespace\n   registry.\n   Common Name:\n      DSKPP-PRF-SHA256\n
        \  URI:\n      urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256\n   Identifier
        Definition:\n      The DSKPP-PRF-SHA256 algorithm realization is defined in\n
        \     Appendix D.3.2 of this document.\n   Registrant Contact:\n      IETF,
        KEYPROV working group (keyprov@ietf.org),\n      Andrea Doherty (andrea.doherty@rsa.com)\n"
      title: 12.6.2.  DSKPP-PRF-SHA256
    title: 12.6.  PRF Algorithm ID Sub-Registry
  - contents:
    - "12.7.  Key Container Registration\n   This section registers the Key Container
      type.\n   Key Container:\n      The registration name for the Key Container.\n
      \  Specification:\n      Key Container defines a key package format that specifies
      how a\n      key should be protected using the three key protection methods\n
      \     provided in Section 5.1.\n   Registration Procedure:\n      Following
      the policies outlined in [RFC3575], the IANA policy for\n      assigning new
      values for the status codes for DSKPP MUST be\n      \"Specification Required\"
      and their meanings MUST be documented in\n      an RFC or in some other permanent
      and readily available reference,\n      in sufficient detail that interoperability
      between independent\n      implementations is possible.\n   Deprecated:\n      TRUE
      if based on expert approval this entry has been deprecated\n      and SHOULD
      NOT be used in any new implementations.  Otherwise,\n      FALSE.\n   Identifiers:\n
      \     The initial URIs for the Key Container defined for this version of\n      the
      document are listed here:\n      Name:  PSKC Key Container\n      URI:  urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container\n
      \     Specification:  [RFC6030]\n      Deprecated:  FALSE\n      Name:  SKPC
      Key Container\n      URI:  urn:ietf:params:xml:ns:keyprov:dskpp:skpc-key-container\n
      \     Specification:  [RFC6031]\n      Deprecated:  FALSE\n      Name:  PKCS12
      Key Container\n      URI:  urn:ietf:params:xml:ns:keyprov:dskpp:pkcs12-key-container\n
      \     Specification:  [PKCS-12]\n      Deprecated:  FALSE\n      Name:  PKCS5-XML
      Key Container\n      URI:  urn:ietf:params:xml:ns:keyprov:dskpp:pkcs5-xml-key-container\n
      \     Specification:  [PKCS-5-XML]\n      Deprecated:  FALSE\n   Registrant
      Contact:\n      IETF, KEYPROV working group (keyprov@ietf.org),\n      Andrea
      Doherty (andrea.doherty@rsa.com)\n"
    title: 12.7.  Key Container Registration
  title: 12.  IANA Considerations
- contents:
  - "13.  Intellectual Property Considerations\n   RSA and RSA Security are registered
    trademarks or trademarks of RSA\n   Security, Inc. in the United States and/or
    other countries.  The\n   names of other products and services mentioned may be
    the trademarks\n   of their respective owners.\n"
  title: 13.  Intellectual Property Considerations
- contents:
  - "14.  Contributors\n   This work is based on information contained in [RFC4758],
    authored by\n   Magnus Nystrom, with enhancements borrowed from an individual\n
    \  document coauthored by Mingliang Pei and Salah Machani (e.g., user\n   authentication,
    and support for multiple key package formats).\n   We would like to thank Philip
    Hoyer for his work in aligning DSKPP\n   and PSKC schemas.\n   We would also like
    to thank Hannes Tschofenig and Phillip Hallam-\n   Baker for their reviews, feedback,
    and text contributions.\n"
  title: 14.  Contributors
- contents:
  - "15.  Acknowledgements\n   We would like to thank the following for review of
    previous DSKPP\n   document versions:\n   o  Dr. Ulrike Meyer (Review June 2007)\n
    \  o  Niklas Neumann (Review June 2007)\n   o  Shuh Chang (Review June 2007)\n
    \  o  Hannes Tschofenig (Review June 2007 and again in August 2007)\n   o  Sean
    Turner (Reviews August 2007 and again in July 2008)\n   o  John Linn (Review August
    2007)\n   o  Philip Hoyer (Review September 2007)\n   o  Thomas Roessler (Review
    November 2007)\n   o  Lakshminath Dondeti (Comments December 2007)\n   o  Pasi
    Eronen (Comments December 2007)\n   o  Phillip Hallam-Baker (Review and Edits
    November 2008 and again in\n      January 2009)\n   o  Alexey Melnikov (Review
    May 2010)\n   o  Peter Saint-Andre (Review May 2010)\n   We would also like to
    thank the following for their input to selected\n   design aspects of DSKPP:\n
    \  o  Anders Rundgren (Key Package Format and Client Authentication\n      Data)\n
    \  o  Thomas Roessler (HTTP Binding)\n   o  Hannes Tschofenig (HTTP Binding)\n
    \  o  Phillip Hallam-Baker (Registry for Algorithms)\n   o  N. Asokan (original
    observation of weakness in Authentication\n      Data)\n   Finally, we would like
    to thank Robert Griffin for opening\n   communication channels for us with the
    IEEE P1619.3 Key Management\n   Group, and facilitating our groups in staying
    informed of potential\n   areas (especially key provisioning and global key identifiers
    of\n   collaboration) of collaboration.\n"
  title: 15.  Acknowledgements
- contents:
  - '16.  References

    '
  - contents:
    - "16.1.  Normative References\n   [FIPS180-SHA]     National Institute of Standards
      and Technology,\n                     \"Secure Hash Standard\", FIPS 180-2,
      February 2004,\n                     <http://csrc.nist.gov/publications/fips/fips180-2/\n
      \                    fips180-2withchangenotice.pdf>.\n   [FIPS197-AES]     National
      Institute of Standards and Technology,\n                     \"Specification
      for the Advanced Encryption Standard\n                     (AES)\", FIPS 197,
      November 2001, <http://\n                     csrc.nist.gov/publications/fips/fips197/\n
      \                    fips-197.pdf>.\n   [ISO3309]         International Organization
      for Standardization,\n                     \"ISO Information Processing Systems
      - Data\n                     Communication - High-Level Data Link Control\n
      \                    Procedure - Frame Structure\", ISO 3309,\n                     3rd
      Edition, October 1984.\n   [PKCS-1]          RSA Laboratories, \"RSA Cryptography
      Standard\",\n                     PKCS #1 Version 2.1, June 2002,\n                     <http://www.rsasecurity.com/rsalabs/pkcs/>.\n
      \  [PKCS-5]          RSA Laboratories, \"Password-Based Cryptography\n                     Standard\",
      PKCS #5 Version 2.0, March 1999,\n                     <http://www.rsasecurity.com/rsalabs/pkcs/>.\n
      \  [PKCS-5-XML]      RSA Laboratories, \"XML Schema for PKCS #5 Version\n                     2.0\",
      PKCS #5 Version 2.0 Amd.1 (FINAL DRAFT),\n                     October 2006,\n
      \                    <http://www.rsasecurity.com/rsalabs/pkcs/>.\n   [RFC2104]
      \        Krawczyk, H., Bellare, M., and R. Canetti, \"HMAC:\n                     Keyed-Hashing
      for Message Authentication\",\n                     RFC 2104, February 1997.\n
      \  [RFC2119]         Bradner, S., \"Key words for use in RFCs to Indicate\n
      \                    Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC2616]
      \        Fielding, R., Gettys, J., Mogul, J., Frystyk, H.,\n                     Masinter,
      L., Leach, P., and T. Berners-Lee,\n                     \"Hypertext Transfer
      Protocol -- HTTP/1.1\",\n                     RFC 2616, June 1999.\n   [RFC3394]
      \        Schaad, J. and R. Housley, \"Advanced Encryption\n                     Standard
      (AES) Key Wrap Algorithm\", RFC 3394,\n                     September 2002.\n
      \  [RFC3629]         Yergeau, F., \"UTF-8, a transformation format of ISO\n
      \                    10646\", STD 63, RFC 3629, November 2003.\n   [RFC4013]
      \        Zeilenga, K., \"SASLprep: Stringprep Profile for\n                     User
      Names and Passwords\", RFC 4013, February 2005.\n   [RFC4210]         Adams,
      C., Farrell, S., Kause, T., and T. Mononen,\n                     \"Internet
      X.509 Public Key Infrastructure\n                     Certificate Management
      Protocol (CMP)\", RFC 4210,\n                     September 2005.\n   [RFC5272]
      \        Schaad, J. and M. Myers, \"Certificate Management\n                     over
      CMS (CMC)\", RFC 5272, June 2008.\n   [RFC5280]         Cooper, D., Santesson,
      S., Farrell, S., Boeyen, S.,\n                     Housley, R., and W. Polk,
      \"Internet X.509 Public\n                     Key Infrastructure Certificate
      and Certificate\n                     Revocation List (CRL) Profile\", RFC 5280,
      May 2008.\n   [RFC5649]         Housley, R. and M. Dworkin, \"Advanced Encryption\n
      \                    Standard (AES) Key Wrap with Padding Algorithm\",\n                     RFC
      5649, September 2009.\n   [RFC6030]         Hoyer, P., Pei, M., and S. Machani,
      \"Portable\n                     Symmetric Key Container (PSKC)\", RFC 6030,\n
      \                    October 2010.\n   [UNICODE]         Davis, M. and M. Duerst,
      \"Unicode Normalization\n                     Forms\", March 2001, <http://www.unicode.org/\n
      \                    unicode/reports/tr15/tr15-21.html>.\n   [XML]             W3C,
      \"Extensible Markup Language (XML) 1.0 (Fifth\n                     Edition)\",
      W3C Recommendation, November 2008,\n                     <http://www.w3.org/TR/2006/REC-xml-20060816/>.\n
      \  [XMLDSIG]         W3C, \"XML Signature Syntax and Processing\",\n                     W3C
      Recommendation, February 2002, <http://\n                     www.w3.org/TR/2002/REC-xmldsig-core-20020212/>.\n
      \  [XMLENC]          W3C, \"XML Encryption Syntax and Processing\",\n                     W3C
      Recommendation, December 2002, <http://\n                     www.w3.org/TR/2002/REC-xmldsig-core-20020212/>.\n"
    title: 16.1.  Normative References
  - contents:
    - "16.2.  Informative References\n   [CT-KIP-P11]      RSA Laboratories, \"PKCS
      #11 Mechanisms for the\n                     Cryptographic Token Key Initialization
      Protocol\",\n                     PKCS #11 Version 2.20 Amd.2, December 2005,\n
      \                    <http://www.rsasecurity.com/rsalabs/pkcs/>.\n   [FAQ]             RSA
      Laboratories, \"Frequently Asked Questions About\n                     Today's
      Cryptography\",  Version 4.1, 2000.\n   [NIST-PWD]        National Institute
      of Standards and Technology,\n                     \"Password Usage\", FIPS
      112, May 1985,\n                     <http://www.itl.nist.gov/fipspubs/fip112.htm>.\n
      \  [NIST-SP800-38B]  International Organization for Standardization,\n                     \"Recommendations
      for Block Cipher Modes of\n                     Operation: The CMAC Mode for
      Authentication\",\n                     NIST SP800-38B, May 2005, <http://csrc.nist.gov/\n
      \                    publications/nistpubs/800-38B/SP_800-38B.pdf>.\n   [NIST-SP800-57]
      \  National Institute of Standards and Technology,\n                     \"Recommendation
      for Key Management - Part I:\n                     General (Revised)\", NIST
      800-57, March 2007, <http:\n                     //csrc.nist.gov/publications/nistpubs/800-57/\n
      \                    sp800-57-Part1-revised2_Mar08-2007.pdf>.\n   [PKCS-11]
      \        RSA Laboratories, \"Cryptographic Token Interface\n                     Standard\",
      PKCS #11 Version 2.20, June 2004,\n                     <http://www.rsasecurity.com/rsalabs/pkcs/>.\n
      \  [PKCS-12]         \"Personal Information Exchange Syntax Standard\",\n                     PKCS
      #12 Version 1.0, 2005, <ftp://\n                     ftp.rsasecurity.com/pub/pkcs/pkcs-12/\n
      \                    pkcs-12v1.pdf>.\n   [RFC2818]         Rescorla, E., \"HTTP
      Over TLS\", RFC 2818, May 2000.\n   [RFC3023]         Murata, M., St. Laurent,
      S., and D. Kohn, \"XML\n                     Media Types\", RFC 3023, January
      2001.\n   [RFC3575]         Aboba, B., \"IANA Considerations for RADIUS (Remote\n
      \                    Authentication Dial In User Service)\", RFC 3575,\n                     July
      2003.\n   [RFC3688]         Mealling, M., \"The IETF XML Registry\", BCP 81,\n
      \                    RFC 3688, January 2004.\n   [RFC3986]         Berners-Lee,
      T., Fielding, R., and L. Masinter,\n                     \"Uniform Resource
      Identifier (URI): Generic\n                     Syntax\", STD 66, RFC 3986,
      January 2005.\n   [RFC4758]         Nystroem, M., \"Cryptographic Token Key\n
      \                    Initialization Protocol (CT-KIP) Version 1.0\n                     Revision
      1\", RFC 4758, November 2006.\n   [RFC5226]         Narten, T. and H. Alvestrand,
      \"Guidelines for\n                     Writing an IANA Considerations Section
      in RFCs\",\n                     BCP 26, RFC 5226, May 2008.\n   [RFC5246]         Dierks,
      T. and E. Rescorla, \"The Transport Layer\n                     Security (TLS)
      Protocol Version 1.2\", RFC 5246,\n                     August 2008.\n   [RFC6031]
      \        Turner, S. and R. , \"Cryptographic Message Syntax\n                     (CMS)
      Symmetric Key Package Content Type\",\n                     RFC 6031, December
      2010.\n   [XMLNS]           W3C, \"Namespaces in XML\", W3C Recommendation,\n
      \                    January 1999,\n                     <http://www.w3.org/TR/2009/REC-xml-names-20091208>.\n"
    title: 16.2.  Informative References
  title: 16.  References
- contents:
  - "Appendix A.  Usage Scenarios\n   DSKPP is expected to be used to provision symmetric
    keys to\n   cryptographic modules in a number of different scenarios, each with\n
    \  its own special requirements, as described below.  This appendix\n   forms
    an informative part of the document.\n"
  - contents:
    - "A.1.  Single Key Request\n   The usual scenario is that a cryptographic module
      makes a request for\n   a symmetric key from a provisioning server that is located
      on the\n   local network or somewhere on the Internet.  Depending upon the\n
      \  deployment scenario, the provisioning server may generate a new key\n   on-the-fly
      or use a pre-generated key, e.g., one provided by a legacy\n   back-end issuance
      server.  The provisioning server assigns a unique\n   key ID to the symmetric
      key and provisions it to the cryptographic\n   module.\n"
    title: A.1.  Single Key Request
  - contents:
    - "A.2.  Multiple Key Requests\n   A cryptographic module makes multiple requests
      for symmetric keys\n   from the same provisioning server.  The symmetric keys
      need not be of\n   the same type, i.e., the keys may be used with different
      symmetric\n   key cryptographic algorithms, including one-time password\n   authentication
      algorithms, and the AES encryption algorithm.\n"
    title: A.2.  Multiple Key Requests
  - contents:
    - "A.3.  User Authentication\n   In some deployment scenarios, a key issuer may
      rely on a third-party\n   provisioning service.  In this case, the issuer directs
      provisioning\n   requests from the cryptographic module to the provisioning
      service.\n   As such, it is the responsibility of the issuer to authenticate
      the\n   user through some out-of-band means before granting him rights to\n
      \  acquire keys.  Once the issuer has granted those rights, the issuer\n   provides
      an Authentication Code to the user and makes it available to\n   the provisioning
      service, so that the user can prove that he is\n   authorized to acquire keys.\n"
    title: A.3.  User Authentication
  - contents:
    - "A.4.  Provisioning Time-Out Policy\n   An issuer may provide a time-limited
      Authentication Code to a user\n   during registration, which the user will input
      into the cryptographic\n   module to authenticate themselves with the provisioning
      server.  The\n   server will allow a key to be provisioned to the cryptographic
      module\n   hosted by the user's device when user authentication is required
      only\n   if the user inputs a valid Authentication Code within the fixed time\n
      \  period established by the issuer.\n"
    title: A.4.  Provisioning Time-Out Policy
  - contents:
    - "A.5.  Key Renewal\n   A cryptographic module requests renewal of the symmetric
      key material\n   attached to a key ID, as opposed to keeping the key value constant\n
      \  and refreshing the metadata.  Such a need may occur in the case when\n   a
      user wants to upgrade her device that houses the cryptographic\n   module or
      when a key has expired.  When a user uses the same\n   cryptographic module
      for example, to perform strong authentication at\n   multiple Web login sites,
      keeping the same key ID removes the need\n   for the user to register a new
      key ID at each site.\n"
    title: A.5.  Key Renewal
  - contents:
    - "A.6.  Pre-Loaded Key Replacement\n   This scenario represents a special case
      of symmetric key renewal in\n   which a local administrator can authenticate
      the user procedurally\n   before initiating the provisioning process.  It also
      allows for a\n   device issuer to pre-load a key onto a cryptographic module
      with a\n   restriction that the key is replaced with a new key prior to use
      of\n   the cryptographic module.  Another variation of this scenario is the\n
      \  organization who recycles devices.  In this case, a key issuer would\n   provision
      a new symmetric key to a cryptographic module hosted on a\n   device that was
      previously owned by another user.\n   Note that this usage scenario is essentially
      the same as the previous\n   scenario wherein the same key ID is used for renewal.\n"
    title: A.6.  Pre-Loaded Key Replacement
  - contents:
    - "A.7.  Pre-Shared Manufacturing Key\n   A cryptographic module is loaded onto
      a smart card after the card is\n   issued to a user.  The symmetric key for
      the cryptographic module\n   will then be provisioned using a secure channel
      mechanism present in\n   many smart card platforms.  This allows a direct secure
      channel to be\n   established between the smart card chip and the provisioning
      server.\n   For example, the card commands (i.e., Application Protocol Data\n
      \  Units, or APDUs) are encrypted with a pre-issued card manufacturer's\n   key
      and sent directly to the smart card chip, allowing secure post-\n   issuance
      in-the-field provisioning.  This secure flow can pass\n   Transport Layer Security
      (TLS) [RFC5246] and other transport security\n   boundaries.\n   Note that two
      pre-conditions for this usage scenario are for the\n   protocol to be tunneled
      and the provisioning server to know the\n   correct pre-established manufacturer's
      key.\n"
    title: A.7.  Pre-Shared Manufacturing Key
  - contents:
    - "A.8.  End-to-End Protection of Key Material\n   In this scenario, Transport
      Layer Security does not provide end-to-\n   end protection of keying material
      transported from the provisioning\n   server to the cryptographic module.  For
      example, TLS may terminate\n   at an application hosted on a PC rather than
      at the cryptographic\n   module (i.e., the endpoint) located on a data storage
      device\n   [RFC5246].  Mutually authenticated key agreement provides end-to-end\n
      \  protection, which TLS cannot provide.\n"
    title: A.8.  End-to-End Protection of Key Material
  title: Appendix A.  Usage Scenarios
- contents:
  - "Appendix B.  Examples\n   This appendix contains example messages that illustrate
    parameters,\n   encoding, and semantics in four- and two-pass DSKPP exchanges.
    \ The\n   examples are written using XML, and are syntactically correct.  MAC\n
    \  and cipher values are fictitious, however.  This appendix forms an\n   informative
    part of the document.\n"
  - contents:
    - "B.1.  Trigger Message\n   <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n
      \  <dskpp:KeyProvTrigger Version=\"1.0\"\n     xmlns:dskpp=\"urn:ietf:params:xml:ns:keyprov:dskpp\"\n
      \    xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\">\n     <dskpp:InitializationTrigger>\n
      \      <dskpp:DeviceIdentifierData>\n           <dskpp:DeviceId>\n               <pskc:Manufacturer>TokenVendorAcme</pskc:Manufacturer>\n
      \              <pskc:SerialNo>987654321</pskc:SerialNo>\n               <pskc:StartDate>2009-09-01T00:00:00Z</pskc:StartDate>\n
      \              <pskc:ExpiryDate>2014-09-01T00:00:00Z</pskc:ExpiryDate>\n           </dskpp:DeviceId>\n
      \      </dskpp:DeviceIdentifierData>\n       <dskpp:KeyID>SE9UUDAwMDAwMDAx</dskpp:KeyID>\n
      \      <dskpp:TokenPlatformInfo KeyLocation=\"Hardware\"\n         AlgorithmLocation=\"Software\"/>\n
      \      <dskpp:AuthenticationData>\n         <dskpp:ClientID>31300257</dskpp:ClientID>\n
      \        <dskpp:AuthenticationCodeMac>\n           <dskpp:IterationCount>512</dskpp:IterationCount>\n
      \          <dskpp:Mac>4bRJf9xXd3KchKoTenHJiw==</dskpp:Mac>\n         </dskpp:AuthenticationCodeMac>\n
      \      </dskpp:AuthenticationData>\n       <dskpp:ServerUrl>keyprovservice.example.com\n
      \        </dskpp:ServerUrl>\n     </dskpp:InitializationTrigger>\n   </dskpp:KeyProvTrigger>\n"
    title: B.1.  Trigger Message
  - contents:
    - 'B.2.  Four-Pass Protocol

      '
    - contents:
      - "B.2.1.  <KeyProvClientHello> without a Preceding Trigger\n    <?xml version=\"1.0\"
        encoding=\"UTF-8\" standalone=\"yes\"?>\n    <dskpp:KeyProvClientHello\n        xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\"\n
        \       xmlns:dskpp=\"urn:ietf:params:xml:ns:keyprov:dskpp\"\n        xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\"\n
        \       xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\n        Version=\"1.0\">\n
        \       <dskpp:DeviceIdentifierData>\n            <dskpp:DeviceId>\n                <pskc:Manufacturer>TokenVendorAcme</pskc:Manufacturer>\n
        \               <pskc:SerialNo>987654321</pskc:SerialNo>\n                <pskc:StartDate>2009-09-01T00:00:00Z</pskc:StartDate>\n
        \               <pskc:ExpiryDate>2014-09-01T00:00:00Z</pskc:ExpiryDate>\n
        \           </dskpp:DeviceId>\n        </dskpp:DeviceIdentifierData>\n        <dskpp:SupportedKeyTypes>\n
        \           <dskpp:Algorithm>\n                urn:ietf:params:xml:ns:keyprov:pskc:hotp\n
        \           </dskpp:Algorithm>\n            <dskpp:Algorithm>\n    http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES\n
        \           </dskpp:Algorithm>\n        </dskpp:SupportedKeyTypes>\n        <dskpp:SupportedEncryptionAlgorithms>\n
        \           <dskpp:Algorithm>\n                http://www.w3.org/2001/04/xmlenc#aes128-cbc\n
        \           </dskpp:Algorithm>\n        </dskpp:SupportedEncryptionAlgorithms>\n
        \       <dskpp:SupportedMacAlgorithms>\n            <dskpp:Algorithm>\n                urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256\n
        \           </dskpp:Algorithm>\n        </dskpp:SupportedMacAlgorithms>\n
        \       <dskpp:SupportedProtocolVariants>\n            <dskpp:FourPass/>\n
        \       </dskpp:SupportedProtocolVariants>\n        <dskpp:SupportedKeyPackages>\n
        \           <dskpp:KeyPackageFormat>\n                urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container\n
        \           </dskpp:KeyPackageFormat>\n        </dskpp:SupportedKeyPackages>\n
        \   </dskpp:KeyProvClientHello>\n"
      title: B.2.1.  <KeyProvClientHello> without a Preceding Trigger
    - contents:
      - "B.2.2.  <KeyProvClientHello> Assuming a Preceding Trigger\n    <?xml version=\"1.0\"
        encoding=\"UTF-8\" standalone=\"yes\"?>\n    <dskpp:KeyProvClientHello\n        xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\"\n
        \       xmlns:dskpp=\"urn:ietf:params:xml:ns:keyprov:dskpp\"\n        xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\"\n
        \       xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\n        Version=\"1.0\">\n
        \       <dskpp:DeviceIdentifierData>\n            <dskpp:DeviceId>\n                <pskc:Manufacturer>TokenVendorAcme</pskc:Manufacturer>\n
        \               <pskc:SerialNo>987654321</pskc:SerialNo>\n                <pskc:StartDate>2009-09-01T00:00:00Z</pskc:StartDate>\n
        \               <pskc:ExpiryDate>2014-09-01T00:00:00Z</pskc:ExpiryDate>\n
        \           </dskpp:DeviceId>\n        </dskpp:DeviceIdentifierData>\n        <dskpp:KeyID>SE9UUDAwMDAwMDAx</dskpp:KeyID>\n
        \       <dskpp:SupportedKeyTypes>\n            <dskpp:Algorithm>\n                urn:ietf:params:xml:ns:keyprov:pskc:hotp\n
        \           </dskpp:Algorithm>\n            <dskpp:Algorithm>\n    http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES\n
        \           </dskpp:Algorithm>\n        </dskpp:SupportedKeyTypes>\n        <dskpp:SupportedEncryptionAlgorithms>\n
        \           <dskpp:Algorithm>\n                http://www.w3.org/2001/04/xmlenc#aes128-cbc\n
        \           </dskpp:Algorithm>\n        </dskpp:SupportedEncryptionAlgorithms>\n
        \       <dskpp:SupportedMacAlgorithms>\n            <dskpp:Algorithm>\n                urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256\n
        \           </dskpp:Algorithm>\n        </dskpp:SupportedMacAlgorithms>\n
        \       <dskpp:SupportedProtocolVariants>\n          <dskpp:FourPass/>\n        </dskpp:SupportedProtocolVariants>\n
        \       <dskpp:SupportedKeyPackages>\n            <dskpp:KeyPackageFormat>\n
        \               urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container\n
        \           </dskpp:KeyPackageFormat>\n        </dskpp:SupportedKeyPackages>\n
        \   </dskpp:KeyProvClientHello>\n"
      title: B.2.2.  <KeyProvClientHello> Assuming a Preceding Trigger
    - contents:
      - "B.2.3.  <KeyProvServerHello> Without a Preceding Trigger\n   <?xml version=\"1.0\"
        encoding=\"UTF-8\" standalone=\"yes\"?>\n   <dskpp:KeyProvServerHello\n       xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\"\n
        \      xmlns:dskpp=\"urn:ietf:params:xml:ns:keyprov:dskpp\"\n       xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\"\n
        \      xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\n       Version=\"1.0\"\n
        \      Status=\"Continue\"\n       SessionID=\"4114\">\n       <dskpp:KeyType>\n
        \          urn:ietf:params:xml:ns:keyprov:pskc:hotp\n       </dskpp:KeyType>\n
        \      <dskpp:EncryptionAlgorithm>\n           http://www.w3.org/2001/04/xmlenc#aes128-cbc\n
        \      </dskpp:EncryptionAlgorithm>\n       <dskpp:MacAlgorithm>\n           urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256\n
        \      </dskpp:MacAlgorithm>\n       <dskpp:EncryptionKey>\n         <ds:KeyName>Example-Key1</ds:KeyName>\n
        \      </dskpp:EncryptionKey>\n       <dskpp:KeyPackageFormat>\n           urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container\n
        \      </dskpp:KeyPackageFormat>\n       <dskpp:Payload>\n           <dskpp:Nonce>EjRWeJASNFZ4kBI0VniQEg==</dskpp:Nonce>\n
        \      </dskpp:Payload>\n   </dskpp:KeyProvServerHello>\n"
      title: B.2.3.  <KeyProvServerHello> Without a Preceding Trigger
    - contents:
      - "B.2.4.  <KeyProvServerHello> Assuming Key Renewal\n    <?xml version=\"1.0\"
        encoding=\"UTF-8\" standalone=\"yes\"?>\n    <dskpp:KeyProvServerHello\n      xmlns:dskpp=\"urn:ietf:params:xml:ns:keyprov:dskpp\"\n
        \     xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\"\n      xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\"\n
        \     xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\n      Version=\"1.0\"\n
        \     SessionID=\"4114\"\n      Status=\"Continue\">\n      <dskpp:KeyType>\n
        \       urn:ietf:params:xml:schema:keyprov:otpalg#SecurID-AES\n      </dskpp:KeyType>\n
        \     <dskpp:EncryptionAlgorithm>\n         http://www.w3.org/2001/04/xmlenc#aes128-cbc\n
        \     </dskpp:EncryptionAlgorithm>\n      <dskpp:MacAlgorithm>\n         urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256\n
        \     </dskpp:MacAlgorithm>\n      <dskpp:EncryptionKey>\n        <ds:KeyName>Example-Key1</ds:KeyName>\n
        \     </dskpp:EncryptionKey>\n      <dskpp:KeyPackageFormat>\n        urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container\n
        \     </dskpp:KeyPackageFormat>\n      <dskpp:Payload>\n        <dskpp:Nonce>qw2ewasde312asder394jw==</dskpp:Nonce>\n
        \     </dskpp:Payload>\n      <dskpp:Mac\n        MacAlgorithm=\"urn:ietf:params:xml:ns:keyprov:dskpp:prf-aes-128\">\n
        \       cXcycmFuZG9tMzEyYXNkZXIzOTRqdw==\n      </dskpp:Mac>\n    </dskpp:KeyProvServerHello>\n"
      title: B.2.4.  <KeyProvServerHello> Assuming Key Renewal
    - contents:
      - "B.2.5.  <KeyProvClientNonce> Using Default Encryption\n   This message contains
        the nonce chosen by the cryptographic module,\n   R_C, encrypted by the specified
        encryption key and encryption\n   algorithm.\n    <?xml version=\"1.0\" encoding=\"UTF-8\"
        standalone=\"yes\"?>\n    <dskpp:KeyProvClientNonce\n        xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\"\n
        \       xmlns:dskpp=\"urn:ietf:params:xml:ns:keyprov:dskpp\"\n        xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\"\n
        \       xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\n        SessionID=\"4114\"\n
        \       Version=\"1.0\">\n        <dskpp:EncryptedNonce>\n            oTvo+S22nsmS2Z/RtcoF8CTwadRa1PVsRXkZnCihHkU1rPueggrd0NpEWVZR\n
        \           16Rg16+FHuTg33GK1wH3wffDZQ==\n        </dskpp:EncryptedNonce>\n
        \   </dskpp:KeyProvClientNonce>\n"
      title: B.2.5.  <KeyProvClientNonce> Using Default Encryption
    - contents:
      - "B.2.6.  <KeyProvServerFinished> Using Default Encryption\n      <?xml version=\"1.0\"
        encoding=\"UTF-8\" standalone=\"yes\"?>\n      <dskpp:KeyProvServerFinished\n
        \         xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\"\n          xmlns:dskpp=\"urn:ietf:params:xml:ns:keyprov:dskpp\"\n
        \         xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\"\n          xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\n
        \         Version=\"1.0\"\n          Status=\"Success\"\n          SessionID=\"4114\">\n
        \         <dskpp:KeyPackage>\n              <dskpp:KeyContainer Version=\"1.0\"
        Id=\"KC0001\">\n                  <pskc:KeyPackage>\n                      <pskc:DeviceInfo>\n
        \                         <pskc:Manufacturer>\n                             TokenVendorAcme\n
        \                         </pskc:Manufacturer>\n                          <pskc:SerialNo>\n
        \                            987654321\n                          </pskc:SerialNo>\n
        \                         <pskc:StartDate>\n                             2009-09-01T00:00:00Z\n
        \                         </pskc:StartDate>\n                          <pskc:ExpiryDate>\n
        \                            2014-09-01T00:00:00Z\n                          </pskc:ExpiryDate>\n
        \                     </pskc:DeviceInfo>\n                      <pskc:CryptoModuleInfo>\n
        \                         <pskc:Id>CM_ID_001</pskc:Id>\n                      </pskc:CryptoModuleInfo>\n
        \                     <pskc:Key\n                         Id=\"MBK000000001\"\n
        \                        Algorithm=\n                            \"urn:ietf:params:xml:ns:keyprov:pskc:hotp\">\n
        \                        <pskc:Issuer>Example-Issuer</pskc:Issuer>\n                         <pskc:AlgorithmParameters>\n
        \                            <pskc:ResponseFormat Length=\"6\"\n                                Encoding=\"DECIMAL\"/>\n
        \                         </pskc:AlgorithmParameters>\n                          <pskc:Data>\n
        \                             <pskc:Counter>\n                                  <pskc:PlainValue>0</pskc:PlainValue>\n
        \                             </pskc:Counter>\n                          </pskc:Data>\n
        \                         <pskc:Policy>\n                              <pskc:KeyUsage>OTP</pskc:KeyUsage>\n
        \                         </pskc:Policy>\n                      </pskc:Key>\n
        \                 </pskc:KeyPackage>\n              </dskpp:KeyContainer>\n
        \         </dskpp:KeyPackage>\n          <dskpp:Mac\n              MacAlgorithm=\n
        \                \"urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256\">\n              151yAR2NqU5dJzETK+SGYqN6sq6DEH5AgHohra3Jpp4=\n
        \         </dskpp:Mac>\n      </dskpp:KeyProvServerFinished>\n"
      title: B.2.6.  <KeyProvServerFinished> Using Default Encryption
    title: B.2.  Four-Pass Protocol
  - contents:
    - 'B.3.  Two-Pass Protocol

      '
    - contents:
      - "B.3.1.  Example Using the Key Transport Method\n   The client indicates support
        for all the Key Transport, Key Wrap, and\n   Passphrase-Based Key Wrap key
        protection methods:\n   <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n
        \  <dskpp:KeyProvClientHello\n       xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\"\n
        \      xmlns:dskpp=\"urn:ietf:params:xml:ns:keyprov:dskpp\"\n       xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\"\n
        \      xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\n       Version=\"1.0\">\n
        \      <dskpp:DeviceIdentifierData>\n           <dskpp:DeviceId>\n               <pskc:Manufacturer>TokenVendorAcme</pskc:Manufacturer>\n
        \              <pskc:SerialNo>987654321</pskc:SerialNo>\n               <pskc:StartDate>2009-09-01T00:00:00Z</pskc:StartDate>\n
        \              <pskc:ExpiryDate>2014-09-01T00:00:00Z</pskc:ExpiryDate>\n           </dskpp:DeviceId>\n
        \      </dskpp:DeviceIdentifierData>\n       <dskpp:SupportedKeyTypes>\n           <dskpp:Algorithm>\n
        \              urn:ietf:params:xml:ns:keyprov:pskc:hotp\n           </dskpp:Algorithm>\n
        \          <dskpp:Algorithm>\n   http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES\n
        \          </dskpp:Algorithm>\n       </dskpp:SupportedKeyTypes>\n       <dskpp:SupportedEncryptionAlgorithms>\n
        \          <dskpp:Algorithm>\n               http://www.w3.org/2001/04/xmlenc#rsa_1_5\n
        \          </dskpp:Algorithm>\n       </dskpp:SupportedEncryptionAlgorithms>\n
        \      <dskpp:SupportedMacAlgorithms>\n           <dskpp:Algorithm>\n               urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256\n
        \          </dskpp:Algorithm>\n       </dskpp:SupportedMacAlgorithms>\n       <dskpp:SupportedProtocolVariants>\n
        \          <dskpp:TwoPass>\n               <dskpp:SupportedKeyProtectionMethod>\n
        \                  urn:ietf:params:xml:schema:keyprov:dskpp:transport\n               </dskpp:SupportedKeyProtectionMethod>\n
        \              <dskpp:Payload>\n                   <ds:KeyInfo>\n                       <ds:X509Data>\n
        \                          <ds:X509Certificate>\n   MIIB5zCCAVCgAwIBAgIESZp/vDANBgkqhkiG9w0BAQUFADA4MQ0wCwYDVQQKEwRJRVRGM\n
        \  RMwEQYDVQQLEwpLZXlQcm92IFdHMRIwEAYDVQQDEwlQU0tDIFRlc3QwHhcNMDkwMjE3MD\n
        \  kxMzMyWhcNMTEwMjE3MDkxMzMyWjA4MQ0wCwYDVQQKEwRJRVRGMRMwEQYDVQQLEwpLZXl\n
        \  Qcm92IFdHMRIwEAYDVQQDEwlQU0tDIFRlc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ\n
        \  AoGBALCWLDa2ItYJ6su80hd1gL4cggQYdyyKK17btt/aS6Q/eDsKjsPyFIODsxeKVV/uA\n
        \  3wLT4jQJM5euKJXkDajzGGOy92+ypfzTX4zDJMkh61SZwlHNJxBKilAM5aW7C+BQ0RvCx\n
        \  vdYtzx2LTdB+X/KMEBA7uIYxLfXH2Mnub3WIh1AgMBAAEwDQYJKoZIhvcNAQEFBQADgYE\n
        \  Ae875m84sYUJ8qPeZ+NG7REgTvlHTmoCdoByU0LBBLotUKuqfrnRuXJRMeZXaaEGmzY1k\n
        \  LonVjQGzjAkU4dJ+RPmiDlYuHLZS41Pg6VMwY+03lhk6I5A/w4rnqdkmwZX/NgXg06aln\n
        \  c2pBsXWhL4O7nk0S2ZrLMsQZ6HcsXgdmHo=\n                           </ds:X509Certificate>\n
        \                      </ds:X509Data>\n                   </ds:KeyInfo>\n
        \              </dskpp:Payload>\n           </dskpp:TwoPass>\n       </dskpp:SupportedProtocolVariants>\n
        \      <dskpp:SupportedKeyPackages>\n           <dskpp:KeyPackageFormat>\n
        \              urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container\n           </dskpp:KeyPackageFormat>\n
        \      </dskpp:SupportedKeyPackages>\n       <dskpp:AuthenticationData>\n
        \          <dskpp:ClientID>AC00000A</dskpp:ClientID>\n           <dskpp:AuthenticationCodeMac>\n
        \              <dskpp:Nonce>\n                   ESIzRFVmd4iZqrvM3e7/ESIzRFVmd4iZqrvM3e7/ESI=\n
        \              </dskpp:Nonce>\n               <dskpp:IterationCount>100000</dskpp:IterationCount>\n
        \              <dskpp:Mac\n                   MacAlgorithm=\n                   \"urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256\">\n
        \                  3eRz51ILqiG+dJW2iLcjuA==\n               </dskpp:Mac>\n
        \          </dskpp:AuthenticationCodeMac>\n       </dskpp:AuthenticationData>\n
        \  </dskpp:KeyProvClientHello>\n   In this example, the server responds to
        the previous request by\n   returning a key package in which the provisioning
        key was encrypted\n   using the Key Transport key protection method.\n   <?xml
        version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n   <dskpp:KeyProvServerFinished\n
        \      xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\"\n       xmlns:dskpp=\"urn:ietf:params:xml:ns:keyprov:dskpp\"\n
        \      xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\"\n       xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\n
        \      xmlns:dkey=\"http://www.w3.org/2009/xmlsec-derivedkey#\"\n       xmlns:pkcs5=\n
        \         \"http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#\"\n
        \      Version=\"1.0\"\n       Status=\"Success\"\n       SessionID=\"4114\">\n
        \      <dskpp:KeyPackage>\n           <dskpp:KeyContainer Version=\"1.0\"
        Id=\"KC0001\">\n               <pskc:EncryptionKey>\n                   <ds:X509Data>\n
        \                      <ds:X509Certificate>\n   MIIB5zCCAVCgAwIBAgIESZp/vDANBgkqhkiG9w0BAQUFADA4MQ0wCwYDVQQKEwRJRVRGM\n
        \  RMwEQYDVQQLEwpLZXlQcm92IFdHMRIwEAYDVQQDEwlQU0tDIFRlc3QwHhcNMDkwMjE3MD\n
        \  kxMzMyWhcNMTEwMjE3MDkxMzMyWjA4MQ0wCwYDVQQKEwRJRVRGMRMwEQYDVQQLEwpLZXl\n
        \  Qcm92IFdHMRIwEAYDVQQDEwlQU0tDIFRlc3QwgZ8wDQYJKoZIhvcNAQEBBQADgY0AMIGJ\n
        \  AoGBALCWLDa2ItYJ6su80hd1gL4cggQYdyyKK17btt/aS6Q/eDsKjsPyFIODsxeKVV/uA\n
        \  3wLT4jQJM5euKJXkDajzGGOy92+ypfzTX4zDJMkh61SZwlHNJxBKilAM5aW7C+BQ0RvCx\n
        \  vdYtzx2LTdB+X/KMEBA7uIYxLfXH2Mnub3WIh1AgMBAAEwDQYJKoZIhvcNAQEFBQADgYE\n
        \  Ae875m84sYUJ8qPeZ+NG7REgTvlHTmoCdoByU0LBBLotUKuqfrnRuXJRMeZXaaEGmzY1k\n
        \  LonVjQGzjAkU4dJ+RPmiDlYuHLZS41Pg6VMwY+03lhk6I5A/w4rnqdkmwZX/NgXg06aln\n
        \  c2pBsXWhL4O7nk0S2ZrLMsQZ6HcsXgdmHo=\n                       </ds:X509Certificate>\n
        \                  </ds:X509Data>\n               </pskc:EncryptionKey>\n
        \              <pskc:KeyPackage>\n                   <pskc:DeviceInfo>\n                       <pskc:Manufacturer>\n
        \                         TokenVendorAcme\n                       </pskc:Manufacturer>\n
        \                      <pskc:SerialNo>\n                          987654321\n
        \                      </pskc:SerialNo>\n                       <pskc:StartDate>\n
        \                         2009-09-01T00:00:00Z\n                       </pskc:StartDate>\n
        \                      <pskc:ExpiryDate>\n                          2014-09-01T00:00:00Z\n
        \                      </pskc:ExpiryDate>\n                   </pskc:DeviceInfo>\n
        \                  <pskc:Key\n                       Id=\"MBK000000001\"\n
        \                      Algorithm=\n                          \"urn:ietf:params:xml:ns:keyprov:pskc:hotp\">\n
        \                      <pskc:Issuer>Example-Issuer</pskc:Issuer>\n                       <pskc:AlgorithmParameters>\n
        \                          <pskc:ResponseFormat Length=\"6\"\n                              Encoding=\"DECIMAL\"/>\n
        \                      </pskc:AlgorithmParameters>\n                       <pskc:Data>\n
        \                          <pskc:Secret>\n                               <pskc:EncryptedValue>\n
        \                                  <xenc:EncryptionMethod\n                                    Algorithm=\n
        \                           \"http://www.w3.org/2001/04/xmlenc#rsa_1_5\"/>\n
        \                                  <xenc:CipherData>\n                                       <xenc:CipherValue>\n
        \  eyjr23WMy9S2UdKgGnQEbs44T1jmX1TNWEBq48xfS20PK2VWF4ZK1iSctHj/u3uk+7+y8\n
        \  uKrAzHEm5mujKPAU4DCbb5mSibXMnAbbIoAi2cJW60/l8FlzwaU4EZsZ1LyQ1GcBQKACE\n
        \  eylG5vK8NTo47vZTatL5UxmbmOX2HvaVQ=\n                                       </xenc:CipherValue>\n
        \                                  </xenc:CipherData>\n                               </pskc:EncryptedValue>\n
        \                          </pskc:Secret>\n                           <pskc:Counter>\n
        \                              <pskc:PlainValue>0</pskc:PlainValue>\n                           </pskc:Counter>\n
        \                      </pskc:Data>\n                       <pskc:Policy>\n
        \                          <pskc:KeyUsage>OTP</pskc:KeyUsage>\n                       </pskc:Policy>\n
        \                  </pskc:Key>\n               </pskc:KeyPackage>\n           </dskpp:KeyContainer>\n
        \      </dskpp:KeyPackage>\n       <dskpp:Mac\n           MacAlgorithm=\n
        \             \"urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256\">\n           GHZ0H6Y+KpxdlVZ7zgcJDiDdqc8Gcmlcf+HQi4EUxYU=\n
        \      </dskpp:Mac>\n   </dskpp:KeyProvServerFinished>\n"
      title: B.3.1.  Example Using the Key Transport Method
    - contents:
      - "B.3.2.  Example Using the Key Wrap Method\n   The client sends a request
        that specifies a shared key to protect the\n   K_TOKEN, and the server responds
        using the Key Wrap key protection\n   method.  Authentication Data in this
        example is based on an\n   Authentication Code rather than a device certificate.\n
        \  <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n   <dskpp:KeyProvClientHello\n
        \      xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\"\n       xmlns:dskpp=\"urn:ietf:params:xml:ns:keyprov:dskpp\"\n
        \      xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\"\n       xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\n
        \      Version=\"1.0\">\n       <dskpp:DeviceIdentifierData>\n           <dskpp:DeviceId>\n
        \              <pskc:Manufacturer>TokenVendorAcme</pskc:Manufacturer>\n               <pskc:SerialNo>987654321</pskc:SerialNo>\n
        \              <pskc:StartDate>2009-09-01T00:00:00Z</pskc:StartDate>\n               <pskc:ExpiryDate>2014-09-01T00:00:00Z</pskc:ExpiryDate>\n
        \          </dskpp:DeviceId>\n       </dskpp:DeviceIdentifierData>\n       <dskpp:SupportedKeyTypes>\n
        \          <dskpp:Algorithm>\n               urn:ietf:params:xml:ns:keyprov:pskc:hotp\n
        \          </dskpp:Algorithm>\n           <dskpp:Algorithm>\n    http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES\n
        \          </dskpp:Algorithm>\n       </dskpp:SupportedKeyTypes>\n       <dskpp:SupportedEncryptionAlgorithms>\n
        \          <dskpp:Algorithm>\n               http://www.w3.org/2001/04/xmlenc#aes128-cbc\n
        \          </dskpp:Algorithm>\n       </dskpp:SupportedEncryptionAlgorithms>\n
        \      <dskpp:SupportedMacAlgorithms>\n           <dskpp:Algorithm>\n               urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256\n
        \          </dskpp:Algorithm>\n       </dskpp:SupportedMacAlgorithms>\n       <dskpp:SupportedProtocolVariants>\n
        \          <dskpp:TwoPass>\n               <dskpp:SupportedKeyProtectionMethod>\n
        \                  urn:ietf:params:xml:schema:keyprov:dskpp:wrap\n               </dskpp:SupportedKeyProtectionMethod>\n
        \              <dskpp:Payload>\n                   <ds:KeyInfo>\n                       <ds:KeyName>Pre-shared-key-1</ds:KeyName>\n
        \                  </ds:KeyInfo>\n               </dskpp:Payload>\n           </dskpp:TwoPass>\n
        \      </dskpp:SupportedProtocolVariants>\n       <dskpp:SupportedKeyPackages>\n
        \          <dskpp:KeyPackageFormat>\n               urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container\n
        \          </dskpp:KeyPackageFormat>\n       </dskpp:SupportedKeyPackages>\n
        \      <dskpp:AuthenticationData>\n           <dskpp:ClientID>AC00000A</dskpp:ClientID>\n
        \          <dskpp:AuthenticationCodeMac>\n               <dskpp:Nonce>\n                   ESIzRFVmd4iZqrvM3e7/ESIzRFVmd4iZqrvM3e7/ESI=\n
        \              </dskpp:Nonce>\n               <dskpp:IterationCount>1</dskpp:IterationCount>\n
        \              <dskpp:Mac\n                   MacAlgorithm=\n                   \"urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256\">\n
        \                  3eRz51ILqiG+dJW2iLcjuA==\n               </dskpp:Mac>\n
        \          </dskpp:AuthenticationCodeMac>\n       </dskpp:AuthenticationData>\n
        \  </dskpp:KeyProvClientHello>\n   In this example, the server responds to
        the previous request by\n   returning a key package in which the provisioning
        key was encrypted\n   using the Key Wrap key protection method.\n   <?xml
        version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n   <dskpp:KeyProvServerFinished\n
        \      xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\"\n       xmlns:dskpp=\"urn:ietf:params:xml:ns:keyprov:dskpp\"\n
        \      xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\"\n       xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\n
        \      xmlns:dkey=\"http://www.w3.org/2009/xmlsec-derivedkey#\"\n       xmlns:pkcs5=\n
        \          \"http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#\"\n
        \      Version=\"1.0\"\n       Status=\"Success\"\n       SessionID=\"4114\">\n
        \      <dskpp:KeyPackage>\n            <dskpp:KeyContainer Version=\"1.0\"
        Id=\"KC0001\">\n                <pskc:EncryptionKey>\n                   <ds:KeyName>Pre-shared-key-1</ds:KeyName>\n
        \               </pskc:EncryptionKey>\n                <pskc:MACMethod\n                    Algorithm=\n
        \                      \"http://www.w3.org/2000/09/xmldsig#hmac-sha1\">\n
        \                   <pskc:MACKey>\n                        <xenc:EncryptionMethod\n
        \                           Algorithm=\n                         \"http://www.w3.org/2001/04/xmlenc#aes128-cbc\"/>\n
        \                       <xenc:CipherData>\n                            <xenc:CipherValue>\n
        \       2GTTnLwM3I4e5IO5FkufoMUBJBuAf25hARFv0Z7MFk9Ecdb04PWY/qaeCbrgz7Es\n
        \                            </xenc:CipherValue>\n                        </xenc:CipherData>\n
        \                   </pskc:MACKey>\n                </pskc:MACMethod>\n                <pskc:KeyPackage>\n
        \                   <pskc:DeviceInfo>\n                        <pskc:Manufacturer>\n
        \                          TokenVendorAcme\n                        </pskc:Manufacturer>\n
        \                       <pskc:SerialNo>\n                           987654321\n
        \                       </pskc:SerialNo>\n                        <pskc:StartDate>\n
        \                          2009-09-01T00:00:00Z\n                        </pskc:StartDate>\n
        \                       <pskc:ExpiryDate>\n                           2014-09-01T00:00:00Z\n
        \                       </pskc:ExpiryDate>\n                    </pskc:DeviceInfo>\n
        \                   <pskc:CryptoModuleInfo>\n                        <pskc:Id>CM_ID_001</pskc:Id>\n
        \                   </pskc:CryptoModuleInfo>\n                    <pskc:Key\n
        \                       Id=\"MBK000000001\"\n                        Algorithm=\n
        \                          \"urn:ietf:params:xml:ns:keyprov:pskc:hotp\">\n
        \                       <pskc:Issuer>Example-Issuer</pskc:Issuer>\n                        <pskc:AlgorithmParameters>\n
        \                         <pskc:ResponseFormat Length=\"6\"\n                             Encoding=\"DECIMAL\"/>\n
        \                       </pskc:AlgorithmParameters>\n                        <pskc:Data>\n
        \                           <pskc:Secret>\n                                <pskc:EncryptedValue>\n
        \                                 <xenc:EncryptionMethod\n                                  Algorithm=\n
        \                        \"http://www.w3.org/2001/04/xmlenc#aes128-cbc\"/>\n
        \                                   <xenc:CipherData>\n                                        <xenc:CipherValue>\n
        \                                           oTvo+S22nsmS2Z/RtcoF8AabC6vr\n
        \                                           09sh0QIU+E224S96sZjpV+6nFYgn\n
        \                                           6525OoepbPnL/fGuuey64WCYXoqh\n
        \                                           Tg==\n                                        </xenc:CipherValue>\n
        \                                   </xenc:CipherData>\n                               </pskc:EncryptedValue>\n
        \                              <pskc:ValueMAC>\n                                   o+e9xgMVUbYuZH9UHe0W9dIo88A=\n
        \                              </pskc:ValueMAC>\n                           </pskc:Secret>\n
        \                          <pskc:Counter>\n                               <pskc:PlainValue>0</pskc:PlainValue>\n
        \                          </pskc:Counter>\n                       </pskc:Data>\n
        \                      <pskc:Policy>\n                           <pskc:KeyUsage>OTP</pskc:KeyUsage>\n
        \                      </pskc:Policy>\n                   </pskc:Key>\n               </pskc:KeyPackage>\n
        \          </dskpp:KeyContainer>\n       </dskpp:KeyPackage>\n       <dskpp:Mac\n
        \          MacAlgorithm=\n              \"urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256\">\n
        \          l53BmSO6qUzoIgbQegimsKk2es+WRpEl0YFqaOp5PGE=\n       </dskpp:Mac>\n
        \  </dskpp:KeyProvServerFinished>\n"
      title: B.3.2.  Example Using the Key Wrap Method
    - contents:
      - "B.3.3.  Example Using the Passphrase-Based Key Wrap Method\n   The client
        sends a request similar to that in Appendix B.3.1 with\n   Authentication
        Data based on an Authentication Code, and the server\n   responds using the
        Passphrase-Based Key Wrap method to encrypt the\n   provisioning key (note
        that the encryption is derived from the\n   password component of the Authentication
        Code).  The Authentication\n   Data is set in clear text when it is sent over
        a secure transport\n   channel such as TLS [RFC5246].\n   <?xml version=\"1.0\"
        encoding=\"UTF-8\" standalone=\"yes\"?>\n   <dskpp:KeyProvClientHello\n       xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\"\n
        \      xmlns:dskpp=\"urn:ietf:params:xml:ns:keyprov:dskpp\"\n       xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\"\n
        \      xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\n       Version=\"1.0\">\n
        \      <dskpp:DeviceIdentifierData>\n           <dskpp:DeviceId>\n               <pskc:Manufacturer>TokenVendorAcme</pskc:Manufacturer>\n
        \              <pskc:SerialNo>987654321</pskc:SerialNo>\n               <pskc:StartDate>2009-09-01T00:00:00Z</pskc:StartDate>\n
        \              <pskc:ExpiryDate>2014-09-01T00:00:00Z</pskc:ExpiryDate>\n           </dskpp:DeviceId>\n
        \      </dskpp:DeviceIdentifierData>\n       <dskpp:SupportedKeyTypes>\n           <dskpp:Algorithm>\n
        \              urn:ietf:params:xml:ns:keyprov:pskc:hotp\n           </dskpp:Algorithm>\n
        \          <dskpp:Algorithm>\n    http://www.rsa.com/rsalabs/otps/schemas/2005/09/otps-wst#SecurID-AES\n
        \          </dskpp:Algorithm>\n       </dskpp:SupportedKeyTypes>\n       <dskpp:SupportedEncryptionAlgorithms>\n
        \          <dskpp:Algorithm>\n               http://www.w3.org/2001/04/xmlenc#rsa_1_5\n
        \          </dskpp:Algorithm>\n       </dskpp:SupportedEncryptionAlgorithms>\n
        \      <dskpp:SupportedMacAlgorithms>\n           <dskpp:Algorithm>\n               urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256\n
        \          </dskpp:Algorithm>\n       </dskpp:SupportedMacAlgorithms>\n       <dskpp:SupportedProtocolVariants>\n
        \          <dskpp:TwoPass>\n               <dskpp:SupportedKeyProtectionMethod>\n
        \               urn:ietf:params:xml:schema:keyprov:dskpp:passphrase-wrap\n
        \              </dskpp:SupportedKeyProtectionMethod>\n               <dskpp:Payload>\n
        \                  <ds:KeyInfo>\n                       <ds:KeyName>Passphrase-1</ds:KeyName>\n
        \                  </ds:KeyInfo>\n               </dskpp:Payload>\n           </dskpp:TwoPass>\n
        \      </dskpp:SupportedProtocolVariants>\n       <dskpp:SupportedKeyPackages>\n
        \          <dskpp:KeyPackageFormat>\n               urn:ietf:params:xml:ns:keyprov:dskpp:pskc-key-container\n
        \          </dskpp:KeyPackageFormat>\n       </dskpp:SupportedKeyPackages>\n
        \      <dskpp:AuthenticationData>\n           <dskpp:ClientID>AC00000A</dskpp:ClientID>\n
        \          <dskpp:AuthenticationCodeMac>\n               <dskpp:Nonce>\n                   ESIzRFVmd4iZqrvM3e7/ESIzRFVmd4iZqrvM3e7/ESI=\n
        \              </dskpp:Nonce>\n               <dskpp:IterationCount>1</dskpp:IterationCount>\n
        \              <dskpp:Mac\n                   MacAlgorithm=\n                  \"urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256\">\n
        \                 K4YvLMN6Q1DZvtShoCxQag==\n               </dskpp:Mac>\n
        \          </dskpp:AuthenticationCodeMac>\n       </dskpp:AuthenticationData>\n
        \  </dskpp:KeyProvClientHello>\n   In this example, the server responds to
        the previous request by\n   returning a key package in which the provisioning
        key was encrypted\n   using the Passphrase-Based Key Wrap key protection method.\n
        \  <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n   <dskpp:KeyProvServerFinished\n
        \      xmlns:pskc=\"urn:ietf:params:xml:ns:keyprov:pskc\"\n       xmlns:dskpp=\"urn:ietf:params:xml:ns:keyprov:dskpp\"\n
        \      xmlns:xenc=\"http://www.w3.org/2001/04/xmlenc#\"\n       xmlns:ds=\"http://www.w3.org/2000/09/xmldsig#\"\n
        \      xmlns:dkey=\"http://www.w3.org/2009/xmlsec-derivedkey#\"\n       xmlns:pkcs5=\n
        \         \"http://www.rsasecurity.com/rsalabs/pkcs/schemas/pkcs-5v2-0#\"\n
        \      Version=\"1.0\"\n       Status=\"Success\"\n       SessionID=\"4114\">\n
        \      <dskpp:KeyPackage>\n           <dskpp:KeyContainer Version=\"1.0\"
        Id=\"KC0002\">\n               <pskc:EncryptionKey>\n                   <dkey:DerivedKey>\n
        \                      <dkey:KeyDerivationMethod\n                       Algorithm=\n
        \                      \"http://www.rsasecurity.com/rsalabs/pkcs/schemas/\n
        \                      pkcs-5v2-0#pbkdf2\">\n                           <pkcs5:PBKDF2-params>\n
        \                              <Salt>\n                                   <Specified>Ej7/PEpyEpw=</Specified>\n
        \                              </Salt>\n                               <IterationCount>1000</IterationCount>\n
        \                              <KeyLength>16</KeyLength>\n                           </pkcs5:PBKDF2-params>\n
        \                      </dkey:KeyDerivationMethod>\n                       <xenc:ReferenceList>\n
        \                          <xenc:DataReference URI=\"#ED\"/>\n                       </xenc:ReferenceList>\n
        \                      <dkey:MasterKeyName>\n                          Passphrase1\n
        \                      </dkey:MasterKeyName>\n                   </dkey:DerivedKey>\n
        \              </pskc:EncryptionKey>\n               <pskc:MACMethod\n                   Algorithm=\n
        \                     \"http://www.w3.org/2000/09/xmldsig#hmac-sha1\">\n                   <pskc:MACKey>\n
        \                      <xenc:EncryptionMethod\n                           Algorithm=\n
        \                        \"http://www.w3.org/2001/04/xmlenc#aes128-cbc\"/>\n
        \                      <xenc:CipherData>\n                           <xenc:CipherValue>\n
        \       2GTTnLwM3I4e5IO5FkufoOEiOhNj91fhKRQBtBJYluUDsPOLTfUvoU2dStyOwYZx\n
        \                          </xenc:CipherValue>\n                       </xenc:CipherData>\n
        \                  </pskc:MACKey>\n               </pskc:MACMethod>\n               <pskc:KeyPackage>\n
        \                  <pskc:DeviceInfo>\n                       <pskc:Manufacturer>\n
        \                         TokenVendorAcme\n                       </pskc:Manufacturer>\n
        \                      <pskc:SerialNo>\n                          987654321\n
        \                      </pskc:SerialNo>\n                       <pskc:StartDate>\n
        \                         2009-09-01T00:00:00Z\n                       </pskc:StartDate>\n
        \                      <pskc:ExpiryDate>\n                          2014-09-01T00:00:00Z\n
        \                      </pskc:ExpiryDate>\n                   </pskc:DeviceInfo>\n
        \                  <pskc:CryptoModuleInfo>\n                       <pskc:Id>CM_ID_001</pskc:Id>\n
        \                  </pskc:CryptoModuleInfo>\n                   <pskc:Key\n
        \                      Id=\"MBK000000001\"\n                       Algorithm=\n
        \                         \"urn:ietf:params:xml:ns:keyprov:pskc:hotp\">\n
        \                      <pskc:Issuer>Example-Issuer</pskc:Issuer>\n                       <pskc:AlgorithmParameters>\n
        \                         <pskc:ResponseFormat Length=\"6\"\n                             Encoding=\"DECIMAL\"/>\n
        \                      </pskc:AlgorithmParameters>\n                       <pskc:Data>\n
        \                          <pskc:Secret>\n                               <pskc:EncryptedValue>\n
        \                                  <xenc:EncryptionMethod\n                                       Algorithm=\n
        \                                      \"http://www.w3.org/2001/04/\n                                       xmlenc#aes128-cbc\"/>\n
        \                                  <xenc:CipherData>\n                                       <xenc:CipherValue>\n
        \                                        oTvo+S22nsmS2Z/RtcoF8HX385uMWgJ\n
        \                                        myIFMESBmcvtHQXp/6T1TgCS9CsgKtm\n
        \                                        cOrF8VoK254tZKnrAjiD5cdw==\n                                       </xenc:CipherValue>\n
        \                                  </xenc:CipherData>\n                               </pskc:EncryptedValue>\n
        \                              <pskc:ValueMAC>\n                                   pbgEbVYxoYs0x41wdeC7eDRbUEk=\n
        \                              </pskc:ValueMAC>\n                           </pskc:Secret>\n
        \                          <pskc:Counter>\n                               <pskc:PlainValue>0</pskc:PlainValue>\n
        \                          </pskc:Counter>\n                       </pskc:Data>\n
        \                      <pskc:Policy>\n                           <pskc:KeyUsage>OTP</pskc:KeyUsage>\n
        \                      </pskc:Policy>\n                   </pskc:Key>\n               </pskc:KeyPackage>\n
        \          </dskpp:KeyContainer>\n       </dskpp:KeyPackage>\n       <dskpp:Mac
        MacAlgorithm=\n           \"urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256\">\n
        \          Jc4VsNODYXgfbDmTn9qQZgcL3cKoa//j/NRT7sTpKOM=\n       </dskpp:Mac>\n
        \  </dskpp:KeyProvServerFinished>\n"
      title: B.3.3.  Example Using the Passphrase-Based Key Wrap Method
    title: B.3.  Two-Pass Protocol
  title: Appendix B.  Examples
- contents:
  - "Appendix C.  Integration with PKCS #11\n   A DSKPP Client that needs to communicate
    with a connected\n   cryptographic module to perform a DSKPP exchange MAY use
    PKCS #11\n   [PKCS-11] as a programming interface as described herein.  This\n
    \  appendix forms an informative part of the document.\n"
  - contents:
    - "C.1.  The Four-Pass Variant\n   When performing four-pass DSKPP with a cryptographic
      module using the\n   PKCS #11 programming interface, the procedure described
      in\n   [CT-KIP-P11], Appendix B, is RECOMMENDED.\n"
    title: C.1.  The Four-Pass Variant
  - contents:
    - "C.2.  The Two-Pass Variant\n   A suggested procedure to perform two-pass DSKPP
      with a cryptographic\n   module through the PKCS #11 interface using the mechanisms
      defined in\n   [CT-KIP-P11] is as follows:\n   a.  On the client side,\n       1.
      \ The client selects a suitable slot and token (e.g., through\n           use
      of the <DeviceIdentifier> or the <PlatformInfo> element\n           of the DSKPP
      trigger message).\n       2.  A nonce R is generated, e.g., by calling C_SeedRandom
      and\n           C_GenerateRandom.\n       3.  The client sends its first message
      to the server, including\n           the nonce R.\n   b.  On the server side,\n
      \      1.  A generic key K_PROV = K_TOKEN | K_MAC (where '|' denotes\n           concatenation)
      is generated, e.g., by calling C_GenerateKey\n           (using key type CKK_GENERIC_SECRET).
      \ The template for K_PROV\n           MUST allow it to be exported (but only
      in wrapped form, i.e.,\n           CKA_SENSITIVE MUST be set to CK_TRUE and
      CKA_EXTRACTABLE MUST\n           also be set to CK_TRUE), and also to be used
      for further key\n           derivation.  From K, a token key K_TOKEN of suitable
      type is\n           derived by calling C_DeriveKey using the PKCS #11 mechanism\n
      \          CKM_EXTRACT_KEY_FROM_KEY and setting the CK_EXTRACT_PARAMS to\n           the
      first bit of the generic secret key (i.e., set to 0).\n           Likewise,
      a MAC key K_MAC is derived from K_PROV by calling\n           C_DeriveKey using
      the CKM_EXTRACT_KEY_FROM_KEY mechanism,\n           this time setting CK_EXTRACT_PARAMS
      to the length of K_PROV\n           (in bits) divided by two.\n       2.  The
      server wraps K_PROV with either the public key of the\n           DSKPP Client
      or device, the pre-shared secret key, or the\n           derived shared secret
      key by using C_WrapKey.  If use of the\n           DSKPP key wrap algorithm
      has been negotiated, then the\n           CKM_KIP_WRAP mechanism MUST be used
      to wrap K.  When calling\n           C_WrapKey, the hKey handle in the CK_KIP_PARAMS
      structure\n           MUST be set to NULL_PTR.  The pSeed parameter in the\n
      \          CK_KIP_PARAMS structure MUST point to the nonce R provided by\n           the
      DSKPP Client, and the ulSeedLen parameter MUST indicate\n           the length
      of R.  The hWrappingKey parameter in the call to\n           C_WrapKey MUST
      be set to refer to the key wrapping key.\n       3.  Next, the server needs
      to calculate a MAC using K_MAC.  If\n           use of the DSKPP MAC algorithm
      has been negotiated, then the\n           MAC is calculated by calling C_SignInit
      with the CKM_KIP_MAC\n           mechanism followed by a call to C_Sign.  In
      the call to\n           C_SignInit, K_MAC MUST be the signature key, the hKey\n
      \          parameter in the CK_KIP_PARAMS structure MUST be set to\n           NULL_PTR,
      the pSeed parameter of the CT_KIP_PARAMS structure\n           MUST be set to
      NULL_PTR, and the ulSeedLen parameter MUST be\n           set to zero.  In the
      call to C_Sign, the pData parameter MUST\n           be set to the concatenation
      of the string ServerID and the\n           nonce R, and the ulDataLen parameter
      MUST be set to the\n           length of the concatenated string.  The desired
      length of the\n           MAC MUST be specified through the pulSignatureLen
      parameter\n           and MUST be set to the length of R.\n       4.  If the
      server also needs to authenticate its message (due to\n           an existing
      K_TOKEN being replaced), the server MUST\n           calculate a second MAC.
      \ Again, if use of the DSKPP MAC\n           algorithm has been negotiated,
      then the MAC is calculated by\n           calling C_SignInit with the CKM_KIP_MAC
      mechanism followed by\n           a call to C_Sign.  In this call to C_SignInit,
      the K_MAC'\n           existing before this DSKPP run MUST be the signature
      key (the\n           implementation may specify K_MAC' to be the value of the\n
      \          K_TOKEN that is being replaced, or a version of K_MAC from\n           the
      previous protocol run), the hKey parameter in the\n           CK_KIP_PARAMS
      structure MUST be set to NULL, the pSeed\n           parameter of the CT_KIP_PARAMS
      structure MUST be set to\n           NULL_PTR, and the ulSeedLen parameter MUST
      be set to zero.\n           In the call to C_Sign, the pData parameter MUST
      be set to the\n           concatenation of the string ServerID and the nonce
      R, and the\n           ulDataLen parameter MUST be set to the length of concatenated\n
      \          string.  The desired length of the MAC MUST be specified\n           through
      the pulSignatureLen parameter and MUST be set to the\n           length of R.\n
      \      5.  The server sends its message to the client, including the\n           wrapped
      key K_TOKEN, the MAC and possibly also the\n           authenticating MAC.\n
      \  c.  On the client side,\n       1.  The client calls C_UnwrapKey to receive
      a handle to K.  After\n           this, the client calls C_DeriveKey twice:
      once to derive\n           K_TOKEN and once to derive K_MAC.  The client MUST
      use the\n           same mechanism (CKM_EXTRACT_KEY_FROM_KEY) and the same\n
      \          mechanism parameters as used by the server above.  When\n           calling
      C_UnwrapKey and C_DeriveKey, the pTemplate parameter\n           MUST be used
      to set additional key attributes in accordance\n           with local policy
      and as negotiated and expressed in the\n           protocol.  In particular,
      the value of the <KeyID> element in\n           the server's response message
      MAY be used as CKA_ID for\n           K_TOKEN.  The key K_PROV MUST be destroyed
      after deriving\n           K_TOKEN and K_MAC.\n       2.  The MAC is verified
      in a reciprocal fashion as it was\n           generated by the server.  If use
      of the CKM_KIP_MAC mechanism\n           has been negotiated, then in the call
      to C_VerifyInit, the\n           hKey parameter in the CK_KIP_PARAMS structure
      MUST be set to\n           NULL_PTR, the pSeed parameter MUST be set to NULL_PTR,
      and\n           ulSeedLen MUST be set to 0.  The hKey parameter of\n           C_VerifyInit
      MUST refer to K_MAC.  In the call to C_Verify,\n           pData MUST be set
      to the concatenation of the string ServerID\n           and the nonce R, and
      the ulDataLen parameter MUST be set to\n           the length of the concatenated
      string, pSignature to the MAC\n           value received from the server, and
      ulSignatureLen to the\n           length of the MAC.  If the MAC does not verify
      the protocol\n           session ends with a failure.  The token MUST be constructed\n
      \          to not \"commit\" to the new K_TOKEN or the new K_MAC unless\n           the
      MAC verifies.\n       3.  If an authenticating MAC was received (REQUIRED if
      the new\n           K_TOKEN will replace an existing key on the token), then
      it\n           is verified in a similar vein but using the K_MAC' associated\n
      \          with this server and existing before the protocol run (the\n           implementation
      may specify K_MAC' to be the value of the\n           K_TOKEN that is being
      replaced, or a version of K_MAC from\n           the previous protocol run).
      \ Again, if the MAC does not\n           verify the protocol session ends with
      a failure, and the\n           token MUST be constructed not to \"commit\" to
      the new K_TOKEN\n           or the new K_MAC unless the MAC verifies.\n"
    title: C.2.  The Two-Pass Variant
  title: 'Appendix C.  Integration with PKCS #11'
- contents:
  - 'Appendix D.  Example of DSKPP-PRF Realizations

    '
  - contents:
    - "D.1.  Introduction\n   This example appendix defines DSKPP-PRF in terms of
      AES [FIPS197-AES]\n   and HMAC [RFC2104].  This appendix forms a normative part
      of the\n   document.\n"
    title: D.1.  Introduction
  - contents:
    - 'D.2.  DSKPP-PRF-AES

      '
    - contents:
      - "D.2.1.  Identification\n   For cryptographic modules supporting this realization
        of DSKPP-PRF,\n   the following URN MUST be used to identify this algorithm
        in DSKPP:\n   urn:ietf:params:xml:ns:keyprov:dskpp:prf-aes-128\n   When this
        URN is used to identify the encryption algorithm, the\n   method for encryption
        of R_C values described in Section 4.2.4 MUST\n   be used.\n"
      title: D.2.1.  Identification
    - contents:
      - "D.2.2.  Definition\n   DSKPP-PRF-AES (k, s, dsLen)\n   Input:\n   k         Encryption
        key to use\n   s         Octet string consisting of randomizing material.
        \ The\n             length of the string s is sLen.\n   dsLen     Desired
        length of the output\n   Output:\n   DS        A pseudorandom string, dsLen-octets
        long\n   Steps:\n   1.  Let bLen be the output block size of AES in octets:\n
        \      bLen = (AES output block length in octets)\n       (normally, bLen
        = 16)\n   2.  If dsLen > (2**32 - 1) * bLen, output \"derived data too long\"
        and\n       stop\n   3.  Let n be the number of bLen-octet blocks in the output
        data,\n       rounding up, and let j be the number of octets in the last block:\n
        \      n = CEILING( dsLen / bLen)\n       j = dsLen - (n - 1) * bLen\n   4.
        \ For each block of the pseudorandom string DS, apply the function\n       F
        defined below to the key k, the string s and the block index to\n       compute
        the block:\n       B1 = F (k, s, 1) ,\n       B2 = F (k, s, 2) ,\n       ...\n
        \      Bn = F (k, s, n)\n   The function F is defined in terms of the CMAC
        construction from\n   [NIST-SP800-38B], using AES as the block cipher:\n   F
        (k, s, i) = CMAC-AES (k, INT (i) || s)\n   where INT (i) is a four-octet encoding
        of the integer i, most\n   significant octet first, and the output length
        of CMAC is set to\n   bLen.\n   Concatenate the blocks and extract the first
        dsLen octets to produce\n   the desired data string DS:\n   DS = B1 || B2
        || ... || Bn<0..j-1>\n   Output the derived data DS.\n"
      title: D.2.2.  Definition
    - contents:
      - "D.2.3.  Example\n   If we assume that dsLen = 16, then:\n   n = 16 / 16 =
        1\n   j = 16 - (1 - 1) * 16 = 16\n   DS = B1 = F (k, s, 1) = CMAC-AES (k,
        INT (1) || s)\n"
      title: D.2.3.  Example
    title: D.2.  DSKPP-PRF-AES
  - contents:
    - 'D.3.  DSKPP-PRF-SHA256

      '
    - contents:
      - "D.3.1.  Identification\n   For cryptographic modules supporting this realization
        of DSKPP-PRF,\n   the following URN MUST be used to identify this algorithm
        in DSKPP:\n   urn:ietf:params:xml:ns:keyprov:dskpp:prf-sha256\n   When this
        URN is used to identify the encryption algorithm to use,\n   the method for
        encryption of R_C values described in Section 4.2.4\n   MUST be used.\n"
      title: D.3.1.  Identification
    - contents:
      - "D.3.2.  Definition\n   DSKPP-PRF-SHA256 (k, s, dsLen)\n   Input:\n   k         Encryption
        key to use\n   s         Octet string consisting of randomizing material.
        \ The\n             length of the string s is sLen.\n   dsLen     Desired
        length of the output\n   Output:\n   DS        A pseudorandom string, dsLen-octets
        long\n   Steps:\n   1.  Let bLen be the output size of SHA-256 in octets of
        [FIPS180-SHA]\n       (no truncation is done on the HMAC output):\n       bLen
        = 32\n       (normally, bLen = 16)\n   2.  If dsLen > (2**32 - 1) * bLen,
        output \"derived data too long\" and\n       stop\n   3.  Let n be the number
        of bLen-octet blocks in the output data,\n       rounding up, and let j be
        the number of octets in the last block:\n       n = CEILING( dsLen / bLen)\n
        \      j = dsLen - (n - 1) * bLen\n   4.  For each block of the pseudorandom
        string DS, apply the function\n       F defined below to the key k, the string
        s and the block index to\n       compute the block:\n       B1 = F (k, s,
        1),\n       B2 = F (k, s, 2),\n       ...\n       Bn = F (k, s, n)\n   The
        function F is defined in terms of the HMAC construction from\n   [RFC2104],
        using SHA-256 as the digest algorithm:\n   F (k, s, i) = HMAC-SHA256 (k, INT
        (i) || s)\n   where INT (i) is a four-octet encoding of the integer i, most\n
        \  significant octet first, and the output length of HMAC is set to\n   bLen.\n
        \  Concatenate the blocks and extract the first dsLen octets to produce\n
        \  the desired data string DS:\n   DS = B1 || B2 || ... || Bn<0..j-1>\n   Output
        the derived data DS.\n"
      title: D.3.2.  Definition
    - contents:
      - "D.3.3.  Example\n   If we assume that sLen = 256 (two 128-octet long values)
        and dsLen =\n   16, then:\n   n = CEILING( 16 / 32 ) = 1\n   j = 16 - (1 -
        1) * 32 = 16\n   B1 = F (k, s, 1) = HMAC-SHA256 (k, INT (1) || s)\n   DS =
        B1<0 ... 15>\n   That is, the result will be the first 16 octets of the HMAC
        output.\n"
      title: D.3.3.  Example
    title: D.3.  DSKPP-PRF-SHA256
  title: Appendix D.  Example of DSKPP-PRF Realizations
- contents:
  - "Authors' Addresses\n   Andrea Doherty\n   RSA, The Security Division of EMC\n
    \  174 Middlesex Turnpike\n   Bedford, MA  01730\n   USA\n   EMail: andrea.doherty@rsa.com\n
    \  Mingliang Pei\n   VeriSign, Inc.\n   487 E. Middlefield Road\n   Mountain View,
    CA  94043\n   USA\n   EMail: mpei@verisign.com\n   Salah Machani\n   Diversinet
    Corp.\n   2225 Sheppard Avenue East, Suite 1801\n   Toronto, Ontario  M2J 5C2\n
    \  Canada\n   EMail: smachani@diversinet.com\n   Magnus Nystrom\n   Microsoft
    Corp.\n   One Microsoft Way\n   Redmond, WA  98052\n   USA\n   EMail: mnystrom@microsoft.com\n"
  title: Authors' Addresses
