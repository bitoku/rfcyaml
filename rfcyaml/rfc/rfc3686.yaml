- contents:
  - "         Using Advanced Encryption Standard (AES) Counter Mode\n            With
    IPsec Encapsulating Security Payload (ESP)\n"
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2004).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document describes the use of Advanced Encryption Standard
    (AES)\n   Counter Mode, with an explicit initialization vector, as an IPsec\n
    \  Encapsulating Security Payload (ESP) confidentiality mechanism.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  2\n       1.1.  Conventions Used In This Document. . . . . . . .
    . . . .  2\n   2.  AES Block Cipher . . . . . . . . . . . . . . . . . . . . .
    . .  2\n       2.1.  Counter Mode . . . . . . . . . . . . . . . . . . . . . .
    \ 2\n       2.2.  Key Size and Rounds. . . . . . . . . . . . . . . . . . .  5\n
    \      2.3.  Block Size . . . . . . . . . . . . . . . . . . . . . . .  5\n   3.
    \ ESP Payload. . . . . . . . . . . . . . . . . . . . . . . . . .  5\n       3.1.
    \ Initialization Vector. . . . . . . . . . . . . . . . . .  6\n       3.2.  Encrypted
    Payload. . . . . . . . . . . . . . . . . . . .  6\n       3.3.  Authentication
    Data. . . . . . . . . . . . . . . . . . .  6\n   4.  Counter Block Format . .
    . . . . . . . . . . . . . . . . . . .  7\n   5.  IKE Conventions. . . . . . .
    . . . . . . . . . . . . . . . . .  8\n       5.1.  Keying Material and Nonces
    . . . . . . . . . . . . . . .  8\n       5.2.  Phase 1 Identifier . . . . . .
    . . . . . . . . . . . . .  9\n       5.3.  Phase 2 Identifier . . . . . . . .
    . . . . . . . . . . .  9\n       5.4.  Key Length Attribute . . . . . . . . .
    . . . . . . . . .  9\n   6.  Test Vectors . . . . . . . . . . . . . . . . . .
    . . . . . . .  9\n   7.  Security Considerations. . . . . . . . . . . . . . .
    . . . . . 12\n   8.  Design Rationale . . . . . . . . . . . . . . . . . . . .
    . . . 14\n   9.  IANA Considerations. . . . . . . . . . . . . . . . . . . . .
    . 16\n   10. Intellectual Property Statement. . . . . . . . . . . . . . . . 16\n
    \  11. Acknowledgments. . . . . . . . . . . . . . . . . . . . . . . . 16\n   12.
    References . . . . . . . . . . . . . . . . . . . . . . . . . . 17\n       12.1.
    Normative References . . . . . . . . . . . . . . . . . . 17\n       12.2. Informative
    References . . . . . . . . . . . . . . . . . 17\n   13. Author's Address . . .
    . . . . . . . . . . . . . . . . . . . . 18\n   14. Full Copyright Statement .
    . . . . . . . . . . . . . . . . . . 19\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The National Institute of Standards and Technology (NIST)
    recently\n   selected the Advanced Encryption Standard (AES) [AES], also known
    as\n   Rijndael.  The AES is a block cipher, and it can be used in many\n   different
    modes.  This document describes the use of AES Counter Mode\n   (AES-CTR), with
    an explicit initialization vector (IV), as an IPsec\n   Encapsulating Security
    Payload (ESP) [ESP] confidentiality mechanism.\n   This document does not provide
    an overview of IPsec.  However,\n   information about how the various components
    of IPsec and the way in\n   which they collectively provide security services
    is available in\n   [ARCH] and [ROADMAP].\n"
  - contents:
    - "1.1.  Conventions Used In This Document\n   The key words \"MUST\", \"MUST
      NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\",
      \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted
      as described in [STDWORDS].\n"
    title: 1.1.  Conventions Used In This Document
  title: 1.  Introduction
- contents:
  - "2.  AES Block Cipher\n   This section contains a brief description of the relevant\n
    \  characteristics of the AES block cipher.  Implementation requirements\n   are
    also discussed.\n"
  - contents:
    - "2.1.  Counter Mode\n   NIST has defined five modes of operation for AES and
      other FIPS-\n   approved block ciphers [MODES].  Each of these modes has different\n
      \  characteristics.  The five modes are: ECB (Electronic Code Book), CBC\n   (Cipher
      Block Chaining), CFB (Cipher FeedBack), OFB (Output\n   FeedBack), and CTR (Counter).\n
      \  Only AES Counter mode (AES-CTR) is discussed in this specification.\n   AES-CTR
      requires the encryptor to generate a unique per-packet value,\n   and communicate
      this value to the decryptor.  This specification\n   calls this per-packet value
      an initialization vector (IV).  The same\n   IV and key combination MUST NOT
      be used more than once.  The\n   encryptor can generate the IV in any manner
      that ensures uniqueness.\n   Common approaches to IV generation include incrementing
      a counter for\n   each packet and linear feedback shift registers (LFSRs).\n
      \  This specification calls for the use of a nonce for additional\n   protection
      against precomputation attacks.  The nonce value need not\n   be secret.  However,
      the nonce MUST be unpredictable prior to the\n   establishment of the IPsec
      security association that is making use of\n   AES-CTR.\n   AES-CTR has many
      properties that make it an attractive encryption\n   algorithm for in high-speed
      networking.  AES-CTR uses the AES block\n   cipher to create a stream cipher.
      \ Data is encrypted and decrypted by\n   XORing with the key stream produced
      by AES encrypting sequential\n   counter block values.  AES-CTR is easy to implement,
      and AES-CTR can\n   be pipelined and parallelized.  AES-CTR also supports key
      stream\n   precomputation.\n   Pipelining is possible because AES has multiple
      rounds (see section\n   2.2).  A hardware implementation (and some software
      implementations)\n   can create a pipeline by unwinding the loop implied by
      this round\n   structure.  For example, after a 16-octet block has been input,
      one\n   round later another 16-octet block can be input, and so on.  In AES-\n
      \  CTR, these inputs are the sequential counter block values used to\n   generate
      the key stream.\n   Multiple independent AES encrypt implementations can also
      be used to\n   improve performance.  For example, one could use two AES encrypt\n
      \  implementations in parallel, to process a sequence of counter block\n   values,
      doubling the effective throughput.\n   The sender can precompute the key stream.
      \ Since the key stream does\n   not depend on any data in the packet, the key
      stream can be\n   precomputed once the nonce and IV are assigned.  This precomputation\n
      \  can reduce packet latency.  The receiver cannot perform similar\n   precomputation
      because the IV will not be known before the packet\n   arrives.\n   AES-CTR
      uses the only AES encrypt operation (for both encryption and\n   decryption),
      making AES-CTR implementations smaller than\n   implementations of many other
      AES modes.\n   When used correctly, AES-CTR provides a high level of\n   confidentiality.
      \ Unfortunately, AES-CTR is easy to use incorrectly.\n   Being a stream cipher,
      any reuse of the per-packet value, called the\n   IV, with the same nonce and
      key is catastrophic.  An IV collision\n   immediately leaks information about
      the plaintext in both packets.\n   For this reason, it is inappropriate to use
      this mode of operation\n   with static keys.  Extraordinary measures would be
      needed to prevent\n   reuse of an IV value with the static key across power
      cycles.  To be\n   safe, implementations MUST use fresh keys with AES-CTR.  The
      Internet\n   Key Exchange (IKE) [IKE] protocol can be used to establish fresh\n
      \  keys.  IKE can also provide the nonce value.\n   With AES-CTR, it is trivial
      to use a valid ciphertext to forge other\n   (valid to the decryptor) ciphertexts.
      \ Thus, it is equally\n   catastrophic to use AES-CTR without a companion authentication\n
      \  function.  Implementations MUST use AES-CTR in conjunction with an\n   authentication
      function, such as HMAC-SHA-1-96 [HMAC-SHA].\n   To encrypt a payload with AES-CTR,
      the encryptor partitions the\n   plaintext, PT, into 128-bit blocks.  The final
      block need not be 128\n   bits; it can be less.\n      PT = PT[1] PT[2] ...
      PT[n]\n   Each PT block is XORed with a block of the key stream to generate
      the\n   ciphertext, CT.  The AES encryption of each counter block results in\n
      \  128 bits of key stream.  The most significant 96 bits of the counter\n   block
      are set to the nonce value, which is 32 bits, followed by the\n   per-packet
      IV value, which is 64 bits.  The least significant 32 bits\n   of the counter
      block are initially set to one.  This counter value is\n   incremented by one
      to generate subsequent counter blocks, each\n   resulting in another 128 bits
      of key stream.  The encryption of n\n   plaintext blocks can be summarized as:\n
      \     CTRBLK := NONCE || IV || ONE\n      FOR i := 1 to n-1 DO\n        CT[i]
      := PT[i] XOR AES(CTRBLK)\n        CTRBLK := CTRBLK + 1\n      END\n      CT[n]
      := PT[n] XOR TRUNC(AES(CTRBLK))\n   The AES() function performs AES encryption
      with the fresh key.\n   The TRUNC() function truncates the output of the AES
      encrypt\n   operation to the same length as the final plaintext block, returning\n
      \  the most significant bits.\n   Decryption is similar.  The decryption of
      n ciphertext blocks can be\n   summarized as:\n      CTRBLK := NONCE || IV ||
      ONE\n      FOR i := 1 to n-1 DO\n        PT[i] := CT[i] XOR AES(CTRBLK)\n        CTRBLK
      := CTRBLK + 1\n      END\n      PT[n] := CT[n] XOR TRUNC(AES(CTRBLK))\n"
    title: 2.1.  Counter Mode
  - contents:
    - "2.2.  Key Size and Rounds\n   AES supports three key sizes: 128 bits, 192 bits,
      and 256 bits.  The\n   default key size is 128 bits, and all implementations
      MUST support\n   this key size.  Implementations MAY also support key sizes
      of 192\n   bits and 256 bits.\n   AES uses a different number of rounds for
      each of the defined key\n   sizes.  When a 128-bit key is used, implementations
      MUST use 10\n   rounds.  When a 192-bit key is used, implementations MUST use
      12\n   rounds.  When a 256-bit key is used, implementations MUST use 14\n   rounds.\n"
    title: 2.2.  Key Size and Rounds
  - contents:
    - "2.3.  Block Size\n   The AES has a block size of 128 bits (16 octets).  As
      such, when\n   using AES-CTR, each AES encrypt operation generates 128 bits
      of key\n   stream.  AES-CTR encryption is the XOR of the key stream with the\n
      \  plaintext.  AES-CTR decryption is the XOR of the key stream with the\n   ciphertext.
      \ If the generated key stream is longer than the plaintext\n   or ciphertext,
      the extra key stream bits are simply discarded.  For\n   this reason, AES-CTR
      does not require the plaintext to be padded to a\n   multiple of the block size.
      \ However, to provide limited traffic flow\n   confidentiality, padding MAY
      be included, as specified in [ESP].\n"
    title: 2.3.  Block Size
  title: 2.  AES Block Cipher
- contents:
  - "3.  ESP Payload\n   The ESP payload is comprised of the IV followed by the ciphertext.\n
    \  The payload field, as defined in [ESP], is structured as shown in\n   Figure
    1.\n    0                   1                   2                   3\n    0 1
    2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |                     Initialization Vector                     |\n   |                            (8
    octets)                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |                                                               |\n   ~                  Encrypted
    Payload (variable)                 ~\n   |                                                               |\n
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                                                               |\n
    \  ~                 Authentication Data (variable)                ~\n   |                                                               |\n
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   Figure
    1.  ESP Payload Encrypted with AES-CTR\n"
  - contents:
    - "3.1.  Initialization Vector\n   The AES-CTR IV field MUST be eight octets.
      \ The IV MUST be chosen by\n   the encryptor in a manner that ensures that the
      same IV value is used\n   only once for a given key.  The encryptor can generate
      the IV in any\n   manner that ensures uniqueness.  Common approaches to IV generation\n
      \  include incrementing a counter for each packet and linear feedback\n   shift
      registers (LFSRs).\n   Including the IV in each packet ensures that the decryptor
      can\n   generate the key stream needed for decryption, even when some packets\n
      \  are lost or reordered.\n"
    title: 3.1.  Initialization Vector
  - contents:
    - "3.2.  Encrypted Payload\n   The encrypted payload contains the ciphertext.\n
      \  AES-CTR mode does not require plaintext padding.  However, ESP does\n   require
      padding to 32-bit word-align the authentication data.  The\n   padding, Pad
      Length, and the Next Header MUST be concatenated with\n   the plaintext before
      performing encryption, as described in [ESP].\n"
    title: 3.2.  Encrypted Payload
  - contents:
    - "3.3.  Authentication Data\n   Since it is trivial to construct a forgery AES-CTR
      ciphertext from a\n   valid AES-CTR ciphertext, AES-CTR implementations MUST
      employ a non-\n   NULL ESP authentication method.  HMAC-SHA-1-96 [HMAC-SHA]
      is a likely\n   choice.\n"
    title: 3.3.  Authentication Data
  title: 3.  ESP Payload
- contents:
  - "4.  Counter Block Format\n   Each packet conveys the IV that is necessary to
    construct the\n   sequence of counter blocks used to generate the key stream necessary\n
    \  to decrypt the payload.  The AES counter block cipher block is 128\n   bits.
    \ Figure 2 shows the format of the counter block.\n    0                   1                   2
    \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5
    6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |                            Nonce                              |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  |                  Initialization Vector (IV)                   |\n   |                                                               |\n
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                         Block
    Counter                         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \  Figure 2.  Counter Block Format\n   The components of the counter block are
    as follows:\n   Nonce\n      The Nonce field is 32 bits.  As the name implies,
    the nonce is a\n      single use value.  That is, a fresh nonce value MUST be
    assigned\n      for each security association.  It MUST be assigned at the\n      beginning
    of the security association.  The nonce value need not\n      be secret, but it
    MUST be unpredictable prior to the beginning of\n      the security association.\n
    \  Initialization Vector\n      The IV field is 64 bits.  As described in section
    3.1, the IV MUST\n      be chosen by the encryptor in a manner that ensures that
    the same\n      IV value is used only once for a given key.\n   Block Counter\n
    \     The block counter field is the least significant 32 bits of the\n      counter
    block.  The block counter begins with the value of one,\n      and it is incremented
    to generate subsequent portions of the key\n      stream.  The block counter is
    a 32-bit big-endian integer value.\n   Using the encryption process described
    in section 2.1, this\n   construction permits each packet to consist of up to:\n
    \     (2^32)-1 blocks  =  4,294,967,295 blocks\n                       = 68,719,476,720
    octets\n   This construction can produce enough key stream for each packet\n   sufficient
    to handle any IPv6 jumbogram [JUMBO].\n"
  title: 4.  Counter Block Format
- contents:
  - "5.  IKE Conventions\n   This section describes the conventions used to generate
    keying\n   material and nonces for use with AES-CTR using the Internet Key\n   Exchange
    (IKE) [IKE] protocol.  The identifiers and attributes needed\n   to negotiate
    a security association which uses AES-CTR are also\n   defined.\n"
  - contents:
    - "5.1.  Keying Material and Nonces\n   As described in section 2.1, implementations
      MUST use fresh keys with\n   AES-CTR.  IKE can be used to establish fresh keys.
      \ This section\n   describes the conventions for obtaining the unpredictable
      nonce value\n   from IKE.  Note that this convention provides a nonce value
      that is\n   secret as well as unpredictable.\n   IKE makes use of a pseudo-random
      function (PRF) to derive keying\n   material.  The PRF is used iteratively to
      derive keying material of\n   arbitrary size, called KEYMAT.  Keying material
      is extracted from the\n   output string without regard to boundaries.\n   The
      size of the requested KEYMAT MUST be four octets longer than is\n   needed for
      the associated AES key.  The keying material is used as\n   follows:\n   AES-CTR
      with a 128 bit key\n      The KEYMAT requested for each AES-CTR key is 20 octets.
      \ The first\n      16 octets are the 128-bit AES key, and the remaining four
      octets\n      are used as the nonce value in the counter block.\n   AES-CTR
      with a 192 bit key\n      The KEYMAT requested for each AES-CTR key is 28 octets.
      \ The first\n      24 octets are the 192-bit AES key, and the remaining four
      octets\n      are used as the nonce value in the counter block.\n   AES-CTR
      with a 256 bit key\n      The KEYMAT requested for each AES-CTR key is 36 octets.
      \ The first\n      32 octets are the 256-bit AES key, and the remaining four
      octets\n      are used as the nonce value in the counter block.\n"
    title: 5.1.  Keying Material and Nonces
  - contents:
    - "5.2.  Phase 1 Identifier\n   This document does not specify the conventions
      for using AES-CTR for\n   IKE Phase 1 negotiations.  For AES-CTR to be used
      in this manner, a\n   separate specification is needed, and an Encryption Algorithm\n
      \  Identifier needs to be assigned.\n"
    title: 5.2.  Phase 1 Identifier
  - contents:
    - "5.3.  Phase 2 Identifier\n   For IKE Phase 2 negotiations, IANA has assigned
      an ESP Transform\n   Identifier of 13 for AES-CTR with an explicit IV.\n"
    title: 5.3.  Phase 2 Identifier
  - contents:
    - "5.4.  Key Length Attribute\n   Since the AES supports three key lengths, the
      Key Length attribute\n   MUST be specified in the IKE Phase 2 exchange [DOI].
      \ The Key Length\n   attribute MUST have a value of 128, 192, or 256.\n"
    title: 5.4.  Key Length Attribute
  title: 5.  IKE Conventions
- contents:
  - "6.  Test Vectors\n   This section contains nine test vectors, which can be used
    to confirm\n   that an implementation has correctly implemented AES-CTR.  The
    first\n   three test vectors use AES with a 128 bit key; the next three test\n
    \  vectors use AES with a 192 bit key; and the last three test vectors\n   use
    AES with a 256 bit key.\n   Test Vector #1: Encrypting 16 octets using AES-CTR
    with 128-bit key\n   AES Key          : AE 68 52 F8 12 10 67 CC 4B F7 A5 76 55
    77 F3 9E\n   AES-CTR IV       : 00 00 00 00 00 00 00 00\n   Nonce            :
    00 00 00 30\n   Plaintext String : 'Single block msg'\n   Plaintext        : 53
    69 6E 67 6C 65 20 62 6C 6F 63 6B 20 6D 73 67\n   Counter Block (1): 00 00 00 30
    00 00 00 00 00 00 00 00 00 00 00 01\n   Key Stream    (1): B7 60 33 28 DB C2 93
    1B 41 0E 16 C8 06 7E 62 DF\n   Ciphertext       : E4 09 5D 4F B7 A7 B3 79 2D 61
    75 A3 26 13 11 B8\n   Test Vector #2: Encrypting 32 octets using AES-CTR with
    128-bit key\n   AES Key          : 7E 24 06 78 17 FA E0 D7 43 D6 CE 1F 32 53 91
    63\n   AES-CTR IV       : C0 54 3B 59 DA 48 D9 0B\n   Nonce            : 00 6C
    B6 DB\n   Plaintext        : 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\n
    \                   : 10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F\n   Counter
    Block (1): 00 6C B6 DB C0 54 3B 59 DA 48 D9 0B 00 00 00 01\n   Key Stream    (1):
    51 05 A3 05 12 8F 74 DE 71 04 4B E5 82 D7 DD 87\n   Counter Block (2): 00 6C B6
    DB C0 54 3B 59 DA 48 D9 0B 00 00 00 02\n   Key Stream    (2): FB 3F 0C EF 52 CF
    41 DF E4 FF 2A C4 8D 5C A0 37\n   Ciphertext       : 51 04 A1 06 16 8A 72 D9 79
    0D 41 EE 8E DA D3 88\n                    : EB 2E 1E FC 46 DA 57 C8 FC E6 30 DF
    91 41 BE 28\n   Test Vector #3: Encrypting 36 octets using AES-CTR with 128-bit
    key\n   AES Key          : 76 91 BE 03 5E 50 20 A8 AC 6E 61 85 29 F9 A0 DC\n   AES-CTR
    IV       : 27 77 7F 3F  4A 17 86 F0\n   Nonce            : 00 E0 01 7B\n   Plaintext
    \       : 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\n                    :
    10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F\n                    : 20 21 22
    23\n   Counter Block (1): 00 E0 01 7B 27 77 7F 3F 4A 17 86 F0 00 00 00 01\n   Key
    Stream    (1): C1 CE 4A AB 9B 2A FB DE C7 4F 58 E2 E3 D6 7C D8\n   Counter Block
    (2): 00 E0 01 7B 27 77 7F 3F 4A 17 86 F0 00 00 00 02\n   Key Stream    (2): 55
    51 B6 38 CA 78 6E 21 CD 83 46 F1 B2 EE 0E 4C\n   Counter Block (3): 00 E0 01 7B
    27 77 7F 3F 4A 17 86 F0 00 00 00 03\n   Key Stream    (3): 05 93 25 0C 17 55 36
    00 A6 3D FE CF 56 23 87 E9\n   Ciphertext       : C1 CF 48 A8 9F 2F FD D9 CF 46
    52 E9 EF DB 72 D7\n                    : 45 40 A4 2B DE 6D 78 36 D5 9A 5C EA AE
    F3 10 53\n                    : 25 B2 07 2F\n   Test Vector #4: Encrypting 16
    octets using AES-CTR with 192-bit key\n   AES Key          : 16 AF 5B 14 5F C9
    F5 79 C1 75 F9 3E 3B FB 0E ED\n                    : 86 3D 06 CC FD B7 85 15\n
    \  AES-CTR IV       : 36 73 3C 14 7D 6D 93 CB\n   Nonce            : 00 00 00
    48\n   Plaintext String : 'Single block msg'\n   Plaintext        : 53 69 6E 67
    6C 65 20 62 6C 6F 63 6B 20 6D 73 67\n   Counter Block (1): 00 00 00 48 36 73 3C
    14 7D 6D 93 CB 00 00 00 01\n   Key Stream    (1): 18 3C 56 28 8E 3C E9 AA 22 16
    56 CB 23 A6 9A 4F\n   Ciphertext       : 4B 55 38 4F E2 59 C9 C8 4E 79 35 A0 03
    CB E9 28\n   Test Vector #5: Encrypting 32 octets using AES-CTR with 192-bit key\n
    \  AES Key          : 7C 5C B2 40 1B 3D C3 3C 19 E7 34 08 19 E0 F6 9C\n                    :
    67 8C 3D B8 E6 F6 A9 1A\n   AES-CTR IV       : 02 0C 6E AD C2 CB 50 0D\n   Nonce
    \           : 00 96 B0 3B\n   Plaintext        : 00 01 02 03 04 05 06 07 08 09
    0A 0B 0C 0D 0E 0F\n                    : 10 11 12 13 14 15 16 17 18 19 1A 1B 1C
    1D 1E 1F\n   Counter Block (1): 00 96 B0 3B 02 0C 6E AD C2 CB 50 0D 00 00 00 01\n
    \  Key Stream    (1): 45 33 41 FF 64 9E 25 35 76 D6 A0 F1 7D 3C C3 90\n   Counter
    Block (2): 00 96 B0 3B 02 0C 6E AD C2 CB 50 0D 00 00 00 02\n   Key Stream    (2):
    94 81 62 0F 4E C1 B1 8B E4 06 FA E4 5E E9 E5 1F\n   Ciphertext       : 45 32 43
    FC 60 9B 23 32 7E DF AA FA 71 31 CD 9F\n                    : 84 90 70 1C 5A D4
    A7 9C FC 1F E0 FF 42 F4 FB 00\n   Test Vector #6: Encrypting 36 octets using AES-CTR
    with 192-bit key\n   AES Key          : 02 BF 39 1E E8 EC B1 59 B9 59 61 7B 09
    65 27 9B\n                    : F5 9B 60 A7 86 D3 E0 FE\n   AES-CTR IV       :
    5C BD 60 27 8D CC 09 12\n   Nonce            : 00 07 BD FD\n   Plaintext        :
    00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\n                    : 10 11 12
    13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F\n                    : 20 21 22 23\n   Counter
    Block (1): 00 07 BD FD 5C BD 60 27 8D CC 09 12 00 00 00 01\n   Key Stream    (1):
    96 88 3D C6 5A 59 74 28 5C 02 77 DA D1 FA E9 57\n   Counter Block (2): 00 07 BD
    FD 5C BD 60 27 8D CC 09 12 00 00 00 02\n   Key Stream    (2): C2 99 AE 86 D2 84
    73 9F 5D 2F D2 0A 7A 32 3F 97\n   Counter Block (3): 00 07 BD FD 5C BD 60 27 8D
    CC 09 12 00 00 00 03\n   Key Stream    (3): 8B CF 2B 16 39 99 B2 26 15 B4 9C D4
    FE 57 39 98\n   Ciphertext       : 96 89 3F C5 5E 5C 72 2F 54 0B 7D D1 DD F7 E7
    58\n                    : D2 88 BC 95 C6 91 65 88 45 36 C8 11 66 2F 21 88\n                    :
    AB EE 09 35\n   Test Vector #7: Encrypting 16 octets using AES-CTR with 256-bit
    key\n   AES Key          : 77 6B EF F2 85 1D B0 6F 4C 8A 05 42 C8 69 6F 6C\n                    :
    6A 81 AF 1E EC 96 B4 D3 7F C1 D6 89 E6 C1 C1 04\n   AES-CTR IV       : DB 56 72
    C9 7A A8 F0 B2\n   Nonce            : 00 00 00 60\n   Plaintext String : 'Single
    block msg'\n   Plaintext        : 53 69 6E 67 6C 65 20 62 6C 6F 63 6B 20 6D 73
    67\n   Counter Block (1): 00 00 00 60 DB 56 72 C9 7A A8 F0 B2 00 00 00 01\n   Key
    Stream    (1): 47 33 BE 7A D3 E7 6E A5 3A 67 00 B7 51 8E 93 A7\n   Ciphertext
    \      : 14 5A D0 1D BF 82 4E C7 56 08 63 DC 71 E3 E0 C0\n   Test Vector #8: Encrypting
    32 octets using AES-CTR with 256-bit key\n   AES Key          : F6 D6 6D 6B D5
    2D 59 BB 07 96 36 58 79 EF F8 86\n                    : C6 6D D5 1A 5B 6A 99 74
    4B 50 59 0C 87 A2 38 84\n   AES-CTR IV       : C1 58 5E F1 5A 43 D8 75\n   Nonce
    \           : 00 FA AC 24\n   Plaintext        : 00 01 02 03 04 05 06 07 08 09
    0A 0B 0C 0D 0E 0F\n                    : 10 11 12 13 14 15 16 17 18 19 1A 1B 1C
    1D 1E 1F\n   Counter block (1): 00 FA AC 24 C1 58 5E F1 5A 43 D8 75 00 00 00 01\n
    \  Key stream    (1): F0 5F 21 18 3C 91 67 2B 41 E7 0A 00 8C 43 BC A6\n   Counter
    block (2): 00 FA AC 24 C1 58 5E F1 5A 43 D8 75 00 00 00 02\n   Key stream    (2):
    A8 21 79 43 9B 96 8B 7D 4D 29 99 06 8F 59 B1 03\n   Ciphertext       : F0 5E 23
    1B 38 94 61 2C 49 EE 00 0B 80 4E B2 A9\n                    : B8 30 6B 50 8F 83
    9D 6A 55 30 83 1D 93 44 AF 1C\n   Test Vector #9: Encrypting 36 octets using AES-CTR
    with 256-bit key\n   AES Key          : FF 7A 61 7C E6 91 48 E4 F1 72 6E 2F 43
    58 1D E2\n                    : AA 62 D9 F8 05 53 2E DF F1 EE D6 87 FB 54 15 3D\n
    \  AES-CTR IV       : 51 A5 1D 70 A1 C1 11 48\n   Nonce            : 00 1C C5
    B7\n   Plaintext        : 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F\n                    :
    10 11 12 13 14 15 16 17 18 19 1A 1B 1C 1D 1E 1F\n                    : 20 21 22
    23\n   Counter block (1): 00 1C C5 B7 51 A5 1D 70 A1 C1 11 48 00 00 00 01\n   Key
    stream    (1): EB 6D 50 81 19 0E BD F0 C6 7C 9E 4D 26 C7 41 A5\n   Counter block
    (2): 00 1C C5 B7 51 A5 1D 70 A1 C1 11 48 00 00 00 02\n   Key stream    (2): A4
    16 CD 95 71 7C EB 10 EC 95 DA AE 9F CB 19 00\n   Counter block (3): 00 1C C5 B7
    51 A5 1D 70 A1 C1 11 48 00 00 00 03\n   Key stream    (3): 3E E1 C4 9B C6 B9 CA
    21 3F 6E E2 71 D0 A9 33 39\n   Ciphertext       : EB 6C 52 82 1D 0B BB F7 CE 75
    94 46 2A CA 4F AA\n                    : B4 07 DF 86 65 69 FD 07 F4 8C C0 B5 83
    D6 07 1F\n                    : 1E C0 E6 B8\n"
  title: 6.  Test Vectors
- contents:
  - "7.  Security Considerations\n   When used properly, AES-CTR mode provides strong
    confidentiality.\n   Bellare, Desai, Jokipii, Rogaway show in [BDJR] that the
    privacy\n   guarantees provided by counter mode are at least as strong as those\n
    \  for CBC mode when using the same block cipher.\n   Unfortunately, it is very
    easy to misuse this counter mode.  If\n   counter block values are ever used for
    more that one packet with the\n   same key, then the same key stream will be used
    to encrypt both\n   packets, and the confidentiality guarantees are voided.\n
    \  What happens if the encryptor XORs the same key stream with two\n   different
    plaintexts?  Suppose two plaintext byte sequences P1, P2,\n   P3 and Q1, Q2, Q3
    are both encrypted with key stream K1, K2, K3.  The\n   two corresponding ciphertexts
    are:\n      (P1 XOR K1), (P2 XOR K2), (P3 XOR K3)\n      (Q1 XOR K1), (Q2 XOR
    K2), (Q3 XOR K3)\n   If both of these two ciphertext streams are exposed to an
    attacker,\n   then a catastrophic failure of confidentiality results, since:\n
    \     (P1 XOR K1) XOR (Q1 XOR K1) = P1 XOR Q1\n      (P2 XOR K2) XOR (Q2 XOR K2)
    = P2 XOR Q2\n      (P3 XOR K3) XOR (Q3 XOR K3) = P3 XOR Q3\n   Once the attacker
    obtains the two plaintexts XORed together, it is\n   relatively straightforward
    to separate them.  Thus, using any stream\n   cipher, including AES-CTR, to encrypt
    two plaintexts under the same\n   key stream leaks the plaintext.\n   Therefore,
    stream ciphers, including AES-CTR, should not be used with\n   static keys.  It
    is inappropriate to use AES-CTR with static keys.\n   Extraordinary measures would
    be needed to prevent reuse of a counter\n   block value with the static key across
    power cycles.  To be safe, ESP\n   implementations MUST use fresh keys with AES-CTR.
    \ The Internet Key\n   Exchange (IKE) protocol [IKE] can be used to establish
    fresh keys.\n   IKE can also be used to establish the nonce at the beginning of
    the\n   security association.\n   When IKE is used to establish fresh keys between
    two peer entities,\n   separate keys are established for the two traffic flows.
    \ When a\n   mechanism other than IKE is used to establish fresh keys, and that\n
    \  mechanism establishes only a single key to encrypt packets, then\n   there
    is a high probability that the peers will select the same IV\n   values for some
    packets.  Thus, to avoid counter block collisions,\n   ESP implementations that
    permit use of the same key for encrypting\n   outbound traffic and decrypting
    incoming traffic with the same peer\n   MUST ensure that the two peers assign
    different Nonce values to the\n   security association.\n   Data forgery is trivial
    with CTR mode.  The demonstration of this\n   attack is similar to the key stream
    reuse discussion above.  If a\n   known plaintext byte sequence P1, P2, P3 is
    encrypted with key stream\n   K1, K2, K3, then the attacker can replace the plaintext
    with one of\n   his own choosing.  The ciphertext is:\n      (P1 XOR K1), (P2
    XOR K2), (P3 XOR K3)\n   The attacker simply XORs a selected sequence Q1, Q2,
    Q3 with the\n   ciphertext to obtain:\n      (Q1 XOR (P1 XOR K1)), (Q2 XOR (P2
    XOR K2)), (Q3 XOR (P3 XOR K3))\n   Which is the same as:\n      ((Q1 XOR P1) XOR
    K1), ((Q2 XOR P2) XOR K2), ((Q3 XOR P3) XOR K3)\n   Decryption of the attacker-generated
    ciphertext will yield exactly\n   what the attacker intended:\n      (Q1 XOR P1),
    (Q2 XOR P2), (Q3 XOR P3)\n   Accordingly, ESP implementations MUST use of AES-CTR
    in conjunction\n   with ESP authentication.\n   Additionally, since AES has a
    128-bit block size, regardless of the\n   mode employed, the ciphertext generated
    by AES encryption becomes\n   distinguishable from random values after 2^64 blocks
    are encrypted\n   with a single key.  Since ESP with Enhanced Sequence Numbers
    allows\n   for up to 2^64 packets in a single security association, there is\n
    \  real potential for more than 2^64 blocks to be encrypted with one\n   key.
    \ Therefore, implementations SHOULD generate a fresh key before\n   2^64 blocks
    are encrypted with the same key.  Note that ESP with 32-\n   bit Sequence Numbers
    will not exceed 2^64 blocks even if all of the\n   packets are maximum-length
    IPv6 jumbograms [JUMBO].\n   There are fairly generic precomputation attacks against
    all block\n   cipher modes that allow a meet-in-the-middle attack against the
    key.\n   These attacks require the creation and searching of huge tables of\n
    \  ciphertext associated with known plaintext and known keys.  Assuming\n   that
    the memory and processor resources are available for a\n   precomputation attack,
    then the theoretical strength of AES-CTR (and\n   any other block cipher mode)
    is limited to 2^(n/2) bits, where n is\n   the number of bits in the key.  The
    use of long keys is the best\n   countermeasure to precomputation attacks.  Therefore,
    implementations\n   that employ 128-bit AES keys should take precautions to make
    the\n   precomputation attacks more difficult.  The unpredictable nonce value\n
    \  in the counter block significantly increases the size of the table\n   that
    the attacker must compute to mount a successful attack.\n"
  title: 7.  Security Considerations
- contents:
  - "8.  Design Rationale\n   In the development of this specification, the use of
    the ESP sequence\n   number field instead of an explicit IV field was considered.
    \ This\n   selection is not a cryptographic security issue, as either approach\n
    \  will prevent counter block collisions.\n   In a very conservative model of
    encryption security, at most 2^64\n   blocks ought to be encrypted with AES-CTR
    under a single key.  Under\n   this constraint, no more than 64 bits are needed
    to identify each\n   packet within a security association.  Since the ESP extended\n
    \  sequence number is 64 bits, it is an obvious candidate for use as an\n   implicit
    IV.  This would dictate a single method for the assignment\n   of per-packet value
    in the counter block.  The use of an explicit IV\n   does not dictate such a method,
    which is desirable for several\n   reasons.\n   1. Only the encryptor can ensure
    that the value is not used for more\n      than one packet, so there is no advantage
    to selecting a mechanism\n      that allows the decryptor to determine whether
    counter block\n      values collide.  Damage from the collision is done, whether
    the\n      decryptor detects it or not.\n   2. Allows adders, LFSRs, and any other
    technique that meets the time\n      budget of the encryptor, so long as the technique
    results in a\n      unique value for each packet.  Adders are simple and\n      straightforward
    to implement, but due to carries, they do not\n      execute in constant time.
    \ LFSRs offer an alternative that\n      executes in constant time.\n   3. Complexity
    is in control of the implementer.  Further, the\n      decision made by the implementer
    of the encryptor does not make\n      the decryptor more (or less) complex.\n
    \  4. When the encryptor has more than one cryptographic hardware\n      device,
    an IV prefix can be assigned to each device, ensuring that\n      collisions will
    not occur.  Yet, since the decryptor does not need\n      to examine IV structure,
    the decryptor is unaffected by the IV\n      structure selected by the encryptor.
    \ One cannot make use of the\n      same technique with the ESP sequence numbers,
    because the\n      semantics for them require sequential value generation.\n   5.
    \ Assurance boundaries are very important to implementations that\n      will
    be evaluated against the FIPS Pub 140-1 or FIPS Pub 140-2\n      [SECRQMTS].  The
    assignment of the per-packet counter block value\n      needs to be inside the
    assurance boundary.  Some implementations\n      assign the sequence number inside
    the assurance boundary, but\n      others do not.  A sequence number collision
    does not have the dire\n      consequences, but, as described in section 6, a
    collision in\n      counter block values has disastrous consequences.\n   6. Coupling
    with the sequence number is possible in those\n      architectures where the sequence
    number assignment is performed\n      within the assurance boundary.  In this
    situation, the sequence\n      number and the IV field will contain the same value.\n
    \  7. Decoupling from the sequence number is possible in those\n      architectures
    where the sequence number assignment is performed\n      outside the assurance
    boundary.\n   The use of an explicit IV field directly follows from the decoupling\n
    \  of the sequence number and the per-packet counter block value.  The\n   overhead
    associated with 64 bits for the IV field is acceptable.\n   This overhead is significantly
    less than the overhead associated with\n   Cipher Block Chaining (CBC) mode.  As
    normally employed, CBC requires\n   a full block for the IV and, on average, half
    of a block for padding.\n   AES-CTR with an explicit IV has about one-third of
    the overhead as\n   AES-CBC, and the overhead is constant for each packet.\n   The
    inclusion of the nonce provides a weak countermeasure against\n   precomputation
    attacks.  For this countermeasure to be effective, the\n   attacker must not be
    able to predict the value of the nonce well in\n   advance of security association
    establishment.  The use of long keys\n   provides a strong countermeasure to precomputation
    attacks, and AES\n   offers key sizes that thwart these attacks for many decades
    to come.\n   A 28-bit block counter value is sufficient for the generation of
    a\n   key stream to encrypt the largest possible IPv6 jumbogram [JUMBO];\n   however,
    a 32-bit field is used.  This size is convenient for both\n   hardware and software
    implementations.\n"
  title: 8.  Design Rationale
- contents:
  - "9.  IANA Considerations\n   IANA has assigned 13 as the ESP transform number
    for AES-CTR with an\n   explicit IV.\n"
  title: 9.  IANA Considerations
- contents:
  - "10.  Intellectual Property Statement\n   The IETF takes no position regarding
    the validity or scope of any\n   intellectual property or other rights that might
    be claimed to\n   pertain to the implementation or use of the technology described
    in\n   this document or the extent to which any license under such rights\n   might
    or might not be available; neither does it represent that it\n   has made any
    effort to identify any such rights.  Information on the\n   IETF's procedures
    with respect to rights in standards-track and\n   standards-related documentation
    can be found in BCP-11. Copies of\n   claims of rights made available for publication
    and any assurances of\n   licenses to be made available, or the result of an attempt
    made to\n   obtain a general license or permission for the use of such\n   proprietary
    rights by implementors or users of this specification can\n   be obtained from
    the IETF Secretariat.\n   The IETF invites any interested party to bring to its
    attention any\n   copyrights, patents or patent applications, or other proprietary\n
    \  rights which may cover technology that may be required to practice\n   this
    standard.  Please address the information to the IETF Executive\n   Director.\n"
  title: 10.  Intellectual Property Statement
- contents:
  - "11.  Acknowledgements\n   This document is the result of extensive discussions
    and compromises.\n   While not all of the participants are completely satisfied
    with the\n   outcome, the document is better for their contributions.\n   The
    author thanks the members of the IPsec working group for their\n   contributions
    to the design, with special mention of the efforts of\n   (in alphabetical order)
    Steve Bellovin, David Black, Niels Ferguson,\n   Charlie Kaufman, Steve Kent,
    Tero Kivinen, Paul Koning, David McGrew,\n   Robert Moskowitz, Jesse Walker, and
    Doug Whiting.\n   The author thanks and Alireza Hodjat, John Viega, and Doug Whiting\n
    \  for assistance with the test vectors.\n"
  title: 11.  Acknowledgements
- contents:
  - "12.  References\n   This section provides normative and informative references.\n"
  - contents:
    - "12.1.  Normative References\n   [AES]       NIST, FIPS PUB 197, \"Advanced
      Encryption Standard (AES)\",\n               November 2001.\n   [DOI]       Piper,
      D., \"The Internet IP Security Domain of\n               Interpretation for
      ISAKMP\", RFC 2407, November 1998.\n   [ESP]       Kent, S. and R. Atkinson,
      \"IP Encapsulating Security\n               Payload (ESP)\", RFC 2406, November
      1998.\n   [MODES]     Dworkin, M., \"Recommendation for Block Cipher Modes of\n
      \              Operation: Methods and Techniques\", NIST Special\n               Publication
      800-38A, December 2001.\n   [STDWORDS]  Bradner, S., \"Key words for use in
      RFCs to Indicate\n               Requirement Levels\", BCP 14, RFC 2119, March
      1997.\n"
    title: 12.1.  Normative References
  - contents:
    - "12.2.  Informative References\n   [ARCH]      Kent, S. and R. Atkinson, \"Security
      Architecture for the\n               Internet Protocol\", RFC 2401, November
      1998.\n   [BDJR]      Bellare, M, Desai, A., Jokipii, E. and P. Rogaway, \"A\n
      \              Concrete Security Treatment of Symmetric Encryption:\n               Analysis
      of the DES Modes of Operation\", Proceedings 38th\n               Annual Symposium
      on Foundations of Computer Science,\n               1997.\n   [HMAC-SHA]  Madson,
      C. and R. Glenn, \"The Use of HMAC-SHA-1-96 within\n               ESP and AH\",
      RFC 2404, November 1998.\n   [IKE]       Harkins, D. and D. Carrel, \"The Internet
      Key Exchange\n               (IKE)\", RFC 2409, November 1998.\n   [JUMBO]     Borman,
      D., Deering, S. and R. Hinden, \"IPv6 Jumbograms\",\n               RFC 2675,
      August 1999.\n   [ROADMAP]   Thayer, R., Doraswamy, N. and R. Glenn, \"IP Security\n
      \              Document Roadmap\", RFC 2411, November 1998.\n   [SECRQMTS]  National
      Institute of Standards and Technology.  FIPS Pub\n               140-1: Security
      Requirements for Cryptographic Modules.\n               11 January 1994.\n               National
      Institute of Standards and Technology.  FIPS Pub\n               140-2: Security
      Requirements for Cryptographic Modules.\n               25 May 2001. [Supercedes
      FIPS Pub 140-1]\n"
    title: 12.2.  Informative References
  title: 12.  References
- contents:
  - "13.  Author's Address\n   Russell Housley\n   Vigil Security, LLC\n   918 Spring
    Knoll Drive\n   Herndon, VA 20170\n   USA\n   EMail: housley@vigilsec.com\n"
  title: 13.  Author's Address
- contents:
  - "14.  Full Copyright Statement\n   Copyright (C) The Internet Society (2004).
    \ All Rights Reserved.\n   This document and translations of it may be copied
    and furnished to\n   others, and derivative works that comment on or otherwise
    explain it\n   or assist in its implementation may be prepared, copied, published\n
    \  and distributed, in whole or in part, without restriction of any\n   kind,
    provided that the above copyright notice and this paragraph are\n   included on
    all such copies and derivative works.  However, this\n   document itself may not
    be modified in any way, such as by removing\n   the copyright notice or references
    to the Internet Society or other\n   Internet organizations, except as needed
    for the purpose of\n   developing Internet standards in which case the procedures
    for\n   copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assignees.\n   This document and the
    information contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET
    SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES,
    EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE
    OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  title: 14.  Full Copyright Statement
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
