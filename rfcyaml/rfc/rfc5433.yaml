- contents:
  - "                 Extensible Authentication Protocol -\n              Generalized
    Pre-Shared Key (EAP-GPSK) Method\n"
  title: __initial_text__
- contents:
  - "Status of This Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2009 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents
    in effect on the date of\n   publication of this document (http://trustee.ietf.org/license-info).\n
    \  Please review these documents carefully, as they describe your rights\n   and
    restrictions with respect to this document.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This memo defines an Extensible Authentication Protocol (EAP) method\n
    \  called EAP Generalized Pre-Shared Key (EAP-GPSK).  This method is a\n   lightweight
    shared-key authentication protocol supporting mutual\n   authentication and key
    derivation.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \  2. Terminology .....................................................4\n   3.
    Overview ........................................................6\n   4. Key
    Derivation ..................................................8\n   5. Key Management
    .................................................11\n   6. Ciphersuites ...................................................11\n
    \  7. Generalized Key Derivation Function (GKDF) .....................12\n   8.
    Ciphersuites Processing Rules ..................................13\n      8.1.
    Ciphersuite #1 ............................................13\n           8.1.1.
    Encryption .........................................13\n           8.1.2. Integrity
    ..........................................13\n      8.2. Ciphersuite #2 ............................................14\n
    \          8.2.1. Encryption .........................................14\n           8.2.2.
    Integrity ..........................................14\n   9. Packet Formats .................................................15\n
    \     9.1. Header Format .............................................15\n      9.2.
    Ciphersuite Formatting ....................................16\n      9.3. Payload
    Formatting ........................................16\n      9.4. Protected Data
    ............................................21\n   10. Packet Processing Rules
    .......................................24\n   11. Example Message Exchanges .....................................25\n
    \  12. Security Considerations .......................................28\n      12.1.
    Security Claims ..........................................28\n      12.2. Mutual
    Authentication ....................................29\n      12.3. Protected Result
    Indications .............................29\n      12.4. Integrity Protection
    .....................................29\n      12.5. Replay Protection ........................................30\n
    \     12.6. Reflection Attacks .......................................30\n      12.7.
    Dictionary Attacks .......................................30\n      12.8. Key
    Derivation and Key Strength ..........................31\n      12.9. Denial-of-Service
    Resistance .............................31\n      12.10. Session Independence
    ....................................32\n      12.11. Compromise of the PSK ...................................32\n
    \     12.12. Fragmentation ...........................................32\n      12.13.
    Channel Binding .........................................32\n      12.14. Fast
    Reconnect ..........................................33\n      12.15. Identity
    Protection .....................................33\n      12.16. Protected Ciphersuite
    Negotiation .......................33\n      12.17. Confidentiality .........................................34\n
    \     12.18. Cryptographic Binding ...................................34\n   13.
    IANA Considerations ...........................................34\n   14. Contributors
    ..................................................35\n   15. Acknowledgments ...............................................36\n
    \  16. References ....................................................37\n      16.1.
    Normative References .....................................37\n      16.2. Informative
    References ...................................38\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   EAP Generalized Pre-Shared Key (EAP-GPSK) is an EAP method
    defining a\n   generalized pre-shared key authentication technique.  Mutual\n
    \  authentication is achieved through a nonce-based exchange that is\n   secured
    by a pre-shared key.\n   EAP-GPSK addresses a large number of design goals with
    the intention\n   of being applicable in a broad range of usage scenarios.\n   The
    main design goals of EAP-GPSK are:\n   Simplicity:\n      EAP-GPSK should be easy
    to implement.\n   Security Model:\n      EAP-GPSK has been designed in a threat
    model where the attacker\n      has full control over the communication channel.
    \ This EAP threat\n      model is presented in Section 7.1 of [RFC3748].\n   Efficiency:\n
    \     EAP-GPSK does not make use of public key cryptography and fully\n      relies
    of symmetric cryptography.  The restriction of symmetric\n      cryptographic
    computations allows for low computational overhead.\n      Hence, EAP-GPSK is
    lightweight and well suited for any type of\n      device, especially those with
    processing power, memory, and\n      battery constraints.  Additionally, it seeks
    to minimize the\n      number of round trips.\n   Flexibility:\n      EAP-GPSK
    offers cryptographic flexibility.  At the beginning, the\n      EAP server proposes
    a list of ciphersuites.  The client then\n      selects one.  The current version
    of EAP-GPSK includes two\n      ciphersuites, but additional ones can be easily
    added.\n   Extensibility:\n      The design of EAP-GPSK allows to securely exchange
    information\n      between the EAP peer and the EAP server using protected data\n
    \     fields.  These fields might, for example, be used to exchange\n      channel
    binding information or to provide support for identity\n      confidentiality.\n"
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   In this document, several words are used to signify the requirements\n
    \  of the specification.  These words are often capitalized.  The key\n   words
    \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\",\n
    \  \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document\n
    \  are to be interpreted as described in [RFC2119].\n   This section describes
    the various variables and functions used in\n   the EAP-GPSK method.\n   Variables:\n
    \  CSuite_List:  An octet array listing available ciphersuites (variable\n      length).\n
    \  CSuite_Sel:  Ciphersuite selected by the peer (6 octets).\n   ID_Peer:  Peer
    Network Access Identifier (NAI) [RFC4282].\n   ID_Server:  Server identity as
    an opaque blob.\n   KS:  Integer representing the input key size, in octets, of
    the\n      selected ciphersuite CSuite_Sel.  The key size is one of the\n      ciphersuite
    parameters.\n   ML:  Integer representing the length of the Message Authentication\n
    \     Code (MAC) output, in octets, of the selected ciphersuite\n      CSuite_Sel.\n
    \  PD_Payload:  Data carried within the protected data payload.\n   PD_Payload_Block:
    \ Block of possibly multiple PD_Payloads carried by\n      a GPSK packet.\n   PL:
    \ Integer representing the length of the PSK in octets (2 octets).\n      PL MUST
    be larger than or equal to KS.\n   RAND_Peer:  Random integer generated by the
    peer (32 octets).\n   RAND_Server:  Random integer generated by the server (32
    octets).\n   Operations:\n   A || B:  Concatenation of octet strings A and B.\n
    \  A**B:  Integer exponentiation.\n   truncate(A,B):  Returns the first B octets
    of A.\n   ENC_X(Y):  Encryption of message Y with a symmetric key X, using a\n
    \     defined block cipher.\n   KDF-X(Y):  Key Derivation Function that generates
    an arbitrary number\n      of octets of output using secret X and seed Y.\n   length(X):
    \ Function that returns the length of input X in octets,\n      encoded as a 2-octet
    integer in network byte order.\n   MAC_X(Y):  Keyed message authentication code
    computed over Y with\n      symmetric key X.\n   SEC_X(Y):  SEC is a function
    that provides integrity protection based\n      on the chosen ciphersuite.  The
    function SEC uses the algorithm\n      defined by the selected ciphersuite and
    applies it to the message\n      content Y with key X.  In short, SEC_X(Y) = Y
    || MAC_X(Y).\n   X[A..B]:  Notation representing octets A through B of octet array
    X\n      where the first octet of the array has index zero.\n   The following
    abbreviations are used for the keying material:\n   EMSK:  Extended Master Session
    Key is exported by the EAP method (64\n          octets).\n   MK:    A session-specific
    Master Key between the peer and EAP server\n          from which all other EAP
    method session keys are derived (KS\n          octets).\n   MSK:   Master Session
    Key exported by the EAP method (64 octets).\n   PK:    Session key generated from
    the MK and used during protocol\n          exchange to encrypt protected data
    (KS octets).\n   PSK:   Long-term key shared between the peer and the server (PL\n
    \         octets).\n   SK:    Session key generated from the MK and used during
    protocol\n          exchange to demonstrate knowledge of the PSK (KS octets).\n"
  title: 2.  Terminology
- contents:
  - "3.  Overview\n   The EAP framework (see Section 1.3 of [RFC3748]) defines three
    basic\n   steps that occur during the execution of an EAP conversation between\n
    \  the EAP peer, the Authenticator, and the EAP server.\n   1.  The first phase,
    discovery, is handled by the underlying\n       protocol, e.g., IEEE 802.1X as
    utilized by IEEE 802.11 [80211].\n   2.  The EAP authentication phase with EAP-GPSK
    is defined in this\n       document.\n   3.  The secure association distribution
    and secure association phases\n       are handled differently depending on the
    underlying protocol.\n   EAP-GPSK performs mutual authentication between the EAP
    peer (\"Peer\")\n   and EAP server (\"Server\") based on a pre-shared key (PSK).
    \ The\n   protocol consists of the message exchanges (GPSK-1, ..., GPSK-4) in\n
    \  which both sides exchange nonces and their identities, and compute\n   and
    exchange a Message Authentication Code (MAC) over the previously\n   exchanged
    values, keyed with the pre-shared key.  This MAC is\n   considered as proof of
    possession of the pre-shared key.  Two further\n   messages, namely GPSK-Fail
    and GPSK-Protected-Fail, are used to deal\n   with error situations.\n   A successful
    protocol exchange is shown in Figure 1.\n   +--------+                                     +--------+\n
    \  |        |                EAP-Request/Identity |        |\n   |  EAP   |<------------------------------------|
    \ EAP   |\n   |  peer  |                                     | server |\n   |
    \       | EAP-Response/Identity               |        |\n   |        |------------------------------------>|
    \       |\n   |        |                                     |        |\n   |
    \       |                  EAP-Request/GPSK-1 |        |\n   |        |<------------------------------------|
    \       |\n   |        |                                     |        |\n   |
    \       | EAP-Response/GPSK-2                 |        |\n   |        |------------------------------------>|
    \       |\n   |        |                                     |        |\n   |
    \       |                  EAP-Request/GPSK-3 |        |\n   |        |<------------------------------------|
    \       |\n   |        |                                     |        |\n   |
    \       | EAP-Response/GPSK-4                 |        |\n   |        |------------------------------------>|
    \       |\n   |        |                                     |        |\n   |
    \       |          EAP-Success                |        |\n   |        |<------------------------------------|
    \       |\n   +--------+                                     +--------+\n                Figure
    1: EAP-GPSK: Successful Exchange\n   The full EAP-GPSK protocol is as follows:\n
    \  GPSK-1:\n      ID_Server, RAND_Server, CSuite_List\n   GPSK-2:\n      SEC_SK(ID_Peer,
    ID_Server, RAND_Peer, RAND_Server, CSuite_List,\n      CSuite_Sel, [ ENC_PK(PD_Payload_Block)
    ] )\n   GPSK-3:\n      SEC_SK(RAND_Peer, RAND_Server, ID_Server, CSuite_Sel, [\n
    \     ENC_PK(PD_Payload_Block) ] )\n   GPSK-4:\n      SEC_SK( [ ENC_PK(PD_Payload_Block)
    ] )\n   The EAP server begins EAP-GPSK by selecting a random number\n   RAND_Server
    and encoding the supported ciphersuites into CSuite_List.\n   A ciphersuite consists
    of an encryption algorithm, a key derivation\n   function, and a message authentication
    code.\n   In GPSK-1, the EAP server sends its identity ID_Server, a random\n   number
    RAND_Server, and a list of supported ciphersuites CSuite_List.\n   The decision
    of which ciphersuite to offer and which ciphersuite to\n   pick is policy- and
    implementation-dependent and, therefore, outside\n   the scope of this document.\n
    \  In GPSK-2, the peer sends its identity ID_Peer and a random number\n   RAND_Peer.
    \ Furthermore, it repeats the received parameters of the\n   GPSK-1 message (ID_Server,
    RAND_Server, CSuite_List) and the selected\n   ciphersuite.  It computes a Message
    Authentication Code over all the\n   transmitted parameters.\n   The EAP server
    verifies the received Message Authentication Code and\n   the consistency of the
    identities, nonces, and ciphersuite parameters\n   transmitted in GPSK-1.  In
    case of successful verification, the EAP\n   server computes a Message Authentication
    Code over the session\n   parameter and returns it to the peer (within GPSK-3).
    \ Within GPSK-2\n   and GPSK-3, the EAP peer and EAP server have the possibility
    to\n   exchange encrypted protected data parameters.\n   The peer verifies the
    received Message Authentication Code and the\n   consistency of the identities,
    nonces, and ciphersuite parameters\n   transmitted in GPSK-2.  If the verification
    is successful, GPSK-4 is\n   prepared.  This message can optionally contain the
    peer's protected\n   data parameters.\n   Upon receipt of GPSK-4, the server processes
    any included\n   PD_Payload_Block.  Then, the EAP server sends an EAP Success
    message\n   to indicate the successful outcome of the authentication.\n"
  title: 3.  Overview
- contents:
  - "4.  Key Derivation\n   EAP-GPSK provides key derivation in compliance to the
    requirements of\n   [RFC3748] and [RFC5247].  Note that this section provides
    an abstract\n   description for the key derivation procedure that needs to be\n
    \  instantiated with a specific ciphersuite.\n   The long-term credential shared
    between EAP peer and EAP server\n   SHOULD be a strong pre-shared key PSK of at
    least 16 octets, though\n   its length and entropy are variable.  While it is
    possible to use a\n   password or passphrase, doing so is NOT RECOMMENDED as EAP-GPSK
    is\n   vulnerable to dictionary attacks.\n   During an EAP-GPSK authentication,
    a Master Key MK, a Session Key SK,\n   and a Protected Data Encryption Key PK
    (if using an encrypting\n   ciphersuite) are derived using the ciphersuite-specified
    KDF and data\n   exchanged during the execution of the protocol, namely 'RAND_Peer
    ||\n   ID_Peer || RAND_Server || ID_Server', referred to as inputString in\n   its
    short-hand form.\n   In case of successful completion, EAP-GPSK derives and exports
    an MSK\n   and an EMSK, each 64 octets in length.\n   The following notation is
    used: KDF-X(Y, Z)[A..B], whereby\n   X  is the length, in octets, of the desired
    output,\n   Y  is a secret key,\n   Z  is the inputString,\n   [A..B]  extracts
    the string of octets starting with octet A and\n      finishing with octet B from
    the output of the KDF function.\n   This keying material is derived using the
    ciphersuite-specified KDF\n   as follows:\n   o  inputString = RAND_Peer || ID_Peer
    || RAND_Server || ID_Server\n   o  MK = KDF-KS(PSK[0..KS-1], PL || PSK || CSuite_Sel
    ||\n      inputString)[0..KS-1]\n   o  MSK = KDF-{128+2*KS}(MK, inputString)[0..63]\n
    \  o  EMSK = KDF-{128+2*KS}(MK, inputString)[64..127]\n   o  SK = KDF-{128+2*KS}(MK,
    inputString)[128..127+KS]\n   o  PK = KDF-{128+2*KS}(MK, inputString)[128+KS..127+2*KS]
    (if using\n      an encrypting ciphersuite)\n   The value for PL (the length of
    the PSK in octets) is encoded as a\n   2-octet integer in network byte order.
    \ Recall that KS is the length\n   of the ciphersuite input key size in octets.\n
    \  Additionally, the EAP keying framework [RFC5247] requires the\n   definition
    of a Method-ID, Session-ID, Peer-ID, and Server-ID.  These\n   values are defined
    as:\n   o  Method-ID = KDF-16(PSK[0..KS-1], \"Method ID\" || EAP_Method_Type ||\n
    \     CSuite_Sel || inputString)[0..15]\n   o  Session-ID = EAP_Method_Type ||
    Method_ID\n   o  Peer-ID = ID_Peer\n   o  Server-ID = ID_Server\n   EAP_Method_Type
    refers to the 1-octet, IANA-allocated EAP Type code\n   value.\n   Figure 2 depicts
    the key derivation procedure of EAP-GPSK.\n   +-------------+     +-------------------------------+\n
    \  |   PL-octet  |     | RAND_Peer || ID_Peer ||       |\n   |     PSK     |     |
    RAND_Server || ID_Server      |\n   +-------------+     +-------------------------------+\n
    \         |                            |            |\n          |     +------------+
    \        |            |\n          |     | CSuite_Sel |         |            |\n
    \         |     +------------+         |            |\n          |           |
    \               |            |\n          v           v                v            |\n
    \  +--------------------------------------------+   |\n   |                    KDF
    \                    |   |\n   +--------------------------------------------+
    \  |\n                             |                      |\n                             v
    \                     |\n                      +-------------+               |\n
    \                     |   KS-octet  |               |\n                      |
    \    MK      |               |\n                      +-------------+               |\n
    \                            |                      |\n                             v
    \                     v\n   +---------------------------------------------------+\n
    \  |                      KDF                          |\n   +---------------------------------------------------+\n
    \       |             |             |            |\n        v             v             v
    \           v\n   +---------+   +---------+  +----------+  +----------+\n   |
    64-octet|   | 64-octet|  | KS-octet |  | KS-octet |\n   |   MSK   |   |  EMSK
    \  |  |    SK    |  |   PK     |\n   +---------+   +---------+  +----------+  +----------+\n
    \                    Figure 2: EAP-GPSK Key Derivation\n"
  title: 4.  Key Derivation
- contents:
  - "5.  Key Management\n   In order to be interoperable, PSKs must be entered in
    the same way on\n   both the peer and server.  The management interface for entering
    PSKs\n   MUST support entering PSKs up to 64 octets in length as ASCII strings\n
    \  and in hexadecimal encoding.\n   Additionally, the ID_Peer and ID_Server MUST
    be provisioned with the\n   PSK.  Validation of these values is by an octet-wise
    comparison.  The\n   management interface SHOULD support entering non-ASCII octets
    for the\n   ID_Peer and ID_Server up to 254 octets in length.  For more\n   information,
    the reader is advised to read Section 2.4 of RFC 4282\n   [RFC4282].\n"
  title: 5.  Key Management
- contents:
  - "6.  Ciphersuites\n   The design of EAP-GPSK allows cryptographic algorithms and
    key sizes,\n   called ciphersuites, to be negotiated during the protocol run.
    \ The\n   ability to specify block-based and hash-based ciphersuites is\n   offered.
    \ Extensibility is provided with the introduction of new\n   ciphersuites; this
    document specifies an initial set.  The CSuite/\n   Specifier column in Figure
    3 uniquely identifies a ciphersuite.\n   For a vendor-specific ciphersuite, the
    first four octets are the\n   vendor-specific enterprise number that contains
    the IANA-assigned\n   \"SMI Network Management Private Enterprise Codes\" value
    (see\n   [ENTNUM]), encoded in network byte order.  The last two octets are\n
    \  vendor assigned for the specific ciphersuite.  A vendor code of\n   0x00000000
    indicates ciphersuites standardized by the IETF in an\n   IANA-maintained registry.\n
    \  The following ciphersuites are specified in this document (recall\n   that
    KS is the length of the ciphersuite input key length in octets,\n   and ML is
    the length of the MAC output in octets):\n   +-----------+----+-------------+----+--------------+----------------+\n
    \  | CSuite/   | KS | Encryption  | ML | Integrity /  | Key Derivation |\n   |
    Specifier |    |             |    | KDF MAC      | Function       |\n   +-----------+----+-------------+----+--------------+----------------+\n
    \  | 0x0001    | 16 | AES-CBC-128 | 16 | AES-CMAC-128 | GKDF           |\n   +-----------+----+-------------+----+--------------+----------------+\n
    \  | 0x0002    | 32 | NULL        | 32 | HMAC-SHA256  | GKDF           |\n   +-----------+----+-------------+----+--------------+----------------+\n
    \                         Figure 3: Ciphersuites\n   Ciphersuite 1, which is based
    on the Advanced Encryption Standard\n   (AES) as a cryptographic primitive, MUST
    be implemented.  This\n   document specifies also a second ciphersuite, which
    MAY be\n   implemented.  Both ciphersuites defined in this document make use of\n
    \  the Generalized Key Derivation Function (GKDF), as defined in\n   Section 7.
    \ The following aspects need to be considered to ensure\n   that the PSK that
    is used as input to the GKDF is sufficiently long:\n   1.  The PSK used with ciphersuite
    1 MUST be 128 bits in length.  Keys\n       longer than 128 bits will be truncated.\n
    \  2.  The PSK used with ciphersuite 2 MUST be 256 bits in length.  Keys\n       longer
    than 256 bits will be truncated.\n   3.  It is RECOMMENDED that 256 bit keys be
    provisioned in all cases\n       to provide enough entropy for all current and
    many possible\n       future ciphersuites.\n   Ciphersuites defined in the future
    that make use of the GKDF need to\n   specify a minimum PSK size (as is done with
    the ciphersuites listed\n   in this document).\n"
  title: 6.  Ciphersuites
- contents:
  - "7.  Generalized Key Derivation Function (GKDF)\n   Each ciphersuite needs to
    specify a key derivation function.  The\n   ciphersuites defined in this document
    make use of the Generalized Key\n   Derivation Function (GKDF) that utilizes the
    MAC function defined in\n   the ciphersuite.  Future ciphersuites can use any
    other formally\n   specified KDF that takes as arguments a key and a seed value,
    and\n   produces at least 128+2*KS octets of output.\n   GKDF has the following
    structure:\n   GKDF-X(Y, Z)\n   X  length, in octets, of the desired output\n
    \  Y  secret key\n   Z  inputString\n   GKDF-X (Y, Z)\n   {\n     n = ceiling
    integer of ( X / ML );\n        /* determine number of output blocks */\n     result
    = \"\";\n     for i = 1 to n {\n       result = result || MAC_Y (i || Z);\n     }\n
    \    return truncate(result, X)\n   }\n   Note that the variable 'i' in M_i is
    represented as a 2-octet value\n   in network byte order.\n"
  title: 7.  Generalized Key Derivation Function (GKDF)
- contents:
  - '8.  Ciphersuites Processing Rules

    '
  - contents:
    - '8.1.  Ciphersuite #1

      '
    - contents:
      - "8.1.1.  Encryption\n   With this ciphersuite, all cryptography is built around
        a single\n   cryptographic primitive, AES-128 ([AES]).  Within the protected
        data\n   frames, AES-128 is used in the Cipher Block Chaining (CBC) mode of\n
        \  operation (see [CBC]).  This EAP method uses encryption in a single\n   payload,
        in the protected data payload (see Section 9.4).\n   In a nutshell, the CBC
        mode proceeds as follows.  The IV is XORed\n   with the first plaintext block
        before it is encrypted.  Then for\n   successive blocks, the previous ciphertext
        block is XORed with the\n   current plaintext, before it is encrypted.\n"
      title: 8.1.1.  Encryption
    - contents:
      - "8.1.2.  Integrity\n   Ciphersuite 1 uses CMAC as Message Authentication Code.
        \ CMAC is\n   recommended by NIST.  Among its advantages, CMAC is capable
        to work\n   with messages of arbitrary length.  A detailed description of
        CMAC\n   can be found in [CMAC].\n   The following instantiation is used:
        AES-CMAC-128(SK, Input) denotes\n   the MAC of Input under the key SK where
        Input refers to the following\n   content:\n   o  Parameter within SEC_SK(Parameter)
        in message GPSK-2\n   o  Parameter within SEC_SK(Parameter) in message GPSK-3\n
        \  o  Parameter within SEC_SK(Parameter) in message GPSK-4\n"
      title: 8.1.2.  Integrity
    title: '8.1.  Ciphersuite #1'
  - contents:
    - '8.2.  Ciphersuite #2

      '
    - contents:
      - "8.2.1.  Encryption\n   Ciphersuite 2 does not include an algorithm for encryption.
        \ With a\n   NULL encryption algorithm, encryption is defined as:\n   E_X(Y)
        = Y\n   When using this ciphersuite, the data exchanged inside the protected\n
        \  data block is not encrypted.  Therefore, this mode MUST NOT be used\n   if
        confidential information appears inside the protected data block.\n"
      title: 8.2.1.  Encryption
    - contents:
      - "8.2.2.  Integrity\n   Ciphersuite 2 uses the keyed MAC function HMAC, with
        the SHA256 hash\n   algorithm (see [RFC4634]).\n   For integrity protection,
        the following instantiation is used:\n   HMAC-SHA256(SK, Input) denotes the
        MAC of Input under the key SK\n   where Input refers to the following content:\n
        \  o  Parameter within SEC_SK(Parameter) in message GPSK-2\n   o  Parameter
        within SEC_SK(Parameter) in message GPSK-3\n   o  Parameter within SEC_SK(Parameter)
        in message GPSK-4\n"
      title: 8.2.2.  Integrity
    title: '8.2.  Ciphersuite #2'
  title: 8.  Ciphersuites Processing Rules
- contents:
  - "9.  Packet Formats\n   This section defines the packet format of the EAP-GPSK
    messages.\n"
  - contents:
    - "9.1.  Header Format\n   The EAP-GPSK header has the following structure:\n
      \  --- bit offset --->\n    0                   1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |     Code      |  Identifier   |            Length             |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |     Type      |    OP-Code    |                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      \                              +\n   |                                                               |\n
      \  ...                         Payload                           ...\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                         Figure
      4: EAP-GPSK Header\n   The Code, Identifier, Length, and Type fields are all
      part of the EAP\n   header and are defined in [RFC3748].  The Type field in
      the EAP\n   header MUST be the value allocated by IANA for EAP-GPSK.\n   The
      OP-Code field is one of 6 values:\n   o  0x00 : Reserved\n   o  0x01 : GPSK-1\n
      \  o  0x02 : GPSK-2\n   o  0x03 : GPSK-3\n   o  0x04 : GPSK-4\n   o  0x05 :
      GPSK-Fail\n   o  0x06 : GPSK-Protected-Fail\n   All other values of this OP-Code
      field are available via IANA\n   registration.\n"
    title: 9.1.  Header Format
  - contents:
    - "9.2.  Ciphersuite Formatting\n   Ciphersuites are encoded as 6-octet arrays.
      \ The first four octets\n   indicate the CSuite/Vendor field.  For vendor-specific
      ciphersuites,\n   this represents the vendor enterprise number and contains
      the IANA-\n   assigned \"SMI Network Management Private Enterprise Codes\" value
      (see\n   [ENTNUM]), encoded in network byte order.  The last two octets\n   indicate
      the CSuite/Specifier field, which identifies the particular\n   ciphersuite.
      \ The 4-octet CSuite/Vendor value 0x00000000 indicates\n   ciphersuites allocated
      by the IETF.\n   Graphically, they are represented as:\n   --- bit offset --->\n
      \   0                   1                   2                   3\n    0 1 2
      3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |       CSuite/Vendor = 0x00000000 or enterprise number         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |      CSuite/Specifier         |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                    Figure 5: Ciphersuite Formatting\n   CSuite_Sel is encoded
      as a 6-octet ciphersuite CSuite/Vendor and\n   CSuite/Specifier pair.\n   CSuite_List
      is a variable-length octet array of ciphersuites.  It is\n   encoded by concatenating
      encoded ciphersuite values.  Its length in\n   octets MUST be a multiple of
      6.\n"
    title: 9.2.  Ciphersuite Formatting
  - contents:
    - "9.3.  Payload Formatting\n   Payload formatting is based on the protocol exchange
      description in\n   Section 3.\n   The GPSK-1 payload format is defined as follows:\n
      \  --- bit offset --->\n    0                   1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |       length(ID_Server)       |                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      \                              +\n   |                                                               |\n
      \  ...                         ID_Server                         ...\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                                                               |\n
      \  ...                   32-octet RAND_Server                    ...\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |      length(CSuite_List)
      \     |                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      \                              +\n   |                                                               |\n
      \  ...                        CSuite_List                        ...\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                         Figure
      6: GPSK-1 Payload\n   The GPSK-2 payload format is defined as follows:\n   ---
      bit offset --->\n    0                   1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |        length(ID_Peer)        |                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      \                              +\n   |                                                               |\n
      \  ...                         ID_Peer                         ...\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |       length(ID_Server)
      \      |                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      \                              +\n   |                                                               |\n
      \  ...                         ID_Server                         ...\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                                                               |\n
      \  ...                     32-octet RAND_Peer                    ...\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                                                               |\n
      \  ...                    32-octet RAND_Server                   ...\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |      length(CSuite_List)
      \     |                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      \                              +\n   |                                                               |\n
      \  ...                        CSuite_List                        ...\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                           CSuite_Sel
      \                         |\n   +                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                               |   length(PD_Payload_Block)    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                                                               |\n   ...
      \                optional PD_Payload_Block                 ...\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                                                               |\n
      \  ...                   ML-octet payload MAC                    ...\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                         Figure
      7: GPSK-2 Payload\n   If the optional protected data payload is not included,
      then\n   length(PD_Payload_Block)=0 and the PD payload is excluded.  The\n   payload
      MAC covers the entire packet, from the ID_Peer length through\n   the optional
      PD_Payload_Block.\n   The GPSK-3 payload is defined as follows:\n   --- bit
      offset --->\n    0                   1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                                                               |\n   ...
      \                   32-octet RAND_Peer                   ...\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                                                               |\n
      \  ...                    32-octet RAND_Server                   ...\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |       length(ID_Server)
      \      |                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      \                              +\n   |                                                               |\n
      \  ...                         ID_Server                         ...\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                           CSuite_Sel
      \                         |\n   +                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                               |   length(PD_Payload_Block)    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                                                               |\n   ...
      \                optional PD_Payload_Block                 ...\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                                                               |\n
      \  ...                   ML-octet payload MAC                    ...\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                         Figure
      8: GPSK-3 Payload\n   If the optional protected data payload is not included,
      then\n   length(PD_Payload_Block)=0 and the PD payload is excluded.  The\n   payload
      MAC covers the entire packet, from the RAND_Peer through the\n   optional PD_Payload_Block.\n
      \  The GPSK-4 payload format is defined as follows:\n   --- bit offset --->\n
      \   0                   1                   2                   3\n    0 1 2
      3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |   length(PD_Payload_Block)    |                               |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
      \                              +\n   |                                                               |\n
      \  ...                 optional PD_Payload_Block                 ...\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                                                               |\n
      \  ...                   ML-octet payload MAC                    ...\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                         Figure
      9: GPSK-4 Payload\n   If the optional protected data payload is not included,
      then\n   length(PD_Payload_Block)=0 and the PD payload is excluded.  The MAC\n
      \  MUST always be included, regardless of the presence of\n   PD_Payload_Block.
      \ The payload MAC covers the entire packet, from the\n   PD_Payload_Block length
      through the optional PD_Payload_Block.\n   The GPSK-Fail payload format is defined
      as follows:\n   --- bit offset --->\n    0                   1                   2
      \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                         Failure-Code                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                      Figure 10: GPSK-Fail Payload\n   The GPSK-Protected-Fail
      payload format is defined as follows:\n   --- bit offset --->\n    0                   1
      \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                         Failure-Code                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                                                               |\n   ...
      \                  ML-octet payload MAC                    ...\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                  Figure
      11: GPSK-Protected-Fail Payload\n   The Failure-Code field is one of three values,
      but can be extended:\n   o  0x00000000 : Reserved\n   o  0x00000001 : PSK Not
      Found\n   o  0x00000002 : Authentication Failure\n   o  0x00000003 : Authorization
      Failure\n   All other values of this field are available via IANA registration.\n
      \  \"PSK Not Found\" indicates a key for a particular user could not be\n   located,
      making authentication impossible.  \"Authentication Failure\"\n   indicates
      a MAC failure due to a PSK mismatch.  \"Authorization\n   Failure\" indicates
      that while the PSK being used is correct, the user\n   is not authorized to
      connect.\n"
    title: 9.3.  Payload Formatting
  - contents:
    - "9.4.  Protected Data\n   The protected data blocks are a generic mechanism
      for the peer and\n   server to securely exchange data.  If the specified ciphersuite
      has a\n   NULL encryption primitive, then this channel only offers\n   authenticity,
      not confidentiality.\n   These payloads are encoded as the concatenation of
      type-length-value\n   (TLV) triples called PD_Payloads.\n   Type values are
      encoded as a 6-octet string and represented by a\n   4-octet vendor and a 2-octet
      specifier field.  The vendor field\n   indicates the type as either standards-specified
      or vendor-specific.\n   If these four octets are 0x00000000, then the value
      is standards-\n   specified, and any other value represents a vendor-specific\n
      \  enterprise number.\n   The specifier field indicates the actual type.  For
      vendor field\n   0x00000000, the specifier field is maintained by IANA.  For
      any other\n   vendor field, the specifier field is maintained by the vendor.\n
      \  Length fields are specified as 2-octet integers in network byte\n   order,
      reflect only the length of the value, and do not include the\n   length of the
      type and length fields.\n   Graphically, this can be depicted as follows:\n
      \  --- bit offset --->\n    0                   1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                   PData/Vendor                                |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \           PData/Specifier        |         PData/Length          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                                                               |\n   ...
      \                       PData/Value                        ...\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n         Figure
      12: Protected Data Payload (PD_Payload) Formatting\n   These PD_Payloads are
      concatenated together to form a\n   PD_Payload_Block.  If the CSuite_Sel includes
      support for encryption,\n   then the PD_Payload_Block includes fields specifying
      an\n   Initialization Vector (IV) and the necessary padding.  This can be\n
      \  depicted as follows:\n   --- bit offset --->\n    0                   1                   2
      \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |   IV Length   |                                               |\n   +-+-+-+-+-+-+-+-+
      \     Initialization Vector                    +\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                                                               |\n
      \  ...                        PD_Payload                         ...\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                                                               |\n
      \  ...                 optional PD_Payload, etc                  ...\n   |                                                               |\n
      \  +               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |               |
      \            Padding (0-255 octets)            |\n   +-+-+-+-+-+-+-+-+                               +-+-+-+-+-+-+-+-+\n
      \  |                                               |  Pad Length   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \           Figure 13: Protected Data Block (PD_Payload_Block)\n                   Formatting
      if Encryption is Supported\n   The Initialization Vector is a randomly chosen
      value whose length is\n   equal to the specified IV Length.  The required length
      is defined by\n   the ciphersuite.  Recipients MUST accept any value.  Senders
      SHOULD\n   either pick this value pseudo-randomly and independently for each\n
      \  message or use the final ciphertext block of the previous message\n   sent.
      \ Senders MUST NOT use the same value for each message, use a\n   sequence of
      values with low hamming distance (e.g., a sequence\n   number), or use ciphertext
      from a received message.  IVs should be\n   selected per the security requirements
      of the underlying cipher.  If\n   the data is not being encrypted, then the
      IV Length MUST be 0.  If\n   the ciphersuite does not require an IV, or has
      a self-contained way\n   of communicating the IV, then the IV Length field MUST
      be 0.  In\n   these cases, the ciphersuite definition defines how the IV is\n
      \  encapsulated in the PD_Payload.\n   The concatenation of PD_Payloads along
      with the padding and padding\n   length are all encrypted using the negotiated
      block cipher.  If no\n   block cipher is specified, then these fields are not
      encrypted.\n   The Padding field MAY contain any value chosen by the sender.
      \ For\n   block-based cipher modes, the padding MUST have a length that makes\n
      \  the combination of the concatenation of PD_Payloads, the Padding, and\n   the
      Pad Length to be a multiple of the encryption block size.  If the\n   underlying
      ciphersuite does not require padding (e.g., a stream-based\n   cipher mode)
      or no encryption is being used, then the padding length\n   MUST still be present
      and be 0.\n   The Pad Length field is the length of the Padding field.  The
      sender\n   SHOULD set the Pad Length to the minimum value that makes the\n   combination
      of the PD_Payloads, the Padding, and the Pad Length a\n   multiple of the block
      size (in the case of block-based cipher modes),\n   but the recipient MUST accept
      any length that results in proper\n   alignment.  This field is encrypted with
      the negotiated cipher.\n   If the negotiated ciphersuite does not support encryption,
      then the\n   IV field MUST be of length 0 and the padding field MUST be of length\n
      \  0.  The IV length and padding length fields MUST still be present,\n   and
      contain the value 0.  The rationale for still requiring the\n   length fields
      is to allow for modular implementations where the\n   crypto processing is independent
      of the payload processing.  This is\n   depicted in the following figure.\n
      \  --- bit offset --->\n    0                   1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |      0x00     |                                               |\n   +-+-+-+-+-+-+-+-+
      \         PD_Payload                         ...\n   |                                                               |\n
      \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |                                                               |\n
      \  ...                 optional PD_Payload, etc    +-+-+-+-+-+-+-+-+\n   |                                               |
      \     0x00     |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \           Figure 14: Protected Data Block (PD_Payload_Block)\n                       Formatting
      Without Encryption\n   For PData/Vendor field 0x00000000, the following PData/Specifier\n
      \  fields are defined:\n   o  0x0000 : Reserved\n   All other values of this
      field are available via IANA registration.\n"
    title: 9.4.  Protected Data
  title: 9.  Packet Formats
- contents:
  - "10.  Packet Processing Rules\n   This section defines how the EAP peer and EAP
    server MUST behave when\n   a received packet is deemed invalid.\n   Any EAP-GPSK
    packet that cannot be parsed by the EAP peer or the EAP\n   server MUST be silently
    discarded.  An EAP peer or EAP server\n   receiving any unexpected packet (e.g.,
    an EAP peer receiving GPSK-3\n   before receiving GPSK-1 or before transmitting
    GPSK-2) MUST silently\n   discard the packet.\n   GPSK-1 contains no MAC protection,
    so provided it properly parses, it\n   MUST be accepted by the peer.  If the EAP
    peer has no ciphersuites in\n   common with the server or decides the ID_Server
    is that of an\n   Authentication, Authorization, and Accounting (AAA) server to
    which\n   it does not wish to authenticate, the EAP peer MUST respond with an\n
    \  EAP-NAK.\n   For GPSK-2, if the ID_Peer is for an unknown user, the EAP server\n
    \  MUST send either a \"PSK Not Found\" GPSK-Fail message or an\n   \"Authentication
    Failure\" GPSK-Fail, depending on its policy.  If the\n   MAC validation fails,
    the server MUST transmit a GPSK-Fail message\n   specifying \"Authentication Failure\".
    \ If the RAND_Server or\n   CSuite_List field in GPSK-2 does not match the values
    in GPSK-1, the\n   server MUST silently discard the packet.  If server policy
    determines\n   the peer is not authorized and the MAC is correct, the server MUST\n
    \  transmit a GPSK-Protected-Fail message indicating \"Authorization\n   Failure\",
    and discard the received packet.\n   A peer receiving a GPSK-Fail / GPSK-Protected-Fail
    message in\n   response to a GPSK-2 message MUST replay the received GPSK-Fail
    /\n   GPSK-Protected-Fail message.  Then, the EAP server returns an EAP-\n   Failure
    after receiving the GPSK-Fail / GPSK-Protected-Fail message\n   to correctly finish
    the EAP conversation.  If MAC validation on a\n   GPSK-Protected-Fail packet fails,
    then the received packet MUST be\n   silently discarded.\n   For GPSK-3, a peer
    MUST silently discard messages where the\n   RAND_Peer, ID_Server, or the CSuite_Sel
    fields do not match those\n   transmitted in GPSK-2.  An EAP peer MUST silently
    discard any packet\n   whose MAC fails.\n   For GPSK-4, a server MUST silently
    discard any packet whose MAC fails\n   validation.\n   If a decryption failure
    of a protected payload is detected, the\n   recipient MUST silently discard the
    GPSK packet.\n"
  title: 10.  Packet Processing Rules
- contents:
  - "11.  Example Message Exchanges\n   This section shows a couple of example message
    flows.\n   A successful EAP-GPSK message exchange is shown in Figure 1.\n   +--------+
    \                                    +--------+\n   |        |                EAP-Request/Identity
    |        |\n   |  EAP   |<------------------------------------|  EAP   |\n   |
    \ peer  |                                     | server |\n   |        | EAP-Response/Identity
    \              |        |\n   |        |------------------------------------>|
    \       |\n   |        |                                     |        |\n   |
    \       |                  EAP-Request/GPSK-1 |        |\n   |        |<------------------------------------|
    \       |\n   |        |                                     |        |\n   |
    \       | EAP-Response/EAP-NAK                |        |\n   |        |------------------------------------>|
    \       |\n   |        |                                     |        |\n   |
    \       |          EAP-Failure                |        |\n   |        |<------------------------------------|
    \       |\n   +--------+                                     +--------+\n                Figure
    15: EAP-GPSK: Unsuccessful Exchange\n               (Unacceptable AAA Server Identity;
    ID_Server)\n   +--------+                                     +--------+\n   |
    \       |                EAP-Request/Identity |        |\n   |  EAP   |<------------------------------------|
    \ EAP   |\n   |  peer  |                                     | server |\n   |
    \       | EAP-Response/Identity               |        |\n   |        |------------------------------------>|
    \       |\n   |        |                                     |        |\n   |
    \       |                  EAP-Request/GPSK-1 |        |\n   |        |<------------------------------------|
    \       |\n   |        |                                     |        |\n   |
    \       | EAP-Response/GPSK-2                 |        |\n   |        |------------------------------------>|
    \       |\n   |        |                                     |        |\n   |
    \       | EAP-Request/GPSK-Fail               |        |\n   |        | (PSK Not
    Found or Authentication    |        |\n   |        | Failure)                            |
    \       |\n   |        |<------------------------------------|        |\n   |
    \       |                                     |        |\n   |        | EAP-Response/GPSK-Fail
    \             |        |\n   |        | (PSK Not Found or Authentication    |
    \       |\n   |        | Failure)                            |        |\n   |
    \       |------------------------------------>|        |\n   |        |                                     |
    \       |\n   |        |          EAP-Failure                |        |\n   |
    \       |<------------------------------------|        |\n   +--------+                                     +--------+\n
    \        Figure 16: EAP-GPSK: Unsuccessful Exchange (Unknown User)\n   +--------+
    \                                    +--------+\n   |        |                EAP-Request/Identity
    |        |\n   |  EAP   |<------------------------------------|  EAP   |\n   |
    \ peer  |                                     | server |\n   |        | EAP-Response/Identity
    \              |        |\n   |        |------------------------------------>|
    \       |\n   |        |                                     |        |\n   |
    \       |                  EAP-Request/GPSK-1 |        |\n   |        |<------------------------------------|
    \       |\n   |        |                                     |        |\n   |
    \       | EAP-Response/GPSK-2                 |        |\n   |        |------------------------------------>|
    \       |\n   |        |                                     |        |\n   |
    \       | EAP-Request/GPSK-Fail               |        |\n   |        | (Authentication
    Failure)            |        |\n   |        |<------------------------------------|
    \       |\n   |        |                                     |        |\n   |
    \       | EAP-Response/GPSK-Fail              |        |\n   |        | (Authentication
    Failure)            |        |\n   |        |------------------------------------>|
    \       |\n   |        |                                     |        |\n   |
    \       |          EAP-Failure                |        |\n   |        |<------------------------------------|
    \       |\n   +--------+                                     +--------+\n    Figure
    17: EAP-GPSK: Unsuccessful Exchange (Invalid MAC in GPSK-2)\n   +--------+                                     +--------+\n
    \  |        |                EAP-Request/Identity |        |\n   |  EAP   |<------------------------------------|
    \ EAP   |\n   |  peer  |                                     | server |\n   |
    \       | EAP-Response/Identity               |        |\n   |        |------------------------------------>|
    \       |\n   |        |                                     |        |\n   |
    \       |                  EAP-Request/GPSK-1 |        |\n   |        |<------------------------------------|
    \       |\n   |        |                                     |        |\n   |
    \       | EAP-Response/GPSK-2                 |        |\n   |        |------------------------------------>|
    \       |\n   |        |                                     |        |\n   |
    \       | EAP-Request/                        |        |\n   |        | GPSK-Protected-Fail
    \                |        |\n   |        | (Authorization Failure)             |
    \       |\n   |        |<------------------------------------|        |\n   |
    \       |                                     |        |\n   |        | EAP-Request/
    \                       |        |\n   |        | GPSK-Protected-Fail                 |
    \       |\n   |        | (Authorization Failure)             |        |\n   |
    \       |------------------------------------>|        |\n   |        |                                     |
    \       |\n   |        |          EAP-Failure                |        |\n   |
    \       |<------------------------------------|        |\n   +--------+                                     +--------+\n
    \   Figure 18: EAP-GPSK: Unsuccessful Exchange (Authorization Failure)\n"
  title: 11.  Example Message Exchanges
- contents:
  - "12.  Security Considerations\n   [RFC3748] highlights several attacks that are
    possible against EAP\n   since EAP itself does not provide any security.\n   This
    section discusses the claimed security properties of EAP-GPSK as\n   well as vulnerabilities
    and security recommendations in the threat\n   model of [RFC3748].\n"
  - contents:
    - "12.1.  Security Claims\n   Authentication mechanism:  Shared Keys\n   Ciphersuite
      negotiation:  Yes (Section 12.16)\n   Mutual authentication:  Yes (Section 12.2)\n
      \  Integrity protection:  Yes (Section 12.4)\n   Replay protection:  Yes (Section
      12.5)\n   Confidentiality:  No (Section 12.17, Section 12.15)\n   Key derivation:
      \ Yes (Section 12.8)\n   Key strength:  Varies (Section 12.8)\n   Dictionary
      attack protection:  No (Section 12.7)\n   Fast reconnect:  No (Section 12.14)\n
      \  Cryptographic binding:  N/A (Section 12.18)\n   Session independence:  Yes
      (Section 12.10)\n   Fragmentation:  No (Section 12.12)\n   Channel binding:
      \ Extensible (Section 12.13)\n"
    title: 12.1.  Security Claims
  - contents:
    - "12.2.  Mutual Authentication\n   EAP-GPSK provides mutual authentication.\n
      \  The server believes that the peer is authentic when it successfully\n   verifies
      the MAC in the GPSK-2 message; the peer believes that the\n   server is authentic
      when it successfully verifies the MAC it receives\n   with the GPSK-3 message.\n
      \  The key used for mutual authentication is derived based on the long-\n   term
      secret PSK, nonces contributed by both parties, and other\n   parameters.  The
      long-term secret PSK has to provide sufficient\n   entropy and, therefore, sufficient
      strength.  The nonces (RAND_Peer\n   and RAND_Server) need to be fresh and unique
      for every session.  In\n   this way, EAP-GPSK is not different than other authentication\n
      \  protocols based on pre-shared keys.\n"
    title: 12.2.  Mutual Authentication
  - contents:
    - "12.3.  Protected Result Indications\n   EAP-GPSK supports protected result
      indications via the GPSK-\n   Protected-Fail message.  This allows a server
      to provide additional\n   information to the peer as to why the session failed,
      and to do so in\n   an authenticated way (if possible).  In particular, the
      server can\n   indicate the lack of PSK (account not present), failed authentication\n
      \  (PSK incorrect), or authorization failure (account disabled or\n   unauthorized).
      \ Only the third message could be integrity protected.\n   It should be noted
      that these options make debugging network and\n   account errors easier, but
      they also leak information about accounts\n   to attackers.  An attacker can
      determine if a particular ID_Peer is a\n   valid user on the network or not.
      \ Thus, implementers should use care\n   in enabling this particular option
      on their servers.  If they are in\n   an environment where such attacks are
      of concern, then protected\n   result indication capabilities should be disabled.\n"
    title: 12.3.  Protected Result Indications
  - contents:
    - "12.4.  Integrity Protection\n   EAP-GPSK provides integrity protection based
      on the ciphersuites\n   suggested in this document.  Integrity protection is
      a minimum\n   feature every ciphersuite must provide.\n"
    title: 12.4.  Integrity Protection
  - contents:
    - "12.5.  Replay Protection\n   EAP-GPSK provides replay protection of its mutual
      authentication part\n   thanks to the use of random numbers RAND_Server and
      RAND_Peer.  Since\n   RAND_Server is 32 octets long, one expects to have to
      record 2**64\n   (i.e., approximately 1.84*10**19) EAP-GPSK successful authentications\n
      \  before a protocol run can be replayed.  Hence, EAP-GPSK provides\n   replay
      protection of its mutual authentication part as long as\n   RAND_Server and
      RAND_Peer are chosen at random; randomness is\n   critical for replay protection.
      \ RFC 4086 [RFC4086] describes\n   techniques for producing random quantities.\n"
    title: 12.5.  Replay Protection
  - contents:
    - "12.6.  Reflection Attacks\n   Reflection attacks occur in bi-directional, challenge-response,\n
      \  mutual authentication protocols where an attacker, upon being issued\n   a
      challenge by an authenticator, responds by issuing the same\n   challenge back
      to the authenticator, obtaining the response, and then\n   \"reflecting\" that
      same response to the original challenge.\n   EAP-GPSK provides protection against
      reflection attacks because the\n   message formats for the challenges differ.
      \ The protocol does not\n   consist of two independent authentications, but
      rather the\n   authentications are tightly coupled.\n   Also note that EAP-GPSK
      does not provide MAC protection of the OP-\n   Code field, but again since each
      message is constructed differently,\n   it would not be possible to change the
      OP-Code of a valid message and\n   still have it be parseable and accepted by
      the recipient.\n"
    title: 12.6.  Reflection Attacks
  - contents:
    - "12.7.  Dictionary Attacks\n   EAP-GPSK relies on a long-term shared secret
      (PSK) that SHOULD be\n   based on at least 16 octets of entropy to be fully
      secure.  The EAP-\n   GPSK protocol makes no special provisions to ensure keys
      based on\n   passwords are used securely.  Users who use passwords as the basis
      of\n   their PSK are not protected against dictionary attacks.  Derivation\n
      \  of the long-term shared secret from a password is strongly\n   discouraged.\n
      \  The success of a dictionary attack against EAP-GPSK depends on the\n   strength
      of the long-term shared secret (PSK) it uses.  The PSK used\n   by EAP-GPSK
      SHOULD be drawn from a pool of secrets that is at least\n   2^128 bits large
      and whose distribution is uniformly random.  Note\n   that this does not imply
      resistance to dictionary attacks -- only\n   that the probability of success
      in such an attack is acceptably\n   remote.\n"
    title: 12.7.  Dictionary Attacks
  - contents:
    - "12.8.  Key Derivation and Key Strength\n   EAP-GPSK supports key derivation
      as shown in Section 4.\n   Keys used within EAP-GPSK are all based on the security
      of the\n   originating PSK.  PSKs SHOULD have at least 16 octets of entropy.\n
      \  Independent of the protocol exchange (i.e., without knowing RAND_Peer\n   and
      RAND_Server), the keys have been derived with sufficient input\n   entropy to
      make them as secure as the underlying KDF output key\n   length.\n"
    title: 12.8.  Key Derivation and Key Strength
  - contents:
    - "12.9.  Denial-of-Service Resistance\n   There are three forms of denial-of-service
      (DoS) attacks relevant for\n   this document, namely (1) attacks that lead to
      a vast amount of state\n   being allocated, (2) attacks that attempt to prevent
      communication\n   between the peer and server, and (3) attacks against computational\n
      \  resources.\n   In an EAP-GPSK conversation the server has to maintain state,
      namely\n   the 32-octet RAND_Server, when transmitting the GPSK-1 message to
      the\n   peer.  An adversary could therefore flood a server with a large\n   number
      of EAP-GPSK communication attempts.  An EAP server may\n   therefore ensure
      that an established state times out after a\n   relatively short period of time
      when no further messages are\n   received.  This enables a sort of garbage collection.\n
      \  The client has to keep state information after receiving the GPSK-1\n   message.
      \ To prevent a replay attack, all the client needs to do is\n   ensure that
      the value of RAND_Peer is consistent between GPSK-2 and\n   GPSK-3.  Message
      GPSK-3 contains all the material required to\n   re-compute the keying material.
      \ Thus, if a client chooses to\n   implement this client-side DoS protection
      mechanism, it may manage\n   RAND_Peer and CSuite_Sel on a per-server basis
      for servers it knows,\n   instead of on a per-message basis.\n   Attacks that
      disrupt communication between the peer and server are\n   mitigated by silently
      discarding messages with invalid MACs.  Attacks\n   against computational resources
      are mitigated by having very light-\n   weight cryptographic operations required
      during each protocol round.\n   The security considerations of EAP itself, see
      Sections 5.2 and 7 of\n   RFC 3748 [RFC3748], are also applicable to this specification
      (e.g.,\n   for example concerning EAP-based notifications).\n"
    title: 12.9.  Denial-of-Service Resistance
  - contents:
    - "12.10.  Session Independence\n   Thanks to its key derivation mechanisms, EAP-GPSK
      provides session\n   independence: passive attacks (such as capture of the EAP\n
      \  conversation) or active attacks (including compromise of the MSK or\n   EMSK)
      do not enable compromise of subsequent or prior MSKs or EMSKs.\n   The assumption
      that RAND_Peer and RAND_Server are random is central\n   for the security of
      EAP-GPSK in general and session independence in\n   particular.\n"
    title: 12.10.  Session Independence
  - contents:
    - "12.11.  Compromise of the PSK\n   EAP-GPSK does not provide perfect forward
      secrecy.  Compromise of the\n   PSK leads to compromise of recorded past sessions.\n
      \  Compromise of the PSK enables the attacker to impersonate the peer\n   and
      the server, and it allows the adversary to compromise future\n   sessions.\n
      \  EAP-GPSK provides no protection against a legitimate peer sharing its\n   PSK
      with a third party.  Such protection may be provided by\n   appropriate repositories
      for the PSK, the choice of which is outside\n   the scope of this document.
      \ The PSK used by EAP-GPSK must only be\n   shared between two parties: the
      peer and the server.  In particular,\n   this PSK must not be shared by a group
      of peers (e.g., those with\n   different ID_Peer values) communicating with
      the same server.\n   The PSK used by EAP-GPSK must be cryptographically separated
      from\n   keys used by other protocols, otherwise the security of EAP-GPSK may\n
      \  be compromised.\n"
    title: 12.11.  Compromise of the PSK
  - contents:
    - "12.12.  Fragmentation\n   EAP-GPSK does not support fragmentation and reassembly
      since the\n   message size is relatively small.  However, it should be noted
      that\n   this impacts the length of protected data payloads that can be\n   attached
      to messages.  Also, if the EAP frame is larger than the MTU\n   of the underlying
      transport, and that transport does not support\n   fragmentation, the frame
      will most likely not be transported.\n   Consequently, implementers and deployers
      should take care to ensure\n   EAP-GPSK frames are short enough to work properly
      on the target\n   underlying transport mechanism.\n"
    title: 12.12.  Fragmentation
  - contents:
    - "12.13.  Channel Binding\n   This document enables the ability to exchange channel
      binding\n   information.  It does not, however, define the encoding of channel\n
      \  binding information in the document.\n"
    title: 12.13.  Channel Binding
  - contents:
    - "12.14.  Fast Reconnect\n   EAP-GPSK does not provide fast reconnect capability
      since this method\n   is already at (or close to) the lower limit of the number
      of\n   roundtrips and the cryptographic operations.\n"
    title: 12.14.  Fast Reconnect
  - contents:
    - "12.15.  Identity Protection\n   Identity protection is not specified in this
      document.  Extensions\n   can be defined that enhance this protocol to provide
      this feature.\n"
    title: 12.15.  Identity Protection
  - contents:
    - "12.16.  Protected Ciphersuite Negotiation\n   EAP-GPSK provides protected ciphersuite
      negotiation via the\n   indication of available ciphersuites by the server in
      the first\n   message, and a confirmation by the peer in the subsequent message.\n
      \  Note, however, that the GPSK-2 message may optionally contain a\n   payload,
      ENC_PK(PD_Payload_Block), protected with an algorithm based\n   on a selected
      ciphersuite before the ciphersuite list has actually\n   been authenticated.
      \ In the classical downgrading attack, an\n   adversary would choose a ciphersuite
      that is so weak that it can be\n   broken in real time or would attempt to disable
      cryptographic\n   protection altogether.  The latter is not possible since any\n
      \  ciphersuite defined for EAP-GPSK must at least provide authentication\n   and
      integrity protection.  Confidentiality protection is optional.\n   When, at
      some time in the future, a ciphersuite contains algorithms\n   that can be broken
      in real-time, then a policy on peers and the\n   server needs to indicate that
      such a ciphersuite must not be selected\n   by any of parties.\n   Furthermore,
      an adversary may modify the selection of the ciphersuite\n   for the client
      to select a ciphersuite that does not provide\n   confidentiality protection.
      \ As a result, this would cause the\n   content of PD_Payload_Block to be transmitted
      in cleartext.  When\n   protocol designers extend EAP-GPSK to carry information
      in the\n   PD_Payload_Block of the GPSK-2 message, then it must be indicated\n
      \  whether confidentiality protection is mandatory.  In case such an\n   extension
      requires a ciphersuite with confidentiality protection,\n   then the policy
      at the peer must be to not transmit information of\n   that extension in the
      PD_Payload_Block of the GPSK-2 message.  The\n   peer may, if possible, delay
      the transmission of this information\n   element to the GPSK-4 message where
      the ciphersuite negotiation has\n   been confirmed already.  In general, when
      a ciphersuite is selected\n   that does not provide confidentiality protection,
      then information\n   that demands confidentiality protection must not be included
      in any\n   of the PD_Payload_Block objects.\n"
    title: 12.16.  Protected Ciphersuite Negotiation
  - contents:
    - "12.17.  Confidentiality\n   Although EAP-GPSK provides confidentiality in its
      protected data\n   payloads, it cannot claim to do so, per Section 7.2.1 of
      [RFC3748],\n   since it does not support identity protection.\n"
    title: 12.17.  Confidentiality
  - contents:
    - "12.18.  Cryptographic Binding\n   Since EAP-GPSK does not tunnel another EAP
      method, it does not\n   implement cryptographic binding.\n"
    title: 12.18.  Cryptographic Binding
  title: 12.  Security Considerations
- contents:
  - "13.  IANA Considerations\n   IANA has allocated a new EAP Type for EAP-GPSK (51).\n
    \  IANA has created a new registry for ciphersuites, protected data\n   types,
    failure codes, and op-codes.  IANA has added the specified\n   ciphersuites, protected
    data types, failure codes, and op-codes to\n   these registries as defined below.
    \ Values defining ciphersuites\n   (block-based or hash-based), protected data
    payloads, failure codes,\n   and op-codes can be added or modified per IETF Review
    [RFC5226].\n   Figure 3 represents the initial contents of the \"EAP-GPSK\n   Ciphersuites\"
    registry.  The CSuite/Specifier field is 16 bits long.\n   All other values are
    available via IANA registration.  Each\n   ciphersuite needs to provide processing
    rules and needs to specify\n   how the following algorithms are instantiated:
    encryption, integrity,\n   key derivation, and key length.\n   The following are
    the initial contents of the \"EAP-GPSK Protected\n   Data Payloads\" registry:\n
    \  o  0x0000 : Reserved\n   The PData/Specifier field is 16 bits long, and all
    other values are\n   available via IANA registration.  Each extension needs to
    indicate\n   whether confidentiality protection for transmission between the EAP\n
    \  peer and the EAP server is mandatory.\n   The following are the initial contents
    of the \"EAP-GPSK Failure\n   Codes\" registry:\n   o  0x00000000 : Reserved\n
    \  o  0x00000001 : PSK Not Found\n   o  0x00000002 : Authentication Failure\n
    \  o  0x00000003 : Authorization Failure\n   The Failure-Code field is 32 bits
    long, and all other values are\n   available via IANA registration.\n   The following
    are the initial contents of the \"EAP-GPSK OP Codes\"\n   registry:\n   o  0x00
    : Reserved\n   o  0x01 : GPSK-1\n   o  0x02 : GPSK-2\n   o  0x03 : GPSK-3\n   o
    \ 0x04 : GPSK-4\n   o  0x05 : GPSK-Fail\n   o  0x06 : GPSK-Protected-Fail\n   The
    OP-Code field is 8 bits long, and all other values are available\n   via IANA
    registration.\n"
  title: 13.  IANA Considerations
- contents:
  - "14.  Contributors\n   This work is a joint effort of the EAP Method Update (EMU)
    design\n   team of the EMU Working Group that was created to develop a mechanism\n
    \  based on strong shared secrets that meets RFC 3748 [RFC3748] and RFC\n   4017
    [RFC4017] requirements.  The design team members (in\n   alphabetical order) were:\n
    \  o  Jari Arkko\n   o  Mohamad Badra\n   o  Uri Blumenthal\n   o  Charles Clancy\n
    \  o  Lakshminath Dondeti\n   o  David McGrew\n   o  Joe Salowey\n   o  Sharma
    Suman\n   o  Hannes Tschofenig\n   o  Jesse Walker\n   Finally, we would like
    to thank Thomas Otto for his reviews,\n   feedback, and text contributions.\n"
  title: 14.  Contributors
- contents:
  - "15.  Acknowledgments\n   We would like to thank:\n   o  Jouni Malinen and Bernard
    Aboba for their early comments on the\n      document in June 2006.  Jouni Malinen
    developed the first\n      prototype implementation.\n   o  Lakshminath Dondeti,
    David McGrew, Bernard Aboba, Michaela\n      Vanderveen, and Ray Bell for their
    input to the ciphersuite\n      discussions between July and August 2006.\n   o
    \ Lakshminath Dondeti for his detailed review (sent to the EMU\n      mailing
    list on 12 July 2006).\n   o  Based on a review requested from NIST, Quynh Dang
    suggested\n      changes to the GKDF function (December 2006).\n   o  Jouni Malinen
    and Victor Fajardo for their review in January 2007.\n   o  Jouni Malinen for
    his suggestions regarding the examples and the\n      key derivation function
    in February 2007.\n   o  Bernard Aboba and Jouni Malinen for their review in February
    2007.\n   o  Vidya Narayanan for her review in March 2007.\n   o  Pasi Eronen
    for his IESG review in March and July 2008.\n   o  Dan Harkins for his review
    in June 2008.\n   o  Joe Salowey, the EMU working group chair, provided a document\n
    \     review in April 2007.  Jouni Malinen also reviewed the document\n      during
    the same month.\n   o  We would like to thank Paul Rowe, Arnab Roy, Prof. Andre
    Scedrov,\n      and Prof. John C. Mitchell for their analysis of EAP-GPSK, for\n
    \     their input to the key derivation function, and for pointing us to\n      a
    client-side DoS attack and to a downgrading attack.  Based on\n      their input,
    the key derivation function has been modified and the\n      text in the security
    considerations section has been updated.\n   o  Finally, we would like to thank
    our working group chair, Joe\n      Salowey, for his support and for the time
    he spent discussing open\n      issues with us.\n"
  title: 15.  Acknowledgments
- contents:
  - '16.  References

    '
  - contents:
    - "16.1.  Normative References\n   [AES]      National Institute of Standards
      and Technology,\n              \"Specification for the Advanced Encryption Standard\n
      \             (AES)\", Federal Information Processing Standards\n              (FIPS)
      197, November 2001.\n   [CBC]      National Institute of Standards and Technology,\n
      \             \"Recommendation for Block Cipher Modes of Encryption --\n              Methods
      and Techniques\", Special Publication (SP) 800-38A,\n              December
      2001.\n   [CMAC]     National Institute of Standards and Technology,\n              \"Recommendation
      for Block Cipher Modes of Operation: The\n              CMAC Mode for Authentication\",
      Special Publication\n              (SP) 800-38B, May 2005.\n   [RFC2119]  Bradner,
      S., \"Key words for use in RFCs to Indicate\n              Requirement Levels\",
      BCP 14, RFC 2119, March 1997.\n   [RFC3748]  Aboba, B., Blunk, L., Vollbrecht,
      J., Carlson, J., and H.\n              Levkowetz, \"Extensible Authentication
      Protocol (EAP)\",\n              RFC 3748, June 2004.\n   [RFC4282]  Aboba,
      B., Beadles, M., Arkko, J., and P. Eronen, \"The\n              Network Access
      Identifier\", RFC 4282, December 2005.\n   [RFC4634]  Eastlake, D. and T. Hansen,
      \"US Secure Hash Algorithms\n              (SHA and HMAC-SHA)\", RFC 4634, July
      2006.\n   [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines for Writing
      an\n              IANA Considerations Section in RFCs\", BCP 26, RFC 5226,\n
      \             May 2008.\n   [RFC5247]  Aboba, B., Simon, D., and P. Eronen,
      \"Extensible\n              Authentication Protocol (EAP) Key Management Framework\",\n
      \             RFC 5247, August 2008.\n"
    title: 16.1.  Normative References
  - contents:
    - "16.2.  Informative References\n   [80211]    \"Information technology - Telecommunications
      and\n              Information Exchange Between Systems - Local and\n              Metropolitan
      Area Networks - Specific Requirements - Part\n              11: Wireless LAN
      Medium Access Control (MAC) and Physical\n              Layer (PHY) Specifications\",
      IEEE Standard 802.11-2007,\n              March 2007.\n   [ENTNUM]   IANA, \"SMI
      Network Management Private Enterprise Codes\",\n              Private Enterprise
      Numbers, <http://www.iana.org>.\n   [RFC4017]  Stanley, D., Walker, J., and
      B. Aboba, \"Extensible\n              Authentication Protocol (EAP) Method Requirements
      for\n              Wireless LANs\", RFC 4017, March 2005.\n   [RFC4086]  Eastlake,
      D., Schiller, J., and S. Crocker, \"Randomness\n              Requirements for
      Security\", BCP 106, RFC 4086, June 2005.\n"
    title: 16.2.  Informative References
  title: 16.  References
- contents:
  - "Authors' Addresses\n   T. Charles Clancy\n   DoD Laboratory for Telecommunications
    Sciences\n   8080 Greenmead Drive\n   College Park, MD  20740\n   USA\n   EMail:
    clancy@ltsnet.net\n   Hannes Tschofenig\n   Nokia Siemens Networks\n   Linnoitustie
    6\n   Espoo  02600\n   Finland\n   EMail: Hannes.Tschofenig@gmx.net\n"
  title: Authors' Addresses
