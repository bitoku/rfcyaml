- title: __initial_text__
  contents:
  - "             Guidelines for Cryptographic Algorithm Agility\n            and\
    \ Selecting Mandatory-to-Implement Algorithms\n"
- title: Abstract
  contents:
  - "Abstract\n   Many IETF protocols use cryptographic algorithms to provide\n  \
    \ confidentiality, integrity, authentication, or digital signature.\n   Communicating\
    \ peers must support a common set of cryptographic\n   algorithms for these mechanisms\
    \ to work properly.  This memo provides\n   guidelines to ensure that protocols\
    \ have the ability to migrate from\n   one mandatory-to-implement algorithm suite\
    \ to another over time.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo documents an Internet Best Current Practice.\n\
    \   This document is a product of the Internet Engineering Task Force\n   (IETF).\
    \  It represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   BCPs is available in Section\
    \ 2 of RFC 5741.\n   Information about the current status of this document, any\
    \ errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc7696.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2015 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  2\n     1.1.  Terminology  . . . . . . . . . . . . . . . . . .\
    \ . . . . .  3\n   2.  Algorithm Agility Guidelines . . . . . . . . . . . . .\
    \ . . . .  3\n     2.1.  Algorithm Identifiers  . . . . . . . . . . . . . . .\
    \ . . .  4\n     2.2.  Mandatory-to-Implement Algorithms  . . . . . . . . . .\
    \ . .  5\n       2.2.1.  Platform Specifications  . . . . . . . . . . . . . .\
    \ .  5\n       2.2.2.  Cryptographic Key Size . . . . . . . . . . . . . . . .\
    \  5\n       2.2.3.  Providing Notice of Expected Changes . . . . . . . . .  6\n\
    \     2.3.  Transitioning from Weak Algorithms . . . . . . . . . . . .  6\n  \
    \   2.4.  Algorithm Transition Mechanisms  . . . . . . . . . . . . .  7\n    \
    \ 2.5.  Cryptographic Key Management . . . . . . . . . . . . . . .  8\n     2.6.\
    \  Preserving Interoperability  . . . . . . . . . . . . . . .  8\n     2.7.  Balancing\
    \ Security Strength  . . . . . . . . . . . . . . .  9\n     2.8.  Balancing Protocol\
    \ Complexity  . . . . . . . . . . . . . . 10\n     2.9.  Opportunistic Security\
    \ . . . . . . . . . . . . . . . . . . 10\n   3.  Cryptographic Algorithm Specifications\
    \ . . . . . . . . . . . . 11\n     3.1.  Choosing Mandatory-to-Implement Algorithms\
    \ . . . . . . . . 11\n     3.2.  Too Many Choices Can Be Harmful  . . . . . .\
    \ . . . . . . . 12\n     3.3.  Picking One True Cipher Suite Can Be Harmful .\
    \ . . . . . . 13\n     3.4.  National Cipher Suites . . . . . . . . . . . . .\
    \ . . . . . 14\n   4.  Security Considerations  . . . . . . . . . . . . . . .\
    \ . . . . 14\n   5.  IANA Considerations  . . . . . . . . . . . . . . . . . .\
    \ . . . 16\n   6.  Normative References . . . . . . . . . . . . . . . . . . .\
    \ . . 16\n   7.  Informative References . . . . . . . . . . . . . . . . . . .\
    \ . 16\n   Acknowledgements . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ 19\n   Author's Address . . . . . . . . . . . . . . . . . . . . . . . . . 19\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Many IETF protocols use cryptographic algorithms to provide\n\
    \   confidentiality, integrity, authentication, or digital signature.\n   For\
    \ interoperability, communicating peers must support a common set\n   of cryptographic\
    \ algorithms.  In most cases, a combination of\n   compatible cryptographic algorithms\
    \ will be used to provide the\n   desired security services.  The set of cryptographic\
    \ algorithms being\n   used at a particular time is often referred to as a cryptographic\n\
    \   algorithm suite or cipher suite.  In a protocol, algorithm\n   identifiers\
    \ might name a single cryptographic algorithm or a full\n   suite of algorithms.\n\
    \   Cryptographic algorithms age; they become weaker with time.  As new\n   cryptanalysis\
    \ techniques are developed and computing capabilities\n   improve, the work required\
    \ to break a particular cryptographic\n   algorithm will reduce, making an attack\
    \ on the algorithm more\n   feasible for more attackers.  While it is unknown\
    \ how cryptoanalytic\n   attacks will evolve, it is certain that they will get\
    \ better.  It is\n   unknown how much better they will become or when the advances\
    \ will\n   happen.  Protocol designers need to assume that advances in computing\n\
    \   power or advances in cryptoanalytic techniques will eventually make\n   any\
    \ algorithm obsolete.  For this reason, protocols need mechanisms\n   to migrate\
    \ from one algorithm suite to another over time.\n   Algorithm agility is achieved\
    \ when a protocol can easily migrate from\n   one algorithm suite to another more\
    \ desirable one, over time.  For\n   the protocol implementer, this means that\
    \ implementations should be\n   modular to easily accommodate the insertion of\
    \ new algorithms or\n   suites of algorithms.  Ideally, implementations will also\
    \ provide a\n   way to measure when deployed implementations have shifted away\
    \ from\n   the old algorithms and to the better ones.  For the protocol\n   designer,\
    \ algorithm agility means that one or more algorithm or suite\n   identifiers\
    \ must be supported, the set of mandatory-to-implement\n   algorithms will change\
    \ over time, and an IANA registry of algorithm\n   identifiers will be needed.\n\
    \   Algorithm identifiers by themselves are not sufficient to ensure easy\n  \
    \ migration.  Action by people that maintain implementations and\n   operate services\
    \ is needed to develop, deploy, and adjust\n   configuration settings to enable\
    \ the new more desirable algorithms\n   and to deprecate or disable older, less\
    \ desirable ones.  For various\n   reasons, most notably interoperability concerns,\
    \ experience has shown\n   that it has proven difficult for implementers and administrators\
    \ to\n   remove or disable weak algorithms.  Further, the inability of legacy\n\
    \   systems and resource-constrained devices to support new algorithms\n   adds\
    \ to those concerns.  As a result, people live with weaker\n   algorithms, sometimes\
    \ seriously flawed ones, well after experts\n   recommend migration.\n"
- title: 1.1.  Terminology
  contents:
  - "1.1.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"\
    SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\"\
    , and \"OPTIONAL\" in this\n   document are to be interpreted as described in\
    \ [RFC2119].\n"
- title: 2.  Algorithm Agility Guidelines
  contents:
  - "2.  Algorithm Agility Guidelines\n   These guidelines are for use by IETF working\
    \ groups and protocol\n   authors for IETF protocols that make use of cryptographic\
    \ algorithms.\n   Past attempts at algorithm agility have not been completely\n\
    \   successful, and this section provides some insights from those\n   experiences.\n"
- title: 2.1.  Algorithm Identifiers
  contents:
  - "2.1.  Algorithm Identifiers\n   IETF protocols that make use of cryptographic\
    \ algorithms MUST support\n   one or more algorithms or suites.  The protocol\
    \ MUST include a\n   mechanism to identify the algorithm or suite that is being\
    \ used.  An\n   algorithm identifier might be explicitly carried in the protocol.\n\
    \   Alternatively, a management mechanism can be used to identify the\n   algorithm.\
    \  For example, an entry in a key table that includes a key\n   value and an algorithm\
    \ identifier might be sufficient.\n   If a protocol does not carry an algorithm\
    \ identifier, then the\n   protocol version number or some other major change\
    \ is needed to\n   transition from one algorithm to another.  The inclusion of\
    \ an\n   algorithm identifier is a minimal step toward cryptographic algorithm\n\
    \   agility.\n   Sometimes a combination of protocol version number and explicit\n\
    \   algorithm or suite identifiers is appropriate.  For example, the\n   Transport\
    \ Layer Security (TLS) [RFC5246] version number names the\n   default key derivation\
    \ function, and the cipher suite identifier\n   names the rest of the needed algorithms.\n\
    \   Some approaches carry one identifier for each algorithm that is used.\n  \
    \ Other approaches carry one identifier for a full suite of algorithms.\n   Both\
    \ approaches are used in IETF protocols.  Designers are encouraged\n   to pick\
    \ one of these approaches and use it consistently throughout\n   the protocol\
    \ or family of protocols.  Suite identifiers make it\n   easier for the protocol\
    \ designer to ensure that the algorithm\n   selections are complete and compatible\
    \ for future assignments.\n   However, suite identifiers inherently face a combinatoric\
    \ explosion\n   as new algorithms are defined.  Algorithm identifiers, on the\
    \ other\n   hand, impose a burden on implementations by forcing a determination\n\
    \   at run-time regarding which algorithm combinations are acceptable.\n   Regardless\
    \ of the approach used, protocols historically negotiate the\n   symmetric cipher\
    \ and cipher mode together to ensure that they are\n   compatible.\n   In the\
    \ IPsec protocol suite, the Internet Key Exchange Protocol\n   version 2 (IKEv2)\
    \ [RFC7296] carries the algorithm identifiers for the\n   Authentication Header\
    \ (AH) [RFC4302] and the Encapsulating Security\n   Payload (ESP) [RFC4303]. \
    \ Such separation is a completely fine design\n   choice.  In contrast, TLS [RFC5246]\
    \ carries cipher suite identifiers,\n   which is also a completely fine design\
    \ choice.\n   An IANA registry SHOULD be used for these algorithm or suite\n \
    \  identifiers.  Once an algorithm identifier is added to the registry,\n   it\
    \ should not be changed or removed.  However, it is desirable to\n   mark a registry\
    \ entry as deprecated when implementation is no longer\n   advisable.\n"
- title: 2.2.  Mandatory-to-Implement Algorithms
  contents:
  - "2.2.  Mandatory-to-Implement Algorithms\n   For secure interoperability, BCP\
    \ 61 [RFC3365] recognizes that\n   communicating peers that use cryptographic\
    \ mechanisms must support a\n   common set of strong cryptographic algorithms.\
    \  For this reason, IETF\n   protocols that employ cryptography MUST specify one\
    \ or more strong\n   mandatory-to-implement algorithms or suites.  This does not\
    \ require\n   all deployments to use this algorithm or suite, but it does require\n\
    \   that it be available to all deployments.\n   The IETF needs to be able to\
    \ change the mandatory-to-implement\n   algorithms over time.  It is highly desirable\
    \ to make this change\n   without updating the base protocol specification.  To\
    \ achieve this\n   goal, it is RECOMMENDED that the base protocol specification\
    \ includes\n   a reference to a companion algorithms document, allowing the update\n\
    \   of one document without necessarily requiring an update to the other.\n  \
    \ This division also facilitates the advancement of the base protocol\n   specification\
    \ on the standards maturity ladder even if the algorithm\n   document changes\
    \ frequently.\n   The IETF SHOULD keep the set of mandatory-to-implement algorithms\n\
    \   small.  To do so, the set of algorithms will necessarily change over\n   time,\
    \ and the transition SHOULD happen before the algorithms in the\n   current set\
    \ have weakened to the breaking point.\n"
- title: 2.2.1.  Platform Specifications
  contents:
  - "2.2.1.  Platform Specifications\n   Note that mandatory-to-implement algorithms\
    \ or suites are not\n   specified for protocols that are embedded in other protocols;\
    \ in\n   these cases, the system-level protocol specification identifies the\n\
    \   mandatory-to-implement algorithm or suite.  For example, S/MIME\n   [RFC5751]\
    \ makes use of the cryptographic message Syntax (CMS)\n   [RFC5652], and S/MIME\
    \ specifies the mandatory-to-implement\n   algorithms, not CMS.  This approach\
    \ allows other protocols to make\n   use of CMS and make different mandatory-to-implement\
    \ algorithm\n   choices.\n"
- title: 2.2.2.  Cryptographic Key Size
  contents:
  - "2.2.2.  Cryptographic Key Size\n   Some cryptographic algorithms are inherently\
    \ tied to a specific key\n   size, but others allow many different key sizes.\
    \  Likewise, some\n   algorithms support parameters of different sizes, such as\
    \ integrity\n   check values or nonces.  The algorithm specification MUST identify\n\
    \   the specific key sizes and parameter sizes that are to be supported.\n   When\
    \ more than one key size is available, expect the mandatory-to-\n   implement\
    \ key size to increase over time.\n   Guidance on cryptographic key size for asymmetric\
    \ keys can be found\n   in BCP 86 [RFC3766].\n   Guidance on cryptographic key\
    \ size for symmetric keys can be found in\n   BCP 195 [RFC7525].\n"
- title: 2.2.3.  Providing Notice of Expected Changes
  contents:
  - "2.2.3.  Providing Notice of Expected Changes\n   Fortunately, algorithm failures\
    \ without warning are rare.  More\n   often, algorithm transition is the result\
    \ of age.  For example, the\n   transition from DES to Triple-DES to AES took\
    \ place over decades,\n   causing a shift in symmetric block cipher strength from\
    \ 56 bits to\n   112 bits to 128 bits.  Where possible, authors SHOULD provide\
    \ notice\n   to implementers about expected algorithm transitions.  One approach\n\
    \   that was first used in RFC 4307 [RFC4307] is to use SHOULD+, SHOULD-,\n  \
    \ and MUST- in the specification of algorithms.  The definitions below\n   are\
    \ slightly modified from those in RFC 4307.\n      SHOULD+  This term means the\
    \ same as SHOULD.  However, it is\n               likely that an algorithm marked\
    \ as SHOULD+ will be\n               promoted to a MUST in the future.\n     \
    \ SHOULD-  This term means the same as SHOULD.  However, it is\n             \
    \  likely that an algorithm marked as SHOULD- will be\n               deprecated\
    \ to a MAY or worse in the future.\n      MUST-    This term means the same as\
    \ MUST.  However, it is\n               expected that an algorithm marked as MUST-\
    \ will be\n               downgraded in the future.  Although the status of the\n\
    \               algorithm will be determined at a later time, it is\n        \
    \       reasonable to expect that a the status of a MUST-\n               algorithm\
    \ will remain at least a SHOULD or a SHOULD-.\n"
- title: 2.3.  Transitioning from Weak Algorithms
  contents:
  - "2.3.  Transitioning from Weak Algorithms\n   Transition from an old algorithm\
    \ that is found to be weak can be\n   tricky.  It is of course straightforward\
    \ to specify the use of a new,\n   better algorithm.  And then, when the new algorithm\
    \ is widely\n   deployed, the old algorithm ought no longer be used.  However,\n\
    \   knowledge about the implementation and deployment of the new\n   algorithm\
    \ will always be imperfect, so one cannot be completely\n   assured of interoperability\
    \ with the new algorithm.\n   Algorithm transition is naturally facilitated as\
    \ part of an algorithm\n   selection or negotiation mechanism.  Protocols traditionally\
    \ select\n   the best algorithm or suite that is supported by all communicating\n\
    \   peers and acceptable by their policies.  In addition, a mechanism is\n   needed\
    \ to determine whether the new algorithm has been deployed.  For\n   example,\
    \ SMIMECapabilities [RFC5751] allows S/MIME mail user agents\n   to share the\
    \ list of algorithms that they are willing to use in\n   preference order.  For\
    \ another example, the DNSSEC EDNS0 option\n   [RFC6975] measures the acceptance\
    \ and use of new digital signing\n   algorithms.\n   In the Resource Public Key\
    \ Infrastructure (RPKI), a globally\n   recognized digital signature is needed.\
    \  BCP 182 [RFC6916] provides\n   an approach to transition, where a second signature\
    \ algorithm is\n   introduced and then the original one is phased out.\n   In\
    \ the worst case, the old algorithm may be found to be tragically\n   flawed,\
    \ permitting a casual attacker to download a simple script to\n   break it.  Sadly,\
    \ this has happened when a secure algorithm is used\n   incorrectly or used with\
    \ poor key management, resulting in a weak\n   cryptographic algorithm suite.\
    \  In such situations, the protection\n   offered by the algorithm is severely\
    \ compromised, perhaps to the\n   point that one wants to stop using the weak\
    \ suite altogether,\n   rejecting offers to use the weak suite well before the\
    \ new suite is\n   widely deployed.\n   In any case, there comes a point in time\
    \ where one refuses to use the\n   old, weak algorithm or suite.  This can happen\
    \ on a flag day, or each\n   installation can select a date on their own.\n"
- title: 2.4.  Algorithm Transition Mechanisms
  contents:
  - "2.4.  Algorithm Transition Mechanisms\n   Cryptographic algorithm selection or\
    \ negotiation SHOULD be integrity\n   protected.  If selection is not integrity\
    \ protected, then the\n   protocol will be subject to a downgrade attack.  Without\
    \ integrity\n   protection of algorithm or suite selection, the attempt to transition\n\
    \   to a new algorithm or suite may introduce new opportunities for\n   downgrade\
    \ attacks.\n   Transition mechanisms need to consider the algorithm that is used\
    \ to\n   provide integrity protection for algorithm negotiation itself.\n   If\
    \ a protocol specifies a single mandatory-to-implement integrity\n   algorithm,\
    \ eventually that algorithm will be found to be weak.\n   Extra care is needed\
    \ when a mandatory-to-implement algorithm is used\n   to provide integrity protection\
    \ for the negotiation of other\n   cryptographic algorithms.  In this situation,\
    \ a flaw in the\n   mandatory-to-implement algorithm may allow an attacker to\
    \ influence\n   the choices of the other algorithms.\n"
- title: 2.5.  Cryptographic Key Establishment
  contents:
  - "2.5.  Cryptographic Key Establishment\n   Traditionally, protocol designers have\
    \ avoided more than one approach\n   to exchanges that establish cryptographic\
    \ keys because it makes the\n   security analysis of the overall protocol more\
    \ difficult.  When\n   frameworks such as the Extensible Authentication Protocol\
    \ (EAP)\n   [RFC3748] and Simple Authentication and Security Layer (SASL)\n  \
    \ [RFC4422] are employed, key establishment is very flexible, often\n   hiding\
    \ many of the details from the application.  This results in\n   protocols that\
    \ support multiple key establishment approaches.  In\n   fact, the key establishment\
    \ approach itself is negotiable, which\n   creates a design challenge to protect\
    \ the negotiation of the key\n   establishment approach before it is used to produce\
    \ cryptographic\n   keys.\n   Protocols can negotiate a key establishment approach,\
    \ derive an\n   initial cryptographic key, and then authenticate the negotiation.\n\
    \   However, if the authentication fails, the only recourse is to start\n   the\
    \ negotiation over from the beginning.\n   Some environments will restrict the\
    \ key establishment approaches by\n   policy.  Such policies tend to improve interoperability\
    \ within a\n   particular environment, but they cause problems for individuals\
    \ that\n   need to work in multiple incompatible environments.\n"
- title: 2.6.  Preserving Interoperability
  contents:
  - "2.6.  Preserving Interoperability\n   Cryptographic algorithm deprecation is\
    \ very difficult.  People do not\n   like to introduce interoperability problems,\
    \ even to preserve\n   security.  As a result, flawed algorithms are supported\
    \ for far too\n   long.  The impact of legacy software and long support tails\
    \ on\n   security can be reduced by making it easy to transition from old\n  \
    \ algorithms and suites to new ones.  Social pressure is often needed\n   to cause\
    \ the transition to happen.\n   Implementers have been reluctant to remove deprecated\
    \ algorithms or\n   suites from server software, and server administrators have\
    \ been\n   reluctant to disable them over concerns that some party will no\n \
    \  longer have the ability to connect to their server.  Implementers and\n   administrators\
    \ want to improve security by using the best supported\n   algorithms, but their\
    \ actions are tempered by the desire to preserve\n   connectivity.  Recently,\
    \ some browser vendors have started to provide\n   visual warnings when a deprecated\
    \ algorithm or suite is used.  These\n   visual warnings provide a new incentive\
    \ to transition away from\n   deprecated algorithms and suites, prompting customers\
    \ to ask for\n   improved security.\n   Transition in Internet infrastructure\
    \ is particularly difficult.  The\n   digital signature on the certificate for\
    \ an intermediate\n   certification authority (CA) [RFC5280] is often expected\
    \ to last\n   decades, which hinders the transition away from a weak signature\n\
    \   algorithm or short key length.  Once a long-lived certificate is\n   issued\
    \ with a particular signature algorithm, that algorithm will be\n   used by many\
    \ relying parties, and none of them can stop supporting it\n   without invalidating\
    \ all of the subordinate certificates.  In a\n   hierarchical system, many subordinate\
    \ certificates could be impacted\n   by the decision to drop support for a weak\
    \ signature algorithm or an\n   associated hash function.\n   Organizations that\
    \ have a significant influence can assist by\n   coordinating the demise of an\
    \ algorithm suite, making the transition\n   easier for their own users as well\
    \ as others.\n"
- title: 2.7.  Balancing Security Strength
  contents:
  - "2.7.  Balancing Security Strength\n   When selecting or negotiating a suite of\
    \ cryptographic algorithms,\n   the strength of each algorithm SHOULD be considered.\
    \  The algorithms\n   in a suite SHOULD be roughly equal by providing comparable\
    \ best-known\n   attack work factors.  However, the security service provided\
    \ by each\n   algorithm in a particular context needs to be considered when making\n\
    \   the selection.  Algorithm strength needs to be considered at the time\n  \
    \ a protocol is designed.  It also needs to be considered at the time a\n   protocol\
    \ implementation is deployed and configured.  Advice from\n   experts is useful,\
    \ but, in reality, such advice is often unavailable\n   to system administrators\
    \ that are deploying a protocol\n   implementation.  For this reason, protocol\
    \ designers SHOULD provide\n   clear guidance to implementers, leading to balanced\
    \ options being\n   available at the time of deployment.\n   Performance is always\
    \ a factor is selecting cryptographic algorithms.\n   Performance and security\
    \ need to be balanced.  Some algorithms offer\n   flexibility in their strength\
    \ by adjusting the key size, number of\n   rounds, authentication tag size, prime\
    \ group size, and so on.  For\n   example, TLS cipher suites include Diffie-Hellman\
    \ or RSA without\n   specifying a particular public key length.  If the algorithm\n\
    \   identifier or suite identifier named a particular public key length,\n   migration\
    \ to longer ones would be more difficult.  On the other hand,\n   inclusion of\
    \ a public key length would make it easier to migrate away\n   from short ones\
    \ when computational resources available to attacker\n   dictate the need to do\
    \ so.  The flexibility on asymmetric key length\n   has led to interoperability\
    \ problems, and to avoid these problems in\n   the future any aspect of the algorithm\
    \ not specified by the algorithm\n   identifiers need to be negotiated, including\
    \ key size and parameters.\n   In CMS [RFC5652], a previously distributed symmetric\
    \ key-encryption\n   key can be used to encrypt a content-encryption key, which\
    \ in turn is\n   used to encrypt the content.  The key-encryption and content-\n\
    \   encryption algorithms are often different.  If, for example, a\n   message\
    \ content is encrypted with a 128-bit AES key and the content-\n   encryption\
    \ key is wrapped with a 256-bit AES key, then at most 128\n   bits of protection\
    \ is provided.  In this situation, the algorithm and\n   key size selections should\
    \ ensure that the key encryption is at least\n   as strong as the content encryption.\
    \  In general, wrapping one key\n   with another key of a different size yields\
    \ the security strength of\n   the shorter key.\n"
- title: 2.8.  Balancing Protocol Complexity
  contents:
  - "2.8.  Balancing Protocol Complexity\n   Protocol designs need to anticipate changes\
    \ in the supported\n   cryptographic algorithm set over time.  There are a number\
    \ of ways to\n   enable the transition, and Section 3 discusses some of the related\n\
    \   issues.\n   Keep implementations as simple as possible.  Complex protocol\n\
    \   negotiation provides opportunities for attack, such as downgrade\n   attacks.\
    \  Support for many algorithm alternatives is also harmful.\n   Both of these\
    \ can lead to portions of the implementation that are\n   rarely used, increasing\
    \ the opportunity for undiscovered exploitable\n   implementation bugs.\n"
- title: 2.9.  Opportunistic Security
  contents:
  - "2.9.  Opportunistic Security\n   Despite the guidance in Section 2.4, opportunistic\
    \ security [RFC7435]\n   also deserves consideration, especially at the time a\
    \ protocol\n   implementation is deployed and configured.  Opportunistic security,\n\
    \   like other reasons for encrypting traffic, needs to make use of the\n   strongest\
    \ encryption algorithms that are implemented and allowed by\n   policy.  When\
    \ communicating parties do not have strong algorithms in\n   common, using algorithms\
    \ that are weak against advanced attackers but\n   sufficient against others is\
    \ one way to make pervasive surveillance\n   significantly more difficult.  As\
    \ a result, when communicating\n   parties do not have strong algorithms in common,\
    \ algorithms that\n   would not be acceptable in many negotiated situations are\
    \ acceptable\n   for opportunistic security when legacy systems are in use for\n\
    \   unauthenticated encrypted sessions (as discussed in Section 3 of\n   [RFC7435])\
    \ as long as their use does not facilitate downgrade\n   attacks.  Similarly,\
    \ weaker algorithms and shorter key sizes are also\n   acceptable for opportunistic\
    \ security with the same constraints.\n   That said, the use of strong algorithms\
    \ is always preferable.\n"
- title: 3.  Cryptographic Algorithm Specifications
  contents:
  - "3.  Cryptographic Algorithm Specifications\n   There are tradeoffs between the\
    \ number of cryptographic algorithms\n   that are supported and the time to deploy\
    \ a new algorithm.  This\n   section provides some of the insights about the tradeoff\
    \ faced by\n   protocol designers.\n   Ideally, two independent sets of mandatory-to-implement\
    \ algorithms\n   will be specified, allowing for a primary suite and a secondary\n\
    \   suite.  This approach ensures that the secondary suite is widely\n   deployed\
    \ if a flaw is found in the primary one.\n"
- title: 3.1.  Choosing Mandatory-to-Implement Algorithms
  contents:
  - "3.1.  Choosing Mandatory-to-Implement Algorithms\n   It may seem as if the ability\
    \ to use an algorithm of one's own\n   choosing is very desirable; however, the\
    \ selection is often better\n   left to experts.  When there are choices, end-users\
    \ might select\n   between configuration profiles that have been defined by experts.\n\
    \   Further, experts need not specify each and every cryptographic\n   algorithm\
    \ alternative.  Specifying all possible choices will not lead\n   to them all\
    \ being available in every implementation.  Mandatory-to-\n   implement algorithms\
    \ MUST have a stable public specification and\n   public documentation that has\
    \ been well studied, giving rise to\n   significant confidence.  The IETF has\
    \ always had a preference for\n   unencumbered algorithms.  There are significant\
    \ benefits in selecting\n   algorithms and suites that are widely deployed.  The\
    \ selected\n   algorithms need to be resistant to side-channel attacks and also\
    \ meet\n   the performance, power, and code size requirements on a wide variety\n\
    \   of platforms.  In addition, inclusion of too many alternatives may\n   add\
    \ complexity to algorithm selection or negotiation.  Specification\n   of too\
    \ many alternatives will likely hamper interoperability and may\n   hamper security\
    \ as well.  When specifying new algorithms or suites,\n   protocol designers would\
    \ be prudent to consider whether existing ones\n   can be deprecated.\n   There\
    \ is significant benefit in selecting the same algorithms and\n   suites for different\
    \ protocols.  Using the same algorithms can\n   simplify implementation when more\
    \ than one of the protocols is used\n   in the same device or system.\n   Sometimes\
    \ more than one mandatory-to-implement algorithm is needed to\n   increase the\
    \ likelihood of interoperability among a diverse\n   population.  For example,\
    \ authenticated encryption is provided by\n   AES-CCM [RFC3610] and AES-GCM [GCM].\
    \  Both of these algorithms are\n   considered to be secure.  AES-CCM is available\
    \ in hardware used by\n   many small devices, and AES-GCM is parallelizable and\
    \ well suited to\n   high-speed devices.  Therefore, an application needing authenticated\n\
    \   encryption might specify one of these algorithms or both of these\n   algorithms,\
    \ depending on the population.\n"
- title: 3.2.  Too Many Choices Can Be Harmful
  contents:
  - "3.2.  Too Many Choices Can Be Harmful\n   It is fairly easy to specify the use\
    \ of any arbitrary cryptographic\n   algorithm, and once the specification is\
    \ available, the algorithm\n   gets implemented and deployed.  Some people say\
    \ that the freedom to\n   specify algorithms independently from the rest of the\
    \ protocol has\n   led to the specification of too many cryptographic algorithms.\
    \  Once\n   deployed, even with moderate uptake, it is quite difficult to remove\n\
    \   algorithms because interoperability with some party will be impacted.\n  \
    \ As a result, weaker ciphers stick around far too long.  Sometimes\n   implementers\
    \ are forced to maintain cryptographic algorithm\n   implementations well beyond\
    \ their useful lifetime.\n   In order to manage the proliferation of algorithm\
    \ choices and provide\n   an expectation of interoperability, many protocols specify\
    \ mandatory-\n   to-implement algorithms or suites.  All implementers are expected\
    \ to\n   support the mandatory-to-implement cryptographic algorithm, and they\n\
    \   can include any others algorithms that they desire.  The mandatory-\n   to-implement\
    \ algorithms are chosen to be highly secure and follow the\n   guidance in RFC\
    \ 1984 [RFC1984].  Of course, many other factors,\n   including intellectual property\
    \ rights, have an impact on the\n   cryptographic algorithms that are selected\
    \ by the community.\n   Generally, the mandatory-to-implement algorithms ought\
    \ to be\n   preferred, and the other algorithms ought to be selected only in\n\
    \   special situations.  However, it can be very difficult for a skilled\n   system\
    \ administrator to determine the proper configuration to achieve\n   these preferences.\n\
    \   In some cases, more than one mandatory-to-implement cryptographic\n   algorithm\
    \ has been specified.  This is intended to ensure that at\n   least one secure\
    \ cryptographic algorithm will be available, even if\n   other mandatory-to-implement\
    \ algorithms are broken.  To achieve this\n   goal, the selected algorithms must\
    \ be diverse, so that a\n   cryptoanalytic advance against one of the algorithms\
    \ does not also\n   impact the other selected algorithms.  The idea is to have\
    \ an\n   implemented and deployed algorithm as a fallback.  However, all of\n\
    \   the selected algorithms need to be routinely exercised to ensure\n   quality\
    \ implementation.  This is not always easy to do, especially if\n   the various\
    \ selected algorithms require different credentials.\n   Obtaining multiple credentials\
    \ for the same installation is an\n   unacceptable burden on system administrators.\
    \  Also, the manner by\n   which system administrators are advised to switch algorithms\
    \ or\n   suites is, at best, ad hoc and, at worst, entirely absent.\n"
- title: 3.3.  Picking One True Cipher Suite Can Be Harmful
  contents:
  - "3.3.  Picking One True Cipher Suite Can Be Harmful\n   In the past, protocol\
    \ designers have chosen one cryptographic\n   algorithm or suite, and then tied\
    \ many protocol details to that\n   selection.  Plan for algorithm transition,\
    \ either because a mistake\n   is made in the initial selection or because the\
    \ protocol is\n   successfully used for a long time and the algorithm becomes\
    \ weak with\n   age.  Either way, the design should enable transition.\n   Protocol\
    \ designers are sometimes misled by the simplicity that\n   results from selecting\
    \ one true algorithm or suite.  Since algorithms\n   age, the selection cannot\
    \ be stable forever.  Even the most simple\n   protocol needs a version number\
    \ to signal which algorithm is being\n   used.  This approach has at least two\
    \ desirable consequences.  First,\n   the protocol is simpler because there is\
    \ no need for algorithm\n   negotiation.  Second, system administrators do not\
    \ need to make any\n   algorithm-related configuration decisions.  However, the\
    \ only way to\n   respond to news that an algorithm that is part of the one true\
    \ cipher\n   suite has been broken is to update the protocol specification to\
    \ the\n   next version, implement the new specification, and then get it\n   deployed.\n\
    \   The first IEEE 802.11 [WiFi] specification included Wired Equivalent\n   Privacy\
    \ (WEP) as the only encryption technique.  Many of the protocol\n   details were\
    \ driven by the selected algorithm.  WEP was found to be\n   quite weak [WEP],\
    \ and a very large effort was needed to specify,\n   implement, and deploy the\
    \ alternative encryption techniques.  This\n   effort was made even harder by\
    \ the protocol design choices that were\n   tied to the initial algorithm selection\
    \ and the desire for backward\n   compatibility.\n   Experience with the transition\
    \ from SHA-1 to SHA-256 indicates that\n   the time from protocol specification\
    \ to widespread use takes more\n   than five years.  In this case, the protocol\
    \ specifications and\n   implementation were straightforward and fairly prompt.\
    \  In many\n   software products, the new algorithm was not considered an update\
    \ to\n   the existing release, so the roll-out of the next release, subsequent\n\
    \   deployment, and finally adjustment of the configuration by system\n   administrators\
    \ took many years.  In many consumer hardware products,\n   firmware to implement\
    \ the new algorithm was difficult to locate and\n   install, or it was simply\
    \ not available.  Further, infrastructure\n   providers were unwilling to make\
    \ the transition until all of their\n   potential clients were able to use the\
    \ new algorithm.\n"
- title: 3.4.  National Cipher Suites
  contents:
  - "3.4.  National Cipher Suites\n   Some nations specify cryptographic algorithms,\
    \ and then require their\n   use through legislation or regulations.  These algorithms\
    \ may not\n   have wide public review, and they can have limited geographic scope\n\
    \   in their deployment.  Yet, the legislative or regulatory mandate\n   creates\
    \ a captive market.  As a result, such algorithms will get\n   specified, implemented,\
    \ and deployed.  The default server or\n   responder configuration SHOULD disable\
    \ such algorithms; in this way,\n   explicit action by the system administrator\
    \ is needed to enable them\n   where they are actually required.  For tiny devices\
    \ with no user\n   interface, an administrator action may only be possible at\
    \ the time\n   the device is purchased.\n   National algorithms can force an implementer\
    \ to produce several\n   incompatible product releases for different countries\
    \ or regions;\n   this has significantly greater cost over development of a product\n\
    \   using a globally acceptable algorithm.  This situation could be even\n   worse\
    \ if the various national algorithms impose different\n   requirements on the\
    \ protocol, its key management, or its use of\n   random values.\n"
- title: 4.  Security Considerations
  contents:
  - "4.  Security Considerations\n   This document provides guidance to working groups\
    \ and protocol\n   designers.  The security of the Internet is improved when broken\
    \ or\n   weak cryptographic algorithms can be easily replaced with strong\n  \
    \ ones.\n   From a software development and maintenance perspective,\n   cryptographic\
    \ algorithms can often be added and removed without\n   making changes to surrounding\
    \ data structures, protocol parsing\n   routines, or state machines.  This approach\
    \ separates the\n   cryptographic algorithm implementation from the rest of the\
    \ code,\n   which makes it easier to tackle special security concerns such as\
    \ key\n   exposure and constant-time execution.\n   Sometimes application-layer\
    \ protocols can make use of transport-layer\n   security protocols, such as TLS\
    \ [RFC5246] or Datagram TLS (DTLS)\n   [RFC6347].  This insulates the application-layer\
    \ protocol from the\n   details of cryptography, but it is likely to still be\
    \ necessary to\n   handle the transition from unprotected traffic to protected\
    \ traffic\n   in the application-layer protocol.  In addition, the application-\n\
    \   layer protocol may need to handle the downgrade from encrypted\n   communication\
    \ to plaintext communication.\n   Hardware offers challenges in the transition\
    \ of algorithms, for both\n   tiny devices and very high-end data center equipment.\
    \  Many tiny\n   devices do not include the ability to update the firmware at\
    \ all.\n   Even if the firmware can be updated, tiny devices are often deployed\n\
    \   in places that make it very inconvenient to do so.  High-end data\n   center\
    \ equipment may use special-purpose chips to achieve very high\n   performance,\
    \ which means that board-level replacement may be needed\n   to change the algorithm.\
    \  Cost and downtime are both factors in such\n   an upgrade.\n   In most cases,\
    \ the cryptographic algorithm remains strong, but an\n   attack is found against\
    \ the way that the strong algorithm is used in\n   a particular protocol.  In\
    \ these cases, a protocol change will\n   probably be needed.  For example, the\
    \ order of cryptographic\n   operations in the TLS protocol has evolved as various\
    \ attacks have\n   been discovered.  Originally, TLS performed encryption after\n\
    \   computation of the message authentication code (MAC).  This order of\n   operations\
    \ is called MAC-then-encrypt, which actually involves MAC\n   computation, padding,\
    \ and then encryption.  This is no longer\n   considered secure [BN] [K].  As\
    \ a result, a mechanism was specified\n   to use encrypt-then-MAC instead [RFC7366].\
    \  Future versions of TLS\n   are expected to use exclusively authenticated encryption\
    \ algorithms\n   [RFC5116], which should resolve the ordering discussion altogether.\n\
    \   After discovery of such attacks, updating the cryptographic\n   algorithms\
    \ is not likely to be sufficient to thwart the new attack.\n   It may necessary\
    \ to make significant changes to the protocol.\n   Some protocols are used to\
    \ protect stored data.  For example, S/MIME\n   [RFC5751] can protect a message\
    \ kept in a mailbox.  To recover the\n   protected stored data, protocol implementations\
    \ need to support older\n   algorithms, even when they no longer use the older\
    \ algorithms for the\n   protection of new stored data.\n   Support for too many\
    \ algorithms can lead to implementation\n   vulnerabilities.  When many algorithms\
    \ are supported, some of them\n   will be rarely used.  Any code that is rarely\
    \ used can contain\n   undetected bugs, and algorithm implementations are no different.\n\
    \   Measurements SHOULD be used to determine whether implemented\n   algorithms\
    \ are actually being used, and if they are not, future\n   releases should remove\
    \ them.  In addition, unused algorithms or\n   suites SHOULD be marked as deprecated\
    \ in the IANA registry.  In\n   short, eliminate the cruft.\n   Section 2.3 talks\
    \ about algorithm transition without considering any\n   other aspects of the\
    \ protocol design.  In practice, there are\n   dependencies between the cryptographic\
    \ algorithm and other aspects of\n   the protocol.  For example, the BEAST attack\
    \ [BEAST] against TLS\n   [RFC5246] caused many sites to turn off modern cryptographic\n\
    \   algorithms in favor of older and clearly weaker algorithms.\n   Mechanisms\
    \ for timely update of devices are needed to deploy a\n   replacement algorithm\
    \ or suite.  It takes a long time to specify,\n   implement, and deploy a replacement;\
    \ therefore, the transition\n   process needs to begin when practically exploitable\
    \ flaws become\n   known.  The update processes on some devices involve certification,\n\
    \   which further increases the time to deploy a replacement.  For\n   example,\
    \ devices that are part of health or safety systems often\n   require certification\
    \ before deployment.  Embedded systems and SCADA\n   (supervisory control and\
    \ data acquisition) systems often have upgrade\n   cycles stretching over many\
    \ years, leading to similar time-to-\n   deployment issues.  Prompt action is\
    \ needed if a replacement has any\n   hope of being deployed before exploitation\
    \ techniques become widely\n   available.\n"
- title: 5.  IANA Considerations
  contents:
  - "5.  IANA Considerations\n   This document does not establish any new IANA registries,\
    \ nor does it\n   add any entries to existing registries.\n   This document does\
    \ RECOMMEND a convention for new registries for\n   cryptographic algorithm or\
    \ suite identifiers.  Once an algorithm or\n   suite identifier is added to the\
    \ registry, it SHOULD NOT be changed\n   or removed.  However, it is desirable\
    \ to include a means of marking a\n   registry entry as deprecated when implementation\
    \ is no longer\n   advisable.\n"
- title: 6.  Normative References
  contents:
  - "6.  Normative References\n   [RFC2119] Bradner, S., \"Key words for use in RFCs\
    \ to Indicate\n             Requirement Levels\", BCP 14, RFC 2119,\n        \
    \     DOI 10.17487/RFC2119, March 1997,\n             <http://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC3766] Orman, H. and P. Hoffman, \"Determining Strengths For Public\n \
    \            Keys Used For Exchanging Symmetric Keys\", BCP 86, RFC 3766,\n  \
    \           DOI 10.17487/RFC3766, April 2004,\n             <http://www.rfc-editor.org/info/rfc3766>.\n"
- title: 7.  Informative References
  contents:
  - "7.  Informative References\n   [BEAST]   Wikipedia, \"BEAST attack\" under \"\
    Transport Layer Security\",\n             November 2015, <https://en.wikipedia.org/w/index.php?title=\n\
    \             Transport_Layer_Security&oldid=689441642#BEAST_attack>.\n   [BN]\
    \      Bellare, M. and C. Namprempre, \"Authenticated Encryption:\n          \
    \   Relations among notions and analysis of the generic\n             composition\
    \ paradigm\", Proceedings of AsiaCrypt '00,\n             Springer-Verlag LNCS\
    \ No. 1976, p. 531,\n             DOI 10.1007/3-540-44448-3_41, December 2000.\n\
    \   [GCM]     Dworkin, M, \"Recommendation for Block Cipher Modes of\n       \
    \      Operation: Galois/Counter Mode (GCM) and GMAC\", NIST\n             Special\
    \ Publication 800-30D, November 2007.\n   [K]       Krawczyk, H., \"The Order\
    \ of Encryption and Authentication\n             for Protecting Communications\
    \ (or: How Secure Is SSL?)\",\n             Proceedings of Crypto '01, Springer-Verlag\
    \ LNCS No. 2139,\n             p. 310, DOI 10.1007/3-540-44647-8_19, August 2001.\n\
    \   [RFC1984] IAB and IESG, \"IAB and IESG Statement on Cryptographic\n      \
    \       Technology and the Internet\", BCP 200, RFC 1984,\n             DOI 10.17487/RFC1984,\
    \ August 1996,\n             <http://www.rfc-editor.org/info/rfc1984>.\n   [RFC3365]\
    \ Schiller, J., \"Strong Security Requirements for Internet\n             Engineering\
    \ Task Force Standard Protocols\", BCP 61,\n             RFC 3365, DOI 10.17487/RFC3365,\
    \ August 2002,\n             <http://www.rfc-editor.org/info/rfc3365>.\n   [RFC3610]\
    \ Whiting, D., Housley, R., and N. Ferguson, \"Counter with\n             CBC-MAC\
    \ (CCM)\", RFC 3610, DOI 10.17487/RFC3610, September\n             2003, <http://www.rfc-editor.org/info/rfc3610>.\n\
    \   [RFC3748] Aboba, B., Blunk, L., Vollbrecht, J., Carlson, J., and H.\n    \
    \         Levkowetz, Ed., \"Extensible Authentication Protocol (EAP)\",\n    \
    \         RFC 3748, DOI 10.17487/RFC3748, June 2004,\n             <http://www.rfc-editor.org/info/rfc3748>.\n\
    \   [RFC4302] Kent, S., \"IP Authentication Header\", RFC 4302,\n            \
    \ DOI 10.17487/RFC4302, December 2005,\n             <http://www.rfc-editor.org/info/rfc4302>.\n\
    \   [RFC4303] Kent, S., \"IP Encapsulating Security Payload (ESP)\",\n       \
    \      RFC 4303, DOI 10.17487/RFC4303, December 2005,\n             <http://www.rfc-editor.org/info/rfc4303>.\n\
    \   [RFC4307] Schiller, J., \"Cryptographic Algorithms for Use in the\n      \
    \       Internet Key Exchange Version 2 (IKEv2)\", RFC 4307,\n             DOI\
    \ 10.17487/RFC4307, December 2005,\n             <http://www.rfc-editor.org/info/rfc4307>.\n\
    \   [RFC4422] Melnikov, A., Ed., and K. Zeilenga, Ed., \"Simple\n            \
    \ Authentication and Security Layer (SASL)\", RFC 4422,\n             DOI 10.17487/RFC4422,\
    \ June 2006,\n             <http://www.rfc-editor.org/info/rfc4422>.\n   [RFC5116]\
    \ McGrew, D., \"An Interface and Algorithms for Authenticated\n             Encryption\"\
    , RFC 5116, DOI 10.17487/RFC5116, January 2008,\n             <http://www.rfc-editor.org/info/rfc5116>.\n\
    \   [RFC5246] Dierks, T. and E. Rescorla, \"The Transport Layer Security\n   \
    \          (TLS) Protocol Version 1.2\", RFC 5246,\n             DOI 10.17487/RFC5246,\
    \ August 2008,\n             <http://www.rfc-editor.org/info/rfc5246>.\n   [RFC5280]\
    \ Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,\n             Housley, R.,\
    \ and W. Polk, \"Internet X.509 Public Key\n             Infrastructure Certificate\
    \ and Certificate Revocation List\n             (CRL) Profile\", RFC 5280, DOI\
    \ 10.17487/RFC5280, May 2008,\n             <http://www.rfc-editor.org/info/rfc5280>.\n\
    \   [RFC5652] Housley, R., \"Cryptographic Message Syntax (CMS)\", STD 70,\n \
    \            RFC 5652, DOI 10.17487/RFC5652, September 2009,\n             <http://www.rfc-editor.org/info/rfc5652>.\n\
    \   [RFC5751] Ramsdell, B. and S. Turner, \"Secure/Multipurpose Internet\n   \
    \          Mail Extensions (S/MIME) Version 3.2 Message\n             Specification\"\
    , RFC 5751, DOI 10.17487/RFC5751, January\n             2010, <http://www.rfc-editor.org/info/rfc5751>.\n\
    \   [RFC6347] Rescorla, E. and N. Modadugu, \"Datagram Transport Layer\n     \
    \        Security Version 1.2\", RFC 6347, DOI 10.17487/RFC6347,\n           \
    \  January 2012, <http://www.rfc-editor.org/info/rfc6347>.\n   [RFC6916] Gagliano,\
    \ R., Kent, S., and S. Turner, \"Algorithm Agility\n             Procedure for\
    \ the Resource Public Key Infrastructure\n             (RPKI)\", BCP 182, RFC\
    \ 6916, DOI 10.17487/RFC6916, April\n             2013, <http://www.rfc-editor.org/info/rfc6916>.\n\
    \   [RFC6975] Crocker, S. and S. Rose, \"Signaling Cryptographic Algorithm\n \
    \            Understanding in DNS Security Extensions (DNSSEC)\",\n          \
    \   RFC 6975, DOI 10.17487/RFC6975, July 2013,\n             <http://www.rfc-editor.org/info/rfc6975>.\n\
    \   [RFC7296] Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T.\n        \
    \     Kivinen, \"Internet Key Exchange Protocol Version 2\n             (IKEv2)\"\
    , STD 79, RFC 7296, DOI 10.17487/RFC7296, October\n             2014, <http://www.rfc-editor.org/info/rfc7296>.\n\
    \   [RFC7366] Gutmann, P., \"Encrypt-then-MAC for Transport Layer Security\n \
    \            (TLS) and Datagram Transport Layer Security (DTLS)\",\n         \
    \    RFC 7366, DOI 10.17487/RFC7366, September 2014,\n             <http://www.rfc-editor.org/info/rfc7366>.\n\
    \   [RFC7435] Dukhovni, V., \"Opportunistic Security: Some Protection Most\n \
    \            of the Time\", RFC 7435, DOI 10.17487/RFC7435, December\n       \
    \      2014, <http://www.rfc-editor.org/info/rfc7435>.\n   [RFC7525] Sheffer,\
    \ Y., Holz, R., and P. Saint-Andre, \"Recommendations\n             for Secure\
    \ Use of Transport Layer Security (TLS) and\n             Datagram Transport Layer\
    \ Security (DTLS)\", BCP 195,\n             RFC 7525, DOI 10.17487/RFC7525, May\
    \ 2015,\n             <http://www.rfc-editor.org/info/rfc7525>.\n   [WEP]    \
    \ Wikipedia, \"Wired Equivalent Privacy\", November 2015,\n             <https://en.wikipedia.org/w/index.php?\n\
    \             title=Wired_Equivalent_Privacy&oldid=688848497>.\n   [WiFi]    IEEE,\
    \ \"Wireless LAN Medium Access Control (MAC) And\n             Physical Layer\
    \ (PHY) Specifications\", IEEE Std 802.11-1997,\n             1997.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   Thanks to Bernard Aboba, Derek Atkins, David Black, Randy\
    \ Bush, Jon\n   Callas, Andrew Chi, Steve Crocker, Viktor Dukhovni, Stephen Farrell,\n\
    \   Tony Finch, Ian Grigg, Peter Gutmann, Phillip Hallam-Baker, Wes\n   Hardaker,\
    \ Joe Hildebrand, Paul Hoffman, Christian Huitema, Leif\n   Johansson, Suresh\
    \ Krishnan, Watson Ladd, Paul Lambert, Ben Laurie,\n   Eliot Lear, Nikos Mavrogiannopoulos,\
    \ Kathleen Moriarty, Yoav Nir,\n   Kenny Paterson, Rich Salz, Wendy Seltzer, Joel\
    \ Sing, Rene Struik,\n   Kristof Teichel, Martin Thompson, Jeffrey Walton, Nico\
    \ Williams, and\n   Peter Yee for their review and insightful comments.  While\
    \ some of\n   these people do not agree with some aspects of this document, the\n\
    \   discussion that resulted for their comments has certainly resulted in\n  \
    \ a better document.\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Russ Housley\n   Vigil Security, LLC\n   918 Spring Knoll\
    \ Drive\n   Herndon, VA 20170\n   United States\n   Email: housley@vigilsec.com\n"
