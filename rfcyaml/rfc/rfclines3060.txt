Abstract This document presents the object oriented information model for representing policy information developed jointly in the IETF Policy Framework WG and as extensions to the Common Information Model (CIM) activity in the Distributed Management Task Force (DMTF).
This model defines two hierarchies of object classes:  structural classes representing policy information and control of policies, and association classes that indicate how instances of the structural classes are related to each other.
Subsequent documents will define mappings of this information model to various concrete implementations, for example, to a directory that uses LDAPv3 as its access protocol.
This document presents the object oriented information model for representing policy information currently under joint development in the IETF Policy Framework WG and as extensions to the Common Information Model (CIM) activity in the Distributed Management Task Force (DMTF).
This model defines two hierarchies of object classes: structural classes representing policy information and control of policies, and association classes that indicate how instances of the structural classes are related to each other.
Subsequent documents will define mappings of this information model to various concrete implementations, for example, to a directory that uses LDAPv3 as its access protocol.
The components of the CIM schema are available via the following URL: http://www.dmtf.org/spec/cims.html [1].
The policy classes and associations defined in this model are sufficiently generic to allow them to represent policies related to anything.
However, it is expected that their initial application in the IETF will be for representing policies related to QoS (DiffServ and IntServ) and to IPSec.
Policy models for application specific areas such as these may extend the Core Model in several ways.
The preferred way is to use the PolicyGroup, PolicyRule, and PolicyTimePeriodCondition classes directly, as a foundation for representing and communicating policy information.
Then, specific subclasses derived from PolicyCondition and PolicyAction can capture application specific definitions of conditions and actions of policies.
Two subclasses, VendorPolicyCondition and VendorPolicyAction, are also included in this document, to provide a standard extension mechanism for vendor specific extensions to the Policy Core Information Model.
This document fits into the overall framework for representing, deploying, and managing policies being developed by the Policy Framework Working Group.
It traces its origins to work that was originally done for the Directory enabled Networks (DEN) specification, reference [5].
Work on the DEN specification by the DEN Ad
Hoc Working Group itself has been completed.
Further work to standardize the models contained in it will be the responsibility of selected working groups of the CIM effort in the Distributed Management Task Force (DMTF).
DMTF standardization of the core policy model is the responsibility of the SLA Policy working group in the DMTF.
This document is organized in the following manner:  Section 2 provides a general overview of policies and how they are modeled.
Section 3 presents a high level overview of the classes and associations comprising the Policy Core Information Model.
The remainder of the document presents the detailed specifications for each of the classes and associations.
Appendix A overviews naming for native CIM implementations.
Other mappings, such as LDAPv3, will have their own naming mechanisms.
Appendix B reproduces the DMTF's Core Policy MOF specification.
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119, reference [3].
The classes comprising the Policy Core Information Model are intended to serve as an extensible class hierarchy (through specialization) for defining policy objects that enable application developers, network administrators, and policy administrators to represent policies of different types.
One way to think of a policy controlled network is to first model the network as a state machine and then use policy to control which state a policy controlled device should be in or is allowed to be in at any given time.
Given this approach, policy is applied using a set of policy rules.
Each policy rule consists of a set of conditions and a set of actions.
Policy rules may be aggregated into policy groups.
These groups may be nested, to represent a hierarchy of policies.
The set of conditions associated with a policy rule specifies when the policy rule is applicable.
The set of conditions can be expressed as either an ORed set of ANDed sets of condition statements or an ANDed set of ORed sets of statements.
Individual condition statements can also be negated.
These combinations are termed, respectively, Disjunctive Normal Form (DNF) and Conjunctive Normal Form (CNF) for the conditions.
If the set of conditions associated with a policy rule evaluates to TRUE, then a set of actions that either maintain the current state of the object or transition the object to a new state may be executed.
For the set of actions associated with a policy rule, it is possible to specify an order of execution, as well as an indication of whether the order is required or merely recommended.
It is also possible to indicate that the order in which the actions are executed does not matter.
Policy rules themselves can be prioritized.
One common reason for doing this is to express an overall policy that has a general case with a few specific exceptions.
For example, a general QoS policy rule might specify that traffic originating from members of the engineering group is to get Bronze Service.
A second policy rule might express an exception: traffic originating from John, a specific member of the engineering group, is to get Gold Service.
Since traffic originating from John satisfies the conditions of both policy rules, and since the actions associated with the two rules are incompatible, a priority needs to be established.
By giving the second rule (the exception) a higher priority than the first rule (the general case), a policy administrator can get the desired effect: traffic originating from John gets Gold Service, and traffic originating from all the other members of the engineering group gets Bronze Service.
Policies can either be used in a stand alone fashion or aggregated into policy groups to perform more elaborate functions.
Stand alone policies are called policy rules.
Policy groups are aggregations of policy rules, or aggregations of policy groups, but not both.
Policy groups can model intricate interactions between objects that have complex interdependencies.
Examples of this include a sophisticated user logon policy that sets up application access, security, and reconfigures network connections based on a combination of user identity, network location, logon method and time of day.
A policy group represents a unit of reusability and manageability in that its management is handled by an identifiable group of administrators and its policy rules would be consistently applied Stand alone policies are those that can be expressed in a simple statement.
They can be represented effectively in schemata or MIBs.
Examples of this are VLAN assignments, simple
YES/NO QoS requests, and IP address allocations.
A specific design goal of this model is to support both stand alone and aggregated policies.
Policy groups and rules can be classified by their purpose and intent.
This classification is useful in querying or grouping policy rules.
It indicates whether the policy is used to motivate when or how an action occurs, or to characterize services (that can then be used, for example, to bind clients to network services).
Describing each of these concepts in more detail,  Motivational Policies are solely targeted at whether or how a policy's goal is accomplished.
Configuration and Usage Policies are specific kinds of Motivational Policies.
Another example is the scheduling of file backup based on disk write activity from 8am to 3pm, M F.  Configuration Policies define the default (or generic) setup of a managed entity (for example, a network service).
Examples of Configuration Policies are the setup of a network forwarding service or a network hosted print queue.
Installation Policies define what can and cannot be put on a system or component, as well as the configuration of the mechanisms that perform the install.
Installation policies typically represent specific administrative permissions, and can also represent dependencies between different components (e.g., to complete the installation of component A, components B and C must be previously successfully installed or uninstalled).
For example, if a device fails between 8am and 9pm, call the system administrator, otherwise call the Help Desk.
Usage Policies control the selection and configuration of entities based on specific "usage" data.
Configuration Policies can be modified or simply re applied by Usage Policies.
Examples of Usage Policies include upgrading network forwarding services after a user is verified to be a member of a "gold" service group, or reconfiguring a printer to be able to handle the next job in its queue.
Security Policies deal with verifying that the client is actually who the client purports to be, permitting or denying access to resources, selecting and applying appropriate authentication mechanisms, and performing accounting and auditing of resources.
Service Policies characterize network and other services (not use them).
For example, all wide area backbone interfaces shall use a specific type of queuing.
Service policies describe services available in the network.
Usage policies describe the particular binding of a client of the network to services available in the network.
These categories are represented in the Policy Core Information Model by special values defined for the PolicyKeywords property of the abstract class Policy.
Policy Scope Policies represent business goals and objectives.
A translation must be made between these goals and objectives and their realization in the network.
An example of this could be a Service Level Agreement (SLA), and its objectives and metrics (Service Level Objectives, or SLOs), that are used to specify services that the network will provide for a given client.
The SLA will usually be written in high level business terminology.
SLOs address more specific metrics in support of the SLA.
These high level descriptions of network services and metrics must be translated into lower level, but also vendor and device independent specifications.
The Policy Core Information Model classes are intended to serve as the foundation for these lower level, vendor  and device independent specifications.
It is envisioned that the definition of the Policy Core Informational Model in this document is generic in nature and is applicable to Quality of Service (QoS), to non QoS networking applications (e.g., DHCP and IPSec), and to non networking applications (e.g., backup policies, auditing access, etc.).
The design of the Policy Core Information Model is influenced by a declarative, not procedural, approach.
More formally, a declarative language is used to describe relational and functional languages.
Declarative languages describe relationships between variables in terms of functions or inference rules, to which the interpreter or compiler can apply a fixed algorithm in order to produce a result.
An imperative (or procedural) language specifies an explicit sequence of steps to follow in order to produce a result.
It is important to note that this information model does not rule out the use of procedural languages.
Rather, it recognizes that both declarative as well as procedural languages can be used to implement policy.
This information model is better viewed as being declarative because the sequence of steps for doing the processing of declarative statements tends to be left to the implementer.
However, we have provided the option of expressing the desired order of action execution in this policy information model, and for expressing whether the order is mandatory or not.
In addition, rather than trying to define algorithms or sets of instructions or steps that must be followed by a policy rule, we instead define a set of modular building blocks and relationships that can be used in a declarative or procedural fashion to define policies.
Compare this to a strictly procedural model.
Taking such an approach would require that we specify the condition testing sequence, and the action execution sequence, in the policy repository itself.
This would, indeed, constrain the implementer.
This is why the policy model is characterized as a declarative one.
That is, the information model defines a set of attributes, and a set of entities that contain these attributes.
However, it does NOT define either the algorithm to produce a result using the attributes or an explicit sequence of steps to produce a result.
There are several design considerations and trade offs to make in this respect.
On the one hand, we would like a policy definition language to be reasonably human friendly for ease of definitions and diagnostics.
On the other hand, given the diversity of devices (in terms of their processing capabilities) which could act as policy decision points, we would like to keep the language somewhat machine  friendly.
That is, it should be relatively simple to automate the parsing and processing of the language in network elements.
The approach taken is to provide a set of classes and attributes that can be combined in either a declarative or procedural approach to express policies that manage network elements and services.
The key point is to avoid trying to standardize rules or sets of steps to be followed in defining a policy.
These must be left up to an implementation.
Interoperability is achieved by standardizing the building blocks that are used to represent policy data and information.
An important decision to make is the semantic style of the representation of the information.
The declarative approach that we are describing falls short of being a "true" declarative model.
Such a model would also specify the algorithms used to combine the information and policy rules to achieve particular behavior.
We avoid specifying algorithms for the same reason that we avoid specifying sets of steps to be followed in a policy rule.
However, the design of the information model more closely follows that of a declarative language, and may be easier to understand if such a conceptual model is used.
This leads to our third point, acknowledging a lack of "completeness" and instead relying on presenting information that the policy processing entity will work with.
It is important to control the complexity of the specification, trading off richness of expression of data in the core information model for ease of implementation and use.
It is important to acknowledge the collective lack of experience in the field regarding policies to control and manage network services and hence avoid the temptation of aiming for "completeness".
We should instead strive to facilitate definition of a set of common policies that customers require today (e.g., VPN and QoS) and allow migration paths towards supporting complex policies as customer needs and our understanding of these policies evolve with experience.
Specifically, in the context of the declarative style language discussed above, it is important to avoid having full blown predicate calculus as the language, as it would render many important problems such as consistency checking and policy decision point algorithms intractable.
It is useful to consider a reasonably constrained language from these perspectives.
The Policy Core Information Model strikes a balance between complexity and lack of power by using the well
understood logical concepts of Disjunctive Normal Form and Conjunctive Normal Form for combining simple policy conditions into more complex ones.
Overview of the Policy Core Information Model
The following diagram provides an overview of the five central classes comprising the Policy Core Information Model, their associations to each other, and their associations to other classes in the overall CIM model.
Note that the abstract class Policy and the two extension classes VendorPolicyCondition and VendorPolicyAction are not shown.
Overview of the Core Policy Classes and Relationships
In this figure the boxes represent the classes, and the dotted arrows represent the associations.
An association always connects two classes.
The "two" classes may, however, be the same class, as is the case with the PolicyGroupInPolicyGroup association, which represents the recursive containment of PolicyGroups in other PolicyGroups.
The PolicyRepositoryInPolicyRepository association is recursive in the same way.
An association includes cardinalities for each of the related classes.
These cardinalities indicate how many instances of each class may be related to an instance of the other class.
indicates that a PolicyRule may be related to no PolicyGroups, to one PolicyGroup, or to more than one PolicyGroup via the PolicyRuleInPolicyGroup association.
In other words, a PolicyRule may be contained in no PolicyGroups, in one PolicyGroups, or in more than one PolicyGroup.
indicates that a PolicyGroup may be related to no PolicyRules, to one PolicyRule, or to more than one PolicyRule via the PolicyRuleInPolicyGroup association.
In other words, a PolicyGroup may contain no PolicyRules, one PolicyRule, or more than one PolicyRule.
The "w" written next to the PolicyGroupInSystem and PolicyRuleInSystem indicates that these are what CIM terms "aggregations with weak references", or more briefly, "weak aggregations".
A weak aggregation is simply an indication of a naming scope.
Thus these two aggregations indicate that an instance of a PolicyGroup or PolicyRule is named within the scope of a System object.
A weak aggregation implicitly has the cardinality 1..1 at the end opposite the 'w'.
The associations shown in Figure 1 are discussed in more detail in Section 7.
Inheritance Hierarchies for the Policy Core Information Model
These classes are not discussed in detail in this document.
In CIM, associations are also modeled as classes.
For the Policy Core Information Model, the inheritance hierarchy for the associations is as follows:
Inheritance Hierarchy for the Core Policy Associations
The Dependency, Component, and SystemComponent associations are defined in the CIM schema [1], and are not discussed further in this document.
Implications of CIM Inheritance From the CIM schema, both properties and associations are inherited to the Policy classes.
For example, the class ManagedElement is referenced in the associations Dependency, Statistics and MemberOfCollection.
And, the Dependency association is in turn referenced in the DependencyContext association.
At this very abstract and high level in the inheritance hierarchy, the number of these associations is very small and their semantics are quite general.
Many of these inherited associations convey additional semantics that are not needed in understanding the Policy Core Information Model.
In fact, they are defined as OPTIONAL in the CIM Schema since their cardinality is "0..
The PCIM document specifically discusses what is necessary to support and instantiate.
For example, through subclassing of the Dependency association, the exact Dependency semantics in PCIM are described.
So, one may wonder what to do with these other inherited associations.
The answer is "ignore them unless you need them".
You would need them to describe additional information and semantics for policy data.
For example, it may be necessary to capture statistical data for a PolicyRule (either for the rule in a repository or for when it is executing in a policy system).
Some examples of statistical data for a rule are the number of times it was downloaded, the number of times its conditions were evaluated, and the number of times its actions were executed.
(These types of data would be described in a subclass of CIM StatisticalInformation.)
In these cases, the Statistics association inherited from ManagedElement to PolicyRule may be used to describe the tie between an instance of a PolicyRule and the set of statistics for it.
The following subsections discuss several specific issues related to the Policy Core Information Model.
Reusable versus Rule Specific Conditions and Actions Policy conditions and policy actions can be partitioned into two groups:  ones associated with a single policy rule, and ones that are reusable, in the sense that they may be associated with more than one policy rule.
Conditions and actions in the first group are termed "rule specific" conditions and actions; those in the second group are characterized as "reusable".
It is important to understand that the difference between a rule  specific condition or action and a reusable one is based on the intent of the policy administrator for the condition or action, rather than on the current associations in which the condition or action participates.
Thus a reusable condition or action (that is, one that a policy administrator has created to be reusable) may at some point in time be associated with exactly one policy rule, without thereby becoming rule specific.
There is no inherent difference between a rule specific condition or action and a reusable one.
There are, however, differences in how they are treated in a policy repository.
For example, it's natural to make the access permissions for a rule specific condition or action identical to those for the rule itself.
It's also natural for a rule specific condition or action to be removed from the policy repository at the same time the rule is.
With reusable conditions and actions, on the other hand, access permissions and existence criteria must be expressible without reference to a policy rule.
The preceding paragraph does not contain an exhaustive list of the ways in which reusable and rule specific conditions should be treated differently.
Its purpose is merely to justify making a semantic distinction between rule specific and reusable, and then reflecting this distinction in the policy model itself.
An issue is highlighted by reusable and rule specific policy conditions and policy actions:  the lack of a programmatic capability for expressing complex constraints involving multiple associations.
Taking PolicyCondition as an example, there are two aggregations to look at.
PolicyConditionInPolicyRule has the cardinality   at both ends, and PolicyConditionInPolicyRepository has the cardinality   at the PolicyCondition end, and [0..1] at the PolicyRepository end.
Globally, these cardinalities are correct.
However, there's more to the story, which only becomes clear if we examine the cardinalities separately for the two cases of a rule specific PolicyCondition and a reusable one.
For a rule specific PolicyCondition, the cardinality of PolicyConditionInPolicyRule at the PolicyRule end is [1..1], rather than [0
(recall that   is an abbreviation for [0..n]), since the condition is unique to one policy rule.
And the cardinality of PolicyConditionInPolicyRepository at the PolicyRepository end is [0..0], since the condition is not in the "re usable" repository.
This is OK, since these are both subsets of the specified cardinalities.
For a reusable PolicyCondition, however, the cardinality of PolicyConditionInPolicyRepository at the PolicyRepository end is [1..1], since the condition must be in the repository.
And, the cardinality of PolicyConditionInPolicyRule at the PolicyRule end is [0..n].
This last point is important:
a reusable PolicyCondition may be associated with 0, 1, or more than 1 PolicyRules, via exactly the same association PolicyConditionInPolicyRule that binds a rule  specific condition to its PolicyRule.
Currently the only way to document constraints of this type is textually.
More formal methods for documenting complex constraints are needed.
The concept of role is central to the design of the entire Policy Framework.
The idea behind roles is a simple one.
Rather than configuring, and then later having to update the configuration of, hundreds or thousands (or more) of resources in a network, a policy administrator assigns each resource to one or more roles, and then specifies the policies for each of these roles.
The Policy Framework is then responsible for configuring each of the resources associated with a role in such a way that it behaves according to the policies specified for that role.
When network behavior must be changed, the policy administrator can perform a single update to the policy for a role, and the Policy Framework will ensure that the necessary configuration updates are performed on all the resources playing that role.
A more formal definition of a role is as follows:
A role is a type of attribute that is used to select one or more policies for a set of entities and/or components from among a much larger set of available policies.
Roles can be combined together.
Here is a formal definition of a "role  combination": A role combination is a set of attributes that are used to select one or more policies for a set of entities and/or components from among a much larger set of available policies.
As the examples below illustrate, the selection process for a role combination chooses policies associated with the combination itself, policies associated with each of its sub combinations, and policies associated with each of the individual roles in the role  combination.
It is important to note that a role is more than an attribute.
A role defines a particular function of an entity or component that can be used to identify particular behavior associated with that entity or component.
This difference is critical, and is most easily understood by thinking of a role as a selector.
When used in this manner, one role (or role combination) selects a different set of policies than a different role (or role combination) does.
Roles and role combinations are especially useful in selecting which policies are applicable to a particular set of entities or components when the policy repository can store thousands or hundreds of thousands of policies.
This use emphasizes the ability of the role (or role  combination) to select the small subset of policies that are applicable from a huge set of policies that are available.
An example will illustrate how role combinations actually work.
Suppose an installation has three roles defined for interfaces: "Ethernet", "Campus", and "WAN".
In the Policy Repository, some policy rules could be associated with the role "Ethernet"; these rules would apply to all Ethernet interfaces, regardless of whether they were on the campus side or the WAN side.
Other rules could be associated with the role combination "Campus" "Ethernet"; these rules would apply to the campus side Ethernet interfaces, but not to those on the WAN side.
Finally, a third set of rules could be associated with the role combination "Ethernet" "WAN"; these rules would apply to the WAN side Ethernet interfaces, but not to those on the campus side.
(The roles in a role combination appear in alphabetical order in these examples, because that is how they appear in the information model.)
If we have a specific interface
that's associated with the role  combination "Ethernet" "WAN", we see that it should have
three categories of policy rules applied to it:  those for the "Ethernet" role, those for the "WAN" role, and those for the role combination "Ethernet" "WAN".
Going one step further, if interface B is associated with the role  combination "branch  office" "Ethernet" "WAN", then B should have seven categories of policy rules applied to it those associated with the following role combinations: "branch office" "Ethernet" "WAN" "branch office" "Ethernet" "branch office" "WAN" "Ethernet" "WAN" "branch office" "Ethernet" "WAN".
In order to get all of the right policy rules for a resource like interface B, a PDP must expand the single role combination it receives for B into this list of seven role combinations, and then retrieve from the Policy Repository the corresponding seven sets of policy rules.
Of course this example is unusually complicated:
the normal case will involve expanding a two role combination into three values identifying three sets of policy rules.
Role combinations also help to simplify somewhat the problem of identifying conflicts between policy rules.
With role combinations, it is possible for a policy administrator to specify one set of policy rules for campus side Ethernet interfaces, and a second set of policy rules for WAN side Ethernet interfaces, without having to worry about conflicts between the two sets of rules.
The policy administrator simply "turns off" conflict detection for these two sets of rules, by telling the policy management system that the roles "Campus" and "WAN" are incompatible with each other.
This indicates that the role combination will never occur, and therefore conflicts will never occur.
In some cases the technology itself might identify incompatible roles:  "Ethernet" and "FrameRelay", for example.
But for less precise terms like "Campus" and "WAN", the policy administrator must say whether they identify incompatible roles.
When the policy administrator does this, there are three effects: 1.
If an interface has assigned to it a role combination involving both "Campus" and "WAN", then the policy management system can flag it as an error.
If a policy rule is associated with a role combination involving both "Campus" and "WAN", then the policy management system can flag it as an error.
If the policy management system sees two policy rules, where one is tied to the role "Campus" (or to a role combination that includes the role "Campus") and the other is tied to the role "WAN" (or to a role  combination that includes the role "WAN"), then the system does not need to look for conflicts between the two policy rules:  because of the incompatible roles, the two rules cannot possibly conflict.
Retrieval and Application of a Policy Figure 4, which is introduced only as an example of how the Policy Framework might be implemented by a collection of network components, illustrates how roles operate within the Policy Framework.
Because the distinction between them is not important to this discussion, the PDP and the PEP are combined in one box.
The points illustrated here apply equally well, though, to an environment where the PDP and the PEP are implemented separately.
A role represents a functional characteristic or capability of a resource to which policies are applied.
Examples of roles include Backbone interface, Frame Relay interface, BGP capable router, web server, firewall, etc.
The multiple roles assigned to a single resource are combined to form that resource's role combination.
Role combinations are represented in the PCIM by values of the PolicyRoles property in the PolicyRule class.
A PDP uses policy roles as follows to identify the policies it needs to be aware of: 1.
The PDP learns in some way the list of roles that its PEPs play.
This information might be configured at the PDP, the PEPs might supply it to the PDP, or the PDP might retrieve it from a repository.
Using repository specific means, the PDP determines where to look for policy rules that might apply to it.
Using the roles and role combinations it received from its PEPs as indicated in the examples above, the PDP is able to locate and retrieve the policy rules that are relevant to it.
As indicated earlier, PolicyRoles is a property associated with a policy rule.
It is an array holding "role combinations" for the policy rule, and correlates with the roles defined for a network resource.
Using the PolicyRoles property, it is possible to mark a policy rule as applying, for example, to a Frame Relay interface or to a backbone ATM interface.
Each value of this property represents a role combination, including the special case of a "combination" containing only one role.
As the format indicates, the role names in a role combination are ANDed together to form a single selector.
The multiple values of the PolicyRoles property are logically ORed, to make it possible for a policy rule to have multiple selectors.
The individual role names in a role combination must appear in alphabetical order (according to the collating sequence for UCS 2 characters), to make the string matches work correctly.
The role names used in an environment are specified by the policy administrator.
Local Time and UTC Time in PolicyTimePeriodConditions
An instance of PolicyTimePeriodCondition has up to five properties that represent times:  TimePeriod, MonthOfYearMask, DayOfMonthMask, DayOfWeekMask, and TimeOfDayMask.
All of the time related properties in an instance of PolicyTimePeriodCondition represent one of two types of times:  local time at the place where a policy rule is applied, or UTC time.
The property LocalOrUtcTime indicates which time representation applies to an instance of PolicyTimePeriodCondition.
Since the PCIM provides only for local time and UTC time, a Policy Management Tool that provides for other time representations (for example, a fixed time at a particular location) will need to map from these other representations to either local time or UTC time.
An example will illustrate the nature of this mapping.
Suppose a policy rule is tied to the hours of operation for a Help Desk:  0800 to 2000 Monday through Friday [US] Eastern Time.
In order to express these times in PolicyTimePeriodCondition, a management tool must convert them to UTC times.
(They are not local times, because they refer to a single time interval worldwide, not to intervals tied to the local clocks at the locations where the PolicyRule is being applied.)
As reference [10] points out, mapping from [US]
Eastern Time to UTC time is not simply a matter of applying an offset:  the offset between [US] Eastern Time and UTC time switches between  0500 and  0400 depending on whether Daylight Savings Time is in effect in the US.
Suppose the policy administrator's goal is to have a policy rule be valid from 0800 until 1200 [US] Eastern Time on every Monday, within the overall time period from the beginning of 2000 until the end of 2001.
The Policy Management Tool could either be configured with the definition of what [US] Eastern Time means, or it could be configured with knowledge of where to go to get this information.
Reference [10] contains further discussion of time zone definitions and where they might reside.
Armed with knowledge about [US] Eastern Time, the Policy Management Tool would create however many instances of PolicyTimePeriodCondition it needed to represent the desired intervals.
Note that while there is an increased number of PolicyTimePeriodCondition instances, there is still just one PolicyRule, which is tied to all the PolicyTimePeriodCondition instances via the aggregation PolicyRuleValidityPeriod.
Here are the first two of these instances: 1.
There would be three more similar instances, for winter 2000 2001, summer 2001, and winter 2001 up through December 31.
Had the example been chosen differently, there could have been even more instances of PolicyTimePeriodCondition.
If, for example, the time interval had been from 0800 2200
[US] Eastern Time on Mondays, instance 1 above would have split into two instances:  one with a UTC time interval of T130000/T240000 on Mondays, and another with a UTC time interval of T000000/T030000 on Tuesdays.
So the end result would have been ten instances of PolicyTimePeriodCondition, not five.
By restricting PolicyTimePeriodCondition to local time and UTC time, the PCIM places the difficult and expensive task of mapping from "human" time representations to machine friendly ones in the Policy Management Tool.
Another approach would have been to place in PolicyTimePeriodCondition a means of representing a named time zone, such as [US] Eastern Time.
This, however, would have passed the difficult mapping responsibility down to the PDPs and PEPs.
It is better to have a mapping such as the one described above done once in a Policy Management Tool, rather than having it done over and over in each of the PDPs (and possibly PEPs) that need to apply a PolicyRule.
Since PCIM extends the CIM Schema, a correspondence between data types used in both CIM and PCIM is needed.
The following CIM data types are used in the class definitions that follow in Sections 6 and 7:
Strings in CIM are stored as UCS 2 characters, where each character is encoded in two octets.
Thus string values may need to be converted when moving between a CIM environment and one that uses a different string encoding.
For example, in an LDAP accessible directory, attributes of type DirectoryString are stored in UTF 8 format.
RFC 2279 [7] explains how to convert between these two formats.
When it is applied to a CIM string, a MaxLen value refers to the maximum number of characters in the string, rather than to the maximum number of octets.
There is one obvious omission from this list of CIM data types: octet strings.
This is because CIM treats octet strings as a derived data type.
There are two forms of octet strings in CIM an ordered uint8 array for single valued strings, and a string array for multi  valued properties.
Both are described by adding an "OctetString" qualifier (meta data) to the property.
This qualifier functions exactly like an SMIv2 (SNMP) Textual Convention, refining the syntax and semantics of the existing CIM data type.
The first four numeric elements of both of the "OctetString" representations are a length field.
(The reason that the "numeric" adjective is added to the previous sentence is that the string property also includes '0' and 'x', as its first characters.)
In both cases, these 4 numeric elements (octets) are included in calculating the length.
For example, a single valued octet string property having the value
X'7C' would be represented by the uint8 array, X'00 00 00 05 7C'.
The strings representing the individual values of a multi valued property qualified with the "OctetString" qualifier are constructed similarly: 1.
Take a value to be encoded as an octet string (we'll use X'7C' as above), and prepend to it a four octet length.
The result is the same, X'00 00 00 05 7C'.
Convert this to a character string by introducing '0' and
'x' at the front, and removing all white space.
Thus we have the 12  character string "0x000000057C".
This string is the value of one of the array elements in the CIM string array.
Since CIM uses the UCS 2 character set, it will require 24 octets to encode this 12  character string.
Mappings of the PCIM to particular data models are not required to follow this CIM technique of representing multi valued octet strings as length  prefixed character strings.
In an LDAP mapping, for example, it would be much more natural to simply use the Octet String syntax, and omit the prepended length octets.
Comparison between CIM and LDAP Class Specifications
There are a number of differences between CIM and LDAP class specifications.
The ones that are relevant to the abbreviated class specifications in this document are listed below.
These items are included here to help introduce the IETF community, which is already familiar with LDAP, to CIM modeling, and by extension, to information modeling in general.
Instead of LDAP's three class types (abstract, auxiliary, structural), CIM has only two:  abstract and instantiable.
The type of a CIM class is indicated by the Boolean qualifier ABSTRACT.
CIM uses the term "property" for what LDAP terms an "attribute".
" to indicate that a property is multi valued.
CIM defines three types of arrays: bags (contents are unordered, duplicates allowed), ordered bags (contents are ordered but duplicates are allowed) and indexed arrays (contents are ordered and no duplicates are allowed).
CIM classes and properties are identified by name, not by OID.
CIM classes use a different naming scheme for native implementations, than LDAP.
The CIM naming scheme is documented in Appendix A since it is not critical to understanding the information model, and only applies when communicating with a native CIM implementation.
In LDAP, attribute definitions are global, and the same attribute may appear in multiple classes.
In CIM, a property is defined within the scope of a single class definition.
The property may be inherited into subclasses of the class in which it is defined, but otherwise it cannot appear in other classes.
One side effect of this difference is that CIM property names tend to be much shorter than LDAP attribute names, since they are implicitly scoped by the name of the class in which they are defined.
There is also a notational convention that this document follows, to improve readability.
In CIM, all class and property names are prefixed with the characters "CIM ".
These prefixes have been omitted throughout this document, with one exception regarding naming, documented in Appendix A.
For the complete definition of the CIM specification language, see reference [2].
The following sections contain the definitions of the PCIM classes.
The Abstract Class "Policy" The abstract class Policy collects several properties that may be included in instances of any of the Core Policy classes (or their subclasses).
For convenience, the two properties that Policy inherits from ManagedElement in the CIM schema are shown here as well.
The class definition is as follows:
The Property "CommonName (CN)" The CN, or CommonName, property corresponds to the X.500 attribute commonName (cn).
In X.500 this property specifies one or more user  friendly names (typically only one name) by which an object is commonly known, names that conform to the naming conventions of the country or culture with which the object is associated.
In the CIM model, however, the CommonName property is single valued.
A user friendly name of a policy related object.
The Multi valued Property "PolicyKeywords"
This property provides a set of one or more keywords that a policy administrator may use to assist in characterizing or categorizing a policy object.
Keywords are of one of two types:  Keywords defined in this document, or in documents that define subclasses of the classes defined in this document.
These keywords provide a vendor independent, installation independent way of characterizing policy objects.
Installation dependent keywords for characterizing policy objects.
Examples include "Engineering", "Billing", and "Review in December 2000".
This document defines the following keywords:  "UNKNOWN", "CONFIGURATION", "USAGE", "SECURITY", "SERVICE", "MOTIVATIONAL", "INSTALLATION", and "EVENT".
These concepts were defined earlier in Section 2.
One additional keyword is defined:  "POLICY".
The role of this keyword is to identify policy related instances that would not otherwise be identifiable as being related to policy.
It may be needed in some repository implementations.
Documents that define subclasses of the Policy Core Information Model classes SHOULD define additional keywords to characterize instances of these subclasses.
By convention, keywords defined in conjunction with class definitions are in uppercase.
Installation defined keywords can be in any case.
The property definition is as follows:
A set of keywords for characterizing /categorizing policy objects.
The Property "Caption" (Inherited from ManagedElement)
This property provides a one line description of a policy related object.
A one line description of this policy related object.
The Property "Description" (Inherited from ManagedElement)
This property provides a longer description than that provided by the caption property.
A long description of this policy related object.
This class is a generalized aggregation container.
It enables either PolicyRules or PolicyGroups to be aggregated in a single container.
Loops, including the degenerate case of a PolicyGroup that contains itself, are not allowed when PolicyGroups contain other PolicyGroups.
PolicyGroups and their nesting capabilities are shown in Figure 5 below.
Note that a PolicyGroup can nest other PolicyGroups, and there is no restriction on the depth of the nesting in sibling PolicyGroups.
Overview of the PolicyGroup class
As a simple example, think of the highest level PolicyGroup shown in Figure 5 above as a logon policy for US employees of a company.
This PolicyGroup may be called USEmployeeLogonPolicy, and may aggregate several PolicyGroups that provide specialized rules per location.
Hence, PolicyGroup A in Figure 5 above may define logon rules for employees on the West Coast, while another PolicyGroup might define logon rules for the Midwest (e.g., PolicyGroup X), and so forth.
Note also that the depth of each PolicyGroup does not need to be the same.
Thus, the WestCoast PolicyGroup might have several additional layers of PolicyGroups defined for any of several reasons (different locales, number of subnets, etc..).
The PolicyRules are therefore contained at n levels from the USEmployeeLogonPolicyGroup.
Compare this to the Midwest PolicyGroup (PolicyGroup X), which might directly contain PolicyRules.
The class definition for PolicyGroup is as follows:
A container for either a set of related PolicyRules or a set of related PolicyGroups.
No properties are defined for this class since it inherits all its properties from Policy.
The class exists to aggregate PolicyRules or other PolicyGroups.
In an implementation, various key/identification properties MUST be defined.
The keys for a native CIM implementation are defined in Appendix A, Section 13.1.1.
Keys for an LDAP implementation will be defined in the LDAP mapping of this information model [11].
The Class "PolicyRule" This class represents the "If Condition then Action" semantics associated with a policy.
A PolicyRule condition, in the most general sense, is represented as either an ORed set of ANDed conditions (Disjunctive Normal Form, or DNF) or an ANDed set of ORed conditions (Conjunctive Normal Form, or CNF).
Individual conditions may either be negated (NOT C) or unnegated (C).
The actions specified by a PolicyRule are to be performed if and only if the PolicyRule condition (whether it is represented in DNF or CNF) evaluates to TRUE.
The conditions and actions associated with a policy rule are modeled, respectively, with subclasses of the classes PolicyCondition and PolicyAction.
These condition and action objects are tied to instances of PolicyRule by the PolicyConditionInPolicyRule and PolicyActionInPolicyRule aggregations.
As illustrated above in Section 3, a policy rule may also be associated with one or more policy time periods, indicating the schedule according to which the policy rule is active and inactive.
In this case it is the PolicyRuleValidityPeriod aggregation that provides the linkage.
A policy rule is illustrated conceptually in Figure 6.
Overview of the PolicyRule Class
The PolicyRule class uses the property ConditionListType, to indicate whether the conditions for the rule are in DNF or CNF.
The PolicyConditionInPolicyRule aggregation contains two additional properties to complete the representation of the rule's conditional expression.
The first of these properties is an integer to partition the referenced conditions into one or more groups, and the second is a Boolean to indicate whether a referenced condition is negated.
An example shows how ConditionListType and these two additional properties provide a unique representation of a set of conditions in either DNF or CNF.
Suppose we have a PolicyRule that aggregates five PolicyConditions C1 through C5, with the following values in the properties of the five PolicyConditionInPolicyRule associations:
C1:  GroupNumber   1, ConditionNegated   FALSE C2:  GroupNumber   1, ConditionNegated
GroupNumber   2, ConditionNegated   FALSE C5:  GroupNumber   2, ConditionNegated   FALSE
If ConditionListType   DNF, then the overall condition for the PolicyRule is:
(C1 AND (NOT C2) AND C3)
On the other hand, if ConditionListType   CNF, then the overall condition for the PolicyRule is: (C1 OR (NOT C2) OR C3) AND (C4 OR C5)
In both cases, there is an unambiguous specification of the overall condition that is tested to determine whether to perform the actions associated with the PolicyRule.
The class definition is as follows:
The central class for representing the "If Condition then Action" semantics associated with a policy rule.
Enabled ConditionListType RuleUsage Priority Mandatory SequencedActions
The PolicyRule class is directly instantiable.
In an implementation, various key/identification properties MUST be defined.
The keys for a native CIM implementation are defined in Appendix A, Section 13.1.2.
Keys for an LDAP implementation will be defined in the LDAP mapping of this information model [11].
This property indicates whether a policy rule is currently enabled, from an administrative point of view.
Its purpose is to allow a policy administrator to enable or disable a policy rule without having to add it to, or remove it from, the policy repository.
The property also supports the value 'enabledForDebug'.
When the property has this value,
the entity evaluating the policy condition(s) is being told to evaluate the conditions for the policy rule, but not to perform the actions if the conditions evaluate to TRUE.
This value serves as a debug vehicle when attempting to determine what policies would execute in a particular scenario, without taking any actions to change state during the debugging.
The property definition is as follows:
An enumeration indicating whether a policy rule is administratively enabled, administratively disabled, or enabled for debug mode.
The Property "ConditionListType" This property is used to specify whether the list of policy conditions associated with this policy rule is in disjunctive normal form (DNF) or conjunctive normal form (CNF).
If this property is not present, the list type defaults to DNF.
The property definition is as follows:
This property is a free form string that recommends how this policy should be used.
The property definition is as follows:
This property is used to provide guidelines on how this policy should be used.
The Property "Priority" This property provides a non negative integer for prioritizing policy rules relative to each other.
Larger integer values indicate higher priority.
Since one purpose of this property is to allow specific, ad hoc policy rules to temporarily override established policy rules, an instance that has this property set has a higher priority than all instances that use or set the default value of zero.
Prioritization among policy rules provides a basic mechanism for resolving policy conflicts.
The property definition is as follows:
A non negative integer for prioritizing this PolicyRule relative to other PolicyRules.
A larger value indicates a higher priority.
The Property "Mandatory" This property indicates whether evaluation (and possibly action execution) of a PolicyRule is mandatory or not.
Its concept is similar to the ability to mark packets for delivery or possible discard, based on network traffic and device load.
The evaluation of a PolicyRule MUST be attempted if the Mandatory property value is TRUE.
If the Mandatory property value of a PolicyRule is FALSE, then the evaluation of the rule is "best effort" and MAY be ignored.
The property definition is as follows:
A flag indicating that the evaluation of the PolicyConditions and execution of PolicyActions (if the condition list evaluates to TRUE) is required.
This property gives a policy administrator a way of specifying how the ordering of the policy actions associated with this PolicyRule is to be interpreted.
Three values are supported:  mandatory(1):
Do the actions in the indicated order, or don't do them at all.
: Do the actions in the indicated order if you can, but if you can't do them in this order, do them in another order if you can.
I don't care about the order.
When error / event reporting is addressed for the Policy Framework, suitable codes will be defined for reporting that a set of actions could not be performed in an order specified as mandatory (and thus were not performed at all), that a set of actions could not be performed in a recommended order (and moreover could not be performed in any order), or that a set of actions could not be performed in a recommended order (but were performed in a different order).
The property definition is as follows:
An enumeration indicating how to interpret the action ordering indicated via the PolicyActionInPolicyRule aggregation.
The Multi valued Property "PolicyRoles"
This property represents the roles and role combinations associated with a policy rule.
Each value represents one role combination.
Since this is a multi valued property, more than one role combination can be associated with a single policy rule.
The property definition is as follows:
A set of strings representing the roles and role combinations associated with a policy rule.
Each value represents one role combination.
The Abstract Class "PolicyCondition" The purpose of a policy condition is to determine whether or not the set of actions (aggregated in the PolicyRule that the condition applies to) should be executed or not.
For the purposes of the Policy  Core Information Model, all that matters about an individual PolicyCondition is that it evaluates to TRUE or FALSE.
(The individual PolicyConditions associated with a PolicyRule are combined to form a compound expression in either DNF or CNF, but this is accomplished via the ConditionListType property, discussed above, and by the properties of the PolicyConditionInPolicyRule aggregation, introduced above and discussed further in Section 7.6 below.)
A logical structure within an individual PolicyCondition may also be introduced, but this would have to be done in a subclass of PolicyCondition.
Because it is general, the PolicyCondition class does not itself contain any "real" conditions.
These will be represented by properties of the domain specific subclasses of PolicyCondition.
Overview of Policy Conditions in DNF
This figure illustrates that when policy conditions are in DNF, there are one or more sets of conditions that are ANDed together to form AND lists.
An AND list evaluates to TRUE if and only if all of its constituent conditions evaluate to TRUE.
The overall condition then evaluates to TRUE if and only if at least one of its constituent AND lists evaluates to TRUE.
Overview of Policy Conditions in CNF
In this figure, the policy conditions are in CNF.
Consequently, there are one or more OR lists, each of which evaluates to TRUE if and only if at least one of its constituent conditions evaluates to TRUE.
The overall condition then evaluates to TRUE if and only if ALL of its constituent OR lists evaluate to TRUE.
The class definition of PolicyCondition is as follows:
A class representing a rule specific or reusable policy condition to be evaluated in conjunction with a policy rule.
No properties are defined for this class since it inherits all its properties from Policy.
The class exists as an abstract superclass for domain specific policy conditions, defined in subclasses.
In an implementation, various key/identification properties MUST be defined for the class or its instantiable subclasses.
The keys for a native CIM implementation are defined in Appendix A, Section 13.2.
Keys for an LDAP implementation will be defined in the LDAP mapping of this information model [11].
When identifying and using the PolicyCondition class, it is necessary to remember that a condition can be rule specific or reusable.
This was discussed above in Section 5.1.
The distinction between the two types of policy conditions lies in the associations in which an instance can participate, and in how the different instances are named.
Conceptually, a reusable policy condition resides in a policy repository, and is named within the scope of that repository.
On the other hand, a rule specific policy condition is, as the name suggests, named within the scope of the single policy rule to which it is related.
The distinction between rule specific and reusable PolicyConditions affects the CIM naming, defined in Appendix A, and the LDAP mapping [11].
The Class "PolicyTimePeriodCondition" This class provides a means of representing the time periods during which a policy rule is valid, i.e., active.
At all times that fall outside these time periods, the policy rule has no effect.
A policy rule is treated as valid at all times if it does not specify a PolicyTimePeriodCondition.
In some cases a PDP may need to perform certain setup / cleanup actions when a policy rule becomes active / inactive.
For example, sessions that were established while a policy rule was active might need to be taken down when the rule becomes inactive.
In other cases, however, such sessions might be left up:  in this case, the effect of deactivating the policy rule would just be to prevent the establishment of new sessions.
Setup / cleanup behaviors on validity period transitions are not currently addressed by the PCIM, and must be specified in 'guideline' documents, or via subclasses of PolicyRule, PolicyTimePeriodCondition or other concrete subclasses of Policy.
If such behaviors need to be under the control of the policy administrator, then a mechanism to allow this control must also be specified in the subclass.
PolicyTimePeriodCondition is defined as a subclass of PolicyCondition.
This is to allow the inclusion of time based criteria in the AND/OR condition definitions for a PolicyRule.
Instances of this class may have up to five properties identifying time periods at different levels.
The values of all the properties present in an instance are ANDed together to determine the validity period(s) for the instance.
For example, an instance with an overall validity range of January 1, 2000 through December 31, 2000; a month mask that selects March and April; a day of the week mask that selects Fridays; and a time of day range of 0800 through 1600 would represent the following time periods: Friday, March  5, 2000, from 0800 through 1600; Friday, March 12, 2000, from 0800 through 1600; Friday, March 19, 2000, from 0800 through 1600; Friday, March 26, 2000, from 0800 through 1600; Friday, April  2, 2000, from 0800 through 1600; Friday, April  9, 2000, from 0800 through 1600; Friday, April 16, 2000, from 0800 through 1600; Friday, April 23, 2000, from 0800 through 1600; Friday, April 30, 2000, from 0800 through 1600.
Properties not present in an instance of PolicyTimePeriodCondition are implicitly treated as having their value "always enabled".
Thus, in the example above, the day of the month mask is not present, and so the validity period for the instance implicitly includes a day  of the month mask that selects all days of the month.
If we apply this "missing property" rule to its fullest, we see that there is a second way to indicate that a policy rule is always enabled: have it point to an instance of PolicyTimePeriodCondition whose only properties are its naming properties.
The property LocalOrUtcTime indicates whether the times represented in the other five time related properties of an instance of PolicyTimePeriodCondition are to be interpreted as local times for the location where a policy rule is being applied, or as UTC times.
The class definition is as follows.
A class that provides the capability of enabling / disabling a policy rule according to a pre determined schedule.
The Property "TimePeriod" This property identifies an overall range of calendar dates and times over which a policy rule is valid.
It reuses the format for an explicit time period defined in RFC 2445
The first date indicates the beginning of the range, while the second date indicates the end.
Thus, the second date and time must be later than the first.
Date/times are expressed as substrings of the form "yyyymmddThhmmss".
For example: 20000101T080000/20000131T120000 January 1, 2000, 0800 through January 31, 2000, noon There are also two special cases in which one of the date/time strings is replaced with a special string defined in RFC 2445.
Note that RFC 2445 does not use these two strings in connection with explicit time periods.
Thus the PCIM is combining two elements from RFC 2445 that are not combined in the RFC itself.
The property definition is as follows:
The range of calendar dates on which a policy rule is valid.
the second date/time may be replaced with the string "THISANDFUTURE" 6.5.2.
The Property "MonthOfYearMask" The purpose of this property is to refine the definition of the valid time period that is defined by the TimePeriod property, by explicitly specifying the months when the policy is valid.
These properties work together, with the TimePeriod used to specify the overall time period during which the policy might be valid, and the MonthOfYearMask used to pick out the specific months within that time period when the policy is valid.
This property is formatted as an octet string of size 2, consisting of 12 bits identifying the 12 months of the year, beginning with January and ending with December, followed by 4 bits that are always set to '0'.
For each month, the value '1' indicates that the policy is valid for that month, and the value '0' indicates that it is not valid.
The value X'08 30', for example, indicates that a policy rule is valid only in the months May, November, and December.
See section 5.4 for details of how CIM represents a single valued octet string property such as this one.
(Basically, CIM prepends a 4 octet length to the octet string.)
If this property is omitted, then the policy rule is treated as valid for all twelve months.
The property definition is as follows:
A mask identifying the months of the year in which a policy rule is valid.
The Property "DayOfMonthMask" The purpose of this property is to refine the definition of the valid time period that is defined by the TimePeriod property, by explicitly specifying the days of the month when the policy is valid.
These properties work together, with the TimePeriod used to specify the overall time period during which the policy might be valid, and the DayOfMonthMask used to pick out the specific days of the month within that time period when the policy is valid.
This property is formatted as an octet string of size 8, consisting of 31 bits identifying the days of the month counting from the beginning, followed by 31 more bits identifying the days of the month counting from the end, followed by 2 bits that are always set to '0'.
For each day, the value '1' indicates that the policy is valid for that day, and the value '0' indicates that it is not valid.
The value X'80 00 00 01 00 00 00 00', for example, indicates that a policy rule is valid on the first and last days of the month.
For months with fewer than 31 days, the digits corresponding to days that the months do not have (counting in both directions) are ignored.
The encoding of the 62 significant bits in the octet string matches that used for the schedDay object in the DISMAN SCHEDULE MIB.
See reference [8] for more details on this object.
See section 5.4 for details of how CIM represents a single valued octet string property such as this one.
(Basically, CIM prepends a 4 octet length to the octet string.)
The property definition is as follows:
A mask identifying the days of the month on which a policy rule is valid.
The Property "DayOfWeekMask" The purpose of this property is to refine the definition of the valid time period that is defined by the TimePeriod property by explicitly specifying the days of the week when the policy is valid.
These properties work together, with the TimePeriod used to specify the overall time period when the policy might be valid, and the DayOfWeekMask used to pick out the specific days of the week in that time period when the policy is valid.
This property is formatted as an octet string of size 1, consisting of 7 bits identifying the 7 days of the week, beginning with Sunday and ending with Saturday, followed by 1 bit that is always set to '0'.
For each day of the week, the value '1' indicates that the policy is valid for that day, and the value '0' indicates that it is not valid.
The value X'7C', for example, indicates that a policy rule is valid Monday through Friday.
See section 5.4 for details of how CIM represents a single valued octet string property such as this one.
(Basically, CIM prepends a 4 octet length to the octet string.)
The property definition is as follows:
A mask identifying the days of the week on which a policy rule is valid.
The Property "TimeOfDayMask" The purpose of this property is to refine the definition of the valid time period that is defined by the TimePeriod property by explicitly specifying a range of times in a day the policy is valid for.
These properties work together, with the TimePeriod used to specify the overall time period that the policy is valid for, and the TimeOfDayMask used to pick out which range of time periods in a given day of that time period the policy is valid for.
The first time indicates the beginning of the range, while the second time indicates the end.
Times are expressed as substrings of the form "Thhmmss".
The second substring always identifies a later time than the first substring.
To allow for ranges that span midnight, however, the value of the second string may be smaller than the value of the first substring.
Thus, "T080000/T210000" identifies the range from 0800 until 2100, while "T210000/T080000" identifies the range from 2100 until 0800 of the following day.
When a range spans midnight, it by definition includes parts of two successive days.
When one of these days is also selected by either the MonthOfYearMask, DayOfMonthMask, and/or DayOfWeekMask, but the other day is not, then the policy is active only during the portion of the range that falls on the selected day.
For example, if the range extends from 2100 until 0800, and the day of week mask selects Monday and Tuesday, then the policy is active during the following three intervals:
From midnight Sunday until 0800 Monday; From 2100 Monday until 0800 Tuesday; From 2100 Tuesday until 23:59:59 Tuesday.
The property definition is as follows:
The range of times at which a policy rule is valid.
If the second time is earlier than the first, then the interval spans midnight.
This property indicates whether the times represented in the TimePeriod property and in the various Mask properties represent local times or UTC times.
There is no provision for mixing of local times and UTC times:  the value of this property applies to all of the other time related properties.
The property definition is as follows:
An indication of whether the other times in this instance represent local times or UTC times.
The Class "VendorPolicyCondition" The purpose of this class is to provide a general extension mechanism for representing policy conditions that have not been modeled with specific properties.
Instead, the two properties Constraint and ConstraintEncoding are used to define the content and format of the condition, as explained below.
As its name suggests, this class is intended for vendor specific extensions to the Policy Core Information Model.
Standardized extensions are not expected to use this class.
The class definition is as follows:
A class that defines a registered means to describe a policy condition.
The Multi valued Property "Constraint"
This property provides a general extension mechanism for representing policy conditions that have not been modeled with specific properties.
The format of the octet strings in the array is left unspecified in this definition.
It is determined by the OID value stored in the property ConstraintEncoding.
Since ConstraintEncoding is single valued, all the values of Constraint share the same format and semantics.
See Section 5.4 for a description of how CIM encodes an array of octet strings like this one.
A policy decision point can readily determine whether it supports the values stored in an instance of Constraint by checking the OID value from ConstraintEncoding against the set of OIDs it recognizes.
The action for the policy decision point to take in case it does not recognize the format of this data could itself be modeled as a policy rule, governing the behavior of the policy decision point.
The property is defined as follows:
The format of the values is identified by the OID stored in the property ConstraintEncoding.
This property identifies the encoding and semantics of the Constraint property values in this instance.
The value of this property is a single string, representing a single OID.
The property is defined as follows:
An OID encoded as a string, identifying the format and semantics for this instance's Constraint property.
The value is a dotted sequence of decimal digits (for example, "1.2.100.200") representing the arcs of the OID.
The characters in the string are the UCS 2 characters corresponding to the US ASCII encodings of the numeric characters and the period.
The Abstract Class "PolicyAction" The purpose of a policy action is to execute one or more operations that will affect network traffic and/or systems, devices, etc., in order to achieve a desired state.
This (new) state provides one or more (new) behaviors.
A policy action ordinarily changes the configuration of one or more elements.
A PolicyRule contains one or more policy actions.
A policy administrator can assign an order to the actions associated with a PolicyRule, complete with an indication of whether the indicated order is mandatory, recommended, or of no significance.
Ordering of the actions associated with a PolicyRule is accomplished via a property in the PolicyActionInPolicyRule aggregation.
The actions associated with a PolicyRule are executed if and only if the overall condition(s) of the PolicyRule evaluates to TRUE.
The class definition of PolicyAction is as follows:
A class representing a rule specific or reusable policy action to be performed if the condition for a policy rule evaluates to TRUE.
No properties are defined for this class since it inherits all its properties from Policy.
The class exists as an abstract superclass for domain specific policy actions, defined in subclasses.
In an implementation, various key/identification properties MUST be defined for the class or its instantiable subclasses.
The keys for a native CIM implementation are defined in Appendix A, Section 13.3.
Keys for an LDAP implementation will be defined in the LDAP mapping of this information model [11].
When identifying and using the PolicyAction class, it is necessary to remember that an action can be rule specific or reusable.
This was discussed above in Section 5.1.
The distinction between the two types of policy actions lies in the associations in which an instance can participate, and in how the different instances are named.
Conceptually, a reusable policy action resides in a policy repository, and is named within the scope of that repository.
On the other hand, a rule specific policy action is named within the scope of the single policy rule to which it is related.
The distinction between rule specific and reusable PolicyActions affects the CIM naming, defined in Appendix A, and the LDAP mapping [11].
The Class "VendorPolicyAction" The purpose of this class is to provide a general extension mechanism for representing policy actions that have not been modeled with specific properties.
Instead, the two properties ActionData and ActionEncoding are used to define the content and format of the action, as explained below.
As its name suggests, this class is intended for vendor specific extensions to the Policy Core Information Model.
Standardized extensions are not expected to use this class.
The class definition is as follows:
A class that defines a registered means to describe a policy action.
The Multi valued Property "ActionData"
This property provides a general extension mechanism for representing policy actions that have not been modeled with specific properties.
The format of the octet strings in the array is left unspecified in this definition.
It is determined by the OID value stored in the property ActionEncoding.
Since ActionEncoding is single valued, all the values of ActionData share the same format and semantics.
See Section 5.4 for a discussion of how CIM encodes an array of octet strings like this one.
A policy decision point can readily determine whether it supports the values stored in an instance of ActionData by checking the OID value from ActionEncoding against the set of OIDs it recognizes.
The action for the policy decision point to take in case it does not recognize the format of this data could itself be modeled as a policy rule, governing the behavior of the policy decision point.
The property is defined as follows:
The format of the values is identified by the OID stored in the property ActionEncoding.
The Property "ActionEncoding" This property identifies the encoding and semantics of the ActionData property values in this instance.
The value of this property is a single string, representing a single OID.
The property is defined as follows:
An OID encoded as a string, identifying the format and semantics for this instance's ActionData property.
The value is a dotted sequence of decimal digits (for example, "1.2.100.200") representing the arcs of the OID.
The characters in the string are the UCS 2 characters corresponding to the US ASCII encodings of the numeric characters and the period.
The Class "PolicyRepository" The class definition of PolicyRepository is as follows:
A class representing an administratively defined container for reusable policy related information.
This class does not introduce any additional properties beyond those in its superclass AdminDomain.
It does, however, participate in a number of unique associations.
The first two subsections of this section introduce associations and aggregations as they are used in CIM.
The remaining subsections present the class definitions for the associations and aggregations that are part of the Policy Core Information Model.
Associations An association is a CIM construct representing a relationship between two (or theoretically more) objects.
It is modeled as a class containing typically two object references.
Associations can be defined between classes without affecting any of the related classes.
That is, addition of an association does not affect the interface of the related classes.
An aggregation is a strong form of an association, which usually represents a "whole part" or a "collection" relationship.
For example, CIM uses an aggregation to represent the containment relationship between a system and the components that make up the system.
Aggregation as a "whole part" relationship often implies, but does not require, that the aggregated objects have mutual dependencies.
The Abstract Aggregation "PolicyComponent This abstract aggregation defines two object references that will be overridden in each of five subclasses, to become references to the concrete policy classes PolicyGroup, PolicyRule, PolicyCondition, PolicyAction, and PolicyTimePeriodCondition.
The value of the abstract superclass is to convey that all five subclasses have the same "whole  part" semantics, and for ease of query to locate all "components" of a PolicyGroup or PolicyRule.
The class definition for the aggregation is as follows:
A generic aggregation used to establish 'part of' relationships between the subclasses of Policy.
For example, the PolicyConditionInPolicyRule aggregation defines that PolicyConditions are part of a PolicyRule.
The Aggregation "PolicyGroupInPolicyGroup" The PolicyGroupInPolicyGroup aggregation enables policy groups to be nested.
This is critical for scalability and manageability, as it enables complex policies to be constructed from multiple simpler policies for administrative convenience.
For example, a policy group representing policies for the US might have nested within it policy groups for the Eastern and Western US.
A PolicyGroup may aggregate other PolicyGroups via this aggregation, or it may aggregate PolicyRules via the PolicyRuleInPolicyGroup aggregation.
Note that it is assumed that this aggregation is used to form directed acyclic graphs and NOT ring structures.
The class definition for the aggregation is as follows:
A class representing the aggregation of PolicyGroups by a higher level PolicyGroup.
This property is inherited from PolicyComponent, and overridden to become an object reference to a PolicyGroup that contains one or more other PolicyGroups.
Note that for any single instance of the aggregation class PolicyGroupInPolicyGroup, this property (like all Reference properties) is single valued.
The [0..n] cardinality indicates that there may be 0, 1, or more than one PolicyGroups that contain any given PolicyGroup.
The Reference "PartComponent" This property is inherited from PolicyComponent, and overridden to become an object reference to a PolicyGroup contained by one or more other PolicyGroups.
Note that for any single instance of the aggregation class PolicyGroupInPolicyGroup, this property (like all Reference properties) is single valued.
The [0..n] cardinality indicates that a given PolicyGroup may contain 0, 1, or more than one other PolicyGroups.
The Aggregation "PolicyRuleInPolicyGroup" A policy group may aggregate one or more policy rules, via the PolicyRuleInPolicyGroup aggregation.
Grouping of policy rules into a policy group is again for administrative convenience; a policy rule may also be used by itself, without belonging to a policy group.
A PolicyGroup may aggregate PolicyRules via this aggregation, or it may aggregate other PolicyGroups via the PolicyGroupInPolicyGroup aggregation.
The class definition for the aggregation is as follows:
A class representing the aggregation of PolicyRules by a PolicyGroup.
This property is inherited from PolicyComponent, and overridden to become an object reference to a PolicyGroup that contains one or more PolicyRules.
Note that for any single instance of the aggregation class PolicyRuleInPolicyGroup, this property (like all Reference properties) is single valued.
The [0..n] cardinality indicates that there may be 0, 1, or more than one PolicyGroups that contain any given PolicyRule.
The Reference "PartComponent" This property is inherited from PolicyComponent, and overridden to become an object reference to a PolicyRule contained by one or more PolicyGroups.
Note that for any single instance of the aggregation class PolicyRuleInPolicyGroup, this property (like all Reference properties) is single valued.
The [0..n] cardinality indicates that a given PolicyGroup may contain 0, 1, or more than one PolicyRules.
The Aggregation "PolicyConditionInPolicyRule" A policy rule aggregates
zero or more instances of the PolicyCondition class, via the PolicyConditionInPolicyRule association.
A policy rule that aggregates zero policy conditions must indicate in its class definition what "triggers" the performance of its actions.
In short, it must describe its implicit PolicyConditions, since none are explicitly associated.
For example, there might be a subclass of PolicyRule named "HttpPolicyRule", where the class definition assumes that the condition, "If HTTP traffic," is true before the rule's actions would be performed.
There is no need to formalize and instantiate this condition, since it is obvious in the semantics of the PolicyRule.
The conditions aggregated by a policy rule are grouped into two levels of lists: either an ORed set of ANDed sets of conditions (DNF, the default) or an ANDed set of ORed sets of conditions (CNF).
Individual conditions in these lists may be negated.
The property ConditionListType (in PolicyRule) specifies which of these two grouping schemes applies to a particular PolicyRule.
The conditions are used to determine whether to perform the actions associated with the PolicyRule.
One or more policy time periods may be among the conditions associated with a policy rule via the PolicyConditionInPolicyRule association.
In this case, the time periods are simply additional conditions to be evaluated along with any other conditions specified for the rule.
The class definition for the aggregation is as follows:
A class representing the aggregation of PolicyConditions by a PolicyRule.
This property is inherited from PolicyComponent, and overridden to become an object reference to a PolicyRule that contains one or more PolicyConditions.
Note that for any single instance of the aggregation class PolicyConditionInPolicyRule, this property (like all Reference properties) is single valued.
The [0..n] cardinality indicates that there may be 0, 1, or more than one PolicyRules that contain any given PolicyCondition.
The Reference "PartComponent" This property is inherited from PolicyComponent, and overridden to become an object reference to a PolicyCondition contained by one or more PolicyRules.
Note that for any single instance of the aggregation class PolicyConditionInPolicyRule, this property (like all Reference properties) is single valued.
The [0..n] cardinality indicates that a given PolicyRule may contain 0, 1, or more than one PolicyConditions.
The Property "GroupNumber" This property contains an integer identifying the group to which the condition referenced by the PartComponent property is assigned in forming the overall conditional expression for the policy rule identified by the GroupComponent reference.
The property is defined as follows:
Unsigned integer indicating the group to which the condition identified by the PartComponent property is to be assigned.
This property is a boolean, indicating whether the condition referenced by the PartComponent property is negated in forming the overall conditional expression for the policy rule identified by the GroupComponent reference.
The property is defined as follows:
(TRUE indicates that the condition is negated, FALSE indicates that it is not negated.)
The Aggregation "PolicyRuleValidityPeriod" A different relationship between a policy rule and a policy time period (than PolicyConditionInPolicyRule) is represented by the PolicyRuleValidityPeriod aggregation.
The latter describes scheduled activation and deactivation of the policy rule.
If a policy rule is associated with multiple policy time periods via this association, then the rule is active if at least one of the time periods indicates that it is active.
(In other words, the time periods are ORed to determine whether the rule is active.)
A policy time period may be aggregated by multiple policy rules.
A rule that does not point to a policy time period via this aggregation is, from the point of view of scheduling, always active.
It may, however, be inactive for other reasons.
Time periods are a general concept that can be used in other applications.
However, they are mentioned explicitly here in this specification since they are frequently used in policy applications.
The class definition for the aggregation is as follows:
A class representing the aggregation of PolicyTimePeriodConditions by a PolicyRule.
This property is inherited from PolicyComponent, and overridden to become an object reference to a PolicyRule that contains one or more PolicyTimePeriodConditions.
Note that for any single instance of the aggregation class PolicyRuleValidityPeriod, this property (like all Reference properties) is single valued.
The [0..n] cardinality indicates that there may be 0, 1, or more than one PolicyRules that contain any given PolicyTimePeriodCondition.
The Reference "PartComponent" This property is inherited from PolicyComponent, and overridden to become an object reference to a PolicyTimePeriodCondition contained by one or more PolicyRules.
Note that for any single instance of the aggregation class PolicyRuleValidityPeriod, this property (like all Reference properties) is single valued.
The [0..n] cardinality indicates that a given PolicyRule may contain 0, 1, or more than one PolicyTimePeriodConditions.
The Aggregation "PolicyActionInPolicyRule" A policy rule may aggregate zero or more policy actions.
A policy rule that aggregates zero policy actions must indicate in its class definition what actions are taken when the rule's conditions evaluate to TRUE.
In short, it must describe its implicit PolicyActions, since none are explicitly associated.
For example, there might be a subclass of PolicyRule representing a Diffserv absolute dropper, where the subclass itself indicates the action to be taken.
There is no need to formalize and instantiate this action, since it is obvious in the semantics of the PolicyRule.
The actions associated with a PolicyRule may be given a required order, a recommended order, or no order at all.
For actions represented as separate objects, the PolicyActionInPolicyRule aggregation can be used to express an order.
This aggregation does not indicate whether a specified action order is required, recommended, or of no significance; the property SequencedActions in the aggregating instance of PolicyRule provides this indication.
The class definition for the aggregation is as follows:
A class representing the aggregation of PolicyActions by a PolicyCondition.
This property is inherited from PolicyComponent, and overridden to become an object reference to a PolicyRule that contains one or more PolicyActions.
Note that for any single instance of the aggregation class PolicyActionInPolicyRule, this property (like all Reference properties) is single valued.
The [0..n] cardinality indicates that there may be 0, 1, or more than one PolicyRules that contain any given PolicyAction.
The Reference "PartComponent" This property is inherited from PolicyComponent, and overridden to become an object reference to a PolicyAction contained by one or more PolicyRules.
Note that for any single instance of the aggregation class PolicyActionInPolicyRule, this property (like all Reference properties) is single valued.
The [0..n] cardinality indicates that a given PolicyRule may contain 0, 1, or more than one  PolicyActions.
This property provides an unsigned integer 'n' that indicates the relative position of an action in the sequence of actions associated with a policy rule.
When 'n' is a positive integer, it indicates a place in the sequence of actions to be performed, with smaller integers indicating earlier positions in the sequence.
The special value '0' indicates "don't care".
If two or more actions have the same non zero sequence number, they may be performed in any order, but they must all be performed at the appropriate place in the overall action sequence.
A series of examples will make ordering of actions clearer:
If all actions have the same sequence number, regardless of whether it is '0' or non zero, any order is acceptable.
ACTION D indicate two acceptable orders:  A,C,B,D or C,A,B,D, since A and C can be performed in either order, but only at the '1' position.
ACTION D require that B,C, and D occur either as B,C,D or as B,D,
C.  Action A may appear at any point relative to B,C, and D.
Thus the complete set of acceptable orders is:  A,B,C,D;
B,A,C,D; B,C,A,D; B,C,D,A; A,B,D,C; B,A,D,C; B,D,A,C; B,D,C,A. Note
that the non zero sequence numbers need not start with '1', and they need not be consecutive.
All that matters is their relative magnitude.
The property is defined as follows:
Unsigned integer indicating the relative position of an action in the sequence of actions aggregated by a policy rule.
This abstract association inherits two object references from a higher  level CIM association class, Dependency.
It overrides these object references to make them references to instances of the classes System and Policy.
Subclasses of PolicyInSystem then override these object references again, to make them references to concrete policy classes.
The value of the abstract superclass is to convey that all subclasses have the same "dependency" semantics, and for ease of query to locate all policy "dependencies" on a System.
These dependencies are related to scoping or hosting of the Policy.
The class definition for the association is as follows:
A generic association used to establish dependency relationships between Policies and the Systems that host them.
The Weak Association "PolicyGroupInSystem" This association links a PolicyGroup to the System in whose scope the PolicyGroup is defined.
The class definition for the association is as follows:
A class representing the fact that a PolicyGroup is defined within the scope of a System.
The Reference "Antecedent" This property is inherited from PolicyInSystem, and overridden to restrict its cardinality to [1..1].
It serves as an object reference to a System that provides a scope for one or more PolicyGroups.
Since this is a weak association, the cardinality for this object reference is always 1, that is, a PolicyGroup is always defined within the scope of exactly one System.
The Reference "Dependent" This property is inherited from PolicyInSystem, and overridden to become an object reference to a PolicyGroup defined within the scope of a System.
Note that for any single instance of the association class PolicyGroupInSystem, this property (like all Reference properties) is single valued.
The [0..n] cardinality indicates that a given System may have 0, 1, or more than one PolicyGroups defined within its scope.
Regardless of whether it belongs to a PolicyGroup (or to multiple PolicyGroups), a PolicyRule is itself defined within the scope of a System.
This association links a PolicyRule to the System in whose scope the PolicyRule is defined.
The class definition for the association is as follows:
A class representing the fact that a PolicyRule is defined within the scope of a System.
The Reference "Antecedent" This property is inherited from PolicyInSystem, and overridden to restrict its cardinality to [1..1].
It serves as an object reference to a System that provides a scope for one or more PolicyRules.
Since this is a weak association, the cardinality for this object reference is always 1, that is, a PolicyRule is always defined within the scope of exactly one System.
The Reference "Dependent" This property is inherited from PolicyInSystem, and overridden to become an object reference to a PolicyRule defined within the scope of a System.
Note that for any single instance of the association class PolicyRuleInSystem, this property (like all Reference properties) is single valued.
The [0..n] cardinality indicates that a given System may have 0, 1, or more than one PolicyRules defined within its scope.
The Association "PolicyConditionInPolicyRepository" A reusable policy condition is always related to a single PolicyRepository, via the PolicyConditionInPolicyRepository association.
This is not true for all PolicyConditions, however.
An instance of PolicyCondition that represents a rule specific condition is not related to any policy repository via this association.
The class definition for the association is as follows:
A class representing the inclusion of a reusable PolicyCondition in a PolicyRepository.
The Reference "Antecedent" This property is inherited from PolicyInSystem, and overridden to become an object reference to a PolicyRepository containing one or more PolicyConditions.
A reusable PolicyCondition is always related to exactly one PolicyRepository via the PolicyConditionInPolicyRepository association.
The [0..1] cardinality for this property covers the two types of PolicyConditions:  0 for a rule specific PolicyCondition, 1 for a reusable one.
The Reference "Dependent" This property is inherited from PolicyInSystem, and overridden to become an object reference to a PolicyCondition included in a PolicyRepository.
Note that for any single instance of the association class PolicyConditionInPolicyRepository, this property (like all Reference properties) is single valued.
The [0..n] cardinality indicates that a given PolicyRepository may contain 0, 1, or more than one PolicyConditions.
The Association "PolicyActionInPolicyRepository" A reusable policy action is always related to a single PolicyRepository, via the PolicyActionInPolicyRepository association.
This is not true for all PolicyActions, however.
An instance of PolicyAction that represents a rule specific action is not related to any policy repository via this association.
The class definition for the association is as follows:
A class representing the inclusion of a reusable PolicyAction in a PolicyRepository.
The Reference "Antecedent" This property is inherited from PolicyInSystem, and overridden to become an object reference to a PolicyRepository containing one or more PolicyActions.
A reusable PolicyAction is always related to exactly one PolicyRepository via the PolicyActionInPolicyRepository association.
The [0..1] cardinality for this property covers the two types of PolicyActions:  0 for a rule specific PolicyAction, 1 for a reusable one.
The Reference "Dependent" This property is inherited from PolicyInSystem, and overridden to become an object reference to a PolicyAction included in a PolicyRepository.
Note that for any single instance of the association class PolicyActionInPolicyRepository, this property (like all Reference properties) is single valued.
The [0..n] cardinality indicates that a given PolicyRepository may contain 0, 1, or more than one PolicyActions.
The PolicyRepositoryInPolicyRepository aggregation enables policy repositories to be nested.
This derives from the higher level CIM association, CIM SystemComponent, describing that Systems contain other ManagedSystemElements.
This superclass could not be used for the other Policy aggregations, since Policies are not ManagedSystemElements, but
Note that it is assumed that this aggregation is used to form directed acyclic graphs and NOT ring structures.
The class definition for the aggregation is as follows:
A class representing the aggregation of PolicyRepositories by a higher level PolicyRepository.
This property is inherited from the CIM class SystemComponent, and overridden to become an object reference to a PolicyRepository that contains one or more other PolicyRepositories.
Note that for any single instance of the aggregation class PolicyRepositoryInPolicyRepository, this property (like all Reference properties) is single valued.
The [0..n] cardinality indicates that there may be 0, 1, or more than one PolicyRepositories that contain any given PolicyRepository.
The Reference "PartComponent" This property is inherited from the CIM class SystemComponent, and overridden to become an object reference to a PolicyRepository contained by one or more other PolicyRepositories.
Note that for any single instance of the aggregation class PolicyRepositoryInPolicyRepository, this property (like all Reference properties) is single valued.
The [0..n] cardinality indicates that a given PolicyRepository may contain 0, 1, or more than one other PolicyRepositories.
The Policy Core Information Model (PCIM) presented in this document provides an object oriented model for describing policy information.
It provides a basic framework for describing the structure of policy information, in a form independent of any specific repository or access protocol, for use by an operational system.
PCIM is not intended to represent any particular system design or implementation, nor does it define a protocol, and as such it does not have any specific security requirements.
However, it should also be noted that certain derivative documents, which use PCIM as a base, will need to convey more specific security considerations.
In order to communicate the nature of what will be expected in these follow on derivative documents, it is necessary to review the reasons that PCIM, as defined in this document, is neither implementable, nor representative of any real world system, as well as the nature of the expected follow on extensions and mappings.
There are three independent reasons that PCIM, as defined here, is neither implementable nor representative of any real world system: 1.
Its classes are independent of any specific repository that uses any specific access protocol.
Therefore, its classes are designed not to be implemented directly.
PCIM should instead be viewed as a schematic that directs how information should be represented, independent of any specific model implementation constraints.
Its classes were designed to be independent of any specific policy domain.
For example, DiffServ and IPSec represent two different policy domains.
Each document which extends PCIM to one of these domains will derive subclasses from the classes and relationships defined in PCIM, in order to represent extensions of a generic model to cover specific technical domains.
It's an information model, which must be mapped to a specific data model (native CIM schema, LDAP schema, MIB, whatever) before it can be implemented.
Derivative documents will map the extended information models noted in item 2, above, to specific types of data model implementations.
Even though specific security requirements are not appropriate for PCIM, specific security requirements MUST be defined for each operational real  world application of PCIM.
Just as there will be a wide range of operational, real world systems using PCIM, there will also be a wide range of security requirements for these systems.
Some operational, real world systems that are deployed using PCIM may have extensive security requirements that impact nearly all classes and subclasses utilized by such a system, while other systems' security requirements might have very little impact.
The derivative documents, discussed above, will create the context for applying operational, real world, system level security requirements against the various models which derive from PCIM.
For example, in some real world scenarios, the values associated with certain properties, within certain instantiated classes, may represent information associated with scarce, and/or costly (and therefore valuable) resources.
It may be the case that these values must not be disclosed to, or manipulated by, unauthorized parties.
As long as the derived model remains an information model (as opposed to a data model), it is not possible to discuss the data model  specific tools and mechanisms that are available for achieving the authentication and authorization implicit in a requirement that restricts read and/or read  write access to these values.
Therefore, these mechanisms will need to be discussed in each of the data models to which the derived information models are mapped.
If there are any general security requirements that can be identified and can be applied across multiple types of data models, it would be appropriate to discuss those at the information model level, rather than the data model level.
In any case, any identified security requirements that are not dealt with in the information model document, MUST be dealt with in the derivative data model documents.
We can illustrate these points by extending the example from Section 2.
A real world system that provides QoS Gold Service to John would likely need to provide at least the following security related capabilities and mechanisms (see [12] for definitions of security related terms):
Data integrity for the information (e.g., property values and instantiated relationships) that specify that John gets QoS Gold Service, from the point(s) that the information is entered into the system to the point(s) where network components actually provide that Service.
Authentication and Authorization methods to ensure that only system administrators (and not John or other engineers) can remotely administer components of the system.
An Authentication method to insure that John receives Gold Service, and the other members of the engineering group receive Bronze Service.
These are one possible set of requirements associated with an example real world system which delivers Gold Service, and the appropriate place to document these would be in some combination of the information model and the derivative data models for QoS Policy.
Each of the data models would also need to discuss how these requirements are satisfied, using the mechanisms typically available to such a data model, given the particular technology or set of technologies which it may employ.
Appendix A:  Class Identification in a Native CIM Implementation
While the CommonName property is present in the abstract superclass Policy, and is thus available in all of its instantiable subclasses, CIM does not use this property for naming instances.
The following subsections discuss how naming is handled in a native CIM implementation for each of the instantiable classes in the Policy Core Information Model.
Two things should be noted regarding CIM naming:  When a CIM association is specified as "weak", this is a statement about naming scopes:  an instance of the class at the weak end of the association is named within the scope of an instance of the class at the other end of the association.
This is accomplished by propagation of keys from the instance of the scoping class to the instance of the weak class.
Thus the weak class has, via key propagation, all the keys from the scoping class, and it also has one or more additional keys for distinguishing instances of the weak class, within the context of the scoping class.
All class names in CIM are limited to alphabetic and numeric characters plus the underscore, with the restriction that the first character cannot be numeric.
Refer to Appendix F "Unicode Usage" in reference
[2] for an exact specification of how CIM class names are encoded in CIM strings.
Naming Instances of PolicyGroup and PolicyRule A policy group always exists in the context of a system.
In the Policy Core Information Model, this is captured by the weak aggregation PolicyGroupInSystem between a PolicyGroup and a System.
Note that System serves as the base class for describing network devices and administrative domains.
A policy rule also exists in the context of a system.
In the Policy Core Information Model, this is captured by the weak association PolicyRuleInSystem between a PolicyRule and a System.
The following sections define the CIM keys for PolicyGroup and PolicyRule.
The CIM keys of the PolicyGroup class are:  SystemCreationClassName (A CIM System key, propagated due to the weak association, PolicyGroupInSystem)  SystemName (A CIM System key, propagated due to  the weak association, PolicyGroupInSystem)
They are defined in Reference [1] as follows:
the class name of the CIM System object providing the naming scope for the instance of PolicyGroup.
This property is set to "CIM PolicyGroup", if the PolicyGroup object is directly instantiated.
Or, it is equal to the class name of the PolicyGroup subclass that is instantiated.
The identifying name of this policy group.
The CIM keys of the PolicyRule class are:  SystemCreationClassName (A CIM System key, propagated due to the weak association PolicyRuleInSystem)
SystemName (A CIM System key, propagated due to the weak association PolicyRuleInSystem)
PolicyRuleName SystemCreationClassName and SystemName work the same as defined for the class PolicyGroup.
See Section 13.1.1 for details.
The other two properties are defined in Reference [1] as follows:
This property is set to "CIM PolicyRule", if the PolicyRule object is directly instantiated.
Or, it is equal to the class name of the PolicyRule subclass that is instantiated.
The identifying name of this policy rule.
Naming Instances of PolicyCondition and Its Subclasses
The CIM keys of the PolicyCondition class are:  SystemCreationClassName  SystemName
PolicyConditionName Note that none of the keys are defined as propagated, although they appear to fit this convention.
The reason for this difference is because (as indicated in Sections 5.1 and 6.4) the PolicyCondition class is used to represent both reusable and rule specific conditions.
This, in turn, affects what associations are valid for an instance of PolicyCondition, and how that instance is named.
In an ideal world, an instance of the PolicyCondition class would be scoped either by its PolicyRepository (for a reusable condition) or by its PolicyRule (for a rule specific condition).
However, CIM has the restriction that a given class can only be "weak" to one other class (i.e., defined by one weak association).
To work within the restrictions of CIM naming, it is necessary to "simulate" weak associations between PolicyCondition and PolicyRule, and between PolicyCondition and PolicyRepository, through a technique we'll call manual key propagation.
Strictly speaking, manual key propagation isn't key propagation at all.
But it has the same effect as (true) key propagation, so the name fits.
Figure 9 illustrates how manual propagation works in the case of PolicyCondition.
(Note that only the key properties are shown for each of the classes.)
In the figure, the line composed of 'I's indicates class inheritance, the one composed of 'P's indicates (true) key propagation via the weak aggregation PolicyRuleInSystem, and the ones composed of 'M's indicate manual key propagation.
Manual Key Propagation for Naming PolicyConditions Looking at Figure 9
, we see that two key properties, CreationClassName and Name, are defined in the System class, and inherited by its subclasses AdminDomain and PolicyRepository.
Since PolicyRule is weak to System, these two keys are propagated to it; it also has its own keys CreationClassName and PolicyRuleName.
A similar approach, though not automatic, is used in "manual key propagation".
Here is the approach for rule specific and reusable PolicyConditions:
The manual propagation of keys from PolicyRule to PolicyCondition involves copying the values of PolicyRule's four key properties into four similarly named key properties in PolicyCondition.
From the point of view of the CIM specification language, the property SystemName in PolicyCondition is a completely new key property.
However, the relationship to the Name property in System is defined in the description of SystemName.
The manual propagation of keys from PolicyRepository to PolicyCondition works in exactly the same way for the first two key properties.
However, since PolicyRepository doesn't include PolicyRule properties, the PolicyRuleCreationClassName and PolicyRuleName have no values.
A special value, "No Rule", is assigned to both of these properties in this case, indicating that this instance of PolicyCondition is not named within the scope of any particular policy rule.
The following section defines the specific CIM keys for PolicyCondition.
PolicyCondition's CIM Keys PolicyCondition's key properties are defined in Reference [1] as follows:
the class name of the CIM System object providing the naming scope for the instance of PolicyCondition.
For a rule specific policy condition, this is the type of system (e.g., the name of the class that created this instance) in whose context the policy rule is defined.
For a reusable policy condition, this is set to "CIM PolicyRepository", if the PolicyRepository object is directly instantiated.
Or, it is equal to the class name of the PolicyRepository subclass that is instantiated.
The name of the System object in whose scope this policy condition is defined.
This property completes the identification of the System object.
For a rule specific policy condition, this is the name of the instance of the system in whose context the policy rule is defined.
For a reusable policy condition, this is name of the instance of PolicyRepository that holds the policy condition.
For a rule specific policy condition, this property identifies the class name of the policy rule instance, in whose scope this instance of PolicyCondition exists.
For a reusable policy condition, this property is set to a special value, "No Rule", indicating that this instance of PolicyCondition is not unique to one policy rule.
For a rule specific policy condition, PolicyRuleName completes the identification of the PolicyRule object with which this condition is associated.
For a reusable policy condition, a special value, "No Rule", is used to indicate that this condition is reusable.
The class name of the PolicyCondition subclass that is instantiated.
The identifying name of this policy condition.
Naming Instances of PolicyAction and Its Subclasses From the point of view of naming, the PolicyAction class and its subclasses work exactly like the PolicyCondition class and its subclasses.
See Section 13.2 and 13.2.1 for details.
Specifically, the CIM keys of PolicyAction are:  SystemCreationClassName  SystemName
They are defined in Reference [1] as follows:
the class name of the CIM System object providing the naming scope for the instance of PolicyAction.
For a rule specific policy action, this is the type of system (e.g., the name of the class that created this instance) in whose context the policy rule is defined.
For a reusable policy action, this is set to "CIM PolicyRepository", if the PolicyRepository object is directly instantiated.
Or, it is equal to the class name of the PolicyRepository subclass that is instantiated.
The name of the System object in whose scope this policy action is defined.
This property completes the identification of the System object.
For a rule specific policy action, this is the name of the instance of the system in whose context the policy rule is defined.
For a reusable policy action, this is name of the instance of PolicyRepository that holds the policy action.
For a rule specific policy action, this property identifies the class name of the policy rule instance, in whose scope this instance of PolicyAction exists.
For a reusable policy action, this property is set to a special value, "No Rule", indicating that this instance of PolicyAction is not unique to one policy rule.
For a rule specific policy action, PolicyRuleName completes the identification of the PolicyRule object with which this action is associated.
For a reusable policy action, a special value, "No Rule", is used to indicate that this action is reusable.
The class name of the PolicyAction subclass that is instantiated.
The identifying name of this policy action.
An instance of PolicyRepository is named by the two key properties CreationClassName and Name that it inherits from its superclass AdminDomain.
These properties are actually defined in  AdminDomain's superclass, System, and then inherited by AdminDomain.
For instances of PolicyRepository itself, the value of CreationClassName must be "CIM PolicyRepository".
(Recall that for readability the prefix "CIM " has been omitted from all class names in this document).
If a subclass of PolicyRepository (perhaps QosPolicyRepository) is defined and instantiated, then the class name "CIM QosPolicyRepository" is used in CreationClassName.
The Name property simply completes the identification of the instance of PolicyRepository.
Role of the CreationClassName Property in Naming To provide for more flexibility in instance naming, CIM makes use of a property called CreationClassName.
The idea of CreationClassName is to provide another dimension that can be used to avoid naming collisions, in the specific case of instances belonging to two different subclasses of a common  superclass.
An example will illustrate how CreationClassName works.
Suppose we have instances of two different subclasses of PolicyCondition, FrameRelayPolicyCondition and BgpPolicyCondition, and that these instances apply to the same context.
If we had only the single key property PolicyConditionName available for distinguishing the two instances, then a collision would result from naming both of the instances with the key value
Thus policy administrators from widely different disciplines would have to coordinate their naming of PolicyConditions for this context.
With CreationClassName, collisions of this type can be eliminated, without requiring coordination among the policy administrators.
The two instances can be distinguished by giving their CreationClassNames different values.
One instance is now identified with the two keys CreationClassName
"PC 1", while the other is identified with CreationClassName   "BgpPolicyCondition"
Each of the instantiable classes in the Core Model includes the CreationClassName property as a key in addition to its own class  specific key property.
The Core Policy MOF //
Rooted the model associations under Policy //
PolicyActionInPolicyRepository to subclass from //
PolicyInSystem (similar to Groups and Roles 'InSystem')
DMTF SLA (Service Level Agreement)
[Abstract, Description ( "An abstract class describing common properties of all " "policy rule related subclasses, such as PolicyGroup, Policy" "Rule and PolicyCondition.
All instances of policy rule " "related entities will be created from subclasses of CIM " "Policy.
[Description ( "An array of keywords for characterizing / categorizing " "policy objects.
Keywords are of one of two types:
These " "concepts are self explanatory and are further discussed " "in the SLA/Policy White Paper.
One additional keyword " "is defined: 'POLICY'.
The role of this keyword is to " "identify policy related instances that may not be otherwise " "identifiable, in some implementations.
[Association, Abstract, Aggregation, Description ( "CIM PolicyComponent is a generic association used to " "establish 'part of' relationships between the subclasses of " "CIM Policy.
These Systems may be ComputerSystems " "where Policies are 'running' or they may be Policy
" "Repositories where Policies are stored.
This relationship " "is similar to the concept of CIM Services being dependent " "on CIM Systems as defined by the HostedService " "association.
"reference since Policies can only be hosted in at most one " "System context.
Some subclasses of the association will " "further refine this definition to make the Policies Weak " "to Systems.
Other subclasses of PolicyInSystem will " "define an optional hosting relationship.
[Description ( "A container for either a set of related PolicyGroups " "or a set of related PolicyRules, but not both.
[Key, MaxLen (256), Description ( "CreationClassName indicates the name of the class or the " "subclass used in the creation of an instance.
[Association, Aggregation, Description ( "
A relationship that aggregates one or more lower level " "PolicyGroups into a higher level Group.
" "conditions (Conjunctive Normal Form, or CNF).
Individual " "conditions may either be negated (NOT C) or unnegated (C). "
These condition and action " "objects are tied to instances of PolicyRule by the Policy" "ConditionInPolicyRule and PolicyActionInPolicyRule
"A PolicyRule may also be associated with one or more policy " "time periods, indicating the schedule according to which the " "policy rule is active and inactive.
The PolicyRule class uses the property ConditionListType, to " "indicate whether the conditions for the rule are in DNF or " "CNF.
The PolicyConditionInPolicyRule aggregation contains " "two additional properties to complete the representation of " "the Rule's conditional expression.
The first of these " "properties is an integer to partition the referenced " "PolicyConditions into one or more groups, and the second is a " "Boolean to indicate whether a referenced Condition is " "negated.
An example shows how ConditionListType and these " "two additional properties provide a unique representation " "of a set of PolicyConditions in either DNF or CNF.\n\n
[Key, MaxLen (256), Description ( "CreationClassName indicates the name of the class or the " "subclass used in the creation of an instance.
[Description ( "Indicates whether this PolicyRule is administratively " "enabled, administratively disabled, or enabled for " "debug.
This serves as a debug vehicle when attempting to " "determine what policies would execute in a particular " "scenario, without taking any actions to change state " "during the debugging.
uint16 Enabled; [Description ( "Indicates whether the list of PolicyConditions " "associated with this PolicyRule is in disjunctive " "normal form (DNF) or conjunctive normal form (CNF)."
A larger value " "indicates a higher priority.
uint16 Priority; [Description ( "
A flag indicating that the evaluation of the Policy" "Conditions and execution of PolicyActions (if the " "Conditions evaluate to TRUE) is required.
The " "evaluation of a PolicyRule MUST be attempted if the " "Mandatory property value is TRUE.
[Description ( "This property gives a policy administrator a way " "of specifying how the ordering of the PolicyActions " "associated with this PolicyRule is to be interpreted. "
This property represents the roles and role combinations " "associated with a PolicyRule.
Each value represents one " "role or role combination.
Since this is a multi valued " "property, more than one role or combination can be associated " "with a single policy rule.
[Association, Aggregation, Description ( "
A relationship that aggregates one or more PolicyRules " "into a PolicyGroup.
CIM System REF Antecedent; [Override ("Dependent"), Weak, Description (
[Description ( "A class representing an administratively defined " "container for reusable policy related information. "
"This class does not introduce any additional " "properties beyond those in its superclass " "AdminDomain.
It does, however, participate in a " "number of unique associations.
[Association, Aggregation, Description ( "
[Abstract, Description ( "A class representing a rule specific or reusable policy " "condition to be evaluated in conjunction with a Policy" "Rule.
this " "PolicyCondition is defined.\n\n"
"For a rule specific PolicyCondition, this is the System " "in whose context the PolicyRule is defined.
For a " "reusable PolicyCondition, this is the instance of " "PolicyRepository (which is a subclass of System) that " "holds the Condition.\n\n
SystemCreationClassName; [Key, MaxLen (256), Description ( "
This property completes the identification of the System " "object in whose scope this instance of PolicyCondition " "exists.
For a rule specific PolicyCondition, this is the " "System in whose context the PolicyRule is defined.
string SystemName; [Key, MaxLen (256), Description ( "For a rule specific PolicyCondition, the " "CreationClassName of the PolicyRule object with which " "this Condition is associated.
string PolicyRuleCreationClassName; [Key, MaxLen (256), Description ( "For a rule specific PolicyCondition, the name of " "the PolicyRule object with which this Condition is " "associated.
string PolicyRuleName; [Key, MaxLen (256), Description ( "CreationClassName indicates the name of the class or the " "subclass used in the creation of an instance.
zero or more instances of the " "PolicyCondition class, via the PolicyConditionInPolicyRule " "association.
A Rule that aggregates zero Conditions is not " "valid
it may, however, be in the process of being entered " "into a PolicyRepository or being defined for a System.
Individual PolicyConditions in these " "lists may be negated.
The property ConditionListType " "specifies which of these two grouping schemes applies to
In this case, the time " "periods are simply additional Conditions to be evaluated " "along with any others that are specified for the Rule.
CIM PolicyRule REF GroupComponent; [Override ("PartComponent"), Description
CIM PolicyCondition REF PartComponent; [Description ( "Unsigned integer indicating the group to which the " "PolicyCondition identified by the ContainedCondition " "property belongs.
uint16 GroupNumber; [Description ( "Indication of whether the Condition identified by " "the ContainedCondition property is negated.
CIM PolicyInSystem { [Override ("Antecedent"), Max(1), Description ( "This property identifies a PolicyRepository " "hosting one or more PolicyConditions.
A reusable " "PolicyCondition is always related to exactly one " "PolicyRepository via the PolicyConditionInPolicyRepository " "aggregation.
CIM PolicyRepository REF Antecedent; [Override ("Dependent"), Description ( "This property holds the name of a PolicyCondition" "hosted in the PolicyRepository.
"At all times that fall outside these time periods, the " "PolicyRule has no effect.
For example, sessions that were " "established
while a Rule was active might need to " "be taken down when the Rule becomes inactive.
In other " "cases, however, such sessions might be left up.
In this " "case, the effect of deactivating the PolicyRule would " "just be to prevent the establishment of new sessions.
" "transitions are not currently addressed by the Policy " "Model, and must be specified in 'guideline' documents or " "via subclasses of CIM PolicyRule, CIM PolicyTimePeriod" "Condition or other concrete subclasses of CIM Policy.
The values " "of all the properties present in an instance are ANDed " "together to determine the validity period(s) for the " "instance.
"If this 'missing property' rule is applied to its fullest, we " "see that there is a second way to indicate that a Policy" "Rule is always enabled:
Thus, the second " "date and time must be later than the first.
Date/times are " "expressed as substrings of the form yyyymmddThhmmss.
"), ModelCorrespondence { "CIM PolicyTimePeriodCondition.
These properties work " "together, with the TimePeriod used to specify the overall " "time period in which the PolicyRule is valid, and the " "TimeOfDayMask used to pick out the range of time periods " "in a given day of during which the Rule is valid.
"The first time indicates the beginning of the range, while " "the second time indicates the end.
Times are expressed as " "substrings of the form 'Thhmmss'.
To allow for ranges that span " "midnight, however, the value of the second string may be " "smaller than the value of the first substring.
From 2100 Monday until 0800 Tuesday; \n" "
From 2100 Tuesday until 23:59:59 Tuesday.
This property indicates whether the times represented " "in the TimePeriod property and in the various Mask " "properties represent local times or UTC times.
[Association, Aggregation, Description ( "The PolicyRuleValidityPeriod aggregation represents " "scheduled activation and deactivation of a PolicyRule. "
"If a PolicyRule is associated with multiple policy time " "periods via this association, then the Rule is active if " "at least one of the time periods indicates that it is " "active.
(In other words, the PolicyTimePeriodConditions " "are ORed to determine whether the Rule is active.)
A Time" "Period may be aggregated by multiple PolicyRules.
It may, however, be inactive for other " "reasons.
CIM PolicyRule REF GroupComponent; [Override ("PartComponent"), Description
CIM PolicyCondition { [Octetstring, Description ( "This property provides a general extension mechanism for " "representing PolicyConditions that have not been " "modeled with specific properties.
The format of the " "octet strings in the array is left unspecified in " "this definition.
It is determined by the OID value " "stored in the property ConstraintEncoding.
[Abstract, Description ( "A class representing a rule specific or reusable policy " "action to be performed if the PolicyConditions for a Policy" "Rule evaluate to TRUE.
"For a rule specific PolicyAction, this is the System " "in whose context the PolicyRule is defined.
For a " "reusable PolicyAction, this is the instance of " "PolicyRepository (which is a subclass of System) that " "holds the Action.
SystemCreationClassName; [Key, MaxLen (256), Description ( "
The name of the System object in whose scope this " "PolicyAction is defined.
For a rule specific PolicyAction, this is the " "System in whose context the PolicyRule is defined.
string SystemName; [Key, MaxLen (256), Description ( "For a rule specific PolicyAction, the CreationClassName " "of the PolicyRule object
with which this Action is " "associated.
string PolicyRuleCreationClassName; [Key, MaxLen (256), Description ( "For a rule specific PolicyAction, the name of " "the PolicyRule object with which this Action is " "associated.
string PolicyRuleName; [Key, MaxLen (256), Description ( "CreationClassName indicates the name of the class or the " "subclass used in the creation of an instance.
CIM PolicyInSystem { [Override ("Antecedent"), Max(1), Description ( "This property represents a PolicyRepository " "hosting one or more PolicyActions.
A reusable " "PolicyAction is always related to exactly one " "PolicyRepository via the PolicyActionInPolicyRepository " "aggregation.
CIM PolicyRepository REF Antecedent; [Override ("Dependent"), Description ( "This property holds the name of a PolicyAction" "hosted in the PolicyRepository.
zero or more instances of the " "PolicyAction class, via the PolicyActionInPolicyRule " "association.
A Rule that aggregates zero Actions is not " "valid
it may, however, be in the process of being entered " "into a PolicyRepository or being defined for a System. "
"Alternately, the actions of the policy may be explicit in " "the definition of the PolicyRule.
Note that a PolicyRule " "should have no effect until it is valid.\n\n"
For " "Actions represented as separate objects, the PolicyActionIn" "PolicyRule aggregation can be used to express an order.
CIM PolicyRule REF GroupComponent; [Override ("PartComponent"), Description
When 'n' is a positive integer, it indicates a place " "in the sequence of actions to be performed, with " "smaller integers indicating earlier positions in the " "sequence.
The special value '0' indicates 'don't care'. "
"If two or more PolicyActions have the same non zero " "sequence number, they may be performed in any order, but " "they must all be performed at the appropriate place in the " "overall action sequence.
Standardized extensions are not expected to use " "this class.")
] class CIM VendorPolicyAction :
CIM PolicyAction { [Octetstring, Description ( "This property provides a general extension mechanism for " "representing PolicyActions that have not been " "modeled with specific properties.
The format of the " "octet strings in the array is left unspecified in " "this definition.
It is determined by the OID value " "stored in the property ActionEncoding.
