- contents:
  - "           Forwarding and Control Element Separation (ForCES)\n                  Logical
    Function Block (LFB) Library\n"
  title: __initial_text__
- contents:
  - "Abstract\n   This document defines basic classes of Logical Function Blocks (LFBs)\n
    \  used in Forwarding and Control Element Separation (ForCES).  The\n   basic
    LFB classes are defined according to the ForCES Forwarding\n   Element (FE) model
    and ForCES protocol specifications; they are\n   scoped to meet requirements of
    typical router functions and are\n   considered the basic LFB library for ForCES.
    \ The library includes\n   the descriptions of the LFBs and the XML definitions.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6956.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2013 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \  2. Terminology and Conventions .....................................4\n      2.1.
    Requirements Language ......................................4\n      2.2. Definitions
    ................................................4\n   3. Overview ........................................................6\n
    \     3.1. Scope of the Library .......................................6\n      3.2.
    Overview of LFB Classes in the Library .....................8\n           3.2.1.
    LFB Design Choices ..................................8\n           3.2.2. LFB
    Class Groupings .................................9\n           3.2.3. Sample LFB
    Class Application .......................10\n      3.3. Document Structure ........................................11\n
    \  4. Base Types .....................................................11\n      4.1.
    Data Types ................................................13\n           4.1.1.
    Atomic .............................................13\n           4.1.2. Compound
    Struct ....................................13\n           4.1.3. Compound Array
    .....................................14\n      4.2. Frame Types ...............................................14\n
    \     4.3. Metadata Types ............................................15\n      4.4.
    XML for Base Type Library .................................16\n   5. LFB Class
    Descriptions .........................................41\n      5.1. Ethernet-Processing
    LFBs ..................................42\n           5.1.1. EtherPHYCop ........................................42\n
    \          5.1.2. EtherMACIn .........................................44\n           5.1.3.
    EtherClassifier ....................................46\n           5.1.4. EtherEncap
    .........................................48\n           5.1.5. EtherMACOut ........................................50\n
    \     5.2. IP Packet Validation LFBs .................................52\n           5.2.1.
    IPv4Validator ......................................52\n           5.2.2. IPv6Validator
    ......................................54\n      5.3. IP Forwarding LFBs ........................................55\n
    \          5.3.1. IPv4UcastLPM .......................................56\n           5.3.2.
    IPv4NextHop ........................................58\n           5.3.3. IPv6UcastLPM
    .......................................60\n           5.3.4. IPv6NextHop ........................................62\n
    \     5.4. Redirect LFBs .............................................64\n           5.4.1.
    RedirectIn .........................................64\n           5.4.2. RedirectOut
    ........................................65\n      5.5. General Purpose LFBs ......................................66\n
    \          5.5.1. BasicMetadataDispatch ..............................66\n           5.5.2.
    GenericScheduler ...................................68\n   6. XML for LFB Library
    ............................................69\n   7. LFB Class Use Cases ............................................97\n
    \     7.1. IPv4 Forwarding ...........................................98\n      7.2.
    ARP Processing ...........................................101\n   8. IANA Considerations
    ...........................................102\n      8.1. LFB Class Names and
    LFB Class Identifiers ................103\n      8.2. Metadata ID ..............................................105\n
    \     8.3. Exception ID .............................................106\n      8.4.
    Validate Error ID ........................................107\n   9. Security
    Considerations .......................................108\n   10. References ...................................................108\n
    \     10.1. Normative References ....................................108\n      10.2.
    Informative References ..................................108\n   Appendix A.  Acknowledgements
    ....................................110\n   Appendix B.  Contributors ........................................110\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   [RFC3746] specifies the Forwarding and Control Element Separation\n
    \  (ForCES) framework.  In the framework, Control Elements (CEs)\n   configure
    and manage one or more separate Forwarding Elements (FEs)\n   within a Network
    Element (NE) by use of a ForCES protocol.  [RFC5810]\n   specifies the ForCES
    protocol.  [RFC5812] specifies the Forwarding\n   Element (FE) model.  In the
    model, resources in FEs are described by\n   classes of Logical Function Blocks
    (LFBs).  The FE model defines the\n   structure and abstract semantics of LFBs
    and provides XML schema for\n   the definitions of LFBs.\n   This document conforms
    to the specifications of the FE model\n   [RFC5812] and specifies detailed definitions
    of classes of LFBs,\n   including detailed XML definitions of LFBs.  These LFBs
    form a base\n   LFB library for ForCES.  LFBs in the base library are expected
    to be\n   combined to form an LFB topology for a typical router to implement IP\n
    \  forwarding.  It should be emphasized that an LFB is an abstraction of\n   functions
    rather than implementation details.  The purpose of the LFB\n   definitions is
    to represent functions so as to provide\n   interoperability between separate
    CEs and FEs.\n   More LFB classes with more functions may be developed in the
    future\n   and documented by the IETF.  Vendors may also develop proprietary LFB\n
    \  classes as described in the FE model [RFC5812].\n"
  title: 1.  Introduction
- contents:
  - '2.  Terminology and Conventions

    '
  - contents:
    - "2.1.  Requirements Language\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\",
      and \"OPTIONAL\" in this\n   document are to be interpreted as described in
      [RFC2119].\n"
    title: 2.1.  Requirements Language
  - contents:
    - "2.2.  Definitions\n   This document follows the terminology defined by the
      ForCES protocol\n   in [RFC5810] and by the ForCES FE model in [RFC5812].  The\n
      \  definitions below are repeated for clarity.\n      Control Element (CE) -
      A logical entity that implements the ForCES\n      protocol and uses it to instruct
      one or more FEs on how to process\n      packets.  CEs handle functionality
      such as the execution of\n      control and signaling protocols.\n      Forwarding
      Element (FE) - A logical entity that implements the\n      ForCES protocol.
      \ FEs use the underlying hardware to provide per-\n      packet processing and
      handling as directed/controlled by one or\n      more CEs via the ForCES protocol.\n
      \     ForCES Network Element (NE) - An entity composed of one or more\n      CEs
      and one or more FEs.  To entities outside an NE, the NE\n      represents a
      single point of management.  Similarly, an NE usually\n      hides its internal
      organization from external entities.\n      Logical Function Block (LFB) - The
      basic building block that is\n      operated on by the ForCES protocol.  The
      LFB is a well-defined,\n      logically separable functional block that resides
      in an FE and is\n      controlled by the CE via the ForCES protocol.  The LFB
      may reside\n      at the FE's data path and process packets or may be purely
      an FE\n      control or configuration entity that is operated on by the CE.\n
      \     Note that the LFB is a functionally accurate abstraction of the\n      FE's
      processing capabilities but not a hardware-accurate\n      representation of
      the FE implementation.\n      FE Model - The FE model is designed to model the
      logical\n      processing functions of an FE, which is defined by the ForCES
      FE\n      model document [RFC5812].  The FE model proposed in this document\n
      \     includes three components: the LFB modeling of individual Logical\n      Functional
      Blocks (LFB model), the logical interconnection between\n      LFBs (LFB topology),
      and the FE-level attributes, including FE\n      capabilities.  The FE model
      provides the basis to define the\n      information elements exchanged between
      the CE and the FE in the\n      ForCES protocol [RFC5810].\n      FE Topology
      - A representation of how the multiple FEs within a\n      single NE are interconnected.
      \ Sometimes this is called inter-FE\n      topology, to be distinguished from
      intra-FE topology (i.e., LFB\n      topology).\n      LFB Class and LFB Instance
      - LFBs are categorized by LFB classes.\n      An LFB instance represents an
      LFB class (or type) existence.\n      There may be multiple instances of the
      same LFB class (or type) in\n      an FE.  An LFB class is represented by an
      LFB class ID, and an LFB\n      instance is represented by an LFB instance ID.
      \ As a result, an\n      LFB class ID associated with an LFB instance ID uniquely
      specifies\n      an LFB existence.\n      LFB Metadata - Metadata is used to
      communicate per-packet state\n      from one LFB to another but is not sent
      across the network.  The\n      FE model defines how such metadata is identified,
      produced, and\n      consumed by the LFBs.  It defines the functionality but
      not how\n      metadata is encoded within an implementation.\n      LFB Component
      - Operational parameters of the LFBs that must be\n      visible to the CEs
      are conceptualized in the FE model as the LFB\n      components.  The LFB components
      include, for example, flags,\n      single parameter arguments, complex arguments,
      and tables that the\n      CE can read and/or write via the ForCES protocol
      (see below).\n      LFB Topology - Representation of how the LFB instances are\n
      \     logically interconnected and placed along the data path within one\n      FE.
      \ Sometimes it is also called intra-FE topology, to be\n      distinguished
      from inter-FE topology.\n      Data Path - A conceptual path taken by packets
      within the\n      forwarding plane inside an FE.  Note that more than one data
      path\n      can exist within an FE.\n      ForCES Protocol - While there may
      be multiple protocols used\n      within the overall ForCES architecture, the
      term \"ForCES protocol\"\n      and \"protocol\" refer to the Fp reference points
      in the ForCES\n      framework in [RFC3746].  This protocol does not apply to
      CE-to-CE\n      communication, FE-to-FE communication, or to communication between\n
      \     FE and CE managers.  Basically, the ForCES protocol works in a\n      master-slave
      mode in which FEs are slaves and CEs are masters.\n      Physical Port - A port
      refers to a physical media input port or\n      output port of an FE.  A physical
      port is usually assigned with a\n      physical port ID, abbreviated with a
      PHYPortID.  This document\n      mainly deals with physical ports with Ethernet
      media.\n      Logical Port - A conceptually virtual port at the data link layer\n
      \     (L2) or network layer (L3).  A logical port is usually assigned\n      with
      a logical port ID, abbreviated with a LogicalPortID.  The\n      logical ports
      can be further categorized with an L2 logical port\n      or an L3 logical port.
      \ An L2 logical port can be assigned with an\n      L2 logical port ID, abbreviated
      with an L2PortID.  An L3 logical\n      port can be assigned with an L3 logical
      port ID, abbreviated with\n      an L3PortID.  MAC-layer VLAN ports belong to
      logical ports, and\n      they belong to L2 logical ports.\n      LFB Port -
      The connection points where one LFB can be connected to\n      another within
      an FE.  As described in [RFC5812], the CE can\n      connect LFBs together by
      establishing connections between an\n      output port of one LFB instance and
      an input port of another LFB\n      instance.  Also see Section 3.2 of [RFC5812]
      for more details.\n      Singleton Port - A named input or output port of an
      LFB.  This\n      port is referred to by a name.  When the context is clear,
      the\n      term \"singleton\" by itself is used to refer to a singleton port.\n
      \     Group Port - A named collection of input or output ports of an\n      LFB.
      \ A group port is referred to by a name.  A group port\n      consists of a
      number of port instances, which are referred to by a\n      combination of a
      name and an index.\n      LFB Class Library - The LFB class library is a set
      of LFB classes\n      that has been identified as the most common functions
      found in\n      most FEs and hence should be defined first by the ForCES Working\n
      \     Group.  The LFB class library is defined by this document.\n"
    title: 2.2.  Definitions
  title: 2.  Terminology and Conventions
- contents:
  - '3.  Overview

    '
  - contents:
    - "3.1.  Scope of the Library\n   It is intended that the LFB classes described
      in this document are\n   designed to provide the functions of a typical router.
      \ [RFC1812]\n   specifies that a typical router is expected to provide functions
      to:\n   (1)  Interface to packet networks and implement the functions\n        required
      by that network.  These functions typically include:\n        *  Encapsulating
      and decapsulating the IP datagrams with the\n           connected network framing
      (e.g., an Ethernet header and\n           checksum),\n        *  Sending and
      receiving IP datagrams up to the maximum size\n           supported by that
      network (this size is the network's Maximum\n           Transmission Unit or
      MTU),\n        *  Translating the IP destination address into an appropriate\n
      \          network-level address for the connected network (e.g., an\n           Ethernet
      hardware address), if needed, and\n        *  Responding to network flow control
      and error indications, if\n           any.\n   (2)  Conform to specific Internet
      protocols including the Internet\n        Protocol (IPv4 and/or IPv6), Internet
      Control Message Protocol\n        (ICMP), and others as necessary.\n   (3)  Receive
      and forward Internet datagrams.  Important issues in\n        this process are
      buffer management, congestion control, and\n        fairness.\n        *  Recognize
      error conditions and generate ICMP error and\n           information messages
      as required.\n        *  Drop datagrams whose time-to-live fields have reached
      zero.\n        *  Fragment datagrams when necessary to fit into the MTU of the\n
      \          next link or interface.\n   (4)  Choose a next-hop destination for
      each IP datagram, based on the\n        information in its routing database.\n
      \  (5)  Usually support an interior gateway protocol (IGP) to carry out\n        distributed
      routing and reachability algorithms with the other\n        routers in the same
      autonomous system.  In addition, some\n        routers will need to support
      an exterior gateway protocol (EGP)\n        to exchange topological information
      with other autonomous\n        systems.  For all routers, it is essential to
      provide the\n        ability to manage static routing items.\n   (6)  Provide
      network management and system support facilities,\n        including loading,
      debugging, status reporting, statistics\n        query, exception reporting,
      and control.\n   The classical IP router utilizing the ForCES framework constitutes
      a\n   CE running some controlling IGP and/or EGP function or static route\n
      \  setup and FEs implemented by use of Logical Function Blocks (LFBs)\n   conforming
      to the FE model [RFC5812] specification.  The CE, in\n   conformance to the
      ForCES protocol [RFC5810] and the FE model\n   [RFC5812] specifications, instructs
      the LFBs on the FE how to treat\n   received/sent packets.\n   Packets in an
      IP router are received and transmitted on physical\n   media typically referred
      to as \"ports\".  Different physical media\n   will have different ways for
      encapsulating outgoing frames and\n   decapsulating incoming frames.  The different
      physical media will\n   also have different attributes that influence its behavior
      and how\n   frames get encapsulated or decapsulated.  This document will only\n
      \  deal with Ethernet physical media.  Future documents may deal with\n   other
      types of media.  This document will also interchangeably refer\n   to a port
      as an abstraction that constitutes a physical layer (PHY)\n   and a Media Access
      Control (MAC) layer, as described by LFBs like\n   EtherPHYCop, EtherMACIn,
      and EtherMACOut.\n   IP packets emanating from port LFBs are then processed
      by a\n   validation LFB before being further forwarded to the next LFB.  After\n
      \  the validation process, the packet is passed to an LFB where an IP\n   forwarding
      decision is made.  In the IP Forwarding LFBs, a Longest\n   Prefix Match LFB
      is used to look up the destination information in a\n   packet and select a
      next-hop index for sending the packet onward.  A\n   next-hop LFB uses the next-hop
      index metadata to apply the proper\n   headers to the IP packets and direct
      them to the proper egress.  Note\n   that in the process of IP packet processing,
      in this document, we are\n   adhering to the weak-host model [RFC1122] since
      that is the most\n   usable model for a packet processing a Network Element.\n"
    title: 3.1.  Scope of the Library
  - contents:
    - "3.2.  Overview of LFB Classes in the Library\n   It is critical to classify
      functional requirements into various\n   classes of LFBs and construct a typical
      but also flexible enough base\n   LFB library for various IP forwarding equipments.\n"
    - contents:
      - "3.2.1.  LFB Design Choices\n   A few design principles were factored into
        choosing what the base\n   LFBs look like:\n   o  If a function can be designed
        by either one LFB or two or more\n      LFBs with the same cost, the choice
        is to go with two or more LFBs\n      so as to provide more flexibility for
        implementers.\n   o  An LFB should take advantage of its independence as much
        as\n      possible and have minimal coupling with other LFBs.  The coupling\n
        \     may be from LFB attributes definitions as well as physical\n      implementations.\n
        \  o  Unless there is a clear difference in functionality, similar\n      packet
        processing in the base LFB library should not be\n      represented simultaneously
        as two or more LFBs.  For instance, it\n      should not be simultaneously
        defined with two different LFBs for\n      the same next-hop processing.  Otherwise,
        it may add extra burden\n      on implementation to achieve interoperability.\n"
      title: 3.2.1.  LFB Design Choices
    - contents:
      - "3.2.2.  LFB Class Groupings\n   This document defines groups of LFBs for
        typical router function\n   requirements:\n   (1)  A group of Ethernet-processing
        LFBs are defined to abstract the\n        packet processing for Ethernet as
        the port media type.  As\n        Ethernet is the most popular media type
        with rich processing\n        features, Ethernet media processing LFBs were
        a natural choice.\n        Definitions for processing of other port media
        types like Packet\n        over SONET (POS) or Asynchronous Transfer Mode
        (ATM) may be\n        incorporated in the library in future versions of this
        document\n        or in a separate document.  The following LFBs are defined
        for\n        Ethernet processing:\n        *  EtherPHYCop (Section 5.1.1)\n
        \       *  EtherMACIn (Section 5.1.2)\n        *  EtherClassifier (Section
        5.1.3)\n        *  EtherEncap (Section 5.1.4)\n        *  EtherMACOut (Section
        5.1.5)\n   (2)  A group of LFBs are defined for IP packet validation process.\n
        \       The following LFBs are defined for IP validation processing:\n        *
        \ IPv4Validator (Section 5.2.1)\n        *  IPv6Validator (Section 5.2.2)\n
        \  (3)  A group of LFBs are defined to abstract IP forwarding process.\n        The
        following LFBs are defined for IP forwarding processing:\n        *  IPv4UcastLPM
        (Section 5.3.1)\n        *  IPv4NextHop (Section 5.3.2)\n        *  IPv6UcastLPM
        (Section 5.3.3)\n        *  IPv6NextHop (Section 5.3.4)\n   (4)  A group of
        LFBs are defined to abstract the process for redirect\n        operation,
        i.e., data packet transmission between CE and FEs.\n        The following
        LFBs are defined for redirect processing:\n        *  RedirectIn (Section
        5.4.1)\n        *  RedirectOut (Section 5.4.2)\n   (5)  A group of LFBs are
        defined for abstracting some general purpose\n        packet processing.  These
        processing processes are usually\n        general to many processing locations
        in an FE LFB topology.  The\n        following LFBs are defined for redirect
        processing:\n        *  BasicMetadataDispatch (Section 5.5.1)\n        *  GenericScheduler
        (Section 5.5.2)\n"
      title: 3.2.2.  LFB Class Groupings
    - contents:
      - "3.2.3.  Sample LFB Class Application\n   Although Section 7 will present
        use cases for the LFBs defined in\n   this document, this section shows a
        simple sample LFB class\n   application in advance so that readers can get
        a quick overlook of\n   the LFB classes with the usage.\n   Figure 1 shows
        a simple LFB processing path for Ethernet packets\n   entered from Ethernet
        physical ports.\n   +-----+                +------+\n   |     |EtherPHYIn
        \     |      |            from some LFB(s) that\n   |     |<---------------|Ether
        |<---------- generate Ethernet\n   |     |                |MACOut|            packets\n
        \  |     |                | LFB  |\n   |Ether|                +------+\n   |PHY
        \ |                +------+\n   |Cop  |                |      |\n   |LFB  |EtherPHYOut
        \    | Ether|            to some LFB(s) that\n   |     |--------------->|
        MACIn|----------> may classify Ethernet\n   |     |                |  LFB
        |            packets and do IP-layer\n   |     |                |      |            processing\n
        \  +-----+                +------+\n                  Figure 1:  A Simple
        Sample LFB Use Case\n   In the figure, Ethernet packets from outer networks
        enter via the\n   EtherPHYCop LFB (Section 5.1.1), which describes Ethernet
        copper\n   interface properties (like the link speed) at the physical layer.\n
        \  After physical-layer processing, Ethernet packets are delivered to\n   the
        EtherMACIn LFB (Section 5.1.2) to describe its MAC-layer\n   processing functions
        (like locality check).  The packets after the\n   EtherMACIn LFB may require
        further processing to implement various\n   functions (like IP-layer forwarding);
        therefore, some LFBs may follow\n   the EtherMACIn LFB in topology to describe
        followed processing\n   functions.\n   Meanwhile, packets generated by some
        LFB(s) may need to be submitted\n   to outer physical networks.  The process
        is described in the figure\n   by an EtherMACOut LFB (Section 5.1.5) at the
        MAC layer and the\n   EtherPHYCop LFB at the physical layer.\n"
      title: 3.2.3.  Sample LFB Class Application
    title: 3.2.  Overview of LFB Classes in the Library
  - contents:
    - "3.3.  Document Structure\n   Base type definitions, including data types, packet
      frame types, and\n   metadata types, are presented in advance for definitions
      of various\n   LFB classes.  Section 4 (\"Base Types\") provides a description
      on the\n   base types used by this LFB library.  To enable extensive use of\n
      \  these base types by other LFB class definitions, the base type\n   definitions
      are provided as a separate library.\n   Within every group of LFB classes, a
      set of LFBs are defined for\n   individual function purposes.  Section 5 (\"LFB
      Class Descriptions\")\n   provides text descriptions on the individual LFBs.
      \ Note that for a\n   complete definition of an LFB, a text description and
      an XML\n   definition are required.\n   LFB classes are finally defined by XML
      with specifications and schema\n   defined in the ForCES FE model [RFC5812].
      \ Section 6 (\"XML for LFB\n   Library\") provides the complete XML definitions
      of the base LFB\n   classes library.\n   Section 7 provides several use cases
      on how some typical router\n   functions can be implemented using the base LFB
      library defined in\n   this document.\n"
    title: 3.3.  Document Structure
  title: 3.  Overview
- contents:
  - "4.  Base Types\n   The FE model [RFC5812] has specified predefined (built-in)
    atomic\n   data types: char, uchar, int16, uint16, int32, uint32, int64, uint64,\n
    \  string[N], string, byte[N], boolean, octetstring[N], float16,\n   float32,
    and float64.\n   Note that, unlike the Simple Network Management Protocol (SNMP)\n
    \  information model, called the Structure of Management Information\n   (SMI)
    [RFC2578], the FE model has not defined specific atomic data\n   types for counting
    purposes.  This document also does not define\n   specific counter types.  To
    describe LFB elements for packet\n   statistics, which actually requires counters
    on packets, an unsigned\n   integer, like an uint32 or an uint64, is adopted.
    \ This document\n   states that any LFB element defined for counting purposes
    is\n   specified to monotonically increase until it reaches a maximum value,\n
    \  when it wraps around and starts increasing again from zero.  This\n   document
    also states that how the unsigned integer element might be\n   maintained to cope
    with issues like counter discontinuities when a\n   counter wraps or is reset
    for any reason is an implementation's\n   issue.  If a CE is expected to understand
    more meanings of the\n   counter element than stated above, a private definition
    on the\n   element between the CE and FE may be required.\n   Based on the atomic
    data types and with the use of type definition\n   elements in the FE model XML
    schema, new data types, packet frame\n   types, and metadata types can be defined.\n
    \  To define a base LFB library for typical router functions, a set of\n   base
    data types, frame types, and metadata types should be defined.\n   This section
    provides a brief description of the base types and a\n   full XML definition of
    them as well.\n   The base type XML definitions are provided with a separate XML\n
    \  library file named \"BaseTypeLibrary\".  Users can refer to this\n   library
    by the statement:\n   <load library=\"BaseTypeLibrary\" location=\"...\"/>\n"
  - contents:
    - "4.1.  Data Types\n   Data types defined in the base type library are categorized
      by the\n   following types: atomic, compound struct, and compound array.\n"
    - contents:
      - "4.1.1.  Atomic\n   The following data types are defined as atomic data types
        and put in\n   the base type library:\n    Data Type Name      Brief Description\n
        \   --------------      -----------------\n    IPv4Addr            IPv4 address\n
        \   IPv6Addr            IPv6 address\n    IEEEMAC             IEEE MAC address\n
        \   LANSpeedType        LAN speed by value types\n    DuplexType          Duplex
        types\n    PortStatusType      The possible types of port status, used for\n
        \                        both administrative and operative status\n    VlanIDType
        \         The type of VLAN ID\n    VlanPriorityType    The type of VLAN priority\n
        \   SchdDisciplineType  Scheduling discipline type\n"
      title: 4.1.1.  Atomic
    - contents:
      - "4.1.2.  Compound Struct\n   The following compound struct types are defined
        in the base type\n   library:\n    Data Type Name           Brief Description\n
        \   --------------           -----------------\n    EtherDispatchEntryType
        \  Entry type for Ethernet dispatch table\n    VlanInputTableEntryType  Entry
        type for VLAN input table\n    EncapTableEntryType      Entry type for Ethernet
        encapsulation table\n    MACInStatsType           Statistics type for EtherMACIn
        LFB\n    MACOutStatsType          Statistics type for EtherMACOut LFB\n    EtherClassifyStatsType
        \  Entry type for statistics table in\n                              EtherClassifier
        LFB\n    IPv4PrefixInfoType       Entry type for IPv4 prefix table\n    IPv6PrefixInfoType
        \      Entry type for IPv6 prefix table\n    IPv4NextHopInfoType      Entry
        type for IPv4 next-hop table\n    IPv6NextHopInfoType      Entry type for
        IPv6 next-hop table\n    IPv4ValidatorStatsType   Statistics type in IPv4validator
        LFB\n    IPv6ValidatorStatsType   Statistics type in IPv6validator LFB\n    IPv4UcastLPMStatsType
        \   Statistics type in IPv4UcastLPM LFB\n    IPv6UcastLPMStatsType    Statistics
        type in IPv6UcastLPM LFB\n    QueueStatsType           Entry type for queue
        depth table\n    MetadataDispatchType     Entry type for metadata dispatch
        table\n"
      title: 4.1.2.  Compound Struct
    - contents:
      - "4.1.3.  Compound Array\n   Compound array types are mostly created based
        on compound struct\n   types for LFB table components.  The following compound
        array types\n   are defined in this base type library:\n    Data Type Name
        \              Brief Description\n    --------------               -----------------\n
        \   EtherClassifyStatsTableType  Type for Ethernet classifier statistics\n
        \                                 information table\n    EtherDispatchTableType
        \      Type for Ethernet dispatch table\n    VlanInputTableType           Type
        for VLAN input table\n    EncapTableType               Type for Ethernet encapsulation
        table\n    IPv4PrefixTableType          Type for IPv4 prefix table\n    IPv6PrefixTableType
        \         Type for IPv6 prefix table\n    IPv4NextHopTableType         Type
        for IPv4 next-hop table\n    IPv6NextHopTableType         Type for IPv6 next-hop
        table\n    MetadataDispatchTableType    Type for Metadata dispatch table\n
        \   QueueStatsTableType          Type for Queue depth table\n"
      title: 4.1.3.  Compound Array
    title: 4.1.  Data Types
  - contents:
    - "4.2.  Frame Types\n   According to the FE model [RFC5812], frame types are
      used in LFB\n   definitions to define packet frame types that an LFB expects
      at its\n   input port and that the LFB emits at its output port.  The <frameDef>\n
      \  element in the FE model is used to define a new frame type.\n   The following
      frame types are defined in the base type library:\n    Frame Name           Brief
      Description\n    --------------       -----------------\n    EthernetII           An
      Ethernet II frame\n    ARP                  An ARP packet frame\n    IPv4                 An
      IPv4 packet frame\n    IPv6                 An IPv6 packet frame\n    IPv4Unicast
      \         An IPv4 unicast packet frame\n    IPv4Multicast        An IPv4 multicast
      packet frame\n    IPv6Unicast          An IPv6 unicast packet frame\n    IPv6Multicast
      \       An IPv6 multicast packet frame\n    Arbitrary            Any type of
      packet frames\n"
    title: 4.2.  Frame Types
  - contents:
    - "4.3.  Metadata Types\n   LFB metadata is used to communicate per-packet state
      from one LFB to\n   another.  The <metadataDef> element in the FE model is used
      to define\n   a new metadata type.\n   The following metadata types are currently
      defined in the base type\n   library.\n   Metadata Name  Metadata ID  Brief
      Description\n   ------------   -----------  -----------------\n   PHYPortID
      \         1        Metadata indicating a physical port ID\n   SrcMAC             2
      \       Metadata indicating a source MAC address\n   DstMAC             3        Metadata
      indicating a destination MAC\n                                address\n   LogicalPortID
      \     4        Metadata of a logical port ID\n   EtherType          5        Metadata
      indicating an Ethernet type\n   VlanID             6        Metadata of a VLAN
      ID\n   VlanPriority       7        Metadata of a VLAN priority\n   NextHopIPv4Addr
      \   8        Metadata representing a next-hop IPv4\n                                address\n
      \  NextHopIPv6Addr    9        Metadata representing a next-hop IPv6\n                                address\n
      \  HopSelector        10       Metadata indicating a hop selector\n   ExceptionID
      \       11       Metadata indicating exception types for\n                                exceptional
      cases during LFB processing\n   ValidateErrorID    12       Metadata indicating
      error types when a\n                                packet passes validation
      process\n   L3PortID           13       Metadata indicating ID of an L3 logical\n
      \                               port\n   RedirectIndex      14       Metadata
      that CE sends to RedirectIn LFB,\n                                indicating
      an associated packet a group\n                                output port index
      of the LFB\n   MediaEncapInfoIndex 15      A search key a packet uses to look
      up a\n                                table in related LFBs to select an\n                                encapsulation
      media\n"
    title: 4.3.  Metadata Types
  - contents:
    - '4.4.  XML for Base Type Library

      '
    - '<?xml version="1.0" encoding="UTF-8"?>

      '
    - "<LFBLibrary xmlns=\"urn:ietf:params:xml:ns:forces:lfbmodel:1.0\"\n     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n
      \    provides=\"BaseTypeLibrary\">\n   <frameDefs>\n      <frameDef>\n         <name>EthernetAll</name>\n
      \        <synopsis>Packet with any Ethernet type</synopsis>\n      </frameDef>\n
      \     <frameDef>\n         <name>EthernetII</name>\n         <synopsis>Packet
      with Ethernet II type</synopsis>\n      </frameDef>\n      <frameDef>\n         <name>ARP</name>\n
      \        <synopsis>ARP packet</synopsis>\n      </frameDef>\n      <frameDef>\n
      \        <name>IPv4</name>\n         <synopsis>IPv4 packet</synopsis>\n      </frameDef>\n
      \     <frameDef>\n         <name>IPv6</name>\n         <synopsis>IPv6 packet</synopsis>\n
      \     </frameDef>\n      <frameDef>\n         <name>IPv4Unicast</name>\n         <synopsis>IPv4
      unicast packet</synopsis>\n      </frameDef>\n      <frameDef>\n         <name>IPv4Multicast</name>\n
      \        <synopsis>IPv4 multicast packet</synopsis>\n      </frameDef>\n      <frameDef>\n
      \        <name>IPv6Unicast</name>\n         <synopsis>IPv6 unicast packet</synopsis>\n
      \     </frameDef>\n      <frameDef>\n         <name>IPv6Multicast</name>\n         <synopsis>IPv6
      multicast packet</synopsis>\n      </frameDef>\n      <frameDef>\n         <name>Arbitrary</name>\n
      \        <synopsis>Any type of packet</synopsis>\n      </frameDef>\n   </frameDefs>\n
      \  <dataTypeDefs>\n      <dataTypeDef>\n         <name>IPv4Addr</name>\n         <synopsis>IPv4
      address</synopsis>\n         <typeRef>byte[4]</typeRef>\n      </dataTypeDef>\n
      \     <dataTypeDef>\n         <name>IPv6Addr</name>\n         <synopsis>IPv6
      address</synopsis>\n         <typeRef>byte[16]</typeRef>\n      </dataTypeDef>\n
      \     <dataTypeDef>\n         <name>IEEEMAC</name>\n         <synopsis>IEEE
      MAC address</synopsis>\n         <typeRef>byte[6]</typeRef>\n      </dataTypeDef>\n
      \     <dataTypeDef>\n        <name>LANSpeedType</name>\n        <synopsis>LAN
      speed type</synopsis>\n        <atomic>\n         <baseType>uint32</baseType>\n
      \        <specialValues>\n           <specialValue value=\"0x00000000\">\n            <name>LAN_SPEED_NONE</name>\n
      \           <synopsis>Nothing connected</synopsis>\n           </specialValue>\n
      \          <specialValue value=\"0x00000001\">\n            <name>LAN_SPEED_10M</name>\n
      \           <synopsis>10M Ethernet</synopsis>\n           </specialValue>\n
      \          <specialValue value=\"0x00000002\">\n            <name>LAN_SPEED_100M</name>\n
      \           <synopsis>100M Ethernet</synopsis>\n           </specialValue>\n
      \          <specialValue value=\"0x00000003\">\n            <name>LAN_SPEED_1G</name>\n
      \           <synopsis>1G Ethernet</synopsis>\n           </specialValue>\n           <specialValue
      value=\"0x00000004\">\n            <name>LAN_SPEED_10G</name>\n            <synopsis>10G
      Ethernet</synopsis>\n           </specialValue>\n           <specialValue value=\"0x00000005\">\n
      \           <name>LAN_SPEED_40G</name>\n            <synopsis>40G Ethernet</synopsis>\n
      \          </specialValue>\n           <specialValue value=\"0x00000006\">\n
      \           <name>LAN_SPEED_100G</name>\n            <synopsis>100G Ethernet</synopsis>\n
      \          </specialValue>\n           <specialValue value=\"0x00000007\">\n
      \           <name>LAN_SPEED_400G</name>\n            <synopsis>400G Ethernet</synopsis>\n
      \          </specialValue>\n           <specialValue value=\"0x00000008\">\n
      \           <name>LAN_SPEED_1T</name>\n            <synopsis>1T Ethernet</synopsis>\n
      \          </specialValue>\n           <specialValue value=\"0x00000009\">\n
      \           <name>LAN_SPEED_OTHER</name>\n            <synopsis>Other LAN speed
      type</synopsis>\n           </specialValue>\n           <specialValue value=\"0x0000000A\">\n
      \           <name>LAN_SPEED_AUTO</name>\n            <synopsis>LAN speed by
      auto negotiation</synopsis>\n           </specialValue>\n         </specialValues>\n
      \       </atomic>\n      </dataTypeDef>\n      <dataTypeDef>\n        <name>DuplexType</name>\n
      \       <synopsis>Duplex mode type</synopsis>\n        <atomic>\n         <baseType>uint32</baseType>\n
      \        <specialValues>\n           <specialValue value=\"0x00000001\">\n            <name>Auto</name>\n
      \           <synopsis>Auto negotiation</synopsis>\n           </specialValue>\n
      \          <specialValue value=\"0x00000002\">\n            <name>HalfDuplex</name>\n
      \           <synopsis>Half duplex</synopsis>\n           </specialValue>\n           <specialValue
      value=\"0x00000003\">\n            <name>FullDuplex</name>\n            <synopsis>Full
      duplex</synopsis>\n           </specialValue>\n         </specialValues>\n        </atomic>\n
      \     </dataTypeDef>\n      <dataTypeDef>\n        <name>PortStatusType</name>\n
      \       <synopsis>\n          Type for port status, used for both administrative
      and\n          operative status.\n        </synopsis>\n        <atomic>\n         <baseType>uchar</baseType>\n
      \        <specialValues>\n           <specialValue value=\"0\">\n            <name>Disabled</name>\n
      \           <synopsis>Port disabled</synopsis>\n           </specialValue>\n
      \          <specialValue value=\"1\">\n            <name>Up</name>\n            <synopsis>Port
      up</synopsis>\n           </specialValue>\n           <specialValue value=\"2\">\n
      \           <name>Down</name>\n            <synopsis>Port down</synopsis>\n
      \          </specialValue>\n         </specialValues>\n        </atomic>\n      </dataTypeDef>\n
      \     <dataTypeDef>\n         <name>MACInStatsType</name>\n         <synopsis>\n
      \          Data type defined for statistics in EtherMACIn LFB.\n         </synopsis>\n
      \        <struct>\n            <component componentID=\"1\">\n               <name>NumPacketsReceived</name>\n
      \              <synopsis>Number of packets received</synopsis>\n               <typeRef>uint64</typeRef>\n
      \           </component>\n            <component componentID=\"2\">\n               <name>NumPacketsDropped</name>\n
      \              <synopsis>Number of packets dropped</synopsis>\n               <typeRef>uint64</typeRef>\n
      \           </component>\n         </struct>\n      </dataTypeDef>\n      <dataTypeDef>\n
      \        <name>MACOutStatsType</name>\n         <synopsis>\n           Data
      type defined for statistics in EtherMACOut LFB.\n         </synopsis>\n         <struct>\n
      \           <component componentID=\"1\">\n               <name>NumPacketsTransmitted</name>\n
      \              <synopsis>Number of packets transmitted</synopsis>\n               <typeRef>uint64</typeRef>\n
      \           </component>\n            <component componentID=\"2\">\n               <name>NumPacketsDropped</name>\n
      \              <synopsis>Number of packets dropped</synopsis>\n               <typeRef>uint64</typeRef>\n
      \           </component>\n         </struct>\n      </dataTypeDef>\n      <dataTypeDef>\n
      \        <name>EtherDispatchEntryType</name>\n         <synopsis>\n           Data
      type defined for entry of Ethernet dispatch\n           table in EtherClassifier
      LFB.\n         </synopsis>\n         <struct>\n            <component componentID=\"1\">\n
      \              <name>LogicalPortID</name>\n               <synopsis>Logical
      port ID</synopsis>\n               <typeRef>uint32</typeRef>\n            </component>\n
      \           <component componentID=\"2\">\n               <name>EtherType</name>\n
      \              <synopsis>\n                The Ethernet type of the Ethernet
      packet.\n               </synopsis>\n               <typeRef>uint16</typeRef>\n
      \           </component>\n            <component componentID=\"3\">\n               <name>Reserved</name>\n
      \              <synopsis>\n               A reserved bit space mainly for purpose
      of padding\n               and packing efficiency.\n               </synopsis>\n
      \              <typeRef>uint16</typeRef>\n            </component>\n            <component
      componentID=\"4\">\n               <name>LFBOutputSelectIndex</name>\n                <synopsis>\n
      \                 Index for a packet to select an instance in the\n                  group
      output port of EtherClassifier LFB to output.\n                </synopsis>\n
      \              <typeRef>uint32</typeRef>\n            </component>\n         </struct>\n
      \     </dataTypeDef>\n      <dataTypeDef>\n         <name>EtherDispatchTableType</name>\n
      \        <synopsis>\n           Data type defined for Ethernet dispatch table
      in\n           EtherClassifier LFB.  The table is composed of an array\n           of
      entries with EtherDispatchEntryType data type.\n         </synopsis>\n         <array
      type=\"variable-size\">\n           <typeRef>EtherDispatchEntryType</typeRef>\n
      \        </array>\n      </dataTypeDef>\n      <dataTypeDef>\n         <name>VlanIDType</name>\n
      \        <synopsis>Data type for VLAN ID</synopsis>\n         <atomic>\n         <baseType>uint16</baseType>\n
      \          <rangeRestriction>\n              <allowedRange min=\"0\" max=\"4095\"/>\n
      \           </rangeRestriction>\n         </atomic>\n       </dataTypeDef>\n
      \     <dataTypeDef>\n         <name>VlanPriorityType</name>\n         <synopsis>Data
      type for VLAN priority</synopsis>\n         <atomic>\n         <baseType>uchar</baseType>\n
      \          <rangeRestriction>\n              <allowedRange min=\"0\" max=\"7\"/>\n
      \          </rangeRestriction>\n         </atomic>\n      </dataTypeDef>\n      <dataTypeDef>\n
      \        <name>VlanInputTableEntryType</name>\n         <synopsis>\n           Data
      type for entry of VLAN input table in EtherClassifier\n           LFB.  Each
      entry of the table contains an incoming port ID,\n           a VLAN ID and a
      logical port ID.  Every input packet is\n           assigned with a new logical
      port ID according to the\n           packet incoming port ID and the VLAN ID.\n
      \          </synopsis>\n         <struct>\n            <component componentID=\"1\">\n
      \              <name>IncomingPortID</name>\n               <synopsis>The incoming
      port ID</synopsis>\n               <typeRef>uint32</typeRef>\n            </component>\n
      \           <component componentID=\"2\">\n               <name>VlanID</name>\n
      \              <synopsis>The VLAN ID</synopsis>\n               <typeRef>VlanIDType</typeRef>\n
      \           </component>\n            <component componentID=\"3\">\n               <name>Reserved</name>\n
      \              <synopsis>\n               A reserved bit space mainly for purpose
      of padding\n               and packing efficiency.\n               </synopsis>\n
      \              <typeRef>uint16</typeRef>\n            </component>\n            <component
      componentID=\"4\">\n               <name>LogicalPortID</name>\n               <synopsis>The
      logical port ID</synopsis>\n               <typeRef>uint32</typeRef>\n            </component>\n
      \        </struct>\n      </dataTypeDef>\n      <dataTypeDef>\n         <name>VlanInputTableType</name>\n
      \        <synopsis>\n           Data type for the VLAN input table in EtherClassifier\n
      \          LFB.  The table is composed of an array of entries with\n           VlanInputTableEntryType.\n
      \        </synopsis>\n         <array type=\"variable-size\">\n           <typeRef>VlanInputTableEntryType</typeRef>\n
      \        </array>\n      </dataTypeDef>\n      <dataTypeDef>\n         <name>EtherClassifyStatsType</name>\n
      \        <synopsis>\n           Data type for entry of statistics table in EtherClassifier\n
      \          LFB.\n         </synopsis>\n         <struct>\n            <component
      componentID=\"1\">\n               <name>EtherType</name>\n               <synopsis>\n
      \               The Ethernet type of the Ethernet packet.\n               </synopsis>\n
      \              <typeRef>uint16</typeRef>\n            </component>\n            <component
      componentID=\"2\">\n               <name>Reserved</name>\n               <synopsis>\n
      \              A reserved bit space mainly for purpose of padding\n               and
      packing efficiency.\n               </synopsis>\n               <typeRef>uint16</typeRef>\n
      \           </component>\n            <component componentID=\"3\">\n               <name>PacketsNum</name>\n
      \              <synopsis>Packets number</synopsis>\n               <typeRef>uint64</typeRef>\n
      \           </component>\n         </struct>\n      </dataTypeDef>\n      <dataTypeDef>\n
      \        <name>EtherClassifyStatsTableType</name>\n         <synopsis>\n           Data
      type for statistics table in EtherClassifier LFB.\n         </synopsis>\n         <array
      type=\"variable-size\">\n           <typeRef>EtherClassifyStatsType</typeRef>\n
      \        </array>\n      </dataTypeDef>\n      <dataTypeDef>\n         <name>IPv4ValidatorStatsType</name>\n
      \        <synopsis>\n           Data type for statistics in IPv4validator LFB.\n
      \        </synopsis>\n         <struct>\n            <component componentID=\"1\">\n
      \              <name>badHeaderPkts</name>\n               <synopsis>Number of
      packets with bad header</synopsis>\n               <typeRef>uint64</typeRef>\n
      \           </component>\n            <component componentID=\"2\">\n               <name>badTotalLengthPkts</name>\n
      \              <synopsis>\n                 Number of packets with bad total
      length\n               </synopsis>\n               <typeRef>uint64</typeRef>\n
      \           </component>\n            <component componentID=\"3\">\n               <name>badTTLPkts</name>\n
      \              <synopsis>Number of packets with bad TTL</synopsis>\n               <typeRef>uint64</typeRef>\n
      \           </component>\n            <component componentID=\"4\">\n               <name>badChecksumPkts</name>\n
      \              <synopsis>Number of packets with bad checksum</synopsis>\n               <typeRef>uint64</typeRef>\n
      \           </component>\n         </struct>\n      </dataTypeDef>\n      <dataTypeDef>\n
      \        <name>IPv6ValidatorStatsType</name>\n         <synopsis>\n           Data
      type for statistics in IPv6validator LFB.\n         </synopsis>\n         <struct>\n
      \           <component componentID=\"1\">\n               <name>badHeaderPkts</name>\n
      \              <synopsis>Number of packets with bad header</synopsis>\n               <typeRef>uint64</typeRef>\n
      \           </component>\n            <component componentID=\"2\">\n               <name>badTotalLengthPkts</name>\n
      \              <synopsis>\n               Number of packets with bad total length.\n
      \              </synopsis>\n               <typeRef>uint64</typeRef>\n            </component>\n
      \           <component componentID=\"3\">\n               <name>badHopLimitPkts</name>\n
      \              <synopsis>\n               Number of packets with bad hop limit.\n
      \              </synopsis>\n               <typeRef>uint64</typeRef>\n            </component>\n
      \        </struct>\n      </dataTypeDef>\n      <dataTypeDef>\n         <name>IPv4PrefixInfoType</name>\n
      \        <synopsis>Data type for entry of IPv4 longest prefix match\n          table
      in IPv4UcastLPM LFB.  The destination IPv4 address\n          of every input
      packet is used as a search key to look up\n          the table to find out a
      next-hop selector.</synopsis>\n         <struct>\n            <component componentID=\"1\">\n
      \              <name>IPv4Address</name>\n               <synopsis>The destination
      IPv4 address</synopsis>\n               <typeRef>IPv4Addr</typeRef>\n            </component>\n
      \           <component componentID=\"2\">\n               <name>Prefixlen</name>\n
      \              <synopsis>The prefix length</synopsis>\n               <atomic>\n
      \                 <baseType>uchar</baseType>\n                  <rangeRestriction>\n
      \                    <allowedRange min=\"0\" max=\"32\"/>\n                  </rangeRestriction>\n
      \              </atomic>\n            </component>\n            <component componentID=\"3\">\n
      \              <name>ECMPFlag</name>\n               <synopsis>The ECMP flag</synopsis>\n
      \              <atomic>\n                  <baseType>boolean</baseType>\n                  <specialValues>\n
      \                    <specialValue value=\"false\">\n                        <name>False</name>\n
      \                       <synopsis>\n                         ECMP false, indicating
      the route\n                         does not have multiple next hops.\n                        </synopsis>\n
      \                    </specialValue>\n                     <specialValue value=\"true\">\n
      \                       <name>True</name>\n                        <synopsis>\n
      \                         ECMP true, indicating the route\n                          has
      multiple next hops.\n                        </synopsis>\n                     </specialValue>\n
      \                 </specialValues>\n               </atomic>\n            </component>\n
      \           <component componentID=\"4\">\n               <name>DefaultRouteFlag</name>\n
      \              <synopsis>Default route flag</synopsis>\n               <atomic>\n
      \                 <baseType>boolean</baseType>\n                  <specialValues>\n
      \                    <specialValue value=\"false\">\n                        <name>False</name>\n
      \                       <synopsis>\n                          Default route
      false, indicating the\n                          route is not a default route.\n
      \                       </synopsis>\n                     </specialValue>\n
      \                    <specialValue value=\"true\">\n                        <name>True</name>\n
      \                       <synopsis>\n                          Default route
      true, indicating the\n                          route is a default route.\n
      \                       </synopsis>\n                     </specialValue>\n
      \                 </specialValues>\n               </atomic>\n            </component>\n
      \           <component componentID=\"5\">\n               <name>Reserved</name>\n
      \              <synopsis>\n               A reserved bit space mainly for purpose
      of padding\n               and packing efficiency.\n               </synopsis>\n
      \              <typeRef>uchar</typeRef>\n            </component>\n            <component
      componentID=\"6\">\n               <name>HopSelector</name>\n               <synopsis>\n
      \                The HopSelector produced by the prefix matching LFB,\n                 which
      will be output to downstream LFB to find next-\n                 hop information.\n
      \              </synopsis>\n               <typeRef>uint32</typeRef>\n            </component>\n
      \        </struct>\n      </dataTypeDef>\n      <dataTypeDef>\n         <name>IPv4PrefixTableType</name>\n
      \        <synopsis>\n           Data type for IPv4 longest prefix match table
      in\n           IPv4UcastLPM LFB.  Entry of the table is\n           of IPv4PrefixInfoType
      data type.\n         </synopsis>\n         <array type=\"variable-size\">\n
      \          <typeRef>IPv4PrefixInfoType</typeRef>\n         </array>\n      </dataTypeDef>\n
      \     <dataTypeDef>\n         <name>IPv4UcastLPMStatsType</name>\n         <synopsis>\n
      \         Data type for statistics in IPv4UcastLPM LFB.\n         </synopsis>\n
      \        <struct>\n            <component componentID=\"1\">\n               <name>InRcvdPkts</name>\n
      \              <synopsis>Number of received input packets.</synopsis>\n               <typeRef>uint64</typeRef>\n
      \           </component>\n            <component componentID=\"2\">\n               <name>FwdPkts</name>\n
      \              <synopsis>Number of forwarded packets.</synopsis>\n               <typeRef>uint64</typeRef>\n
      \           </component>\n            <component componentID=\"3\">\n               <name>NoRoutePkts</name>\n
      \              <synopsis>\n                Number of packets with no route found.\n
      \              </synopsis>\n               <typeRef>uint64</typeRef>\n            </component>\n
      \        </struct>\n      </dataTypeDef>\n      <dataTypeDef>\n         <name>IPv6PrefixInfoType</name>\n
      \        <synopsis>Data type for entry of IPv6 longest prefix match\n          table
      in IPv6UcastLPM LFB.  The destination IPv6 address\n          of every input
      packet is used as a search key to look up\n          the table to find out a
      next-hop selector.</synopsis>\n         <struct>\n            <component componentID=\"1\">\n
      \              <name>IPv6Address</name>\n               <synopsis>The destination
      IPv6 address</synopsis>\n               <typeRef>IPv6Addr</typeRef>\n            </component>\n
      \           <component componentID=\"2\">\n               <name>Prefixlen</name>\n
      \              <synopsis>The prefix length</synopsis>\n               <atomic>\n
      \                 <baseType>uchar</baseType>\n                  <rangeRestriction>\n
      \                    <allowedRange min=\"0\" max=\"128\"/>\n                  </rangeRestriction>\n
      \              </atomic>\n            </component>\n            <component componentID=\"3\">\n
      \              <name>ECMPFlag</name>\n               <synopsis>ECMP flag</synopsis>\n
      \              <atomic>\n                  <baseType>boolean</baseType>\n                  <specialValues>\n
      \                    <specialValue value=\"false\">\n                        <name>False</name>\n
      \                       <synopsis>ECMP false</synopsis>\n                     </specialValue>\n
      \                    <specialValue value=\"true\">\n                        <name>True</name>\n
      \                       <synopsis>ECMP true</synopsis>\n                     </specialValue>\n
      \                 </specialValues>\n               </atomic>\n            </component>\n
      \           <component componentID=\"4\">\n               <name>DefaultRouteFlag</name>\n
      \              <synopsis>Default route flag</synopsis>\n               <atomic>\n
      \                 <baseType>boolean</baseType>\n                  <specialValues>\n
      \                    <specialValue value=\"false\">\n                        <name>False</name>\n
      \                       <synopsis>Default false</synopsis>\n                     </specialValue>\n
      \                    <specialValue value=\"true\">\n                        <name>True</name>\n
      \                       <synopsis>Default route true</synopsis>\n                     </specialValue>\n
      \                 </specialValues>\n               </atomic>\n            </component>\n
      \           <component componentID=\"5\">\n               <name>Reserved</name>\n
      \              <synopsis>\n               A reserved bit space mainly for purpose
      of padding\n               and packing efficiency.\n               </synopsis>\n
      \              <typeRef>uchar</typeRef>\n            </component>\n            <component
      componentID=\"6\">\n               <name>HopSelector</name>\n               <synopsis>\n
      \                The HopSelector produced by the prefix matching LFB,\n                 which
      will be output to downstream LFB to find next-\n                 hop information.\n
      \              </synopsis>\n               <typeRef>uint32</typeRef>\n            </component>\n
      \        </struct>\n      </dataTypeDef>\n      <dataTypeDef>\n         <name>IPv6PrefixTableType</name>\n
      \        <synopsis>\n           Data type for IPv6 longest prefix match table
      in\n           IPv6UcastLPM LFB.  Entry of the table is\n           of IPv6PrefixInfoType
      data type.\n         </synopsis>\n         <array type=\"variable-size\">\n
      \          <typeRef>IPv6PrefixInfoType</typeRef>\n         </array>\n      </dataTypeDef>\n
      \     <dataTypeDef>\n         <name>IPv6UcastLPMStatsType</name>\n         <synopsis>Data
      type for statistics in IPv6UcastLPM LFB\n         </synopsis>\n         <struct>\n
      \           <component componentID=\"1\">\n               <name>InRcvdPkts</name>\n
      \              <synopsis>Number of received input packets</synopsis>\n               <typeRef>uint64</typeRef>\n
      \           </component>\n            <component componentID=\"2\">\n               <name>FwdPkts</name>\n
      \              <synopsis>Number of forwarded packets</synopsis>\n               <typeRef>uint64</typeRef>\n
      \           </component>\n            <component componentID=\"3\">\n               <name>NoRoutePkts</name>\n
      \              <synopsis>\n                Number of packets with no route found.\n
      \              </synopsis>\n               <typeRef>uint64</typeRef>\n            </component>\n
      \        </struct>\n      </dataTypeDef>\n      <dataTypeDef>\n         <name>IPv4NextHopInfoType</name>\n
      \        <synopsis>\n           Data type for entry of IPv4 next-hop information
      table\n           in IPv4NextHop LFB.  The table uses a hop selector\n           received
      from upstream LFB as a search key to look up\n           index of the table
      to find the next-hop information.\n         </synopsis>\n         <struct>\n
      \           <component componentID=\"1\">\n               <name>L3PortID</name>\n
      \              <synopsis>\n                The ID of the logical output port
      that is to pass\n                onto downstream LFB, indicating what port to
      the\n                neighbor is as defined by L3.\n               </synopsis>\n
      \              <typeRef>uint32</typeRef>\n            </component>\n            <component
      componentID=\"2\">\n               <name>MTU</name>\n               <synopsis>\n
      \               Maximum Transmission Unit for outgoing port\n               </synopsis>\n
      \              <typeRef>uint32</typeRef>\n            </component>\n            <component
      componentID=\"3\">\n               <name>NextHopIPAddr</name>\n               <synopsis>The
      next-hop IPv4 address</synopsis>\n               <typeRef>IPv4Addr</typeRef>\n
      \           </component>\n            <component componentID=\"4\">\n               <name>MediaEncapInfoIndex</name>\n
      \              <synopsis>\n                 The index passed onto a downstream
      encapsulation\n                 LFB, used there as a search key to lookup further\n
      \                encapsulation information.\n               </synopsis>\n               <typeRef>uint32</typeRef>\n
      \           </component>\n            <component componentID=\"5\">\n               <name>LFBOutputSelectIndex</name>\n
      \               <synopsis>\n                  The index for the IPv4NextHop
      LFB to choose an\n                  instance in the group output port of the
      LFB to\n                  output.\n                </synopsis>\n               <typeRef>uint32</typeRef>\n
      \           </component>\n         </struct>\n      </dataTypeDef>\n      <dataTypeDef>\n
      \        <name>IPv4NextHopTableType</name>\n         <synopsis>\n           Data
      type for IPv4 next-hop table in IPv4NextHop LFB.\n           Entry of the table
      is of IPv4NextHopInfoType data type.\n         </synopsis>\n         <array
      type=\"variable-size\">\n           <typeRef>IPv4NextHopInfoType</typeRef>\n
      \        </array>\n      </dataTypeDef>\n      <dataTypeDef>\n         <name>IPv6NextHopInfoType</name>\n
      \        <synopsis>\n           Data type for entry of IPv6 next-hop information
      table\n           in IPv6NextHop LFB.  The table uses a hop selector\n           received
      from upstream LFB as a search key to look up\n           index of the table
      to find the next-hop information.\n         </synopsis>\n         <struct>\n
      \           <component componentID=\"1\">\n               <name>L3PortID</name>\n
      \              <synopsis>\n                The ID of the logical output port
      that is to pass\n                onto downstream LFB, indicating what port to
      the\n                neighbor is as defined by L3.\n               </synopsis>\n
      \              <typeRef>uint32</typeRef>\n            </component>\n            <component
      componentID=\"2\">\n               <name>MTU</name>\n               <synopsis>\n
      \                Maximum Transmission Unit for outgoing port\n               </synopsis>\n
      \              <typeRef>uint32</typeRef>\n            </component>\n            <component
      componentID=\"3\">\n               <name>NextHopIPAddr</name>\n               <synopsis>The
      next-hop IPv6 address</synopsis>\n               <typeRef>IPv6Addr</typeRef>\n
      \           </component>\n            <component componentID=\"4\">\n               <name>MediaEncapInfoIndex</name>\n
      \              <synopsis>\n                 The index passed onto a downstream
      encapsulation\n                 LFB, used there as a search key to lookup further\n
      \                encapsulation information.\n               </synopsis>\n               <typeRef>uint32</typeRef>\n
      \           </component>\n            <component componentID=\"5\">\n               <name>LFBOutputSelectIndex</name>\n
      \               <synopsis>\n                 The index for the IPv6NextHop LFB
      to choose an instance\n                 in the group output port of the LFB
      to output.\n                </synopsis>\n               <typeRef>uint32</typeRef>\n
      \           </component>\n         </struct>\n      </dataTypeDef>\n      <dataTypeDef>\n
      \        <name>IPv6NextHopTableType</name>\n         <synopsis>\n           Data
      type for IPv6 next-hop table in IPv6NextHop LFB.\n           Entry of the table
      is of IPv6NextHopInfoType data type.\n         </synopsis>\n         <array
      type=\"variable-size\">\n           <typeRef>IPv6NextHopInfoType</typeRef>\n
      \        </array>\n      </dataTypeDef>\n      <dataTypeDef>\n         <name>EncapTableEntryType</name>\n
      \        <synopsis>\n           Data type for entry of Ethernet encapsulation
      table in\n           EtherEncap LFB.  The LFB uses the MediaEncapInfoIndex\n
      \          received from upstream LFB as index of the table to\n           find
      encapsulation information of every packet.\n         </synopsis>\n         <struct>\n
      \           <component componentID=\"1\">\n               <name>DstMac</name>\n
      \              <synopsis>\n                 Destination MAC address for Ethernet
      encapsulation of\n                 the packet.\n               </synopsis>\n
      \              <typeRef>IEEEMAC</typeRef>\n            </component>\n            <component
      componentID=\"2\">\n               <name>SrcMac</name>\n               <synopsis>\n
      \                Source MAC address for Ethernet encapsulation of the\n                 packet.\n
      \              </synopsis>\n               <typeRef>IEEEMAC</typeRef>\n            </component>\n
      \           <component componentID=\"3\">\n               <name>VlanID</name>\n
      \              <synopsis>The VLAN ID assigned to the packet</synopsis>\n               <typeRef>VlanIDType</typeRef>\n
      \           </component>\n             <component componentID=\"4\">\n               <name>Reserved</name>\n
      \              <synopsis>\n                A reserved bit space mainly for purpose
      of padding\n                and packing efficiency.\n               </synopsis>\n
      \              <typeRef>uint16</typeRef>\n            </component>\n            <component
      componentID=\"5\">\n               <name>L2PortID</name>\n               <synopsis>\n
      \                The L2 logical output port ID for the packet.\n               </synopsis>\n
      \              <typeRef>uint32</typeRef>\n            </component>\n         </struct>\n
      \     </dataTypeDef>\n      <dataTypeDef>\n         <name>EncapTableType</name>\n
      \        <synopsis>\n           Data type for Ethernet encapsulation table in
      EtherEncap\n           LFB.  Entry of the table is of EncapTableEntryType data\n
      \          type.\n         </synopsis>\n         <array type=\"variable-size\">\n
      \          <typeRef>EncapTableEntryType</typeRef>\n         </array>\n      </dataTypeDef>\n
      \     <dataTypeDef>\n         <name>MetadataDispatchType</name>\n         <synopsis>\n
      \          Data type for entry of metadata dispatch table used in\n           BasicMetadataDispatch
      LFB.  The LFB uses a metadata value\n           as a search key to look up the
      table to find an index of\n           the LFB group output port to output the
      packet.\n         </synopsis>\n         <struct>\n            <component componentID=\"1\">\n
      \              <name>MetadataValue</name>\n               <synopsis>The value
      of the dispatch metadata</synopsis>\n               <typeRef>uint32</typeRef>\n
      \           </component>\n            <component componentID=\"2\">\n               <name>OutputIndex</name>\n
      \              <synopsis>\n                 Index of a group output port for
      outgoing packets.\n               </synopsis>\n               <typeRef>uint32</typeRef>\n
      \           </component>\n         </struct>\n      </dataTypeDef>\n      <dataTypeDef>\n
      \        <name>MetadataDispatchTableType</name>\n         <synopsis>\n           Data
      type for metadata dispatch table used in\n           BasicMetadataDispatch LFB.
      \ Metadata value of\n           the table is also defined as a content key field.\n
      \        </synopsis>\n         <array type=\"variable-size\">\n           <typeRef>MetadataDispatchType</typeRef>\n
      \          <contentKey contentKeyID=\"1\">\n           <contentKeyField>MetadataValue</contentKeyField>\n
      \          </contentKey>\n         </array>\n      </dataTypeDef>\n      <dataTypeDef>\n
      \        <name>SchdDisciplineType</name>\n         <synopsis>Scheduling discipline
      type</synopsis>\n         <atomic>\n            <baseType>uint32</baseType>\n
      \           <specialValues>\n               <specialValue value=\"1\">\n                  <name>RR</name>\n
      \                 <synopsis>\n                    Round Robin scheduling discipline\n
      \                 </synopsis>\n               </specialValue>\n            </specialValues>\n
      \        </atomic>\n      </dataTypeDef>\n      <dataTypeDef>\n         <name>QueueStatsType</name>\n
      \        <synopsis>\n           Data type for entry of queue statistics table
      in\n           GenericScheduler LFB.\n         </synopsis>\n         <struct>\n
      \           <component componentID=\"1\">\n               <name>QueueID</name>\n
      \              <synopsis>The input queue ID</synopsis>\n               <typeRef>uint32</typeRef>\n
      \           </component>\n            <component componentID=\"2\">\n               <name>QueueDepthInPackets</name>\n
      \              <synopsis>Current queue depth in packets</synopsis>\n               <typeRef>uint32</typeRef>\n
      \           </component>\n            <component componentID=\"3\">\n               <name>QueueDepthInBytes</name>\n
      \              <synopsis>Current queue depth in bytes</synopsis>\n               <typeRef>uint32</typeRef>\n
      \           </component>\n         </struct>\n      </dataTypeDef>\n      <dataTypeDef>\n
      \        <name>QueueStatsTableType</name>\n         <synopsis>\n           Data
      type for queue statistics table in GenericScheduler\n           LFB.  Entry
      of the table is of QueueStatsType data type.\n         </synopsis>\n         <array
      type=\"variable-size\">\n           <typeRef>QueueStatsType</typeRef>\n         </array>\n
      \     </dataTypeDef>\n   </dataTypeDefs>\n   <metadataDefs>\n      <metadataDef>\n
      \        <name>PHYPortID</name>\n         <synopsis>Metadata indicating physical
      port ID</synopsis>\n         <metadataID>1</metadataID>\n         <typeRef>uint32</typeRef>\n
      \     </metadataDef>\n      <metadataDef>\n         <name>SrcMAC</name>\n         <synopsis>Metadata
      indicating source MAC address</synopsis>\n         <metadataID>2</metadataID>\n
      \        <typeRef>IEEEMAC</typeRef>\n      </metadataDef>\n      <metadataDef>\n
      \        <name>DstMAC</name>\n         <synopsis>\n           Metadata indicating
      destination MAC address.\n         </synopsis>\n         <metadataID>3</metadataID>\n
      \        <typeRef>IEEEMAC</typeRef>\n      </metadataDef>\n      <metadataDef>\n
      \        <name>LogicalPortID</name>\n         <synopsis>Metadata of logical
      port ID</synopsis>\n         <metadataID>4</metadataID>\n         <typeRef>uint32</typeRef>\n
      \     </metadataDef>\n      <metadataDef>\n         <name>EtherType</name>\n
      \        <synopsis>Metadata indicating Ethernet type</synopsis>\n         <metadataID>5</metadataID>\n
      \        <typeRef>uint16</typeRef>\n      </metadataDef>\n      <metadataDef>\n
      \        <name>VlanID</name>\n         <synopsis>Metadata of VLAN ID</synopsis>\n
      \        <metadataID>6</metadataID>\n         <typeRef>VlanIDType</typeRef>\n
      \     </metadataDef>\n      <metadataDef>\n         <name>VlanPriority</name>\n
      \        <synopsis>Metadata of VLAN priority</synopsis>\n         <metadataID>7</metadataID>\n
      \        <typeRef>VlanPriorityType</typeRef>\n      </metadataDef>\n      <metadataDef>\n
      \        <name>NextHopIPv4Addr</name>\n         <synopsis>\n           Metadata
      representing a next-hop IPv4 address\n         </synopsis>\n         <metadataID>8</metadataID>\n
      \        <typeRef>IPv4Addr</typeRef>\n      </metadataDef>\n      <metadataDef>\n
      \        <name>NextHopIPv6Addr</name>\n         <synopsis>\n           Metadata
      representing a next-hop IPv6 address\n         </synopsis>\n         <metadataID>9</metadataID>\n
      \        <typeRef>IPv6Addr</typeRef>\n      </metadataDef>\n      <metadataDef>\n
      \        <name>HopSelector</name>\n         <synopsis>Metadata indicating a
      hop selector</synopsis>\n         <metadataID>10</metadataID>\n         <typeRef>uint32</typeRef>\n
      \     </metadataDef>\n      <metadataDef>\n         <name>ExceptionID</name>\n
      \        <synopsis>\n           Metadata indicating exception types for exceptional
      cases\n           during packet processing.\n         </synopsis>\n         <metadataID>11</metadataID>\n
      \        <atomic>\n            <baseType>uint32</baseType>\n            <specialValues>\n
      \               <specialValue value=\"0\">\n                  <name>AnyUnrecognizedExceptionCase</name>\n
      \                 <synopsis>Any unrecognized exception case</synopsis>\n                  </specialValue>\n
      \               <specialValue value=\"1\">\n                  <name>ClassifyNoMatching</name>\n
      \                 <synopsis>\n                   Exception case: no matching
      of tables in\n                   EtherClassifier LFB.\n                  </synopsis>\n
      \               </specialValue>\n                <specialValue value=\"2\">\n
      \                 <name>MediaEncapInfoIndexInvalid</name>\n                  <synopsis>\n
      \                  Exception case: the MediaEncapInfoIndex value of\n                   the
      packet is invalid and cannot be allocated in\n                   the EncapTable
      in EtherEncap LFB.\n                  </synopsis>\n                </specialValue>\n
      \               <specialValue value=\"3\">\n                  <name>EncapTableLookupFailed</name>\n
      \                 <synopsis>\n                   Exception case: the packet
      fails lookup of the\n                   EncapTable table in EtherEncap LFB even
      though the\n                   MediaEncapInfoIndex is valid.\n                  </synopsis>\n
      \               </specialValue>\n                <specialValue value=\"4\">\n
      \                 <name>BadTTL</name>\n                  <synopsis>\n                   Exception
      case: packet with expired TTL\n                  </synopsis>\n                </specialValue>\n
      \               <specialValue value=\"5\">\n                  <name>IPv4HeaderLengthMismatch</name>\n
      \                 <synopsis>\n                   Exception case: packet with
      header length more\n                   than 5 words.\n                  </synopsis>\n
      \               </specialValue>\n                <specialValue value=\"6\">\n
      \                  <name>RouterAlertOptions</name>\n                   <synopsis>\n
      \                   Exception case: packet IP head includes router\n                    alert
      options.\n                   </synopsis>\n                </specialValue>\n
      \               <specialValue value=\"7\">\n                   <name>IPv6HopLimitZero</name>\n
      \                  <synopsis>\n                    Exception case: packet with
      the hop limit to zero.\n                   </synopsis>\n                </specialValue>\n
      \               <specialValue value=\"8\">\n                   <name>IPv6NextHeaderHBH</name>\n
      \                  <synopsis>\n                    Exception case: packet with
      next header set to\n                    Hop-by-Hop.\n                   </synopsis>\n
      \               </specialValue>\n                <specialValue value=\"9\">\n
      \                  <name>SrcAddressException</name>\n                   <synopsis>\n
      \                   Exception case: packet with exceptional source\n                    address.\n
      \                  </synopsis>\n                </specialValue>\n                <specialValue
      value=\"10\">\n                   <name>DstAddressException</name>\n                   <synopsis>\n
      \                   Exception case: packet with exceptional destination\n                    address.\n
      \                  </synopsis>\n                </specialValue>\n                <specialValue
      value=\"11\">\n                   <name>LPMLookupFailed</name>\n                   <synopsis>\n
      \                   Exception case: packet failed the LPM table lookup\n                    in
      a prefix match LFB.\n                   </synopsis>\n                </specialValue>\n
      \               <specialValue value=\"12\">\n                   <name>HopSelectorInvalid</name>\n
      \                  <synopsis>\n                    Exception case: HopSelector
      for the packet is\n                    invalid.\n                   </synopsis>\n
      \               </specialValue>\n                <specialValue value=\"13\">\n
      \                  <name>NextHopLookupFailed</name>\n                   <synopsis>\n
      \                   Exception case: packet failed lookup of a next-hop\n                    table
      even though HopSelector is valid.\n                   </synopsis>\n                </specialValue>\n
      \               <specialValue value=\"14\">\n                   <name>FragRequired</name>\n
      \                  <synopsis>\n                    Exception case: packet fragmentation
      is required\n                   </synopsis>\n                </specialValue>\n
      \               <specialValue value=\"15\">\n                   <name>MetadataNoMatching</name>\n
      \                  <synopsis>\n                    Exception case: there is
      no matching when looking\n                    up the metadata dispatch table
      in\n                    BasicMetadataDispatch LFB.\n                   </synopsis>\n
      \               </specialValue>\n             </specialValues>\n          </atomic>\n
      \     </metadataDef>\n      <metadataDef>\n          <name>ValidateErrorID</name>\n
      \         <synopsis>\n            Metadata indicating error types when a packet
      passes\n            validation process.\n          </synopsis>\n          <metadataID>12</metadataID>\n
      \         <atomic>\n             <baseType>uint32</baseType>\n             <specialValues>\n
      \               <specialValue value=\"0\">\n                   <name>AnyUnrecognizedValidateErrorCase</name>\n
      \                  <synopsis>\n                     Any unrecognized validate
      error case.\n                   </synopsis>\n                </specialValue>\n
      \               <specialValue value=\"1\">\n                   <name>InvalidIPv4PacketSize</name>\n
      \                  <synopsis>\n                    Error case: packet length
      reported by the link\n                    layer is less than 20 bytes.\n                   </synopsis>\n
      \               </specialValue>\n                <specialValue value=\"2\">\n
      \                  <name>NotIPv4Packet</name>\n                   <synopsis>\n
      \                   Error case: packet is not IP version 4</synopsis>\n                </specialValue>\n
      \               <specialValue value=\"3\">\n                   <name>InvalidIPv4HeaderLengthSize</name>\n
      \                  <synopsis>\n                    Error case: packet with header
      length field in\n                    the header less than 5 words.\n                   </synopsis>\n
      \               </specialValue>\n                <specialValue value=\"4\">\n
      \                  <name>InvalidIPv4LengthFieldSize</name>\n                   <synopsis>\n
      \                   Error case: packet with total length field in the\n                    header
      less than 20 bytes.\n                   </synopsis>\n                </specialValue>\n
      \               <specialValue value=\"5\">\n                   <name>InvalidIPv4Checksum</name>\n
      \                  <synopsis>\n                    Error case: packet with invalid
      checksum.\n                    </synopsis>\n                </specialValue>\n
      \               <specialValue value=\"6\">\n                   <name>InvalidIPv4SrcAddr</name>\n
      \                  <synopsis>\n                    Error case: packet with invalid
      IPv4 source\n                    address.\n                   </synopsis>\n
      \               </specialValue>\n                <specialValue value=\"7\">\n
      \                  <name>InvalidIPv4DstAddr</name>\n                   <synopsis>\n
      \                   Error case: packet with invalid IPv4 destination\n                    address.\n
      \                  </synopsis>\n                </specialValue>\n                <specialValue
      value=\"8\">\n                   <name>InvalidIPv6PacketSize</name>\n                   <synopsis>\n
      \                   Error case: packet size is less than 40 bytes.\n                   </synopsis>\n
      \               </specialValue>\n                <specialValue value=\"9\">\n
      \                  <name>NotIPv6Packet</name>\n                   <synopsis>\n
      \                   Error case: packet is not IP version 6\n                    </synopsis>\n
      \               </specialValue>\n                <specialValue value=\"10\">\n
      \                  <name>InvalidIPv6SrcAddr</name>\n                   <synopsis>\n
      \                   Error case: packet with invalid IPv6 source address.\n                   </synopsis>\n
      \               </specialValue>\n                <specialValue value=\"11\">\n
      \                  <name>InvalidIPv6DstAddr</name>\n                   <synopsis>\n
      \                   Error case: packet with invalid IPv6 destination\n                    address.\n
      \                  </synopsis>\n                </specialValue>\n             </specialValues>\n
      \         </atomic>\n      </metadataDef>\n      <metadataDef>\n         <name>L3PortID</name>\n
      \        <synopsis>\n           Metadata indicating ID of an L3 logical port\n
      \        </synopsis>\n         <metadataID>13</metadataID>\n         <typeRef>uint32</typeRef>\n
      \     </metadataDef>\n      <metadataDef>\n         <name>RedirectIndex</name>\n
      \        <synopsis>\n           Metadata that CE sends to RedirectIn LFB, indicating\n
      \          the index of the LFB group output port.\n         </synopsis>\n         <metadataID>14</metadataID>\n
      \        <typeRef>uint32</typeRef>\n      </metadataDef>\n      <metadataDef>\n
      \        <name>MediaEncapInfoIndex</name>\n         <synopsis>\n           A
      search key a packet uses to look up a table to select\n           an encapsulation
      media.\n         </synopsis>\n         <metadataID>15</metadataID>\n         <typeRef>uint32</typeRef>\n
      \     </metadataDef>\n   </metadataDefs>\n"
    - '</LFBLibrary>

      '
    title: 4.4.  XML for Base Type Library
  title: 4.  Base Types
- contents:
  - "5.  LFB Class Descriptions\n   According to ForCES specifications, an LFB (Logical
    Function Block)\n   is a well-defined, logically separable functional block that
    resides\n   in an FE and is a functionally accurate abstraction of the FE's\n
    \  processing capabilities.  An LFB class (or type) is a template that\n   represents
    a fine-grained, logically separable aspect of FE\n   processing.  Most LFBs are
    related to packet processing in the data\n   path.  LFB classes are the basic
    building blocks of the FE model.\n   Note that [RFC5810] has already defined an
    'FE Protocol LFB', which\n   is a logical entity in each FE to control the ForCES
    protocol.\n   [RFC5812] has already defined an 'FE Object LFB'.  Information like\n
    \  the FE Name, FE ID, FE State, and LFB Topology in the FE are\n   represented
    in this LFB.\n   As specified in Section 3.1, this document focuses on the base
    LFB\n   library for implementing typical router functions, especially for IP\n
    \  forwarding functions.  As a result, LFB classes in the library are\n   all
    base LFBs to implement router forwarding.\n   In this section, the terms \"upstream
    LFB\" and \"downstream LFB\" are\n   used.  These are used relative to the LFB
    that is being described.\n   An \"upstream LFB\" is one whose output ports are
    connected to input\n   ports of the LFB under consideration such that output (typically\n
    \  packets with metadata) can be sent from the \"upstream LFB\" to the LFB\n   under
    consideration.  Similarly, a \"downstream LFB\" whose input ports\n   are connected
    to output ports of the LFB under consideration such\n   that the LFB under consideration
    can send information to the\n   \"downstream LFB\".  Note that in some rare topologies,
    an LFB may be\n   both upstream and downstream relative to another LFB.\n   Also
    note that, as a default provision of [RFC5812], in the FE model,\n   all metadata
    produced by upstream LFBs will pass through all\n   downstream LFBs by default
    without being specified by input port or\n   output port.  Only those metadata
    that will be used (consumed) by an\n   LFB will be explicitly marked in the input
    of the LFB as expected\n   metadata.  For instance, in downstream LFBs of a physical-layer
    LFB,\n   even if there is no specific metadata expected, metadata like\n   PHYPortID
    produced by the physical-layer LFB will always pass through\n   all downstream
    LFBs regardless of whether or not the metadata has\n   been expected by the LFBs.\n"
  - contents:
    - "5.1.  Ethernet-Processing LFBs\n   As the most popular physical- and data-link-layer
      protocol, Ethernet\n   is widely deployed.  It becomes a basic requirement for
      a router to\n   be able to process various Ethernet data packets.\n   Note that
      different versions of Ethernet formats exist, like Ethernet\n   V2, 802.3 RAW,
      IEEE 802.3/802.2, and IEEE 802.3/802.2 SNAP.\n   Varieties of LAN techniques
      based on Ethernet also exist, like\n   various VLANs, MACinMAC, etc.  Ethernet-processing
      LFBs defined here\n   are intended to be able to cope with all these variations
      of Ethernet\n   technology.\n   There are also various types of Ethernet physical
      interface media.\n   Among them, copper and fiber media may be the most popular
      ones.  As\n   a base LFB definition and a starting point, this document only\n
      \  defines an Ethernet physical LFB with copper media.  For other media\n   interfaces,
      specific LFBs may be defined in future versions of the\n   library.\n"
    - contents:
      - "5.1.1.  EtherPHYCop\n   EtherPHYCop LFB abstracts an Ethernet interface physical
        layer with\n   media limited to copper.\n"
      - contents:
        - "5.1.1.1.  Data Handling\n   This LFB is the interface to the Ethernet physical
          media.  The LFB\n   handles Ethernet frames coming in from or going out
          of the FE.\n   Ethernet frames sent and received cover all packets encapsulated
          with\n   different versions of Ethernet protocols, like Ethernet V2, 802.3\n
          \  RAW, IEEE 802.3/802.2, and IEEE 802.3/802.2 SNAP, including packets\n
          \  encapsulated with varieties of LAN techniques based on Ethernet, like\n
          \  various VLANs, MACinMAC, etc.  Therefore, in the XML, an EthernetAll\n
          \  frame type has been introduced.\n   Ethernet frames are received from
          the physical media port and passed\n   downstream to LFBs, such as EtherMACIn
          LFBs, via a singleton output\n   known as \"EtherPHYOut\".  A PHYPortID
          metadata, which indicates the\n   physical port from which the frame came
          in from the external world,\n   is passed along with the frame.\n   Ethernet
          packets are received by this LFB from upstream LFBs, such as\n   EtherMacOut
          LFBs, via the singleton input known as \"EtherPHYIn\"\n   before being sent
          out to the external world.\n"
        title: 5.1.1.1.  Data Handling
      - contents:
        - "5.1.1.2.  Components\n   The AdminStatus component is defined for the CE
          to administratively\n   manage the status of the LFB.  The CE may administratively
          start up\n   or shut down the LFB by changing the value of AdminStatus.
          \ The\n   default value is set to 'Down'.\n   An OperStatus component captures
          the physical port operational\n   status.  A PHYPortStatusChanged event
          is defined so the LFB can\n   report to the CE whenever there is an operational
          status change of\n   the physical port.\n   The PHYPortID component is a
          unique identification for a physical\n   port.  It is defined as 'read-only'
          by the CE.  Its value is\n   enumerated by FE.  The component will be used
          to produce a PHYPortID\n   metadata at the LFB output and to associate it
          to every Ethernet\n   packet this LFB receives.  The metadata will be handed
          to downstream\n   LFBs for them to use the PHYPortID.\n   A group of components
          are defined for link speed management.  The\n   AdminLinkSpeed is for the
          CE to configure link speed for the port,\n   and the OperLinkSpeed is for
          the CE to query the actual link speed in\n   operation.  The default value
          for the AdminLinkSpeed is set to auto-\n   negotiation mode.\n   A group
          of components are defined for duplex mode management.  The\n   AdminDuplexMode
          is for the CE to configure proper duplex mode for the\n   port, and the
          OperDuplexMode is for CE to query the actual duplex\n   mode in operation.
          \ The default value for the AdminDuplexMode is set\n   to auto-negotiation
          mode.\n   A CarrierStatus component captures the status of the carrier and\n
          \  specifies whether the port link is operationally up.  The default\n   value
          for the CarrierStatus is 'false'.\n"
        title: 5.1.1.2.  Components
      - contents:
        - "5.1.1.3.  Capabilities\n   The capability information for this LFB includes
          the link speeds that\n   are supported by the FE (SupportedLinkSpeed) as
          well as the supported\n   duplex modes (SupportedDuplexMode).\n"
        title: 5.1.1.3.  Capabilities
      - contents:
        - "5.1.1.4.  Events\n   Several events are generated.  There is an event for
          changes in the\n   status of the physical port (PhyPortStatusChanged).  Such
          an event\n   will notify that the physical port status has been changed,
          and the\n   report will include the new status of the physical port.\n   Another
          event captures changes in the operational link speed\n   (LinkSpeedChanged).
          \ Such an event will notify the CE that the\n   operational speed has been
          changed, and the report will include the\n   new negotiated operational
          speed.\n   A final event captures changes in the duplex mode\n   (DuplexModeChanged).
          \ Such an event will notify the CE that the\n   duplex mode has been changed
          and the report will include the new\n   negotiated duplex mode.\n"
        title: 5.1.1.4.  Events
      title: 5.1.1.  EtherPHYCop
    - contents:
      - "5.1.2.  EtherMACIn\n   EtherMACIn LFB abstracts an Ethernet port at the MAC
        data link layer.\n   This LFB describes Ethernet processing functions like
        checking MAC\n   address locality, deciding if the Ethernet packets should
        be bridged,\n   providing Ethernet-layer flow control, etc.\n"
      - contents:
        - "5.1.2.1.  Data Handling\n   The LFB is expected to receive all types of
          Ethernet packets (via a\n   singleton input known as \"EtherPktsIn\"), which
          are usually output\n   from some Ethernet physical-layer LFB, like an EtherPHYCop
          LFB, along\n   with a metadata indicating the physical port ID of the port
          on which\n   the packet arrived.\n   The LFB is defined with two separate
          singleton outputs.  All output\n   packets are emitted in the original Ethernet
          format received at the\n   physical port, unchanged, and cover all Ethernet
          types.\n   The first singleton output is known as \"NormalPathOut\".  It
          usually\n   outputs Ethernet packets to some LFB, like an EtherClassifier
          LFB,\n   for further L3 forwarding process along with a PHYPortID metadata\n
          \  indicating the physical port from which the packet came.\n   The second
          singleton output is known as \"L2BridgingPathOut\".\n   Although the LFB
          library this document defines is basically to meet\n   typical router functions,
          it will attempt to be forward compatible\n   with future router functions.
          \ The L2BridgingPathOut is defined to\n   meet the requirement that L2 bridging
          functions may be optionally\n   supported simultaneously with L3 processing
          and some L2 bridging LFBs\n   that may be defined in the future.  If the
          FE supports L2 bridging,\n   the CE can enable or disable it by means of
          a \"L2BridgingPathEnable\"\n   component in the FE.  If it is enabled, by
          also instantiating some L2\n   bridging LFB instances following the L2BridgingPathOut,
          FEs are\n   expected to fulfill L2 bridging functions.  L2BridgingPathOut
          will\n   output packets exactly the same as in the NormalPathOut output.\n
          \  This LFB can be set to work in a promiscuous mode, allowing all\n   packets
          to pass through the LFB without being dropped.  Otherwise, a\n   locality
          check will be performed based on the local MAC addresses.\n   All packets
          that do not pass through the locality check will be\n   dropped.\n   This
          LFB can optionally participate in Ethernet flow control in\n   cooperation
          with EtherMACOut LFB.  This document does not go into the\n   details of
          how this is implemented.  This document also does not\n   describe how the
          buffers that induce the flow control messages behave\n   -- it is assumed
          that such artifacts exist, and describing them is\n   out of scope in this
          document.\n"
        title: 5.1.2.1.  Data Handling
      - contents:
        - "5.1.2.2.  Components\n   The AdminStatus component is defined for the CE
          to administratively\n   manage the status of the LFB.  The CE may administratively
          start up\n   or shut down the LFB by changing the value of AdminStatus.
          \ The\n   default value is set to 'Down'.\n   The LocalMACAddresses component
          specifies the local MAC addresses\n   based on which locality checks will
          be made.  This component is an\n   array of MAC addresses and of 'read-write'
          access permission.\n   An L2BridgingPathEnable component captures whether
          the LFB is set to\n   work as an L2 bridge.  An FE that does not support
          bridging will\n   internally set this flag to false and additionally set
          the flag\n   property as read-only.  The default value for the component
          is\n   'false'.\n   The PromiscuousMode component specifies whether the
          LFB is set to\n   work in a promiscuous mode.  The default value for the
          component is\n   'false'.\n   The TxFlowControl component defines whether
          the LFB is performing\n   flow control on sending packets.  The default
          value is 'false'.  Note\n   that the component is defined as \"optional\".
          \ If an FE does not\n   implement the component while a CE tries to configure
          the component\n   to that FE, an error from the FE may be responded to the
          CE with an\n   error code like 0x09 (E_COMPONENT_DOES_NOT_EXIST) or 0x15\n
          \  (E_NOT_SUPPORTED), depending on the FE processing.  See [RFC5810] for\n
          \  details.\n   The RxFlowControl component defines whether the LFB is performing\n
          \  flow control on receiving packets.  The default value is 'false'.\n   The
          component is defined as \"optional\".\n   A struct component, MACInStats,
          defines a set of statistics for this\n   LFB, including the number of received
          packets and the number of\n   dropped packets.  Note that this statistics
          component is optional to\n   implementers.  If a CE tries to query the component
          while it is not\n   implemented in an FE, an error code will be responded
          to the CE\n   indicating the error type like 0x09 (E_COMPONENT_DOES_NOT_EXIST)
          or\n   0x15 (E_NOT_SUPPORTED), depending on the FE implementation.\n"
        title: 5.1.2.2.  Components
      - contents:
        - "5.1.2.3.  Capabilities\n   This LFB does not have a list of capabilities.\n"
        title: 5.1.2.3.  Capabilities
      - contents:
        - "5.1.2.4.  Events\n   This LFB does not have any events specified.\n"
        title: 5.1.2.4.  Events
      title: 5.1.2.  EtherMACIn
    - contents:
      - "5.1.3.  EtherClassifier\n   The EtherClassifier LFB abstracts the process
        to decapsulate Ethernet\n   packets and then classify them.\n"
      - contents:
        - "5.1.3.1.  Data Handling\n   This LFB describes the process of decapsulating
          Ethernet packets and\n   classifying them into various network-layer data
          packets according to\n   information included in the Ethernet packets headers.\n
          \  The LFB is expected to receive all types of Ethernet packets (via a\n
          \  singleton input known as \"EtherPktsIn\"), which are usually output\n
          \  from an upstream LFB like EtherMACIn LFB.  This input is also capable\n
          \  of multiplexing to allow for multiple upstream LFBs to be connected.\n
          \  For instance, when an L2 bridging function is enabled in the\n   EtherMACIn
          LFB, some L2 bridging LFBs may be applied.  In this case,\n   after L2 processing,
          some Ethernet packets may have to be input to\n   the EtherClassifier LFB
          for classification, while simultaneously,\n   packets directly output from
          EtherMACIn may also need to input to\n   this LFB.  This input is capable
          of handling such a case.  Usually,\n   all expected Ethernet packets will
          be associated with a PHYPortID\n   metadata, indicating the physical port
          from which the packet comes.\n   In some cases, for instance, in a MACinMAC
          case, a LogicalPortID\n   metadata may be expected to associate with the
          Ethernet packet to\n   further indicate the logical port to which the Ethernet
          packet\n   belongs.  Note that PHYPortID metadata is always expected while\n
          \  LogicalPortID metadata is optionally expected.\n   Two output LFB ports
          are defined.\n   The first output is a group output port known as \"ClassifyOut\".\n
          \  Types of network-layer protocol packets are output to instances of\n
          \  the port group.  Because there may be various types of protocol\n   packets
          at the output ports, the produced output frame is defined as\n   arbitrary
          for the purpose of wide extensibility in the future.\n   Metadata to be
          carried along with the packet data is produced at this\n   LFB for consumption
          by downstream LFBs.  The metadata passed\n   downstream includes PHYPortID,
          as well as information on Ethernet\n   type, source MAC address, destination
          MAC address, and the logical\n   port ID.  If the original packet is a VLAN
          packet and contains a VLAN\n   ID and a VLAN priority value, then the VLAN
          ID and the VLAN priority\n   value are also carried downstream as metadata.
          \ As a result, the VLAN\n   ID and priority metadata are defined with the
          availability of\n   \"conditional\".\n   The second output is a singleton
          output port known as \"ExceptionOut\",\n   which will output packets for
          which the data processing failed, along\n   with an additional ExceptionID
          metadata to indicate what caused the\n   exception.  Currently defined exception
          types include:\n   o  There is no matching when classifying the packet.\n
          \  Usually, the ExceptionOut port may point to nowhere, indicating\n   packets
          with exceptions are dropped, while in some cases, the output\n   may be
          pointed to the path to the CE for further processing,\n   depending on individual
          implementations.\n"
        title: 5.1.3.1.  Data Handling
      - contents:
        - "5.1.3.2.  Components\n   An EtherDispatchTable array component is defined
          in the LFB to\n   dispatch every Ethernet packet to the output group according
          to the\n   logical port ID assigned by the VlanInputTable to the packet
          and the\n   Ethernet type in the Ethernet packet header.  Each row of the
          array\n   is a struct containing a logical port ID, an EtherType and an
          output\n   index.  With the CE configuring the dispatch table, the LFB can
          be\n   expected to classify various network-layer protocol type packets
          and\n   output them at different output ports.  It is expected that the
          LFB\n   classify packets according to protocols like IPv4, IPv6, MPLS,\n
          \  Address Resolution Protocol (ARP), Neighbor Discovery (ND), etc.\n   A
          VlanInputTable array component is defined in the LFB to classify\n   VLAN
          Ethernet packets.  Each row of the array is a struct containing\n   an incoming
          port ID, a VLAN ID, and a logical port ID.  According to\n   IEEE VLAN specifications,
          all Ethernet packets can be recognized as\n   VLAN types by defining that
          if there is no VLAN encapsulation in a\n   packet, a case with VLAN tag
          0 is considered.  Every input packet is\n   assigned with a new LogicalPortID
          according to the packet's incoming\n   port ID and the VLAN ID.  A packet's
          incoming port ID is defined as a\n   logical port ID if a logical port ID
          is associated with the packet or\n   a physical port ID if no logical port
          ID is associated.  The VLAN ID\n   is exactly the VLAN ID in the packet
          if it is a VLAN packet, or 0 if\n   it is not.  Note that a logical port
          ID of a packet may be rewritten\n   with a new one by the VlanInputTable
          processing.\n   Note that the logical port ID and physical port ID mentioned
          above\n   are all originally configured by the CE, and are globally effective\n
          \  within a ForCES NE (Network Element).  To distinguish a physical port\n
          \  ID from a logical port ID in the incoming port ID field of the\n   VlanInputTable,
          physical port ID and logical port ID must be assigned\n   with separate
          number spaces.\n   An array component, EtherClassifyStats, defines a set
          of statistics\n   for this LFB, measuring the number of packets per EtherType.
          \ Each\n   row of the array is a struct containing an EtherType and a packet\n
          \  number.  Note that this statistics component is optional to\n   implementers.\n"
        title: 5.1.3.2.  Components
      - contents:
        - "5.1.3.3.  Capabilities\n   This LFB does not have a list of capabilities.\n"
        title: 5.1.3.3.  Capabilities
      - contents:
        - "5.1.3.4.  Events\n   This LFB has no events specified.\n"
        title: 5.1.3.4.  Events
      title: 5.1.3.  EtherClassifier
    - contents:
      - "5.1.4.  EtherEncap\n   The EtherEncap LFB abstracts the process to replace
        or attach\n   appropriate Ethernet headers to the packet.\n"
      - contents:
        - "5.1.4.1.  Data Handling\n   This LFB abstracts the process of encapsulating
          Ethernet headers onto\n   received packets.  The encapsulation is based
          on passed metadata.\n   The LFB is expected to receive IPv4 and IPv6 packets
          (via a singleton\n   input port known as \"EncapIn\"), which may be connected
          to an upstream\n   LFB like IPv4NextHop, IPv6NextHop, BasicMetadataDispatch,
          or any LFB\n   that requires output packets for Ethernet encapsulation.
          \ The LFB\n   always expects from upstream LFBs the MediaEncapInfoIndex
          metadata,\n   which is used as a search key to look up the encapsulation
          table\n   EncapTable by the search key matching the table index.  An input\n
          \  packet may also optionally receive a VLAN priority metadata,\n   indicating
          that the packet originally had a priority value.  The\n   priority value
          will be loaded back to the packet when encapsulating.\n   The optional VLAN
          priority metadata is defined with a default value\n   of 0.\n   Two singleton
          output LFB ports are defined.\n   The first singleton output is known as
          \"SuccessOut\".  Upon a\n   successful table lookup, the destination and
          source MAC addresses and\n   the logical media port (L2PortID) are found
          in the matching table\n   entry.  The CE may set the VlanID in case VLANs
          are used.  By\n   default, the table entry for VlanID of 0 is used as per
          IEEE rules\n   [IEEE.802-1Q].  Whatever the value of VlanID, if the input
          metadata\n   VlanPriority is non-zero, the packet will have a VLAN tag.
          \ If the\n   VlanPriority and the VlanID are all zero, there is no VLAN
          tag for\n   this packet.  After replacing or attaching the appropriate Ethernet\n
          \  headers to the packet is complete, the packet is passed out on the\n
          \  \"SuccessOut\" LFB port to a downstream LFB instance along with the\n
          \  L2PortID.\n   The second singleton output is known as \"ExceptionOut\"
          and will\n   output packets for which the table lookup fails, along with
          an\n   additional ExceptionID metadata.  Currently defined exception types\n
          \  only include the following cases:\n   o  The MediaEncapInfoIndex value
          of the packet is invalid and can not\n      be allocated in the EncapTable.\n
          \  o  The packet failed lookup of the EncapTable table even though the\n
          \     MediaEncapInfoIndex is valid.\n   The upstream LFB may be programmed
          by the CE to pass along a\n   MediaEncapInfoIndex that does not exist in
          the EncapTable.  This\n   allows for resolution of the L2 headers, if needed,
          to be made at the\n   L2 encapsulation level, in this case, Ethernet via
          ARP or ND (or\n   other methods depending on the link-layer technology),
          when a table\n   miss occurs.\n   For neighbor L2 header resolution (table
          miss exception), the\n   processing LFB may pass this packet to the CE via
          the redirect LFB or\n   FE software or another LFB instance for further
          resolution.  In such\n   a case, the metadata NextHopIPv4Addr or NextHopIPv6Addr
          generated by\n   the next-hop LFB is also passed to the exception handling.
          \ Such an\n   IP address could be used to do activities such as ARP or ND
          by the\n   handler to which it is passed.\n   The result of the L2 resolution
          is to update the EncapTable as well\n   as the next-hop LFB so subsequent
          packets do not fail EncapTable\n   lookup.  The EtherEncap LFB does not
          make any assumptions of how the\n   EncapTable is updated by the CE (or
          whether ARP/ND is used\n   dynamically or static maps exist).\n   Downstream
          LFB instances could be either an EtherMACOut type or a\n   BasicMetadataDispatch
          type.  If the final packet L2 processing is on\n   a per-media-port basis,
          resides on a different FE, or needs L2 header\n   resolution, then it makes
          sense for the model to use a\n   BasicMetadataDispatch LFB to fan out to
          different LFB instances.  If\n   there is a direct egress port point, then
          it makes sense for the\n   model to have a downstream LFB instance be an
          EtherMACOut.\n"
        title: 5.1.4.1.  Data Handling
      - contents:
        - "5.1.4.2.  Components\n   This LFB has only one component named EncapTable,
          which is defined as\n   an array.  Each row of the array is a struct containing
          the\n   destination MAC address, the source MAC address, the VLAN ID with
          a\n   default value of zero, and the output logical L2 port ID.\n"
        title: 5.1.4.2.  Components
      - contents:
        - "5.1.4.3.  Capabilities\n   This LFB does not have a list of capabilities.\n"
        title: 5.1.4.3.  Capabilities
      - contents:
        - "5.1.4.4.  Events\n   This LFB does not have any events specified.\n"
        title: 5.1.4.4.  Events
      title: 5.1.4.  EtherEncap
    - contents:
      - "5.1.5.  EtherMACOut\n   The EtherMACOut LFB abstracts an Ethernet port at
        the MAC data link\n   layer.  This LFB describes Ethernet packet output process.
        \ Ethernet\n   output functions are closely related to Ethernet input functions;\n
        \  therefore, many components defined in this LFB are aliases of\n   EtherMACIn
        LFB components.\n"
      - contents:
        - "5.1.5.1.  Data Handling\n   The LFB is expected to receive all types of
          Ethernet packets (via a\n   singleton input known as \"EtherPktsIn\"), which
          are usually output\n   from an Ethernet encapsulation LFB along with a metadata
          indicating\n   the ID of the physical port that the packet will go through.\n
          \  The LFB is defined with a singleton output port known as\n   \"EtherPktsOut\".
          \ All output packets are in Ethernet format, possibly\n   with various Ethernet
          types, along with a metadata indicating the ID\n   of the physical port
          that the packet is to go through.  This output\n   links to a downstream
          LFB that is usually an Ethernet physical LFB\n   like the EtherPHYCop LFB.\n
          \  This LFB can optionally participate in Ethernet flow control in\n   cooperation
          with the EtherMACIn LFB.  This document does not go into\n   the details
          of how this is implemented.  This document also does not\n   describe how
          the buffers that induce the flow control messages behave\n   -- it is assumed
          that such artifacts exist, but describing them is\n   out of the scope of
          this document.\n   Note that as a base definition, functions like multiple
          virtual MAC\n   layers are not supported in this LFB version.  It may be
          supported in\n   the future by defining a subclass or a new version of this
          LFB.\n"
        title: 5.1.5.1.  Data Handling
      - contents:
        - "5.1.5.2.  Components\n   The AdminStatus component is defined for the CE
          to administratively\n   manage the status of the LFB.  The CE may administratively
          start up\n   or shut down the LFB by changing the value of AdminStatus.
          \ The\n   default value is set to 'Down'.  Note that this component is defined\n
          \  as an alias of the AdminStatus component in the EtherMACIn LFB.  This\n
          \  infers that an EtherMACOut LFB usually coexists with an EtherMACIn\n
          \  LFB, both of which share the same administrative status management by\n
          \  the CE.  Alias properties, as defined in the ForCES FE model\n   [RFC5812],
          will be used by the CE to declare the target component to\n   which the
          alias refers, which includes the target LFB class and\n   instance IDs as
          well as the path to the target component.\n   The MTU component defines
          the maximum transmission unit.\n   The optional TxFlowControl component
          defines whether or not the LFB\n   is performing flow control on sending
          packets.  The default value is\n   'false'.  Note that this component is
          defined as an alias of the\n   TxFlowControl component in the EtherMACIn
          LFB.\n   The optional RxFlowControl component defines whether or not the
          LFB\n   is performing flow control on receiving packets.  The default value\n
          \  is 'false'.  Note that this component is defined as an alias of the\n
          \  RxFlowControl component in the EtherMACIn LFB.\n   A struct component,
          MACOutStats, defines a set of statistics for this\n   LFB, including the
          number of transmitted packets and the number of\n   dropped packets.  This
          statistics component is optional to\n   implementers.\n"
        title: 5.1.5.2.  Components
      - contents:
        - "5.1.5.3.  Capabilities\n   This LFB does not have a list of capabilities.\n"
        title: 5.1.5.3.  Capabilities
      - contents:
        - "5.1.5.4.  Events\n   This LFB does not have any events specified.\n"
        title: 5.1.5.4.  Events
      title: 5.1.5.  EtherMACOut
    title: 5.1.  Ethernet-Processing LFBs
  - contents:
    - "5.2.  IP Packet Validation LFBs\n   The LFBs are defined to abstract the IP
      packet validation process.\n   An IPv4Validator LFB is specifically for IPv4
      protocol validation,\n   and an IPv6Validator LFB is specifically for IPv6.\n"
    - contents:
      - "5.2.1.  IPv4Validator\n   The IPv4Validator LFB performs IPv4 packet validation.\n"
      - contents:
        - "5.2.1.1.  Data Handling\n   This LFB performs IPv4 validation according
          to [RFC1812] and its\n   updates.  The IPv4 packet will be output to the
          corresponding LFB\n   port, indicating whether the packet is unicast or
          multicast or\n   whether an exception has occurred or the validation failed.\n
          \  This LFB always expects, as input, packets that have been indicated\n
          \  as IPv4 packets by an upstream LFB, like an EtherClassifier LFB.\n   There
          is no specific metadata expected by the input of the LFB.\n   Four output
          LFB ports are defined.\n   All validated IPv4 unicast packets will be output
          at the singleton\n   port known as \"IPv4UnicastOut\".  All validated IPv4
          multicast packets\n   will be output at the singleton port known as \"IPv4MulticastOut\"\n
          \  port.\n   A singleton port known as \"ExceptionOut\" is defined to output
          packets\n   that have been validated as exception packets.  An exception
          ID\n   metadata is produced to indicate what has caused the exception.  An\n
          \  exception case is the case when a packet needs further processing\n   before
          being normally forwarded.  Currently defined exception types\n   include:\n
          \  o  Packet with expired TTL\n   o  Packet with header length more than
          5 words\n   o  Packet IP head including router alert options\n   o  Packet
          with exceptional source address\n   o  Packet with exceptional destination
          address\n   Note that although Time to Live (TTL) is checked in this LFB
          for\n   validity, operations like TTL decrement are made by the downstream\n
          \  forwarding LFB.\n   The final singleton port known as \"FailOut\" is
          defined for all\n   packets that have errors and failed the validation process.
          \ An error\n   case is when a packet is unable to be further processed or
          forwarded\n   without being dropped.  An error ID is associated with a packet
          to\n   indicate the failure reason.  Currently defined failure reasons\n
          \  include:\n   o  Packet with size reported less than 20 bytes\n   o  Packet
          with version not IPv4\n   o  Packet with header length less than 5 words\n
          \  o  Packet with total length field less than 20 bytes\n   o  Packet with
          invalid checksum\n   o  Packet with invalid source address\n   o  Packet
          with invalid destination address\n"
        title: 5.2.1.1.  Data Handling
      - contents:
        - "5.2.1.2.  Components\n   This LFB has only one struct component, the\n
          \  IPv4ValidatorStatisticsType, which defines a set of statistics for\n
          \  validation process, including the number of bad header packets, the\n
          \  number of bad total length packets, the number of bad TTL packets,\n
          \  and the number of bad checksum packets.  This statistics component is\n
          \  optional to implementers.\n"
        title: 5.2.1.2.  Components
      - contents:
        - "5.2.1.3.  Capabilities\n   This LFB does not have a list of capabilities\n"
        title: 5.2.1.3.  Capabilities
      - contents:
        - "5.2.1.4.  Events\n   This LFB does not have any events specified.\n"
        title: 5.2.1.4.  Events
      title: 5.2.1.  IPv4Validator
    - contents:
      - "5.2.2.  IPv6Validator\n   The IPv6Validator LFB performs IPv6 packet validation.\n"
      - contents:
        - "5.2.2.1.  Data Handling\n   This LFB performs IPv6 validation according
          to [RFC2460] and its\n   updates.  Then the IPv6 packet will be output to
          the corresponding\n   port regarding of the validation result, indicating
          whether the\n   packet is a unicast or a multicast one, an exception has
          occurred or\n   the validation failed.\n   This LFB always expects, as input,
          packets that have been indicated\n   as IPv6 packets by an upstream LFB,
          like an EtherClassifier LFB.\n   There is no specific metadata expected
          by the input of the LFB.\n   Similar to the IPv4validator LFB, the IPv6Validator
          LFB has also\n   defined four output ports to emit packets with various
          validation\n   results.\n   All validated IPv6 unicast packets will be output
          at the singleton\n   port known as \"IPv6UnicastOut\".  All validated IPv6
          multicast packets\n   will be output at the singleton port known as \"IPv6MulticastOut\".\n
          \  There is no metadata produced at this LFB.\n   A singleton port known
          as \"ExceptionOut\" is defined to output packets\n   that have been validated
          as exception packets.  An exception case is\n   when a packet needs further
          processing before being normally\n   forwarded.  An exception ID metadata
          is produced to indicate what\n   caused the exception.  Currently defined
          exception types include:\n   o  Packet with hop limit to zero\n   o  Packet
          with next header set to hop-by-hop\n   o  Packet with exceptional source
          address\n   o  Packet with exceptional destination address\n   The final
          singleton port known as \"FailOut\" is defined for all\n   packets that
          have errors and failed the validation process.  An error\n   case when a
          packet is unable to be further processed or forwarded\n   without being
          dropped.  A validate error ID is associated to every\n   failed packet to
          indicate the reason.  Currently defined reasons\n   include:\n   o  Packet
          with size reported less than 40 bytes\n   o  Packet with version not IPv6\n
          \  o  Packet with invalid source address\n   o  Packet with invalid destination
          address\n   Note that in the base type library, definitions for exception
          ID and\n   validate error ID metadata are applied to both IPv4Validator
          and\n   IPv6Validator LFBs, i.e., the two LFBs share the same metadata\n
          \  definition, with different ID assignment inside.\n"
        title: 5.2.2.1.  Data Handling
      - contents:
        - "5.2.2.2.  Components\n   This LFB has only one struct component, the\n
          \  IPv6ValidatorStatisticsType, which defines a set of statistics for\n
          \  the validation process, including the number of bad header packets,\n
          \  the number of bad total length packets, and the number of bad hop\n   limit
          packets.  Note that this component is optional to implementers.\n"
        title: 5.2.2.2.  Components
      - contents:
        - "5.2.2.3.  Capabilities\n   This LFB does not have a list of capabilities.\n"
        title: 5.2.2.3.  Capabilities
      - contents:
        - "5.2.2.4.  Events\n   This LFB does not have any events specified.\n"
        title: 5.2.2.4.  Events
      title: 5.2.2.  IPv6Validator
    title: 5.2.  IP Packet Validation LFBs
  - contents:
    - "5.3.  IP Forwarding LFBs\n   IP Forwarding LFBs are specifically defined to
      abstract the IP\n   forwarding processes.  As definitions for a base LFB library,
      this\n   document restricts its LFB definition scope only to IP unicast\n   forwarding.
      \ IP multicast may be defined in future documents.\n   The two fundamental tasks
      performed in IP unicast forwarding\n   constitute looking up the forwarding
      information table to find next-\n   hop information and then using the resulting
      next-hop details to\n   forward packets out on specific physical output ports.
      \ This document\n   models the forwarding processes by abstracting out the described
      two\n   steps.  Whereas this document describes functional LFB models that\n
      \  are modular, there may be multiple ways to implement the abstracted\n   models.
      \ It is not intended or expected that the provided LFB models\n   constrain
      implementations.\n   Based on the IP forwarding abstraction, two kinds of typical
      IP\n   unicast forwarding LFBs are defined: unicast LPM lookup LFB and next-\n
      \  hop application LFB.  They are further distinguished by IPv4 and IPv6\n   protocols.\n"
    - contents:
      - "5.3.1.  IPv4UcastLPM\n   The IPv4UcastLPM LFB abstracts the IPv4 unicast
        Longest Prefix Match\n   (LPM) process.\n   This LFB also provides facilities
        to support users to implement\n   equal-cost multipath (ECMP) routing or reverse
        path forwarding (RPF).\n   However, this LFB itself does not provide ECMP
        or RPF.  To fully\n   implement ECMP or RPF, additional specific LFBs, like
        a specific ECMP\n   LFB or an RPF LFB, will have to be defined.\n"
      - contents:
        - "5.3.1.1.  Data Handling\n   This LFB performs the IPv4 unicast LPM table
          lookup.  It always\n   expects as input IPv4 unicast packets from one singleton
          input known\n   as \"PktsIn\".  Then, the LFB uses the destination IPv4
          address of\n   every packet as a search key to look up the IPv4 prefix table
          and\n   generate a hop selector as the matching result.  The hop selector
          is\n   passed as packet metadata to downstream LFBs and will usually be
          used\n   there as a search index to find more next-hop information.\n   Three
          singleton output LFB ports are defined.\n   The first singleton output is
          known as \"NormalOut\" and outputs IPv4\n   unicast packets that succeed
          the LPM lookup (and got a hop selector).\n   The hop selector is associated
          with the packet as a metadata.\n   Downstream from the LPM LFB is usually
          a next-hop application LFB,\n   like an IPv4NextHop LFB.\n   The second
          singleton output is known as \"ECMPOut\" and is defined to\n   provide support
          for users wishing to implement ECMP.\n   An ECMP flag is defined in the
          LPM table to enable the LFB to support\n   ECMP.  When a table entry is
          created with the flag set to true, it\n   indicates this table entry is
          for ECMP only.  A packet that has\n   passed through this prefix lookup
          will always output from the\n   \"ECMPOut\" output port, with the hop selector
          being its lookup result.\n   The output will usually go directly to a downstream
          ECMP processing\n   LFB, where the hop selector can usually further generate
          optimized\n   one or multiple next-hop routes by use of ECMP algorithms.\n
          \  A default route flag is defined in the LPM table to enable the LFB to\n
          \  support a default route as well as loose RPF.  When this flag is set\n
          \  to true, the table entry is identified as a default route, which also\n
          \  implies that the route is forbidden for RPF.  If a user wants to\n   implement
          RPF on FE, a specific RPF LFB will have to be defined.  In\n   such an RPF
          LFB, a component can be defined as an alias of the prefix\n   table component
          of this LFB, as described below.\n   The final singleton output is known
          as \"ExceptionOut\" of the\n   IPv4UcastLPM LFB and is defined to output
          exception packets after the\n   LFB processing, along with an ExceptionID
          metadata to indicate what\n   caused the exception.  Currently defined exception
          types include:\n   o  The packet failed the LPM lookup of the prefix table.\n
          \  The upstream LFB of this LFB is usually an IPv4Validator LFB.  If RPF\n
          \  is to be adopted, the upstream can be an RPF LFB, when defined.\n   The
          downstream LFB is usually an IPv4NextHop LFB.  If ECMP is\n   adopted, the
          downstream can be an ECMP LFB, when defined.\n"
        title: 5.3.1.1.  Data Handling
      - contents:
        - "5.3.1.2.  Components\n   This LFB has two components.\n   The IPv4PrefixTable
          component is defined as an array component of the\n   LFB.  Each row of
          the array contains an IPv4 address, a prefix\n   length, a hop selector,
          an ECMP flag and a default route flag.  The\n   LFB uses the destination
          IPv4 address of every input packet as a\n   search key to look up this table
          in order extract a next-hop\n   selector.  The ECMP flag is for the LFB
          to support ECMP.  The default\n   route flag is for the LFB to support a
          default route and for loose\n   RPF.\n   The IPv4UcastLPMStats component
          is a struct component that collects\n   statistics information, including
          the total number of input packets\n   received, the IPv4 packets forwarded
          by this LFB, and the number of\n   IP datagrams discarded due to no route
          found.  Note that this\n   component is defined as optional to implementers.\n"
        title: 5.3.1.2.  Components
      - contents:
        - "5.3.1.3.  Capabilities\n   This LFB does not have a list of capabilities.\n"
        title: 5.3.1.3.  Capabilities
      - contents:
        - "5.3.1.4.  Events\n   This LFB does not have any events specified.\n"
        title: 5.3.1.4.  Events
      title: 5.3.1.  IPv4UcastLPM
    - contents:
      - "5.3.2.  IPv4NextHop\n   This LFB abstracts the process of selecting IPv4
        next-hop action.\n"
      - contents:
        - "5.3.2.1.  Data Handling\n   The LFB abstracts the process of next-hop information
          application to\n   IPv4 packets.  It receives an IPv4 packet with an associated
          next-hop\n   identifier (HopSelector) and uses the identifier as a table
          index to\n   look up a next-hop table to find an appropriate LFB output
          port.\n   The LFB is expected to receive unicast IPv4 packets, via a singleton\n
          \  input known as \"PktsIn\", along with a HopSelector metadata, which is\n
          \  used as a table index to look up the NextHop table.  The data\n   processing
          involves the forwarding TTL decrement and IP checksum\n   recalculation.\n
          \  Two output LFB ports are defined.\n   The first output is a group output
          port known as \"SuccessOut\".  On\n   successful data processing, the packet
          is sent out from an LFB port\n   from within the LFB port group as selected
          by the\n   LFBOutputSelectIndex value of the matched table entry.  The packet
          is\n   sent to a downstream LFB along with the L3PortID and\n   MediaEncapInfoIndex
          metadata.\n   The second output is a singleton output port known as \"ExceptionOut\",\n
          \  which will output packets for which the data processing failed, along\n
          \  with an additional ExceptionID metadata to indicate what caused the\n
          \  exception.  Currently defined exception types include:\n   o  The HopSelector
          for the packet is invalid.\n   o  The packet failed lookup of the next-hop
          table even though the\n      HopSelector is valid.\n   o  The MTU for outgoing
          interface is less than the packet size.\n   Downstream LFB instances could
          be either a BasicMetadataDispatch type\n   (Section 5.5.1), used to fan
          out to different LFB instances or a\n   media-encapsulation-related type,
          such as an EtherEncap type or a\n   RedirectOut type (Section 5.4.2).  For
          example, if there are Ethernet\n   and other tunnel encapsulation, then
          a BasicMetadataDispatch LFB can\n   use the L3PortID metadata (Section 5.3.2.2)
          to dispatch packets to a\n   different encapsulator.\n"
        title: 5.3.2.1.  Data Handling
      - contents:
        - "5.3.2.2.  Components\n   This LFB has only one component, IPv4NextHopTable,
          which is defined\n   as an array.  The HopSelector received is used to match
          the array\n   index of IPv4NextHopTable to find out a row of the table as
          the next-\n   hop information result.  Each row of the array is a struct\n
          \  containing:\n   o  The L3PortID, which is the ID of the logical output
          port that is\n      passed on to the downstream LFB instance.  This ID indicates
          what\n      kind of encapsulating port the neighbor is to use.  This is
          L3-\n      derived information that affects L2 processing and so needs to
          be\n      based from one LFB to another as metadata.  Usually, this ID is\n
          \     used for the next-hop LFB to distinguish packets that need\n      different
          L2 encapsulating.  For instance, some packets may\n      require general
          Ethernet encapsulation while others may require\n      various types of
          tunnel encapsulations.  In such a case, different\n      L3PortIDs are assigned
          to the packets and are passed as metadata\n      to a downstream LFB.  A
          BasicMetadataDispatch LFB (Section 5.5.1)\n      may have to be applied
          as the downstream LFB so as to dispatch\n      packets to different encapsulation
          LFB instances according to the\n      L3PortIDs.\n   o  MTU, the Maximum
          Transmission Unit for the outgoing port.\n   o  NextHopIPAddr, the IPv4
          next-hop address.\n   o  MediaEncapInfoIndex, the index that passes on to
          the downstream\n      encapsulation LFB instance and that is used there
          as a search key\n      to look up a table (typically media-encapsulation-related)
          for\n      further encapsulation information.  The search key looks up the\n
          \     table by matching the table index.  Note that the encapsulation\n
          \     LFB instance that uses this metadata may not be the LFB instance\n
          \     that immediately follows this LFB instance in the processing.  The\n
          \     MediaEncapInfoIndex metadata is attached here and is passed\n      through
          intermediate LFBs until it is used by the encapsulation\n      LFB instance.
          \ In some cases, depending on implementation, the CE\n      may set the
          MediaEncapInfoIndex passed downstream to a value that\n      will fail lookup
          when it gets to a target encapsulation LFB; such\n      a lookup failure
          at that point is an indication that further\n      resolution is needed.
          \ For an example of this approach, refer to\n      Section 7.2, which discusses
          ARP and mentions this approach.\n   o  LFBOutputSelectIndex, the LFB group
          output port index to select\n      the downstream LFB port.  This value
          identifies the specific port\n      within the SuccessOut port group out
          of which packets that\n      successfully use this next-hop entry are to
          be sent.\n"
        title: 5.3.2.2.  Components
      - contents:
        - "5.3.2.3.  Capabilities\n   This LFB does not have a list of capabilities.\n"
        title: 5.3.2.3.  Capabilities
      - contents:
        - "5.3.2.4.  Events\n   This LFB does not have any events specified.\n"
        title: 5.3.2.4.  Events
      title: 5.3.2.  IPv4NextHop
    - contents:
      - "5.3.3.  IPv6UcastLPM\n   The IPv6UcastLPM LFB abstracts the IPv6 unicast
        Longest Prefix Match\n   (LPM) process.  The definition of this LFB is similar
        to the\n   IPv4UcastLPM LFB except that all IP addresses refer to IPv6\n   addresses.\n
        \  This LFB also provides facilities to support users to implement\n   equal-cost
        multipath (ECMP) routing or reverse path forwarding (RPF).\n   However, this
        LFB itself does not provide ECMP or RPF.  To fully\n   implement ECMP or RPF,
        additional specific LFBs, like a specific ECMP\n   LFB or an RPF LFB, will
        have to be defined.  This work may be done in\n   future versions of this
        document.\n"
      - contents:
        - "5.3.3.1.  Data Handling\n   This LFB performs the IPv6 unicast LPM table
          lookup.  It always\n   expects as input IPv6 unicast packets from one singleton
          input known\n   as \"PktsIn\".  The destination IPv6 address of an incoming
          packet is\n   used as a search key to look up the IPv6 prefix table and
          generate a\n   hop selector.  This hop selector result is associated to
          the packet\n   as a metadata and sent to downstream LFBs; it will usually
          be used in\n   downstream LFBs as a search key to find more next-hop information.\n
          \  Three singleton output LFB ports are defined.\n   The first singleton
          output is known as \"NormalOut\" and outputs IPv6\n   unicast packets that
          succeed the LPM lookup (and got a hop selector).\n   The hop selector is
          associated with the packet as a metadata.\n   Downstream from the LPM LFB
          is usually a next-hop application LFB,\n   like an IPv6NextHop LFB.\n   The
          second singleton output is known as \"ECMPOut\" and is defined to\n   provide
          support for users wishing to implement ECMP.\n   An ECMP flag is defined
          in the LPM table to enable the LFB to support\n   ECMP.  When a table entry
          is created with the flag set to true, it\n   indicates this table entry
          is for ECMP only.  A packet that has\n   passed through this prefix lookup
          will always output from the\n   \"ECMPOut\" output port, with the hop selector
          being its lookup result.\n   The output will usually go directly to a downstream
          ECMP processing\n   LFB, where the hop selector can usually further generate
          optimized\n   one or multiple next-hop routes by use of ECMP algorithms.\n
          \  A default route flag is defined in the LPM table to enable the LFB to\n
          \  support a default route as well as loose RPF.  When this flag is set\n
          \  to true, the table entry is identified as a default route, which also\n
          \  implies that the route is forbidden for RPF.\n   If a user wants to implement
          RPF on FE, a specific RPF LFB will have\n   to be defined.  In such an RPF
          LFB, a component can be defined as an\n   alias of the prefix table component
          of this LFB, as described below.\n   The final singleton output is known
          as \"ExceptionOut\" of the\n   IPv6UcastLPM LFB and is defined to output
          exception packets after the\n   LFB processing, along with an ExceptionID
          metadata to indicate what\n   caused the exception.  Currently defined exception
          types include:\n   o  The packet failed the LPM lookup of the prefix table.\n
          \  The upstream LFB of this LFB is usually an IPv6Validator LFB.  If RPF\n
          \  is to be adopted, the upstream can be an RPF LFB, when defined.\n   The
          downstream LFB is usually an IPv6NextHop LFB.  If ECMP is\n   adopted, the
          downstream can be an ECMP LFB, when defined.\n"
        title: 5.3.3.1.  Data Handling
      - contents:
        - "5.3.3.2.  Components\n   This LFB has two components.\n   The IPv6PrefixTable
          component is defined as an array component of the\n   LFB.  Each row of
          the array contains an IPv6 address, a prefix\n   length, a hop selector,
          an ECMP flag, and a default route flag.  The\n   ECMP flag is so the LFB
          can support ECMP.  The default route flag is\n   for the LFB to support
          a default route and for loose RPF, as\n   described earlier.\n   The IPv6UcastLPMStats
          component is a struct component that collects\n   statistics information,
          including the total number of input packets\n   received, the IPv6 packets
          forwarded by this LFB and the number of IP\n   datagrams discarded due to
          no route found.  Note that the component\n   is defined as optional to implementers.\n"
        title: 5.3.3.2.  Components
      - contents:
        - "5.3.3.3.  Capabilities\n   This LFB does not have a list of capabilities.\n"
        title: 5.3.3.3.  Capabilities
      - contents:
        - "5.3.3.4.  Events\n   This LFB does not have any events specified.\n"
        title: 5.3.3.4.  Events
      title: 5.3.3.  IPv6UcastLPM
    - contents:
      - "5.3.4.  IPv6NextHop\n   This LFB abstracts the process of selecting IPv6
        next-hop action.\n"
      - contents:
        - "5.3.4.1.  Data Handling\n   The LFB abstracts the process of next-hop information
          application to\n   IPv6 packets.  It receives an IPv6 packet with an associated
          next-hop\n   identifier (HopSelector) and uses the identifier to look up
          a next-\n   hop table to find an appropriate output port from the LFB.\n
          \  The LFB is expected to receive unicast IPv6 packets, via a singleton\n
          \  input known as \"PktsIn\", along with a HopSelector metadata, which is\n
          \  used as a table index to look up the next-hop table.\n   Two output LFB
          ports are defined.\n   The first output is a group output port known as
          \"SuccessOut\".  On\n   successful data processing, the packet is sent out
          from an LFB port\n   from within the LFB port group as selected by the\n
          \  LFBOutputSelectIndex value of the matched table entry.  The packet is\n
          \  sent to a downstream LFB along with the L3PortID and\n   MediaEncapInfoIndex
          metadata.\n   The second output is a singleton output port known as \"ExceptionOut\",\n
          \  which will output packets for which the data processing failed, along\n
          \  with an additional ExceptionID metadata to indicate what caused the\n
          \  exception.  Currently defined exception types include:\n   o  The HopSelector
          for the packet is invalid.\n   o  The packet failed lookup of the next-hop
          table even though the\n      HopSelector is valid.\n   o  The MTU for outgoing
          interface is less than the packet size.\n   Downstream LFB instances could
          be either a BasicMetadataDispatch\n   type, used to fan out to different
          LFB instances, or a media\n   encapsulation related type, such as an EtherEncap
          type or a\n   RedirectOut type.  For example, when the downstream LFB is\n
          \  BasicMetadataDispatch and Ethernet and other tunnel encapsulation\n   exist
          downstream from BasicMetadataDispatch, then the\n   BasicMetadataDispatch
          LFB can use the L3PortID metadata (see section\n   below) to dispatch packets
          to the different encapsulator LFBs.\n"
        title: 5.3.4.1.  Data Handling
      - contents:
        - "5.3.4.2.  Components\n   This LFB has only one component named IPv6NextHopTable,
          which is\n   defined as an array.  The array index of IPv6NextHopTable is
          used for\n   a HopSelector to find out a row of the table as the next-hop\n
          \  information.  Each row of the array is a struct containing:\n   o  The
          L3PortID, which is the ID of the logical output port that is\n      passed
          onto the downstream LFB instance.  This ID indicates what\n      kind of
          encapsulating port the neighbor is to use.  This is L3-\n      derived information
          that affects L2 processing and so needs to be\n      based from one LFB
          to another as metadata.  Usually, this ID is\n      used for the next-hop
          LFB to distinguish packets that need\n      different L2 encapsulating.
          \ For instance, some packets may\n      require general Ethernet encapsulation
          while others may require\n      various types of tunnel encapsulations.
          \ In such a case, different\n      L3PortIDs are assigned to the packets
          and are passed as metadata\n      to a downstream LFB.  A BasicMetadataDispatch
          LFB (Section 5.5.1)\n      may have to be applied as the downstream LFB
          so as to dispatch\n      packets to different encapsulation LFB instances
          according to the\n      L3PortIDs.\n   o  MTU, the Maximum Transmission
          Unit for the outgoing port.\n   o  NextHopIPAddr, the IPv6 next-hop address.\n
          \  o  MediaEncapInfoIndex, the index that is passed on to the downstream\n
          \     encapsulation LFB instance and that is used there as a search key\n
          \     to look up a table (typically media-encapsulation-related) for\n      further
          encapsulation information.  The search key looks up the\n      table by
          matching the table index.  Note that the encapsulation\n      LFB instance
          that uses this metadata may not be the LFB instance\n      that immediately
          follows this LFB instance in the processing.  The\n      MediaEncapInfoIndex
          metadata is attached here and is passed\n      through intermediate LFBs
          until it is used by the encapsulation\n      LFB instance.  In some cases,
          depending on implementation, the CE\n      may set the MediaEncapInfoIndex
          passed downstream to a value that\n      will fail lookup when it gets to
          a target encapsulation LFB; such\n      a lookup failure at that point is
          an indication that further\n      resolution is needed.  For an example
          of this approach, refer to\n      Section 7.2, which discusses ARP and mentions
          this approach.\n   o  LFBOutputSelectIndex, the LFB group output port index
          to select\n      the downstream LFB port.  This value identifies the specific
          port\n      within the SuccessOut port group out of which packets that\n
          \     successfully use this next-hop entry are to be sent.\n"
        title: 5.3.4.2.  Components
      - contents:
        - "5.3.4.3.  Capabilities\n   This LFB does not have a list of capabilities.\n"
        title: 5.3.4.3.  Capabilities
      - contents:
        - "5.3.4.4.  Events\n   This LFB does not have any events specified.\n"
        title: 5.3.4.4.  Events
      title: 5.3.4.  IPv6NextHop
    title: 5.3.  IP Forwarding LFBs
  - contents:
    - "5.4.  Redirect LFBs\n   Redirect LFBs abstract the data packet transportation
      process between\n   the CE and FE.  Some packets output from some LFBs may have
      to be\n   delivered to the CE for further processing, and some packets\n   generated
      by the CE may have to be delivered to the FE and further to\n   some specific
      LFBs for data path processing.  According to [RFC5810],\n   data packets and
      their associated metadata are encapsulated in a\n   ForCES redirect message
      for transportation between CE and FE.  We\n   define two LFBs to abstract the
      process: a RedirectIn LFB and a\n   RedirectOut LFB.  Usually, in an LFB topology
      of an FE, only one\n   RedirectIn LFB instance and one RedirectOut LFB instance
      exist.\n"
    - contents:
      - "5.4.1.  RedirectIn\n   The RedirectIn LFB abstracts the process for the CE
        to inject data\n   packets into the FE data path.\n"
      - contents:
        - "5.4.1.1.  Data Handling\n   A RedirectIn LFB abstracts the process for
          the CE to inject data\n   packets into the FE LFB topology so as to input
          data packets into FE\n   data paths.  From the LFB topology's point of view,
          the RedirectIn\n   LFB acts as a source point for data packets coming from
          the CE;\n   therefore, the RedirectIn LFB is defined with a single output
          LFB\n   port (and no input LFB port).\n   The single output port of RedirectIn
          LFB is defined as a group output\n   type with the name of \"PktsOut\".
          \ Packets produced by this output\n   will have arbitrary frame types decided
          by the CE that generated the\n   packets.  Possible frames may include IPv4,
          IPv6, or ARP protocol\n   packets.  The CE may associate some metadata to
          indicate the frame\n   types and may also associate other metadata to indicate
          various\n   information on the packets.  Among them, there MUST exist a\n
          \  RedirectIndex metadata, which is an integer acting as an index.  When\n
          \  the CE transmits the metadata along with the packet to a RedirectIn\n
          \  LFB, the LFB will read the RedirectIndex metadata and output the\n   packet
          to one of its group output port instances, whose port index is\n   indicated
          by this metadata.  Any other metadata, in addition to\n   RedirectIndex,
          will be passed untouched along the packet delivered by\n   the CE to the
          downstream LFB.  This means the RedirectIndex metadata\n   from CE will
          be \"consumed\" by the RedirectIn LFB and will not be\n   passed to downstream
          LFB.  Note that a packet from the CE without a\n   RedirectIndex metadata
          associated will be dropped by the LFB.  Note\n   that all metadata visible
          to the LFB need to be global and IANA\n   controlled.  See Section 8 (\"IANA
          Considerations\") of this document\n   for more details about a metadata
          ID space that can be used by\n   vendors and is \"Reserved for Private Use\".\n"
        title: 5.4.1.1.  Data Handling
      - contents:
        - "5.4.1.2.  Components\n   An optional statistics component is defined to
          collect the number of\n   packets received by the LFB from the CE.  There
          are no other\n   components defined for the current version of the LFB.\n"
        title: 5.4.1.2.  Components
      - contents:
        - "5.4.1.3.  Capabilities\n   This LFB does not have a list of capabilities.\n"
        title: 5.4.1.3.  Capabilities
      - contents:
        - "5.4.1.4.  Events\n   This LFB does not have any events specified.\n"
        title: 5.4.1.4.  Events
      title: 5.4.1.  RedirectIn
    - contents:
      - "5.4.2.  RedirectOut\n   RedirectOut LFB abstracts the process for LFBs in
        the FE to deliver\n   data packets to the CE.\n"
      - contents:
        - "5.4.2.1.  Data Handling\n   A RedirectOut LFB abstracts the process for
          LFBs in the FE to deliver\n   data packets to the CE.  From the LFB topology's
          point of view, the\n   RedirectOut LFB acts as a sink point for data packets
          going to the\n   CE; therefore, the RedirectOut LFB is defined with a single
          input LFB\n   port (and no output LFB port).\n   The RedirectOut LFB has
          only one singleton input, known as \"PktsIn\",\n   but is capable of receiving
          packets from multiple LFBs by\n   multiplexing this input.  The input expects
          any kind of frame type;\n   therefore, the frame type has been specified
          as arbitrary, and also\n   all types of metadata are expected.  All associated
          metadata produced\n   (but not consumed) by previous processed LFBs should
          be delivered to\n   the CE via the ForCES protocol redirect message [RFC5810].
          \ The CE\n   can decide how to process the redirected packet by referencing
          the\n   associated metadata.  As an example, a packet could be redirected
          by\n   the FE to the CE because the EtherEncap LFB is not able to resolve
          L2\n   information.  The metadata \"ExceptionID\" created by the EtherEncap\n
          \  LFB is passed along with the packet and should be sufficient for the\n
          \  CE to do the necessary processing and resolve the L2 entry required.\n
          \  Note that all metadata visible to the LFB need to be global and IANA\n
          \  controlled.  See Section 8 (\"IANA Considerations\") of this document\n
          \  for more details about a metadata ID space that can be used by\n   vendors
          and is \"Reserved for Private Use\".\n"
        title: 5.4.2.1.  Data Handling
      - contents:
        - "5.4.2.2.  Components\n   An optional statistics component is defined to
          collect the number of\n   packets sent by the LFB to the CE.  There are
          no other components\n   defined for the current version of the LFB.\n"
        title: 5.4.2.2.  Components
      - contents:
        - "5.4.2.3.  Capabilities\n   This LFB does not have a list of capabilities.\n"
        title: 5.4.2.3.  Capabilities
      - contents:
        - "5.4.2.4.  Events\n   This LFB does not have any events specified.\n"
        title: 5.4.2.4.  Events
      title: 5.4.2.  RedirectOut
    title: 5.4.  Redirect LFBs
  - contents:
    - '5.5.  General Purpose LFBs

      '
    - contents:
      - "5.5.1.  BasicMetadataDispatch\n   The BasicMetadataDispatch LFB is defined
        to abstract the process in\n   which a packet is dispatched to some output
        path based on its\n   associated metadata value.\n"
      - contents:
        - "5.5.1.1.  Data Handling\n   The BasicMetadataDispatch LFB has only one
          singleton input known as\n   \"PktsIn\".  Every input packet should be associated
          with a metadata\n   that will be used by the LFB to do the dispatch.  This
          LFB contains a\n   metadata ID and a dispatch table named MetadataDispatchTable,
          all\n   configured by the CE.  The metadata ID specifies which metadata
          is to\n   be used for dispatching packets.  The MetadataDispatchTable contains\n
          \  entries of a metadata value and an OutputIndex, specifying that the\n
          \  packet with the metadata value must go out from the LFB group output\n
          \  port instance with the OutputIndex.\n   Two output LFB ports are defined.\n
          \  The first output is a group output port known as \"PktsOut\".  A packet\n
          \  with its associated metadata having found an OutputIndex by\n   successfully
          looking up the dispatch table will be output to the\n   group port instance
          with the corresponding index.\n   The second output is a singleton output
          port known as \"ExceptionOut\",\n   which will output packets for which
          the data processing failed, along\n   with an additional ExceptionID metadata
          to indicate what caused the\n   exception.  Currently defined exception
          types only include one case:\n   o  There is no matching when looking up
          the metadata dispatch table.\n   As an example, if the CE decides to dispatch
          packets according to a\n   physical port ID (PHYPortID), the CE may set
          the ID of PHYPortID\n   metadata to the LFB first.  Moreover, the CE also
          sets the PHYPortID\n   actual values (the metadata values) and assigned
          OutputIndex for the\n   values to the dispatch table in the LFB.  When a
          packet arrives, a\n   PHYPortID metadata is found associated with the packet,
          and the\n   metadata value is further used as a key to look up the dispatch
          table\n   to find out an output port instance for the packet.\n   Currently,
          the BasicMetadataDispatch LFB only allows the metadata\n   value of the
          dispatch table entry to be a 32-bit integer.  A metadata\n   with other
          value types is not supported in this version.  A more\n   complex metadata
          dispatch LFB may be defined in future versions of\n   the library.  In that
          LFB, multiple tuples of metadata with more\n   value types supported may
          be used to dispatch packets.\n"
        title: 5.5.1.1.  Data Handling
      - contents:
        - "5.5.1.2.  Components\n   This LFB has two components.  One component is
          MetadataID and the\n   other is MetadataDispatchTable.  Each row entry of
          the dispatch table\n   is a struct containing the metadata value and the
          OutputIndex.  Note\n   that currently, the metadata value is only allowed
          to be a 32-bit\n   integer.  The metadata value is also defined as a content
          key for the\n   table.  The concept of content key is a searching key for
          tables,\n   which is defined in the ForCES FE model [RFC5812].  With the
          content\n   key, the CE can manipulate the table by means of a specific
          metadata\n   value rather than by the table index only.  See the ForCES
          FE model\n   [RFC5812] and also the ForCES protocol [RFC5810] for more details
          on\n   the definition and use of a content key.\n"
        title: 5.5.1.2.  Components
      - contents:
        - "5.5.1.3.  Capabilities\n   This LFB does not have a list of capabilities.\n"
        title: 5.5.1.3.  Capabilities
      - contents:
        - "5.5.1.4.  Events\n   This LFB does not have any events specified.\n"
        title: 5.5.1.4.  Events
      title: 5.5.1.  BasicMetadataDispatch
    - contents:
      - "5.5.2.  GenericScheduler\n   This is a preliminary generic scheduler LFB
        for abstracting a simple\n   scheduling process.\n"
      - contents:
        - "5.5.2.1.  Data Handling\n   There exist various kinds of scheduling strategies
          with various\n   implementations.  As a base LFB library, this document
          only defines a\n   preliminary generic scheduler LFB for abstracting a simple
          scheduling\n   process.  Users may use this LFB as a basic LFB to further
          construct\n   more complex scheduler LFBs by means of \"inheritance\", as
          described\n   in [RFC5812].\n   Packets of any arbitrary frame type are
          received via a group input\n   known as \"PktsIn\" with no additional metadata
          expected.  This group\n   input is capable of multiple input port instances.
          \ Each port\n   instance may be connected to a different upstream LFB output.
          \ Inside\n   the LFB, it is abstracted that each input port instance is
          connected\n   to a queue, and the queue is marked with a queue ID whose
          value is\n   exactly the same as the index of corresponding group input
          port\n   instance.  Scheduling disciplines are applied to all queues and
          also\n   all packets in the queues.  The group input port property\n   PortGroupLimits
          in ObjectLFB, as defined by the ForCES FE model\n   [RFC5810], provides
          means for the CE to query the capability of total\n   queue numbers the
          scheduler supports.  The CE can then decide how\n   many queues it may use
          for a scheduling application.\n   Scheduled packets are output from a singleton
          output port of the LFB\n   knows as \"PktsOut\" with no corresponding metadata.\n
          \  More complex scheduler LFBs may be defined with more complex\n   scheduling
          disciplines by succeeding this LFB.  For instance, a\n   priority scheduler
          LFB may be defined by inheriting this LFB and\n   defining a component to
          indicate priorities for all input queues.\n"
        title: 5.5.2.1.  Data Handling
      - contents:
        - "5.5.2.2.  Components\n   The SchedulingDiscipline component is for the
          CE to specify a\n   scheduling discipline to the LFB.  Currently defined
          scheduling\n   disciplines only include Round Robin (RR) strategy.  The
          default\n   scheduling discipline is thus RR.\n   The QueueStats component
          is defined to allow the CE to query every\n   queue status of the scheduler.
          \ It is an array component, and each\n   row of the array is a struct containing
          a queue ID.  Currently\n   defined queue status includes the queue depth
          in packets and the\n   queue depth in bytes.  Using the queue ID as the
          index, the CE can\n   query every queue for its used length in unit of packets
          or bytes.\n   Note that the QueueStats component is defined as optional
          to\n   implementers.\n"
        title: 5.5.2.2.  Components
      - contents:
        - "5.5.2.3.  Capabilities\n   The following capability is currently defined
          for the\n   GenericScheduler.\n   o  The queue length limit providing the
          storage ability for every\n      queue.\n"
        title: 5.5.2.3.  Capabilities
      - contents:
        - "5.5.2.4.  Events\n   This LFB does not have any events specified.\n"
        title: 5.5.2.4.  Events
      title: 5.5.2.  GenericScheduler
    title: 5.5.  General Purpose LFBs
  title: 5.  LFB Class Descriptions
- contents:
  - '6.  XML for LFB Library

    '
  - '<?xml version="1.0" encoding="UTF-8"?>

    '
  - "<LFBLibrary xmlns=\"urn:ietf:params:xml:ns:forces:lfbmodel:1.0\"\n     xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n
    \    provides=\"BaseLFBLibrary\">\n   <load library=\"BaseTypeLibrary\"/>\n   <LFBClassDefs>\n
    \     <LFBClassDef LFBClassID=\"3\">\n         <name>EtherPHYCop</name>\n         <synopsis>\n
    \          The EtherPHYCop LFB describes an Ethernet interface\n           that
    limits the physical media to copper.\n         </synopsis>\n         <version>1.0</version>\n
    \        <inputPorts>\n            <inputPort>\n               <name>EtherPHYIn</name>\n
    \              <synopsis>\n                 The input port of the EtherPHYCop
    LFB.  It expects any\n                 type of Ethernet frame.\n               </synopsis>\n
    \              <expectation>\n                  <frameExpected>\n                     <ref>EthernetAll</ref>\n
    \                 </frameExpected>\n               </expectation>\n            </inputPort>\n
    \        </inputPorts>\n         <outputPorts>\n            <outputPort>\n               <name>EtherPHYOut</name>\n
    \              <synopsis>\n                 The output port of the EtherPHYCop
    LFB.  The output\n                 packet has the same Ethernet frame type as
    the\n                 input packet, associated with a metadata indicating\n                 the
    ID of the physical port.\n               </synopsis>\n               <product>\n
    \                 <frameProduced>\n                     <ref>EthernetAll</ref>\n
    \                 </frameProduced>\n                  <metadataProduced>\n                     <ref>PHYPortID</ref>\n
    \                 </metadataProduced>\n               </product>\n            </outputPort>\n
    \        </outputPorts>\n         <components>\n            <component componentID=\"1\"
    access=\"read-only\">\n               <name>PHYPortID</name>\n               <synopsis>\n
    \                The identification of the physical port\n               </synopsis>\n
    \              <typeRef>uint32</typeRef>\n            </component>\n            <component
    componentID=\"2\" access=\"read-write\">\n               <name>AdminStatus</name>\n
    \              <synopsis>\n                 The port status administratively requested\n
    \              </synopsis>\n               <typeRef>PortStatusType</typeRef>\n
    \              <defaultValue>2</defaultValue>\n            </component>\n            <component
    componentID=\"3\" access=\"read-only\">\n               <name>OperStatus</name>\n
    \              <synopsis>\n                 The port actual operational status\n
    \              </synopsis>\n               <typeRef>PortStatusType</typeRef>\n
    \           </component>\n            <component componentID=\"4\" access=\"read-write\">\n
    \              <name>AdminLinkSpeed</name>\n               <synopsis>\n                 The
    port link speed administratively requested\n               </synopsis>\n               <typeRef>LANSpeedType</typeRef>\n
    \              <defaultValue>LAN_SPEED_AUTO</defaultValue>\n            </component>\n
    \           <component componentID=\"5\" access=\"read-only\">\n               <name>OperLinkSpeed</name>\n
    \              <synopsis>\n                 The port actual operational link speed\n
    \              </synopsis>\n               <typeRef>LANSpeedType</typeRef>\n            </component>\n
    \           <component componentID=\"6\" access=\"read-write\">\n               <name>AdminDuplexMode</name>\n
    \              <synopsis>\n                 The port duplex mode administratively
    requested\n               </synopsis>\n               <typeRef>DuplexType</typeRef>\n
    \              <defaultValue>Auto</defaultValue>\n            </component>\n            <component
    componentID=\"7\" access=\"read-only\">\n               <name>OperDuplexMode</name>\n
    \              <synopsis>\n                 The port actual operational duplex
    mode\n               </synopsis>\n               <typeRef>DuplexType</typeRef>\n
    \           </component>\n            <component componentID=\"8\" access=\"read-only\">\n
    \              <name>CarrierStatus</name>\n               <synopsis>The carrier
    status of the port </synopsis>\n               <typeRef>boolean</typeRef>\n               <defaultValue>false</defaultValue>\n
    \           </component>\n         </components>\n         <capabilities>\n            <capability
    componentID=\"30\">\n               <name>SupportedLinkSpeed</name>\n               <synopsis>\n
    \                A list of link speeds the port supports\n               </synopsis>\n
    \              <array>\n                  <typeRef>LANSpeedType</typeRef>\n               </array>\n
    \           </capability>\n            <capability componentID=\"31\">\n               <name>SupportedDuplexMode</name>\n
    \              <synopsis>\n                 A list of duplex modes the port supports\n
    \              </synopsis>\n               <array>\n                  <typeRef>DuplexType</typeRef>\n
    \              </array>\n            </capability>\n         </capabilities>\n
    \        <events baseID=\"60\">\n            <event eventID=\"1\">\n               <name>PHYPortStatusChanged</name>\n
    \              <synopsis>\n                 An event reporting change on operational
    status of the\n                 physical port.\n               </synopsis>\n               <eventTarget>\n
    \                 <eventField>OperStatus</eventField>\n               </eventTarget>\n
    \              <eventChanged/>\n               <eventReports>\n                  <eventReport>\n
    \                    <eventField>OperStatus</eventField>\n                  </eventReport>\n
    \              </eventReports>\n            </event>\n            <event eventID=\"2\">\n
    \              <name>LinkSpeedChanged</name>\n               <synopsis>\n                 An
    event reporting change on operational link speed\n                 of the physical
    port.\n               </synopsis>\n               <eventTarget>\n                  <eventField>OperLinkSpeed</eventField>\n
    \              </eventTarget>\n               <eventChanged/>\n               <eventReports>\n
    \                 <eventReport>\n                     <eventField>OperLinkSpeed</eventField>\n
    \                 </eventReport>\n               </eventReports>\n            </event>\n
    \           <event eventID=\"3\">\n               <name>DuplexModeChanged</name>\n
    \              <synopsis>\n                 An event reporting change on operational
    duplex mode\n                 of the physical port.\n               </synopsis>\n
    \              <eventTarget>\n                  <eventField>OperDuplexMode</eventField>\n
    \              </eventTarget>\n               <eventChanged/>\n               <eventReports>\n
    \                 <eventReport>\n                     <eventField>OperDuplexMode</eventField>\n
    \                 </eventReport>\n               </eventReports>\n            </event>\n
    \        </events>\n      </LFBClassDef>\n      <LFBClassDef LFBClassID=\"4\">\n
    \        <name>EtherMACIn</name>\n         <synopsis>\n           EtherMACIn LFB
    describes an Ethernet port at MAC data link\n           layer.  The LFB describes
    Ethernet processing functions\n           of MAC address locality check, deciding
    if the Ethernet\n           packets should be bridged, providing Ethernet-layer
    flow\n           control, etc.\n         </synopsis>\n         <version>1.0</version>\n
    \        <inputPorts>\n            <inputPort group=\"false\">\n               <name>EtherPktsIn</name>\n
    \              <synopsis>\n                 The input port of the EtherMACIn LFB.
    \ It expects any\n                 type of Ethernet frame.\n               </synopsis>\n
    \              <expectation>\n                  <frameExpected>\n                     <ref>EthernetAll</ref>\n
    \                 </frameExpected>\n                  <metadataExpected>\n                     <ref>PHYPortID</ref>\n
    \                 </metadataExpected>\n               </expectation>\n            </inputPort>\n
    \        </inputPorts>\n         <outputPorts>\n            <outputPort group=\"false\">\n
    \              <name>NormalPathOut</name>\n               <synopsis>\n                 An
    output port in the EtherMACIn LFB.  It outputs\n                 Ethernet packets
    to downstream LFBs for normal\n                 processing like Ethernet packet
    classification and\n                 other L3 IP-layer processing.\n               </synopsis>\n
    \              <product>\n                  <frameProduced>\n                     <ref>EthernetAll</ref>\n
    \                 </frameProduced>\n                  <metadataProduced>\n                     <ref>PHYPortID</ref>\n
    \                 </metadataProduced>\n               </product>\n            </outputPort>\n
    \           <outputPort>\n               <name>L2BridgingPathOut</name>\n               <synopsis>\n
    \                An output port in\n                 the EtherMACIn LFB.  It outputs
    Ethernet packets\n                 to downstream LFBs for layer 2 bridging processing.\n
    \                The port is switched on or off by the\n                 L2BridgingPathEnable
    flag in the LFB.\n               </synopsis>\n               <product>\n                  <frameProduced>\n
    \                    <ref>EthernetAll</ref>\n                  </frameProduced>\n
    \                 <metadataProduced>\n                     <ref>PHYPortID</ref>\n
    \                 </metadataProduced>\n               </product>\n            </outputPort>\n
    \        </outputPorts>\n         <components>\n            <component componentID=\"1\"
    access=\"read-write\">\n               <name>AdminStatus</name>\n               <synopsis>\n
    \                 The LFB status administratively requested, which has\n                  the
    same data type with a port status.  Default is in\n                  'Down' status.\n
    \              </synopsis>\n               <typeRef>PortStatusType</typeRef>\n
    \              <defaultValue>2</defaultValue>\n            </component>\n            <component
    componentID=\"2\" access=\"read-write\">\n               <name>LocalMACAddresses</name>\n
    \              <synopsis>\n                 Local MAC address(es) of the Ethernet
    port the LFB\n                 represents.\n               </synopsis>\n               <array>\n
    \                 <typeRef>IEEEMAC</typeRef>\n               </array>\n            </component>\n
    \           <component componentID=\"3\" access=\"read-write\">\n               <name>L2BridgingPathEnable</name>\n
    \              <synopsis>\n                 A flag indicating if the LFB L2 BridgingPath
    output\n                 port is enabled or not.  Default is not enabled.\n               </synopsis>\n
    \              <typeRef>boolean</typeRef>\n               <defaultValue>false</defaultValue>\n
    \           </component>\n            <component componentID=\"4\" access=\"read-write\">\n
    \              <name>PromiscuousMode</name>\n               <synopsis>\n                 A
    flag indicating whether the LFB is in promiscuous\n                 mode or not.
    \ Default is not.\n               </synopsis>\n               <typeRef>boolean</typeRef>\n
    \              <defaultValue>false</defaultValue>\n            </component>\n
    \           <component componentID=\"5\" access=\"read-write\">\n               <name>TxFlowControl</name>\n
    \              <synopsis>\n                 A flag indicating whether transmit
    flow control is\n                 applied or not.  Default is not.\n               </synopsis>\n
    \              <optional/>\n               <typeRef>boolean</typeRef>\n               <defaultValue>false</defaultValue>\n
    \           </component>\n            <component componentID=\"6\" access=\"read-write\">\n
    \              <name>RxFlowControl</name>\n               <synopsis>\n                 A
    flag indicating whether receive flow control is\n                 applied or not.
    \ Default is not.\n               </synopsis>\n               <optional/>\n               <typeRef>boolean</typeRef>\n
    \              <defaultValue>false</defaultValue>\n            </component>\n
    \           <component componentID=\"7\" access=\"read-reset\">\n               <name>MACInStats</name>\n
    \              <synopsis>\n                 The statistics of the EtherMACIn LFB\n
    \              </synopsis>\n               <optional/>\n               <typeRef>MACInStatsType</typeRef>\n
    \           </component>\n         </components>\n      </LFBClassDef>\n      <LFBClassDef
    LFBClassID=\"5\">\n         <name>EtherClassifier</name>\n         <synopsis>\n
    \          EtherClassifier LFB describes the process to decapsulate\n           Ethernet
    packets and then classify them into various\n           network-layer packets
    according to information in the\n           Ethernet headers.  It is expected
    the LFB classifies packets\n           by packet types like IPv4, IPv6, MPLS,
    ARP, ND, etc.\n         </synopsis>\n         <version>1.0</version>\n         <inputPorts>\n
    \           <inputPort>\n               <name>EtherPktsIn</name>\n               <synopsis>\n
    \                Input port of Ethernet packets.  PHYPortID metadata is\n                 always
    expected while LogicalPortID metadata is\n                 optionally expected
    to associate with every input\n                 Ethernet packet.\n               </synopsis>\n
    \              <expectation>\n                  <frameExpected>\n                     <ref>EthernetAll</ref>\n
    \                 </frameExpected>\n                  <metadataExpected>\n                     <ref>PHYPortID</ref>\n
    \                    <ref dependency=\"optional\" defaultValue=\"0\">\n                  LogicalPortID</ref>\n
    \                 </metadataExpected>\n               </expectation>\n            </inputPort>\n
    \        </inputPorts>\n         <outputPorts>\n            <outputPort group=\"true\">\n
    \              <name>ClassifyOut</name>\n               <synopsis>\n                 A
    group port for output of Ethernet classifying\n                 results.\n               </synopsis>\n
    \              <product>\n                  <frameProduced>\n                     <ref>Arbitrary</ref>\n
    \                 </frameProduced>\n                  <metadataProduced>\n                     <ref>PHYPortID</ref>\n
    \                    <ref>SrcMAC</ref>\n                     <ref>DstMAC</ref>\n
    \                    <ref>EtherType</ref>\n                     <ref availability=\"conditional\">VlanID</ref>\n
    \                    <ref availability=\"conditional\">VlanPriority</ref>\n                  </metadataProduced>\n
    \              </product>\n            </outputPort>\n            <outputPort
    group=\"false\">\n               <name>ExceptionOut</name>\n               <synopsis>\n
    \                A singleton port for output of all Ethernet packets\n                 that
    fail the classifying process.  An ExceptionID\n                 metadata indicates
    the failure reason.\n               </synopsis>\n               <product>\n                  <frameProduced>\n
    \                    <ref>Arbitrary</ref>\n                  </frameProduced>\n
    \                 <metadataProduced>\n                     <ref>ExceptionID</ref>\n
    \                 </metadataProduced>\n               </product>\n            </outputPort>\n
    \        </outputPorts>\n         <components>\n            <component access=\"read-write\"
    componentID=\"1\">\n               <name>EtherDispatchTable</name>\n               <synopsis>\n
    \                An EtherDispatchTable array component that is defined\n                 in
    the LFB to dispatch every Ethernet packet to output\n                 ports according
    to logical port ID assigned by the\n                 VlanInputTable in the LFB
    and Ethernet type in the\n                 Ethernet packet header.\n               </synopsis>\n
    \              <typeRef>EtherDispatchTableType</typeRef>\n            </component>\n
    \           <component access=\"read-write\" componentID=\"2\">\n               <name>VlanInputTable</name>\n
    \              <synopsis>\n                 A VlanInputTable array component that
    is defined in\n                 the LFB to classify VLAN Ethernet packets.  Every
    input\n                 packet is assigned with a new LogicalPortID according\n
    \                to the packet's incoming port ID and VLAN ID.\n               </synopsis>\n
    \              <typeRef>VlanInputTableType</typeRef>\n            </component>\n
    \           <component access=\"read-reset\" componentID=\"3\">\n               <name>EtherClassifyStats</name>\n
    \              <synopsis>\n                 A table recording statistics on the
    Ethernet\n                 classifying process in the LFB.\n               </synopsis>\n
    \              <optional/>\n               <typeRef>EtherClassifyStatsTableType</typeRef>\n
    \           </component>\n         </components>\n       </LFBClassDef>\n      <LFBClassDef
    LFBClassID=\"6\">\n         <name>EtherEncap</name>\n         <synopsis>\n           The
    EtherEncap LFB abstracts the process of encapsulating\n           Ethernet headers
    onto received packets.  The encapsulation\n           is based on passed metadata.\n
    \        </synopsis>\n         <version>1.0</version>\n         <inputPorts>\n
    \           <inputPort group=\"false\">\n               <name>EncapIn</name>\n
    \              <synopsis>\n                 An input port receiving IPv4 and/or
    IPv6 packets for\n                 encapsulation.  A MediaEncapInfoIndex metadata
    is\n                 expected, and a VLAN priority metadata is optionally\n                 expected
    with every input packet.\n               </synopsis>\n               <expectation>\n
    \              <frameExpected>\n                  <ref>IPv4</ref>\n                  <ref>IPv6</ref>\n
    \              </frameExpected>\n               <metadataExpected>\n                  <ref>MediaEncapInfoIndex</ref>\n
    \                 <ref dependency=\"optional\" defaultValue=\"0\">\n                  VlanPriority</ref>\n
    \              </metadataExpected>\n               </expectation>\n            </inputPort>\n
    \        </inputPorts>\n         <outputPorts>\n            <outputPort group=\"false\">\n
    \              <name>SuccessOut</name>\n               <synopsis>\n                 An
    output port for packets that have found Ethernet\n                 L2 information
    and have been successfully encapsulated\n                 into an Ethernet packet.
    \ An L2PortID metadata is\n                 produced for every output packet.\n
    \              </synopsis>\n               <product>\n                  <frameProduced>\n
    \                    <ref>IPv4</ref>\n                     <ref>IPv6</ref>\n                  </frameProduced>\n
    \                 <metadataProduced>\n                     <ref>L2PortID</ref>\n
    \                 </metadataProduced>\n               </product>\n            </outputPort>\n
    \           <outputPort group=\"false\">\n               <name>ExceptionOut</name>\n
    \              <synopsis>\n                 An output port for packets that fail
    encapsulation\n                 in the LFB.  An ExceptionID metadata indicates
    failure\n                 reason.\n               </synopsis>\n               <product>\n
    \                 <frameProduced>\n                     <ref>IPv4</ref>\n                     <ref>IPv6</ref>\n
    \                 </frameProduced>\n                  <metadataProduced>\n                     <ref>ExceptionID</ref>\n
    \                    <ref>MediaEncapInfoIndex</ref>\n                     <ref
    availability=\"conditional\">VlanPriority</ref>\n                  </metadataProduced>\n
    \              </product>\n            </outputPort>\n         </outputPorts>\n
    \        <components>\n            <component componentID=\"1\" access=\"read-write\">\n
    \              <name>EncapTable</name>\n               <synopsis>\n                 An
    array table for Ethernet encapsulation information\n                 lookup.  Each
    row of the array contains destination MAC\n                 address, source MAC
    address, VLAN ID, and output\n                 logical L2 port ID.\n               </synopsis>\n
    \              <typeRef>EncapTableType</typeRef>\n            </component>\n         </components>\n
    \     </LFBClassDef>\n      <LFBClassDef LFBClassID=\"7\">\n         <name>EtherMACOut</name>\n
    \        <synopsis>\n           EtherMACOut LFB abstracts an Ethernet port at
    MAC data link\n           layer.  It specifically describes Ethernet packet process\n
    \          for output to physical port.  A downstream LFB is usually\n           an
    Ethernet physical LFB like EtherPHYCop LFB.  Note that\n           Ethernet output
    functions are closely related to Ethernet\n           input functions; therefore,
    some components defined in this\n           LFB are aliases of EtherMACIn LFB
    components.\n         </synopsis>\n         <version>1.0</version>\n         <inputPorts>\n
    \           <inputPort group=\"false\">\n               <name>EtherPktsIn</name>\n
    \              <synopsis>\n                 The input port of the EtherMACOut
    LFB.  It expects\n                 any type of Ethernet frame.\n               </synopsis>\n
    \              <expectation>\n                  <frameExpected>\n                     <ref>EthernetAll</ref>\n
    \                 </frameExpected>\n                  <metadataExpected>\n                     <ref>PHYPortID</ref>\n
    \                 </metadataExpected>\n               </expectation>\n            </inputPort>\n
    \        </inputPorts>\n         <outputPorts>\n            <outputPort group=\"false\">\n
    \              <name>EtherPktsOut</name>\n               <synopsis>\n                 A
    port to output all Ethernet packets, each with a\n                 metadata indicating
    the ID of the physical port\n                 that the packet is to go through.\n
    \              </synopsis>\n               <product>\n                  <frameProduced>\n
    \                    <ref>EthernetAll</ref>\n                  </frameProduced>\n
    \                 <metadataProduced>\n                     <ref>PHYPortID</ref>\n
    \                 </metadataProduced>\n               </product>\n            </outputPort>\n
    \        </outputPorts>\n         <components>\n            <component componentID=\"1\"
    access=\"read-write\">\n               <name>AdminStatus</name>\n               <synopsis>\n
    \                The LFB status administratively requested, which has\n                 the
    same data type with a port status.  The\n                 component is defined
    as an alias of AdminStatus\n                 component in EtherMACIn LFB.\n               </synopsis>\n
    \              <alias>PortStatusType</alias>\n            </component>\n            <component
    componentID=\"2\" access=\"read-write\">\n               <name>MTU</name>\n               <synopsis>Maximum
    transmission unit (MTU) </synopsis>\n               <typeRef>uint32</typeRef>\n
    \           </component>\n            <component componentID=\"3\" access=\"read-write\">\n
    \              <name>TxFlowControl</name>\n               <synopsis>\n                 A
    flag indicating whether transmit flow control is\n                 applied, defined
    as an alias of TxFlowControl\n                 component in EtherMACIn LFB.\n
    \              </synopsis>\n               <optional/>\n               <alias>boolean</alias>\n
    \           </component>\n            <component componentID=\"4\" access=\"read-write\">\n
    \              <name>RxFlowControl</name>\n               <synopsis>\n                 A
    flag indicating whether receive flow control is\n                 applied, defined
    as an alias of RxFlowControl\n                 component in EtherMACIn LFB.\n
    \              </synopsis>\n               <optional/>\n               <alias>boolean</alias>\n
    \           </component>\n            <component componentID=\"5\" access=\"read-reset\">\n
    \              <name>MACOutStats</name>\n               <synopsis>\n                 The
    statistics of the EtherMACOut LFB\n               </synopsis>\n               <optional/>\n
    \              <typeRef>MACOutStatsType</typeRef>\n            </component>\n
    \        </components>\n      </LFBClassDef>\n      <LFBClassDef LFBClassID=\"8\">\n
    \        <name>IPv4Validator</name>\n         <synopsis>\n          This LFB performs
    IPv4 validation according to RFC 1812 and\n          its updates.  The IPv4 packet
    will be output to the\n          corresponding LFB port, indicating whether the
    packet is\n          unicast or multicast or whether an exception has occurred\n
    \         or the validation failed.\n         </synopsis>\n         <version>1.0</version>\n
    \        <inputPorts>\n            <inputPort>\n               <name>ValidatePktsIn</name>\n
    \              <synopsis>\n                 Input port for data packets to be
    validated\n               </synopsis>\n               <expectation>\n                  <frameExpected>\n
    \                    <ref>Arbitrary</ref>\n                  </frameExpected>\n
    \              </expectation>\n            </inputPort>\n         </inputPorts>\n
    \        <outputPorts>\n            <outputPort>\n               <name>IPv4UnicastOut</name>\n
    \              <synopsis>\n                 Output port for validated IPv4 unicast
    packets\n               </synopsis>\n               <product>\n                  <frameProduced>\n
    \                    <ref>IPv4Unicast</ref>\n                  </frameProduced>\n
    \              </product>\n            </outputPort>\n            <outputPort>\n
    \              <name>IPv4MulticastOut</name>\n               <synopsis>\n                 Output
    port for validated IPv4 multicast packets\n               </synopsis>\n               <product>\n
    \                 <frameProduced>\n                     <ref>IPv4Multicast</ref>\n
    \                 </frameProduced>\n               </product>\n            </outputPort>\n
    \           <outputPort>\n               <name>ExceptionOut</name>\n               <synopsis>\n
    \                Output port for all packets with exceptional cases\n                 when
    validating.  An ExceptionID metadata indicates\n                 the exception
    case type.\n               </synopsis>\n               <product>\n                  <frameProduced>\n
    \                    <ref>IPv4</ref>\n                  </frameProduced>\n                  <metadataProduced>\n
    \                    <ref>ExceptionID</ref>\n                  </metadataProduced>\n
    \              </product>\n            </outputPort>\n            <outputPort>\n
    \              <name>FailOut</name>\n               <synopsis>\n                 Output
    port for packets that failed validating\n                 process.  A ValidateErrorID
    metadata indicates the\n                 error type or failure reason.\n               </synopsis>\n
    \              <product>\n                  <frameProduced>\n                     <ref>IPv4</ref>\n
    \                 </frameProduced>\n                  <metadataProduced>\n                     <ref>ValidateErrorID</ref>\n
    \                 </metadataProduced>\n               </product>\n            </outputPort>\n
    \        </outputPorts>\n         <components>\n            <component access=\"read-write\"
    componentID=\"1\">\n               <name>IPv4ValidatorStats</name>\n               <synopsis>\n
    \                The statistics information for validating process in\n                 the
    LFB.\n               </synopsis>\n               <optional/>\n               <typeRef>IPv4ValidatorStatsType</typeRef>\n
    \           </component>\n         </components>\n       </LFBClassDef>\n      <LFBClassDef
    LFBClassID=\"9\">\n         <name>IPv6Validator</name>\n         <synopsis>\n
    \          This LFB performs IPv6 validation according to RFC 2460 and\n           its
    updates.  Then, the IPv6 packet will be output to the\n           corresponding
    port, indicating whether the packet is\n           unicast or multicast or whether
    an exception has occurred\n           or the validation failed.\n         </synopsis>\n
    \        <version>1.0</version>\n         <inputPorts>\n            <inputPort>\n
    \              <name>ValidatePktsIn</name>\n               <synopsis>\n                 Input
    port for data packets to be validated\n               </synopsis>\n               <expectation>\n
    \                 <frameExpected>\n                     <ref>Arbitrary</ref>\n
    \                 </frameExpected>\n               </expectation>\n            </inputPort>\n
    \        </inputPorts>\n         <outputPorts>\n            <outputPort>\n               <name>IPv6UnicastOut</name>\n
    \              <synopsis>\n                 Output port for validated IPv6 unicast
    packets\n               </synopsis>\n               <product>\n                  <frameProduced>\n
    \                    <ref>IPv6Unicast</ref>\n                  </frameProduced>\n
    \              </product>\n            </outputPort>\n            <outputPort>\n
    \              <name>IPv6MulticastOut</name>\n               <synopsis>\n                 Output
    port for validated IPv6 multicast packets\n               </synopsis>\n               <product>\n
    \                 <frameProduced>\n                     <ref>IPv6Multicast</ref>\n
    \                 </frameProduced>\n               </product>\n            </outputPort>\n
    \           <outputPort>\n               <name>ExceptionOut</name>\n               <synopsis>\n
    \                Output port for packets with exceptional cases when\n                 validating.
    \ An ExceptionID metadata indicates the\n                 exception case type.\n
    \              </synopsis>\n               <product>\n                  <frameProduced>\n
    \                    <ref>IPv6</ref>\n                  </frameProduced>\n                  <metadataProduced>\n
    \                    <ref>ExceptionID</ref>\n                  </metadataProduced>\n
    \              </product>\n            </outputPort>\n            <outputPort>\n
    \              <name>FailOut</name>\n               <synopsis>\n                 Output
    port for packets failed validating process.\n                 A ValidateErrorID
    metadata indicates the error type\n                 or failure reason.\n               </synopsis>\n
    \              <product>\n                  <frameProduced>\n                     <ref>IPv6</ref>\n
    \                 </frameProduced>\n                  <metadataProduced>\n                     <ref>ValidateErrorID</ref>\n
    \                 </metadataProduced>\n               </product>\n            </outputPort>\n
    \        </outputPorts>\n         <components>\n            <component access=\"read-write\"
    componentID=\"1\">\n               <name>IPv6ValidatorStats</name>\n               <synopsis>\n
    \                The statistics information for validating process in\n                 the
    LFB.\n               </synopsis>\n               <optional/>\n               <typeRef>IPv6ValidatorStatsType</typeRef>\n
    \           </component>\n         </components>\n       </LFBClassDef>\n      <LFBClassDef
    LFBClassID=\"10\">\n         <name>IPv4UcastLPM</name>\n         <synopsis>\n
    \          The IPv4UcastLPM LFB abstracts the IPv4 unicast Longest\n           Prefix
    Match (LPM) process.  This LFB supports\n           implementing equal-cost multipath
    (ECMP) routing and\n           reverse path forwarding (RPF).\n         </synopsis>\n
    \        <version>1.0</version>\n         <inputPorts>\n            <inputPort
    group=\"false\">\n               <name>PktsIn</name>\n               <synopsis>\n
    \                A port for input of packets to be processed.\n                 IPv4
    unicast packets are expected.\n               </synopsis>\n               <expectation>\n
    \              <frameExpected>\n                  <ref>IPv4Unicast</ref>\n               </frameExpected>\n
    \              </expectation>\n            </inputPort>\n         </inputPorts>\n
    \        <outputPorts>\n            <outputPort group=\"false\">\n               <name>NormalOut</name>\n
    \              <synopsis>\n                 An output port to output IPv4 unicast
    packets that\n                 successfully passed the LPM lookup.  A HopSelector\n
    \                metadata is produced to associate every output packet\n                 for
    downstream LFB to do next-hop action.\n               </synopsis>\n               <product>\n
    \                 <frameProduced>\n                     <ref>IPv4Unicast</ref>\n
    \                 </frameProduced>\n                  <metadataProduced>\n                     <ref>HopSelector</ref>\n
    \                 </metadataProduced>\n               </product>\n            </outputPort>\n
    \           <outputPort group=\"false\">\n               <name>ECMPOut</name>\n
    \              <synopsis>\n                 The port to output packets needing
    further ECMP\n                 processing.  A downstream ECMP processing LFB is\n
    \                usually followed to the port.  If ECMP is not\n                 required,
    no downstream LFB may be connected to\n                 the port.\n               </synopsis>\n
    \              <product>\n                  <frameProduced>\n                     <ref>IPv4Unicast</ref>\n
    \                 </frameProduced>\n                  <metadataProduced>\n                     <ref>HopSelector</ref>\n
    \                 </metadataProduced>\n               </product>\n            </outputPort>\n
    \           <outputPort group=\"false\">\n               <name>ExceptionOut</name>\n
    \              <synopsis>\n                 The port to output all packets with
    exceptional cases\n                 happened during LPM process.  An ExceptionID
    metadata\n                 is associated to indicate what caused the exception.\n
    \              </synopsis>\n               <product>\n                  <frameProduced>\n
    \                    <ref>IPv4Unicast</ref>\n                  </frameProduced>\n
    \                 <metadataProduced>\n                     <ref>ExceptionID</ref>\n
    \                 </metadataProduced>\n               </product>\n            </outputPort>\n
    \        </outputPorts>\n         <components>\n            <component componentID=\"1\"
    access=\"read-write\">\n               <name>IPv4PrefixTable</name>\n               <synopsis>\n
    \                A table for IPv4 Longest Prefix Match(LPM).  The\n                 destination
    IPv4 address of every input packet is\n                 used as a search key to
    look up the table to find\n                 out a next-hop selector.\n               </synopsis>\n
    \              <typeRef>IPv4PrefixTableType</typeRef>\n            </component>\n
    \           <component componentID=\"2\" access=\"read-reset\">\n               <name>IPv4UcastLPMStats</name>\n
    \              <synopsis>\n                 The statistics information for the
    IPv4 unicast LPM\n                 process in the LFB.\n               </synopsis>\n
    \              <optional/>\n               <typeRef>IPv4UcastLPMStatsType</typeRef>\n
    \           </component>\n         </components>\n      </LFBClassDef>\n      <LFBClassDef
    LFBClassID=\"11\">\n         <name>IPv6UcastLPM</name>\n         <synopsis>\n
    \          The IPv6UcastLPM LFB abstracts the IPv6 unicast Longest\n           Prefix
    Match (LPM) process.  This LFB supports\n           implementing equal-cost multipath
    (ECMP) routing and\n           reverse path forwarding (RPF).\n         </synopsis>\n
    \        <version>1.0</version>\n         <inputPorts>\n            <inputPort
    group=\"false\">\n               <name>PktsIn</name>\n               <synopsis>\n
    \                A port for input of packets to be processed.\n                 IPv6
    unicast packets are expected.\n               </synopsis>\n               <expectation>\n
    \              <frameExpected>\n                  <ref>IPv6Unicast</ref>\n               </frameExpected>\n
    \              </expectation>\n            </inputPort>\n         </inputPorts>\n
    \        <outputPorts>\n            <outputPort group=\"false\">\n               <name>NormalOut</name>\n
    \              <synopsis>\n                 An output port to output IPv6 unicast
    packets that\n                 successfully passed the LPM lookup.  A HopSelector\n
    \                metadata is produced to associate every output packet\n                 for
    downstream LFB to do next-hop action.\n               </synopsis>\n               <product>\n
    \                 <frameProduced>\n                     <ref>IPv6Unicast</ref>\n
    \                 </frameProduced>\n                  <metadataProduced>\n                     <ref>HopSelector</ref>\n
    \                 </metadataProduced>\n               </product>\n            </outputPort>\n
    \           <outputPort group=\"false\">\n               <name>ECMPOut</name>\n
    \              <synopsis>\n                 The port to output packets needing
    further ECMP\n                 processing.  A downstream ECMP processing LFB is\n
    \                usually followed to the port.  If ECMP is not\n                 required,
    no downstream LFB may be connected to\n                 the port.\n               </synopsis>\n
    \              <product>\n                  <frameProduced>\n                     <ref>IPv6Unicast</ref>\n
    \                 </frameProduced>\n                  <metadataProduced>\n                     <ref>HopSelector</ref>\n
    \                 </metadataProduced>\n               </product>\n            </outputPort>\n
    \           <outputPort group=\"false\">\n               <name>ExceptionOut</name>\n
    \              <synopsis>\n                 The port to output all packets with
    exceptional cases\n                 happened during LPM process.  An ExceptionID
    metadata\n                 is associated to indicate what caused the exception.\n
    \              </synopsis>\n               <product>\n                  <frameProduced>\n
    \                    <ref>IPv6Unicast</ref>\n                  </frameProduced>\n
    \                 <metadataProduced>\n                     <ref>ExceptionID</ref>\n
    \                 </metadataProduced>\n               </product>\n            </outputPort>\n
    \        </outputPorts>\n         <components>\n            <component componentID=\"1\"
    access=\"read-write\">\n               <name>IPv6PrefixTable</name>\n               <synopsis>\n
    \                A table for IPv6 Longest Prefix Match (LPM).  The\n                 destination
    IPv6 address of every input packet is\n                 used as a search key to
    look up the table to find\n                 out a next-hop selector.\n               </synopsis>\n
    \              <typeRef>IPv6PrefixTableType</typeRef>\n            </component>\n
    \           <component componentID=\"2\" access=\"read-reset\">\n               <name>IPv6UcastLPMStats</name>\n
    \              <synopsis>\n                The statistics information for the
    IPv6 unicast LPM\n                process in the LFB.\n               </synopsis>\n
    \              <optional/>\n               <typeRef>IPv6UcastLPMStatsType</typeRef>\n
    \           </component>\n         </components>\n      </LFBClassDef>\n      <LFBClassDef
    LFBClassID=\"12\">\n         <name>IPv4NextHop</name>\n         <synopsis>\n           The
    IPv4NextHop LFB abstracts the process of next-hop\n           information application
    to IPv4 packets.  It receives an\n           IPv4 packet with an associated next-hop
    identifier\n           (HopSelector) and uses the identifier as a table index\n
    \          to look up a next-hop table to find an appropriate output\n           port.
    \ The data processing also involves the forwarding\n           TTL decrement and
    IP checksum recalculation.\n         </synopsis>\n         <version>1.0</version>\n
    \        <inputPorts>\n            <inputPort group=\"false\">\n               <name>PktsIn</name>\n
    \              <synopsis>\n                 A port for input of unicast IPv4 packets,
    along with\n                 a HopSelector metadata.\n               </synopsis>\n
    \              <expectation>\n               <frameExpected>\n                  <ref>IPv4Unicast</ref>\n
    \              </frameExpected>\n               <metadataExpected>\n                  <ref>HopSelector</ref>\n
    \              </metadataExpected>\n               </expectation>\n            </inputPort>\n
    \        </inputPorts>\n         <outputPorts>\n            <outputPort group=\"true\">\n
    \              <name>SuccessOut</name>\n               <synopsis>\n                 The
    group port for output of packets that\n                 successfully found next-hop
    information.  Some\n                 metadata are associated with every packet.\n
    \              </synopsis>\n               <product>\n                  <frameProduced>\n
    \                    <ref>IPv4Unicast</ref>\n                  </frameProduced>\n
    \                 <metadataProduced>\n                     <ref>L3PortID</ref>\n
    \                    <ref>NextHopIPv4Addr</ref>\n                     <ref availability=\"conditional\">\n
    \                    MediaEncapInfoIndex</ref>\n                  </metadataProduced>\n
    \              </product>\n            </outputPort>\n            <outputPort
    group=\"false\">\n               <name>ExceptionOut</name>\n               <synopsis>\n
    \                The output port for packets with exceptional or\n                 failure
    cases.  An ExceptionID metadata indicates\n                 what caused the case.\n
    \              </synopsis>\n               <product>\n                  <frameProduced>\n
    \                    <ref>IPv4Unicast</ref>\n                  </frameProduced>\n
    \                 <metadataProduced>\n                     <ref>ExceptionID</ref>\n
    \                 </metadataProduced>\n               </product>\n            </outputPort>\n
    \        </outputPorts>\n         <components>\n            <component componentID=\"1\">\n
    \              <name>IPv4NextHopTable</name>\n               <synopsis>\n                 The
    IPv4NextHopTable component.  A\n                 HopSelector is used to match
    the table index\n                 to find out a row that contains the next-hop\n
    \                information result.\n               </synopsis>\n               <typeRef>IPv4NextHopTableType</typeRef>\n
    \           </component>\n         </components>\n      </LFBClassDef>\n      <LFBClassDef
    LFBClassID=\"13\">\n         <name>IPv6NextHop</name>\n         <synopsis>\n           The
    LFB abstracts the process of next-hop information\n           application to IPv6
    packets.  It receives an IPv6 packet\n           with an associated next-hop identifier
    (HopSelector) and\n           uses the identifier as a table index to look up
    a next-hop\n           table to find an appropriate output port.\n         </synopsis>\n
    \        <version>1.0</version>\n         <inputPorts>\n            <inputPort
    group=\"false\">\n               <name>PktsIn</name>\n               <synopsis>\n
    \                A port for input of unicast IPv6 packets, along with\n                 a
    HopSelector metadata.\n                </synopsis>\n               <expectation>\n
    \              <frameExpected>\n                  <ref>IPv6Unicast</ref>\n               </frameExpected>\n
    \              <metadataExpected>\n                  <ref>HopSelector</ref>\n
    \              </metadataExpected>\n               </expectation>\n            </inputPort>\n
    \        </inputPorts>\n         <outputPorts>\n            <outputPort group=\"true\">\n
    \              <name>SuccessOut</name>\n               <synopsis>\n                 The
    group port for output of packets that successfully\n                 found next-hop
    information.  Some metadata are\n                 associated with every packet.\n
    \               </synopsis>\n               <product>\n                  <frameProduced>\n
    \                    <ref>IPv6Unicast</ref>\n                  </frameProduced>\n
    \                 <metadataProduced>\n                     <ref>L3PortID</ref>\n
    \                    <ref>NextHopIPv6Addr</ref>\n                     <ref availability=\"conditional\">\n
    \                    MediaEncapInfoIndex</ref>\n                  </metadataProduced>\n
    \              </product>\n            </outputPort>\n            <outputPort
    group=\"false\">\n               <name>ExceptionOut</name>\n               <synopsis>\n
    \                The output port for packets with exceptional or\n                 failure
    cases.  An ExceptionID metadata indicates\n                 what caused the case.\n
    \              </synopsis>\n               <product>\n                  <frameProduced>\n
    \                    <ref>IPv6Unicast</ref>\n                  </frameProduced>\n
    \                 <metadataProduced>\n                     <ref>ExceptionID</ref>\n
    \                 </metadataProduced>\n               </product>\n            </outputPort>\n
    \        </outputPorts>\n         <components>\n            <component componentID=\"1\">\n
    \              <name>IPv6NextHopTable</name>\n               <synopsis>\n                 The
    IPv6NextHopTable component.  A HopSelector is\n                 used to match
    the table index to find out a row that\n                 contains the next-hop
    information result.\n               </synopsis>\n               <typeRef>IPv6NextHopTableType</typeRef>\n
    \           </component>\n         </components>\n      </LFBClassDef>\n      <LFBClassDef
    LFBClassID=\"14\">\n         <name>RedirectIn</name>\n         <synopsis>\n           The
    RedirectIn LFB abstracts the process for the ForCES CE to\n           inject data
    packets into the ForCES FE LFBs.\n         </synopsis>\n         <version>1.0</version>\n
    \        <outputPorts>\n            <outputPort group=\"true\">\n               <name>PktsOut</name>\n
    \              <synopsis>\n                 The output port of RedirectIn LFB,
    which is defined as\n                 a group port type.  From the LFB topology's
    point of\n                 view, the RedirectIn LFB acts as a source point for\n
    \                data packets coming from CE; therefore, the LFB is\n                 defined
    with a singleton output port (and no input\n                 port).\n               </synopsis>\n
    \              <product>\n                  <frameProduced>\n                     <ref>Arbitrary</ref>\n
    \                 </frameProduced>\n               </product>\n            </outputPort>\n
    \        </outputPorts>\n         <components>\n            <component componentID=\"1\">\n
    \              <name>NumPacketsReceived</name>\n               <synopsis>\n                 Number
    of packets received from CE.\n               </synopsis>\n               <optional/>\n
    \              <typeRef>uint64</typeRef>\n            </component>\n         </components>\n
    \     </LFBClassDef>\n      <LFBClassDef LFBClassID=\"15\">\n         <name>RedirectOut</name>\n
    \        <synopsis>\n           The RedirectOut LFB abstracts the process for
    LFBs in a\n           ForCES FE to deliver data packets to the ForCES CE.\n         </synopsis>\n
    \        <version>1.0</version>\n         <inputPorts>\n            <inputPort
    group=\"false\">\n               <name>PktsIn</name>\n               <synopsis>\n
    \                The input port for the RedirectOut LFB.  From the LFB\n                 topology's
    point of view, the RedirectOut LFB acts as\n                 a sink point for
    data packets going to the CE;\n                 therefore, RedirectOut LFB is
    defined with a\n                 singleton input port (and no output port).\n
    \              </synopsis>\n               <expectation>\n                  <frameExpected>\n
    \                    <ref>Arbitrary</ref>\n                  </frameExpected>\n
    \              </expectation>\n            </inputPort>\n         </inputPorts>\n
    \        <components>\n            <component componentID=\"1\">\n               <name>NumPacketsSent</name>\n
    \              <synopsis>\n                 Number of packets sent to CE.\n               </synopsis>\n
    \              <optional/>\n               <typeRef>uint64</typeRef>\n            </component>\n
    \        </components>\n      </LFBClassDef>\n      <LFBClassDef LFBClassID=\"16\">\n
    \        <name>BasicMetadataDispatch</name>\n         <synopsis>\n           The
    BasicMetadataDispatch LFB is defined to abstract the\n           process by which
    packets are dispatched to various output\n           paths based on associated
    metadata value.  Current\n           version of the LFB only allows the metadata
    value to be\n           a 32-bit integer.\n         </synopsis>\n         <version>1.0</version>\n
    \        <inputPorts>\n            <inputPort>\n               <name>PktsIn</name>\n
    \              <synopsis>\n                 The packet input port for dispatching.
    \ Every input\n                 packet should be associated with a metadata that
    will\n                 be used by the LFB to do the dispatch.\n               </synopsis>\n
    \              <expectation>\n                  <frameExpected>\n                     <ref>Arbitrary</ref>\n
    \                 </frameExpected>\n                  <metadataExpected>\n                     <ref>Arbitrary</ref>\n
    \                 </metadataExpected>\n               </expectation>\n            </inputPort>\n
    \        </inputPorts>\n         <outputPorts>\n            <outputPort group=\"true\">\n
    \              <name>PktsOut</name>\n               <synopsis>\n                 The
    group output port that outputs dispatching\n                 results.  A packet
    with its associated metadata\n                 having found an OutputIndex by
    successfully looking\n                 up the dispatch table will be output to
    the group\n                 port instance with the corresponding index.\n               </synopsis>\n
    \              <product>\n                  <frameProduced>\n                     <ref>Arbitrary</ref>\n
    \                 </frameProduced>\n               </product>\n            </outputPort>\n
    \           <outputPort group=\"false\">\n               <name>ExceptionOut</name>\n
    \              <synopsis>\n                 The output port that outputs packets
    that failed\n                 to process.  An ExceptionID metadata indicates what\n
    \                caused the exception.\n               </synopsis>\n               <product>\n
    \                 <frameProduced>\n                     <ref>Arbitrary</ref>\n
    \                 </frameProduced>\n                  <metadataProduced>\n                     <ref>ExceptionID</ref>\n
    \                 </metadataProduced>\n               </product>\n            </outputPort>\n
    \        </outputPorts>\n         <components>\n            <component access=\"read-write\"
    componentID=\"1\">\n               <name>MetadataID</name>\n               <synopsis>\n
    \                The ID of the metadata to be\n                 used for dispatching
    packets.\n               </synopsis>\n               <typeRef>uint32</typeRef>\n
    \           </component>\n            <component access=\"read-write\" componentID=\"2\">\n
    \              <name>MetadataDispatchTable</name>\n               <synopsis>\n
    \                The MetadataDispatchTable component, which contains\n                 entries
    of a metadata value and an output index,\n                 specifying that a packet
    with the metadata value must\n                 go out from the instance with the
    output index of the\n                 LFB group output port.\n               </synopsis>\n
    \              <typeRef>MetadataDispatchTableType</typeRef>\n            </component>\n
    \        </components>\n       </LFBClassDef>\n      <LFBClassDef LFBClassID=\"17\">\n
    \        <name>GenericScheduler</name>\n         <synopsis>\n           This is
    a preliminary generic scheduler LFB abstracting\n           a simple scheduling
    process, which may be used as a\n           basic LFB to construct a more complex
    scheduler LFB.\n         </synopsis>\n         <version>1.0</version>\n         <inputPorts>\n
    \           <inputPort group=\"true\">\n               <name>PktsIn</name>\n               <synopsis>\n
    \                The group input port of the LFB.  Inside the LFB,\n                 each
    instance of the group port is connected to\n                 a queue marked with
    a queue ID, whose value is\n                 index of the port instance.\n               </synopsis>\n
    \              <expectation>\n                  <frameExpected>\n                     <ref>Arbitrary</ref>\n
    \                 </frameExpected>\n               </expectation>\n            </inputPort>\n
    \        </inputPorts>\n         <outputPorts>\n            <outputPort>\n               <name>PktsOut</name>\n
    \              <synopsis>\n                 The output port of the LFB.  Scheduled
    packets are\n                 output from the port.\n               </synopsis>\n
    \              <product>\n                  <frameProduced>\n                     <ref>Arbitrary</ref>\n
    \                 </frameProduced>\n               </product>\n            </outputPort>\n
    \        </outputPorts>\n         <components>\n            <component access=\"read-write\"
    componentID=\"1\">\n               <name>SchedulingDiscipline</name>\n               <synopsis>\n
    \                The SchedulingDiscipline component, which is for the\n                 CE
    to specify a scheduling discipline to the LFB.\n               </synopsis>\n               <typeRef>SchdDisciplineType</typeRef>\n
    \              <defaultValue>1</defaultValue>\n            </component>\n            <component
    access=\"read-only\" componentID=\"2\">\n               <name>QueueStats</name>\n
    \              <synopsis>\n                 The QueueStats component, which is
    defined to allow\n                 the CE to query every queue statistics in the\n
    \                scheduler.\n               </synopsis>\n               <optional/>\n
    \              <typeRef>QueueStatsTableType</typeRef>\n            </component>\n
    \        </components>\n         <capabilities>\n            <capability componentID=\"30\">\n
    \              <name>QueueLenLimit</name>\n               <synopsis>\n                 The
    QueueLenLimit capability, which specifies\n                 maximum length of
    each queue.  The length unit is in\n                 bytes.\n               </synopsis>\n
    \              <typeRef>uint32</typeRef>\n            </capability>\n         </capabilities>\n
    \      </LFBClassDef>\n   </LFBClassDefs>\n"
  - '</LFBLibrary>

    '
  title: 6.  XML for LFB Library
- contents:
  - "7.  LFB Class Use Cases\n   This section demonstrates examples on how the LFB
    classes defined by\n   the base LFB library in Section 6 can be applied to achieve
    some\n   typical router functions.  The functions demonstrated are:\n   o  IPv4
    forwarding\n   o  ARP processing\n   It is assumed the LFB topology on the FE
    described has already been\n   established by the CE and maps to the use cases
    illustrated in this\n   section.\n   The use cases demonstrated in this section
    are mere examples and by\n   no means should be treated as the only way one would
    construct router\n   functionality from LFBs; based on the capability of the FE(s),
    a CE\n   should be able to express different NE applications.\n"
  - contents:
    - "7.1.  IPv4 Forwarding\n   Figure 2 shows the typical LFB processing path for
      an IPv4 unicast\n   forwarding case with Ethernet media interfaces by use of
      the base LFB\n   classes.  Note that in the figure, to focus on the IP forwarding\n
      \  function, some inputs or outputs of LFBs that are not related to the\n   IPv4
      forwarding function are not shown.  For example, an\n   EtherClassifier LFB
      normally has two output ports: a \"ClassifyOut\"\n   group output port and an
      \"ExceptionOut\" singleton output port, with\n   the group port containing various
      port instances according to various\n   classified packet types (Section 5.1.3).
      \ In this figure, only the\n   IPv4 and IPv6 packet output port instances are
      shown for displaying\n   the mere IPv4 forwarding processing function.\n   +-----+
      \               +------+\n   |     |                |      |\n   |     |<---------------|Ether
      |<----------------------------+\n   |     |                |MACOut|                             |\n
      \  |     |                |      |                             |\n   |Ether|
      \               +------+                             |\n   |PHY  |                                                     |\n
      \  |Cop  |            +---+                                    |\n   |#1   |
      \ +-----+   |   |----->IPv6 Packets                  |\n   |     |  |     |
      \  |   |                                    |\n   |     |  |Ether|   |   | IPv4
      Packets                       |\n   |     |->|MACIn|-->|   |-+  +----+                          |\n
      \  +-----+  |     |   |   | |  |    |---> Multicast Packets    |\n            +-----+
      \  +---+ |  |    |        +-----+  +---+    |\n                      Ether +->|
      \   |------->|     |  |   |    |\n      .           Classifier|  |    |Unicast
      |IPv4 |  |   |    |\n      .                     |  |    |Packets |Ucast|->|
      \  |--+ |\n      .                     |  +----+        |LPM  |  |   |  | |\n
      \                     +---+ |   IPv4         +-----+  +---+  | |\n            +-----+
      \  |   | |   Validator              IPv4  | |\n            |     |   |   | |
      \                        NextHop| |\n   +-----+  |Ether|   |   |-+ IPv4 Packets
      \                  | |\n   |     |->|MACIn|-->|   |                                  |
      |\n   |     |  |     |   |   |----->IPv6 Packets                | |\n   |Ether|
      \ +-----+   +---+                                  | |\n   |PHY  |           Ether
      \              +----+              | |\n   |Cop  |           Classifier          |
      \   |   +-------+  | |\n   |#n   |                +------+       |    |   |Ether
      \ |  | |\n   |     |                |      |       |    |<--|Encap  |<-+ |\n
      \  |     |                |      |<------|    |   |       |    |\n   |     |<---------------|Ether
      |    ...|    |   +-------+    |\n   |     |                |MACOut|   +---|
      \   |                |\n   |     |                |      |   |   +----+                |\n
      \  +-----+                +------+   | BasicMetadataDispatch   |\n                                     +----------->-------------+\n
      \               Figure 2:  LFB Use Case for IPv4 Forwarding\n   In the LFB use
      case, a number of EtherPHYCop LFB (Section 5.1.1)\n   instances are used to
      describe physical-layer functions of the ports.\n   PHYPortID metadata is generated
      by the EtherPHYCop LFB and is used by\n   all the subsequent downstream LFBs.
      \ An EtherMACIn LFB\n   (Section 5.1.2), which describes the MAC-layer processing,
      follows\n   every EtherPHYCop LFB.  The EtherMACIn LFB may do a locality check
      of\n   MAC addresses if the CE configures the appropriate EtherMACIn LFB\n   component.\n
      \  Ethernet packets out of the EtherMACIn LFB are sent to an\n   EtherClassifier
      LFB (Section 5.1.3) to be decapsulated and classified\n   into network-layer
      types like IPv4, IPv6, ARP, etc.  In the example\n   use case, every physical
      Ethernet interface is associated with one\n   Classifier instance; although
      not illustrated, it is also feasible\n   that all physical interfaces are associated
      with only one Ethernet\n   Classifier instance.\n   EtherClassifier uses the
      PHYPortID metadata, the Ethernet type of the\n   input packet, and VlanID (if
      present in the input Ethernet packets)\n   to decide the packet network-layer
      type and the LFB output port to\n   the downstream LFB.  The EtherClassifier
      LFB also assigns a new\n   logical port ID metadata to the packet for later
      use.  The\n   EtherClassifier may also generate some new metadata for every
      packet,\n   like EtherType, SrcMAC, DstMAC, LogicPortID, etc., for consumption
      by\n   downstream LFBs.\n   If a packet is classified as an IPv4 packet, it
      is sent downstream to\n   an IPv4Validator LFB (Section 5.2.1) to validate the
      IPv4 packet.  In\n   the validator LFB, IPv4 packets are validated and are additionally\n
      \  classified into either IPv4 unicast packets or multicast packets.\n   IPv4
      unicast packets are sent to downstream to the IPv4UcastLPM LFB\n   (Section
      5.3.1).\n   The IPv4UcastLPM LFB is where the longest prefix match decision
      is\n   made, and a next-hop selection is selected.  The next-hop ID metadata\n
      \  is generated by the IPv4UcastLPM LFB to be consumed downstream by the\n   IPv4NextHop
      LFB (Section 5.3.2).\n   The IPv4NextHop LFB uses the next-hop ID metadata to
      derive where the\n   packet is to go next and the media encapsulation type for
      the port,\n   etc.  The IPv4NextHop LFB generates the L3PortID metadata used
      to\n   identify a next-hop output physical/logical port.  In the example use\n
      \  case, the next-hop output port is an Ethernet type; as a result, the\n   packet
      and its L3 port ID metadata are sent downstream to an\n   EtherEncap LFB (Section
      5.1.4).\n   The EtherEncap LFB encapsulates the incoming packet into an Ethernet\n
      \  frame.  A BasicMetadataDispatch LFB (Section 5.5.1) follows the\n   EtherEncap
      LFB.  The BasicMetadataDispatch LFB is where packets are\n   finally dispatched
      to different output physical/logical ports based\n   on the L3PortID metadata
      sent to the LFB.\n"
    title: 7.1.  IPv4 Forwarding
  - contents:
    - "7.2.  ARP Processing\n   Figure 3 shows the processing path for the Address
      Resolution\n   Protocol (ARP) in the case the CE implements the ARP processing\n
      \  function.  By no means is this the only way ARP processing could be\n   achieved;
      as an example, ARP processing could happen at the FE, but\n   that discussion
      is out of the scope of this use case.\n          +---+                             +---+\n
      \         |   | ARP packets                 |   |\n          |   |-------------->---------+--->|
      \  | To CE\n    ...-->|   | .                      |    |   |\n          |   |
      .                      |    +---+\n          |   | .                      |
      \  RedirectOut\n          +---+                        ^\n          Ether     EtherEncap
      \        | IPv4 packets lack\n        Classifier   +---+             | address
      resolution information\n                     |   |             |\n       Packets
      need  |   |--------->---+\n        ...--------->|   |\n     L2 Encapsulation|
      \  |\n          +---+      |   |                     +------+\n          |   |
      \ +-->|   |--+   +---+          |Ether |\n          |   |  |   +---+  |   |
      \  |--------->|MACOut|-->...\n   From CE|   |--+          +-->|   | .        +------+\n
      \         |   |ARP Packets      |   | .\n          |   |from CE          |   |
      .        +------+\n          |   |                 |   |--------> |Ether |-->...\n
      \         +---+                 +---+          |MACOut|\n       RedirectIn            BasicMetadata
      \    +------+\n                             Dispatch\n                      Figure
      3: LFB Use Case for ARP\n   There are two ways ARP processing could be triggered
      in the CE as\n   illustrated in Figure 3:\n   o  ARP packets arriving from outside
      of the NE.\n   o  IPV4 packets failing to resolve within the FE.\n   ARP packets
      from network interfaces are filtered out by\n   EtherClassifier LFB.  The classified
      ARP packets and associated\n   metadata are then sent downstream to the RedirectOut
      LFB\n   (Section 5.4.2) to be transported to CE.\n   The EtherEncap LFB, as
      described in Section 5.1.4, receives packets\n   that need Ethernet L2 encapsulating.
      \ When the EtherEncap LFB fails\n   to find the necessary L2 Ethernet information
      with which to\n   encapsulate the packet, it outputs the packet to its ExceptionOut
      LFB\n   port.  Downstream to EtherEncap LFB's ExceptionOut LFB port is the\n
      \  RedirectOut LFB, which transports the packet to the CE (see\n   Section 5.1.4
      on EtherEncap LFB for details).\n   To achieve its goal, the CE needs to generate
      ARP request and\n   response packets and send them to external (to the NE) networks.
      \ ARP\n   request and response packets from the CE are redirected to an FE via\n
      \  a RedirectIn LFB (Section 5.4.1).\n   As was the case with forwarded IPv4
      packets, outgoing ARP packets are\n   also encapsulated to Ethernet format by
      the EtherEncap LFB, and then\n   dispatched to different interfaces via a BasicMetadataDispatch
      LFB.\n   The BasicMetadataDispatch LFB dispatches the packets according to the\n
      \  L3PortID metadata included in every ARP packet sent from CE.\n"
    title: 7.2.  ARP Processing
  title: 7.  LFB Class Use Cases
- contents:
  - "8.  IANA Considerations\n   IANA has created a registry of ForCES LFB class names
    and the\n   corresponding ForCES LFB class identifiers, with the location of the\n
    \  definition of the ForCES LFB class, in accordance with the rules to\n   use
    the namespace.\n   This document registers the unique class names and numeric
    class\n   identifiers for the LFBs listed in Section 8.1.  Besides, this\n   document
    defines the following namespaces:\n   o  Metadata ID, defined in Sections 4.3
    and 4.4\n   o  Exception ID, defined in Section 4.4\n   o  Validate Error ID,
    defined in Section 4.4\n"
  - contents:
    - "8.1.  LFB Class Names and LFB Class Identifiers\n   LFB classes defined by
      this document belong to LFBs defined by\n   Standards Track RFCs.  According
      to IANA, the registration procedure\n   is Standards Action for the range 0
      to 65535 and First Come First\n   Served with any publicly available specification
      for over 65535.\n   The assignment of LFB class names and LFB class identifiers
      is as in\n   the following table.\n   +----------+--------------- +------------------------+--------------+\n
      \  |LFB Class | LFB Class Name |     Description        |  Reference   |\n   |Identifier|
      \               |                        |              |\n   +----------+---------------
      +------------------------+--------------+\n   |    3     |  EtherPHYCop   |
      Define an Ethernet port|   RFC 6956,  |\n   |          |                | abstracted
      at physical | Section 5.1.1|\n   |          |                | layer.                 |
      \             |\n   |          |                |                        |              |\n
      \  |    4     |  EtherMACIn    | Define an Ethernet     |   RFC 6956,  |\n   |
      \         |                | input port at MAC data | Section 5.1.2|\n   |          |
      \               | link layer.            |              |\n   |          |                |
      \                       |              |\n   |    5     |EtherClassifier | Define
      the process to  |   RFC 6956,  |\n   |          |                | decapsulate
      Ethernet   | Section 5.1.3|\n   |          |                | packets and classify
      \  |              |\n   |          |                | the packets.           |
      \             |\n   |          |                |                        |              |\n
      \  |    6     |  EtherEncap    | Define the process to  |   RFC 6956,  |\n   |
      \         |                | encapsulate IP packets | Section 5.1.4|\n   |          |
      \               | to Ethernet packets.   |              |\n   |          |                |
      \                       |              |\n   |    7     |  EtherMACOut   | Define
      an Ethernet     |   RFC 6956   |\n   |          |                | output port
      at MAC     | Section 5.1.5|\n   |          |                | data link layer.
      \      |              |\n   |          |                |                        |
      \             |\n   |    8     | IPv4Validator  | Perform IPv4 packets   |   RFC
      6956,  |\n   |          |                | validation.            | Section
      5.2.1|\n   |          |                |                        |              |\n
      \  |    9     | IPv6Validator  | Perform IPv6 packets   |   RFC 6956,  |\n   |
      \         |                | validation.            | Section 5.2.2|\n   |          |
      \               |                        |              |\n   |    10    | IPv4UcastLPM
      \  | Perform IPv4 Longest   |   RFC 6956,  |\n   |          |                |
      Prefix Match Lookup.   | Section 5.3.1|\n   |          |                |                        |
      \             |\n   |    11    | IPv6UcastLPM   | Perform IPv6 Longest   |   RFC
      6956,  |\n   |          |                | Prefix Match Lookup.   | Section
      5.3.3|\n   |          |                |                        |              |\n
      \  |    12    |  IPv4NextHop   | Define the process of  |   RFC 6956,  |\n   |
      \         |                | selecting IPv4 next-hop| Section 5.3.2|\n   |          |
      \               | action.                |              |\n   |          |                |
      \                       |              |\n   |    13    |  IPv6NextHop   | Define
      the process of  |   RFC 6956,  |\n   |          |                | selecting
      IPv6 next-hop| Section 5.3.4|\n   |          |                | action.                |
      \             |\n   |          |                |                        |              |\n
      \  |    14    |  RedirectIn    | Define the process for |   RFC 6956,  |\n   |
      \         |                | CE to inject data      | Section 5.4.1|\n   |          |
      \               | packets into FE LFB    |              |\n   |          |                |
      topology.              |              |\n   |          |                |                        |
      \             |\n   |    15    |  RedirectOut   | Define the process for |   RFC
      6956,  |\n   |          |                | LFBs in FE to deliver  | Section
      5.4.2|\n   |          |                | data packets to CE.    |              |\n
      \  |          |                |                        |              |\n   |
      \   16    | BasicMetadata  | Dispatch input packets |   RFC 6956,  |\n   |          |
      \   Dispatch    | to a group output      | Section 5.5.1|\n   |          |                |
      according to a metadata|              |\n   |          |                |                        |
      \             |\n   |    17    |GenericScheduler| Define a preliminary   |   RFC
      6956,  |\n   |          |                | generic scheduling     | Section
      5.5.2|\n   |          |                | process.               |              |\n
      \  +----------+--------------- +------------------------+--------------+\n                                 Table
      1\n"
    title: 8.1.  LFB Class Names and LFB Class Identifiers
  - contents:
    - "8.2.  Metadata ID\n   The Metadata ID namespace is 32 bits long.  Below are
      the guidelines\n   for managing the namespace.\n   Metadata IDs in the range
      of 0x00000001-0x7FFFFFFF are Specification\n   Required [RFC5226].  A metadata
      ID using this range MUST be\n   documented in an RFC or other permanent and
      readily available\n   reference.\n   Values assigned by this specification:\n
      \  +--------------+-------------------------+--------------------------+\n   |
      \  Value      |           Name          |        Definition        |\n   +--------------+-------------------------+--------------------------+\n
      \  |  0x00000000  |         Reserved        |   RFC 6956               |\n   |
      \ 0x00000001  |       PHYPortID         |   RFC 6956, Section 4.4  |\n   |  0x00000002
      \ |         SrcMAC          |   RFC 6956, Section 4.4  |\n   |  0x00000003  |
      \        DstMAC          |   RFC 6956, Section 4.4  |\n   |  0x00000004  |       LogicalPortID
      \    |   RFC 6956, Section 4.4  |\n   |  0x00000005  |         EtherType       |
      \  RFC 6956, Section 4.4  |\n   |  0x00000006  |          VlanID         |   RFC
      6956, Section 4.4  |\n   |  0x00000007  |       VlanPriority      |   RFC 6956,
      Section 4.4  |\n   |  0x00000008  |       NextHopIPv4Addr   |   RFC 6956, Section
      4.4  |\n   |  0x00000009  |       NextHopIPv6Addr   |   RFC 6956, Section 4.4
      \ |\n   |  0x0000000A  |       HopSelector       |   RFC 6956, Section 4.4  |\n
      \  |  0x0000000B  |       ExceptionID       |   RFC 6956, Section 4.4  |\n   |
      \ 0x0000000C  |      ValidateErrorID    |   RFC 6956, Section 4.4  |\n   |  0x0000000D
      \ |         L3PortID        |   RFC 6956, Section 4.4  |\n   |  0x0000000E  |
      \      RedirectIndex     |   RFC 6956, Section 4.4  |\n   |  0x0000000F  |    MediaEncapInfoIndex
      \ |   RFC 6956, Section 4.4  |\n   |  0x80000000- |      Reserved for       |
      \  RFC 6956               |\n   |  0xFFFFFFFF  |      Private Use        |                          |\n
      \  +--------------+-------------------------+--------------------------+\n                                   Table
      2\n"
    title: 8.2.  Metadata ID
  - contents:
    - "8.3.  Exception ID\n   The Exception ID namespace is 32 bits long.  Below are
      the guidelines\n   for managing the namespace.\n   Exception IDs in the range
      of 0x00000000-0x7FFFFFFF are Specification\n   Required [RFC5226].  An exception
      ID using this range MUST be\n   documented in an RFC or other permanent and
      readily available\n   reference.\n   Values assigned by this specification:\n
      \  +--------------+---------------------------------+------------------+\n   |
      \  Value      |           Name                  |   Definition     |\n   +--------------+---------------------------------+------------------+\n
      \  |  0x00000000  |  AnyUnrecognizedExceptionCase   | See Section 4.4  |\n   |
      \ 0x00000001  |        ClassifyNoMatching       | See Section 4.4  |\n   |  0x00000002
      \ |   MediaEncapInfoIndexInvalid    | See Section 4.4  |\n   |  0x00000003  |
      \      EncapTableLookupFailed    | See Section 4.4  |\n   |  0x00000004  |             BadTTL
      \             | See Section 4.4  |\n   |  0x00000005  |     IPv4HeaderLengthMismatch
      \   | See Section 4.4  |\n   |  0x00000006  |        RouterAlertOptions       |
      See Section 4.4  |\n   |  0x00000007  |         IPv6HopLimitZero        | See
      Section 4.4  |\n   |  0x00000008  |       IPv6NextHeaderHBH         | See Section
      4.4  |\n   |  0x00000009  |      SrcAddressException        | See Section 4.4
      \ |\n   |  0x0000000A  |      DstAddressException        | See Section 4.4  |\n
      \  |  0x0000000B  |        LPMLookupFailed          | See Section 4.4  |\n   |
      \ 0x0000000C  |       HopSelectorInvalid        | See Section 4.4  |\n   |  0x0000000D
      \ |      NextHopLookupFailed        | See Section 4.4  |\n   |  0x0000000E  |
      \         FragRequired           | See Section 4.4  |\n   |  0x0000000F  |       MetadataNoMatching
      \       | See Section 4.4  |\n   |  0x80000000- |         Reserved for            |
      RFC 6956         |\n   |  0xFFFFFFFF  |         Private Use             |                  |\n
      \  +--------------+---------------------------------+------------------+\n                                  Table
      3\n"
    title: 8.3.  Exception ID
  - contents:
    - "8.4.  Validate Error ID\n   The Validate Error ID namespace is 32 bits long.
      \ Below are the\n   guidelines for managing the namespace.\n   Validate Error
      IDs in the range of 0x00000000-0x7FFFFFFF are\n   Specification Required [RFC5226].
      \ A Validate Error ID using this\n   range MUST be documented in an RFC or other
      permanent and readily\n   available reference.\n   Values assigned by this specification:\n
      \  +--------------+---------------------------------+------------------+\n   |
      \  Value      |           Name                  |   Definition     |\n   +--------------+---------------------------------+------------------+\n
      \  |  0x00000000  | AnyUnrecognizedValidateErrorCase| See Section 4.4  |\n   |
      \ 0x00000001  |        InvalidIPv4PacketSize    | See Section 4.4  |\n   |  0x00000002
      \ |           NotIPv4Packet         | See Section 4.4  |\n   |  0x00000003  |
      \   InvalidIPv4HeaderLengthSize  | See Section 4.4  |\n   |  0x00000004  |    InvalidIPv4LengthFieldSize
      \  | See Section 4.4  |\n   |  0x00000005  |         InvalidIPv4Checksum     |
      See Section 4.4  |\n   |  0x00000006  |      InvalidIPv4SrcAddr         | See
      Section 4.4  |\n   |  0x00000007  |      InvalidIPv4DstAddr         | See Section
      4.4  |\n   |  0x00000008  |      InvalidIPv6PacketSize      | See Section 4.4
      \ |\n   |  0x00000009  |          NotIPv6Packet          | See Section 4.4  |\n
      \  |  0x0000000A  |      InvalidIPv6SrcAddr         | See Section 4.4  |\n   |
      \ 0x0000000B  |      InvalidIPv6DstAddr         | See Section 4.4  |\n   |  0x80000000-
      |        Reserved for             | RFC 6956         |\n   |  0xFFFFFFFF  |
      \       Private Use              |                  |\n   +--------------+---------------------------------+------------------+\n
      \                                  Table 4\n"
    title: 8.4.  Validate Error ID
  title: 8.  IANA Considerations
- contents:
  - "9.  Security Considerations\n   The ForCES framework document [RFC3746] provides
    a description of the\n   security needs for the overall ForCES architecture.  For
    example, the\n   ForCES protocol entities must be authenticated per the ForCES\n
    \  requirements before they can access the information elements\n   described
    in this document via ForCES.  The ForCES protocol document\n   [RFC5810] includes
    a comprehensive set of security mechanisms that\n   implementations are required
    to support to meet these needs.  SCTP-\n   based Transport Mapping Layer (TML)
    for the ForCES protocol [RFC5811]\n   specifies security mechanisms for transport
    mapping for the ForCES\n   protocol.  The LFBs defined in this document are similar
    to other\n   LFBs modeled by the FE model [RFC5812].  In particular, they have
    the\n   same security properties.  Thus, the security mechanisms and\n   considerations
    from the ForCES protocol document [RFC5810] apply to\n   this document.\n"
  title: 9.  Security Considerations
- contents:
  - '10.  References

    '
  - contents:
    - "10.1.  Normative References\n   [RFC2119]      Bradner, S., \"Key words for
      use in RFCs to Indicate\n                  Requirement Levels\", BCP 14, RFC
      2119, March 1997.\n   [RFC5810]      Doria, A., Hadi Salim, J., Haas, R., Khosravi,
      H.,\n                  Wang, W., Dong, L., Gopal, R., and J. Halpern,\n                  \"Forwarding
      and Control Element Separation (ForCES)\n                  Protocol Specification\",
      RFC 5810, March 2010.\n   [RFC5811]      Hadi Salim, J. and K. Ogawa, \"SCTP-Based
      Transport\n                  Mapping Layer (TML) for the Forwarding and Control\n
      \                 Element Separation (ForCES) Protocol\", RFC 5811,\n                  March
      2010.\n   [RFC5812]      Halpern, J. and J. Hadi Salim, \"Forwarding and Control\n
      \                 Element Separation (ForCES) Forwarding Element Model\",\n
      \                 RFC 5812, March 2010.\n"
    title: 10.1.  Normative References
  - contents:
    - "10.2.  Informative References\n   [IEEE.802-1Q]  IEEE, \"IEEE Standard for
      Local and metropolitan area\n                  networks -- Media Access Control
      (MAC) Bridges and\n                  Virtual Bridged Local Area Networks\",
      IEEE Standard\n                  802.1Q, 2011.\n   [RFC1122]      Braden, R.,
      \"Requirements for Internet Hosts -\n                  Communication Layers\",
      STD 3, RFC 1122, October 1989.\n   [RFC1812]      Baker, F., \"Requirements
      for IP Version 4 Routers\",\n                  RFC 1812, June 1995.\n   [RFC2460]
      \     Deering, S. and R. Hinden, \"Internet Protocol, Version\n                  6
      (IPv6) Specification\", RFC 2460, December 1998.\n   [RFC2578]      McCloghrie,
      K., Ed., Perkins, D., Ed., and J.\n                  Schoenwaelder, Ed., \"Structure
      of Management\n                  Information Version 2 (SMIv2)\", STD 58, RFC
      2578,\n                  April 1999.\n   [RFC3746]      Yang, L., Dantu, R.,
      Anderson, T., and R. Gopal,\n                  \"Forwarding and Control Element
      Separation (ForCES)\n                  Framework\", RFC 3746, April 2004.\n
      \  [RFC5226]      Narten, T. and H. Alvestrand, \"Guidelines for Writing\n                  an
      IANA Considerations Section in RFCs\", BCP 26,\n                  RFC 5226,
      May 2008.\n"
    title: 10.2.  Informative References
  title: 10.  References
- contents:
  - "Appendix A.  Acknowledgements\n   The authors would like to acknowledge the following
    people, whose\n   input was particularly helpful during development of this document:\n
    \     Edward Crabbe\n      Adrian Farrel\n      Rong Jin\n      Bin Zhuge\n      Ming
    Gao\n      Jingjing Zhou\n      Xiaochun Wu\n      Derek Atkins\n      Stephen
    Farrell\n      Meral Shirazipour\n      Jari Arkko\n      Martin Stiemerling\n
    \     Stewart Bryant\n      Richard Barnes\n"
  title: Appendix A.  Acknowledgements
- contents:
  - "Appendix B.  Contributors\n   The authors would like to thank Jamal Hadi Salim,
    Ligang Dong, and\n   Fenggen Jia, all of whom made major contributions to the
    development\n   of this document.  Ligang Dong and Fenggen Jia were also two of
    the\n   authors of earlier documents from which this document evolved.\n   Jamal
    Hadi Salim\n   Mojatatu Networks\n   Ottawa, Ontario\n   Canada\n   EMail: hadi@mojatatu.com\n
    \  Ligang Dong\n   Zhejiang Gongshang University\n   18 Xuezheng Str., Xiasha
    University Town\n   Hangzhou 310018\n   P.R. China\n   EMail: donglg@zjsu.edu.cn\n
    \  Fenggen Jia\n   National Digital Switching Center (NDSC)\n   Jianxue Road\n
    \  Zhengzhou 452000\n   P.R. China\n   EMail: jfg@mail.ndsc.com.cn\n"
  title: Appendix B.  Contributors
- contents:
  - "Authors' Addresses\n   Weiming Wang\n   Zhejiang Gongshang University\n   18
    Xuezheng Str., Xiasha University Town\n   Hangzhou  310018\n   P.R. China\n   Phone:
    +86 571 28877751\n   EMail: wmwang@zjsu.edu.cn\n   Evangelos Haleplidis\n   University
    of Patras\n   Department of Electrical & Computer Engineering\n   Patras  26500\n
    \  Greece\n   EMail: ehalep@ece.upatras.gr\n   Kentaro Ogawa\n   NTT Corporation\n
    \  Tokyo\n   Japan\n   EMail: ogawa.kentaro@lab.ntt.co.jp\n   Chuanhuang Li\n
    \  Hangzhou DPtech\n   6th Floor, Zhongcai Group, 68 Tonghe Road, Binjiang District\n
    \  Hangzhou  310051\n   P.R. China\n   EMail: chuanhuang_li@zjsu.edu.cn\n   Joel
    Halpern\n   Ericsson\n   P.O. Box 6049\n   Leesburg, VA  20178\n   USA\n   Phone:
    +1 703 371 3043\n   EMail: joel.halpern@ericsson.com\n"
  title: Authors' Addresses
