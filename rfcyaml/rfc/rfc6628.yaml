- title: __initial_text__
  contents:
  - "          Efficient Augmented Password-Only Authentication and\n            \
    \             Key Exchange for IKEv2\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes an efficient augmented password-only\n \
    \  authentication and key exchange (AugPAKE) protocol where a user\n   remembers\
    \ a low-entropy password and its verifier is registered in\n   the intended server.\
    \  In general, the user password is chosen from a\n   small set of dictionary\
    \ words that allows an attacker to perform\n   exhaustive searches (i.e., off-line\
    \ dictionary attacks).  The AugPAKE\n   protocol described here is secure against\
    \ passive attacks, active\n   attacks, and off-line dictionary attacks (on the\
    \ obtained messages\n   with passive/active attacks), and also provides resistance\
    \ to server\n   compromise (in the context of augmented PAKE security).  In addition,\n\
    \   this document describes how the AugPAKE protocol is integrated into\n   the\
    \ Internet Key Exchange Protocol version 2 (IKEv2).\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for examination, experimental implementation, and\n   evaluation.\n\
    \   This document defines an Experimental Protocol for the Internet\n   community.\
    \  This document is a product of the Internet Engineering\n   Task Force (IETF).\
    \  It represents the consensus of the IETF\n   community.  It has received public\
    \ review and has been approved for\n   publication by the Internet Engineering\
    \ Steering Group (IESG).  Not\n   all documents approved by the IESG are a candidate\
    \ for any level of\n   Internet Standard; see Section 2 of RFC 5741.\n   Information\
    \ about the current status of this document, any errata,\n   and how to provide\
    \ feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6628.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2012 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \      1.1. Keywords ...................................................4\n  \
    \ 2. AugPAKE Specification ...........................................4\n    \
    \  2.1. Underlying Group ...........................................4\n      2.2.\
    \ Notation ...................................................5\n           2.2.1.\
    \ Password Processing .................................6\n      2.3. Protocol\
    \ ...................................................7\n           2.3.1. Initialization\
    \ ......................................7\n           2.3.2. Actual Protocol Execution\
    \ ...........................7\n   3. Security Considerations .........................................9\n\
    \      3.1. General Assumptions ........................................9\n  \
    \    3.2. Security against Passive Attacks ..........................10\n    \
    \  3.3. Security against Active Attacks ...........................10\n      \
    \     3.3.1. Impersonation Attacks on User U ....................10\n        \
    \   3.3.2. Impersonation Attacks on Server S ..................11\n          \
    \ 3.3.3. Man-in-the-Middle Attacks ..........................11\n      3.4. Security\
    \ against Off-line Dictionary Attacks ..............12\n      3.5. Resistance\
    \ to Server Compromise ...........................12\n   4. Implementation Consideration\
    \ ...................................13\n   5. AugPAKE for IKEv2 ..............................................13\n\
    \      5.1. Integration into IKEv2 ....................................13\n  \
    \    5.2. Payload Formats ...........................................15\n    \
    \       5.2.1. Notify Payload .....................................15\n      \
    \     5.2.2. Generic Secure Password Method Payload .............16\n   6. IANA\
    \ Considerations ............................................16\n   7. References\
    \ .....................................................16\n      7.1. Normative\
    \ References ......................................16\n      7.2. Informative\
    \ References ....................................17\n   Appendix A.  Evaluation\
    \ by PAKE Selection Criteria.................19\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   In the real world, many applications, such as Web mail and\
    \ Internet\n   banking/shopping/trading, require secure channels between\n   participating\
    \ parties.  Such secure channels can be established by\n   using an authentication\
    \ and key exchange (AKE) protocol, which allows\n   the involved parties to authenticate\
    \ each other and to generate a\n   temporary session key.  The temporary session\
    \ key is used to protect\n   the subsequent communications between the parties.\n\
    \   Until now, password-only AKE (called PAKE) protocols have attracted\n   much\
    \ attention because password-only authentication is very\n   convenient to the\
    \ users.  However, it is not trivial to design a\n   secure PAKE protocol due\
    \ to the existence of off-line dictionary\n   attacks on passwords.  These attacks\
    \ are possible since passwords are\n   chosen from a relatively-small dictionary\
    \ that allows for an attacker\n   to perform the exhaustive searches.  This problem\
    \ was brought forth\n   by Bellovin and Merritt [BM92], and many subsequent works\
    \ have been\n   conducted in the literature (see some examples in [IEEEP1363.2]).\
    \  A\n   PAKE protocol is said to be secure if the best attack an active\n   attacker\
    \ can take is restricted to the on-line dictionary attacks,\n   which allows a\
    \ guessed password to be checked only by interacting\n   with the honest party.\n\
    \   An augmented PAKE protocol (e.g., [BM93], [RFC2945], [ISO]) provides\n   extra\
    \ protection for server compromise in the sense that an attacker,\n   who obtains\
    \ a password verifier from a server, cannot impersonate the\n   corresponding\
    \ user without performing off-line dictionary attacks on\n   the password verifier.\
    \  This additional security is known as\n   \"resistance to server compromise\"\
    .  The AugPAKE protocol described in\n   this document is an augmented PAKE, which\
    \ also achieves measurable\n   efficiency over some previous works (i.e., SRP\
    \ [RFC2945] and AMP\n   [ISO]).  We believe the following (see [SKI10] for the\
    \ formal\n   security proof): 1) The AugPAKE protocol is secure against passive\n\
    \   attacks, active attacks, and off-line dictionary attacks (on the\n   obtained\
    \ messages with passive/active attacks), and 2) It provides\n   resistance to\
    \ server compromise.  At the same time, the AugPAKE\n   protocol has similar computational\
    \ efficiency to the plain Diffie-\n   Hellman key exchange [DH76] that does not\
    \ provide authentication by\n   itself.  Specifically, the user and the server\
    \ need to compute 2 and\n   2.17 modular exponentiations, respectively, in the\
    \ AugPAKE protocol.\n   After excluding pre-computable costs, the user and the\
    \ server are\n   required to compute only 1 and 1.17 modular exponentiations,\n\
    \   respectively.  Compared with SRP [RFC2945] and AMP [ISO], the AugPAKE\n  \
    \ protocol is more efficient 1) than SRP in terms of the user's\n   computational\
    \ costs and 2) than AMP in terms of the server's\n   computational costs.\n  \
    \ This document also describes how the AugPAKE protocol is integrated\n   into\
    \ IKEv2 [RFC5996].\n"
- title: 1.1.  Keywords
  contents:
  - "1.1.  Keywords\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and\
    \ \"OPTIONAL\" in this\n   document are to be interpreted as described in RFC\
    \ 2119 [RFC2119].\n"
- title: 2.  AugPAKE Specification
  contents:
  - '2.  AugPAKE Specification

    '
- title: 2.1.  Underlying Group
  contents:
  - "2.1.  Underlying Group\n   The AugPAKE protocol can be implemented over the following\
    \ group.\n   o  Let p and q be sufficiently large primes such that q is a divisor\n\
    \      of ((p - 1) / 2), and every factor of ((p - 1) / 2) are also\n      primes\
    \ comparable to q in size.  This p is called a \"secure\"\n      prime.  By G,\
    \ we denote a multiplicative subgroup of prime order q\n      over the field GF(p),\
    \ the integers modulo p.  Let g be a generator\n      for the subgroup G so that\
    \ all the subgroup elements are generated\n      by g.  The group operation is\
    \ denoted multiplicatively (in modulo\n      p).\n   By using a secure prime p,\
    \ the AugPAKE protocol has computational\n   efficiency gains.  Specifically,\
    \ it does not require the order check\n   of elements received from the counterpart\
    \ party.  Note that the\n   groups defined in Discrete Logarithm Cryptography\
    \ [SP800-56A] and RFC\n   5114 [RFC5114] are not necessarily the above secure\
    \ prime groups.\n   Alternatively, one can implement the AugPAKE protocol over\
    \ the\n   following groups.\n   o  Let p and q be sufficiently large primes such\
    \ that p = (2 * q) +\n      1.  This p is called a \"safe\" prime.  By G, we denote\
    \ a\n      multiplicative subgroup of prime order q over the field GF(p), the\n\
    \      integers modulo p.  Let g be any element of G other than 1.  For\n    \
    \  example, g = h^2 mod p where h is a primitive element.  The group\n      operation\
    \ is denoted multiplicatively (in modulo p).\n   o  Let p and q be sufficiently\
    \ large primes such that q is a divisor\n      of ((p - 1) / 2).  By G, we denote\
    \ a multiplicative subgroup of\n      prime order q over the field GF(p), the\
    \ integers modulo p.  Let g\n      be a generator for the subgroup G so that all\
    \ the subgroup\n      elements are generated by g.  The group operation is denoted\n\
    \      multiplicatively (in modulo p).  If p is not a \"secure\" prime, the\n\
    \      AugPAKE protocol MUST perform the order check of received\n      elements.\n"
- title: 2.2.  Notation
  contents:
  - "2.2.  Notation\n   The AugPAKE protocol is a two-party protocol where a user\
    \ and a\n   server authenticate each other and generate a session key.  The\n\
    \   following notation is used in this document:\n   U\n      The user's identity\
    \ (e.g., as defined in [RFC4282]).  It is a\n      string in {0,1}^* where {0,1}^*\
    \ indicates a set of finite binary\n      strings.\n   S\n      The server's identity\
    \ (e.g., as defined in [RFC4282]).  It is a\n      string in {0,1}^*.\n   b =\
    \ H(a)\n      A binary string a is given as input to a secure one-way hash\n \
    \     function H (e.g., SHA-2 family [FIPS180-3]), which produces a\n      fixed-length\
    \ output b.  The hash function H maps {0,1}^* to\n      {0,1}^k, where {0,1}^k\
    \ indicates a set of binary strings of length\n      k and k is a security parameter.\n\
    \   b = H'(a)\n      A binary string a is given as input to a secure one-way hash\n\
    \      function H', which maps the input a in {0,1}^* to the output b in\n   \
    \   Z_q^*, where Z_q^* is a set of positive integers modulo prime q.\n   a | b\n\
    \      It denotes a concatenation of binary strings a and b in {0,1}^*.\n   0x\n\
    \      A hexadecimal value is shown preceded by \"0x\".\n   X * Y mod p\n    \
    \  It indicates a multiplication of X and Y modulo prime p.\n   X = g^x mod p\n\
    \      The g^x indicates a multiplication computation of g by x times.\n     \
    \ The resultant value modulo prime p is assigned to X.  The discrete\n      logarithm\
    \ problem says that it is computationally hard to compute\n      the discrete\
    \ logarithm x from X, g, and p.\n   w\n      The password remembered by the user.\
    \  This password may be used as\n      an effective password (instead of itself)\
    \ in the form of H'(0x00 |\n      U | S | w).\n   W\n      The password verifier\
    \ registered in the server.  This password\n      verifier is computed as follows:\
    \ W = g^w mod p where the user's\n      password w is used itself, or W = g^w'\
    \ mod p where the effective\n      password w' = H'(0x00 | U | S | w) is used.\n\
    \   bn2bin(X)\n      It indicates a conversion of a multiple precision integer\
    \ X to the\n      corresponding binary string.  If X is an element over GF(p),\
    \ its\n      binary representation MUST have the same bit length as the binary\n\
    \      representation of prime p.\n   U -> S: msg\n      It indicates a message\
    \ transmission that the user U sends a\n      message msg to the server S.\n \
    \  U:\n      It indicates a local computation of user U (without any outgoing\n\
    \      messages).\n"
- title: 2.2.1.  Password Processing
  contents:
  - "2.2.1.  Password Processing\n   The input password MUST be processed according\
    \ to the rules of the\n   [RFC4013] profile of [RFC3454].  The password SHALL\
    \ be considered a\n   \"stored string\" per [RFC3454], and unassigned code points\
    \ are\n   therefore prohibited.  The output SHALL be the binary representation\n\
    \   of the processed UTF-8 character string.  Prohibited output and\n   unassigned\
    \ code points encountered in SASLprep pre-processing SHALL\n   cause a failure\
    \ of pre-processing, and the output SHALL NOT be used\n   with the AugPAKE protocol.\n\
    \   The following table shows examples of how various character data is\n   transformed\
    \ by the rules of the [RFC4013] profile.\n   #  Input            Output     Comments\n\
    \   -  -----            ------     --------\n   1  I<U+00AD>X       IX       \
    \  SOFT HYPHEN mapped to nothing\n   2  user             user       no transformation\n\
    \   3  USER             USER       case preserved, will not match #2\n   4  <U+00AA>\
    \         a          output is NFKC, input in ISO 8859-1\n   5  <U+2168>     \
    \    IX         output is NFKC, will match #1\n   6  <U+0007>                \
    \    Error - prohibited character\n   7  <U+0627><U+0031>            Error - bidirectional\
    \ check\n"
- title: 2.3.  Protocol
  contents:
  - "2.3.  Protocol\n   The AugPAKE protocol consists of two phases: initialization\
    \ and\n   actual protocol execution.  The initialization phase SHOULD be\n   finished\
    \ in a secure manner between the user and the server, and it\n   is performed\
    \ all at once.  Whenever the user and the server need to\n   establish a secure\
    \ channel, they can run the actual protocol\n   execution through an open network\
    \ (i.e., the Internet) in which an\n   active attacker exists.\n"
- title: 2.3.1.  Initialization
  contents:
  - "2.3.1.  Initialization\n   U -> S: (U, W)\n      The user U computes W = g^w'\
    \ mod p, where w' is the effective\n      password, and transmits W to the server\
    \ S.  The W is registered in\n      the server as the password verifier of user\
    \ U.  Of course, user U\n      just remembers password w only.\n   If resistance\
    \ to server compromise is not necessary and a node needs\n   to act as both initiator\
    \ and responder, e.g., as a gateway, then the\n   node can store w' instead of\
    \ W even when it acts as server S.  In\n   either case, server S SHOULD NOT store\
    \ any plaintext passwords.\n   As noted above, this phase SHOULD be performed\
    \ securely and all at\n   once.\n"
- title: 2.3.2.  Actual Protocol Execution
  contents:
  - "2.3.2.  Actual Protocol Execution\n   The actual protocol execution of the AugPAKE\
    \ protocol allows the user\n   and the server to share an authenticated session\
    \ key through an open\n   network (see Figure 1).\n   +-----------------+    \
    \                          +------------------+\n   |     User U      |      \
    \                        |  Server S (U,W)  |\n   |                 |        \
    \    (U, X)            |                  |\n   |                 |----------------------------->|\
    \                  |\n   |                 |                              |  \
    \                |\n   |                 |            (S, Y)            |    \
    \              |\n   |                 |<-----------------------------|      \
    \            |\n   |                 |                              |        \
    \          |\n   |                 |             V_U              |          \
    \        |\n   |                 |----------------------------->|            \
    \      |\n   |                 |                              |              \
    \    |\n   |                 |             V_S              |                \
    \  |\n   |                 |<-----------------------------|                  |\n\
    \   |                 |                              |                  |\n  \
    \ +-----------------+                              +------------------+\n    \
    \                Figure 1: Actual Protocol Execution\n   U -> S: (U, X)\n    \
    \  The user U chooses a random element x from Z_q^* and computes its\n      Diffie-Hellman\
    \ public value X = g^x mod p.  The user sends the\n      first message (U, X)\
    \ to the server S.\n   S -> U: (S, Y)\n      If the received X from user U is\
    \ 0, 1, or -1 (mod p), server S\n      MUST terminate the protocol execution.\
    \  Otherwise, the server\n      chooses a random element y from Z_q^* and computes\
    \ Y = (X *\n      (W^r))^y mod p where r = H'(0x01 | U | S | bn2bin(X)).  Note\
    \ that\n      X^y * g^(w * r * y) mod p can be computed from y and (w * r * y)\n\
    \      efficiently using Shamir's trick [MOV97].  Then, server S sends\n     \
    \ the second message (S, Y) to the user U.\n   U -> S: V_U\n      If the received\
    \ Y from server S is 0, 1, or -1 (mod p), user U\n      MUST terminate the protocol\
    \ execution.  Otherwise, the user\n      computes K = Y^z mod p where z = 1 /\
    \ (x + (w * r)) mod q and r =\n      H'(0x01 | U | S | bn2bin(X)).  Also, user\
    \ U generates an\n      authenticator V_U = H(0x02 | U | S | bn2bin(X) | bn2bin(Y)\
    \ |\n      bn2bin(K)).  Then, the user sends the third message V_U to the\n  \
    \    server S.\n   S -> U: V_S\n      If the received V_U from user U is not equal\
    \ to H(0x02 | U | S |\n      bn2bin(X) | bn2bin(Y) | bn2bin(K)) where K = g^y\
    \ mod p, server S\n      MUST terminate the protocol execution.  Otherwise, the\
    \ server\n      generates an authenticator V_S = H(0x03 | U | S | bn2bin(X) |\n\
    \      bn2bin(Y) | bn2bin(K)) and a session key SK = H(0x04 | U | S |\n      bn2bin(X)\
    \ | bn2bin(Y) | bn2bin(K)).  Then, server S sends the\n      fourth message V_S\
    \ to the user U.\n   U:\n      If the received V_S from server S is not equal\
    \ to H(0x03 | U | S |\n      bn2bin(X) | bn2bin(Y) | bn2bin(K)), user U MUST terminate\
    \ the\n      protocol execution.  Otherwise, the user generates a session key\n\
    \      SK = H(0x04 | U | S | bn2bin(X) | bn2bin(Y) | bn2bin(K)).\n   In the actual\
    \ protocol execution, the sequential order of message\n   exchanges is very important\
    \ to avoid any possible attacks.  For\n   example, if the server S sends the second\
    \ message (S, Y) and the\n   fourth message V_S together, any attacker can easily\
    \ derive the\n   correct password w with off-line dictionary attacks.\n   The\
    \ session key SK, shared only if the user and the server\n   authenticate each\
    \ other successfully, MAY be generated by using a key\n   derivation function\
    \ (KDF) [SP800-108].  After generating SK, the user\n   and the server MUST delete\
    \ all the internal states (e.g., Diffie-\n   Hellman exponents x and y) from memory.\n\
    \   For the formal proof [SKI10] of the AugPAKE protocol, we need to\n   slightly\
    \ change the computation of Y (in the above S -> U: (S, Y))\n   and K (in the\
    \ above S -> U: V_S) as follows: Y = (X * (W^r))^y' and K\n   = g^y' where y'\
    \ = H'(0x05 | bn2bin(y)).\n"
- title: 3.  Security Considerations
  contents:
  - "3.  Security Considerations\n   This section shows why the AugPAKE protocol (i.e.,\
    \ the actual\n   protocol execution) is secure against passive attacks, active\n\
    \   attacks, and off-line dictionary attacks, and also provides\n   resistance\
    \ to server compromise.\n"
- title: 3.1.  General Assumptions
  contents:
  - "3.1.  General Assumptions\n   o  An attacker is computationally bounded.\n  \
    \ o  Any hash functions used in the AugPAKE protocol are secure in\n      terms\
    \ of pre-image resistance (one-wayness), second pre-image\n      resistance, and\
    \ collision resistance.\n"
- title: 3.2.  Security against Passive Attacks
  contents:
  - "3.2.  Security against Passive Attacks\n   An augmented PAKE protocol is said\
    \ to be secure against passive\n   attacks in the sense that an attacker, who\
    \ eavesdrops the exchanged\n   messages, cannot compute an authenticated session\
    \ key (shared between\n   the honest parties in the protocol).\n   In the AugPAKE\
    \ protocol, an attacker can get the messages (U, X),\n   (S,Y), V_U, V_S by eavesdropping,\
    \ and then wants to compute the\n   session key SK.  That is, the attacker's goal\
    \ is to derive the\n   correct K from the obtained messages X and Y, because the\
    \ hash\n   functions are secure and the only secret in the computation of SK is\n\
    \   K = g^y mod p.  Note that\n   X =     g^x mod p and\n   Y =     (X * (W^r))^y\
    \ = X^y * W^(r * y) = X^y * (g^y)^t = X^y * K^t\n   hold where t = w' * r mod\
    \ q.  Though t is determined from possible\n   password candidates and X, the\
    \ only way for the attacker to extract K\n   from X and Y is to compute X^y. \
    \ However, the probability for the\n   attacker to compute X^y is negligible in\
    \ the security parameter for\n   the underlying groups since both x and y are\
    \ random elements chosen\n   from Z_q^*.  Therefore, the AugPAKE protocol is secure\
    \ against\n   passive attacks.\n"
- title: 3.3.  Security against Active Attacks
  contents:
  - "3.3.  Security against Active Attacks\n   An augmented PAKE protocol is said\
    \ to be secure against active\n   attacks in the sense that an attacker, who completely\
    \ controls the\n   exchanged messages, cannot compute an authenticated session\
    \ key\n   (shared with the honest party in the protocol) with the probability\n\
    \   better than that of on-line dictionary attacks.  In other words, the\n   probability\
    \ for an active attacker to compute the session key is\n   restricted by the on-line\
    \ dictionary attacks where it grows linearly\n   to the number of interactions\
    \ with the honest party.\n   In the AugPAKE protocol, the user (respectively,\
    \ the server) computes\n   the session key SK only if the received authenticator\
    \ V_S\n   (respectively, V_U) is valid.  There are three cases to be considered\n\
    \   in the active attacks.\n"
- title: 3.3.1.  Impersonation Attacks on User U
  contents:
  - "3.3.1.  Impersonation Attacks on User U\n   When an attacker impersonates the\
    \ user U, the attacker can compute\n   the same SK (to be shared with the server\
    \ S) only if the\n   authenticator V_U is valid.  For a valid authenticator V_U,\
    \ the\n   attacker has to compute the correct K from X and Y because the hash\n\
    \   functions are secure.  In this impersonation attack, the attacker of\n   course\
    \ knows the discrete logarithm x of X and guesses a password w''\n   from the\
    \ password dictionary.  So, the probability for the attacker\n   to compute the\
    \ correct K is bounded by the probability of w = w''.\n   That is, this impersonation\
    \ attack is restricted by the on-line\n   dictionary attacks where the attacker\
    \ can try a guessed password\n   communicating with the honest server S.  Therefore,\
    \ the AugPAKE\n   protocol is secure against impersonation attacks on user U.\n"
- title: 3.3.2.  Impersonation Attacks on Server S
  contents:
  - "3.3.2.  Impersonation Attacks on Server S\n   When an attacker impersonates the\
    \ server S, the attacker can compute\n   the same SK (to be shared with the user\
    \ U) only if the authenticator\n   V_S is valid.  For a valid authenticator V_S,\
    \ the attacker has to\n   compute the correct K from X and Y because the hash\
    \ functions are\n   secure.  In this impersonation attack, the attacker chooses\
    \ a random\n   element y and guesses a password w'' from the password dictionary\
    \ so\n   that\n   Y =     (X * (W'^r))^y = X^y * W'^(r * y) = X^y * (g^y)^t'\n\
    \   where t' = w'' * r mod q.  The probability for the attacker to\n   compute\
    \ the correct K is bounded by the probability of w = w''.\n   Also, the attacker\
    \ knows whether the guessed password is equal to w\n   or not by seeing the received\
    \ authenticator V_U.  However, when w is\n   not equal to w'', the probability\
    \ for the attacker to compute the\n   correct K is negligible in the security\
    \ parameter for the underlying\n   groups since the attacker has to guess the\
    \ discrete logarithm x\n   (chosen by user U) as well.  That is, this impersonation\
    \ attack is\n   restricted by the on-line dictionary attacks where the attacker\
    \ can\n   try a guessed password communicating with the honest user U.\n   Therefore,\
    \ the AugPAKE protocol is secure against impersonation\n   attacks on server S.\n"
- title: 3.3.3.  Man-in-the-Middle Attacks
  contents:
  - "3.3.3.  Man-in-the-Middle Attacks\n   When an attacker performs the man-in-the-middle\
    \ attack, the attacker\n   can compute the same SK (to be shared with the user\
    \ U or the server\n   S) only if one of the authenticators V_U, V_S is valid.\
    \  Note that if\n   the attacker relays the exchanged messages honestly, it corresponds\n\
    \   to the passive attacks.  In order to generate a valid authenticator\n   V_U\
    \ or V_S, the attacker has to compute the correct K from X and Y\n   because the\
    \ hash functions are secure.  So, the attacker is in the\n   same situation as\
    \ discussed above.  Though the attacker can test two\n   passwords (one with user\
    \ U and the other with server S), it does not\n   change the fact that this attack\
    \ is restricted by the on-line\n   dictionary attacks where the attacker can try\
    \ a guessed password\n   communicating with the honest party.  Therefore, the\
    \ AugPAKE protocol\n   is also secure against man-in-the-middle attacks.\n"
- title: 3.4.  Security against Off-line Dictionary Attacks
  contents:
  - "3.4.  Security against Off-line Dictionary Attacks\n   An augmented PAKE protocol\
    \ is said to be secure against off-line\n   dictionary attacks in the sense that\
    \ an attacker, who completely\n   controls the exchanged messages, cannot reduce\
    \ the possible password\n   candidates better than on-line dictionary attacks.\
    \  Note that in the\n   on-line dictionary attacks, an attacker can test one guessed\
    \ password\n   by running the protocol execution (i.e., communicating with the\n\
    \   honest party).\n   As discussed in Section 3.2, an attacker in the passive\
    \ attacks does\n   not compute X^y (and the correct K = g^y mod p) from the obtained\n\
    \   messages X, Y.  This security analysis also indicates that, even if\n   the\
    \ attacker can guess a password, the K is derived independently\n   from the guessed\
    \ password.  Next, we consider an active attacker\n   whose main goal is to perform\
    \ the off-line dictionary attacks in the\n   AugPAKE protocol.  As in Section\
    \ 3.3, the attacker can 1) test one\n   guessed password by impersonating the\
    \ user U or the server S, or 2)\n   test two guessed passwords by impersonating\
    \ the server S (to the\n   honest user U) and impersonating the user U (to the\
    \ honest server S)\n   in the man-in-the-middle attacks.  Whenever the honest\
    \ party receives\n   an invalid authenticator, the party terminates the actual\
    \ protocol\n   execution without sending any message.  In fact, this is important\
    \ to\n   prevent an attacker from testing more than one password in the active\n\
    \   attacks.  Since passive attacks and active attacks cannot remove the\n   possible\
    \ password candidates more efficiently than on-line dictionary\n   attacks, the\
    \ AugPAKE protocol is secure against off-line dictionary\n   attacks.\n"
- title: 3.5.  Resistance to Server Compromise
  contents:
  - "3.5.  Resistance to Server Compromise\n   We consider an attacker who has obtained\
    \ a (user's) password verifier\n   from a server.  In the (augmented) PAKE protocols,\
    \ there are two\n   limitations [BJKMRSW00]: 1) the attacker can find out the\
    \ correct\n   password from the password verifier with the off-line dictionary\n\
    \   attacks because the verifier has the same entropy as the password;\n   and\
    \ 2) if the attacker impersonates the server with the password\n   verifier, this\
    \ attack is always possible because the attacker has\n   enough information to\
    \ simulate the server.  An augmented PAKE\n   protocol is said to provide resistance\
    \ to server compromise in the\n   sense that the attacker cannot impersonate the\
    \ user without\n   performing off-line dictionary attacks on the password verifier.\n\
    \   In order to show resistance to server compromise in the AugPAKE\n   protocol,\
    \ we consider an attacker who has obtained the password\n   verifier W and then\
    \ tries to impersonate the user U without off-line\n   dictionary attacks on W.\
    \  As a general attack, the attacker chooses\n   two random elements c and d from\
    \ Z_q^*, and computes\n   X =     (g^c) * (W^d) mod p\n   and sends the first\
    \ message (U, X) to the server S.  In order to\n   impersonate user U successfully,\
    \ the attacker has to compute the\n   correct K = g^y mod p where y is randomly\
    \ chosen by server S.  After\n   receiving Y from the server, the attacker's goal\
    \ is to find out a\n   value e satisfying Y^e = K mod p.  That is,\n         \
    \   log_g (Y^e) = log_g K mod q\n            (c + (w' * d) + (w' * r)) * y * e\
    \ = y mod q\n            (c + w' * (d + r)) * e = 1 mod q\n   where log_g K indicates\
    \ the logarithm of K to the base g.  Since\n   there is no off-line dictionary\
    \ attacks on W, the above solution is\n   that e = 1 / c mod q and d = -r mod\
    \ q.  However, the latter is not\n   possible since r is determined by X (i.e.,\
    \ r = H'(0x01 | U | S |\n   bn2bin(X))) and H' is a secure hash function.  Therefore,\
    \ the AugPAKE\n   protocol provides resistance to server compromise.\n"
- title: 4.  Implementation Consideration
  contents:
  - "4.  Implementation Consideration\n   As discussed in Section 3, the AugPAKE protocol\
    \ is secure against\n   passive attacks, active attacks, and off-line dictionary\
    \ attacks, and\n   provides resistance to server compromise.  However, an attacker\
    \ in\n   the on-line dictionary attacks can check whether one password\n   (guessed\
    \ from the password dictionary) is correct or not by\n   interacting with the\
    \ honest party.  Let N be the number of possible\n   passwords within a dictionary.\
    \  Certainly, the attacker's success\n   probability grows with the probability\
    \ of (I / N) where I is the\n   number of interactions with the honest party.\
    \  In order to provide a\n   reasonable security margin, implementation SHOULD\
    \ take a\n   countermeasure to the on-line dictionary attacks.  For example, it\n\
    \   would take about 90 years to test 2^(25.5) passwords with a one\n   minute\
    \ lock-out for 3 failed password guesses (see Appendix A in\n   [SP800-63]).\n"
- title: 5.  AugPAKE for IKEv2
  contents:
  - '5.  AugPAKE for IKEv2

    '
- title: 5.1.  Integration into IKEv2
  contents:
  - "5.1.  Integration into IKEv2\n   IKE is a primary component of IPsec in order\
    \ to provide mutual\n   authentication and establish security associations between\
    \ two peers.\n   The AugPAKE protocol, described in Section 2, can be easily\n\
    \   integrated into IKEv2 [RFC5996] as a \"weak\" pre-shared key\n   authentication\
    \ method (see Figure 2).  This integrated protocol\n   preserves the IKEv2 structure\
    \ and security guarantees (e.g., identity\n   protection).  Note that the AugPAKE\
    \ protocol can be used in three\n   scenarios for IKEv2: \"Security Gateway to\
    \ Security Gateway Tunnel\",\n   \"Endpoint-to-Endpoint Transport\", and \"Endpoint\
    \ to Security Gateway\n   Tunnel\".\n    Initiator                           \
    \    Responder\n   -----------                             -----------\n   IKE_SA_INIT:\n\
    \    HDR, SAi1, KEi, Ni,\n    N(SECURE_PASSWORD_METHODS)      -->\n          \
    \                          <--  HDR, SAr1, KEr, Nr,\n                        \
    \                 N(SECURE_PASSWORD_METHODS)\n   IKE_AUTH:\n    HDR, SK {IDi,\
    \ GSPM(PVi), [IDr,]\n             SAi2, TSi, TSr}        -->\n               \
    \                     <--  HDR, SK {IDr, GSPM(PVr)}\n    HDR, SK {AUTHi}     \
    \            -->\n                                    <--  HDR, SK {AUTHr, SAr2,\
    \ TSi, TSr}\n                       Figure 2: AugPAKE into IKEv2\n   The changes\
    \ from IKEv2 are summarized as follows:\n   o  In addition to IKEv2, one round\
    \ trip is added.\n   o  The initiator (respectively, the responder) sends an\n\
    \      N(SECURE_PASSWORD_METHODS) notification to indicate its\n      willingness\
    \ to use AugPAKE in the IKE_SA_INIT exchange.\n   o  The added values GSPM(PVi)\
    \ and GSPM(PVr) in the IKE_AUTH exchange\n      correspond to X and Y of the AugPAKE\
    \ protocol in Section 2,\n      respectively.\n   o  From K (represented as an\
    \ octet string) derived in Section 2, the\n      AUTH values in the IKE_AUTH exchange\
    \ are computed as\n         AUTHi = prf( prf(K, \"AugPAKE for IKEv2\"),\n    \
    \     <InitiatorSignedOctets> | GSPM(PVi) | GSPM(PVr) | IDi | IDr)\n         AUTHr\
    \ = prf( prf(K, \"AugPAKE for IKEv2\"),\n         <ResponderSignedOctets> | GSPM(PVr)\
    \ | GSPM(PVi) | IDr | IDi)\n"
- title: 5.2.  Payload Formats
  contents:
  - '5.2.  Payload Formats

    '
- title: 5.2.1.  Notify Payload
  contents:
  - "5.2.1.  Notify Payload\n   The Notify Payload N(SECURE_PASSWORD_METHODS) [RFC6467],\
    \ indicating a\n   willingness to use AugPAKE in the IKE_SA_INIT exchange, is\
    \ defined as\n   follows:\n                        1                   2     \
    \              3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7\
    \ 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ! Next Payload  !C!  RESERVED   !         Payload Length        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   !  Protocol ID  !   SPI Size    !      Notify Message Type      !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   !                                                               !\n   ~  \
    \              Security Parameter Index (SPI)                 ~\n   !        \
    \                                                       !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   !                                                               !\n   ~  \
    \                     Notification Data                       ~\n   !        \
    \                                                       !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   As in [RFC5996], the Protocol ID and SPI Size SHALL be set to zero\n   and,\
    \ therefore, the SPI field SHALL be empty.  The Notify Message\n   Type will be\
    \ 16424 [RFC6467].\n   The Notification Data contains the list of the 16-bit secure\
    \ password\n   method numbers:\n                        1                   2\
    \                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\
    \ 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ! Secure Password Method #1     ! Secure Password Method #2     !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ! Secure Password Method #3     ! ...                           !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   The response Notify Payload contains exactly one 16-bit secure\n   password\
    \ method number (i.e., for AugPAKE here) inside the\n   Notification Data field.\n"
- title: 5.2.2.  Generic Secure Password Method Payload
  contents:
  - "5.2.2.  Generic Secure Password Method Payload\n   The Generic Secure Password\
    \ Method (GSPM) Payload, denoted GSPM(PV)\n   in Section 5.1, is defined as follows:\n\
    \                        1                   2                   3\n    0 1 2\
    \ 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   ! Next Payload  !C!  RESERVED   !         Payload Length        !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   !                                                               !\n   ~  \
    \                                                             ~\n   !        \
    \  Data Specific to the Secure Password Method          !\n   ~              \
    \                                                 ~\n   !                    \
    \                                           !\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \                The GSPM Payload Type will be 49 [RFC6467].\n   Since the GSPM(PV)\
    \ value is a group element, the encoded octet string\n   is actually used in the\
    \ \"Data Specific to the Secure Password Method\"\n   field.\n"
- title: 6.  IANA Considerations
  contents:
  - "6.  IANA Considerations\n   IANA has assigned value 2 to the method name \"AugPAKE\"\
    \ from the\n   \"IKEv2 Secure Password Methods\" registry in [IKEV2-IANA].\n"
- title: 7.  References
  contents:
  - '7.  References

    '
- title: 7.1.  Normative References
  contents:
  - "7.1.  Normative References\n   [FIPS180-3]   Information Technology Laboratory,\
    \ \"Secure Hash\n                 Standard (SHS)\", NIST FIPS Publication 180-3,\
    \ October\n                 2008, <http://csrc.nist.gov/publications/fips/\n \
    \                fips180-3/fips180-3_final.pdf>.\n   [IKEV2-IANA]  IANA, \"Internet\
    \ Key Exchange Version 2 (IKEv2)\n                 Parameters\",\n           \
    \      <http://www.iana.org/assignments/ikev2-parameters>.\n   [RFC2119]     Bradner,\
    \ S., \"Key words for use in RFCs to Indicate\n                 Requirement Levels\"\
    , BCP 14, RFC 2119, March 1997.\n   [RFC3454]     Hoffman, P. and M. Blanchet,\
    \ \"Preparation of\n                 Internationalized Strings (\"stringprep\"\
    )\", RFC 3454,\n                 December 2002.\n   [RFC4013]     Zeilenga, K.,\
    \ \"SASLprep: Stringprep Profile for User\n                 Names and Passwords\"\
    , RFC 4013, February 2005.\n   [RFC4282]     Aboba, B., Beadles, M., Arkko, J.,\
    \ and P. Eronen, \"The\n                 Network Access Identifier\", RFC 4282,\
    \ December 2005.\n   [RFC5996]     Kaufman, C., Hoffman, P., Nir, Y., and P. Eronen,\n\
    \                 \"Internet Key Exchange Protocol Version 2 (IKEv2)\", RFC\n\
    \                 5996, September 2010.\n   [SP800-108]   Chen, L., \"Recommendation\
    \ for Key Derivation Using\n                 Pseudorandom Functions (Revised)\"\
    , NIST Special\n                 Publication 800-108, October 2009,\n        \
    \         <http://csrc.nist.gov/publications/\n                 nistpubs/800-108/sp800-108.pdf>.\n"
- title: 7.2.  Informative References
  contents:
  - "7.2.  Informative References\n   [BJKMRSW00]   Bellare, M., Jablon, D., Krawczyk,\
    \ H., MacKenzie, P.,\n                 Rogaway, P., Swaminathan, R., and T. Wu,\
    \ \"Proposal for\n                 P1363 Study Group on Password-Based\n     \
    \            Authenticated-Key-Exchange Methods\", IEEE P1363.2:\n           \
    \      Password-Based Public-Key Cryptography, Submissions to\n              \
    \   IEEE P1363.2 , February 2000, <http://grouper.ieee.org/\n                \
    \ groups/1363/passwdPK/contributions/p1363-pw.pdf>.\n   [BM92]        Bellovin,\
    \ S. and M. Merritt, \"Encrypted Key Exchange:\n                 Password-based\
    \ Protocols Secure against Dictionary\n                 Attacks\", Proceedings\
    \ of the IEEE Symposium on Security\n                 and Privacy, IEEE Computer\
    \ Society, 1992.\n   [BM93]        Bellovin, S. and M. Merritt, \"Augmented Encrypted\
    \ Key\n                 Exchange: A Password-based Protocol Secure against\n \
    \                Dictionary Attacks and Password File Compromise\",\n        \
    \         Proceedings of the 1st ACM Conference on Computer and\n            \
    \     Communication Security, ACM Press, 1993.\n   [DH76]        Diffie, W. and\
    \ M. Hellman, \"New Directions in\n                 Cryptography\", IEEE Transactions\
    \ on Information Theory\n                 Volume IT-22, Number 6, 1976.\n   [H10]\
    \         Harkins, D., \"Password-Based Authentication in IKEv2:\n           \
    \      Selection Criteria and Considerations\", Work in\n                 Progress,\
    \ October 2010.\n   [IEEEP1363.2] IEEE P1363.2, \"Password-Based Public-Key Cryptography\"\
    ,\n                 Submissions to IEEE P1363.2 , <http://grouper.ieee.org/\n\
    \                 groups/1363/passwdPK/submissions.html>.\n   [ISO]         ISO/IEC\
    \ JTC 1/SC 27 11770-4, \"Information technology --\n                 Security\
    \ techniques -- Key management -- Part 4:\n                 Mechanisms based on\
    \ weak secrets\", April 2006,\n                 <http://www.iso.org/iso/iso_catalogue/catalogue_tc/\n\
    \                 catalogue_detail.htm?csnumber=39723>.\n   [MOV97]       Menezes,\
    \ A., Oorschot, P., and S. Vanstone,\n                 \"Simultaneous Multiple\
    \ Exponentiation\", in Handbook of\n                 Applied Cryptography, CRC\
    \ Press, 1997.\n   [RFC2945]     Wu, T., \"The SRP Authentication and Key Exchange\n\
    \                 System\", RFC 2945, September 2000.\n   [RFC5114]     Lepinski,\
    \ M. and S. Kent, \"Additional Diffie-Hellman\n                 Groups for Use\
    \ with IETF Standards\", RFC 5114, January\n                 2008.\n   [RFC6467]\
    \     Kivinen, T., \"Secure Password Framework for Internet\n                \
    \ Key Exchange Version 2 (IKEv2)\", RFC 6467, December\n                 2011.\n\
    \   [SKI10]       Shin, S., Kobara, K., and H. Imai, \"Security Proof of\n   \
    \              AugPAKE\", Cryptology ePrint Archive:  Report 2010/334,\n     \
    \            June 2010, <http://eprint.iacr.org/2010/334>.\n   [SP800-56A]   Barker,\
    \ E., Johnson, D., and M. Smid, \"Recommendation\n                 for Pair-Wise\
    \ Key Establishment Schemes Using Discrete\n                 Logarithm Cryptography\
    \ (Revised)\", NIST Special\n                 Publication 800-56A, March 2007,\
    \ <http://csrc.nist.gov/\n                 publications/nistpubs/800-56A/\n  \
    \               SP800-56A_Revision1_Mar08-2007.pdf>.\n   [SP800-63]    Burr, W.,\
    \ Dodson, D., and W. Polk, \"Electronic\n                 Authentication Guideline\"\
    , NIST Special Publication\n                 800-63 Version 1.0.2, April 2006,\n\
    \                 <http://csrc.nist.gov/publications/\n                 nistpubs/800-63/SP800-63V1_0_2.pdf>.\n"
- title: Appendix A.  Evaluation by PAKE Selection Criteria
  contents:
  - "Appendix A.  Evaluation by PAKE Selection Criteria\n   Below is a self-evaluation\
    \ of the AugPAKE protocol following PAKE\n   selection criteria [H10].\n   SEC1:\
    \ AugPAKE is zero knowledge (password) proof.  It is secure\n         against\
    \ passive/active/off-line dictionary attacks.  It is also\n         resistant\
    \ to server-compromise impersonation attacks.\n   SEC2: AugPAKE provides Perfect\
    \ Forward Secrecy (PFS) and is secure\n         against Denning-Sacco attack.\n\
    \   SEC3: IKEv2 identity protection is preserved.\n   SEC4: Any cryptographically\
    \ secure Diffie-Hellman groups can be used.\n   SEC5: The formal security proof\
    \ of AugPAKE can be found at [SKI10].\n   SEC6: AugPAKE can be easily used with\
    \ strong credentials.\n   SEC7: In the case of server compromise, an attacker\
    \ has to perform\n         off-line dictionary attacks while computing modular\n\
    \         exponentiation with a password candidate.\n   SEC8: AugPAKE is secure\
    \ regardless of the transform negotiated by\n         IKEv2.\n   IPR1: AugPAKE\
    \ was publicly disclosed on Oct. 2008.\n   IPR2: AIST applied for a patent in\
    \ Japan on July 10, 2008.  AIST\n         would provide royal-free license of\
    \ AugPAKE.\n   IPR3: IPR disclosure (see https://datatracker.ietf.org/ipr/1284/)\n\
    \   MISC1:  AugPAKE adds one round trip to IKEv2.\n   MISC2:  The initiator needs\
    \ to compute only 2 modular exponentiation\n           computations while the\
    \ responder needs to compute 2.17\n           modular exponentiation computations.\
    \  AugPAKE needs to\n           exchange 2 group elements and 2 hash values. \
    \ This is almost\n           the same computation/communication costs as the plain\
    \ Diffie-\n           Hellman (DH) key exchange.  If we use a large (e.g.,\n \
    \          2048/3072-bits) parent group, the hash size would be\n           relatively\
    \ small.\n   MISC3:  AugPAKE has the same performance for any type of secret.\n\
    \   MISC4:  Internationalization of character-based passwords can be\n       \
    \    supported.\n   MISC5:  AugPAKE can be implemented over any ECP (Elliptic\
    \ Curve Group\n           over GF[P]), EC2N (Elliptic Curve Group over GF[2^N]),\
    \ and\n           MODP (Modular Exponentiation Group) groups.\n   MISC6:  AugPAKE\
    \ has request/response nature of IKEv2.\n   MISC7:  No additional negotiation\
    \ is needed.\n   MISC8:  No Trusted Third Party (TTP) and clock synchronization\n\
    \   MISC9:  No additional primitive (e.g., Full Domain Hashing (FDH)\n       \
    \    and/or ideal cipher) is needed.\n   MISC10: As above, AugPAKE can be implemented\
    \ over any ECP/EC2N\n           groups.\n   MISC11: Easy implementation.  We already\
    \ implemented AugPAKE and have\n           been testing in AIST.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   SeongHan Shin\n   AIST\n   Central 2, 1-1-1, Umezono\n\
    \   Tsukuba, Ibaraki 305-8568\n   JP\n   Phone: +81 29-861-2670\n   EMail: seonghan.shin@aist.go.jp\n\
    \   Kazukuni Kobara\n   AIST\n   EMail: kobara_conf@m.aist.go.jp\n"
