- title: __initial_text__
  contents:
  - '            Transition Mechanisms for IPv6 Hosts and Routers

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies IPv4 compatibility mechanisms that can be\n\
    \   implemented by IPv6 hosts and routers.  These mechanisms include\n   providing\
    \ complete implementations of both versions of the Internet\n   Protocol (IPv4\
    \ and IPv6), and tunneling IPv6 packets over IPv4\n   routing infrastructures.\
    \  They are designed to allow IPv6 nodes to\n   maintain complete compatibility\
    \ with IPv4, which should greatly\n   simplify the deployment of IPv6 in the Internet,\
    \ and facilitate the\n   eventual transition of the entire Internet to IPv6.\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   The key to a successful IPv6 transition is compatibility\
    \ with the\n   large installed base of IPv4 hosts and routers.  Maintaining\n\
    \   compatibility with IPv4 while deploying IPv6 will streamline the task\n  \
    \ of transitioning the Internet to IPv6.  This specification defines a\n   set\
    \ of mechanisms that IPv6 hosts and routers may implement in order\n   to be compatible\
    \ with IPv4 hosts and routers.\n   The mechanisms in this document are designed\
    \ to be employed by IPv6\n   hosts and routers that need to interoperate with\
    \ IPv4 hosts and\n   utilize IPv4 routing infrastructures.  We expect that most\
    \ nodes in\n   the Internet will need such compatibility for a long time to come,\n\
    \   and perhaps even indefinitely.\n   However, IPv6 may be used in some environments\
    \ where interoperability\n   with IPv4 is not required.  IPv6 nodes that are designed\
    \ to be used\n   in such environments need not use or even implement these mechanisms.\n\
    \   The mechanisms specified here include:\n   -    Dual IP layer.  Providing\
    \ complete support for both IPv4 and\n        IPv6 in hosts and routers.\n   -\
    \    IPv6 over IPv4 tunneling.  Encapsulating IPv6 packets within\n        IPv4\
    \ headers to carry them over IPv4 routing infrastructures.\n        Two types\
    \ of tunneling are employed: configured and automatic.\n   Additional transition\
    \ and compatibility mechanisms may be developed\n   in the future.  These will\
    \ be specified in other documents.\n"
- title: 1.2. Terminology
  contents:
  - "1.2. Terminology\n   The following terms are used in this document:\n   Types\
    \ of Nodes\n        IPv4-only node:\n                A  host  or  router  that\
    \  implements  only  IPv4.    An\n                IPv4-only  node does not understand\
    \ IPv6.  The installed\n                base of IPv4  hosts  and  routers  existing\
    \  before  the\n                transition begins are IPv4-only nodes.\n     \
    \   IPv6/IPv4 node:\n                A host or router that implements both IPv4\
    \ and IPv6.\n        IPv6-only node:\n                A host or router that implements\
    \ IPv6, and does not\n                implement IPv4.  The operation of IPv6-only\
    \ nodes is not\n                addressed here.\n        IPv6 node:\n        \
    \        Any host or router that implements IPv6.  IPv6/IPv4 and\n           \
    \     IPv6-only nodes are both IPv6 nodes.\n        IPv4 node:\n             \
    \   Any host or router that implements IPv4.  IPv6/IPv4 and\n                IPv4-only\
    \ nodes are both IPv4 nodes.\n   Types of IPv6 Addresses\n        IPv4-compatible\
    \ IPv6 address:\n                An IPv6 address, assigned to an IPv6/IPv4 node,\
    \ which\n                bears the high-order 96-bit prefix 0:0:0:0:0:0, and an\n\
    \                IPv4 address in the low-order 32-bits.  IPv4-compatible\n   \
    \             addresses are used by the automatic tunneling mechanism.\n     \
    \   IPv6-only address:\n                The remainder of the IPv6 address space.\
    \  An IPv6\n                address that bears a prefix other than 0:0:0:0:0:0.\n\
    \   Techniques Used in the Transition\n        IPv6-over-IPv4 tunneling:\n   \
    \             The technique of encapsulating IPv6 packets within IPv4\n      \
    \          so that they can be carried across IPv4 routing\n                infrastructures.\n\
    \        IPv6-in-IPv4 encapsulation:\n                IPv6-over-IPv4 tunneling.\n\
    \        Configured tunneling:\n                IPv6-over-IPv4 tunneling where\
    \ the IPv4 tunnel endpoint\n                address is determined by configuration\
    \ information on\n                the encapsulating node.\n        Automatic tunneling:\n\
    \                IPv6-over-IPv4 tunneling where the IPv4 tunnel endpoint\n   \
    \             address is determined from the IPv4 address embedded in\n      \
    \          the IPv4-compatible destination address of the IPv6\n             \
    \   packet.\n"
- title: 1.3. Structure of this Document
  contents:
  - "1.3. Structure of this Document\n   The remainder of this document is organized\
    \ into three sections:\n   -    Section 2 discusses the IPv4-compatible address\
    \ format.\n   -    Section 3 discusses the operation of nodes with a dual IP\n\
    \        layer, IPv6/IPv4 nodes.\n   -    Section 4 discusses IPv6-over-IPv4 tunneling.\n"
- title: 2. Addressing
  contents:
  - "2. Addressing\n   The automatic tunneling mechanism uses a special type of IPv6\n\
    \   address, termed an \"IPv4-compatible\" address.  An IPv4-compatible\n   address\
    \ is identified by an all-zeros 96-bit prefix, and holds an\n   IPv4 address in\
    \ the low-order 32-bits.  IPv4-compatible addresses are\n   structured as follows:\n\
    \        |              96-bits                 |   32-bits    |\n        +--------------------------------------+--------------+\n\
    \        |            0:0:0:0:0:0               | IPv4 Address |\n        +--------------------------------------+--------------+\n\
    \                 IPv4-Compatible IPv6 Address Format\n   IPv4-compatible addresses\
    \ are assigned to IPv6/IPv4 nodes that\n   support automatic tunneling.  Nodes\
    \ that are configured with IPv4-\n   compatible addresses may use the complete\
    \ address as their IPv6\n   address, and use the embedded IPv4 address as their\
    \ IPv4 address.\n   The remainder of the IPv6 address space (that is, all addresses\
    \ with\n   96-bit prefixes other than 0:0:0:0:0:0) are termed \"IPv6-only\n  \
    \ Addresses.\"\n"
- title: 3. Dual IP Layer
  contents:
  - "3. Dual IP Layer\n   The most straightforward way for IPv6 nodes to remain compatible\
    \ with\n   IPv4-only nodes is by providing a complete IPv4 implementation.  IPv6\n\
    \   nodes that provide a complete IPv4 implementation in addition to\n   their\
    \ IPv6 implementation are called \"IPv6/IPv4 nodes.\"  IPv6/IPv4\n   nodes have\
    \ the ability to send and receive both IPv4 and IPv6\n   packets.  They can directly\
    \ interoperate with IPv4 nodes using IPv4\n   packets, and also directly interoperate\
    \ with IPv6 nodes using IPv6\n   packets.\n   The dual IP layer technique may\
    \ or may not be used in conjunction\n   with the IPv6-over-IPv4 tunneling techniques,\
    \ which are described in\n   section 4.  An IPv6/IPv4 node that supports tunneling\
    \ may support\n   only configured tunneling, or both configured and automatic\n\
    \   tunneling.  Thus three configurations are possible:\n   -    IPv6/IPv4 node\
    \ that does not perform tunneling.\n   -    IPv6/IPv4 node that performs configured\
    \ tunneling only.\n   -    IPv6/IPv4 node that performs configured tunneling and\n\
    \        automatic tunneling.\n"
- title: 3.1. Address Configuration
  contents:
  - "3.1. Address Configuration\n   Because they support both protocols, IPv6/IPv4\
    \ nodes may be\n   configured with both IPv4 and IPv6 addresses.  Although the\
    \ two\n   addresses may be related to each other, this is not required.\n   IPv6/IPv4\
    \ nodes may be configured with IPv6 and IPv4 addresses that\n   are unrelated\
    \ to each other.\n   Nodes that perform automatic tunneling are configured with\
    \ IPv4-\n   compatible IPv6 addresses.  These may be viewed as single addresses\n\
    \   that can serve both as IPv6 and IPv4 addresses.  The entire 128-bit\n   IPv4-compatible\
    \ IPv6 address is used as the node's IPv6 address,\n   while the IPv4 address\
    \ embedded in low-order 32-bits serves as the\n   node's IPv4 address.\n   IPv6/IPv4\
    \ nodes may use the stateless IPv6 address configuration\n   mechanism [5] or\
    \ DHCP for IPv6 [3] to acquire their IPv6 address.\n   These mechanisms may provide\
    \ either IPv4-compatible or IPv6-only IPv6\n   addresses.\n   IPv6/IPv4 nodes\
    \ may use IPv4 mechanisms to acquire their IPv4\n   addresses.\n   IPv6/IPv4 nodes\
    \ that perform automatic tunneling may also acquire\n   their IPv4-compatible\
    \ IPv6 addresses from another source: IPv4\n   address configuration protocols.\
    \  A node may use any IPv4 address\n   configuration mechanism to acquire its\
    \ IPv4 address, then \"map\" that\n   address into an IPv4-compatible IPv6 address\
    \ by pre-pending it with\n   the 96-bit prefix 0:0:0:0:0:0.  This mode of configuration\
    \ allows\n   IPv6/IPv4 nodes to \"leverage\" the installed base of IPv4 address\n\
    \   configuration servers.  It can be particularly useful in environments\n  \
    \ where IPv6 routers and address configuration servers have not yet\n   been deployed.\n\
    \   The specific algorithm for acquiring an IPv4-compatible address using\n  \
    \ IPv4-based address configuration protocols is as follows:\n   1)   The IPv6/IPv4\
    \ node uses standard IPv4 mechanisms or protocols\n        to acquire its own\
    \ IPv4 address.  These include:\n           -    The Dynamic Host Configuration\
    \ Protocol (DHCP) [2]\n           -    The Bootstrap Protocol (BOOTP) [1]\n  \
    \         -    The Reverse Address Resolution Protocol (RARP) [9]\n          \
    \ -    Manual configuration\n           -    Any other mechanism which accurately\
    \ yields the node's\n                own IPv4 address\n   2)   The node uses this\
    \ address as its IPv4 address.\n   3)   The node prepends the 96-bit prefix 0:0:0:0:0:0\
    \ to the 32-bit\n        IPv4 address that it acquired in step (1).  The result\
    \ is an\n        IPv4-compatible IPv6 address with the node's own IPv4-address\n\
    \        embedded in the low-order 32-bits.  The node uses this address\n    \
    \    as its own IPv6 address.\n"
- title: 3.1.1. IPv4 Loopback Address
  contents:
  - "3.1.1. IPv4 Loopback Address\n   Many IPv4 implementations treat the address\
    \ 127.0.0.1 as a \"loopback\n   address\" -- an address to reach services located\
    \ on the local\n   machine.  Per the host requirements specification [10], section\n\
    \   3.2.1.3, IPv4 packets addressed from or to the loopback address are\n   not\
    \ to be sent onto the network; they must remain entirely within the\n   node.\
    \  IPv6/IPv4 implementations may treat the IPv4-compatible IPv6\n   address ::127.0.0.1\
    \ as an IPv6 loopback address.  Packets with this\n   address should also remain\
    \ entirely within the node, and not be\n   transmitted onto the network.\n"
- title: 3.2.  DNS
  contents:
  - "3.2.  DNS\n   The Domain Naming System (DNS) is used in both IPv4 and IPv6 to\
    \ map\n   hostnames into addresses.  A new resource record type named \"AAAA\"\
    \n   has been defined for IPv6 addresses [6].  Since IPv6/IPv4 nodes must\n  \
    \ be able to interoperate directly with both IPv4 and IPv6 nodes, they\n   must\
    \ provide resolver libraries capable of dealing with IPv4 \"A\"\n   records as\
    \ well as IPv6 \"AAAA\" records.\n"
- title: 3.2.1.  Handling Records for IPv4-Compatible Addresses
  contents:
  - "3.2.1.  Handling Records for IPv4-Compatible Addresses\n   When an IPv4-compatible\
    \ IPv6 addresses is assigned to an IPv6/IPv4\n   host that supports automatic\
    \ tunneling, both A and AAAA records are\n   listed in the DNS.  The AAAA record\
    \ holds the full IPv4-compatible\n   IPv6 address, while the A record holds the\
    \ low-order 32-bits of that\n   address.  The AAAA record is needed so that queries\
    \ by IPv6 hosts can\n   be satisfied.  The A record is needed so that queries\
    \ by IPv4-only\n   hosts, whose resolver libraries only support the A record type,\
    \ will\n   locate the host.\n   DNS resolver libraries on IPv6/IPv4 nodes must\
    \ be capable of handling\n   both AAAA and A records.  However, when a query locates\
    \ an AAAA\n   record holding an IPv4-compatible IPv6 address, and an A record\n\
    \   holding the corresponding IPv4 address, the resolver library need not\n  \
    \ necessarily return both addresses.  It has three options:\n   -    Return only\
    \ the IPv6 address to the application.\n   -    Return only the IPv4 address to\
    \ the application.\n   -    Return both addresses to the application.\n   The\
    \ selection of which address type to return in this case, or, if\n   both addresses\
    \ are returned, in which order they are listed, can\n   affect what type of IP\
    \ traffic is generated.  If the IPv6 address is\n   returned, the node will communicate\
    \ with that destination using IPv6\n   packets (in most cases encapsulated in\
    \ IPv4); If the IPv4 address is\n   returned, the communication will use IPv4\
    \ packets.\n   The way that DNS resolver implementations handle redundant records\n\
    \   for IPv4-compatible addresses may depend on whether that\n   implementation\
    \ supports automatic tunneling, or whether it is\n   enabled.  For example, an\
    \ implementation that does not support\n   automatic tunneling would not return\
    \ IPv4-compatible IPv6 addresses\n   to applications because those destinations\
    \ are generally only\n   reachable via tunneling.  On the other hand, those implementations\
    \ in\n   which automatic tunneling is supported and enabled may elect to\n   return\
    \ only the IPv4-compatible IPv6 address and not the IPv4\n   address.\n"
- title: 4. IPv6-over-IPv4 Tunneling
  contents:
  - "4. IPv6-over-IPv4 Tunneling\n   In most deployment scenarios, the IPv6 routing\
    \ infrastructure will be\n   built up over time.  While the IPv6 infrastructure\
    \ is being deployed,\n   the existing IPv4 routing infrastructure can remain functional,\
    \ and\n   can be used to carry IPv6 traffic.  Tunneling provides a way to\n  \
    \ utilize an existing IPv4 routing infrastructure to carry IPv6\n   traffic.\n\
    \   IPv6/IPv4 hosts and routers can tunnel IPv6 datagrams over regions of\n  \
    \ IPv4 routing topology by encapsulating them within IPv4 packets.\n   Tunneling\
    \ can be used in a variety of ways:\n   -    Router-to-Router.  IPv6/IPv4 routers\
    \ interconnected by an IPv4\n        infrastructure can tunnel IPv6 packets between\
    \ themselves.  In\n        this case, the tunnel spans one segment of the end-to-end\
    \ path\n        that the IPv6 packet takes.\n   -    Host-to-Router.  IPv6/IPv4\
    \ hosts can tunnel IPv6 packets to an\n        intermediary IPv6/IPv4 router that\
    \ is reachable via an IPv4\n        infrastructure.  This type of tunnel spans\
    \ the first segment\n        of the packet's end-to-end path.\n   -    Host-to-Host.\
    \  IPv6/IPv4 hosts that are interconnected by an\n        IPv4 infrastructure\
    \ can tunnel IPv6 packets between\n        themselves.  In this case, the tunnel\
    \ spans the entire\n        end-to-end path that the packet takes.\n   -    Router-to-Host.\
    \ IPv6/IPv4 routers can tunnel IPv6 packets to\n        their final destination\
    \ IPv6/IPv4 host.  This tunnel spans\n        only the last segment of the end-to-end\
    \ path.\n   Tunneling techniques are usually classified according to the\n   mechanism\
    \ by which the encapsulating node determines the address of\n   the node at the\
    \ end of the tunnel.  In the first two tunneling\n   methods listed above -- router-to-router\
    \ and host-to-router -- the\n   IPv6 packet is being tunneled to a router.  The\
    \ endpoint of this type\n   of tunnel is an intermediary router which must decapsulate\
    \ the IPv6\n   packet and forward it on to its final destination.  When tunneling\
    \ to\n   a router, the endpoint of the tunnel is different from the\n   destination\
    \ of the packet being tunneled.  So the addresses in the\n   IPv6 packet being\
    \ tunneled do not provide the IPv4 address of the\n   tunnel endpoint.  Instead,\
    \ the tunnel endpoint address must be\n   determined from configuration information\
    \ on the node performing the\n   tunneling.  We use the term \"configured tunneling\"\
    \ to describe the\n   type of tunneling where the endpoint is explicitly configured.\n\
    \   In the last two tunneling methods -- host-to-host and router-to-host\n   --\
    \ the IPv6 packet is tunneled all the way to its final destination.\n   The tunnel\
    \ endpoint is the node to which the IPv6 packet is\n   addressed.  Since the endpoint\
    \ of the tunnel is the destination of\n   the IPv6 packet, the tunnel endpoint\
    \ can be determined from the\n   destination IPv6 address of that packet: If that\
    \ address is an IPv4-\n   compatible address, then the low-order 32-bits hold\
    \ the IPv4 address\n   of the destination node, and that can be used as the tunnel\
    \ endpoint\n   address.  This technique avoids the need to explicitly configure\
    \ the\n   tunnel endpoint address.  Deriving the tunnel endpoint address from\n\
    \   the embedded IPv4 address of the packet's IPv6 address is termed\n   \"automatic\
    \ tunneling\".\n   The two tunneling techniques -- automatic and configured --\
    \ differ\n   primarily in how they determine the tunnel endpoint address.  Most\
    \ of\n   the underlying mechanisms are the same:\n   -    The entry node of the\
    \ tunnel (the encapsulating node) creates an\n        encapsulating IPv4 header\
    \ and transmits the encapsulated packet.\n   -    The exit node of the tunnel\
    \ (the decapsulating node) receives\n        the encapsulated packet, removes\
    \ the IPv4 header, updates the\n        IPv6 header, and processes the received\
    \ IPv6 packet.\n   -    The encapsulating node may need to maintain soft state\n\
    \        information for each tunnel recording such parameters as the MTU\n  \
    \      of the tunnel in order to process IPv6 packets forwarded into\n       \
    \ the tunnel.  Since the number of tunnels that any one host or\n        router\
    \ may be using may grow to be quite large, this state\n        information can\
    \ be cached and discarded when not in use.\n   The next section discusses the\
    \ common mechanisms that apply to both\n   types of tunneling.  Subsequent sections\
    \ discuss how the tunnel\n   endpoint address is determined for automatic and\
    \ configured\n   tunneling.\n"
- title: 4.1. Common Tunneling Mechanisms
  contents:
  - "4.1. Common Tunneling Mechanisms\n   The encapsulation of an IPv6 datagram in\
    \ IPv4 is shown below:\n                                        +-------------+\n\
    \                                        |    IPv4     |\n                   \
    \                     |   Header    |\n        +-------------+               \
    \  +-------------+\n        |    IPv6     |                 |    IPv6     |\n\
    \        |   Header    |                 |   Header    |\n        +-------------+\
    \                 +-------------+\n        |  Transport  |                 | \
    \ Transport  |\n        |   Layer     |      ===>       |   Layer     |\n    \
    \    |   Header    |                 |   Header    |\n        +-------------+\
    \                 +-------------+\n        |             |                 | \
    \            |\n        ~    Data     ~                 ~    Data     ~\n    \
    \    |             |                 |             |\n        +-------------+\
    \                 +-------------+\n                      Encapsulating IPv6 in\
    \ IPv4\n   In addition to adding an IPv4 header, the encapsulating node also has\n\
    \   to handle some more complex issues:\n  -     Determine when to fragment and\
    \ when to report an ICMP \"packet\n        too big\" error back to the source.\n\
    \  -     How to reflect IPv4 ICMP errors from routers along the tunnel\n     \
    \   path back to the source as IPv6 ICMP errors.\n   Those issues are discussed\
    \ in the following sections.\n"
- title: 4.1.1.  Tunnel MTU and Fragmentation
  contents:
  - "4.1.1.  Tunnel MTU and Fragmentation\n   The encapsulating node could view encapsulation\
    \ as IPv6 using IPv4 as\n   a link layer with a very large MTU (65535-20 bytes\
    \ to be exact; 20\n   bytes \"extra\" are needed for the encapsulating IPv4 header).\
    \  The\n   encapsulating node would need only to report IPv6 ICMP \"packet too\n\
    \   big\" errors back to the source for packets that exceed this MTU.\n   However,\
    \ such a scheme would be inefficient for two reasons:\n  1)    It would result\
    \ in more fragmentation than needed. IPv4 layer\n        fragmentation should\
    \ be avoided due to the performance problems\n        caused by the loss unit\
    \ being smaller than the retransmission\n        unit [11].\n  2)    Any IPv4\
    \ fragmentation occurring inside the tunnel would have to\n        be reassembled\
    \ at the tunnel endpoint.  For tunnels that\n        terminate at a router, this\
    \ would require additional memory to\n        reassemble the IPv4 fragments into\
    \ a complete IPv6 packet before\n        that packet could be forwarded onward.\n\
    \   The fragmentation inside the tunnel can be reduced to a minimum by\n   having\
    \ the encapsulating node track the IPv4 Path MTU across the\n   tunnel, using\
    \ the IPv4 Path MTU Discovery Protocol [8] and recording\n   the resulting path\
    \ MTU.  The IPv6 layer in the encapsulating node can\n   then view a tunnel as\
    \ a link layer with an MTU equal to the IPv4 path\n   MTU, minus the size of the\
    \ encapsulating IPv4 header.\n   Note that this does not completely eliminate\
    \ IPv4 fragmentation in\n   the case when the IPv4 path MTU would result in an\
    \ IPv6 MTU less than\n   576 bytes. (Any link layer used by IPv6 has to have an\
    \ MTU of at\n   least 576 bytes [4].) In this case the IPv6 layer has to \"see\"\
    \ a link\n   layer with an MTU of 576 bytes and the encapsulating node has to\
    \ use\n   IPv4 fragmentation in order to forward the 576 byte IPv6 packets.\n\
    \   The encapsulating node can employ the following algorithm to\n   determine\
    \ when to forward an IPv6 packet that is larger than the\n   tunnel's path MTU\
    \ using IPv4 fragmentation, and when to return an\n   IPv6 ICMP \"packet too big\"\
    \ message:\n        if (IPv4 path MTU - 20) is less than or equal to 576\n   \
    \             if packet is larger than 576 bytes\n                        Send\
    \ IPv6 ICMP \"packet too big\" with MTU = 576.\n                        Drop packet.\n\
    \                else\n                        Encapsulate but do not set the\
    \ Don't Fragment\n                        flag in the IPv4 header. The resulting\
    \ IPv4\n                        packet might be fragmented by the IPv4 layer on\n\
    \                        the encapsulating node or by some router along\n    \
    \                    the IPv4 path.\n                endif\n        else\n   \
    \             if packet is larger than (IPv4 path MTU - 20)\n                \
    \        Send IPv6 ICMP \"packet too big\" with\n                        MTU =\
    \ (IPv4 path MTU - 20).\n                        Drop packet.\n              \
    \  else\n                        Encapsulate and set the Don't Fragment flag\n\
    \                        in the IPv4 header.\n                endif\n        endif\n\
    \   Encapsulating nodes that have a large number of tunnels might not be\n   able\
    \ to store the IPv4 Path MTU for all tunnels. Such nodes can, at\n   the expense\
    \ of additional fragmentation in the network, avoid using\n   the IPv4 Path MTU\
    \ algorithm across the tunnel and instead use the MTU\n   of the link layer (under\
    \ IPv4) in the above algorithm instead of the\n   IPv4 path MTU.\n   In this case\
    \ the Don't Fragment bit must not be set in the\n   encapsulating IPv4 header.\n"
- title: 4.1.2.  Hop Limit
  contents:
  - "4.1.2.  Hop Limit\n   IPv6-over-IPv4 tunnels are modeled as \"single-hop\". \
    \ That is, the\n   IPv6 hop limit is decremented by 1 when an IPv6 packet traverses\
    \ the\n   tunnel.  The single-hop model serves to hide the existence of a\n  \
    \ tunnel.  The tunnel is opaque to users of the network, and is not\n   detectable\
    \ by network diagnostic tools such as traceroute.\n   The single-hop model is\
    \ implemented by having the encapsulating and\n   decapsulating nodes process\
    \ the IPv6 hop limit field as they would if\n   they were forwarding a packet\
    \ on to any other datalink.  That is,\n   they decrement the hop limit by 1 when\
    \ forwarding an IPv6 packet.\n   (The originating node and final destination do\
    \ not decrement the hop\n   limit.)\n   The TTL of the encapsulating IPv4 header\
    \ is selected in an\n   implementation dependent manner.  The current suggested\
    \ value is\n   published in the \"Assigned Numbers RFC.  Implementations may provide\n\
    \   a mechanism to allow the administrator to configure the IPv4 TTL.\n"
- title: 4.1.3. Handling IPv4 ICMP errors
  contents:
  - "4.1.3. Handling IPv4 ICMP errors\n   In response to encapsulated packets it has\
    \ sent into the tunnel, the\n   encapsulating node may receive IPv4 ICMP error\
    \ messages from IPv4\n   routers inside the tunnel.  These packets are addressed\
    \ to the\n   encapsulating node because it is the IPv4 source of the encapsulated\n\
    \   packet.\n   The ICMP \"packet too big\" error messages are handled according\
    \ to\n   IPv4 Path MTU Discovery [8] and the resulting path MTU is recorded in\n\
    \   the IPv4 layer.  The recorded path MTU is used by IPv6 to determine\n   if\
    \ an IPv6 ICMP \"packet too big\" error has to be generated as\n   described in\
    \ section 4.1.1.\n   The handling of other types of ICMP error messages depends\
    \ on how\n   much information is included in the \"packet in error\" field, which\n\
    \   holds the encapsulated packet that caused the error.\n   Many older IPv4 routers\
    \ return only 8 bytes of data beyond the IPv4\n   header of the packet in error,\
    \ which is not enough to include the\n   address fields of the IPv6 header. More\
    \ modern IPv4 routers may\n   return enough data beyond the IPv4 header to include\
    \ the entire IPv6\n   header and possibly even the data beyond that.\n   If the\
    \ offending packet includes enough data, the encapsulating node\n   may extract\
    \ the encapsulated IPv6 packet and use it to generating an\n   IPv6 ICMP message\
    \ directed back to the originating IPv6 node, as\n   shown below:\n          \
    \      +--------------+\n                | IPv4 Header  |\n                | dst\
    \ = encaps |\n                |       node   |\n                +--------------+\n\
    \                |     ICMP     |\n                |    Header    |\n        \
    \ - -    +--------------+\n                | IPv4 Header  |\n                |\
    \ src = encaps |\n        IPv4    |       node   |\n                +--------------+\
    \   - -\n        Packet  |    IPv6      |\n                |    Header    |  \
    \ Original IPv6\n         in     +--------------+   Packet -\n               \
    \ |  Transport   |   Can be used to\n        Error   |    Header    |   generate\
    \ an\n                +--------------+   IPv6 ICMP\n                |        \
    \      |   error message\n                ~     Data     ~   back to the source.\n\
    \                |              |\n         - -    +--------------+   - -\n  \
    \      IPv4 ICMP Error Message Returned to Encapsulating Node\n"
- title: 4.1.4.  IPv4 Header Construction
  contents:
  - "4.1.4.  IPv4 Header Construction\n   When encapsulating an IPv6 packet in an\
    \ IPv4 datagram, the IPv4\n   header fields are set as follows:\n        Version:\n\
    \                4\n        IP Header Length in 32-bit words:\n              \
    \  5 (There are no IPv4 options in the encapsulating\n                header.)\n\
    \        Type of Service:\n                0\n        Total Length:\n        \
    \        Payload length from IPv6 header plus length of IPv6 and\n           \
    \     IPv4 headers (i.e. a constant 60 bytes).\n        Identification:\n    \
    \            Generated uniquely as for any IPv4 packet transmitted by\n      \
    \          the system.\n        Flags:\n                Set the Don't Fragment\
    \ (DF) flag as specified in\n                section 4.1.1. Set the More Fragments\
    \ (MF) bit as\n                necessary if fragmenting.\n        Fragment offset:\n\
    \                Set as necessary if fragmenting.\n        Time to Live:\n   \
    \             Set in implementation-specific manner.\n        Protocol:\n    \
    \            41 (Assigned payload type number for IPv6)\n        Header Checksum:\n\
    \                Calculate the checksum of the IPv4 header.\n        Source Address:\n\
    \                IPv4 address of outgoing interface of the\n                encapsulating\
    \ node.\n        Destination Address:\n                IPv4 address of tunnel\
    \ endpoint.\n   Any IPv6 options are preserved in the packet (after the IPv6 header).\n"
- title: 4.1.5. Decapsulating IPv6-in-IPv4 Packets
  contents:
  - "4.1.5. Decapsulating IPv6-in-IPv4 Packets\n   When an IPv6/IPv4 host or a router\
    \ receives an IPv4 datagram that is\n   addressed to one of its own IPv4 address,\
    \ and the value of the\n   protocol field is 41, it removes the IPv4 header and\
    \ submits the IPv6\n   datagram to its IPv6 layer code.\n   The decapsulation\
    \ is shown below:\n        +-------------+\n        |    IPv4     |\n        |\
    \   Header    |\n        +-------------+                 +-------------+\n   \
    \     |    IPv6     |                 |    IPv6     |\n        |   Header    |\
    \                 |   Header    |\n        +-------------+                 +-------------+\n\
    \        |  Transport  |                 |  Transport  |\n        |   Layer  \
    \   |      ===>       |   Layer     |\n        |   Header    |               \
    \  |   Header    |\n        +-------------+                 +-------------+\n\
    \        |             |                 |             |\n        ~    Data  \
    \   ~                 ~    Data     ~\n        |             |               \
    \  |             |\n        +-------------+                 +-------------+\n\
    \                    Decapsulating IPv6 from IPv4\n   When decapsulating the IPv6-in-IPv4\
    \ packet, the IPv6 header is not\n   modified.  If the packet is subsequently\
    \ forwarded, its hop limit is\n   decremented by one.\n   The encapsulating IPv4\
    \ header is discarded.\n   The decapsulating node performs IPv4 reassembly before\
    \ decapsulating\n   the IPv6 packet.  All IPv6 options are preserved even if the\n\
    \   encapsulating IPv4 packet is fragmented.\n   After the IPv6 packet is decapsulated,\
    \ it is processed the same as\n   any received IPv6 packet.\n"
- title: 4.2. Configured Tunneling
  contents:
  - "4.2. Configured Tunneling\n   In configured tunneling, the tunnel endpoint address\
    \ is determined\n   from configuration information in the encapsulating node.\
    \  For each\n   tunnel, the encapsulating node must store the tunnel endpoint\n\
    \   address.  When an IPv6 packet is transmitted over a tunnel, the\n   tunnel\
    \ endpoint address configured for that tunnel is used as the\n   destination address\
    \ for the encapsulating IPv4 header.\n   The determination of which packets to\
    \ tunnel is usually made by\n   routing information on the encapsulating node.\
    \  This is usually done\n   via a routing table, which directs packets based on\
    \ their destination\n   address using the prefix mask and match technique.\n"
- title: 4.2.1. Default Configured Tunnel
  contents:
  - "4.2.1. Default Configured Tunnel\n   Nodes that are connected to IPv4 routing\
    \ infrastructures may use a\n   configured tunnel to reach an IPv6 \"backbone\"\
    .  If the IPv4 address\n   of an IPv6/IPv4 router bordering the backbone is known,\
    \ a tunnel can\n   be configured to that router.  This tunnel can be configured\
    \ into the\n   routing table as a \"default route\".  That is, all IPv6 destination\n\
    \   addresses will match the route and could potentially traverse the\n   tunnel.\
    \  Since the \"mask length\" of such default route is zero, it\n   will be used\
    \ only if there are no other routes with a longer mask\n   that match the destination.\n\
    \   The tunnel endpoint address of such a default tunnel could be the\n   IPv4\
    \ address of one IPv6/IPv4 router at the border of the IPv6\n   backbone.  Alternatively,\
    \ the tunnel endpoint could be an IPv4\n   \"anycast address\".  With this approach,\
    \ multiple IPv6/IPv4 routers at\n   the border advertise IPv4 reachability to\
    \ the same IPv4 address.  All\n   of these routers accept packets to this address\
    \ as their own, and\n   will decapsulate IPv6 packets tunneled to this address.\
    \  When an\n   IPv6/IPv4 node sends an encapsulated packet to this address, it\
    \ will\n   be delivered to only one of the border routers, but the sending node\n\
    \   will not know which one.  The IPv4 routing system will generally\n   carry\
    \ the traffic to the closest router.\n   Using a default tunnel to an IPv4 \"\
    anycast address\" provides a high\n   degree of robustness since multiple border\
    \ router can be provided,\n   and, using the normal fallback mechanisms of IPv4\
    \ routing, traffic\n   will automatically switch to another router when one goes\
    \ down.\n"
- title: 4.3. Automatic Tunneling
  contents:
  - "4.3. Automatic Tunneling\n   In automatic tunneling, the tunnel endpoint address\
    \ is determined\n   from the packet being tunneled.  The destination IPv6 address\
    \ in the\n   packet must be an IPv4-compatible address.  If it is, the IPv4\n\
    \   address component of that address -- the low-order 32-bits -- are\n   extracted\
    \ and used as the tunnel endpoint address.  IPv6 packets that\n   are not addressed\
    \ to an IPv4-compatible address can not be tunneled\n   using automatic tunneling.\n\
    \   IPv6/IPv4 nodes need to determine which IPv6 packets can be sent via\n   automatic\
    \ tunneling.  One technique is to use the IPv6 routing table\n   to direct automatic\
    \ tunneling.  An implementation can have a special\n   static routing table entry\
    \ for the prefix 0:0:0:0:0:0/96.  (That is,\n   a route to the all-zeros prefix\
    \ with a 96-bit mask.)  Packets that\n   match this prefix are sent to a pseudo-interface\
    \ driver which\n   performs automatic tunneling.  Since all IPv4-compatible IPv6\n\
    \   addresses will match this prefix, all packets to those destinations\n   will\
    \ be auto-tunneled.\n"
- title: 4.4. Default Sending Algorithm
  contents:
  - "4.4. Default Sending Algorithm\n   This section presents a combined IPv4 and\
    \ IPv6 sending algorithm that\n   IPv6/IPv4 nodes can use.  The algorithm can\
    \ be used to determine when\n   to send IPv4 packets, when to send IPv6 packets,\
    \ and when to perform\n   automatic and configured tunneling.  It illustrates\
    \ how the\n   techniques of dual IP layer, configured tunneling, and automatic\n\
    \   tunneling can be used together.  Note that is just an example to show\n  \
    \ how the techniques can be combined; IPv6/IPv6 implementations may\n   provide\
    \ different algorithms.  This algorithm has the following\n   properties:\n  \
    \ -    Sends IPv4 packets to all IPv4 destinations.\n   -    Sends IPv6 packets\
    \ to all IPv6 destinations on the same link.\n   -    Using automatic tunneling,\
    \ sends IPv6 packets encapsulated in\n        IPv4 to IPv6 destinations with IPv4-compatible\
    \ addresses that\n        are located off-link.\n   -    Sends IPv6 packets to\
    \ IPv6 destinations located off-link when\n        IPv6 routers are present.\n\
    \   -    Using the default IPv6 tunnel, sends IPv6 packets encapsulated\n    \
    \    in IPv4 to IPv6 destinations with IPv6-only addresses when no\n        IPv6\
    \ routers are present.\n"
- title: 'The algorithm is as follows:'
  contents:
  - "The algorithm is as follows:\n  1)    If the address of the end node is an IPv4\
    \ address then:\n          1.1)  If the destination is located on an attached\
    \ link, then\n                send an IPv4 packet addressed to the end node.\n\
    \          1.2)  If the destination is located off-link, then;\n             \
    \   1.2.1)  If there is an IPv4 router on link, then send an\n               \
    \         IPv4 format packet.  The IPv4 destination\n                        address\
    \ is the IPv4 address of the end node.\n                        The datalink address\
    \ is the datalink address of\n                        the IPv4 router.\n     \
    \           1.2.2)  Else, the destination is treated as\n                    \
    \    \"unreachable\" because it is located off link and\n                    \
    \    there are no on-link routers.\n  2)    If the address of the end node is\
    \ an IPv4-compatible IPv6\n        address (i.e. bears the prefix 0:0:0:0:0:0),\
    \ then:\n          2.1)  If the destination is located on an attached link, then\n\
    \                send an IPv6 format packet (not encapsulated).  The IPv6\n  \
    \              destination address is the IPv6 address of the end node.\n    \
    \            The datalink address is the datalink address of the end\n       \
    \         node.\n          2.2)  If the destination is located off-link, then:\n\
    \                2.2.1)  If there is an IPv4 router on an attached link,\n   \
    \                     then send an IPv6 packet encapsulated in IPv4.\n       \
    \                 The IPv6 destination address is the address of\n           \
    \             the end node.  The IPv4 destination address is\n               \
    \         the low-order 32-bits of the end node's address.\n                 \
    \       The datalink address is the datalink address of\n                    \
    \    the IPv4 router.\n                2.2.2)  Else, if there is an IPv6 router\
    \ on an attached\n                        link, then send an IPv6 format packet.\
    \  The IPv6\n                        destination address is the IPv6 address of\
    \ the\n                        end node.  The datalink address is the datalink\n\
    \                        address of the IPv6 router.\n                2.2.3) \
    \ Else, the destination is treated as\n                        \"unreachable\"\
    \ because it is located off-link and\n                        there are no on-link\
    \ routers.\n   3)   If the address of the end node is an IPv6-only address, then:\n\
    \          3.1)  If the destination is located on an attached link, then\n   \
    \             send an IPv6 format packet.  The IPv6 destination\n            \
    \    address is the IPv6 address of the end node.  The\n                datalink\
    \ address is the datalink address of the end\n                node.\n        \
    \  3.2)  If the destination is located off-link, then:\n                3.2.1)\
    \  If there is an IPv6 router on an attached link,\n                        then\
    \ send an IPv6 format packet.  The IPv6\n                        destination address\
    \ is the IPv6 address of the\n                        end node.  The datalink\
    \ address is the datalink\n                        address of the IPv6 router.\n\
    \                3.2.2)  Else, if the destination is reachable via a\n       \
    \                 configured tunnel, and there is an IPv4 router\n           \
    \             on an attached link, then send an IPv6\n                       \
    \ packet encapsulated in IPv4.  The IPv6\n                        destination\
    \ address is the address of the end\n                        node.  The IPv4 destination\
    \ address is the\n                        configured IPv4 address of the tunnel\
    \ endpoint.\n                        The datalink address is the datalink address\
    \ of\n                        the IPv4 router.\n                3.2.3)  Else,\
    \ the destination is treated as\n                        \"unreachable\" because\
    \ it is located off-link and\n                        there are no on-link IPv6\
    \ routers.\n"
- title: 'A summary of these sending rules are given in the table below:'
  contents:
  - 'A summary of these sending rules are given in the table below:

    '
- title: End         | End     | IPv4    | IPv6    | Packet |      |      |
  contents:
  - 'End         | End     | IPv4    | IPv6    | Packet |      |      |

    '
- title: Node        | Node    | Router  | Router  | Format | IPv6 | IPv4 | DLink
  contents:
  - 'Node        | Node    | Router  | Router  | Format | IPv6 | IPv4 | DLink

    '
- title: Address     | On      | On      | On      | To     | Dest | Dest | Dest
  contents:
  - 'Address     | On      | On      | On      | To     | Dest | Dest | Dest

    '
- title: Type        | Link?   | Link?   | Link?   | Send   | Addr | Addr | Addr
  contents:
  - 'Type        | Link?   | Link?   | Link?   | Send   | Addr | Addr | Addr

    '
- title: '------------+---------+---------+---------+--------+------+------+------'
  contents:
  - '------------+---------+---------+---------+--------+------+------+------

    '
- title: IPv4        | Yes     |  N/A    |  N/A    | IPv4   |  N/A |  E4  | EL
  contents:
  - 'IPv4        | Yes     |  N/A    |  N/A    | IPv4   |  N/A |  E4  | EL

    '
- title: '------------+---------+---------+---------+--------+------+------+------'
  contents:
  - '------------+---------+---------+---------+--------+------+------+------

    '
- title: IPv4        | No      |  Yes    |  N/A    | IPv4   |  N/A |  E4  | RL
  contents:
  - 'IPv4        | No      |  Yes    |  N/A    | IPv4   |  N/A |  E4  | RL

    '
- title: '------------+---------+---------+---------+--------+------+------+------'
  contents:
  - '------------+---------+---------+---------+--------+------+------+------

    '
- title: IPv4        | No      |  No     |  N/A    | UNRCH  |  N/A |  N/A | N/A
  contents:
  - 'IPv4        | No      |  No     |  N/A    | UNRCH  |  N/A |  N/A | N/A

    '
- title: '------------+---------+---------+---------+--------+------+------+------'
  contents:
  - '------------+---------+---------+---------+--------+------+------+------

    '
- title: IPv4-compat | Yes     |  N/A    |  N/A    | IPv6   |  E6  |  N/A | EL
  contents:
  - 'IPv4-compat | Yes     |  N/A    |  N/A    | IPv6   |  E6  |  N/A | EL

    '
- title: '------------+---------+---------+---------+--------+------+------+------'
  contents:
  - '------------+---------+---------+---------+--------+------+------+------

    '
- title: IPv4-compat | No      |  Yes    |  N/A    | IPv6/4 |  E6  |  E4  | RL
  contents:
  - 'IPv4-compat | No      |  Yes    |  N/A    | IPv6/4 |  E6  |  E4  | RL

    '
- title: '------------+---------+---------+---------+--------+------+------+------'
  contents:
  - '------------+---------+---------+---------+--------+------+------+------

    '
- title: IPv4-compat | No      |  No     |  Yes    | IPv6   |  E6  |  N/A | RL
  contents:
  - 'IPv4-compat | No      |  No     |  Yes    | IPv6   |  E6  |  N/A | RL

    '
- title: '------------+---------+---------+---------+--------+------+------+------'
  contents:
  - '------------+---------+---------+---------+--------+------+------+------

    '
- title: IPv4-compat | No      |  No     |  No     | UNRCH  |  N/A |  N/A | N/A
  contents:
  - 'IPv4-compat | No      |  No     |  No     | UNRCH  |  N/A |  N/A | N/A

    '
- title: '------------+---------+---------+---------+--------+------+------+------'
  contents:
  - '------------+---------+---------+---------+--------+------+------+------

    '
- title: IPv6-only   | Yes     |  N/A    |  N/A    | IPv6   |  E6  |  N/A | EL
  contents:
  - 'IPv6-only   | Yes     |  N/A    |  N/A    | IPv6   |  E6  |  N/A | EL

    '
- title: '------------+---------+---------+---------+--------+------+------+------'
  contents:
  - '------------+---------+---------+---------+--------+------+------+------

    '
- title: IPv6-only   | No      |  N/A    |  Yes    | IPv6   |  E6  |  N/A | RL
  contents:
  - 'IPv6-only   | No      |  N/A    |  Yes    | IPv6   |  E6  |  N/A | RL

    '
- title: '------------+---------+---------+---------+--------+------+------+------'
  contents:
  - '------------+---------+---------+---------+--------+------+------+------

    '
- title: IPv6-only   | No      |  Yes    |  No     | IPv6/4 |  E6  |  T4  | RL
  contents:
  - 'IPv6-only   | No      |  Yes    |  No     | IPv6/4 |  E6  |  T4  | RL

    '
- title: '------------+---------+---------+---------+--------+------+------+------'
  contents:
  - '------------+---------+---------+---------+--------+------+------+------

    '
- title: IPv6-only   | No      |  No     |  No     | UNRCH  |  N/A |  N/A | N/A
  contents:
  - 'IPv6-only   | No      |  No     |  No     | UNRCH  |  N/A |  N/A | N/A

    '
- title: '------------+---------+---------+---------+--------+------+------+------'
  contents:
  - "------------+---------+---------+---------+--------+------+------+------\n  \
    \      Key to Abbreviations\n        --------------------\n        N/A:    Not\
    \ applicable or does not matter.\n        E6:     IPv6 address of end node.\n\
    \        E4:     IPv4 address of end node (low-order 32-bits of\n            \
    \    IPv4-compatible address).\n        EL:     Datalink address of end node.\n\
    \        T4:     IPv4 address of the tunnel endpoint.\n        R6:     IPv6 address\
    \ of router.\n        R4:     IPv4 address of router.\n        RL:     Datalink\
    \ address of router.\n        IPv4:   IPv4 packet format.\n        IPv6:   IPv6\
    \ packet format.\n        IPv6/4: IPv6 encapsulated in IPv4 packet format.\n \
    \       UNRCH:  Destination is unreachable.  Don't send a packet.\n"
- title: 4.4.1  On/Off Link Determination
  contents:
  - "4.4.1  On/Off Link Determination\n   Part of the process of determining what\
    \ packet format to use includes\n   determining whether a destination is located\
    \ on an attached link or\n   not.  IPv4 and IPv6 employ different mechanisms.\
    \  IPv4 uses an\n   algorithm in which the destination address and the interface\
    \ address\n   are both logically ANDed with the netmask of the interface and then\n\
    \   compared.  If the resulting two values match, then the destination is\n  \
    \ located on-link.  This algorithm is discussed in more detail in\n   Section\
    \ 3.3.1.1 of the host requirements specification [10].  IPv6\n   uses the neighbor\
    \ discovery algorithm described in \"Neighbor\n   Discovery for IP Version 6\"\
    \ [7].\n   IPv6/IPv4 nodes need to use both methods:\n   -    If a destination\
    \ is an IPv4 address, then the on/off link\n        determination is made by comparison\
    \ with the netmask, as\n        described in RFC 1122 section 3.3.1.1.\n   - \
    \   If a destination is represented by an IPv4-compatible IPv6\n        address\
    \ (prefix 0:0:0:0:0:0), the decision is made using the\n        IPv4 netmask comparison\
    \ algorithm using the low-order 32-bits\n        (IPv4 address part) of the destination\
    \ address.\n  -     If the destination is represented by an IPv6-only address\n\
    \        (prefix other than 0:0:0:0:0:0), the on/off link determination\n    \
    \    is made using the IPv6 neighbor discovery mechanism.\n"
- title: 5. Acknowledgements
  contents:
  - "5. Acknowledgements\n   We would like to thank the members of the IPng working\
    \ group and the\n   IPng transition working group for their many contributions\
    \ and\n   extensive review of this document.  Special thanks to Jim Bound, Ross\n\
    \   Callon, and Bob Hinden for many helpful suggestions and to John Moy\n   for\
    \ suggesting the IPv4 \"anycast address\" default tunnel technique.\n"
- title: 6.  Security Considerations
  contents:
  - "6.  Security Considerations\n   Security issues are not discussed in this memo.\n"
- title: 7. Authors' Addresses
  contents:
  - "7. Authors' Addresses\n   Robert E. Gilligan\n   Sun Microsystems, Inc.\n   2550\
    \ Garcia Ave.\n   Mailstop UMTV 05-44\n   Mountain View, California 94043\n  \
    \ Phone: 415-336-1012\n   Fax:   415-336-6015\n   EMail: Bob.Gilligan@Eng.Sun.COM\n\
    \   Erik Nordmark\n   Sun Microsystems, Inc.\n   2550 Garcia Ave.\n   Mailstop\
    \ UMTV 05-44\n   Mountain View, California 94043\n   Phone: 415-336-2788\n   Fax:\
    \   415-336-6015\n   EMail: Erik.Nordmark@Eng.Sun.COM\n"
- title: 7. References
  contents:
  - "7. References\n   [1] Croft, W., and J. Gilmore, \"Bootstrap Protocol\", RFC\
    \ 951,\n       September 1985.\n   [2] Droms, R., \"Dynamic Host Configuration\
    \ Protocol\", RFC 1541.\n       October 1993.\n   [3] Bound, J., \"Dynamic Host\
    \ Configuration Protocol for IPv6 for IPv6\n       (DHCPv6)\", Work in Progress,\
    \ November 1995.\n   [4] Deering, S., and R. Hinden, \"Internet Protocol, Version\
    \ 6 (IPv6)\n       Specification\", RFC 1883, December 1995.\n   [5] Thomson,\
    \ S., and T. Nartan, \"IPv6 Stateless Address\n       Autoconfiguration, Work\
    \ in Progress, December 1995.\n   [6] Thomson, S., and C. Huitema. \"DNS Extensions\
    \ to support IP\n       version 6\", RFC 1886, December 1995.\n   [7] Nartan,\
    \ T., Nordmark, E., and W. Simpson, \"Neighbor Discovery for\n       IP Version\
    \ 6 (IPv6)\", Work in Progress, November 1995.\n   [8] Mogul, J., and S. Deering,\
    \ \"Path MTU Discovery\", RFC 1191,\n       November 1990.\n   [9] Finlayson,\
    \ R., Mann, T., Mogul, J., and M. Theimer, \"Reverse\n       Address Resolution\
    \ Protocol\", RFC 903, June 1984.\n  [10] Braden, R., \"Requirements for Internet\
    \ Hosts - Communication\n       Layers\", STD 3, RFC 1122, October 1989.\n  [11]\
    \ Kent, C., and J. Mogul, \"Fragmentation Considered Harmful\".  In\n       Proc.\
    \  SIGCOMM '87 Workshop on Frontiers in Computer\n       Communications Technology.\
    \  August 1987.\n"
