- title: __initial_text__
  contents:
  - "                          A Thinwire Protocol\n                   for connecting\
    \ personal computers\n                            to the INTERNET\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This RFC focuses discussion on the particular problems\
    \ in the\n   ARPA-Internet of low speed network interconnection with personal\n\
    \   computers, and possible methods of solution.  None of the proposed\n   solutions\
    \ in this document are intended as standards for the\n   ARPA-Internet.  Rather,\
    \ it is hoped that a general consensus will\n   emerge as to the appropriate solution\
    \ to the problems, leading\n   eventually to the adoption of standards.  Distribution\
    \ of this memo\n   unlimited.\n"
- title: What is the Problem Anyway ?
  contents:
  - "What is the Problem Anyway ?\n   As we connect workstations and personal computers\
    \ to the INTERNET,\n   many of the cost/speed communication tradeoffs change.\
    \  This has made\n   us reconsider the way we juggle the protocol and hardware\
    \ design\n   tradeoffs.  With substantial computing power available in the $3--10K\n\
    \   range, it is feasible to locate computers at their point of use,\n   including\
    \ in buildings, in our homes, and other places remote from\n   the existing high\
    \ speed connections.  Dedicated 56k baud lines are\n   costly, have limited availability,\
    \ and long lead time for\n   installation.  High speed LAN's are not an applicable\
    \ interconnection\n   solution.  These two facts ensure that readily available\
    \ 1200 / 2400\n   baud phone modems over dialed or leased telephone lines will\
    \ be an\n   important part of the interconnection scheme in the near future.\n\
    \   This paper will consider some of the problems and possibilities\n   involved\
    \ with using a \"thin\" (less than 9600 baud) data path.  A trio\n   of \"THINWIRE\"\
    \  protocols for connecting a personal computer to the\n   INTERNET are presented\
    \ for discussion.\n   Although the cost and flexibility of telephone modems is\
    \ very\n   attractive, their low speed produces some major problems.  As an\n\
    \   example, a minimum TCP/IP Telnet packet (one character) is 41 bytes\n   long.\
    \  At 1200 baud, the transmission time for such a packet would be\n   around 0.3\
    \ seconds.  This is equivalent to using a 30 baud line for\n   single character\
    \ transmission.  (Throughout the paper, the assumption\n   is made that the transmission\
    \ speed is limited only by the speed of\n   the communication line.  We also assume\
    \ that the line will act as a\n   synchronous link when calculating speed.  In\
    \ reality, with interrupt,\n   computational, and framing overhead, the times\
    \ could be 10-50%\n   worse.)\n   In many cases, local echo and line editing can\
    \ allow acceptable\n"
- title: RFC 914                                                   September 1984
  contents:
  - 'RFC 914                                                   September 1984

    '
- title: Thinwire Protocol
  contents:
  - "Thinwire Protocol\n   Telnet behavior, but many applications will work only with\
    \ character\n   at a time transmission.  In addition, multiple data streams can\
    \ be\n   very useful for fully taking advantage of the personal\n   computer/Internet\
    \ link.  Thus this proposal.\n   There are several forms that a solution to this\
    \ problem can take.\n   Three of these are listed below, followed by descriptions\
    \ of possible\n   solutions of each form.\n   o    As a non-solution, one can\
    \ learn to live with the slow\n        communication (possibly a reasonable thing\
    \ to do for background\n        file transfer and one-time inquiries to time,\
    \ date, or\n        quote-of-the-day servers).\n   o    Using TCP/IP, one can\
    \ intercept the link level transmissions,\n        and try various kinds of compression\
    \ algorithms.  This provides\n        for a symmetrical structure on either side\
    \ of the \"Thinwire\".\n   o    One could build an \"asymmetrical\" gateway which\
    \ takes some of\n        the transport and network communication overhead away\
    \ from both\n        the serial link and the personal computer.  The object would\
    \ be\n        to make the PC do the local work, and to make the\n        interconnection\
    \ with the extended network a benefit to the PC\n        and not a drain on the\
    \ facilities of the PC.\n   The first form has the advantage of simplicity and\
    \ ease of\n   implementation. The disadvantages have been discussed above.  The\n\
    \   second form, compression at link level, can be exploited in two ways.\n  \
    \    Thinwire I is a simple robust compressor, which will reduce the 41\n    \
    \  byte minimum TCP/IP Telnet packets to a series of 17 byte update\n      packets.\
    \  This would improve the effective baud rate from 30 baud\n      to 70 baud over\
    \ a 1200 baud line (for single character packets).\n      Thinwire II uses a considerably\
    \ more complex technique, and takes\n      advantage of the storage and processing\
    \ power on either side of\n      the thinwire link.  Thinwire II will compress\
    \ packets from\n      multiple TCP/IP connections from 41 bytes down to 13 bytes.\
    \  The\n      increased communication rate is 95 (effective) baud for single\n\
    \      character packets.\n   The third form balances the characteristics of the\
    \ personal computer,\n   the communications line, the gateway, and the Internet\
    \ protocols to\n   optimize the utility of the communications and the workstation\n\
    \   itself.  Instead of running full transport and internet layers on the\n  \
    \ PC, the PC and the gateway manage a single reliable stream,\n   multiplexing\
    \ data on this stream with control requests.  Without the\n   interneting and\
    \ flow control structures traveling over the\n   communications line on a per/packet\
    \ basis, the data flow can be\n"
- title: RFC 914                                                   September 1984
  contents:
  - 'RFC 914                                                   September 1984

    '
- title: Thinwire Protocol
  contents:
  - "Thinwire Protocol\n   compressed a great deal.  As there is some switching overhead,\
    \ and a\n   reliable link level protocol is needed on the serial line, the\n \
    \  average effective baud rate would be in the 900 baud range.\n   Each of these\
    \ Thinwire possibilities will be explored in detail.\n"
- title: Thinwire I
  contents:
  - "Thinwire I\n   The simplest technique for the compression of packets which have\n\
    \   similar headers is for both the transmitting and receiving host to\n   store\
    \ the most recent packet and transmit just the changes from one\n   packet to\
    \ the next.  The updated information is transmitted by\n   sending a packet including\
    \ the updated information along with a\n   description of where the information\
    \ should be placed.  A series of\n   descriptor-data blocks would make up the\
    \ update packet.  The\n   descriptor consists of the offset from the last byte\
    \ changed to the\n   start of the data to be changed and a count of the number\
    \ of data\n   bytes to be substituted into the old template.  The descriptor is\
    \ one\n   byte long, with two four bit fields; offsets and counts of up to 15\n\
    \   bytes can be described. In the most pathological case the descriptor\n   adds\
    \ an extra byte for every 15 bytes (or a 6% expansion).\n   An example of Thinwire\
    \ I in action is shown in Appendix A.  A\n   sequence of two single character\
    \ TCP/IP Telnet packets is shown.  The\n   \"update\" packet which would actually\
    \ be transmitted is shown\n   following them.  Each Telnet packet is 41 bytes\
    \ long; the typical\n   update is 17 bytes.  This technique is a useful improvement\
    \ over\n   sending entire packets.  It is also computationally simple.  It\n \
    \  suffers from two problems: the compression is modest, and, if there\n   is\
    \ more than one class of packets being handled, the assumption of\n   common header\
    \ information breaks down, causing the compression of\n   each class to suffer.\n"
- title: Thinwire II
  contents:
  - "Thinwire II\n   Both of the problems described above suggest that a more\n  \
    \ computationally complex protocol may be appropriate.  Any major\n   improvement\
    \ in data compression must depend on knowledge of the\n   protocols being used.\
    \  Thinwire II uses this knowledge to accomplish\n   two things.  First, the packets\
    \ are sorted into classes.  The packets\n   from each TCP connection using the\
    \ thinwire link, would, because of\n   their header similarities, make up a class\
    \ of packets.  Recognizing\n   these classes and sorting by them is called \"\
    matching templates\".\n   Second, knowledge of the protocols is used to compress\
    \ the updates.\n   A bitfield indicating which fields in the header have changed,\n\
    \   followed only by the changed fields, is much shorter than the general\n  \
    \ form of change notices.  Simple arithmetic is allowed, so 32 bit\n"
- title: RFC 914                                                   September 1984
  contents:
  - 'RFC 914                                                   September 1984

    '
- title: Thinwire Protocol
  contents:
  - "Thinwire Protocol\n   fields can often be updated in 8 or 16 bits.  By using\
    \ the sorting,\n   protocol-specific updating, Thinwire II provides significant\n\
    \   compression.\n   A typical transaction is described in Appendix B.  The \"\
    template\n   matching\" is based on the unchanging fields in each class of packet.\n\
    \   A TCP/IP packet would match on the following fields: network type\n   field(IP),\
    \ version, type of service, protocol(TCP), and source and\n   destination address\
    \ and port.  Note that the 41 bytes have been\n   reduced to 13 bytes.  An additional\
    \ advantage is that  multiple\n   classes of packets can be transported across\
    \ the same line without\n   affecting the compression of each other, just by matching\
    \ and storing\n   multiple templates.\n   Some of the implications of this system\
    \ are:\n      o    The necessity of saving several templates (one for each\n \
    \          TCP/IP connection ) means that there will be a relatively\n       \
    \    large memory requirement.  This requirement for current\n           personal\
    \ computers is reasonable.  In addition, the gateway\n           must keep tables\
    \ for several connections at a time.\n      o    The Thinwire links are slow (that's\
    \ why we call them thin);\n           much slower than normal disk access.  There\
    \ is no reason that\n           inactive templates cannot be swapped out to disk\
    \ and\n           retrieved when needed if memory is limited.  (Note that as\n\
    \           memory density increases, this is less and less of a\n           problem.)\n\
    \      o    There is state information in the connections.  If the two\n     \
    \      sides get out of synchronization with each other, data flow\n         \
    \  stops.  This means that some method of error detection and\n           recovery\
    \ must be provided.\n      o    To minimize the problem described above, the protocol\
    \ used on\n           the serial line must be reliable.  See Appendix D for details\n\
    \           of SLIP, Serial Line Interface Protocol, as an example of\n      \
    \     such a protocol.  There must also be periodic\n           resynchronization.\
    \  (For example, every Nth packet would be\n           transmitted in full).\n\
    \      o    The asynchronous link is not, by its nature, a packet\n          \
    \ oriented system; a packet structure will need to be layered\n           on the\
    \ character at a time transfer.  However, if the\n           protocol layer below\
    \ thinwire (SLIP) can be trusted, the\n           formation of packets is a simple\
    \ matter.\n      o    Thinwire II will need to be enhanced for each new protocol\n"
- title: RFC 914                                                   September 1984
  contents:
  - 'RFC 914                                                   September 1984

    '
- title: Thinwire Protocol
  contents:
  - "Thinwire Protocol\n           (TCP, UDP, TP4) it is called upon to service. \
    \ Any packet\n           type not recognized by the Thinwire connection will be\n\
    \           transmitted in full.\n   For maintaining full network service, Thinwire\
    \ II or a close variant\n   seems to be the solution.\n"
- title: Thinwire III
  contents:
  - "Thinwire III\n   When transmissions at the local network (link) level are not\n\
    \   required, if only the available services are desired, then a solution\n  \
    \ based on Thinwire III may be appropriate.  A star network with a\n   gateway\
    \ in the center serving as the connection between a number of\n   Personal Computers\
    \ and the Internet is the key of Thinwire III.\n   Rather than providing connections\
    \ at the network/link level, Thinwire\n   III assumes that there is a reliable\
    \ serial link (SLIP or equivalent)\n   beneath it and that the workstation/personal\
    \ computer has better\n   things to do than manage TCP state tables, timeouts,\
    \ etc.  It also\n   assumes that the gateway supporting the Thinwire III connections\
    \ is\n   powerful enough to run many TCP connections and several SLIP's at the\n\
    \   same time.  The gateway fills in for the limitations of the\n   communications\
    \ line and the personal computer.  It provides a gateway\n   to the INTERNET,\
    \ managing the transport and network functions,\n   providing both reliable stream\
    \ and datagram service.\n   In Thinwire III, the gateway starts an interpreter\
    \ for each SLIP\n   connection from a personal computer.  The gateway will open\
    \ TCP, UDP,\n   and later TP4 connections on the request of the personal computer.\n\
    \   Acting as the agent for the personal computer, it will manage the\n   remote\
    \ negotiations and the data flow to and from the personal\n   computer.  Multiple\
    \ connections can be opened, with inline logical\n   switches in the reliable\
    \ data flow indicating which connection the\n   data is destined for.  Additional\
    \ escaped sequences will send error\n   and informational data between the two\
    \ Thinwire III communicators.\n   This protocol is not symmetric.  The gateway\
    \ will open connections to\n   the INTERNET world as an agent for the personal\
    \ computer, but the\n   gateway will not be able to open inbound connections to\
    \ the personal\n   computer, as the personal computer is perceived as a stub host.\
    \  The\n   personal computer may however passively open connections on the\n \
    \  gateway to act as a server.  Extended control sequences are specified\n   to\
    \ handle the multiple connection negotiation that this server\n   ability will\
    \ entail.\n   This protocol seems to ignore the problem of flow control. Our\n\
    \   thought is that the processing on either side of the communication\n   link\
    \ will be much speedier than the link itself.  The buffering for\n   the communication\
    \ line and the user process blocking for this will\n"
- title: RFC 914                                                   September 1984
  contents:
  - 'RFC 914                                                   September 1984

    '
- title: Thinwire Protocol
  contents:
  - "Thinwire Protocol\n   provide most of the flow control.  For the rare instances\
    \ that this\n   is not sufficient, there are control messages to delay the flow\
    \ to a\n   port or all data flow.\n   A tentative specification for Thinwire III\
    \ is attached as Appendix C.\n"
- title: The authors acknowledge the shoulders upon which they stand, and
  contents:
  - 'The authors acknowledge the shoulders upon which they stand, and

    '
- title: apologize for the toes they step on.  Ongoing work is being done by Eric
  contents:
  - 'apologize for the toes they step on.  Ongoing work is being done by Eric

    '
- title: Thayer, Guru Parulkar, and John Jaggers.  Special thanks are extended to
  contents:
  - 'Thayer, Guru Parulkar, and John Jaggers.  Special thanks are extended to

    '
- title: Peter vonGlahn, Jon Postel and Helen Delp for their helpful comments on
  contents:
  - 'Peter vonGlahn, Jon Postel and Helen Delp for their helpful comments on

    '
- title: earlier drafts.  Responses will be greatly appreciated at the following
  contents:
  - 'earlier drafts.  Responses will be greatly appreciated at the following

    '
- title: 'addresses:'
  contents:
  - "addresses:\n   Dave Farber <Farber@udel-ee>\n   Gary Delp <Delp@udel-ee>\n  \
    \ Tom Conte <Conte@udel-ee>\n"
- title: RFC 914                                                   September 1984
  contents:
  - 'RFC 914                                                   September 1984

    '
- title: Thinwire Protocol
  contents:
  - 'Thinwire Protocol

    '
- title: Appendix A -- Example of Thinwire I Compression
  contents:
  - "Appendix A -- Example of Thinwire I Compression\n   Here is an example of how\
    \ Thinwire I would operate in a common\n   situation.  The connection is a TCP/IP\
    \ Telnet connection.  The first\n   TCP/IP Telnet packet is on the next page;\
    \ it simulates the typing of\n   the character \"a\".  The second packet would\
    \ be produced by typing\n   \"d\"; it is shown on the following page.  The compressed\
    \ version is on\n   the third page following.\n   [NOTE: The checksums pictured\
    \ have not been calculated.  Binary in\n   MSB to LSB format]\n"
- title: RFC 914                                                   September 1984
  contents:
  - 'RFC 914                                                   September 1984

    '
- title: Thinwire Protocol
  contents:
  - "Thinwire Protocol\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1\n"
- title: IP     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - 'IP     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    '
- title: header:|Version|  IHL  |Type of Service|          Total Length         |
  contents:
  - "header:|Version|  IHL  |Type of Service|          Total Length         |\n  \
    \     |0 1 0 0|0 1 0 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0 0 0 1 0 1 1 0 0|\n"
- title: P      |   4   |   5   |       0       |               41              |
  contents:
  - 'P      |   4   |   5   |       0       |               41              |

    '
- title: a      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - 'a      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    '
- title: c      |       Identification          |Flags|      Fragment Offset    |
  contents:
  - 'c      |       Identification          |Flags|      Fragment Offset    |

    '
- title: k      |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1|0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0|
  contents:
  - 'k      |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1|0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0|

    '
- title: e      |                1              |  0  |            0            |
  contents:
  - 'e      |                1              |  0  |            0            |

    '
- title: t      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - 't      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    '
- title: '-      |  Time to live |   Protocol    |       Header Checksum         |'
  contents:
  - '-      |  Time to live |   Protocol    |       Header Checksum         |

    '
- title: 1      |0 1 1 0 0 1 0 1|0 0 0 0 0 1 1 0|0 1 1 1 0 1 1 1 0 0 0 1 0 1 0 0|
  contents:
  - "1      |0 1 1 0 0 1 0 1|0 0 0 0 0 1 1 0|0 1 1 1 0 1 1 1 0 0 0 1 0 1 0 0|\n  \
    \     |      101      |       6       |             nnn               |\n    \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      \
    \ |                     Source Address                            |\n       |1\
    \ 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 0 0 1 1 1 0 0 0 1 0 1 0 0|\n       |   \
    \ 192.       |       5.      |     39.       |      20       |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |                   Destination Address                         |\n  \
    \     |0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0|\n    \
    \   |     10.       |       2.      |      0.       |      52       |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n"
- title: TCP    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - 'TCP    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    '
- title: header:|         Source Port           |       Destination Port        |
  contents:
  - "header:|         Source Port           |       Destination Port        |\n  \
    \     |0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1|0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 1|\n    \
    \   |             1025              |               27              |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                        Sequence Number                        |\n       |0 0\
    \ 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 1 0 0|\n       |     \
    \                         300                              |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |                     Acknowledgement Number                    |\n  \
    \     |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 0 0|\n    \
    \   |                              100                              |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |offset\
    \ | Reserved  |U A P R S F|            Window             |\n       |0 1 0 1|0\
    \ 0 0 0 0 0|0 1 0 0 0 0|0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0|\n       |   5   |   \
    \  0     |     16    |             512               |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |           Checksum            |         Urgent Pointer        |\n  \
    \     |0 0 0 0 0 1 0 0 1 0 1 1 0 0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n    \
    \   |             nnn               |               0               |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \                            Data                               |\n       |0 1\
    \ 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n       |     \
    \   \"a\"                                                    |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: RFC 914                                                   September 1984
  contents:
  - 'RFC 914                                                   September 1984

    '
- title: Thinwire Protocol
  contents:
  - "Thinwire Protocol\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4\
    \ 5 6 7 8 9 0 1\n"
- title: IP     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - 'IP     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    '
- title: header:|Version|  IHL  |Type of Service|          Total Length         |
  contents:
  - "header:|Version|  IHL  |Type of Service|          Total Length         |\n  \
    \     |0 1 0 0|0 1 0 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0 0 0 1 0 1 1 0 0|\n    \
    \   |   4   |   5   |       0       |               41              |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: P      |       Identification*         |Flags|      Fragment Offset    |
  contents:
  - 'P      |       Identification*         |Flags|      Fragment Offset    |

    '
- title: a      |0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0|0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0|
  contents:
  - 'a      |0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0|0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0|

    '
- title: c      |                2              |  0  |            0            |
  contents:
  - 'c      |                2              |  0  |            0            |

    '
- title: k      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - 'k      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    '
- title: e      |  Time to live*|   Protocol    |       Header Checksum*        |
  contents:
  - 'e      |  Time to live*|   Protocol    |       Header Checksum*        |

    '
- title: t      |0 1 1 0 0 1 1 0|0 0 0 0 0 1 1 0|0 1 1 1 0 1 1 1 0 0 0 1 0 1 0 0|
  contents:
  - 't      |0 1 1 0 0 1 1 0|0 0 0 0 0 1 1 0|0 1 1 1 0 1 1 1 0 0 0 1 0 1 0 0|

    '
- title: '-      |      102      |       6       |             nnn               |'
  contents:
  - '-      |      102      |       6       |             nnn               |

    '
- title: 2      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - "2      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n  \
    \     |                     Source Address                            |\n    \
    \   |1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 0 1 0 0 1 1 1 0 0 0 1 0 1 0 0|\n      \
    \ |    192.       |       5.      |     39.       |      20       |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |                   Destination Address                         |\n  \
    \     |0 0 0 0 1 0 1 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 1 0 1 0|\n    \
    \   |     10.       |       2.      |      0.       |      52       |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n        0\
    \ 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n"
- title: TCP    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - 'TCP    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    '
- title: header:|         Source Port           |       Destination Port        |
  contents:
  - "header:|         Source Port           |       Destination Port        |\n  \
    \     |0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 1|0 0 0 0 0 0 0 0 0 0 0 1 1 0 1 1|\n    \
    \   |             1025              |               27              |\n"
- title: '* ''s   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+'
  contents:
  - '* ''s   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    '
- title: show   |                        Sequence Number*                       |
  contents:
  - 'show   |                        Sequence Number*                       |

    '
- title: changed|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 1 0 1|
  contents:
  - 'changed|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 1 1 0 1|

    '
- title: fields |                              301                              |
  contents:
  - "fields |                              301                              |\n  \
    \     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n    \
    \   |                     Acknowledgement Number*                   |\n      \
    \ |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 1 0 0 1 0 1|\n       |\
    \                              101                              |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |offset | Reserved  |U A P R S F|            Window             |\n  \
    \     |0 1 0 1|0 0 0 0 0 0|0 1 0 0 0 0|0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0|\n    \
    \   |   5   |     0     |     16    |             512               |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \           Checksum*           |         Urgent Pointer        |\n       |0 0\
    \ 0 0 0 1 0 0 1 0 1 1 0 0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n       |     \
    \        nnn               |               0               |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \       |                            Data*                              |\n  \
    \     |0 1 1 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n    \
    \   |        \"d\"                                                    |\n    \
    \   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: RFC 914                                                   September 1984
  contents:
  - 'RFC 914                                                   September 1984

    '
- title: Thinwire Protocol
  contents:
  - "Thinwire Protocol\n   The Thinwire Driver finds the template (which is the previous\
    \ packet\n   sent), compares the template to the packet and creates a change\n\
    \   message (field names of change record data have been added for\n   comparison):\n\
    \       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n    \
    \  +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      |Descriptor\
    \ byte|   Data:       |Descriptor byte|  Data:        |\n      |offset |length\
    \ | Identification|offset |length |  Time to live |\n      |0 0 1 0|0 0 0 1|0\
    \ 0 0 0 0 0 1 0|0 0 1 0|0 0 0 1|0 1 1 1 0 1 1 0|\n      |   2   |   1   |    \
    \  2        |   2   |   1   |     102       |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |Descriptor byte|   Data:                       |Descriptor byte|\n   \
    \   | offset| length|         Header Checksum       |offset |length |\n      |0\
    \ 0 1 0|0 0 1 0|1 1 1 1 0 0 1 0 1 0 1 1 0 1 0 0|1 1 1 1|0 0 1 0|\n      |    2\
    \  |   2   |              nn               |  15   |   2   |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |   Data:       |Descriptor byte|   Data:       |Descriptor byte|\n   \
    \   |   Seq Number  |offset |length |   Ack Number  |offset |length |\n      |0\
    \ 0 1 0 1 1 0 1|0 0 1 1|0 0 0 1|0 1 1 0 0 1 0 1|0 1 1 1|0 0 1 0|\n      |    \
    \  301      |   3   |   1   |      101      |   7   |   2   |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |   Data:                       |Descriptor byte|   Data:       |\n   \
    \   |       -- TCP Checksum --      |offset |length |     data      |\n      |0\
    \ 0 0 0 0 1 0 0 1 0 1 1 0 0 0 0|0 0 1 0|0 0 0 1|0 1 1 0 0 1 0 0|\n      |    \
    \         nn                |   2   |   1   |     \"d\"       |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      |Descriptor byte|\n      |offset |length |\n      |0 0 0 0|0 0 0 0|  the\
    \ 0 0 offset/length record ends the update.\n      |   0   |   0   |\n      +-+-+-+-+-+-+-+-+\n\
    \   Thinwire I then sends this message over the line where the previous\n   packet\
    \ is updated to form the new packet.  Note: One can see that a\n   series of null\
    \ descriptor bytes will reset the connection.\n"
- title: RFC 914                                                   September 1984
  contents:
  - 'RFC 914                                                   September 1984

    '
- title: Thinwire Protocol
  contents:
  - 'Thinwire Protocol

    '
- title: Appendix B -- Examples of Thinwire II Compression
  contents:
  - "Appendix B -- Examples of Thinwire II Compression\n   This Appendix provides\
    \ an example of how the Thinwire II would\n   operate in a common situation. \
    \ The same original packets are used as\n   in Appendix A, so only the updates\
    \ are shown.\n   As the later field definitions depend on the contents of earlier\n\
    \   fields, a field by field analysis of the update packets will be\n   useful.\n\
    \                    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\n       \
    \            +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n      Thinwire\
    \ II  |U|L|Template no| Len of change | Type of Packet|\n       minimum     |0|0|0\
    \ 0 0 1 0 1|0 0 0 1 1 0 0 1|0 0 0 0 0 0 0 1|\n       header:     |N N|     5 \
    \    |          41   |     TCP/IP    |\n                   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \      The first bit is the UPDATE bit. If it is a 0 this packet\n      describes\
    \ a new template, and the entire new packet is included,\n      following the\
    \ header.  If there was a previous template with the\n      same number, it will\
    \ be cleared and replaced by the new template.\n      If the UPDATE bit is a 1,\
    \ then this packet should be used to\n      update the template with the number\
    \ given in the template number\n      field.\n      The second bit is the LONG\
    \ bit. If it is a 1 it indicates a LONG\n      packet.  This means that the update\
    \ length field will be 16 bits\n      instead of 8 bits.\n      The remaining\
    \ 6 bits in the first byte indicate the template\n      number that this packet\
    \ is an update to.\n      The template number is followed by 1 or 2 bytes (depending\
    \ on the\n      value of the LONG bit) which give the length of the packet. This\n\
    \      is the number of data bytes following the variable length header.\n   \
    \   If the UPDATE bit is 0 on this packet, the next byte will be a\n      flag\
    \ telling what type of packet the sender thinks this packet is.\n      The flag\
    \ will be saved by the receiver to interpret the update\n      packets.  Type\
    \ 0 is for unknown types. If the type 0 flag is set,\n      there will be no updates\
    \ to this template number.  Type 1 is\n      TCP/IP; the method of updating will\
    \ be described below.  Type 2 is\n      UDP/IP; the method of update is not described\
    \ at this time.\n   At this time we have enough information to encode packet 1\
    \ of the\n   example. Assuming for the moment that this is the first packet for\n\
    \   this connection, the UPDATE bit would be set to 0.  As the packet has\n  \
    \ a length of 41 and so can be described in 8 bits, the LONG bit would\n   be\
    \ set to 0.  A template number not in use (or the oldest in use\n"
- title: RFC 914                                                   September 1984
  contents:
  - 'RFC 914                                                   September 1984

    '
- title: Thinwire Protocol
  contents:
  - "Thinwire Protocol\n   template number) would be assigned to this packet.  The\
    \ number 5 is\n   illustrated.  The Length of Packet would be given as 41, and\
    \ the Type\n   Flag set to TCP/IP (1).  The 41 bytes of the packet would follow.\n\
    \   The transmission of packet 2 requires the specification of Type 1\n   (TCP/IP)\
    \ updating.  There are portions of the packets which will\n   always be the same;\
    \ these are described in the body of the paper, and\n   are used to match the\
    \ template.  These do not need to be transmitted\n   for an update.  There are\
    \ portions of the packet which will always\n   (well almost always) change.  These\
    \ are the IP Header checksum, the\n   IP Identification number, and the TCP checksum.\
    \  These are\n   transmitted, in that order, with each template update immediately\n\
    \   after the packet length byte/bytes.  Following the invariant portion\n   of\
    \ the header are updates to the fields which change some of the\n   time.  Which\
    \ fields are different is indicated with a bitfield\n   describing the changes.\n\
    \   The Bitfield is used to indicate which fields (of those that may stay\n  \
    \ the same) have changed.  The technique for updating the field varies\n   with\
    \ the field description.  The specifications for TCP/IP are shown\n   in Table\
    \ B-1.\n           0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
- title: Thin-  |U|L|Template no| Len of change | Type of Packet|
  contents:
  - 'Thin-  |U|L|Template no| Len of change | Type of Packet|

    '
- title: wire II|0|0|0 0 0 1 0 1|0 0 0 1 1 0 0 1|0 0 0 0 0 0 0 1|
  contents:
  - 'wire II|0|0|0 0 0 1 0 1|0 0 0 1 1 0 0 1|0 0 0 0 0 0 0 1|

    '
- title: header:|N N|     5     |          41   |     TCP/IP    |
  contents:
  - "header:|N N|     5     |          41   |     TCP/IP    |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n"
- title: IP     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - 'IP     +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    '
- title: header:|Version|  IHL  |Type of Service|          Total Length         |
  contents:
  - "header:|Version|  IHL  |Type of Service|          Total Length         |\n  \
    \     |0 1 0 0|0 1 0 1|0 0 0 0 0 0 0 0|0 0 0 0 0 0 0 0 0 0 1 0 1 1 0 0|\n"
- title: P      |   4   |   5   |       0       |               44              |
  contents:
  - 'P      |   4   |   5   |       0       |               44              |

    '
- title: a      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
  contents:
  - 'a      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+

    '
- title: c      |       Identification          |Flags|      Fragment Offset    |
  contents:
  - 'c      |       Identification          |Flags|      Fragment Offset    |

    '
- title: k      |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1|0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0|
  contents:
  - 'k      |0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1|0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0|

    '
- title: e      |                1              |  0  |            0            |
  contents:
  - 'e      |                1              |  0  |            0            |

    '
- title: t      +~+~+~+~+~.~+~+~+~+~+~+~+~+~+~+.+~+~+~+~+~+~+~+~+~+~+~.~+~+~+~+~+
  contents:
  - 't      +~+~+~+~+~.~+~+~+~+~+~+~+~+~+~+.+~+~+~+~+~+~+~+~+~+~+~.~+~+~+~+~+

    '
- title: '-                .                    .                      .'
  contents:
  - '-                .                    .                      .

    '
- title: 1                .                    .                      .
  contents:
  - "1                .                    .                      .\n       +~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+~+\n\
    \       |           Checksum            |         Urgent Pointer        |\n  \
    \     |0 0 0 0 0 1 0 0 1 0 1 1 0 0 0 0|0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0|\n    \
    \   |             nnn               |               0               |\n      \
    \ +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |\
    \    Data       |\n       |0 1 1 0 0 0 0 1|\n       |        \"a\"    |\n    \
    \   +-+-+-+-+-+-+-+-+\n"
- title: RFC 914                                                   September 1984
  contents:
  - 'RFC 914                                                   September 1984

    '
- title: Thinwire Protocol
  contents:
  - "Thinwire Protocol\n   The changed field update information is added to the update\
    \ header in\n   the order that the bits appear in the field.  That is, if both\
    \ the IP\n   packet length bit and the Time to Live  bit are set, the 2 new bytes\n\
    \   of the IP Packet length will precede the 1 new byte of the Time to\n   Live\
    \ field.\n   The update for packet 2 is shown below. Note that this is an update\n\
    \   to template 5, the length of update is 8 bits with a value of 1.  The\n  \
    \ new checksums and IP Identification Number are included, and the\n   flags are\
    \ set to indicate changes to the following fields: Time to\n   Live, Add 8 bits\
    \ to Sequence and Acknowledgement Numbers.  The new\n   data is one byte following\
    \ the header.\n   Thinwire II would send this message over the line where it would\
    \ be\n   reassembled into the correct packet.\n   Note: For purposes of synchronization,\
    \ if three 0 length, template 0,\n   type 0 packets are received, the next non-zero\
    \ byte should be treated\n   as a start of packet, and the template tables cleared.\n\
    \  ____________________________________________________________________\n    \
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |U|L|Template no| Len of change |   IP  Header  Checksum        |\n   |1|0|0\
    \ 0 0 1 0 1|0 0 0 0 0 0 0 1|0 1 1 1 0 1 1 1 0 0 0 1 0 1 0 0|\n   |Y|N|     5 \
    \    |       1       |           nnn                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |   IP Identification number    |      TCP  Checksum            |\n   |0 0\
    \ 0 0 0 0 0 0 0 0 0 0 0 0 1 0|0 0 0 0 0 1 0 0 1 0 1 1 0 0 0 0|\n   |         \
    \  2                   |           nnn                 |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |  Bitfield     |  Time to Live |add to Seq no. | add to Ack Num|\n   |0 0\
    \ 1 0 1 0 0 0|0 0 0 0 0 0 0 1|0 0 0 0 0 0 0 1|0 0 0 0 0 0 0 1|\n   |    T Ad8\
    \      |       1       |        1      |      1        |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n\
    \   |    data       |                                                \n   |0 0\
    \ 0 1 0 1 1 1|                                                \n   |      \"d\"\
    \      |                                                \n   +-+-+-+-+-+-+-+-+\
    \                                                \n                      Packet\
    \ 2. Thinwire II update\n  ____________________________________________________________________\n"
- title: RFC 914                                                   September 1984
  contents:
  - 'RFC 914                                                   September 1984

    '
- title: Thinwire Protocol
  contents:
  - 'Thinwire Protocol

    '
- title: Appendix C -- Tentative Specification for Thinwire III
  contents:
  - "Appendix C -- Tentative Specification for Thinwire III\n   Thinwire III, as stated\
    \ in the body of this paper, provides multiple\n   virtual connections over a\
    \ single physical connection.  As Thinwire\n   III is based on a single point\
    \ to point connection, much of the\n   per/datagram information (routing and sequencing)\
    \ of other transport\n   systems can be eliminated.  In the steady state any bytes\
    \ received by\n   thinwire III are sent to the default higher level protocol\n\
    \   connection.  There are escaped control sequences which allow the\n   creation\
    \ of additional connections, the switching of the default\n   connection, the\
    \ packetizing of datagrams, and the passing of\n   information between the gateway\
    \ and the personal computer.  The\n   gateway and the personal computer manage\
    \ a single full duplex stream,\n   multiplexing control requests and streams of\
    \ data through the use of\n   embedded logical switches.\n   The ascii character\
    \ \"z\" (binary 01011011 ) is used as the escape\n   character.  The byte following\
    \ the \"z\" is interpreted to determine\n   the command.  Table C-1 shows the\
    \ general classes the  bytes (Request\n   codes) can fall into.\n   In order to\
    \ transmit the character \"z\", two \"z\"'s are transmitted.\n   The first is\
    \ interpreted as an escape, the second as the lower case\n   letter \"z\" to be\
    \ transmitted to the default connection.  The letter z\n   was chosen as the escape\
    \ for its low occurrence in text and control\n   data streams, because it should\
    \ pass easily through any lower level\n   protocols, and for its generally innocuous\
    \ behavior.\n   Descriptions of specifications of each of the Request codes are\n\
    \   below.\n   Starting with the range 0-31; these Request codes change the default\n\
    \   connection. After a connection has been established, any characters\n   which\
    \ come across the line that are not part of a Request code\n   sequence are transmitted\
    \ to one of the connections.  To begin with\n   this connection defaults to Zero,\
    \ but when the \"Switch Default\n   Connection\" command is received, characters\
    \ are sent to the\n   connection named in the request until a new request is received.\n\
    \   Zero is a special diagnostic connection; anything received on\n   connection\
    \ number Zero should be echoed back to the sender on\n   connection number One.\
    \  Anything received on connection number One\n   should be placed on the diagnostic\
    \ output of the receiving host.  Any\n   other connection number indicates data\
    \ which should be sent out the\n   numbered connection.  If the numbered connection\
    \ has not been opened,\n   the data can be thrown away, and an Error Control Message\
    \ returned to\n   the sender.\n   Escapes followed by numbers 32 through 255 are\
    \ for new connections,\n   requests for information, and error messages.  The\
    \ escape will be\n"
- title: RFC 914                                                   September 1984
  contents:
  - 'RFC 914                                                   September 1984

    '
- title: Thinwire Protocol
  contents:
  - "Thinwire Protocol\n   followed by a Request code, a one byte Request Sequence\
    \ Number (so\n   that the Reply to Request can be asynchronously associated with\
    \ the\n   Request), and the arguments for the specific request.  (The length of\n\
    \   the argument field will be determined by the Request code.)  The\n   format\
    \ of the request will be as pictured below:\n      \"z\" <Request Code> <Request\
    \ Sequence Number> [ <Arguments> ... ]\n   At this time the Request codes 32-63\
    \ are reserved.\n   The Request codes 64-127 are for stream server open requests.\
    \  For\n   the purposes of compression, many of the common servers are assigned\n\
    \   single byte codes.  See Table C-2.\n   Request code 68 is to a connection\
    \ to the default hostname server\n   used by the gateway.  It takes 3 bytes for\
    \ this request. It has the\n   form:\n      \"z\" < 68 > < Request Sequence Number\
    \ >\n   Request code 95 is to open any specified TCP Port at the specified\n \
    \  address.  It takes 9 bytes for this request.  It has the form:\n      \"z\"\
    \ < 95 > < Request Sequence Number > < 4 bytes of IP address> <\n      2 bytes\
    \ of TCP Port >\n   Request codes 96-127  are RESERVED for alternate transport\
    \ protocols.\n   The Request codes 128-191 are used for framing Datagrams and\
    \ opening\n   new Datagram connections.  The code 128 is the Start of Datagram\n\
    \   code.  The format is:\n      \"z\" <128> <Length of Datagram (2 bytes)> <Socket>\
    \ Data ...\n   As with the Stream opens, there are a number of assigned ports\
    \ with\n   codes for them.  They are listed in Table C-3.\n   The Request Codes\
    \ 192-254 are control, status and informational\n   requests.  These are still\
    \ under development, but will include:\n      -flow control\n      -get host/server/protocol\
    \ by entry/name/number.\n      -additional error messages\n      -overall reset\n\
    \      -open passive connection\n   The Request Code 252 is the request to close\
    \ a connection.  This\n   Code, followed by the connection number, indicates that\
    \ no more data\n"
- title: RFC 914                                                   September 1984
  contents:
  - 'RFC 914                                                   September 1984

    '
- title: Thinwire Protocol
  contents:
  - "Thinwire Protocol\n   will be sent out this connection number.  A second request\
    \ with the\n   same connection number will indicate that no more data will be\n\
    \   accepted on this connection.\n   The Request Code 253 is the information request\
    \ for a connection. The\n   protocol, status, and port number of the connection\
    \ should be\n   returned. The format of this reply has yet to be specified.\n\
    \   The Request code 254 is an error notification.  These are to be\n   acknowledged\
    \ with their Request Sequence Numbers.  Error codes are\n   under development.\n\
    \   The Request code 255 is the Reply to Request. The Request Sequence\n   Number\
    \ identifies the request being replied to.  The format is:\n      \"z\" <255>\
    \ <Request Sequence Number (in reply to)> <Length of reply\n      (1 byte)> Reply...\n\
    \   The Thinwire Drivers on each side will wait at their inbound sockets,\n  \
    \ and relay across the thinwire link\n   character-by-character/packet-by-packet\
    \ for the stream/datagram\n   connections.\n   Thinwire III is labeled as a tentative\
    \ specification, because at this\n   time, in order to publish this RFC in a timely\
    \ fashion, several minor\n   issues are still unresolved.  An example is the scheduling\
    \ of serial\n   line use. Short messages could be given priority over long packets,\n\
    \   or priority schemes could be changed during the session, depending\n   upon\
    \ the interactive desire of the user.  Addition issues will be\n   resolved in\
    \ the future.\n"
- title: RFC 914                                                   September 1984
  contents:
  - 'RFC 914                                                   September 1984

    '
- title: Thinwire Protocol
  contents:
  - 'Thinwire Protocol

    '
- title: Appendix D -- Serial Line Interface Protocol (SLIP)
  contents:
  - "Appendix D -- Serial Line Interface Protocol (SLIP)\n   Initial Specifications\
    \ and Implementation Suggestions\n   PHILOSOPHY\n      The world is a dangerous\
    \ place for bits.  Data transmission can be\n      an time consuming business\
    \ when one has to make sure that bits\n      don't get lost, destroyed, or forgotten.\
    \  To reduce such problems,\n      the Serial Line Interface Protocol (SLIP) maintains\
    \ an attitude\n      toward the world that includes both a mistrust of serial\
    \ lines and\n      a margin of laziness.  Examples of this approach include how\
    \ SLIP\n      recovers from errors and how SLIP handles the problem of\n     \
    \ resequencing (see PROTOCOL SPECIFICATIONS and IMPLEMENTATION\n      SUGGESTIONS).\n\
    \   THE MESSAGE FORMAT\n      Both the Sender Task and the Receiver Task communicate\
    \ using a\n      standard message format and the Sender and Receiver Task of one\n\
    \      machine's SLIP communicate using a shared buffer.  The message\n      begins\
    \ with a 1 byte Start of Header token (StH, 11111111) and is\n      followed by\
    \ a sequence number of four bits (SEQ) and an\n      acknowledgement number of\
    \ four bits (ACK).  Following the StH, SEQ\n      and ACK, is a 5 bit length field\
    \ which specifies the length of the\n      data contained in the message. Following\
    \ the length is a three bit\n      field of flags.  The first bit is used to indicate\
    \ that the a\n      receive error has occurred, and the ACK is actually a repeat\
    \ of\n      the Last Acknowledged message (a LACK).  The second bit is used to\n\
    \      indicate a Synchronize Sequence Numbers message (SSNM), and the\n     \
    \ third bit is used to indicate a Start of Control Message (SOCM);\n      all\
    \ three of these flags are explained below. Finally, at the end\n      of the\
    \ message is an exclusive-or checksum.  The message format is\n      shown in\
    \ figure D-1.\n            ________________________________________________\n\
    \ 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\n"
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...

    '
- title: '|     StH       |  SEQ  |  ACK  |  Length |Flags|...Data...'
  contents:
  - '|     StH       |  SEQ  |  ACK  |  Length |Flags|...Data...

    '
- title: +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...
  contents:
  - '+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+...

    '
- title: The maximum data length is 32 bytes.                0 1 2 3 4 5 6 7
  contents:
  - 'The maximum data length is 32 bytes.                0 1 2 3 4 5 6 7

    '
- title: This limits the vulnerability of receiver       ...-+-+-+-+-+-+-+-+-+-+
  contents:
  - 'This limits the vulnerability of receiver       ...-+-+-+-+-+-+-+-+-+-+

    '
- title: timeout errors occurring because of bit error .Data...|   Checksum    |
  contents:
  - 'timeout errors occurring because of bit error .Data...|   Checksum    |

    '
- title: in the length field.                            ...-+-+-+-+-+-+-+-+-+-+
  contents:
  - "in the length field.                            ...-+-+-+-+-+-+-+-+-+-+\n   \
    \                 Figure D-1. SLIP Message Format\n            ________________________________________________\n"
- title: RFC 914                                                   September 1984
  contents:
  - 'RFC 914                                                   September 1984

    '
- title: Thinwire Protocol
  contents:
  - "Thinwire Protocol\n      The Sender, when idle but needing to acknowledge, will\
    \ send out\n      short messages of the same format as a regular message but with\n\
    \      the SOCM flag set and the data field omitted.  ( This short\n      message\
    \ is called a SOCM, and is used instead of a zero length\n      message to avoid\
    \ the problem of continually ACK'ing ACK's ). The\n      Sender Task, when originating\
    \ a connection (see STARTING UP AND\n      FINISHING OFF COMMUNICATIONS), will\
    \ send out another short message\n      but with the SSNM flag set and the data\
    \ omitted.  This message (a\n      SSNM) used for a TCP-style 3 way startup handshake.\n\
    \   PROTOCOL SPECIFICATIONS and SUGGESTIONS\n      The SLIP module, when called\
    \ with data to send, prepends its\n      header (SEE ABOVE) to the data, calculates\
    \ a checksum and appends\n      the checksum at the end.  (This creates a message.)\
    \  The message\n      has a sequence number associated with it which represents\
    \ the\n      position of the message in the Sender SLIP's buffers.  The\n    \
    \  sequence number for the message can range from 0 to 15 and is\n      returned\
    \ in the ACK field of the other machine's Sender SLIP\n      messages to acknowledge\
    \ receipt.\n      There are two scenarios for transmission.  In the first, both\n\
    \      SLIP's will be transmitting to each other.  To send an\n      acknowledgement,\
    \ the Receiver SLIP uses the ACK field in its next\n      outgoing message. To\
    \ receive an acknowledgement, the Sender checks\n      the ACK field of its Receiver's\
    \ incoming messages.  In the second\n      scenario, one SLIP may have no data\
    \ to transmit for a long time.\n      Then, as stated above, to acknowledge a\
    \ received message, the\n      Receiver has its Sender send out a short message,\
    \ the SOCM (SEE\n      ABOVE) which specifies the message it is acknowledging.\
    \  The SOCM\n      includes a checksum of its total contents.  If there is a checksum\n\
    \      error, THE SOCM IS IGNORED.\n      When there is a checksum error on a\
    \ received normal message, the\n      Receiver asks its Sender to send out a SOCM\
    \ with the LACK flag\n      set, or set the LACK flag on its next message.  The\
    \ Sender sends\n      this flag ONCE then ceases to increment the acknowledgement\
    \ number\n      (the ACK) while the Receiver continues to check incoming messages\n\
    \      for the sequence number of the message with a checksum error.\n      (Note\
    \ that it continues to react to the acknowledgement field in\n      the incoming\
    \ messages.) When it finds the needed message, it\n      resumes accepting the\
    \ data in new messages and increments the\n      acknowledgement number transmitted\
    \ accordingly.\n      The sending SLIP must never send a message greater than\
    \ four past\n      the last message for which it has received an acknowledgement\n\
    \      (effectively a window size of four). Under normal processing\n      loads,\
    \ a window size greater than four should not be needed, and\n      this decreases\
    \ the probability of random errors creating valid\n"
- title: RFC 914                                                   September 1984
  contents:
  - 'RFC 914                                                   September 1984

    '
- title: Thinwire Protocol
  contents:
  - "Thinwire Protocol\n      acknowledgement or sequence numbers.  If the Sender\
    \ has four\n      unacknowledged messages outstanding, it will retransmit the\
    \ old\n      messages, starting from the oldest unacknowledged message.  If it\n\
    \      receives an acknowledgement with the LACK flag set, it transmits\n    \
    \  the message following the LACK number and continues to transmit\n      the\
    \ messages from that one on.  Thus a LACK is a message asking\n      the Sender\
    \ to please the Receiver.  If the Sender times out on any\n      message not logically\
    \ greater than four past the last acknowledged\n      message, it should retransmit\
    \ the message that timed out and then\n      continues to transmit messages following\
    \ the timed out message.\n      The following describes a partial implementation\
    \ of SLIP.  System\n      dependent subjects like buffer management, timer handling\
    \ and\n      calling conventions are discussed.\n      The SLIP implementation\
    \ is subdivided into four modules and two\n      sets of input/output interfaces.\
    \  The four modules are: The Sender\n      Task, The Receiver Task, the buffer\
    \ Manager, and SLIPTIME (the\n      timer). The two interfaces are to the higher\
    \ protocol and to the\n      lower protocol (the UARTian, an interrupt driven\
    \ device driver for\n      the serial lines).\n   OPERATIONS OF THE SENDER TASK\n\
    \      The Sender Task takes a relatively noncomplex approach to\n      transmitting.\
    \  It sends message zero, sets a timer (using the\n      SLIPTIME Task) on the\
    \ message, and proceeds to send and set timers\n      for messages one, two, and\
    \ three.  When the Receiver Task tells\n      the Sender Task that a message has\
    \ been acknowledged, the Sender\n      Task then clears the timer for that message,\
    \ and marks it\n      acknowledged.  When the Sender Task has finished sending\
    \ a\n      message, it checks several conditions to decide what to do next.\n\
    \      It first checks to see if a LACK has been received. If it has then\n  \
    \    it clears all the timers, and begins retransmitting messages\n      (updating\
    \ the acknowledgement field and checksum) starting from\n      the one after the\
    \ LACK'ed message.  If there is not a LACK waiting\n      for the Sender Task,\
    \ it checks to see if any messages have timed\n      out.  If a message has timed\
    \ out, the Sender Task again will clear\n      the timers and begin retransmitting\
    \ from the message number which\n      timed out.  If neither of these conditions\
    \ are true, the Sender\n      Task checks to see if, because it has looped back\
    \ to retransmit,\n      it has any previously formulated messages to send.  If\
    \ so, it send\n      the first of these messages. If it does not have previously\n\
    \      formulated messages, it checks to see if it is more than three\n      past\
    \ the last acknowledged message.  If so, it restarts from the\n      message after\
    \ the last acknowledged message.  If none of these are\n      true, then it checks\
    \ to see if there is more data waiting to be\n      transmitted.  If there is\
    \ more data available, it forms the\n      largest packet it can, and begins to\
    \ transmit it.  If there is no\n"
- title: RFC 914                                                   September 1984
  contents:
  - 'RFC 914                                                   September 1984

    '
- title: Thinwire Protocol
  contents:
  - "Thinwire Protocol\n      more data to transmit, it checks to see if it needs\
    \ to acknowledge\n      a message received from the other side.  If so then it\
    \ sends a\n      SOCM.  If none of the above conditions create work for the Sender\n\
    \      Task, the task suspends itself.\n      Note that the Sender Task uses the\
    \ Receiver Task to find out about\n      acknowledgements and the Receiver Task\
    \ uses the Sender Task to\n      send acknowledgements to the other SLIP on the\
    \ other side (via the\n      ACK field in the Sender Task's message). The two\
    \ tasks on one\n      machine communicate through a small buffer. Because\n  \
    \    acknowledgements need to be passed back to the Sender Task\n      quickly,\
    \ the Receiver Task can wake up the Sender Task (unblock\n      it).\n   OPERATIONS\
    \ OF THE RECEIVER TASK\n      The Receiver Task checks the checksums of the messages\
    \ coming into\n      it.  When it gets a checksum error, it tells the Sender Task\
    \ to\n      mark the next acknowledgement as a LACK.  It then throws away all\n\
    \      messages coming into it that don't match the message it wants and\n   \
    \   continues to acknowledge with the last ACK until it gets the\n      message\
    \ it wants.  As a checksum error could be the result of a\n      crashed packet,\
    \ and the StH character can occur within the packet,\n      when a checksum error\
    \ does occur, the recovery includes scanning\n      forward from the last StH\
    \ character for the next StH character\n      then attempting to verify a packet\
    \ beginning from it.  A valid\n      message includes a valid checksum, and sequence\
    \ and\n      acknowledgement numbers within the active window of numbers.  This\n\
    \      eliminates the need for the resequencing of messages, because the\n   \
    \   Receiver Task throws away anything that would make information in\n      its\
    \ buffers out of sequence.\n   OPERATIONS OF SLIPTIME\n      The timer task will\
    \ maintain and update a table of timers for each\n      request.  Its functions\
    \ should be called with the timer length and\n      the sequence number to associate\
    \ with the timer.  Its functions\n      can also be called with a request to delete\
    \ a timer.  An\n      interrupt-driven mechanism is used to update the running\
    \ timers\n      and to wake up the Sender when an alarm goes off.\n"
- title: RFC 914                                                   September 1984
  contents:
  - 'RFC 914                                                   September 1984

    '
- title: Thinwire Protocol
  contents:
  - "Thinwire Protocol\n   THE INPUT AND OUTPUT INTERFACES\n      To force SLIP to\
    \ do something, the higher protocol should create a\n      buffer and then call\
    \ SLIP, passing it a pointer to the buffer.\n      SLIP will then read the buffer\
    \ and begin sending it.  The call to\n      SLIP will return the number of bytes\
    \ written, negative number\n      indicates to the caller that SLIP could not\
    \ do the request.  Exact\n      error numbers will be assigned in the future.\
    \  To ask SLIP to\n      receive something, one would call SLIP and SLIP would\
    \ immediately\n      return the number of bytes received or a negative number\
    \ for an\n      error (nothing ready to receive, for example).\n      SLIP, when\
    \ it wants to talk to the underworld of the serial\n      interface, will do much\
    \ the same thing only through a buffer\n      written to by the UARTian (for received\
    \ data) and read from by the\n      UARTian (for sent data).\n   OPERATIONS OF\
    \ THE BUFFER/WINDOW MANAGER\n      The Manager tends a continuous, circular buffer\
    \ for the Sender\n      Task in which data to be sent (from the downcalling protocol)\
    \ is\n      stored.  This buffer is called the INPUT-DATA BUFFER (IDBuff).\n \
    \     The Manager also manages a SENDER TASK'S OUTPUT-DATA BUFFER\n      (SODBuff),\
    \ which is its output buffer to the UARTian.\n      The IDBuff has associated\
    \ with it some parameters.  These\n      parameters include: START OF MEMORY (SOM),\
    \ the start of memory\n      reserved for the IDBuff; END OF MEMORY (EOM), the\
    \ end of memory\n      reserved; START OF DATA (SOD), the beginning of the used\
    \ portion\n      of the IDBuff; and END OF DATA (EOD), the end of data in the\n\
    \      IDBuff.  The SOM and EOM are constants whereas the SOD and EOD are\n  \
    \    variables.\n      The SODBuff is composed of four buffers for four outbound\
    \ messages\n      (less the checksum).  The buffers can be freed up to be\n  \
    \    overwritten when the message that they contain is acknowledged by\n     \
    \ the SLIP on the other side of the line.  When a message is in the\n      SODBuff,\
    \ it has associated with it a sequence number (which is the\n      message's sequence\
    \ number).  The Sender Task can reference the\n      data in the SODBuff and reference\
    \ acknowledgements via this\n      sequence number.\n      When the application\
    \ has data to be transmitted, it is placed in\n      the IDBuff by the application\
    \ using functions from the Manager and\n      the EOD is incremented.  If the\
    \ data the application wants to send\n      won't fit in the buffer, no data is\
    \ written, and the application\n      can either sleep, or continue to attempt\
    \ to write data until the\n"
- title: RFC 914                                                   September 1984
  contents:
  - 'RFC 914                                                   September 1984

    '
- title: Thinwire Protocol
  contents:
  - "Thinwire Protocol\n      data will fit. The Sender Task calls a Manager function\
    \ to fill a\n      message slot in the SODBuff.  The Sender Task then sends its\n\
    \      message from the SODBuff.\n      The Manager also maintains a buffer set\
    \ for the Receiver Task. The\n      buffers are similar to those of the Sender\
    \ Task.  There is a\n      CHECKSUMMED OUTPUT-DATA BUFFER (CODBuff), which is\
    \ the final\n      output from SLIP that the higher level protocol may read. \
    \ The\n      CODBuff is also controlled by the four parameters START OF MEMORY,\n\
    \      END OF MEMORY, START OF DATA, and END OF DATA (SOM, EOM, SOD, and\n   \
    \   EOD).\n      There is also an inbound circular buffer the analog of the\n\
    \      SODBuff, called the RECEIVER TASK'S INPUT-DATA BUFFER (RIDBuff).\n    \
    \  When the UARTian gets data, it places the data in the RIDBuff.\n      After\
    \ this, the Receiver Task checksums the data.  If the checksum\n      is good\
    \ and the Receiver Task opts to acknowledge the message, it\n      moves the data\
    \ to the CODBuff, increments EOD, and frees up space\n      in the RIDBuff.  The\
    \ higher level application can then take data\n      off on the CODBuff, incrementing\
    \ SOD as it does so.\n   STARTING UP AND FINISHING OFF COMMUNICATIONS\n      The\
    \ problem is that the SLIP's on either side need to know (and\n      keep knowing)\
    \ the sequence number of the other SLIP.  The easiest\n      way to solve most\
    \ of these problems is to have the SLIP check the\n      Request to Send and Clear\
    \ to Send Lines to see if the other SLIP\n      is active. On startup, or if it\
    \ has reason to believe the other\n      side has died, the SLIP assumes: all\
    \ connections are closed, no\n      data from any connection has been sent, and\
    \ both its SEQ and the\n      SEQ of the other SLIP are zero.  To start up a connection,\
    \ the\n      instigating SLIP sends a SSNM with its starting sequence number in\n\
    \      it.  The receiving SLIP acknowledges this SSNM and replies with\n     \
    \ its starting sequence number (combined into one message).  Then\n      the sending\
    \ SLIP acknowledges the receiving SLIP's starting\n      sequence number and the\
    \ transmission commences.  This is the three\n      way handshake taken from TCP,\
    \ After which data transmission can\n      begin.\n"
