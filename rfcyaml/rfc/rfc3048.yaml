- title: __initial_text__
  contents:
  - "      Reliable Multicast Transport Building Blocks for One-to-Many\n        \
    \                   Bulk-Data Transfer\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2001).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document describes a framework for the standardization of bulk-\n\
    \   data reliable multicast transport.  It builds upon the experience\n   gained\
    \ during the deployment of several classes of contemporary\n   reliable multicast\
    \ transport, and attempts to pull out the\n   commonalities between these classes\
    \ of protocols into a number of\n   building blocks.  To that end, this document\
    \ recommends that certain\n   components that are common to multiple protocol\
    \ classes be\n   standardized as \"building blocks\".  The remaining parts of\
    \ the\n   protocols, consisting of highly protocol specific, tightly\n   intertwined\
    \ functions, shall be designated as \"protocol cores\".\n   Thus, each protocol\
    \ can then be constructed by merging a \"protocol\n   core\" with a number of\
    \ \"building blocks\" which can be re-used across\n   multiple protocols.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1 Introduction ..................................................\
    \  2\n   1.1 Protocol Families ...........................................  5\n\
    \   2 Building Blocks Rationale .....................................  6\n   2.1\
    \ Building Blocks Advantages ..................................  6\n   2.2 Building\
    \ Block Risks ........................................  7\n   2.3 Building Block\
    \ Requirements .................................  8\n   3 Protocol Components\
    \ ...........................................  8\n   3.1 Sub-Components Definition\
    \ ...................................  9\n   4 Building Block Recommendations\
    \ ................................ 12\n   4.1 NACK-based Reliability ......................................\
    \ 13\n   4.2 FEC coding .................................................. 13\n\
    \   4.3 Congestion Control .......................................... 13\n   4.4\
    \ Generic Router Support ...................................... 14\n   4.5 Tree\
    \ Configuration .......................................... 14\n   4.6 Data Security\
    \ ............................................... 15\n   4.7 Common Headers ..............................................\
    \ 15\n   4.8 Protocol Cores .............................................. 15\n\
    \   5 Security ...................................................... 15\n   6\
    \ IANA Considerations ........................................... 15\n   7 Conclusions\
    \ ................................................... 16\n   8 Acknowledgements\
    \ .............................................. 16\n   9 References ....................................................\
    \ 16\n   10 Authors' Addresses ........................................... 19\n\
    \   11 Full Copyright Statement ..................................... 20\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   RFC 2357 lays out the requirements for reliable multicast\
    \ protocols\n   that are to be considered for standardization by the IETF.  They\n\
    \   include:\n   o  Congestion Control.  The protocol must be safe to deploy in\
    \ the\n      widespread Internet.  Specifically, it must adhere to three\n   \
    \   mandates:  a) it must achieve good throughput (i.e., it must not\n      consistently\
    \ overload links with excess data or repair traffic),\n      b) it must achieve\
    \ good link utilization, and c) it must not\n      starve competing flows.\n \
    \  o  Scalability.  The protocol should be able to work under a variety\n    \
    \  of conditions that include multiple network topologies, link\n      speeds,\
    \ and the receiver set size.  It is more important to have a\n      good understanding\
    \ of how and when a protocol breaks than when it\n      works.\n   o  Security.\
    \  The protocol must be analyzed to show what is necessary\n      to allow it\
    \ to cope with security and privacy issues.  This\n      includes understanding\
    \ the role of the protocol in data\n      confidentiality and sender authentication,\
    \ as well as how the\n      protocol will provide defenses against denial of service\
    \ attacks.\n   These requirements are primarily directed towards making sure that\n\
    \   any standards will be safe for widespread Internet deployment.  The\n   advancing\
    \ maturity of current work on reliable multicast congestion\n   control (RMCC)\
    \ [HFW99] in the IRTF Reliable Multicast Research Group\n   (RMRG) has been one\
    \ of the events that has allowed the IETF to\n   charter the RMT working group.\
    \  RMCC only addresses a subset of the\n   design space for reliable multicast.\
    \  Fortuitously, the requirements\n   it addresses are also the most pressing\
    \ application and market\n   requirements.\n   A protocol's ability to meet the\
    \ requirements of congestion control,\n   scalability, and security is affected\
    \ by a number of secondary\n   requirements that are described in a separate document\
    \ [RFC2887].  In\n   summary, these are:\n   o  Ordering Guarantees.  A protocol\
    \ must offer at least one of either\n      source ordered or unordered delivery\
    \ guarantees.  Support for\n      total ordering across multiple senders is not\
    \ recommended, as it\n      makes it more difficult to scale the protocol, and\
    \ can more easily\n      be implemented at a higher level.\n   o  Receiver Scalability.\
    \  A protocol should be able to support a\n      \"large\" number of simultaneous\
    \ receivers per transport group.  A\n      typical receiver set could be on the\
    \ order of at least 1,000 -\n      10,000 simultaneous receivers per group, or\
    \ could even eventually\n      scale up to millions of receivers in the large\
    \ Internet.\n   o  Real-Time Feedback.  Some versions of RMCC may require soft\
    \ real-\n      time feedback, so a protocol may provide some means for this\n\
    \      information to be measured and returned to the sender.  While this\n  \
    \    does not require that a protocol deliver data in soft real-time,\n      it\
    \ is an important application requirement that can be provided\n      easily given\
    \ real-time feedback.\n   o  Delivery Guarantees.  In many applications, a logically\
    \ defined\n      unit or units of data is to be delivered to multiple clients,\n\
    \      e.g., a file or a set of files, a software package, a stock quote\n   \
    \   or package of stock quotes, an event notification, a set of\n      slides,\
    \ a frame or block from a video.  An application data unit\n      is defined to\
    \ be a logically separable unit of data that is useful\n      to the application.\
    \  In some cases, an application data unit may\n      be short enough to fit into\
    \ a single packet (e.g., an event\n      notification or a stock quote), whereas\
    \ in other cases an\n      application data unit may be much longer than a packet\
    \ (e.g., a\n      software package).  A protocol must provide good throughput\
    \ of\n      application data units to receivers.  This means that most data\n\
    \      that is delivered to receivers is useful in recovering the\n      application\
    \ data unit that they are trying to receive.  A protocol\n      may optionally\
    \ provide delivery confirmation, i.e., a mechanism\n      for receivers to inform\
    \ the sender when data has been delivered.\n      There are two types of confirmation,\
    \ at the application data unit\n      level and at the packet level.  Application\
    \ data unit confirmation\n      is useful at the application level, e.g., to inform\
    \ the\n      application about receiver progress and to decide when to stop\n\
    \      sending packets about a particular application data unit.  Packet\n   \
    \   confirmation is useful at the transport level, e.g., to inform the\n     \
    \ transport level when it can release buffer space being used for\n      storing\
    \ packets for which delivery has been confirmed.  Packet\n      level confirmation\
    \ may also aid in application data unit\n      confirmation.\n   o  Network Topologies.\
    \  A protocol must not break the network when\n      deployed in the full Internet.\
    \  However, we recognize that\n      intranets will be where the first wave of\
    \ deployments happen, and\n      so are also very important to support.  Thus,\
    \ support for\n      satellite networks (including those with terrestrial return\
    \ paths\n      or no return paths at all) is encouraged, but not required.\n \
    \  o  Group Membership.  The group membership algorithms must be\n      scalable.\
    \  Membership can be anonymous (where the sender does not\n      know the list\
    \ of receivers), or fully distributed (where the\n      sender receives a count\
    \ of the number of receivers, and optionally\n      a list of failures).\n   o\
    \  Example Applications.  Some of the applications that a RM protocol\n      could\
    \ be designed to support include multimedia broadcasts, real\n      time financial\
    \ market data distribution, multicast file transfer,\n      and server replication.\n\
    \   In the rest of this document the following terms will be used with a\n   specific\
    \ connotation: \"protocol family\", \"protocol component\",\n   \"building block\"\
    , \"protocol core\", and \"protocol instantiation\".  A\n   \"protocol family\"\
    \ is a broad class of RM protocols which share a\n   common characteristic.  In\
    \ our classification, this characteristic is\n   the mechanism used to achieve\
    \ reliability.  A \"protocol component\" is\n   a logical part of the protocol\
    \ that addresses a particular\n   functionality.  A \"building block\" is a constituent\
    \ of a protocol\n   that implements one, more than one or a part of a component.\
    \  A\n   \"protocol core\" is the set of functionality required for the\n   instantiation\
    \ of a complete protocol, that is not specified by any\n   building block.  Finally\
    \ a \"protocol instantiation\" is an actual RM\n   protocol defined in term of\
    \ building blocks and a protocol core.\n"
- title: 1.1.  Protocol Families
  contents:
  - "1.1.  Protocol Families\n   The design-space document [RFC2887] also provides\
    \ a taxonomy of the\n   most popular approaches that have been proposed over the\
    \ last ten\n   years.  After congestion control, the primary challenge has been\
    \ that\n   of meeting the requirement for ensuring good throughput in a way that\n\
    \   scales to a large number of receivers.  For protocols that include a\n   back-channel\
    \ for recovery of lost packets, the ability to take\n   advantage of support of\
    \ elements in the network has been found to be\n   very beneficial for supporting\
    \ good throughput for a large numbers of\n   receivers.  Other protocols have\
    \ found it very beneficial to transmit\n   coded data to achieve good throughput\
    \ for large numbers of receivers.\n   This taxonomy breaks proposed protocols\
    \ into four families.  Some\n   protocols in the family provide packet level delivery\
    \ confirmation\n   that may be useful to the transport level.  All protocols in\
    \ all\n   families can be supplemented with higher level protocols that provide\n\
    \   delivery confirmation of application data units.\n   1  NACK only.  Protocols\
    \ such as SRM [FJM95] and MDP2 [MA99] attempt\n      to limit traffic by only\
    \ using NACKs for requesting packet\n      retransmission.  They do not require\
    \ network infrastructure.\n   2  Tree based ACK.  Protocols such as RMTP [LP96,\
    \ PSLM97], RMTP-II\n      [WBPM98] and TRAM [KCW98], use positive acknowledgments\
    \ (ACKs).\n      ACK based protocols reduce the need for supplementary protocols\n\
    \      that provide delivery confirmation, as the ACKS can be used for\n     \
    \ this purpose.  In order to avoid ACK implosion in scaled up\n      deployments,\
    \ the protocol can use servers placed in the network.\n   3  Asynchronous Layered\
    \ Coding (ALC).  These protocols (examples\n      include [RV97] and [BLMR98])\
    \ use sender-based Forward Error\n      Correction (FEC) methods with no feedback\
    \ from receivers or the\n      network to ensure good throughput.  These protocols\
    \ also used\n      sender-based layered multicast and receiver-driven protocols\
    \ to\n      join and leave these layers with no feedback to the sender to\n  \
    \    achieve scalable congestion control.\n   4  Router assist.  Like SRM, protocols\
    \ such as PGM [FLST98] and\n      [LG97] also use negative acknowledgments for\
    \ packet recovery.\n      These protocols take advantage of new router software\
    \ to do\n      constrained negative acknowledgments and retransmissions.  Router\n\
    \      assist protocols can also provide other functionality more\n      efficiently\
    \ than end to end protocols.  For example, [LVS99] shows\n      how router assist\
    \ can provide fine grained congestion control for\n      ALC protocols.  Router\
    \ assist protocols can be designed to\n      complement all protocol families\
    \ described above.\n   Note that the distinction in protocol families in not necessarily\n\
    \   precise and mutually exclusive.  Actual protocols may use a\n   combination\
    \ of the mechanisms belonging to different classes.  For\n   example, hybrid NACK/ACK\
    \ based protocols (such as [WBPM98]) are\n   possible.  Other examples are protocols\
    \ belonging to class 1 through\n   3 that take advantage of router support.\n"
- title: 2.  Building Blocks Rationale
  contents:
  - "2.  Building Blocks Rationale\n   As specified in RFC 2357 [MRBP98], no single\
    \ reliable multicast\n   protocol will likely meet the needs of all applications.\
    \  Therefore,\n   the IETF expects to standardize a number of protocols that are\n\
    \   tailored to application and network specific needs.  This document\n   concentrates\
    \ on the requirements for \"one-to-many bulk-data\n   transfer\", but in the future,\
    \ additional protocols and building-\n   blocks are expected that will address\
    \ the needs of other types of\n   applications, including \"many-to- many\" applications.\
    \  Note that\n   bulk-data transfer does not refer to the timeliness of the data,\n\
    \   rather it states that there is a large amount of data to be\n   transferred\
    \ in a session.  The scope and approach taken for the\n   development of protocols\
    \ for these additional scenarios will depend\n   upon large part on the success\
    \ of the \"building-block\" approach put\n   forward in this document.\n"
- title: 2.1.  Building Blocks Advantages
  contents:
  - "2.1.  Building Blocks Advantages\n   Building a large piece of software out of\
    \ smaller modular components\n   is a well understood technique of software engineering.\
    \  Some of the\n   advantages that can come from this include:\n   o  Specification\
    \ Reuse.  Modules can be used in multiple protocols,\n      which reduces the\
    \ amount of development time required.\n   o  Reduced Complexity.  To the extent\
    \ that each module can be easily\n      defined with a simple API, breaking a\
    \ large protocol in to smaller\n      pieces typically reduces the total complexity\
    \ of the system.\n   o  Reduced Verification and Debugging Time.  Reduced complexity\n\
    \      results in reduced time to debug the modules.  It is also usually\n   \
    \   faster to verify a set of smaller modules than a single larger\n      module.\n\
    \   o  Easier Future Upgrades.  There is still ongoing research in\n      reliable\
    \ multicast, and we expect the state of the art to continue\n      to evolve.\
    \  Building protocols with smaller modules allows them to\n      be more easily\
    \ upgraded to reflect future research.\n   o  Common Diagnostics.  To the extent\
    \ that multiple protocols share\n      common packet headers, packet analyzers\
    \ and other diagnostic tools\n      can be built which work with multiple protocols.\n\
    \   o  Reduces Effort for New Protocols.  As new application requirements\n  \
    \    drive the need for new standards, some existing modules may be\n      reused\
    \ in these protocols.\n   o  Parallelism of Development.  If the APIs are defined\
    \ clearly, the\n      development of each module can proceed in parallel.\n"
- title: 2.2.  Building Block Risks
  contents:
  - "2.2.  Building Block Risks\n   Like most software specification, this technique\
    \ of breaking down a\n   protocol in to smaller components also brings tradeoffs.\
    \  After a\n   certain point, the disadvantages outweigh the advantages, and it\
    \ is\n   not worthwhile to further subdivide a problem.  These risks include:\n\
    \   o  Delaying Development.  Defining the API for how each two modules\n    \
    \  inter-operate takes time and effort.  As the number of modules\n      increases,\
    \ the number of APIs can increase at more than a linear\n      rate.  The more\
    \ tightly coupled and complex a component is, the\n      more difficult it is\
    \ to define a simple API, and the less\n      opportunity there is for reuse.\
    \  In particular, the problem of how\n      to build and standardize fine grained\
    \ building blocks for a\n      transport protocol is a difficult one, and in some\
    \ cases requires\n      fundamental research.\n   o  Increased Complexity.  If\
    \ there are too many modules, the total\n      complexity of the system actually\
    \ increases, due to the\n      preponderance of interfaces between modules.\n\
    \   o  Reduced Performance.  Each extra API adds some level of processing\n  \
    \    overhead.  If an API is inserted in to the \"common case\" of packet\n  \
    \    processing, this risks degrading total protocol performance.\n   o  Abandoning\
    \ Prior Work.  The development of robust transport\n      protocols is a long\
    \ and time intensive process, which is heavily\n      dependent on feedback from\
    \ real deployments.  A great deal of work\n      has been done over the past five\
    \ years on components of protocols\n      such as RMTP-II, SRM, and PGM.  Attempting\
    \ to dramatically re-\n      engineer these components risks losing the benefit\
    \ of this prior\n      work.\n"
- title: 2.3.  Building Block Requirements
  contents:
  - "2.3.  Building Block Requirements\n   Given these tradeoffs, we propose that\
    \ a building block must meet the\n   following requirements:\n   o  Wide Applicability.\
    \  In order to have confidence that the\n      component can be reused, it should\
    \ apply across multiple protocol\n      families and allow for the component's\
    \ evolution.\n   o  Simplicity.  In order to have confidence that the specification\
    \ of\n      the component APIs will not dramatically slow down the standards\n\
    \      process, APIs must be simple and straight forward to define.  No\n    \
    \  new fundamental research should be done in defining these APIs.\n   o  Performance.\
    \  To the extent possible, the building blocks should\n      attempt to avoid\
    \ breaking up the \"fast track\", or common case\n      packet processing.\n"
- title: 3.  Protocol Components
  contents:
  - "3.  Protocol Components\n   This section proposes a functional decomposition\
    \ of RM bulk-data\n   protocols from the perspective of the functional components\
    \ provided\n   to an application by a transport protocol.  It also covers some\n\
    \   components that while not necessarily part of the transport protocol,\n  \
    \ are directly impacted by the specific requirements of a reliable\n   multicast\
    \ transport.  The next section then specifies recommended\n   building blocks\
    \ that can implement these components.\n   Although this list tries to cover all\
    \ the most common transport-\n   related needs of one-to-many bulk-data transfer\
    \ applications, new\n   application requirements may arise during the process\
    \ of\n   standardization, hence this list must not be interpreted as a\n   statement\
    \ of what the transport layer should provide and what it\n   should not.  Nevertheless,\
    \ it must be pointed out that some\n   functional components have been deliberately\
    \ omitted since they have\n   been deemed irrelevant to the type of application\
    \ considered (i.e.,\n   one-to-many bulk-data transfer).  Among these are advanced\
    \ message\n   ordering (i.e., those which cannot be implemented through a simple\n\
    \   sequence number) and atomic delivery.\n   It is also worth mentioning that\
    \ some of the functional components\n   listed below may be required by other\
    \ functional components and not\n   directly by the application (e.g., membership\
    \ knowledge is usually\n   required to implement ACK-based reliability).\n   The\
    \ following list covers various transport functional components and\n   splits\
    \ them in sub-components.\n   o  Data Reliability (ensuring good throughput) \
    \   |\n                          | - Loss Detection/Notification\n           \
    \               | - Loss Recovery\n                          | - Loss Protection\n\
    \   o  Congestion Control  |\n                          | - Congestion Feedback\n\
    \                          | - Rate Regulation\n                          | -\
    \ Receiver Controls\n   o  Security\n   o  Group membership    |\n           \
    \               | - Membership Notification\n                          | - Membership\
    \ Management\n   o  Session Management  |\n                          | - Group\
    \ Membership Tracking\n                          | - Session Advertisement\n \
    \                         | - Session Start/Stop\n                          |\
    \ - Session Configuration/Monitoring\n   o  Tree Configuration\n   Note that not\
    \ all components are required by all protocols, depending\n   upon the fully defined\
    \ service that is being provided by the\n   protocol.  In particular, some minimal\
    \ service models do not require\n   many of these functions, including loss notification,\
    \ loss recovery,\n   and group membership.\n"
- title: 3.1.  Sub-Components Definition
  contents:
  - "3.1.  Sub-Components Definition\n   Loss Detection/Notification.  This includes\
    \ how missing packets are\n   detected during transmission and how knowledge of\
    \ these events are\n   propagated to one or more agents which are designated to\
    \ recover from\n   the transmission error.  This task raises major scalability\
    \ issues\n   and can lead to feedback implosion and poor throughput if not\n \
    \  properly handled.  Mechanisms based on TRACKs (tree-based positive\n   acknowledgements)\
    \ or NACKs (negative acknowledgements) are the most\n   widely used to perform\
    \ this function.  Mechanisms based on a\n   combination of TRACKs and NACKs are\
    \ also possible.\n   Loss Recovery.  This function responds to loss notification\
    \ events\n   through the transmission of additional packets, either in the form\
    \ of\n   copies of those packets lost or in the form of FEC packets.  The\n  \
    \ manner in which this function is implemented can significantly affect\n   the\
    \ scalability of a protocol.\n   Loss Protection.  This function attempts to mask\
    \ packet-losses so\n   that they don't become Loss Notification events.  This\
    \ function can\n   be realized through the pro-active transmission of FEC packets.\
    \  Each\n   FEC packet is created from an entire application data unit [LMSSS97]\n\
    \   or a portion of an application data unit [RV97], [BKKKLZ95], a fact\n   that\
    \ allows a receiver to recover from some packet loss without\n   further retransmissions.\
    \  The number of losses that can be recovered\n   from without requiring retransmission\
    \ depends on the amount of FEC\n   packets sent in the first place.  Loss protection\
    \ can also be pushed\n   to the extreme when good throughput is achieved without\
    \ any Loss\n   Detection/Notification and Loss Recovery functionality, as in the\
    \ ALC\n   family of protocols defined above.\n   Congestion Feedback.  For sender\
    \ driven congestion control protocols,\n   the receiver must provide some type\
    \ of feedback on congestion to the\n   sender.  This typically involves loss rate\
    \ and round trip time\n   measurements.\n   Rate Regulation.  Given the congestion\
    \ feedback, the sender then must\n   adjust its rate in a way that is fair to\
    \ the network.  One proposal\n   that defines this notion of fairness and other\
    \ congestion control\n   requirements is [Whetten99].\n   Receiver Controls. \
    \ In order to avoid allowing a receiver that has an\n   extremely slow connection\
    \ to the sender to stop all progress within\n   single rate schemes, a congestion\
    \ control algorithm will often\n   require receivers to leave groups.  For multiple\
    \ rate approaches,\n   receivers of all connection speeds can have data delivered\
    \ to them\n   according to the rate of their connection without slowing down other\n\
    \   receivers.\n   Security.  Security for reliable multicast contains a number\
    \ of\n   complex and tricky issues that stem in large part from the IP\n   multicast\
    \ service model.  In this service model, hosts do not send\n   traffic to another\
    \ host, but instead elect to receive traffic from a\n   multicast group. This\
    \ means that any host may join a group and\n   receive its traffic.  Conversely,\
    \ hosts may also leave a group at any\n   time.  Therefore, the protocol must\
    \ address how it impacts the\n   following security issues:\n   o  Sender Authentication\
    \ (since any host can send to a group),\n   o  Data Encryption (since any host\
    \ can join a group)\n   o  Transport Protection (denial of service attacks, through\n\
    \      corruption of transport state, or requests for unauthorized\n      resources)\n\
    \   o  Group Key Management (since hosts may join and leave a group at\n     \
    \ any time) [WHA98]\n   In particular, a transport protocol needs to pay particular\
    \ attention\n   to how it protects itself from denial of service attacks, through\n\
    \   mechanisms such as lightweight authentication of control packets\n   [HW99].\n\
    \   With Source Specific Multicast service model (SSM), a host joins\n   specifically\
    \ to a sender and group pair.  Thus, SSM offers more\n   security against hosts\
    \ receiving traffic from a denial of service\n   attack where an arbitrary sender\
    \ sends packets that hosts did not\n   specifically request to receive.  Nevertheless,\
    \ it is recommended\n   that additional protections against such attacks should\
    \ be provided\n   when using SSM, because the protection offered by SSM against\
    \ such\n   attacks may not be enough.\n   Sender Authentication, Data Encryption,\
    \ and Group Key Management.\n   While these functions are not typically part of\
    \ the transport layer\n   per se, a protocol needs to understand what ramifications\
    \ it has on\n   data security, and may need to have special interfaces to the\n\
    \   security layer in order to accommodate these ramifications.\n   Transport\
    \ Protection.  The primary security task for a transport\n   layer is that of\
    \ protecting the transport layer itself from attack.\n   The most important function\
    \ for this is typically lightweight\n   authentication of control packets in order\
    \ to prevent corruption of\n   state and other denial of service attacks.\n  \
    \ Membership Notification.  This is the function through which the data\n   source--or\
    \ upper level agent in a possible hierarchical\n   organization--learns about\
    \ the identity and/or number of receivers or\n   lower level agents.  To be scalable,\
    \ this typically will not provide\n   total knowledge of the identity of each\
    \ receiver.\n   Membership Management.  This implements the mechanisms for members\
    \ to\n   join and leave the group, to accept/refuse new members, or to\n   terminate\
    \ the membership of existing members.\n   Group Membership Tracking.  As an optional\
    \ feature, a protocol may\n   interface with a component which tracks the identity\
    \ of each receiver\n   in a large group.  If so, this feature will typically be\
    \ implemented\n   out of band, and may be implemented by an upper level protocol.\
    \  This\n   may be useful for services that require tracking of usage of the\n\
    \   system, billing, and usage reports.\n   Session Advertisement.  This publishes\
    \ the session name/contents and\n   the parameters needed for its reception. This\
    \ function is usually\n   performed by an upper layer protocol (e.g., [HPW99]\
    \ and [HJ98]).\n   Session Start/Stop.  These functions determine the start/stop\
    \ time of\n   sender and/or receivers.  In many cases this is implicit or performed\n\
    \   by an upper level application or protocol.  In some protocols,\n   however,\
    \ this is a task best performed by the transport layer due to\n   scalability\
    \ requirements.\n   Session Configuration/Monitoring.  Due to the potentially\
    \ far\n   reaching scope of a multicast session, it is particularly important\n\
    \   for a protocol to include tools for configuring and monitoring the\n   protocol's\
    \ operation.\n   Tree Configuration.  For protocols which include hierarchical\n\
    \   elements (such as PGM and RMTP-II), it is important to configure\n   these\
    \ elements in a way that has approximate congruence with the\n   multicast routing\
    \ topology.  While tree configuration could be\n   included as part of the session\
    \ configuration tools, it is clearly\n   better if this configuration can be made\
    \ automatic.\n"
- title: 4.  Building Block Recommendations
  contents:
  - "4.  Building Block Recommendations\n   The families of protocols introduced in\
    \ section 1.1 generally use\n   different mechanisms to implement the protocol\
    \ functional components\n   described in section 3.  This section tries to group\
    \ these mechanisms\n   in macro components that define protocol building blocks.\n\
    \   A building block is defined as\n      \"a logical protocol component that\
    \ results in explicit APIs for use\n      by other building blocks or by the protocol\
    \ client.\"\n   Building blocks are generally specified in terms of the set of\n\
    \   algorithms and packet formats that implement protocol functional\n   components.\
    \  A building block may also have API's through which it\n   communicates to applications\
    \ and/or other building blocks.  Most\n   building blocks should also have a management\
    \ API, through which it\n   communicates to SNMP and/or other management protocols.\n\
    \   In the following section we will list a number of building blocks\n   which,\
    \ at this stage, seem to cover most of the functional components\n   needed to\
    \ implement the protocol families presented in section 1.1.\n   Nevertheless this\
    \ list represents the \"best current guess\", and as\n   such it is not meant\
    \ to be exhaustive.  The actual building block\n   decomposition, i.e., the division\
    \ of functional components into\n   building blocks, may also have to be revised\
    \ in the future.\n"
- title: 4.1.  NACK-based Reliability
  contents:
  - "4.1.  NACK-based Reliability\n   This building block defines NACK-based loss\
    \ detection/notification\n   and recovery.  The major issues it addresses are\
    \ implosion prevention\n   (suppression) and NACK semantics (i.e., how packets\
    \ to be\n   retransmitted should be specified, both in the case of selective and\n\
    \   FEC loss repair).  Suppression mechanisms to be considered are:\n   o  Multicast\
    \ NACKs\n   o  Unicast NACKs and Multicast confirmation\n   These suppression\
    \ mechanisms primarily need to both minimize delay\n   while also minimizing redundant\
    \ messages.  They may also need to have\n   special weighting to work with Congestion\
    \ Feedback.\n"
- title: 4.2.  FEC coding
  contents:
  - "4.2.  FEC coding\n   This building block is concerned with packet level FEC information\n\
    \   when FEC codes are used either proactively or as repairs in reaction\n   to\
    \ lost packets.  It specifies the FEC codec selection and the FEC\n   packet naming\
    \ (indexing) for both reactive FEC repair and pro-active\n   FEC.\n"
- title: 4.3.  Congestion Control
  contents:
  - "4.3.  Congestion Control\n   There will likely be multiple versions of this building\
    \ block,\n   corresponding to different design policies in addressing congestion\n\
    \   control.  Two main approaches are considered for the time being: a\n   source-based\
    \ rate regulation with a single rate provided to all the\n   receivers in the\
    \ session, and a multiple rate receiver-driven\n   approach with different receivers\
    \ receiving at different rates in the\n   same session.  The multiple rate approach\
    \ may use multiple layers of\n   multicast traffic [VRC98] or router filtering\
    \ of a single layer\n   [LVS99].  The multiple rate approach is most applicable\
    \ for ALC\n   protocols.\n   Both approaches are still in the phase of study,\
    \ however the first\n   seems to be mature enough [HFW99] to allow the standardization\n\
    \   process to begin.\n   At the time of writing this document, a third class\
    \ of congestion\n   control algorithm based on router support is beginning to\
    \ emerge in\n   the IRTF RMRG [LVS99].  This work may lead to the future\n   standardization\
    \ of one or more additional building blocks for\n   congestion control.\n"
- title: 4.4.  Generic Router Support
  contents:
  - "4.4.  Generic Router Support\n   The task of designing RM protocols can be made\
    \ much easier by the\n   presence of some specific support in routers.  In some\
    \ application-\n   specific cases, the increased benefits afforded by the addition\
    \ of\n   special router support can justify the resulting additional\n   complexity\
    \ and expense [FLST98].\n   Functional components which can take advantage of\
    \ router support\n   include feedback aggregation/suppression (both for loss notification\n\
    \   and congestion control) and constrained retransmission of repair\n   packets.\
    \  Another component that can take advantage of router support\n   is intentional\
    \ packet filtering to provide different rates of\n   delivery of packets to different\
    \ receivers from the same multicast\n   packet stream.  This could be most advantageous\
    \ when combined with\n   ALC protocols [LVS99].\n   The process of designing and\
    \ deploying these mechanisms inside\n   routers can be much slower than the one\
    \ required for end-host\n   protocol mechanisms.  Therefore, it would be highly\
    \ advantageous to\n   define these mechanisms in a generic way that multiple protocols\
    \ can\n   use if it is available, but do not necessarily need to depend on.\n\
    \   This component has two halves, a signaling protocol and actual router\n  \
    \ algorithms.  The signaling protocol allows the transport protocol to\n   request\
    \ from the router the functions that it wishes to perform, and\n   the router\
    \ algorithms actually perform these functions.  It is more\n   urgent to define\
    \ the signaling protocol, since it will likely impact\n   the common case protocol\
    \ headers.\n   An important component of the signaling protocol is some level\
    \ of\n   commonality between the packet headers of multiple protocols, which\n\
    \   allows the router to recognize and interpret the headers.\n"
- title: 4.5.  Tree Configuration
  contents:
  - "4.5.  Tree Configuration\n   It has been shown that the scalability of RM protocols\
    \ can be greatly\n   enhanced by the insertion of some kind of retransmission\
    \ or feedback\n   aggregation agents between the source and receivers.  These\
    \ agents\n   are then used to form a tree with the source at (or near) the root,\n\
    \   the receivers at the leaves of the tree, and the aggregation/local\n   repair\
    \ nodes in the middle.  The internal nodes can either be\n   dedicated software\
    \ for this task, or they may be receivers that are\n   performing dual duty.\n\
    \   The effectiveness of these agents to assist in the delivery of data\n   is\
    \ highly dependent upon how well the logical tree they use to\n   communicate\
    \ matches the underlying routing topology.  The purpose of\n   this building block\
    \ would be to construct and manage the logical tree\n   connecting the agents.\
    \  Ideally, this building block would perform\n   these functions in a manner\
    \ that adapts to changes in session\n   membership, routing topology, and network\
    \ availability.\n"
- title: 4.6.  Data Security
  contents:
  - "4.6.  Data Security\n   At the time of writing, the security issues are the subject\
    \ of\n   research within the IRTF Secure Multicast Group (SMuG).  Solutions\n\
    \   for these requirements will be standardized within the IETF when\n   ready.\n"
- title: 4.7.  Common Headers
  contents:
  - "4.7.  Common Headers\n   As pointed out in the generic router support section,\
    \ it is important\n   to have some level of commonality across packet headers.\
    \  It may also\n   be useful to have common data header formats for other reasons.\
    \  This\n   building block would consist of recommendations on fields in their\n\
    \   packet headers that protocols should make common across themselves.\n"
- title: 4.8.  Protocol Cores
  contents:
  - "4.8.  Protocol Cores\n   The above building blocks consist of the functional\
    \ components listed\n   in section 3 that appear to meet the requirements for\
    \ being\n   implemented as building blocks presented in section 2.\n   The other\
    \ functions from section 3, which are not covered above,\n   should be implemented\
    \ as part of \"protocol cores\", specific to each\n   protocol standardized.\n"
- title: 5.  Security Considerations
  contents:
  - "5.  Security Considerations\n   RFC 2357 specifically states that \"reliable\
    \ multicast Internet-Drafts\n   reviewed by the Transport Area Directors must\
    \ explicitly explore the\n   security aspects of the proposed design.\"  Specifically,\
    \ RMT building\n   block works in progress must examine the denial-of-service\
    \ attacks\n   that can be made upon building blocks and affected by building blocks\n\
    \   upon the Internet at large.  This requirement is in addition to any\n   discussions\
    \ regarding data-security, that is the manipulation of or\n   exposure of session\
    \ information to unauthorized receivers.  Readers\n   are referred to section\
    \ 5.e of RFC 2357 for further details.\n"
- title: 6.  IANA Considerations
  contents:
  - "6.  IANA Considerations\n   There will be more than one building block, and possibly\
    \ multiple\n   versions of individual building blocks as their designs are refined.\n\
    \   For this reason, the creation of new building blocks and new building\n  \
    \ block versions will be administered via a building block registry\n   that will\
    \ be administered by IANA.  Initially, this registry will be\n   empty, since\
    \ the building blocks described in sections 4.1 to 4.3 are\n   presented for example\
    \ and design purposes.  The requested IANA\n   building block registry will be\
    \ populated from specifications as they\n   are approved for RFC publication (using\
    \ the \"Specification Required\"\n   policy as described in RFC 2434 [RFC2434]).\
    \  A registration will\n   consist of a building block name, a version number,\
    \ a brief text\n   description, a specification RFC number, and a responsible\
    \ person, to\n   which IANA will assign the type number.\n"
- title: 7.  Conclusions
  contents:
  - "7.  Conclusions\n   In this document, we briefly described a number of building\
    \ blocks\n   that may be used for the generation of reliable multicast protocols\n\
    \   to be used in the application space of one-to-many reliable bulk-data\n  \
    \ transfer.  The list of building blocks presented was derived from\n   considering\
    \ the functions that a protocol in this space must perform\n   and how these functions\
    \ should be grouped.  This list is not intended\n   to be all-inclusive but instead\
    \ to act as guide as to which building\n   blocks are considered during the standardization\
    \ process within the\n   Reliable Multicast Transport WG.\n"
- title: 8.  Acknowledgements
  contents:
  - "8.  Acknowledgements\n   This document represents an overview of a number of\
    \ building blocks\n   for one to many bulk data transfer that may be ready for\n\
    \   standardization within the RMT working group.  The ideas presented\n   are\
    \ not those of the authors, rather they are a summarization of many\n   years\
    \ of research into multicast transport combined with the varied\n   presentations\
    \ and discussions in the IRTF Reliable Multicast Research\n   Group.  Although\
    \ they are too numerous to list here, we thank\n   everyone who has participated\
    \ in these discussions for their\n   contributions.\n"
- title: 9.  References
  contents:
  - "9.  References\n   [BKKKLZ95]  J. Bloemer, M. Kalfane, M. Karpinski, R. Karp,\
    \ M. Luby,\n               D.  Zuckerman, \"An XOR-based Erasure Resilient Coding\n\
    \               Scheme,\" ICSI Technical Report No. TR-95-048, August\n      \
    \         1995.\n   [BLMR98]    J. Byers, M. Luby, M. Mitzenmacher, A. Rege, \"\
    A Digital\n               Fountain Approach to Reliable Distribution of Bulk Data,\"\
    \n               Proc ACM SIGCOMM 98.\n   [FJM95]     S. Floyd, V. Jacobson, S.\
    \ McCanne, \"A Reliable Multicast\n               Framework for Light-weight Sessions\
    \ and Application Level\n               Framing,\" Proc ACM SIGCOMM 95, Aug 1995\
    \ pp. 342-356.\n   [FLST98]    D. Farinacci, S. Lin, T. Speakman, and A. Tweedly,\
    \ \"PGM\n               reliable transport protocol specification,\" Work in\n\
    \               Progress.\n   [HFW99]     M. Handley, S. Floyd, B. Whetten, \"\
    Strawman Specification\n               for TCP Friendly (Reliable) Multicast Congestion\
    \ Control\n               (TFMCC),\" Work in Progress.\n   [HJ98]      Handley,\
    \ M. and V. Jacobson, \"SDP: Session Description\n               Protocol\", RFC\
    \ 2327, April 1998.\n   [HPW99]     M. Handley, C. Perkins, E. Whelan, \"Session\
    \ Announcement\n               Protocol,\" Work in Progress, June 1999.\n   [HW99]\
    \      T. Hardjorno, B. Whetten,  \"Security Requirements for\n              \
    \ RMTP-II,\" Work in Progress, June 1999.\n   [RFC2887]   Handley, M., Whetten,\
    \ B., Kermode, R., Floyd, S.,\n               Vicisano, L. and M. Luby, \"The\
    \ Reliable Multicast Design\n               Space for Bulk Data Transfer\", RFC\
    \ 2887, August 2000.\n   [KCW98]     M. Kadansky, D. Chiu, and J. Wesley, \"Tree-based\
    \ reliable\n               multicast (TRAM),\" Work in Progress.\n   [Kermode98]\
    \ R. Kermode, \"Scoped Hybrid Automatic Repeat Request with\n               Forward\
    \ Error Correction,\" Proc ACM SIGCOMM 98, Sept\n               1998.\n   [LDW98]\
    \     M. Lucas, B. Dempsey, A. Weaver, \"MESH: Distributed Error\n           \
    \    Recovery for Multimedia Streams in Wide-Area Multicast\n               Networks\"\
    .\n   [LESZ97]    C-G. Liu, D. Estrin, S. Shenkar, L. Zhang, \"Local Error\n \
    \              Recovery in SRM: Comparison of Two Approaches,\" USC\n        \
    \       Technical Report 97-648, Jan 1997.\n   [LG97]      B.N. Levine, J.J. Garcua-Luna-Aceves,\
    \ \"Improving Internet\n               Multicast Routing with Routing Labels,\"\
    \ IEEE\n               International Conference on Network Protocols (ICNP-97),\n\
    \               Oct 28-31, 1997, p.241-250.\n   [LP96]      K. Lin and S. Paul.\
    \ \"RMTP: A Reliable Multicast Transport\n               Protocol,\" IEEE INFOCOMM\
    \ 1996, March 1996, pp. 1414-1424.\n   [LMSSS97]   M. Luby, M. Mitzenmacher, A.\
    \ Shokrollahi, D. Spielman, V.\n               Stemann, \"Practical Loss-Resilient\
    \ Codes\", Proc ACM\n               Symposium on Theory of Computing, 1997.\n\
    \   [LVS99]     M. Luby, L. Vicisano, T. Speakman. \"Heterogeneous\n         \
    \      multicast congestion control based on router packet\n               filtering\"\
    , RMT working group, June 1999, Pisa, Italy.\n   [MA99]      J. Macker, B. Adamson.\
    \ \"Multicast Dissemination Protocol\n               version 2 (MDPv2),\" Work\
    \ in Progress,\n               http://manimac.itd.nrl.navy.mil/MDP\n   [MRBP98]\
    \    Mankin, A., Romanow, A., Brander, S. and V.Paxson, \"IETF\n             \
    \  Criteria for Evaluating Reliable Multicast Transport and\n               Application\
    \ Protocols\", RFC 2357, June 1998.\n   [RFC2434]   Narten, T. and H. Alvestrand,\
    \ \"Guidelines for Writing an\n               IANA Considerations Section in RFCs\"\
    , BCP 26, RFC 2434,\n               October 1998.\n   [OXB99]     O. Ozkasap,\
    \ Z. Xiao, K. Birman.  \"Scalability of Two\n               Reliable Multicast\
    \ Protocols\", Work in Progress, May\n               1999.\n   [PSLB97]    \"\
    Reliable Multicast Transport Protocol (RMTP),\" S. Paul,\n               K. K.\
    \ Sabnani, J. C. Lin, and S. Bhattacharyya, IEEE\n               Journal on Selected\
    \ Areas in Communications, Vol. 15, No.\n               3, April 1997.\n   [RV97]\
    \      L. Rizzo, L. Vicisano, \"A Reliable Multicast Data\n               Distribution\
    \ Protocol Based on Software FEC Techniques,\"\n               Proc. of The Fourth\
    \ IEEE Workshop on the Architecture and\n               Implementation of High\
    \ Performance Communication Systems\n               (HPCS'97), Sani Beach, Chalkidiki,\
    \ Greece June 23-25,\n               1997.\n   [VRC98]     L. Vicisano, L. Rizzo,\
    \ J. Crowcroft, \"TCP-Like Congestion\n               Control for Layered Multicast\
    \ Data Transfer\", Proc. of\n               IEEE Infocom'98, March 1998.\n   [WBPM98]\
    \    B. Whetten, M. Basavaiah, S. Paul, T. Montgomery, N.\n               Rastogi,\
    \ J. Conlan, and T. Yeh, \"THE RMTP-II PROTOCOL,\"\n               Work in Progress.\n\
    \   [WHA98]     D. Wallner, E. Hardler, R. Agee, \"Key Management for\n      \
    \         Multicast: Issues and Architectures,\" Work in Progress.\n   [Whetten99]\
    \ B. Whetten,  \"A Proposal for Reliable Multicast\n               Congestion\
    \ Control Requirements,\" Work in Progress.\n               http://www.talarian.com/rmtp-ii/overview.htm\n"
- title: 10.  Authors' Addresses
  contents:
  - "10.  Authors' Addresses\n   Brian Whetten\n   Talarian Corporation,\n   333 Distel\
    \ Circle,\n   Los Altos, CA 94022, USA\n   EMail: whetten@talarian.com\n   Lorenzo\
    \ Vicisano\n   Cisco Systems,\n   170 West Tasman Dr.\n   San Jose, CA 95134,\
    \ USA\n   EMail: lorenzo@cisco.com\n   Roger Kermode\n   Motorola Australian Research\
    \ Centre\n   Level 3, 12 Lord St,\n   Botany  NSW  2019, Australia\n   EMail:\
    \ Roger.Kermode@motorola.com\n   Mark Handley, Sally Floyd\n   ATT Center for\
    \ Internet Research at ICSI,\n   International Computer Science Institute,\n \
    \  1947 Center Street, Suite 600,\n   Berkeley, CA 94704, USA\n   EMail: mjh@aciri.org,\
    \ floyd@aciri.org\n   Michael Luby\n   600 Alabama Street\n   San Francisco, CA\
    \  94110\n   Digital Fountain, Inc.\n   EMail: luby@digitalfountain.com\n"
- title: 11.  Full Copyright Statement
  contents:
  - "11.  Full Copyright Statement\n   Copyright (C) The Internet Society (2001).\
    \  All Rights Reserved.\n   This document and translations of it may be copied\
    \ and furnished to\n   others, and derivative works that comment on or otherwise\
    \ explain it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
