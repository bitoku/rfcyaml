- title: __initial_text__
  contents:
  - '          Terminology Used in Internationalization in the IETF

    '
- title: Abstract
  contents:
  - "Abstract\n   This document provides a list of terms used in the IETF when\n \
    \  discussing internationalization.  The purpose is to help frame\n   discussions\
    \ of internationalization in the various areas of the IETF\n   and to help introduce\
    \ the main concepts to IETF participants.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo documents an Internet Best Current Practice.\n\
    \   This document is a product of the Internet Engineering Task Force\n   (IETF).\
    \  It represents the consensus of the IETF community.  It has\n   received public\
    \ review and has been approved for publication by the\n   Internet Engineering\
    \ Steering Group (IESG).  Further information on\n   BCPs is available in Section\
    \ 2 of RFC 5741.\n   Information about the current status of this document, any\
    \ errata,\n   and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6365.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2011 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .\
    \ . . . . . .  3\n     1.1.  Purpose of this Document . . . . . . . . . . . .\
    \ . . . . .  3\n     1.2.  Format of the Definitions in This Document . . . .\
    \ . . . .  4\n     1.3.  Normative Terminology  . . . . . . . . . . . . . . .\
    \ . . .  4\n   2.  Fundamental Terms  . . . . . . . . . . . . . . . . . . . .\
    \ . .  5\n   3.  Standards Bodies and Standards . . . . . . . . . . . . . . .\
    \ . 10\n     3.1.  Standards Bodies . . . . . . . . . . . . . . . . . . . . .\
    \ 11\n     3.2.  Encodings and Transformation Formats of ISO/IEC 10646  . . 13\n\
    \     3.3.  Native CCSs and Charsets . . . . . . . . . . . . . . . . . 15\n  \
    \ 4.  Character Issues . . . . . . . . . . . . . . . . . . . . . . . 16\n    \
    \ 4.1.  Types of Characters  . . . . . . . . . . . . . . . . . . . 20\n     4.2.\
    \  Differentiation of Subsets . . . . . . . . . . . . . . . . 23\n   5.  User\
    \ Interface for Text  . . . . . . . . . . . . . . . . . . . 24\n   6.  Text in\
    \ Current IETF Protocols . . . . . . . . . . . . . . . . 27\n   7.  Terms Associated\
    \ with Internationalized Domain Names . . . . . 31\n     7.1.  IDNA Terminology\
    \ . . . . . . . . . . . . . . . . . . . . . 31\n     7.2.  Character Relationships\
    \ and Variants . . . . . . . . . . . 32\n   8.  Other Common Terms in Internationalization\
    \ . . . . . . . . . . 33\n   9.  Security Considerations  . . . . . . . . . .\
    \ . . . . . . . . . 36\n   10. References . . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . 37\n     10.1. Normative References . . . . . . . . . . . .\
    \ . . . . . . . 37\n     10.2. Informative References . . . . . . . . . . . .\
    \ . . . . . . 37\n   Appendix A.  Additional Interesting Reading  . . . . . .\
    \ . . . . . 41\n   Appendix B.  Acknowledgements  . . . . . . . . . . . . . .\
    \ . . . . 42\n   Appendix C.  Significant Changes from RFC 3536 . . . . . . .\
    \ . . . 42\n   Index  . . . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . 43\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   As the IETF Character Set Policy specification [RFC2277]\
    \ summarizes:\n   \"Internationalization is for humans.  This means that protocols\
    \ are\n   not subject to internationalization; text strings are.\"  Many\n   protocols\
    \ throughout the IETF use text strings that are entered by,\n   or are visible\
    \ to, humans.  Subject only to the limitations of their\n   own knowledge and\
    \ facilities, it should be possible for anyone to\n   enter or read these text\
    \ strings, which means that Internet users\n   must be able to enter text using\
    \ typical input methods and have it be\n   displayed in any human language.  Further,\
    \ text containing any\n   character should be able to be passed between Internet\
    \ applications\n   easily.  This is the challenge of internationalization.\n"
- title: 1.1.  Purpose of this Document
  contents:
  - "1.1.  Purpose of this Document\n   This document provides a glossary of terms\
    \ used in the IETF when\n   discussing internationalization.  The purpose is to\
    \ help frame\n   discussions of internationalization in the various areas of the\
    \ IETF\n   and to help introduce the main concepts to IETF participants.\n   Internationalization\
    \ is discussed in many working groups of the IETF.\n   However, few working groups\
    \ have internationalization experts.  When\n   designing or updating protocols,\
    \ the question often comes up \"Should\n   we internationalize this?\" (or, more\
    \ likely, \"Do we have to\n   internationalize this?\").\n   This document gives\
    \ an overview of internationalization terminology\n   as it applies to IETF standards\
    \ work by lightly covering the many\n   aspects of internationalization and the\
    \ vocabulary associated with\n   those topics.  Some of the overview is somewhat\
    \ tutorial in nature.\n   It is not meant to be a complete description of internationalization.\n\
    \   The definitions here SHOULD be used by IETF standards.  IETF\n   standards\
    \ that explicitly want to create different definitions for\n   the terms defined\
    \ here can do so, but unless an alternate definition\n   is provided the definitions\
    \ of the terms in this document apply.\n   IETF standards that have a requirement\
    \ for different definitions are\n   encouraged, for clarity's sake, to find terms\
    \ different than the ones\n   defined here.  Some of the definitions in this document\
    \ come from\n   earlier IETF documents and books.\n   As in many fields, there\
    \ is disagreement in the internationalization\n   community on definitions for\
    \ many words.  The topic of language\n   brings up particularly passionate opinions\
    \ for experts and non-\n   experts alike.  This document attempts to define terms\
    \ in a way that\n   will be most useful to the IETF audience.\n   This document\
    \ uses definitions from many documents that have been\n   developed inside and\
    \ outside the IETF.  The primary documents used\n   are:\n   o  ISO/IEC 10646\
    \ [ISOIEC10646]\n   o  The Unicode Standard [UNICODE]\n   o  W3C Character Model\
    \ [CHARMOD]\n   o  IETF RFCs, including the Character Set Policy specification\n\
    \      [RFC2277] and the domain name internationalization standard\n      [RFC5890]\n"
- title: 1.2.  Format of the Definitions in This Document
  contents:
  - "1.2.  Format of the Definitions in This Document\n   In the body of this document,\
    \ the source for the definition is shown\n   in angle brackets, such as \"<ISOIEC10646>\"\
    .  Many definitions are\n   shown as \"<RFC6365>\", which means that the definitions\
    \ were crafted\n   originally for this document.  The angle bracket notation for\
    \ the\n   source of definitions is different than the square bracket notation\n\
    \   used for references to documents, such as in the paragraph above;\n   these\
    \ references are given in the reference sections of this\n   document.\n   For\
    \ some terms, there are commentary and examples after the\n   definitions.  In\
    \ those cases, the part before the angle brackets is\n   the definition that comes\
    \ from the original source, and the part\n   after the angle brackets is commentary\
    \ that is not a definition (such\n   as an example or further exposition).\n \
    \  Examples in this document use the notation for code points and names\n   from\
    \ the Unicode Standard [UNICODE] and ISO/IEC 10646 [ISOIEC10646].\n   For example,\
    \ the letter \"a\" may be represented as either \"U+0061\" or\n   \"LATIN SMALL\
    \ LETTER A\".  See RFC 5137 [RFC5137] for a description of\n   this notation.\n"
- title: 1.3.  Normative Terminology
  contents:
  - "1.3.  Normative Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\"\
    , \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"\
    MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted as described\
    \ in RFC 2119 [RFC2119].\n"
- title: 2.  Fundamental Terms
  contents:
  - "2.  Fundamental Terms\n   This section covers basic topics that are needed for\
    \ almost anyone\n   who is involved with making IETF protocols more friendly to\
    \ non-ASCII\n   text (see Section 4.2) and with other aspects of\n   internationalization.\n\
    \   language\n      A language is a way that humans communicate.  The use of language\n\
    \      occurs in many forms, the most common of which are speech,\n      writing,\
    \ and signing. <RFC6365>\n      Some languages have a close relationship between\
    \ the written and\n      spoken forms, while others have a looser relationship.\
    \  The so-\n      called LTRU (Language Tag Registry Update) standards [RFC5646]\n\
    \      [RFC4647] discuss languages in more detail and provide identifiers\n  \
    \    for languages for use in Internet protocols.  Note that computer\n      languages\
    \ are explicitly excluded from this definition.\n   script\n      A set of graphic\
    \ characters used for the written form of one or\n      more languages. <ISOIEC10646>\n\
    \      Examples of scripts are Latin, Cyrillic, Greek, Arabic, and Han\n     \
    \ (the characters, often called ideographs after a subset of them,\n      used\
    \ in writing Chinese, Japanese, and Korean).  RFC 2277\n      discusses scripts\
    \ in detail.\n      It is common for internationalization novices to mix up the\
    \ terms\n      \"language\" and \"script\".  This can be a problem in protocols\
    \ that\n      differentiate the two.  Almost all protocols that are designed (or\n\
    \      were re-designed) to handle non-ASCII text deal with scripts (the\n   \
    \   written systems) or characters, while fewer actually deal with\n      languages.\n\
    \      A single name can mean either a language or a script; for example,\n  \
    \    \"Arabic\" is both the name of a language and the name of a script.\n   \
    \   In fact, many scripts borrow their names from the names of\n      languages.\
    \  Further, many scripts are used to write more than one\n      language; for\
    \ example, the Russian and Bulgarian languages are\n      written in the Cyrillic\
    \ script.  Some languages can be expressed\n      using different scripts or were\
    \ used with different scripts at\n      different times; the Mongolian language\
    \ can be written in either\n      the Mongolian or Cyrillic scripts; Malay is\
    \ primarily written in\n      Latin script today, but the earlier, Arabic-script-based,\
    \ Jawa\n      form is still in use; and a number of languages were converted\n\
    \      from other scripts to Cyrillic in the first half of the last\n      century,\
    \ some of which have switched again more recently.\n      Further, some languages\
    \ are normally expressed with more than one\n      script at the same time; for\
    \ example, the Japanese language is\n      normally expressed in the Kanji (Han),\
    \ Katakana, and Hiragana\n      scripts in a single string of text.\n   writing\
    \ system\n      A set of rules for using one or more scripts to write a particular\n\
    \      language.  Examples include the American English writing system,\n    \
    \  the British English writing system, the French writing system, and\n      the\
    \ Japanese writing system. <UNICODE>\n   character\n      A member of a set of\
    \ elements used for the organization, control,\n      or representation of data.\
    \ <ISOIEC10646>\n      There are at least three common definitions of the word\n\
    \      \"character\":\n      *  a general description of a text entity\n     \
    \ *  a unit of a writing system, often synonymous with \"letter\" or\n       \
    \  similar terms, but generalized to include digits and symbols of\n         various\
    \ sorts\n      *  the encoded entity itself\n      When people talk about characters,\
    \ they usually intend one of the\n      first two definitions.  The term \"character\"\
    \ is often abbreviated\n      as \"char\".\n      A particular character is identified\
    \ by its name, not by its\n      shape.  A name may suggest a meaning, but the\
    \ character may be\n      used for representing other meanings as well.  A name\
    \ may suggest\n      a shape, but that does not imply that only that shape is\
    \ commonly\n      used in print, nor that the particular shape is associated only\n\
    \      with that name.\n   coded character\n      A character together with its\
    \ coded representation. <ISOIEC10646>\n   coded character set\n      A coded character\
    \ set (CCS) is a set of unambiguous rules that\n      establishes a character\
    \ set and the relationship between the\n      characters of the set and their\
    \ coded representation.\n      <ISOIEC10646>\n   character encoding form\n   \
    \   A character encoding form is a mapping from a coded character set\n      (CCS)\
    \ to the actual code units used to represent the data.\n      <UNICODE>\n   repertoire\n\
    \      The collection of characters included in a character set.  Also\n     \
    \ called a character repertoire. <UNICODE>\n   glyph\n      A glyph is an image\
    \ of a character that can be displayed after\n      being imaged onto a display\
    \ surface. <RFC6365>\n      The Unicode Standard has a different definition that\
    \ refers to an\n      abstract form that may represent different images when the\
    \ same\n      character is rendered under different circumstances.\n   glyph code\n\
    \      A glyph code is a numeric code that refers to a glyph.  Usually,\n    \
    \  the glyphs contained in a font are referenced by their glyph code.\n      Glyph\
    \ codes are local to a particular font; that is, a different\n      font containing\
    \ the same glyphs may use different codes. <UNICODE>\n   transcoding\n      Transcoding\
    \ is the process of converting text data from one\n      character encoding form\
    \ to another.  Transcoders work only at the\n      level of character encoding\
    \ and do not parse the text.  Note:\n      Transcoding may involve one-to-one,\
    \ many-to-one, one-to-many, or\n      many-to-many mappings.  Because some legacy\
    \ mappings are glyphic,\n      they may not only be many-to-many, but also unordered:\
    \ thus XYZ\n      may map to yxz. <CHARMOD>\n      In this definition, \"many-to-one\"\
    \ means a sequence of characters\n      mapped to a single character.  The \"\
    many\" does not mean\n      alternative characters that map to the single character.\n\
    \   character encoding scheme\n      A character encoding scheme (CES) is a character\
    \ encoding form\n      plus byte serialization.  There are many character encoding\n\
    \      schemes in Unicode, such as UTF-8 and UTF-16BE. <UNICODE>\n      Some CESs\
    \ are associated with a single CCS; for example, UTF-8\n      [RFC3629] applies\
    \ only to the identical CCSs of ISO/IEC 10646 and\n      Unicode.  Other CESs,\
    \ such as ISO 2022, are associated with many\n      CCSs.\n   charset\n      A\
    \ charset is a method of mapping a sequence of octets to a\n      sequence of\
    \ abstract characters.  A charset is, in effect, a\n      combination of one or\
    \ more CCSs with a CES.  Charset names are\n      registered by the IANA according\
    \ to procedures documented in\n      [RFC2978]. <RFC6365>\n      Many protocol\
    \ definitions use the term \"character set\" in their\n      descriptions.  The\
    \ terms \"charset\", or \"character encoding scheme\"\n      and \"coded character\
    \ set\", are strongly preferred over the term\n      \"character set\" because\
    \ \"character set\" has other definitions in\n      other contexts, particularly\
    \ outside the IETF.  When reading IETF\n      standards that use \"character set\"\
    \ without defining the term, they\n      usually mean \"a specific combination\
    \ of one CCS with a CES\",\n      particularly when they are talking about the\
    \ \"US-ASCII character\n      set\".\n   internationalization\n      In the IETF,\
    \ \"internationalization\" means to add or improve the\n      handling of non-ASCII\
    \ text in a protocol. <RFC6365>  A different\n      perspective, more appropriate\
    \ to protocols that are designed for\n      global use from the beginning, is\
    \ the definition used by W3C:\n         \"Internationalization is the design and\
    \ development of a\n         product, application or document content that enables\
    \ easy\n         localization for target audiences that vary in culture, region,\n\
    \         or language.\"  [W3C-i18n-Def]\n      Many protocols that handle text\
    \ only handle one charset\n      (US-ASCII), or leave the question of what CCS\
    \ and encoding are\n      used up to local guesswork (which leads, of course,\
    \ to\n      interoperability problems).  If multiple charsets are permitted,\n\
    \      they must be explicitly identified [RFC2277].  Adding non-ASCII\n     \
    \ text to a protocol allows the protocol to handle more scripts,\n      hopefully\
    \ all of the ones useful in the world.  In today's world,\n      that is normally\
    \ best accomplished by allowing Unicode encoded in\n      UTF-8 only, thereby\
    \ shifting conversion issues away from\n      individual choices.\n   localization\n\
    \      The process of adapting an internationalized application platform\n   \
    \   or application to a specific cultural environment.  In\n      localization,\
    \ the same semantics are preserved while the syntax\n      may be changed.  [FRAMEWORK]\n\
    \      Localization is the act of tailoring an application for a\n      different\
    \ language or script or culture.  Some internationalized\n      applications can\
    \ handle a wide variety of languages.  Typical\n      users only understand a\
    \ small number of languages, so the program\n      must be tailored to interact\
    \ with users in just the languages they\n      know.\n      The major work of\
    \ localization is translating the user interface\n      and documentation.  Localization\
    \ involves not only changing the\n      language interaction, but also other relevant\
    \ changes such as\n      display of numbers, dates, currency, and so on.  The\
    \ better\n      internationalized an application is, the easier it is to localize\n\
    \      it for a particular language and character encoding scheme.\n      Localization\
    \ is rarely an IETF matter, and protocols that are\n      merely localized, even\
    \ if they are serially localized for several\n      locations, are generally considered\
    \ unsatisfactory for the global\n      Internet.\n      Do not confuse \"localization\"\
    \ with \"locale\", which is described in\n      Section 8 of this document.\n\
    \   i18n, l10n\n      These are abbreviations for \"internationalization\" and\n\
    \      \"localization\". <RFC6365>\n      \"18\" is the number of characters between\
    \ the \"i\" and the \"n\" in\n      \"internationalization\", and \"10\" is the\
    \ number of characters\n      between the \"l\" and the \"n\" in \"localization\"\
    .\n   multilingual\n      The term \"multilingual\" has many widely varying definitions\
    \ and\n      thus is not recommended for use in standards.  Some of the\n    \
    \  definitions relate to the ability to handle international\n      characters;\
    \ other definitions relate to the ability to handle\n      multiple charsets;\
    \ and still others relate to the ability to\n      handle multiple languages.\
    \ <RFC6365>\n   displaying and rendering text\n      To display text, a system\
    \ puts characters on a visual display\n      device such as a screen or a printer.\
    \  To render text, a system\n      analyzes the character input to determine how\
    \ to display the text.\n      The terms \"display\" and \"render\" are sometimes\
    \ used\n      interchangeably.  Note, however, that text might be rendered as\n\
    \      audio and/or tactile output, such as in systems that have been\n      designed\
    \ for people with visual disabilities. <RFC6365>\n      Combining characters modify\
    \ the display of the character (or, in\n      some cases, characters) that precede\
    \ them.  When rendering such\n      text, the display engine must either find\
    \ the glyph in the font\n      that represents the base character and all of the\
    \ combining\n      characters, or it must render the combination itself.  Such\n\
    \      rendering can be straightforward, but it is sometimes complicated\n   \
    \   when the combining marks interact with each other, such as when\n      there\
    \ are two combining marks that would appear above the same\n      character. \
    \ Formatting characters can also change the way that a\n      renderer would display\
    \ text.  Rendering can also be difficult for\n      some scripts that have complex\
    \ display rules for base characters,\n      such as Arabic and Indic scripts.\n"
- title: 3.  Standards Bodies and Standards
  contents:
  - "3.  Standards Bodies and Standards\n   This section describes some of the standards\
    \ bodies and standards\n   that appear in discussions of internationalization\
    \ in the IETF.  This\n   is an incomplete and possibly over-full list; listing\
    \ too few bodies\n   or standards can be just as politically dangerous as listing\
    \ too\n   many.  Note that there are many other bodies that deal with\n   internationalization;\
    \ however, few if any of them appear commonly in\n   IETF standards work.\n"
- title: 3.1.  Standards Bodies
  contents:
  - "3.1.  Standards Bodies\n   ISO and ISO/IEC JTC 1\n      The International Organization\
    \ for Standardization has been\n      involved with standards for characters since\
    \ before the IETF was\n      started.  ISO is a non-governmental group made up\
    \ of national\n      bodies.  Most of ISO's work in information technology is\
    \ performed\n      jointly with a similar body, the International Electrotechnical\n\
    \      Commission (IEC) through a joint committee known as \"JTC 1\".  ISO\n \
    \     and ISO/IEC JTC 1 have many diverse standards in the international\n   \
    \   characters area; the one that is most used in the IETF is commonly\n     \
    \ referred to as \"ISO/IEC 10646\", sometimes with a specific date.\n      ISO/IEC\
    \ 10646 describes a CCS that covers almost all known written\n      characters\
    \ in use today.\n      ISO/IEC 10646 is controlled by the group known as \"ISO/IEC\
    \ JTC 1/\n      SC 2 WG2\", often called \"SC2/WG2\" or \"WG2\" for short.  ISO\n\
    \      standards go through many steps before being finished, and years\n    \
    \  often go by between changes to the base ISO/IEC 10646 standard\n      although\
    \ amendments are now issued to track Unicode changes.\n      Information on WG2,\
    \ and its work products, can be found at\n      <http://www.dkuug.dk/JTC1/SC2/WG2/>.\
    \  Information on SC2, and its\n      work products, can be found at <http://www.iso.org/iso/\n\
    \      standards_development/technical_committees/\n      list_of_iso_technical_committees/\n\
    \      iso_technical_committee.htm?commid=45050>\n      The standard comes as\
    \ a base part and a series of attachments or\n      amendments.  It is available\
    \ in PDF form for downloading or in a\n      CD-ROM version.  One example of how\
    \ to cite the standard is given\n      in [RFC3629].  Any standard that cites\
    \ ISO/IEC 10646 needs to\n      evaluate how to handle the versioning problem\
    \ that is relevant to\n      the protocol's needs.\n      ISO is responsible for\
    \ other standards that might be of interest\n      to protocol developers concerned\
    \ about internationalization.\n      ISO 639 [ISO639] specifies the names of languages\
    \ and forms part\n      of the basis for the IETF's Language Tag work [RFC5646].\
    \  ISO 3166\n      [ISO3166] specifies the names and code abbreviations for countries\n\
    \      and territories and is used in several protocols and databases\n      including\
    \ names for country-code top level domain names.  The\n      responsibilities\
    \ of ISO TC 46 on Information and Documentation\n      <http://www.iso.org/iso/standards_development/\n\
    \      technical_committees/list_of_iso_technical_committees/\n      iso_technical_committee.htm?commid=48750>\
    \ include a series of\n      standards for transliteration of various languages\
    \ into Latin\n      characters.\n      Another relevant ISO group was JTC 1/SC22/WG20,\
    \ which was\n      responsible for internationalization in JTC 1, such as for\n\
    \      international string ordering.  Information on WG20, and its work\n   \
    \   products, can be found at <http://www.dkuug.dk/jtc1/sc22/wg20/>.\n      The\
    \ specific tasks of SC22/WG20 were moved from SC22 into SC2, and\n      there\
    \ has been little significant activity since that occurred.\n   Unicode Consortium\n\
    \      The second important group for international character standards\n    \
    \  is the Unicode Consortium.  The Unicode Consortium is a trade\n      association\
    \ of companies, governments, and other groups interested\n      in promoting the\
    \ Unicode Standard [UNICODE].  The Unicode Standard\n      is a CCS whose repertoire\
    \ and code points are identical to\n      ISO/IEC 10646.  The Unicode Consortium\
    \ has added features to the\n      base CCS that make it more useful in protocols,\
    \ such as defining\n      attributes for each character.  Examples of these attributes\n\
    \      include case conversion and numeric properties.\n      The actual technical\
    \ and definitional work of the Unicode\n      Consortium is done in the Unicode\
    \ Technical Committee (UTC).  The\n      terms \"UTC\" and \"Unicode Consortium\"\
    \ are often treated,\n      imprecisely, as synonymous in the IETF.\n      The\
    \ Unicode Consortium publishes addenda to the Unicode Standard\n      as Unicode\
    \ Technical Reports.  There are many types of technical\n      reports at various\
    \ stages of maturity.  The Unicode Standard and\n      affiliated technical reports\
    \ can be found at\n      <http://www.unicode.org/>.\n      A reciprocal agreement\
    \ between the Unicode Consortium and\n      ISO/IEC JTC 1/SC 2 provides for ISO/IEC\
    \ 10646 and The Unicode\n      Standard to track each other for definitions of\
    \ characters and\n      assignments of code points.  Updates, often in the form\
    \ of\n      amendments, to the former sometimes lag updates to the latter for\n\
    \      a short period, but the gap has rarely been significant in recent\n   \
    \   years.\n      At the time that the IETF character set policy [RFC2277] was\n\
    \      established and the first version of this terminology\n      specification\
    \ was published, there was a strong preference in the\n      IETF community for\
    \ references to ISO/IEC 10646 (rather than\n      Unicode) when possible.  That\
    \ preference largely reflected a more\n      general IETF preference for referencing\
    \ established open\n      international standards over specifications from consortia.\n\
    \      However, the Unicode definitions of character properties and\n      classes\
    \ are not part of ISO/IEC 10646.  Because IETF\n      specifications are increasingly\
    \ dependent on those definitions\n      (for example, see the explanation in Section\
    \ 4.2) and the Unicode\n      specifications are freely available online in convenient\
    \ machine-\n      readable form, the IETF's preference has shifted to referencing\n\
    \      the Unicode Standard.  The latter is especially important when\n      version\
    \ consistency between code points (either standard) and\n      Unicode properties\
    \ (Unicode only) is required.\n   World Wide Web Consortium (W3C)\n      This\
    \ group created and maintains the standard for XML, the markup\n      language\
    \ for text that has become very popular.  XML has always\n      been fully internationalized\
    \ so that there is no need for a new\n      version to handle international text.\
    \  However, in some\n      circumstances, XML files may be sensitive to differences\
    \ among\n      Unicode versions.\n   local and regional standards organizations\n\
    \      Just as there are many native CCSs and charsets, there are many\n     \
    \ local and regional standards organizations to create and support\n      them.\
    \  Common examples of these are ANSI (United States), CEN/ISSS\n      (Europe),\
    \ JIS (Japan), and SAC (China).\n"
- title: 3.2.  Encodings and Transformation Formats of ISO/IEC 10646
  contents:
  - "3.2.  Encodings and Transformation Formats of ISO/IEC 10646\n   Characters in\
    \ the ISO/IEC 10646 CCS can be expressed in many ways.\n   Historically, \"encoding\
    \ forms\" are both direct addressing methods,\n   while \"transformation formats\"\
    \ are methods for expressing encoding\n   forms as bits on the wire.  That distinction\
    \ has mostly disappeared\n   in recent years.\n   Documents that discuss characters\
    \ in the ISO/IEC 10646 CCS often need\n   to list specific characters.  RFC 5137\
    \ describes the common methods\n   for doing so in IETF documents, and these practices\
    \ have been adopted\n   by many other communities as well.\n   Basic Multilingual\
    \ Plane (BMP)\n      The BMP is composed of the first 2^16 code points in ISO/IEC\
    \ 10646\n      and contains almost all characters in contemporary use.  The BMP\n\
    \      is also called \"Plane 0\".\n   UCS-2 and UCS-4\n      UCS-2 and UCS-4\
    \ are the two encoding forms historically defined\n      for ISO/IEC 10646.  UCS-2\
    \ addresses only the BMP.  Because many\n      useful characters (such as many\
    \ Han characters) have been defined\n      outside of the BMP, many people consider\
    \ UCS-2 to be obsolete.\n      UCS-4 addresses the entire range of code points\
    \ from ISO/IEC 10646\n      (by agreement between ISO/IEC JTC 1 SC2 and the Unicode\n\
    \      Consortium, a range from 0..0x10FFFF) as 32-bit values with zero\n    \
    \  padding to the left.  UCS-4 is identical to UTF-32BE (without use\n      of\
    \ a BOM (see below)); UTF-32BE is now the preferred term.\n   UTF-8\n      UTF-8\
    \ [RFC3629] is the preferred encoding for IETF protocols.\n      Characters in\
    \ the BMP are encoded as one, two, or three octets.\n      Characters outside\
    \ the BMP are encoded as four octets.  Characters\n      from the US-ASCII repertoire\
    \ have the same on-the-wire\n      representation in UTF-8 as they do in US-ASCII.\
    \  The IETF-specific\n      definition of UTF-8 in RFC 3629 is identical to that\
    \ in recent\n      versions of the Unicode Standard (e.g., in Section 3.9 of Version\n\
    \      6.0 [UNICODE]).\n   UTF-16, UTF-16BE, and UTF-16LE\n      UTF-16, UTF-16BE,\
    \ and UTF-16LE, three transformation formats\n      described in [RFC2781] and\
    \ defined in The Unicode Standard\n      (Sections 3.9 and 16.8 of Version 6.0),\
    \ are not required by any\n      IETF standards, and are thus used much less often\
    \ in protocols\n      than UTF-8.  Characters in the BMP are always encoded as\
    \ two\n      octets, and characters outside the BMP are encoded as four octets\n\
    \      using a \"surrogate pair\" arrangement.  The latter is not part of\n  \
    \    UCS-2, marking the difference between UTF-16 and UCS-2.  The three\n    \
    \  UTF-16 formats differ based on the order of the octets and the\n      presence\
    \ or absence of a special lead-in ordering identifier\n      called the \"byte\
    \ order mark\" or \"BOM\".\n   UTF-32\n      The Unicode Consortium and ISO/IEC\
    \ JTC 1 have defined UTF-32 as a\n      transformation format that incorporates\
    \ the integer code point\n      value right-justified in a 32-bit field.  As with\
    \ UTF-16, the byte\n      order mark (BOM) can be used and UTF-32BE and UTF-32LE\
    \ are\n      defined.  UTF-32 and UCS-4 are essentially equivalent and the\n \
    \     terms are often used interchangeably.\n   SCSU and BOCU-1\n      The Unicode\
    \ Consortium has defined an encoding, SCSU [UTR6], which\n      is designed to\
    \ offer good compression for typical text.  A\n      different encoding that is\
    \ meant to be MIME-friendly, BOCU-1, is\n      described in [UTN6].  Although\
    \ compression is attractive, as\n      opposed to UTF-8, neither of these (at\
    \ the time of this writing)\n      has attracted much interest.\n      The compression\
    \ provided as a side effect of the Punycode\n      algorithm [RFC3492] is heavily\
    \ used in some contexts, especially\n      IDNA [RFC5890], but imposes some restrictions.\
    \  (See also\n      Section 7.)\n"
- title: 3.3.  Native CCSs and Charsets
  contents:
  - "3.3.  Native CCSs and Charsets\n   Before ISO/IEC 10646 was developed, many countries\
    \ developed their\n   own CCSs and charsets.  Some of these were adopted into\
    \ international\n   standards for the relevant scripts or writing systems.  Many\
    \ dozen of\n   these are in common use on the Internet today.  Examples include\n\
    \   ISO 8859-5 for Cyrillic and Shift-JIS for Japanese scripts.\n   The official\
    \ list of the registered charset names for use with IETF\n   protocols is maintained\
    \ by IANA and can be found at\n   <http://www.iana.org/assignments/character-sets>.\
    \  The list contains\n   preferred names and aliases.  Note that this list has\
    \ historically\n   contained many errors, such as names that are in fact not charsets\
    \ or\n   references that do not give enough detail to reliably map names to\n\
    \   charsets.\n   Probably the most well-known native CCS is ASCII [US-ASCII].\
    \  This\n   CCS is used as the basis for keywords and parameter names in many\n\
    \   IETF protocols, and as the sole CCS in numerous IETF protocols that\n   have\
    \ not yet been internationalized.  ASCII became the basis for\n   ISO/IEC 646\
    \ which, in turn, formed the basis for many national and\n   international standards,\
    \ such as the ISO 8859 series, that mix Basic\n   Latin characters with characters\
    \ from another script.\n   It is important to note that, strictly speaking, \"\
    ASCII\" is a CCS and\n   repertoire, not an encoding.  The encoding used for ASCII\
    \ in IETF\n   protocols involves the 7-bit integer ASCII code point right-justified\n\
    \   in an 8-bit field and is sometimes described as the \"Network Virtual\n  \
    \ Terminal\" or \"NVT\" encoding [RFC5198].  Less formally, \"ASCII\" and\n  \
    \ \"NVT\" are often used interchangeably.  However, \"non-ASCII\" refers\n   only\
    \ to characters outside the ASCII repertoire and is not linked to\n   a specific\
    \ encoding.  See Section 4.2.\n   A Unicode publication describes issues involved\
    \ in mapping character\n   data between charsets, and an XML format for mapping\
    \ table data\n   [UTR22].\n"
- title: 4.  Character Issues
  contents:
  - "4.  Character Issues\n   This section contains terms and topics that are commonly\
    \ used in\n   character handling and therefore are of concern to people adding\
    \ non-\n   ASCII text handling to protocols.  These topics are standardized\n\
    \   outside the IETF.\n   code point\n      A value in the codespace of a repertoire.\
    \  For all common\n      repertoires developed in recent years, code point values\
    \ are\n      integers (code points for ASCII and its immediate descendants were\n\
    \      defined in terms of column and row positions of a table).\n   combining\
    \ character\n      A member of an identified subset of the coded character set\
    \ of\n      ISO/IEC 10646 intended for combination with the preceding non-\n \
    \     combining graphic character, or with a sequence of combining\n      characters\
    \ preceded by a non-combining character.  Combining\n      characters are inherently\
    \ non-spacing. <ISOIEC10646>\n   composite sequence or combining character sequence\n\
    \      A sequence of graphic characters consisting of a non-combining\n      character\
    \ followed by one or more combining characters.  A graphic\n      symbol for a\
    \ composite sequence generally consists of the\n      combination of the graphic\
    \ symbols of each character in the\n      sequence.  The Unicode Standard often\
    \ uses the term \"combining\n      character sequence\" to refer to composite\
    \ sequences.  A composite\n      sequence is not a character and therefore is\
    \ not a member of the\n      repertoire of ISO/IEC 10646. <ISOIEC10646>  However,\
    \ Unicode now\n      assigns names to some such sequences especially when the\
    \ names are\n      required to match terminology in other standards [UAX34].\n\
    \      In some CCSs, some characters consist of combinations of other\n      characters.\
    \  For example, the letter \"a with acute\" might be a\n      combination of the\
    \ two characters \"a\" and \"combining acute\", or it\n      might be a combination\
    \ of the three characters \"a\", a non-\n      destructive backspace, and an acute.\
    \  In the same or other CCSs,\n      it might be available as a single code point.\
    \  The rules for\n      combining two or more characters are called \"composition\
    \ rules\",\n      and the rules for taking apart a character into other characters\n\
    \      are called \"decomposition rules\".  The result of decomposition is\n \
    \     called a \"decomposed character\"; the result of composition is\n      usually\
    \ a \"precomposed character\".\n   normalization\n      Normalization is the transformation\
    \ of data to a normal form, for\n      example, to unify spelling. <UNICODE>\n\
    \      Note that the phrase \"unify spelling\" in the definition above does\n\
    \      not mean unifying different strings with the same meaning as words\n  \
    \    (such as \"color\" and \"colour\").  Instead, it means unifying\n      different\
    \ character sequences that are intended to form the same\n      composite characters,\
    \ such as \"<n><combining tilde>\" and \"<n with\n      tilde>\" (where \"<n>\"\
    \ is U+006E, \"<combining tilde>\" is U+0303, and\n      \"<n with tilde>\" is\
    \ U+00F1).\n      The purpose of normalization is to allow two strings to be\n\
    \      compared for equivalence.  The strings \"<a><n><combining\n      tilde><o>\"\
    \ and \"<a><n with tilde><o>\" would be shown identically\n      on a text display\
    \ device.  If a protocol designer wants those two\n      strings to be considered\
    \ equivalent during comparison, the\n      protocol must define where normalization\
    \ occurs.\n      The terms \"normalization\" and \"canonicalization\" are often\
    \ used\n      interchangeably.  Generally, they both mean to convert a string\
    \ of\n      one or more characters into another string based on standardized\n\
    \      rules.  However, in Unicode, \"canonicalization\" or similar terms\n  \
    \    are used to refer to a particular type of normalization\n      equivalence\
    \ (\"canonical equivalence\" in contrast to \"compatibility\n      equivalence\"\
    ), so the term should be used with some care.  Some\n      CCSs allow multiple\
    \ equivalent representations for a written\n      string; normalization selects\
    \ one among multiple equivalent\n      representations as a base for reference\
    \ purposes in comparing\n      strings.  In strings of text, these rules are usually\
    \ based on\n      decomposing combined characters or composing characters with\n\
    \      combining characters.  Unicode Standard Annex #15 [UTR15]\n      describes\
    \ the process and many forms of normalization in detail.\n      Normalization\
    \ is important when comparing strings to see if they\n      are the same.\n  \
    \    The Unicode NFC and NFD normalizations support canonical\n      equivalence;\
    \ NFKC and NFKD support canonical and compatibility\n      equivalence.\n   case\n\
    \      Case is the feature of certain alphabets where the letters have\n     \
    \ two (or occasionally more) distinct forms.  These forms, which may\n      differ\
    \ markedly in shape and size, are called the uppercase letter\n      (also known\
    \ as capital or majuscule) and the lowercase letter\n      (also known as small\
    \ or minuscule).  Case mapping is the\n      association of the uppercase and\
    \ lowercase forms of a letter.\n      <UNICODE>\n      There is usually (but not\
    \ always) a one-to-one mapping between the\n      same letter in the two cases.\
    \  However, there are many examples of\n      characters that exist in one case\
    \ but for which there is no\n      corresponding character in the other case or\
    \ for which there is a\n      special mapping rule, such as the Turkish dotless\
    \ \"i\", some Greek\n      characters with modifiers, and characters like the\
    \ German Sharp S\n      (Eszett) and Greek Final Sigma that traditionally do not\
    \ have\n      uppercase forms.  Case mapping can even be dependent on locale or\n\
    \      language.  Converting text to have only a single case, primarily\n    \
    \  for comparison purposes, is called \"case folding\".  Because of the\n    \
    \  various unusual cases, case mapping can be quite controversial and\n      some\
    \ case folding algorithms even more so.  For example, some\n      programming\
    \ languages such as Java have case-folding algorithms\n      that are locale-sensitive;\
    \ this makes those algorithms incredibly\n      resource-intensive and makes them\
    \ act differently depending on the\n      location of the system at the time the\
    \ algorithm is used.\n   sorting and collation\n      Collating is the process\
    \ of ordering units of textual information.\n      Collation is usually specific\
    \ to a particular language or even to\n      a particular application or locale.\
    \  It is sometimes known as\n      alphabetizing, although alphabetization is\
    \ just a special case of\n      sorting and collation. <UNICODE>\n      Collation\
    \ is concerned with the determination of the relative\n      order of any particular\
    \ pair of strings, and algorithms concerned\n      with collation focus on the\
    \ problem of providing appropriate\n      weighted keys for string values, to\
    \ enable binary comparison of\n      the key values to determine the relative\
    \ ordering of the strings.\n      The relative orders of letters in collation\
    \ sequences can differ\n      widely based on the needs of the system or protocol\
    \ defining the\n      collation order.  For example, even within ASCII characters,\
    \ there\n      are two common and very different collation orders: \"A, a, B,\n\
    \      b,...\" and \"A, B, C, ..., Z, a, b,...\", with additional variations\n\
    \      for lowercase first and digits before and after letters.\n      In practice,\
    \ it is rarely necessary to define a collation sequence\n      for characters\
    \ drawn from different scripts, but arranging such\n      sequences so as to not\
    \ surprise users is usually particularly\n      problematic.\n      Sorting is\
    \ the process of actually putting data records into\n      specified orders, according\
    \ to criteria for comparison between the\n      records.  Sorting can apply to\
    \ any kind of data (including textual\n      data) for which an ordering criterion\
    \ can be defined.  Algorithms\n      concerned with sorting focus on the problem\
    \ of performance (in\n      terms of time, memory, or other resources) in actually\
    \ putting the\n      data records into the desired order.\n      A sorting algorithm\
    \ for string data can be internationalized by\n      providing it with the appropriate\
    \ collation-weighted keys\n      corresponding to the strings to be ordered.\n\
    \      Many processes have a need to order strings in a consistent\n      (sorted)\
    \ sequence.  For only a few CCS/CES combinations, there is\n      an obvious sort\
    \ order that can be applied without reference to the\n      linguistic meaning\
    \ of the characters: the code point order is\n      sufficient for sorting.  That\
    \ is, the code point order is also the\n      order that a person would use in\
    \ sorting the characters.  For many\n      CCS/CES combinations, the code point\
    \ order would make no sense to\n      a person and therefore is not useful for\
    \ sorting if the results\n      will be displayed to a person.\n      Code point\
    \ order is usually not how any human educated by a local\n      school system\
    \ expects to see strings ordered; if one orders to the\n      expectations of\
    \ a human, one has a \"language-specific\" or \"human\n      language\" sort.\
    \  Sorting to code point order will seem\n      inconsistent if the strings are\
    \ not normalized before sorting\n      because different representations of the\
    \ same character will sort\n      differently.  This problem may be smaller with\
    \ a language-specific\n      sort.\n   code table\n      A code table is a table\
    \ showing the characters allocated to the\n      octets in a code. <ISOIEC10646>\n\
    \      Code tables are also commonly called \"code charts\".\n"
- title: 4.1.  Types of Characters
  contents:
  - "4.1.  Types of Characters\n   The following definitions of types of characters\
    \ do not clearly\n   delineate each character into one type, nor do they allow\
    \ someone to\n   accurately predict what types would apply to a particular character.\n\
    \   The definitions are intended for application designers to help them\n   think\
    \ about the many (sometimes confusing) properties of text.\n   alphabetic\n  \
    \    An informative Unicode property.  Characters that are the primary\n     \
    \ units of alphabets and/or syllabaries, whether combining or non-\n      combining.\
    \  This includes composite characters that are canonical\n      equivalents to\
    \ a combining character sequence of an alphabetic\n      base character plus one\
    \ or more combining characters: letter\n      digraphs; contextual variants of\
    \ alphabetic characters; ligatures\n      of alphabetic characters; contextual\
    \ variants of ligatures;\n      modifier letters; letterlike symbols that are\
    \ compatibility\n      equivalents of single alphabetic letters; and miscellaneous\
    \ letter\n      elements. <UNICODE>\n   ideographic\n      Any symbol that primarily\
    \ denotes an idea (or meaning) in contrast\n      to a sound (or pronunciation),\
    \ for example, a symbol showing a\n      telephone or the Han characters used\
    \ in Chinese, Japanese, and\n      Korean. <UNICODE>\n      While Unicode and\
    \ many other systems use this term to refer to all\n      Han characters, strictly\
    \ speaking not all of those characters are\n      actually ideographic.  Some\
    \ are pictographic (such as the\n      telephone example above), some are used\
    \ phonetically, and so on.\n      However, the convention is to describe the script\
    \ as ideographic\n      as contrasted to alphabetic.\n   digit or number\n   \
    \   All modern writing systems use decimal digits in some form; some\n      older\
    \ ones use non-positional or other systems.  Different scripts\n      may have\
    \ their own digits.  Unicode distinguishes between numbers\n      and other kinds\
    \ of characters by assigning a special General\n      Category value to them and\
    \ subdividing that value to distinguish\n      between decimal digits, letter\
    \ digits, and other digits. <UNICODE>\n   punctuation\n      Characters that separate\
    \ units of text, such as sentences and\n      phrases, thus clarifying the meaning\
    \ of the text.  The use of\n      punctuation marks is not limited to prose; they\
    \ are also used in\n      mathematical and scientific formulae, for example. <UNICODE>\n\
    \   symbol\n      One of a set of characters other than those used for letters,\n\
    \      digits, or punctuation, and representing various concepts\n      generally\
    \ not connected to written language use per se. <RFC6365>\n      Examples of symbols\
    \ include characters for mathematical operators,\n      symbols for optical character\
    \ recognition (OCR), symbols for box-\n      drawing or graphics, as well as symbols\
    \ for dingbats, arrows,\n      faces, and geometric shapes.  Unicode has a property\
    \ that\n      identifies symbol characters.\n   nonspacing character\n      A\
    \ combining character whose positioning in presentation is\n      dependent on\
    \ its base character.  It generally does not consume\n      space along the visual\
    \ baseline in and of itself. <UNICODE>\n      A combining acute accent (U+0301)\
    \ is an example of a nonspacing\n      character.\n   diacritic\n      A mark\
    \ applied or attached to a symbol to create a new symbol that\n      represents\
    \ a modified or new value.  They can also be marks\n      applied to a symbol\
    \ irrespective of whether they change the value\n      of that symbol.  In the\
    \ latter case, the diacritic usually\n      represents an independent value (for\
    \ example, an accent, tone, or\n      some other linguistic information).  Also\
    \ called diacritical mark\n      or diacritical. <UNICODE>\n   control character\n\
    \      The 65 characters in the ranges U+0000..U+001F and U+007F..U+009F.\n  \
    \    The basic space character, U+0020, is often considered as a\n      control\
    \ character as well, making the total number 66.  They are\n      also known as\
    \ control codes.  In terminology adopted by Unicode\n      from ASCII and the\
    \ ISO 8859 standards, these codes are treated as\n      belonging to three ranges:\
    \ \"C0\" (for U+0000..U+001F), \"C1\" (for\n      U+0080...U+009F), and the single\
    \ control character \"DEL\" (U+007F).\n      <UNICODE>\n      Occasionally, in\
    \ other vocabularies, the term \"control character\"\n      is used to describe\
    \ any character that does not normally have an\n      associated glyph; it is\
    \ also sometimes used for device control\n      sequences [ISO6429].  Neither\
    \ of those usages is appropriate to\n      internationalization terminology in\
    \ the IETF.\n   formatting character\n      Characters that are inherently invisible\
    \ but that have an effect\n      on the surrounding characters. <UNICODE>\n  \
    \    Examples of formatting characters include characters for\n      specifying\
    \ the direction of text and characters that specify how\n      to join multiple\
    \ characters.\n   compatibility character or compatibility variant\n      A graphic\
    \ character included as a coded character of ISO/IEC 10646\n      primarily for\
    \ compatibility with existing coded character sets.\n      <ISOIEC10646)>\n  \
    \    The Unicode definition of compatibility charter also includes\n      characters\
    \ that have been incorporated for other reasons.  Their\n      list includes several\
    \ separate groups of characters included for\n      compatibility purposes: halfwidth\
    \ and fullwidth characters used\n      with East Asian scripts, Arabic contextual\
    \ forms (e.g., initial or\n      final forms), some ligatures, deprecated formatting\
    \ characters,\n      variant forms of characters (or even copies of them) for\n\
    \      particular uses (e.g., phonetic or mathematical applications),\n      font\
    \ variations, CJK compatibility ideographs, and so on.  For\n      additional\
    \ information and the separate term \"compatibility\n      decomposable character\"\
    , see the Unicode standard.\n      For example, U+FF01 (FULLWIDTH EXCLAMATION\
    \ MARK) was included for\n      compatibility with Asian charsets that include\
    \ full-width and\n      half-width ASCII characters.\n      Some efforts in the\
    \ IETF have concluded that it would be useful to\n      support mapping of some\
    \ groups of compatibility equivalents and\n      not others (e.g., supporting\
    \ or mapping width variations while\n      preserving or rejecting mathematical\
    \ variations).  See the IDNA\n      Mapping document [RFC5895] for one example.\n"
- title: 4.2.  Differentiation of Subsets
  contents:
  - "4.2.  Differentiation of Subsets\n   Especially as existing IETF standards are\
    \ internationalized, it is\n   necessary to describe collections of characters\
    \ including especially\n   various subsets of Unicode.  Because Unicode includes\
    \ ways to code\n   substantially all characters in contemporary use, subsets of\
    \ the\n   Unicode repertoire can be a useful tool for defining these\n   collections\
    \ as repertoires independent of specific Unicode coding.\n   However specific\
    \ collections are defined, it is important to remember\n   that, while older CCSs\
    \ such as ASCII and the ISO 8859 family are\n   close-ended and fixed, Unicode\
    \ is open-ended, with new character\n   definitions, and often new scripts, being\
    \ added every year or so.\n   So, while, e.g., an ASCII subset, such as \"uppercase\
    \ letters\", can be\n   specified as a range of code points (4/1 to 5/10 for that\
    \ example),\n   similar definitions for Unicode either have to be specified in\
    \ terms\n   of Unicode properties or are very dependent on Unicode versions (and\n\
    \   the relevant version must be identified in any specification).  See\n   the\
    \ IDNA code point specification [RFC5892] for an example of\n   specification\
    \ by combinations of properties.\n   Some terms are commonly used in the IETF\
    \ to define character ranges\n   and subsets.  Some of these are imprecise and\
    \ can cause confusion if\n   not used carefully.\n   non-ASCII\n      The term\
    \ \"non-ASCII\" strictly refers to characters other than\n      those that appear\
    \ in the ASCII repertoire, independent of the CCS\n      or encoding used for\
    \ them.  In practice, if a repertoire such as\n      that of Unicode is established\
    \ as context, \"non-ASCII\" refers to\n      characters in that repertoire that\
    \ do not appear in the ASCII\n      repertoire.  \"Outside the ASCII repertoire\"\
    \ and \"outside the ASCII\n      range\" are practical, and more precise, synonyms\
    \ for \"non-ASCII\".\n   letters\n      The term \"letters\" does not have an\
    \ exact equivalent in the\n      Unicode standard.  Letters are generally characters\
    \ that are used\n      to write words, but that means very different things in\
    \ different\n      languages and cultures.\n"
- title: 5.  User Interface for Text
  contents:
  - "5.  User Interface for Text\n   Although the IETF does not standardize user interfaces,\
    \ many\n   protocols make assumptions about how a user will enter or see text\n\
    \   that is used in the protocol.  Internationalization challenges\n   assumptions\
    \ about the type and limitations of the input and output\n   devices that may\
    \ be used with applications that use various\n   protocols.  It is therefore useful\
    \ to consider how users typically\n   interact with text that might contain one\
    \ or more non-ASCII\n   characters.\n   input methods\n      An input method is\
    \ a mechanism for a person to enter text into an\n      application. <RFC6365>\n\
    \      Text can be entered into a computer in many ways.  Keyboards are\n    \
    \  by far the most common device used, but many characters cannot be\n      entered\
    \ on typical computer keyboards in a single stroke.  Many\n      operating systems\
    \ come with system software that lets users input\n      characters outside the\
    \ range of what is allowed by keyboards.\n      For example, there are dozens\
    \ of different input methods for Han\n      characters in Chinese, Japanese, and\
    \ Korean.  Some start with\n      phonetic input through the keyboard, while others\
    \ use the number\n      of strokes in the character.  Input methods are also needed\
    \ for\n      scripts that have many diacritics, such as European or Vietnamese\n\
    \      characters that have two or three diacritics on a single\n      alphabetic\
    \ character.\n      The term \"input method editor\" (IME) is often used generically\
    \ to\n      describe the tools and software used to deal with input of\n     \
    \ characters on a particular system.\n   rendering rules\n      A rendering rule\
    \ is an algorithm that a system uses to decide how\n      to display a string\
    \ of text. <RFC6365>\n      Some scripts can be directly displayed with fonts,\
    \ where each\n      character from an input stream can simply be copied from a\
    \ glyph\n      system and put on the screen or printed page.  Other scripts need\n\
    \      rules that are based on the context of the characters in order to\n   \
    \   render text for display.\n      Some examples of these rendering rules include:\n\
    \      *  Scripts such as Arabic (and many others), where the form of the\n  \
    \       letter changes depending on the adjacent letters, whether the\n      \
    \   letter is standing alone, at the beginning of a word, in the\n         middle\
    \ of a word, or at the end of a word.  The rendering rules\n         must choose\
    \ between two or more glyphs.\n      *  Scripts such as the Indic scripts, where\
    \ consonants may change\n         their form if they are adjacent to certain other\
    \ consonants or\n         may be displayed in an order different from the way\
    \ they are\n         stored and pronounced.  The rendering rules must choose between\n\
    \         two or more glyphs.\n      *  Arabic and Hebrew scripts, where the order\
    \ of the characters\n         displayed are changed by the bidirectional properties\
    \ of the\n         alphabetic and other characters and with right-to-left and\n\
    \         left-to-right ordering marks.  The rendering rules must choose\n   \
    \      the order that characters are displayed.\n      *  Some writing systems\
    \ cannot have their rendering rules suitably\n         defined using mechanisms\
    \ that are now defined in the Unicode\n         Standard.  None of those languages\
    \ are in active non-scholarly\n         use today.\n      *  Many systems use\
    \ a special rendering rule when they lack a font\n         or other mechanism\
    \ for rendering a particular character\n         correctly.  That rule typically\
    \ involves substitution of a\n         small open box or a question mark for the\
    \ missing character.\n         See \"undisplayable character\" below.\n   graphic\
    \ symbol\n      A graphic symbol is the visual representation of a graphic\n \
    \     character or of a composite sequence. <ISOIEC10646>\n   font\n      A font\
    \ is a collection of glyphs used for the visual depiction of\n      character\
    \ data.  A font is often associated with a set of\n      parameters (for example,\
    \ size, posture, weight, and serifness),\n      which, when set to particular\
    \ values, generates a collection of\n      imagable glyphs. <UNICODE>\n      The\
    \ term \"font\" is often used interchangeably with \"typeface\".  As\n      historically\
    \ used in typography, a typeface is a family of one or\n      more fonts that\
    \ share a common general design.  For example,\n      \"Times Roman\" is actually\
    \ a typeface, with a collection of fonts\n      such as \"Times Roman Bold\",\
    \ \"Times Roman Medium\", \"Times Roman\n      Italic\", and so on.  Some sources\
    \ even consider different type\n      sizes within a typeface to be different\
    \ fonts.  While those\n      distinctions are rarely important for internationalization\n\
    \      purposes, there are exceptions.  Those writing specifications\n      should\
    \ be very careful about definitions in cases in which the\n      exceptions might\
    \ lead to ambiguity.\n   bidirectional display\n      The process or result of\
    \ mixing left-to-right oriented text and\n      right-to-left oriented text in\
    \ a single line is called\n      bidirectional display, often abbreviated as \"\
    bidi\". <UNICODE>\n      Most of the world's written languages are displayed left-to-right.\n\
    \      However, many widely-used written languages such as ones based on\n   \
    \   the Hebrew or Arabic scripts are displayed primarily right-to-left\n     \
    \ (numerals are a common exception in the modern scripts).  Right-\n      to-left\
    \ text often confuses protocol writers because they have to\n      keep thinking\
    \ in terms of the order of characters in a string in\n      memory, an order that\
    \ might be different from what they see on the\n      screen.  (Note that some\
    \ languages are written both horizontally\n      and vertically and that some\
    \ historical ones use other display\n      orderings.)\n      Further, bidirectional\
    \ text can cause confusion because there are\n      formatting characters in ISO/IEC\
    \ 10646 that cause the order of\n      display of text to change.  These explicit\
    \ formatting characters\n      change the display regardless of the implicit left-to-right\
    \ or\n      right-to-left properties of characters.  Text that might contain\n\
    \      those characters typically requires careful processing before\n      being\
    \ sorted or compared for equality.\n      It is common to see strings with text\
    \ in both directions, such as\n      strings that include both text and numbers,\
    \ or strings that\n      contain a mixture of scripts.\n      Unicode has a long\
    \ and incredibly detailed algorithm for\n      displaying bidirectional text [UAX9].\n\
    \   undisplayable character\n      A character that has no displayable form. <RFC6365>\n\
    \      For instance, the zero-width space (U+200B) cannot be displayed\n     \
    \ because it takes up no horizontal space.  Formatting characters\n      such\
    \ as those for setting the direction of text are also\n      undisplayable.  Note,\
    \ however, that every character in [UNICODE]\n      has a glyph associated with\
    \ it, and that the glyphs for\n      undisplayable characters are enclosed in\
    \ a dashed square as an\n      indication that the actual character is undisplayable.\n\
    \      The property of a character that causes it to be undisplayable is\n   \
    \   intrinsic to its definition.  Undisplayable characters can never\n      be\
    \ displayed in normal text (the dashed square notation is used\n      only in\
    \ special circumstances).  Printable characters whose\n      Unicode definitions\
    \ are associated with glyphs that cannot be\n      rendered on a particular system\
    \ are not, in this sense,\n      undisplayable.\n   writing style\n      Conventions\
    \ of writing the same script in different styles.\n      <RFC6365>\n      Different\
    \ communities using the script may find text in different\n      writing styles\
    \ difficult to read and possibly unintelligible.  For\n      example, the Perso-Arabic\
    \ Nastalique writing style and the Arabic\n      Naskh writing style both use\
    \ the Arabic script but have very\n      different renderings and are not mutually\
    \ comprehensible.  Writing\n      styles may have significant impact on internationalization;\
    \ for\n      example, the Nastalique writing style requires significantly more\n\
    \      line height than Naskh writing style.\n"
- title: 6.  Text in Current IETF Protocols
  contents:
  - "6.  Text in Current IETF Protocols\n   Many IETF protocols started off being\
    \ fully internationalized, while\n   others have been internationalized as they\
    \ were revised.  In this\n   process, IETF members have seen patterns in the way\
    \ that many\n   protocols use text.  This section describes some specific protocol\n\
    \   interactions with text.\n   protocol elements\n      Protocol elements are\
    \ uniquely named parts of a protocol.\n      <RFC6365>\n      Almost every protocol\
    \ has named elements, such as \"source port\" in\n      TCP.  In some protocols,\
    \ the names of the elements (or text tokens\n      for the names) are transmitted\
    \ within the protocol.  For example,\n      in SMTP and numerous other IETF protocols,\
    \ the names of the verbs\n      are part of the command stream.  The names are\
    \ thus part of the\n      protocol standard.  The names of protocol elements are\
    \ not\n      normally seen by end users, and it is rarely appropriate to\n   \
    \   internationalize protocol element names (even while the elements\n      themselves\
    \ can be internationalized).\n   name spaces\n      A name space is the set of\
    \ valid names for a particular item, or\n      the syntactic rules for generating\
    \ these valid names. <RFC6365>\n      Many items in Internet protocols use names\
    \ to identify specific\n      instances or values.  The names may be generated\
    \ (by some\n      prescribed rules), registered centrally (e.g., such as with\
    \ IANA),\n      or have a distributed registration and control mechanism, such\
    \ as\n      the names in the DNS.\n   on-the-wire encoding\n      The encoding\
    \ and decoding used before and after transmission over\n      the network is often\
    \ called the \"on-the-wire\" (or sometimes just\n      \"wire\") format. <RFC6365>\n\
    \      Characters are identified by code points.  Before being\n      transmitted\
    \ in a protocol, they must first be encoded as bits and\n      octets.  Similarly,\
    \ when characters are received in a\n      transmission, they have been encoded,\
    \ and a protocol that needs to\n      process the individual characters needs\
    \ to decode them before\n      processing.\n   parsed text\n      Text strings\
    \ that have been analyzed for subparts. <RFC6365>\n      In some protocols, free\
    \ text in text fields might be parsed.  For\n      example, many mail user agents\
    \ (MUAs) will parse the words in the\n      text of the Subject: field to attempt\
    \ to thread based on what\n      appears after the \"Re:\" prefix.\n      Such\
    \ conventions are very sensitive to localization.  If, for\n      example, a form\
    \ like \"Re:\" is altered by an MUA to reflect the\n      language of the sender\
    \ or recipient, a system that subsequently\n      does threading may not recognize\
    \ the replacement term as a\n      delimiter string.\n   charset identification\n\
    \      Specification of the charset used for a string of text. <RFC6365>\n   \
    \   Protocols that allow more than one charset to be used in the same\n      place\
    \ should require that the text be identified with the\n      appropriate charset.\
    \  Without this identification, a program\n      looking at the text cannot definitively\
    \ discern the charset of the\n      text.  Charset identification is also called\
    \ \"charset tagging\".\n   language identification\n      Specification of the\
    \ human language used for a string of text.\n      <RFC6365>\n      Some protocols\
    \ (such as MIME and HTTP) allow text that is meant\n      for machine processing\
    \ to be identified with the language used in\n      the text.  Such identification\
    \ is important for machine processing\n      of the text, such as by systems that\
    \ render the text by speaking\n      it.  Language identification is also called\
    \ \"language tagging\".\n      The IETF \"LTRU\" standards [RFC5646] and [RFC4647]\
    \ provide a\n      comprehensive model for language identification.\n   MIME\n\
    \      MIME (Multipurpose Internet Mail Extensions) is a message format\n    \
    \  that allows for textual message bodies and headers in character\n      sets\
    \ other than US-ASCII in formats that require ASCII (most\n      notably RFC 5322,\
    \ the standard for Internet mail headers\n      [RFC5322]).  MIME is described\
    \ in RFCs 2045 through 2049, as well\n      as more recent RFCs. <RFC6365>\n \
    \  transfer encoding syntax\n      A transfer encoding syntax (TES) (sometimes\
    \ called a transfer\n      encoding scheme) is a reversible transform of already\
    \ encoded data\n      that is represented in one or more character encoding schemes.\n\
    \      <RFC6365>\n      TESs are useful for encoding types of character data into\
    \ another\n      format, usually for allowing new types of data to be transmitted\n\
    \      over legacy protocols.  The main examples of TESs used in the IETF\n  \
    \    include Base64 and quoted-printable.  MIME identifies the transfer\n    \
    \  encoding syntax for body parts as a Content-transfer-encoding,\n      occasionally\
    \ abbreviated C-T-E.\n   Base64\n      Base64 is a transfer encoding syntax that\
    \ allows binary data to be\n      represented by the ASCII characters A through\
    \ Z, a through z, 0\n      through 9, +, /, and =.  It is defined in [RFC2045].\
    \ <RFC6365>\n   quoted printable\n      Quoted printable is a transfer encoding\
    \ syntax that allows strings\n      that have non-ASCII characters mixed in with\
    \ mostly ASCII\n      printable characters to be somewhat human readable.  It\
    \ is\n      described in [RFC2047]. <RFC6365>\n      The quoted printable syntax\
    \ is generally considered to be a\n      failure at being readable.  It is jokingly\
    \ referred to as \"quoted\n      unreadable\".\n   XML\n      XML (which is an\
    \ approximate abbreviation for Extensible Markup\n      Language) is a popular\
    \ method for structuring text.  XML text that\n      is not encoded as UTF-8 is\
    \ explicitly tagged with charsets, and\n      all text in XML consists only of\
    \ Unicode characters.  The\n      specification for XML can be found at <http://www.w3.org/XML/>.\n\
    \      <RFC6365>\n   ASN.1 text formats\n      The ASN.1 data description language\
    \ has many formats for text\n      data.  The formats allow for different repertoires\
    \ and different\n      encodings.  Some of the formats that appear in IETF standards\n\
    \      based on ASN.1 include IA5String (all ASCII characters),\n      PrintableString\
    \ (most ASCII characters, but missing many\n      punctuation characters), BMPString\
    \ (characters from ISO/IEC 10646\n      plane 0 in UTF-16BE format), UTF8String\
    \ (just as the name\n      implies), and TeletexString (also called T61String).\n\
    \   ASCII-compatible encoding (ACE)\n      Starting in 1996, many ASCII-compatible\
    \ encoding schemes (which\n      are actually transfer encoding syntaxes) have\
    \ been proposed as\n      possible solutions for internationalizing host names\
    \ and some\n      other purposes.  Their goal is to be able to encode any string\
    \ of\n      ISO/IEC 10646 characters using the preferred syntax for domain\n \
    \     names (as described in STD 13).  At the time of this writing, only\n   \
    \   the ACE produced by Punycode [RFC3492] has become an IETF\n      standard.\n\
    \      The choice of ACE forms to internationalize legacy protocols must\n   \
    \   be made with care as it can cause some difficult side effects\n      [RFC6055].\n\
    \   LDH label\n      The classical label form used in the DNS and most applications\n\
    \      that call on it, albeit with some additional restrictions,\n      reflects\
    \ the early syntax of \"hostnames\" [RFC0952] and limits\n      those names to\
    \ ASCII letters, digits, and embedded hyphens.  The\n      hostname syntax is\
    \ identical to that described as the \"preferred\n      name syntax\" in Section\
    \ 3.5 of RFC 1034 [RFC1034] as modified by\n      RFC 1123 [RFC1123].  LDH labels\
    \ are defined in a more restrictive\n      and precise way for internationalization\
    \ contexts as part of the\n      IDNA2008 specification [RFC5890].\n"
- title: 7.  Terms Associated with Internationalized Domain Names
  contents:
  - '7.  Terms Associated with Internationalized Domain Names

    '
- title: 7.1.  IDNA Terminology
  contents:
  - "7.1.  IDNA Terminology\n   The current specification for Internationalized Domain\
    \ Names (IDNs),\n   known formally as Internationalized Domain Names for Applications\
    \ or\n   IDNA, is referred to in the IETF and parts of the broader community\n\
    \   as \"IDNA2008\" and consists of several documents.  Section 2.3 of the\n \
    \  first of those documents, commonly known as \"IDNA2008 Definitions\"\n   [RFC5890]\
    \ provides definitions and introduces some specialized terms\n   for differentiating\
    \ among types of DNS labels in an IDN context.\n   Those terms are listed in the\
    \ table below; see RFC 5890 for the\n   specific definitions if needed.\n    \
    \  ACE Prefix\n      A-label\n      Domain Name Slot\n      IDNA-valid string\n\
    \      Internationalized Domain Name (IDN)\n      Internationalized Label\n  \
    \    LDH Label\n      Non-Reserved LDH label (NR-LDH label)\n      U-label\n \
    \  Two additional terms entered the IETF's vocabulary as part of the\n   earlier\
    \ IDN effort [RFC3490] (IDNA2003):\n      Stringprep\n         Stringprep [RFC3454]\
    \ provides a model and character tables for\n         preparing and handling internationalized\
    \ strings.  It was used\n         in the original IDN specification (IDNA2003)\
    \ via a profile\n         called \"Nameprep\" [RFC3491].  It is no longer in use\
    \ in IDNA,\n         but continues to be used in profiles by a number of other\n\
    \         protocols. <RFC6365>\n      Punycode\n         This is the name of the\
    \ algorithm [RFC3492] used to convert\n         otherwise-valid IDN labels from\
    \ native-character strings\n         expressed in Unicode to an ASCII-compatible\
    \ encoding (ACE).\n         Strictly speaking, the term applies to the algorithm\
    \ only.  In\n         practice, it is widely, if erroneously, used to refer to\n\
    \         strings that the algorithm encodes.\n"
- title: 7.2.  Character Relationships and Variants
  contents:
  - "7.2.  Character Relationships and Variants\n   The term \"variant\" was introduced\
    \ into the IETF i18n vocabulary with\n   the JET recommendations [RFC3743].  As\
    \ used there, it referred\n   strictly to the relationship between Traditional\
    \ Chinese characters\n   and their Simplified equivalents.  The JET recommendations\
    \ provided a\n   model for identifying these pairs of characters and labels that\
    \ used\n   them.  Specific recommendations for variant handling for the Chinese\n\
    \   language were provided in a follow-up document [RFC4713].\n   In more recent\
    \ years, the term has also been used to describe other\n   collections of characters\
    \ or strings that might be perceived as\n   equivalent.  Those collections have\
    \ involved one or more of several\n   categories of characters and labels containing\
    \ them including:\n   o  \"visually similar\" or \"visually confusable\" characters.\
    \  These may\n      be limited to characters in different scripts, characters\
    \ in a\n      single script, or both, and may be those that can appear to be\n\
    \      alike even when high-distinguishability reference fonts are used\n    \
    \  or under various circumstances that may involve malicious choices\n      of\
    \ typefaces or other ways to trick user perception.  Trivial\n      examples include\
    \ ASCII \"l\" and \"1\" and Latin and Cyrillic \"a\".\n   o  Characters assigned\
    \ more than one Unicode code point because of\n      some special property.  These\
    \ characters may be considered \"the\n      same\" for some purposes and different\
    \ for others (or by other\n      users).  One of the most commonly cited examples\
    \ is the Arabic\n      YEH, which is encoded more than once because some of its\
    \ shapes\n      are different across different languages.  Another example are\
    \ the\n      Greek lowercase sigma and final sigma: if the latter were viewed\n\
    \      purely as a positional presentation variation on the former, it\n     \
    \ should not have been assigned a separate code point.\n   o  Numerals and labels\
    \ including them.  Unlike letters, the \"meaning\"\n      of decimal digits is\
    \ clear and unambiguous regardless of the\n      script with which they are associated.\
    \  Some scripts are routinely\n      used almost interchangeably with European\
    \ digits and digits native\n      to that script.  The Arabic script has two sets\
    \ of digits\n      (U+0660..U+0669 and U+06F0..U=06F9), written identically for\
    \ zero\n      through three and seven through nine but differently for four\n\
    \      through six; European digits predominate in other areas.\n      Substitution\
    \ of digits with the same numeric value in labels may\n      give rise to another\
    \ type of variant.\n   o  Orthographic differences within a language.  Many languages\
    \ have\n      alternate choices of spellings or spellings that differ by locale.\n\
    \      Users of those languages generally recognize the spellings as\n      equivalent,\
    \ at least as much so as the variations described above.\n      Examples include\
    \ \"color\" and \"colour\" in English, German words\n      spelled with o-umlaut\
    \ or \"oe\", and so on.  Some of these\n      relationships may also create other\
    \ types of language-specific\n      perceived differences that do not exist for\
    \ other languages using\n      the same script.  For example, in Arabic language\
    \ usage at the end\n      of words, ARABIC LETTER TEH MARBUTA (U+0629) and ARABIC\
    \ LETTER HEH\n      (U+0647) are differently shaped (one has 2 dots in top of\
    \ it), but\n      they are used interchangeably in writing: they \"sound\" similar\n\
    \      when pronounced at the end of phrase, and hence the LETTER TEH\n      MARBUTA\
    \ sometimes is written as LETTER HEH and the two are\n      considered \"confusable\"\
    \ in that context.\n   The term \"variant\" as used in this section should also\
    \ not be\n   confused with other uses of the term in this document or in Unicode\n\
    \   terminology (e.g., those in Section 4.1 above).  If the term is to be\n  \
    \ used at all, context should clearly distinguish among these different\n   uses\
    \ and, in particular, between variant characters and variant\n   labels.  Local\
    \ text should identify which meaning, or combination of\n   meanings, are intended.\n"
- title: 8.  Other Common Terms in Internationalization
  contents:
  - "8.  Other Common Terms in Internationalization\n   This is a hodge-podge of other\
    \ terms that have appeared in\n   internationalization discussions in the IETF.\n\
    \   locale\n      Locale is the user-specific location and cultural information\n\
    \      managed by a computer. <RFC6365>\n      Because languages and orthographic\
    \ conventions differ from country\n      to country (and even region to region\
    \ within a country), the\n      locale of the user can often be an important factor.\
    \  Typically,\n      the locale information for a user includes the language(s)\
    \ used.\n      Locale issues go beyond character use, and can include things such\n\
    \      as the display format for currency, dates, and times.  Some\n      locales\
    \ (especially the popular \"C\" and \"POSIX\" locales) do not\n      include language\
    \ information.\n      It should be noted that there are many thorny, unsolved\
    \ issues\n      with locale.  For example, should text be viewed using the locale\n\
    \      information of the person who wrote the text, information that\n      would\
    \ apply to the location of the system storing or providing the\n      text, or\
    \ the person viewing it?  What if the person viewing it is\n      traveling to\
    \ different locations?  Should only some of the locale\n      information affect\
    \ creation and editing of text?\n   Latin characters\n      \"Latin characters\"\
    \ is a not-precise term for characters\n      historically related to ancient\
    \ Greek script as modified in the\n      Roman Republic and Empire and currently\
    \ used throughout the world.\n      <RFC6365>\n      The base Latin characters\
    \ are a subset of the ASCII repertoire and\n      have been augmented by many\
    \ single and multiple diacritics and\n      quite a few other characters.  ISO/IEC\
    \ 10646 encodes the Latin\n      characters in including ranges U+0020..U+024F\
    \ and U+1E00..U+1EFF.\n      Because \"Latin characters\" is used in different\
    \ contexts to refer\n      to the letters from the ASCII repertoire, the subset\
    \ of those\n      characters used late in the Roman Republic period, or the\n\
    \      different subset used to write Latin in medieval times, the entire\n  \
    \    ASCII repertoire, all of the code points in the extended Latin\n      script\
    \ as defined by Unicode, and other collections, the term\n      should be avoided\
    \ in IETF specifications when possible.\n      Similarly, \"Basic Latin\" should\
    \ not be used as a synonym for\n      \"ASCII\".\n   romanization\n      The transliteration\
    \ of a non-Latin script into Latin characters.\n      <RFC6365>\n      Because\
    \ of their widespread use, Latin characters (or graphemes\n      constructed from\
    \ them) are often used to try to write text in\n      languages that didn't previously\
    \ have writing systems or whose\n      writing systems were originally based on\
    \ different scripts.  For\n      example, there are two popular romanizations\
    \ of Chinese: Wade-\n      Giles and Pinyin, the latter of which is by far more\
    \ common today.\n      Many romanization systems are inexact and do not give perfect\n\
    \      round-trip mappings between the native script and the Latin\n      characters.\n\
    \   CJK characters and Han characters\n      The ideographic characters used in\
    \ Chinese, Japanese, Korean, and\n      traditional Vietnamese writing systems\
    \ are often called \"CJK\n      characters\" after the initial letters of the\
    \ language names in\n      English.  They are also called \"Han characters\",\
    \ after the term in\n      Chinese that is often used for these characters. <RFC6365>\n\
    \      Note that Han characters do not include the phonetic characters\n     \
    \ used in the Japanese and Korean languages.  Users of the term \"CJK\n      characters\"\
    \ may or may not assume those additional characters are\n      included.\n   \
    \   In ISO/IEC 10646, the Han characters were \"unified\", meaning that\n    \
    \  each set of Han characters from Japanese, Chinese, and/or Korean\n      that\
    \ had the same origin was assigned a single code point.  The\n      positive result\
    \ of this was that many fewer code points were\n      needed to represent Han;\
    \ the negative result of this was that\n      characters that people who write\
    \ the three languages think are\n      different have the same code point.  There\
    \ is a great deal of\n      disagreement on the nature, the origin, and the severity\
    \ of the\n      problems caused by Han unification.\n   translation\n      The\
    \ process of conveying the meaning of some passage of text in\n      one language,\
    \ so that it can be expressed equivalently in another\n      language. <RFC6365>\n\
    \      Many language translation systems are inexact and cannot be\n      applied\
    \ repeatedly to go from one language to another to another.\n   transliteration\n\
    \      The process of representing the characters of an alphabetical or\n    \
    \  syllabic system of writing by the characters of a conversion\n      alphabet.\
    \ <RFC6365>\n      Many script transliterations are exact, and many have perfect\n\
    \      round-trip mappings.  The notable exception to this is\n      romanization,\
    \ described above.  Transliteration involves\n      converting text expressed\
    \ in one script into another script,\n      generally on a letter-by-letter basis.\
    \  There are many official\n      and unofficial transliteration standards, most\
    \ notably those from\n      ISO TC 46 and the U.S. Library of Congress.\n   transcription\n\
    \      The process of systematically writing the sounds of some passage\n    \
    \  of spoken language, generally with the use of a technical phonetic\n      alphabet\
    \ (usually Latin-based) or other systematic transcriptional\n      orthography.\
    \  Transcription also sometimes refers to the\n      conversion of written text\
    \ into a transcribed form, based on the\n      sound of the text as if it had\
    \ been spoken. <RFC6365>\n      Unlike transliterations, which are generally designed\
    \ to be round-\n      trip convertible, transcriptions of written material are\
    \ almost\n      never round-trip convertible to their original form, at least\n\
    \      without some supplemental information.\n   regular expressions\n      Regular\
    \ expressions provide a mechanism to select specific strings\n      from a set\
    \ of character strings.  Regular expressions are a\n      language used to search\
    \ for text within strings, and possibly\n      modify the text found with other\
    \ text. <RFC6365>\n      Pattern matching for text involves being able to represent\
    \ one or\n      more code points in an abstract notation, such as searching for\n\
    \      all capital Latin letters or all punctuation.  The most common\n      mechanism\
    \ in IETF protocols for naming such patterns is the use of\n      regular expressions.\
    \  There is no single regular expression\n      language, but there are numerous\
    \ very similar dialects that are\n      not quite consistent with each other.\n\
    \      The Unicode Consortium has a good discussion about how to adapt\n     \
    \ regular expression engines to use Unicode.  [UTR18]\n   private use character\n\
    \      ISO/IEC 10646 code points from U+E000 to U+F8FF, U+F0000 to\n      U+FFFFD,\
    \ and U+100000 to U+10FFFD are available for private use.\n      This refers to\
    \ code points of the standard whose interpretation is\n      not specified by\
    \ the standard and whose use may be determined by\n      private agreement among\
    \ cooperating users. <UNICODE>\n      The use of these \"private use\" characters\
    \ is defined by the\n      parties who transmit and receive them, and is thus\
    \ not appropriate\n      for standardization.  (The IETF has a long history of\
    \ private use\n      names for things such as \"x-\" names in MIME types, charsets,\
    \ and\n      languages.  Most of the experience with these has been quite\n  \
    \    negative, with many implementors assuming that private use names\n      are\
    \ in fact public and long-lived.)\n"
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   Security is not discussed directly in this document.\
    \  While the\n   definitions here have no direct effect on security, they are\
    \ used in\n   many security contexts.  For example, authentication usually involves\n\
    \   comparing two tokens, and one or both of those tokens might be text;\n   thus,\
    \ some methods of comparison might involve using some of the\n   internationalization\
    \ concepts for which terms are defined in this\n   document.\n   Having said that,\
    \ other RFCs dealing with internationalization have\n   security consideration\
    \ descriptions that may be useful to the reader\n   of this document.  In particular,\
    \ the security considerations in RFC\n   3454, RFC 3629, RFC 4013 [RFC4013], and\
    \ RFC 5890 go into a fair\n   amount of detail.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [ISOIEC10646]   ISO/IEC, \"ISO/IEC 10646:2011.\
    \  International Standard\n                   -- Information technology - Universal\
    \ Multiple-Octet\n                   Coded Character Set (UCS)\", 2011.\n   [RFC2047]\
    \       Moore, K., \"MIME (Multipurpose Internet Mail\n                   Extensions)\
    \ Part Three: Message Header Extensions for\n                   Non-ASCII Text\"\
    , RFC 2047, November 1996.\n   [UNICODE]       The Unicode Consortium, \"The Unicode\
    \ Standard,\n                   Version 6.0\", (Mountain View, CA: The Unicode\n\
    \                   Consortium, 2011. ISBN 978-1-936213-01-6).\n             \
    \      <http://www.unicode.org/versions/Unicode6.0.0/>.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [CHARMOD]       W3C, \"Character Model for\
    \ the World Wide Web 1.0\",\n                   2005, <http://www.w3.org/TR/charmod/>.\n\
    \   [FRAMEWORK]     ISO/IEC, \"ISO/IEC TR 11017:1997(E).  Information\n      \
    \             technology - Framework for internationalization,\n             \
    \      prepared by ISO/IEC JTC 1/SC 22/WG 20\", 1997.\n   [ISO3166]       ISO,\
    \ \"ISO 3166-1:2006 - Codes for the representation\n                   of names\
    \ of countries and their subdivisions -- Part\n                   1: Country codes\"\
    , 2006.\n   [ISO639]        ISO, \"ISO 639-1:2002 - Code for the representation\
    \ of\n                   names of languages - Part 1: Alpha-2 code\", 2002.\n\
    \   [ISO6429]       ISO/IEC, \"ISO/IEC, \"ISO/IEC 6429:1992.  Information\n  \
    \                 technology -- Control functions for coded character\n      \
    \             sets\"\", ISO/IEC 6429:1992, 1992.\n   [RFC0952]       Harrenstien,\
    \ K., Stahl, M., and E. Feinler, \"DoD\n                   Internet host table\
    \ specification\", RFC 952,\n                   October 1985.\n   [RFC1034]  \
    \     Mockapetris, P., \"Domain names - concepts and\n                   facilities\"\
    , STD 13, RFC 1034, November 1987.\n   [RFC1123]       Braden, R., \"Requirements\
    \ for Internet Hosts -\n                   Application and Support\", STD 3, RFC\
    \ 1123,\n                   October 1989.\n   [RFC2045]       Freed, N. and N.\
    \ Borenstein, \"Multipurpose Internet\n                   Mail Extensions (MIME)\
    \ Part One: Format of Internet\n                   Message Bodies\", RFC 2045,\
    \ November 1996.\n   [RFC2119]       Bradner, S., \"Key words for use in RFCs\
    \ to Indicate\n                   Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [RFC2277]       Alvestrand, H., \"IETF Policy on Character Sets and\n\
    \                   Languages\", BCP 18, RFC 2277, January 1998.\n   [RFC2781]\
    \       Hoffman, P. and F. Yergeau, \"UTF-16, an encoding of\n               \
    \    ISO 10646\", RFC 2781, February 2000.\n   [RFC2978]       Freed, N. and J.\
    \ Postel, \"IANA Charset Registration\n                   Procedures\", BCP 19,\
    \ RFC 2978, October 2000.\n   [RFC3454]       Hoffman, P. and M. Blanchet, \"\
    Preparation of\n                   Internationalized Strings (\"stringprep\")\"\
    , RFC 3454,\n                   December 2002.\n   [RFC3490]       Faltstrom,\
    \ P., Hoffman, P., and A. Costello,\n                   \"Internationalizing Domain\
    \ Names in Applications\n                   (IDNA)\", RFC 3490, March 2003.\n\
    \   [RFC3491]       Hoffman, P. and M. Blanchet, \"Nameprep: A Stringprep\n  \
    \                 Profile for Internationalized Domain Names (IDN)\",\n      \
    \             RFC 3491, March 2003.\n   [RFC3492]       Costello, A., \"Punycode:\
    \ A Bootstring encoding of\n                   Unicode for Internationalized Domain\
    \ Names in\n                   Applications (IDNA)\", RFC 3492, March 2003.\n\
    \   [RFC3629]       Yergeau, F., \"UTF-8, a transformation format of ISO\n   \
    \                10646\", STD 63, RFC 3629, November 2003.\n   [RFC3743]     \
    \  Konishi, K., Huang, K., Qian, H., and Y. Ko, \"Joint\n                   Engineering\
    \ Team (JET) Guidelines for\n                   Internationalized Domain Names\
    \ (IDN) Registration and\n                   Administration for Chinese, Japanese,\
    \ and Korean\",\n                   RFC 3743, April 2004.\n   [RFC4013]      \
    \ Zeilenga, K., \"SASLprep: Stringprep Profile for User\n                   Names\
    \ and Passwords\", RFC 4013, February 2005.\n   [RFC4647]       Phillips, A. and\
    \ M. Davis, \"Matching of Language\n                   Tags\", BCP 47, RFC 4647,\
    \ September 2006.\n   [RFC4713]       Lee, X., Mao, W., Chen, E., Hsu, N., and\
    \ J. Klensin,\n                   \"Registration and Administration Recommendations\
    \ for\n                   Chinese Domain Names\", RFC 4713, October 2006.\n  \
    \ [RFC5137]       Klensin, J., \"ASCII Escaping of Unicode Characters\",\n   \
    \                BCP 137, RFC 5137, February 2008.\n   [RFC5198]       Klensin,\
    \ J. and M. Padlipsky, \"Unicode Format for\n                   Network Interchange\"\
    , RFC 5198, March 2008.\n   [RFC5322]       Resnick, P., Ed., \"Internet Message\
    \ Format\",\n                   RFC 5322, October 2008.\n   [RFC5646]       Phillips,\
    \ A. and M. Davis, \"Tags for Identifying\n                   Languages\", BCP\
    \ 47, RFC 5646, September 2009.\n   [RFC5890]       Klensin, J., \"Internationalized\
    \ Domain Names for\n                   Applications (IDNA): Definitions and Document\n\
    \                   Framework\", RFC 5890, August 2010.\n   [RFC5892]       Faltstrom,\
    \ P., \"The Unicode Code Points and\n                   Internationalized Domain\
    \ Names for Applications\n                   (IDNA)\", RFC 5892, August 2010.\n\
    \   [RFC5895]       Resnick, P. and P. Hoffman, \"Mapping Characters for\n   \
    \                Internationalized Domain Names in Applications (IDNA)\n     \
    \              2008\", RFC 5895, September 2010.\n   [RFC6055]       Thaler, D.,\
    \ Klensin, J., and S. Cheshire, \"IAB\n                   Thoughts on Encodings\
    \ for Internationalized Domain\n                   Names\", RFC 6055, February\
    \ 2011.\n   [UAX34]         The Unicode Consortium, \"Unicode Standard Annex #34:\n\
    \                   Unicode Named Character Sequences\", 2010,\n             \
    \      <http://www.unicode.org/reports/tr34>.\n   [UAX9]          The Unicode\
    \ Consortium, \"Unicode Standard Annex #9:\n                   Unicode Bidirectional\
    \ Algorithm\", 2010,\n                   <http://www.unicode.org/reports/tr9>.\n\
    \   [US-ASCII]      ANSI, \"Coded Character Set -- 7-bit American Standard\n \
    \                  Code for Information Interchange, ANSI X3.4-1986\",\n     \
    \              1986.\n   [UTN6]          The Unicode Consortium, \"Unicode Technical\
    \ Note #5:\n                   BOCU-1: MIME-Compatible Unicode Compression\",\
    \ 2006,\n                   <http://www.unicode.org/notes/tn6/>.\n   [UTR15] \
    \        The Unicode Consortium, \"Unicode Standard Annex #15:\n             \
    \      Unicode Normalization Forms\", 2010,\n                   <http://www.unicode.org/reports/tr15>.\n\
    \   [UTR18]         The Unicode Consortium, \"Unicode Standard Annex #18:\n  \
    \                 Unicode Regular Expressions\", 2008,\n                   <http://www.unicode.org/reports/tr18>.\n\
    \   [UTR22]         The Unicode Consortium, \"Unicode Technical Standard\n   \
    \                #22: Unicode Character Mapping Markup Language\",\n         \
    \          2009, <http://www.unicode.org/reports/tr22>.\n   [UTR6]          The\
    \ Unicode Consortium, \"Unicode Technical Standard\n                   #6: A Standard\
    \ Compression Scheme for Unicode\", 2005,\n                   <http://www.unicode.org/reports/tr6>.\n\
    \   [W3C-i18n-Def]  W3C, \"Localization vs. Internationalization\",\n        \
    \           September 2010, <http://www.w3.org/International/\n              \
    \     questions/qa-i18n.en>.\n"
- title: Appendix A.  Additional Interesting Reading
  contents:
  - "Appendix A.  Additional Interesting Reading\n   Barry, Randall, ed.  ALA-LC Romanization\
    \ Tables.  Washington: U.S.\n   Library of Congress, 1997.  ISBN 0844409405\n\
    \   Coulmas, Florian.  Blackwell Encyclopedia of Writing Systems.\n   Oxford:\
    \ Blackwell Publishers, 1999.  ISBN 063121481X\n   Dalby, Andrew.  Dictionary\
    \ of Languages: The Definitive Reference to\n   More than 400 Languages.  New\
    \ York: Columbia University Press, 2004.\n   ISBN 978-0231115698\n   Daniels,\
    \ Peter, and William Bright.  The World's Writing Systems.\n   New York: Oxford\
    \ University Press, 1996.  ISBN 0195079930\n   DeFrancis, John.  The Chinese Language:\
    \ Fact and Fantasy.  Honolulu:\n   University of Hawaii Press, 1984.  ISBN 0-8284-085505\
    \ and\n   0-8248-1058-6\n   Drucker, Joanna.  The Alphabetic Labyrinth: The Letters\
    \ in History\n   and Imagination.  London: Thames & Hudson, 1995.  ISBN 0-500-28068-1\n\
    \   Fazzioli, Edoardo.  Chinese Calligraphy.  New York: Abbeville Press,\n   1986,\
    \ 1987 (English translation).  ISBN 0-89659-774-1\n   Hooker, J.T., et al.  Reading\
    \ the Past: Ancient Writing from\n   Cuneiform to the Alphabet.  London: British\
    \ Museum Press, 1990.  ISBN\n   0-7141-8077-7\n   Lunde, Ken.  CJKV Information\
    \ Processing.  Sebastopol, CA: O'Reilly &\n   Assoc., 1999.  ISBN 1-56592-224-7\n\
    \   Nakanishi, Akira.  Writing Systems of the World.  Rutland, VT:\n   Charles\
    \ E. Tuttle Company, 1980.  ISBN 0804816549\n   Robinson, Andrew.  The Story of\
    \ Writing: Alphabets, Hieroglyphs, &\n   Pictograms.  London: Thames & Hudson,\
    \ 1995, 2000.  ISBN 0-500-28156-4\n   Sacks, David.  Language Visible.  New York:\
    \ Broadway Books (a\n   division of Random House, Inc.), 2003.  ISBN 0-7679-1172-5\n"
- title: Appendix B.  Acknowledgements
  contents:
  - "Appendix B.  Acknowledgements\n   The definitions in this document come from\
    \ many sources, including a\n   wide variety of IETF documents.\n   James Seng\
    \ contributed to the initial outline of RFC 3536.  Harald\n   Alvestrand and Martin\
    \ Duerst made extensive useful comments on early\n   versions.  Others who contributed\
    \ to the development of RFC 3536\n   include Dan Kohn, Jacob Palme, Johan van\
    \ Wingen, Peter Constable,\n   Yuri Demchenko, Susan Harris, Zita Wenzel, John\
    \ Klensin, Henning\n   Schulzrinne, Leslie Daigle, Markus Scherer, and Ken Whistler.\n\
    \   Abdulaziz Al-Zoman, Tim Bray, Frank Ellermann, Antonio Marko, JFC\n   Morphin,\
    \ Sarmad Hussain, Mykyta Yevstifeyev, Ken Whistler, and others\n   identified\
    \ important issues with, or made specific suggestions for,\n   this new version.\n"
- title: Appendix C.  Significant Changes from RFC 3536
  contents:
  - "Appendix C.  Significant Changes from RFC 3536\n   This document mostly consists\
    \ of additions to RFC 3536.  The\n   following is a list of the most significant\
    \ changes.\n   o  Changed the document's status to BCP.\n   o  Commonly used synonyms\
    \ added to several descriptions and indexed.\n   o  A list of terms defined and\
    \ used in IDNA2008 was added, with a\n      pointer to RFC 5890.  Those definitions\
    \ have not been repeated in\n      this document.\n   o  The much-abused term\
    \ \"variant\" is now discussed in some detail.\n   o  A discussion of different\
    \ subsets of the Unicode repertoire was\n      added as Section 4.2 and associated\
    \ definitions were included.\n   o  Added a new term, \"writing style\".\n   o\
    \  Discussions of case-folding and mapping were expanded.\n   o  Minor edits were\
    \ made to some section titles and a number of other\n      editorial improvements\
    \ were made.\n   o  The discussion of control codes was updated to include additional\n\
    \      information and clarify that \"control code\" and \"control\n      character\"\
    \ are synonyms.\n   o  Many terms were clarified to reflect contemporary usage.\n\
    \   o  The index to terms by section in RFC 3536 was replaced by an index\n  \
    \    to pages containing considerably more terms.\n   o  The acknowledgments were\
    \ updated.\n   o  Some of the references were updated.\n   o  The supplemental\
    \ reading list was expanded somewhat.\n"
- title: Index
  contents:
  - "Index\n   A\n      A-label  31\n      ACE  30, 31\n      ACE Prefix  31\n   \
    \   alphabetic  20\n      ANSI  13\n      ASCII  15\n      ASCII-compatible encoding\
    \  30, 31\n      ASN.1 text formats  30\n   B\n      Base64  29\n      Basic Multilingual\
    \ Plane  13\n      bidi  26\n      bidirectional display  26\n      BMP  13\n\
    \      BMPString  30\n      BOCU-1  14\n      BOM  14\n      byte order mark \
    \ 14\n   C\n      C-T-E  29\n      case  18\n      CCS  7\n      CEN/ISSS  13\n\
    \      character  6\n      character encoding form  7\n      character encoding\
    \ scheme  8\n      character repertoire  7\n      charset  8\n      charset identification\
    \  28\n      CJK characters  34\n      code chart  19\n      code point  16\n\
    \      code table  19\n      coded character  6\n      coded character set  7\n\
    \      collation  18\n      combining character  16\n      combining character\
    \ sequence  16\n      compatibility character  22\n      compatibility variant\
    \  22\n      composite sequence  16\n      content-transfer-encoding  29\n   \
    \   control character  21\n      control code  21\n      control sequence  22\n\
    \   D\n      decomposed character  16\n      diacritic  21\n      displaying and\
    \ rendering text  10\n      Domain Name Slot  31\n   E\n      encoding forms \
    \ 13\n   F\n      font  25\n      formatting character  22\n   G\n      glyph\
    \  7\n      glyph code  7\n      graphic symbol  25\n   H\n      Han characters\
    \  34\n   I\n      i18n  9\n      IA5String  30\n      ideographic  20\n     \
    \ IDN  31\n      IDNA  31\n      IDNA-valid string  31\n      IDNA2003  31\n \
    \     IDNA2008  31\n      IME  24\n      input method editor  24\n      input\
    \ methods  24\n      internationalization  8\n      Internationalized Domain Name\
    \  31\n      Internationalized Label  31\n      ISO  11\n      ISO 639  11\n \
    \     ISO 3166  11\n      ISO 8859  15\n      ISO TC 46  11\n   J\n      JIS \
    \ 13\n      JTC 1  11\n   L\n      l10n  9\n      language  5\n      language\
    \ identification  29\n      Latin characters  34\n      LDH Label  30\n      letters\
    \  23\n      Local and regional standards organizations  13\n      locale  33\n\
    \      localization  9\n   M\n      MIME  29\n      multilingual  10\n   N\n \
    \     name spaces  28\n      Nameprep  31\n      NFC  17\n      NFD  17\n    \
    \  NFKC  17\n      NFKD  17\n      non-ASCII  23\n      nonspacing character \
    \ 21\n      normalization  17\n      NR-LDH label  31\n      NVT  15\n   O\n \
    \     on-the-wire encoding  28\n   P\n      parsed text  28\n      precomposed\
    \ character  16\n      PrintableString  30\n      private use charater  36\n \
    \     protocol elements  27\n      punctuation  21\n      Punycode  30, 31\n \
    \  Q\n      quoted-printable  29\n   R\n      regular expressions  36\n      rendering\
    \ rules  24\n      repertoire  7\n      romanization  34\n   S\n      SAC  13\n\
    \      script  5\n      SCSU  14\n      sorting  18\n      Stringprep  31\n  \
    \    surrogate pair  14\n      symbol  21\n   T\n      T61String  30\n      TeletexString\
    \  30\n      TES  29\n      transcoding  7\n      transcription  35\n      transfer\
    \ encoding syntax  29\n      transformation formats  13\n      translation  35\n\
    \      transliteration  34, 35\n      typeface  25\n   U\n      U-label  31\n\
    \      UCS-2  13\n      UCS-4  13\n      undisplayable character  26\n      Unicode\
    \ Consortium  12\n      US-ASCII  15\n      UTC  12\n      UTF-8  14\n      UTF-16\
    \  14\n      UTF-16BE  14\n      UTF-16LE  14\n      UTF-32  14\n      UTF8String\
    \  30\n   V\n      variant  32\n   W\n      W3C  13\n      World Wide Web Consortium\
    \  13\n      writing style  27\n      writing system  6\n   X\n      XML  13,\
    \ 30\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Paul Hoffman\n   VPN Consortium\n   EMail: paul.hoffman@vpnc.org\n\
    \   John C Klensin\n   1770 Massachusetts Ave, Ste 322\n   Cambridge, MA  02140\n\
    \   USA\n   Phone: +1 617 245 1457\n   EMail: john+ietf@jck.com\n"
