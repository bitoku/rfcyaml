- title: __initial_text__
  contents:
  - '                         RIB Information Model

    '
- title: Abstract
  contents:
  - "Abstract\n   Routing and routing functions in enterprise and carrier networks\
    \ are\n   typically performed by network devices (routers and switches) using\
    \ a\n   Routing Information Base (RIB).  Protocols and configurations push\n \
    \  data into the RIB, and the RIB manager installs state into the\n   hardware\
    \ for packet forwarding.  This document specifies an\n   information model for\
    \ the RIB to enable defining a standardized data\n   model.  The IETF's I2RS WG\
    \ used this document to design the I2RS RIB\n   data model.  This document is\
    \ being published to record the higher-\n   level information model decisions\
    \ for RIBs so that other developers\n   of RIBs may benefit from the design concepts.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are candidates for any level of Internet\n\
    \   Standard; see Section 2 of RFC 7841.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   https://www.rfc-editor.org/info/rfc8430.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2018 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (https://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   4\n     1.1.  Conventions Used in This Document . . . . . . . .\
    \ . . . .   6\n   2.  RIB Data  . . . . . . . . . . . . . . . . . . . . . . .\
    \ . . .   6\n     2.1.  RIB Definition  . . . . . . . . . . . . . . . . . . .\
    \ . .   7\n     2.2.  Routing Instance  . . . . . . . . . . . . . . . . . . .\
    \ .   7\n     2.3.  Route . . . . . . . . . . . . . . . . . . . . . . . . . .\
    \   8\n     2.4.  Nexthop . . . . . . . . . . . . . . . . . . . . . . . . .  10\n\
    \       2.4.1.  Base Nexthops . . . . . . . . . . . . . . . . . . . .  12\n  \
    \     2.4.2.  Derived Nexthops  . . . . . . . . . . . . . . . . . .  14\n    \
    \   2.4.3.  Nexthop Indirection . . . . . . . . . . . . . . . . .  15\n   3. \
    \ Reading from the RIB  . . . . . . . . . . . . . . . . . . . .  16\n   4.  Writing\
    \ to the RIB  . . . . . . . . . . . . . . . . . . . . .  16\n   5.  Notifications\
    \ . . . . . . . . . . . . . . . . . . . . . . . .  17\n   6.  RIB Grammar . .\
    \ . . . . . . . . . . . . . . . . . . . . . . .  17\n     6.1.  Nexthop Grammar\
    \ Explained . . . . . . . . . . . . . . . .  20\n   7.  Using the RIB Grammar\
    \ . . . . . . . . . . . . . . . . . . . .  20\n     7.1.  Using Route Preference\
    \  . . . . . . . . . . . . . . . . .  20\n     7.2.  Using Different Nexthop Types\
    \ . . . . . . . . . . . . . .  20\n       7.2.1.  Tunnel Nexthops . . . . . .\
    \ . . . . . . . . . . . . .  21\n       7.2.2.  Replication Lists . . . . . .\
    \ . . . . . . . . . . . .  21\n       7.2.3.  Weighted Lists  . . . . . . . .\
    \ . . . . . . . . . . .  21\n       7.2.4.  Protection  . . . . . . . . . . .\
    \ . . . . . . . . . .  22\n       7.2.5.  Nexthop Chains  . . . . . . . . . .\
    \ . . . . . . . . .  22\n       7.2.6.  Lists of Lists  . . . . . . . . . . .\
    \ . . . . . . . .  23\n     7.3.  Performing Multicast  . . . . . . . . . . .\
    \ . . . . . . .  24\n   8.  RIB Operations at Scale . . . . . . . . . . . . .\
    \ . . . . . .  25\n     8.1.  RIB Reads . . . . . . . . . . . . . . . . . . .\
    \ . . . . .  25\n     8.2.  RIB Writes  . . . . . . . . . . . . . . . . . . .\
    \ . . . .  25\n     8.3.  RIB Events and Notifications  . . . . . . . . . . .\
    \ . . .  25\n   9.  Security Considerations . . . . . . . . . . . . . . . . .\
    \ . .  25\n   10. IANA Considerations . . . . . . . . . . . . . . . . . . . .\
    \ .  26\n   11. References  . . . . . . . . . . . . . . . . . . . . . . . . .\
    \  26\n     11.1.  Normative References . . . . . . . . . . . . . . . . . .  26\n\
    \     11.2.  Informative References . . . . . . . . . . . . . . . . .  27\n  \
    \ Acknowledgements  . . . . . . . . . . . . . . . . . . . . . . . .  28\n   Authors'\
    \ Addresses  . . . . . . . . . . . . . . . . . . . . . . .  28\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Routing and routing functions in enterprise and carrier\
    \ networks are\n   traditionally performed in network devices.  Customarily, routers\
    \ run\n   routing protocols, and the routing protocols (along with static\n  \
    \ configuration information) populate the Routing Information Base\n   (RIB) of\
    \ the router.  The RIB is managed by the RIB manager, and the\n   RIB manager\
    \ provides a northbound interface to its clients (i.e., the\n   routing protocols)\
    \ to insert routes into the RIB.  The RIB manager\n   consults the RIB and decides\
    \ how to program the Forwarding\n   Information Base (FIB) of the hardware by\
    \ interfacing with the FIB\n   manager.  The relationship between these entities\
    \ is shown in\n   Figure 1.\n         +-------------+        +-------------+\n\
    \         |RIB Client 1 | ...... |RIB Client N |\n         +-------------+   \
    \     +-------------+\n                ^                      ^\n            \
    \    |                      |\n                +----------------------+\n    \
    \                       |\n                           V\n                +---------------------+\n\
    \                |    RIB Manager      |\n                |                  \
    \   |\n                |     +--------+      |\n                |     | RIB(s)\
    \ |      |\n                |     +--------+      |\n                +---------------------+\n\
    \                           ^\n                           |\n          +---------------------------------+\n\
    \          |                                 |\n          V                  \
    \               V\n   +----------------+               +----------------+\n  \
    \ | FIB Manager 1  |               | FIB Manager M  |\n   |   +--------+   | \
    \ ..........   |   +--------+   |\n   |   | FIB(s) |   |               |   | FIB(s)\
    \ |   |\n   |   +--------+   |               |   +--------+   |\n   +----------------+\
    \               +----------------+\n           Figure 1: RIB Manager, RIB Clients,\
    \ and FIB Managers\n   Routing protocols are inherently distributed in nature,\
    \ and each\n   router makes an independent decision based on the routing data\n\
    \   received from its peers.  With the advent of newer deployment\n   paradigms\
    \ and the need for specialized applications, there is an\n   emerging need to\
    \ guide the router's routing function [RFC7920].  The\n   traditional network-device\
    \ RIB population that is protocol based\n   suffices for most use cases where\
    \ distributed network control is\n   used.  However, there are use cases that\
    \ the network operators\n   currently address by configuring static routes, policies,\
    \ and RIB\n   import/export rules on the routers.  There is also a growing list\
    \ of\n   use cases in which a network operator might want to program the RIB\n\
    \   based on data unrelated to just routing (within that network's\n   domain).\
    \  Programming the RIB could be based on other information\n   (such as routing\
    \ data in the adjacent domain or the load on storage\n   and compute) in the given\
    \ domain.  Or, it could simply be a\n   programmatic way of creating on-demand\
    \ dynamic overlays (e.g., GRE\n   tunnels) between compute hosts (without requiring\
    \ the hosts to run\n   traditional routing protocols).  If there was a standardized,\n\
    \   publicly documented programmatic interface to a RIB, it would enable\n   further\
    \ networking applications that address a variety of use cases\n   [RFC7920].\n\
    \   A programmatic interface to the RIB involves two types of operations:\n  \
    \ reading from the RIB and writing (adding/modifying/deleting) to the\n   RIB.\n\
    \   In order to understand what is in a router's RIB, methods like per-\n   protocol\
    \ SNMP MIBs and screen scraping are used.  These methods are\n   not scalable\
    \ since they are client pull mechanisms and not proactive\n   push (from the router)\
    \ mechanisms.  Screen scraping is error prone\n   (since the output format can\
    \ change) and is vendor dependent.\n   Building a RIB from per-protocol MIBs is\
    \ error prone since the MIB\n   data represents protocol data and not the exact\
    \ information that went\n   into the RIB.  Thus, just getting read-only RIB information\
    \ from a\n   router is a hard task.\n   Adding content to the RIB from a RIB client\
    \ can be done today using\n   static configuration mechanisms provided by router\
    \ vendors.  However,\n   the mix of what can be modified in the RIB varies from\
    \ vendor to\n   vendor, and the method of configuring it is also vendor dependent.\n\
    \   This makes it hard for a RIB client to program a multi-vendor network\n  \
    \ in a consistent and vendor-independent way.\n   The purpose of this document\
    \ is to specify an information model for\n   the RIB.  Using the information model,\
    \ one can build a detailed data\n   model for the RIB.  That data model could\
    \ then be used by a RIB\n   client to program a network device.  One data model\
    \ that has been\n   based on this document is the I2RS RIB data model [RFC8431].\n\
    \   The rest of this document is organized as follows.  Section 2 goes\n   into\
    \ the details of what constitutes and can be programmed in a RIB.\n   Guidelines\
    \ for reading and writing the RIB are provided in Sections 3\n   and 4, respectively.\
    \  Section 5 provides a high-level view of the\n   events and notifications going\
    \ from a network device to a RIB client\n   to update the RIB client on asynchronous\
    \ events.  The RIB grammar is\n   specified in Section 6.  Examples of using the\
    \ RIB grammar are shown\n   in Section 7.  Section 8 covers considerations for\
    \ performing RIB\n   operations at scale.\n"
- title: 1.1.  Conventions Used in This Document
  contents:
  - "1.1.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST NOT\"\
    , \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\"\
    , \"NOT RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be\
    \ interpreted as described in\n   BCP 14 [RFC2119] [RFC8174] when, and only when,\
    \ they appear in all\n   capitals, as shown here.\n"
- title: 2.  RIB Data
  contents:
  - "2.  RIB Data\n   This section describes the details of a RIB.  It makes forward\n\
    \   references to objects in the RIB grammar (see Section 6).  A high-\n   level\
    \ description of the RIB contents is as shown in Figure 2.\n   Please note that\
    \ for ease of representation in ASCII art, this\n   drawing shows a single routing\
    \ instance, a single RIB, and a single\n   route.  Subsections of this section\
    \ describe the logical data nodes\n   that should be contained within a RIB. \
    \ Sections 3 and 4 describe the\n   high-level read and write operations.\n  \
    \                        network-device\n                                |\n \
    \                               | 0..N\n                                |\n  \
    \                       routing instance(s)\n                          |     \
    \        |\n                          |             |\n                    0..N\
    \  |             | 0..N\n                          |             |\n         \
    \            interface(s)     RIB(s)\n                                       \
    \ |\n                                        |\n                             \
    \           | 0..N\n                                        |\n              \
    \                        route(s)\n                      Figure 2: RIB Information\
    \ Model\n"
- title: 2.1.  RIB Definition
  contents:
  - "2.1.  RIB Definition\n   A RIB, in the context of the RIB information model,\
    \ is an entity that\n   contains routes.  It is identified by its name and is\
    \ contained\n   within a routing instance (see Section 2.2).  A network device\
    \ MAY\n   contain routing instances, and each routing instance MAY contain\n \
    \  RIBs.  The name MUST be unique within a routing instance.  All routes\n   in\
    \ a given RIB MUST be of the same address family (e.g., IPv4).  Each\n   RIB MUST\
    \ belong to a routing instance.\n   A routing instance may contain two or more\
    \ RIBs of the same address\n   family (e.g., IPv6).  A typical case where this\
    \ can be used is for\n   multi-topology routing [RFC4915] [RFC5120].\n   Each\
    \ RIB MAY be associated with an ENABLE_IP_RPF_CHECK attribute that\n   enables\
    \ Reverse Path Forwarding (RPF) checks on all IP routes in that\n   RIB.  The\
    \ RPF check is used to prevent spoofing and limit malicious\n   traffic.  For\
    \ IP packets, the IP source address is looked up and the\n   RPF interface(s)\
    \ associated with the route for that IP source address\n   is found.  If the incoming\
    \ IP packet's interface matches one of the\n   RPF interfaces, then the IP packet\
    \ is forwarded based on its IP\n   destination address; otherwise, the IP packet\
    \ is discarded.\n"
- title: 2.2.  Routing Instance
  contents:
  - "2.2.  Routing Instance\n   A routing instance, in the context of the RIB information\
    \ model, is a\n   collection of RIBs, interfaces, and routing parameters.  A routing\n\
    \   instance creates a logical slice of the router.  It allows different\n   logical\
    \ slices across a set of routers to communicate with each\n   other.  Layer 3\
    \ VPNs, Layer 2 VPNs (L2VPNs), and Virtual Private LAN\n   Service (VPLS) can\
    \ be modeled as routing instances.  Note that\n   modeling an L2VPN using a routing\
    \ instance only models the Layer 3\n   (RIB) aspect and does not model any Layer\
    \ 2 information (like ARP)\n   that might be associated with the L2VPN.\n   The\
    \ set of interfaces indicates which interfaces are associated with\n   this routing\
    \ instance.  The RIBs specify how incoming traffic is to\n   be forwarded, and\
    \ the routing parameters control the information in\n   the RIBs.  The intersection\
    \ set of interfaces of two routing\n   instances MUST be the null set.  In other\
    \ words, an interface MUST\n   NOT be present in two routing instances.  Thus,\
    \ a routing instance\n   describes the routing information and parameters across\
    \ a set of\n   interfaces.\n   A routing instance MUST contain the following mandatory\
    \ fields:\n   o  INSTANCE_NAME: A routing instance is identified by its name,\n\
    \      INSTANCE_NAME.  This MUST be unique across all routing instances\n    \
    \  in a given network device.\n   o  rib-list: This is the list of RIBs associated\
    \ with this routing\n      instance.  Each routing instance can have multiple\
    \ RIBs to\n      represent routes of different types.  For example, one would\
    \ put\n      IPv4 routes in one RIB and MPLS routes in another RIB.  The list\n\
    \      of RIBs can be an empty list.\n   A routing instance MAY contain the following\
    \ fields:\n   o  interface-list: This represents the list of interfaces associated\n\
    \      with this routing instance.  The interface list helps constrain\n     \
    \ the boundaries of packet forwarding.  Packets coming in on these\n      interfaces\
    \ are directly associated with the given routing\n      instance.  The interface\
    \ list contains a list of identifiers, with\n      each identifier uniquely identifying\
    \ an interface.\n   o  ROUTER_ID: This field identifies the network device in\
    \ control\n      plane interactions with other network devices.  This field is\
    \ to\n      be used if one wants to virtualize a physical router into multiple\n\
    \      virtual routers.  Each virtual router MUST have a unique\n      ROUTER_ID.\
    \  A ROUTER_ID MUST be unique across all network devices\n      in a given domain.\n\
    \   A routing instance may be created purely for the purposes of packet\n   processing\
    \ and may not have any interfaces associated with it.  For\n   example, an incoming\
    \ packet in routing instance A might have a\n   nexthop of routing instance B,\
    \ and after packet processing in B, the\n   nexthop might be routing instance\
    \ C.  Thus, routing instance B is not\n   associated with any interface.  And,\
    \ given that this routing instance\n   does not do any control-plane interaction\
    \ with other network devices,\n   a ROUTER_ID is also not needed.\n"
- title: 2.3.  Route
  contents:
  - "2.3.  Route\n   A route is essentially a match condition and an action following\
    \ the\n   match.  The match condition specifies the kind of route (IPv4, MPLS,\n\
    \   etc.) and the set of fields to match on.  Figure 3 represents the\n   overall\
    \ contents of a route.  Please note that for ease of depiction\n   in ASCII art,\
    \ only a single instance of the route-attribute, match\n   flags, and nexthop\
    \ is depicted.\n                                 route\n                     \
    \            | | |\n                       +---------+ | +----------+\n      \
    \                 |           |            |\n                  0..N |       \
    \    |            |\n         route-attribute         match         nexthop\n\
    \                                   |\n                                   |\n\
    \                   +-------+-------+-------+--------+\n                   | \
    \      |       |       |        |\n                   |       |       |      \
    \ |        |\n                  IPv4    IPv6    MPLS    MAC    Interface\n   \
    \                        Figure 3: Route Model\n   This document specifies the\
    \ following match types:\n   o  IPv4: Match on destination and/or source IP address\
    \ in the IPv4\n      header\n   o  IPv6: Match on destination and/or source IP\
    \ address in the IPv6\n      header\n   o  MPLS: Match on an MPLS label at the\
    \ top of the MPLS label stack\n   o  MAC: Match on Media Access Control (MAC)\
    \ destination addresses in\n      the Ethernet header\n   o  Interface: Match\
    \ on the incoming interface of the packet\n   A route MAY be matched on one or\
    \ more of these match types by policy\n   as either an \"AND\" (to restrict the\
    \ number of routes) or an \"OR\" (to\n   combine two filters).\n   Each route\
    \ MUST have the following mandatory route-attributes\n   associated with it:\n\
    \   o  ROUTE_PREFERENCE: This is a numerical value that allows for\n      comparing\
    \ routes from different protocols.  Static configuration\n      is also considered\
    \ a protocol for the purpose of this field.  It\n      is also known as \"administrative\
    \ distance\".  The lower the value,\n      the higher the preference.  For example,\
    \ there can be an OSPF\n      route for 192.0.2.1/32 (or IPv6 2001:DB8::1/128)\
    \ with a preference\n      of 5.  If a controller programs a route for 192.0.2.1/32\
    \ (or IPv6\n      2001:DB8::1/128) with a preference of 2, then the controller's\n\
    \      route will be preferred by the RIB manager.  Preference should be\n   \
    \   used to dictate behavior.  For more examples of preference, see\n      Section\
    \ 7.1.\n   Each route can have one or more optional route-attributes associated\n\
    \   with it.\n   o  route-vendor-attributes: Vendors can specify vendor-specific\n\
    \      attributes using this.  The details of this attribute are outside\n   \
    \   the scope of this document.\n   Each route has a nexthop associated with it.\
    \  Nexthops are described\n   in Section 2.4.\n   Additional features to match\
    \ multicast packets were considered (e.g.,\n   TTL of the packet to limit the\
    \ range of a multicast group), but these\n   were not added to this information\
    \ model.  Future RIB information\n   models should investigate these multicast\
    \ features.\n"
- title: 2.4.  Nexthop
  contents:
  - "2.4.  Nexthop\n   A nexthop represents an object resulting from a route lookup.\
    \  For\n   example, if a route lookup results in sending the packet out of a\n\
    \   given interface, then the nexthop represents that interface.\n   Nexthops\
    \ can be either fully resolved or unresolved.  A resolved\n   nexthop has adequate\
    \ information to send the outgoing packet to the\n   destination by forwarding\
    \ it on an interface to a directly connected\n   neighbor.  For example, a nexthop\
    \ to a point-to-point interface or a\n   nexthop to an IP address on an Ethernet\
    \ interface has the nexthop\n   resolved.  An unresolved nexthop is something\
    \ that requires the RIB\n   manager to determine the final resolved nexthop. \
    \ For example, a\n   nexthop could be an IP address.  The RIB manager would resolve\
    \ how to\n   reach that IP address; for example, is the IP address reachable by\n\
    \   regular IP forwarding, by an MPLS tunnel, or by both?  If the RIB\n   manager\
    \ cannot resolve the nexthop, then the nexthop remains in an\n   unresolved state\
    \ and is NOT a candidate for installation in the FIB.\n   Future RIB events can\
    \ cause an unresolved nexthop to get resolved\n   (e.g., an IP address being advertised\
    \ by an IGP neighbor).\n   Conversely, resolved nexthops can also become unresolved\
    \ (e.g., in\n   the case of a tunnel going down); hence, they would no longer\
    \ be\n   candidates to be installed in the FIB.\n   When at least one of a route's\
    \ nexthops is resolved, then the route\n   can be used to forward packets.  Such\
    \ a route is considered eligible\n   to be installed in the FIB and is henceforth\
    \ referred to as a FIB-\n   eligible route.  Conversely, when all the nexthops\
    \ of a route are\n   unresolved, that route can no longer be used to forward packets.\n\
    \   Such a route is considered ineligible to be installed in the FIB and\n   is\
    \ henceforth referred to as a FIB-ineligible route.  The RIB\n   information model\
    \ allows a RIB client to program routes whose\n   nexthops may be unresolved initially.\
    \  Whenever an unresolved nexthop\n   gets resolved, the RIB manager will send\
    \ a notification of the same\n   (see Section 5).\n   The overall structure and\
    \ usage of a nexthop is as shown in the\n   figure below.  For ease of description\
    \ using ASCII art, only a single\n   instance of any component of the nexthop\
    \ is shown in Figure 4.\n                               route\n              \
    \                   |\n                                 | 0..N\n             \
    \                    |\n                               nexthop <-------------------------------+\n\
    \                                 |                                     |\n  \
    \        +-------+----------------------------+-------------+         |\n    \
    \      |       |              |             |             |         |\n      \
    \    |       |              |             |             |         |\n       base\
    \   load-balance   protection      replicate     chain       |\n          |  \
    \     |              |             |             |         |\n          |    \
    \   |2..N          |2..N         |2..N         |1..N     |\n          |      \
    \ |              |             |             |         |\n          |       |\
    \              V             |             |         |\n          |       +------------->+<------------+-------------+\
    \         |\n          |                      |                              \
    \       |\n          |                      +-------------------------------------+\n\
    \          |\n          +-------------------+\n                              |\n\
    \                              |\n                              |\n          \
    \                    |\n     +---------------+--------+--------+--------------+----------+\n\
    \     |               |                 |              |          |\n     |  \
    \             |                 |              |          |\n  nexthop-id  egress-interface\
    \  ip-address     logical-tunnel    |\n                                      \
    \                           |\n                                              \
    \                   |\n                          +--------------------------------------+\n\
    \                          |\n       +----------------------+------------------+-------------+\n\
    \       |                      |                  |             |\n       |  \
    \                    |                  |             |\n tunnel-encapsulation\
    \   tunnel-decapsulation  rib-name   special-nexthop\n                       \
    \   Figure 4: Nexthop Model\n   This document specifies a very generic, extensible,\
    \ and recursive\n   grammar for nexthops.  A nexthop can be a base nexthop or\
    \ a derived\n   nexthop.  Section 2.4.1 details base nexthops, and Section 2.4.2\n\
    \   explains various kinds of derived nexthops.  There are certain\n   special\
    \ nexthops, and those are described in Section 2.4.1.1.\n   Lastly, Section 2.4.3\
    \ delves into nexthop indirection and its use.\n   Examples of when and how to\
    \ use tunnel nexthops and derived nexthops\n   are shown in Section 7.2.\n"
- title: 2.4.1.  Base Nexthops
  contents:
  - "2.4.1.  Base Nexthops\n   At the lowest level, a nexthop can be one of the following:\n\
    \   o  Identifier: This is an identifier returned by the network device\n    \
    \  representing a nexthop.  This can be used as a way of reusing a\n      nexthop\
    \ when programming derived nexthops.\n   o  Interface nexthops: These are nexthops\
    \ that are pointing to an\n      interface.  Various attributes associated with\
    \ these nexthops are:\n      *  Egress-interface: This represents a physical,\
    \ logical, or\n         virtual interface on the network device.  Address resolution\n\
    \         must not be required on this interface.  This interface may\n      \
    \   belong to any routing instance.\n      *  IP address: A route lookup on this\
    \ IP address is done to\n         determine the egress-interface.  Address resolution\
    \ may be\n         required depending on the interface.\n         +  An optional\
    \ rib-name can also be specified to indicate the\n            RIB in which the\
    \ IP address is to be looked up.  One can use\n            the rib-name field\
    \ to direct the packet from one domain into\n            another domain.  By default\
    \ the RIB will be the same as the\n            one that route belongs to.\n  \
    \    These attributes can be used in combination as follows:\n      *  Egress-interface\
    \ and IP address: This can be used in cases\n         where, e.g., the IP address\
    \ is a link-local address.\n      *  Egress-interface and MAC address: The egress-interface\
    \ must be\n         an Ethernet interface.  Address resolution is not required\
    \ for\n         this nexthop.\n   o  Tunnel nexthops: These are nexthops that\
    \ are pointing to a tunnel.\n      The types of tunnel nexthops are:\n      *\
    \  tunnel-encapsulation: This can be an encapsulation representing\n         an\
    \ IP tunnel, MPLS tunnel, or others as defined in this\n         document.  An\
    \ optional egress-interface can be chained to the\n         tunnel-encapsulation\
    \ to indicate which interface to send the\n         packet out on.  The egress-interface\
    \ is useful when the network\n         device contains Ethernet interfaces and\
    \ one needs to perform\n         address resolution for the IP packet.\n     \
    \ *  tunnel-decapsulation: This is to specify decapsulating a tunnel\n       \
    \  header.  After decapsulation, further lookup on the packet can\n         be\
    \ done via chaining it with another nexthop.  The packet can\n         also be\
    \ sent out via an egress-interface directly.\n      *  logical-tunnel: This can\
    \ be an MPLS Label Switched Path (LSP)\n         or a GRE tunnel (or others as\
    \ defined in this document) that is\n         represented by a unique identifier\
    \ (e.g., name).\n   o  rib-name: A nexthop pointing to a RIB.  This indicates\
    \ that the\n      route lookup needs to continue in the specified RIB.  This is\
    \ a\n      way to perform chained lookups.\n   Tunnel nexthops allow a RIB client\
    \ to program static tunnel headers.\n   There can be cases where the remote tunnel\
    \ endpoint does not support\n   dynamic signaling (e.g., no LDP support on a host);\
    \ in those cases,\n   the RIB client might want to program the tunnel header on\
    \ both ends\n   of the tunnel.  The tunnel nexthop is kept generic with\n   specifications\
    \ provided for some commonly used tunnels.  It is\n   expected that the data model\
    \ will model these tunnel types with\n   complete accuracy.\n"
- title: 2.4.1.1.  Special Nexthops
  contents:
  - "2.4.1.1.  Special Nexthops\n   Special nexthops are for performing specific well-defined\
    \ functions\n   (e.g., DISCARD).  The purpose of each of them is explained below:\n\
    \   o  DISCARD: This indicates that the network device should drop the\n     \
    \ packet and increment a drop counter.\n   o  DISCARD_WITH_ERROR: This indicates\
    \ that the network device should\n      drop the packet, increment a drop counter,\
    \ and send back an\n      appropriate error message (like ICMP error).\n   o \
    \ RECEIVE: This indicates that the traffic is destined for the\n      network\
    \ device, for example, protocol packets or Operations,\n      Administration,\
    \ and Maintenance (OAM) packets.  All locally\n      destined traffic SHOULD be\
    \ throttled to avoid a denial-of-service\n      attack on the router's control\
    \ plane.  An optional rate limiter\n      can be specified to indicate how to\
    \ throttle traffic destined for\n      the control plane.  The description of\
    \ the rate limiter is outside\n      the scope of this document.\n"
- title: 2.4.2.  Derived Nexthops
  contents:
  - "2.4.2.  Derived Nexthops\n   Derived nexthops can be:\n   o  weighted lists,\
    \ which are used for load-balancing;\n   o  preference lists, which are used for\
    \ protection using primary and\n      backup;\n   o  replication lists, which\
    \ are lists of nexthops to which to\n      replicate a packet;\n   o  nexthop\
    \ chains, which are for chaining multiple operations or\n      attaching multiple\
    \ headers; or\n   o  lists of lists, which are a recursive application of the\
    \ above.\n   Nexthop chains (see Section 7.2.5 for usage) are a way to perform\n\
    \   multiple operations on a packet by logically combining them.  For\n   example,\
    \ one can chain together \"decapsulate MPLS header\" and \"send\n   it out a specific\
    \ egress-interface\".  Chains can be used to specify\n   multiple headers over\
    \ a packet before a packet is forwarded.  One\n   simple example is that of MPLS\
    \ over GRE, wherein the packet has an\n   inner MPLS header followed by a GRE\
    \ header followed by an IP header.\n   The outermost IP header is decided by the\
    \ network device, whereas the\n   MPLS header or GRE header is specified by the\
    \ controller.  Not every\n   network device will be able to support all kinds\
    \ of nexthop chains\n   and an arbitrary number of headers chained together. \
    \ The RIB data\n   model SHOULD provide a way to expose a nexthop chaining capability\n\
    \   supported by a given network device.\n   It is expected that all network devices\
    \ will have a limit on how many\n   levels of lookup can be performed, and not\
    \ all hardware will be able\n   to support all kinds of nexthops.  RIB capability\
    \ negotiation becomes\n   very important for this reason, and a RIB data model\
    \ MUST specify a\n   way for a RIB client to learn about the network device's\n\
    \   capabilities.\n"
- title: 2.4.2.1.  Nexthop List Attributes
  contents:
  - "2.4.2.1.  Nexthop List Attributes\n   For nexthops that are of the form of a\
    \ list(s), attributes can be\n   associated with each member of the list to indicate\
    \ the role of an\n   individual member of the list.  Two attributes are specified:\n\
    \   o  NEXTHOP_PREFERENCE: This is used for protection schemes.  It is an\n  \
    \    integer value between 1 and 99.  A lower value indicates higher\n      preference.\
    \  To download a primary/standby pair to the FIB, the\n      nexthops that are\
    \ resolved and have the two highest preferences\n      are selected.  Each <NEXTHOP_PREFERENCE>\
    \ should have a unique\n      value within a <nexthop-protection> (see Section\
    \ 6).\n   o  NEXTHOP_LB_WEIGHT: This is used for load-balancing.  Each list\n\
    \      member MUST be assigned a weight between 1 and 99.  The weight\n      determines\
    \ the proportion of traffic to be sent over a nexthop\n      used for forwarding\
    \ as a ratio of the weight of this nexthop\n      divided by the weights of all\
    \ the nexthops of this route that are\n      used for forwarding.  To perform\
    \ equal load-balancing, one MAY\n      specify a weight of \"0\" for all the member\
    \ nexthops.  The value\n      \"0\" is reserved for equal load-balancing and,\
    \ if applied, MUST be\n      applied to all member nexthops.  Note that a weight\
    \ of 0 is\n      special because of historical reasons.\n"
- title: 2.4.3.  Nexthop Indirection
  contents:
  - "2.4.3.  Nexthop Indirection\n   Nexthops can be identified by an identifier to\
    \ create a level of\n   indirection.  The identifier is set by the RIB manager\
    \ and returned\n   to the RIB client on request.\n   One example of usage of indirection\
    \ is a nexthop that points to\n   another network device (e.g., a BGP peer). \
    \ The returned nexthop\n   identifier can then be used for programming routes\
    \ to point to the\n   this nexthop.  Given that the RIB manager has created an\
    \ indirection\n   using the nexthop identifier, if the transport path to the network\n\
    \   device (BGP peer) changes, that change in path will be seamless to\n   the\
    \ RIB client and all routes that point to that network device will\n   automatically\
    \ start going over the new transport path.  Nexthop\n   indirection using identifiers\
    \ could be applied to not only unicast\n   nexthops but also nexthops that contain\
    \ chains and nested nexthops.\n   See Section 2.4.2 for examples.\n"
- title: 3.  Reading from the RIB
  contents:
  - "3.  Reading from the RIB\n   A RIB data model MUST allow a RIB client to read\
    \ entries for RIBs\n   created by that entity.  The network device administrator\
    \ MAY allow\n   reading of other RIBs by a RIB client through access lists on\
    \ the\n   network device.  The details of access lists are outside the scope of\n\
    \   this document.\n   The data model MUST support a full read of the RIB and\
    \ subsequent\n   incremental reads of changes to the RIB.  When sending data to\
    \ a RIB\n   client, the RIB manager SHOULD try to send all dependencies of an\n\
    \   object prior to sending that object.\n"
- title: 4.  Writing to the RIB
  contents:
  - "4.  Writing to the RIB\n   A RIB data model MUST allow a RIB client to write\
    \ entries for RIBs\n   created by that entity.  The network device administrator\
    \ MAY allow\n   writes to other RIBs by a RIB client through access lists on the\n\
    \   network device.  The details of access lists are outside the scope of\n  \
    \ this document.\n   When writing an object to a RIB, the RIB client SHOULD try\
    \ to write\n   all dependencies of the object prior to sending that object.  The\n\
    \   data model SHOULD support requesting identifiers for nexthops and\n   collecting\
    \ the identifiers back in the response.\n   Route programming in the RIB MUST\
    \ result in a return code that\n   contains the following attributes:\n   o  Installed:\
    \ Yes/No (indicates whether the route got installed in\n      the FIB)\n   o \
    \ Active: Yes/No (indicates whether a route is fully resolved and is\n      a\
    \ candidate for selection)\n   o  Reason: E.g., \"Not authorized\"\n   The data\
    \ model MUST specify which objects can be modified.  An object\n   that can be\
    \ modified is one whose contents can be changed without\n   having to change objects\
    \ that depend on it and without affecting any\n   data forwarding.  To change\
    \ a non-modifiable object, one will need to\n   create a new object and delete\
    \ the old one.  For example, routes that\n   use a nexthop that is identified\
    \ by a nexthop identifier should be\n   unaffected when the contents of that nexthop\
    \ changes.\n"
- title: 5.  Notifications
  contents:
  - "5.  Notifications\n   Asynchronous notifications are sent by the network device's\
    \ RIB\n   manager to a RIB client when some event occurs on the network device.\n\
    \   A RIB data model MUST support sending asynchronous notifications.  A\n   brief\
    \ list of suggested notifications is as below:\n   o  Route change notification\
    \ (with a return code as specified in\n      Section 4)\n   o  Nexthop resolution\
    \ status (resolved/unresolved) notification\n"
- title: 6.  RIB Grammar
  contents:
  - "6.  RIB Grammar\n   This section specifies the RIB information model in Routing\
    \ Backus-\n   Naur Form (rBNF) [RFC5511].  This grammar is intended to help the\n\
    \   reader better understand Section 2 in order to derive a data model.\n <routing-instance>\
    \ ::= <INSTANCE_NAME>\n                        [<interface-list>] <rib-list>\n\
    \                        [<ROUTER_ID>]\n <interface-list> ::= (<INTERFACE_IDENTIFIER>\
    \ ...)\n <rib-list> ::= (<rib> ...)\n <rib> ::= <rib-name> <address-family>\n\
    \                     [<route> ... ]\n                     [ENABLE_IP_RPF_CHECK]\n\
    \ <address-family> ::= <IPV4_ADDRESS_FAMILY> | <IPV6_ADDRESS_FAMILY> |\n     \
    \                 <MPLS_ADDRESS_FAMILY> | <IEEE_MAC_ADDRESS_FAMILY>\n <route>\
    \ ::= <match> <nexthop>\n             [<route-attributes>]\n             [<route-vendor-attributes>]\n\
    \ <match> ::= <IPV4> <ipv4-route> | <IPV6> <ipv6-route> |\n             <MPLS>\
    \ <MPLS_LABEL> | <IEEE_MAC> <MAC_ADDRESS> |\n             <INTERFACE> <INTERFACE_IDENTIFIER>\n\
    \ <route-type> ::= <IPV4> | <IPV6> | <MPLS> | <IEEE_MAC> | <INTERFACE>\n <ipv4-route>\
    \ ::= <ip-route-type>\n                  (<destination-ipv4-address> | <source-ipv4-address>\
    \ |\n                   (<destination-ipv4-address> <source-ipv4-address>))\n\
    \ <destination-ipv4-address> ::= <ipv4-prefix>\n <source-ipv4-address> ::= <ipv4-prefix>\n\
    \ <ipv4-prefix> ::= <IPV4_ADDRESS> <IPV4_PREFIX_LENGTH>\n <ipv6-route> ::= <ip-route-type>\n\
    \                  (<destination-ipv6-address> | <source-ipv6-address> |\n   \
    \                (<destination-ipv6-address> <source-ipv6-address>))\n <destination-ipv6-address>\
    \ ::= <ipv6-prefix>\n <source-ipv6-address> ::= <ipv6-prefix>\n <ipv6-prefix>\
    \ ::= <IPV6_ADDRESS> <IPV6_PREFIX_LENGTH>\n <ip-route-type> ::= <SRC> | <DEST>\
    \ | <DEST_SRC>\n <route-attributes> ::= <ROUTE_PREFERENCE> [<LOCAL_ONLY>]\n  \
    \                      [<address-family-route-attributes>]\n <address-family-route-attributes>\
    \ ::= <ip-route-attributes> |\n                                       <mpls-route-attributes>\
    \ |\n                                       <ethernet-route-attributes>\n <ip-route-attributes>\
    \ ::= <>\n <mpls-route-attributes> ::= <>\n <ethernet-route-attributes> ::= <>\n\
    \ <route-vendor-attributes> ::= <>\n <nexthop> ::= <nexthop-base> |\n        \
    \       (<NEXTHOP_LOAD_BALANCE> <nexthop-lb>) |\n               (<NEXTHOP_PROTECTION>\
    \ <nexthop-protection>) |\n               (<NEXTHOP_REPLICATE> <nexthop-replicate>)\
    \ |\n               <nexthop-chain>\n <nexthop-base> ::= <NEXTHOP_ID> |\n    \
    \                <nexthop-special> |\n                    <egress-interface> |\n\
    \                    <ipv4-address> | <ipv6-address> |\n                    (<egress-interface>\n\
    \                        (<ipv4-address> | <ipv6-address>)) |\n              \
    \      (<egress-interface> <IEEE_MAC_ADDRESS>) |\n                    <tunnel-encapsulation>\
    \ | <tunnel-decapsulation> |\n                    <logical-tunnel> |\n       \
    \             <rib-name>\n <egress-interface> ::= <INTERFACE_IDENTIFIER>\n <nexthop-special>\
    \ ::= <DISCARD> | <DISCARD_WITH_ERROR> |\n                       (<RECEIVE> [<COS_VALUE>])\n\
    \ <nexthop-lb> ::= <NEXTHOP_LB_WEIGHT> <nexthop>\n                  (<NEXTHOP_LB_WEIGHT>\
    \ <nexthop) ...\n <nexthop-protection> = <NEXTHOP_PREFERENCE> <nexthop>\n    \
    \                   (<NEXTHOP_PREFERENCE> <nexthop>)...\n <nexthop-replicate>\
    \ ::= <nexthop> <nexthop> ...\n <nexthop-chain> ::= <nexthop> ...\n <logical-tunnel>\
    \ ::= <tunnel-type> <TUNNEL_NAME>\n <tunnel-type> ::= <IPV4> | <IPV6> | <MPLS>\
    \ | <GRE> | <VxLAN> | <NVGRE>\n <tunnel-encapsulation> ::= (<IPV4> <ipv4-header>)\
    \ |\n                            (<IPV6> <ipv6-header>) |\n                  \
    \          (<MPLS> <mpls-header>) |\n                            (<GRE> <gre-header>)\
    \ |\n                            (<VXLAN> <vxlan-header>) |\n                \
    \            (<NVGRE> <nvgre-header>)\n <ipv4-header> ::= <SOURCE_IPv4_ADDRESS>\
    \ <DESTINATION_IPv4_ADDRESS>\n                   <PROTOCOL> [<TTL>] [<DSCP>]\n\
    \ <ipv6-header> ::= <SOURCE_IPV6_ADDRESS> <DESTINATION_IPV6_ADDRESS>\n       \
    \            <NEXT_HEADER> [<TRAFFIC_CLASS>]\n                   [<FLOW_LABEL>]\
    \ [<HOP_LIMIT>]\n <mpls-header> ::= (<mpls-label-operation> ...)\n <mpls-label-operation>\
    \ ::= (<MPLS_PUSH> <MPLS_LABEL> [<S_BIT>]\n                                  \
    \       [<TOS_VALUE>] [<TTL_VALUE>]) |\n                            (<MPLS_SWAP>\
    \ <IN_LABEL> <OUT_LABEL>\n                                        [<TTL_ACTION>])\n\
    \ <gre-header> ::= <GRE_IP_DESTINATION> <GRE_PROTOCOL_TYPE> [<GRE_KEY>]\n <vxlan-header>\
    \ ::= (<ipv4-header> | <ipv6-header>)\n                    [<VXLAN_IDENTIFIER>]\n\
    \ <nvgre-header> ::= (<ipv4-header> | <ipv6-header>)\n                    <VIRTUAL_SUBNET_ID>\n\
    \                    [<FLOW_ID>]\n <tunnel-decapsulation> ::= ((<IPV4> <IPV4_DECAP>\
    \ [<TTL_ACTION>]) |\n                            (<IPV6> <IPV6_DECAP> [<HOP_LIMIT_ACTION>])\
    \ |\n                            (<MPLS> <MPLS_POP> [<TTL_ACTION>]))\n       \
    \                 Figure 5: RIB rBNF Grammar\n"
- title: 6.1.  Nexthop Grammar Explained
  contents:
  - "6.1.  Nexthop Grammar Explained\n   A nexthop is used to specify the next network\
    \ element to forward the\n   traffic to.  It is also used to specify how the traffic\
    \ should be\n   load-balanced, protected using preference, or multicast using\n\
    \   replication.  This is explicitly specified in the grammar.  The\n   nexthop\
    \ has recursion built in to address complex use cases like the\n   one defined\
    \ in Section 7.2.6.\n"
- title: 7.  Using the RIB Grammar
  contents:
  - "7.  Using the RIB Grammar\n   The RIB grammar is very generic and covers a variety\
    \ of features.\n   This section provides examples on using objects in the RIB\
    \ grammar\n   and examples to program certain use cases.\n"
- title: 7.1.  Using Route Preference
  contents:
  - "7.1.  Using Route Preference\n   Using route preference, a client can preinstall\
    \ alternate paths in\n   the network.  For example, if OSPF has a route preference\
    \ of 10, then\n   another client can install a route with a route preference of\
    \ 20 to\n   the same destination.  The OSPF route will get precedence and will\n\
    \   get installed in the FIB.  When the OSPF route is withdrawn, the\n   alternate\
    \ path will get installed in the FIB.\n   Route preference can also be used to\
    \ prevent denial-of-service\n   attacks by installing routes with the best preference,\
    \ which either\n   drops the offending traffic or routes it to some monitoring/analysis\n\
    \   station.  Since the routes are installed with the best preference,\n   they\
    \ will supersede any route installed by any other protocol.\n"
- title: 7.2.  Using Different Nexthop Types
  contents:
  - "7.2.  Using Different Nexthop Types\n   The RIB grammar allows one to create\
    \ a variety of nexthops.  This\n   section describes uses for certain types of\
    \ nexthops.\n"
- title: 7.2.1.  Tunnel Nexthops
  contents:
  - "7.2.1.  Tunnel Nexthops\n   A tunnel nexthop points to a tunnel of some kind.\
    \  Traffic that goes\n   over the tunnel gets encapsulated with the tunnel-encapsulation.\n\
    \   Tunnel nexthops are useful for abstracting out details of the network\n  \
    \ by having the traffic seamlessly route between network edges.  At the\n   end\
    \ of a tunnel, the tunnel will get decapsulated.  Thus, the grammar\n   supports\
    \ two kinds of operations: one for encapsulation and another\n   for decapsulation.\n"
- title: 7.2.2.  Replication Lists
  contents:
  - "7.2.2.  Replication Lists\n   One can create a replication list for replicating\
    \ traffic to multiple\n   destinations.  The destinations, in turn, could be derived\
    \ nexthops\n   in themselves (at a level supported by the network device); point\
    \ to\n   multipoint and broadcast are examples that involve replication.\n   A\
    \ replication list (at the simplest level) can be represented as:\n   <nexthop>\
    \ ::= <NEXTHOP_REPLICATE> <nexthop> [ <nexthop> ... ]\n   The above can be derived\
    \ from the grammar as follows:\n   <nexthop> ::= <nexthop-replicate>\n   <nexthop>\
    \ ::= <NEXTHOP_REPLICATE> <nexthop> <nexthop> ...\n"
- title: 7.2.3.  Weighted Lists
  contents:
  - "7.2.3.  Weighted Lists\n   A weighted list is used to load-balance traffic among\
    \ a set of\n   nexthops.  From a modeling perspective, a weighted list is very\n\
    \   similar to a replication list, with the difference that each member\n   nexthop\
    \ MUST have a NEXTHOP_LB_WEIGHT associated with it.\n   A weighted list (at the\
    \ simplest level) can be represented as:\n   <nexthop> ::= <NEXTHOP_LOAD_BALANCE>\
    \ (<nexthop> <NEXTHOP_LB_WEIGHT>)\n                      [(<nexthop> <NEXTHOP_LB_WEIGHT>)...\
    \ ]\n   The above can be derived from the grammar as follows:\n   <nexthop> ::=\
    \ <nexthop-lb>\n   <nexthop> ::= <NEXTHOP_LOAD_BALANCE>\n                   <NEXTHOP_LB_WEIGHT>\
    \ <nexthop>\n                   (<NEXTHOP_LB_WEIGHT> <nexthop>) ...\n   <nexthop>\
    \ ::= <NEXTHOP_LOAD_BALANCE> (<NEXTHOP_LB_WEIGHT> <nexthop>)\n               \
    \    (<NEXTHOP_LB_WEIGHT> <nexthop>) ...\n"
- title: 7.2.4.  Protection
  contents:
  - "7.2.4.  Protection\n   A primary/backup protection can be represented as:\n \
    \  <nexthop> ::= <NEXTHOP_PROTECTION> <1> <interface-primary>\n              \
    \                        <2> <interface-backup>)\n   The above can be derived\
    \ from the grammar as follows:\n"
- title: <nexthop> ::= <nexthop-protection>
  contents:
  - '<nexthop> ::= <nexthop-protection>

    '
- title: <nexthop> ::= <NEXTHOP_PROTECTION> (<NEXTHOP_PREFERENCE> <nexthop>
  contents:
  - "<nexthop> ::= <NEXTHOP_PROTECTION> (<NEXTHOP_PREFERENCE> <nexthop>\n        \
    \              (<NEXTHOP_PREFERENCE> <nexthop>)...)\n"
- title: <nexthop> ::= <NEXTHOP_PROTECTION> (<NEXTHOP_PREFERENCE> <nexthop>
  contents:
  - "<nexthop> ::= <NEXTHOP_PROTECTION> (<NEXTHOP_PREFERENCE> <nexthop>\n        \
    \              (<NEXTHOP_PREFERENCE> <nexthop>))\n"
- title: <nexthop> ::= <NEXTHOP_PROTECTION> ((<NEXTHOP_PREFERENCE> <nexthop-base>
  contents:
  - "<nexthop> ::= <NEXTHOP_PROTECTION> ((<NEXTHOP_PREFERENCE> <nexthop-base>\n  \
    \                    (<NEXTHOP_PREFERENCE> <nexthop-base>))\n"
- title: <nexthop> ::= <NEXTHOP_PROTECTION> (<1> <interface-primary>
  contents:
  - "<nexthop> ::= <NEXTHOP_PROTECTION> (<1> <interface-primary>\n               \
    \       (<2> <interface-backup>))\n   Traffic can be load-balanced among multiple\
    \ primary nexthops and a\n   single backup.  In such a case, the nexthop will\
    \ look like:\n   <nexthop> ::= <NEXTHOP_PROTECTION> (<1>\n                 (<NEXTHOP_LOAD_BALANCE>\n\
    \                  (<NEXTHOP_LB_WEIGHT> <nexthop-base>\n                  (<NEXTHOP_LB_WEIGHT>\
    \ <nexthop-base>) ...))\n                   <2> <nexthop-base>)\n   A backup can\
    \ also have another backup.  In such a case, the list will\n   look like:\n  \
    \ <nexthop> ::= <NEXTHOP_PROTECTION> (<1> <nexthop>\n                 <2> <NEXTHOP_PROTECTION>(<1>\
    \ <nexthop> <2> <nexthop>))\n"
- title: 7.2.5.  Nexthop Chains
  contents:
  - "7.2.5.  Nexthop Chains\n   A nexthop chain is a way to perform multiple operations\
    \ on a packet\n   by logically combining them.  For example, when a VPN packet\
    \ comes on\n   the WAN interface and has to be forwarded to the correct VPN\n\
    \   interface, one needs to pop the VPN label before sending the packet\n   out.\
    \  Using a nexthop chain, one can chain together \"pop MPLS header\"\n   and \"\
    send it out a specific egress-interface\".\n   The above example can be derived\
    \ from the grammar as follows:\n   <nexthop-chain> ::= <nexthop> <nexthop>\n \
    \  <nexthop-chain> ::= <nexthop-base> <nexthop-base>\n   <nexthop-chain> ::= <tunnel-decapsulation>\
    \ <egress-interface>\n   <nexthop-chain> ::= (<MPLS> <MPLS_POP>) <interface-outgoing>\n\
    \   Elements in a nexthop chain are evaluated left to right.\n   A nexthop chain\
    \ can also be used to put one or more headers on an\n   outgoing packet.  One\
    \ example is a pseudowire, which is MPLS over\n   some transport (MPLS or GRE,\
    \ for instance).  Another example is\n   Virtual eXtensible Local Area Network\
    \ (VXLAN) over IP.  A nexthop\n   chain thus allows a RIB client to break up the\
    \ programming of the\n   nexthop into independent pieces (one per encapsulation).\n\
    \   A simple example of MPLS over GRE can be represented as follows:\n   <nexthop-chain>\
    \ ::= (<MPLS> <mpls-header>) (<GRE> <gre-header>)\n                       <interface-outgoing>\n\
    \   The above can be derived from the grammar as follows:\n   <nexthop-chain>\
    \ ::= <nexthop> <nexthop> <nexthop>\n   <nexthop-chain> ::= <nexthop-base> <nexthop-base>\
    \ <nexthop-base>\n   <nexthop-chain> ::= <tunnel-encapsulation> <tunnel-encapsulation>\n\
    \                       <egress-interface>\n   <nexthop-chain> ::= (<MPLS> <mpls-header>)\
    \ (<GRE> <gre-header>)\n                       <interface-outgoing>\n"
- title: 7.2.6.  Lists of Lists
  contents:
  - "7.2.6.  Lists of Lists\n   Lists of lists is a derived construct.  One example\
    \ of usage of such\n   a construct is to replicate traffic to multiple destinations\
    \ with\n   load-balancing.  In other words, for each branch of the replication\n\
    \   tree, there are multiple interfaces on which traffic needs to be\n   load-balanced.\
    \  So, the outer list is a replication list for\n   multicast and the inner lists\
    \ are weighted lists for load-balancing.\n   Let's take an example of a network\
    \ element that has to replicate\n   traffic to two other network elements.  Traffic\
    \ to the first network\n   element should be load-balanced equally over two interfaces:\n\
    \   outgoing-1-1 and outgoing-1-2.  Traffic to the second network element\n  \
    \ should be load-balanced over three interfaces: outgoing-2-1,\n   outgoing-2-2,\
    \ and outgoing-2-3 (in the ratio 20:20:60).\n   This can be derived from the grammar\
    \ as follows:\n"
- title: <nexthop> ::= <nexthop-replicate>
  contents:
  - '<nexthop> ::= <nexthop-replicate>

    '
- title: <nexthop> ::= <NEXTHOP_REPLICATE> (<nexthop> <nexthop>...)
  contents:
  - '<nexthop> ::= <NEXTHOP_REPLICATE> (<nexthop> <nexthop>...)

    '
- title: <nexthop> ::= <NEXTHOP_REPLICATE> (<nexthop> <nexthop>)
  contents:
  - '<nexthop> ::= <NEXTHOP_REPLICATE> (<nexthop> <nexthop>)

    '
- title: <nexthop> ::= <NEXTHOP_REPLICATE> ((<NEXTHOP_LOAD_BALANCE> <nexthop-lb>)
  contents:
  - "<nexthop> ::= <NEXTHOP_REPLICATE> ((<NEXTHOP_LOAD_BALANCE> <nexthop-lb>)\n  \
    \            (<NEXTHOP_LOAD_BALANCE> <nexthop-lb>))\n"
- title: <nexthop> ::= <NEXTHOP_REPLICATE> ((<NEXTHOP_LOAD_BALANCE>
  contents:
  - "<nexthop> ::= <NEXTHOP_REPLICATE> ((<NEXTHOP_LOAD_BALANCE>\n              (<NEXTHOP_LB_WEIGHT>\
    \ <nexthop>\n              (<NEXTHOP_LB_WEIGHT> <nexthop>) ...))\n           \
    \    ((<NEXTHOP_LOAD_BALANCE>\n                (<NEXTHOP_LB_WEIGHT> <nexthop>\n\
    \                (<NEXTHOP_LB_WEIGHT> <nexthop>) ...))\n"
- title: <nexthop> ::= <NEXTHOP_REPLICATE> ((<NEXTHOP_LOAD_BALANCE>
  contents:
  - "<nexthop> ::= <NEXTHOP_REPLICATE> ((<NEXTHOP_LOAD_BALANCE>\n              (<NEXTHOP_LB_WEIGHT>\
    \ <nexthop>\n               (<NEXTHOP_LB_WEIGHT> <nexthop>)))\n              \
    \  ((<NEXTHOP_LOAD_BALANCE>\n                (<NEXTHOP_LB_WEIGHT> <nexthop>\n\
    \                (<NEXTHOP_LB_WEIGHT> <nexthop>)\n                (<NEXTHOP_LB_WEIGHT>\
    \ <nexthop>)))\n"
- title: <nexthop> ::= <NEXTHOP_REPLICATE> ((<NEXTHOP_LOAD_BALANCE>
  contents:
  - "<nexthop> ::= <NEXTHOP_REPLICATE> ((<NEXTHOP_LOAD_BALANCE>\n               (<NEXTHOP_LB_WEIGHT>\
    \ <nexthop>)\n               (<NEXTHOP_LB_WEIGHT> <nexthop>)))\n             \
    \  ((<NEXTHOP_LOAD_BALANCE>\n               (<NEXTHOP_LB_WEIGHT> <nexthop>)\n\
    \               (<NEXTHOP_LB_WEIGHT> <nexthop>)\n               (<NEXTHOP_LB_WEIGHT>\
    \ <nexthop>)))\n"
- title: <nexthop> ::= <NEXTHOP_REPLICATE>
  contents:
  - "<nexthop> ::= <NEXTHOP_REPLICATE>\n               ((<NEXTHOP_LOAD_BALANCE>\n\
    \                 (50 <outgoing-1-1>)\n                 (50 <outgoing-1-2>)))\n\
    \                ((<NEXTHOP_LOAD_BALANCE>\n                  (20 <outgoing-2-1>)\n\
    \                  (20 <outgoing-2-2>)\n                  (60 <outgoing-2-3>)))\n"
- title: 7.3.  Performing Multicast
  contents:
  - "7.3.  Performing Multicast\n   IP multicast involves matching a packet on (S,G)\
    \ or (*,G), where both\n   S (Source) and G (Group) are IP prefixes.  Following\
    \ the match, the\n   packet is replicated to one or more recipients.  How the\
    \ recipients\n   subscribe to the multicast group is outside the scope of this\n\
    \   document.\n   In PIM-based multicast, the packets are IP forwarded on an IP\n\
    \   multicast tree.  The downstream nodes on each point in the multicast\n   tree\
    \ are one or more IP addresses.  These can be represented as a\n   replication\
    \ list (see Section 7.2.2).\n   In MPLS-based multicast, the packets are forwarded\
    \ on a Point-to-\n   Multipoint (P2MP) LSP.  The nexthop for a P2MP LSP can be\
    \ represented\n   in the nexthop grammar as a <logical-tunnel> (P2MP LSP identifier)\
    \ or\n   a replication list (see Section 7.2.2) of <tunnel-encapsulation>,\n \
    \  with each tunnel-encapsulation representing a single MPLS downstream\n   nexthop.\n"
- title: 8.  RIB Operations at Scale
  contents:
  - "8.  RIB Operations at Scale\n   This section discusses the scale requirements\
    \ for a RIB data model.\n   The RIB data model should be able to handle a large\
    \ scale of\n   operations to enable deployment of RIB applications in large\n\
    \   networks.\n"
- title: 8.1.  RIB Reads
  contents:
  - "8.1.  RIB Reads\n   Bulking (grouping of multiple objects in a single message)\
    \ MUST be\n   supported when a network device sends RIB data to a RIB client.\n\
    \   Similarly, the data model MUST enable a RIB client to request data in\n  \
    \ bulk from a network device.\n"
- title: 8.2.  RIB Writes
  contents:
  - "8.2.  RIB Writes\n   Bulking (grouping of multiple write operations in a single\
    \ message)\n   MUST be supported when a RIB client wants to write to the RIB.\
    \  The\n   response from the network device MUST include a return-code for each\n\
    \   write operation in the bulk message.\n"
- title: 8.3.  RIB Events and Notifications
  contents:
  - "8.3.  RIB Events and Notifications\n   There can be cases where a single network\
    \ event results in multiple\n   events and/or notifications from the network device\
    \ to a RIB client.\n   On the other hand, due to timing of multiple things happening\
    \ at the\n   same time, a network device might have to send multiple events and/or\n\
    \   notifications to a RIB client.  The network-device-originated event/\n   notification\
    \ message MUST support the bulking of multiple events and\n   notifications in\
    \ a single message.\n"
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   The information model specified in this document\
    \ defines a schema for\n   data models that are designed to be accessed via network\
    \ management\n   protocols such as NETCONF [RFC6241] or RESTCONF [RFC8040].  The\n\
    \   lowest NETCONF layer is the secure transport layer, and the\n   mandatory-to-implement\
    \ secure transport is Secure Shell (SSH)\n   [RFC6242].  The lowest RESTCONF layer\
    \ is HTTPS, and the mandatory-to-\n   implement secure transport is TLS [RFC8446].\n\
    \   The NETCONF access control model [RFC8341] provides the means to\n   restrict\
    \ access for particular NETCONF or RESTCONF users to a\n   preconfigured subset\
    \ of all available NETCONF or RESTCONF protocol\n   operations and content.\n\
    \   The RIB information model specifies read and write operations to\n   network\
    \ devices.  These network devices might be considered sensitive\n   or vulnerable\
    \ in some network environments.  Write operations to\n   these network devices\
    \ without proper protection can have a negative\n   effect on network operations.\
    \  Due to this factor, it is recommended\n   that data models also consider the\
    \ following in their design:\n   o  Require utilization of the authentication\
    \ and authorization\n      features of the NETCONF or RESTCONF suite of protocols.\n\
    \   o  Augment the limits on how much data can be written or updated by a\n  \
    \    remote entity built to include enough protection for a RIB data\n      model.\n\
    \   o  Expose the specific RIB data model implemented via NETCONF/\n      RESTCONF\
    \ data models.\n"
- title: 10.  IANA Considerations
  contents:
  - "10.  IANA Considerations\n   This document has no IANA actions.\n"
- title: 11.  References
  contents:
  - '11.  References

    '
- title: 11.1.  Normative References
  contents:
  - "11.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119,\n  \
    \            DOI 10.17487/RFC2119, March 1997,\n              <https://www.rfc-editor.org/info/rfc2119>.\n\
    \   [RFC6241]  Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder, J., Ed.,\n  \
    \            and A. Bierman, Ed., \"Network Configuration Protocol\n         \
    \     (NETCONF)\", RFC 6241, DOI 10.17487/RFC6241, June 2011,\n              <https://www.rfc-editor.org/info/rfc6241>.\n\
    \   [RFC6242]  Wasserman, M., \"Using the NETCONF Protocol over Secure\n     \
    \         Shell (SSH)\", RFC 6242, DOI 10.17487/RFC6242, June 2011,\n        \
    \      <https://www.rfc-editor.org/info/rfc6242>.\n   [RFC8040]  Bierman, A.,\
    \ Bjorklund, M., and K. Watsen, \"RESTCONF\n              Protocol\", RFC 8040,\
    \ DOI 10.17487/RFC8040, January 2017,\n              <https://www.rfc-editor.org/info/rfc8040>.\n\
    \   [RFC8174]  Leiba, B., \"Ambiguity of Uppercase vs Lowercase in RFC\n     \
    \         2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n        \
    \      May 2017, <https://www.rfc-editor.org/info/rfc8174>.\n   [RFC8341]  Bierman,\
    \ A. and M. Bjorklund, \"Network Configuration\n              Access Control Model\"\
    , STD 91, RFC 8341,\n              DOI 10.17487/RFC8341, March 2018,\n       \
    \       <https://www.rfc-editor.org/info/rfc8341>.\n   [RFC8446]  Rescorla, E.,\
    \ \"The Transport Layer Security (TLS) Protocol\n              Version 1.3\",\
    \ RFC 8446, DOI 10.17487/RFC8446, August 2018,\n              <https://www.rfc-editor.org/info/rfc8446>.\n"
- title: 11.2.  Informative References
  contents:
  - "11.2.  Informative References\n   [RFC4915]  Psenak, P., Mirtorabi, S., Roy,\
    \ A., Nguyen, L., and P.\n              Pillay-Esnault, \"Multi-Topology (MT)\
    \ Routing in OSPF\",\n              RFC 4915, DOI 10.17487/RFC4915, June 2007,\n\
    \              <https://www.rfc-editor.org/info/rfc4915>.\n   [RFC5120]  Przygienda,\
    \ T., Shen, N., and N. Sheth, \"M-ISIS: Multi\n              Topology (MT) Routing\
    \ in Intermediate System to\n              Intermediate Systems (IS-ISs)\", RFC\
    \ 5120,\n              DOI 10.17487/RFC5120, February 2008,\n              <https://www.rfc-editor.org/info/rfc5120>.\n\
    \   [RFC5511]  Farrel, A., \"Routing Backus-Naur Form (RBNF): A Syntax\n     \
    \         Used to Form Encoding Rules in Various Routing Protocol\n          \
    \    Specifications\", RFC 5511, DOI 10.17487/RFC5511, April\n              2009,\
    \ <https://www.rfc-editor.org/info/rfc5511>.\n   [RFC7920]  Atlas, A., Ed., Nadeau,\
    \ T., Ed., and D. Ward, \"Problem\n              Statement for the Interface to\
    \ the Routing System\",\n              RFC 7920, DOI 10.17487/RFC7920, June 2016,\n\
    \              <https://www.rfc-editor.org/info/rfc7920>.\n   [RFC8431]  Wang,\
    \ L., Chen, M., Dass, A., Ananthakrishnan, H., Kini,\n              S., and N.\
    \ Bahadur, \"A YANG Data Model for the Routing\n              Information Base\
    \ (RIB)\", RFC 8431, DOI 10.17487/RFC8431,\n              September 2018, <http://www.rfc-editor.org/info/rfc8431>.\n"
- title: Acknowledgements
  contents:
  - "Acknowledgements\n   The authors would like to thank Ron Folkes, Jeffrey Zhang,\
    \ the WG\n   co-Chairs, and reviewers for their comments and suggestions on this\n\
    \   document.  The following people contributed to the design of the RIB\n   information\
    \ model as part of the I2RS Interim meeting in April 2013:\n   Wes George, Chris\
    \ Liljenstolpe, Jeff Tantsura, Susan Hares, and\n   Fabian Schneider.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Nitin Bahadur (editor)\n   Uber\n   900 Arastradero Rd\n\
    \   Palo Alto, CA  94304\n   United States of America\n   Email: nitin_bahadur@yahoo.com\n\
    \   Sriganesh Kini (editor)\n   Email: sriganeshkini@gmail.com\n   Jan Medved\n\
    \   Cisco\n   Email: jmedved@cisco.com\n"
