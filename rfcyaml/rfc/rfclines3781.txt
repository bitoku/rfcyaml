Abstract SMIng (Structure of Management Information, Next Generation) (RFC3780), is a protocol independent data definition language for management information.
This memo defines an SMIng language extension that specifies the mapping of SMIng definitions of identities, classes, and their attributes and events to dedicated definitions of nodes, scalar objects, tables and columnar objects, and notifications, for application to the SNMP management framework.
(Structure of Management Information, Next Generation)
[RFC3780] is a protocol independent data definition language for management information.
This memo defines an SMIng language extension that specifies the mapping of SMIng definitions of identities, classes, and their attributes and events to dedicated definitions of nodes, scalar objects, tables and columnar objects, and notifications for application in the SNMP management framework.
Section 2 introduces basics of the SNMP management framework.
Section 3 defines how SMIng data types are mapped to the data types supported by the SNMP protocol.
It introduces some new ASN.1 [ASN1] definitions which are used to represent new SMIng base types such as floats in the SNMP protocol.
Section 4 describes the semantics of the SNMP mapping extensions for SMIng.
The formal SMIng specification of the extension is provided in Section 5.
Section 6 contains an SMIng module which defines derived types (such as RowStatus) that are specific to the SNMP mapping.
The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in [RFC2119].
The SNMP network management framework [RFC3410] is based on the concept of "managed objects".
Managed objects represent real or synthesized variables of systems that are to be managed.
Note that in spite of these terms this model is not object oriented.
For naming purposes, the managed objects are organized hierarchically in an "object identifier tree", where only leaf nodes may represent objects.
Nodes in the object identifier tree may also identify conceptual tables, rows of conceptual tables, notifications, groups of objects and/or notifications, compliance statements, modules or other information.
Each node is identified by an unique "object identifier" value which is a sequence of non negative numbers, named "sub identifiers", where the left most sub identifier refers to the node next to the root of the tree and the right most sub identifier refers to the node that is identified by the complete object identifier value.
Each sub identifier has a value between 0 and 2^32 1 (4294967295).
The SMIng extensions described in this document are used to map SMIng data definitions to SNMP compliant managed objects.
This mapping is designed to be readable to computer programs, named MIB compilers, as well as to human readers.
Each node in the object identifier tree is of a certain kind and may represent management information or not:
Simple nodes, that do not represent management information, but may be used for grouping nodes in a subtree.
Those nodes are defined by the `node' statement.
This statement can also be used to map an SMIng `identity' to a node.
Nodes representing the identity of a module to allow references to a module in other objects of type `ObjectIdentifier'.
Those nodes are defined by the `snmp' statement,  Scalar objects, which have exactly one object instance and no child nodes.
See Section 2.2 for scalar objects' instances.
A set of scalar objects is mapped from one or more SMIng classes using the `scalars' statement.
The statement block of the `scalars' statement contains one `implements' statement for each class.
The associated statement blocks in turn contain `object' statements that specify the mapping of attributes to scalar objects.
Scalar objects MUST not have any child node.
Tables, which represent the root node of a collection of information structured in table rows.
Table nodes are defined by the `table' statement.
A table object identifier SHOULD not have any other child node than the implicitly defined row node (see below).
Rows, which belong to a table (that is, row's object identifier consists of the table's full object identifier plus a single `1' sub identifier) and represent a sequence of one or more columnar objects.
A row node is implicitly defined for each table node.
Columnar objects, which belong to a row (that is, the columnar objects' object identifier consists of the row's full object identifier plus a single column identifying sub identifier) and have zero or more object instances and no child nodes.
They are defined as follows:
The classes that are implemented by a `table' statement are identified by `implements' statements.
The statement block of each `implements' statement contains `object' statements that specify the mapping of attributes to columnar objects of this table.
Columnar objects MUST not have any child node.
Notifications, which represent information that is sent by agents within unsolicited transmissions.
The `notification' statement is used to map an SMIng event to a notification.
A notification's object identifier SHOULD not have any child node.
Groups of objects and notifications, which may be used for compliance statements.
They are defined using the `group' statement.
Compliance statements which define requirements for MIB module implementations.
They are defined using the `compliance' statement.
Scalar and Columnar Object Instances Instances of managed objects are identified by appending an instance identifier to the object's object identifier.
Scalar objects and columnar objects use different ways to construct the instance identifier.
Scalar objects have exactly one object instance.
It is identified by appending a single `0' sub identifier to the object identifier of the scalar object.
Within tables, different instances of the same columnar object are identified by appending a sequence of one or more sub identifiers to the object identifier of the columnar object which consists of the values of object instances that unambiguously distinguish a table row.
These indexing objects can be columnar objects of the same and/or another table, but MUST NOT be scalar objects.
Multiple applications of the same object in a single table indexing specification are strongly discouraged.
The base types of the indexing objects indicate how to form the instance identifier:  integer valued or enumeration valued: a single sub identifier taking the integer value (this works only for non negative integers and integers of a size of up to 32 bits),  string valued, fixed length strings (or variable length with compact encoding): `n' sub identifiers, where `n' is the length of the string (each octet of the string is encoded in a separate sub identifier),  string valued, variable length strings or bits valued: `n 1' sub  identifiers, where `n' is the length of the string or bits
encoding (the first sub identifier is `n' itself, following this,
each octet of the string or bits is encoded in a separate sub  identifier),  object identifier valued (with compact encoding):
`n' sub  identifiers, where `n' is the number of sub identifiers in the value (each sub identifier of the value is copied into a separate sub identifier),  object identifier valued: `
n 1' sub identifiers, where `n' is the number of sub identifiers in the value (the first sub identifier is `n' itself, following this, each sub identifier in the value is copied), Note that compact encoding can only be applied to an object having a variable length syntax (e.g., variable length strings, bits objects or object identifier valued objects).
Further, compact encoding can only be associated with the last object in a list of indexing objects.
Finally, compact encoding MUST NOT be used on a variable  length string object if that string might have a value of zero  length.
Instances identified by use of integer valued or enumeration valued objects are RECOMMENDED to be numbered starting from one (i.e., not from zero).
Integer objects that allow negative values,
Unsigned64 objects, Integer64 objects and floating point objects MUST NOT be used for table indexing.
Objects which are both specified for indexing in a row and also columnar objects of the same row are termed auxiliary objects.
Auxiliary objects SHOULD be non accessible, except in the following circumstances:  within a module originally written to conform to SMIv1, or  a row must contain at least one columnar object which is not an auxiliary object.
In the event that all of a row's columnar objects are also specified to be indexing objects then one of them MUST be accessible.
The layers of the object identifier tree near the root are well defined and organized by standardization bodies.
The first level next to the root has three nodes:
joint iso ccitt Note that the renaming of the Commite Consultatif International de Telegraphique et Telephonique (CCITT) to International Telecommunications Union (ITU) had no consequence on the names used in the object identifier tree.
The root of the subtree administered by the Internet Assigned Numbers Authority (IANA) for the Internet is `1.3.6.1' which is assigned with the identifier `internet'.
That is, the Internet subtree of object identifiers starts with the prefix `1.3.6.1.'.
Several branches underneath this subtree are used for network management:
internet.2) subtree is used to identify "standard" definitions.
An information module produced by an IETF working group becomes a "standard" information module when the document is first approved by the IESG and enters the Internet standards track.
The `experimental' (internet.3) subtree is used to identify experimental definitions being designed by working groups of the IETF or IRTF.
If an information module produced by a working group becomes a "standard" module, then at the very beginning of its entry onto the Internet standards track, the definitions are moved under the mgmt subtree.
The `private' (internet.4) subtree is used to identify definitions defined unilaterally.
The `enterprises' (private.1) subtree beneath private is used, among other things, to permit providers of networking subsystems to register information modules of their products.
These and some other nodes are defined in the SMIng module NMRG  SMING SNMP EXT (Section 5).
SMIng Data Type Mappings SMIng [RFC3780] supports the following set of base types:
OctetString, Pointer, Integer32, Integer64, Unsigned32, Unsigned64, Float32, Float64, Float128, Enumeration, Bits, and ObjectIdentifier.
The SMIng core module NMRG SMING ([RFC3780], Appendix A) defines additional derived types, among them Counter32
(derived from Unsigned32), Counter64 (derived from Unsigned64),
TimeTicks32 and TimeTicks64 (derived from Unsigned32 and Unsigned64), IpAddress (derived from OctetString), and Opaque (derived from OctetString).
The version 2 of the protocol operations for SNMP document [RFC3416] defines the following 9 data types which are distinguished by the protocol: INTEGER, OCTET STRING, OBJECT IDENTIFIER, IpAddress, Counter32, TimeTicks, Opaque, Counter64, and Unsigned32.
The SMIng base types and their derived types are mapped to SNMP data types according to the following table:
This mapping includes all types derived from the OctetString type except those types derived from the IpAddress and Opaque SMIng types defined in the module NMRG SMING.
This type is encoded according to the ASN.1 type with the same name defined in Section 3.1.
The resulting BER encoded value is then wrapped in an Opaque value.
This mapping includes all types derived from the Unsigned32 type except those types derived from the Counter32 and TimeTicks32 SMIng types defined in the module NMRG SMING.
This mapping includes all types derived from the Unsigned64 type except those types derived from the Counter64
SMIng type defined in the module NMRG SMING.
The ASN.1 [ASN1] type definitions below introduce data types which are used to map the new SMIng base types into the set of ASN.1 types supported by the second version of SNMP protocol operations [RFC3416].
[APPLICATION 11] IMPLICIT INTEGER (0..18446744073709551615)
IMPLICIT OCTET STRING (SIZE (4))
IMPLICIT OCTET STRING (SIZE (8))
IMPLICIT OCTET STRING (SIZE (16))
The definitions of Integer64 and Unsigned64 are consistent with the same definitions in the SPPI [RFC3159].
The floating point types Float32,
Float64 and Float128 support single, double and quadruple IEEE floating point values.
The encoding of the values follows the "IEEE Standard for Binary Floating Point Arithmetic" as defined in ANSI/IEEE Standard 754 1985
The `snmp' statement is the main statement of the SNMP mapping specification.
It gets one or two arguments: an optional lower case identifier that specifies a node that represents the module's identity, and a mandatory statement block that contains all details of the SNMP mapping.
All information of an SNMP mapping are mapped to an SNMP conformant module of the same name as the containing SMIng module.
A single SMIng module must not contain more than one `snmp' statement.
The snmp's `oid' statement, which must be present, if the snmp statement contains a module identifier and must be absent otherwise, gets one argument which specifies the object identifier value that is assigned to this module's identity node.
The `node' statement is used to name and describe a node in the object identifier tree, without associating any class or attribute information with this node.
This may be useful to group definitions in a subtree of related management information, or to uniquely define an SMIng `identity' to be referenced in attributes of type Pointer.
The `node' statement gets two arguments: a lower case node identifier and a statement block that holds detailed node information in an obligatory order.
See the `nodeStatement' rule of the grammar (Section 5) for the formal syntax of the `node' statement.
The node's `oid' statement, which must be present, gets one argument which specifies the object identifier value that is assigned to this node.
The node's `represents' statement, which need not be present, makes this node represent an SMIng identity, so that objects of type Pointer can reference that identity.
The statement gets one argument which specifies the identity name.
The node's `status' statement, which must be present, gets one argument which is used to specify whether this node definition is current or historic.
The value `current' means that the definition is current and valid.
The value `obsolete' means the definition is obsolete and should not be implemented and/or can be removed if previously implemented.
While the value `deprecated' also indicates an obsolete definition, it permits new/continued implementation in order to foster interoperability with older/existing implementations.
The node's `description' statement, which need not be present, gets one argument which is used to specify a high level textual description of this node.
It is RECOMMENDED to include all semantics and purposes of this node.
The node's `reference' statement, which need not be present, gets one argument which is used to specify a textual cross reference to some other document, either another module which defines related definitions, or some other document which provides additional information relevant to this node.
The `scalars' statement is used to define the mapping of one or more classes to a group of SNMP scalar managed objects organized under a common parent node.
The `scalars' statement gets two arguments: a lower case scalar group identifier and a statement block that holds detailed mapping information of this scalar group in an obligatory order.
See the `scalarsStatement' rule of the grammar (Section 5) for the formal syntax of the `scalars' statement.
The scalars' `oid' statement, which must be present, gets one argument which specifies the object identifier value that is assigned to the common parent node of this scalar group.
The scalars' `object' statement, which must be present at least once, makes this scalar group contain a given scalar object.
It gets two arguments: the name of the scalar object to be defined and a statement block that holds additional detailed information in an obligatory order.
The `implements' statement, which must be present, is used to specify a single leaf attribute of a class that is implemented by this scalar object.
The type of this attribute must be a simple type, i.e., not a class.
The `subid' statement, which need not be present, is used to specify the sub identifier that identifies the scalar object within this scalar group, i.e., the object identifier of the scalar object is the concatenation of the values of this scalar group's oid statement and of this subid statement.
If this statement is omitted, the sub identifier is the one of the previous object statement within this scalar group plus 1.
If the containing object statement is the first one within the containing scalar group and the subid statement is omitted, the sub identifier is 1.
The object's `status' statement, which need not be present, gets one argument which is used to specify whether this scalar object definition is current or historic.
The value `current' means that the definition is current and valid.
The value `obsolete' means the definition is obsolete and should not be implemented and/or can be removed if previously implemented.
While the value `deprecated' also indicates an obsolete definition, it permits new/continued implementation in order to foster interoperability with older/existing implementations.
Scalar objects SHOULD NOT be defined as `current' if the implemented attribute definition is `deprecated' or `obsolete'.
Similarly, they SHOULD NOT be defined as `deprecated' if the implemented attribute is `obsolete'.
Nevertheless, subsequent revisions of used class definitions cannot be avoided, but SHOULD be taken into account in subsequent revisions of the local module.
Note that it is RECOMMENDED to omit the status statement which means that the status is inherited from the containing scalars statement.
However, if the status of a scalar object varies from the containing scalar group, it has to be expressed explicitly, e.g., if the implemented attribute has been deprecated or obsoleted.
The object's `description' statement, which need not be present, gets one argument which is used to specify a high level textual description of this scalar object.
Note that in contrast to other definitions this description statement is not mandatory and it is RECOMMENDED to omit it, if the object is fully described by the description of the implemented attribute.
The object's `reference' statement, which need not be present, gets one argument which is used to specify a textual cross reference to some other document, either another module which defines related definitions, or some other document which provides additional information relevant to this scalar object.
It is RECOMMENDED to omit this statement, if the object's references are fully described by the implemented attribute.
The scalars' `status' statement, which must be present, gets one argument which is used to specify whether this scalar group definition is current or historic.
The value `current' means that the definition is current and valid.
The value `obsolete' means the definition is obsolete and should not be implemented and/or can be removed if previously implemented.
While the value `deprecated' also indicates an obsolete definition, it permits new/continued implementation in order to foster interoperability with older/existing implementations.
The scalars' `description' statement, which must be present, gets one argument which is used to specify a high level textual description of this scalar group.
It is RECOMMENDED to include all semantic definitions necessary for the implementation of this scalar group.
The scalars' `reference' statement, which need not be present, gets one argument which is used to specify a textual cross reference to some other document, either another module which defines related definitions, or some other document which provides additional information relevant to this scalars statement.
The `table' statement is used to define the mapping of one or more classes to a single SNMP table of columnar managed objects.
The `table' statement gets two arguments: a lower case table identifier and a statement block that holds detailed mapping information of this table in an obligatory order.
See the `tableStatement' rule of the grammar (Section 5) for the formal syntax of the `table' statement.
The table's `oid' statement, which must be present, gets one argument which specifies the object identifier value that is assigned to this table's node.
Table Indexing Statements SNMP table mappings offers five methods to supply table indexing information: ordinary tables, table augmentations, sparse table augmentations, table expansions, and reordered tables use different statements to denote their indexing information.
Each table definition must contain exactly one of the following indexing statements.
The table's index Statement for Table Indexing
The table's `index' statement, which is used to supply table indexing information of base tables, gets one argument that specifies a comma separated list of objects, that are used for table indexing, enclosed in parenthesis.
The elements of the `unique' statement of the implemented class(es) and their order should be regarded as a hint for the index elements of the table.
In case of modules that should be compatible on the SNMP protocol level to SMIv2 versions of the module, an optional `implied' keyword may be added in front of the list to indicate a compact encoding of the last object in the list.
See Section 2.2 for details.
The table's augments Statement for Table Indexing
The table's `augments' statement, which is used to supply table indexing information of tables that augment a base table, gets one argument that specifies the identifier of the table to be augmented.
Note that a table augmentation cannot itself be augmented.
Anyhow, a base table may be augmented by multiple table augmentations.
A table augmentation makes instances of subordinate columnar objects identified according to the index specification of the base table corresponding to the table named in the `augments' statement.
Further, instances of subordinate columnar objects of a table augmentation exist according to the same semantics as instances of subordinate columnar objects of the base table being augmented.
As such, note that creation of a base table row implies the correspondent creation of any table row augmentations.
Table augmentations MUST NOT be used in table row creation and deletion operations.
The table's extends Statement for Table Indexing
The table's `extends' statement, which is used to supply table indexing information of tables that sparsely augment a base table, gets one argument that specifies the identifier of the table to be sparsely augmented.
Note that a sparse table augmentation cannot itself be augmented.
Anyhow, a base table may be augmented by multiple table augmentations, sparsely or not.
A sparse table augmentation makes instances of subordinate columnar objects identified, if present, according to the index specification of the base table corresponding to the table named in the `extends' statement.
Further, instances of subordinate columnar objects of a sparse table augmentation exist according to the semantics as instances of subordinate columnar objects of the base table and the (non formal) rules that confine the sparse relationship.
As such, note that creation of a sparse table row augmentation may be implied by the creation of a base table row as well as done by an explicit creation.
However, if a base table row gets deleted, any dependent sparse table row augmentations get also deleted implicitly.
The table's reorders Statement for Table Indexing
The table's `reorders' statement is used to supply table indexing information of tables, that contain exactly the same index objects of a base table but in a different order.
It gets at least two arguments.
The first one specifies the identifier of the base table.
The second one specifies a comma separated list of exactly those object identifiers of the base table's `index' statement, but in the order to be used in this table.
Note that a reordered table cannot itself be reordered.
Anyhow, a base table may be used for multiple reordered tables.
Under some circumstances, an optional `implied' keyword may be added in front of the list to indicate a compact encoding of the last object in the list.
See Section 2.2 for details.
Instances of subordinate columnar objects of a reordered table exist according to the same semantics as instances of subordinate columnar objects of the base table.
As such, note that creation of a base table row implies the correspondent creation of any related reordered table row.
Reordered tables MUST NOT be used in table row creation and deletion operations.
The table's expands Statement for Table Indexing
The table's `expands' statement is used to supply table indexing information of table expansions.
Table expansions use exactly the same index objects of another table together with additional indexing objects.
Thus, the `expands' statement gets at least two arguments.
The first one specifies the identifier of the base table.
The second one specifies a comma separated list of the additional object identifiers used for indexing.
Note that an expanded table may itself be expanded, and base tables may be used for multiple table expansions.
Under some circumstances, an optional `implied' keyword may be added in front of the list to indicate a compact encoding of the last object in the list.
See Section 2.2 for details.
The table's `create' statement, which need not be present, gets no argument.
If the `create' statement is present, table row creation (and deletion) is possible.
The table's `object' statement, which must be present at least once, makes this table contain a given columnar object.
It gets two arguments: the name of the columnar object to be defined and a statement block that holds additional detailed information in an obligatory order.
The `implements' statement, which must be present, is used to specify a single leaf attribute of a class that is implemented by this columnar object.
The type of this attribute must be a simple type, i.e., not a class.
The `subid' statement, which need not be present, is used to specify the sub identifier that identifies the columnar object within this table, i.e., the object identifier of the columnar object is the concatenation of the values of this table's oid statement and of this subid statement.
If this statement is omitted, the sub identifier is the one of the previous object statement within this table plus 1.
If the containing object statement is the first one within the containing table and the subid statement is omitted, the sub identifier is 1.
The object's `status' statement, which need not be present, gets one argument which is used to specify whether this columnar object definition is current or historic.
The value `current' means that the definition is current and valid.
The value `obsolete' means the definition is obsolete and should not be implemented and/or can be removed if previously implemented.
While the value `deprecated' also indicates an obsolete definition, it permits new/continued implementation in order to foster interoperability with older/existing implementations.
Columnar objects SHOULD NOT be defined as `current' if the implemented attribute definition is `deprecated' or `obsolete'.
Similarly, they SHOULD NOT be defined as `deprecated' if the implemented attribute is `obsolete'.
Nevertheless, subsequent revisions of used class definitions cannot be avoided, but SHOULD be taken into account in subsequent revisions of the local module.
Note that it is RECOMMENDED to omit the status statement which means that the status is inherited from the containing table statement.
However, if the status of a columnar object varies from the containing table, it has to be expressed explicitly, e.g., if the implemented attribute has been deprecated or obsoleted.
The object's `description' statement, which need not be present, gets one argument which is used to specify a high level textual description of this columnar object.
Note that in contrast to other definitions this description statement is not mandatory and it is RECOMMENDED to omit it, if the object is fully described by the description of the implemented attribute.
The object's `reference' statement, which need not be present, gets one argument which is used to specify a textual cross reference to some other document, either another module which defines related definitions, or some other document which provides additional information relevant to this columnar object.
It is RECOMMENDED to omit this statement, if the object's references are fully described by the implemented attribute.
The table's `status' statement, which must be present, gets one argument which is used to specify whether this table definition is current or historic.
The value `current' means that the definition is current and valid.
The value `obsolete' means the definition is obsolete and should not be implemented and/or can be removed if previously implemented.
While the value `deprecated' also indicates an obsolete definition, it permits new/continued implementation in order to foster interoperability with older/existing implementations.
The table's `description' statement, which must be present, gets one argument which is used to specify a high level textual description of this table.
It is RECOMMENDED to include all semantic definitions necessary for the implementation of this table.
The table's `reference' statement, which need not be present, gets one argument which is used to specify a textual cross reference to some other document, either another module which defines related definitions, or some other document which provides additional information relevant to this table statement.
The `notification' statement is used to map events defined within classes to SNMP notifications.
The `notification' statement gets two arguments: a lower case notification identifier and a statement block that holds detailed notification information in an obligatory order.
See the `notificationStatement' rule of the grammar (Section 5) for the formal syntax of the `notification' statement.
The notification's `oid' statement, which must be present, gets one argument which specifies the object identifier value that is assigned to this notification.
The notification's `signals' statement, which must be present, denotes the event that is signaled by this notification.
The statement gets two arguments: the event to be signaled (in the qualified form `Class.event') and a statement block that holds detailed information on the objects transmitted with this notification in an obligatory order.
The signals' `object' statement, which can be present zero, one or multiple times, makes a single instance of a class attribute be contained in this notification.
It gets one argument: the specific class attribute.
The namespace of attributes not specified by qualified names is the namespace of the event's class specified in the `signals' statement.
The notification's `status' statement, which must be present, gets one argument which is used to specify whether this notification definition is current or historic.
The value `current' means that the definition is current and valid.
The value `obsolete' means the definition is obsolete and should not be implemented and/or can be removed if previously implemented.
While the value `deprecated' also indicates an obsolete definition, it permits new/continued implementation in order to foster interoperability with older/existing implementations.
The notification's `description' statement, which need not be present, gets one argument which is used to specify a high level textual description of this notification.
It is RECOMMENDED to include all semantics and purposes of this notification.
The notification's `reference' statement, which need not be present, gets one argument which is used to specify a textual cross reference to some other document, either another module which defines related definitions, or some other document which provides additional information relevant to this notification statement.
The group Statement The `group' statement is used to define a group of arbitrary nodes in the object identifier tree.
It gets two arguments: a lower case group identifier and a statement block that holds detailed group information in an obligatory order.
Note that the primary application of groups are compliance statements, although they might be referred in other formal or informal documents.
See the `groupStatement' rule of the grammar (Section 5) for the formal syntax of the `group' statement.
The group's `oid' statement, which must be present, gets one argument which specifies the object identifier value that is assigned to this group.
The group's `members' statement, which must be present, gets one argument which specifies the list of nodes by their identifiers to be contained in this group.
The list of nodes has to be comma separated and enclosed in parenthesis.
The group's `status' statement, which must be present, gets one argument which is used to specify whether this group definition is current or historic.
The value `current' means that the definition is current and valid.
The value `obsolete' means the definition is obsolete and the group should no longer be used.
While the value `deprecated' also indicates an obsolete definition, it permits new/continued use of this group.
The group's `description' statement, which must be present, gets one argument which is used to specify a high level textual description of this group.
It is RECOMMENDED to include any relation to other groups.
The group's `reference' statement, which need not be present, gets one argument which is used to specify a textual cross reference to some other document, either another module which defines related groups, or some other document which provides additional information relevant to this group.
The snmpGroup, originally defined in [RFC3418], may be described as follows:
The `compliance' statement is used to define a set of conformance requirements, named a `compliance statement'.
It gets two arguments: a lower case compliance identifier and a statement block that holds detailed compliance information in an obligatory order.
See the `complianceStatement' rule of the grammar (Section 5) for the formal syntax of the `compliance' statement.
The compliance's `oid' statement, which must be present, gets one argument which specifies the object identifier value that is assigned to this compliance statement.
The compliance's `status' statement, which must be present, gets one argument which is used to specify whether this compliance statement is current or historic.
The value `current' means that the definition is current and valid.
The value `obsolete' means the definition is obsolete and no longer specifies a valid definition of conformance.
While the value `deprecated' also indicates an obsolete definition, it permits new/continued use of the compliance specification.
The compliance's `description' statement, which must be present, gets one argument which is used to specify a high level textual description of this compliance statement.
The compliance's `reference' statement, which need not be present, gets one argument which is used to specify a textual cross reference to some other document, either another module which defines related compliance statements, or some other document which provides additional information relevant to this compliance statement.
The compliance's `mandatory' statement, which need not be present, gets one argument which is used to specify a comma separated list of one or more groups (Section 4.6) of objects and/or notifications enclosed in parenthesis.
These groups are unconditionally mandatory for implementation.
If an agent claims compliance to a MIB module then it must implement each and every object and notification within each group listed in the `mandatory' statement(s) of the compliance statement(s) of that module.
The compliance's `optional' statement, which need not be present, is repeatedly used to name each group which is conditionally mandatory for compliance to the compliance statement.
It can also be used to name unconditionally optional groups.
A group named in an `optional' statement MUST be absent from the correspondent `mandatory' statement.
The `optional' statement gets two arguments: a lower case group identifier and a statement block that holds detailed compliance information on that group.
Conditionally mandatory groups include those groups which are mandatory only if a particular protocol is implemented, or only if another group is implemented.
The `description' statement specifies the conditions under which the group is conditionally mandatory.
A group which is named in neither a `mandatory' statement nor an `optional' statement, is unconditionally optional for compliance to the module.
See the `optionalStatement' rule of the grammar (Section 5) for the formal syntax of the `optional' statement.
The optional's `description' statement, which must be present, gets one argument which is used to specify a high level textual description of the conditions under which this group is conditionally mandatory or unconditionally optional.
The compliance's `refine' statement, which need not be present, is repeatedly used to specify each object for which compliance has a refined requirement with respect to the module definition.
The object must be present in one of the conformance groups named in the correspondent `mandatory' or `optional' statements.
The `refine' statement gets two arguments: a lower case identifier of a scalar or columnar object and a statement block that holds detailed refinement information on that object.
See the `refineStatement' rule of the grammar (Section 5) for the formal syntax of the `refine' statement.
The refine's `type' statement, which need not be present, gets one argument that is used to provide a refined type for the correspondent object.
Type restrictions may be applied by appending subtyping information according to the rules of the base type.
See [RFC3780] for SMIng base types and their type restrictions.
In case of enumeration or bitset types the order of named numbers is not significant.
Note that if a `type' and a `writetype' statement are both present then this type only applies when instances of the correspondent object are read.
The refine's `writetype' statement, which need not be present, gets one argument that is used to provide a refined type for the correspondent object, only when instances of that object are written.
Type restrictions may be applied by appending subtyping information according to the rules of the base type.
See [RFC3780] for SMIng base types and their type restrictions.
In case of enumeration or bitset types the order of named numbers is not significant.
The refine's `access' statement, which need not be present, gets one argument that is used to specify the minimal level of access that the correspondent object must implement in the sense of its original `access' statement.
Hence, the refine's `access' statement MUST NOT specify a greater level of access than is specified in the correspondent object definition.
An implementation is compliant if the level of access it provides is greater or equal to the minimal level in the refine's `access' statement and less or equal to the maximal level in the object's `access' statement.
The refine's `description' statement, which must be present, gets one argument which is used to specify a high level textual description of the refined compliance requirement.
The compliance statement contained in the SNMPv2 MIB [RFC3418], converted to SMIng:
The grammar of the snmp statement (including all its contained statements) conforms to the Augmented Backus Naur Form (ABNF) [RFC2234].
It is included in the abnf statement of the snmp SMIng extension definition in the NMRG
SMING SNMP EXT module below.
Frank Strauss TU Braunschweig Muehlenpfordtstrasse 23 38106
Braunschweig Germany Phone:  49 531
strauss@ibr.cs.tu bs.de Juergen Schoenwaelder International University
750 561 28725 Bremen Germany Phone:  49 421 200 3587 EMail:
This module defines a SMIng extension to define the mapping of SMIng definitions of class and their attributes and events to SNMP compatible definitions of modules, node, scalars, tables, and notifications, and additional information on module compliances.
(notificationStatement stmtsep)  (groupStatement stmtsep)  (complianceStatement stmtsep)
statusStatement stmtsep descriptionStatement stmtsep  1(referenceStatement stmtsep)
statusStatement stmtsep  1(descriptionStatement stmtsep)  1(referenceStatement stmtsep)
statusStatement stmtsep descriptionStatement stmtsep  1(referenceStatement stmtsep)
statusStatement stmtsep descriptionStatement stmtsep  1(referenceStatement stmtsep)
stmtsep oidStatement stmtsep signalsStatement stmtsep statusStatement stmtsep descriptionStatement stmtsep  1(referenceStatement stmtsep)
stmtsep oidStatement stmtsep membersStatement stmtsep statusStatement stmtsep descriptionStatement stmtsep  1(referenceStatement stmtsep)
stmtsep oidStatement stmtsep statusStatement stmtsep descriptionStatement stmtsep  1(referenceStatement stmtsep)  1(mandatoryStatement stmtsep)
indexStatement / augmentsStatement / reordersStatement / extendsStatement / expandsStatement indexStatement
%x6F %x62 %x6A %x65 %x63 %x74 notificationKeyword
%x6E %x6F %x74 %x69 %x66 %x69 %x63 %x61 %x74 %x69 %x6F
x70 %x61 %x6E %x64 %x73
specified below defines derived types that are specific to the SNMP mapping.
Frank Strauss TU Braunschweig Muehlenpfordtstrasse 23 38106
Braunschweig Germany Phone:  49 531
strauss@ibr.cs.tu bs.de Juergen Schoenwaelder International University
750 561 28725 Bremen Germany Phone:  49 421 200 3587 EMail:
These definitions are based on RFC 2579 definitions that are specific to the SNMP protocol and its naming system.
When the management protocol is used to specify that an object instance having this type is to be modified, the new value supplied via the management protocol must precisely match the value presently held by the instance.
If not, the management protocol set operation fails with an error of `inconsistentValue'.
Otherwise, if the current value is the maximum value of 2^31 1 (2147483647 decimal), then the value held by the instance is wrapped to zero; otherwise, the value held by the instance is incremented by one.
(Note that regardless of whether the management protocol set operation succeeds, the variable binding in the request and response PDUs are identical.)
The value of the SNMP access clause for objects having this type has to be `readwrite'.
When an instance of a columnar object having this type is created, any value may be supplied via the management protocol.
It may, for example, indicate a particular OID sub tree with further MIB definitions, or define a particular type of protocol or hardware."
The value is the name of the instance of the first accessible columnar object in the conceptual row.
The status column has six defined values: `active', which indicates that the conceptual row is available for use by the managed device; `notInService', which indicates that the conceptual row exists in the agent, but is unavailable for use by the managed device (see NOTE below); `notReady', which indicates that the conceptual row exists in the agent, but is missing information necessary in order to be available for use by the managed device; `createAndGo', which is supplied by a management station wishing to create a new instance of a conceptual row and to have its status automatically set to active, making it available for use by the managed device; `createAndWait', which is supplied by a management station wishing to create a new instance of a conceptual row (but not make it available for use by the managed device); and, `destroy', which is supplied by a management station wishing to delete all of the instances associated with an existing conceptual row.
Whereas five of the six values (all except `notReady') may be specified in a management protocol set operation, only three values will be returned in response to a management protocol retrieval operation: `notReady', `notInService' or `active'.
That is, when queried, an existing conceptual row has only three states: it is either available for use by the managed device (the status column has value `active'); it is not available for use by the managed device, though the agent has sufficient information to make it so
(the status column has value `notInService'); or, it is not available for use by the managed device, and an attempt to make it so would fail because the agent has insufficient information (the state column has value `notReady').
This textual convention may be used for a MIB table, irrespective of whether the values of that table's conceptual rows are able to be modified while it is active, or whether its conceptual rows must be taken out of service in order to be modified.
That is, it is the responsibility of the DESCRIPTION clause of the status column to specify whether the status column must not be `active' in order for the value of some other column of the same conceptual row to be modified.
If such a specification is made, affected columns may be changed by an SNMP set PDU if the RowStatus would not be equal to `active' either immediately before or after processing the PDU.
In other words, if the PDU also contained a varbind that would change the RowStatus value, the column in question may be changed if the RowStatus was not equal to `active' as the PDU was received, or if the varbind sets the status to a value other than 'active'.
Also note that whenever any elements of a row exist, the RowStatus column must also exist.
To summarize the effect of having a conceptual row with a column having a type of RowStatus, consider the following state diagram: STATE
A see 7    set any other
(2) if other variable bindings included in the same PDU, provide values for all columns which are missing but required, then return noError and goto D. (3) if other variable bindings included in the same PDU, provide values for all columns which are missing but required, then return noError and goto C. (4) at the discretion of the agent, the return value may be either: inconsistentName: because the agent does not choose to create such an instance when the corresponding RowStatus instance does not exist, or inconsistentValue: if the supplied value is inconsistent with the state of some other MIB object's value, or noError: because the agent chooses to create the instance.
If noError is returned, then the instance of the status column must also be created, and the new state is B or C, depending on the information available to the agent.
If inconsistentName or inconsistentValue is returned, the row remains in state A. (5) depending on the MIB definition for the column/table, either noError or inconsistentValue may be returned.
(6) the return value can indicate one of the following errors: wrongValue: because the agent does not support createAndWait, or inconsistentValue: because the agent is unable to take the row out of service at this time, perhaps because it is in use and cannot be de activated.
(7) the return value can indicate the following error: inconsistentValue: because the agent is unable to remove the row at this time, perhaps because it is in use and cannot be de activated.
Other processing of the set request may result in a response other than noError being returned, e.g., wrongValue, noCreation, etc.
There are four potential interactions when creating a conceptual row: selecting an instance identifier which is not in use; creating the conceptual row; initializing any objects for which the agent does not supply a default; and, making the conceptual row available for use by the managed device.
The algorithm used to select an instance identifier varies for each conceptual row.
In some cases, the instance  identifier is semantically significant, e.g., the destination address of a route, and a management station selects the instance identifier according to the semantics.
In other cases, the instance identifier is used solely to distinguish conceptual rows, and a management station without specific knowledge of the conceptual row might examine the instances present in order to determine an unused instance identifier.
(This approach may be used, but it is often highly sub optimal; however, it is also a questionable practice for a naive management station to attempt conceptual row creation.)
Alternately, the MIB module which defines the conceptual row might provide one or more objects which provide assistance in determining an unused instance identifier.
For example, if the conceptual row is indexed by an integer value, then an object having an integer
valued SYNTAX clause might be defined for such a purpose, allowing a management station to issue a management protocol retrieval operation.
In order to avoid unnecessary collisions between competing management stations, `adjacent' retrievals of this object should be different.
Finally, the management station could select a pseudo random number to use as the index.
In the event that this index was already in use and an inconsistentValue was returned in response to the management protocol set operation, the management station should simply select a new pseudo random number and retry the operation.
A MIB designer should choose between the two latter algorithms based on the size of the table (and therefore the efficiency of each algorithm).
For tables in which a large number of entries are expected, it is recommended that a MIB object be defined that returns an acceptable index for creation.
For tables with small numbers of entries, it is recommended that the latter pseudo random index mechanism be used.
Interaction 2: Creating the Conceptual Row
Once an unused instance identifier has been selected, the management station determines if it wishes to create and activate the conceptual row in one transaction or in a negotiated set of interactions.
Creating and Activating the Conceptual Row
The management station must first determine the column requirements, i.e., it must determine those columns for which it must or must not provide values.
Depending on the complexity of the table and the management station's knowledge of the agent's capabilities, this determination can be made locally by the management station.
Alternately, the management station issues a management protocol get operation to examine all columns in the conceptual row that it wishes to create.
In response, for each column, there are three possible outcomes: a value is returned, indicating that some other management station has already created this conceptual row.
We return to interaction 1.
the exception `noSuchInstance' is returned, indicating that the agent implements the object type associated with this column, and that this column in at least one conceptual row would be accessible in the MIB view used by the retrieval were it to exist.
For those columns to which the agent provides read create access, the `noSuchInstance' exception tells the management station that it should supply a value for this column when the conceptual row is to be created.
the exception `noSuchObject' is returned, indicating that the agent does not implement the object type associated with this column or that there is no conceptual row for which this column would be accessible in the MIB view used by the retrieval.
As such, the management station can not issue any management protocol set operations to create an instance of this column.
Once the column requirements have been determined, a management protocol set operation is accordingly issued.
This operation also sets the new instance of the status column to `createAndGo'.
When the agent processes the set operation, it verifies that it has sufficient information to make the conceptual row available for use by the managed device.
The information available to the agent is provided by two sources: the management protocol set operation which creates the conceptual row, and, implementation specific defaults supplied by the agent (note that an agent must provide implementation specific defaults for at least those objects which it implements as read only).
If there is sufficient information available, then the conceptual row is created, a `noError' response is returned, the status column is set to `active', and no further interactions are necessary (i.e., interactions 3 and 4 are skipped).
If there is insufficient information, then the conceptual row is not created, and the set operation fails with an error of `inconsistentValue'.
On this error, the management station can issue a management protocol retrieval operation to determine if this was because it failed to specify a value for a required column, or, because the selected instance of the status column already existed.
In the latter case, we return to interaction 1.
In the former case, the management station can re issue the set operation with the additional information, or begin interaction 2 again using `createAndWait' in order to negotiate creation of the conceptual row.
Regardless of the method used to determine the column requirements, it is possible that the management station might deem a column necessary when, in fact, the agent will not allow that particular columnar instance to be created or written.
In this case, the management protocol set operation will fail with an error such as `noCreation' or `notWritable'.
In this case, the management station decides whether it needs to be able to set a value for that particular columnar instance.
If not, the management station re issues the management protocol set operation, but without setting a value for that particular columnar instance; otherwise, the management station aborts the row creation algorithm.
Negotiating the Creation of the Conceptual Row
The management station issues a management protocol set operation which sets the desired instance of the status column to `createAndWait'.
If the agent is unwilling to process a request of this sort, the set operation fails with an error of `wrongValue'.
(As a consequence, such an agent must be prepared to accept a single management protocol set operation, i.e., interaction 2a above, containing all of the columns indicated by its column requirements.)
Otherwise, the conceptual row is created, a `noError' response is returned, and the status column is immediately set to either `notInService' or `notReady', depending on whether it has sufficient information to make the conceptual row available for use by the managed device.
If there is sufficient information available, then the status column is set to `notInService'; otherwise, if there is insufficient information, then the status column is set to `notReady'.
Regardless, we proceed to interaction 3.
Interaction 3: Initializing non defaulted Objects
The management station must now determine the column requirements.
It issues a management protocol get operation to examine all columns in the created conceptual row.
In the response, for each column, there are three possible outcomes: a value is returned, indicating that the agent implements the object type associated with this column and had sufficient information to provide a value.
For those columns to which the agent provides read create access (and for which the agent allows their values to be changed after their creation), a value return tells the management station that it may issue additional management protocol set operations, if it desires, in order to change the value associated with this column.
the exception `noSuchInstance' is returned, indicating that the agent implements the object type associated with this column, and that this column in at least one conceptual row would be accessible in the MIB view used by the retrieval were it to exist.
However, the agent does not have sufficient information to provide a value, and until a value is provided, the conceptual row may not be made available for use by the managed device.
For those columns to which the agent provides read create access, the `noSuchInstance' exception tells the management station that it must issue additional management protocol set operations, in order to provide a value associated with this column.
the exception `noSuchObject' is returned, indicating that the agent does not implement the object type associated with this column or that there is no conceptual row for which this column would be accessible in the MIB view used by the retrieval.
As such, the management station can not issue any management protocol set operations to create an instance of this column.
If the value associated with the status column is `notReady', then the management station must first deal with all `noSuchInstance' columns, if any.
Having done so, the value of the status column becomes `notInService', and we proceed to interaction 4.
Making the Conceptual Row Available
Once the management station is satisfied with the values associated with the columns of the conceptual row, it issues a management protocol set operation to set the status column to `active'.
If the agent has sufficient information to make the conceptual row available for use by the managed device, the management protocol set operation succeeds (a `noError' response is returned).
Otherwise, the management protocol set operation fails with an error of `inconsistentValue'.
A conceptual row having a status column with value `notInService' or `notReady' is unavailable to the managed device.
As such, it is possible for the managed device to create its own instances during the time between the management protocol set operation which sets the status column to `createAndWait' and the management protocol set operation which sets the status column to `active'.
In this case, when the management protocol set operation is issued to set the status column to `active', the values held in the agent supersede those used by the managed device.
If the management station is prevented from setting the status column to `active' (e.g., due to management station or network failure)
the conceptual row will be left in the `notInService' or `notReady' state, consuming resources indefinitely.
The agent must detect conceptual rows that have been in either state for an abnormally long period of time and remove them.
It is the responsibility of the DESCRIPTION clause of the status column to indicate what an abnormally long period of time would be.
This period of time should be long enough to allow for human response time (including `think time') between the creation of the conceptual row and the setting of the status to `active'.
In the absence of such information in the DESCRIPTION clause, it is suggested that this period be approximately 5 minutes in length.
This removal action applies not only to newly  created rows, but also to previously active rows which are set to, and left in, the notInService state for a prolonged period exceeding that which is considered normal for such a conceptual row.
When a conceptual row is `active', the management station may issue a management protocol set operation which sets the instance of the status column to `notInService'.
If the agent is unwilling to do so, the set operation fails with an error of `wrongValue' or `inconsistentValue'.
Otherwise, the conceptual row is taken out of service, and a `noError' response is returned.
It is the responsibility of the DESCRIPTION clause of the status column to indicate under what circumstances the status column should be taken out of service (e.g., in order for the value of some other column of the same conceptual row to be modified).
For deletion of conceptual rows, a management protocol set operation is issued which sets the instance of the status column to `destroy'.
This request may be made regardless of the current value of the status column (e.g., it is possible to delete conceptual rows which are either `notReady', `notInService' or `active'.)
A row which is volatile(2) is lost upon reboot.
A row which is either nonVolatile(3), permanent(4) or readOnly(5), is backed up by stable storage.
A row which is permanent(4) can be changed but not deleted.
A row which is readOnly(5) cannot be changed nor deleted.
If the value of an object with this syntax is either permanent(4) or readOnly(5), it cannot be modified.
Conversely, if the value is either other(1), volatile(2) or nonVolatile(3), it cannot be modified to be permanent(4) or readOnly(5).
(All illegal modifications result in a 'wrongValue' error.)
Some possible values, such as snmpUDPDomain, are defined in the SNMPv2 TM MIB module.
Other possible values are defined in other MIB modules.
" reference "The SNMPv2 TM MIB module is defined in RFC 3417."
A TAddress value is always interpreted within the context of a TDomain value.
Thus, each definition of a TDomain value must be accompanied by a definition of a textual convention for use with that TDomain.
Some possible textual conventions, such as SnmpUDPAddress for snmpUDPDomain, are defined in the SNMPv2 TM MIB module.
Other possible textual conventions are defined in other MIB modules.
A zero length TAddress value denotes an unknown transport service address.
" reference "The SNMPv2 TM MIB module is defined in RFC 3417."
This document presents an extension of the SMIng data definition language which supports the mapping of SMIng data definitions so that they can be used with the SNMP management framework.
The language extension and the mapping itself has no security impact on the Internet.
