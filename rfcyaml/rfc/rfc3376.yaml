- contents:
  - '             Internet Group Management Protocol, Version 3

    '
  title: __initial_text__
- contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol
    for the\n   Internet community, and requests discussion and suggestions for\n
    \  improvements.  Please refer to the current edition of the \"Internet\n   Official
    Protocol Standards\" (STD 1) for the standardization state\n   and status of this
    protocol.  Distribution of this memo is unlimited.\n"
  title: Status of this Memo
- contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2002).  All Rights Reserved.\n"
  title: Copyright Notice
- contents:
  - "Abstract\n   This document specifies Version 3 of the Internet Group Management\n
    \  Protocol, IGMPv3.  IGMP is the protocol used by IPv4 systems to\n   report
    their IP multicast group memberships to neighboring multicast\n   routers.  Version
    3 of IGMP adds support for \"source filtering\", that\n   is, the ability for
    a system to report interest in receiving packets\n   *only* from specific source
    addresses, or from *all but* specific\n   source addresses, sent to a particular
    multicast address.  That\n   information may be used by multicast routing protocols
    to avoid\n   delivering multicast packets from specific sources to networks where\n
    \  there are no interested receivers.\n   This document obsoletes RFC 2236.\n"
  title: Abstract
- contents:
  - "Table of Contents\n   1.  Introduction. . . . . . . . . . . . . . . . . . . .
    . . . . .   2\n   2.  The Service Interface for Requesting IP Multicast Reception
    .   3\n   3.  Multicast Reception State Maintained by Systems . . . . . . .   5\n
    \  4.  Message Formats . . . . . . . . . . . . . . . . . . . . . . .   7\n   5.
    \ Description of the Protocol for Group Members . . . . . . . .  19\n   6.  Description
    of the Protocol for Multicast Routers . . . . . .  24\n   7.  Interoperation with
    Older Versions of IGMP. . . . . . . . . .  35\n   8.  List of Timers, Counters,
    and Their Default Values. . . . . .  40\n   9.  Security Considerations . . .
    . . . . . . . . . . . . . . . .  43\n   10. IANA Considerations . . . . . . .
    . . . . . . . . . . . . . .  47\n   11. Acknowledgments . . . . . . . . . . .
    . . . . . . . . . . . .  47\n   12. Normative References. . . . . . . . . . .
    . . . . . . . . . .  47\n   13. Informative References. . . . . . . . . . . .
    . . . . . . . .  47\n       Appendix A. Design Rationale. . . . . . . . . . .
    . . . . . .  49\n       Appendix B. Summary of changes from IGMPv2. . . . . .
    . . . .  50\n       Authors' Addresses. . . . . . . . . . . . . . . . . . . .
    . .  52\n       Full Copyright Statement. . . . . . . . . . . . . . . . . . .
    \ 53\n"
  title: Table of Contents
- contents:
  - "1. Introduction\n   The Internet Group Management Protocol (IGMP) is used by
    IPv4 systems\n   (hosts and routers) to report their IP multicast group memberships
    to\n   any neighboring multicast routers.  Note that an IP multicast router\n
    \  may itself be a member of one or more multicast groups, in which case\n   it
    performs both the \"multicast router part\" of the protocol (to\n   collect the
    membership information needed by its multicast routing\n   protocol) and the \"group
    member part\" of the protocol (to inform\n   itself and other, neighboring multicast
    routers of its memberships).\n   IGMP is also used for other IP multicast management
    functions, using\n   message types other than those used for group membership
    reporting.\n   This document specifies only the group membership reporting functions\n
    \  and messages.\n   This document specifies Version 3 of IGMP.  Version 1, specified
    in\n   [RFC-1112], was the first widely-deployed version and the first\n   version
    to become an Internet Standard.  Version 2, specified in\n   [RFC-2236], added
    support for \"low leave latency\", that is, a\n   reduction in the time it takes
    for a multicast router to learn that\n   there are no longer any members of a
    particular group present on an\n   attached network.  Version 3 adds support for
    \"source filtering\",\n   that is, the ability for a system to report interest
    in receiving\n   packets *only* from specific source addresses, as required to
    support\n   Source-Specific Multicast [SSM], or from *all but* specific source\n
    \  addresses, sent to a particular multicast address.  Version 3 is\n   designed
    to be interoperable with Versions 1 and 2.\n   Multicast Listener Discovery (MLD)
    is used in a similar way by IPv6\n   systems.  MLD version 1 [MLD] implements
    the functionality of IGMP\n   version 2; MLD version 2 [MLDv2] implements the
    functionality of IGMP\n   version 3.\n   The capitalized key words \"MUST\", \"MUST
    NOT\", \"REQUIRED\", \"SHALL\",\n   \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\",
    \"RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted
    as described in\n   [RFC-2119].  Due to the lack of italics, emphasis is indicated
    herein\n   by bracketing a word or phrase in \"*\" characters.\n"
  title: 1. Introduction
- contents:
  - "2. The Service Interface for Requesting IP Multicast Reception\n   Within an
    IP system, there is (at least conceptually) a service\n   interface used by upper-layer
    protocols or application programs to\n   ask the IP layer to enable and disable
    reception of packets sent to\n   specific IP multicast addresses.  In order to
    take full advantage of\n   the capabilities of IGMPv3, a system's IP service interface
    must\n   support the following operation:\n      IPMulticastListen ( socket, interface,
    multicast-address,\n                          filter-mode, source-list )\n   where:\n
    \  o \"socket\" is an implementation-specific parameter used to\n     distinguish
    among different requesting entities (e.g., programs or\n     processes) within
    the system; the socket parameter of BSD Unix\n     system calls is a specific
    example.\n   o \"interface\" is a local identifier of the network interface on
    which\n     reception of the specified multicast address is to be enabled or\n
    \    disabled.  Interfaces may be physical (e.g., an Ethernet interface)\n     or
    virtual (e.g., the endpoint of a Frame Relay virtual circuit or\n     the endpoint
    of an IP-in-IP \"tunnel\").  An implementation may allow\n     a special \"unspecified\"
    value to be passed as the interface\n     parameter, in which case the request
    would apply to the \"primary\"\n     or \"default\" interface of the system (perhaps
    established by system\n     configuration).  If reception of the same multicast
    address is\n     desired on more than one interface, IPMulticastListen is invoked\n
    \    separately for each desired interface.\n   o \"multicast-address\" is the
    IP multicast address, or group, to which\n     the request pertains.  If reception
    of more than one multicast\n     address on a given interface is desired, IPMulticastListen
    is\n     invoked separately for each desired multicast address.\n   o \"filter-mode\"
    may be either INCLUDE or EXCLUDE.  In INCLUDE mode,\n     reception of packets
    sent to the specified multicast address is\n     requested *only* from those IP
    source addresses listed in the\n     source-list parameter.  In EXCLUDE mode,
    reception of packets sent\n     to the given multicast address is requested from
    all IP source\n     addresses *except* those listed in the source-list parameter.\n
    \  o \"source-list\" is an unordered list of zero or more IP unicast\n     addresses
    from which multicast reception is desired or not desired,\n     depending on the
    filter mode.  An implementation MAY impose a limit\n     on the size of source
    lists, but that limit MUST NOT be less than\n     64 addresses per list.  When
    an operation causes the source list\n     size limit to be exceeded, the service
    interface MUST return an\n     error.\n   For a given combination of socket, interface,
    and multicast address,\n   only a single filter mode and source list can be in
    effect at any one\n   time.  However, either the filter mode or the source list,
    or both,\n   may be changed by subsequent IPMulticastListen requests that specify\n
    \  the same socket, interface, and multicast address.  Each subsequent\n   request
    completely replaces any earlier request for the given socket,\n   interface and
    multicast address.\n   Previous versions of IGMP did not support source filters
    and had a\n   simpler service interface consisting of Join and Leave operations
    to\n   enable and disable reception of a given multicast address (from *all*\n
    \  sources) on a given interface.  The equivalent operations in the new\n   service
    interface follow:\n   The Join operation is equivalent to\n      IPMulticastListen
    ( socket, interface, multicast-address,\n                          EXCLUDE, {}
    )\n   and the Leave operation is equivalent to:\n      IPMulticastListen ( socket,
    interface, multicast-address,\n                          INCLUDE, {} )\n   where
    {} is an empty source list.\n   An example of an API providing the capabilities
    outlined in this\n   service interface is in [FILTER-API].\n"
  title: 2. The Service Interface for Requesting IP Multicast Reception
- contents:
  - '3. Multicast Reception State Maintained by Systems

    '
  - contents:
    - "3.1. Socket State\n   For each socket on which IPMulticastListen has been invoked,
      the\n   system records the desired multicast reception state for that socket.\n
      \  That state conceptually consists of a set of records of the form:\n      (interface,
      multicast-address, filter-mode, source-list)\n   The socket state evolves in
      response to each invocation of\n   IPMulticastListen on the socket, as follows:\n
      \  o If the requested filter mode is INCLUDE *and* the requested source\n     list
      is empty, then the entry corresponding to the requested\n     interface and
      multicast address is deleted if present.  If no such\n     entry is present,
      the request is ignored.\n   o If the requested filter mode is EXCLUDE *or* the
      requested source\n     list is non-empty, then the entry corresponding to the
      requested\n     interface and multicast address, if present, is changed to contain\n
      \    the requested filter mode and source list.  If no such entry is\n     present,
      a new entry is created, using the parameters specified in\n     the request.\n"
    title: 3.1. Socket State
  - contents:
    - "3.2. Interface State\n     In addition to the per-socket multicast reception
      state, a system\n     must also maintain or compute multicast reception state
      for each of\n     its interfaces.  That state conceptually consists of a set
      of\n     records of the form:\n        (multicast-address, filter-mode, source-list)\n
      \    At most one record per multicast-address exists for a given\n     interface.
      \ This per-interface state is derived from the per-socket\n     state, but may
      differ from the per-socket state when different\n     sockets have differing
      filter modes and/or source lists for the\n     same multicast address and interface.
      \ For example, suppose one\n     application or process invokes the following
      operation on socket\n     s1:\n        IPMulticastListen ( s1, i, m, INCLUDE,
      {a, b, c} )\n     requesting reception on interface i of packets sent to multicast\n
      \    address m, *only* if they come from source a, b, or c.  Suppose\n     another
      application or process invokes the following operation on\n     socket s2:\n
      \       IPMulticastListen ( s2, i, m, INCLUDE, {b, c, d} )\n     requesting
      reception on the same interface i of packets sent to the\n     same multicast
      address m, *only* if they come from sources b, c, or\n     d.  In order to satisfy
      the reception requirements of both sockets,\n     it is necessary for interface
      i to receive packets sent to m from\n     any one of the sources a, b, c, or
      d.  Thus, in this example, the\n     reception state of interface i for multicast
      address m has filter\n     mode INCLUDE and source list {a, b, c, d}.\n     After
      a multicast packet has been accepted from an interface by the\n     IP layer,
      its subsequent delivery to the application or process\n     listening on a particular
      socket depends on the multicast reception\n     state of that socket [and possibly
      also on other conditions, such\n     as what transport-layer port the socket
      is bound to].  So, in the\n     above example, if a packet arrives on interface
      i, destined to\n     multicast address m, with source address a, it will be
      delivered on\n     socket s1 but not on socket s2.  Note that IGMP Queries and
      Reports\n     are not subject to source filtering and must always be processed
      by\n     hosts and routers.\n     Filtering of packets based upon a socket's
      multicast reception\n     state is a new feature of this service interface.
      \ The previous\n     service interface [RFC1112] described no filtering based
      upon\n     multicast join state; rather, a join on a socket simply caused the\n
      \    host to join a group on the given interface, and packets destined\n     for
      that group could be delivered to all sockets whether they had\n     joined or
      not.\n     The general rules for deriving the per-interface state from the\n
      \    per-socket state are as follows:  For each distinct (interface,\n     multicast-address)
      pair that appears in any socket state, a per-\n     interface record is created
      for that multicast address on that\n     interface.  Considering all socket
      records containing the same\n     (interface, multicast-address) pair,\n   o
      if *any* such record has a filter mode of EXCLUDE, then the filter\n     mode
      of the interface record is EXCLUDE, and the source list of the\n     interface
      record is the intersection of the source lists of all\n     socket records in
      EXCLUDE mode, minus those source addresses that\n     appear in any socket record
      in INCLUDE mode.  For example, if the\n     socket records for multicast address
      m on interface i are:\n        from socket s1:  ( i, m, EXCLUDE, {a, b, c, d}
      )\n        from socket s2:  ( i, m, EXCLUDE, {b, c, d, e} )\n        from socket
      s3:  ( i, m, INCLUDE, {d, e, f} )\n     then the corresponding interface record
      on interface i is:\n                         ( m, EXCLUDE, {b, c} )\n     If
      a fourth socket is added, such as:\n        from socket s4:  ( i, m, EXCLUDE,
      {} )\n     then the interface record becomes:\n                         ( m,
      EXCLUDE, {} )\n   o if *all* such records have a filter mode of INCLUDE, then
      the\n     filter mode of the interface record is INCLUDE, and the source list\n
      \    of the interface record is the union of the source lists of all the\n     socket
      records.  For example, if the socket records for multicast\n     address m on
      interface i are:\n        from socket s1:  ( i, m, INCLUDE, {a, b, c} )\n        from
      socket s2:  ( i, m, INCLUDE, {b, c, d} )\n        from socket s3:  ( i, m, INCLUDE,
      {e, f} )\n     then the corresponding interface record on interface i is:\n
      \                        ( m, INCLUDE, {a, b, c, d, e, f} )\n     An implementation
      MUST NOT use an EXCLUDE interface record to\n     represent a group when all
      sockets for this group are in INCLUDE\n     state.  If system resource limits
      are reached when an interface\n     state source list is calculated, an error
      MUST be returned to the\n     application which requested the operation.\n   The
      above rules for deriving the interface state are (re-)evaluated\n   whenever
      an IPMulticastListen invocation modifies the socket state by\n   adding, deleting,
      or modifying a per-socket state record.  Note that\n   a change  of socket state
      does not necessarily result in a change of\n   interface state.\n"
    title: 3.2. Interface State
  title: 3. Multicast Reception State Maintained by Systems
- contents:
  - "4. Message Formats\n   IGMP messages are encapsulated in IPv4 datagrams, with
    an IP protocol\n   number of 2.  Every IGMP message described in this document
    is sent\n   with an IP Time-to-Live of 1, IP Precedence of Internetwork Control\n
    \  (e.g., Type of Service 0xc0), and carries an IP Router Alert option\n   [RFC-2113]
    in its IP header.  IGMP message types are registered by\n   the IANA [IANA-REG]
    as described by [RFC-3228].\n   There are two IGMP message types of concern to
    the IGMPv3 protocol\n   described in this document:\n      Type Number (hex)   Message
    Name\n      -----------------   ------------\n            0x11          Membership
    Query\n            0x22          Version 3 Membership Report\n   An implementation
    of IGMPv3 MUST also support the following three\n   message types, for interoperation
    with previous versions of IGMP (see\n   section 7):\n           0x12          Version
    1 Membership Report    [RFC-1112]\n           0x16          Version 2 Membership
    Report    [RFC-2236]\n           0x17          Version 2 Leave Group          [RFC-2236]\n
    \  Unrecognized message types MUST be silently ignored.  Other message\n   types
    may be used by newer versions or extensions of IGMP, by\n   multicast routing
    protocols, or for other uses.\n   In this document, unless otherwise qualified,
    the capitalized words\n   \"Query\" and \"Report\" refer to IGMP Membership Queries
    and IGMP\n   Version 3 Membership Reports, respectively.\n"
  - contents:
    - "4.1. Membership Query Message\n   Membership Queries are sent by IP multicast
      routers to query the\n   multicast reception state of neighboring interfaces.
      \ Queries have\n   the following format:\n       0                   1                   2
      \                  3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |  Type = 0x11  | Max Resp Code |           Checksum            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |                         Group Address                         |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     | Resv  |S| QRV |     QQIC      |     Number of Sources (N)     |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |                       Source Address [1]                      |\n      +-
      \                                                            -+\n      |                       Source
      Address [2]                      |\n      +-                              .
      \                             -+\n      .                               .                               .\n
      \     .                               .                               .\n      +-
      \                                                            -+\n      |                       Source
      Address [N]                      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
    - contents:
      - "4.1.1. Max Resp Code\n   The Max Resp Code field specifies the maximum time
        allowed before\n   sending a responding report.  The actual time allowed,
        called the Max\n   Resp Time, is represented in units of 1/10 second and is
        derived from\n   the Max Resp Code as follows:\n   If Max Resp Code < 128,
        Max Resp Time = Max Resp Code\n   If Max Resp Code >= 128, Max Resp Code represents
        a floating-point\n   value as follows:\n       0 1 2 3 4 5 6 7\n      +-+-+-+-+-+-+-+-+\n
        \     |1| exp | mant  |\n      +-+-+-+-+-+-+-+-+\n   Max Resp Time = (mant
        | 0x10) << (exp + 3)\n   Small values of Max Resp Time allow IGMPv3 routers
        to tune the \"leave\n   latency\" (the time between the moment the last host
        leaves a group\n   and the moment the routing protocol is notified that there
        are no\n   more members).  Larger values, especially in the exponential range,\n
        \  allow tuning of the burstiness of IGMP traffic on a network.\n"
      title: 4.1.1. Max Resp Code
    - contents:
      - "4.1.2. Checksum\n   The Checksum is the 16-bit one's complement of the one's
        complement\n   sum of the whole IGMP message (the entire IP payload).  For
        computing\n   the checksum, the Checksum field is set to zero.  When receiving\n
        \  packets, the checksum MUST be verified before processing a packet.\n   [RFC-1071]\n"
      title: 4.1.2. Checksum
    - contents:
      - "4.1.3. Group Address\n   The Group Address field is set to zero when sending
        a General Query,\n   and set to the IP multicast address being queried when
        sending a\n   Group-Specific Query or Group-and-Source-Specific Query (see
        section\n   4.1.9, below).\n"
      title: 4.1.3. Group Address
    - contents:
      - "4.1.4. Resv (Reserved)\n   The Resv field is set to zero on transmission,
        and ignored on\n   reception.\n"
      title: 4.1.4. Resv (Reserved)
    - contents:
      - "4.1.5. S Flag (Suppress Router-Side Processing)\n   When set to one, the
        S Flag indicates to any receiving multicast\n   routers that they are to suppress
        the normal timer updates they\n   perform upon hearing a Query.  It does not,
        however, suppress the\n   querier election or the normal \"host-side\" processing
        of a Query that\n   a router may be required to perform as a consequence of
        itself being\n   a group member.\n"
      title: 4.1.5. S Flag (Suppress Router-Side Processing)
    - contents:
      - "4.1.6. QRV (Querier's Robustness Variable)\n   If non-zero, the QRV field
        contains the [Robustness Variable] value\n   used by the querier, i.e., the
        sender of the Query.  If the querier's\n   [Robustness Variable] exceeds 7,
        the maximum value of the QRV field,\n   the QRV is set to zero.  Routers adopt
        the QRV value from the most\n   recently received Query as their own [Robustness
        Variable] value,\n   unless that most recently received QRV was zero, in which
        case the\n   receivers use the default [Robustness Variable] value specified
        in\n   section 8.1 or a statically configured value.\n"
      title: 4.1.6. QRV (Querier's Robustness Variable)
    - contents:
      - "4.1.7. QQIC (Querier's Query Interval Code)\n   The Querier's Query Interval
        Code field specifies the [Query\n   Interval] used by the querier.  The actual
        interval, called the\n   Querier's Query Interval (QQI), is represented in
        units of seconds\n   and is derived from the Querier's Query Interval Code
        as follows:\n   If QQIC < 128, QQI = QQIC\n   If QQIC >= 128, QQIC represents
        a floating-point value as follows:\n       0 1 2 3 4 5 6 7\n      +-+-+-+-+-+-+-+-+\n
        \     |1| exp | mant  |\n      +-+-+-+-+-+-+-+-+\n   QQI = (mant | 0x10) <<
        (exp + 3)\n   Multicast routers that are not the current querier adopt the
        QQI\n   value from the most recently received Query as their own [Query\n
        \  Interval] value, unless that most recently received QQI was zero, in\n
        \  which case the receiving routers use the default [Query Interval]\n   value
        specified in section 8.2.\n"
      title: 4.1.7. QQIC (Querier's Query Interval Code)
    - contents:
      - "4.1.8. Number of Sources (N)\n   The Number of Sources (N) field specifies
        how many source addresses\n   are present in the Query.  This number is zero
        in a General Query or\n   a Group-Specific Query, and non-zero in a Group-and-Source-Specific\n
        \  Query.  This number is limited by the MTU of the network over which\n   the
        Query is transmitted.  For example, on an Ethernet with an MTU of\n   1500
        octets, the IP header including the Router Alert option consumes\n   24 octets,
        and the IGMP fields up to including the Number of Sources\n   (N) field consume
        12 octets, leaving 1464 octets for source\n   addresses, which limits the
        number of source addresses to 366\n   (1464/4).\n"
      title: 4.1.8. Number of Sources (N)
    - contents:
      - "4.1.9. Source Address [i]\n   The Source Address [i] fields are a vector
        of n IP unicast addresses,\n   where n is the value in the Number of Sources
        (N) field.\n"
      title: 4.1.9. Source Address [i]
    - contents:
      - "4.1.10. Additional Data\n   If the Packet Length field in the IP header of
        a received Query\n   indicates that there are additional octets of data present,
        beyond\n   the fields described here, IGMPv3 implementations MUST include
        those\n   octets in the computation to verify the received IGMP Checksum,
        but\n   MUST otherwise ignore those additional octets.  When sending a Query,\n
        \  an IGMPv3 implementation MUST NOT include additional octets beyond\n   the
        fields described here.\n"
      title: 4.1.10. Additional Data
    - contents:
      - "4.1.11. Query Variants\n   There are three variants of the Query message:\n
        \  1. A \"General Query\" is sent by a multicast router to learn the\n      complete
        multicast reception state of the neighboring interfaces\n      (that is, the
        interfaces attached to the network on which the\n      Query is transmitted).
        \ In a General Query, both the Group Address\n      field and the Number of
        Sources (N) field are zero.\n   2. A \"Group-Specific Query\" is sent by a
        multicast router to learn\n      the reception state, with respect to a *single*
        multicast address,\n      of the neighboring interfaces.  In a Group-Specific
        Query, the\n      Group Address field contains the multicast address of interest,\n
        \     and the Number of Sources (N) field contains zero.\n   3. A \"Group-and-Source-Specific
        Query\" is sent by a multicast router\n      to learn if any neighboring interface
        desires reception of packets\n      sent to a specified multicast address,
        from any of a specified\n      list of sources.  In a Group-and-Source-Specific
        Query, the Group\n      Address field contains the multicast address of interest,
        and the\n      Source Address [i] fields contain the source address(es) of\n
        \     interest.\n"
      title: 4.1.11. Query Variants
    - contents:
      - "4.1.12. IP Destination Addresses for Queries\n   In IGMPv3, General Queries
        are sent with an IP destination address of\n   224.0.0.1, the all-systems
        multicast address.  Group-Specific and\n   Group-and-Source-Specific Queries
        are sent with an IP destination\n   address equal to the  multicast address
        of interest.  *However*, a\n   system MUST accept and  process any Query whose
        IP Destination\n   Address field contains *any* of the addresses (unicast
        or multicast)\n   assigned to the interface on which the Query arrives.\n"
      title: 4.1.12. IP Destination Addresses for Queries
    title: 4.1. Membership Query Message
  - contents:
    - "4.2. Version 3 Membership Report Message\n   Version 3 Membership Reports are
      sent by IP systems to report (to\n   neighboring routers) the current multicast
      reception state, or\n   changes in the multicast reception state, of their interfaces.\n
      \  Reports have the following format:\n       0                   1                   2
      \                  3\n       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
      4 5 6 7 8 9 0 1\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |  Type = 0x22  |    Reserved   |           Checksum            |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |           Reserved            |  Number of Group Records (M)  |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |                                                               |\n      .
      \                                                              .\n      .                        Group
      Record [1]                       .\n      .                                                               .\n
      \     |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |                                                               |\n      .
      \                                                              .\n      .                        Group
      Record [2]                       .\n      .                                                               .\n
      \     |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |                               .                               |\n      .
      \                              .                               .\n      |                               .
      \                              |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |                                                               |\n      .
      \                                                              .\n      .                        Group
      Record [M]                       .\n      .                                                               .\n
      \     |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  where each Group Record has the following internal format:\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |  Record Type  |  Aux Data Len |     Number of Sources (N)     |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |                       Multicast Address                       |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |                       Source Address [1]                      |\n      +-
      \                                                            -+\n      |                       Source
      Address [2]                      |\n      +-                                                             -+\n
      \     .                               .                               .\n      .
      \                              .                               .\n      .                               .
      \                              .\n      +-                                                             -+\n
      \     |                       Source Address [N]                      |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     |                                                               |\n      .
      \                                                              .\n      .                         Auxiliary
      Data                        .\n      .                                                               .\n
      \     |                                                               |\n      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"
    - contents:
      - "4.2.1. Reserved\n   The Reserved fields are set to zero on transmission,
        and ignored on\n   reception.\n"
      title: 4.2.1. Reserved
    - contents:
      - "4.2.2. Checksum\n   The Checksum is the 16-bit one's complement of the one's
        complement\n   sum of the whole IGMP message (the entire IP payload).  For
        computing\n   the checksum, the Checksum field is set to zero.  When receiving\n
        \  packets, the checksum MUST be verified before processing a message.\n"
      title: 4.2.2. Checksum
    - contents:
      - "4.2.3. Number of Group Records (M)\n   The Number of Group Records (M) field
        specifies how many Group\n   Records are present in this Report.\n"
      title: 4.2.3. Number of Group Records (M)
    - contents:
      - "4.2.4. Group Record\n   Each Group Record is a block of fields containing
        information\n   pertaining to the sender's membership in a single multicast
        group on\n   the interface from which the Report is sent.\n"
      title: 4.2.4. Group Record
    - contents:
      - "4.2.5. Record Type\n   See section 4.2.12, below.\n"
      title: 4.2.5. Record Type
    - contents:
      - "4.2.6. Aux Data Len\n   The Aux Data Len field contains the length of the
        Auxiliary Data\n   field in this Group Record, in units of 32-bit words.  It
        may contain\n   zero, to indicate the absence of any auxiliary data.\n"
      title: 4.2.6. Aux Data Len
    - contents:
      - "4.2.7. Number of Sources (N)\n   The Number of Sources (N) field specifies
        how many source addresses\n   are present in this Group Record.\n"
      title: 4.2.7. Number of Sources (N)
    - contents:
      - "4.2.8. Multicast Address\n   The Multicast Address field contains the IP
        multicast address to\n   which this Group Record pertains.\n"
      title: 4.2.8. Multicast Address
    - contents:
      - "4.2.9. Source Address [i]\n   The Source Address [i] fields are a vector
        of n IP unicast addresses,\n   where n is the value in this record's Number
        of Sources (N) field.\n"
      title: 4.2.9. Source Address [i]
    - contents:
      - "4.2.10. Auxiliary Data\n   The Auxiliary Data field, if present, contains
        additional information\n   pertaining to this Group Record.  The protocol
        specified in this\n   document, IGMPv3, does not define any auxiliary data.
        \ Therefore,\n   implementations of IGMPv3 MUST NOT include any auxiliary
        data (i.e.,\n   MUST set the Aux Data Len field to zero) in any transmitted
        Group\n   Record, and MUST ignore any auxiliary data present in any received\n
        \  Group Record.  The semantics and internal encoding of the Auxiliary\n   Data
        field are to be defined by any future version or extension of\n   IGMP that
        uses this field.\n"
      title: 4.2.10. Auxiliary Data
    - contents:
      - "4.2.11. Additional Data\n   If the Packet Length field in the IP header of
        a received Report\n   indicates that there are additional octets of data present,
        beyond\n   the last Group Record, IGMPv3 implementations MUST include those\n
        \  octets in the computation to verify the received IGMP Checksum, but\n   MUST
        otherwise ignore those additional octets.  When sending a\n   Report, an IGMPv3
        implementation MUST NOT include additional octets\n   beyond the last Group
        Record.\n"
      title: 4.2.11. Additional Data
    - contents:
      - "4.2.12. Group Record Types\n   There are a number of different types of Group
        Records that may be\n   included in a Report message:\n   o A \"Current-State
        Record\" is sent by a system in response to a Query\n     received on an interface.
        \ It reports the current reception state\n     of that interface, with respect
        to a single multicast address.  The\n     Record Type of a Current-State Record
        may be one of the following\n     two values:\n        Value  Name and Meaning\n
        \       -----  ----------------\n          1    MODE_IS_INCLUDE - indicates
        that the interface has a\n               filter mode of INCLUDE for the specified
        multicast\n               address.  The Source Address [i] fields in this
        Group\n               Record contain the interface's source list for the\n
        \              specified multicast address, if it is non-empty.\n          2
        \   MODE_IS_EXCLUDE - indicates that the interface has a\n               filter
        mode of EXCLUDE for the specified multicast\n               address.  The
        Source Address [i] fields in this Group\n               Record contain the
        interface's source list for the\n               specified multicast address,
        if it is non-empty.\n   o A \"Filter-Mode-Change Record\" is sent by a system
        whenever a local\n     invocation of IPMulticastListen causes a change of
        the filter mode\n     (i.e., a change from INCLUDE to EXCLUDE, or from EXCLUDE
        to\n     INCLUDE), of the interface-level state entry for a particular\n     multicast
        address.  The Record is included in a Report sent from\n     the interface
        on which the change occurred.  The Record Type of a\n     Filter-Mode-Change
        Record may be one of the following two values:\n          3    CHANGE_TO_INCLUDE_MODE
        - indicates that the interface\n               has changed to INCLUDE filter
        mode for the specified\n               multicast address.  The Source Address
        [i] fields\n               in this Group Record contain the interface's new\n
        \              source list for the specified multicast address,\n               if
        it is non-empty.\n          4    CHANGE_TO_EXCLUDE_MODE - indicates that the
        interface\n               has changed to EXCLUDE filter mode for the specified\n
        \              multicast address.  The Source Address [i] fields\n               in
        this Group Record contain the interface's new\n               source list
        for the specified multicast address,\n               if it is non-empty.\n
        \  o A \"Source-List-Change Record\" is sent by a system whenever a local\n
        \    invocation of IPMulticastListen causes a change of source list that\n
        \    is *not* coincident with a change of filter mode, of the\n     interface-level
        state entry for a particular multicast address.\n     The Record is included
        in a Report sent from the interface on which\n     the change occurred.  The
        Record Type of a Source-List-Change\n     Record may be one of the following
        two values:\n          5    ALLOW_NEW_SOURCES - indicates that the Source
        Address\n               [i] fields in this Group Record contain a list of
        the\n               additional sources that the system wishes to\n               hear
        from, for packets sent to the specified\n               multicast address.
        \ If the change was to an INCLUDE\n               source list, these are the
        addresses that were added\n               to the list; if the change was to
        an EXCLUDE source\n               list, these are the addresses that were
        deleted from\n               the list.\n          6    BLOCK_OLD_SOURCES -
        indicates that the Source Address\n               [i] fields in this Group
        Record contain a list of the\n               sources that the system no longer
        wishes to\n               hear from, for packets sent to the specified\n               multicast
        address.  If the change was to an INCLUDE\n               source list, these
        are the addresses that were\n               deleted from  the list; if the
        change was to an\n               EXCLUDE source list, these are the addresses
        that\n               were added to the list.\n   If a change of source list
        results in both allowing new sources and\n   blocking old sources, then two
        Group Records are sent for the same\n   multicast address, one of type ALLOW_NEW_SOURCES
        and one of type\n   BLOCK_OLD_SOURCES.\n   We use the term \"State-Change
        Record\" to refer to either a Filter-\n   Mode-Change Record or a Source-List-Change
        Record.\n   Unrecognized Record Type values MUST be silently ignored.\n"
      title: 4.2.12. Group Record Types
    - contents:
      - "4.2.13. IP Source Addresses for Reports\n   An IGMP report is sent with a
        valid IP source address for the\n   destination subnet.  The 0.0.0.0 source
        address may be used by a\n   system that has not yet acquired an IP address.
        \ Note that the\n   0.0.0.0 source address may simultaneously be used by multiple
        systems\n   on a LAN.  Routers MUST accept a report with a source address
        of\n   0.0.0.0.\n"
      title: 4.2.13. IP Source Addresses for Reports
    - contents:
      - "4.2.14. IP Destination Addresses for Reports\n   Version 3 Reports are sent
        with an IP destination address of\n   224.0.0.22, to which all IGMPv3-capable
        multicast routers listen.  A\n   system that is operating in version 1 or
        version 2 compatibility\n   modes sends version 1 or version 2 Reports to
        the multicast group\n   specified in the Group Address field of the Report.
        \ In addition, a\n   system MUST accept and process any version 1 or version
        2 Report\n   whose IP Destination Address field contains *any* of the addresses\n
        \  (unicast or multicast) assigned to the interface on which the Report\n
        \  arrives.\n"
      title: 4.2.14. IP Destination Addresses for Reports
    - contents:
      - "4.2.15. Notation for Group Records\n   In the rest of this document, we use
        the following notation to\n   describe the contents of a Group Record pertaining
        to a particular\n   multicast address:\n      IS_IN ( x )  -  Type MODE_IS_INCLUDE,
        source addresses x\n      IS_EX ( x )  -  Type MODE_IS_EXCLUDE, source addresses
        x\n      TO_IN ( x )  -  Type CHANGE_TO_INCLUDE_MODE, source addresses x\n
        \     TO_EX ( x )  -  Type CHANGE_TO_EXCLUDE_MODE, source addresses x\n      ALLOW
        ( x )  -  Type ALLOW_NEW_SOURCES, source addresses x\n      BLOCK ( x )  -
        \ Type BLOCK_OLD_SOURCES, source addresses x\n   where x is either:\n   o
        a capital letter (e.g., \"A\") to represent the set of source\n     addresses,
        or\n   o a set expression (e.g., \"A+B\"), where \"A+B\" means the union of
        sets\n     A and B, \"A*B\" means the intersection of sets A and B, and \"A-B\"\n
        \    means the removal of all elements of set B from set A.\n"
      title: 4.2.15. Notation for Group Records
    - contents:
      - "4.2.16. Membership Report Size\n   If the set of Group Records required in
        a Report does not fit within\n   the size limit of a single Report message
        (as determined by the MTU\n   of the network on which it will be sent), the
        Group Records are sent\n   in as many Report messages as needed to report
        the entire set.\n   If a single Group Record contains so many source addresses
        that it\n   does not fit within the size limit of a single Report message,
        if its\n   Type is not MODE_IS_EXCLUDE or CHANGE_TO_EXCLUDE_MODE, it is split\n
        \  into multiple Group Records, each containing a different subset of\n   the
        source addresses and each sent in a separate Report message.  If\n   its Type
        is MODE_IS_EXCLUDE or CHANGE_TO_EXCLUDE_MODE, a single Group\n   Record is
        sent, containing as many source addresses as can fit, and\n   the remaining
        source addresses are not reported; though the choice of\n   which sources
        to report is arbitrary, it is preferable to report the\n   same set of sources
        in each subsequent report, rather than reporting\n   different sources each
        time.\n"
      title: 4.2.16. Membership Report Size
    title: 4.2. Version 3 Membership Report Message
  title: 4. Message Formats
- contents:
  - "5. Description of the Protocol for Group Members\n   IGMP is an asymmetric protocol,
    specifying separate behaviors for\n   group members -- that is, hosts or routers
    that wish to receive\n   multicast packets -- and multicast routers.  This section
    describes\n   the part of IGMPv3 that applies to all group members.  (Note that
    a\n   multicast router that is also a group member performs both parts of\n   IGMPv3,
    receiving and responding to its own IGMP message\n   transmissions as well as
    those of its neighbors.  The multicast\n   router part of IGMPv3 is described
    in section 6.)\n   A system performs the protocol described in this section over
    all\n   interfaces on which multicast reception is supported, even if more\n   than
    one of those interfaces is connected to the same network.\n   For interoperability
    with multicast routers running older versions of\n   IGMP, systems maintain a
    MulticastRouterVersion variable for each\n   interface on which multicast reception
    is supported.  This section\n   describes the behavior of group member systems
    on interfaces for\n   which MulticastRouterVersion = 3.  The algorithm for determining\n
    \  MulticastRouterVersion, and the behavior for versions other than 3,\n   are
    described in section 7.\n   The all-systems multicast address, 224.0.0.1, is handled
    as a special\n   case.  On all systems -- that is all hosts and routers, including\n
    \  multicast routers -- reception of packets destined to the all-systems\n   multicast
    address, from all sources, is permanently enabled on all\n   interfaces on which
    multicast reception is supported.  No IGMP\n   messages are ever sent regarding
    the all-systems multicast address.\n   There are two types of events that trigger
    IGMPv3 protocol actions on\n   an interface:\n   o a change of the interface reception
    state, caused by a local\n     invocation of IPMulticastListen.\n   o reception
    of a Query.\n   (Received IGMP messages of types other than Query are silently\n
    \  ignored, except as required for interoperation with earlier versions\n   of
    IGMP.)\n   The following subsections describe the actions to be taken for each\n
    \  of these two cases.  In those descriptions, timer and counter names\n   appear
    in square brackets.  The default values for those timers and\n   counters are
    specified in section 8.\n"
  - contents:
    - "5.1. Action on Change of Interface State\n   An invocation of IPMulticastListen
      may cause the multicast reception\n   state of an interface to change, according
      to the rules in section\n   3.2.  Each such change affects the per-interface
      entry for a single\n   multicast address.\n   A change of interface state causes
      the system to immediately transmit\n   a State-Change Report from that interface.
      \ The type and contents of\n   the Group Record(s) in that Report are determined
      by comparing the\n   filter mode and source list for the affected multicast
      address before\n   and after the change, according to the table below.  If no
      interface\n   state existed for that multicast address before the change (i.e.,
      the\n   change consisted of creating a new per-interface record), or if no\n
      \  state exists after the change (i.e., the change consisted of deleting\n   a
      per-interface record), then the \"non-existent\" state is considered\n   to
      have a filter mode of INCLUDE and an empty source list.\n     Old State         New
      State         State-Change Record Sent\n     ---------         ---------         ------------------------\n
      \    INCLUDE (A)       INCLUDE (B)       ALLOW (B-A), BLOCK (A-B)\n     EXCLUDE
      (A)       EXCLUDE (B)       ALLOW (A-B), BLOCK (B-A)\n     INCLUDE (A)       EXCLUDE
      (B)       TO_EX (B)\n     EXCLUDE (A)       INCLUDE (B)       TO_IN (B)\n   If
      the computed source list for either an ALLOW or a BLOCK State-\n   Change Record
      is empty, that record is omitted from the Report\n   message.\n   To cover the
      possibility of the State-Change Report being missed by\n   one or more multicast
      routers, it is retransmitted [Robustness\n   Variable] - 1 more times, at intervals
      chosen at random from the\n   range (0, [Unsolicited Report Interval]).\n   If
      more changes to the same interface state entry occur before all\n   the retransmissions
      of the State-Change Report for the first change\n   have been completed, each
      such additional change triggers the\n   immediate transmission of a new State-Change
      Report.\n   The contents of the new transmitted report are calculated as follows.\n
      \  As was done with the first report, the interface state for the\n   affected
      group before and after the latest change is compared.  The\n   report records
      expressing the difference are built according to the\n   table above.  However
      these records are not transmitted in a message\n   but instead merged with the
      contents of the pending report, to create\n   the new State-Change report.  The
      rules for merging the difference\n   report resulting from the state change
      and the pending report are\n   described below.\n   The transmission of the
      merged State-Change Report terminates\n   retransmissions of the earlier State-Change
      Reports for the same\n   multicast address, and becomes the first of [Robustness
      Variable]\n   transmissions of State-Change Reports.\n   Each time a source
      is included in the difference report calculated\n   above, retransmission state
      for that source needs to be maintained\n   until [Robustness Variable] State-Change
      reports have been sent by\n   the host.  This is done in order to ensure that
      a series of\n   successive state changes do not break the protocol robustness.\n
      \  If the interface reception-state change that triggers the new report\n   is
      a filter-mode change, then the next [Robustness Variable] State-\n   Change
      Reports will include a Filter-Mode-Change record.  This\n   applies even if
      any number of source-list changes occur in that\n   period.  The host has to
      maintain retransmission state for the group\n   until the [Robustness Variable]
      State-Change reports have been sent.\n   When [Robustness Variable] State-Change
      reports with Filter-Mode-\n   Change records have been transmitted after the
      last filter-mode\n   change, and if source-list changes to the interface reception
      have\n   scheduled additional reports, then the next State-Change report will\n
      \  include Source-List-Change records.\n   Each time a State-Change Report is
      transmitted, the contents are\n   determined as follows.  If the report should
      contain a Filter-Mode-\n   Change record, then if the current filter-mode of
      the interface is\n   INCLUDE, a TO_IN record is included in the report, otherwise
      a TO_EX\n   record is included.  If instead the report should contain Source-\n
      \  List-Change records, an ALLOW and a BLOCK record are included.  The\n   contents
      of these records are built according to the table below.\n      Record   Sources
      included\n      ------   ----------------\n      TO_IN    All in the current
      interface state that must be forwarded\n      TO_EX    All in the current interface
      state that must be blocked\n      ALLOW    All with retransmission state that
      must be forwarded\n      BLOCK    All with retransmission state that must be
      blocked\n   If the computed source list for either an ALLOW or a BLOCK record
      is\n   empty, that record is omitted from the State-Change report.\n   Note:
      When the first State-Change report is sent, the non-existent\n   pending report
      to merge with, can be treated as a source-change\n   report with empty ALLOW
      and BLOCK records (no sources have\n   retransmission state).\n"
    title: 5.1. Action on Change of Interface State
  - contents:
    - "5.2. Action on Reception of a Query\n   When a system receives a Query, it
      does not respond immediately.\n   Instead, it delays its response by a random
      amount of time, bounded\n   by the Max Resp Time value derived from the Max
      Resp Code in the\n   received Query message.  A system may receive a variety
      of Queries on\n   different interfaces and of different kinds (e.g., General
      Queries,\n   Group-Specific Queries, and Group-and-Source-Specific Queries),
      each\n   of which may require its own delayed response.\n   Before scheduling
      a response to a Query, the system must first\n   consider previously scheduled
      pending responses and in many cases\n   schedule a combined response.  Therefore,
      the system must be able to\n   maintain the following state:\n   o A timer per
      interface for scheduling responses to General Queries.\n   o A per-group and
      interface timer for scheduling responses to Group-\n     Specific and Group-and-Source-Specific
      Queries.\n   o A per-group and interface list of sources to be reported in the\n
      \    response to a Group-and-Source-Specific Query.\n   When a new Query with
      the Router-Alert option arrives on an\n   interface, provided the system has
      state to report, a delay for a\n   response is randomly selected in the range
      (0, [Max Resp Time]) where\n   Max Resp Time is derived from Max Resp Code in
      the received Query\n   message.  The following rules are then used to determine
      if a Report\n   needs to be scheduled and the type of Report to schedule.  The
      rules\n   are considered in order and only the first matching rule is applied.\n
      \  1. If there is a pending response to a previous General Query\n      scheduled
      sooner than the selected delay, no additional response\n      needs to be scheduled.\n
      \  2. If the received Query is a General Query, the interface timer is\n      used
      to schedule a response to the General Query after the\n      selected delay.
      \ Any previously pending response to a General\n      Query is canceled.\n   3.
      If the received Query is a Group-Specific Query or a Group-and-\n      Source-Specific
      Query and there is no pending response to a\n      previous Query for this group,
      then the group timer is used to\n      schedule a report.  If the received Query
      is a Group-and-Source-\n      Specific Query, the list of queried sources is
      recorded to be used\n      when generating a response.\n   4. If there already
      is a pending response to a previous Query\n      scheduled for this group, and
      either the new Query is a Group-\n      Specific Query or the recorded source-list
      associated with the\n      group is empty, then the group source-list is cleared
      and a single\n      response is scheduled using the group timer.  The new response
      is\n      scheduled to be sent at the earliest of the remaining time for the\n
      \     pending report and the selected delay.\n   5. If the received Query is
      a Group-and-Source-Specific Query and\n      there is a pending response for
      this group with a non-empty\n      source-list, then the group source list is
      augmented to contain\n      the list of sources in the new Query and a single
      response is\n      scheduled using the group timer.  The new response is scheduled
      to\n      be sent at the earliest of the remaining time for the pending\n      report
      and the selected delay.\n   When the timer in a pending response record expires,
      the system\n   transmits, on the associated interface, one or more Report messages\n
      \  carrying one or more Current-State Records (see section 4.2.12), as\n   follows:\n
      \  1. If the expired timer is the interface timer (i.e., it is a pending\n      response
      to a General Query), then one Current-State Record is\n      sent for each multicast
      address for which the specified interface\n      has reception state, as described
      in section 3.2.  The Current-\n      State Record carries the multicast address
      and its associated\n      filter mode (MODE_IS_INCLUDE or MODE_IS_EXCLUDE) and
      source list.\n      Multiple Current-State Records are packed into individual
      Report\n      messages, to the extent possible.\n      This naive algorithm
      may result in bursts of packets when a system\n      is a member of a large
      number of groups.  Instead of using a\n      single interface timer, implementations
      are recommended to spread\n      transmission of such Report messages over the
      interval (0, [Max\n      Resp Time]).  Note that any such implementation MUST
      avoid the\n      \"ack-implosion\" problem, i.e., MUST NOT send a Report immediately\n
      \     on reception of a General Query.\n   2. If the expired timer is a group
      timer and the list of recorded\n      sources for the that group is empty (i.e.,
      it is a pending\n      response to a Group-Specific Query), then if and only
      if the\n      interface has reception state for that group address, a single\n
      \     Current-State Record is sent for that address.  The Current-State\n      Record
      carries the multicast address and its associated filter\n      mode (MODE_IS_INCLUDE
      or MODE_IS_EXCLUDE) and source list.\n   3. If the expired timer is a group
      timer and the list of recorded\n      sources for that group is non-empty (i.e.,
      it is a pending\n      response to a Group-and-Source-Specific Query), then
      if and only\n      if the interface has reception state for that group address,
      the\n      contents of the responding Current-State Record is determined from\n
      \     the interface state and the pending response record, as specified\n      in
      the following table:\n                         set of sources in the\n      interface
      state   pending response record   Current-State Record\n      ---------------
      \  -----------------------   --------------------\n       INCLUDE (A)                B
      \                  IS_IN (A*B)\n       EXCLUDE (A)                B                   IS_IN
      (B-A)\n   If the resulting Current-State Record has an empty set of source\n
      \  addresses, then no response is sent.\n   Finally, after any required Report
      messages have been generated, the\n   source lists associated with any reported
      groups are cleared.\n"
    title: 5.2. Action on Reception of a Query
  title: 5. Description of the Protocol for Group Members
- contents:
  - "6. Description of the Protocol for Multicast Routers\n   The purpose of IGMP
    is to enable each multicast router to learn, for\n   each of its directly attached
    networks, which multicast addresses are\n   of interest to the systems attached
    to those networks.  IGMP version\n   3 adds the capability for a multicast router
    to also learn  which\n   *sources* are of interest to neighboring systems, for
    packets sent to\n   any particular multicast address.  The information gathered
    by IGMP\n   is provided to whichever multicast routing protocol is being used
    by\n   the router, in order to ensure that multicast packets are delivered\n   to
    all networks where there are interested receivers.\n   This section describes
    the part of IGMPv3 that is performed by\n   multicast routers.  Multicast routers
    may also themselves become\n   members of multicast groups, and therefore also
    perform the group\n   member part of IGMPv3, described in section 5.\n   A multicast
    router performs the protocol described in this section\n   over each of its directly-attached
    networks.  If a multicast router\n   has more than one interface to the same network,
    it only needs to\n   operate this protocol over one of those interfaces.  On each\n
    \  interface over which this protocol is being run, the router MUST\n   enable
    reception of multicast address 224.0.0.22, from all sources\n   (and MUST perform
    the group member part of IGMPv3 for that address on\n   that interface).\n   Multicast
    routers need to know only that *at least one* system on an\n   attached network
    is interested in packets to a particular multicast\n   address from a particular
    source; a multicast router is not required\n   to keep track of the interests
    of each individual neighboring system.\n   (However, see Appendix A.2 point 1
    for discussion.)\n   IGMPv3 is backward compatible with previous versions of the
    IGMP\n   protocol.  In order to remain backward compatible with older IGMP\n   systems,
    IGMPv3 multicast routers MUST also implement versions 1 and\n   2 of the protocol
    (see section 7).\n"
  - contents:
    - "6.1. Conditions for IGMP Queries\n   Multicast routers send General Queries
      periodically to request group\n   membership information from an attached network.
      \ These queries are\n   used to build and refresh the group membership state
      of systems on\n   attached networks.  Systems respond to these queries by reporting\n
      \  their group membership state (and their desired set of sources) with\n   Current-State
      Group Records in IGMPv3 Membership Reports.\n   As a member of a multicast group,
      a system may express interest in\n   receiving or not receiving traffic from
      particular sources.  As the\n   desired reception state of a system changes,
      it reports these changes\n   using Filter-Mode-Change Records or Source-List-Change
      Records.\n   These records indicate an explicit state change in a group at a\n
      \  system in either the group record's source list or its filter-mode.\n   When
      a group membership is terminated at a system or traffic from a\n   particular
      source is no longer desired, a multicast router must query\n   for other members
      of the group or listeners of the source before\n   deleting the group (or source)
      and pruning its traffic.\n   To enable all systems on a network to respond to
      changes in group\n   membership, multicast routers send specific queries.  A
      Group-\n   Specific Query is sent to verify there are no systems that desire\n
      \  reception of the specified group or to \"rebuild\" the desired\n   reception
      state for a particular group.  Group-Specific Queries are\n   sent when a router
      receives a State-Change record indicating a system\n   is leaving a group.\n
      \  A Group-and-Source Specific Query is used to verify there are no\n   systems
      on a network which desire to receive traffic from a set of\n   sources.  Group-and-Source
      Specific Queries list sources for a\n   particular group which have been requested
      to no longer be forwarded.\n   This query is sent by a multicast router to learn
      if any systems\n   desire reception of packets to the specified group address
      from the\n   specified source addresses.  Group-and-Source Specific Queries
      are\n   only sent in response to State-Change Records and never in response\n
      \  to Current-State Records.  Section 4.1.11 describes each query in\n   more
      detail.\n"
    title: 6.1. Conditions for IGMP Queries
  - contents:
    - "6.2. IGMP State Maintained by Multicast Routers\n   Multicast routers implementing
      IGMPv3 keep state per group per\n   attached network.  This group state consists
      of a filter-mode, a list\n   of sources, and various timers.  For each attached
      network running\n   IGMP, a multicast router records the desired reception state
      for that\n   network.  That state conceptually consists of a set of records
      of the\n   form:\n      (multicast address, group timer, filter-mode, (source
      records))\n   Each source record is of the form:\n      (source address, source
      timer)\n   If all sources within a given group are desired, an empty source\n
      \  record list is kept with filter-mode set to EXCLUDE.  This means\n   hosts
      on this network want all sources for this group to be\n   forwarded.  This is
      the IGMPv3 equivalent to a IGMPv1 or IGMPv2 group\n   join.\n"
    - contents:
      - "6.2.1. Definition of Router Filter-Mode\n   To reduce internal state, IGMPv3
        routers keep a filter-mode per group\n   per attached network.  This filter-mode
        is used to condense the total\n   desired reception state of a group to a
        minimum set such that all\n   systems' memberships are satisfied.  This filter-mode
        may change in\n   response to the reception of particular types of group records
        or\n   when certain timer conditions occur.  In the following sections, we\n
        \  use the term \"router filter-mode\" to refer to the filter-mode of a\n
        \  particular group within a router.  Section 6.4 describes the changes\n
        \  of a router filter-mode per group record received.\n   Conceptually, when
        a group record is received, the router filter-mode\n   for that group is updated
        to cover all the requested sources using\n   the least amount of state.  As
        a rule, once a group record with a\n   filter-mode of EXCLUDE is received,
        the router filter-mode for that\n   group will be EXCLUDE.\n   When a router
        filter-mode for a group is EXCLUDE, the source record\n   list contains two
        types of sources.  The first type is the set which\n   represents conflicts
        in the desired reception state; this set must be\n   forwarded by some router
        on the network.  The second type is the set\n   of sources which hosts have
        requested to not be forwarded.  Appendix\n   A describes the reasons for keeping
        this second set when in EXCLUDE\n   mode.\n   When a router filter-mode for
        a group is INCLUDE, the source record\n   list is the list of sources desired
        for the group.  This is the total\n   desired set of sources for that group.
        \ Each source in the source\n   record list must be forwarded by some router
        on the network.\n   Because a reported group record with a filter-mode of
        EXCLUDE will\n   cause a router to transition its filter-mode for that group
        to\n   EXCLUDE, a mechanism for transitioning a router's filter-mode back
        to\n   INCLUDE must exist.  If all systems with a group record in EXCLUDE\n
        \  filter-mode cease reporting, it is desirable for the router filter-\n   mode
        for that group to transition back to INCLUDE mode.  This\n   transition occurs
        when the group timer expires and is explained in\n   detail in section 6.5.\n"
      title: 6.2.1. Definition of Router Filter-Mode
    - contents:
      - "6.2.2. Definition of Group Timers\n   The group timer is only used when a
        group is in EXCLUDE mode and it\n   represents the time for the *filter-mode*
        of the group to expire and\n   switch to INCLUDE mode.  We define a group
        timer as a decrementing\n   timer with a lower bound of zero kept per group
        per attached network.\n   Group timers are updated according to the types
        of group records\n   received.\n   A group timer expiring when a router filter-mode
        for the group is\n   EXCLUDE means there are no listeners on the attached
        network in\n   EXCLUDE mode.  At this point, a router will transition to INCLUDE\n
        \  filter-mode.  Section 6.5 describes the actions taken when a group\n   timer
        expires while in EXCLUDE mode.\n   The following table summarizes the role
        of the group timer.  Section\n   6.4 describes the details of setting the
        group timer per type of\n   group record received.\n      Group\n      Filter-Mode
        \     Group Timer Value      Actions/Comments\n      -----------      -----------------
        \     ----------------\n      INCLUDE          Timer >= 0             All
        members in INCLUDE\n                                              mode.\n
        \     EXCLUDE          Timer > 0              At least one member in\n                                              EXCLUDE
        mode.\n      EXCLUDE          Timer == 0             No more listeners to\n
        \                                             group.  If all source\n                                              timers
        have expired then\n                                              delete Group
        Record.\n                                              If there are still\n
        \                                             source record timers\n                                              running,
        switch to\n                                              INCLUDE filter-mode\n
        \                                             using those source records\n
        \                                             with running timers as the\n
        \                                             INCLUDE source record\n                                              state.\n"
      title: 6.2.2. Definition of Group Timers
    - contents:
      - "6.2.3. Definition of Source Timers\n   A source timer is kept per source
        record and is a decrementing timer\n   with a lower bound of zero.  Source
        timers are updated according to\n   the type and filter-mode of the group
        record received.  Source timers\n   are always updated (for a particular group)
        whenever the source is\n   present in a received record for that group.  Section
        6.4 describes\n   the setting of source timers per type of group records received.\n
        \  A source record with a running timer with a router filter-mode for\n   the
        group of INCLUDE means that there is currently one or more\n   systems (in
        INCLUDE filter-mode) which desire to receive that source.\n   If a source
        timer expires with a router filter-mode for the group of\n   INCLUDE, the
        router concludes that traffic from this particular\n   source is no longer
        desired on the attached network, and deletes the\n   associated source record.\n
        \  Source timers are treated differently when a router filter-mode for a\n
        \  group is EXCLUDE.  If a source record has a running timer with a\n   router
        filter-mode for the group of EXCLUDE, it means that at least\n   one system
        desires the source.  It should therefore be forwarded by a\n   router on the
        network.  Appendix A describes the reasons for keeping\n   state for sources
        that have been requested to be forwarded while in\n   EXCLUDE state.\n   If
        a source timer expires with a router filter-mode for the group of\n   EXCLUDE,
        the router informs the routing protocol that there is no\n   longer a receiver
        on the network interested in traffic from this\n   source.\n   When a router
        filter-mode for a group is EXCLUDE, source records are\n   only deleted when
        the group timer expires.  Section 6.3 describes the\n   actions that should
        be taken dependent upon the value of a source\n   timer.\n"
      title: 6.2.3. Definition of Source Timers
    title: 6.2. IGMP State Maintained by Multicast Routers
  - contents:
    - "6.3. IGMPv3 Source-Specific Forwarding Rules\n   When a multicast router receives
      a datagram from a source destined to\n   a particular group, a decision has
      to be made whether to forward the\n   datagram onto an attached network or not.
      \ The multicast routing\n   protocol in use is in charge of this decision, and
      should use the\n   IGMPv3 information to ensure that all sources/groups desired
      on a\n   subnetwork are forwarded to that subnetwork.  IGMPv3 information does\n
      \  not override multicast routing information; for example, if the\n   IGMPv3
      filter-mode group for G is EXCLUDE, a router may still forward\n   packets for
      excluded sources to a transit subnet.\n   To summarize, the following table
      describes the forwarding\n   suggestions made by IGMP to the routing protocol
      for traffic\n   originating from a source destined to a group.  It also summarizes\n
      \  the actions taken upon the expiration of a source timer based on the\n   router
      filter-mode of the group.\n      Group\n      Filter-Mode    Source Timer Value
      \   Action\n      -----------    ------------------    ------\n      INCLUDE
      \       TIMER > 0             Suggest to forward traffic\n                                           from
      source\n      INCLUDE        TIMER == 0            Suggest to stop forwarding\n
      \                                          traffic from source and\n                                           remove
      source record.  If\n                                           there are no
      more source\n                                           records for the group,
      delete\n                                           group record.\n      INCLUDE
      \       No Source Elements    Suggest to not forward source\n      EXCLUDE        TIMER
      > 0             Suggest to forward traffic\n                                           from
      source\n      EXCLUDE        TIMER == 0            Suggest to not forward\n
      \                                          traffic from source\n                                           (DO
      NOT remove record)\n      EXCLUDE        No Source Elements    Suggest to forward
      traffic\n                                           from source\n"
    title: 6.3. IGMPv3 Source-Specific Forwarding Rules
  - contents:
    - '6.4. Action on Reception of Reports

      '
    - contents:
      - "6.4.1. Reception of Current-State Records\n   When receiving Current-State
        Records, a router updates both its group\n   and source timers.  In some circumstances,
        the reception of a type of\n   group record will cause the router filter-mode
        for that group to\n   change.  The table below describes the actions, with
        respect to state\n   and timers that occur to a router's state upon reception
        of Current-\n   State Records.\n   The following notation is used to describe
        the updating of source\n   timers.  The notation ( A, B ) will be used to
        represent the total\n   number of sources for a particular group, where\n
        \  A = set of source records whose source timers > 0 (Sources that at\n       least
        one host has requested to be forwarded)\n   B = set of source records whose
        source timers = 0 (Sources that IGMP\n       will suggest to the routing protocol
        not to forward)\n   Note that there will only be two sets when a router's
        filter-mode for\n   a group is EXCLUDE.  When a router's filter-mode for a
        group is\n   INCLUDE, a single set is used to describe the set of sources\n
        \  requested to be forwarded (e.g., simply (A)).\n   In the following tables,
        abbreviations are used for several variables\n   (all of which are described
        in detail in section 8).  The variable\n   GMI is an abbreviation for the
        Group Membership Interval, which is\n   the time in which group memberships
        will time out.  The variable LMQT\n   is an abbreviation for the Last Member
        Query Time, which is the total\n   time spent after Last Member Query Count
        retransmissions.  LMQT\n   represents the  \"leave latency\", or the difference
        between the\n   transmission of a membership change and the change in the
        information\n   given to the routing protocol.\n   Within the \"Actions\"
        section of the router state tables, we use the\n   notation 'A=J', which means
        that the set A of source records should\n   have their source timers set to
        value J.  'Delete A' means that the\n   set A of source records should be
        deleted.  'Group Timer=J' means\n   that the Group Timer for the group should
        be set to value J.\n   Router State   Report Rec'd  New Router State         Actions\n
        \  ------------   ------------  ----------------         -------\n   INCLUDE
        (A)    IS_IN (B)     INCLUDE (A+B)            (B)=GMI\n   INCLUDE (A)    IS_EX
        (B)     EXCLUDE (A*B,B-A)        (B-A)=0\n                                                         Delete
        (A-B)\n                                                         Group Timer=GMI\n
        \  EXCLUDE (X,Y)  IS_IN (A)     EXCLUDE (X+A,Y-A)        (A)=GMI\n   EXCLUDE
        (X,Y)  IS_EX (A)     EXCLUDE (A-Y,Y*A)        (A-X-Y)=GMI\n                                                         Delete
        (X-A)\n                                                         Delete (Y-A)\n
        \                                                        Group Timer=GMI\n"
      title: 6.4.1. Reception of Current-State Records
    - contents:
      - "6.4.2. Reception of Filter-Mode-Change and Source-List-Change Records\n   When
        a change in the global state of a group occurs in a system, the\n   system
        sends either a Source-List-Change Record or a Filter-Mode-\n   Change Record
        for that group.  As with Current-State Records, routers\n   must act upon
        these records and possibly change their own state to\n   reflect the new desired
        membership state of the network.\n   Routers must query sources that are requested
        to be no longer\n   forwarded to a group.  When a router queries or receives
        a query for\n   a specific set of sources, it lowers its source timers for
        those\n   sources to a small interval of Last Member Query Time seconds.  If\n
        \  group records are received in response to the queries which express\n   interest
        in receiving traffic from the queried sources, the\n   corresponding timers
        are updated.\n   Similarly, when a router queries a specific group, it lowers
        its\n   group timer for that group to a small interval of Last Member Query\n
        \  Time seconds.  If any group records expressing EXCLUDE mode interest\n
        \  in the group are received within the interval, the group timer for\n   the
        group is updated and the suggestion to the routing protocol to\n   forward
        the group stands without any interruption.\n   During a query period (i.e.,
        Last Member Query Time seconds), the\n   IGMP component in the router continues
        to suggest to the routing\n   protocol that it forwards traffic from the groups
        or sources that it\n   is querying.  It is not until after Last Member Query
        Time seconds\n   without receiving a record expressing interest in the queried
        group\n   or sources that the router may prune the group or sources from the\n
        \  network.\n   The following table describes the changes in group state and
        the\n   action(s) taken when receiving either Filter-Mode-Change or Source-\n
        \  List-Change Records.  This table also describes the queries which are\n
        \  sent by the querier when a particular report is received.\n   We use the
        following notation for describing the queries which are\n   sent.  We use
        the notation 'Q(G)' to describe a Group-Specific Query\n   to G.  We use the
        notation 'Q(G,A)' to describe a Group-and-Source\n   Specific Query to G with
        source-list A.  If source-list A is null as\n   a result of the action (e.g.,
        A*B) then no query is sent as a result\n   of the operation.\n   In order
        to maintain protocol robustness, queries sent by actions in\n   the table
        below need to be transmitted [Last Member Query Count]\n   times, once every
        [Last Member Query Interval].\n   If while scheduling new queries, there are
        already pending queries to\n   be retransmitted for the same group, the new
        and pending queries have\n   to be merged.  In addition, received host reports
        for a group with\n   pending queries may affect the contents of those queries.
        \ Section\n   6.6.3 describes the process of building and maintaining the
        state of\n   pending queries.\n"
      - 'Router State   Report Rec''d New Router State        Actions

        '
      - '------------   ------------ ----------------        -------

        '
      - 'INCLUDE (A)    ALLOW (B)    INCLUDE (A+B)           (B)=GMI

        '
      - 'INCLUDE (A)    BLOCK (B)    INCLUDE (A)             Send Q(G,A*B)

        '
      - "INCLUDE (A)    TO_EX (B)    EXCLUDE (A*B,B-A)       (B-A)=0\n                                                    Delete
        (A-B)\n                                                    Send Q(G,A*B)\n
        \                                                   Group Timer=GMI\n"
      - "INCLUDE (A)    TO_IN (B)    INCLUDE (A+B)           (B)=GMI\n                                                    Send
        Q(G,A-B)\n"
      - 'EXCLUDE (X,Y)  ALLOW (A)    EXCLUDE (X+A,Y-A)       (A)=GMI

        '
      - "EXCLUDE (X,Y)  BLOCK (A)    EXCLUDE (X+(A-Y),Y)     (A-X-Y)=Group Timer\n
        \                                                   Send Q(G,A-Y)\n"
      - "EXCLUDE (X,Y)  TO_EX (A)    EXCLUDE (A-Y,Y*A)       (A-X-Y)=Group Timer\n
        \                                                   Delete (X-A)\n                                                    Delete
        (Y-A)\n                                                    Send Q(G,A-Y)\n
        \                                                   Group Timer=GMI\n"
      - "EXCLUDE (X,Y)  TO_IN (A)    EXCLUDE (X+A,Y-A)       (A)=GMI\n                                                    Send
        Q(G,X-A)\n                                                    Send Q(G)\n"
      title: 6.4.2. Reception of Filter-Mode-Change and Source-List-Change Records
    title: 6.4. Action on Reception of Reports
  - contents:
    - "6.5. Switching Router Filter-Modes\n   The group timer is used as a mechanism
      for transitioning the router\n   filter-mode from EXCLUDE to INCLUDE.\n   When
      a group timer expires with a router filter-mode of EXCLUDE, a\n   router assumes
      that there are no systems with a *filter-mode* of\n   EXCLUDE present on the
      attached network.  When a router's filter-mode\n   for a group is EXCLUDE and
      the group timer expires, the router\n   filter-mode for the group transitions
      to INCLUDE.\n   A router uses source records with running source timers as its
      state\n   for the switch to a filter-mode of INCLUDE.  If there are any source\n
      \  records with source timers greater than zero (i.e., requested to be\n   forwarded),
      a router switches to filter-mode of INCLUDE using those\n   source records.
      \ Source records whose timers are zero (from the\n   previous EXCLUDE mode)
      are deleted.\n   For example, if a router's state for a group is EXCLUDE(X,Y)
      and the\n   group timer expires for that group, the router switches to filter-\n
      \  mode of INCLUDE with state INCLUDE(X).\n"
    title: 6.5. Switching Router Filter-Modes
  - contents:
    - '6.6. Action on Reception of Queries

      '
    - contents:
      - "6.6.1. Timer Updates\n   When a router sends or receives a query with a clear
        Suppress\n   Router-Side Processing flag, it must update its timers to reflect
        the\n   correct timeout values for the group or sources being queried.  The\n
        \  following table describes the timer actions when sending or receiving\n
        \  a Group-Specific or Group-and-Source Specific Query with the Suppress\n
        \  Router-Side Processing flag not set.\n      Query      Action\n      -----
        \     ------\n      Q(G,A)     Source Timer for sources in A are lowered to
        LMQT\n      Q(G)       Group Timer is lowered to LMQT\n   When a router sends
        or receives a query with the Suppress Router-Side\n   Processing flag set,
        it will not update its timers.\n"
      title: 6.6.1. Timer Updates
    - contents:
      - "6.6.2. Querier Election\n   IGMPv3 elects a single querier per subnet using
        the same querier\n   election mechanism as IGMPv2, namely by IP address.  When
        a router\n   receives a query with a lower IP address, it sets the Other-Querier-\n
        \  Present timer to Other Querier Present Interval and ceases to send\n   queries
        on the network if it was the previously elected querier.\n   After its Other-Querier
        Present timer expires, it should begin\n   sending General Queries.\n   If
        a router receives an older version query, it MUST use the oldest\n   version
        of IGMP on the network.  For a detailed description of\n   compatibility issues
        between IGMP versions see section 7.\n"
      title: 6.6.2. Querier Election
    - contents:
      - '6.6.3. Building and Sending Specific Queries

        '
      - contents:
        - "6.6.3.1. Building and Sending Group Specific Queries\n   When a table action
          \"Send Q(G)\" is encountered, then the group timer\n   must be lowered to
          LMQT.  The router must then immediately send a\n   group specific query
          as well as schedule [Last Member Query Count -\n   1] query retransmissions
          to be sent every [Last Member Query\n   Interval] over [Last Member Query
          Time].\n   When transmitting a group specific query, if the group timer
          is\n   larger than LMQT, the \"Suppress Router-Side Processing\" bit is
          set in\n   the query message.\n"
        title: 6.6.3.1. Building and Sending Group Specific Queries
      - contents:
        - "6.6.3.2. Building and Sending Group and Source Specific Queries\n   When
          a table action \"Send Q(G,X)\" is encountered by a querier in the\n   table
          in section 6.4.2, the following actions must be performed for\n   each of
          the sources in X of group G, with source timer larger than\n   LMQT:\n   o
          Set number of retransmissions for each source to [Last Member Query\n     Count].\n
          \  o Lower source timer to LMQT.\n   The router must then immediately send
          a group and source specific\n   query as well as schedule [Last Member Query
          Count - 1] query\n   retransmissions to be sent every [Last Member Query
          Interval] over\n   [Last Member Query Time].  The contents of these queries
          are\n   calculated as follows.\n   When building a group and source specific
          query for a group G, two\n   separate query messages are sent for the group.
          \ The first one has\n   the \"Suppress Router-Side Processing\" bit set
          and contains all the\n   sources with retransmission state and timers greater
          than LMQT.  The\n   second has the \"Suppress Router-Side Processing\" bit
          clear and\n   contains all the sources with retransmission state and timers
          lower\n   or equal to LMQT.  If either of the two calculated messages does
          not\n   contain any sources, then its transmission is suppressed.\n   Note:
          If a group specific query is scheduled to be transmitted at the\n   same
          time as a group and source specific query for the same group,\n   then transmission
          of the group and source specific message with the\n   \"Suppress Router-Side
          Processing\" bit set may be suppressed.\n"
        title: 6.6.3.2. Building and Sending Group and Source Specific Queries
      title: 6.6.3. Building and Sending Specific Queries
    title: 6.6. Action on Reception of Queries
  title: 6. Description of the Protocol for Multicast Routers
- contents:
  - "7. Interoperation With Older Versions of IGMP\n   IGMP version 3 hosts and routers
    interoperate with hosts and routers\n   that have not yet been upgraded to IGMPv3.
    \ This compatibility is\n   maintained by hosts and routers taking appropriate
    actions depending\n   on the versions of IGMP operating on hosts and routers within
    a\n   network.\n"
  - contents:
    - "7.1. Query Version Distinctions\n   The IGMP version of a Membership Query
      message is determined as\n   follows:\n      IGMPv1 Query: length = 8 octets
      AND Max Resp Code field is zero\n      IGMPv2 Query: length = 8 octets AND Max
      Resp Code field is\n                    non-zero\n      IGMPv3 Query: length
      >= 12 octets\n   Query messages that do not match any of the above conditions
      (e.g., a\n   Query of length 10 octets) MUST be silently ignored.\n"
    title: 7.1. Query Version Distinctions
  - contents:
    - '7.2. Group Member Behavior

      '
    - contents:
      - "7.2.1. In the Presence of Older Version Queriers\n   In order to be compatible
        with older version routers, IGMPv3 hosts\n   MUST operate in version 1 and
        version 2 compatibility modes.  IGMPv3\n   hosts MUST keep state per local
        interface regarding the compatibility\n   mode of each attached network.  A
        host's compatibility mode is\n   determined from the Host Compatibility Mode
        variable which can be in\n   one of three states:  IGMPv1, IGMPv2 or IGMPv3.
        \ This variable is\n   kept per interface and is dependent on the version
        of General Queries\n   heard on that interface as well as the Older Version
        Querier Present\n   timers for the interface.\n   In order to switch gracefully
        between versions of IGMP, hosts keep\n   both an IGMPv1 Querier Present timer
        and an IGMPv2 Querier Present\n   timer per interface.  IGMPv1 Querier Present
        is set to Older Version\n   Querier Present Timeout seconds whenever an IGMPv1
        Membership Query\n   is received.  IGMPv2 Querier Present is set to Older
        Version Querier\n   Present Timeout seconds whenever an IGMPv2 General Query
        is received.\n   The Host Compatibility Mode of an interface changes whenever
        an older\n   version query (than the current compatibility mode) is heard
        or when\n   certain timer conditions occur.  When the IGMPv1 Querier Present\n
        \  timer expires, a host switches to Host Compatibility mode of IGMPv2\n   if
        it has a running IGMPv2 Querier Present timer.  If it does not\n   have a
        running IGMPv2 Querier Present timer then it switches to Host\n   Compatibility
        of IGMPv3.  When the IGMPv2 Querier Present timer\n   expires, a host switches
        to Host Compatibility mode of IGMPv3.\n   The Host Compatibility Mode variable
        is based on whether an older\n   version General query was heard in the last
        Older Version Querier\n   Present Timeout seconds.  The Host Compatibility
        Mode is set\n   depending on the following:\n   Host Compatibility Mode       Timer
        State\n   -----------------------       -----------\n         IGMPv3 (default)
        \       IGMPv2 Querier Present not running\n                                 and
        IGMPv1 Querier Present not running\n         IGMPv2                  IGMPv2
        Querier Present running\n                                 and IGMPv1 Querier
        Present not running\n         IGMPv1                  IGMPv1 Querier Present
        running\n   If a host receives a query which causes its Querier Present timers
        to\n   be updated and correspondingly its compatibility mode, it should\n
        \  switch compatibility modes immediately.\n   When Host Compatibility Mode
        is IGMPv3, a host acts using the IGMPv3\n   protocol on that interface.  When
        Host Compatibility Mode is IGMPv2,\n   a host acts in IGMPv2 compatibility
        mode, using only the IGMPv2\n   protocol, on that interface.  When Host Compatibility
        Mode is IGMPv1,\n   a host acts in IGMPv1 compatibility mode, using only the
        IGMPv1\n   protocol on that interface.\n   An IGMPv1 router will send General
        Queries with the Max Resp Code set\n   to 0.  This MUST be interpreted as
        a value of 100 (10 seconds).\n   An IGMPv2 router will send General Queries
        with the Max Resp Code set\n   to the desired Max Resp Time, i.e., the full
        range of this field is\n   linear and the exponential algorithm described
        in section 4.1.1 is\n   not used.\n   Whenever a host changes its compatibility
        mode, it cancels all its\n   pending response and retransmission timers.\n"
      title: 7.2.1. In the Presence of Older Version Queriers
    - contents:
      - "7.2.2. In the Presence of Older Version Group Members\n   An IGMPv3 host
        may be placed on a network where there are hosts that\n   have not yet been
        upgraded to IGMPv3.  A host MAY allow its IGMPv3\n   Membership Record to
        be suppressed by either a Version 1 Membership\n   Report, or a Version 2
        Membership Report.\n"
      title: 7.2.2. In the Presence of Older Version Group Members
    title: 7.2. Group Member Behavior
  - contents:
    - '7.3. Multicast Router Behavior

      '
    - contents:
      - "7.3.1. In the Presence of Older Version Queriers\n   IGMPv3 routers may be
        placed on a network where at least one router\n   on the network has not yet
        been upgraded to IGMPv3.  The following\n   requirements apply:\n   o If any
        older versions of IGMP are present on routers, the querier\n     MUST use
        the lowest version of IGMP present on the network.  This\n     must be administratively
        assured; routers that desire to be\n     compatible with IGMPv1 and IGMPv2
        MUST have a configuration option\n     to act in IGMPv1 or IGMPv2 compatibility
        modes.  When in IGMPv1\n     mode, routers MUST send Periodic Queries with
        a Max Resp Code of 0\n     and truncated at the Group Address field (i.e.,
        8 bytes long), and\n     MUST ignore Leave Group messages.  They SHOULD also
        warn about\n     receiving an IGMPv2 or IGMPv3 query, although such warnings
        MUST be\n     rate-limited.  When in IGMPv2 mode, routers MUST send Periodic\n
        \    Queries truncated at the Group Address field (i.e., 8 bytes long),\n
        \    and SHOULD also warn about receiving an IGMPv3 query (such warnings\n
        \    MUST be rate-limited).  They also MUST fill in the Max Resp Time in\n
        \    the Max Resp Code field, i.e., the exponential algorithm described\n
        \    in section 4.1.1 is not used.\n   o If a router is not explicitly configured
        to use IGMPv1 or IGMPv2\n     and hears an IGMPv1 Query or IGMPv2 General
        Query, it SHOULD log a\n     warning.  These warnings MUST be rate-limited.\n"
      title: 7.3.1. In the Presence of Older Version Queriers
    - contents:
      - "7.3.2. In the Presence of Older Version Group Members\n   IGMPv3 routers
        may be placed on a network where there are hosts that\n   have not yet been
        upgraded to IGMPv3.  In order to be compatible with\n   older version hosts,
        IGMPv3 routers MUST operate in version 1 and\n   version 2 compatibility modes.
        \ IGMPv3 routers keep a compatibility\n   mode per group record.  A group's
        compatibility mode is determined\n   from the Group Compatibility Mode variable
        which can be in one of\n   three states:  IGMPv1, IGMPv2 or IGMPv3.  This
        variable is kept per\n   group record and is dependent on the version of Membership
        Reports\n   heard for that group as well as the Older Version Host Present
        timer\n   for the group.\n   In order to switch gracefully between versions
        of IGMP, routers keep\n   an IGMPv1 Host Present timer and an IGMPv2 Host
        Present timer per\n   group record.  The IGMPv1 Host Present timer is set
        to Older Version\n   Host Present Timeout seconds whenever an IGMPv1 Membership
        Report is\n   received.  The IGMPv2 Host Present timer is set to Older Version
        Host\n   Present Timeout seconds whenever an IGMPv2 Membership Report is\n
        \  received.\n   The Group Compatibility Mode of a group record changes whenever
        an\n   older version report (than the current compatibility mode) is heard\n
        \  or when certain timer conditions occur.  When the IGMPv1 Host Present\n
        \  timer expires, a router switches to Group Compatibility mode of\n   IGMPv2
        if it has a running IGMPv2 Host Present timer.  If it does not\n   have a
        running IGMPv2 Host Present timer then it switches to Group\n   Compatibility
        of IGMPv3.  When the IGMPv2 Host Present timer expires\n   and the IGMPv1
        Host Present timer is not running, a router switches\n   to Group Compatibility
        mode of IGMPv3.  Note that when a group\n   switches back to IGMPv3 mode,
        it takes some time to regain source-\n   specific state information.  Source-specific
        information will be\n   learned during the next General Query, but sources
        that should be\n   blocked will not be blocked until [Group Membership Interval]
        after\n   that.\n   The Group Compatibility Mode variable is based on whether
        an older\n   version report was heard in the last Older Version Host Present\n
        \  Timeout seconds.  The Group Compatibility Mode is set depending on\n   the
        following:\n   Group Compatibility Mode      Timer State\n   ------------------------
        \     -----------\n         IGMPv3 (default)        IGMPv2 Host Present not
        running\n                                 and IGMPv1 Host Present not running\n
        \        IGMPv2                  IGMPv2 Host Present running\n                                 and
        IGMPv1 Host Present not running\n         IGMPv1                  IGMPv1 Host
        Present running\n   If a router receives a report which causes its older Host
        Present\n   timers to be updated and correspondingly its compatibility mode,
        it\n   SHOULD switch compatibility modes immediately.\n   When Group Compatibility
        Mode is IGMPv3, a router acts using the\n   IGMPv3 protocol for that group.\n
        \  When Group Compatibility Mode is IGMPv2, a router internally\n   translates
        the following IGMPv2 messages for that group to their\n   IGMPv3 equivalents:\n
        \      IGMPv2 Message                IGMPv3 Equivalent\n       --------------
        \               -----------------\n         Report                        IS_EX(
        {} )\n         Leave                         TO_IN( {} )\n   IGMPv3 BLOCK
        messages are ignored, as are source-lists in TO_EX()\n   messages (i.e., any
        TO_EX() message is treated as TO_EX( {} )).\n   When Group Compatibility Mode
        is IGMPv1, a router internally\n   translates the following IGMPv1 and IGMPv2
        messages for that group to\n   their IGMPv3 equivalents:\n       IGMP Message
        \                 IGMPv3 Equivalent\n       ------------                  -----------------\n
        \        v1 Report                      IS_EX( {} )\n         v2 Report                      IS_EX(
        {} )\n   In addition to ignoring IGMPv3 BLOCK messages and source-lists in\n
        \  TO_EX() messages as in IGMPv2 Group Compatibility Mode, IGMPv2 Leave\n
        \  messages and IGMPv3 TO_IN() messages are also ignored.\n"
      title: 7.3.2. In the Presence of Older Version Group Members
    title: 7.3. Multicast Router Behavior
  title: 7. Interoperation With Older Versions of IGMP
- contents:
  - "8. List of Timers, Counters and Their Default Values\n   Most of these timers
    are configurable.  If non-default settings are\n   used, they MUST be consistent
    among all systems on a single link.\n   Note that parentheses are used to group
    expressions to make the\n   algebra clear.\n"
  - contents:
    - "8.1. Robustness Variable\n   The Robustness Variable allows tuning for the
      expected packet loss on\n   a network.  If a network is expected to be lossy,
      the Robustness\n   Variable may be increased.  IGMP is robust to (Robustness
      Variable -\n   1) packet losses.  The Robustness Variable MUST NOT be zero,
      and\n   SHOULD NOT be one.  Default: 2\n"
    title: 8.1. Robustness Variable
  - contents:
    - "8.2. Query Interval\n   The Query Interval is the interval between General
      Queries sent by\n   the Querier.  Default: 125 seconds.\n   By varying the [Query
      Interval], an administrator may tune the number\n   of IGMP messages on the
      network; larger values cause IGMP Queries to\n   be sent less often.\n"
    title: 8.2. Query Interval
  - contents:
    - "8.3. Query Response Interval\n   The Max Response Time used to calculate the
      Max Resp Code inserted\n   into the periodic General Queries.  Default: 100
      (10 seconds)\n   By varying the [Query Response Interval], an administrator
      may tune\n   the burstiness of IGMP messages on the network; larger values make\n
      \  the traffic less bursty, as host responses are spread out over a\n   larger
      interval.  The number of seconds represented by the [Query\n   Response Interval]
      must be less than the [Query Interval].\n"
    title: 8.3. Query Response Interval
  - contents:
    - "8.4. Group Membership Interval\n   The Group Membership Interval is the amount
      of time that must pass\n   before a multicast router decides there are no more
      members of a\n   group or a particular source on a network.\n   This value MUST
      be ((the Robustness Variable) times (the Query\n   Interval)) plus (one Query
      Response Interval).\n"
    title: 8.4. Group Membership Interval
  - contents:
    - "8.5. Other Querier Present Interval\n   The Other Querier Present Interval
      is the length of time that must\n   pass before a multicast router decides that
      there is no longer\n   another multicast router which should be the querier.
      \ This value\n   MUST be ((the Robustness Variable) times (the Query Interval))
      plus\n   (one half of one Query Response Interval).\n"
    title: 8.5. Other Querier Present Interval
  - contents:
    - "8.6. Startup Query Interval\n   The Startup Query Interval is the interval
      between General Queries\n   sent by a Querier on startup.  Default: 1/4 the
      Query Interval.\n"
    title: 8.6. Startup Query Interval
  - contents:
    - "8.7. Startup Query Count\n   The Startup Query Count is the number of Queries
      sent out on startup,\n   separated by the Startup Query Interval.  Default:
      the Robustness\n   Variable.\n"
    title: 8.7. Startup Query Count
  - contents:
    - "8.8. Last Member Query Interval\n   The Last Member Query Interval is the Max
      Response Time used to\n   calculate the Max Resp Code inserted into Group-Specific
      Queries sent\n   in response to Leave Group messages.  It is also the Max Response\n
      \  Time used in calculating the Max Resp Code for Group-and-Source-\n   Specific
      Query messages.  Default: 10 (1 second)\n   Note that for values of LMQI greater
      than 12.8 seconds, a limited set\n   of values can be represented, corresponding
      to sequential values of\n   Max Resp Code.  When converting a configured time
      to a Max Resp Code\n   value, it is recommended to use the exact value if possible,
      or the\n   next lower value if the requested value is not exactly representable.\n
      \  This value may be tuned to modify the \"leave latency\" of the network.\n
      \  A reduced value results in reduced time to detect the loss of the\n   last
      member of a group or source.\n"
    title: 8.8. Last Member Query Interval
  - contents:
    - "8.9. Last Member Query Count\n   The Last Member Query Count is the number
      of Group-Specific Queries\n   sent before the router assumes there are no local
      members.  The Last\n   Member Query Count is also the number of Group-and-Source-Specific\n
      \  Queries sent before the router assumes there are no listeners for a\n   particular
      source.  Default: the Robustness Variable.\n"
    title: 8.9. Last Member Query Count
  - contents:
    - "8.10. Last Member Query Time\n   The Last Member Query Time is the time value
      represented by the Last\n   Member Query Interval, multiplied by the Last Member
      Query Count.  It\n   is not a tunable value, but may be tuned by changing its
      components.\n"
    title: 8.10. Last Member Query Time
  - contents:
    - "8.11. Unsolicited Report Interval\n   The Unsolicited Report Interval is the
      time between repetitions of a\n   host's initial report of membership in a group.
      \ Default: 1 second.\n"
    title: 8.11. Unsolicited Report Interval
  - contents:
    - "8.12. Older Version Querier Present Timeout\n   The Older Version Querier Interval
      is the time-out for transitioning\n   a host back to IGMPv3 mode once an older
      version query is heard.\n   When an older version query is received, hosts set
      their Older\n   Version Querier Present Timer to Older Version Querier Interval.\n
      \  This value MUST be ((the Robustness Variable) times (the Query\n   Interval
      in the last Query received)) plus (one Query Response\n   Interval).\n"
    title: 8.12. Older Version Querier Present Timeout
  - contents:
    - "8.13. Older Host Present Interval\n   The Older Host Present Interval is the
      time-out for transitioning a\n   group back to IGMPv3 mode once an older version
      report is sent for\n   that group.  When an older version report is received,
      routers set\n   their Older Host Present Timer to Older Host Present Interval.\n
      \  This value MUST be ((the Robustness Variable) times (the Query\n   Interval))
      plus (one Query Response Interval).\n"
    title: 8.13. Older Host Present Interval
  - contents:
    - "8.14. Configuring Timers\n   This section is meant to provide advice to network
      administrators on\n   how to tune these settings to their network.  Ambitious
      router\n   implementations might tune these settings dynamically based upon\n
      \  changing characteristics of the network.\n"
    - contents:
      - "8.14.1. Robustness Variable\n   The Robustness Variable tunes IGMP to expected
        losses on a link.\n   IGMPv3 is robust to (Robustness Variable - 1) packet
        losses, e.g., if\n   the Robustness Variable is set to the default value of
        2, IGMPv3 is\n   robust to a single packet loss but may operate imperfectly
        if more\n   losses occur.  On lossy subnetworks, the Robustness Variable should\n
        \  be increased to allow for the expected level of packet loss. However,\n
        \  increasing the Robustness Variable increases the leave latency of the\n
        \  subnetwork.  (The leave latency is the time between when the last\n   member
        stops listening to a source or group and when the traffic\n   stops flowing.)\n"
      title: 8.14.1. Robustness Variable
    - contents:
      - "8.14.2. Query Interval\n   The overall level of periodic IGMP traffic is
        inversely proportional\n   to the Query Interval.  A longer Query Interval
        results in a lower\n   overall level of IGMP traffic.  The Query Interval
        MUST be equal to\n   or longer than the Max Response Time inserted in General
        Query\n   messages.\n"
      title: 8.14.2. Query Interval
    - contents:
      - "8.14.3. Max Response Time\n   The burstiness of IGMP traffic is inversely
        proportional to the Max\n   Response Time.  A longer Max Response Time will
        spread Report\n   messages over a longer interval.  However, a longer Max
        Response Time\n   in Group-Specific and Source-and-Group-Specific Queries
        extends the\n   leave latency.  (The leave latency is the time between when
        the last\n   member stops listening to a source or group and when the traffic\n
        \  stops flowing.)  The expected rate of Report messages can be\n   calculated
        by dividing the expected number of Reporters by the Max\n   Response Time.
        \ The Max Response Time may be dynamically calculated\n   per Query by using
        the expected number of Reporters for that Query as\n   follows:\n      Query
        Type            Expected number of Reporters\n      ----------            ----------------------------\n
        \     General Query         All systems on subnetwork\n      Group-Specific
        Query  All systems that had expressed interest\n                            in
        the group on the subnetwork\n      Source-and-Group-     All systems on the
        subnetwork that had\n      Specific Query        expressed interest in the
        source and group\n   A router is not required to calculate these populations
        or tune the\n   Max Response Time dynamically; these are simply guidelines.\n"
      title: 8.14.3. Max Response Time
    title: 8.14. Configuring Timers
  title: 8. List of Timers, Counters and Their Default Values
- contents:
  - "9. Security Considerations\n   We consider the ramifications of a forged message
    of each type, and\n   describe the usage of IPSEC AH to authenticate messages
    if desired.\n"
  - contents:
    - "9.1. Query Message\n   A forged Query message from a machine with a lower IP
      address than\n   the current Querier will cause Querier duties to be assigned
      to the\n   forger.  If the forger then sends no more Query messages, other\n
      \  routers' Other Querier Present timer will time out and one will\n   resume
      the role of Querier.  During this time, if the forger ignores\n   Leave Messages,
      traffic might flow to groups with no members for up\n   to [Group Membership
      Interval].\n   A DoS attack on a host could be staged through forged Group-and-\n
      \  Source-Specific Queries.  The attacker can find out about membership\n   of
      a specific host with a general query.  After that it could send a\n   large
      number of Group-and-Source-Specific queries, each with a large\n   source list
      and the Maximum Response Time set to a large value.  The\n   host will have
      to store and maintain the sources specified in all of\n   those queries for
      as long as it takes to send the delayed response.\n   This would consume both
      memory and CPU cycles in order to augment the\n   recorded sources with the
      source lists included in the successive\n   queries.\n   To protect against
      such a DoS attack, a host stack implementation\n   could restrict the number
      of Group-and-Source-Specific Queries per\n   group membership within this interval,
      and/or record only a limited\n   number of sources.\n   Forged Query messages
      from the local network can be easily traced.\n   There are three measures necessary
      to defend against externally\n   forged Queries:\n   o Routers SHOULD NOT forward
      Queries.  This is easier for a router to\n     accomplish if the Query carries
      the Router-Alert option.\n   o Hosts SHOULD ignore v2 or v3 Queries without
      the Router-Alert\n     option.\n   o Hosts SHOULD ignore v1, v2 or v3 General
      Queries sent to a\n     multicast address other than 224.0.0.1, the all-systems
      address.\n"
    title: 9.1. Query Message
  - contents:
    - "9.2. Current-State Report messages\n   A forged Report message may cause multicast
      routers to think there\n   are members of a group on a network when there are
      not.  Forged\n   Report messages from the local network are meaningless, since
      joining\n   a group on a host is generally an unprivileged operation, so a local\n
      \  user may trivially gain the same result without forging any messages.\n   Forged
      Report messages from external sources are more troublesome;\n   there are two
      defenses against externally forged Reports:\n   o Ignore the Report if you cannot
      identify the source address of the\n     packet as belonging to a network assigned
      to the interface on which\n     the packet was received.  This solution means
      that Reports sent by\n     mobile hosts without addresses on the local network
      will be\n     ignored.  Report messages with a source address of 0.0.0.0 SHOULD\n
      \    be accepted on any interface.\n   o Ignore Report messages without Router
      Alert options [RFC-2113], and\n     require that routers not forward Report
      messages.  (The requirement\n     is not a requirement of generalized filtering
      in the forwarding\n     path, since the packets already have Router Alert options
      in them.)\n     This solution breaks backwards compatibility with implementations\n
      \    of IGMPv1 or earlier versions of IGMPv2 which did not require\n     Router
      Alert.\n   A forged Version 1 Report Message may put a router into \"version
      1\n   members present\" state for a particular group, meaning that the\n   router
      will ignore Leave messages.  This can cause traffic to flow to\n   groups with
      no members for up to [Group Membership Interval].  This\n   can be solved by
      providing routers with a configuration switch to\n   ignore Version 1 messages
      completely.  This breaks automatic\n   compatibility with Version 1 hosts, so
      should only be used in\n   situations where \"fast leave\" is critical.\n   A
      forged Version 2 Report Message may put a router into \"version 2\n   members
      present\" state for a particular group, meaning that the\n   router will ignore
      IGMPv3 source-specific state messages.  This can\n   cause traffic to flow from
      unwanted sources for up to [Group\n   Membership Interval].  This can be solved
      by providing routers with a\n   configuration switch to ignore Version 2 messages
      completely.  This\n   breaks automatic compatibility with Version 2 hosts, so
      should only\n   be used in situations where source include and exclude is critical.\n"
    title: 9.2. Current-State Report messages
  - contents:
    - "9.3. State-Change Report Messages\n   A forged State-Change Report message
      will cause the Querier to send\n   out Group-Specific or Source-and-Group-Specific
      Queries for the group\n   in question.  This causes extra processing on each
      router and on each\n   member of the group, but can not cause loss of desired
      traffic.\n   There are two defenses against externally forged State-Change Report\n
      \  messages:\n   o Ignore the State-Change Report message if you cannot identify
      the\n     source address of the packet as belonging to a subnet assigned to\n
      \    the interface on which the packet was received.  This solution\n     means
      that State-Change Report messages sent by mobile hosts\n     without addresses
      on the local subnet will be ignored.  State-\n     Change Report messages with
      a source address of 0.0.0.0 SHOULD be\n     accepted on any interface.\n   o
      Ignore State-Change Report messages without Router Alert options\n     [RFC-2113],
      and require that routers not forward State-Change\n     Report messages.  (The
      requirement is not a requirement of\n     generalized filtering in the forwarding
      path, since the packets\n     already have Router Alert options in them.)\n"
    title: 9.3. State-Change Report Messages
  - contents:
    - "9.4. IPSEC Usage\n   In addition to these measures, IPSEC in Authentication
      Header mode\n   [AH] may be used to protect against remote attacks by ensuring
      that\n   IGMPv3 messages came from a system on the LAN (or, more specifically,\n
      \  a system with the proper key).  When using IPSEC, the messages sent\n   to
      224.0.0.1 and 224.0.0.22 should be authenticated using AH.  When\n   keying,
      there are two possibilities:\n   1. Use a symmetric signature algorithm with
      a single key for the LAN\n      (or a key for each group).  This allows validation
      that a packet\n      was sent by a system with the key.  This has the limitation
      that\n      any system with the key can forge a message; it is not possible
      to\n      authenticate the individual sender precisely.  It also requires\n
      \     disabling IPSec's Replay Protection.\n   2. When appropriate key management
      standards have been developed, use\n      an asymmetric signature algorithm.
      \ All systems need to know the\n      public key of all routers, and all routers
      need to know the public\n      key of all systems.  This requires a large amount
      of key\n      management but has the advantage that senders can be authenticated\n
      \     individually so e.g., a host cannot forge a message that only\n      routers
      should be allowed to send.\n   This solution only directly applies to Query
      and Leave messages in\n   IGMPv1 and IGMPv2, since Reports are sent to the group
      being reported\n   and it is not feasible to agree on a key for host-to-router\n
      \  communication for arbitrary multicast groups.\n"
    title: 9.4. IPSEC Usage
  title: 9. Security Considerations
- contents:
  - "10. IANA Considerations\n   All IGMP types described in this document are already
    assigned in\n   [IANA-REG].\n"
  title: 10. IANA Considerations
- contents:
  - "11. Acknowledgments\n   We would like to thank Ran Atkinson, Luis Costa, Toerless
    Eckert,\n   Dino Farinacci, Serge Fdida, Wilbert de Graaf, Sumit Gupta, Mark\n
    \  Handley, Bob Quinn, Michael Speer, Dave Thaler and Rolland Vida for\n   comments
    and suggestions on this document.\n   Portions of the text of this document were
    copied from [RFC-1112] and\n   [RFC-2236].\n"
  title: 11. Acknowledgments
- contents:
  - "12. Normative References\n   [AH]         Kent, S. and R. Atkinson, \"IP Authentication
    Header\",\n                RFC 2402, November 1998.\n   [IANA-REG]   http://www.iana.org/assignments/igmp-type-numbers\n
    \  [RFC-1112]   Deering, S., \"Host Extensions for IP Multicasting\", STD\n                5,
    RFC 1112, August 1989.\n   [RFC-2113]   Katz, D., \"IP Router Alert Option,\"
    RFC 2113, February,\n                1997.\n   [RFC-2119]   Bradner, S., \"Key
    words for use in RFCs to Indicate\n                Requirement Levels\", BCP 14,
    RFC 2119, March 1997.\n   [RFC-2236]   Fenner, W., \"Internet Group Management
    Protocol, Version\n                2\", RFC 2236, November 1997.\n   [RFC-3228]
    \  Fenner, B., \"IANA Considerations for IPv4 Internet Group\n                Management
    Protocol (IGMP)\", BCP 57, RFC 3228, February\n                2002.\n"
  title: 12. Normative References
- contents:
  - "13. Informative References\n   [RFC-1071]   Braden, R., Borman, D. and C.  Partridge,
    \"Computing the\n                Internet checksum\", RFC 1071, September 1988.\n
    \  [FILTER-API] Thaler, D., B. Fenner, and B. Quinn, \"Socket Interface\n                Extensions
    for Multicast Source Filters\", Work in\n                Progress.\n   [SSM]        Bhattacharyya,
    S., et. al., \"An Overview of Source-\n                Specific Multicast (SSM)\",
    Work in Progress.\n   [MLD]        Deering, S., Fenner, W. and B. Haberman, \"Multicast\n
    \               Listener Discovery (MLD) for IPv6\", RFC 2710, October\n                1999.\n
    \  [MLDV2]      Vida, R., L. Costa, S. Fdida, S. Deering, B. Fenner, I.\n                Kouvelas,
    and B. Haberman, \"Multicast Listener Discovery\n                Version 2 (MLDv2)
    for IPv6\", Work in Progress.\n"
  title: 13. Informative References
- contents:
  - 'Appendix A.  Design Rationale

    '
  - contents:
    - "A.1  The Need for State-Change Messages\n   IGMPv3 specifies two types of Membership
      Reports: Current-State and\n   State Change.  This section describes the rationale
      for the need for\n   both these types of Reports.\n   Routers need to distinguish
      Membership Reports that were sent in\n   response to Queries from those that
      were sent as a result of a change\n   in interface state.  Membership reports
      that are sent in response to\n   Membership Queries are used mainly to refresh
      the existing state at\n   the router; they typically do not cause transitions
      in state at the\n   router.  Membership Reports that are sent in response to
      changes in\n   interface state require the router to take some action in response
      to\n   the received report (see Section 6.4).\n   The inability to distinguish
      between the two types of reports would\n   force a router to treat all Membership
      Reports as potential changes\n   in state and could result in increased processing
      at the router as\n   well as an increase in IGMP traffic on the network.\n"
    title: A.1  The Need for State-Change Messages
  - contents:
    - "A.2  Host Suppression\n   In IGMPv1 and IGMPv2, a host would cancel sending
      a pending\n   membership reports if a similar report was observed from another\n
      \  member on the network.  In IGMPv3, this suppression of host\n   membership
      reports has been removed.  The following points explain\n   the reasons behind
      this decision.\n   1. Routers may want to track per-host membership status on
      an\n      interface.  This allows routers to implement fast leaves (e.g.,\n
      \     for layered multicast congestion control schemes) as well as track\n      membership
      status for possible accounting purposes.\n   2. Membership Report suppression
      does not work well on bridged LANs.\n      Many bridges and Layer2/Layer3 switches
      that implement IGMP\n      snooping do not forward IGMP messages across LAN
      segments in order\n      to prevent membership report suppression.  Removing
      membership\n      report suppression eases the job of these IGMP snooping devices.\n
      \  3. By eliminating membership report suppression, hosts have fewer\n      messages
      to process; this leads to a simpler state machine\n      implementation.\n   4.
      In IGMPv3, a single membership report now bundles multiple\n      multicast
      group records to decrease the number of packets sent.\n      In comparison,
      the previous versions of IGMP required that each\n      multicast group be reported
      in a separate message.\n"
    title: A.2  Host Suppression
  - contents:
    - "A.3 Switching Router Filter Modes from EXCLUDE to INCLUDE\n   If there exist
      hosts in both EXCLUDE and INCLUDE modes for a single\n   multicast group in
      a network, the router must be in EXCLUDE mode as\n   well (see section 6.2.1).
      \ In EXCLUDE mode, a router forwards traffic\n   from all sources unless that
      source exists in the exclusion source\n   list.  If all hosts in EXCLUDE mode
      cease to exist, it would be\n   desirable for the router to switch back to INCLUDE
      mode seamlessly\n   without interrupting the flow of traffic to existing receivers.\n
      \  One of the ways to accomplish this is for routers to keep track of\n   all
      sources desired by hosts that are in INCLUDE mode even though the\n   router
      itself is in EXCLUDE mode.  If the group timer now expires in\n   EXCLUDE mode,
      it implies that there are no hosts in EXCLUDE mode on\n   the network (otherwise
      a membership report from that host would have\n   refreshed the group timer).
      \ The router can then switch to INCLUDE\n   mode seamlessly with the list of
      sources currently being forwarded in\n   its source list.\n"
    title: A.3 Switching Router Filter Modes from EXCLUDE to INCLUDE
  title: Appendix A.  Design Rationale
- contents:
  - "Appendix B.  Summary of Changes from IGMPv2\n   While the main additional feature
    of IGMPv3 is the addition of source\n   filtering, the following is a summary
    of other changes from RFC 2236.\n   o State is maintained as Group + List-of-Sources,
    not simply Group as\n     in IGMPv2.\n   o Interoperability with IGMPv1 and IGMPv2
    systems is defined as\n     operations on the IGMPv3 state.\n   o The IP Service
    Interface has changed to allow specification of\n     source-lists.\n   o The
    Querier includes its Robustness Variable and Query Interval in\n     Query packets
    to allow synchronization of these variables on non-\n     Queriers.\n   o The
    Max Response Time in Query messages has an exponential range,\n     changing the
    maximum from 25.5 seconds to about 53 minutes, for use\n     on links with huge
    numbers of systems.\n   o Hosts retransmit state-change messages for increased
    robustness.\n   o Additional data sections are defined to allow later extensions.\n
    \  o Report packets are sent to 224.0.0.22, to assist layer-2 switches\n     in
    \"snooping\".\n   o Report packets can contain multiple group records, to allow\n
    \    reporting of full current state using fewer packets.\n   o Hosts no longer
    perform suppression, to simplify implementations\n     and permit explicit membership
    tracking.\n   o New Suppress Router-Side Processing (S) flag in Query messages\n
    \    fixes robustness issues which were also present in IGMPv2.\n"
  title: Appendix B.  Summary of Changes from IGMPv2
- contents:
  - "Authors' Addresses\n   Brad Cain\n   Cereva Networks\n   Steve Deering\n   Cisco
    Systems, Inc.\n   170 Tasman Drive\n   San Jose, CA 95134-1706\n   Phone: +1-408-527-8213\n
    \  EMail: deering@cisco.com\n   Bill Fenner\n   AT&T Labs - Research\n   75 Willow
    Rd.\n   Menlo Park, CA 94025\n   Phone: +1-650-330-7893\n   EMail: fenner@research.att.com\n
    \  Isidor Kouvelas\n   Cisco Systems, Inc.\n   170 Tasman Drive\n   San Jose,
    CA 95134-1706\n   Phone: +1-408-525-0727\n   EMail: kouvelas@cisco.com\n   Ajit
    Thyagarajan\n   Ericsson IP Infrastructure\n"
  title: Authors' Addresses
- contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2002).  All
    Rights Reserved.\n   This document and translations of it may be copied and furnished
    to\n   others, and derivative works that comment on or otherwise explain it\n
    \  or assist in its implementation may be prepared, copied, published\n   and
    distributed, in whole or in part, without restriction of any\n   kind, provided
    that the above copyright notice and this paragraph are\n   included on all such
    copies and derivative works.  However, this\n   document itself may not be modified
    in any way, such as by removing\n   the copyright notice or references to the
    Internet Society or other\n   Internet organizations, except as needed for the
    purpose of\n   developing Internet standards in which case the procedures for\n
    \  copyrights defined in the Internet Standards process must be\n   followed,
    or as required to translate it into languages other than\n   English.\n   The
    limited permissions granted above are perpetual and will not be\n   revoked by
    the Internet Society or its successors or assigns.\n   This document and the information
    contained herein is provided on an\n   \"AS IS\" basis and THE INTERNET SOCIETY
    AND THE INTERNET ENGINEERING\n   TASK FORCE DISCLAIMS ALL WARRANTIES, EXPRESS
    OR IMPLIED, INCLUDING\n   BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF THE
    INFORMATION\n   HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED WARRANTIES
    OF\n   MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.\n"
  title: Full Copyright Statement
- contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided
    by the\n   Internet Society.\n"
  title: Acknowledgement
