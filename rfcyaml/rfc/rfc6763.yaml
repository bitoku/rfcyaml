- contents:
  - '                      DNS-Based Service Discovery

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document specifies how DNS resource records are named and\n
    \  structured to facilitate service discovery.  Given a type of service\n   that
    a client is looking for, and a domain in which the client is\n   looking for that
    service, this mechanism allows clients to discover\n   a list of named instances
    of that desired service, using standard\n   DNS queries.  This mechanism is referred
    to as DNS-based Service\n   Discovery, or DNS-SD.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6763.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2013 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \  2. Conventions and Terminology Used in This Document ...............5\n   3.
    Design Goals ....................................................5\n   4. Service
    Instance Enumeration (Browsing) .........................6\n      4.1. Structured
    Service Instance Names ..........................6\n      4.2. User Interface
    Presentation ................................9\n      4.3. Internal Handling of
    Names .................................9\n   5. Service Instance Resolution ....................................10\n
    \  6. Data Syntax for DNS-SD TXT Records .............................11\n      6.1.
    General Format Rules for DNS TXT Records ..................11\n      6.2. DNS-SD
    TXT Record Size ....................................12\n      6.3. DNS TXT Record
    Format Rules for Use in DNS-SD .............13\n      6.4. Rules for Keys in DNS-SD
    Key/Value Pairs ..................14\n      6.5. Rules for Values in DNS-SD Key/Value
    Pairs ................16\n      6.6. Example TXT Record ........................................17\n
    \     6.7. Version Tag ...............................................17\n      6.8.
    Service Instances with Multiple TXT Records ...............18\n   7. Service Names
    ..................................................19\n      7.1. Selective Instance
    Enumeration (Subtypes) .................21\n      7.2. Service Name Length Limits
    ................................23\n   8. Flagship Naming ................................................25\n
    \  9. Service Type Enumeration .......................................27\n   10.
    Populating the DNS with Information ...........................27\n   11. Discovery
    of Browsing and Registration Domains (Domain\n       Enumeration) ..................................................28\n
    \  12. DNS Additional Record Generation ..............................30\n      12.1.
    PTR Records ..............................................30\n      12.2. SRV
    Records ..............................................30\n      12.3. TXT Records
    ..............................................31\n      12.4. Other Record Types
    .......................................31\n   13. Working Examples ..............................................31\n
    \     13.1. What web pages are being advertised from dns-sd.org? .....31\n      13.2.
    What printer-configuration web pages are there? ..........31\n      13.3. How
    do I access the web page called \"Service\n            Discovery\"? ..............................................32\n
    \  14. IPv6 Considerations ...........................................32\n   15.
    Security Considerations .......................................32\n   16. IANA
    Considerations ...........................................32\n   17. Acknowledgments
    ...............................................33\n   18. References ....................................................33\n
    \     18.1. Normative References .....................................33\n      18.2.
    Informative References ...................................34\n   Appendix A. Rationale
    for Using DNS as a Basis for Service\n               Discovery .............................................37\n
    \  Appendix B. Ordering of Service Instance Name Components ..........38\n      B.1.
    Semantic Structure ........................................38\n      B.2. Network
    Efficiency ........................................39\n      B.3. Operational
    Flexibility ...................................39\n   Appendix C. What You See
    Is What You Get ..........................40\n   Appendix D. Choice of Factory-Default
    Names .......................42\n   Appendix E. Name Encodings in the Domain Name
    System ..............44\n   Appendix F. \"Continuous Live Update\" Browsing Model
    ...............45\n   Appendix G. Deployment History ....................................47\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This document specifies how DNS resource records are named
    and\n   structured to facilitate service discovery.  Given a type of service\n
    \  that a client is looking for, and a domain in which the client is\n   looking
    for that service, this mechanism allows clients to discover a\n   list of named
    instances of that desired service, using standard DNS\n   queries.  This mechanism
    is referred to as DNS-based Service\n   Discovery, or DNS-SD.\n   This document
    proposes no change to the structure of DNS messages,\n   and no new operation
    codes, response codes, resource record types, or\n   any other new DNS protocol
    values.\n   This document specifies that a particular service instance can be\n
    \  described using a DNS SRV [RFC2782] and DNS TXT [RFC1035] record.\n   The SRV
    record has a name of the form \"<Instance>.<Service>.<Domain>\"\n   and gives
    the target host and port where the service instance can be\n   reached.  The DNS
    TXT record of the same name gives additional\n   information about this instance,
    in a structured form using key/value\n   pairs, described in Section 6.  A client
    discovers the list of\n   available instances of a given service type using a
    query for a DNS\n   PTR [RFC1035] record with a name of the form \"<Service>.<Domain>\",\n
    \  which returns a set of zero or more names, which are the names of the\n   aforementioned
    DNS SRV/TXT record pairs.\n   This specification is compatible with both Multicast
    DNS [RFC6762]\n   and with today's existing Unicast DNS server and client software.\n
    \  When used with Multicast DNS, DNS-SD can provide zero-configuration\n   operation
    -- just connect a DNS-SD/mDNS device, and its services are\n   advertised on the
    local link with no further user interaction [ZC].\n   When used with conventional
    Unicast DNS, some configuration will\n   usually be required -- such as configuring
    the device with the DNS\n   domain(s) in which it should advertise its services,
    and configuring\n   it with the DNS Update [RFC2136] [RFC3007] keys to give it
    permission\n   to do so.  In rare cases, such as a secure corporate network behind
    a\n   firewall where no DNS Update keys are required, zero-configuration\n   operation
    may be achieved by simply having the device register its\n   services in a default
    registration domain learned from the network\n   (see Section 11, \"Discovery
    of Browsing and Registration Domains\"),\n   but this is the exception and usually
    security credentials will be\n   required to perform DNS updates.\n   Note that
    when using DNS-SD with Unicast DNS, the Unicast DNS-SD\n   service does NOT have
    to be provided by the same DNS server hardware\n   that is currently providing
    an organization's conventional host name\n   lookup service.  While many people
    think of \"DNS\" exclusively in the\n   context of mapping host names to IP addresses,
    in fact, \"the DNS is a\n   general (if somewhat limited) hierarchical database,
    and can store\n   almost any kind of data, for almost any purpose\" [RFC2181].
    \ By\n   delegating the \"_tcp\" and \"_udp\" subdomains, all the workload related\n
    \  to DNS-SD can be offloaded to a different machine.  This flexibility,\n   to
    handle DNS-SD on the main DNS server or not, at the network\n   administrator's
    discretion, is one of the benefits of using DNS.\n   Even when the DNS-SD functions
    are delegated to a different machine,\n   the benefits of using DNS remain: it
    is mature technology, well\n   understood, with multiple independent implementations
    from different\n   vendors, a wide selection of books published on the subject,
    and an\n   established workforce experienced in its operation.  In contrast,\n
    \  adopting some other service discovery technology would require every\n   site
    in the world to install, learn, configure, operate, and maintain\n   some entirely
    new and unfamiliar server software.  Faced with these\n   obstacles, it seems
    unlikely that any other service discovery\n   technology could hope to compete
    with the ubiquitous deployment that\n   DNS already enjoys.  For further discussion,
    see Appendix A,\n   \"Rationale for Using DNS as a Basis for Service Discovery\".\n
    \  This document is written for two audiences: for developers creating\n   application
    software that offers or accesses services on the network,\n   and for developers
    creating DNS-SD libraries to implement the\n   advertising and discovery mechanisms.
    \ For both audiences,\n   understanding the entire document is helpful.  For developers\n
    \  creating application software, this document provides guidance on\n   choosing
    instance names, service names, and other aspects that play a\n   role in creating
    a good overall user experience.  However, also\n   understanding the underlying
    DNS mechanisms used to provide the\n   service discovery facilities helps application
    developers understand\n   the capabilities and limitations of those underlying
    mechanisms\n   (e.g., name length limits).  For library developers writing software\n
    \  to construct the DNS records (to advertise a service) and generate\n   the
    DNS queries (to discover and use a service), understanding the\n   ultimate user-experience
    goals helps them provide APIs that can meet\n   those goals.\n"
  title: 1.  Introduction
- contents:
  - "2.  Conventions and Terminology Used in This Document\n   The key words \"MUST\",
    \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD
    NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to
    be interpreted as described in \"Key words for use in\n   RFCs to Indicate Requirement
    Levels\" [RFC2119].\n"
  title: 2.  Conventions and Terminology Used in This Document
- contents:
  - "3.  Design Goals\n   Of the many properties a good service discovery protocol
    needs to\n   have, three of particular importance are:\n      (i) The ability
    to query for services of a certain type in a\n      certain logical domain, and
    receive in response a list of named\n      instances (network browsing or \"Service
    Instance Enumeration\").\n      (ii) Given a particular named instance, the ability
    to efficiently\n      resolve that instance name to the required information a
    client\n      needs to actually use the service, i.e., IP address and port\n      number,
    at the very least (Service Instance Resolution).\n      (iii) Instance names should
    be relatively persistent.  If a user\n      selects their default printer from
    a list of available choices\n      today, then tomorrow they should still be able
    to print on that\n      printer -- even if the IP address and/or port number where
    the\n      service resides have changed -- without the user (or their\n      software)
    having to repeat the step (i) (the initial network\n      browsing) a second time.\n
    \  In addition, if it is to become successful, a service discovery\n   protocol
    should be so simple to implement that virtually any device\n   capable of implementing
    IP should not have any trouble implementing\n   the service discovery software
    as well.\n   These goals are discussed in more detail in the remainder of this\n
    \  document.  A more thorough treatment of service discovery\n   requirements
    may be found in \"Requirements for a Protocol to Replace\n   the AppleTalk Name
    Binding Protocol (NBP)\" [RFC6760].  That document\n   draws upon examples from
    two decades of operational experience with\n   AppleTalk to develop a list of
    universal requirements that are\n   broadly applicable to any potential service
    discovery protocol.\n"
  title: 3.  Design Goals
- contents:
  - "4.  Service Instance Enumeration (Browsing)\n   Traditional DNS SRV records [RFC2782]
    are useful for locating\n   instances of a particular type of service when all
    the instances are\n   effectively indistinguishable and provide the same service
    to the\n   client.\n   For example, SRV records with the (hypothetical) name\n
    \  \"_http._tcp.example.com.\" would allow a client to discover servers\n   implementing
    the \"_http._tcp\" service (i.e., web servers) for the\n   \"example.com.\" domain.
    \ The unstated assumption is that all these\n   servers offer an identical set
    of web pages, and it doesn't matter to\n   the client which of the servers it
    uses, as long as it selects one at\n   random according to the weight and priority
    rules laid out in the DNS\n   SRV specification [RFC2782].\n   Instances of other
    kinds of service are less easily interchangeable.\n   If a word processing application
    were to look up the (hypothetical)\n   SRV record \"_ipp._tcp.example.com.\" to
    find the list of Internet\n   Printing Protocol (IPP) [RFC2910] printers at Example
    Co., then\n   picking one at random and printing on it would probably not be what\n
    \  the user wanted.\n   The remainder of this section describes how SRV records
    may be used\n   in a slightly different way, to allow a user to discover the names
    of\n   all available instances of a given type of service, and then select,\n
    \  from that list, the particular instance they desire.\n"
  - contents:
    - "4.1.  Structured Service Instance Names\n   This document borrows the logical
      service-naming syntax and semantics\n   from DNS SRV records, but adds one level
      of indirection.  Instead of\n   requesting records of type \"SRV\" with name
      \"_ipp._tcp.example.com.\",\n   the client requests records of type \"PTR\"
      (pointer from one name to\n   another in the DNS namespace) [RFC1035].\n   In
      effect, if one thinks of the domain name \"_ipp._tcp.example.com.\"\n   as being
      analogous to an absolute path to a directory in a file\n   system, then DNS-SD's
      PTR lookup is akin to performing a listing of\n   that directory to find all
      the entries it contains.  (Remember that\n   domain names are expressed in reverse
      order compared to path names --\n   an absolute path name starts with the root
      on the left and is read\n   from left to right, whereas a fully qualified domain
      name starts with\n   the root on the right and is read from right to left.  If
      the fully\n   qualified domain name \"_ipp._tcp.example.com.\" were expressed
      as a\n   file system path name, it would be \"/com/example/_tcp/_ipp\".)\n   The
      result of this PTR lookup for the name \"<Service>.<Domain>\" is a\n   set of
      zero or more PTR records giving Service Instance Names of the\n   form:\n      Service
      Instance Name = <Instance> . <Service> . <Domain>\n   For explanation of why
      the components are in this order, see Appendix\n   B, \"Ordering of Service
      Instance Name Components\".\n"
    - contents:
      - "4.1.1.  Instance Names\n   The <Instance> portion of the Service Instance
        Name is a user-\n   friendly name consisting of arbitrary Net-Unicode text
        [RFC5198].  It\n   MUST NOT contain ASCII control characters (byte values
        0x00-0x1F and\n   0x7F) [RFC20] but otherwise is allowed to contain any characters,\n
        \  without restriction, including spaces, uppercase, lowercase,\n   punctuation
        -- including dots -- accented characters, non-Roman text,\n   and anything
        else that may be represented using Net-Unicode.  For\n   discussion of why
        the <Instance> name should be a user-visible, user-\n   friendly name rather
        than an invisible machine-generated opaque\n   identifier, see Appendix C,
        \"What You See Is What You Get\".\n   The <Instance> portion of the name of
        a service being offered on the\n   network SHOULD be configurable by the user
        setting up the service, so\n   that he or she may give it an informative name.
        \ However, the device\n   or service SHOULD NOT require the user to configure
        a name before it\n   can be used.  A sensible choice of default name can in
        many cases\n   allow the device or service to be accessed without any manual\n
        \  configuration at all.  The default name should be short and\n   descriptive,
        and SHOULD NOT include the device's Media Access Control\n   (MAC) address,
        serial number, or any similar incomprehensible\n   hexadecimal string in an
        attempt to make the name globally unique.\n   For discussion of why <Instance>
        names don't need to be (and SHOULD\n   NOT be) made unique at the factory,
        see Appendix D, \"Choice of\n   Factory-Default Names\".\n   This <Instance>
        portion of the Service Instance Name is stored\n   directly in the DNS as
        a single DNS label of canonical precomposed\n   UTF-8 [RFC3629] \"Net-Unicode\"
        (Unicode Normalization Form C)\n   [RFC5198] text.  For further discussion
        of text encodings, see\n   Appendix E, \"Name Encodings in the Domain Name
        System\".\n   DNS labels are currently limited to 63 octets in length.  UTF-8\n
        \  encoding can require up to four octets per Unicode character, which\n   means
        that in the worst case, the <Instance> portion of a name could\n   be limited
        to fifteen Unicode characters.  However, the Unicode\n   characters with longer
        octet lengths under UTF-8 encoding tend to be\n   the more rarely used ones,
        and tend to be the ones that convey\n   greater meaning per character.\n   Note
        that any character in the commonly used 16-bit Unicode Basic\n   Multilingual
        Plane [Unicode6] can be encoded with no more than three\n   octets of UTF-8
        encoding.  This means that an instance name can\n   contain up to 21 Kanji
        characters, which is a sufficiently expressive\n   name for most purposes.\n"
      title: 4.1.1.  Instance Names
    - contents:
      - "4.1.2.  Service Names\n   The <Service> portion of the Service Instance Name
        consists of a pair\n   of DNS labels, following the convention already established
        for SRV\n   records [RFC2782].  The first label of the pair is an underscore\n
        \  character followed by the Service Name [RFC6335].  The Service Name\n   identifies
        what the service does and what application protocol it\n   uses to do it.
        \ The second label is either \"_tcp\" (for application\n   protocols that
        run over TCP) or \"_udp\" (for all others).  For more\n   details, see Section
        7, \"Service Names\".\n"
      title: 4.1.2.  Service Names
    - contents:
      - "4.1.3.  Domain Names\n   The <Domain> portion of the Service Instance Name
        specifies the DNS\n   subdomain within which those names are registered.  It
        may be\n   \"local.\", meaning \"link-local Multicast DNS\" [RFC6762], or
        it may be\n   a conventional Unicast DNS domain name, such as \"ietf.org.\",\n
        \  \"cs.stanford.edu.\", or \"eng.us.ibm.com.\"  Because Service Instance\n
        \  Names are not host names, they are not constrained by the usual rules\n
        \  for host names [RFC1033] [RFC1034] [RFC1035], and rich-text service\n   subdomains
        are allowed and encouraged, for example:\n     Building 2, 1st Floor  .  example
        \ .  com  .\n     Building 2, 2nd Floor  .  example  .  com  .\n     Building
        2, 3rd Floor  .  example  .  com  .\n     Building 2, 4th Floor  .  example
        \ .  com  .\n   In addition, because Service Instance Names are not constrained
        by\n   the limitations of host names, this document recommends that they be\n
        \  stored in the DNS, and communicated over the wire, encoded as\n   straightforward
        canonical precomposed UTF-8 [RFC3629] \"Net-Unicode\"\n   (Unicode Normalization
        Form C) [RFC5198] text.  In cases where the\n   DNS server returns a negative
        response for the name in question,\n   client software MAY choose to retry
        the query using the \"Punycode\"\n   algorithm [RFC3492] to convert the UTF-8
        name to an IDNA \"A-label\"\n   [RFC5890], beginning with the top-level label,
        then issuing the query\n   repeatedly, with successively more labels translated
        to IDNA A-labels\n   each time, and giving up if it has converted all labels
        to IDNA\n   A-labels and the query still fails.\n"
      title: 4.1.3.  Domain Names
    title: 4.1.  Structured Service Instance Names
  - contents:
    - "4.2.  User Interface Presentation\n   The names resulting from the Service
      Instance Enumeration PTR lookup\n   are presented to the user in a list for
      the user to select one (or\n   more).  Typically, only the first label is shown
      (the user-friendly\n   <Instance> portion of the name).\n   In the common case
      the <Service> and <Domain> are already known to\n   the client software, these
      having been provided implicitly by the\n   user in the first place, by the act
      of indicating the service being\n   sought, and the domain in which to look
      for it.  Note that the\n   software handling the response should be careful
      not to make invalid\n   assumptions though, since it *is* possible, though rare,
      for a\n   service enumeration in one domain to return the names of services
      in\n   a different domain.  Similarly, when using subtypes (see Section 7.1,\n
      \  \"Selective Instance Enumeration\") the <Service> of the discovered\n   instance
      may not be exactly the same as the <Service> that was\n   requested.\n   For
      further discussion of Service Instance Enumeration (browsing)\n   user-interface
      considerations, see Appendix F, \"'Continuous Live\n   Update' Browsing Model\".\n
      \  Once the user has selected the desired named instance, the Service\n   Instance
      Name may then be used immediately, or saved away in some\n   persistent user-preference
      data structure for future use, depending\n   on what is appropriate for the
      application in question.\n"
    title: 4.2.  User Interface Presentation
  - contents:
    - "4.3.  Internal Handling of Names\n   If client software takes the <Instance>,
      <Service>, and <Domain>\n   portions of a Service Instance Name and internally
      concatenates them\n   together into a single string, then because the <Instance>
      portion is\n   allowed to contain any characters, including dots, appropriate\n
      \  precautions MUST be taken to ensure that DNS label boundaries are\n   properly
      preserved.  Client software can do this in a variety of\n   ways, such as character
      escaping.\n   This document RECOMMENDS that if concatenating the three portions
      of\n   a Service Instance Name, any dots in the <Instance> portion be\n   escaped
      following the customary DNS convention for text files: by\n   preceding literal
      dots with a backslash (so \".\" becomes \"\\.\").\n   Likewise, any backslashes
      in the <Instance> portion should also be\n   escaped by preceding them with
      a backslash (so \"\\\" becomes \"\\\\\").\n   Having done this, the three components
      of the name may be safely\n   concatenated.  The backslash-escaping allows literal
      dots in the name\n   (escaped) to be distinguished from label-separator dots
      (not\n   escaped), and the resulting concatenated string may be safely passed\n
      \  to standard DNS APIs like res_query(), which will interpret the\n   backslash-escaped
      string as intended.\n"
    title: 4.3.  Internal Handling of Names
  title: 4.  Service Instance Enumeration (Browsing)
- contents:
  - "5.  Service Instance Resolution\n   When a client needs to contact a particular
    service, identified by a\n   Service Instance Name, previously discovered via
    Service Instance\n   Enumeration (browsing), it queries for the SRV and TXT records
    of\n   that name.  The SRV record for a service gives the port number and\n   target
    host name where the service may be found.  The TXT record\n   gives additional
    information about the service, as described in\n   Section 6, \"Data Syntax for
    DNS-SD TXT Records\".\n   SRV records are extremely useful because they remove
    the need for\n   preassigned port numbers.  There are only 65535 TCP port numbers\n
    \  available.  These port numbers are traditionally allocated one per\n   application
    protocol [RFC6335].  Some protocols like the X Window\n   System have a block
    of 64 TCP ports allocated (6000-6063).  Using a\n   different TCP port for each
    different instance of a given service on\n   a given machine is entirely sensible,
    but allocating each application\n   its own large static range, as was done for
    the X Window System, is\n   not a practical way to do that.  On any given host,
    most TCP ports\n   are reserved for services that will never run on that particular
    host\n   in its lifetime.  This is very poor utilization of the limited port\n
    \  space.  Using SRV records allows each host to allocate its available\n   port
    numbers dynamically to those services actually running on that\n   host that need
    them, and then advertise the allocated port numbers\n   via SRV records.  Allocating
    the available listening port numbers\n   locally on a per-host basis as needed
    allows much better utilization\n   of the available port space than today's centralized
    global\n   allocation.\n   In the event that more than one SRV is returned, clients
    MUST\n   correctly interpret the priority and weight fields -- i.e., lower-\n
    \  numbered priority servers should be used in preference to higher-\n   numbered
    priority servers, and servers with equal priority should be\n   selected randomly
    in proportion to their relative weights.  However,\n   in the overwhelmingly common
    case, a single advertised DNS-SD service\n   instance is described by exactly
    one SRV record, and in this common\n   case the priority and weight fields of
    the SRV record SHOULD both be\n   set to zero.\n"
  title: 5.  Service Instance Resolution
- contents:
  - "6.  Data Syntax for DNS-SD TXT Records\n   Some services discovered via Service
    Instance Enumeration may need\n   more than just an IP address and port number
    to completely identify\n   the service instance.  For example, printing via the
    old Unix LPR\n   (port 515) protocol [RFC1179] often specifies a queue name [BJP].\n
    \  This queue name is typically short and cryptic, and need not be shown\n   to
    the user.  It should be regarded the same way as the IP address\n   and port number:
    it is another component of the addressing\n   information required to identify
    a specific instance of a service\n   being offered by some piece of hardware.
    \ Similarly, a file server\n   may have multiple volumes, each identified by its
    own volume name.  A\n   web server typically has multiple pages, each identified
    by its own\n   URL.  In these cases, the necessary additional data is stored in
    a\n   TXT record with the same name as the SRV record.  The specific nature\n
    \  of that additional data, and how it is to be used, is service-\n   dependent,
    but the overall syntax of the data in the TXT record is\n   standardized, as described
    below.\n   Every DNS-SD service MUST have a TXT record in addition to its SRV\n
    \  record, with the same name, even if the service has no additional\n   data
    to store and the TXT record contains no more than a single zero\n   byte.  This
    allows a service to have explicit control over the Time\n   to Live (TTL) of its
    (empty) TXT record, rather than using the\n   default negative caching TTL, which
    would otherwise be used for a \"no\n   error no answer\" DNS response.\n   Note
    that this requirement for a mandatory TXT record applies\n   exclusively to DNS-SD
    service advertising, i.e., services advertised\n   using the PTR+SRV+TXT convention
    specified in this document.  It is\n   not a requirement of SRV records in general.
    \ The DNS SRV record\n   datatype [RFC2782] may still be used in other contexts
    without any\n   requirement for accompanying PTR and TXT records.\n"
  - contents:
    - "6.1.  General Format Rules for DNS TXT Records\n   A DNS TXT record can be
      up to 65535 (0xFFFF) bytes long.  The total\n   length is indicated by the length
      given in the resource record header\n   in the DNS message.  There is no way
      to tell directly from the data\n   alone how long it is (e.g., there is no length
      count at the start, or\n   terminating NULL byte at the end).\n   Note that
      when using Multicast DNS [RFC6762] the maximum packet size\n   is 9000 bytes,
      including the IP header, UDP header, and DNS message\n   header, which imposes
      an upper limit on the size of TXT records of\n   about 8900 bytes.  In practice
      the maximum sensible size of a DNS-SD\n   TXT record is smaller even than this,
      typically at most a few hundred\n   bytes, as described below in Section 6.2.\n
      \  The format of the data within a DNS TXT record is one or more\n   strings,
      packed together in memory without any intervening gaps or\n   padding bytes
      for word alignment.\n   The format of each constituent string within the DNS
      TXT record is a\n   single length byte, followed by 0-255 bytes of text data.\n
      \  These format rules for TXT records are defined in Section 3.3.14 of\n   the
      DNS specification [RFC1035] and are not specific to DNS-SD.\n   DNS-SD specifies
      additional rules for what data should be stored in\n   those constituent strings
      when used for DNS-SD service advertising,\n   i.e., when used to describe services
      advertised using the PTR+SRV+TXT\n   convention specified in this document.\n
      \  An empty TXT record containing zero strings is not allowed [RFC1035].\n   DNS-SD
      implementations MUST NOT emit empty TXT records.  DNS-SD\n   clients MUST treat
      the following as equivalent:\n   o  A TXT record containing a single zero byte.\n
      \     (i.e., a single empty string.)\n   o  An empty (zero-length) TXT record.\n
      \     (This is not strictly legal, but should one be received, it should\n      be
      interpreted as the same as a single empty string.)\n   o  No TXT record.\n      (i.e.,
      an NXDOMAIN or no-error-no-answer response.)\n"
    title: 6.1.  General Format Rules for DNS TXT Records
  - contents:
    - "6.2.  DNS-SD TXT Record Size\n   The total size of a typical DNS-SD TXT record
      is intended to be small\n   -- 200 bytes or less.\n   In cases where more data
      is justified (e.g., LPR printing [BJP]),\n   keeping the total size under 400
      bytes should allow it to fit in a\n   single 512-byte DNS message [RFC1035].\n
      \  In extreme cases where even this is not enough, keeping the size of\n   the
      TXT record under 1300 bytes should allow it to fit in a single\n   1500-byte
      Ethernet packet.\n   Using TXT records larger than 1300 bytes is NOT RECOMMENDED
      at this\n   time.\n   Note that some Ethernet hardware vendors offer chipsets
      with\n   Multicast DNS [RFC6762] offload, so that computers can sleep and\n
      \  still be discoverable on the network.  Early versions of such\n   chipsets
      were sometimes quite limited: for example, some were\n   (unwisely) limited
      to handling TXT records no larger than 256 bytes\n   (which meant that LPR printer
      services with larger TXT records did\n   not work).  Developers should be aware
      of this real-world limitation,\n   and should understand that even hardware
      which is otherwise perfectly\n   capable may have low-power and sleep modes
      that are more limited.\n"
    title: 6.2.  DNS-SD TXT Record Size
  - contents:
    - "6.3.  DNS TXT Record Format Rules for Use in DNS-SD\n   DNS-SD uses DNS TXT
      records to store arbitrary key/value pairs\n   conveying additional information
      about the named service.  Each\n   key/value pair is encoded as its own constituent
      string within the\n   DNS TXT record, in the form \"key=value\" (without the
      quotation\n   marks).  Everything up to the first '=' character is the key (Section\n
      \  6.4).  Everything after the first '=' character to the end of the\n   string
      (including subsequent '=' characters, if any) is the value\n   (Section 6.5).
      \ No quotation marks are required around the value,\n   even if it contains
      spaces, '=' characters, or other punctuation\n   marks.  Each author defining
      a DNS-SD profile for discovering\n   instances of a particular type of service
      should define the base set\n   of key/value attributes that are valid for that
      type of service.\n   Using this standardized key/value syntax within the TXT
      record makes\n   it easier for these base definitions to be expanded later by
      defining\n   additional named attributes.  If an implementation sees unknown
      keys\n   in a service TXT record, it MUST silently ignore them.\n   The target
      host name and TCP (or UDP) port number of the service are\n   given in the SRV
      record.  This information -- target host name and\n   port number -- MUST NOT
      be duplicated using key/value attributes in\n   the TXT record.\n   The intention
      of DNS-SD TXT records is to convey a small amount of\n   useful additional information
      about a service.  Ideally, it should\n   not be necessary for a client to retrieve
      this additional information\n   before it can usefully establish a connection
      to the service.  For a\n   well-designed application protocol, even if there
      is no information\n   at all in the TXT record, it should be possible, knowing
      only the\n   host name, port number, and protocol being used, to communicate
      with\n   that listening process and then perform version- or feature-\n   negotiation
      to determine any further options or capabilities of the\n   service instance.
      \ For example, when connecting to an AFP (Apple\n   Filing Protocol) server
      [AFP] over TCP, the client enters into a\n   protocol exchange with the server
      to determine which version of AFP\n   the server implements and which optional
      features or capabilities (if\n   any) are available.\n   For protocols designed
      with adequate in-band version- and feature-\n   negotiation, any information
      in the TXT record should be viewed as a\n   performance optimization -- when
      a client discovers many instances of\n   a service, the TXT record allows the
      client to know some rudimentary\n   information about each instance without
      having to open a TCP\n   connection to each one and interrogate every service
      instance\n   separately.  Care should be taken when doing this to ensure that
      the\n   information in the TXT record is in agreement with the information\n
      \  that would be retrieved by a client connecting over TCP.\n   There are legacy
      protocols that provide no feature negotiation\n   capability, and in these cases
      it may be useful to convey necessary\n   information in the TXT record.  For
      example, when printing using LPR\n   [RFC1179], the LPR protocol provides no
      way for the client to\n   determine whether a particular printer accepts PostScript,
      what\n   version of PostScript, etc.  In this case it is appropriate to embed\n
      \  this information in the TXT record [BJP], because the alternative\n   would
      be worse -- passing around written instructions to the users,\n   arcane manual
      configuration of \"/etc/printcap\" files, etc.\n   The engineering decision
      about what keys to define for the TXT record\n   needs to be decided on a case-by-case
      basis for each service type.\n   For some service types it is appropriate to
      communicate information\n   via the TXT record as well as (or instead of) via
      in-band\n   communication in the application protocol.\n"
    title: 6.3.  DNS TXT Record Format Rules for Use in DNS-SD
  - contents:
    - "6.4.  Rules for Keys in DNS-SD Key/Value Pairs\n   The key MUST be at least
      one character.  DNS-SD TXT record strings\n   beginning with an '=' character
      (i.e., the key is missing) MUST be\n   silently ignored.\n   The key SHOULD
      be no more than nine characters long.  This is because\n   it is beneficial
      to keep packet sizes small for the sake of network\n   efficiency.  When using
      DNS-SD in conjunction with Multicast DNS\n   [RFC6762] this is important because
      multicast traffic is especially\n   expensive on 802.11 wireless networks [IEEEW],
      but even when using\n   conventional Unicast DNS, keeping the TXT records small
      helps improve\n   the chance that responses will fit within the original DNS
      512-byte\n   size limit [RFC1035].  Also, each constituent string of a DNS TXT\n
      \  record is limited to 255 bytes, so excessively long keys reduce the\n   space
      available for that key's values.\n   The keys in key/value pairs can be as short
      as a single character.\n   A key name needs only to be unique and unambiguous
      within the context\n   of the service type for which it is defined.  A key name
      is intended\n   solely to be a machine-readable identifier, not a human-readable\n
      \  essay giving detailed discussion of the purpose of a parameter, with\n   a
      URL for a web page giving yet more details of the specification.\n   For ease
      of development and debugging, it can be valuable to use key\n   names that are
      mnemonic textual names, but excessively verbose keys\n   are wasteful and inefficient,
      hence the recommendation to keep them\n   to nine characters or fewer.\n   The
      characters of a key MUST be printable US-ASCII values (0x20-0x7E)\n   [RFC20],
      excluding '=' (0x3D).\n   Spaces in the key are significant, whether leading,
      trailing, or in\n   the middle -- so don't include any spaces unless you really
      intend\n   that.\n   Case is ignored when interpreting a key, so \"papersize=A4\",\n
      \  \"PAPERSIZE=A4\", and \"Papersize=A4\" are all identical.\n   If there is
      no '=' in a DNS-SD TXT record string, then it is a\n   boolean attribute, simply
      identified as being present, with no value.\n   A given key SHOULD NOT appear
      more than once in a TXT record.  The\n   reason for this simplifying rule is
      to facilitate the creation of\n   client libraries that parse the TXT record
      into an internal data\n   structure (such as a hash table or dictionary object
      that maps from\n   keys to values) and then make that abstraction available
      to client\n   code.  The rule that a given key may not appear more than once\n
      \  simplifies these abstractions because they aren't required to support\n   the
      case of returning more than one value for a given key.\n   If a client receives
      a TXT record containing the same key more than\n   once, then the client MUST
      silently ignore all but the first\n   occurrence of that attribute.  For client
      implementations that\n   process a DNS-SD TXT record from start to end, placing
      key/value\n   pairs into a hash table using the key as the hash table key, this\n
      \  means that if the implementation attempts to add a new key/value pair\n   into
      the table and finds an entry with the same key already present,\n   then the
      new entry being added should be silently discarded instead.\n   Client implementations
      that retrieve key/value pairs by searching the\n   TXT record for the requested
      key should search the TXT record from\n   the start and simply return the first
      matching key they find.\n   When examining a TXT record for a given key, there
      are therefore four\n   categories of results that may be returned:\n   *  Attribute
      not present (Absent)\n   *  Attribute present, with no value\n      (e.g., \"passreq\"
      -- password required for this service)\n   *  Attribute present, with empty
      value\n      (e.g., \"PlugIns=\" -- the server supports plugins, but none are\n
      \     presently installed)\n   *  Attribute present, with non-empty value\n
      \     (e.g., \"PlugIns=JPEG,MPEG2,MPEG4\")\n   Each author defining a DNS-SD
      profile for discovering instances of a\n   particular type of service should
      define the interpretation of these\n   different kinds of result.  For example,
      for some keys, there may be\n   a natural true/false boolean interpretation:\n
      \  *  Absent implies 'false'\n   *  Present implies 'true'\n   For other keys
      it may be sensible to define other semantics, such as\n   value/no-value/unknown:\n
      \  *  Present with value implies that value.\n      (e.g., \"Color=4\" for a
      four-color ink-jet printer\n      or \"Color=6\" for a six-color ink-jet printer)\n
      \  *  Present with empty value implies 'false'.\n      (e.g., not a color printer)\n
      \  *  Absent implies 'Unknown'.\n      (e.g., a print server connected to some
      unknown printer where the\n      print server doesn't actually know if the printer
      does color or\n      not -- which gives a very bad user experience and should
      be\n      avoided wherever possible)\n   Note that this is a hypothetical example,
      not an example of actual\n   key/value keys used by DNS-SD network printers,
      which are documented\n   in the \"Bonjour Printing Specification\" [BJP].\n"
    title: 6.4.  Rules for Keys in DNS-SD Key/Value Pairs
  - contents:
    - "6.5.  Rules for Values in DNS-SD Key/Value Pairs\n   If there is an '=' in
      a DNS-SD TXT record string, then everything\n   after the first '=' to the end
      of the string is the value.  The value\n   can contain any eight-bit values
      including '='.  The value MUST NOT\n   be enclosed in additional quotation marks
      or any similar punctuation;\n   any quotation marks, or leading or trailing
      spaces, are part of the\n   value.\n   The value is opaque binary data.  Often
      the value for a particular\n   attribute will be US-ASCII [RFC20] or UTF-8 [RFC3629]
      text, but it is\n   legal for a value to be any binary data.\n   Generic debugging
      tools should generally display all attribute values\n   as a hex dump, with
      accompanying text alongside displaying the UTF-8\n   interpretation of those
      bytes, except for attributes where the\n   debugging tool has embedded knowledge
      that the value is some other\n   kind of data.\n   Authors defining DNS-SD profiles
      SHOULD NOT generically convert\n   binary attribute data types into printable
      text using hexadecimal\n   representation, Base-64 [RFC4648], or Unix-to-Unix
      (UU) encoding,\n   merely for the sake of making the data appear to be printable
      text\n   when seen in a generic debugging tool.  Doing this simply bloats the\n
      \  size of the TXT record, without actually making the data any more\n   understandable
      to someone looking at it in a generic debugging tool.\n"
    title: 6.5.  Rules for Values in DNS-SD Key/Value Pairs
  - contents:
    - "6.6.  Example TXT Record\n   The TXT record below contains three syntactically
      valid key/value\n   strings.  (The meaning of these key/value pairs, if any,
      would depend\n   on the definitions pertaining to the service in question that
      is\n   using them.)\n        -------------------------------------------------------\n
      \       | 0x09 | key=value | 0x08 | paper=A4 | 0x07 | passreq |\n        -------------------------------------------------------\n"
    title: 6.6.  Example TXT Record
  - contents:
    - "6.7.  Version Tag\n   It is recommended that authors defining DNS-SD profiles
      include an\n   attribute of the form \"txtvers=x\", where \"x\" is a decimal
      version\n   number in US-ASCII [RFC20] text (e.g., \"txtvers=1\" or \"txtvers=8\"),\n
      \  in their definition, and require it to be the first key/value pair in\n   the
      TXT record.  This information in the TXT record can be useful to\n   help clients
      maintain backwards compatibility with older\n   implementations if it becomes
      necessary to change or update the\n   specification over time.  Even if the
      profile author doesn't\n   anticipate the need for any future incompatible changes,
      having a\n   version number in the TXT record provides useful insurance should\n
      \  incompatible changes become unavoidable [RFC6709].  Clients SHOULD\n   ignore
      TXT records with a txtvers number higher (or lower) than the\n   version(s)
      they know how to interpret.\n   Note that the version number in the txtvers
      tag describes the version\n   of the specification governing the defined keys
      and the meaning of\n   those keys for that particular TXT record, not the version
      of the\n   application protocol that will be used if the client subsequently\n
      \  decides to contact that service.  Ideally, every DNS-SD TXT record\n   specification
      starts at txtvers=1 and stays that way forever.\n   Improvements can be made
      by defining new keys that older clients\n   silently ignore.  The only reason
      to increment the version number is\n   if the old specification is subsequently
      found to be so horribly\n   broken that there's no way to do a compatible forward
      revision, so\n   the txtvers number has to be incremented to tell all the old
      clients\n   they should just not even try to understand this new TXT record.\n
      \  If there is a need to indicate which version number(s) of the\n   application
      protocol the service implements, the recommended key for\n   this is \"protovers\".\n"
    title: 6.7.  Version Tag
  - contents:
    - "6.8.  Service Instances with Multiple TXT Records\n   Generally speaking, every
      DNS-SD service instance has exactly one TXT\n   record.  However, it is possible
      for a particular protocol's DNS-SD\n   advertising specification to state that
      it allows multiple TXT\n   records.  In this case, each TXT record describes
      a different variant\n   of the same logical service, offered using the same
      underlying\n   protocol on the same port, described by the same SRV record.\n
      \  Having multiple TXT records to describe a single service instance is\n   very
      rare, and to date, of the many hundreds of registered DNS-SD\n   service types
      [SN], only one makes use of this capability, namely LPR\n   printing [BJP].
      \ This capability is used when a printer conceptually\n   supports multiple
      logical queue names, where each different logical\n   queue name implements
      a different page description language, such as\n   80-column monospaced plain
      text, seven-bit Adobe PostScript, eight-\n   bit (\"binary\") PostScript, or
      some proprietary page description\n   language.  When multiple TXT records are
      used to describe multiple\n   logical LPR queue names for the same underlying
      service, printers\n   include two additional keys in each TXT record: 'qtotal',
      which\n   specifies the total number of TXT records associated with this SRV\n
      \  record, and 'priority', which gives the printer's relative preference\n   for
      this particular TXT record.  Clients then select the most\n   preferred TXT
      record that meets the client's needs [BJP].  The only\n   reason multiple TXT
      records are used is because the LPR protocol\n   lacks in-band feature-negotiation
      capabilities for the client and\n   server to agree on a data representation
      for the print job, so this\n   information has to be communicated out-of-band
      instead using the DNS-\n   SD TXT records.  Future protocol designs should not
      follow this bad\n   example by mimicking this inadequacy of the LPR printing
      protocol.\n"
    title: 6.8.  Service Instances with Multiple TXT Records
  title: 6.  Data Syntax for DNS-SD TXT Records
- contents:
  - "7.  Service Names\n   The <Service> portion of a Service Instance Name consists
    of a pair\n   of DNS labels, following the convention already established for
    SRV\n   records [RFC2782].\n   The first label of the pair is an underscore character
    followed by\n   the Service Name [RFC6335].  The Service Name identifies what
    the\n   service does and what application protocol it uses to do it.\n   For applications
    using TCP, the second label is \"_tcp\".\n   For applications using any transport
    protocol other than TCP, the\n   second label is \"_udp\".  This applies to all
    other transport\n   protocols, including User Datagram Protocol (UDP), Stream
    Control\n   Transmission Protocol (SCTP) [RFC4960], Datagram Congestion Control\n
    \  Protocol (DCCP) [RFC4340], Adobe's Real Time Media Flow Protocol\n   (RTMFP),
    etc.  In retrospect, perhaps the SRV specification should\n   not have used the
    \"_tcp\" and \"_udp\" labels at all, and instead should\n   have used a single
    label \"_srv\" to carve off a subdomain of DNS\n   namespace for this use, but
    that specification is already published\n   and deployed.  At this point there
    is no benefit in changing\n   established practice.  While \"_srv\" might be aesthetically
    nicer than\n   \"_udp\", it is not a user-visible string, and all that is required\n
    \  protocol-wise is (i) that it be a label that can form a DNS\n   delegation
    point, and (ii) that it be short so that it does not take\n   up too much space
    in the packet, and in this respect either \"_udp\" or\n   \"_srv\" is equally
    good.  Thus, it makes sense to use \"_tcp\" for TCP-\n   based services and \"_udp\"
    for all other transport protocols -- which\n   are in fact, in today's world,
    often encapsulated over UDP -- rather\n   than defining a new subdomain for every
    new transport protocol.\n   Note that this usage of the \"_udp\" label for all
    protocols other than\n   TCP applies exclusively to DNS-SD service advertising,
    i.e., services\n   advertised using the PTR+SRV+TXT convention specified in this\n
    \  document.  It is not a requirement of SRV records in general.  Other\n   specifications
    that are independent of DNS-SD and not intended to\n   interoperate with DNS-SD
    records are not in any way constrained by\n   how DNS-SD works just because they
    also use the DNS SRV record\n   datatype [RFC2782]; they are free to specify their
    own naming\n   conventions as appropriate.\n   The rules for Service Names [RFC6335]
    state that they may be no more\n   than fifteen characters long (not counting
    the mandatory underscore),\n   consisting of only letters, digits, and hyphens,
    must begin and end\n   with a letter or digit, must not contain consecutive hyphens,
    and\n   must contain at least one letter.  The requirement to contain at\n   least
    one letter is to disallow Service Names such as \"80\" or\n   \"6000-6063\", which
    could be misinterpreted as port numbers or port\n   number ranges.  While both
    uppercase and lowercase letters may be\n   used for mnemonic clarity, case is
    ignored for comparison purposes,\n   so the strings \"HTTP\" and \"http\" refer
    to the same service.\n   Wise selection of a Service Name is important, and the
    choice is not\n   always as obvious as it may appear.\n   In many cases, the Service
    Name merely names and refers to the on-\n   the-wire message format and semantics
    being used.  FTP is \"ftp\", IPP\n   printing is \"ipp\", and so on.\n   However,
    it is common to \"borrow\" an existing protocol and repurpose\n   it for a new
    task.  This is entirely sensible and sound engineering\n   practice, but that
    doesn't mean that the new protocol is providing\n   the same semantic service
    as the old one, even if it borrows the same\n   message formats.  For example,
    the network music sharing protocol\n   implemented by iTunes on Macintosh and
    Windows is built upon \"HTTP\n   GET\" commands.  However, that does *not* mean
    that it is sensible or\n   useful to try to access one of these music servers
    by connecting to\n   it with a standard web browser.  Consequently, the DNS-SD
    service\n   advertised (and browsed for) by iTunes is \"_daap._tcp\" (Digital
    Audio\n   Access Protocol), not \"_http._tcp\".\n   If iTunes were to advertise
    that it offered \"_http._tcp\" service,\n   that would cause iTunes servers to
    appear in conventional web\n   browsers (Safari, Camino, OmniWeb, Internet Explorer,
    Firefox,\n   Chrome, etc.), which is of little use since an iTunes music library\n
    \  offers no HTML pages containing human-readable content that a web\n   browser
    could display.\n   Equally, if iTunes were to browse for \"_http._tcp\" service,
    that\n   would cause it to discover generic web servers, such as the embedded\n
    \  web servers in devices like printers, which is of little use since\n   printers
    generally don't have much music to offer.\n   Analogously, Sun Microsystems's
    Network File System (NFS) is built on\n   top of Sun Microsystems's Remote Procedure
    Call (Sun RPC) mechanism,\n   but that doesn't mean it makes sense for an NFS
    server to advertise\n   that it provides \"Sun RPC\" service.  Likewise, Microsoft's
    Server\n   Message Block (SMB) file service is built on top of Netbios running\n
    \  over IP, but that doesn't mean it makes sense for an SMB file server\n   to
    advertise that it provides \"Netbios-over-IP\" service.  The DNS-SD\n   name of
    a service needs to encapsulate both the \"what\" (semantics)\n   and the \"how\"
    (protocol implementation) of the service, since\n   knowledge of both is necessary
    for a client to use the service\n   meaningfully.  Merely advertising that a service
    was built on top of\n   Sun RPC is no use if the client has no idea what the service
    does.\n   Another common question is whether the service type advertised by\n
    \  iTunes should be \"_daap._http._tcp.\"  This would also be incorrect.\n   Similarly,
    a protocol designer implementing a network service that\n   happens to use the
    Simple Object Access Protocol [SOAP] should not\n   feel compelled to have \"_soap\"
    appear somewhere in the Service Name.\n   Part of the confusion here is that the
    presence of \"_tcp\" or \"_udp\"\n   in the <Service> portion of a Service Instance
    Name has led people to\n   assume that the visible structure of the <Service>
    should reflect\n   the private internal structure of how the protocol was implemented.\n
    \  This is not correct.  All that is required is that the service be\n   identified
    by some unique opaque Service Name.  Making the Service\n   Name be English text
    that is at least marginally descriptive of what\n   the service does may be convenient,
    but it is by no means essential.\n"
  - contents:
    - "7.1.  Selective Instance Enumeration (Subtypes)\n   This document does not
      attempt to define a sophisticated (e.g.,\n   Turing complete, or even regular
      expression) query language for\n   service discovery, nor do we believe one
      is necessary.\n   However, there are some limited circumstances where narrowing
      the set\n   of results may be useful.  For example, many network printers offer
      a\n   web-based user interface, for management and administration, using\n   HTML/HTTP.
      \ A web browser wanting to discover all advertised web\n   pages issues a query
      for \"_http._tcp.<Domain>\".  On the other hand,\n   there are cases where users
      wish to manage printers specifically, not\n   to discover web pages in general,
      and it is good accommodate this.\n   In this case, we define the \"_printer\"
      subtype of \"_http._tcp\", and\n   to discover only the subset of pages advertised
      as having that\n   subtype property, the web browser issues a query for\n   \"_printer._sub._http._tcp.<Domain>\".\n
      \  The Safari web browser on Mac OS X 10.5 \"Leopard\" and later uses\n   subtypes
      in this way.  If an \"_http._tcp\" service is discovered both\n   via \"_printer._sub._http._tcp\"
      browsing and via \"_http._tcp\" browsing\n   then it is displayed in the \"Printers\"
      section of Safari's UI.  If a\n   service is discovered only via \"_http._tcp\"
      browsing then it is\n   displayed in the \"Webpages\" section of Safari's UI.
      \ This can be seen\n   by using the commands below on Mac OS X to advertise
      two \"fake\"\n   services.  The service instance \"A web page\" is displayed
      in the\n   \"Webpages\" section of Safari's Bonjour list, while the instance\n
      \  \"A printer's web page\" is displayed in the \"Printers\" section.\n      dns-sd
      -R \"A web page\"           _http._tcp          local 100\n      dns-sd -R \"A
      printer's web page\" _http._tcp,_printer local 101\n   Note that the advertised
      web page's Service Instance Name is\n   unchanged by the use of subtypes --
      it is still something of the form\n   \"The Server._http._tcp.example.com.\",
      and the advertised web page is\n   still discoverable using a standard browsing
      query for services of\n   type \"_http._tcp\".  The subdomain in which HTTP
      server SRV records\n   are registered defines the namespace within which HTTP
      server names\n   are unique.  Additional subtypes (e.g., \"_printer\") of the
      basic\n   service type (e.g., \"_http._tcp\") serve to allow clients to query
      for\n   a narrower set of results, not to create more namespace.\n   Using DNS
      zone file syntax, the service instance \"A web page\" is\n   advertised using
      one PTR record, while the instance \"A printer's web\n   page\" is advertised
      using two: the primary service type and the\n   additional subtype.  Even though
      the \"A printer's web page\" service\n   is advertised two different ways, both
      PTR records refer to the name\n   of the same SRV+TXT record pair:\n   ; One
      PTR record advertises \"A web page\"\n   _http._tcp.local. PTR A\\032web\\032page._http._tcp.local.\n
      \  ; Two different PTR records advertise \"A printer's web page\"\n   _http._tcp.local.
      PTR A\\032printer's\\032web\\032page._http._tcp.local.\n   _printer._sub._http._tcp.local.\n
      \                    PTR A\\032printer's\\032web\\032page._http._tcp.local.\n
      \  Subtypes are appropriate when it is desirable for different kinds of\n   client
      to be able to browse for services at two levels of\n   granularity.  In the
      example above, we describe two classes of HTTP\n   clients: general web browsing
      clients that are interested in all web\n   pages, and specific printer management
      tools that would like to\n   discover only web UI pages advertised by printers.
      \ The set of HTTP\n   servers on the network is the same in both cases; the
      difference is\n   that some clients want to discover all of them, whereas other
      clients\n   only want to find the subset of HTTP servers whose purpose is printer\n
      \  administration.\n   Subtypes are only appropriate in two-level scenarios
      such as this\n   one, where some clients want to find the full set of services
      of a\n   given type, and at the same time other clients only want to find some\n
      \  subset.  Generally speaking, if there is no client that wants to find\n   the
      entire set, then it's neither necessary nor desirable to use the\n   subtype
      mechanism.  If all clients are browsing for some particular\n   subtype, and
      no client exists that browses for the parent type, then\n   a new Service Name
      representing the logical service should be\n   defined, and software should
      simply advertise and browse for that\n   particular service type directly.  In
      particular, just because a\n   particular network service happens to be implemented
      in terms of some\n   other underlying protocol, like HTTP, Sun RPC, or SOAP,
      doesn't mean\n   that it's sensible for that service to be defined as a subtype
      of\n   \"_http\", \"_sunrpc\", or \"_soap\".  That would only be useful if there\n
      \  were some class of client for which it is sensible to say, \"I want to\n
      \  discover a service on the network, and I don't care what it does, as\n   long
      as it does it using the SOAP XML RPC mechanism.\"\n   Subtype strings are not
      required to begin with an underscore, though\n   they often do.  As with the
      TXT record key/value pairs, the list of\n   possible subtypes, if any (including
      whether some or all begin with\n   an underscore) are defined and specified
      separately for each basic\n   service type.\n   Subtype strings (e.g., \"_printer\"
      in the example above) may be\n   constructed using arbitrary 8-bit data values.
      \ In many cases these\n   data values may be UTF-8 [RFC3629] representations
      of text, or even\n   (as in the example above) plain ASCII [RFC20], but they
      do not have\n   to be.  Note, however, that even when using arbitrary 8-bit
      data for\n   subtype strings, DNS name comparisons are still case-insensitive,
      so\n   (for example) the byte values 0x41 and 0x61 will be considered\n   equivalent
      for subtype comparison purposes.\n"
    title: 7.1.  Selective Instance Enumeration (Subtypes)
  - contents:
    - "7.2.  Service Name Length Limits\n   As specified above, Service Names are
      allowed to be no more than\n   fifteen characters long.  The reason for this
      limit is to conserve\n   bytes in the domain name for use both by the network
      administrator\n   (choosing service domain names) and by the end user (choosing\n
      \  instance names).\n   A fully qualified domain name may be up to 255 bytes
      long, plus one\n   byte for the final terminating root label at the end.  Domain
      names\n   used by DNS-SD take the following forms:\n                   <sn>._tcp
      . <servicedomain> . <parentdomain>.\n      <Instance> . <sn>._tcp . <servicedomain>
      . <parentdomain>.\n      <sub>._sub . <sn>._tcp . <servicedomain> . <parentdomain>.\n
      \  The first example shows the name used for PTR queries.  The second\n   shows
      a Service Instance Name, i.e., the name of the service's SRV\n   and TXT records.
      \ The third shows a subtype browsing name, i.e., the\n   name of a PTR record
      pointing to a Service Instance Name (see Section\n   7.1, \"Selective Instance
      Enumeration\").\n   The Service Name <sn> may be up to 15 bytes, plus the underscore
      and\n   length byte, making a total of 17.  Including the \"_udp\" or \"_tcp\"\n
      \  and its length byte, this makes 22 bytes.\n   The instance name <Instance>
      may be up to 63 bytes.  Including the\n   length byte used by the DNS format
      when the name is stored in a\n   packet, that makes 64 bytes.\n   When using
      subtypes, the subtype identifier is allowed to be up to 63\n   bytes, plus the
      length byte, making 64.  Including the \"_sub\" and its\n   length byte, this
      makes 69 bytes.\n   Typically, DNS-SD service records are placed into subdomains
      of their\n   own beneath a company's existing domain name.  Since these subdomains\n
      \  are intended to be accessed through graphical user interfaces, not\n   typed
      on a command line, they are frequently long and descriptive.\n   Including the
      length byte, the user-visible service domain may be up\n   to 64 bytes.\n   Of
      our available 255 bytes, we have now accounted for 69+22+64 = 155\n   bytes.
      \ This leaves 100 bytes to accommodate the organization's\n   existing domain
      name <parentdomain>.  When used with Multicast DNS,\n   <parentdomain> is \"local.\",
      which easily fits.  When used with parent\n   domains of 100 bytes or less,
      the full functionality of DNS-SD is\n   available without restriction.  When
      used with parent domains longer\n   than 100 bytes, the protocol risks exceeding
      the maximum possible\n   length of domain names, causing failures.  In this
      case, careful\n   choice of short <servicedomain> names can help avoid overflows.
      \ If\n   the <servicedomain> and <parentdomain> are too long, then service\n
      \  instances with long instance names will not be discoverable or\n   resolvable,
      and applications making use of long subtype names may\n   fail.\n   Because
      of this constraint, we choose to limit Service Names to 15\n   characters or
      less.  Allowing more characters would not increase the\n   expressive power
      of the protocol and would needlessly reduce the\n   maximum <parentdomain> length
      that may be safely used.\n   Note that <Instance> name lengths affect the maximum
      number of\n   services of a given type that can be discovered in a given\n   <servicedomain>.
      \ The largest Unicast DNS response than can be sent\n   (typically using TCP,
      not UDP) is 64 kB.  Using DNS name compression,\n   a Service Instance Enumeration
      PTR record requires 2 bytes for the\n   (compressed) name, plus 10 bytes for
      type, class, ttl, and rdata\n   length.  The rdata of the PTR record requires
      up to 64 bytes for the\n   <Instance> part of the name, plus 2 bytes for a name
      compression\n   pointer to the common suffix, making a maximum of 78 bytes total.\n
      \  This means that using maximum-sized <Instance> names, up to 839\n   instances
      of a given service type can be discovered in a given\n   <servicedomain>.\n
      \  Multicast DNS aggregates response packets, so it does not have the\n   same
      hard limit, but in practice it is also useful for up to a few\n   hundred instances
      of a given service type, but probably not\n   thousands.\n   However, displaying
      even 100 instances in a flat list is probably too\n   many to be helpful to
      a typical user.  If a network has more than 100\n   instances of a given service
      type, it's probably appropriate to\n   divide those services into logical subdomains
      by building, by floor,\n   by department, etc.\n"
    title: 7.2.  Service Name Length Limits
  title: 7.  Service Names
- contents:
  - "8.  Flagship Naming\n   In some cases, there may be several network protocols
    available that\n   all perform roughly the same logical function.  For example,
    the\n   printing world has the lineprinter (LPR) protocol [RFC1179] and the\n
    \  Internet Printing Protocol (IPP) [RFC2910], both of which cause\n   printed
    sheets to be emitted from printers in much the same way.  In\n   addition, many
    printer vendors send their own proprietary page\n   description language (PDL)
    data over a TCP connection to TCP port\n   9100, herein referred to generically
    as the \"pdl-datastream\"\n   protocol.  In an ideal world, we would have only
    one network printing\n   protocol, and it would be sufficiently good that no one
    felt a\n   compelling need to invent a different one.  However, in practice,\n
    \  multiple legacy protocols do exist, and a service discovery protocol\n   has
    to accommodate that.\n   Many printers implement all three printing protocols:
    LPR, IPP, and\n   pdl-datastream.  For the benefit of clients that may speak only
    one\n   of those protocols, all three are advertised.\n   However, some clients
    may implement two, or all three of those\n   printing protocols.  When a client
    looks for all three service types\n   on the network, it will find three distinct
    services -- an LPR\n   service, an IPP service, and a pdl-datastream service --
    all of which\n   cause printed sheets to be emitted from the same physical printer.\n
    \  In a case like this, where multiple protocols all perform effectively\n   the
    same function, a client may browse for all the service types it\n   supports and
    display all the discovered instance names in a single\n   aggregated list.  Where
    the same instance name is discovered more\n   than once because that entity supports
    more than one service type\n   (e.g. a single printer which implements multiple
    printing protocols)\n   the duplicates should be suppressed and the name should
    appear only\n   once in the list.  When the user indicates their desire to print
    on a\n   given named printer, the printing client is responsible for choosing\n
    \  which of the available protocols will best achieve the desired\n   effect,
    without, for example, requiring the user to make a manual\n   choice between LPR
    and IPP.\n   As described so far, this all works very well.  However, consider
    the\n   case of: some future printer that only supports IPP printing, and\n   some
    other future printer that only supports pdl-datastream printing.\n   The namespaces
    for different service types are intentionally disjoint\n   (it is acceptable and
    desirable to be able to have both a file server\n   called \"Sales Department\"
    and a printer called \"Sales Department\").\n   However, it is not desirable,
    in the common case, to allow two\n   different printers both to be called \"Sales
    Department\" merely\n   because those two printers implement different printing
    protocols.\n   To help guard against this, when there are two or more network\n
    \  protocols that perform roughly the same logical function, one of the\n   protocols
    is declared the \"flagship\" of the fleet of related\n   protocols.  Typically
    the flagship protocol is the oldest and/or\n   best-known protocol of the set.\n
    \  If a device does not implement the flagship protocol, then it instead\n   creates
    a placeholder SRV record (priority=0, weight=0, port=0,\n   target host = host
    name of device) with that name.  If, when it\n   attempts to create this SRV record,
    it finds that a record with the\n   same name already exists, then it knows that
    this name is already\n   taken by some other entity implementing at least one
    of the protocols\n   from the fleet, and it must choose another.  If no SRV record
    already\n   exists, then the act of creating it stakes a claim to that name so\n
    \  that future devices in the same protocol fleet will detect a conflict\n   when
    they try to use it.\n   Note: When used with Multicast DNS [RFC6762], the target
    host field\n   of the placeholder SRV record MUST NOT be the empty root label.
    \ The\n   SRV record needs to contain a real target host name in order for the\n
    \  Multicast DNS conflict detection rules to operate.  If two different\n   devices
    were to create placeholder SRV records both using a null\n   target host name
    (just the root label), then the two SRV records\n   would be seen to be in agreement,
    and no conflict would be detected.\n   By defining a common well-known flagship
    protocol for the class,\n   future devices that may not even know about each other's
    protocols\n   establish a common ground where they can coordinate to verify\n
    \  uniqueness of names.\n   No PTR record is created advertising the presence
    of empty flagship\n   SRV records, since they do not represent a real service
    being\n   advertised, and hence are not (and should not be) discoverable via\n
    \  Service Instance Enumeration (browsing).\n"
  title: 8.  Flagship Naming
- contents:
  - "9.  Service Type Enumeration\n   In general, a normal client is not interested
    in finding *every*\n   service on the network, just the services that the client
    knows how\n   to use.\n   However, for problem diagnosis and network management
    tools, it may\n   be useful for network administrators to find the list of advertised\n
    \  service types on the network, even if those Service Names are just\n   opaque
    identifiers and not particularly informative in isolation.\n   For this purpose,
    a special meta-query is defined.  A DNS query for\n   PTR records with the name
    \"_services._dns-sd._udp.<Domain>\" yields a\n   set of PTR records, where the
    rdata of each PTR record is the two-\n   label <Service> name, plus the same domain,
    e.g.,\n   \"_http._tcp.<Domain>\".  Including the domain in the PTR rdata allows\n
    \  for slightly better name compression in Unicast DNS responses, but\n   only
    the first two labels are relevant for the purposes of service\n   type enumeration.
    \ These two-label service types can then be used to\n   construct subsequent Service
    Instance Enumeration PTR queries, in\n   this <Domain> or others, to discover
    instances of that service type.\n"
  title: 9.  Service Type Enumeration
- contents:
  - "10.  Populating the DNS with Information\n   How a service's PTR, SRV, and TXT
    records make their way into the DNS\n   is outside the scope of this document,
    but, for illustrative\n   purposes, some examples are given here.\n   On some
    networks, the administrator might manually enter the records\n   into the name
    server's configuration file.\n   A network monitoring tool could output a standard
    zone file to be\n   read into a conventional DNS server.  For example, a tool
    that can\n   find networked PostScript laser printers using AppleTalk NBP could\n
    \  find the list of printers, communicate with each one to find its IP\n   address,
    PostScript version, installed options, etc., and then write\n   out a DNS zone
    file describing those printers and their capabilities\n   using DNS resource records.
    \ That information would then be available\n   to IP-only clients that implement
    DNS-SD but not AppleTalk NBP.\n   A printer manager device that has knowledge
    of printers on the\n   network through some other management protocol could also
    output a\n   zone file or use DNS Update [RFC2136] [RFC3007].\n   Alternatively,
    a printer manager device could implement enough of the\n   DNS protocol that it
    is able to answer DNS queries directly, and\n   Example Co.'s main DNS server
    could delegate the\n   \"_ipp._tcp.example.com.\" subdomain to the printer manager
    device.\n   IP printers could use Dynamic DNS Update [RFC2136] [RFC3007] to\n
    \  automatically register their own PTR, SRV, and TXT records with the\n   DNS
    server.\n   Zeroconf printers answer Multicast DNS queries on the local link for\n
    \  their own PTR, SRV, and TXT names ending with \".local.\" [RFC6762].\n"
  title: 10.  Populating the DNS with Information
- contents:
  - "11.  Discovery of Browsing and Registration Domains (Domain Enumeration)\n   One
    of the motivations for DNS-based Service Discovery is to enable a\n   visiting
    client (e.g., a Wi-Fi-equipped [IEEEW] laptop computer,\n   tablet, or mobile
    telephone) arriving on a new network to discover\n   what services are available
    on that network, without any manual\n   configuration.  The logic that discovering
    services without manual\n   configuration is a good idea also dictates that discovering\n
    \  recommended registration and browsing domains without manual\n   configuration
    is a similarly good idea.\n   This discovery is performed using DNS queries, using
    Unicast or\n   Multicast DNS.  Five special RR names are reserved for this purpose:\n
    \         b._dns-sd._udp.<domain>.\n         db._dns-sd._udp.<domain>.\n          r._dns-sd._udp.<domain>.\n
    \        dr._dns-sd._udp.<domain>.\n         lb._dns-sd._udp.<domain>.\n   By
    performing PTR queries for these names, a client can learn,\n   respectively:\n
    \  o  A list of domains recommended for browsing.\n   o  A single recommended
    default domain for browsing.\n   o  A list of domains recommended for registering
    services using\n      Dynamic Update.\n   o  A single recommended default domain
    for registering services.\n   o  The \"legacy browsing\" or \"automatic browsing\"
    domain(s).\n      Sophisticated client applications that care to present choices
    of\n      domain to the user use the answers learned from the previous four\n
    \     queries to discover the domains to present.  In contrast, many\n      current
    applications browse without specifying an explicit domain,\n      allowing the
    operating system to automatically select an\n      appropriate domain on their
    behalf.  It is for this class of\n      application that the \"automatic browsing\"
    query is provided, to\n      allow the network administrator to communicate to
    the client\n      operating systems which domain(s) should be used automatically
    for\n      these applications.\n   These domains are purely advisory.  The client
    or user is free to\n   register services and/or browse in any domains.  The purpose
    of these\n   special queries is to allow software to create a user interface that\n
    \  displays a useful list of suggested choices to the user, from which\n   the
    user may make an informed selection, or ignore the offered\n   suggestions and
    manually enter their own choice.\n   The <domain> part of the Domain Enumeration
    query name may be\n   \"local.\" (meaning \"perform the query using link-local
    multicast\") or\n   it may be learned through some other mechanism, such as the
    DHCP\n   \"Domain\" option (option code 15) [RFC2132], the DHCP \"Domain Search\"\n
    \  option (option code 119) [RFC3397], or IPv6 Router Advertisement\n   Options
    [RFC6106].\n   The <domain> part of the query name may also be derived a different\n
    \  way, from the host's IP address.  The host takes its IP address and\n   calculates
    the logical AND of that address and its subnet mask, to\n   derive the 'base'
    address of the subnet (the 'network address' of\n   that subnet, or, equivalently,
    the IP address of the 'all-zero' host\n   address on that subnet).  It then constructs
    the conventional DNS\n   \"reverse mapping\" name corresponding to that base address,
    and uses\n   that as the <domain> part of the name for the queries described\n
    \  above.  For example, if a host has the address 192.168.12.34, with\n   the
    subnet mask 255.255.0.0, then the 'base' address of the subnet is\n   192.168.0.0,
    and to discover the recommended automatic browsing\n   domain(s) for devices on
    this subnet, the host issues a DNS PTR query\n   for the name \"lb._dns-sd._udp.0.0.168.192.in-addr.arpa.\"\n
    \  Equivalent address-derived Domain Enumeration queries should also be\n   done
    for the host's IPv6 address(es).\n   Address-derived Domain Enumeration queries
    SHOULD NOT be done for\n   IPv4 link-local addresses [RFC3927] or IPv6 link-local
    addresses\n   [RFC4862].\n   Sophisticated clients may perform Domain Enumeration
    queries both in\n   \"local.\" and in one or more unicast domains, using both
    name-derived\n   and address-derived queries, and then present the user with an\n
    \  combined result, aggregating the information received from all\n   sources.\n"
  title: 11.  Discovery of Browsing and Registration Domains (Domain Enumeration)
- contents:
  - "12.  DNS Additional Record Generation\n   DNS has an efficiency feature whereby
    a DNS server may place\n   additional records in the additional section of the
    DNS message.\n   These additional records are records that the client did not\n
    \  explicitly request, but the server has reasonable grounds to expect\n   that
    the client might request them shortly, so including them can\n   save the client
    from having to issue additional queries.\n   This section recommends which additional
    records SHOULD be generated\n   to improve network efficiency, for both Unicast
    and Multicast DNS-SD\n   responses.\n   Note that while servers SHOULD add these
    additional records for\n   efficiency purposes, as with all DNS additional records,
    it is the\n   client's responsibility to determine whether or not to trust them.\n
    \  Generally speaking, stub resolvers that talk to a single recursive\n   name
    server for all their queries will trust all records they receive\n   from that
    recursive name server (whom else would they ask?).\n   Recursive name servers
    that talk to multiple authoritative name\n   servers should verify that any records
    they receive from a given\n   authoritative name server are \"in bailiwick\" for
    that server, and\n   ignore them if not.\n   Clients MUST be capable of functioning
    correctly with DNS servers\n   (and Multicast DNS Responders) that fail to generate
    these additional\n   records automatically, by issuing subsequent queries for
    any further\n   record(s) they require.  The additional-record generation rules
    in\n   this section are RECOMMENDED for improving network efficiency, but\n   are
    not required for correctness.\n"
  - contents:
    - "12.1.  PTR Records\n   When including a DNS-SD Service Instance Enumeration
      or Selective\n   Instance Enumeration (subtype) PTR record in a response packet,
      the\n   server/responder SHOULD include the following additional records:\n
      \  o  The SRV record(s) named in the PTR rdata.\n   o  The TXT record(s) named
      in the PTR rdata.\n   o  All address records (type \"A\" and \"AAAA\") named
      in the SRV rdata.\n"
    title: 12.1.  PTR Records
  - contents:
    - "12.2.  SRV Records\n   When including an SRV record in a response packet, the\n
      \  server/responder SHOULD include the following additional records:\n   o  All
      address records (type \"A\" and \"AAAA\") named in the SRV rdata.\n"
    title: 12.2.  SRV Records
  - contents:
    - "12.3.  TXT Records\n   When including a TXT record in a response packet, no
      additional\n   records are required.\n"
    title: 12.3.  TXT Records
  - contents:
    - "12.4.  Other Record Types\n   In response to address queries, or other record
      types, no new\n   additional records are recommended by this document.\n"
    title: 12.4.  Other Record Types
  title: 12.  DNS Additional Record Generation
- contents:
  - "13.  Working Examples\n   The following examples were prepared using standard
    unmodified\n   nslookup and standard unmodified BIND running on GNU/Linux.\n   Note:
    In real products, this information is obtained and presented to\n   the user using
    graphical network browser software, not command-line\n   tools.  However, if you
    wish, you can try these examples for yourself\n   as you read along, using the
    nslookup command already available on\n   most Unix machines.\n"
  - contents:
    - "13.1.  What web pages are being advertised from dns-sd.org?\n   nslookup -q=ptr
      _http._tcp.dns-sd.org.\n   _http._tcp.dns-sd.org\n                name = Zeroconf._http._tcp.dns-sd.org\n
      \  _http._tcp.dns-sd.org\n                name = Multicast\\032DNS._http._tcp.dns-sd.org\n
      \  _http._tcp.dns-sd.org\n                name = Service\\032Discovery._http._tcp.dns-sd.org\n
      \  _http._tcp.dns-sd.org\n                name = Stuart's\\032Printer._http._tcp.dns-sd.org\n
      \  Answer: There are four, called \"Zeroconf\", \"Multicast DNS\", \"Service\n
      \  Discovery\", and \"Stuart's Printer\".\n   Note that nslookup escapes spaces
      as \"\\032\" for display purposes, but\n   a graphical DNS-SD browser should
      not.\n"
    title: 13.1.  What web pages are being advertised from dns-sd.org?
  - contents:
    - "13.2.  What printer-configuration web pages are there?\n   nslookup -q=ptr
      _printer._sub._http._tcp.dns-sd.org.\n   _printer._sub._http._tcp.dns-sd.org\n
      \               name = Stuart's\\032Printer._http._tcp.dns-sd.org\n   Answer:
      \"Stuart's Printer\" is the web configuration UI of a network\n   printer.\n"
    title: 13.2.  What printer-configuration web pages are there?
  - contents:
    - "13.3.  How do I access the web page called \"Service Discovery\"?\n   nslookup
      -q=any \"Service\\032Discovery._http._tcp.dns-sd.org.\"\n   Service\\032Discovery._http._tcp.dns-sd.org\n
      \                 priority = 0, weight = 0, port = 80, host = dns-sd.org\n   Service\\032Discovery._http._tcp.dns-sd.org\n
      \                 text = \"txtvers=1\" \"path=/\"\n   dns-sd.org     nameserver
      = ns1.dns-sd.org\n   dns-sd.org     internet address = 64.142.82.154\n   ns1.dns-sd.org
      internet address = 64.142.82.152\n   Answer: You need to connect to dns-sd.org
      port 80, path \"/\".\n   The address for dns-sd.org is also given (64.142.82.154).\n"
    title: 13.3.  How do I access the web page called "Service Discovery"?
  title: 13.  Working Examples
- contents:
  - "14.  IPv6 Considerations\n   IPv6 has only minor differences from IPv4.\n   The
    address of the SRV record's target host is given by the\n   appropriate IPv6 \"AAAA\"
    address records instead of (or in addition\n   to) IPv4 \"A\" records.\n   Address-based
    Domain Enumeration queries are performed using names\n   under the IPv6 reverse-mapping
    tree, which is different from the IPv4\n   reverse-mapping tree and has longer
    names in it.\n"
  title: 14.  IPv6 Considerations
- contents:
  - "15.  Security Considerations\n   Since DNS-SD is just a specification for how
    to name and use records\n   in the existing DNS system, it has no specific additional
    security\n   requirements over and above those that already apply to DNS queries\n
    \  and DNS updates.\n   For DNS queries, DNS Security Extensions (DNSSEC) [RFC4033]
    should be\n   used where the authenticity of information is important.\n   For
    DNS updates, secure updates [RFC2136] [RFC3007] should generally\n   be used to
    control which clients have permission to update DNS\n   records.\n"
  title: 15.  Security Considerations
- contents:
  - "16.  IANA Considerations\n   IANA manages the namespace of unique Service Names
    [RFC6335].\n   When a protocol service advertising specification includes subtypes,\n
    \  these should be documented in the protocol specification in question\n   and/or
    in the \"notes\" field of the registration request sent to IANA.\n   In the event
    that a new subtype becomes relevant after a protocol\n   specification has been
    published, this can be recorded by requesting\n   that IANA add it to the \"notes\"
    field.  For example, vendors of\n   network printers advertise their embedded
    web servers using the\n   subtype _printer.  This allows printer management clients
    to browse\n   for only printer-related web servers by browsing for the _printer\n
    \  subtype.  While the existence of the _printer subtype of _http._tcp\n   is
    not directly relevant to the HTTP protocol specification, it is\n   useful to
    record this usage in the IANA registry to help avoid\n   another community of
    developers inadvertently using the same subtype\n   string for a different purpose.
    \ The namespace of possible subtypes\n   is separate for each different service
    type.  For example, the\n   existence of the _printer subtype of _http._tcp does
    not imply that\n   the _printer subtype is defined or has any meaning for any
    other\n   service type.\n   When IANA records a Service Name registration, if
    the new application\n   protocol is one that conceptually duplicates existing
    functionality\n   of an older protocol, and the implementers desire the Flagship
    Naming\n   behavior described in Section 8, then the registrant should request\n
    \  that IANA record the name of the flagship protocol in the \"notes\"\n   field
    of the new registration.  For example, the registrations for\n   \"ipp\" and \"pdl-datastream\"
    both reference \"printer\" as the flagship\n   name for this family of printing-related
    protocols.\n"
  title: 16.  IANA Considerations
- contents:
  - "17.  Acknowledgments\n   The concepts described in this document have been explored,\n
    \  developed, and implemented with help from Ran Atkinson, Richard\n   Brown,
    Freek Dijkstra, Ralph Droms, Erik Guttman, Pasi Sarolahti,\n   Pekka Savola, Mark
    Townsley, Paul Vixie, Bill Woodcock, and others.\n   Special thanks go to Bob
    Bradley, Josh Graessley, Scott Herscher,\n   Rory McGuire, Roger Pantos, and Kiren
    Sekar for their significant\n   contributions.\n"
  title: 17.  Acknowledgments
- contents:
  - '18.  References

    '
  - contents:
    - "18.1.  Normative References\n   [RFC20]     Cerf, V., \"ASCII format for network
      interchange\", RFC 20,\n               October 1969.\n   [RFC1033]   Lottor,
      M., \"Domain Administrators Operations Guide\", RFC\n               1033, November
      1987.\n   [RFC1034]   Mockapetris, P., \"Domain names - concepts and\n               facilities\",
      STD 13, RFC 1034, November 1987.\n   [RFC1035]   Mockapetris, P., \"Domain names
      - implementation and\n               specification\", STD 13, RFC 1035, November
      1987.\n   [RFC2119]   Bradner, S., \"Key words for use in RFCs to Indicate\n
      \              Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC2782]
      \  Gulbrandsen, A., Vixie, P., and L. Esibov, \"A DNS RR for\n               specifying
      the location of services (DNS SRV)\", RFC 2782,\n               February 2000.\n
      \  [RFC3492]   Costello, A., \"Punycode: A Bootstring encoding of Unicode\n
      \              for Internationalized Domain Names in Applications\n               (IDNA)\",
      RFC 3492, March 2003.\n   [RFC3629]   Yergeau, F., \"UTF-8, a transformation
      format of ISO\n               10646\", STD 63, RFC 3629, November 2003.\n   [RFC3927]
      \  Cheshire, S., Aboba, B., and E. Guttman, \"Dynamic\n               Configuration
      of IPv4 Link-Local Addresses\", RFC 3927,\n               May 2005.\n   [RFC4862]
      \  Thomson, S., Narten, T., and T. Jinmei, \"IPv6 Stateless\n               Address
      Autoconfiguration\", RFC 4862, September 2007.\n   [RFC5198]   Klensin, J. and
      M. Padlipsky, \"Unicode Format for Network\n               Interchange\", RFC
      5198, March 2008.\n   [RFC5890]   Klensin, J., \"Internationalized Domain Names
      for\n               Applications (IDNA): Definitions and Document Framework\",\n
      \              RFC 5890, August 2010.\n   [RFC6335]   Cotton, M., Eggert, L.,
      Touch, J., Westerlund, M., and S.\n               Cheshire, \"Internet Assigned
      Numbers Authority (IANA)\n               Procedures for the Management of the
      Service Name and\n               Transport Protocol Port Number Registry\",
      BCP 165, RFC\n               6335, August 2011.\n"
    title: 18.1.  Normative References
  - contents:
    - "18.2.  Informative References\n   [AFP]       Mac OS X Developer Library, \"Apple
      Filing Protocol\n               Programming Guide\", <http://developer.apple.com/\n
      \              documentation/Networking/Conceptual/AFP/>.\n   [BJ]        Apple
      Bonjour Open Source Software,\n               <http://developer.apple.com/bonjour/>.\n
      \  [BJP]       Bonjour Printing Specification,\n               <https://developer.apple.com/bonjour/\n
      \              printing-specification/bonjourprinting-1.0.2.pdf>.\n   [IEEEW]
      \    IEEE 802 LAN/MAN Standards Committee,\n               <http://standards.ieee.org/wireless/>.\n
      \  [NIAS]      Cheshire, S., \"Discovering Named Instances of Abstract\n               Services
      using DNS\", Work in Progress, July 2001.\n   [NSD]       \"NsdManager | Android
      Developer\", June 2012,\n               <http://developer.android.com/reference/android/\n
      \              net/nsd/NsdManager.html>.\n   [RFC1179]   McLaughlin, L., \"Line
      printer daemon protocol\", RFC 1179,\n               August 1990.\n   [RFC2132]
      \  Alexander, S. and R. Droms, \"DHCP Options and BOOTP\n               Vendor
      Extensions\", RFC 2132, March 1997.\n   [RFC2136]   Vixie, P., Ed., Thomson,
      S., Rekhter, Y., and J. Bound,\n               \"Dynamic Updates in the Domain
      Name System (DNS UPDATE)\",\n               RFC 2136, April 1997.\n   [RFC2181]
      \  Elz, R. and R. Bush, \"Clarifications to the DNS\n               Specification\",
      RFC 2181, July 1997.\n   [RFC2910]   Herriot, R., Ed., Butler, S., Moore, P.,
      Turner, R., and\n               J. Wenn, \"Internet Printing Protocol/1.1: Encoding
      and\n               Transport\", RFC 2910, September 2000.\n   [RFC4960]   Stewart,
      R., Ed., \"Stream Control Transmission Protocol\",\n               RFC 4960,
      September 2007.\n   [RFC3007]   Wellington, B., \"Secure Domain Name System
      (DNS) Dynamic\n               Update\", RFC 3007, November 2000.\n   [RFC4340]
      \  Kohler, E., Handley, M., and S. Floyd, \"Datagram\n               Congestion
      Control Protocol (DCCP)\", RFC 4340, March\n               2006.\n   [RFC3397]
      \  Aboba, B. and S. Cheshire, \"Dynamic Host Configuration\n               Protocol
      (DHCP) Domain Search Option\", RFC 3397, November\n               2002.\n   [RFC4033]
      \  Arends, R., Austein, R., Larson, M., Massey, D., and S.\n               Rose,
      \"DNS Security Introduction and Requirements\", RFC\n               4033, March
      2005.\n   [RFC4648]   Josefsson, S., \"The Base16, Base32, and Base64 Data\n
      \              Encodings\", RFC 4648, October 2006.\n   [RFC4795]   Aboba, B.,
      Thaler, D., and L. Esibov, \"Link-local\n               Multicast Name Resolution
      (LLMNR)\", RFC 4795, January\n               2007.\n   [RFC6106]   Jeong, J.,
      Park, S., Beloeil, L., and S. Madanapalli,\n               \"IPv6 Router Advertisement
      Options for DNS\n               Configuration\", RFC 6106, November 2010.\n
      \  [RFC6281]   Cheshire, S., Zhu, Z., Wakikawa, R., and L. Zhang,\n               \"Understanding
      Apple's Back to My Mac (BTMM) Service\",\n               RFC 6281, June 2011.\n
      \  [RFC6709]   Carpenter, B., Aboba, B., Ed., and S. Cheshire, \"Design\n               Considerations
      for Protocol Extensions\", RFC 6709,\n               September 2012.\n   [RFC6760]
      \  Cheshire, S. and M. Krochmal, \"Requirements for a\n               Protocol
      to Replace the AppleTalk Name Binding Protocol\n               (NBP)\", RFC
      6760, February 2013.\n   [RFC6762]   Cheshire, S. and M. Krochmal, \"Multicast
      DNS\", RFC 6762,\n               February 2013.\n   [SN]        IANA, \"Service
      Name and Transport Protocol Port Number\n               Registry\", <http://www.iana.org/assignments/\n
      \              service-names-port-numbers/>.\n   [SOAP]      Mitra, N., \"SOAP
      Version 1.2 Part 0: Primer\", W3C\n               Proposed Recommendation 24
      June 2003,\n               <http://www.w3.org/TR/2003/REC-soap12-part0-20030624>.\n
      \  [Unicode6]  The Unicode Consortium. The Unicode Standard, Version\n               6.0.0,
      (Mountain View, CA: The Unicode Consortium, 2011.\n               ISBN 978-1-936213-01-6)\n
      \              <http://www.unicode.org/versions/Unicode6.0.0/>.\n   [ZC]        Cheshire,
      S. and D. Steinberg, \"Zero Configuration\n               Networking: The Definitive
      Guide\", O'Reilly Media, Inc.,\n               ISBN 0-596-10100-7, December
      2005.\n"
    title: 18.2.  Informative References
  title: 18.  References
- contents:
  - "Appendix A.  Rationale for Using DNS as a Basis for Service Discovery\n   Over
    the years, there have been many proposed ways to do network\n   service discovery
    with IP, but none achieved ubiquity in the\n   marketplace.  Certainly none has
    achieved anything close to the\n   ubiquity of today's deployment of DNS servers,
    clients, and other\n   infrastructure.\n   The advantage of using DNS as the basis
    for service discovery is that\n   it makes use of those existing servers, clients,
    protocols,\n   infrastructure, and expertise.  Existing network analyzer tools\n
    \  already know how to decode and display DNS packets for network\n   debugging.\n
    \  For ad hoc networks such as Zeroconf environments, peer-to-peer\n   multicast
    protocols are appropriate.  Using DNS-SD running over\n   Multicast DNS [RFC6762]
    provides zero-configuration ad hoc service\n   discovery, while maintaining the
    DNS-SD semantics and record types\n   described here.\n   In larger networks,
    a high volume of enterprise-wide IP multicast\n   traffic may not be desirable,
    so any credible service discovery\n   protocol intended for larger networks has
    to provide some facility to\n   aggregate registrations and lookups at a central
    server (or servers)\n   instead of working exclusively using multicast.  This
    requires some\n   service discovery aggregation server software to be written,\n
    \  debugged, deployed, and maintained.  This also requires some service\n   discovery
    registration protocol to be implemented and deployed for\n   clients to register
    with the central aggregation server.  Virtually\n   every company with an IP network
    already runs a DNS server, and DNS\n   already has a dynamic registration protocol
    [RFC2136] [RFC3007].\n   Given that virtually every company already has to operate
    and\n   maintain a DNS server anyway, it makes sense to take advantage of\n   this
    expertise instead of also having to learn, operate, and maintain\n   a different
    service registration server.  It should be stressed again\n   that using the same
    software and protocols doesn't necessarily mean\n   using the same physical piece
    of hardware.  The DNS-SD service\n   discovery functions do not have to be provided
    by the same piece of\n   hardware that is currently providing the company's DNS
    name service.\n   The \"_tcp.<Domain>\" and \"_udp.<Domain>\" subdomains may be
    delegated\n   to a different piece of hardware.  However, even when the DNS-SD\n
    \  service is being provided by a different piece of hardware, it is\n   still
    the same familiar DNS server software, with the same\n   configuration file syntax,
    the same log file format, and so forth.\n   Service discovery needs to be able
    to provide appropriate security.\n   DNS already has existing mechanisms for security
    [RFC4033].\n   In summary:\n      Service discovery requires a central aggregation
    server.\n      DNS already has one: a DNS server.\n      Service discovery requires
    a service registration protocol.\n      DNS already has one: DNS Dynamic Update.\n
    \     Service discovery requires a query protocol.\n      DNS already has one:
    DNS queries.\n      Service discovery requires security mechanisms.\n      DNS
    already has security mechanisms: DNSSEC.\n      Service discovery requires a multicast
    mode for ad hoc networks.\n      Using DNS-SD in conjunction with Multicast DNS
    provides this,\n      using peer-to-peer multicast instead of a DNS server.\n
    \  It makes more sense to use the existing software that every network\n   needs
    already, instead of deploying an entire parallel system just\n   for service discovery.\n"
  title: Appendix A.  Rationale for Using DNS as a Basis for Service Discovery
- contents:
  - "Appendix B.  Ordering of Service Instance Name Components\n   There have been
    questions about why services are named using DNS\n   Service Instance Names of
    the form:\n      Service Instance Name = <Instance> . <Service> . <Domain>\n   instead
    of:\n      Service Instance Name = <Service> . <Instance> . <Domain>\n   There
    are three reasons why it is beneficial to name service\n   instances with the
    parent domain as the most-significant (rightmost)\n   part of the name, then the
    abstract service type as the next-most\n   significant, and then the specific
    instance name as the least-\n   significant (leftmost) part of the name.  These
    reasons are discussed\n   below in Sections B.1, B.2, and B.3.\n"
  - contents:
    - "B.1.  Semantic Structure\n   The facility being provided by browsing (\"Service
      Instance\n   Enumeration\") is effectively enumerating the leaves of a tree\n
      \  structure.  A given domain offers zero or more services.  For each of\n   those
      service types, there may be zero or more instances of that\n   service.\n   The
      user knows what type of service they are seeking.  (If they are\n   running
      an FTP client, they are looking for FTP servers.  If they\n   have a document
      to print, they are looking for entities that speak\n   some known printing protocol.)
      \ The user knows in which\n   organizational or geographical domain they wish
      to search.  (The user\n   does not want a single flat list of every single printer
      on the\n   planet, even if such a thing were possible.)  What the user does
      not\n   know in advance is whether the service they seek is offered in the\n
      \  given domain, or if so, the number of instances that are offered and\n   the
      names of those instances.\n   Hence, having the instance names be the leaves
      of the tree is\n   consistent with this semantic model.\n   Having the service
      types be the terminal leaves of the tree would\n   imply that the user knows
      the domain name and the name of the service\n   instance, but doesn't have any
      idea what the service does.  We would\n   argue that this is a less useful model.\n"
    title: B.1.  Semantic Structure
  - contents:
    - "B.2.  Network Efficiency\n   When a DNS response contains multiple answers,
      name compression works\n   more effectively if all the names contain a common
      suffix.  If many\n   answers in the packet have the same <Service> and <Domain>,
      then each\n   occurrence of a Service Instance Name can be expressed using only
      the\n   <Instance> part followed by a two-byte compression pointer\n   referencing
      a previous appearance of \"<Service>.<Domain>\".  This\n   efficiency would
      not be possible if the <Service> component appeared\n   first in each name.\n"
    title: B.2.  Network Efficiency
  - contents:
    - "B.3.  Operational Flexibility\n   This name structure allows subdomains to
      be delegated along logical\n   service boundaries.  For example, the network
      administrator at\n   Example Co. could choose to delegate the \"_tcp.example.com.\"\n
      \  subdomain to a different machine, so that the machine handling\n   service
      discovery doesn't have to be the machine that handles other\n   day-to-day DNS
      operations.  (It *can* be the same machine if the\n   administrator so chooses,
      but the administrator is free to make that\n   choice.)  Furthermore, if the
      network administrator wishes to\n   delegate all information related to IPP
      printers to a machine\n   dedicated to that specific task, this is easily done
      by delegating\n   the \"_ipp._tcp.example.com.\" subdomain to the desired machine.
      \ It is\n   also convenient to set security policies on a per-zone/per-subdomain\n
      \  basis.  For example, the administrator may choose to enable DNS\n   Dynamic
      Update [RFC2136] [RFC3007] for printers registering in the\n   \"_ipp._tcp.example.com.\"
      subdomain, but not for other\n   zones/subdomains.  This easy flexibility would
      not exist if the\n   <Service> component appeared first in each name.\n"
    title: B.3.  Operational Flexibility
  title: Appendix B.  Ordering of Service Instance Name Components
- contents:
  - "Appendix C.  What You See Is What You Get\n   Some service discovery protocols
    decouple the true service identifier\n   from the name presented to the user.
    \ The true service identifier\n   used by the protocol is an opaque unique identifier,
    often\n   represented using a long string of hexadecimal digits, which should\n
    \  never be seen by the typical user.  The name presented to the user is\n   merely
    one of the decorative ephemeral attributes attached to this\n   opaque identifier.\n
    \  The problem with this approach is that it decouples user perception\n   from
    network reality:\n   *  What happens if there are two service instances, with
    different\n      unique ids, but they have inadvertently been given the same user-\n
    \     visible name?  If two instances appear in an on-screen list with\n      the
    same name, how does the user know which is which?\n   *  Suppose a printer breaks
    down, and the user replaces it with\n      another printer of the same make and
    model, and configures the new\n      printer with the exact same name as the one
    being replaced:\n      \"Stuart's Printer\".  Now, when the user tries to print,
    the on-\n      screen print dialog tells them that their selected default printer\n
    \     is \"Stuart's Printer\".  When they browse the network to see what\n      is
    there, they see a printer called \"Stuart's Printer\", yet when\n      the user
    tries to print, they are told that the printer \"Stuart's\n      Printer\" can't
    be found.  The hidden internal unique identifier\n      that the software is trying
    to find on the network doesn't match\n      the hidden internal unique identifier
    of the new printer, even\n      though its apparent \"name\" and its logical purpose
    for being there\n      are the same.  To remedy this, the user typically has to
    delete\n      the print queue they have created, and then create a new\n      (apparently
    identical) queue for the new printer, so that the new\n      queue will contain
    the right hidden internal unique identifier.\n      Having all this hidden information
    that the user can't see makes\n      for a confusing and frustrating user experience,
    and exposing\n      long, ugly hexadecimal strings to the user and forcing them
    to\n      understand what they mean is even worse.\n   *  Suppose an existing
    printer is moved to a new department, and\n      given a new name and a new function.
    \ Changing the user-visible\n      name of that piece of hardware doesn't change
    its hidden internal\n      unique identifier.  Users who had previously created
    a print queue\n      for that printer will still be accessing the same hardware
    by its\n      unique identifier, even though the logical service that used to
    be\n      offered by that hardware has ceased to exist.\n   Solving these problems
    requires the user or administrator to be aware\n   of the supposedly hidden unique
    identifier, and to set its value\n   correctly as hardware is moved around, repurposed,
    or replaced,\n   thereby contradicting the notion that it is a hidden identifier
    that\n   human users never need to deal with.  Requiring the user to\n   understand
    this expert behind-the-scenes knowledge of what is\n   *really* going on is just
    one more burden placed on the user when\n   they are trying to diagnose why their
    computers and network devices\n   are not working as expected.\n   These anomalies
    and counterintuitive behaviors can be eliminated by\n   maintaining a tight bidirectional
    one-to-one mapping between what the\n   user sees on the screen and what is really
    happening \"behind the\n   curtain\".  If something is configured incorrectly,
    then that is\n   apparent in the familiar day-to-day user interface that everyone\n
    \  understands, not in some little-known, rarely used \"expert\"\n   interface.\n
    \  In summary: in DNS-SD the user-visible name is also the primary\n   identifier
    for a service.  If the user-visible name is changed, then\n   conceptually the
    service being offered is a different logical service\n   -- even though the hardware
    offering the service may have stayed the\n   same.  If the user-visible name doesn't
    change, then conceptually the\n   service being offered is the same logical service
    -- even if the\n   hardware offering the service is new hardware brought in to
    replace\n   some old equipment.\n   There are certainly arguments on both sides
    of this debate.\n   Nonetheless, the designers of any service discovery protocol
    have to\n   make a choice between having the primary identifiers be hidden, or\n
    \  having them be visible, and these are the reasons that we chose to\n   make
    them visible.  We're not claiming that there are no\n   disadvantages of having
    primary identifiers be visible.  We\n   considered both alternatives, and we believe
    that the few\n   disadvantages of visible identifiers are far outweighed by the
    many\n   problems caused by use of hidden identifiers.\n"
  title: Appendix C.  What You See Is What You Get
- contents:
  - "Appendix D.  Choice of Factory-Default Names\n   When a DNS-SD service is advertised
    using Multicast DNS [RFC6762], if\n   there is already another service of the
    same type advertising with\n   the same name then automatic name conflict resolution
    will occur.  As\n   described in the Multicast DNS specification [RFC6762], upon\n
    \  detecting a conflict, the service should:\n   1.  Automatically select a new
    name (typically by appending or\n       incrementing a digit at the end of the
    name),\n   2.  Try advertising with the new name, and\n   3.  Upon success, record
    the new name in persistent storage.\n   This renaming behavior is very important,
    because it is key to\n   providing user-friendly instance names in the out-of-the-box
    factory-\n   default configuration.  Some product developers apparently have not\n
    \  realized this, because there are some products today where the\n   factory-default
    name is distinctly unfriendly, containing random-\n   looking strings of characters,
    such as the device's Ethernet address\n   in hexadecimal.  This is unnecessary
    and undesirable, because the\n   point of the user-visible name is that it should
    be friendly and\n   meaningful to human users.  If the name is not unique on the
    local\n   network then the protocol will remedy this as necessary.  It is\n   ironic
    that many of the devices with this design mistake are network\n   printers, given
    that these same printers also simultaneously support\n   AppleTalk-over-Ethernet,
    with nice user-friendly default names (and\n   automatic conflict detection and
    renaming).  Some examples of good\n   factory-default names are:\n      Brother
    5070N\n      Canon W2200\n      HP LaserJet 4600\n      Lexmark W840\n      Okidata
    C5300\n      Ricoh Aficio CL7100\n      Xerox Phaser 6200DX\n   To make the case
    for why adding long, ugly factory-unique serial\n   numbers to the end of names
    is neither necessary nor desirable,\n   consider the cases where the user has
    (a) only one network printer,\n   (b) two network printers, and (c) many network
    printers.\n   (a)  In the case where the user has only one network printer,\n
    \       a simple name like (to use a vendor-neutral example)\n        \"Printer\"
    is more user-friendly than an ugly name like\n        \"Printer_0001E68C74FB\".
    \ Appending ugly hexadecimal goop to the\n        end of the name to make sure
    the name is unique is irrelevant to\n        a user who only has one printer anyway.\n
    \  (b)  In the case where the user gets a second network printer, having\n        the
    new printer detect that the name \"Printer\" is already in use\n        and automatically
    name itself \"Printer (2)\" instead, provides a\n        good user experience.
    \ For most users, remembering that the old\n        printer is \"Printer\" and
    the new one is \"Printer (2)\" is easy\n        and intuitive.  Seeing a printer
    called \"Printer_0001E68C74FB\"\n        and another called \"Printer_00306EC3FD1C\"
    is a lot less helpful.\n   (c)  In the case of a network with ten network printers,
    seeing a\n        list of ten names all of the form \"Printer_xxxxxxxxxxxx\" has\n
    \       effectively taken what was supposed to be a list of user-\n        friendly
    rich-text names (supporting mixed case, spaces,\n        punctuation, non-Roman
    characters, and other symbols) and turned\n        it into just about the worst
    user interface imaginable: a list\n        of incomprehensible random-looking
    strings of letters and\n        digits.  In a network with a lot of printers,
    it would be\n        advisable for the people setting up the printers to take
    a\n        moment to give each one a descriptive name, but in the event\n        they
    don't, presenting the users with a list of sequentially\n        numbered printers
    is a much more desirable default user\n        experience than showing a list
    of raw Ethernet addresses.\n"
  title: Appendix D.  Choice of Factory-Default Names
- contents:
  - "Appendix E.  Name Encodings in the Domain Name System\n   Although the original
    DNS specifications [RFC1033] [RFC1034]\n   [RFC1035] recommend that host names
    contain only letters, digits, and\n   hyphens (because of the limitations of the
    typing-based user\n   interfaces of that era), Service Instance Names are not
    host names.\n   Users generally access a service by selecting it from a list\n
    \  presented by a user interface, not by typing in its Service Instance\n   Name.
    \"Clarifications to the DNS Specification\" [RFC2181] directly\n   discusses the
    subject of allowable character set in Section 11 (\"Name\n   syntax\"), and explicitly
    states that the traditional letters-digits-\n   hyphens rule applies only to conventional
    host names:\n      Occasionally it is assumed that the Domain Name System serves
    only\n      the purpose of mapping Internet host names to data, and mapping\n
    \     Internet addresses to host names.  This is not correct, the DNS is\n      a
    general (if somewhat limited) hierarchical database, and can\n      store almost
    any kind of data, for almost any purpose.\n      The DNS itself places only one
    restriction on the particular\n      labels that can be used to identify resource
    records.  That one\n      restriction relates to the length of the label and the
    full name.\n      The length of any one label is limited to between 1 and 63 octets.\n
    \     A full domain name is limited to 255 octets (including the\n      separators).
    \ The zero length full name is defined as representing\n      the root of the
    DNS tree, and is typically written and displayed\n      as \".\".  Those restrictions
    aside, any binary string whatever can\n      be used as the label of any resource
    record.  Similarly, any\n      binary string can serve as the value of any record
    that includes a\n      domain name as some or all of its value (SOA, NS, MX, PTR,
    CNAME,\n      and any others that may be added).  Implementations of the DNS\n
    \     protocols must not place any restrictions on the labels that can\n      be
    used.  In particular, DNS servers must not refuse to serve a\n      zone because
    it contains labels that might not be acceptable to\n      some DNS client programs.\n
    \  Note that just because DNS-based Service Discovery supports arbitrary\n   UTF-8-encoded
    names doesn't mean that any particular user or\n   administrator is obliged to
    make use of that capability.  Any user is\n   free, if they wish, to continue
    naming their services using only\n   letters, digits, and hyphens, with no spaces,
    capital letters, or\n   other punctuation.\n"
  title: Appendix E.  Name Encodings in the Domain Name System
- contents:
  - "Appendix F.  \"Continuous Live Update\" Browsing Model\n   Of particular concern
    in the design of DNS-SD, especially when used\n   in conjunction with ad hoc Multicast
    DNS, is the dynamic nature of\n   service discovery in a changing network environment.
    \ Other service\n   discovery protocols seem to have been designed with an implicit\n
    \  unstated assumption that the usage model is:\n   (a)  client software calls
    the service discovery API,\n   (b)  service discovery code spends a few seconds
    getting a list of\n        instances available at a particular moment in time,
    and then\n   (c)  client software displays the list for the user to select from.\n
    \  Superficially this usage model seems reasonable, but the problem is\n   that
    it's too optimistic.  It only considers the success case, where\n   the software
    immediately finds the service instance the user is\n   looking for.\n   In the
    case where the user is looking for (say) a particular printer,\n   and that printer
    is not turned on or not connected, the user first\n   has to attempt to remedy
    the problem, and then has to click a\n   \"refresh\" button to retry the service
    discovery to find out whether\n   they were successful.  Because nothing happens
    instantaneously in\n   networking, and packets can be lost, necessitating some
    number of\n   retransmissions, a service discovery search is not instantaneous
    and\n   typically takes a few seconds.  As a result, a fairly typical user\n   experience
    is:\n   (a)  display an empty window,\n   (b)  display some animation like a searchlight
    sweeping back and\n        forth for ten seconds, and then\n   (c)  at the end
    of the ten-second search, display a static list\n        showing what was discovered.\n
    \  Every time the user clicks the \"refresh\" button they have to endure\n   another
    ten-second wait, and every time the discovered list is\n   finally shown at the
    end of the ten-second wait, it's already\n   beginning to get stale and out-of-date
    the moment it's displayed on\n   the screen.\n   The service discovery user experience
    that the DNS-SD designers had\n   in mind has some rather different properties:\n
    \  1.  Displaying the initial list of discovered services should be\n       effectively
    instantaneous -- i.e., typically 0.1 seconds, not 10\n       seconds.\n   2.  The
    list of discovered services should not be getting stale and\n       out-of-date
    from the moment it's displayed.  The list should be\n       'live' and should
    continue to update as new services are\n       discovered.  Because of the delays,
    packet losses, and\n       retransmissions inherent in networking, it is to be
    expected that\n       sometimes, after the initial list is displayed showing the\n
    \      majority of discovered services, a few remaining stragglers may\n       continue
    to trickle in during the subsequent few seconds.  Even\n       after this stable
    list has been built and displayed, it should\n       remain 'live' and should
    continue to update.  At any future time,\n       be it minutes, hours, or even
    days later, if a new service of the\n       desired type is discovered, it should
    be displayed in the list\n       automatically, without the user having to click
    a \"refresh\"\n       button or take any other explicit action to update the display.\n
    \  3.  With users getting in the habit of leaving service discovery\n       windows
    open, and expecting them to show a continuous 'live' view\n       of current network
    reality, this gives us an additional\n       requirement: deletion of stale services.
    \ When a service\n       discovery list shows just a static snapshot at a moment
    in time,\n       then the situation is simple: either a service was discovered
    and\n       appears in the list, or it was not and does not.  However, when\n
    \      our list is live and updates continuously with the discovery of\n       new
    services, then this implies the corollary: when a service\n       goes away, it
    needs to *disappear* from the service discovery\n       list.  Otherwise, the
    service discovery list would simply grow\n       monotonically over time, accreting
    stale data, and would require\n       a periodic \"refresh\" (or complete dismissal
    and recreation) to\n       restore correct display.\n   4.  Another consequence
    of users leaving service discovery windows\n       open for extended periods of
    time is that these windows should\n       update not only in response to services
    coming and going, but\n       also in response to changes in configuration and
    connectivity of\n       the client machine itself.  For example, if a user opens
    a\n       service discovery window when the client machine has no network\n       connectivity,
    then the window will typically appear empty, with\n       no discovered services.
    \ When the user connects an Ethernet cable\n       or joins an 802.11 [IEEEW]
    wireless network the window should\n       then automatically populate with discovered
    services, without\n       requiring any explicit user action.  If the user disconnects
    the\n       Ethernet cable or turns off 802.11 wireless then all the services\n
    \      discovered via that network interface should automatically\n       disappear.
    \ If the user switches from one 802.11 wireless access\n       point to another,
    the service discovery window should\n       automatically update to remove all
    the services discovered via\n       the old wireless access point, and add all
    the services\n       discovered via the new one.\n"
  title: Appendix F.  "Continuous Live Update" Browsing Model
- contents:
  - "Appendix G.  Deployment History\n   In July 1997, in an email to the net-thinkers@thumper.vmeng.com\n
    \  mailing list, Stuart Cheshire first proposed the idea of running the\n   AppleTalk
    Name Binding Protocol [RFC6760] over IP.  As a result of\n   this and related
    IETF discussions, the IETF Zeroconf working group\n   was chartered September
    1999.  After various working group\n   discussions and other informal IETF discussions,
    several Internet-\n   Drafts were written that were loosely related to the general
    themes\n   of DNS and multicast, but did not address the service discovery\n   aspect
    of NBP.\n   In April 2000, Stuart Cheshire registered IPv4 multicast address\n
    \  224.0.0.251 with IANA and began writing code to test and develop the\n   idea
    of performing NBP-like service discovery using Multicast DNS,\n   which was documented
    in a group of three Internet-Drafts:\n   o \"Requirements for a Protocol to Replace
    the AppleTalk Name Binding\n      Protocol (NBP)\" [RFC6760] is an overview explaining
    the AppleTalk\n      Name Binding Protocol, because many in the IETF community
    had\n      little first-hand experience using AppleTalk, and confusion in the\n
    \     IETF community about what AppleTalk NBP did was causing confusion\n      about
    what would be required in an IP-based replacement.\n   o \"Discovering Named Instances
    of Abstract Services using DNS\"\n      [NIAS], which later became this document,
    proposed a way to\n      perform NBP-like service discovery using DNS-compatible
    names and\n      record types.\n   o \"Multicast DNS\" [RFC6762] specifies a way
    to transport those DNS-\n      compatible queries and responses using IP multicast,
    for zero-\n      configuration environments where no conventional Unicast DNS\n
    \     server was available.\n   In 2001, an update to Mac OS 9 added resolver
    library support for\n   host name lookup using Multicast DNS.  If the user typed
    a name such\n   as \"MyPrinter.local.\" into any piece of networking software
    that used\n   the standard Mac OS 9 name lookup APIs, then those name lookup APIs\n
    \  would recognize the name as a dot-local name and query for it by\n   sending
    simple one-shot Multicast DNS queries to 224.0.0.251:5353.\n   This enabled the
    user to, for example, enter the name\n   \"MyPrinter.local.\" into their web browser
    in order to view a\n   printer's status and configuration web page, or enter the
    name\n   \"MyPrinter.local.\" into the printer setup utility to create a print\n
    \  queue for printing documents on that printer.\n   Multicast DNS responder software,
    with full service discovery, first\n   began shipping to end users in volume with
    the launch of Mac OS X\n   10.2 \"Jaguar\" in August 2002, and network printer
    makers (who had\n   historically supported AppleTalk in their network printers
    and were\n   receptive to IP-based technologies that could offer them similar\n
    \  ease-of-use) started adopting Multicast DNS shortly thereafter.\n   In September
    2002, Apple released the source code for the\n   mDNSResponder daemon as Open
    Source under Apple's standard Apple\n   Public Source License (APSL).\n   Multicast
    DNS responder software became available for Microsoft\n   Windows users in June
    2004 with the launch of Apple's \"Rendezvous for\n   Windows\" (now \"Bonjour
    for Windows\"), both in executable form (a\n   downloadable installer for end
    users) and as Open Source (one of the\n   supported platforms within Apple's body
    of cross-platform code in the\n   publicly accessible mDNSResponder CVS source
    code repository) [BJ].\n   In August 2006, Apple re-licensed the cross-platform
    mDNSResponder\n   source code under the Apache License, Version 2.0.\n   In addition
    to desktop and laptop computers running Mac OS X and\n   Microsoft Windows, Multicast
    DNS is now implemented in a wide range\n   of hardware devices, such as Apple's
    \"AirPort\" wireless base\n   stations, iPhone and iPad, and in home gateways
    from other vendors,\n   network printers, network cameras, TiVo DVRs, etc.\n   The
    Open Source community has produced many independent\n   implementations of Multicast
    DNS, some in C like Apple's\n   mDNSResponder daemon, and others in a variety
    of different languages\n   including Java, Python, Perl, and C#/Mono.\n   In January
    2007, the IETF published the Informational RFC \"Link-Local\n   Multicast Name
    Resolution (LLMNR)\" [RFC4795], which is substantially\n   similar to Multicast
    DNS, but incompatible in some small but\n   important ways.  In particular, the
    LLMNR design explicitly excluded\n   support for service discovery, which made
    it an unsuitable candidate\n   for a protocol to replace AppleTalk NBP [RFC6760].\n
    \  While the original focus of Multicast DNS and DNS-Based Service\n   Discovery
    was for zero-configuration environments without a\n   conventional Unicast DNS
    server, DNS-Based Service Discovery also\n   works using Unicast DNS servers,
    using DNS Update [RFC2136] [RFC3007]\n   to create service discovery records and
    standard DNS queries to query\n   for them.  Apple's Back to My Mac service, launched
    with Mac OS X\n   10.5 \"Leopard\" in October 2007, uses DNS-Based Service Discovery
    over\n   Unicast DNS [RFC6281].\n   In June 2012, Google's Android operating system
    added native support\n   for DNS-SD and Multicast DNS with the android.net.nsd.NsdManager\n
    \  class in Android 4.1 \"Jelly Bean\" (API Level 16) [NSD].\n"
  title: Appendix G.  Deployment History
- contents:
  - "Authors' Addresses\n   Stuart Cheshire\n   Apple Inc.\n   1 Infinite Loop\n   Cupertino,
    CA  95014\n   USA\n   Phone: +1 408 974 3207\n   EMail: cheshire@apple.com\n   Marc
    Krochmal\n   Apple Inc.\n   1 Infinite Loop\n   Cupertino, CA  95014\n   USA\n
    \  Phone: +1 408 974 4368\n   EMail: marc@apple.com\n"
  title: Authors' Addresses
