- title: __initial_text__
  contents:
  - '                 Application Aspects of IPv6 Transition

    '
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo provides information for the Internet community.\
    \  It does\n   not specify an Internet standard of any kind.  Distribution of\
    \ this\n   memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (2005).\n"
- title: Abstract
  contents:
  - "Abstract\n   As IPv6 networks are deployed and the network transition is\n  \
    \ discussed, one should also consider how to enable IPv6 support in\n   applications\
    \ running on IPv6 hosts, and the best strategy to develop\n   IP protocol support\
    \ in applications.  This document specifies\n   scenarios and aspects of application\
    \ transition.  It also proposes\n   guidelines on how to develop IP version-independent\
    \ applications\n   during the transition period.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction .................................................\
    \  3\n   2.  Overview of IPv6 Application Transition ......................  3\n\
    \   3.  Problems with IPv6 Application Transition ....................  5\n  \
    \     3.1.  IPv6 Support in the OS and Applications Are Unrelated...  5\n    \
    \   3.2.  DNS Does Not Indicate Which IP Version Will Be Used ....  6\n      \
    \ 3.3.  Supporting Many Versions of an Application Is Difficult.  6\n   4.  Description\
    \ of Transition Scenarios and Guidelines ...........  7\n       4.1.  IPv4 Applications\
    \ in a Dual-Stack Node .................  7\n       4.2.  IPv6 Applications in\
    \ a Dual-Stack Node .................  8\n       4.3.  IPv4/IPv6 Applications\
    \ in a Dual-Stack Node ............ 11\n       4.4.  IPv4/IPv6 Applications in\
    \ an IPv4-only Node ............ 12\n   5.  Application Porting Considerations\
    \ ........................... 12\n       5.1.  Presentation Format for an IP Address\
    \ .................. 13\n       5.2.  Transport Layer API ....................................\
    \ 14\n       5.3.  Name and Address Resolution ............................ 15\n\
    \       5.4.  Specific IP Dependencies ............................... 16\n  \
    \           5.4.1.  IP Address Selection ........................... 16\n    \
    \         5.4.2.  Application Framing ............................ 16\n      \
    \       5.4.3.  Storage of IP addresses ........................ 17\n       5.5.\
    \  Multicast Applications ................................. 17\n   6.  Developing\
    \ IP Version - Independent Applications ............. 18\n       6.1.  IP Version\
    \ - Independent Structures..................... 18\n       6.2.  IP Version -\
    \ Independent APIs........................... 19\n             6.2.1.  Example\
    \ of Overly Simplistic TCP Server\n                     Application ....................................\
    \ 20\n             6.2.2.  Example of Overly Simplistic TCP Client\n         \
    \            Application .................................... 21\n           \
    \  6.2.3.  Binary/Presentation Format Conversion .......... 22\n       6.3.  Iterated\
    \ Jobs for Finding the Working Address .......... 23\n             6.3.1.  Example\
    \ of TCP Server Application .............. 23\n             6.3.2.  Example of\
    \ TCP Client Application .............. 25\n   7.  Transition Mechanism Considerations\
    \ .......................... 26\n   8.  Security Considerations ......................................\
    \ 26\n   9.  Acknowledgments .............................................. 27\n\
    \   10. References ................................................... 27\n  \
    \ Appendix A.  Other Binary/Presentation Format Conversions ........ 30\n    \
    \   A.1.  Binary to Presentation Using inet_ntop() ............... 30\n      \
    \ A.2.  Presentation to Binary Using inet_pton() ............... 31\n   Authors'\
    \ Addresses ............................................... 32\n   Full Copyright\
    \ Statement ......................................... 33\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   As IPv6 is introduced in the IPv4-based Internet, several\
    \ general\n   issues will arise, such as routing, addressing, DNS, and scenarios.\n\
    \   An important key to a successful IPv6 transition is compatibility\n   with\
    \ the large installed base of IPv4 hosts and routers.  This issue\n   has already\
    \ been extensively studied, and work is still in progress.\n   [2893BIS] describes\
    \ the basic transition mechanisms: dual-stack\n   deployment and tunneling.  Various\
    \ other kinds of mechanisms have\n   been developed for the transition to an IPv6\
    \ network.  However, these\n   transition mechanisms take no stance on whether\
    \ applications support\n   IPv6.\n   This document specifies application aspects\
    \ of IPv6 transition.  Two\n   inter-related topics are covered:\n      1. How\
    \ different network transition techniques affect\n         applications, and strategies\
    \ for applications to support IPv6\n         and IPv4.\n      2. How to develop\
    \ IPv6-capable or protocol-independent\n         applications (\"application porting\
    \ guidelines\") using standard\n         APIs [RFC3493][RFC3542].\n   In the context\
    \ of this document, the term \"application\" covers all\n   kinds of applications,\
    \ but the focus is on those network applications\n   which have been developed\
    \ using relatively low-level APIs (such as\n   the \"C\" language, using standard\
    \ libraries).  Many such applications\n   could be command-line driven, but that\
    \ is not a requirement.\n   Applications will have to be modified to support IPv6\
    \ (and IPv4) by\n   using one of a number of techniques described in sections\
    \ 2 - 4.\n   Guidelines for developing such applications are presented in sections\n\
    \   5 and 6.\n"
- title: 2.  Overview of IPv6 Application Transition
  contents:
  - "2.  Overview of IPv6 Application Transition\n   The transition of an application\
    \ can be classified by using four\n   different cases (excluding the first case\
    \ when there is no IPv6\n   support in either the application or the operating\
    \ system):\n      +-------------------+\n      |       appv4       | (appv4 -\
    \ IPv4-only applications)\n      +-------------------+\n      | TCP / UDP / others|\
    \ (transport protocols - TCP, UDP,\n      +-------------------+  SCTP, DCCP, etc.)\n\
    \      |    IPv4 | IPv6    | (IP protocols supported/enabled in the OS)\n    \
    \  +-------------------+\n      Case 1. IPv4 applications in a dual-stack node.\n\
    \      +-------------------+ (appv4 - IPv4-only applications)\n      |  appv4\
    \  |  appv6  | (appv6 - IPv6-only applications)\n      +-------------------+\n\
    \      | TCP / UDP / others| (transport protocols - TCP, UDP,\n      +-------------------+\
    \             SCTP, DCCP, etc.)\n      |    IPv4 | IPv6    | (IP protocols supported/enabled\
    \ in the OS)\n      +-------------------+\n      Case 2. IPv4-only applications\
    \ and IPv6-only applications\n              in a dual-stack node.\n      +-------------------+\n\
    \      |     appv4/v6      | (appv4/v6 - applications supporting\n      +-------------------+\
    \             both IPv4 and IPv6)\n      | TCP / UDP / others| (transport protocols\
    \ - TCP, UDP,\n      +-------------------+             SCTP, DCCP, etc.)\n   \
    \   |    IPv4 | IPv6    | (IP protocols supported/enabled in the OS)\n      +-------------------+\n\
    \      Case 3. Applications supporting both IPv4 and IPv6\n              in a\
    \ dual-stack node.\n      +-------------------+\n      |     appv4/v6      | (appv4/v6\
    \ - applications supporting\n      +-------------------+             both IPv4\
    \ and IPv6)\n      | TCP / UDP / others| (transport protocols - TCP, UDP,\n  \
    \    +-------------------+             SCTP, DCCP, etc.)\n      |       IPv4 \
    \       | (IP protocols supported/enabled in the OS)\n      +-------------------+\n\
    \      Case 4. Applications supporting both IPv4 and IPv6\n              in an\
    \ IPv4-only node.\n         Figure 1. Overview of Application Transition\n   \
    \  Figure 1 shows the cases of application transition.\n      Case 1:  IPv4-only\
    \ applications in a dual-stack node.\n               IPv6 protocol is introduced\
    \ in a node, but\n               applications are not yet ported to support IPv6.\n\
    \      Case 2:  IPv4-only applications and IPv6-only applications\n          \
    \     in a dual-stack node.\n               Applications are ported for IPv6-only.\
    \  Therefore\n               there are two similar applications, one for each\n\
    \               protocol version (e.g., ping and ping6).\n      Case 3:  Applications\
    \ supporting both IPv4 and IPv6 in a dual\n               stack node.\n      \
    \         Applications are ported for both IPv4 and IPv6 support.\n          \
    \     Therefore, the existing IPv4 applications can be\n               removed.\n\
    \      Case 4:  Applications supporting both IPv4 and IPv6 in an\n           \
    \    IPv4-only node.\n               Applications are ported for both IPv4 and\
    \ IPv6 support,\n               but the same applications may also have to work\
    \ when\n               IPv6 is not being used (e.g., disabled from the OS).\n\
    \   The first two cases are not interesting in the longer term; only few\n   applications\
    \ are inherently IPv4- or IPv6-specific, and should work\n   with both protocols\
    \ without having to care about which one is being\n   used.\n"
- title: 3.  Problems with IPv6 Application Transition
  contents:
  - "3.  Problems with IPv6 Application Transition\n   There are several reasons why\
    \ the transition period between IPv4 and\n   IPv6 applications may not be straightforward.\
    \  These issues are\n   described in this section.\n"
- title: 3.1.  IPv6 Support in the OS and Applications Are Unrelated
  contents:
  - "3.1.  IPv6 Support in the OS and Applications Are Unrelated\n   Considering the\
    \ cases described in the previous section, IPv4 and\n   IPv6 protocol stacks are\
    \ likely to co-exist in a node for a long\n   time.\n   Similarly, most applications\
    \ are expected to be able to handle both\n   IPv4 and IPv6 during another long\
    \ period.  A dual-stack operating\n   system is not intended to have both IPv4\
    \ and IPv6 applications.\n   Therefore, IPv6-capable application transition may\
    \ be independent of\n   protocol stacks in a node.\n   Applications capable of\
    \ both IPv4 and IPv6 will  probably have to\n   work properly in IPv4-only nodes\
    \ (whether the IPv6 protocol is\n   completely disabled or there is no IPv6 connectivity\
    \ at all).\n"
- title: 3.2.  DNS Does Not Indicate Which IP Version Will Be Used
  contents:
  - "3.2.  DNS Does Not Indicate Which IP Version Will Be Used\n   In a node, the\
    \ DNS name resolver gathers the list of destination\n   addresses.  DNS queries\
    \ and responses are sent by using either IPv4\n   or IPv6 to carry the queries,\
    \ regardless of the protocol version of\n   the data records [DNSTRANS].\n   The\
    \ DNS name resolution issue related to application transition is\n   that by only\
    \ doing a DNS name lookup a client application can not be\n   certain of the version\
    \ of the peer application.  For example, if a\n   server application does not\
    \ support IPv6 yet but runs on a dual-stack\n   machine for other IPv6 services,\
    \ and this host is listed with an AAAA\n   record in the DNS, the client application\
    \ will fail to connect to the\n   server application.  This is caused by a mismatch\
    \ between the DNS\n   query result (i.e., IPv6 addresses) and a server application\
    \ version\n   (i.e., IPv4).\n   Using SRV records would avoid these problems.\
    \  Unfortunately, they\n   are not used widely enough to be applicable in most\
    \ cases.  Hence an\n   operational solution is to use \"service names\" in the\
    \ DNS.  If a node\n   offers multiple services, but only some of them over IPv6,\
    \ a DNS name\n   may be added for each of these services or group of services\
    \ (with\n   the associated A/AAAA records), not just a single name for the\n \
    \  physical machine, also including the AAAA records.  However, the\n   applications\
    \ cannot depend on this operational practice.\n   The application should request\
    \ all IP addresses without address\n   family constraints and try all the records\
    \ returned from the DNS, in\n   some order, until a working address is found.\
    \  In particular, the\n   application has to be able to handle all IP versions\
    \ returned from\n   the DNS.  This issue is discussed in more detail in [DNSOPV6].\n"
- title: 3.3.  Supporting Many Versions of an Application is Difficult
  contents:
  - "3.3.  Supporting Many Versions of an Application is Difficult\n   During the\
    \ application transition period, system administrators may\n   have various versions\
    \ of the same application (an IPv4-only\n   application, an IPv6-only application,\
    \ or an application supporting\n   both IPv4 and IPv6).\n   Typically one cannot\
    \ know which IP versions must be supported prior\n   to doing a DNS lookup *and*\
    \ trying (see section 3.2) the addresses\n   returned.  Therefore if multiple\
    \ versions of the same application are\n   available, the local users have difficulty\
    \ selecting the right\n   version supporting the exact IP version required.\n\
    \   To avoid problems with one application not supporting the specified\n   protocol\
    \ version, it is desirable to have hybrid applications\n   supporting both.\n\
    \   An alternative approach for local client applications could be to\n   have\
    \ a \"wrapper application\" that performs certain tasks (such as\n   figuring\
    \ out which protocol version will be used) and calls the\n   IPv4/IPv6-only applications\
    \ as necessary.  This application would\n   perform connection establishment (or\
    \ similar tasks) and pass the\n   opened socket to another application.  However,\
    \ as applications such\n   as this would have to do more than just perform a DNS\
    \ lookup or\n   determine the literal IP address given, they will become complex\
    \ --\n   likely much more so than a hybrid application.  Furthermore, writing\n\
    \   \"wrapping\" applications that perform complex operations with IP\n   addresses\
    \ (such as FTP clients) might be even more challenging or\n   even impossible.\
    \  In short, wrapper applications do not look like a\n   robust approach for application\
    \ transition.\n"
- title: 4.  Description of Transition Scenarios and Guidelines
  contents:
  - "4.  Description of Transition Scenarios and Guidelines\n   Once the IPv6 network\
    \ is deployed, applications supporting IPv6 can\n   use IPv6 network services\
    \ to establish IPv6 connections.  However,\n   upgrading every node to IPv6 at\
    \ the same time is not feasible, and\n   transition from IPv4 to IPv6 will be\
    \ a gradual process.\n   Dual-stack nodes provide one solution to maintaining\
    \ IPv4\n   compatibility in unicast communications.  In this section we will\n\
    \   analyze different application transition scenarios (as introduced in\n   section\
    \ 2) and guidelines for maintaining interoperability between\n   applications\
    \ running in different types of nodes.\n   Note that the first two cases, IPv4-only\
    \ and IPv6-only applications,\n   are not interesting in the longer term; only\
    \ few applications are\n   inherently IPv4- or IPv6-specific, and should work\
    \ with both\n   protocols without having to care about which one is being used.\n"
- title: 4.1.  IPv4 Applications in a Dual-Stack Node
  contents:
  - "4.1.  IPv4 Applications in a Dual-Stack Node\n   In this scenario, the IPv6 protocol\
    \ is added in a node, but IPv6-\n   capable applications aren't yet available\
    \ or installed.  Although the\n   node implements the dual stack, IPv4 applications\
    \ can only manage\n   IPv4 communications and accept/establish connections from/to\
    \ nodes\n   that implement an IPv4 stack.\n   To allow an application to communicate\
    \ with other nodes using IPv6,\n   the first priority is to port applications\
    \ to IPv6.\n   In some cases (e.g., when no source code is available), existing\
    \ IPv4\n   applications can work if the Bump-in-the-Stack [BIS] or Bump-in-the-\n\
    \   API [BIA] mechanism is installed in the node.  We strongly recommend\n   that\
    \ application developers not use these mechanisms when application\n   source\
    \ code is available.  Also, they should not be used as an excuse\n   not to port\
    \ software or to delay porting.\n   When [BIA] or [BIS] is used, the problem described\
    \ in section 3.2\n   arises - (the IPv4 client in a [BIS]/[BIA] node tries to\
    \ connect to\n   an IPv4 server in a dual stack system).  However, one can rely\
    \ on the\n   [BIA]/[BIS] mechanism, which should cycle through all the addresses\n\
    \   instead of applications.\n   [BIS] and [BIA] do not work with all kinds of\
    \ applications - in\n   particular, with applications that exchange IP addresses\
    \ as\n   application data (e.g., FTP).  These mechanisms provide IPv4\n   temporary\
    \ addresses to the applications and locally make a\n   translation between IPv4\
    \ and IPv6 communication.  Therefore, these\n   IPv4 temporary addresses are only\
    \ valid in the node scope.\n"
- title: 4.2.  IPv6 Applications in a Dual-Stack Node
  contents:
  - "4.2.  IPv6 Applications in a Dual-Stack Node\n   As we have seen in the previous\
    \ section, applications should be\n   ported to IPv6.  The easiest way to port\
    \ an IPv4 application is to\n   substitute the old IPv4 API references with the\
    \ new IPv6 APIs with\n   one-to-one mapping.  This way the application will be\
    \ IPv6-only.\n   This IPv6-only source code cannot work in IPv4-only nodes, so\
    \ the old\n   IPv4 application should be maintained in these nodes.  This\n  \
    \ necessitates having two similar applications working with different\n   protocol\
    \ versions, depending on the node they are running (e.g.,\n   telnet and telnet6).\
    \  This case is undesirable, as maintaining two\n   versions of the same source\
    \ code per application could be difficult.\n   This approach would also cause\
    \ problems for users having to select\n   which version of the application to\
    \ use, as described in section 3.3.\n   Most implementations of dual stack allow\
    \ IPv6-only applications to\n   interoperate with both IPv4 and IPv6 nodes.  IPv4\
    \ packets going to\n   IPv6 applications on a dual-stack node reach their destination\n\
    \   because their addresses are mapped by using IPv4-mapped IPv6\n   addresses:\
    \ the IPv6 address ::FFFF:x.y.z.w represents the IPv4\n   address x.y.z.w.\n \
    \     +----------------------------------------------+\n      | +------------------------------------------+\
    \ |\n      | |                                          | |\n      | |       \
    \ IPv6-only applications            | |\n      | |                           \
    \               | |\n      | +------------------------------------------+ |\n\
    \      |                      |                       |\n      | +------------------------------------------+\
    \ |\n      | |                                          | |\n      | |   TCP /\
    \ UDP / others (SCTP, DCCP, etc.)  | |\n      | |                            \
    \              | |\n      | +------------------------------------------+ |\n \
    \     |    IPv4-mapped    |        |    IPv6         |\n      |  IPv6 addresses\
    \   |        |   addresses     |\n      | +--------------------+ +-------------------+\
    \ |\n      | |        IPv4        | |      IPv6         | |\n      | +--------------------+\
    \ +-------------------+ |\n      |   IPv4       |                 |          \
    \   |\n      |   addresses  |                 |             |\n      +--------------|-----------------|-------------+\n\
    \                     |                 |\n                IPv4 packets      IPv6\
    \ packets\n   We will analyze the behaviour of IPv6-applications that exchange\
    \ IPv4\n   packets with IPv4 applications by using the client/server model.  We\n\
    \   consider the default case to be when the IPV6_V6ONLY socket option\n   has\
    \ not been set.  In these dual-stack nodes, this default behavior\n   allows a\
    \ limited amount of IPv4 communication using the IPv4-mapped\n   IPv6 addresses.\n\
    \      IPv6-only server:\n         When an IPv4 client application sends data\
    \ to an IPv6-only\n         server application running on a dual-stack node by\
    \ using the\n         wildcard address, the IPv4 client address is interpreted\
    \ as the\n         IPv4-mapped IPv6 address in the dual-stack node.  This allows\n\
    \         the IPv6 application to manage the communication.  The IPv6\n      \
    \   server will use this mapped address as if it were a regular\n         IPv6\
    \ address, and a usual IPv6 connection.  However, IPv4\n         packets will\
    \ be exchanged between the nodes.  Kernels with dual\n         stack properly\
    \ interpret IPv4-mapped IPv6 addresses as IPv4\n         ones, and vice versa.\n\
    \      IPv6-only client:\n         IPv6-only client applications in a dual-stack\
    \ node will not\n         receive IPv4-mapped addresses from the hostname resolution\
    \ API\n         functions unless a special hint, AI_V4MAPPED, is given.  If it\n\
    \         is, the IPv6 client will use the returned mapped address as if\n   \
    \      it were a regular IPv6 address, and a usual IPv6 connection.\n        \
    \ However, IPv4 packets will be exchanged between applications.\n   Respectively,\
    \ with IPV6_V6ONLY set, an IPv6-only server application\n   will only communicate\
    \ with IPv6 nodes, and an IPv6-only client only\n   with IPv6 servers, as the\
    \ mapped addresses have been disabled.  This\n   option could be useful if applications\
    \ use new IPv6 features such as\n   Flow Label.  If communication with IPv4 is\
    \ needed, either IPV6_V6ONLY\n   must not be used, or dual-stack applications\
    \ must be used, as\n   described in section 4.3.\n   Some implementations of dual-stack\
    \ do not allow IPv4-mapped IPv6\n   addresses to be used for interoperability\
    \ between IPv4 and IPv6\n   applications.  In these cases, there are two ways\
    \ to handle the\n   problem:\n      1. Deploy two different versions of the application\
    \ (possibly\n         attached with '6' in the name).\n      2. Deploy just one\
    \ application supporting both protocol versions\n         as described in the\
    \ next section.\n   The first method is not recommended because of a significant\
    \ number\n   of problems associated with selecting the right applications.  These\n\
    \   problems are described in sections 3.2 and 3.3.\n   Therefore, there are two\
    \ distinct cases to consider when writing one\n   application to support both\
    \ protocols:\n      1. Whether the application can (or should) support both IPv4\
    \ and\n         IPv6 through IPv4-mapped IPv6 addresses or the applications\n\
    \         should support both explicitly (see section 4.3), and\n      2. Whether\
    \ the systems in which the applications are used support\n         IPv6 (see section\
    \ 4.4).\n   Note that some systems will disable (by default) support for internal\n\
    \   IPv4-mapped IPv6 addresses.  The security concerns regarding these\n   are\
    \ legitimate, but disabling them internally breaks one transition\n   mechanism\
    \ for server applications originally written to bind() and\n   listen() to a single\
    \ socket by using a wildcard address.  This forces\n   the software developer\
    \ to rewrite the daemon to create two separate\n   sockets, one for IPv4 only\
    \ and the other for IPv6 only, and then to\n   use select().  However, mapping-enabling\
    \ of IPv4 addresses on any\n   particular system is controlled by the OS owner\
    \ and not necessarily\n   by a developer.  This complicates developers' work,\
    \ as they now have\n   to rewrite the daemon network code to handle both environments,\
    \ even\n   for the same OS.\n"
- title: 4.3.  IPv4/IPv6 Applications in a Dual-Stack Node
  contents:
  - "4.3.  IPv4/IPv6 Applications in a Dual-Stack Node\n   Applications should be\
    \ ported to support both IPv4 and IPv6.  Over\n   time, the existing IPv4-only\
    \ applications could be removed.  As we\n   have only one version of each application,\
    \ the source code will\n   typically be easy to maintain and to modify, and there\
    \ are no\n   problems managing which application to select for which\n   communication.\n\
    \   This transition case is the most advisable.  During the IPv6\n   transition\
    \ period, applications supporting both IPv4 and IPv6 should\n   be able to communicate\
    \ with other applications, irrespective of the\n   version of the protocol stack\
    \ or the application in the node.  Dual\n   applications allow more interoperability\
    \ between heterogeneous\n   applications and nodes.\n   If the source code is\
    \ written in a protocol-independent way, without\n   dependencies on either IPv4\
    \ or IPv6, applications will be able to\n   communicate with any combination of\
    \ applications and types of nodes.\n   Implementations typically prefer IPv6 by\
    \ default if the remote node\n   and application support it.  However, if IPv6\
    \ connections fail,\n   version-independent applications will automatically try\
    \ IPv4 ones.\n   The resolver returns a list of valid addresses for the remote\
    \ node,\n   and applications can iterate through all of them until connection\n\
    \   succeeds.\n   Application writers should be aware of this protocol ordering,\
    \ which\n   is typically the default, but the applications themselves usually\n\
    \   need not be [RFC3484].\n   If the source code is written in a protocol-dependent\
    \ way, the\n   application will support IPv4 and IPv6 explicitly by using two\n\
    \   separate sockets.  Note that there are some differences in bind()\n   implementation\
    \ - that is,  in whether one can first bind to IPv6\n   wildcard addresses, and\
    \ then to those for IPv4.  Writing applications\n   that cope with this can be\
    \ a pain.  Implementing IPV6_V6ONLY\n   simplifies this.  The IPv4 wildcard bind\
    \ fails on some systems\n   because the IPv4 address space is embedded into IPv6\
    \ address space\n   when IPv4-mapped IPv6 addresses are used.\n   A more detailed\
    \ porting guideline is described in section 6.\n"
- title: 4.4.  IPv4/IPv6 Applications in an IPv4-Only Node
  contents:
  - "4.4.  IPv4/IPv6 Applications in an IPv4-Only Node\n   As the transition is likely\
    \ to take place over a longer time frame,\n   applications already ported to support\
    \ both IPv4 and IPv6 may be run\n   on IPv4-only nodes.  This would typically\
    \ be done to avoid supporting\n   two application versions for older and newer\
    \ operating systems, or to\n   support a case in which the user wants to disable\
    \ IPv6 for some\n   reason.\n   The most important case is the application support\
    \ on systems where\n   IPv6 support can be dynamically enabled or disabled by\
    \ the users.\n   Applications on such a system should be able to handle a situation\n\
    \   IPv6 would not be enabled.  Another scenario is when an application\n   is\
    \ deployed on older systems that do not support IPv6 at all (even\n   the basic\
    \ APIs such as getaddrinfo).  In this case, the application\n   designer has to\
    \ make a case-by-case judgment call as to whether it\n   makes sense to have compile-time\
    \ toggle between an older and a newer\n   API (having to support both in the code),\
    \ or whether to provide\n   getaddrinfo etc. function support on older platforms\
    \ as part of the\n   application libraries.\n   Depending on application/operating\
    \ system support, some may want to\n   ignore this case, but usually no assumptions\
    \ can be made, and\n   applications should also work in this scenario.\n   An\
    \ example is an application that issues a socket() command, first\n   trying AF_INET6\
    \ and then AF_INET.  However, if the kernel does not\n   have IPv6 support, the\
    \ call will result in an EPROTONOSUPPORT or\n   EAFNOSUPPORT error.  Typically,\
    \ errors like these lead to exiting the\n   socket loop, and AF_INET will not\
    \ even be tried.  The application\n   will need to handle this case or build the\
    \ loop so that errors are\n   ignored until the last address family.\n   This\
    \ case is just an extension of the IPv4/IPv6 support in the\n   previous case,\
    \ covering one relatively common but often-ignored case.\n"
- title: 5.  Application Porting Considerations
  contents:
  - "5.  Application Porting Considerations\n   The minimum changes for IPv4 applications\
    \ to work with IPv6 are based\n   on the different size and format of IPv4 and\
    \ IPv6 addresses.\n   Applications have been developed with IPv4 network protocol\
    \ in mind.\n   This assumption has resulted in many IP dependencies through source\n\
    \   code.\n   The following list summarizes the more common IP version dependencies\n\
    \   in applications:\n      a) Presentation format for an IP address:  An ASCII\
    \ string that\n         represents the IP address, a dotted-decimal string for\
    \ IPv4,\n         and a hexadecimal string for IPv6.\n      b) Transport layer\
    \ API: Functions to establish communications and\n         to exchange information.\n\
    \      c) Name and address resolution: Conversion functions between\n        \
    \ hostnames and IP addresses.\n      d) Specific IP dependencies: More specific\
    \ IP version\n         dependencies, such as IP address selection, application\n\
    \         framing, and storage of IP addresses.\n      e) Multicast applications:\
    \ One must find the IPv6 equivalents to\n         the IPv4 multicast addresses\
    \ and use the right socket\n         configuration options.\n   The following\
    \ subsections describe the problems with the\n   aforementioned IP version dependencies.\
    \  Although application source\n   code can be ported to IPv6 with minimum changes\
    \ related to IP\n   addresses, some recommendations are given to modify the source\
    \ code\n   in a protocol-independent way, which will allow applications to work\n\
    \   with both IPv4 and IPv6.\n"
- title: 5.1.  Presentation Format for an IP Address
  contents:
  - "5.1.  Presentation Format for an IP Address\n   Many applications use IP addresses\
    \ to identify network nodes and to\n   establish connections to destination addresses.\
    \  For instance, using\n   the client/server model, clients usually need an IP\
    \ address as an\n   application parameter to connect to a server.  This IP address\
    \ is\n   usually provided in the presentation format, as a string.  There are\n\
    \   two problems when porting the presentation format for an IP address:\n   the\
    \ allocated memory and the management of the presentation format.\n   Usually,\
    \ the memory allocated to contain an IPv4 address\n   representation as a string\
    \ is unable to contain an IPv6 address.\n   Applications should be modified to\
    \ prevent buffer overflows made\n   possible by the larger IPv6 address.\n   IPv4\
    \ and IPv6 do not use the same presentation format.  IPv4 uses a\n   dot (.) to\
    \ separate the four octets written in decimal notation, and\n   IPv6 uses a colon\
    \ (:) to separate each pair of octets written in\n   hexadecimal notation [RFC3513].\
    \  In cases where one must be able to\n   specify, for example, port numbers with\
    \ the address (see below), it\n   may be desirable to require placing the address\
    \ inside the square\n   brackets [TextRep].\n   A particular problem with IP address\
    \ parsers comes when the input is\n   actually a combination of IP address and\
    \ port number.  With IPv4\n   these are often coupled with a colon; for example,\
    \ \"192.0.2.1:80\".\n   However, this approach would be ambiguous with IPv6, as\
    \ colons are\n   already used to structure the address.\n   Therefore, the IP\
    \ address parsers that take the port number separated\n   with a colon should\
    \ distinguish IPv6 addresses somehow.  One way is\n   to enclose the address in\
    \ brackets, as is done with Uniform Resource\n   Locators (URLs) [RFC2732]; for\
    \ example, http://[2001:db8::1]:80.\n   Some applications also need to specify\
    \ IPv6 prefixes and lengths:\n   The prefix length should be inserted outside\
    \ of the square brackets,\n   if used; for example, [2001:db8::]/64 or 2001:db8::/64\
    \ and not\n   [2001:db8::/64].  Note that prefix/length notation is syntactically\n\
    \   indistinguishable from a legal URI; therefore, the prefix/length\n   notation\
    \ must not be used when it isn't clear from the context that\n   it's used to\
    \ specify the prefix and length and not, for example, a\n   URI.\n   In some specific\
    \ cases, it may be necessary to give a zone identifier\n   as part of the address;\
    \ for example, fe80::1%eth0.  In general,\n   applications should not need to\
    \ parse these identifiers.\n   The IP address parsers should support enclosing\
    \ the IPv6 address in\n   brackets, even when the address is not used in conjunction\
    \ with a\n   port number.  Requiring that the user always give a literal IP\n\
    \   address enclosed in brackets is not recommended.\n   Note that some applications\
    \ may also represent IPv6 address literals\n   differently; for example, SMTP\
    \ [RFC2821] uses [IPv6:2001:db8::1].\n   Note that the use of address literals\
    \ is strongly discouraged for\n   general-purpose direct input to the applications.\
    \  Host names and DNS\n   should be used instead.\n"
- title: 5.2.  Transport Layer API
  contents:
  - "5.2.  Transport Layer API\n   Communication applications often include a transport\
    \ module that\n   establishes communications.  Usually this module manages everything\n\
    \   related to communications and uses a transport-layer API, typically\n   as\
    \ a network library.  When an application is ported to IPv6, most\n   changes\
    \ should be made in this application transport module in order\n   to be adapted\
    \ to the new IPv6 API.\n   In the general case, porting an existing application\
    \ to IPv6 requires\n   an examination of the following issues related to the API:\n\
    \      -  Network Information Storage: IP address Data Structures\n         The\
    \ new structures must contain 128-bit IP addresses.  The use\n         of generic\
    \ address structures, which can store any address\n         family, is recommended.\n\
    \         Sometimes special addresses are hard-coded in the application\n    \
    \     source code.  Developers should pay attention to these in order\n      \
    \   to use the new address format.  Some of these special IP\n         addresses\
    \ are wildcard local, loopback, and broadcast.  IPv6\n         does not have the\
    \ broadcast addresses, so applications can use\n         multicast instead.\n\
    \      -  Address Conversion Functions\n         The address conversion functions\
    \ convert the binary address\n         representation to the presentation format\
    \ and vice versa.  The\n         new conversion functions are specified to the\
    \ IPv6 address\n         format.\n      -  Communication API Functions\n     \
    \    These functions manage communications.  Their signatures are\n         defined\
    \ based on a generic socket address structure.  The same\n         functions are\
    \ valid for IPv6; however, the IP address data\n         structures used when\
    \ calling these functions require the\n         updates.\n      -  Network Configuration\
    \ Options\n         These are used when different communication models are\n \
    \        configured for Input/Output (I/O) operations\n         (blocking/nonblocking,\
    \ I/O multiplexing, etc.) and should be\n         translated for IPv6.\n"
- title: 5.3.  Name and Address Resolution
  contents:
  - "5.3.  Name and Address Resolution\n   From the application point of view, the\
    \ name and address resolution\n   is a system-independent process.  An application\
    \ calls functions in a\n   system library, the resolver, which is linked into\
    \ the application\n   when it is built.  However, these functions use IP address\n\
    \   structures, that are protocol dependent and must be reviewed to\n   support\
    \ the new IPv6 resolution calls.\n   With IPv6, there are two new basic resolution\
    \ functions,\n   getaddrinfo() and getnameinfo().  The first returns a list of\
    \ all\n   configured IP addresses for a hostname.  These queries can be\n   constrained\
    \ to one protocol family; for instance, only IPv4 or only\n   IPv6 addresses.\
    \  However, it is recommended that all configured IP\n   addresses be obtained\
    \ to allow applications to work with every kind\n   of node.  The second function\
    \ returns the hostname associated to an\n   IP address.\n"
- title: 5.4.  Specific IP Dependencies
  contents:
  - '5.4.  Specific IP Dependencies

    '
- title: 5.4.1.  IP Address Selection
  contents:
  - "5.4.1.  IP Address Selection\n   Unlike the IPv4 model, IPv6 promotes the configuration\
    \ of multiple IP\n   addresses per node, however, applications only use a\n  \
    \ destination/source pair for a communication.  Choosing the right IP\n   source\
    \ and destination addresses is a key factor that may determine\n   the route of\
    \ IP datagrams.\n   Typically, nodes, not applications, automatically solve the\
    \ source\n   address selection.  A node will choose the source address for a\n\
    \   communication following some rules of best choice, per [RFC3484], but\n  \
    \ will also allow applications to make changes in the ordering rules.\n   When\
    \ selecting the destination address, applications usually ask a\n   resolver for\
    \ the destination IP address.  The resolver returns a set\n   of valid IP addresses\
    \ from a hostname.  Unless applications have a\n   specific reason to select any\
    \ particular destination address, they\n   should try each element in the list\
    \ until the communication succeeds.\n   In some cases, the application may need\
    \ to specify its source\n   address.  The destination address selection process\
    \ picks the best\n   destination for the source address (instead of picking the\
    \ best\n   source address for the chosen destination address).  Note that if it\n\
    \   is not yet known which protocol will be used for communication there\n   may\
    \ be an increase in complexity for IP version - independent\n   applications that\
    \ have to specify the source address (especially for\n   client applications.\
    \  Fortunately, specifying the source address is\n   not typically required).\n"
- title: 5.4.2.  Application Framing
  contents:
  - "5.4.2.  Application Framing\n   The Application Level Framing (ALF) architecture\
    \ controls mechanisms\n   that traditionally fall within the transport layer.\
    \  Applications\n   implementing ALF are often responsible for packetizing data\
    \ into\n   Application Data Units (ADUs).  The application problem with ALF\n\
    \   arrives from the ADU size selection to obtain better performance.\n   Applications\
    \ using connectionless protocols (such as UDP) typically\n   need application\
    \ framing.  These applications have three choices: (1)\n   to use packet sizes\
    \ no larger than the IPv6 minimum Maximum\n   Transmission Unit (MTU) of 1280\
    \ bytes [RFC2460], (2) to use any\n   packet sizes, but to force IPv6 fragmentation/reassembly\
    \ when\n   necessary, or (3) to optimize the packet size and avoid unnecessary\n\
    \   fragmentation/reassembly, and to guess or find out the optimal packet\n  \
    \ sizes that can be sent and received, end-to-end, on the network.\n   This memo\
    \ takes no stance on that approach is best.\n   Note that the most optimal ALF\
    \ depends on dynamic factors such as\n   Path MTU or whether IPv4 or IPv6 is being\
    \ used (due to different\n   header sizes, possible IPv6-in-IPv4 tunneling overhead,\
    \ etc.).  These\n   factors have to be taken into consideration when application\
    \ framing\n   is implemented.\n"
- title: 5.4.3.  Storage of IP Addresses
  contents:
  - "5.4.3.  Storage of IP Addresses\n   Some applications store IP addresses as remote\
    \ peer information.  For\n   instance, one of the most popular ways to register\
    \ remote nodes in\n   collaborative applications uses IP addresses as registry\
    \ keys.\n   Although the source code that stores IP addresses can be modified\
    \ to\n   IPv6 by following the previous basic porting recommendations,\n   applications\
    \ should not store IP addresses for the following reasons:\n      -  IP addresses\
    \ can change throughout time; for instance, after a\n         renumbering process.\n\
    \      -  The same node can reach a destination host using different IP\n    \
    \     addresses, possibly with a different protocol version.\n   When possible,\
    \ applications should store names such as FQDNs or other\n   protocol-independent\
    \ identities instead of addresses.  In this case\n   applications are only bound\
    \ to specific addresses at run time, or for\n   the duration of a cache lifetime.\
    \  Other types of applications, such\n   as massive peer-to-peer systems with\
    \ their own rendezvous and\n   discovery mechanisms, may need to cache addresses\
    \ for performance\n   reasons, but cached addresses should not be treated as permanent,\n\
    \   reliable information.  In highly dynamic networks, any form of name\n   resolution\
    \ may be impossible, and here again addresses must be\n   cached.\n"
- title: 5.5.  Multicast Applications
  contents:
  - "5.5.  Multicast Applications\n   There is an additional problem in porting multicast\
    \ applications.\n   When multicast facilities are used some changes must be carried\
    \ out\n   to support IPv6.  First, applications must change the IPv4 multicast\n\
    \   addresses to IPv6 ones, and second, the socket configuration options\n   must\
    \ be changed.\n   All IPv6 multicast addresses encode scope; the scope was only\n\
    \   implicit in IPv4 (with multicast groups in 239/8).  Also, although a\n   large\
    \ number of application-specific multicast addresses have been\n   assigned with\
    \ IPv4, this has been (luckily enough) avoided with IPv6.\n   So there are no\
    \ direct equivalents for all the multicast addresses.\n   For link-local multicast,\
    \ it's possible to pick almost anything\n   within the link-local scope.  The\
    \ global groups could use unicast\n   prefix - based addresses [RFC3306].  All\
    \ in all, this may force the\n   application developers to write more protocol-dependent\
    \ code.\n   Another problem is that IPv6 multicast does not yet have a\n   standardized\
    \ mechanism for traditional Any Source Multicast for\n   Interdomain multicast.\
    \  The models for Any Source Multicast (ASM) or\n   Source-Specific Multicast\
    \ (SSM) are generally similar between IPv4\n   and IPv6, but it is possible that\
    \ PIM-SSM will become more widely\n   deployed in IPv6 due to its simpler architecture.\n\
    \   It might be beneficial to port the applications to use SSM semantics,\n  \
    \ requiring off-band source discovery mechanisms and a different API\n   [RFC3678].\
    \  Inter-domain ASM service is available only through a\n   method embedding the\
    \ Rendezvous Point address in the multicast\n   address [Embed-RP].\n   Another\
    \ generic problem with multiparty conferencing applications,\n   similar to the\
    \ issues with peer-to-peer applications, is that all\n   users of the session\
    \ must use the same protocol version (IPv4 or\n   IPv6), or some form of proxy\
    \ or translator (e.g., [MUL-GW]).\n"
- title: 6.  Developing IP Version - Independent Applications
  contents:
  - "6.  Developing IP Version - Independent Applications\n   As stated, dual applications\
    \ working with both IPv4 and IPv6 are\n   recommended.  These applications should\
    \ avoid IP dependencies in the\n   source code.  However, if IP dependencies are\
    \ required, one of the\n   better solutions would be to build a communication\
    \ library that\n   provides an IP version -  independent API to applications and\
    \ that\n   hides all dependencies.\n   To develop IP version - independent applications,\
    \ the following\n   guidelines should be considered.\n"
- title: 6.1.  IP Version - Independent Structures
  contents:
  - "6.1.  IP Version - Independent Structures\n   All memory structures and APIs\
    \ should be IP version-independent.  One\n   should avoid structs in_addr, in6_addr,\
    \ sockaddr_in, and\n   sockaddr_in6.\n   Suppose a network address is passed to\
    \ some function, foo().  If one\n   uses struct in_addr or struct in6_addr, results\
    \ an extra parameter to\n   indicate address family, as below:\n      struct in_addr\
    \ in4addr;\n      struct in6_addr in6addr;\n       /* IPv4 case */\n      foo(&in4addr,\
    \ AF_INET);\n       /* IPv6 case */\n      foo(&in6addr, AF_INET6);\n   This leads\
    \ to duplicated code and having to consider each scenario\n   from both perspectives\
    \ independently, which is difficult to maintain.\n   So we should use struct sockaddr_storage,\
    \ as below:\n      struct sockaddr_storage ss;\n      int sslen;\n      /* AF\
    \ independent! - use sockaddr when passing a pointer */\n      /* note: it's typically\
    \ necessary to also pass the length\n         explicitly */\n      foo((struct\
    \ sockaddr *)&ss, sslen);\n"
- title: 6.2.  IP Version - Independent APIs
  contents:
  - "6.2.  IP Version - Independent APIs\n   The new address independent variants\
    \ getaddrinfo() and getnameinfo()\n   hide the gory details of name-to-address\
    \ and address-to-name\n   translations.  They implement functionalities of the\
    \ following\n   functions:\n      gethostbyname()\n      gethostbyaddr()\n   \
    \   getservbyname()\n      getservbyport()\n   They also obsolete the functionality\
    \ of gethostbyname2(), defined in\n   [RFC2133].\n   The new variants can perform\
    \ hostname/address and service name/port\n   lookups, though the features can\
    \ be turned off, if desired.\n   Getaddrinfo() can return multiple addresses,\
    \ as below:\n      localhost.      IN A    127.0.0.1\n                      IN\
    \ A    127.0.0.2\n                      IN AAAA ::1\n   In this example, if IPv6\
    \ is preferred, getaddrinfo first returns ::1;\n   then both 127.0.0.1 and 127.0.0.2\
    \ are in a random order.\n   Getaddrinfo() and getnameinfo() can query hostname\
    \ and service\n   name/port at once.\n   Hardcoding AF-dependent knowledge is\
    \ not preferred in the program.\n   Constructs such as that below should be avoided:\n\
    \       /* BAD EXAMPLE */\n       switch (sa->sa_family) {\n       case AF_INET:\n\
    \               salen = sizeof(struct sockaddr_in);\n               break;\n \
    \     }\n   Instead, we should use the ai_addrlen member of the addrinfo\n   structure,\
    \ as returned by getaddrinfo().\n   The gethostbyname(), gethostbyaddr(), getservbyname(),\
    \ and\n   getservbyport() are mainly used to get server and client sockets.  In\n\
    \   the following sections, we will see simple examples creating these\n   sockets\
    \ by using the new IPv6 resolution functions.\n"
- title: 6.2.1.  Example of Overly Simplistic TCP Server Application
  contents:
  - "6.2.1.  Example of Overly Simplistic TCP Server Application\n   A simple TCP\
    \ server socket at service name (or port number string)\n   SERVICE:\n      /*\n\
    \       * BAD EXAMPLE: does not implement the getaddrinfo loop as\n       * specified\
    \ in 6.3.  This may result in one of the following:\n       *  - an IPv6 server,\
    \ listening at the wildcard address,\n       *    allowing IPv4 addresses through\
    \ IPv4-mapped IPv6 addresses.\n       *  - an IPv4 server, if IPv6 is not enabled,\n\
    \       *  - an IPv6-only server, if IPv6 is enabled but IPv4-mapped IPv6\n  \
    \     *    addresses are not used by default, or\n       *  - no server at all,\
    \ if getaddrinfo supports IPv6, but the\n       *    system doesn't, and socket(AF_INET6,\
    \ ...) exits with an\n       *    error.\n       */\n      struct addrinfo hints,\
    \ *res;\n      int error, sockfd;\n      memset(&hints, 0, sizeof(hints));\n \
    \     hints.ai_flags = AI_PASSIVE;\n      hints.ai_family = AF_UNSPEC;\n     \
    \ hints.ai_socktype = SOCK_STREAM;\n      error = getaddrinfo(NULL, SERVICE, &hints,\
    \ &res);\n      if (error != 0) {\n         /* handle getaddrinfo error */\n \
    \     }\n      sockfd = socket(res->family, res->ai_socktype, res->ai_protocol);\n\
    \      if (sockfd < 0) {\n         /* handle socket error */\n      }\n      if\
    \ (bind(sockfd, res->ai_addr, res->ai_addrlen) < 0) {\n         /* handle bind\
    \ error */\n      }\n      /* ... */\n      freeaddrinfo(res);\n"
- title: 6.2.2.  Example of Overly Simplistic TCP Client Application
  contents:
  - "6.2.2.  Example of Overly Simplistic TCP Client Application\n   A simple TCP\
    \ client socket connecting to a server running at node\n   name (or IP address\
    \ presentation format) SERVER_NODE and service name\n   (or port number string)\
    \ SERVICE follows:\n      /*\n       * BAD EXAMPLE: does not implement the getaddrinfo\
    \ loop as\n       * specified in 6.3.  This may result in one of the following:\n\
    \       *  - an IPv4 connection to an IPv4 destination,\n       *  - an IPv6 connection\
    \ to an IPv6 destination,\n       *  - an attempt to try to reach an IPv6 destination\
    \ (if AAAA\n       *    record found), but failing -- without fallbacks -- because:\n\
    \       *     o getaddrinfo supports IPv6 but the system does not\n       *  \
    \   o IPv6 routing doesn't exist, so falling back to e.g., TCP\n       *     \
    \  timeouts\n       *     o IPv6 server reached, but service not IPv6-enabled\
    \ or\n       *       firewalled away\n       *  - if the first destination is\
    \ not reached, there is no\n       *    fallback to the next records\n       */\n\
    \      struct addrinfo hints, *res;\n      int error, sockfd;\n      memset(&hints,\
    \ 0, sizeof(hints));\n      hints.ai_family = AF_UNSPEC;\n      hints.ai_socktype\
    \ = SOCK_STREAM;\n      error = getaddrinfo(SERVER_NODE, SERVICE, &hints, &res);\n\
    \      if (error != 0) {\n           /* handle getaddrinfo error */\n      }\n\
    \      sockfd = socket(res->family, res->ai_socktype, res->ai_protocol);\n   \
    \   if (sockfd < 0) {\n           /* handle socket error */\n      }\n      if\
    \ (connect(sockfd, res->ai_addr, res->ai_addrlen) < 0 ) {\n           /* handle\
    \ connect error */\n      }\n      /* ... */\n      freeaddrinfo(res);\n"
- title: 6.2.3.  Binary/Presentation Format Conversion
  contents:
  - "6.2.3.  Binary/Presentation Format Conversion\n   We should consider the binary\
    \ and presentation address format\n   conversion APIs.  The following functions\
    \ convert network address\n   structure in its presentation address format and\
    \ vice versa:\n      inet_ntop()\n      inet_pton()\n   Both are from the basic\
    \ socket extensions for IPv6.  However, these\n   conversion functions are protocol-dependent.\
    \  It is better to use\n   getnameinfo()/getaddrinfo() (inet_pton and inet_ntop\
    \ equivalents are\n   described in Appendix A).\n   Conversion from network address\
    \ structure to presentation format can\n   be written as follows:\n      struct\
    \ sockaddr_storage ss;\n      char addrStr[INET6_ADDRSTRLEN];\n      char servStr[NI_MAXSERV];\n\
    \      int error;\n      /* fill ss structure */\n      error = getnameinfo((struct\
    \ sockaddr *)&ss, sizeof(ss),\n                          addrStr, sizeof(addrStr),\n\
    \                          servStr, sizeof(servStr),\n                       \
    \   NI_NUMERICHOST);\n   Conversions from presentation format to network address\
    \ structure can\n   be written as follows:\n      struct addrinfo hints, *res;\n\
    \      char addrStr[INET6_ADDRSTRLEN];\n      int error;\n      /* fill addrStr\
    \ buffer */\n      memset(&hints, 0, sizeof(hints));\n      hints.ai_family =\
    \ AF_UNSPEC;\n      error = getaddrinfo(addrStr, NULL, &hints, &res);\n      if\
    \ (error != 0) {\n          /* handle getaddrinfo error */\n      }\n      /*\
    \ res->ai_addr contains the network address structure */\n      /* ... */\n  \
    \    freeaddrinfo(res);\n"
- title: 6.3.  Iterated Jobs for Finding the Working Address
  contents:
  - "6.3.  Iterated Jobs for Finding the Working Address\n   In a client code, when\
    \ multiple addresses are returned from\n   getaddrinfo(), we should try all of\
    \ them until connection succeeds.\n   When a failure occurs with socket(), connect(),\
    \ bind(), or some other\n   function, the code should go on to try the next address.\n\
    \   In addition, if something is wrong with the socket call because the\n   address\
    \ family is not supported (i.e., in case of section 4.4),\n   applications should\
    \ try the next address structure.\n   Note: In the following examples, the socket()\
    \ return value error\n   handling could be simplified by always continuing on\
    \ with the socket\n   loop instead of performing special checking of specific\
    \ error\n   numbers.\n"
- title: 6.3.1.  Example of TCP Server Application
  contents:
  - "6.3.1.  Example of TCP Server Application\n   The previous TCP server example\
    \ should be written as follows:\n      #define MAXSOCK 2\n      struct addrinfo\
    \ hints, *res;\n      int error, sockfd[MAXSOCK], nsock=0;\n      memset(&hints,\
    \ 0, sizeof(hints));\n      hints.ai_flags = AI_PASSIVE;\n      hints.ai_family\
    \ = AF_UNSPEC;\n      hints.ai_socktype = SOCK_STREAM;\n      error = getaddrinfo(NULL,\
    \ SERVICE, &hints, &res);\n      if (error != 0) {\n          /* handle getaddrinfo\
    \ error */\n      }\n      for (aip=res; aip && nsock < MAXSOCK; aip=aip->ai_next)\
    \ {\n          sockfd[nsock] = socket(aip->ai_family,\n                      \
    \           aip->ai_socktype,\n                                 aip->ai_protocol);\n\
    \          if (sockfd[nsock] < 0) {\n              switch errno {\n          \
    \         case EAFNOSUPPORT:\n                   case EPROTONOSUPPORT:\n     \
    \                  /*\n                        *  e.g., skip the errors until\n\
    \                        *  the last address family,\n                       \
    \ *  see section 4.4.\n                        */\n                        if\
    \ (aip->ai_next)\n                                continue;\n                \
    \        else {\n                               /* handle unknown protocol errors\
    \ */\n                                break;\n                        }\n    \
    \               default:\n                        /* handle other socket errors\
    \ */\n                        ;\n               }\n          } else {\n      \
    \        int on = 1;\n              /* optional: works better if dual-binding\
    \ to wildcard\n                 address */\n              if (aip->ai_family ==\
    \ AF_INET6) {\n                  setsockopt(sockfd[nsock], IPPROTO_IPV6, IPV6_V6ONLY,\n\
    \                             (char *)&on, sizeof(on));\n                  /*\
    \ errors are ignored */\n              }\n              if (bind(sockfd[nsock],\
    \ aip->ai_addr,\n                                      aip->ai_addrlen) < 0 )\
    \ {\n                  /* handle bind error */\n                  close(sockfd[nsock]);\n\
    \                  continue;\n              }\n              if (listen(sockfd[nsock],\
    \ SOMAXCONN) < 0) {\n                  /* handle listen errors */\n          \
    \        close(sockfd[nsock]);\n                  continue;\n              }\n\
    \          }\n          nsock++;\n      }\n      freeaddrinfo(res);\n      /*\
    \ check that we were able to obtain the sockets */\n"
- title: 6.3.2.  Example of TCP Client Application
  contents:
  - "6.3.2.  Example of TCP Client Application\n   The previous TCP client example\
    \ should be written as follows:\n      struct addrinfo hints, *res, *aip;\n  \
    \    int sockfd, error;\n      memset(&hints, 0, sizeof(hints));\n      hints.ai_family\
    \   = AF_UNSPEC;\n      hints.ai_socktype = SOCK_STREAM;\n      error = getaddrinfo(SERVER_NODE,\
    \ SERVICE, &hints, &res);\n      if (error != 0) {\n          /* handle getaddrinfo\
    \ error */\n      }\n      for (aip=res; aip; aip=aip->ai_next) {\n          sockfd\
    \ = socket(aip->ai_family,\n                          aip->ai_socktype,\n    \
    \                      aip->ai_protocol);\n          if (sockfd < 0) {\n     \
    \         switch errno {\n                   case EAFNOSUPPORT:\n            \
    \       case EPROTONOSUPPORT:\n                       /*\n                   \
    \     *  e.g., skip the errors until\n                        *  the last address\
    \ family,\n                        *  see section 4.4.\n                     \
    \   */\n                        if (aip->ai_next)\n                          \
    \      continue;\n                        else {\n                           \
    \    /* handle unknown protocol errors */\n                                break;\n\
    \                        }\n                   default:\n                    \
    \    /* handle other socket errors */\n                        ;\n           \
    \    }\n          } else {\n              if (connect(sockfd, aip->ai_addr, aip->ai_addrlen)\
    \ == 0)\n                  break;\n              /* handle connect errors */\n\
    \              close(sockfd);\n              sockfd=-1;\n          }\n      }\n\
    \      if (sockfd > 0) {\n          /* socket connected to server address */\n\
    \          /* ... */\n      }\n      freeaddrinfo(res);\n"
- title: 7.  Transition Mechanism Considerations
  contents:
  - "7.  Transition Mechanism Considerations\n   The mechanism [NAT-PT] introduces\
    \ a special set of addresses, formed\n   of an NAT-PT prefix and an IPv4 address\
    \ these refer to IPv4 addresses\n   translated by NAT-PT DNS-ALG.  In some cases,\
    \ one might be tempted to\n   handle these differently.\n   However, IPv6 applications\
    \ must not be required to distinguish\n   \"normal\" and \"NAT-PT translated\"\
    \ addresses (or any other kind of\n   special addresses, including the IPv4-mapped\
    \ IPv6 addresses): This\n   would be completely impractical, and if the distinction\
    \ must be made,\n   it must be done elsewhere (e.g., kernel, system libraries).\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   There are a number of security considerations\
    \ for IPv6 transition,\n   but those are outside the scope of this memo.\n   To\
    \ ensure the availability and robustness of the service even when\n   transitioning\
    \ to IPv6, this memo describes a number of ways to make\n   applications more\
    \ resistant to failures by cycling through addresses\n   until a working one is\
    \ found.  Doing this properly is critical to\n   maintain availability and to\
    \ avoid loss of service.\n   A special consideration about application transition\
    \ is how IPv4-\n   mapped IPv6 addresses are handled.  The use in the API can\
    \ be seen\n   both as a merit (easier application transition) and as a burden\n\
    \   (difficulty in ensuring whether the use was legitimate).  Note that\n   some\
    \ systems will disable (by default) support for internal IPv4-\n   mapped IPv6\
    \ addresses.  The security concerns regarding these on the\n   wire are legitimate,\
    \ but disabling it internally breaks one\n   transition mechanism for server applications\
    \ originally written to\n   bind() and listen() to a single socket by using a\
    \ wildcard address\n   [V6MAPPED].  This should be considered in more detail when\n\
    \   applications are designed.\n"
- title: 9.  Acknowledgments
  contents:
  - "9.  Acknowledgments\n   Some of guidelines for development of IP version-independent\n\
    \   applications (section 6) were first brought up by [AF-APP].  Other\n   work\
    \ to document application porting guidelines has also been in\n   progress; for\
    \ example, [IP-GGF] and [PRT].  We would like to thank\n   the members of the\
    \ v6ops working group and the application area for\n   helpful comments.  Special\
    \ thanks are due to Brian E.  Carpenter,\n   Antonio Querubin, Stig Venaas, Chirayu\
    \ Patel, Jordi Palet, and Jason\n   Lin for extensive review of this document.\
    \  We acknowledge Ron Pike\n   for proofreading the document.\n"
- title: 10.  References
  contents:
  - '10.  References

    '
- title: 10.1.  Normative References
  contents:
  - "10.1.  Normative References\n   [RFC3493]   Gilligan, R., Thomson, S., Bound,\
    \ J., McCann, J., and W.\n               Stevens, \"Basic Socket Interface Extensions\
    \ for IPv6\",\n               RFC 3493, February 2003.\n   [RFC3542]   Stevens,\
    \ W., Thomas, M., Nordmark, E., and T. Jinmei,\n               \"Advanced Sockets\
    \ Application Program Interface (API) for\n               IPv6\", RFC 3542, May\
    \ 2003.\n   [BIS]       Tsuchiya, K., Higuchi, H., and Y. Atarashi, \"Dual Stack\n\
    \               Hosts using the \"Bump-In-the-Stack\" Technique (BIS)\", RFC\n\
    \               2767, February 2000.\n   [BIA]       Lee, S., Shin, M-K., Kim,\
    \ Y-J., Nordmark, E., and A.\n               Durand, \"Dual Stack Hosts Using\
    \ \"Bump-in-the-API\" (BIA)\",\n               RFC 3338, October 2002.\n   [RFC2460]\
    \   Deering, S. and R. Hinden, \"Internet Protocol, Version 6\n              \
    \ (IPv6) Specification\", RFC 2460, December 1998.\n   [RFC3484]   Draves, R.,\
    \ \"Default Address Selection for Internet\n               Protocol version 6\
    \ (IPv6)\", RFC 3484, February 2003.\n   [RFC3513]   Hinden, R. and S. Deering,\
    \ \"Internet Protocol Version 6\n               (IPv6) Addressing Architecture\"\
    , RFC 3513, April 2003.\n"
- title: 10.2.  Informative References
  contents:
  - "10.2.  Informative References\n   [2893BIS]   Nordmark, E. and R. E. Gilligan,\
    \ \"Basic Transition\n               Mechanisms for IPv6 Hosts and Routers\",\
    \ Work in Progress,\n               June 2004.\n   [RFC2133]   Gilligan, R., Thomson,\
    \ S., Bound, J., and W. Stevens,\n               \"Basic Socket Interface Extensions\
    \ for IPv6\", RFC 2133,\n               April 1997.\n   [RFC2732]   Hinden, R.,\
    \ Carpenter, B., and L. Masinter, \"Format for\n               Literal IPv6 Addresses\
    \ in URL's\", RFC 2732, December\n               1999.\n   [RFC2821]   Klensin,\
    \ J., \"Simple Mail Transfer Protocol\", RFC 2821,\n               April 2001.\n\
    \   [TextRep]   Main, A., \"Textual Representation of IPv4 and IPv6\n        \
    \       Addresses\", Work in Progress, October 2003.\n   [NAT-PT]    Tsirtsis,\
    \ G. and P. Srisuresh, \"Network Address\n               Translation - Protocol\
    \ Translation (NAT-PT)\", RFC 2766,\n               February 2000.\n   [DNSTRANS]\
    \  Durand, A. and J. Ihren, \"DNS IPv6 Transport Operational\n               Guidelines\"\
    , BCP 91, RFC 3901, September 2004.\n   [DNSOPV6]   Durand, A., Ihren, J. and\
    \ P. Savola, \"Operational\n               Considerations and Issues with IPv6\
    \ DNS\", Work in\n               Progress, May 2004.\n   [AF-APP]    Hagino, J.,\
    \ \"Implementing AF-independent application\",\n               http://www.kame.net/newsletter/19980604/,\
    \ 2001.\n   [V6MAPPED]  Hagino, J., \"IPv4 mapped address considered harmful\"\
    ,\n               Work in Progress, April 2002.\n   [IP-GGF]    Chown, T., Bound,\
    \ J., Jiang, S. and P. O'Hanlon,\n               \"Guidelines for IP version independence\
    \ in GGF\n               specifications\", Global Grid Forum(GGF) Documentation,\n\
    \               work in Progress, September 2003.\n   [Embed-RP]  Savola, P. and\
    \ B. Haberman, \"Embedding the Rendezvous\n               Point (RP) Address in\
    \ an IPv6 Multicast Address\", RFC\n               3956, November 2004.\n   [RFC3306]\
    \   Haberman, B. and D. Thaler, \"Unicast-Prefix-based IPv6\n               Multicast\
    \ Addresses\", RFC 3306, August 2002.\n   [RFC3678]   Thaler, D., Fenner, B.,\
    \ and B. Quinn, \"Socket Interface\n               Extensions for Multicast Source\
    \ Filters, RFC 3678,\n               January 2004.\n   [MUL-GW]    Venaas, S.,\
    \ \"An IPv4 - IPv6 multicast gateway\", Work in\n               Progress, February\
    \ 2003.\n   [PRT]       Castro, E. M., \"Programming guidelines on transition\
    \ to\n               IPv6 LONG project\", Work in Progress, January 2003.\n"
- title: Appendix A.  Other Binary/Presentation Format Conversions
  contents:
  - "Appendix A.  Other Binary/Presentation Format Conversions\n   Section 6.2.3 describes\
    \ the preferred way to perform\n   binary/presentation format conversions; these\
    \ can also be done by\n   using inet_pton() and inet_ntop() and by writing protocol-dependent\n\
    \   code.  This approach is not recommended, but it is provided here for\n   reference\
    \ and comparison.\n   Note that inet_ntop()/inet_pton() lose the scope identifier\
    \ (if used,\n   e.g., with link-local addresses) in the conversions, contrary\
    \ to the\n   getaddrinfo()/getnameinfo() functions.\n"
- title: A.1.  Binary to Presentation Using inet_ntop()
  contents:
  - "A.1.  Binary to Presentation Using inet_ntop()\n   Conversions from network address\
    \ structure to presentation format can\n   be written as follows:\n      struct\
    \ sockaddr_storage ss;\n      char addrStr[INET6_ADDRSTRLEN];\n      /* fill ss\
    \ structure */\n      switch (ss.ss_family) {\n           case AF_INET:\n    \
    \            inet_ntop(ss.ss_family,\n                         &((struct sockaddr_in\
    \ *)&ss)->sin_addr,\n                         addrStr,\n                     \
    \    sizeof(addrStr));\n                break;\n           case AF_INET6:\n  \
    \              inet_ntop(ss.ss_family,\n                          &((struct sockaddr_in6\
    \ *)&ss)->sin6_addr,\n                          addrStr,\n                   \
    \       sizeof(addrStr));\n                break;\n           default:\n     \
    \           /* handle unknown family */\n      }\n   Note that, the destination\
    \ buffer addrStr should be long enough to\n   contain the presentation address\
    \ format: INET_ADDRSTRLEN for IPv4 and\n   INET6_ADDRSTRLEN for IPv6.  As INET6_ADDRSTRLEN\
    \ is longer than\n   INET_ADDRSTRLEN, the first one is used as the destination\
    \ buffer\n   length.\n"
- title: A.2.  Presentation to Binary Using inet_pton()
  contents:
  - "A.2.  Presentation to Binary Using inet_pton()\n   Conversions from presentation\
    \ format to network address structure can\n   be written as follows:\n      struct\
    \ sockaddr_storage ss;\n      struct sockaddr_in *sin;\n      struct sockaddr_in6\
    \ *sin6;\n      char addrStr[INET6_ADDRSTRLEN];\n      /* fill addrStr buffer\
    \ and ss.ss_family */\n      switch (ss.ss_family) {\n            case AF_INET:\n\
    \                  sin = (struct sockaddr_in *)&ss;\n                  inet_pton(ss.ss_family,\n\
    \                            addrStr,\n                            (sockaddr *)&sin->sin_addr));\n\
    \                  break;\n            case AF_INET6:\n                  sin6\
    \ = (struct sockaddr_in6 *)&ss;\n                  inet_pton(ss.ss_family,\n \
    \                           addrStr,\n                            (sockaddr *)&sin6->sin6_addr);\n\
    \                  break;\n            default:\n                /* handle unknown\
    \ family */\n      }\n   Note that, the address family of the presentation format\
    \ must be\n   known.\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Myung-Ki Shin\n   ETRI/NIST\n   820 West Diamond Avenue\n\
    \   Gaithersburg, MD 20899, USA\n   Phone: +1 301 975-3613\n   Fax:   +1 301 590-0932\n\
    \   EMail: mshin@nist.gov\n   Yong-Guen Hong\n   ETRI PEC\n   161 Gajeong-Dong,\
    \ Yuseong-Gu, Daejeon 305-350, Korea\n   Phone: +82 42 860 6447\n   Fax:   +82\
    \ 42 861 5404\n   EMail: yghong@pec.etri.re.kr\n   Jun-ichiro itojun HAGINO\n\
    \   Research Laboratory, Internet Initiative Japan Inc.\n   Takebashi Yasuda Bldg.,\n\
    \   3-13 Kanda Nishiki-cho,\n   Chiyoda-ku,Tokyo 101-0054, JAPAN\n   Phone: +81-3-5259-6350\n\
    \   Fax:   +81-3-5259-6351\n   EMail: itojun@iijlab.net\n   Pekka Savola\n   CSC/FUNET\n\
    \   Espoo, Finland\n   EMail: psavola@funet.fi\n   Eva M. Castro\n   Rey Juan\
    \ Carlos University (URJC)\n   Departamento de Informatica, Estadistica y Telematica\n\
    \   C/Tulipan s/n\n   28933 Madrid - SPAIN\n   EMail: eva@gsyc.escet.urjc.es\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (2005).\n   This\
    \ document is subject to the rights, licenses and restrictions\n   contained in\
    \ BCP 78, and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY AND THE INTERNET\n   ENGINEERING\
    \ TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS OR IMPLIED,\n   INCLUDING BUT NOT\
    \ LIMITED TO ANY WARRANTY THAT THE USE OF THE\n   INFORMATION HEREIN WILL NOT\
    \ INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY OR FITNESS\
    \ FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at ietf-\n   ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
