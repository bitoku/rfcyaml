- title: __initial_text__
  contents:
  - '               Multiple Provisioning Domain Architecture

    '
- title: Abstract
  contents:
  - "Abstract\n   This document is a product of the work of the Multiple Interfaces\n\
    \   Architecture Design team.  It outlines a solution framework for some\n   of\
    \ the issues experienced by nodes that can be attached to multiple\n   networks\
    \ simultaneously.  The framework defines the concept of a\n   Provisioning Domain\
    \ (PvD), which is a consistent set of network\n   configuration information. \
    \ PvD-aware nodes learn PvD-specific\n   information from the networks they are\
    \ attached to and/or other\n   sources.  PvDs are used to enable separation and\
    \ configuration\n   consistency in the presence of multiple concurrent connections.\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This document is not an Internet Standards Track specification;\
    \ it is\n   published for informational purposes.\n   This document is a product\
    \ of the Internet Engineering Task Force\n   (IETF).  It represents the consensus\
    \ of the IETF community.  It has\n   received public review and has been approved\
    \ for publication by the\n   Internet Engineering Steering Group (IESG).  Not\
    \ all documents\n   approved by the IESG are a candidate for any level of Internet\n\
    \   Standard; see Section 2 of RFC 5741.\n   Information about the current status\
    \ of this document, any errata,\n   and how to provide feedback on it may be obtained\
    \ at\n   http://www.rfc-editor.org/info/rfc7556.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (c) 2015 IETF Trust and the persons identified\
    \ as the\n   document authors.  All rights reserved.\n   This document is subject\
    \ to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n\
    \   (http://trustee.ietf.org/license-info) in effect on the date of\n   publication\
    \ of this document.  Please review these documents\n   carefully, as they describe\
    \ your rights and restrictions with respect\n   to this document.  Code Components\
    \ extracted from this document must\n   include Simplified BSD License text as\
    \ described in Section 4.e of\n   the Trust Legal Provisions and are provided\
    \ without warranty as\n   described in the Simplified BSD License.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .\
    \ . . . . .   4\n   2.  Definitions and Types of PvDs . . . . . . . . . . . .\
    \ . . . .   5\n     2.1.  Explicit PvDs . . . . . . . . . . . . . . . . . . .\
    \ . . .   5\n     2.2.  Implicit PvDs and Incremental Adoption of Explicit PvDs\
    \ .   6\n     2.3.  Relationship between PvDs and Interfaces  . . . . . . . .\
    \   7\n     2.4.  PvD Identity/Naming . . . . . . . . . . . . . . . . . . .  \
    \ 8\n     2.5.  The Relationship to Dual-Stack Networks . . . . . . . . .   8\n\
    \   3.  Conveying PvD Information . . . . . . . . . . . . . . . . . .   9\n  \
    \   3.1.  Separate Messages or One Message? . . . . . . . . . . . .   9\n    \
    \ 3.2.  Securing PvD Information  . . . . . . . . . . . . . . . .  10\n     3.3.\
    \  Backward Compatibility  . . . . . . . . . . . . . . . . .  10\n     3.4.  Retracting/Updating\
    \ PvD Information . . . . . . . . . . .  10\n     3.5.  Conveying Configuration\
    \ Information Using IKEv2 . . . . .  10\n   4.  Example Network Configurations\
    \  . . . . . . . . . . . . . . .  11\n     4.1.  A Mobile Node . . . . . . . .\
    \ . . . . . . . . . . . . . .  11\n     4.2.  A Node with a VPN Connection  .\
    \ . . . . . . . . . . . . .  12\n     4.3.  A Home Network and a Network Operator\
    \ with Multiple PvDs   12\n   5.  Reference Model for the PvD-Aware Node  . .\
    \ . . . . . . . . .  13\n     5.1.  Constructions and Maintenance of Separate\
    \ PvDs  . . . . .  13\n     5.2.  Consistent Use of PvDs for Network Connections\
    \  . . . . .  14\n       5.2.1.  Name Resolution . . . . . . . . . . . . . . .\
    \ . . . .  14\n       5.2.2.  Next-Hop and Source Address Selection . . . . .\
    \ . . .  15\n       5.2.3.  Listening Applications  . . . . . . . . . . . . .\
    \ . .  16\n         5.2.3.1.  Processing of Incoming Traffic  . . . . . . . .\
    \ .  16\n       5.2.4.  Enforcement of Security Policies  . . . . . . . . . .\
    \  17\n     5.3.  Connectivity Tests  . . . . . . . . . . . . . . . . . . .  18\n\
    \     5.4.  Relationship to Interface Management and Connection\n           Managers\
    \  . . . . . . . . . . . . . . . . . . . . . . . .  18\n   6.  PvD Support in\
    \ APIs . . . . . . . . . . . . . . . . . . . . .  19\n     6.1.  Basic . . . .\
    \ . . . . . . . . . . . . . . . . . . . . . .  19\n     6.2.  Intermediate  .\
    \ . . . . . . . . . . . . . . . . . . . . .  19\n     6.3.  Advanced  . . . .\
    \ . . . . . . . . . . . . . . . . . . . .  20\n   7.  PvD Trust for PvD-Aware\
    \ Node  . . . . . . . . . . . . . . . .  20\n     7.1.  Untrusted PvDs  . . .\
    \ . . . . . . . . . . . . . . . . . .  20\n     7.2.  Trusted PvDs  . . . . .\
    \ . . . . . . . . . . . . . . . . .  20\n       7.2.1.  Authenticated PvDs  .\
    \ . . . . . . . . . . . . . . . .  21\n       7.2.2.  PvDs Trusted by Attachment\
    \  . . . . . . . . . . . . .  21\n   8.  Security Considerations . . . . . . .\
    \ . . . . . . . . . . . .  21\n   9.  Informative References  . . . . . . . .\
    \ . . . . . . . . . . .  23\n   Acknowledgments . . . . . . . . . . . . . . .\
    \ . . . . . . . . . .  25\n   Contributors  . . . . . . . . . . . . . . . . .\
    \ . . . . . . . . .  25\n   Author's Address  . . . . . . . . . . . . . . . .\
    \ . . . . . . . .  25\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Nodes attached to multiple networks may encounter problems\
    \ from\n   conflicting configuration between the networks or attempts to\n   simultaneously\
    \ use more than one network.  While various techniques\n   are currently used\
    \ to tackle these problems [RFC6419], in many cases\n   issues may still appear.\
    \  The Multiple Interfaces Problem Statement\n   document [RFC6418] describes\
    \ the general landscape and discusses many\n   of the specific issues and scenario\
    \ details.\n   Problems, enumerated in [RFC6418], can be grouped into 3 categories:\n\
    \   1.  Lack of consistent and distinctive management of configuration\n     \
    \  elements associated with different networks.\n   2.  Inappropriate mixed use\
    \ of configuration elements associated with\n       different networks during\
    \ a particular network activity or\n       connection.\n   3.  Use of a particular\
    \ network that is not consistent with the\n       intended use of the network,\
    \ or the intent of the communicating\n       parties, leading to connectivity\
    \ failure and/or other undesired\n       consequences.\n   An example of (1) is\
    \ a single, node-scoped list of DNS server IP\n   addresses learned from different\
    \ networks leading to failures or\n   delays in resolution of names from particular\
    \ namespaces; an example\n   of (2) is an attempt to resolve the name of an HTTP\
    \ proxy server\n   learned from network A using a DNS server learned from network\
    \ B; and\n   an example of (3) is the use of an employer-provided VPN connection\n\
    \   for peer-to-peer connectivity unrelated to employment activities.\n   This\
    \ architecture provides solutions to these categories of problems,\n   respectively,\
    \ by:\n   1.  Introducing the formal notion of PvDs, including identity for\n\
    \       PvDs, and describing mechanisms for nodes to learn the intended\n    \
    \   associations between acquired network configuration information\n       elements.\n\
    \   2.  Introducing a reference model for PvD-aware nodes that prevents\n    \
    \   the inadvertent mixed use of configuration information that may\n       belong\
    \ to different PvDs.\n   3.  Providing recommendations on PvD selection based\
    \ on PvD identity\n       and connectivity tests for common scenarios.\n"
- title: 2.  Definitions and Types of PvDs
  contents:
  - "2.  Definitions and Types of PvDs\n   Provisioning Domain:\n      A consistent\
    \ set of network configuration information.\n      Classically, all of the configuration\
    \ information available on a\n      single interface is provided by a single source\
    \ (such as a network\n      administrator) and can therefore be treated as a single\n\
    \      provisioning domain.  In modern IPv6 networks, multihoming can\n      result\
    \ in more than one provisioning domain being present on a\n      single link.\
    \  In some scenarios, it is also possible for elements\n      of the same PvD\
    \ to be present on multiple links.\n      Typical examples of information in a\
    \ provisioning domain learned\n      from the network are:\n      *  Source address\
    \ prefixes for use by connections within the\n         provisioning domain\n \
    \     *  IP address(es) of the DNS server(s)\n      *  Name of the HTTP proxy\
    \ server (if available)\n      *  DNS suffixes associated with the network\n \
    \     *  Default gateway address\n   PvD-aware node:\n      A node that supports\
    \ the association of network configuration\n      information into PvDs and the\
    \ use of these PvDs to serve requests\n      for network connections in ways consistent\
    \ with the\n      recommendations of this architecture.\n   PvD-aware application:\n\
    \      An application that contains code and/or application-specific\n      configuration\
    \ information explicitly aware of the notion of PvD\n      and/or specific types\
    \ of PvD elements or properties.\n"
- title: 2.1.  Explicit PvDs
  contents:
  - "2.1.  Explicit PvDs\n   A node may receive explicit information from the network\
    \ and/or other\n   sources conveying the presence of PvDs and the association\
    \ of\n   particular network information with a particular PvD.  PvDs that are\n\
    \   constructed based on such information are referred to as \"explicit\"\n  \
    \ in this document.\n   Protocol changes or extensions will likely be required\
    \ to support\n   explicit PvDs through IETF-defined mechanisms.  As an example,\
    \ one\n   could think of one or more DHCP options carrying PvD identity and/or\n\
    \   its elements.\n   A different approach could be the introduction of a DHCP\
    \ option that\n   only carries the identity of a PvD.  Here, the associations\
    \ between\n   network information elements with the identity is implemented by\
    \ the\n   respective protocols, for example, with a Router Discovery [RFC4861]\n\
    \   option associating an address range with a PvD.  Additional\n   discussion\
    \ can be found in Section 3.\n   Other examples of a delivery mechanism for PvDs\
    \ are key exchange or\n   tunneling protocols, such as the Internet Key Exchange\
    \ Protocol\n   version 2 (IKEv2) [RFC7296] that allows the transport of host\n\
    \   configuration information.\n   Specific, existing, or new features of networking\
    \ protocols that\n   enable the delivery of PvD identity and association with\
    \ various\n   network information elements will be defined in companion design\n\
    \   documents.\n   Link-specific and/or vendor-proprietary mechanisms for the\
    \ discovery\n   of PvD information (differing from IETF-defined mechanisms) can\
    \ be\n   used by nodes either separate from or in conjunction with IETF-\n   defined\
    \ mechanisms, providing they allow the discovery of the\n   necessary elements\
    \ of the PvD(s).\n   In all cases, nodes must by default ensure that the lifetime\
    \ of all\n   dynamically discovered PvD configuration is appropriately limited\
    \ by\n   relevant events.  For example, if an interface media state change is\n\
    \   indicated, previously discovered information relevant to that\n   interface\
    \ may no longer be valid and thus needs to be confirmed or\n   re-discovered.\n\
    \   It is expected that the way a node makes use of PvD information is\n   generally\
    \ independent of the specific mechanism/protocol that the\n   information was\
    \ received by.\n   In some network topologies, network infrastructure elements\
    \ may need\n   to advertise multiple PvDs.  Generally, the details of how this\
    \ is\n   performed will be defined in companion design documents.\n"
- title: 2.2.  Implicit PvDs and Incremental Adoption of Explicit PvDs
  contents:
  - "2.2.  Implicit PvDs and Incremental Adoption of Explicit PvDs\n   For the foreseeable\
    \ future, there will be networks that do not\n   advertise explicit PvD information,\
    \ because deployment of new\n   features in networking protocols is a relatively\
    \ slow process.\n   When connected to networks that don't advertise explicit PvD\n\
    \   information, a PvD-aware node shall automatically create separate\n   PvDs\
    \ for received configuration.  Such PvDs are referred to in this\n   document\
    \ as \"implicit\".\n   Through the use of implicit PvDs, PvD-aware nodes may still\
    \ provide\n   benefits to their users (when compared to non-PvD-aware nodes) by\n\
    \   following the best practices described in Section 5.\n   PvD-aware nodes shall\
    \ treat network information from different\n   interfaces, which is not identified\
    \ as belonging explicitly to some\n   PvD, as belonging to separate PvDs, one\
    \ per interface.\n   Implicit PvDs can also occur in a mixed mode, i.e., where\
    \ of multiple\n   networks that are available on an attached link, only some advertise\n\
    \   PvD information.  In this case, the PvD-aware node shall create\n   explicit\
    \ PvDs from information explicitly labeled as belonging to\n   PvDs.  It shall\
    \ associate configuration information not labeled with\n   an explicit PvD with\
    \ an implicit PvD(s) created for that interface.\n"
- title: 2.3.  Relationship between PvDs and Interfaces
  contents:
  - "2.3.  Relationship between PvDs and Interfaces\n   By default, implicit PvDs\
    \ are limited to the network configuration\n   information received on a single\
    \ interface, and by default, one such\n   PvD is formed for each interface.  If\
    \ additional information is\n   available to the host (through mechanisms out\
    \ of scope of this\n   document), the host may form implicit PvDs with different\n\
    \   granularity.  For example, PvDs spanning multiple interfaces such as\n   a\
    \ home network with a router that has multiple internal interfaces or\n   multiple\
    \ PvDs on a single interface such as a network that has\n   multiple uplink connections.\n\
    \   In the simplest case, explicit PvDs will be scoped for configuration\n   related\
    \ only to a specific interface.  However, there is no\n   requirement in this\
    \ architecture for such a limitation.  Explicit\n   PvDs may include information\
    \ related to more than one interface if\n   the node learns the presence of the\
    \ same PvD on those interfaces and\n   the authentication of the PvD ID meets\
    \ the level required by the node\n   policy (authentication of a PvD ID may be\
    \ also required in scenarios\n   involving only one connected interface and/or\
    \ PvD; for additional\n   discussion of PvD Trust, see Section 7).\n   This architecture\
    \ supports such scenarios.  Hence, no hierarchical\n   relationship exists between\
    \ interfaces and PvDs: it is possible for\n   multiple PvDs to be simultaneously\
    \ accessible over one interface, as\n   well as a single PvD to be simultaneously\
    \ accessible over multiple\n   interfaces.\n"
- title: 2.4.  PvD Identity/Naming
  contents:
  - "2.4.  PvD Identity/Naming\n   For explicit PvDs, the PvD ID is a value that is\
    \ or has a high\n   probability of being globally unique and is received as part\
    \ of PvD\n   information.  It shall be possible to generate a human-readable form\n\
    \   of the PvD ID to present to the end user, either based on the PvD ID\n   itself\
    \ or using metadata associated with the ID.  For implicit PvDs,\n   the node assigns\
    \ a locally generated ID with a high probability of\n   being globally unique\
    \ to each implicit PvD.\n   We say that a PvD ID should be, or should have a high\
    \ probability of\n   being, globally unique.  The purpose of this is to make it\
    \ unlikely\n   that any individual node will ever accidentally see the same PvD\
    \ name\n   twice if it is not actually referring to the same PvD.  Protection\n\
    \   against deliberate attacks involving name clashes requires that the\n   name\
    \ be authenticated (see Section 7.2.1).\n   A PvD-aware node may use these IDs\
    \ to select a PvD with a matching ID\n   for special-purpose connection requests\
    \ in accordance with node\n   policy, as chosen by advanced applications, or to\
    \ present a human-\n   readable representation of the IDs to the end user for\
    \ selection of\n   PvDs.\n   A single network provider may operate multiple networks,\
    \ including\n   networks at different locations.  In such cases, the provider\
    \ may\n   chose whether to advertise single or multiple PvD identities at all\n\
    \   or some of those networks as it suits their business needs.  This\n   architecture\
    \ does not impose any specific requirements in this\n   regard.\n   When multiple\
    \ nodes are connected to the same link with one or more\n   explicit PvDs available,\
    \ this architecture assumes that the\n   information about all available PvDs\
    \ is made available by the\n   networks to all the connected nodes.  At the same\
    \ time, connected\n   nodes may have different heuristics, policies, and/or other\
    \ settings,\n   including their configured sets of trusted PvDs.  This may lead\
    \ to\n   different PvDs actually being used by different nodes for their\n   connections.\n\
    \   Possible extensions whereby networks advertise different sets of PvDs\n  \
    \ to different connected nodes are out of scope of this document.\n"
- title: 2.5.  The Relationship to Dual-Stack Networks
  contents:
  - "2.5.  The Relationship to Dual-Stack Networks\n   When applied to dual-stack\
    \ networks, the PvD definition allows for\n   multiple PvDs to be created whereby\
    \ each PvD contains information\n   relevant to only one address family, or for\
    \ a single PvD containing\n   information for multiple address families.  This\
    \ architecture\n   requires that accompanying design documents describing PvD-related\n\
    \   protocol changes must support PvDs containing information from\n   multiple\
    \ address families.  PvD-aware nodes must be capable of\n   creating and using\
    \ both single-family and multi-family PvDs.\n   For explicit PvDs, the choice\
    \ of either of these approaches is a\n   policy decision for the network administrator\
    \ and/or the node user/\n   administrator.  Since some of the IP configuration\
    \ information that\n   can be learned from the network can be applicable to multiple\
    \ address\n   families (for instance, DHCPv6 Address Selection Policy Option\n\
    \   [RFC7078]), it is likely that dual-stack networks will deploy single\n   PvDs\
    \ for both address families.\n   By default for implicit PvDs, PvD-aware nodes\
    \ shall include multiple\n   IP families into a single implicit PvD created for\
    \ an interface.  At\n   the time of writing, in dual-stack networks it appears\
    \ to be common\n   practice for the configuration of both address families to\
    \ be\n   provided by a single source.\n   A PvD-aware node that provides an API\
    \ to use, enumerate, and inspect\n   PvDs and/or their properties shall provide\
    \ the ability to filter PvDs\n   and/or their properties by address family.\n"
- title: 3.  Conveying PvD Information
  contents:
  - "3.  Conveying PvD Information\n   DHCPv6 and Router Advertisements (RAs) are\
    \ the two most common\n   methods of configuring hosts.  To support the architecture\
    \ described\n   in this document, these protocols would need to be extended to\
    \ convey\n   explicit PvD information.  The following sections describe topics\n\
    \   that must be considered before finalizing a mechanism to augment\n   DHCPv6\
    \ and RAs with PvD information.\n"
- title: 3.1.  Separate Messages or One Message?
  contents:
  - "3.1.  Separate Messages or One Message?\n   When information related to several\
    \ PvDs is available from the same\n   configuration source, there are two possible\
    \ ways of distributing\n   this information: One way is to send information from\
    \ each different\n   provisioning domain in separate messages.  The second method\
    \ is\n   combining the information from multiple PvDs into a single message.\n\
    \   The latter method has the advantage of being more efficient but could\n  \
    \ have problems with authentication and authorization, as well as\n   potential\
    \ issues with accommodating information not tagged with any\n   PvD information.\n"
- title: 3.2.  Securing PvD Information
  contents:
  - "3.2.  Securing PvD Information\n   DHCPv6 [RFC3315] and RAs [RFC3971] both provide\
    \ some form of\n   authentication to ensure the identity of the source as well\
    \ as the\n   integrity of the secured message content.  While this is useful,\n\
    \   determining authenticity does not tell a node whether the\n   configuration\
    \ source is actually allowed to provide information from\n   a given PvD.  To\
    \ resolve this, there must be a mechanism for the PvD\n   owner to attach some\
    \ form of authorization token or signature to the\n   configuration information\
    \ that is delivered.\n"
- title: 3.3.  Backward Compatibility
  contents:
  - "3.3.  Backward Compatibility\n   The extensions to RAs and DHCPv6 should be defined\
    \ in such a manner\n   that unmodified hosts (i.e., hosts not aware of PvDs) will\
    \ continue\n   to function as well as they did prior to PvD information being\
    \ added.\n   This could imply that some information may need to be duplicated\
    \ in\n   order to be conveyed to legacy hosts.  Similarly, PvD-aware hosts\n \
    \  need to be able to correctly utilize legacy configuration sources\n   that\
    \ do not provide PvD information.  There are also several\n   initiatives that\
    \ are aimed at adding some form of additional\n   information to prefixes [DHCPv6-CLASS-BASED-PREFIX]\n\
    \   [IPv6-PREFIX-PROPERTIES], and any new mechanism should try to\n   consider\
    \ coexistence with such deployed mechanisms.\n"
- title: 3.4.  Retracting/Updating PvD Information
  contents:
  - "3.4.  Retracting/Updating PvD Information\n   After PvD information is provisioned\
    \ to a host, it may become\n   outdated or superseded by updated information before\
    \ the hosts would\n   normally request updates.  To resolve this requires that\
    \ the\n   mechanism be able to update and/or withdraw all (or some subset) of\n\
    \   the information related to a given PvD.  For efficiency reasons,\n   there\
    \ should be a way to specify that all information from the PvD\n   needs to be\
    \ reconfigured instead of individually updating each item\n   associated with\
    \ the PvD.\n"
- title: 3.5.  Conveying Configuration Information Using IKEv2
  contents:
  - "3.5.  Conveying Configuration Information Using IKEv2\n   IKEv2 [RFC7296] [RFC5739]\
    \ is another widely used method of\n   configuring host IP information.  For IKEv2,\
    \ the provisioning domain\n   could be implicitly learned from the Identification\
    \ - Responder (IDr)\n   payloads that the IKEv2 initiator and responder inject\
    \ during their\n   IKEv2 exchange.  The IP configuration may depend on the named\
    \ IDr.\n   Another possibility could be adding a specific provisioning domain\n\
    \   identifying payload extensions to IKEv2.  All of the considerations\n   for\
    \ DHCPv6 and the RAs listed above potentially apply to IKEv2 as\n   well.\n"
- title: 4.  Example Network Configurations
  contents:
  - '4.  Example Network Configurations

    '
- title: 4.1.  A Mobile Node
  contents:
  - "4.1.  A Mobile Node\n   Consider a mobile node with two network interfaces: one\
    \ to the mobile\n   network, the other to the Wi-Fi network.  When the mobile\
    \ node is\n   only connected to the mobile network, it will typically have one\
    \ PvD,\n   implicit or explicit.  When the mobile node discovers and connects\
    \ to\n   a Wi-Fi network, it will have zero or more (typically one) additional\n\
    \   PvD(s).\n   Some existing OS implementations only allow one active network\n\
    \   connection.  In this case, only the PvD(s) associated with the active\n  \
    \ interface can be used at any given time.\n   As an example, the mobile network\
    \ can explicitly deliver PvD\n   information through the Packet Data Protocol\
    \ (PDP) context activation\n   process.  Then, the PvD-aware mobile node will\
    \ treat the mobile\n   network as an explicit PvD.  Conversely, the legacy Wi-Fi\
    \ network may\n   not explicitly communicate PvD information to the mobile node.\
    \  The\n   PvD-aware mobile node will associate network configuration for the\n\
    \   Wi-Fi network with an implicit PvD in this case.\n   The following diagram\
    \ illustrates the use of different PvDs in this\n   scenario:\n              \
    \   <----------- Wi-Fi 'Internet' PvD -------->\n        +---------+\n       \
    \ | +-----+ |    +-----+         _   __               _  _\n        | |Wi-Fi|\
    \ |    |     |        ( `    )             ( `   )_\n        | |-IF  + |----+\
    \     |---------------------------(         `)\n        | |     | |    |Wi-Fi|\
    \      (         )         (  Internet  )\n        | +-----+ |    | AP  |    \
    \ (           )        (            )\n        |         |    |     |    (   Service\
    \    )      (            )\n        |         |    +-----+    (  Provider's  \
    \ )     (            )\n        |         |               (   Networks    -  \
    \   (            )\n        | +----+  |                `_            )      (\
    \            )\n        | |CELL|  |                 (          )        (    \
    \        )\n        | |-IF +--|-------------------------------------(        \
    \    )\n        | |    |  |                 (_     __)          (_          _)\n\
    \        | +----+  |                  `- --               `- __  _) -\n      \
    \  +---------+\n                 <------- Mobile 'Internet' PvD ----------->\n\
    \     Figure 1: An Example of PvD Use with Wi-Fi and Mobile Interfaces\n"
- title: 4.2.  A Node with a VPN Connection
  contents:
  - "4.2.  A Node with a VPN Connection\n   If the node has established a VPN connection,\
    \ zero or more (typically\n   one) additional PvD(s) will be created.  These may\
    \ be implicit or\n   explicit.  The routing to IP addresses reachable within this\
    \ PvD will\n   be set up via the VPN connection, and the routing of packets to\n\
    \   addresses outside the scope of this PvD will remain unaffected.  If a\n  \
    \ node already has N connected PvDs, after the VPN session has been\n   established\
    \ typically there will be N+1 connected PvDs.\n   The following diagram illustrates\
    \ the use of different PvDs in this\n   scenario:\n             <----------- 'Internet'\
    \ PvD ------>\n    +--------+\n    | +----+ |    +----+         _   __       \
    \ _  _\n    | |Phy | |    |    |        ( `    )      ( `   )_\n    | |-IF +-|----+\
    \    |--------------------(         `)\n    | |    | |    |    |      (      \
    \   )  (_ Internet  _)\n    | +----+ |    |    |     (           )   `- __  _)\
    \ -\n    |        |    |Home|    (   Service    )      ||\n    |        |    |Gate|\
    \    (  Provider's   )     ||\n    |        |    |-way|    (   Network     - \
    \    ||\n    | +----+ |    |    |    `_            )  +---------+  +------------+\n\
    \    | |VPN | |    |    |      (          )   |   VPN   |  |            |\n  \
    \  | |-IF +-|----+    |---------------------+ Gateway |--+  Private   |\n    |\
    \ |    | |    |    |       (_     __)    |         |  |  Services  |\n    | +----+\
    \ |    +----+         `- --       +---------+  +------------+\n    +--------+\n\
    \             <-------------- Explicit 'VPN' PvD ----->\n                 Figure\
    \ 2: An Example of PvD Use with VPN\n"
- title: 4.3.  A Home Network and a Network Operator with Multiple PvDs
  contents:
  - "4.3.  A Home Network and a Network Operator with Multiple PvDs\n   An operator\
    \ may use separate PvDs for individual services that they\n   offer to their customers.\
    \  These may be used so that services can be\n   designed and provisioned to be\
    \ completely independent of each other,\n   allowing for complete flexibility\
    \ in combinations of services that\n   are offered to customers.\n   From the\
    \ perspective of the home network and the node, this model is\n   functionally\
    \ very similar to being multihomed to multiple upstream\n   operators: Each of\
    \ the different services offered by the service\n   provider is its own PvD with\
    \ associated PvD information.  In this\n   case, the operator may provide a generic/default\
    \ PvD (explicit or\n   implicit), which provides Internet access to the customer.\n\
    \   Additional services would then be provisioned as explicit PvDs for\n   subscribing\
    \ customers.\n   The following diagram illustrates this, using video-on-demand\
    \ as a\n   service-specific PvD:\n                <------ Implicit 'Internet'\
    \ PvD ------>\n           +----+     +-----+        _   __              _  _\n\
    \           |    |     |     |       ( `    )            ( `   )_\n          \
    \ | PC +-----+     |-------------------------(         `)\n           |    | \
    \    |     |     (         )        (_ Internet  _)\n           +----+     | \
    \    |    (           )         `- __  _) -\n                      |Home |   (\
    \   Service    )\n                      |Gate-|   (  Provider's   )\n        \
    \              |way  |   (   Network     -\n           +-----+    |     |   `_\
    \            )        +-----------+\n           | Set-|    |     |     (     \
    \     )         |ISP Video- |\n           | Top +----+     |--------------------------+on-Demand\
    \  |\n           | Box |    |     |      (_     __)          | Service   |\n \
    \          +-----+    +-----+        `- --             +-----------+\n       \
    \          <-- Explicit 'Video-on-Demand' PvD -->\n     Figure 3: An Example of\
    \ PvD Use with Wi-Fi and Mobile Interfaces\n   In this case, the number of PvDs\
    \ that a single operator could\n   provision is based on the number of independently\
    \ provisioned\n   services that they offer.  Some examples may include:\n   o\
    \  Real-time packet voice\n   o  Streaming video\n   o  Interactive video (n-way\
    \ video conferencing)\n   o  Interactive gaming\n   o  Best effort / Internet\
    \ access\n"
- title: 5.  Reference Model for the PvD-Aware Node
  contents:
  - '5.  Reference Model for the PvD-Aware Node

    '
- title: 5.1.  Constructions and Maintenance of Separate PvDs
  contents:
  - "5.1.  Constructions and Maintenance of Separate PvDs\n   It is assumed that normally,\
    \ the configuration information contained\n   in a single PvD shall be sufficient\
    \ for a node to fulfill a network\n   connection request by an application, and\
    \ hence there should be no\n   need to attempt to merge information across different\
    \ PvDs.\n   Nevertheless, even when a PvD lacks some necessary configuration\n\
    \   information, merging of information associated with a different\n   PvD(s)\
    \ shall not be done automatically as this will typically lead to\n   the issues\
    \ described in [RFC6418].\n   A node may use other sources, for example: node\
    \ local policy, user\n   input, or other mechanisms not defined by the IETF for\
    \ any of the\n   following:\n   o  Construction of a PvD in its entirety (analogous\
    \ to statically\n      configuring IP on an interface)\n   o  Supplementing some\
    \ or all learned PvDs with particular\n      configuration elements\n   o  Merging\
    \ of information from different PvDs (if this is explicitly\n      allowed by\
    \ policy)\n   As an example, a node administrator could configure the node to\
    \ use a\n   specific DNS resolver on a particular interface, or for a particular\n\
    \   named PvD.  In the case of a per-interface DNS resolver, this might\n   override\
    \ or augment the DNS resolver configuration for PvDs that are\n   discovered on\
    \ that interface.  Such creation/augmentation of a PvD(s)\n   could be static\
    \ or dynamic.  The specific mechanism(s) for\n   implementing this is outside\
    \ the scope of this document.  Such a\n   merging or overriding of DNS resolver\
    \ configuration might be contrary\n   to the policy that applies to a special-purpose\
    \ connection, such as,\n   for example, those discussed in Sections 5.2.1 and\
    \ 5.2.4.  In such\n   cases, either the special-purpose connection should not\
    \ be used or\n   the merging/overriding should not be performed.\n"
- title: 5.2.  Consistent Use of PvDs for Network Connections
  contents:
  - "5.2.  Consistent Use of PvDs for Network Connections\n   PvDs enable PvD-aware\
    \ nodes to consistently use the correct set of\n   configuration elements to serve\
    \ specific network requests from\n   beginning to end.  This section provides\
    \ examples of such use.\n"
- title: 5.2.1.  Name Resolution
  contents:
  - "5.2.1.  Name Resolution\n   When a PvD-aware node needs to resolve the name of\
    \ the destination\n   for use by a connection request, the node could use one\
    \ or multiple\n   PvDs for a given name lookup.\n   The node shall choose a single\
    \ PvD if, for example, the node policy\n   required the use of a particular PvD\
    \ for a specific purpose (e.g., to\n   download a Multimedia Messaging Service\
    \ (MMS) message using a\n   specific Access Point Name (APN) over a cellular connection\
    \ or to\n   direct traffic of enterprise applications to a VPN connection to the\n\
    \   enterprise network).  To make this selection, the node could use a\n   match\
    \ between the PvD DNS suffix and a Fully Qualified Domain Name\n   (FQDN) that\
    \ is being resolved or a match of the PvD ID, as determined\n   by the node policy.\n\
    \   The node may pick multiple PvDs if, for example, the PvDs are for\n   general\
    \ purpose Internet connectivity, and the node is attempting to\n   maximize the\
    \ probability of connectivity similar to the Happy\n   Eyeballs [RFC6555] approach.\
    \  In this case, the node could perform\n   DNS lookups in parallel, or in sequence.\
    \  Alternatively, the node may\n   use only one PvD for the lookup, based on the\
    \ PvD connectivity\n   properties, user configuration of preferred Internet PvD,\
    \ etc.\n   If an application implements an API that provides a way of explicitly\n\
    \   specifying the desired interface or PvD, that interface or PvD should\n  \
    \ be used for name resolution (and the subsequent connection attempt),\n   provided\
    \ that the host's configuration permits this.\n   In either case, by default a\
    \ node uses information obtained via a\n   name service lookup to establish connections\
    \ only within the same PvD\n   as the lookup results were obtained.\n   For clarification,\
    \ when it is written that the name service lookup\n   results were obtained \"\
    from a PvD\", it should be understood to mean\n   that the name service query\
    \ was issued against a name service that is\n   configured for use in a particular\
    \ PvD.  In that sense, the results\n   are \"from\" that particular PvD.\n   Some\
    \ nodes may support transports and/or APIs that provide an\n   abstraction of\
    \ a single connection, aggregating multiple underlying\n   connections.  Multipath\
    \ TCP (MPTCP) [RFC6182] is an example of such a\n   transport protocol.  For connections\
    \ provided by such transports/\n   APIs, a PvD-aware node may use different PvDs\
    \ for servicing that\n   logical connection, provided that all operations on the\
    \ underlying\n   connections are performed consistently within their corresponding\n\
    \   PvD(s).\n"
- title: 5.2.2.  Next-Hop and Source Address Selection
  contents:
  - "5.2.2.  Next-Hop and Source Address Selection\n   For the purpose of this example,\
    \ let us assume that the preceding\n   name lookup succeeded in a particular PvD.\
    \  For each obtained\n   destination address, the node shall perform a next-hop\
    \ lookup among\n   routers associated with that PvD.  As an example, the node\
    \ could\n   determine such associations via matching the source address prefixes\n\
    \   / specific routes advertised by the router against known PvDs or by\n   receiving\
    \ an explicit PvD affiliation advertised through a new Router\n   Discovery [RFC4861]\
    \ option.\n   For each destination, once the best next hop is found, the node\n\
    \   selects the best source address according to rules defined in\n   [RFC6724],\
    \ but with the constraint that the source address must\n   belong to a range associated\
    \ with the used PvD.  If needed, the node\n   would use the prefix policy from\
    \ the same PvD for selecting the best\n   source address from multiple candidates.\n\
    \   When destination/source pairs are identified, they are sorted using\n   the\
    \ [RFC6724] destination sorting rules and prefix policy table from\n   the used\
    \ PvD.\n"
- title: 5.2.3.  Listening Applications
  contents:
  - "5.2.3.  Listening Applications\n   Consider a host connected to several PvDs,\
    \ running an application\n   that opens a listening socket / transport API object.\
    \  The\n   application is authorized by the host policy to use a subset of\n \
    \  connected PvDs that may or may not be equal to the complete set of\n   the\
    \ connected PvDs.  As an example, in the case where there are\n   different PvDs\
    \ on the Wi-Fi and cellular interfaces, for general\n   Internet traffic the host\
    \ could use only one, preferred PvD at a time\n   (and accordingly, advertise\
    \ to remote peers the host name and\n   addresses associated with that PvD), or\
    \ it could use one PvD as the\n   default for outgoing connections, while still\
    \ allowing use of the\n   other PvDs simultaneously.\n   Another example is a\
    \ host with an established VPN connection.  Here,\n   security policy could be\
    \ used to permit or deny an application's\n   access to the VPN PvD and other\
    \ PvDs.\n   For non-PvD-aware applications, the operating system has policies\n\
    \   that determine the authorized set of PvDs and the preferred outgoing\n   PvD.\
    \  For PvD-aware applications, both the authorized set of PvDs and\n   the default\
    \ outgoing PvD can be determined as the common subset\n   produced between the\
    \ OS policies and the set of PvD IDs or\n   characteristics provided by the application.\n\
    \   Application input could be provided on a per-application, per-\n   transport-API-object,\
    \ or per-transport-API-call basis.  The API for\n   application input may have\
    \ an option for specifying whether the input\n   should be treated as a preference\
    \ instead of a requirement.\n"
- title: 5.2.3.1.  Processing of Incoming Traffic
  contents:
  - "5.2.3.1.  Processing of Incoming Traffic\n   Unicast IP packets are received\
    \ on a specific IP address associated\n   with a PvD.  For multicast packets,\
    \ the host can derive the PvD\n   association from other configuration information,\
    \ such as an explicit\n   PvD property or local policy.\n   The node OS or middleware\
    \ may apply more advanced techniques for\n   determining the resultant PvD and/or\
    \ authorization of the incoming\n   traffic.  Those techniques are outside the\
    \ scope of this document.\n   If the determined receiving PvD of a packet is not\
    \ in the allowed\n   subset of PvDs for the particular application/transport API\
    \ object,\n   the packet should be handled in the same way as if there were no\n\
    \   listener.\n"
- title: 5.2.3.1.1.  Connection-Oriented APIs
  contents:
  - "5.2.3.1.1.  Connection-Oriented APIs\n   For connection-oriented APIs, when the\
    \ initial incoming packet is\n   received, the packet PvD is remembered for the\
    \ established connection\n   and used for the handling of outgoing traffic for\
    \ that connection.\n   While typically connection-oriented APIs use a connection-oriented\n\
    \   transport protocol, such as TCP, it is possible to have a connection-\n  \
    \ oriented API that uses a generally connectionless transport protocol,\n   such\
    \ as UDP.\n   For APIs/protocols that support multiple IP traffic flows associated\n\
    \   with a single transport API connection object (for example, Multipath\n  \
    \ TCP), the processing rules may be adjusted accordingly.\n"
- title: 5.2.3.1.2.  Connectionless APIs
  contents:
  - "5.2.3.1.2.  Connectionless APIs\n   For connectionless APIs, the host should\
    \ provide an API that\n   PvD-aware applications can use to query the PvD associated\
    \ with the\n   packet.  For outgoing traffic on this transport API object, the\
    \ OS\n   should use the selected outgoing PvDs, determined as described in\n \
    \  Sections 5.2.1 and 5.2.2.\n"
- title: 5.2.4.  Enforcement of Security Policies
  contents:
  - "5.2.4.  Enforcement of Security Policies\n   By themselves, PvDs do not define,\
    \ and cannot be used for\n   communication of, security policies.  When implemented\
    \ in a network,\n   this architecture provides the host with information about\
    \ connected\n   networks.  The actual behavior of the host then depends on the\
    \ host's\n   policies (provisioned through mechanisms out of scope of this\n \
    \  document), applied by taking received PvD information into account.\n   In\
    \ some scenarios, e.g., a VPN, such policies could require the host\n   to use\
    \ only a particular VPN PvD for some/all of the application's\n   traffic (VPN\
    \ 'disable split tunneling' also known as 'force\n   tunneling' behavior) or apply\
    \ such restrictions only to selected\n   applications and allow the simultaneous\
    \ use of the VPN PvD together\n   with the other connected PvDs by the other or\
    \ all applications (VPN\n   'split tunneling' behavior).\n"
- title: 5.3.  Connectivity Tests
  contents:
  - "5.3.  Connectivity Tests\n   Although some PvDs may appear as valid candidates\
    \ for PvD selection\n   (e.g., good link quality, consistent connection parameters,\
    \ etc.),\n   they may provide limited or no connectivity to the desired network\
    \ or\n   the Internet.  For example, some PvDs provide limited IP connectivity\n\
    \   (e.g., scoped to the link or to the access network) but require the\n   node\
    \ to authenticate through a web portal to get full access to the\n   Internet.\
    \  This may be more likely to happen for PvDs that are not\n   trusted by a given\
    \ PvD-aware node.\n   An attempt to use such a PvD may lead to limited network\
    \ connectivity\n   or application connection failures.  To prevent the latter,\
    \ a PvD-\n   aware node may perform a connectivity test for the PvD before using\n\
    \   it to serve application network connection requests.  In current\n   implementations,\
    \ some nodes already implement this, e.g., by trying\n   to reach a dedicated\
    \ web server (see [RFC6419]).\n   Section 5.2 describes how a PvD-aware node shall\
    \ maintain and use\n   multiple PvDs separately.  The PvD-aware node shall perform\
    \ a\n   connectivity test and, only after validation of the PvD, consider\n  \
    \ using it to serve application connections requests.  Ongoing\n   connectivity\
    \ tests are also required, since during the IP session,\n   the end-to-end connectivity\
    \ could be disrupted for various reasons\n   (e.g., L2 problems and IP QoS issues);\
    \ hence, a connectivity\n   monitoring function is needed to check the connectivity\
    \ status and\n   remove the PvD from the set of usable PvDs if necessary.\n  \
    \ There may be cases where a connectivity test for PvD selection may\n   not be\
    \ appropriate and should be complemented, or replaced, by PvD\n   selection based\
    \ on other factors.  For example, this could be\n   realized by leveraging some\
    \ 3GPP and IEEE mechanisms, which would\n   allow the exposure of some PvD characteristics\
    \ to the node (e.g.,\n   3GPP Access Network Discovery and Selection Function\
    \ (ANDSF)\n   [TS23402], Access Network Query Protocol (ANQP) [IEEE802.11u]).\n"
- title: 5.4.  Relationship to Interface Management and Connection Managers
  contents:
  - "5.4.  Relationship to Interface Management and Connection Managers\n   Current\
    \ devices such as mobile handsets make use of proprietary\n   mechanisms and custom\
    \ applications to manage connectivity in\n   environments with multiple interfaces\
    \ and multiple sets of network\n   configuration.  These mechanisms or applications\
    \ are commonly known\n   as connection managers [RFC6419].\n   Connection managers\
    \ sometimes rely on policy servers to allow a node\n   that is connected to multiple\
    \ networks to perform network selection.\n   They can also make use of routing\
    \ guidance from the network (e.g.,\n   3GPP ANDSF [TS23402]).  Although connection\
    \ managers solve some\n   connectivity problems, they rarely address network selection\
    \ problems\n   in a comprehensive manner.  With proprietary solutions, it is\n\
    \   challenging to present coherent behavior to the end user of the\n   device,\
    \ as different platforms present different behaviors even when\n   connected to\
    \ the same network, with the same type of interface, and\n   for the same purpose.\
    \  The architecture described in this document\n   should improve the host's behavior\
    \ by providing the hosts with tools\n   and guidance to make informed network\
    \ selection decisions.\n"
- title: 6.  PvD Support in APIs
  contents:
  - "6.  PvD Support in APIs\n   For all levels of PvD support in APIs described in\
    \ this chapter, it\n   is expected that the notifications about changes in the\
    \ set of\n   available PvDs are exposed as part of the API surface.\n"
- title: 6.1.  Basic
  contents:
  - "6.1.  Basic\n   Applications are not PvD aware in any manner and only submit\n\
    \   connection requests.  The node performs PvD selection implicitly,\n   without\
    \ any application participation, based purely on node-specific\n   administrative\
    \ policies and/or choices made by the user from a user\n   interface provided\
    \ by the operating environment, not by the\n   application.\n   As an example,\
    \ PvD selection can be done at the name service lookup\n   step by using the relevant\
    \ configuration elements, such as those\n   described in [RFC6731].  As another\
    \ example, PvD selection could be\n   made based on application identity or type\
    \ (i.e., a node could always\n   use a particular PvD for a Voice over IP (VoIP)\
    \ application).\n"
- title: 6.2.  Intermediate
  contents:
  - "6.2.  Intermediate\n   Applications indirectly participate in PvD selection by\
    \ specifying\n   hard requirements and soft preferences.  As an example, a real-time\n\
    \   communication application intending to use the connection for the\n   exchange\
    \ of real-time audio/video data may indicate a preference or a\n   requirement\
    \ for connection quality, which could affect PvD selection\n   (different PvDs\
    \ could correspond to Internet connections with\n   different loss rates and latencies).\n\
    \   Another example is the connection of an infrequently executed\n   background\
    \ activity, which checks for application updates and\n   performs large downloads\
    \ when updates are available.  For such\n   connections, a cheaper or zero-cost\
    \ PvD may be preferable, even if\n   such a connection has a higher relative loss\
    \ rate or lower bandwidth.\n   The node performs PvD selection based on applications'\
    \ inputs and\n   policies and/or user preferences.  Some/all properties of the\n\
    \   resultant PvD may be exposed to applications.\n"
- title: 6.3.  Advanced
  contents:
  - "6.3.  Advanced\n   PvDs are directly exposed to applications for enumeration\
    \ and\n   selection.  Node polices and/or user choices may still override the\n\
    \   applications' preferences and limit which PvD(s) can be enumerated\n   and/or\
    \ used by the application, irrespective of any preferences that\n   the application\
    \ may have specified.  Depending on the implementation,\n   such restrictions\
    \ (imposed by node policy and/or user choice) may or\n   may not be visible to\
    \ the application.\n"
- title: 7.  PvD Trust for PvD-Aware Node
  contents:
  - '7.  PvD Trust for PvD-Aware Node

    '
- title: 7.1.  Untrusted PvDs
  contents:
  - "7.1.  Untrusted PvDs\n   Implicit and explicit PvDs for which no trust relationship\
    \ exists are\n   considered untrusted.  Only PvDs that meet the requirements in\n\
    \   Section 7.2 are trusted; any other PvD is untrusted.\n   In order to avoid\
    \ the various forms of misinformation that could\n   occur when PvDs are untrusted,\
    \ nodes that implement PvD separation\n   cannot assume that two explicit PvDs\
    \ with the same identifier are\n   actually the same PvD.  A node that makes this\
    \ assumption will be\n   vulnerable to attacks where, for example, an open Wi-Fi\
    \ hotspot might\n   assert that it was part of another PvD and thereby attempt\
    \ to draw\n   traffic intended for that PvD onto its own network.\n   Since implicit\
    \ PvD identifiers are synthesized by the node, this\n   issue cannot arise with\
    \ implicit PvDs.\n   Mechanisms exist (for example, [RFC6731]) whereby a PvD can\
    \ provide\n   configuration information that asserts special knowledge about the\n\
    \   reachability of resources through that PvD.  Such assertions cannot\n   be\
    \ validated unless the node has a trust relationship with the PvD;\n   therefore,\
    \ assertions of this type must be ignored by nodes that\n   receive them from\
    \ untrusted PvDs.  Failure to ignore such assertions\n   could result in traffic\
    \ being diverted from legitimate destinations\n   to spoofed destinations.\n"
- title: 7.2.  Trusted PvDs
  contents:
  - "7.2.  Trusted PvDs\n   Trusted PvDs are PvDs for which two conditions apply:\
    \ First, a trust\n   relationship must exist between the node that is using the\
    \ PvD\n   configuration and the source that provided that configuration; this\n\
    \   is the authorization portion of the trust relationship.  Second,\n   there\
    \ must be some way to validate the trust relationship.  This is\n   the authentication\
    \ portion of the trust relationship.  Two mechanisms\n   for validating the trust\
    \ relationship are defined.\n   It shall be possible to validate the trust relationship\
    \ for all\n   advertised elements of a trusted PvD, irrespective of whether the\
    \ PvD\n   elements are communicated as a whole, e.g., in a single DHCP option,\n\
    \   or separately, e.g., in supplementary RA options.  The feasibility of\n  \
    \ mechanisms to implement a trust relationship for all PvD elements\n   will be\
    \ determined in the respective companion design documents.\n"
- title: 7.2.1.  Authenticated PvDs
  contents:
  - "7.2.1.  Authenticated PvDs\n   One way to validate the trust relationship between\
    \ a node and the\n   source of a PvD is through the combination of cryptographic\n\
    \   authentication and an identifier configured on the node.\n   If authentication\
    \ is done using a public key mechanism such as PKI\n   certificate chain validation\
    \ or DNS-Based Authentication of Named\n   Entities (DANE), authentication by\
    \ itself is not enough since\n   theoretically any PvD could be authenticated\
    \ in this way.  In\n   addition to authentication, the node would need configuration\
    \ to\n   trust the identifier being authenticated.  Validating the\n   authenticated\
    \ PvD name against a list of PvD names configured as\n   trusted on the node would\
    \ constitute the authorization step in this\n   case.\n"
- title: 7.2.2.  PvDs Trusted by Attachment
  contents:
  - "7.2.2.  PvDs Trusted by Attachment\n   In some cases, a trust relationship may\
    \ be validated by some means\n   other than those described in Section 7.2.1 simply\
    \ by virtue of the\n   connection through which the PvD was obtained.  For instance,\
    \ a\n   handset connected to a mobile network may know through the mobile\n  \
    \ network infrastructure that it is connected to a trusted PvD.\n   Whatever mechanism\
    \ was used to validate that connection constitutes\n   the authentication portion\
    \ of the PvD trust relationship.\n   Presumably, such a handset would be configured\
    \ from the factory (or\n   else through mobile operator or user preference settings)\
    \ to trust\n   the PvD, and this would constitute the authorization portion of\
    \ this\n   type of trust relationship.\n"
- title: 8.  Security Considerations
  contents:
  - "8.  Security Considerations\n   There are at least three different forms of attacks\
    \ that can be\n   performed using configuration sources that support multiple\n\
    \   provisioning domains.\n   Tampering with provided configuration information:\
    \  An attacker may\n      attempt to modify information provided inside the PvD\
    \ container\n      option.  These attacks can easily be prevented by using message\n\
    \      integrity features provided by the underlying protocol used to\n      carry\
    \ the configuration information.  For example, SEcure Neighbor\n      Discovery\
    \ (SEND) [RFC3971] would detect any form of tampering with\n      the RA contents\
    \ and the DHCPv6 [RFC3315] AUTH option that would\n      detect any form of tampering\
    \ with the DHCPv6 message contents.\n      This attack can also be performed by\
    \ a compromised configuration\n      source by modifying information inside a\
    \ specific PvD, in which\n      case the mitigations proposed in the next subsection\
    \ may be\n      helpful.\n   Rogue configuration source:  A compromised configuration\
    \ source, such\n      as a router or a DHCPv6 server, may advertise information\
    \ about\n      PvDs that it is not authorized to advertise.  For example, a\n\
    \      coffee shop WLAN may advertise configuration information\n      purporting\
    \ to be from an enterprise and may try to attract\n      enterprise-related traffic.\
    \  This may also occur accidentally if\n      two sites choose the same identifier\
    \ (e.g., \"linsky\").\n      In order to detect and prevent this, the client must\
    \ be able to\n      authenticate the identifier provided by the network.  This\
    \ means\n      that the client must have configuration information that maps the\n\
    \      PvD identifier to an identity and must be able to authenticate\n      that\
    \ identity.\n      In addition, the network must provide information the client\
    \ can\n      use to authenticate the identity.  This could take the form of a\n\
    \      PKI-based or DNSSEC-based trust anchor, or a key remembered from a\n  \
    \    previous leap-of-faith authentication of the identifier.\n      Because the\
    \ PvD-specific information may come to the network\n      infrastructure with\
    \ which the client is actually communicating\n      from some upstream provider,\
    \ it is necessary in this case that the\n      PvD container and its contents\
    \ be relayed to the client unchanged,\n      leaving the upstream provider's signature\
    \ intact.\n   Replay attacks:  A compromised configuration source or an on-link\n\
    \      attacker may try to capture advertised configuration information\n    \
    \  and replay it on a different link, or at a future point in time.\n      This\
    \ can be avoided by including a replay protection mechanism\n      such as a timestamp\
    \ or a nonce inside the PvD container to ensure\n      the validity of the provided\
    \ information.\n"
- title: 9.  Informative References
  contents:
  - "9.  Informative References\n   [DHCPv6-CLASS-BASED-PREFIX]\n              Systems,\
    \ C., Halwasia, G., Gundavelli, S., Deng, H.,\n              Thiebaut, L., Korhonen,\
    \ J., and I. Farrer, \"DHCPv6 class\n              based prefix\", Work in Progress,\
    \ draft-bhandari-dhc-class-\n              based-prefix-05, July 2013.\n   [IEEE802.11u]\n\
    \              IEEE, \"Local and Metropolitan networks - specific\n          \
    \    requirements - Part II: Wireless LAN Medium Access Control\n            \
    \  (MAC) and Physical Layer (PHY) specifications: Amendment\n              9:\
    \ Interworking with External Networks\", IEEE Std 802.11u,\n              <http://standards.ieee.org/findstds/\n\
    \              standard/802.11u-2011.html>.\n   [IPv6-PREFIX-PROPERTIES]\n   \
    \           Korhonen, J., Patil, B., Gundavelli, S., Seite, P., and D.\n     \
    \         Liu, \"IPv6 Prefix Mobility Management Properties\", Work in\n     \
    \         Progress, draft-korhonen-dmm-prefix-properties-03, October\n       \
    \       2012.\n   [RFC3315]  Droms, R., Ed., Bound, J., Volz, B., Lemon, T., Perkins,\n\
    \              C., and M. Carney, \"Dynamic Host Configuration Protocol\n    \
    \          for IPv6 (DHCPv6)\", RFC 3315, DOI 10.17487/RFC3315, July\n       \
    \       2003, <http://www.rfc-editor.org/info/rfc3315>.\n   [RFC3971]  Arkko,\
    \ J., Ed., Kempf, J., Zill, B., and P. Nikander,\n              \"SEcure Neighbor\
    \ Discovery (SEND)\", RFC 3971,\n              DOI 10.17487/RFC3971, March 2005,\n\
    \              <http://www.rfc-editor.org/info/rfc3971>.\n   [RFC4861]  Narten,\
    \ T., Nordmark, E., Simpson, W., and H. Soliman,\n              \"Neighbor Discovery\
    \ for IP version 6 (IPv6)\", RFC 4861,\n              DOI 10.17487/RFC4861, September\
    \ 2007,\n              <http://www.rfc-editor.org/info/rfc4861>.\n   [RFC5739]\
    \  Eronen, P., Laganier, J., and C. Madson, \"IPv6\n              Configuration\
    \ in Internet Key Exchange Protocol Version 2\n              (IKEv2)\", RFC 5739,\
    \ DOI 10.17487/RFC5739, February 2010,\n              <http://www.rfc-editor.org/info/rfc5739>.\n\
    \   [RFC6182]  Ford, A., Raiciu, C., Handley, M., Barre, S., and J.\n        \
    \      Iyengar, \"Architectural Guidelines for Multipath TCP\n              Development\"\
    , RFC 6182, DOI 10.17487/RFC6182, March 2011,\n              <http://www.rfc-editor.org/info/rfc6182>.\n\
    \   [RFC6418]  Blanchet, M. and P. Seite, \"Multiple Interfaces and\n        \
    \      Provisioning Domains Problem Statement\", RFC 6418,\n              DOI\
    \ 10.17487/RFC6418, November 2011,\n              <http://www.rfc-editor.org/info/rfc6418>.\n\
    \   [RFC6419]  Wasserman, M. and P. Seite, \"Current Practices for\n         \
    \     Multiple-Interface Hosts\", RFC 6419, DOI 10.17487/RFC6419,\n          \
    \    November 2011, <http://www.rfc-editor.org/info/rfc6419>.\n   [RFC6555]  Wing,\
    \ D. and A. Yourtchenko, \"Happy Eyeballs: Success with\n              Dual-Stack\
    \ Hosts\", RFC 6555, DOI 10.17487/RFC6555, April\n              2012, <http://www.rfc-editor.org/info/rfc6555>.\n\
    \   [RFC6724]  Thaler, D., Ed., Draves, R., Matsumoto, A., and T. Chown,\n   \
    \           \"Default Address Selection for Internet Protocol Version 6\n    \
    \          (IPv6)\", RFC 6724, DOI 10.17487/RFC6724, September 2012,\n       \
    \       <http://www.rfc-editor.org/info/rfc6724>.\n   [RFC6731]  Savolainen, T.,\
    \ Kato, J., and T. Lemon, \"Improved\n              Recursive DNS Server Selection\
    \ for Multi-Interfaced\n              Nodes\", RFC 6731, DOI 10.17487/RFC6731,\
    \ December 2012,\n              <http://www.rfc-editor.org/info/rfc6731>.\n  \
    \ [RFC7078]  Matsumoto, A., Fujisaki, T., and T. Chown, \"Distributing\n     \
    \         Address Selection Policy Using DHCPv6\", RFC 7078,\n              DOI\
    \ 10.17487/RFC7078, January 2014,\n              <http://www.rfc-editor.org/info/rfc7078>.\n\
    \   [RFC7296]  Kaufman, C., Hoffman, P., Nir, Y., Eronen, P., and T.\n       \
    \       Kivinen, \"Internet Key Exchange Protocol Version 2\n              (IKEv2)\"\
    , STD 79, RFC 7296, DOI 10.17487/RFC7296, October\n              2014, <http://www.rfc-editor.org/info/rfc7296>.\n\
    \   [TS23402]  3GPP, \"Technical Specification Group Services and System\n   \
    \           Aspects; Architecture enhancements for non-3GPP accesses\",\n    \
    \          Release 12, 3GPP TS 23.402, 2014.\n"
- title: Acknowledgments
  contents:
  - "Acknowledgments\n   The authors would like to thank (in no specific order) Ian\
    \ Farrer,\n   Markus Stenberg, and Mikael Abrahamsson for their review and\n \
    \  comments.\n"
- title: Contributors
  contents:
  - "Contributors\n   The following individuals contributed to this document (listed\
    \ in no\n   specific order): Alper Yegin (alper.yegin@yegin.org), Aaron Yi Ding\n\
    \   (yding@cs.helsinki.fi), Zhen Cao (caozhenpku@gmail.com), Dapeng Liu\n   (liudapeng@chinamobile.com),\
    \ Dave Thaler (dthaler@microsoft.com),\n   Dmitry Anipko (dmitry.anipko@gmail.com),\
    \ Hui Deng\n   (denghui@chinamobile.com), Jouni Korhonen (jouni.nospam@gmail.com),\n\
    \   Juan Carlos Zuniga (JuanCarlos.Zuniga@InterDigital.com), Konstantinos\n  \
    \ Pentikousis (k.pentikousis@huawei.com), Marc Blanchet\n   (marc.blanchet@viagenie.ca),\
    \ Margaret Wasserman\n   (margaretw42@gmail.com), Pierrick Seite (pierrick.seite@orange.com),\n\
    \   Suresh Krishnan (suresh.krishnan@ericsson.com), Teemu Savolainen\n   (teemu.savolainen@nokia.com),\
    \ Ted Lemon (ted.lemon@nominum.com), and\n   Tim Chown (tjc@ecs.soton.ac.uk).\n"
- title: Author's Address
  contents:
  - "Author's Address\n   Dmitry Anipko (editor)\n   Unaffiliated\n   Phone: +1 425\
    \ 442 6356\n   EMail: dmitry.anipko@gmail.com\n"
