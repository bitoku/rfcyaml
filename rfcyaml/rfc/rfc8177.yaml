- contents:
  - '                     YANG Data Model for Key Chains

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document describes the key chain YANG data model.  Key chains\n
    \  are commonly used for routing protocol authentication and other\n   applications
    requiring symmetric keys.  A key chain is a list\n   containing one or more elements
    containing a Key ID, key string,\n   send/accept lifetimes, and the associated
    authentication or\n   encryption algorithm.  By properly overlapping the send
    and accept\n   lifetimes of multiple key chain elements, key strings and algorithms\n
    \  may be gracefully updated.  By representing them in a YANG data\n   model,
    key distribution can be automated.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc8177.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2017 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   3\n     1.1.  Requirements Notation . . . . . . . . . . . . . . .
    . . .   3\n     1.2.  Tree Diagrams . . . . . . . . . . . . . . . . . . . . .
    .   3\n   2.  Problem Statement . . . . . . . . . . . . . . . . . . . . . .   4\n
    \    2.1.  Applicability . . . . . . . . . . . . . . . . . . . . . .   4\n     2.2.
    \ Graceful Key Rollover Using Key Chains  . . . . . . . . .   4\n   3.  Design
    of the Key Chain Model . . . . . . . . . . . . . . . .   5\n     3.1.  Key Chain
    Operational State . . . . . . . . . . . . . . .   6\n     3.2.  Key Chain Model
    Features  . . . . . . . . . . . . . . . .   6\n     3.3.  Key Chain Model Tree
    \ . . . . . . . . . . . . . . . . . .   7\n   4.  Key Chain YANG Model  . . .
    . . . . . . . . . . . . . . . . .   8\n   5.  Security Considerations . . . .
    . . . . . . . . . . . . . . .  16\n   6.  IANA Considerations . . . . . . . .
    . . . . . . . . . . . . .  17\n   7.  References  . . . . . . . . . . . . . .
    . . . . . . . . . . .  18\n     7.1.  Normative References  . . . . . . . . .
    . . . . . . . . .  18\n     7.2.  Informative References  . . . . . . . . . .
    . . . . . . .  19\n   Appendix A.  Examples . . . . . . . . . . . . . . . . .
    . . . . .  21\n     A.1.  Simple Key Chain with an Always Valid Single Key  .
    . . .  21\n     A.2.  Key Chain with Keys Having Different Lifetimes  . . . .
    .  21\n     A.3.  Key Chain with Independent Send and Accept Lifetimes  . .  23\n
    \  Contributors  . . . . . . . . . . . . . . . . . . . . . . . . . .  24\n   Acknowledgments
    . . . . . . . . . . . . . . . . . . . . . . . . .  24\n   Authors' Addresses  .
    . . . . . . . . . . . . . . . . . . . . . .  25\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   This document describes the key chain YANG [YANG-1.1] data
    model.\n   Key chains are commonly used for routing protocol authentication and\n
    \  other applications requiring symmetric keys.  A key chain is a list\n   containing
    one or more elements containing a Key ID, key string,\n   send/accept lifetimes,
    and the associated authentication or\n   encryption algorithm.  By properly overlapping
    the send and accept\n   lifetimes of multiple key chain elements, key strings
    and algorithms\n   may be gracefully updated.  By representing them in a YANG
    data\n   model, key distribution can be automated.\n   In some applications, the
    protocols do not use the key chain element\n   key directly, but rather a key
    derivation function is used to derive\n   a short-lived key from the key chain
    element key (e.g., the master\n   keys used in [TCP-AO]).\n"
  - contents:
    - "1.1.  Requirements Notation\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\",
      \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT
      RECOMMENDED\", \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted
      as described in\n   BCP 14 [KEYWORDS] [KEYWORDS-UPD] when, and only when, they
      appear in\n   all capitals, as shown here.\n"
    title: 1.1.  Requirements Notation
  - contents:
    - "1.2.  Tree Diagrams\n   A simplified graphical representation of the complete
      data tree is\n   presented in Section 3.3.  The following tree notation is used.\n
      \  o  Brackets \"[\" and \"]\" enclose YANG list keys.  These YANG list keys\n
      \     should not be confused with the key chain keys.\n   o  Curly braces \"{\"
      and \"}\" contain names of optional features that\n      make the corresponding
      node conditional.\n   o  Abbreviations before data node names: \"rw\" means
      configuration\n      (read-write), \"ro\" means state data (read-only), \"-x\"
      means RPC\n      operations, and \"-n\" means notifications.\n   o  Symbols
      after data node names: \"?\" means an optional node, \"!\"\n      denotes a
      container with presence, and \"*\" denotes a \"list\" or\n      \"leaf-list\".\n
      \  o  Parentheses enclose choice and case nodes, and case nodes are also\n      marked
      with a colon (\":\").\n   o  Ellipsis (\"...\") stands for contents of subtrees
      that are not\n      shown.\n"
    title: 1.2.  Tree Diagrams
  title: 1.  Introduction
- contents:
  - "2.  Problem Statement\n   This document describes a YANG [YANG-1.1] data model
    for key chains.\n   Key chains have been implemented and deployed by a large percentage\n
    \  of network equipment vendors.  Providing a standard YANG model will\n   facilitate
    automated key distribution and non-disruptive key\n   rollover.  This will aid
    in tightening the security of the core\n   routing infrastructure as recommended
    in [IAB-REPORT].\n   A key chain is a list containing one or more elements containing
    a\n   Key ID, key string, send/accept lifetimes, and the associated\n   authentication
    or encryption algorithm.  A key chain can be used by\n   any service or application
    requiring authentication or encryption\n   using symmetric keys.  In essence,
    the key chain is a reusable key\n   policy that can be referenced wherever it
    is required.  The key chain\n   construct has been implemented by most networking
    vendors and\n   deployed in many networks.\n   A conceptual representation of
    a crypto key table is described in\n   [CRYPTO-KEYTABLE].  The crypto key table
    includes keys as well as\n   their corresponding lifetimes and algorithms.  Additionally,
    the key\n   table includes key selection criteria and is designed for a\n   deployment
    model where the details of the applications or services\n   requiring authentication
    or encryption permeate into the key\n   database.  The YANG key chain model described
    herein doesn't include\n   key selection criteria or support this deployment model.
    \ At the same\n   time, it does not preclude it.  [YANG-CRYPTO-KEYTABLE] describes\n
    \  augmentations to the key chain YANG model in support of key selection\n   criteria.\n"
  - contents:
    - "2.1.  Applicability\n   Other YANG modules may reference ietf-key-chain YANG
      module key-chain\n   names for authentication and encryption applications.  A
      YANG type\n   has been provided to facilitate reference to the key-chain name\n
      \  without having to specify the complete YANG XML Path Language (XPath)\n   expression.\n"
    title: 2.1.  Applicability
  - contents:
    - "2.2.  Graceful Key Rollover Using Key Chains\n   Key chains may be used to
      gracefully update the key string and/or\n   algorithm used by an application
      for authentication or encryption.\n   To achieve graceful key rollover, the
      receiver MAY accept all the\n   keys that have a valid accept lifetime, and
      the sender MAY send the\n   key with the most recent send lifetime.  One scenario
      for\n   facilitating key rollover is to:\n   1.  Distribute a key chain with
      a new key to all the routers or other\n       network devices in the domain
      of that key chain.  The new key's\n       accept lifetime should be such that
      it is accepted during the key\n       rollover period.  The send lifetime should
      be a time in the\n       future when it can be assured that all the routers
      in the domain\n       of that key are upgraded.  This will have no immediate
      impact on\n       the keys used for transmission.\n   2.  Assure that all the
      network devices have been updated with the\n       updated key chain and that
      their system times are roughly\n       synchronized.  The system times of devices
      within an\n       administrative domain are commonly synchronized (e.g., using
      the\n       Network Time Protocol (NTP) [NTP-PROTO]).  This also may be\n       automated.\n
      \  3.  When the send lifetime of the new key becomes valid, the network\n       devices
      within the domain of that key chain will use the new key\n       for transmissions.\n
      \  4.  At some point in the future, a new key chain with the old key\n       removed
      may be distributed to the network devices within the\n       domain of the key
      chain.  However, this may be deferred until the\n       next key rollover.  If
      this is done, the key chain will always\n       include two keys: either the
      current and future key (during key\n       rollovers) or the current and previous
      keys (between key\n       rollovers).\n   Since the most recent send lifetime
      is defined as the one with the\n   latest start-time, specification of \"always\"
      will prevent using the\n   graceful key rollover technique described above.
      \ Other key\n   configuration and usage scenarios are possible, but these are
      beyond\n   the scope of this document.\n"
    title: 2.2.  Graceful Key Rollover Using Key Chains
  title: 2.  Problem Statement
- contents:
  - "3.  Design of the Key Chain Model\n   The ietf-key-chain module contains a list
    of one or more keys indexed\n   by a Key ID.  For some applications (e.g., OSPFv3
    [OSPFV3-AUTH]), the\n   Key ID is used to identify the key chain key to be used.
    \ In addition\n   to the Key ID, each key chain key includes a key string and
    a\n   cryptographic algorithm.  Optionally, the key chain keys include\n   send/accept
    lifetimes.  If the send/accept lifetime is unspecified,\n   the key is always
    considered valid.\n   Note that different key values for transmission versus acceptance
    may\n   be supported with multiple key chain elements.  The key used for\n   transmission
    will have a valid send-lifetime and invalid accept-\n   lifetime (e.g., has an
    end-time equal to the start-time).  The key\n   used for acceptance will have
    a valid accept-lifetime and invalid\n   send-lifetime.\n   Due to the differences
    in key chain implementations across various\n   vendors, some of the data elements
    are optional.  Finally, the crypto\n   algorithm identities are provided for reuse
    when configuring legacy\n   authentication and encryption not using key chains.\n
    \  A key chain is identified by a unique name within the scope of the\n   network
    device.  The \"key-chain-ref\" typedef SHOULD be used by other\n   YANG modules
    when they need to reference a configured key chain.\n"
  - contents:
    - "3.1.  Key Chain Operational State\n   The key chain operational state is included
      in the same tree as key\n   chain configuration consistent with Network Management
      Datastore\n   Architecture [NMDA].  The timestamp of the last key chain\n   modification
      is also maintained in the operational state.\n   Additionally, the operational
      state includes an indication of whether\n   or not a key chain key is valid
      for transmission or acceptance.\n"
    title: 3.1.  Key Chain Operational State
  - contents:
    - "3.2.  Key Chain Model Features\n   Features are used to handle differences
      between vendor\n   implementations.  For example, not all vendors support configuration\n
      \  of an acceptance tolerance or configuration of key strings in\n   hexadecimal.
      \ They are also used to support security requirements\n   (e.g., TCP-AO algorithms
      [TCP-AO-ALGORITHMS]) not yet implemented by\n   vendors or implemented by only
      a single vendor.\n   It is common for an entity with sufficient permissions
      to read and\n   store a device's configuration, which would include the contents
      of\n   this model.  To avoid unnecessarily seeing and storing the keys in\n
      \  cleartext, this model provides the aes-key-wrap feature.  More\n   details
      are described in the Security Considerations (Section 5).\n"
    title: 3.2.  Key Chain Model Features
  - contents:
    - "3.3.  Key Chain Model Tree\n   +--rw key-chains\n      +--rw key-chain* [name]\n
      \     |  +--rw name                       string\n      |  +--rw description?
      \              string\n      |  +--rw accept-tolerance {accept-tolerance}?\n
      \     |  |  +--rw duration?   uint32\n      |  +--ro last-modified-timestamp?
      \  yang:date-and-time\n      |  +--rw key* [key-id]\n      |     +--rw key-id
      \                   uint64\n      |     +--rw lifetime\n      |     |  +--rw
      (lifetime)?\n      |     |     +--:(send-and-accept-lifetime)\n      |     |
      \    |  +--rw send-accept-lifetime\n      |     |     |     +--rw (lifetime)?\n
      \     |     |     |        +--:(always)\n      |     |     |        |  +--rw
      always?            empty\n      |     |     |        +--:(start-end-time)\n
      \     |     |     |           +--rw start-date-time?\n      |     |     |           |
      \      yang:date-and-time\n      |     |     |           +--rw (end-time)?\n
      \     |     |     |              +--:(infinite)\n      |     |     |              |
      \ +--rw no-end-time?       empty\n      |     |     |              +--:(duration)\n
      \     |     |     |              |  +--rw duration?          uint32\n      |
      \    |     |              +--:(end-date-time)\n      |     |     |                 +--rw
      end-date-time?\n      |     |     |                         yang:date-and-time\n
      \     |     |     +--:(independent-send-accept-lifetime)\n      |     |        |
      \  {independent-send-accept-lifetime}?\n      |     |        +--rw send-lifetime\n
      \     |     |        |  +--rw (lifetime)?\n      |     |        |     +--:(always)\n
      \     |     |        |     |  +--rw always?            empty\n      |     |
      \       |     +--:(start-end-time)\n      |     |        |        +--rw start-date-time?\n
      \     |     |        |        |       yang:date-and-time\n      |     |        |
      \       +--rw (end-time)?\n      |     |        |           +--:(infinite)\n
      \     |     |        |           |  +--rw no-end-time?       empty\n      |
      \    |        |           +--:(duration)\n      |     |        |           |
      \ +--rw duration?          uint32\n      |     |        |           +--:(end-date-time)\n
      \     |     |        |              +--rw end-date-time?\n      |     |        |
      \                     yang:date-and-time\n      |     |        +--rw accept-lifetime\n
      \     |     |           +--rw (lifetime)?\n      |     |              +--:(always)\n
      \     |     |              |  +--rw always?            empty\n      |     |
      \             +--:(start-end-time)\n      |     |                 +--rw start-date-time?\n
      \     |     |                 |       yang:date-and-time\n      |     |                 +--rw
      (end-time)?\n      |     |                    +--:(infinite)\n      |     |
      \                   |  +--rw no-end-time?       empty\n      |     |                    +--:(duration)\n
      \     |     |                    |  +--rw duration?          uint32\n      |
      \    |                    +--:(end-date-time)\n      |     |                       +--rw
      end-date-time?\n      |     |                               yang:date-and-time\n
      \     |     +--rw crypto-algorithm identityref\n      |     +--rw key-string\n
      \     |     |  +--rw (key-string-style)?\n      |     |     +--:(keystring)\n
      \     |     |     |  +--rw keystring?            string\n      |     |     +--:(hexadecimal)
      {hex-key-string}?\n      |     |        +--rw hexadecimal-string?   yang:hex-string\n
      \     |     +--ro send-lifetime-active?     boolean\n      |     +--ro accept-lifetime-active?
      \  boolean\n      +--rw aes-key-wrap {aes-key-wrap}?\n         +--rw enable?
      \  boolean\n"
    title: 3.3.  Key Chain Model Tree
  title: 3.  Design of the Key Chain Model
- contents:
  - "4.  Key Chain YANG Model\n   <CODE BEGINS> file \"ietf-key-chain@2017-06-15.yang\"\n
    \  module ietf-key-chain {\n     yang-version 1.1;\n     namespace \"urn:ietf:params:xml:ns:yang:ietf-key-chain\";\n
    \    prefix key-chain;\n     import ietf-yang-types {\n       prefix yang;\n     }\n
    \    import ietf-netconf-acm {\n       prefix nacm;\n     }\n     organization\n
    \      \"IETF RTGWG - Routing Area Working Group\";\n     contact\n       \"WG
    Web:   <https://datatracker.ietf.org/group/rtgwg>\n        WG List:  <mailto:rtgwg@ietf.org>\n
    \       Editor: Acee Lindem\n                <mailto:acee@cisco.com>\n                Yingzhen
    Qu\n                <mailto:yingzhen.qu@huawei.com>\n                Derek Yeung\n
    \               <mailto:derek@arrcus.com>\n                Ing-Wher Chen\n                <mailto:Ing-Wher_Chen@jabail.com>\n
    \               Jeffrey Zhang\n                <mailto:zzhang@juniper.net>\";\n
    \    description\n       \"This YANG module defines the generic configuration\n
    \       data for key chains.  It is intended that the module\n        will be
    extended by vendors to define vendor-specific\n        key chain configuration
    parameters.\n        Copyright (c) 2017 IETF Trust and the persons identified
    as\n        authors of the code.  All rights reserved.\n        Redistribution
    and use in source and binary forms, with or\n        without modification, is
    permitted pursuant to, and subject\n        to the license terms contained in,
    the Simplified BSD License\n        set forth in Section 4.c of the IETF Trust's
    Legal Provisions\n        Relating to IETF Documents\n        (http://trustee.ietf.org/license-info).\n
    \       This version of this YANG module is part of RFC 8177;\n        see the
    RFC itself for full legal notices.\";\n     reference \"RFC 8177\";\n     revision
    2017-06-15 {\n       description\n         \"Initial RFC Revision\";\n       reference
    \"RFC 8177: YANG Data Model for Key Chains\";\n     }\n     feature hex-key-string
    {\n       description\n         \"Support hexadecimal key string.\";\n     }\n
    \    feature accept-tolerance {\n       description\n         \"Support the tolerance
    or acceptance limit.\";\n     }\n     feature independent-send-accept-lifetime
    {\n       description\n         \"Support for independent send and accept key
    lifetimes.\";\n     }\n     feature crypto-hmac-sha-1-12 {\n       description\n
    \        \"Support for TCP HMAC-SHA-1 12-byte digest hack.\";\n     }\n     feature
    cleartext {\n       description\n         \"Support for cleartext algorithm.  Usage
    is\n          NOT RECOMMENDED.\";\n     }\n     feature aes-cmac-prf-128 {\n       description\n
    \        \"Support for AES Cipher-based Message Authentication\n          Code
    Pseudorandom Function.\";\n     }\n     feature aes-key-wrap {\n       description\n
    \        \"Support for Advanced Encryption Standard (AES) Key Wrap.\";\n     }\n
    \    feature replay-protection-only {\n       description\n         \"Provide
    replay protection without any authentication\n          as required by protocols
    such as Bidirectional\n          Forwarding Detection (BFD).\";\n     }\n     identity
    crypto-algorithm {\n       description\n         \"Base identity of cryptographic
    algorithm options.\";\n     }\n     identity hmac-sha-1-12 {\n       base crypto-algorithm;\n
    \      if-feature \"crypto-hmac-sha-1-12\";\n       description\n         \"The
    HMAC-SHA1-12 algorithm.\";\n     }\n     identity aes-cmac-prf-128 {\n       base
    crypto-algorithm;\n       if-feature \"aes-cmac-prf-128\";\n       description\n
    \        \"The AES-CMAC-PRF-128 algorithm - required by\n          RFC 5926 for
    TCP-AO key derivation functions.\";\n     }\n     identity md5 {\n       base
    crypto-algorithm;\n       description\n         \"The MD5 algorithm.\";\n     }\n
    \    identity sha-1 {\n       base crypto-algorithm;\n       description\n         \"The
    SHA-1 algorithm.\";\n     }\n     identity hmac-sha-1 {\n       base crypto-algorithm;\n
    \      description\n         \"HMAC-SHA-1 authentication algorithm.\";\n     }\n
    \    identity hmac-sha-256 {\n       base crypto-algorithm;\n       description\n
    \        \"HMAC-SHA-256 authentication algorithm.\";\n     }\n     identity hmac-sha-384
    {\n       base crypto-algorithm;\n       description\n         \"HMAC-SHA-384
    authentication algorithm.\";\n     }\n     identity hmac-sha-512 {\n       base
    crypto-algorithm;\n       description\n         \"HMAC-SHA-512 authentication
    algorithm.\";\n     }\n     identity cleartext {\n       base crypto-algorithm;\n
    \      if-feature \"cleartext\";\n       description\n         \"cleartext.\";\n
    \    }\n     identity replay-protection-only {\n       base crypto-algorithm;\n
    \      if-feature \"replay-protection-only\";\n       description\n         \"Provide
    replay protection without any authentication as\n          required by protocols
    such as Bidirectional Forwarding\n          Detection (BFD).\";\n     }\n     typedef
    key-chain-ref {\n       type leafref {\n         path\n         \"/key-chain:key-chains/key-chain:key-chain/key-chain:name\";\n
    \      }\n       description\n         \"This type is used by data models that
    need to reference\n          configured key chains.\";\n     }\n     grouping
    lifetime {\n       description\n         \"Key lifetime specification.\";\n       choice
    lifetime {\n         default \"always\";\n         description\n           \"Options
    for specifying key accept or send lifetimes\";\n         case always {\n           leaf
    always {\n             type empty;\n             description\n               \"Indicates
    key lifetime is always valid.\";\n           }\n         }\n         case start-end-time
    {\n           leaf start-date-time {\n             type yang:date-and-time;\n
    \            description\n               \"Start time.\";\n           }\n           choice
    end-time {\n             default \"infinite\";\n             description\n               \"End-time
    setting.\";\n             case infinite {\n               leaf no-end-time {\n
    \                type empty;\n                 description\n                   \"Indicates
    key lifetime end-time is infinite.\";\n               }\n             }\n             case
    duration {\n               leaf duration {\n                 type uint32 {\n                   range
    \"1..2147483646\";\n                 }\n                 units \"seconds\";\n
    \                description\n                   \"Key lifetime duration, in seconds\";\n
    \              }\n             }\n             case end-date-time {\n               leaf
    end-date-time {\n                 type yang:date-and-time;\n                 description\n
    \                  \"End time.\";\n               }\n             }\n           }\n
    \        }\n       }\n     }\n     container key-chains {\n       description\n
    \        \"All configured key-chains on the device.\";\n       list key-chain
    {\n         key \"name\";\n         description\n           \"List of key-chains.\";\n
    \        leaf name {\n           type string;\n           description\n             \"Name
    of the key-chain.\";\n         }\n         leaf description {\n           type
    string;\n           description\n             \"A description of the key-chain\";\n
    \        }\n         container accept-tolerance {\n           if-feature \"accept-tolerance\";\n
    \          description\n             \"Tolerance for key lifetime acceptance (seconds).\";\n
    \          leaf duration {\n             type uint32;\n             units \"seconds\";\n
    \            default \"0\";\n             description\n               \"Tolerance
    range, in seconds.\";\n           }\n         }\n         leaf last-modified-timestamp
    {\n           type yang:date-and-time;\n           config false;\n           description\n
    \            \"Timestamp of the most recent update to the key-chain\";\n         }\n
    \        list key {\n           key \"key-id\";\n           description\n             \"Single
    key in key chain.\";\n           leaf key-id {\n             type uint64;\n             description\n
    \              \"Numeric value uniquely identifying the key\";\n           }\n
    \          container lifetime {\n             description\n               \"Specify
    a key's lifetime.\";\n             choice lifetime {\n               description\n
    \                \"Options for specification of send and accept\n                  lifetimes.\";\n
    \              case send-and-accept-lifetime {\n                 description\n
    \                  \"Send and accept key have the same lifetime.\";\n                 container
    send-accept-lifetime {\n                   description\n                     \"Single
    lifetime specification for both\n                      send and accept lifetimes.\";\n
    \                  uses lifetime;\n                 }\n               }\n               case
    independent-send-accept-lifetime {\n                 if-feature \"independent-send-accept-lifetime\";\n
    \                description\n                   \"Independent send and accept
    key lifetimes.\";\n                 container send-lifetime {\n                   description\n
    \                    \"Separate lifetime specification for send\n                      lifetime.\";\n
    \                  uses lifetime;\n                 }\n                 container
    accept-lifetime {\n                   description\n                     \"Separate
    lifetime specification for accept\n                      lifetime.\";\n                   uses
    lifetime;\n                 }\n               }\n             }\n           }\n
    \          leaf crypto-algorithm {\n             type identityref {\n               base
    crypto-algorithm;\n             }\n             mandatory true;\n             description\n
    \              \"Cryptographic algorithm associated with key.\";\n           }\n
    \          container key-string {\n             description\n               \"The
    key string.\";\n             nacm:default-deny-all;\n             choice key-string-style
    {\n               description\n                 \"Key string styles\";\n                case
    keystring {\n                  leaf keystring {\n                   type string;\n
    \                  description\n                     \"Key string in ASCII format.\";\n
    \                }\n               }\n               case hexadecimal {\n                 if-feature
    \"hex-key-string\";\n                 leaf hexadecimal-string {\n                   type
    yang:hex-string;\n                   description\n                     \"Key in
    hexadecimal string format.  When compared\n                      to ASCII, specification
    in hexadecimal affords\n                      greater key entropy with the same
    number of\n                      internal key-string octets.  Additionally, it\n
    \                     discourages usage of well-known words or\n                      numbers.\";\n
    \                }\n               }\n             }\n           }\n           leaf
    send-lifetime-active {\n             type boolean;\n             config false;\n
    \            description\n               \"Indicates if the send lifetime of the\n
    \               key-chain key is currently active.\";\n              }\n           leaf
    accept-lifetime-active {\n             type boolean;\n             config false;\n
    \            description\n               \"Indicates if the accept lifetime of
    the\n                key-chain key is currently active.\";\n           }\n         }\n
    \      }\n       container aes-key-wrap {\n         if-feature \"aes-key-wrap\";\n
    \        description\n           \"AES Key Wrap encryption for key-chain key-strings.
    \ The\n            encrypted key-strings are encoded as hexadecimal key\n            strings
    using the hex-key-string leaf.\";\n         leaf enable {\n           type boolean;\n
    \          default \"false\";\n           description\n             \"Enable AES
    Key Wrap encryption.\";\n         }\n       }\n     }\n   }\n   <CODE ENDS>\n"
  title: 4.  Key Chain YANG Model
- contents:
  - "5.  Security Considerations\n   The YANG module defined in this document is designed
    to be accessed\n   via network management protocols such as NETCONF [NETCONF]
    or\n   RESTCONF [RESTCONF].  The lowest NETCONF layer is the secure\n   transport
    layer, and the mandatory-to-implement secure transport is\n   Secure Shell (SSH)
    [NETCONF-SSH].  The lowest RESTCONF layer is\n   HTTPS, and the mandatory-to-implement
    secure transport is TLS [TLS].\n   The NETCONF access control model [NETCONF-ACM]
    provides the means to\n   restrict access for particular NETCONF or RESTCONF users
    to a pre-\n   configured subset of all available NETCONF or RESTCONF protocol\n
    \  operations and content.  The key strings are not accessible by\n   default,
    and NETCONF access control model [NETCONF-ACM] rules are\n   required to configure
    or retrieve them.\n   When configured, the key strings can be encrypted using
    the AES Key\n   Wrap algorithm [AES-KEY-WRAP].  The AES key-encryption key (KEK)
    is\n   not included in the YANG model and must be set or derived independent\n
    \  of key chain configuration.  When AES key encryption is used, the\n   hex-key-string
    feature is also required since the encrypted keys will\n   contain characters
    that are not representable in the YANG string\n   built-in type [YANG-1.1].  It
    is RECOMMENDED that key strings be\n   encrypted using AES key encryption to prevent
    key chains from being\n   retrieved and stored with the key strings in cleartext.
    \ This\n   recommendation is independent of the access protection that is\n   availed
    from the NETCONF access control model (NACM) [NETCONF-ACM].\n   The cleartext
    algorithm is included as a YANG feature.  Usage is NOT\n   RECOMMENDED except
    in cases where the application and device have no\n   other alternative (e.g.,
    a legacy network device that must\n   authenticate packets at intervals of 10
    milliseconds or less for many\n   peers using Bidirectional Forwarding Detection
    [BFD]).  Keys used\n   with the cleartext algorithm are considered insecure and
    SHOULD NOT\n   be reused with more secure algorithms.\n   Similarly, the MD5 and
    SHA-1 algorithms have been proven to be\n   insecure ([Dobb96a], [Dobb96b], and
    [SHA-SEC-CON]), and usage is NOT\n   RECOMMENDED.  Usage should be confined to
    deployments where it is\n   required for backward compatibility.\n   Implementations
    with keys provided via this model should store them\n   using best current security
    practices.\n"
  title: 5.  Security Considerations
- contents:
  - "6.  IANA Considerations\n   This document registers a URI in the \"IETF XML Registry\"\n
    \  [XML-REGISTRY].  It follows the format in [XML-REGISTRY].\n      URI: urn:ietf:params:xml:ns:yang:ietf-key-chain\n
    \     Registrant Contact: The IESG.\n      XML: N/A, the requested URI is an XML
    namespace.\n   This document registers a YANG module in the \"YANG Module Names\"\n
    \  registry [YANG-1.0].\n      name: ietf-key-chain\n      namespace: urn:ietf:params:xml:ns:yang:ietf-key-chain\n
    \     prefix: key-chain\n      reference: RFC 8177\n"
  title: 6.  IANA Considerations
- contents:
  - '7.  References

    '
  - contents:
    - "7.1.  Normative References\n   [KEYWORDS]\n              Bradner, S., \"Key
      words for use in RFCs to Indicate\n              Requirement Levels\", BCP 14,
      RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n
      \  [KEYWORDS-UPD]\n              Leiba, B., \"Ambiguity of Uppercase vs Lowercase
      in RFC\n              2119 Key Words\", BCP 14, RFC 8174, DOI 10.17487/RFC8174,\n
      \             May 2017, <http://www.rfc-editor.org/info/rfc8174>.\n   [NETCONF]
      \ Enns, R., Ed., Bjorklund, M., Ed., Schoenwaelder, J., Ed.,\n              and
      A. Bierman, Ed., \"Network Configuration Protocol\n              (NETCONF)\",
      RFC 6241, DOI 10.17487/RFC6241, June 2011,\n              <http://www.rfc-editor.org/info/rfc6241>.\n
      \  [NETCONF-ACM]\n              Bierman, A. and M. Bjorklund, \"Network Configuration\n
      \             Protocol (NETCONF) Access Control Model\", RFC 6536,\n              DOI
      10.17487/RFC6536, March 2012,\n              <http://www.rfc-editor.org/info/rfc6536>.\n
      \  [NETCONF-SSH]\n              Wasserman, M., \"Using the NETCONF Protocol
      over Secure\n              Shell (SSH)\", RFC 6242, DOI 10.17487/RFC6242, June
      2011,\n              <http://www.rfc-editor.org/info/rfc6242>.\n   [RESTCONF]\n
      \             Bierman, A., Bjorklund, M., and K. Watsen, \"RESTCONF\n              Protocol\",
      RFC 8040, DOI 10.17487/RFC8040, January 2017,\n              <http://www.rfc-editor.org/info/rfc8040>.\n
      \  [TLS]      Dierks, T. and E. Rescorla, \"The Transport Layer Security\n              (TLS)
      Protocol Version 1.2\", RFC 5246,\n              DOI 10.17487/RFC5246, August
      2008,\n              <http://www.rfc-editor.org/info/rfc5246>.\n   [XML-REGISTRY]\n
      \             Mealling, M., \"The IETF XML Registry\", BCP 81, RFC 3688,\n              DOI
      10.17487/RFC3688, January 2004,\n              <http://www.rfc-editor.org/info/rfc3688>.\n
      \  [YANG-1.0]\n              Bjorklund, M., Ed., \"YANG - A Data Modeling Language
      for\n              the Network Configuration Protocol (NETCONF)\", RFC 6020,\n
      \             DOI 10.17487/RFC6020, October 2010,\n              <http://www.rfc-editor.org/info/rfc6020>.\n
      \  [YANG-1.1]\n              Bjorklund, M., Ed., \"The YANG 1.1 Data Modeling
      Language\",\n              RFC 7950, DOI 10.17487/RFC7950, August 2016,\n              <http://www.rfc-editor.org/info/rfc7950>.\n"
    title: 7.1.  Normative References
  - contents:
    - "7.2.  Informative References\n   [AES-KEY-WRAP]\n              Housley, R.
      and M. Dworkin, \"Advanced Encryption Standard\n              (AES) Key Wrap
      with Padding Algorithm\", RFC 5649,\n              DOI 10.17487/RFC5649, September
      2009,\n              <http://www.rfc-editor.org/info/rfc5649>.\n   [BFD]      Katz,
      D. and D. Ward, \"Bidirectional Forwarding Detection\n              (BFD)\",
      RFC 5880, DOI 10.17487/RFC5880, June 2010,\n              <http://www.rfc-editor.org/info/rfc5880>.\n
      \  [CRYPTO-KEYTABLE]\n              Housley, R., Polk, T., Hartman, S., and
      D. Zhang,\n              \"Database of Long-Lived Symmetric Cryptographic Keys\",\n
      \             RFC 7210, DOI 10.17487/RFC7210, April 2014,\n              <http://www.rfc-editor.org/info/rfc7210>.\n
      \  [Dobb96a]  Dobbertin, H., \"Cryptanalysis of MD5 Compress\", Technical\n
      \             Report Presented at the Rump Session of EuroCrypt '96, May\n              1996.\n
      \  [Dobb96b]  Dobbertin, H., \"The Status of MD5 After a Recent Attack\",\n
      \             CryptoBytes, Vol. 2, No. 2, Summer 1996.\n   [IAB-REPORT]\n              Andersson,
      L., Davies, E., and L. Zhang, \"Report from the\n              IAB workshop
      on Unwanted Traffic March 9-10, 2006\",\n              RFC 4948, DOI 10.17487/RFC4948,
      August 2007,\n              <http://www.rfc-editor.org/info/rfc4948>.\n   [NMDA]
      \    Bjorklund, M., Schoenwaelder, J., Shafer, P., Watsen, K.,\n              and
      R. Wilton, \"Network Management Datastore\n              Architecture\", Work
      in Progress, draft-ietf-netmod-\n              revised-datastores-02, May 2017.\n
      \  [NTP-PROTO]\n              Mills, D., Martin, J., Ed., Burbank, J., and W.
      Kasch,\n              \"Network Time Protocol Version 4: Protocol and Algorithms\n
      \             Specification\", RFC 5905, DOI 10.17487/RFC5905, June 2010,\n
      \             <http://www.rfc-editor.org/info/rfc5905>.\n   [OSPFV3-AUTH]\n
      \             Bhatia, M., Manral, V., and A. Lindem, \"Supporting\n              Authentication
      Trailer for OSPFv3\", RFC 7166,\n              DOI 10.17487/RFC7166, March 2014,\n
      \             <http://www.rfc-editor.org/info/rfc7166>.\n   [SHA-SEC-CON]\n
      \             Polk, T., Chen, L., Turner, S., and P. Hoffman, \"Security\n              Considerations
      for the SHA-0 and SHA-1 Message-Digest\n              Algorithms\", RFC 6194,
      DOI 10.17487/RFC6194, March 2011,\n              <http://www.rfc-editor.org/info/rfc6194>.\n
      \  [TCP-AO]   Touch, J., Mankin, A., and R. Bonica, \"The TCP\n              Authentication
      Option\", RFC 5925, DOI 10.17487/RFC5925,\n              June 2010, <http://www.rfc-editor.org/info/rfc5925>.\n
      \  [TCP-AO-ALGORITHMS]\n              Lebovitz, G. and E. Rescorla, \"Cryptographic
      Algorithms\n              for the TCP Authentication Option (TCP-AO)\", RFC
      5926,\n              DOI 10.17487/RFC5926, June 2010,\n              <http://www.rfc-editor.org/info/rfc5926>.\n
      \  [YANG-CRYPTO-KEYTABLE]\n              Chen, I., \"YANG Data Model for RFC
      7210 Key Table\", Work\n              in Progress, draft-chen-rtg-key-table-yang-00,
      March 2015.\n"
    title: 7.2.  Informative References
  title: 7.  References
- contents:
  - 'Appendix A.  Examples

    '
  - contents:
    - "A.1.  Simple Key Chain with an Always Valid Single Key\n   <?xml version=\"1.0\"
      encoding=\"utf-8\"?>\n   <data xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n
      \    <key-chains xmlns=\"urn:ietf:params:xml:ns:yang:ietf-key-chain\">\n       <key-chain>\n
      \        <name>keychain-no-end-time</name>\n         <description>\n           A
      key chain with a single key that is always valid for\n           transmission
      and reception.\n         </description>\n         <key>\n           <key-id>100</key-id>\n
      \          <lifetime>\n             <send-accept-lifetime>\n               <always/>\n
      \            </send-accept-lifetime>\n           </lifetime>\n           <crypto-algorithm>hmac-sha-256</crypto-algorithm>\n
      \          <key-string>\n             <keystring>keystring_in_ascii_100</keystring>\n
      \          </key-string>\n         </key>\n       </key-chain>\n     </key-chains>\n
      \  </data>\n"
    title: A.1.  Simple Key Chain with an Always Valid Single Key
  - contents:
    - "A.2.  Key Chain with Keys Having Different Lifetimes\n   <?xml version=\"1.0\"
      encoding=\"utf-8\"?>\n   <data xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n
      \    <key-chains xmlns=\"urn:ietf:params:xml:ns:yang:ietf-key-chain\">\n       <key-chain>\n
      \        <name>keychain2</name>\n         <description>\n           A key chain
      where each key contains a different send time\n           and accept time and
      a different algorithm illustrating\n           algorithm agility.\n         </description>\n
      \        <key>\n           <key-id>35</key-id>\n           <lifetime>\n             <send-lifetime>\n
      \              <start-date-time>2017-01-01T00:00:00Z</start-date-time>\n               <end-date-time>2017-02-01T00:00:00Z</end-date-time>\n
      \            </send-lifetime>\n             <accept-lifetime>\n               <start-date-time>2016-12-31T23:59:55Z</start-date-time>\n
      \              <end-date-time>2017-02-01T00:00:05Z</end-date-time>\n             </accept-lifetime>\n
      \          </lifetime>\n           <crypto-algorithm>hmac-sha-256</crypto-algorithm>\n
      \          <key-string>\n             <keystring>keystring_in_ascii_35</keystring>\n
      \          </key-string>\n         </key>\n         <key>\n           <key-id>36</key-id>\n
      \          <lifetime>\n             <send-lifetime>\n               <start-date-time>2017-02-01T00:00:00Z</start-date-time>\n
      \              <end-date-time>2017-03-01T00:00:00Z</end-date-time>\n             </send-lifetime>\n
      \            <accept-lifetime>\n               <start-date-time>2017-01-31T23:59:55Z</start-date-time>\n
      \              <end-date-time>2017-03-01T00:00:05Z</end-date-time>\n             </accept-lifetime>\n
      \          </lifetime>\n           <crypto-algorithm>hmac-sha-512</crypto-algorithm>\n
      \          <key-string>\n             <hexadecimal-string>fe:ed:be:af:36</hexadecimal-string>\n
      \          </key-string>\n         </key>\n       </key-chain>\n     </key-chains>\n
      \  </data>\n"
    title: A.2.  Key Chain with Keys Having Different Lifetimes
  - contents:
    - "A.3.  Key Chain with Independent Send and Accept Lifetimes\n   <?xml version=\"1.0\"
      encoding=\"utf-8\"?>\n   <data xmlns=\"urn:ietf:params:xml:ns:netconf:base:1.0\">\n
      \    <key-chains xmlns=\"urn:ietf:params:xml:ns:yang:ietf-key-chain\">\n       <key-chain>\n
      \        <name>keychain2</name>\n         <description>\n           A key chain
      where each key contains different send times\n           and accept times.\n
      \        </description>\n         <key>\n           <key-id>35</key-id>\n           <lifetime>\n
      \            <send-lifetime>\n               <start-date-time>2017-01-01T00:00:00Z</start-date-time>\n
      \              <end-date-time>2017-02-01T00:00:00Z</end-date-time>\n             </send-lifetime>\n
      \            <accept-lifetime>\n               <start-date-time>2016-12-31T23:59:55Z</start-date-time>\n
      \              <end-date-time>2017-02-01T00:00:05Z</end-date-time>\n             </accept-lifetime>\n
      \          </lifetime>\n           <crypto-algorithm>hmac-sha-256</crypto-algorithm>\n
      \          <key-string>\n             <keystring>keystring_in_ascii_35</keystring>\n
      \          </key-string>\n         </key>\n         <key>\n           <key-id>36</key-id>\n
      \          <lifetime>\n             <send-lifetime>\n               <start-date-time>2017-02-01T00:00:00Z</start-date-time>\n
      \              <end-date-time>2017-03-01T00:00:00Z</end-date-time>\n             </send-lifetime>\n
      \            <accept-lifetime>\n               <start-date-time>2017-01-31T23:59:55Z</start-date-time>\n
      \              <end-date-time>2017-03-01T00:00:05Z</end-date-time>\n             </accept-lifetime>\n
      \          </lifetime>\n           <crypto-algorithm>hmac-sha-256</crypto-algorithm>\n
      \          <key-string>\n             <hexadecimal-string>fe:ed:be:af:36</hexadecimal-string>\n
      \          </key-string>\n         </key>\n       </key-chain>\n     </key-chains>\n
      \  </data>\n"
    title: A.3.  Key Chain with Independent Send and Accept Lifetimes
  title: Appendix A.  Examples
- contents:
  - "Contributors\n   Yi Yang\n   SockRate\n   Email: yi.yang@sockrate.com\n"
  title: Contributors
- contents:
  - "Acknowledgments\n   Thanks to Brian Weis for fruitful discussions on security\n
    \  requirements.\n   Thanks to Ines Robles for Routing Directorate QA review comments.\n
    \  Thanks to Ladislav Lhotka for YANG Doctor comments.\n   Thanks to Martin Bjorklund
    for additional YANG Doctor comments.\n   Thanks to Tom Petch for comments during
    IETF last call.\n   Thanks to Matthew Miller for comments made during the Gen-ART
    review.\n   Thanks to Vincent Roca for comments made during the Security\n   Directorate
    review.\n   Thanks to Warren Kumari, Ben Campbell, Adam Roach, and Benoit Claise\n
    \  for comments received during the IESG review.\n"
  title: Acknowledgments
- contents:
  - "Authors' Addresses\n   Acee Lindem (editor)\n   Cisco Systems\n   301 Midenhall
    Way\n   Cary, NC  27513\n   United States of America\n   Email: acee@cisco.com\n
    \  Yingzhen Qu\n   Huawei\n   Email: yingzhen.qu@huawei.com\n   Derek Yeung\n
    \  Arrcus, Inc\n   Email: derek@arrcus.com\n   Ing-Wher Chen\n   Jabil\n   Email:
    Ing-Wher_Chen@jabil.com\n   Jeffrey Zhang\n   Juniper Networks\n   10 Technology
    Park Drive\n   Westford, MA  01886\n   United States of America\n   Email: zzhang@juniper.net\n"
  title: Authors' Addresses
