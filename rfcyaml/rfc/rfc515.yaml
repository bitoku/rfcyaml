- title: __initial_text__
  contents:
  - '              Specifications for Datalanguage, Version 0/9

    '
- title: Preface
  contents:
  - "Preface\n   Datalanguage is the language processed by the Datacomputer, a data\n\
    \   utility system being developed for the Arpanet.  The Datacomputer\n   performs\
    \ data storage and data management functions for the benefit\n   of computers\
    \ on the network.\n   Version 0/9 is currently running at CCA.  This version is\
    \ extremely\n   primitive; however, it does offer an opportunity for experience\
    \ with\n   the Datacomputer and with fundamental Datalanguage concepts.\n   Subsequent\
    \ versions will provide greater portions of the full\n   Datalanguage capability,\
    \ which has been described earlier\n   (Datalanguage, Working Paper No. 3, Datacomputer\
    \ Project, October,\n   1971, NIC 8028).  For example, one of the primary restrictions\
    \ in\n   0/9--elementary data items must be fixed-length ASCII strings--will\n\
    \   be eliminated in Version 0/10, which is currently being implemented.\n   Based\
    \ on the experience gained in the implementation of these early\n   versions,\
    \ and based on the feedback from their use, a revised\n   specification of the\
    \ full language will be issued.\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   This document presents a precise and complete specification\
    \ of\n   Datalanguage, Version 0/9.  It is organized into 11 sections, of\n  \
    \ which this introduction is the first.  Section 2 discusses the\n   capabilities\
    \ of Version 0/9 in general terms.  Sections 3 and 4 are\n   concerned with data\
    \ description and the directory.  Sections 5\n   through 8 cover the expression\
    \ of data management operations.\n   Section 9 discusses the recognition of names.\
    \  Section 10 covers\n   miscellaneous topics and Section 11 specifies the syntax\
    \ in BNF.\n   This specification is to be followed with a user manual, which will\n\
    \   present the language in tutorial form and treat components of the\n   Datacomputer-user\
    \ interface other than the language.\n"
- title: 2. Capabilities of Version 0/9
  contents:
  - "2. Capabilities of Version 0/9\n   Version 0/9 of Datalanguage has capabilities\
    \ for the storage of\n   files; for addition of data to existing files, and for\
    \ the deletion\n   of files.  Retrievals can output whole files as well as subsets\
    \ of\n   files.  Data can be selected from files by content, using expressions\n\
    \   formed from boolean and inequality operators.\n   At the option of the file\
    \ creator, an inversion is constructed and\n   maintained by the Datacomputer.\
    \  The inversion increases the\n   efficiency of selective retrieval, at the cost\
    \ of storage space and\n   file maintenance effort.  Users other than the file\
    \ creator need not\n   be aware of the existence of the inversion, or of which\
    \ fields are\n   inverted file keys.  The language is designed so that they state\
    \ the\n   desired result of a retrieval, and the Datacomputer uses the\n   inversion\
    \ as much as the request permits.\n   Elementary data items are fixed-length ASCII\
    \ strings.  Files are a\n   restricted class of hierarchical structures.\n   Many\
    \ of the restrictions mentioned in this memo will be short-lived.\n   In particular,\
    \ those statements followed with 3 asterisks (***) refer\n   to restrictions that\
    \ will be considerably weakened or eliminated\n   entirely in the next version\
    \ of the software.\n"
- title: 3. Data Description
  contents:
  - "3. Data Description\n   A container is a variable whose value is a data object\
    \ of general\n   character and arbitrary size (In Version 0/9, size is restricted.\n\
    \   See section 3.4).  Examples of containers which are implemented in\n   other\
    \ systems are files, records, fields, groups, and entries.\n   The container is\
    \ distinct from the data in the container.  For\n   example, space allocation\
    \ is an operation on a container, while\n   changing the unit price field from\
    \ 25 to 50 is an operation on data\n   in a container.\n   A container may enclose\
    \ other containers.  When a container is not\n   enclosed by another container,\
    \ it is said to be outermost.  If\n   container A encloses container B, and no\
    \ other container in A also\n   encloses B, then A immediately encloses B.\n \
    \  A Datalanguage description is a statement of the properties of a\n   container.\n\
    \   All containers have the attributes ident and type.  Ident is a\n   character\
    \ string by which users refer to the container.  Type\n   determines the form\
    \ of the container's value; the value can be\n   elementary, or it can consist\
    \ of other containers.  There are 3\n   types: LIST, STRUCT, and STRING(***).\
    \  A LIST contains a group of\n   containers having the same description.  A STRUCT\
    \ contains a group of\n   containers, each of which has its own description. \
    \ A STRING is a\n   sequence of ASCII characters.  While a STRING is not really\
    \ an\n   elementary item, it is handled as one in Version 0/9.\n   Certain containers\
    \ can have other attributes.  An outermost container\n   has a function.  The\
    \ function attribute specifies whether the\n   container is to be used for storage\
    \ or for transmission.\n   Size is some meaningful dimension of the container,\
    \ which is type-\n   dependent.  It is used for space allocation and data stream\
    \ parsing.\n   An aggregate container (i.e., one that contains other containers)\
    \ has\n   as an attribute the description or descriptions of its components.\n\
    \   Thus if S is a STRUCT containing A, B, and C, then the descriptions\n   of\
    \ A, B, and C are attributes of S.\n   A STRING defined in certain contexts can\
    \ have an inversion attribute.\n   This is an access property that is not really\
    \ local to the STRING,\n   but is associated with it for convenience.\n"
- title: 3.1 Ident
  contents:
  - "3.1 Ident\n      The ident of a container is composed of alphanumeric characters,\n\
    \      the first of which is alphabetic.  It may not consist of more than\n  \
    \    100 characters.\n      The elements of a STRUCT must have idents unique in\
    \ the STRUCT.\n"
- title: 3.2 Function
  contents:
  - "3.2 Function\n      The function of a container is either FILE, PORT, or TEMPORARY\n\
    \      PORT.  When the function is FILE, then the container is used for\n    \
    \  storage of data at the Datacomputer.  When the function is PORT,\n      then\
    \ the container is used for transmission of data into or out of\n      the Datacomputer.\
    \  When the function is TEMPORARY PORT (which may\n      be abbreviated TEMP PORT),\
    \ the container behaves like a PORT;\n      however, its description is not retained\
    \ in the Datacomputer\n      beyond the session in which it is created.\n"
- title: 3.3 Type
  contents:
  - "3.3 Type\n      Type is one of: LIST, STRUCT, or STRING.  These are defined on\
    \ the\n      preceding page.\n      In an occurrence of a STRUCT, the elements\
    \ appear in the order in\n      which their descriptions appear in the STRUCT\
    \ description.  All\n      elements are present in each occurrence of the STRUCT.\n\
    \      An element of a STRUCT or LIST can be a container of any datatype.\n  \
    \    However, the outermost container must be a LIST(***).\n"
- title: 3.4 Size
  contents:
  - "3.4 Size\n      The size of a STRING is the number of characters in it.  The\
    \ size\n      of a STRUCT is not defined (***).  The meaning of the size of a\n\
    \      LIST depends upon other properties of the LIST (***).\n      Ordinarily,\
    \ the size of a LIST is the number of LIST-members.  An\n      exception is the\
    \ case of the outermost-LIST.  In an outermost-LIST\n      with a function of\
    \ FILE, the size is the number of LIST-members\n      for which space should be\
    \ allocated.  When no size is present in\n      this case, the system computes\
    \ a default.  In an outermost-LIST\n      with a function of PORT, the size is\
    \ ignored (***).\n      Only outermost containers may be larger than a TENEX page\
    \ (2560\n      ASCII characters)(***).\n"
- title: 3.5 Inversion
  contents:
  - "3.5 Inversion\n      An inversion is an auxiliary data structure used to facilitate\n\
    \      retrieval by content.\n      Its basic application is the fast retrieval\
    \ of sets of outermost-\n      LIST-members (this can be extended to other container\
    \ sets, and\n      will be after release 1).  Consider a list of weather\n   \
    \   observations, stored as a file on the Datacomputer.  If quick\n      retrieval\
    \ of observations by COUNTRY is desired, then this is\n      indicated in the\
    \ description of the COUNTRY container.  According\n      to common usage in information\
    \ retrieval, this makes COUNTRY a key\n      in the retrieval of observations.\n\
    \      Note that the inversion option only affects the efficiency of\n      retrieval\
    \ by COUNTRY, not the ability to retrieve by COUNTRY.\n      There are restrictions\
    \ on use of the inversion option.  First, it\n      can be applied only to STRINGs.\
    \  Second a STRING having the\n      inversion option must occur only once in\
    \ each\n      outermost-LIST-member.  Third, it is ignored when applied to\n \
    \     STRINGs in PORT descriptions.\n      Eventually there will be several types\
    \ of inversion option; in\n      Version 0/9 there is only the 'D' option (for\
    \ distinct).\n"
- title: 3.6 Syntax
  contents:
  - "3.6 Syntax\n      The description is simply an enumeration of properties; these\n\
    \      properties are specified in the order:\n            <ident> <function>\
    \ <type> <size> <other>\n      Properties which do not apply are omitted.  An\
    \ example:\n            F FILE LIST (25) A STR (10)\n      Here 'F' is the <ident>,\
    \ 'FILE' is the <function>, 'LIST' is the\n      <type>, '(25)' is the size, and\
    \ 'A STR (10)' is the <other> of one\n      description.  Of course, 'A STR (10)'\
    \ is itself another\n      description: the description for members of the LIST\
    \ named F.\n      An example of a complete description for a file of weather\n\
    \      observations keyed on location:\n            WEATHER FILE LIST\n      \
    \      OBSERVATION STRUCT\n                 LOCATION STRUCT\n                \
    \       CITY STR (10), I=D\n                       COUNTRY STR (10), I=D\n   \
    \                    END\n                 TIME STRUCT\n                     \
    \  YEAR STR (2)\n                       DAY STR (3)\n                       HOUR\
    \ STR (2)\n                       END\n                 DATE STRUCT\n        \
    \               TEMPERATURE STR (3)\n                       RAINFALL STR (3)\n\
    \                       HUMIDITY STR (2)\n                       END\n       \
    \          END\n      The ENDs are needed to delimit the list of elements of a\
    \ STRUCT.\n      `, I=D' indicates that the string is to be an inversion key for\n\
    \      the retrieval of outermost-LIST-members.\n"
- title: 4. Directory
  contents:
  - "4. Directory\n   The directory is a system file in which the names and descriptions\
    \ of\n   all user-defined containers are kept.\n   The directory is structured\
    \ as a tree.  Each node has an ident, which\n   need not be unique.  There is\
    \ a single path from the root of the tree\n   to any node.  The idents of the\
    \ nodes along this path are\n   concatenated, separated by periods, to form a\
    \ pathname, which\n   unambiguously identifies the node (e.g., A.B.C could be\
    \ a pathname\n   for node with an ident of C).\n   In a later version of the software,\
    \ the directory will be generalized\n   to provide for links between nodes, so\
    \ that it will not properly be a\n   tree.  For now, however, the tree model is\
    \ convenient and adequate.\n   A node may represent a container, or it may simply\
    \ hold a place in\n   the space of pathnames.  When it represents a container,\
    \ it cannot\n   (currently) have subordinate nodes.\n   Eventually, it is planned\
    \ to model the directory as a structure of\n   containers, with its description\
    \ distributed throughout the\n   structure.  Most operations defined on the directory\
    \ will be defined\n   on user data, and vice versa.  Access privileges and privacy\
    \ locks\n   will be part of the data description and will likewise be applicable\n\
    \   both to directory nodes and data structures below the node level.\n"
- title: 4.1 CREATE
  contents:
  - "4.1 CREATE\n      A CREATE-request either; (a) adds a node to the directory,\n\
    \      optionally associating the description of either a PORT or a FILE\n   \
    \   with the node, or (b) creates a temporary container which is not\n      entered\
    \ in the directory, but has a description and can be\n      referenced in requests.\
    \  If the description defines a file, CREATE\n      causes space to be allocated\
    \ for the file.\n      To create a node with a description:\n           CREATE\
    \ <pathname> <description> ;\n      To create a node with no description:\n  \
    \         CREATE <pathname> ;\n      Note that the description determines whether\
    \ or not the container\n      is temporary (see section 3.2 for details).\n  \
    \    A CREATE-request adds a single node to the directory.  Thus to add\n    \
    \  CCA.RAW.F to an empty directory, three requests are needed:\n           CREATE\
    \ CCA ;\n           CREATE CCA.RAW ;\n           CREATE CCA.RAW.F ;\n      Notice\
    \ that the last ident of the pathname doubles as the first\n      ident of the\
    \ description:\n           CREATE CCA.RAW.G FILE LIST A STR (5) ;\n      That\
    \ is, G is both the ident of a node and the ident of an\n      outermost container\
    \ of type LIST.\n"
- title: 4.2 DELETE
  contents:
  - "4.2 DELETE\n      A DELETE-request deletes a tree of nodes and any associated\n\
    \      descriptions or data.  The syntax is:\n           DELETE <pathname> ;\n\
    \      The named node and any subordinates are deleted.\n      Note that to delete\
    \ data while retaining the directory entry and\n      description, DELETE should\
    \ not be used (see section 6.3 for the\n      proper method).\n"
- title: 4.3 LIST
  contents:
  - "4.3 LIST\n      The LIST-request is used to display system data of interest to\
    \ a\n      user.  It causes the data specified to be transmitted through the\n\
    \      Datalanguage output port.\n      Several arguments of LIST apply to the\
    \ directory.  LIST %ALL\n      transmits all pathnames in the directory.  LIST\
    \ %ALL.%SOURCE\n      transmits all descriptions in the directory.  Instead of\
    \ %ALL, a\n      pathname can be used:\n           LIST <pn>.%ALL\n      Lists\
    \ pathnames subordinate to <pn>.\n           LIST <pn>.%SOURCE\n      lists descriptions\
    \ subordinate to the node represented by <pn>.\n      For details about the LIST-request,\
    \ see section 10.1.\n"
- title: 5. Opening and closing containers
  contents:
  - "5. Opening and closing containers\n   Containers must be open before they can\
    \ be operated on.\n   A container is open when it is first created.  It remains\
    \ open until\n   closed explicitly by a CLOSE-request or implicitly by a DELETE-\n\
    \   request or by session end.\n   A closed container is opened by an OPEN-request.\
    \  A temporary\n   container is always open; a CLOSE-request deletes it.\n"
- title: 5.1 Modes
  contents:
  - "5.1 Modes\n      An open container has a mode, which is one of: READ, WRITE,\
    \ or\n      APPEND.  The mode determines the meaning and/or legitimacy of\n  \
    \    certain operations on the container.\n      The mode is established by the\
    \ operation which opens the\n      container.  It can be changed at any time by\
    \ a MODE-request.  A\n      CREATE leaves the container in WRITE mode.  An OPEN\
    \ either\n      specifies the mode explicitly or implicitly sets the mode to READ.\n"
- title: 5.2 Syntax
  contents:
  - "5.2 Syntax\n      To open a container:\n           OPEN <pathname> <mode> ;\n\
    \      or:\n           OPEN <pathname> ;\n      where <mode> is defaulted to READ.\n\
    \      To close a container:\n           CLOSE <ident> ;\n      where <ident>\
    \ is the name of an outermost container.\n      Two containers with the same outermost\
    \ <ident> can not be\n      opened at the same time (***).\n      To change the\
    \ mode of an open container:\n           MODE <ident> <newmode> ;\n"
- title: 5.3 LIST
  contents:
  - "5.3 LIST\n      LIST %OPEN transmits name, mode and connection status of each\
    \ open\n      outermost container through the Datalanguage output port. (The\n\
    \      Datalanguage output port is the destination to which all\n      Datacomputer\
    \ diagnostics and replies are sent.  It is established\n      when the user initially\
    \ connects to the Datacomputer.)  For\n      details of the LIST-request, see\
    \ section 10.1.\n"
- title: 6. Assignment
  contents:
  - "6. Assignment\n   Assignment transfers data from one container to another.\n\
    \   The equal sign ('=') is the symbol for assignment.  The value of the\n   operand\
    \ on the right of the equal sign is transferred to the operand\n   on the left.\
    \  (Eventually, both operands will be weakly-restricted\n   Datalanguage expressions,\
    \ which may evaluate to sets as well as to\n   single containers.  Now, the left\
    \ must be a container name, the right\n   may be a container name or a constant.)\n\
    \   Assignment is defined for all types of containers.  When the\n   containers\
    \ are aggregates, their elements are paired and data is\n   transferred between\
    \ paired elements.  Elements of the target\n   container that do not pair with\
    \ some source element are handled with\n   a default operation (currently they\
    \ are filled with blanks).\n   The operands of an assignment must have descriptions\
    \ that match.  The\n   idea of matching is that the descriptions must be similar\
    \ enough so\n   that it is obvious how to map one into the other.\n"
- title: 6.1 Conditions for legitimate assignment
  contents:
  - "6.1 Conditions for legitimate assignment\n      Assignment must reference objects,\
    \ not sets.  An object is:\n         (a)   an outermost container, or\n      \
    \   (b)   a constant, or\n         (c)   in the body of a FOR-loop, either\n \
    \              (c1) a member of a set defined by a FOR-OPERAND, or\n         \
    \      (c2) a container which occurs once in such a member\n      In the case\
    \ of a reference of type (c1), the object referenced is\n      taken to be the\
    \ current member.  In the case of (c2), the object\n      referenced is that which\
    \ occurs in the current member.  This is\n      explained further in section 7.\n\
    \      The left operand of an assignment is subject to further\n      restriction.\
    \  If it is an outermost container, it must be open in\n      either WRITE- or\
    \ APPEND-mode.  If it is not an outermost\n      container, then the reference\
    \ is of type (c), which means that\n      some FOR-operand has established a context\
    \ in which the assign-\n      operand is an object.  The FOR-operand which establishes\
    \ this\n      context must be the output-operand of the FOR.\n      When the assign-operand\
    \ is an outermost container, it must be\n      open.  Such an operand must be\
    \ referenced by its simple container\n      ident(***), not its directory pathname.\n\
    \      In the body of a loop nested in one or more other loops,\n      assignments\
    \ are further restricted, due to a 0/9 implementation\n      problem.  See section\
    \ 7.2 for details.\n      Finally, the descriptions of the operands must match.\
    \  If one is a\n      constant, then the other must be a STRING(***).  If both\
    \ are\n      containers, then in the expression:\n         A = B;\n      the descriptions\
    \ of containers A and B match if:\n      1. A and B have the same type\n     \
    \ 2. If A and B are LISTs, then they have equal numbers of\n         LIST-members,\
    \ or else A is an outermost-LIST.\n      3. If A and B are aggregates, then at\
    \ least one container\n      immediately enclosed in A matches, and has the same\
    \ ident as, one\n      container immediately enclosed in B.\n"
- title: 6.2 Result of assignment
  contents:
  - "6.2 Result of assignment\n      If the operands are STRINGs, then the value of\
    \ B, left-justified,\n      replaces the value of A.  If B is longer than A, the\
    \ value is\n      truncated.  If B is shorter than A, then A is filled on the\
    \ right\n      with blanks as necessary.\n      If the operands are STRUCTs, then\
    \ assignment is defined in terms\n      of the STRUCT members.  If a member of\
    \ A, mA, matches and has the\n      same name as a member of B, mB, then mB is\
    \ assigned to mA.  If no\n      such mB exists, then mA is filled with blanks.\n\
    \      If the operands are LISTs, the result depends on several factors.\n   \
    \   First, notice that the descriptions of the LIST-members must\n      match;\
    \  otherwise the assignment would not be legitimate by the\n      matching rules\
    \ of 6.1.\n      If A is an outermost-LIST, then it can be in either of two modes:\n\
    \      WRITE or APPEND.  If A is in WRITE-mode, its previous contents are\n  \
    \    first discarded; it is then handled as though it were in APPEND-\n      mode.\n\
    \      If A is not an outermost-LIST, then it is always effectively in\n     \
    \ WRITE-mode.\n      After taking the mode of A into account, as described above,\
    \ the\n      procedure is:\n         for each member of LIST B\n         (a) add\
    \ a new member to the end of A\n         (b) assign the current number of B to\
    \ the new member of A\n"
- title: 6.3 Deletion of Data Through Assignment
  contents:
  - "6.3 Deletion of Data Through Assignment\n      If A is an outermost container\
    \ in WRITE-mode, and B is a container\n      with description that matches A,\
    \ and if B contains no data, then\n      A=B has the effect of deleting all data\
    \ from A.  Note that if A is\n      in APPEND-mode in these circumstances, then\
    \ A=B is a no-operation\n      (i.e., has no effect).\n"
- title: 7. FOR
  contents:
  - "7. FOR\n      FOR <output set spec>, <input set spec> <body> END ;\n   The output\
    \ set is optional: that is, FOR need not produce output.\n   When the output set\
    \ is omitted, the syntax is:\n      FOR <input set spec> <body> END ;\n   The\
    \ operations specified in the body are performed once for each\n   member of the\
    \ input set.  References in the body to the input set\n   member are treated as\
    \ references to the current input set member.\n   When an output set is present,\
    \ a new member is created and added to\n   the output set for each iteration (i.e.,\
    \ for each input set member).\n   References to the output set member, similarly,\
    \ are treated as\n   references to the current output set member.\n   The output\
    \ set spec must be the name of a LIST member.  Each\n   iteration of the FOR will\
    \ create one such member, and add it to its\n   LIST (hereafter called the output\
    \ LIST).  The body terminates the\n   value that the new member receives.  Any\
    \ STRING in the new member\n   which is not given a value by the body receives\
    \ he default value of\n   all blanks.\n   The input set spec must be an expression\
    \ evaluating to a set of\n   LIST-members (see section 7.1 for details of input\
    \ set\n   specification).  Each iteration for the FOR will input one such\n  \
    \ member; the FOR will terminate when each member of the set has been\n   processed.\
    \  The LIST from which the input set members are drawn is\n   called the input\
    \ LIST.\n   FOR is effectively a means of accomplishing variants of assignment\n\
    \   between a pair of LISTS.  FOR is less concise than assignment, but\n   offers\
    \ more flexibility.  Its advantages are:\n      (a) not all the input LIST-members\
    \ need be transferred to the\n          output LIST.  A subset can be selected\
    \ by content.\n      (b) the user has explicit control over the assignment of\
    \ values to\n          output LIST-members.\n   This is most easily understood\
    \ by an example:\n       P PORT LIST               F FILE LIST\n         R STRUCT\
    \                  R STRUCT\n           B STR                     A STRUCT\n \
    \          C STR                       A1 STR\n           END                \
    \         A2 STR\n                                     B STR\n               \
    \                      C STR\n                                     END\n   (1)\
    \   P = F ;\n   (2)   FOR P.R, F.R\n               P.R = F.R ;\n             \
    \  END ;\n   (3)   FOR P.R, F.R WITH A1 EQ 'XY' OR A2 GE 'AB'\n              \
    \ B = C ;\n               C = A2 ;\n               END\n   Here, (1) and (2) are\
    \ entirely equivalent requests.  However, (3) is\n   quite different and is not\
    \ expressible as assignment.  It selects a\n   subset of F.Rs.  The values it\
    \ gives to the P.Rs could not result\n   from application of the matching rules\
    \ to F and P.\n   Because FOR is effectively assignment between a pair of LISTs,\
    \ the\n   LISTs referenced by a legitimate FOR-operation are largely subject to\n\
    \   the same restrictions as LISTs referenced in an assignment.  One\n   exception\
    \ is that the descriptions of the LIST-members need not\n   match.\n   These restrictions\
    \ are:\n   (a)   both LISTs must be objects in the context in which the FOR\n\
    \         appears.\n   (b)   both LISTs must be open or contained in open outermost\n\
    \         containers.\n   (c)   if the output LIST is an outermost container,\
    \ it must be in\n         WRITE- or APPEND-mode.\n   (d)   If the output LIST\
    \ is not outermost, the LIST which most\n         immediately encloses it must\
    \ be the output LIST of an enclosing\n         FOR.\n   The mode of the output\
    \ LIST of the FOR affects the result much as it\n   would in an assignment: that\
    \ is, a FOR outputting to a LIST in\n   WRITE-mode overwrites previous contents,\
    \ while a FOR outputting to a\n   LIST in APPEND-mode adds to previous contents.\n\
    \   CAUTION TO THE READER: For convenience, these specifications use\n   phrases\
    \ such as 'LISTs referenced by a FOR'.  Recall that such a\n   phrase is not literally\
    \ correct, in the sense that the operands of a\n   FOR are always LIST members,\
    \ not LISTs.\n"
- title: 7.1 Details of input set specification
  contents:
  - "7.1 Details of input set specification\n      The input set is specified by a\
    \ Datalanguage expression that\n      evaluates to a set of LIST-members.  Such\
    \ an expression can be\n      simply the set of all members of a LIST, or it can\
    \ be a subset of\n      the members of a LIST, specified by content.  For example,\
    \ with\n      the description:\n          F FILE LIST\n               R STRUCT\n\
    \                     A STR (1)\n                     B STR (2)\n            \
    \         END\n      the expression:\n         F.R\n      references all R's on\
    \ the LIST F.  However:\n         F.R WITH A EQ '5'\n      references only those\
    \ R's containing an A having the value '5'.\n      The expressions permitted as\
    \ input set specifications are of the\n      form:\n         <list-member-name>\
    \ WITH <boolexp>\n      The <boolexp> is constructed of comparison expressions\
    \ joined by\n      the Boolean operators AND and OR.  Any expression can be negated\n\
    \      with NOT.\n      Comparison operators have the highest precedence.  Next\
    \ highest is\n      AND, then OR, then NOT.\n      The comparison expressions\
    \ are restricted to the form:\n         <container name> <comop> <constant>\n\
    \      where:\n      (a)   <constant> is a string constant enclosed in single\
    \ quotes\n            (see section 10.2 for a discussion of constants)\n     \
    \ (b)   <comop> is one of six operators:\n                      EQ          equal\n\
    \                      NE          not equal\n                      LT       \
    \   less than\n                      GT          greater than\n              \
    \        LE          less than or equal to\n                      GE         \
    \ greater than or equal to\n      (c)   <container name> is the name of a STRING\
    \ that appears once\n            in each LIST-member.\n      The constant is truncated\
    \ or padded with blanks on the right to\n      make it equal in size to the container\
    \ to which it is being\n      compared.  Notice that padding on the right is not\
    \ always\n      desirable (users will have control over the padding in a future\n\
    \      release).  In particular, care must be exercised when using\n      numbers\
    \ in Version 0/9.  (A number represented as a STRING should\n      actually be\
    \ described as a number; eventually it will be possible\n      to do this).\n"
- title: 7.2 FOR-body
  contents:
  - "7.2 FOR-body\n      Two operations are legitimate in a FOR-body:  FOR and assignment.\n\
    \      These are subject to the restrictions discussed in Section 6.1 and\n  \
    \    in the introduction to Section 7.  The restrictions are related to\n    \
    \  three requirements:  (1) that the names be recognizable (see\n      Section\
    \ 9 for details), (2) that a request be consistent regarding\n      direction\
    \ of data transfer between containers, both within itself\n      and with the\
    \ MODE of outermost containers, and (3) that transfers\n      occur between objects,\
    \ not sets of objects.  The first two\n      requirements are permanent, but will\
    \ become weaker in later\n      versions of the language.  The last requirement\
    \ is temporary and\n      will be present only in early versions.\n      Due to\
    \ an implementation problem associated with Version 0/9,\n      there is a somewhat\
    \ bizarre restriction applied to references made\n      in the body of a loop\
    \ nested in another loop.  This restriction is\n      not expected to pose any\
    \ practical problems for users, and is not\n      part of the language design,\
    \ but is discussed here for\n      completeness.\n      The restriction is most\
    \ easily understood by example:\n      given the description\n          F LIST\n\
    \                R STRUCT\n                      A STR (3)\n                 \
    \     BL LIST (3)\n                            B STR (3)\n                   \
    \   C STR (3)\n                      END\n      and the request fragment:\n  \
    \        FOR ...,R\n                FOR ...,B\n                      ... = A ;\n\
    \                      ... = C ;\n                      END\n                END\n\
    \      observe:\n      (a)   The outer loop processes the set of R's in F.\n \
    \     (b)   For each R in F, the inner loop processes the set of B's in\n    \
    \        the BL contained in that R.\n      (c)   In the body of the inner loop,\
    \ there are references to A and\n            C, which do not occur in B, but do\
    \ occur in R.  That is, the\n            objects referenced in the inner loop\
    \ body are defined by the\n            outer loop, not the inner loop.  In general,\
    \ this is fine;\n            in the case of C, however, we have a problem.\n \
    \     (d)   C occurs beyond the end of BL.\n      The 0/9 compiler is capable\
    \ of neither (1) looking ahead enough to\n      locate C before it compiles code\
    \ for the loop, nor (2) while\n      generating code to loop on the B's in BL,\
    \ generating a separate\n      body of code that skips to the end of BL to locate\
    \ C.  Thus it can\n      handle A, which has been located before it begins loop\
    \ generation,\n      but it cannot handle C, which requires a little foresight.\n\
    \      The request fragment shown would not cause problems if the\n      description\
    \ were changed to:\n          F LIST\n                R STRUCT\n             \
    \         A STR (3)\n                      C STR (3)\n                      BL\
    \ LIST (3)\n                            B STR (3)\n                      END\n\
    \      Then both A and C would have been found before code for the inner\n   \
    \   loop was generated.\n"
- title: 8.  Data Transmission
  contents:
  - "8.  Data Transmission\n   Data is transferred from container to container by\
    \ execution of\n   assignment and FOR operations.  The outermost containers involved\
    \ in\n   transfers can be files or ports.  If both are files, then the\n   transfer\
    \ is internal to the Datacomputer.  If either is a port, then\n   an address in\
    \ the external world is needed to accomplish the data\n   transmission.\n   Such\
    \ an address is supplied through a CONNECT-request, which\n   associates a container\
    \ (having a function of PORT) with an external\n   address:\n      CONNECT <ident>\
    \ TO <address> ;\n   Here <address> is either a specifications of host and socket\
    \ number,\n   or a TENEX file designator (for CCA's TENEX) enclosed in single\n\
    \   quotes.  The host and socket form is:\n      <socket> AT <host>\n   where\
    \ <socket> is a decimal number, and <host> is either a decimal\n   number or a\
    \ standard host name (since standard host names don't exist\n   right now, it\
    \ has to be the TENEX 'standard' name for the host.\n   Contact the author for\
    \ the latest list.)  If <host> is omitted, it is\n   taken to be the host from\
    \ which the Datalanguage is being\n   transmitted.\n   The address associated\
    \ with a port can be changed by issuing another\n   CONNECT-request.\n   A DISCONNECT-request\
    \ simply breaks an existing port/address\n   association without establishing\
    \ a new one.  (A CLOSE-request that\n   references an open port executes a DISCONNECT.)\
    \  The syntax of\n   DISCONNECT is:\n      DISCONNECT <ident> ;\n   A port is\
    \ disconnected when: (a) no successful CONNECT-request has\n   ever been issued\
    \ for it, or (b) a DISCONNECT for the port has been\n   executed since the last\
    \ successful CONNECT.\n   When a disconnected port is referenced in an assignment,\
    \ it is\n   connected by default either to:\n   (a) the connection used for the\
    \ transmission of Datalanguage to the\n         Datacomputer, or\n   (b) the connection\
    \ used for the transmission of Datacomputer\n         diagnostics to the user\n\
    \   The choice between (a) and (b), of course, depends on whether the\n   reference\
    \ is for input or output.  These connections are established\n   by the network\
    \ user's ICP to the Datacomputer at the beginning of the\n   session.\n   Note\
    \ that CONNECT and DISCONNECT do not open files or network\n   connections.  They\
    \ simply make address associations within the\n   Datacomputer.  The files and\
    \ connections are opened before each\n   request and closed after each request.\n"
- title: 9.  Names in Datalanguage
  contents:
  - "9.  Names in Datalanguage\n   A name is recognized when it has been associated\
    \ with a particular\n   data container or set of containers.\n   Datalanguage\
    \ has mechanisms for the recognition of names in contexts.\n   That is, the meaning\
    \ of the name is related to where it appears.\n   This makes it possible to attach\
    \ natural meanings to partially\n   qualified names.\n   For example:\n      \
    \ WEATHER FILE LIST\n             STATION STRUCT\n                   CITY STR\
    \ (15)\n                   STATE STR (15)\n                   DATA LIST (24)\n\
    \                         OBSERVATION STRUCT\n                               HOUR\
    \ STR (2)\n                               TEMPERATURE STR (3)\n              \
    \                 HUMIDITY STR (2)\n                               PRESSURE STR\
    \ (4)\n                               END\n                   END\n       RESULTS\
    \ PORT LIST\n             RESULT STRUCT\n                   CITY STR (15)\n  \
    \                 HOUR STR (2)\n                   TEMPERATURE STR (3)\n     \
    \              END\n       FOR STATION WITH STATE EQ 'CALIFORNIA'\n          \
    \   FOR RESULT, OBSERVATION WITH HOUR GT '12'\n                         AND HUMIDITY\
    \ LT '75'\n                   CITY = CITY ;\n                   HOUR = HOUR ;\n\
    \                   TEMPERATURE = TEMPERATURE ;\n                   END ;\n  \
    \           END ;\n   in the assignment 'CITY = CITY', the first CITY is understood\
    \ to be\n   RESULT.CITY and the second is understood to be STATION.CITY.\n"
- title: 9.1 Informal Presentation of Recognition Rules
  contents:
  - "9.1 Informal Presentation of Recognition Rules\n      'Ident' is used in the\
    \ sense of section 3.  For example, in the\n      description:\n         F FILE\
    \ LIST R STRUCT A STR (1) B STR (1) END\n         F, R, A and B are idents.\n\
    \      A context is a tree whose nodes are idents.  In such a tree, the\n    \
    \  terminal nodes are idents of STRINGs.  The ident of a LIST is\n      superior\
    \ to the ident of the LIST-member.  The ident of a STRUCT\n      is superior to\
    \ the idents of the STRUCT elements.  The context\n      whose top node is F is\
    \ said to be the context of F.\n                  +-----+\n                  !\
    \  F  !\n                  +-----+\n                     !\n                 \
    \    !\n                  +-----+\n                  !  R  !\n               \
    \   +-----+\n                     !\n                     !\n          +----------+----------+\n\
    \          !                     !\n          !                     !\n      \
    \ +-----+               +-----+\n       !  A  !               !  B  !\n      \
    \ +-----+               +-----+\n       Figure 9.1-1  The context of F\n     \
    \ A pathname is a sequence of idents, naming nodes along a path from\n      one\
    \ node to another.  A full pathname in the context starts at the\n      topmost\
    \ node.  Thus F.R.B is a full pathname in the context of F.\n      A partial pathname\
    \ starts at a node other than the topmost node\n      (e.g.  R.B, B).\n      In\
    \ Datalanguage, pathnames omitting intermediate nodes, such as\n      F.B (which\
    \ omits 'R'), are not permitted.  Thus partial pathnames\n      are partial only\
    \ in that additional names are implied on the left.\n      Three attempts at recognition\
    \ of a pathname, PN, in a context, CX,\n      are made:\n      (a)   recognition\
    \ of PN as a full pathname in CX\n      (b)   recognition of PN as a partial pathname\
    \ in which only the\n            topmost node of CX is omitted\n      (c)   recognition\
    \ of PN as an arbitrary partial pathname occurring\n            only once in CX.\n\
    \      The attempts are made in the above order, and the recognition\n      process\
    \ halts with the first successful attempt.\n      As an example, consider the\
    \ description:\n          F FILE LIST\n                R STRUCT\n            \
    \          A STR\n                      B STR\n                      S STRUCT\n\
    \                            R STR\n      which defines the context in Figure\
    \ 9.1-2.\n                                  +-----+\n                        \
    \          !  F  !\n                                  +-----+\n              \
    \                       !\n                                     !\n          \
    \                        +-----+\n                                  !  R  !\n\
    \                                  +-----+\n                                 \
    \    !\n                                     !\n                    +----------------+----------------+\n\
    \                    !                !                !\n                   \
    \ !                !                !\n                 +-----+          +-----+\
    \          +-----+\n                 !  A  !          !  B  !          !  S  !\n\
    \                 +-----+          +-----+          +-----+\n                \
    \                                      !\n                                   \
    \                   !\n                                                   +-----+\n\
    \                                                   !  R  !\n                \
    \                                   +-----+\n                  Figure 9.1-2  \
    \    Example Context\n      In this context, F.R.A is a full pathname.  Thus,\
    \ F.R.A is\n      recognized in attempt (a).  R is a partial pathname in which\
    \ only\n      the topmost node is omitted.  Thus R is recognized in attempt (b).\n\
    \      Note carefully that R is recognized as a reference to F.R, not to\n   \
    \   F.R.S.R.  Finally, B is an arbitrary partial pathname occurring\n      only\
    \ once in the context.  Thus B is recognized in attempt (c).\n      Two stacks\
    \ of contexts are maintained:  one for names used in an\n      input sense, and\
    \ one for names used in an output sense.  When a\n      name is to be recognized,\
    \ it is first decided whether the\n      reference is an input reference or an\
    \ output reference.  An input\n      reference is (a) the right hand operand of\
    \ an assign, or (b) a\n      name in the input set spec of a FOR.  An output reference\
    \ is (a)\n      the left operand of an assign, or (b) the output operand of a\
    \ FOR.\n      The first context on the appropriate context stack is then\n   \
    \   searched, according to the procedure outlined on the previous\n      page.\
    \  If the name is neither recognized nor ambiguous in that\n      context, search\
    \ continues in the next context on the stack.  If\n      the name can be recognized\
    \ in none of the contexts on the\n      appropriate stack, it is unrecognizable.\n\
    \      When a stack is empty, the recognition procedure is different.\n      The\
    \ search is carried on in a special context: The context of\n      %OPEN.  Its\
    \ top node, %OPEN, is a built in system ident.\n      Subordinate to %OPEN is\
    \ a context for each open directory node.\n      Each such context represents\
    \ all the idents defined in the\n      directory nodes having data descriptions:\n\
    \         F FILE LIST R STRUCT A STR (1) B STR (1)\n      and:\n         P PORT\
    \ LIST R STRUCT A STR (1) B STR (1)\n      then the context of %OPEN would be\
    \ as in Figure 9.1-3.\n                                 +-------+\n          \
    \                       ! %OPEN !\n                                 +-------+\n\
    \                                     !\n                                    \
    \ !\n                         +-----------+-----------+\n                    \
    \     !                       !\n                         !                  \
    \     !\n                 +-----+                      +-----+\n             \
    \    !  A  !                      !  S  !\n                 +-----+          \
    \            +-----+\n                    !                            !\n   \
    \                 !                            !\n                 +-----+   \
    \                   +-----+\n                 !  R  !                      ! \
    \ R  !\n                 +-----+                      +-----+\n              \
    \      !                            !\n                    !                 \
    \           !\n              +-----+-----+                +-----+-----+\n    \
    \          !           !                !           !\n              !       \
    \    !                !           !\n           +-----+     +-----+          +-----+\
    \     +-----+\n           !  A  !     !  B  !          !  A  !     !  B  !\n \
    \          +-----+     +-----+          +-----+     +-----+\n                \
    \  Figure 9.1-3      The Context of %OPEN\n      When a directory node is closed,\
    \ the corresponding context is\n      removed from the context of %OPEN.  When\
    \ a node is opened, the\n      associated context is added as the rightmost context\
    \ subordinate\n      to %OPEN.\n"
- title: 9.2 Context Stack Maintenance
  contents:
  - "9.2 Context Stack Maintenance\n      The context stacks are always empty between\
    \ requests.  The FOR-\n      operator adds entries to the stacks.  FOR A adds\
    \ the context of A\n      to the input context stack.  FOR A, B ... adds the context\
    \ of A to\n      the output stack and the context of B to the input stack.\n \
    \     When adding to an empty stack, FOR adds two contexts instead of\n      one.\
    \  The second addition to the stack is the context of the\n      looparg; the\
    \ first addition is the context of the outermost\n      container which encloses\
    \ the looparg.\n      For example, given a context of %OPEN as in Figure 9.1-3,\
    \ and\n      empty context stacks, the fragment 'FOR F.R ...' adds two\n     \
    \ contexts: (1) the context of F, and (2) the context of F.R.\n      Contexts\
    \ are removed from the stacks by the END matching the FOR\n      which added them.\n"
- title: 10.  Miscellaneous Topics
  contents:
  - '10.  Miscellaneous Topics

    '
- title: 10.1 The LIST-request
  contents:
  - "10.1 The LIST-request\n      The LIST-request provides a means for the user to\
    \ inspect system\n      data of interest to him.  The user can determine the contents\
    \ of\n      the directory, the source or parsed form of any data description\n\
    \      in the system, and the mode and connection status of any open file\n  \
    \    or port.\n      The LIST operator has a single operand, which can have any\
    \ of\n      several forms.  The action of the operator is to output a list of\n\
    \      values on the Datalanguage output port.\n      To output a list of pathnames,\
    \ the operand used is '%ALL'.  When\n      '%ALL' appears alone, all pathnames\
    \ in the directory are listed.\n      When '%ALL' appears after the last ident\
    \ in a directory pathname,\n      the full pathnames of all nodes subordinate\
    \ to the named node are\n      listed.\n      To output one or more source descriptions,\
    \ the operand '.%SOURCE'\n      is used.  '.%SOURCE' is preceded with one of (a)\
    \ '%ALL', (b)\n      '%OPEN', or (c) the ident of an open outermost container.\
    \  The\n      output is either (a) all descriptions, (b) all open descriptions,\n\
    \      or (c) a particular open description.\n      To output a parsed description,\
    \ the operand '.%DESC' is used\n      ('%DESCRIPTION' is also accepted).  This\
    \ operand is preceded\n      either with (a) '%OPEN', or (b) the ident of an open\
    \ outermost\n      container.\n      Examples:\n         Let P be the ident of\
    \ an open PORT.  Let A.B.C be a\n         directory pathname.\n             LIST\
    \ %ALL\n             LIST A.B.C.%ALL\n             LIST %OPEN\n             LIST\
    \ %ALL.%SOURCE\n             LIST %OPEN.%SOURCE\n             LIST P.%SOURCE\n\
    \             LIST %OPEN.%DESC\n             LIST P.%DESC\n         Note that\
    \ 'LIST A.B.C.%SOURCE' is not legal - '.%SOURCE'\n         must be preceded with\
    \ the ident of an open container, not a\n         pathname.  A similar restriction\
    \ applies to '.%DESC'.\n"
- title: 10.2 Constants in Datalanguage
  contents:
  - "10.2 Constants in Datalanguage\n      A constant of type STRING can be included\
    \ in a Datalanguage\n      request by enclosing it in single quotes:\n       \
    \  'ABC'\n      A single quote is included in a constant by preceding it with\
    \ a\n      double quote:\n         'FATHER\"'S'\n      Likewise, a double quote\
    \ is included by preceding it with a double\n      quote:\n         'JOHN SAID\
    \ \"\"HELLO\"\"'\n      Such constants can be used on the right of comparison\
    \ operators\n      and of assignment operators which reference strings.\n    \
    \  Eventually, Datalanguage will contain facilities for the inclusion\n      of\
    \ constants of all datatypes; such constants are simply a special\n      case\
    \ of the Datalanguage expression and will be permitted wherever\n      such expressions\
    \ are permitted.\n"
- title: 10.3 Character Set
  contents:
  - "10.3 Character Set\n      Internally, Version 0/9 of the Datacomputer software\
    \ operates in\n      7-bit ASCII characters.  Its output to the ARPANET is converted\
    \ to\n      8-bit ASCII.  On input from the ARPANET, it expects 8-bit\n      characters,\
    \ which it converts to 7-bit characters.\n      To convert from 7- to 8-bit characters,\
    \ a '0' bit is prefixed.  To\n      convert from 8- to 7-bit characters, the high-order\
    \ bit is\n      checked.  If the high-order bit is a '0', the bit is discarded\
    \ and\n      the character is accepted as a 7-bit character.  If the high-order\n\
    \      bit is a '1', then the character is discarded.\n      (In the following\
    \ discussion, as elsewhere in this memo, all\n      references to numerical character\
    \ codes are in decimal).\n      The remainder of this section discusses treatment\
    \ of codes 0\n      through 127, when they appear in Datalanguage requests.\n\
    \      In general, printing characters are acceptable in requests, while\n   \
    \   control characters are not.  There are some exceptions, which are\n      detailed\
    \ below.  The printing characters are codes 32-126.  The\n      control characters\
    \ are codes 0-31 and 127.\n      Certain control characters are accepted:\n  \
    \       Tab(9) is accepted freely in requests.  It functions as a\n         separator\
    \ (explained below).\n         EOL(31), meaning end-of-line, is accepted in requests,\n\
    \         functioning both as a separator and an activator (a).  EOL has\n   \
    \      a special meaning in data, and should not be introduced into\n        \
    \ STRING constants(***).\n         Control-L(12) is an activator and a high-level\
    \ request\n         delimiter.  It terminates the test of any request being\n\
    \         processed when it is encounter in the input stream.  It is\n       \
    \  useful in Datacomputer-user program synchronization.\n         Control-Z(26)\
    \ means end-of-session when encountered in\n         Datalanguage.  It has the\
    \ properties of control-L, and in\n         addition, causes the Datacomputer\
    \ to execute an end-of-session\n         procedure, which results in closing the\
    \ Datalanguage\n         connections, closing any open files or ports, etc.  The\
    \ effect\n         is equivalent to a [LOGOUT(which] does not exist yet).\n  \
    \       The two-character sequence <carriage return(13), line feed(10)>\n    \
    \     is equivalent to EOL (and is translated to EOL on input from\n         the\
    \ network).  The reverse sequence, as well as either\n         character alone,\
    \ is treated simply as other control characters\n         (ignored).\n      All\
    \ other control characters are ignored.\n      The printing characters are further\
    \ divided into four groups:\n      special characters, uppercase letters, lower\
    \ case letters, and\n      digits (the membership of these groups is defined in\
    \ section 11).\n      Corresponding upper and lower case letters are equivalent\
    \ in\n      requests, except with quoted strings.\n      Certain special characters\
    \ have a lexical function, which is\n      either break or separator.  A break\
    \ character terminates the\n      current lexical item and returned itself as\
    \ the next item.  A\n      separator character terminates the current item but\
    \ does not begin\n      a new item (i.e., its only function is to separate items).\n\
    \      Multiple separators are equivalent to a single separator.  A\n      separator\
    \ can always be inserted before or after a break\n      character, without altering\
    \ the meaning of the request.\n      The separators are tab(9), space(32), and\
    \ end-of-line(31).\n      The break characters are left parenthesis(40), right\n\
    \      parenthesis(41), equals(61), semicolon(59), period(46), comma(44),\n  \
    \    quote(39), and slash(47).\n      (a)   An activator character causes the\
    \ Datacomputer to process\n            whatever has been received since the previous\
    \ activator or\n            the beginning of the request.  The meaning of a request\
    \ is\n            independent of the presence/absence of activators.  However,\n\
    \            a request will not be executed until an activator beyond the\n  \
    \          end of the request is received.\n      While Version 0/9 defines (carriage\
    \ return, linefeed) in terms of\n      EOL, network users should not think in\
    \ terms of sending EOL's to\n      the Datacomputer over the network.  EOL is\
    \ not part of the network\n      ASCII character set, and has no definite permanent\
    \ place in\n      Datacomputer implementation plans.\n"
- title: 10.4 Comments
  contents:
  - "10.4 Comments\n      Comments can be included in Datalanguage requests.  A comment\
    \ is\n      begun with the two-character sequence '/*', and ended with the\n \
    \     two-character sequence '*/'.  Since slash is a break character, a\n    \
    \  comment does cause a lexical break; its overall effect is that of\n      a\
    \ separator.\n"
- title: 10.5 Reserved Identifiers
  contents:
  - "10.5 Reserved Identifiers\n      Certain identifiers are reserved in Datalanguage,\
    \ and should not\n      be used to name containers or directory nodes.  These\
    \ are:\n      AND\n      APPEND\n      AT\n      CLOSE\n      CONNECT\n      CREATE\n\
    \      DELETE\n      DISCONNECT\n      END\n      EQ\n      FILE\n      FOR\n\
    \      GE\n      GT\n      LE\n      LIST\n      LT\n      NODE\n      NE\n  \
    \    NOT\n      OPEN\n      OR\n      PORT\n      READ\n      STR\n      STRUCT\n\
    \      TO\n      WITH\n      WRITE\n      More reserved identifiers will be added\
    \ in Version 0/10.\n"
- title: 11.  Datalanguage Syntax Expressed in BNF
  contents:
  - '11.  Datalanguage Syntax Expressed in BNF

    '
- title: 11.1 Requests
  contents:
  - "11.1 Requests\n      11.1.01  <request>  ::=  ;\n      11.1.02  <request>  ::=\
    \  <create>\n      11.1.03  <request>  ::=  OPEN <pn>  ;\n      11.1.04  <request>\
    \  ::=  OPEN <pn> <mode>  ;\n      11.1.05  <request>  ::=  CLOSE <ident>  ;\n\
    \      11.1.06  <request>  ::=  CONNECT <ident> TO <address>  ;\n      11.1.07\
    \  <request>  ::=  DISCONNECT <ident>  ;\n      11.1.08  <request>  ::=  MODE\
    \ <ident> <mode>  ;\n      11.1.09  <request>  ::=  DELETE <pn>  ;\n      11.1.10\
    \  <request>  ::=  LIST <listarg>  ;\n      11.1.11  <request>  ::=  <sr-request>\
    \  ;\n"
- title: 11.2 Data Description and Creation
  contents:
  - "11.2 Data Description and Creation\n      11.2.01  <create>  ::=  CREATE <pn>\n\
    \      11.2.02  <create>  ::=  CREATE <pn> <ftn> LIST <desc>\n      11.2.03  <create>\
    \  ::=  CREATE <pn> <ftn> LIST <size> <desc>\n      11.2.04  <desc>  ::=  <ident>\
    \ <attributes>\n      11.2.05  <attributes>  ::=  LIST <size> <desc>\n      11.2.06\
    \  <attributes>  ::=  STRUCT <descs> END\n      11.2.07  <attributes>  ::=  STR\
    \ <size>\n      11.2.08  <attributes>  ::=  STR <size> ,I=D\n      11.2.09  <descs>\
    \  ::=  <desc>\n      11.2.10  <descs>  ::=  <descs> <desc>\n      11.2.11  <ftn>\
    \  ::=  PORT\n      11.2.12  <ftn>  ::=  FILE\n      11.2.13  <ftn>  ::=  TEMP\
    \ PORT\n      11.2.14  <ftn>  ::=  TEMPORARY PORT\n      11.2.15  <size>  ::=\
    \  (  <integer constant>  )\n"
- title: 11.3 Data Storage and Retrieval
  contents:
  - "11.3 Data Storage and Retrieval\n      11.3.01  <sr-request>  ::=  <assign>\n\
    \      11.3.01  <sr-request>  ::=  <loop>\n      11.3.03  <assign>  ::=  <pn>\
    \ = <object>\n      11.3.04  <loop>  ::=  FOR <looparg> <loopbody> END\n     \
    \ 11.3.05  <looparg>  ::=  <exp>\n      11.3.06  <looparg>  ::=  <pn> , <exp>\n\
    \      11.3.07  <loopbody>  ::=  <sr-request>\n      11.3.08  <loopbody>  ::=\
    \  <loopbody1> <sr-request>\n      11.3.09  <loopbody>  ::=  <loopbody1>\n   \
    \   11.3.10  <loopbody1>  ::=  <sr-request>  ;\n      11.3.11  <loopbody1>  ::=\
    \  <loopbody1> <sr-request>  ;\n"
- title: 11.4 Expressions
  contents:
  - "11.4 Expressions\n      11.4.01  <exp>  ::=  <pn>\n      11.4.02  <exp>  ::=\
    \  <pn> WITH <boolexp>\n      11.4.03  <boolexp>  ::=  <pn> <comop> <string constant>\n\
    \      11.4.04  <boolexp>  ::=  (  <boolexp>  )\n      11.4.05  <boolexp>  ::=\
    \  NOT <boolexp>\n      11.4.06  <boolexp>  ::=  <boolexp> AND <boolexp>\n   \
    \   11.4.07  <boolexp>  ::=  <boolexp> OR <boolexp>\n      11.4.08  <comop>  ::=\
    \  EQ\n      11.4.09  <comop>  ::=  NE\n      11.4.10  <comop>  ::=  GT\n    \
    \  11.4.11  <comop>  ::=  LT\n      11.4.12  <comop>  ::=  GE\n      11.4.13 \
    \ <comop>  ::=  LE\n"
- title: 11.5 Miscellaneous
  contents:
  - "11.5 Miscellaneous\n      11.5.01  <address>  ::=  <quote> <TENEX file designator>\n\
    \               <quote>\n      11.5.02  <address>  ::=  <socket> AT <host>\n \
    \     11.5.03  <address>  ::=  <socket>\n      11.5.04  <socket>  ::=  <integer\
    \ constant>  //INTERPRETED AS\n               DECIMAL\n      11.5.05  <host> \
    \ ::=  <integer constant>  //INTERPRETED AS\n               DECIMAL\n      11.5.06\
    \  <host>  ::=  *****  TENEX host names *****\n      11.5.07  <object>  ::=  <pn>\n\
    \      11.5.08  <object>  ::=  <string constant>\n      11.5.09  <mode>  ::= \
    \ READ\n      11.5.10  <mode>  ::=  APPEND\n      11.5.11  <mode>  ::=  WRITE\n\
    \      11.5.12  <listarg>  ::=  %ALL\n      11.5.13  <listarg>  ::=  <pn>.%ALL\n\
    \      11.5.14  <listarg>  ::=  %OPEN\n      11.5.15  <listarg>  ::=  %ALL.%SOURCE\n\
    \      11.5.16  [<LISTARG>]  ::=  <IDENT>.%SOURCE\n      11.5.17  <listarg>  ::=\
    \  %OPEN.%SOURCE\n      11.5.18  <listarg>  ::=  %OPEN.%DESC\n      11.5.19  <listarg>\
    \  ::=  <ident>.%DESC\n      11.5.20  <pn>  ::=  <ident>\n      11.5.21  <pn>\
    \  ::=  <pn>.<ident>\n      11.5.22  <ident>  ::=  <letter>\n      11.5.23  <ident>\
    \  ::=  <ident> <letter>\n      11.5.24  <ident>  ::=  <ident> <digit>\n     \
    \ 11.5.25  <integer constant>  ::=  <digit>\n      11.5.26  <integer constant>\
    \  ::=  <integer constant> <digit>\n      11.5.27  <string constant>  ::=  <quote>\
    \ <string conbody>\n               <quote>\n      11.5.28  <string conbody>  ::=\
    \  <nonquote>\n      11.5.28  <string conbody>  ::=  <string conbody> <nonquote>\n"
- title: 11.6 Character Set
  contents:
  - "11.6 Character Set\n      11.6.01  <separator>  ::=   //SPACE(32)\n      11.6.02\
    \  <separator>  ::=   //TAB(9)\n      11.6.03  <separator>  ::=  <eol>\n     \
    \ 11.6.04  <special>  ::=  <quote>\n      11.6.05  <special>  ::=  <superquote>\n\
    \      11.6.06  <special>  ::=  <special1>\n      11.6.07  <letter>  ::=  A\n\
    \      11.6.08  <letter>  ::=  B\n       ...............\n      11.6.09  <letter>\
    \  ::=  Z\n      11.6.10  <letter>  ::=  a\n      11.6.11  <letter>  ::=  b\n\
    \       ...............\n      11.6.12  <letter>  ::=  z\n      11.6.13  <digit>\
    \  ::=  0\n      11.6.14  <digit>  ::=  1\n       ...............\n      11.6.15\
    \  <digit>  ::=  9\n      11.6.16  <nonquote>  ::=  <letter>\n      11.6.17  <nonquote>\
    \  ::=  <digit>\n      11.6.18  <nonquote>  ::=  <superquote> <quote>\n      11.6.19\
    \  <nonquote>  ::=  <superquote> <superquote>\n      11.6.20  <nonquote>  ::=\
    \  <special1>\n      11.6.21  <nonquote>  ::=  <separator>\n      11.6.22  <eol>\
    \  ::=  //EOL (31)\n      11.6.23  <eol>  ::=  <carriage return> <line feed>\n\
    \      11.6.24  <carriage return>  ::=  //CARRIAGE RETURN (13)\n      11.6.25\
    \  <line feed>  ::=  //LINE FEED (10)\n      11.6.26  <quote>  ::=  ' //SINGLE\
    \ QUOTE(44)\n      11.6.27  <superquote>  ::=  \" //DOUBLE QUOTE(34)\n      11.6.28\
    \  <special1>  ::=  ! //EXCLAMATION POINT(33)\n      11.6.29  <special1>  ::=\
    \  # //NUMBER SIGN(35)\n      11.6.30  <special1>  ::=  $ //DOLLAR SIGN(36)\n\
    \      11.6.31  <special1>  ::=  % //PERCENT SIGN(37)\n      11.6.32  <special1>\
    \  ::=  & //AMPERSAND(38)\n      11.6.33  <special1>  ::=  ( //LEFT PARENTHESIS(40)\n\
    \      11.6.34  <special1>  ::=  ) //RIGHT PARENTHESIS(41)\n      11.6.35  <special1>\
    \  ::=  * //ASTERISK(42)\n      11.6.36  <special1>  ::=  + //PLUS SIGN(43)\n\
    \      11.6.37  <special1>  ::=  , //COMMA(44)\n      11.6.38  <special1>  ::=\
    \  - //MINUS SIGN(45)\n      11.6.39  <special1>  ::=  . //PERIOD(46)\n      11.6.40\
    \  <special1>  ::=  / //SLASH(47)\n      11.6.41  <special1>  ::=  : //COLON(58)\n\
    \      11.6.42  <special1>  ::=  ; //SEMICOLON(59)\n      11.6.43  <special1>\
    \  ::=  < //LEFT ANGLE BRACKET(60)\n      11.6.44  <special1>  ::=  = //EQUAL\
    \ SIGN(61)\n      11.6.45  <special1>  ::=  > //RIGHT ANGLE BRACKET(62)\n    \
    \  11.6.46  <special1>  ::=  ? //QUESTION MARK(63)\n      11.6.47  <special1>\
    \  ::=  @ //AT-SIGN(64)\n      11.6.48  <special1>  ::=  [ //LEFT SQUARE BRACKET(91)\n\
    \      11.6.49  <special1>  ::=   //BACK SLASH(92)\n      11.6.50  <special1>\
    \  ::=  ] //RIGHT SQUARE BRACKET(93)\n      11.6.51  <special1>  ::=  ^ //CIRCUMFLEX(94)\n\
    \      11.6.52  <special1>  ::=  _ //UNDERBAR(95)\n      11.6.53  <special1> \
    \ ::=  ` //ACCENT GRAVE(96)\n      11.6.54  <special1>  ::=  { //LEFT BRACE(123)\n\
    \      11.6.55  <special1>  ::=  | //VERTICAL BAR(124)\n      11.6.56  <special1>\
    \  ::=  } //RIGHT BRACE(125)\n      11.6.57  <special1>  ::=  ~ //TILDE(126)\n\
    \      <EOF>\n          [ This RFC was put into machine readable form for entry\
    \ ]\n           [ into the online RFC archives by Walter Benton 12/98 ]\n"
