- title: __initial_text__
  contents:
  - '            The Kerberos Network Authentication Service (V5)

    '
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This RFC specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" for the standardization state and status\n   of this protocol.\
    \  Distribution of this memo is unlimited.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document gives an overview and specification of Version 5 of\
    \ the\n   protocol for the Kerberos network authentication system. Version 4,\n\
    \   described elsewhere [1,2], is presently in production use at MIT's\n   Project\
    \ Athena, and at other Internet sites.\n"
- title: Overview
  contents:
  - "Overview\n   Project Athena, Athena, Athena MUSE, Discuss, Hesiod, Kerberos,\n\
    \   Moira, and Zephyr are trademarks of the Massachusetts Institute of\n   Technology\
    \ (MIT).  No commercial use of these trademarks may be made\n   without prior\
    \ written permission of MIT.\n   This RFC describes the concepts and model upon\
    \ which the Kerberos\n   network authentication system is based. It also specifies\
    \ Version 5\n   of the Kerberos protocol.\n   The motivations, goals, assumptions,\
    \ and rationale behind most design\n   decisions are treated cursorily; for Version\
    \ 4 they are fully\n   described in the Kerberos portion of the Athena Technical\
    \ Plan [1].\n   The protocols are under review, and are not being submitted for\n\
    \   consideration as an Internet standard at this time.  Comments are\n   encouraged.\
    \  Requests for addition to an electronic mailing list for\n   discussion of Kerberos,\
    \ kerberos@MIT.EDU, may be addressed to\n   kerberos-request@MIT.EDU.  This mailing\
    \ list is gatewayed onto the\n   Usenet as the group comp.protocols.kerberos.\
    \  Requests for further\n   information, including documents and code availability,\
    \ may be sent\n   to info-kerberos@MIT.EDU.\n"
- title: Background
  contents:
  - "Background\n   The Kerberos model is based in part on Needham and Schroeder's\n\
    \   trusted third-party authentication protocol [3] and on modifications\n   suggested\
    \ by Denning and Sacco [4].  The original design and\n   implementation of Kerberos\
    \ Versions 1 through 4 was the work of two\n   former Project Athena staff members,\
    \ Steve Miller of Digital\n   Equipment Corporation and Clifford Neuman (now at\
    \ the Information\n   Sciences Institute of the University of Southern California),\
    \ along\n   with Jerome Saltzer, Technical Director of Project Athena, and\n \
    \  Jeffrey Schiller, MIT Campus Network Manager.  Many other members of\n   Project\
    \ Athena have also contributed to the work on Kerberos.\n   Version 4 is publicly\
    \ available, and has seen wide use across the\n   Internet.\n   Version 5 (described\
    \ in this document) has evolved from Version 4\n   based on new requirements and\
    \ desires for features not available in\n   Version 4.  Details on the differences\
    \ between Kerberos Versions 4\n   and 5 can be found in [5].\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction .......................................\
    \    5\n   1.1. Cross-Realm Operation ............................    7\n   1.2.\
    \ Environmental assumptions ........................    8\n   1.3. Glossary of\
    \ terms ................................    9\n   2. Ticket flag uses and requests\
    \ ......................   12\n   2.1. Initial and pre-authenticated tickets ............\
    \   12\n   2.2. Invalid tickets ..................................   12\n   2.3.\
    \ Renewable tickets ................................   12\n   2.4. Postdated tickets\
    \ ................................   13\n   2.5. Proxiable and proxy tickets ......................\
    \   14\n   2.6. Forwardable tickets ..............................   15\n   2.7.\
    \ Other KDC options ................................   15\n   3. Message Exchanges\
    \ ..................................   16\n   3.1. The Authentication Service\
    \ Exchange ..............   16\n   3.1.1. Generation of KRB_AS_REQ message ...............\
    \   17\n   3.1.2. Receipt of KRB_AS_REQ message ..................   17\n   3.1.3.\
    \ Generation of KRB_AS_REP message ...............   17\n   3.1.4. Generation\
    \ of KRB_ERROR message ................   19\n   3.1.5. Receipt of KRB_AS_REP\
    \ message ..................   19\n   3.1.6. Receipt of KRB_ERROR message ...................\
    \   20\n   3.2. The Client/Server Authentication Exchange ........   20\n   3.2.1.\
    \ The KRB_AP_REQ message .........................   20\n   3.2.2. Generation\
    \ of a KRB_AP_REQ message .............   20\n   3.2.3. Receipt of KRB_AP_REQ\
    \ message ..................   21\n   3.2.4. Generation of a KRB_AP_REP message\
    \ .............   23\n   3.2.5. Receipt of KRB_AP_REP message ..................\
    \   23\n   3.2.6. Using the encryption key .......................   24\n   3.3.\
    \ The Ticket-Granting Service (TGS) Exchange .......   24\n   3.3.1. Generation\
    \ of KRB_TGS_REQ message ..............   25\n   3.3.2. Receipt of KRB_TGS_REQ\
    \ message .................   26\n   3.3.3. Generation of KRB_TGS_REP message\
    \ ..............   27\n   3.3.3.1. Encoding the transited field .................\
    \   29\n   3.3.4. Receipt of KRB_TGS_REP message .................   31\n   3.4.\
    \ The KRB_SAFE Exchange ............................   31\n   3.4.1. Generation\
    \ of a KRB_SAFE message ...............   31\n   3.4.2. Receipt of KRB_SAFE message\
    \ ....................   32\n   3.5. The KRB_PRIV Exchange ............................\
    \   33\n   3.5.1. Generation of a KRB_PRIV message ...............   33\n   3.5.2.\
    \ Receipt of KRB_PRIV message ....................   33\n   3.6. The KRB_CRED\
    \ Exchange ............................   34\n   3.6.1. Generation of a KRB_CRED\
    \ message ...............   34\n   3.6.2. Receipt of KRB_CRED message ....................\
    \   34\n   4. The Kerberos Database ..............................   35\n   4.1.\
    \ Database contents ................................   35\n   4.2. Additional\
    \ fields ................................   36\n   4.3. Frequently Changing Fields\
    \ .......................   37\n   4.4. Site Constants ...................................\
    \   37\n   5. Message Specifications .............................   38\n   5.1.\
    \ ASN.1 Distinguished Encoding Representation ......   38\n   5.2. ASN.1 Base\
    \ Definitions ...........................   38\n   5.3. Tickets and Authenticators\
    \ .......................   42\n   5.3.1. Tickets ........................................\
    \   42\n   5.3.2. Authenticators .................................   47\n   5.4.\
    \ Specifications for the AS and TGS exchanges ......   49\n   5.4.1. KRB_KDC_REQ\
    \ definition .........................   49\n   5.4.2. KRB_KDC_REP definition\
    \ .........................   56\n   5.5. Client/Server (CS) message specifications\
    \ ........   58\n   5.5.1. KRB_AP_REQ definition ..........................  \
    \ 58\n   5.5.2. KRB_AP_REP definition ..........................   60\n   5.5.3.\
    \ Error message reply ............................   61\n   5.6. KRB_SAFE message\
    \ specification ...................   61\n   5.6.1. KRB_SAFE definition ............................\
    \   61\n   5.7. KRB_PRIV message specification ...................   62\n   5.7.1.\
    \ KRB_PRIV definition ............................   62\n   5.8. KRB_CRED message\
    \ specification ...................   63\n   5.8.1. KRB_CRED definition ............................\
    \   63\n   5.9. Error message specification ......................   65\n   5.9.1.\
    \ KRB_ERROR definition ...........................   66\n   6. Encryption and\
    \ Checksum Specifications .............   67\n   6.1. Encryption Specifications\
    \ ........................   68\n   6.2. Encryption Keys ..................................\
    \   71\n   6.3. Encryption Systems ...............................   71\n   6.3.1.\
    \ The NULL Encryption System (null) ..............   71\n   6.3.2. DES in CBC\
    \ mode with a CRC-32 checksum (descbc-crc)71\n   6.3.3. DES in CBC mode with an\
    \ MD4 checksum (descbc-md4)  72\n   6.3.4. DES in CBC mode with an MD5 checksum\
    \ (descbc-md5)  72\n   6.4. Checksums ........................................\
    \   74\n   6.4.1. The CRC-32 Checksum (crc32) ....................   74\n   6.4.2.\
    \ The RSA MD4 Checksum (rsa-md4) .................   75\n   6.4.3. RSA MD4 Cryptographic\
    \ Checksum Using DES\n   (rsa-md4-des) .........................................\
    \   75\n   6.4.4. The RSA MD5 Checksum (rsa-md5) .................   76\n   6.4.5.\
    \ RSA MD5 Cryptographic Checksum Using DES\n   (rsa-md5-des) .........................................\
    \   76\n   6.4.6. DES cipher-block chained checksum (des-mac)\n   6.4.7. RSA MD4\
    \ Cryptographic Checksum Using DES\n   alternative (rsa-md4-des-k) ...........................\
    \   77\n   6.4.8. DES cipher-block chained checksum alternative\n   (des-mac-k)\
    \ ...........................................   77\n   7. Naming Constraints .................................\
    \   78\n   7.1. Realm Names ......................................   77\n   7.2.\
    \ Principal Names ..................................   79\n   7.2.1. Name of server\
    \ principals ......................   80\n   8. Constants and other defined values\
    \ .................   80\n   8.1. Host address types ...............................\
    \   80\n   8.2. KDC messages .....................................   81\n   8.2.1.\
    \ IP transport ...................................   81\n   8.2.2. OSI transport\
    \ ..................................   82\n   8.2.3. Name of the TGS ................................\
    \   82\n   8.3. Protocol constants and associated values .........   82\n   9.\
    \ Interoperability requirements ......................   86\n   9.1. Specification\
    \ 1 ..................................   86\n   9.2. Recommended KDC values ...........................\
    \   88\n   10. Acknowledgments ...................................   88\n   11.\
    \ References ........................................   89\n   12. Security Considerations\
    \ ...........................   90\n   13. Authors' Addresses ................................\
    \   90\n   A. Pseudo-code for protocol processing ................   91\n   A.1.\
    \ KRB_AS_REQ generation ............................   91\n   A.2. KRB_AS_REQ\
    \ verification and KRB_AS_REP generation    92\n   A.3. KRB_AS_REP verification\
    \ ..........................   95\n   A.4. KRB_AS_REP and KRB_TGS_REP common checks\
    \ .........   96\n   A.5. KRB_TGS_REQ generation ........................... \
    \  97\n   A.6. KRB_TGS_REQ verification and KRB_TGS_REP generation  98\n   A.7.\
    \ KRB_TGS_REP verification .........................  104\n   A.8. Authenticator\
    \ generation .........................  104\n   A.9. KRB_AP_REQ generation ............................\
    \  105\n   A.10. KRB_AP_REQ verification .........................  105\n   A.11.\
    \ KRB_AP_REP generation ...........................  106\n   A.12. KRB_AP_REP\
    \ verification .........................  107\n   A.13. KRB_SAFE generation .............................\
    \  107\n   A.14. KRB_SAFE verification ...........................  108\n   A.15.\
    \ KRB_SAFE and KRB_PRIV common checks .............  108\n   A.16. KRB_PRIV generation\
    \ .............................  109\n   A.17. KRB_PRIV verification ...........................\
    \  110\n   A.18. KRB_CRED generation .............................  110\n   A.19.\
    \ KRB_CRED verification ...........................  111\n   A.20. KRB_ERROR generation\
    \ ............................  112\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   Kerberos provides a means of verifying the identities of\
    \ principals,\n   (e.g., a workstation user or a network server) on an open\n\
    \   (unprotected) network.  This is accomplished without relying on\n   authentication\
    \ by the host operating system, without basing trust on\n   host addresses, without\
    \ requiring physical security of all the hosts\n   on the network, and under the\
    \ assumption that packets traveling along\n   the network can be read, modified,\
    \ and inserted at will. (Note,\n   however, that many applications use Kerberos'\
    \ functions only upon the\n   initiation of a stream-based network connection,\
    \ and assume the\n   absence of any \"hijackers\" who might subvert such a connection.\
    \  Such\n   use implicitly trusts the host addresses involved.)  Kerberos\n  \
    \ performs authentication under these conditions as a trusted third-\n   party\
    \ authentication service by using conventional cryptography,\n   i.e., shared\
    \ secret key.  (shared secret key - Secret and private are\n   often used interchangeably\
    \ in the literature.  In our usage, it takes\n   two (or more) to share a secret,\
    \ thus a shared DES key is a secret\n   key.  Something is only private when no\
    \ one but its owner knows it.\n   Thus, in public key cryptosystems, one has a\
    \ public and a private\n   key.)\n   The authentication process proceeds as follows:\
    \ A client sends a\n   request to the authentication server (AS) requesting \"\
    credentials\"\n   for a given server.  The AS responds with these credentials,\n\
    \   encrypted in the client's key.  The credentials consist of 1) a\n   \"ticket\"\
    \ for the server and 2) a temporary encryption key (often\n   called a \"session\
    \ key\").  The client transmits the ticket (which\n   contains the client's identity\
    \ and a copy of the session key, all\n   encrypted in the server's key) to the\
    \ server.  The session key (now\n   shared by the client and server) is used to\
    \ authenticate the client,\n   and may optionally be used to authenticate the\
    \ server.  It may also\n   be used to encrypt further communication between the\
    \ two parties or\n   to exchange a separate sub-session key to be used to encrypt\
    \ further\n   communication.\n   The implementation consists of one or more authentication\
    \ servers\n   running on physically secure hosts.  The authentication servers\n\
    \   maintain a database of principals (i.e., users and servers) and their\n  \
    \ secret keys. Code libraries provide encryption and implement the\n   Kerberos\
    \ protocol.  In order to add authentication to its\n   transactions, a typical\
    \ network application adds one or two calls to\n   the Kerberos library, which\
    \ results in the transmission of the\n   necessary messages to achieve authentication.\n\
    \   The Kerberos protocol consists of several sub-protocols (or\n   exchanges).\
    \  There are two methods by which a client can ask a\n   Kerberos server for credentials.\
    \  In the first approach, the client\n   sends a cleartext request for a ticket\
    \ for the desired server to the\n   AS. The reply is sent encrypted in the client's\
    \ secret key. Usually\n   this request is for a ticket-granting ticket (TGT) which\
    \ can later be\n   used with the ticket-granting server (TGS).  In the second\
    \ method,\n   the client sends a request to the TGS.  The client sends the TGT\
    \ to\n   the TGS in the same manner as if it were contacting any other\n   application\
    \ server which requires Kerberos credentials.  The reply is\n   encrypted in the\
    \ session key from the TGT.\n   Once obtained, credentials may be used to verify\
    \ the identity of the\n   principals in a transaction, to ensure the integrity\
    \ of messages\n   exchanged between them, or to preserve privacy of the messages.\
    \  The\n   application is free to choose whatever protection may be necessary.\n\
    \   To verify the identities of the principals in a transaction, the\n   client\
    \ transmits the ticket to the server.  Since the ticket is sent\n   \"in the clear\"\
    \ (parts of it are encrypted, but this encryption\n   doesn't thwart replay) and\
    \ might be intercepted and reused by an\n   attacker, additional information is\
    \ sent to prove that the message\n   was originated by the principal to whom the\
    \ ticket was issued.  This\n   information (called the authenticator) is encrypted\
    \ in the session\n   key, and includes a timestamp.  The timestamp proves that\
    \ the message\n   was recently generated and is not a replay.  Encrypting the\n\
    \   authenticator in the session key proves that it was generated by a\n   party\
    \ possessing the session key.  Since no one except the requesting\n   principal\
    \ and the server know the session key (it is never sent over\n   the network in\
    \ the clear) this guarantees the identity of the client.\n   The integrity of\
    \ the messages exchanged between principals can also\n   be guaranteed using the\
    \ session key (passed in the ticket and\n   contained in the credentials).  This\
    \ approach provides detection of\n   both replay attacks and message stream modification\
    \ attacks.  It is\n   accomplished by generating and transmitting a collision-proof\n\
    \   checksum (elsewhere called a hash or digest function) of the client's\n  \
    \ message, keyed with the session key.  Privacy and integrity of the\n   messages\
    \ exchanged between principals can be secured by encrypting\n   the data to be\
    \ passed using the session key passed in the ticket, and\n   contained in the\
    \ credentials.\n   The authentication exchanges mentioned above require read-only\
    \ access\n   to the Kerberos database.  Sometimes, however, the entries in the\n\
    \   database must be modified, such as when adding new principals or\n   changing\
    \ a principal's key.  This is done using a protocol between a\n   client and a\
    \ third Kerberos server, the Kerberos Administration\n   Server (KADM).  The administration\
    \ protocol is not described in this\n   document. There is also a protocol for\
    \ maintaining multiple copies of\n   the Kerberos database, but this can be considered\
    \ an implementation\n   detail and may vary to support different database technologies.\n"
- title: 1.1.  Cross-Realm Operation
  contents:
  - "1.1.  Cross-Realm Operation\n   The Kerberos protocol is designed to operate\
    \ across organizational\n   boundaries.  A client in one organization can be authenticated\
    \ to a\n   server in another.  Each organization wishing to run a Kerberos\n \
    \  server establishes its own \"realm\".  The name of the realm in which a\n \
    \  client is registered is part of the client's name, and can be used by\n   the\
    \ end-service to decide whether to honor a request.\n   By establishing \"inter-realm\"\
    \ keys, the administrators of two realms\n   can allow a client authenticated\
    \ in the local realm to use its\n   authentication remotely (Of course, with appropriate\
    \ permission the\n   client could arrange registration of a separately-named principal\
    \ in\n   a remote realm, and engage in normal exchanges with that realm's\n  \
    \ services. However, for even small numbers of clients this becomes\n   cumbersome,\
    \ and more automatic methods as described here are\n   necessary).  The exchange\
    \ of inter-realm keys (a separate key may be\n   used for each direction) registers\
    \ the ticket-granting service of\n   each realm as a principal in the other realm.\
    \  A client is then able\n   to obtain a ticket-granting ticket for the remote\
    \ realm's ticket-\n   granting service from its local realm. When that ticket-granting\n\
    \   ticket is used, the remote ticket-granting service uses the inter-\n   realm\
    \ key (which usually differs from its own normal TGS key) to\n   decrypt the ticket-granting\
    \ ticket, and is thus certain that it was\n   issued by the client's own TGS.\
    \ Tickets issued by the remote ticket-\n   granting service will indicate to the\
    \ end-service that the client was\n   authenticated from another realm.\n   A\
    \ realm is said to communicate with another realm if the two realms\n   share\
    \ an inter-realm key, or if the local realm shares an inter-realm\n   key with\
    \ an intermediate realm that communicates with the remote\n   realm.  An authentication\
    \ path is the sequence of intermediate realms\n   that are transited in communicating\
    \ from one realm to another.\n   Realms are typically organized hierarchically.\
    \ Each realm shares a\n   key with its parent and a different key with each child.\
    \  If an\n   inter-realm key is not directly shared by two realms, the\n   hierarchical\
    \ organization allows an authentication path to be easily\n   constructed.  If\
    \ a hierarchical organization is not used, it may be\n   necessary to consult\
    \ some database in order to construct an\n   authentication path between realms.\n\
    \   Although realms are typically hierarchical, intermediate realms may\n   be\
    \ bypassed to achieve cross-realm authentication through alternate\n   authentication\
    \ paths (these might be established to make\n   communication between two realms\
    \ more efficient).  It is important\n   for the end-service to know which realms\
    \ were transited when deciding\n   how much faith to place in the authentication\
    \ process. To facilitate\n   this decision, a field in each ticket contains the\
    \ names of the\n   realms that were involved in authenticating the client.\n"
- title: 1.2.  Environmental assumptions
  contents:
  - "1.2.  Environmental assumptions\n   Kerberos imposes a few assumptions on the\
    \ environment in which it can\n   properly function:\n   +    \"Denial of service\"\
    \ attacks are not solved with Kerberos.  There\n        are places in these protocols\
    \ where an intruder intruder can\n        prevent an application from participating\
    \ in the proper\n        authentication steps.  Detection and solution of such\
    \ attacks\n        (some of which can appear to be not-uncommon \"normal\" failure\n\
    \        modes for the system) is usually best left to the human\n        administrators\
    \ and users.\n   +    Principals must keep their secret keys secret.  If an intruder\n\
    \        somehow steals a principal's key, it will be able to masquerade\n   \
    \     as that principal or impersonate any server to the legitimate\n        principal.\n\
    \   +    \"Password guessing\" attacks are not solved by Kerberos.  If a\n   \
    \     user chooses a poor password, it is possible for an attacker to\n      \
    \  successfully mount an offline dictionary attack by repeatedly\n        attempting\
    \ to decrypt, with successive entries from a\n        dictionary, messages obtained\
    \ which are encrypted under a key\n        derived from the user's password.\n\
    \   +    Each host on the network must have a clock which is \"loosely\n     \
    \   synchronized\" to the time of the other hosts; this\n        synchronization\
    \ is used to reduce the bookkeeping needs of\n        application servers when\
    \ they do replay detection.  The degree\n        of \"looseness\" can be configured\
    \ on a per-server basis.  If the\n        clocks are synchronized over the network,\
    \ the clock\n        synchronization protocol must itself be secured from network\n\
    \        attackers.\n   +    Principal identifiers are not recycled on a short-term\
    \ basis.  A\n        typical mode of access control will use access control lists\n\
    \        (ACLs) to grant permissions to particular principals.  If a\n       \
    \ stale ACL entry remains for a deleted principal and the\n        principal identifier\
    \ is reused, the new principal will inherit\n        rights specified in the stale\
    \ ACL entry. By not re-using\n        principal identifiers, the danger of inadvertent\
    \ access is\n        removed.\n"
- title: 1.3.  Glossary of terms
  contents:
  - "1.3.  Glossary of terms\n   Below is a list of terms used throughout this document.\n\
    \   Authentication      Verifying the claimed identity of a\n                \
    \       principal.\n   Authentication header A record containing a Ticket and\
    \ an\n                         Authenticator to be presented to a\n          \
    \               server as part of the authentication\n                       \
    \  process.\n   Authentication path  A sequence of intermediate realms transited\n\
    \                        in the authentication process when\n                \
    \        communicating from one realm to another.\n   Authenticator       A record\
    \ containing information that can\n                       be shown to have been\
    \ recently generated\n                       using the session key known only\
    \ by  the\n                       client and server.\n   Authorization       The\
    \ process of determining whether a\n                       client may use a service,\
    \ which objects\n                       the client is allowed to access, and the\n\
    \                       type of access allowed for each.\n   Capability      \
    \    A token that grants the bearer permission\n                       to access\
    \ an object or service.  In\n                       Kerberos, this might be a\
    \ ticket whose\n                       use is restricted by the contents of the\n\
    \                       authorization data field, but which\n                \
    \       lists no network addresses, together\n                       with the\
    \ session key necessary to use\n                       the ticket.\n   Ciphertext\
    \          The output of an encryption function.\n                       Encryption\
    \ transforms plaintext into\n                       ciphertext.\n   Client   \
    \           A process that makes use of a network\n                       service\
    \ on behalf of a user.  Note that\n                       in some cases a Server\
    \ may itself be a\n                       client of some other server (e.g., a\n\
    \                       print server may be a client of a file\n             \
    \          server).\n   Credentials         A ticket plus the secret session key\n\
    \                       necessary to successfully use that\n                 \
    \      ticket in an authentication exchange.\n   KDC                 Key Distribution\
    \ Center, a network service\n                       that supplies tickets and\
    \ temporary\n                       session keys; or an instance of that\n   \
    \                    service or the host on which it runs.\n                 \
    \      The KDC services both initial ticket and\n                       ticket-granting\
    \ ticket requests.  The\n                       initial ticket portion is sometimes\n\
    \                       referred to as the Authentication Server\n           \
    \            (or service).  The ticket-granting\n                       ticket\
    \ portion is sometimes referred to\n                       as the ticket-granting\
    \ server (or service).\n   Kerberos            Aside from the 3-headed dog guarding\n\
    \                       Hades, the name given to Project\n                   \
    \    Athena's authentication service, the\n                       protocol used\
    \ by that service, or the\n                       code used to implement the authentication\n\
    \                       service.\n   Plaintext           The input to an encryption\
    \ function  or\n                       the output of a decryption function.\n\
    \                       Decryption transforms ciphertext into\n              \
    \         plaintext.\n   Principal           A uniquely named client or server\n\
    \                       instance that participates in a network\n            \
    \           communication.\n   Principal identifier The name used to uniquely\
    \ identify each\n                        different principal.\n   Seal       \
    \         To encipher a record containing several\n                       fields\
    \ in such a way that the fields\n                       cannot be individually\
    \ replaced without\n                       either knowledge of the encryption\
    \ key\n                       or leaving evidence of tampering.\n   Secret key\
    \          An encryption key shared by a principal\n                       and\
    \ the KDC, distributed outside the\n                       bounds of the system,\
    \ with a long lifetime.\n                       In the case of a human user's\n\
    \                       principal, the secret key is derived\n               \
    \        from a password.\n   Server              A particular Principal which\
    \ provides a\n                       resource to network clients.\n   Service\
    \             A resource provided to network clients;\n                      \
    \ often provided by more than one server\n                       (for example,\
    \ remote file service).\n   Session key         A temporary encryption key used\
    \ between\n                       two principals, with a lifetime limited\n  \
    \                     to the duration of a single login \"session\".\n   Sub-session\
    \ key     A temporary encryption key used between\n                       two\
    \ principals, selected and exchanged\n                       by the principals\
    \ using the session key,\n                       and with a lifetime limited to\
    \ the duration\n                       of a single association.\n   Ticket   \
    \           A record that helps a client authenticate\n                      \
    \ itself to a server; it contains the\n                       client's identity,\
    \ a session key, a\n                       timestamp, and other information, all\n\
    \                       sealed using the server's secret key.\n              \
    \         It only serves to authenticate a client\n                       when\
    \ presented along with a fresh\n                       Authenticator.\n"
- title: 2.  Ticket flag uses and requests
  contents:
  - "2.  Ticket flag uses and requests\n   Each Kerberos ticket contains a set of\
    \ flags which are used to\n   indicate various attributes of that ticket.  Most\
    \ flags may be\n   requested by a client when the ticket is obtained; some are\n\
    \   automatically turned on and off by a Kerberos server as required.\n   The\
    \ following sections explain what the various flags mean, and gives\n   examples\
    \ of reasons to use such a flag.\n"
- title: 2.1.  Initial and pre-authenticated tickets
  contents:
  - "2.1.  Initial and pre-authenticated tickets\n   The INITIAL flag indicates that\
    \ a ticket was issued using the AS\n   protocol and not issued based on a ticket-granting\
    \ ticket.\n   Application servers that want to require the knowledge of a client's\n\
    \   secret key (e.g., a passwordchanging program) can insist that this\n   flag\
    \ be set in any tickets they accept, and thus be assured that the\n   client's\
    \ key was recently presented to the application client.\n   The PRE-AUTHENT and\
    \ HW-AUTHENT flags provide addition information\n   about the initial authentication,\
    \ regardless of whether the current\n   ticket was issued directly (in which case\
    \ INITIAL will also be set)\n   or issued on the basis of a ticket-granting ticket\
    \ (in which case the\n   INITIAL flag is clear, but the PRE-AUTHENT and HW-AUTHENT\
    \ flags are\n   carried forward from the ticket-granting ticket).\n"
- title: 2.2.  Invalid tickets
  contents:
  - "2.2.  Invalid tickets\n   The INVALID flag indicates that a ticket is invalid.\
    \  Application\n   servers must reject tickets which have this flag set.  A postdated\n\
    \   ticket will usually be issued in this form. Invalid tickets must be\n   validated\
    \ by the KDC before use, by presenting them to the KDC in a\n   TGS request with\
    \ the VALIDATE option specified.  The KDC will only\n   validate tickets after\
    \ their starttime has passed.  The validation is\n   required so that postdated\
    \ tickets which have been stolen before\n   their starttime can be rendered permanently\
    \ invalid (through a hot-\n   list mechanism).\n"
- title: 2.3.  Renewable tickets
  contents:
  - "2.3.  Renewable tickets\n   Applications may desire to hold tickets which can\
    \ be valid for long\n   periods of time.  However, this can expose their credentials\
    \ to\n   potential theft for equally long periods, and those stolen\n   credentials\
    \ would be valid until the expiration time of the\n   ticket(s).  Simply using\
    \ shortlived tickets and obtaining new ones\n   periodically would require the\
    \ client to have long-term access to its\n   secret key, an even greater risk.\
    \  Renewable tickets can be used to\n   mitigate the consequences of theft.  Renewable\
    \ tickets have two\n   \"expiration times\": the first is when the current instance\
    \ of the\n   ticket expires, and the second is the latest permissible value for\
    \ an\n   individual expiration time.  An application client must periodically\n\
    \   (i.e., before it expires) present a renewable ticket to the KDC, with\n  \
    \ the RENEW option set in the KDC request.  The KDC will issue a new\n   ticket\
    \ with a new session key and a later expiration time.  All other\n   fields of\
    \ the ticket are left unmodified by the renewal process.\n   When the latest permissible\
    \ expiration time arrives, the ticket\n   expires permanently.  At each renewal,\
    \ the KDC may consult a hot-list\n   to determine if the ticket had been reported\
    \ stolen since its last\n   renewal; it will refuse to renew such stolen tickets,\
    \ and thus the\n   usable lifetime of stolen tickets is reduced.\n   The RENEWABLE\
    \ flag in a ticket is normally only interpreted by the\n   ticket-granting service\
    \ (discussed below in section 3.3).  It can\n   usually be ignored by application\
    \ servers.  However, some\n   particularly careful application servers may wish\
    \ to disallow\n   renewable tickets.\n   If a renewable ticket is not renewed\
    \ by its  expiration time, the KDC\n   will not renew the ticket.  The RENEWABLE\
    \ flag is reset by default,\n   but a client may request it be  set  by setting\
    \  the RENEWABLE option\n   in the KRB_AS_REQ message.  If it is set, then the\
    \ renew-till field\n   in the ticket  contains the time after which the ticket\
    \ may not be\n   renewed.\n"
- title: 2.4.  Postdated tickets
  contents:
  - "2.4.  Postdated tickets\n   Applications may occasionally need to obtain tickets\
    \ for use much\n   later, e.g., a batch submission system would need tickets to\
    \ be valid\n   at the time the batch job is serviced.  However, it is dangerous\
    \ to\n   hold valid tickets in a batch queue, since they will be on-line\n   longer\
    \ and more prone to theft.  Postdated tickets provide a way to\n   obtain these\
    \ tickets from the KDC at job submission time, but to\n   leave them \"dormant\"\
    \ until they are activated and validated by a\n   further request of the KDC.\
    \  If a ticket theft were reported in the\n   interim, the KDC would refuse to\
    \ validate the ticket, and the thief\n   would be foiled.\n   The MAY-POSTDATE\
    \ flag in a ticket is normally only interpreted by the\n   ticket-granting service.\
    \  It can be ignored by application servers.\n   This flag must be set in a ticket-granting\
    \ ticket in order to issue a\n   postdated ticket based on the presented ticket.\
    \ It is reset by\n   default; it may be requested by a client by setting the ALLOW-\n\
    \   POSTDATE option in the KRB_AS_REQ message.  This flag does not allow\n   a\
    \ client to obtain a postdated ticket-granting ticket; postdated\n   ticket-granting\
    \ tickets can only by obtained by requesting the\n   postdating in the KRB_AS_REQ\
    \ message.  The life (endtime-starttime)\n   of a postdated ticket will be the\
    \ remaining life of the ticket-\n   granting ticket at the time of the request,\
    \ unless the RENEWABLE\n   option is also set, in which case it can be the full\
    \ life (endtime-\n   starttime) of the ticket-granting ticket.  The KDC may limit\
    \ how far\n   in the future a ticket may be postdated.\n   The POSTDATED flag\
    \ indicates that a ticket has been postdated.  The\n   application server can\
    \ check the authtime field in the ticket to see\n   when the original authentication\
    \ occurred.  Some services may choose\n   to reject postdated tickets, or they\
    \ may only accept them within a\n   certain period after the original authentication.\
    \ When the KDC issues\n   a POSTDATED ticket, it will also be marked as INVALID,\
    \ so that the\n   application client must present the ticket to the KDC to be\
    \ validated\n   before use.\n"
- title: 2.5.  Proxiable and proxy tickets
  contents:
  - "2.5.  Proxiable and proxy tickets\n   At times it may be necessary for a principal\
    \ to allow a service  to\n   perform an operation on its behalf.  The service\
    \ must be able to take\n   on the identity of the client, but only for  a particular\
    \ purpose.  A\n   principal can allow a service to take on the principal's identity\
    \ for\n   a particular purpose by granting it a proxy.\n   The PROXIABLE flag\
    \ in a ticket is normally only interpreted by the\n   ticket-granting service.\
    \ It can be ignored by application servers.\n   When set, this flag tells the\
    \ ticket-granting server that it is OK to\n   issue a new ticket (but not a ticket-granting\
    \ ticket) with a\n   different network address based on this ticket.  This flag\
    \ is set by\n   default.\n   This flag allows a client to pass a proxy to a server\
    \ to perform a\n   remote request on its behalf, e.g., a print service client\
    \ can give\n   the print server a proxy to access the client's files on a particular\n\
    \   file server in order to satisfy a print request.\n   In order to complicate\
    \ the use of stolen credentials, Kerberos\n   tickets are usually valid from only\
    \ those network addresses\n   specifically included in the ticket (It is permissible\
    \ to request or\n   issue tickets with no network addresses specified, but we\
    \ do not\n   recommend it).  For this reason, a client wishing to grant a proxy\n\
    \   must request a new ticket valid for the network address of the\n   service\
    \ to be granted the proxy.\n   The PROXY flag is set in a ticket by the  TGS \
    \ when  it issues a\n   proxy ticket.  Application servers may check this flag\
    \ and require\n   additional authentication  from  the  agent presenting the proxy\
    \ in\n   order to provide an audit trail.\n"
- title: 2.6.  Forwardable tickets
  contents:
  - "2.6.  Forwardable tickets\n   Authentication forwarding is an instance of the\
    \ proxy case where the\n   service is granted complete use of the client's identity.\
    \  An example\n   where it might be used is when a user logs in to a remote system\
    \ and\n   wants authentication to work from that system as if the login were\n\
    \   local.\n   The FORWARDABLE flag in a ticket is normally only interpreted by\
    \ the\n   ticket-granting service.  It can be ignored by application servers.\n\
    \   The FORWARDABLE flag has an interpretation similar to that of the\n   PROXIABLE\
    \ flag, except ticket-granting tickets may also be issued\n   with different network\
    \ addresses.  This flag is reset by default, but\n   users may request that it\
    \ be set by setting the FORWARDABLE option in\n   the AS request when they request\
    \ their initial ticket-granting\n   ticket.\n   This flag allows for authentication\
    \ forwarding without requiring the\n   user to enter a password again.  If the\
    \ flag is not set, then\n   authentication forwarding is not permitted, but the\
    \ same end result\n   can still be achieved if the user engages in the AS exchange\
    \ with the\n   requested network addresses and supplies a password.\n   The FORWARDED\
    \ flag is set by the TGS when a client presents a ticket\n   with the FORWARDABLE\
    \ flag set and requests it be set by specifying\n   the FORWARDED KDC option and\
    \ supplying a set of addresses for the new\n   ticket.  It is also set in all\
    \ tickets issued based on tickets with\n   the FORWARDED flag set.  Application\
    \ servers may wish to process\n   FORWARDED tickets differently than non-FORWARDED\
    \ tickets.\n"
- title: 2.7.  Other KDC options
  contents:
  - "2.7.  Other KDC options\n   There are two additional options which may be set\
    \ in a client's\n   request of the KDC.  The RENEWABLE-OK option indicates that\
    \ the\n   client will accept a renewable ticket if a ticket with the requested\n\
    \   life cannot otherwise be provided.  If a ticket with the requested\n   life\
    \ cannot be provided, then the KDC may issue a renewable ticket\n   with a renew-till\
    \ equal to the the requested endtime.  The value of\n   the renew-till field may\
    \ still be adjusted by site-determined limits\n   or limits imposed by the individual\
    \ principal or server.\n   The ENC-TKT-IN-SKEY option is honored only by the ticket-granting\n\
    \   service.  It indicates that the to-be-issued ticket for the end\n   server\
    \ is to be encrypted in the session key from the additional\n   ticket-granting\
    \ ticket provided with the request.  See section 3.3.3\n   for specific details.\n"
- title: 3.  Message Exchanges
  contents:
  - "3.  Message Exchanges\n   The following sections describe the interactions between\
    \ network\n   clients and servers and the messages involved in those exchanges.\n"
- title: 3.1.  The Authentication Service Exchange
  contents:
  - "3.1.  The Authentication Service Exchange\n                             Summary\n\
    \         Message direction       Message type    Section\n         1. Client\
    \ to Kerberos   KRB_AS_REQ      5.4.1\n         2. Kerberos to client   KRB_AS_REP\
    \ or   5.4.2\n                                 KRB_ERROR       5.9.1\n   The Authentication\
    \ Service (AS) Exchange between the client and the\n   Kerberos Authentication\
    \ Server is usually initiated by a client when\n   it wishes to obtain authentication\
    \ credentials for a given server but\n   currently holds no credentials.  The\
    \ client's secret key is used for\n   encryption and decryption.  This exchange\
    \ is typically used at the\n   initiation of a login session, to obtain credentials\
    \ for a Ticket-\n   Granting Server, which will subsequently be used to obtain\n\
    \   credentials for other servers (see section 3.3) without requiring\n   further\
    \ use of the client's secret key.  This exchange is also used\n   to request credentials\
    \ for services which must not be mediated\n   through the Ticket-Granting Service,\
    \ but rather require a principal's\n   secret key, such as the password-changing\
    \ service.  (The password-\n   changing request must not be honored unless the\
    \ requester can provide\n   the old password (the user's current secret key).\
    \  Otherwise, it\n   would be possible for someone to walk up to an unattended\
    \ session and\n   change another user's password.)  This exchange does not by\
    \ itself\n   provide any assurance of the the identity of the user.  (To\n   authenticate\
    \ a user logging on to a local system, the credentials\n   obtained in the AS\
    \ exchange may first be used in a TGS exchange to\n   obtain credentials for a\
    \ local server.  Those credentials must then\n   be verified by the local server\
    \ through successful completion of the\n   Client/Server exchange.)\n   The exchange\
    \ consists of two messages: KRB_AS_REQ from the client to\n   Kerberos, and KRB_AS_REP\
    \ or KRB_ERROR in reply. The formats for these\n   messages are described in sections\
    \ 5.4.1, 5.4.2, and 5.9.1.\n   In the request, the client sends (in cleartext)\
    \ its own identity and\n   the identity of the server for which it is requesting\
    \ credentials.\n   The response, KRB_AS_REP, contains a ticket for the client\
    \ to present\n   to the server, and a session key that will be shared by the client\n\
    \   and the server.  The session key and additional information are\n   encrypted\
    \ in the client's secret key.  The KRB_AS_REP message\n   contains information\
    \ which can be used to detect replays, and to\n   associate it with the message\
    \ to which it replies.  Various errors\n   can occur; these are indicated by an\
    \ error response (KRB_ERROR)\n   instead of the KRB_AS_REP response.  The error\
    \ message is not\n   encrypted.  The KRB_ERROR message also contains information\
    \ which can\n   be used to associate it with the message to which it replies.\
    \  The\n   lack of encryption in the KRB_ERROR message precludes the ability to\n\
    \   detect replays or fabrications of such messages.\n   In the normal case the\
    \ authentication server does not know whether\n   the client is actually the principal\
    \ named in the request.  It simply\n   sends a reply without knowing or caring\
    \ whether they are the same.\n   This is acceptable because nobody but the principal\
    \ whose identity\n   was given in the request will be able to use the reply. Its\
    \ critical\n   information is encrypted in that principal's key.  The initial\n\
    \   request supports an optional field that can be used to pass\n   additional\
    \ information that might be needed for the initial exchange.\n   This field may\
    \ be used for preauthentication if desired, but the\n   mechanism is not currently\
    \ specified.\n"
- title: 3.1.1. Generation of KRB_AS_REQ message
  contents:
  - "3.1.1. Generation of KRB_AS_REQ message\n   The client may specify a number of\
    \ options in the initial request.\n   Among these options are whether preauthentication\
    \ is to be performed;\n   whether the requested ticket is to be renewable, proxiable,\
    \ or\n   forwardable; whether it should be postdated or allow postdating of\n\
    \   derivative tickets; and whether a renewable ticket will be accepted\n   in\
    \ lieu of a non-renewable ticket if the requested ticket expiration\n   date cannot\
    \ be satisfied by a nonrenewable ticket (due to\n   configuration constraints;\
    \ see section 4).  See section A.1 for\n   pseudocode.\n   The client prepares\
    \ the KRB_AS_REQ message and sends it to the KDC.\n"
- title: 3.1.2. Receipt of KRB_AS_REQ message
  contents:
  - "3.1.2. Receipt of KRB_AS_REQ message\n   If all goes well, processing the KRB_AS_REQ\
    \ message will result in\n   the creation of a ticket for the client to present\
    \ to the server.\n   The format for the ticket is described in section 5.3.1.\
    \  The\n   contents of the ticket are determined as follows.\n"
- title: 3.1.3. Generation of KRB_AS_REP message
  contents:
  - "3.1.3. Generation of KRB_AS_REP message\n   The authentication server looks up\
    \ the client and server principals\n   named in the KRB_AS_REQ in its database,\
    \ extracting their respective\n   keys.  If required, the server pre-authenticates\
    \ the request, and if\n   the pre-authentication check fails, an error message\
    \ with the code\n   KDC_ERR_PREAUTH_FAILED is returned. If the server cannot accommodate\n\
    \   the requested encryption type, an error message with code\n   KDC_ERR_ETYPE_NOSUPP\
    \ is returned. Otherwise it generates a \"random\"\n   session key (\"Random\"\
    \ means that, among other things, it should be\n   impossible to guess the next\
    \ session key based on knowledge of past\n   session keys.  This can only be achieved\
    \ in a pseudo-random number\n   generator if it is based on cryptographic principles.\
    \  It would be\n   more desirable to use a truly random number generator, such\
    \ as one\n   based on measurements of random physical phenomena.).\n   If the\
    \ requested start time is absent or indicates a time in the\n   past, then the\
    \ start time of the ticket is set to the authentication\n   server's current time.\
    \ If it indicates a time in the future, but the\n   POSTDATED option has not been\
    \ specified, then the error\n   KDC_ERR_CANNOT_POSTDATE is returned.  Otherwise\
    \ the requested start\n   time is checked against the policy of the local realm\
    \ (the\n   administrator might decide to prohibit certain types or ranges of\n\
    \   postdated tickets), and if acceptable, the ticket's start time is set\n  \
    \ as requested and the INVALID flag is set in the new ticket. The\n   postdated\
    \ ticket must be validated before use by presenting it to the\n   KDC after the\
    \ start time has been reached.\n   The expiration time of the ticket will be set\
    \ to the minimum of the\n   following:\n   +The expiration time (endtime) requested\
    \ in the KRB_AS_REQ\n    message.\n   +The ticket's start time plus the maximum\
    \ allowable lifetime\n    associated with the client principal (the authentication\n\
    \    server's database includes a maximum ticket lifetime field\n    in each principal's\
    \ record; see section 4).\n   +The ticket's start time plus the maximum allowable\
    \ lifetime\n    associated with the server principal.\n   +The ticket's start\
    \ time plus the maximum lifetime set by\n    the policy of the local realm.\n\
    \   If the requested expiration time minus the start time (as determined\n   above)\
    \ is less than a site-determined minimum lifetime, an error\n   message with code\
    \ KDC_ERR_NEVER_VALID is returned.  If the requested\n   expiration time for the\
    \ ticket exceeds what was determined as above,\n   and if the \"RENEWABLE-OK\"\
    \ option was requested, then the \"RENEWABLE\"\n   flag is set in the new ticket,\
    \ and the renew-till value is set as if\n   the \"RENEWABLE\" option were requested\
    \ (the field and option names are\n   described fully in section 5.4.1).  If the\
    \ RENEWABLE option has been\n   requested or if the RENEWABLE-OK option has been\
    \ set and a renewable\n   ticket is to be issued, then the renew-till field is\
    \ set to the\n   minimum of:\n   +Its requested value.\n   +The start time of\
    \ the ticket plus the minimum of the two\n    maximum renewable lifetimes associated\
    \ with the principals'\n    database entries.\n   +The start time of the ticket\
    \ plus the maximum renewable\n    lifetime set by the policy of the local realm.\n\
    \   The flags field of the new ticket will have the following options set\n  \
    \ if they have been requested and if the policy of the local realm\n   allows:\
    \ FORWARDABLE, MAY-POSTDATE, POSTDATED, PROXIABLE, RENEWABLE.\n   If the new ticket\
    \ is postdated (the start time is in the future), its\n   INVALID flag will also\
    \ be set.\n   If all of the above succeed, the server formats a KRB_AS_REP message\n\
    \   (see section 5.4.2), copying the addresses in the request into the\n   caddr\
    \ of the response, placing any required pre-authentication data\n   into the padata\
    \ of the response, and encrypts the ciphertext part in\n   the client's key using\
    \ the requested encryption method, and sends it\n   to the client.  See section\
    \ A.2 for pseudocode.\n"
- title: 3.1.4. Generation of KRB_ERROR message
  contents:
  - "3.1.4. Generation of KRB_ERROR message\n   Several errors can occur, and the\
    \ Authentication Server responds by\n   returning an error message, KRB_ERROR,\
    \ to the client, with the\n   error-code and e-text fields set to appropriate\
    \ values.  The error\n   message contents and details are described in Section\
    \ 5.9.1.\n"
- title: 3.1.5. Receipt of KRB_AS_REP message
  contents:
  - "3.1.5. Receipt of KRB_AS_REP message\n   If the reply message type is KRB_AS_REP,\
    \ then the client verifies\n   that the cname and crealm fields in the cleartext\
    \ portion of the\n   reply match what it requested.  If any padata fields are\
    \ present,\n   they may be used to derive the proper secret key to decrypt the\n\
    \   message.  The client decrypts the encrypted part of the response\n   using\
    \ its secret key, verifies that the nonce in the encrypted part\n   matches the\
    \ nonce it supplied in its request (to detect replays).  It\n   also verifies\
    \ that the sname and srealm in the response match those\n   in the request, and\
    \ that the host address field is also correct.  It\n   then stores the ticket,\
    \ session key, start and expiration times, and\n   other information for later\
    \ use.  The key-expiration field from the\n   encrypted part of the response may\
    \ be checked to notify the user of\n   impending key expiration (the client program\
    \ could then suggest\n   remedial action, such as a password change).  See section\
    \ A.3 for\n   pseudocode.\n   Proper decryption of the KRB_AS_REP message is not\
    \ sufficient to\n   verify the identity of the user; the user and an attacker\
    \ could\n   cooperate to generate a KRB_AS_REP format message which decrypts\n\
    \   properly but is not from the proper KDC.  If the host wishes to\n   verify\
    \ the identity of the user, it must require the user to present\n   application\
    \ credentials which can be verified using a securely-stored\n   secret key.  If\
    \ those credentials can be verified, then the identity\n   of the user can be\
    \ assured.\n"
- title: 3.1.6. Receipt of KRB_ERROR message
  contents:
  - "3.1.6. Receipt of KRB_ERROR message\n   If the reply message type is KRB_ERROR,\
    \ then the client interprets it\n   as an error and performs whatever application-specific\
    \ tasks are\n   necessary to recover.\n"
- title: 3.2.  The Client/Server Authentication Exchange
  contents:
  - "3.2.  The Client/Server Authentication Exchange\n                        Summary\n\
    \   Message direction                         Message type    Section\n   Client\
    \ to Application server              KRB_AP_REQ      5.5.1\n   [optional] Application\
    \ server to client   KRB_AP_REP or   5.5.2\n                                 \
    \            KRB_ERROR       5.9.1\n   The client/server authentication (CS) exchange\
    \ is used by network\n   applications to authenticate the client to the server\
    \ and vice versa.\n   The client must have already acquired credentials for the\
    \ server\n   using the AS or TGS exchange.\n"
- title: 3.2.1. The KRB_AP_REQ message
  contents:
  - "3.2.1. The KRB_AP_REQ message\n   The KRB_AP_REQ contains authentication information\
    \ which should be\n   part of the first message in an authenticated transaction.\
    \  It\n   contains a ticket, an authenticator, and some additional bookkeeping\n\
    \   information (see section 5.5.1 for the exact format).  The ticket by\n   itself\
    \ is insufficient to authenticate a client, since tickets are\n   passed across\
    \ the network in cleartext(Tickets contain both an\n   encrypted and unencrypted\
    \ portion, so cleartext here refers to the\n   entire unit, which can be copied\
    \ from one message and replayed in\n   another without any cryptographic skill.),\
    \ so the authenticator is\n   used to prevent invalid replay of tickets by proving\
    \ to the server\n   that the client knows the session key of the ticket and thus\
    \ is\n   entitled to use it.  The KRB_AP_REQ message is referred to elsewhere\n\
    \   as the \"authentication header.\"\n"
- title: 3.2.2. Generation of a KRB_AP_REQ message
  contents:
  - "3.2.2. Generation of a KRB_AP_REQ message\n   When a client wishes to initiate\
    \ authentication to a server, it\n   obtains (either through a credentials cache,\
    \ the AS exchange, or the\n   TGS exchange) a ticket and session key for the desired\
    \ service.  The\n   client may re-use any tickets it holds until they expire.\
    \  The client\n   then constructs a new Authenticator from the the system time,\
    \ its\n   name, and optionally an application specific checksum, an initial\n\
    \   sequence number to be used in KRB_SAFE or KRB_PRIV messages, and/or a\n  \
    \ session subkey to be used in negotiations for a session key unique to\n   this\
    \ particular session.  Authenticators may not be re-used and will\n   be rejected\
    \ if replayed to a server (Note that this can make\n   applications based on unreliable\
    \ transports difficult to code\n   correctly, if the transport might deliver duplicated\
    \ messages.  In\n   such cases, a new authenticator must be generated for each\
    \ retry.).\n   If a sequence number is to be included, it should be randomly chosen\n\
    \   so that even after many messages have been exchanged it is not likely\n  \
    \ to collide with other sequence numbers in use.\n   The client may indicate a\
    \ requirement of mutual authentication or the\n   use of a session-key based ticket\
    \ by setting the appropriate flag(s)\n   in the ap-options field of the message.\n\
    \   The Authenticator is encrypted in the session key and combined with\n   the\
    \ ticket to form the KRB_AP_REQ message which is then sent to the\n   end server\
    \ along with any additional application-specific\n   information.  See section\
    \ A.9 for pseudocode.\n"
- title: 3.2.3. Receipt of KRB_AP_REQ message
  contents:
  - "3.2.3. Receipt of KRB_AP_REQ message\n   Authentication is based on the server's\
    \ current time of day (clocks\n   must be loosely synchronized), the authenticator,\
    \ and the ticket.\n   Several errors are possible.  If an error occurs, the server\
    \ is\n   expected to reply to the client with a KRB_ERROR message.  This\n   message\
    \ may be encapsulated in the application protocol if its \"raw\"\n   form is not\
    \ acceptable to the protocol. The format of error messages\n   is described in\
    \ section 5.9.1.\n   The algorithm for verifying authentication information is\
    \ as follows.\n   If the message type is not KRB_AP_REQ, the server returns the\n\
    \   KRB_AP_ERR_MSG_TYPE error. If the key version indicated by the Ticket\n  \
    \ in the KRB_AP_REQ is not one the server can use (e.g., it indicates\n   an old\
    \ key, and the server no longer possesses a copy of the old\n   key), the KRB_AP_ERR_BADKEYVER\
    \ error is returned.  If the USE-\n   SESSION-KEY flag is set in the ap-options\
    \ field, it indicates to the\n   server that the ticket is encrypted in the session\
    \ key from the\n   server's ticket-granting ticket rather than its secret key\
    \ (This is\n   used for user-to-user authentication as described in [6]).  Since\
    \ it\n   is possible for the server to be registered in multiple realms, with\n\
    \   different keys in each, the srealm field in the unencrypted portion\n   of\
    \ the ticket in the KRB_AP_REQ is used to specify which secret key\n   the server\
    \ should use to decrypt that ticket.  The KRB_AP_ERR_NOKEY\n   error code is returned\
    \ if the server doesn't have the proper key to\n   decipher the ticket.\n   The\
    \ ticket is decrypted using the version of the server's key\n   specified by the\
    \ ticket.  If the decryption routines detect a\n   modification of the ticket\
    \ (each encryption system must provide\n   safeguards to detect modified ciphertext;\
    \ see section 6), the\n   KRB_AP_ERR_BAD_INTEGRITY error is returned (chances\
    \ are good that\n   different keys were used to encrypt and decrypt).\n   The\
    \ authenticator is decrypted using the session key extracted from\n   the decrypted\
    \ ticket.  If decryption shows it to have been modified,\n   the KRB_AP_ERR_BAD_INTEGRITY\
    \ error is returned.  The name and realm\n   of the client from the ticket are\
    \ compared against the same fields in\n   the authenticator.  If they don't match,\
    \ the KRB_AP_ERR_BADMATCH\n   error is returned (they might not match, for example,\
    \ if the wrong\n   session key was used to encrypt the authenticator).  The addresses\
    \ in\n   the ticket (if any) are then searched for an address matching the\n \
    \  operating-system reported address of the client.  If no match is\n   found\
    \ or the server insists on ticket addresses but none are present\n   in the ticket,\
    \ the KRB_AP_ERR_BADADDR error is returned.\n   If the local (server) time and\
    \ the client time in the authenticator\n   differ by more than the allowable clock\
    \ skew (e.g., 5 minutes), the\n   KRB_AP_ERR_SKEW error is returned.  If the server\
    \ name, along with\n   the client name, time and microsecond fields from the Authenticator\n\
    \   match any recently-seen such tuples, the KRB_AP_ERR_REPEAT error is\n   returned\
    \ (Note that the rejection here is restricted to\n   authenticators from the same\
    \ principal to the same server.  Other\n   client principals communicating with\
    \ the same server principal should\n   not be have their authenticators rejected\
    \ if the time and microsecond\n   fields happen to match some other client's authenticator.).\
    \  The\n   server must remember any authenticator presented within the allowable\n\
    \   clock skew, so that a replay attempt is guaranteed to fail. If a\n   server\
    \ loses track of any authenticator presented within the\n   allowable clock skew,\
    \ it must reject all requests until the clock\n   skew interval has passed.  This\
    \ assures that any lost or re-played\n   authenticators will fall outside the\
    \ allowable clock skew and can no\n   longer be successfully replayed (If this\
    \ is not done, an attacker\n   could conceivably record the ticket and authenticator\
    \ sent over the\n   network to a server, then disable the client's host, pose\
    \ as the\n   disabled host, and replay the ticket and authenticator to subvert\
    \ the\n   authentication.).  If a sequence number is provided in the\n   authenticator,\
    \ the server saves it for later use in processing\n   KRB_SAFE and/or KRB_PRIV\
    \ messages.  If a subkey is present, the\n   server either saves it for later\
    \ use or uses it to help generate its\n   own choice for a subkey to be returned\
    \ in a KRB_AP_REP message.\n   The server computes the age of the ticket: local\
    \ (server) time minus\n   the start time inside the Ticket.  If the start time\
    \ is later than\n   the current time by more than the allowable clock skew or\
    \ if the\n   INVALID flag is set in the ticket, the KRB_AP_ERR_TKT_NYV error is\n\
    \   returned.  Otherwise, if the current time is later than end time by\n   more\
    \ than the allowable clock skew, the KRB_AP_ERR_TKT_EXPIRED error\n   is returned.\n\
    \   If all these checks succeed without an error, the server is assured\n   that\
    \ the client possesses the credentials of the principal named in\n   the ticket\
    \ and thus, the client has been authenticated to the server.\n   See section A.10\
    \ for pseudocode.\n"
- title: 3.2.4. Generation of a KRB_AP_REP message
  contents:
  - "3.2.4. Generation of a KRB_AP_REP message\n   Typically, a client's request will\
    \ include both the authentication\n   information and its initial request in the\
    \ same message, and the\n   server need not explicitly reply to the KRB_AP_REQ.\
    \  However, if\n   mutual authentication (not only authenticating the client to\
    \ the\n   server, but also the server to the client) is being performed, the\n\
    \   KRB_AP_REQ message will have MUTUAL-REQUIRED set in its ap-options\n   field,\
    \ and a KRB_AP_REP message is required in response.  As with the\n   error message,\
    \ this message may be encapsulated in the application\n   protocol if its \"raw\"\
    \ form is not acceptable to the application's\n   protocol.  The timestamp and\
    \ microsecond field used in the reply must\n   be the client's timestamp and microsecond\
    \ field (as provided in the\n   authenticator). [Note: In the Kerberos version\
    \ 4 protocol, the\n   timestamp in the reply was the client's timestamp plus one.\
    \  This is\n   not necessary in version 5 because version 5 messages are formatted\n\
    \   in such a way that it is not possible to create the reply by\n   judicious\
    \ message surgery (even in encrypted form) without knowledge\n   of the appropriate\
    \ encryption keys.]  If a sequence number is to be\n   included, it should be\
    \ randomly chosen as described above for the\n   authenticator.  A subkey may\
    \ be included if the server desires to\n   negotiate a different subkey.  The\
    \ KRB_AP_REP message is encrypted in\n   the session key extracted from the ticket.\
    \  See section A.11 for\n   pseudocode.\n"
- title: 3.2.5. Receipt of KRB_AP_REP message
  contents:
  - "3.2.5. Receipt of KRB_AP_REP message\n   If a KRB_AP_REP message is returned,\
    \ the client uses the session key\n   from the credentials obtained for the server\
    \ (Note that for\n   encrypting the KRB_AP_REP message, the sub-session key is\
    \ not used,\n   even if present in the Authenticator.) to decrypt the message,\
    \ and\n   verifies that the timestamp and microsecond fields match those in the\n\
    \   Authenticator it sent to the server.  If they match, then the client\n   is\
    \ assured that the server is genuine. The sequence number and subkey\n   (if present)\
    \ are retained for later use.  See section A.12 for\n   pseudocode.\n"
- title: 3.2.6. Using the encryption key
  contents:
  - "3.2.6. Using the encryption key\n   After the KRB_AP_REQ/KRB_AP_REP exchange\
    \ has occurred, the client and\n   server share an encryption key which can be\
    \ used by the application.\n   The \"true session key\" to be used for KRB_PRIV,\
    \ KRB_SAFE, or other\n   application-specific uses may be chosen by the application\
    \ based on\n   the subkeys in the KRB_AP_REP message and the authenticator\n \
    \  (Implementations of the protocol may wish to provide routines to\n   choose\
    \ subkeys based on session keys and random numbers and to\n   orchestrate a negotiated\
    \ key to be returned in the KRB_AP_REP\n   message.).  In some cases, the use\
    \ of this session key will be\n   implicit in the protocol; in others the method\
    \ of use must be chosen\n   from a several alternatives.  We leave the protocol\
    \ negotiations of\n   how to use the key (e.g., selecting an encryption or checksum\
    \ type)\n   to the application programmer; the Kerberos protocol does not\n  \
    \ constrain the implementation options.\n   With both the one-way and mutual authentication\
    \ exchanges, the peers\n   should take care not to send sensitive information\
    \ to each other\n   without proper assurances.  In particular, applications that\
    \ require\n   privacy or integrity should use the KRB_AP_REP or KRB_ERROR responses\n\
    \   from the server to client to assure both client and server of their\n   peer's\
    \ identity.  If an application protocol requires privacy of its\n   messages,\
    \ it can use the KRB_PRIV message (section 3.5). The KRB_SAFE\n   message (section\
    \ 3.4) can be used to assure integrity.\n"
- title: 3.3.  The Ticket-Granting Service (TGS) Exchange
  contents:
  - "3.3.  The Ticket-Granting Service (TGS) Exchange\n                          \
    \   Summary\n         Message direction       Message type     Section\n     \
    \    1. Client to Kerberos   KRB_TGS_REQ      5.4.1\n         2. Kerberos to client\
    \   KRB_TGS_REP or   5.4.2\n                                 KRB_ERROR       \
    \ 5.9.1\n   The TGS exchange between a client and the Kerberos Ticket-Granting\n\
    \   Server is initiated by a client when it wishes to obtain\n   authentication\
    \ credentials for a given server (which might be\n   registered in a remote realm),\
    \ when it wishes to renew or validate an\n   existing ticket, or when it wishes\
    \ to obtain a proxy ticket.  In the\n   first case, the client must already have\
    \ acquired a ticket for the\n   Ticket-Granting Service using the AS exchange\
    \ (the ticket-granting\n   ticket is usually obtained when a client initially\
    \ authenticates to\n   the system, such as when a user logs in).  The message\
    \ format for the\n   TGS exchange is almost identical to that for the AS exchange.\
    \  The\n   primary difference is that encryption and decryption in the TGS\n \
    \  exchange does not take place under the client's key.  Instead, the\n   session\
    \ key from the ticket-granting ticket or renewable ticket, or\n   sub-session\
    \ key from an Authenticator is used.  As is the case for\n   all application servers,\
    \ expired tickets are not accepted by the TGS,\n   so once a renewable or ticket-granting\
    \ ticket expires, the client\n   must use a separate exchange to obtain valid\
    \ tickets.\n   The TGS exchange consists of two messages: A request (KRB_TGS_REQ)\n\
    \   from the client to the Kerberos Ticket-Granting Server, and a reply\n   (KRB_TGS_REP\
    \ or KRB_ERROR).  The KRB_TGS_REQ message includes\n   information authenticating\
    \ the client plus a request for credentials.\n   The authentication information\
    \ consists of the authentication header\n   (KRB_AP_REQ) which includes the client's\
    \ previously obtained ticket-\n   granting, renewable, or invalid ticket.  In\
    \ the ticket-granting\n   ticket and proxy cases, the request may include one\
    \ or more of: a\n   list of network addresses, a collection of typed authorization\
    \ data\n   to be sealed in the ticket for authorization use by the application\n\
    \   server, or additional tickets (the use of which are described later).\n  \
    \ The TGS reply (KRB_TGS_REP) contains the requested credentials,\n   encrypted\
    \ in the session key from the ticket-granting ticket or\n   renewable ticket,\
    \ or if present, in the subsession key from the\n   Authenticator (part of the\
    \ authentication header). The KRB_ERROR\n   message contains an error code and\
    \ text explaining what went wrong.\n   The KRB_ERROR message is not encrypted.\
    \  The KRB_TGS_REP message\n   contains information which can be used to detect\
    \ replays, and to\n   associate it with the message to which it replies.  The\
    \ KRB_ERROR\n   message also contains information which can be used to associate\
    \ it\n   with the message to which it replies, but the lack of encryption in\n\
    \   the KRB_ERROR message precludes the ability to detect replays or\n   fabrications\
    \ of such messages.\n"
- title: 3.3.1. Generation of KRB_TGS_REQ message
  contents:
  - "3.3.1. Generation of KRB_TGS_REQ message\n   Before sending a request to the\
    \ ticket-granting service, the client\n   must determine in which realm the application\
    \ server is registered\n   [Note: This can be accomplished in several ways.  It\
    \ might be known\n   beforehand (since the realm is part of the principal identifier),\
    \ or\n   it might be stored in a nameserver.  Presently, however, this\n   information\
    \ is obtained from a configuration file.  If the realm to\n   be used is obtained\
    \ from a nameserver, there is a danger of being\n   spoofed if the nameservice\
    \ providing the realm name is not\n   authenticated.  This might result in the\
    \ use of a realm which has\n   been compromised, and would result in an attacker's\
    \ ability to\n   compromise the authentication of the application server to the\n\
    \   client.].  If the client does not already possess a ticket-granting\n   ticket\
    \ for the appropriate realm, then one must be obtained.  This is\n   first attempted\
    \ by requesting a ticket-granting ticket for the\n   destination realm from the\
    \ local Kerberos server (using the\n   KRB_TGS_REQ message recursively).  The\
    \ Kerberos server may return a\n   TGT for the desired realm in which case one\
    \ can proceed.\n   Alternatively, the Kerberos server may return a TGT for a realm\
    \ which\n   is \"closer\" to the desired realm (further along the standard\n \
    \  hierarchical path), in which case this step must be repeated with a\n   Kerberos\
    \ server in the realm specified in the returned TGT.  If\n   neither are returned,\
    \ then the request must be retried with a\n   Kerberos server for a realm higher\
    \ in the hierarchy.  This request\n   will itself require a ticket-granting ticket\
    \ for the higher realm\n   which must be obtained by recursively applying these\
    \ directions.\n   Once the client obtains a ticket-granting ticket for the appropriate\n\
    \   realm, it determines which Kerberos servers serve that realm, and\n   contacts\
    \ one. The list might be obtained through a configuration file\n   or network\
    \ service; as long as the secret keys exchanged by realms\n   are kept secret,\
    \ only denial of service results from a false Kerberos\n   server.\n   As in the\
    \ AS exchange, the client may specify a number of options in\n   the KRB_TGS_REQ\
    \ message.  The client prepares the KRB_TGS_REQ\n   message, providing an authentication\
    \ header as an element of the\n   padata field, and including the same fields\
    \ as used in the KRB_AS_REQ\n   message along with several optional fields: the\
    \ enc-authorization-\n   data field for application server use and additional\
    \ tickets required\n   by some options.\n   In preparing the authentication header,\
    \ the client can select a sub-\n   session key under which the response from the\
    \ Kerberos server will be\n   encrypted (If the client selects a sub-session key,\
    \ care must be\n   taken to ensure the randomness of the selected subsession key.\
    \  One\n   approach would be to generate a random number and XOR it with the\n\
    \   session key from the ticket-granting ticket.). If the sub-session key\n  \
    \ is not specified, the session key from the ticket-granting ticket\n   will be\
    \ used.  If the enc-authorization-data is present, it must be\n   encrypted in\
    \ the sub-session key, if present, from the authenticator\n   portion of the authentication\
    \ header, or if not present in the\n   session key from the ticket-granting ticket.\n\
    \   Once prepared, the message is sent to a Kerberos server for the\n   destination\
    \ realm.  See section A.5 for pseudocode.\n"
- title: 3.3.2. Receipt of KRB_TGS_REQ message
  contents:
  - "3.3.2. Receipt of KRB_TGS_REQ message\n   The KRB_TGS_REQ message is processed\
    \ in a manner similar to the\n   KRB_AS_REQ message, but there are many additional\
    \ checks to be\n   performed.  First, the Kerberos server must determine which\
    \ server\n   the accompanying ticket is for and it must select the appropriate\
    \ key\n   to decrypt it. For a normal KRB_TGS_REQ message, it will be for the\n\
    \   ticket granting service, and the TGS's key will be used.  If the TGT\n   was\
    \ issued by another realm, then the appropriate inter-realm key\n   must be used.\
    \  If the accompanying ticket is not a ticket granting\n   ticket for the current\
    \ realm, but is for an application server in the\n   current realm, the RENEW,\
    \ VALIDATE, or PROXY options are specified in\n   the request, and the server\
    \ for which a ticket is requested is the\n   server named in the accompanying\
    \ ticket, then the KDC will decrypt\n   the ticket in the authentication header\
    \ using the key of the server\n   for which it was issued.  If no ticket can be\
    \ found in the padata\n   field, the KDC_ERR_PADATA_TYPE_NOSUPP error is returned.\n\
    \   Once the accompanying ticket has been decrypted, the user-supplied\n   checksum\
    \ in the Authenticator must be verified against the contents\n   of the request,\
    \ and the message rejected if the checksums do not\n   match (with an error code\
    \ of KRB_AP_ERR_MODIFIED) or if the checksum\n   is not keyed or not collision-proof\
    \ (with an error code of\n   KRB_AP_ERR_INAPP_CKSUM).  If the checksum type is\
    \ not supported, the\n   KDC_ERR_SUMTYPE_NOSUPP error is returned.  If the authorization-data\n\
    \   are present, they are decrypted using the sub-session key from the\n   Authenticator.\n\
    \   If any of the decryptions indicate failed integrity checks, the\n   KRB_AP_ERR_BAD_INTEGRITY\
    \ error is returned.\n"
- title: 3.3.3. Generation of KRB_TGS_REP message
  contents:
  - "3.3.3. Generation of KRB_TGS_REP message\n   The KRB_TGS_REP message shares its\
    \ format with the KRB_AS_REP\n   (KRB_KDC_REP), but with its type field set to\
    \ KRB_TGS_REP.  The\n   detailed specification is in section 5.4.2.\n   The response\
    \ will include a ticket for the requested server.  The\n   Kerberos database is\
    \ queried to retrieve the record for the requested\n   server (including the key\
    \ with which the ticket will be encrypted).\n   If the request is for a ticket\
    \ granting ticket for a remote realm,\n   and if no key is shared with the requested\
    \ realm, then the Kerberos\n   server will select the realm \"closest\" to the\
    \ requested realm with\n   which it does share a key, and use that realm instead.\
    \ This is the\n   only case where the response from the KDC will be for a different\n\
    \   server than that requested by the client.\n   By default, the address field,\
    \ the client's name and realm, the list\n   of transited realms, the time of initial\
    \ authentication, the\n   expiration time, and the authorization data of the newly-issued\n\
    \   ticket will be copied from the ticket-granting ticket (TGT) or\n   renewable\
    \ ticket.  If the transited field needs to be updated, but\n   the transited type\
    \ is not supported, the KDC_ERR_TRTYPE_NOSUPP error\n   is returned.\n   If the\
    \ request specifies an endtime, then the endtime of the new\n   ticket is set\
    \ to the minimum of (a) that request, (b) the endtime\n   from the TGT, and (c)\
    \ the starttime of the TGT plus the minimum of\n   the maximum life for the application\
    \ server and the maximum life for\n   the local realm (the maximum life for the\
    \ requesting principal was\n   already applied when the TGT was issued).  If the\
    \ new ticket is to be\n   a renewal, then the endtime above is replaced by the\
    \ minimum of (a)\n   the value of the renew_till field of the ticket and (b) the\
    \ starttime\n   for the new ticket plus the life (endtimestarttime) of the old\n\
    \   ticket.\n   If the FORWARDED option has been requested, then the resulting\
    \ ticket\n   will contain the addresses specified by the client.  This option\
    \ will\n   only be honored if the FORWARDABLE flag is set in the TGT.  The PROXY\n\
    \   option is similar; the resulting ticket will contain the addresses\n   specified\
    \ by the client.  It will be honored only if the PROXIABLE\n   flag in the TGT\
    \ is set.  The PROXY option will not be honored on\n   requests for additional\
    \ ticket-granting tickets.\n   If the requested start time is absent or indicates\
    \ a time in the\n   past, then the start time of the ticket is set to the authentication\n\
    \   server's current time.  If it indicates a time in the future, but the\n  \
    \ POSTDATED option has not been specified or the MAY-POSTDATE flag is\n   not\
    \ set in the TGT, then the error KDC_ERR_CANNOT_POSTDATE is\n   returned.  Otherwise,\
    \ if the ticket-granting ticket has the\n   MAYPOSTDATE flag set, then the resulting\
    \ ticket will be postdated and\n   the requested starttime is checked against\
    \ the policy of the local\n   realm. If acceptable, the ticket's start time is\
    \ set as requested,\n   and the INVALID flag is set.  The postdated ticket must\
    \ be validated\n   before use by presenting it to the KDC after the starttime\
    \ has been\n   reached. However, in no case may the starttime, endtime, or renew-\n\
    \   till time of a newly-issued postdated ticket extend beyond the\n   renew-till\
    \ time of the ticket-granting ticket.\n   If the ENC-TKT-IN-SKEY option has been\
    \ specified and an additional\n   ticket has been included in the request, the\
    \ KDC will decrypt the\n   additional ticket using the key for the server to which\
    \ the\n   additional ticket was issued and verify that it is a ticket-granting\n\
    \   ticket.  If the name of the requested server is missing from the\n   request,\
    \ the name of the client in the additional ticket will be\n   used.  Otherwise\
    \ the name of the requested server will be compared to\n   the name of the client\
    \ in the additional ticket and if different, the\n   request will be rejected.\
    \  If the request succeeds, the session key\n   from the additional ticket will\
    \ be used to encrypt the new ticket\n   that is issued instead of using the key\
    \ of the server for which the\n   new ticket will be used (This allows easy implementation\
    \ of user-to-\n   user authentication [6], which uses ticket-granting ticket session\n\
    \   keys in lieu of secret server keys in situations where such secret\n   keys\
    \ could be easily compromised.).\n   If the name of the server in the ticket that\
    \ is presented to the KDC\n   as part of the authentication header is not that\
    \ of the ticket-\n   granting server itself, and the server is registered in the\
    \ realm of\n   the KDC, If the RENEW option is requested, then the KDC will verify\n\
    \   that the RENEWABLE flag is set in the ticket and that the renew_till\n   time\
    \ is still in the future.  If the VALIDATE option is rqeuested,\n   the KDC will\
    \ check that the starttime has passed and the INVALID flag\n   is set.  If the\
    \ PROXY option is requested, then the KDC will check\n   that the PROXIABLE flag\
    \ is set in the ticket.  If the tests succeed,\n   the KDC will issue the appropriate\
    \ new ticket.\n   Whenever a request is made to the ticket-granting server, the\n\
    \   presented ticket(s) is(are) checked against a hot-list of tickets\n   which\
    \ have been canceled.  This hot-list might be implemented by\n   storing a range\
    \ of issue dates for \"suspect tickets\"; if a presented\n   ticket had an authtime\
    \ in that range, it would be rejected.  In this\n   way, a stolen ticket-granting\
    \ ticket or renewable ticket cannot be\n   used to gain additional tickets (renewals\
    \ or otherwise) once the\n   theft has been reported.  Any normal ticket obtained\
    \ before it was\n   reported stolen will still be valid (because they require\
    \ no\n   interaction with the KDC), but only until their normal expiration\n \
    \  time.\n   The ciphertext part of the response in the KRB_TGS_REP message is\n\
    \   encrypted in the sub-session key from the Authenticator, if present,\n   or\
    \ the session key key from the ticket-granting ticket.  It is not\n   encrypted\
    \ using the client's secret key.  Furthermore, the client's\n   key's expiration\
    \ date and the key version number fields are left out\n   since these values are\
    \ stored along with the client's database\n   record, and that record is not needed\
    \ to satisfy a request based on a\n   ticket-granting ticket.  See section A.6\
    \ for pseudocode.\n"
- title: 3.3.3.1.  Encoding the transited field
  contents:
  - "3.3.3.1.  Encoding the transited field\n   If the identity of the server in the\
    \ TGT that is presented to the KDC\n   as part of the authentication header is\
    \ that of the ticket-granting\n   service, but the TGT was issued from another\
    \ realm, the KDC will look\n   up the inter-realm key shared with that realm and\
    \ use that key to\n   decrypt the ticket.  If the ticket is valid, then the KDC\
    \ will honor\n   the request, subject to the constraints outlined above in the\
    \ section\n   describing the AS exchange.  The realm part of the client's identity\n\
    \   will be taken from the ticket-granting ticket.  The name of the realm\n  \
    \ that issued the ticket-granting ticket will be added to the transited\n   field\
    \ of the ticket to be issued.  This is accomplished by reading\n   the transited\
    \ field from the ticket-granting ticket (which is treated\n   as an unordered\
    \ set of realm names), adding the new realm to the set,\n   then constructing\
    \ and writing out its encoded (shorthand) form (this\n   may involve a rearrangement\
    \ of the existing encoding).\n   Note that the ticket-granting service does not\
    \ add the name of its\n   own realm.  Instead, its responsibility is to add the\
    \ name of the\n   previous realm.  This prevents a malicious Kerberos server from\n\
    \   intentionally leaving out its own name (it could, however, omit other\n  \
    \ realms' names).\n   The names of neither the local realm nor the principal's\
    \ realm are to\n   be included in the transited field.  They appear elsewhere\
    \ in the\n   ticket and both are known to have taken part in authenticating the\n\
    \   principal.  Since the endpoints are not included, both local and\n   single-hop\
    \ inter-realm authentication result in a transited field\n   that is empty.\n\
    \   Because the name of each realm transited  is  added  to this field,\n   it\
    \ might potentially be very long.  To decrease the length of this\n   field, its\
    \ contents are encoded.  The initially supported encoding is\n   optimized for\
    \ the normal case of inter-realm communication: a\n   hierarchical arrangement\
    \ of realms using either domain or X.500 style\n   realm names. This encoding\
    \ (called DOMAIN-X500-COMPRESS) is now\n   described.\n   Realm names in the transited\
    \ field are separated by a \",\".  The \",\",\n   \"\\\", trailing \".\"s, and\
    \ leading spaces (\" \") are special characters,\n   and if they are part of a\
    \ realm name, they must be quoted in the\n   transited field by preceding them\
    \ with a \"\\\".\n   A realm name ending with a \".\" is interpreted as  being\
    \ prepended to\n   the previous realm.  For example, we can encode traversal of\
    \ EDU,\n   MIT.EDU,  ATHENA.MIT.EDU,  WASHINGTON.EDU, and CS.WASHINGTON.EDU as:\n\
    \              \"EDU,MIT.,ATHENA.,WASHINGTON.EDU,CS.\".\n   Note that if ATHENA.MIT.EDU,\
    \ or CS.WASHINGTON.EDU were endpoints,\n   that they would not be included in\
    \ this field, and we would have:\n              \"EDU,MIT.,WASHINGTON.EDU\"\n\
    \   A realm name beginning with a \"/\" is interpreted as being appended to\n\
    \   the previous realm (For the purpose of appending, the realm preceding\n  \
    \ the first listed realm is considered to be the null realm (\"\")).  If\n   it\
    \ is to stand by itself, then it should be preceded by a space (\"\n   \").  For\
    \ example, we can encode traversal of /COM/HP/APOLLO, /COM/HP,\n   /COM, and /COM/DEC\
    \ as:\n              \"/COM,/HP,/APOLLO, /COM/DEC\".\n   Like the example above,\
    \ if /COM/HP/APOLLO and /COM/DEC are endpoints,\n   they they would not be included\
    \ in this field, and we would have:\n              \"/COM,/HP\"\n   A null subfield\
    \ preceding or following a \",\" indicates that all\n   realms between the previous\
    \ realm and the next realm have been\n   traversed (For the purpose of interpreting\
    \ null subfields, the\n   client's realm is considered to precede those in the\
    \ transited field,\n   and the server's realm is considered to follow them.).\
    \ Thus, \",\"\n   means that all realms along the path between the client and\
    \ the\n   server have been traversed.  \",EDU, /COM,\" means that that all realms\n\
    \   from the client's realm up to EDU (in a domain style hierarchy) have\n   been\
    \ traversed, and that everything from /COM down to the server's\n   realm in an\
    \ X.500 style has also been traversed.  This could occur if\n   the EDU realm\
    \ in one hierarchy shares an inter-realm key directly\n   with the /COM realm\
    \ in another hierarchy.\n"
- title: 3.3.4. Receipt of KRB_TGS_REP message
  contents:
  - "3.3.4. Receipt of KRB_TGS_REP message\n   When the KRB_TGS_REP is received by\
    \ the client, it is processed in\n   the same manner as the KRB_AS_REP processing\
    \ described above.  The\n   primary difference is that the ciphertext part of\
    \ the response must\n   be decrypted using the session key from the ticket-granting\
    \ ticket\n   rather than the client's secret key.  See section A.7 for pseudocode.\n"
- title: 3.4.  The KRB_SAFE Exchange
  contents:
  - "3.4.  The KRB_SAFE Exchange\n   The KRB_SAFE message may be used by clients requiring\
    \ the ability to\n   detect modifications of messages they exchange.  It achieves\
    \ this by\n   including a keyed collisionproof checksum of the user data and some\n\
    \   control information.  The checksum is keyed with an encryption key\n   (usually\
    \ the last key negotiated via subkeys, or the session key if\n   no negotiation\
    \ has occured).\n"
- title: 3.4.1. Generation of a KRB_SAFE message
  contents:
  - "3.4.1. Generation of a KRB_SAFE message\n   When an application wishes to send\
    \ a KRB_SAFE message, it collects\n   its data and the appropriate control information\
    \ and computes a\n   checksum over them.  The checksum algorithm should be some\
    \ sort of\n   keyed one-way hash function (such as the RSA-MD5-DES checksum\n\
    \   algorithm specified in section 6.4.5, or the DES MAC), generated\n   using\
    \ the sub-session key if present, or the session key.  Different\n   algorithms\
    \ may be selected by changing the checksum type in the\n   message.  Unkeyed or\
    \ non-collision-proof checksums are not suitable\n   for this use.\n   The control\
    \ information for the KRB_SAFE message includes both a\n   timestamp and a sequence\
    \ number.  The designer of an application\n   using the KRB_SAFE message must\
    \ choose at least one of the two\n   mechanisms.  This choice should be based\
    \ on the needs of the\n   application protocol.\n   Sequence numbers are useful\
    \ when all messages sent will be received\n   by one's peer.  Connection state\
    \ is presently required to maintain\n   the session key, so maintaining the next\
    \ sequence number should not\n   present an additional problem.\n   If the application\
    \ protocol is expected to tolerate lost messages\n   without them being resent,\
    \ the use of the timestamp is the\n   appropriate replay detection mechanism.\
    \  Using timestamps is also the\n   appropriate mechanism for multi-cast protocols\
    \ where all of one's\n   peers share a common sub-session key, but some messages\
    \ will be sent\n   to a subset of one's peers.\n   After computing the checksum,\
    \ the client then transmits the\n   information and checksum to the recipient\
    \ in the message format\n   specified in section 5.6.1.\n"
- title: 3.4.2. Receipt of KRB_SAFE message
  contents:
  - "3.4.2. Receipt of KRB_SAFE message\n   When an application receives a KRB_SAFE\
    \ message, it verifies it as\n   follows.  If any error occurs, an error code\
    \ is reported for use by\n   the application.\n   The message is first checked\
    \ by verifying that the protocol version\n   and type fields match the current\
    \ version and KRB_SAFE, respectively.\n   A mismatch generates a KRB_AP_ERR_BADVERSION\
    \ or KRB_AP_ERR_MSG_TYPE\n   error.  The application verifies that the checksum\
    \ used is a\n   collisionproof keyed checksum, and if it is not, a\n   KRB_AP_ERR_INAPP_CKSUM\
    \ error is generated.  The recipient verifies\n   that the operating system's\
    \ report of the sender's address matches\n   the sender's address in the message,\
    \ and (if a recipient address is\n   specified or the recipient requires an address)\
    \ that one of the\n   recipient's addresses appears as the recipient's address\
    \ in the\n   message.  A failed match for either case generates a\n   KRB_AP_ERR_BADADDR\
    \ error.  Then the timestamp and usec and/or the\n   sequence number fields are\
    \ checked.  If timestamp and usec are\n   expected and not present, or they are\
    \ present but not current, the\n   KRB_AP_ERR_SKEW error is generated.  If the\
    \ server name, along with\n   the client name, time and microsecond fields from\
    \ the Authenticator\n   match any recently-seen such tuples, the KRB_AP_ERR_REPEAT\
    \ error is\n   generated.  If an incorrect sequence number is included, or a\n\
    \   sequence number is expected but not present, the KRB_AP_ERR_BADORDER\n   error\
    \ is generated.  If neither a timestamp and usec or a sequence\n   number is present,\
    \ a KRB_AP_ERR_MODIFIED error is generated.\n   Finally, the checksum is computed\
    \ over the data and control\n   information, and if it doesn't match the received\
    \ checksum, a\n   KRB_AP_ERR_MODIFIED error is generated.\n   If all the checks\
    \ succeed, the application is assured that the\n   message was generated by its\
    \ peer and was not modified in transit.\n"
- title: 3.5.  The KRB_PRIV Exchange
  contents:
  - "3.5.  The KRB_PRIV Exchange\n   The KRB_PRIV message may be used by clients requiring\
    \ confidentiality\n   and the ability to detect modifications of exchanged messages.\
    \  It\n   achieves this by encrypting the messages and adding control\n   information.\n"
- title: 3.5.1. Generation of a KRB_PRIV message
  contents:
  - "3.5.1. Generation of a KRB_PRIV message\n   When an application wishes to send\
    \ a KRB_PRIV message, it collects\n   its data and the appropriate control information\
    \ (specified in\n   section 5.7.1) and encrypts them under an encryption key (usually\
    \ the\n   last key negotiated via subkeys, or the session key if no negotiation\n\
    \   has occured).  As part of the control information, the client must\n   choose\
    \ to use either a timestamp or a sequence number (or both); see\n   the discussion\
    \ in section 3.4.1 for guidelines on which to use.\n   After the user data and\
    \ control information are encrypted, the client\n   transmits the ciphertext and\
    \ some \"envelope\" information to the\n   recipient.\n"
- title: 3.5.2. Receipt of KRB_PRIV message
  contents:
  - "3.5.2. Receipt of KRB_PRIV message\n   When an application receives a KRB_PRIV\
    \ message, it verifies it as\n   follows.  If any error occurs, an error code\
    \ is reported for use by\n   the application.\n   The message is first checked\
    \ by verifying that the protocol version\n   and type fields match the current\
    \ version and KRB_PRIV, respectively.\n   A mismatch generates a KRB_AP_ERR_BADVERSION\
    \ or KRB_AP_ERR_MSG_TYPE\n   error.  The application then decrypts the ciphertext\
    \ and processes\n   the resultant plaintext. If decryption shows the data to have\
    \ been\n   modified, a KRB_AP_ERR_BAD_INTEGRITY error is generated.  The\n   recipient\
    \ verifies that the operating system's report of the sender's\n   address matches\
    \ the sender's address in the message, and (if a\n   recipient address is specified\
    \ or the recipient requires an address)\n   that one of the recipient's addresses\
    \ appears as the recipient's\n   address in the message.  A failed match for either\
    \ case generates a\n   KRB_AP_ERR_BADADDR error.  Then the timestamp and usec\
    \ and/or the\n   sequence number fields are checked. If timestamp and usec are\n\
    \   expected and not present, or they are present but not current, the\n   KRB_AP_ERR_SKEW\
    \ error is generated.  If the server name, along with\n   the client name, time\
    \ and microsecond fields from the Authenticator\n   match any recently-seen such\
    \ tuples, the KRB_AP_ERR_REPEAT error is\n   generated.  If an incorrect sequence\
    \ number is included, or a\n   sequence number is expected but not present, the\
    \ KRB_AP_ERR_BADORDER\n   error is generated.  If neither a timestamp and usec\
    \ or a sequence\n   number is present, a KRB_AP_ERR_MODIFIED error is generated.\n\
    \   If all the checks succeed, the application can assume the message was\n  \
    \ generated by its peer, and was securely transmitted (without\n   intruders able\
    \ to see the unencrypted contents).\n"
- title: 3.6.  The KRB_CRED Exchange
  contents:
  - "3.6.  The KRB_CRED Exchange\n   The KRB_CRED message may be used by clients requiring\
    \ the ability to\n   send Kerberos credentials from one host to another.  It achieves\
    \ this\n   by sending the tickets together with encrypted data containing the\n\
    \   session keys and other information associated with the tickets.\n"
- title: 3.6.1. Generation of a KRB_CRED message
  contents:
  - "3.6.1. Generation of a KRB_CRED message\n   When an application wishes to send\
    \ a KRB_CRED message it first (using\n   the KRB_TGS exchange) obtains credentials\
    \ to be sent to the remote\n   host.  It then constructs a KRB_CRED message using\
    \ the ticket or\n   tickets so obtained, placing the session key needed to use\
    \ each\n   ticket in the key field of the corresponding KrbCredInfo sequence of\n\
    \   the encrypted part of the the KRB_CRED message.\n   Other information associated\
    \ with each ticket and obtained during the\n   KRB_TGS exchange is also placed\
    \ in the corresponding KrbCredInfo\n   sequence in the encrypted part of the KRB_CRED\
    \ message.  The current\n   time and, if specifically required by the application\
    \ the nonce, s-\n   address, and raddress fields, are placed in the encrypted\
    \ part of the\n   KRB_CRED message which is then encrypted under an encryption\
    \ key\n   previosuly exchanged in the KRB_AP exchange (usually the last key\n\
    \   negotiated via subkeys, or the session key if no negotiation has\n   occured).\n"
- title: 3.6.2. Receipt of KRB_CRED message
  contents:
  - "3.6.2. Receipt of KRB_CRED message\n   When an application receives a KRB_CRED\
    \ message, it verifies it.  If\n   any error occurs, an error code is reported\
    \ for use by the\n   application.  The message is verified by checking that the\
    \ protocol\n   version and type fields match the current version and KRB_CRED,\n\
    \   respectively.  A mismatch generates a KRB_AP_ERR_BADVERSION or\n   KRB_AP_ERR_MSG_TYPE\
    \ error.  The application then decrypts the\n   ciphertext and processes the resultant\
    \ plaintext. If decryption shows\n   the data to have been modified, a KRB_AP_ERR_BAD_INTEGRITY\
    \ error is\n   generated.\n   If present or required, the recipient verifies that\
    \ the operating\n   system's report of the sender's address matches the sender's\
    \ address\n   in the message, and that one of the recipient's addresses appears\
    \ as\n   the recipient's address in the message.  A failed match for either\n\
    \   case generates a KRB_AP_ERR_BADADDR error.  The timestamp and usec\n   fields\
    \ (and the nonce field if required) are checked next.  If the\n   timestamp and\
    \ usec are not present, or they are present but not\n   current, the KRB_AP_ERR_SKEW\
    \ error is generated.\n   If all the checks succeed, the application stores each\
    \ of the new\n   tickets in its ticket cache together with the session key and\
    \ other\n   information in the corresponding KrbCredInfo sequence from the\n \
    \  encrypted part of the KRB_CRED message.\n"
- title: 4.  The Kerberos Database
  contents:
  - "4.  The Kerberos Database\n   The Kerberos server must have access to a database\
    \ containing the\n   principal identifiers and secret keys of principals to be\n\
    \   authenticated (The implementation of the Kerberos server need not\n   combine\
    \ the database and the server on the same machine; it is\n   feasible to store\
    \ the principal database in, say, a network name\n   service, as long as the entries\
    \ stored therein are protected from\n   disclosure to and modification by unauthorized\
    \ parties.  However, we\n   recommend against such strategies, as they can make\
    \ system management\n   and threat analysis quite complex.).\n"
- title: 4.1.  Database contents
  contents:
  - "4.1.  Database contents\n   A database entry should contain at least the following\
    \ fields:\n   Field                Value\n   name                 Principal's\
    \ identifier\n   key                  Principal's secret key\n   p_kvno      \
    \         Principal's key version\n   max_life             Maximum lifetime for\
    \ Tickets\n   max_renewable_life   Maximum total lifetime for renewable\n    \
    \                    Tickets\n   The name field is an encoding of the principal's\
    \ identifier.  The key\n   field contains an encryption key.  This key is the\
    \ principal's secret\n   key.  (The key can be encrypted before storage under\
    \ a Kerberos\n   \"master key\" to protect it in case the database is compromised\
    \ but\n   the master key is not.  In that case, an extra field must be added to\n\
    \   indicate the master key version used, see below.) The p_kvno field is\n  \
    \ the key version number of the principal's secret key.  The max_life\n   field\
    \ contains the maximum allowable lifetime (endtime - starttime)\n   for any Ticket\
    \ issued for this principal.  The max_renewable_life\n   field contains the maximum\
    \ allowable total lifetime for any renewable\n   Ticket issued for this principal.\
    \  (See section 3.1 for a description\n   of how these lifetimes are used in determining\
    \ the lifetime of a\n   given Ticket.)\n   A server may provide KDC service to\
    \ several realms, as long as the\n   database representation provides a mechanism\
    \ to distinguish between\n   principal records with identifiers which differ only\
    \ in the realm\n   name.\n   When an application server's key changes, if the\
    \ change is routine\n   (i.e.,  not the result of disclosure of the old key),\
    \ the old key\n   should be retained by the server until all tickets that had\
    \ been\n   issued using that key have expired.  Because of this, it is possible\n\
    \   for several keys to be active for a single principal.  Ciphertext\n   encrypted\
    \ in a principal's key is always tagged with the version of\n   the key that was\
    \ used for encryption, to help the recipient find the\n   proper key for decryption.\n\
    \   When more than one key is active for a particular principal, the\n   principal\
    \ will have more than one record in the Kerberos database.\n   The keys and key\
    \ version numbers will differ between the records (the\n   rest of the fields\
    \ may or may not be the same). Whenever Kerberos\n   issues a ticket, or responds\
    \ to a request for initial authentication,\n   the most recent key (known by the\
    \ Kerberos server) will be used for\n   encryption.  This is the key with the\
    \ highest key version number.\n"
- title: 4.2.  Additional fields
  contents:
  - "4.2.  Additional fields\n   Project Athena's KDC implementation uses additional\
    \ fields in its\n   database:\n   Field        Value\n   K_kvno       Kerberos'\
    \ key version\n   expiration   Expiration date for entry\n   attributes   Bit\
    \ field of attributes\n   mod_date     Timestamp of last modification\n   mod_name\
    \     Modifying principal's identifier\n   The K_kvno field indicates the key\
    \ version of the Kerberos master key\n   under which the principal's secret key\
    \ is encrypted.\n   After an entry's expiration date has passed, the KDC will\
    \ return an\n   error to any client attempting to gain tickets as or for the\n\
    \   principal.  (A database may want to maintain two expiration dates:\n   one\
    \ for the principal, and one for the principal's current key.  This\n   allows\
    \ password aging to work independently of the principal's\n   expiration date.\
    \  However, due to the limited space in the responses,\n   the KDC must combine\
    \ the key expiration and principal expiration date\n   into a single value called\
    \ \"key_exp\", which is used as a hint to the\n   user to take administrative\
    \ action.)\n   The attributes field is a bitfield used to govern the operations\n\
    \   involving the principal.  This field might be useful in conjunction\n   with\
    \ user registration procedures, for site-specific policy\n   implementations (Project\
    \ Athena currently uses it for their user\n   registration process controlled\
    \ by the system-wide database service,\n   Moira [7]), or to identify the \"string\
    \ to key\" conversion algorithm\n   used for a principal's key.  (See the discussion\
    \ of the padata field\n   in section 5.4.2 for details on why this can be useful.)\
    \  Other bits\n   are used to indicate that certain ticket options should not\
    \ be\n   allowed in tickets encrypted under a principal's key (one bit each):\n\
    \   Disallow issuing postdated tickets, disallow issuing forwardable\n   tickets,\
    \ disallow issuing tickets based on TGT authentication,\n   disallow issuing renewable\
    \ tickets, disallow issuing proxiable\n   tickets, and disallow issuing tickets\
    \ for which the principal is the\n   server.\n   The mod_date field contains the\
    \ time of last modification of the\n   entry, and the mod_name field contains\
    \ the name of the principal\n   which last modified the entry.\n"
- title: 4.3.  Frequently Changing Fields
  contents:
  - "4.3.  Frequently Changing Fields\n   Some KDC implementations may wish to maintain\
    \ the last time that a\n   request was made by a particular principal.  Information\
    \ that might\n   be maintained includes the time of the last request, the time\
    \ of the\n   last request for a ticket-granting ticket, the time of the last use\n\
    \   of a ticket-granting ticket, or other times.  This information can\n   then\
    \ be returned to the user in the last-req field (see section 5.2).\n   Other frequently\
    \ changing information that can be maintained is the\n   latest expiration time\
    \ for any tickets that have been issued using\n   each key.  This field would\
    \ be used to indicate how long old keys\n   must remain valid to allow the continued\
    \ use of outstanding tickets.\n"
- title: 4.4.  Site Constants
  contents:
  - "4.4.  Site Constants\n   The KDC implementation should have the following configurable\n\
    \   constants or options, to allow an administrator to make and enforce\n   policy\
    \ decisions:\n   + The minimum supported lifetime (used to determine whether the\n\
    \      KDC_ERR_NEVER_VALID error should be returned). This constant\n      should\
    \ reflect reasonable expectations of round-trip time to the\n      KDC, encryption/decryption\
    \ time, and processing time by the client\n      and target server, and it should\
    \ allow for a minimum \"useful\"\n      lifetime.\n   + The maximum allowable\
    \ total (renewable) lifetime of a ticket\n      (renew_till - starttime).\n  \
    \ + The maximum allowable lifetime of a ticket (endtime - starttime).\n   + Whether\
    \ to allow the issue of tickets with empty address fields\n      (including the\
    \ ability to specify that such tickets may only be\n      issued if the request\
    \ specifies some authorization_data).\n   + Whether proxiable, forwardable, renewable\
    \ or post-datable tickets\n      are to be issued.\n"
- title: 5.  Message Specifications
  contents:
  - "5.  Message Specifications\n   The following sections describe the exact contents\
    \ and encoding of\n   protocol messages and objects.  The ASN.1 base definitions\
    \ are\n   presented in the first subsection.  The remaining subsections specify\n\
    \   the protocol objects (tickets and authenticators) and messages.\n   Specification\
    \ of encryption and checksum techniques, and the fields\n   related to them, appear\
    \ in section 6.\n"
- title: 5.1.  ASN.1 Distinguished Encoding Representation
  contents:
  - "5.1.  ASN.1 Distinguished Encoding Representation\n   All uses of ASN.1 in Kerberos\
    \ shall use the Distinguished Encoding\n   Representation of the data elements\
    \ as described in the X.509\n   specification, section 8.7 [8].\n"
- title: 5.2.  ASN.1 Base Definitions
  contents:
  - "5.2.  ASN.1 Base Definitions\n   The following ASN.1 base definitions are used\
    \ in the rest of this\n   section. Note that since the underscore character (_)\
    \ is not\n   permitted in ASN.1 names, the hyphen (-) is used in its place for\
    \ the\n   purposes of ASN.1 names.\n   Realm ::=           GeneralString\n   PrincipalName\
    \ ::=   SEQUENCE {\n                       name-type[0]     INTEGER,\n       \
    \                name-string[1]   SEQUENCE OF GeneralString\n   }\n   Kerberos\
    \ realms are encoded as GeneralStrings. Realms shall not\n   contain a character\
    \ with the code 0 (the ASCII NUL).  Most realms\n   will usually consist of several\
    \ components separated by periods (.),\n   in the style of Internet Domain Names,\
    \ or separated by slashes (/) in\n   the style of X.500 names.  Acceptable forms\
    \ for realm names are\n   specified in section 7.  A PrincipalName is a typed\
    \ sequence of\n   components consisting of the following sub-fields:\n   name-type\
    \ This field specifies the type of name that follows.\n             Pre-defined\
    \ values for this field are\n             specified in section 7.2.  The name-type\
    \ should be\n             treated as a hint.  Ignoring the name type, no two\n\
    \             names can be the same (i.e., at least one of the\n             components,\
    \ or the realm, must be different).\n             This constraint may be eliminated\
    \ in the future.\n   name-string This field encodes a sequence of components that\n\
    \               form a name, each component encoded as a General\n           \
    \    String.  Taken together, a PrincipalName and a Realm\n               form\
    \ a principal identifier.  Most PrincipalNames\n               will have only\
    \ a few components (typically one or two).\n           KerberosTime ::=   GeneralizedTime\n\
    \                              -- Specifying UTC time zone (Z)\n   The timestamps\
    \ used in Kerberos are encoded as GeneralizedTimes.  An\n   encoding shall specify\
    \ the UTC time zone (Z) and shall not include\n   any fractional portions of the\
    \ seconds.  It further shall not include\n   any separators.  Example: The only\
    \ valid format for UTC time 6\n   minutes, 27 seconds after 9 pm on 6 November\
    \ 1985 is 19851106210627Z.\n    HostAddress ::=     SEQUENCE  {\n            \
    \            addr-type[0]             INTEGER,\n                        address[1]\
    \               OCTET STRING\n    }\n    HostAddresses ::=   SEQUENCE OF SEQUENCE\
    \ {\n                        addr-type[0]             INTEGER,\n             \
    \           address[1]               OCTET STRING\n    }\n   The host adddress\
    \ encodings consists of two fields:\n   addr-type  This field specifies the type\
    \ of  address that\n              follows. Pre-defined values for this field are\n\
    \              specified in section 8.1.\n   address   This field encodes a single\
    \ address of type addr-type.\n   The two forms differ slightly. HostAddress contains\
    \ exactly one\n   address; HostAddresses contains a sequence of possibly many\n\
    \   addresses.\n   AuthorizationData ::=   SEQUENCE OF SEQUENCE {\n          \
    \                 ad-type[0]               INTEGER,\n                        \
    \   ad-data[1]               OCTET STRING\n   }\n   ad-data   This field contains\
    \ authorization data to be\n             interpreted according to the value of\
    \ the\n             corresponding ad-type field.\n   ad-type   This field specifies\
    \ the format for the ad-data\n             subfield.  All negative values are\
    \ reserved for\n             local use.  Non-negative values are reserved for\n\
    \             registered use.\n                   APOptions ::=   BIT STRING {\n\
    \                                   reserved(0),\n                           \
    \        use-session-key(1),\n                                   mutual-required(2)\n\
    \                   }\n                   TicketFlags ::=   BIT STRING {\n   \
    \                                  reserved(0),\n                            \
    \         forwardable(1),\n                                     forwarded(2),\n\
    \                                     proxiable(3),\n                        \
    \             proxy(4),\n                                     may-postdate(5),\n\
    \                                     postdated(6),\n                        \
    \             invalid(7),\n                                     renewable(8),\n\
    \                                     initial(9),\n                          \
    \           pre-authent(10),\n                                     hw-authent(11)\n\
    \                   }\n                  KDCOptions ::=   BIT STRING {\n     \
    \                              reserved(0),\n                                \
    \   forwardable(1),\n                                   forwarded(2),\n      \
    \                             proxiable(3),\n                                \
    \   proxy(4),\n                                   allow-postdate(5),\n       \
    \                            postdated(6),\n                                 \
    \  unused7(7),\n                                   renewable(8),\n           \
    \                        unused9(9),\n                                   unused10(10),\n\
    \                                   unused11(11),\n                          \
    \         renewable-ok(27),\n                                   enc-tkt-in-skey(28),\n\
    \                                   renew(30),\n                             \
    \      validate(31)\n                  }\n            LastReq ::=   SEQUENCE OF\
    \ SEQUENCE {\n                          lr-type[0]               INTEGER,\n  \
    \                        lr-value[1]              KerberosTime\n            }\n\
    \   lr-type   This field indicates how the following lr-value\n             field\
    \ is to be interpreted.  Negative values indicate\n             that the information\
    \ pertains only to the\n             responding server.  Non-negative values pertain\
    \ to\n             all servers for the realm.\n             If the lr-type field\
    \ is zero (0), then no information\n             is conveyed by the lr-value subfield.\
    \  If the\n             absolute value of the lr-type field is one (1),\n    \
    \         then the lr-value subfield is the time of last\n             initial\
    \ request for a TGT.  If it is two (2), then\n             the lr-value subfield\
    \ is the time of last initial\n             request.  If it is three (3), then\
    \ the lr-value\n             subfield is the time of issue for the newest\n  \
    \           ticket-granting ticket used. If it is four (4),\n             then\
    \ the lr-value subfield is the time of the last\n             renewal.  If it\
    \ is five (5), then the lr-value\n             subfield is the time of last request\
    \ (of any\n             type).\n   lr-value  This field contains the time of the\
    \ last request.\n             The time must be interpreted according to the contents\n\
    \             of the accompanying lr-type subfield.\n   See section 6 for the\
    \ definitions of Checksum, ChecksumType,\n   EncryptedData, EncryptionKey, EncryptionType,\
    \ and KeyType.\n"
- title: 5.3.  Tickets and Authenticators
  contents:
  - "5.3.  Tickets and Authenticators\n   This section describes the format and encryption\
    \ parameters for\n   tickets and authenticators.  When a ticket or authenticator\
    \ is\n   included in a protocol message it is treated as an opaque object.\n"
- title: 5.3.1. Tickets
  contents:
  - "5.3.1. Tickets\n   A ticket is a record that helps a client authenticate to a\
    \ service.\n   A Ticket contains the following information:\n"
- title: Ticket ::=                    [APPLICATION 1] SEQUENCE {
  contents:
  - "Ticket ::=                    [APPLICATION 1] SEQUENCE {\n                  \
    \            tkt-vno[0]                   INTEGER,\n                         \
    \     realm[1]                     Realm,\n                              sname[2]\
    \                     PrincipalName,\n                              enc-part[3]\
    \                  EncryptedData\n"
- title: '}'
  contents:
  - '}

    '
- title: -- Encrypted part of ticket
  contents:
  - '-- Encrypted part of ticket

    '
- title: EncTicketPart ::=     [APPLICATION 3] SEQUENCE {
  contents:
  - "EncTicketPart ::=     [APPLICATION 3] SEQUENCE {\n                      flags[0]\
    \             TicketFlags,\n                      key[1]               EncryptionKey,\n\
    \                      crealm[2]            Realm,\n                      cname[3]\
    \             PrincipalName,\n                      transited[4]         TransitedEncoding,\n\
    \                      authtime[5]          KerberosTime,\n                  \
    \    starttime[6]         KerberosTime OPTIONAL,\n                      endtime[7]\
    \           KerberosTime,\n                      renew-till[8]        KerberosTime\
    \ OPTIONAL,\n                      caddr[9]             HostAddresses OPTIONAL,\n\
    \                      authorization-data[10]   AuthorizationData OPTIONAL\n"
- title: '}'
  contents:
  - '}

    '
- title: -- encoded Transited field
  contents:
  - '-- encoded Transited field

    '
- title: TransitedEncoding ::=         SEQUENCE {
  contents:
  - "TransitedEncoding ::=         SEQUENCE {\n                              tr-type[0]\
    \  INTEGER, -- must be registered\n                              contents[1] \
    \         OCTET STRING\n"
- title: '}'
  contents:
  - "}\n   The encoding of EncTicketPart is encrypted in the key shared by\n   Kerberos\
    \ and the end server (the server's secret key).  See section 6\n   for the format\
    \ of the ciphertext.\n   tkt-vno   This field specifies the version number for\
    \ the ticket\n             format.  This document describes version number 5.\n\
    \   realm     This field specifies the realm that issued a ticket.  It\n     \
    \        also serves to identify the realm part of the server's\n            \
    \ principal identifier.  Since a Kerberos server can only\n             issue\
    \ tickets for servers within its realm, the two will\n             always be identical.\n\
    \   sname     This field specifies the name part of the server's\n           \
    \  identity.\n   enc-part  This field holds the encrypted encoding of the\n  \
    \           EncTicketPart sequence.\n   flags     This field indicates which of\
    \ various options were used or\n             requested when the ticket was issued.\
    \  It is a bit-field,\n             where the selected options are indicated by\
    \ the bit being\n             set (1), and the unselected options and reserved\
    \ fields\n             being reset (0).  Bit 0 is the most significant bit.  The\n\
    \             encoding of the bits is specified in section 5.2.  The\n       \
    \      flags are described in more detail above in section 2.  The\n         \
    \    meanings of the flags are:\n             Bit(s)    Name        Description\n\
    \             0         RESERVED    Reserved for future expansion of this\n  \
    \                                 field.\n             1         FORWARDABLE The\
    \ FORWARDABLE flag is normally only\n                                   interpreted\
    \ by the TGS, and can be\n                                   ignored by end servers.\
    \  When set,\n                                   this flag tells the ticket-granting\n\
    \                                   server that it is OK to issue a new\n    \
    \                               ticket- granting ticket with a\n             \
    \                      different network address based on\n                  \
    \                 the presented ticket.\n             2         FORWARDED   When\
    \ set, this flag indicates that\n                                   the ticket\
    \ has either been forwarded\n                                   or was issued\
    \ based on authentication\n                                   involving a forwarded\
    \ ticket-granting\n                                   ticket.\n             3\
    \         PROXIABLE   The PROXIABLE flag is normally only\n                  \
    \                 interpreted by the TGS, and can be\n                       \
    \            ignored by end servers. The PROXIABLE\n                         \
    \          flag has an interpretation identical\n                            \
    \       to that of the FORWARDABLE flag,\n                                   except\
    \ that the PROXIABLE flag tells\n                                   the ticket-granting\
    \ server that only\n                                   non- ticket-granting tickets\
    \ may be\n                                   issued with different network\n \
    \                                  addresses.\n             4         PROXY  \
    \    When set, this flag indicates that a\n                                  \
    \ ticket is a proxy.\n             5         MAY-POSTDATE The MAY-POSTDATE flag\
    \ is normally\n                                   only interpreted by the TGS,\
    \ and can\n                                   be ignored by end servers.  This\
    \ flag\n                                   tells the ticket-granting server that\n\
    \                                   a post- dated ticket may be issued\n     \
    \                              based on this ticket-granting ticket.\n       \
    \      6         POSTDATED   This flag indicates that this ticket\n          \
    \                         has been postdated.  The end-service\n             \
    \                      can check the authtime field to see\n                 \
    \                  when the original authentication\n                        \
    \           occurred.\n             7         INVALID     This flag indicates\
    \ that a ticket is\n                                   invalid, and it must be\
    \ validated by\n                                   the KDC before use.  Application\n\
    \                                   servers must reject tickets which\n      \
    \                             have this flag set.\n             8         RENEWABLE\
    \   The RENEWABLE flag is normally only\n                                   interpreted\
    \ by the TGS, and can\n                                   usually be ignored by\
    \ end servers\n                                   (some particularly careful servers\n\
    \                                   may wish to disallow renewable\n         \
    \                          tickets).  A renewable ticket can be\n            \
    \                       used to obtain a replacement ticket\n                \
    \                   that expires at a later date.\n             9         INITIAL\
    \     This flag indicates that this ticket\n                                 \
    \  was issued using the AS protocol, and\n                                   not\
    \ issued based on a ticket-granting\n                                   ticket.\n\
    \             10        PRE-AUTHENT This flag indicates that during\n        \
    \                           initial authentication, the client\n             \
    \                      was authenticated by the KDC before a\n               \
    \                    ticket was issued.  The strength of\n                   \
    \                the preauthentication method is not\n                       \
    \            indicated, but is acceptable to the\n                           \
    \        KDC.\n             11        HW-AUTHENT  This flag indicates that the\
    \ protocol\n                                   employed for initial authentication\n\
    \                                   required the use of hardware expected\n  \
    \                                 to be possessed solely by the named\n      \
    \                             client.  The hardware authentication\n         \
    \                          method is selected by the KDC and the\n           \
    \                        strength of the method is not\n                     \
    \              indicated.\n             12-31     RESERVED    Reserved for future\
    \ use.\n   key       This field exists in the ticket and the KDC response and\
    \ is\n             used to pass the session key from Kerberos to the\n       \
    \      application server and the client.  The field's encoding is\n         \
    \    described in section 6.2.\n   crealm    This field contains the name of the\
    \ realm in which the\n             client is registered and in which initial authentication\n\
    \             took place.\n   cname     This field contains the name part of the\
    \ client's principal\n             identifier.\n   transited This field lists\
    \ the names of the Kerberos realms that took\n             part in authenticating\
    \ the user to whom this ticket was\n             issued.  It does not specify\
    \ the order in which the realms\n             were transited.  See section 3.3.3.1\
    \ for details on how\n             this field encodes the traversed realms.\n\
    \   authtime  This field indicates the time of initial authentication for\n  \
    \           the named principal.  It is the time of issue for the\n          \
    \   original ticket on which this ticket is based.  It is\n             included\
    \ in the ticket to provide additional information to\n             the end service,\
    \ and  to provide  the necessary information\n             for implementation\
    \ of a `hot list' service at the KDC.   An\n             end service that is particularly\
    \ paranoid could refuse to\n             accept tickets for which the initial\
    \ authentication\n             occurred \"too far\" in the past.\n           \
    \  This field is also returned as part of the response from\n             the\
    \ KDC.  When returned as part of the response to initial\n             authentication\
    \ (KRB_AS_REP), this is the current time on\n             the Kerberos server\
    \ (It is NOT recommended that this time\n             value be used to adjust\
    \ the workstation's clock since the\n             workstation cannot reliably\
    \ determine that such a\n             KRB_AS_REP actually came from the proper\
    \ KDC in a timely\n             manner.).\n   starttime This field in the ticket\
    \ specifies the time after which the\n             ticket is valid.  Together\
    \ with endtime, this field\n             specifies the life of the ticket.   If\
    \ it is absent from\n             the ticket, its value should be treated as that\
    \ of the\n             authtime field.\n   endtime   This field contains the time\
    \ after which the ticket will\n             not be honored (its expiration time).\
    \  Note that individual\n             services may place their own limits on the\
    \ life of a ticket\n             and may reject tickets which have not yet expired.\
    \  As\n             such, this is really an upper bound on the expiration time\n\
    \             for the ticket.\n   renew-till This field is only present in tickets\
    \ that have the\n             RENEWABLE flag set in the flags field.  It indicates\
    \ the\n             maximum endtime that may be included in a renewal.  It can\n\
    \             be thought of as the absolute expiration time for the\n        \
    \     ticket, including all renewals.\n   caddr     This field in a ticket contains\
    \ zero (if omitted) or more\n             (if present) host addresses.  These\
    \ are the addresses from\n             which the ticket can be used.  If there\
    \ are no addresses,\n             the ticket can be used from any location.  The\
    \ decision\n             by the KDC to issue or by the end server to accept zero-\n\
    \             address tickets is a policy decision and is left to the\n      \
    \       Kerberos and end-service administrators; they may refuse to\n        \
    \     issue or accept such tickets.  The suggested and default\n             policy,\
    \ however, is that such tickets will only be issued\n             or accepted\
    \ when additional information that can be used to\n             restrict the use\
    \ of the ticket is included in the\n             authorization_data field.  Such\
    \ a ticket is a capability.\n             Network addresses are included in the\
    \ ticket to make it\n             harder for an attacker to use stolen credentials.\
    \ Because\n             the session key is not sent over the network in cleartext,\n\
    \             credentials can't be stolen simply by listening to the\n       \
    \      network; an attacker has to gain access to the session key\n          \
    \   (perhaps through operating system security breaches or a\n             careless\
    \ user's unattended session) to make use of stolen\n             tickets.\n  \
    \           It is important to note that the network address from which\n    \
    \         a connection is received cannot be reliably determined.\n          \
    \   Even if it could be, an attacker who has compromised the\n             client's\
    \ workstation could use the credentials from there.\n             Including the\
    \ network addresses only makes it more\n             difficult, not impossible,\
    \ for an attacker to walk off with\n             stolen credentials and then use\
    \ them from a \"safe\"\n             location.\n   authorization-data The authorization-data\
    \ field is used to pass\n             authorization data from the principal on\
    \ whose behalf a\n             ticket was issued to the application service. \
    \ If no\n             authorization data is included, this field will be left\n\
    \             out.  The data in this field are specific to the end\n         \
    \    service.  It is expected that the field will contain the\n             names\
    \ of service specific objects, and the rights to those\n             objects.\
    \  The format for this field is described in section\n             5.2.  Although\
    \ Kerberos is not concerned with the format of\n             the contents of the\
    \ subfields, it does carry type\n             information (ad-type).\n       \
    \      By using the authorization_data field, a principal is able\n          \
    \   to issue a proxy that is valid for a specific purpose.  For\n            \
    \ example, a client wishing to print a file can obtain a file\n             server\
    \ proxy to be passed to the print server.  By\n             specifying the name\
    \ of the file in the authorization_data\n             field, the file server knows\
    \ that the print server can only\n             use the client's rights when accessing\
    \ the particular file\n             to be printed.\n             It is interesting\
    \ to note that if one specifies the\n             authorization-data field of\
    \ a proxy and leaves the host\n             addresses blank, the resulting ticket\
    \ and session key can\n             be treated as a capability.  See [9] for some\
    \ suggested\n             uses of this field.\n             The authorization-data\
    \ field is optional and does not have\n             to be included in a ticket.\n"
- title: 5.3.2. Authenticators
  contents:
  - "5.3.2. Authenticators\n   An authenticator is a record sent with a ticket to\
    \ a server to\n   certify the client's knowledge of the encryption key in the\
    \ ticket,\n   to help the server detect replays, and to help choose a \"true session\n\
    \   key\" to use with the particular session.  The encoding is encrypted\n   in\
    \ the ticket's session key shared by the client and the server:\n"
- title: -- Unencrypted authenticator
  contents:
  - '-- Unencrypted authenticator

    '
- title: Authenticator ::=    [APPLICATION 2] SEQUENCE    {
  contents:
  - "Authenticator ::=    [APPLICATION 2] SEQUENCE    {\n               authenticator-vno[0]\
    \          INTEGER,\n               crealm[1]                     Realm,\n   \
    \            cname[2]                      PrincipalName,\n               cksum[3]\
    \                      Checksum OPTIONAL,\n               cusec[4]           \
    \           INTEGER,\n               ctime[5]                      KerberosTime,\n\
    \               subkey[6]                     EncryptionKey OPTIONAL,\n      \
    \         seq-number[7]                 INTEGER OPTIONAL,\n               authorization-data[8]\
    \         AuthorizationData OPTIONAL\n                     }\n   authenticator-vno\
    \ This field specifies the version number for the\n             format of the\
    \ authenticator. This document specifies\n             version 5.\n   crealm and\
    \ cname These fields are the same as those described for the\n             ticket\
    \ in section 5.3.1.\n   cksum     This field contains a checksum of the the application\
    \ data\n             that accompanies the KRB_AP_REQ.\n   cusec     This field\
    \ contains the microsecond part of the client's\n             timestamp.  Its\
    \ value (before encryption) ranges from 0 to\n             999999.  It often appears\
    \ along with ctime.  The two fields\n             are used together to specify\
    \ a reasonably accurate\n             timestamp.\n   ctime     This field contains\
    \ the current time on the client's host.\n   subkey    This field contains the\
    \ client's choice for an encryption\n             key which is to be used to protect\
    \ this specific\n             application session. Unless an application specifies\n\
    \             otherwise, if this field is left out the session key from\n    \
    \         the ticket will be used.\n   seq-number This optional field includes\
    \ the initial sequence number\n             to be used by the KRB_PRIV or KRB_SAFE\
    \ messages when\n             sequence numbers are used to detect replays (It\
    \ may also be\n             used by application specific messages).  When included\
    \ in\n             the authenticator this field specifies the initial sequence\n\
    \             number for messages from the client to the server.  When\n     \
    \        included in the AP-REP message, the initial sequence number\n       \
    \      is that for messages from the server to the client.  When\n           \
    \  used in KRB_PRIV or KRB_SAFE messages, it is incremented by\n             one\
    \ after each message is sent.\n             For sequence numbers to adequately\
    \ support the detection of\n             replays they should be non-repeating,\
    \ even across\n             connection boundaries. The initial sequence number\
    \ should\n             be random and uniformly distributed across the full space\n\
    \             of possible sequence numbers, so that it cannot be guessed\n   \
    \          by an attacker and so that it and the successive sequence\n       \
    \      numbers do not repeat other sequences.\n   authorization-data This field\
    \ is the same as described for the ticket\n             in section 5.3.1.  It\
    \ is optional and will only appear when\n             additional restrictions\
    \ are to be placed on the use of a\n             ticket, beyond those carried\
    \ in the ticket itself.\n"
- title: 5.4.  Specifications for the AS and TGS exchanges
  contents:
  - "5.4.  Specifications for the AS and TGS exchanges\n   This section specifies\
    \ the format of the messages used in exchange\n   between the client and the Kerberos\
    \ server.  The format of possible\n   error messages appears in section 5.9.1.\n"
- title: 5.4.1. KRB_KDC_REQ definition
  contents:
  - "5.4.1. KRB_KDC_REQ definition\n   The KRB_KDC_REQ message has no type of its\
    \ own.  Instead, its type is\n   one of KRB_AS_REQ or KRB_TGS_REQ depending on\
    \ whether the request is\n   for an initial ticket or an additional ticket.  In\
    \ either case, the\n   message is sent from the client to the Authentication Server\
    \ to\n   request credentials for a service.\n"
- title: 'The message fields are:'
  contents:
  - 'The message fields are:

    '
- title: AS-REQ ::=         [APPLICATION 10] KDC-REQ
  contents:
  - 'AS-REQ ::=         [APPLICATION 10] KDC-REQ

    '
- title: TGS-REQ ::=        [APPLICATION 12] KDC-REQ
  contents:
  - 'TGS-REQ ::=        [APPLICATION 12] KDC-REQ

    '
- title: KDC-REQ ::=        SEQUENCE {
  contents:
  - "KDC-REQ ::=        SEQUENCE {\n           pvno[1]               INTEGER,\n  \
    \         msg-type[2]           INTEGER,\n           padata[3]             SEQUENCE\
    \ OF PA-DATA OPTIONAL,\n           req-body[4]           KDC-REQ-BODY\n"
- title: '}'
  contents:
  - '}

    '
- title: PA-DATA ::=        SEQUENCE {
  contents:
  - "PA-DATA ::=        SEQUENCE {\n           padata-type[1]        INTEGER,\n  \
    \         padata-value[2]       OCTET STRING,\n                         -- might\
    \ be encoded AP-REQ\n"
- title: '}'
  contents:
  - '}

    '
- title: KDC-REQ-BODY ::=   SEQUENCE {
  contents:
  - "KDC-REQ-BODY ::=   SEQUENCE {\n            kdc-options[0]       KDCOptions,\n\
    \            cname[1]             PrincipalName OPTIONAL,\n                  \
    \       -- Used only in AS-REQ\n            realm[2]             Realm, -- Server's\
    \ realm\n                         -- Also client's in AS-REQ\n            sname[3]\
    \             PrincipalName OPTIONAL,\n            from[4]              KerberosTime\
    \ OPTIONAL,\n            till[5]              KerberosTime,\n            rtime[6]\
    \             KerberosTime OPTIONAL,\n            nonce[7]             INTEGER,\n\
    \            etype[8]             SEQUENCE OF INTEGER, -- EncryptionType,\n  \
    \                       -- in preference order\n            addresses[9]     \
    \    HostAddresses OPTIONAL,\n            enc-authorization-data[10]   EncryptedData\
    \ OPTIONAL,\n                         -- Encrypted AuthorizationData encoding\n\
    \            additional-tickets[11]       SEQUENCE OF Ticket OPTIONAL\n"
- title: '}'
  contents:
  - "}\n   The fields in this message are:\n   pvno      This field is included in\
    \ each message, and specifies the\n             protocol version number.  This\
    \ document specifies protocol\n             version 5.\n   msg-type  This field\
    \ indicates the type of a protocol message.  It\n             will almost always\
    \ be the same as the application\n             identifier associated with a message.\
    \  It is included to\n             make the identifier more readily accessible\
    \ to the\n             application.  For the KDC-REQ message, this type will be\n\
    \             KRB_AS_REQ or KRB_TGS_REQ.\n   padata    The padata (pre-authentication\
    \ data) field contains a of\n             authentication information which may\
    \ be needed before\n             credentials can be issued or decrypted.  In the\
    \ case of\n             requests for additional tickets (KRB_TGS_REQ), this field\n\
    \             will include an element with padata-type of PA-TGS-REQ and\n   \
    \          data of an authentication header (ticket-granting ticket\n        \
    \     and authenticator). The checksum in the authenticator\n             (which\
    \ must be collisionproof) is to be computed over the\n             KDC-REQ-BODY\
    \ encoding.  In most requests for initial\n             authentication (KRB_AS_REQ)\
    \ and most replies (KDC-REP), the\n             padata field will be left out.\n\
    \             This field may also contain information needed by certain\n    \
    \         extensions to the Kerberos protocol.  For example, it might\n      \
    \       be used to initially verify the identity of a client before\n        \
    \     any response is returned.  This is accomplished with a\n             padata\
    \ field with padata-type equal to PA-ENC-TIMESTAMP and\n             padata-value\
    \ defined as follows:\n   padata-type     ::= PA-ENC-TIMESTAMP\n   padata-value\
    \    ::= EncryptedData -- PA-ENC-TS-ENC\n   PA-ENC-TS-ENC   ::= SEQUENCE {\n \
    \          patimestamp[0]               KerberosTime, -- client's time\n     \
    \      pausec[1]                    INTEGER OPTIONAL\n   }\n             with\
    \ patimestamp containing the client's time and pausec\n             containing\
    \ the microseconds which may be omitted if a\n             client will not generate\
    \ more than one request per second.\n             The ciphertext (padata-value)\
    \ consists of the PA-ENC-TS-ENC\n             sequence, encrypted using the client's\
    \ secret key.\n             The padata field can also contain information needed\
    \ to\n             help the KDC or the client select the key needed for\n    \
    \         generating or decrypting the response.  This form of the\n         \
    \    padata is useful for supporting the use of certain\n             \"smartcards\"\
    \ with Kerberos.  The details of such extensions\n             are beyond the\
    \ scope of this specification.  See [10] for\n             additional uses of\
    \ this field.\n   padata-type The padata-type element of the padata field indicates\
    \ the\n             way that the padata-value element is to be interpreted.\n\
    \             Negative values of padata-type are reserved for\n             unregistered\
    \ use; non-negative values are used for a\n             registered interpretation\
    \ of the element type.\n   req-body  This field is a placeholder delimiting the\
    \ extent of the\n             remaining fields.  If a checksum is to be calculated\
    \ over\n             the request, it is calculated over an encoding of the KDC-\n\
    \             REQ-BODY sequence which is enclosed within the req-body\n      \
    \       field.\n   kdc-options This field appears in the KRB_AS_REQ and KRB_TGS_REQ\n\
    \             requests to the KDC and indicates the flags that the client\n  \
    \           wants set on the tickets as well as other information that\n     \
    \        is to modify the behavior of the KDC. Where appropriate,\n          \
    \   the name of an option may be the same as the flag that is\n             set\
    \ by that option.  Although in most case, the bit in the\n             options\
    \ field will be the same as that in the flags field,\n             this is not\
    \ guaranteed, so it is not acceptable to simply\n             copy the options\
    \ field to the flags field.  There are\n             various checks that must\
    \ be made before honoring an option\n             anyway.\n             The kdc_options\
    \ field is a bit-field, where the selected\n             options are indicated\
    \ by the bit being set (1), and the\n             unselected options and reserved\
    \ fields being reset (0).\n             The encoding of the bits is specified\
    \ in section 5.2.  The\n             options are described in more detail above\
    \ in section 2.\n             The meanings of the options are:\n             Bit(s)\
    \  Name         Description\n             0       RESERVED     Reserved for future\
    \ expansion of this\n                                  field.\n             1\
    \       FORWARDABLE  The FORWARDABLE option indicates that\n                 \
    \                 the ticket to be issued is to have its\n                   \
    \               forwardable flag set.  It may only be\n                      \
    \            set on the initial request, or in a\n                           \
    \       subsequent request if the ticket-\n                                  granting\
    \ ticket on which it is based\n                                  is also forwardable.\n\
    \             2       FORWARDED    The FORWARDED option is only specified\n  \
    \                                in a request to the ticket-granting\n       \
    \                           server and will only be honored if the\n         \
    \                         ticket-granting ticket in the request\n            \
    \                      has its FORWARDABLE bit set.  This\n                  \
    \                option indicates that this is a\n                           \
    \       request for forwarding. The\n                                  address(es)\
    \ of the host from which the\n                                  resulting ticket\
    \ is to be valid are\n                                  included in the addresses\
    \ field of the\n                                  request.\n             3   \
    \    PROXIABLE    The PROXIABLE option indicates that\n                      \
    \            the ticket to be issued is to have its\n                        \
    \          proxiable flag set. It may only be set\n                          \
    \        on the initial request, or in a\n                                  subsequent\
    \ request if the ticket-\n                                  granting ticket on\
    \ which it is based\n                                  is also proxiable.\n  \
    \           4       PROXY        The PROXY option indicates that this\n      \
    \                            is a request for a proxy.  This option\n        \
    \                          will only be honored if the ticket-\n             \
    \                     granting ticket in the request has its\n               \
    \                   PROXIABLE bit set.  The address(es) of\n                 \
    \                 the host from which the resulting\n                        \
    \          ticket is to be valid are included in\n                           \
    \       the addresses field of the request.\n             5       ALLOW-POSTDATE\
    \ The ALLOW-POSTDATE option indicates\n                                  that\
    \ the ticket to be issued is to\n                                  have its MAY-POSTDATE\
    \ flag set.  It\n                                  may only be set on the initial\n\
    \                                  request, or in a subsequent request if\n  \
    \                                the ticket-granting ticket on which it\n    \
    \                              is based also has its MAY-POSTDATE\n          \
    \                        flag set.\n             6       POSTDATED    The POSTDATED\
    \ option indicates that\n                                  this is a request for\
    \ a postdated\n                                  ticket.  This option will only\
    \ be\n                                  honored if the ticket-granting ticket\n\
    \                                  on which it is based has its MAY-\n       \
    \                           POSTDATE flag set.  The resulting\n              \
    \                    ticket will also have its INVALID flag\n                \
    \                  set, and that flag may be reset by a\n                    \
    \              subsequent request to the KDC after\n                         \
    \         the starttime in the ticket has been\n                             \
    \     reached.\n             7       UNUSED       This option is presently unused.\n\
    \             8       RENEWABLE    The RENEWABLE option indicates that\n     \
    \                             the ticket to be issued is to have its\n       \
    \                           RENEWABLE flag set.  It may only be\n            \
    \                      set on the initial request, or when\n                 \
    \                 the ticket-granting ticket on which\n                      \
    \            the request is based is also\n                                  renewable.\
    \  If this option is\n                                  requested, then the rtime\
    \ field in the\n                                  request contains the desired\
    \ absolute\n                                  expiration time for the ticket.\n\
    \             9-26    RESERVED     Reserved for future use.\n             27 \
    \     RENEWABLE-OK The RENEWABLE-OK option indicates that\n                  \
    \                a renewable ticket will be acceptable\n                     \
    \             if a ticket with the requested life\n                          \
    \        cannot otherwise be provided.  If a\n                               \
    \   ticket with the requested life cannot\n                                  be\
    \ provided, then a renewable ticket\n                                  may be\
    \ issued with a renew-till equal\n                                  to the the\
    \ requested endtime.  The\n                                  value of the renew-till\
    \ field may\n                                  still be limited by local limits,\
    \ or\n                                  limits selected by the individual\n  \
    \                                principal or server.\n             28      ENC-TKT-IN-SKEY\
    \ This option is used only by the\n                                  ticket-granting\
    \ service.  The ENC-\n                                  TKT-IN-SKEY option indicates\
    \ that the\n                                  ticket for the end server is to\
    \ be\n                                  encrypted in the session key from the\n\
    \                                  additional ticket-granting ticket\n       \
    \                           provided.\n             29      RESERVED     Reserved\
    \ for future use.\n             30      RENEW        This option is used only\
    \ by the\n                                  ticket-granting service.  The RENEW\n\
    \                                  option indicates that the present\n       \
    \                           request is for a renewal.  The ticket\n          \
    \                        provided is encrypted in the secret\n               \
    \                   key for the server on which it is\n                      \
    \            valid.  This option will only be\n                              \
    \    honored if the ticket to be renewed\n                                  has\
    \ its RENEWABLE flag set and if the\n                                  time in\
    \ its renew till field has not\n                                  passed.  The\
    \ ticket to be renewed is\n                                  passed in the padata\
    \ field as part of\n                                  the authentication header.\n\
    \             31      VALIDATE     This option is used only by the\n         \
    \                         ticket-granting service.  The VALIDATE\n           \
    \                       option indicates that the request is\n               \
    \                   to validate a postdated ticket.  It\n                    \
    \              will only be honored if the ticket\n                          \
    \        presented is postdated, presently has\n                             \
    \     its INVALID flag set, and would be\n                                  otherwise\
    \ usable at this time.  A\n                                  ticket cannot be\
    \ validated before its\n                                  starttime.  The ticket\
    \ presented for\n                                  validation is encrypted in\
    \ the key of\n                                  the server for which it is valid\
    \ and\n                                  is passed in the padata field as part\n\
    \                                  of the authentication header.\n   cname and\
    \ sname These fields are the same as those described for the\n             ticket\
    \ in section 5.3.1.  sname may only be absent when the\n             ENC-TKT-IN-SKEY\
    \ option is specified.  If absent, the name\n             of the server is taken\
    \ from the name of the client in the\n             ticket passed as additional-tickets.\n\
    \   enc-authorization-data The enc-authorization-data, if present (and it\n  \
    \           can only be present in the TGS_REQ form), is an encoding of\n    \
    \         the desired authorization-data encrypted under the sub-\n          \
    \   session key if present in the Authenticator, or\n             alternatively\
    \ from the session key in the ticket-granting\n             ticket, both from\
    \ the padata field in the KRB_AP_REQ.\n   realm     This field specifies the realm\
    \ part of the server's\n             principal identifier. In the AS exchange,\
    \ this is also the\n             realm part of the client's principal identifier.\n\
    \   from      This field is included in the KRB_AS_REQ and KRB_TGS_REQ\n     \
    \        ticket requests when the requested ticket is to be\n             postdated.\
    \  It specifies the desired start time for the\n             requested ticket.\n\
    \   till      This field contains the expiration date requested by the\n     \
    \        client in a ticket request.\n   rtime     This field is the requested\
    \ renew-till time sent from a\n             client to the KDC in a ticket request.\
    \  It is optional.\n   nonce     This field is part of the KDC request and response.\
    \  It it\n             intended to hold a random number generated by the client.\n\
    \             If the same number is included in the encrypted response\n     \
    \        from the KDC, it provides evidence that the response is\n           \
    \  fresh and has not been replayed by an attacker.  Nonces\n             must\
    \ never be re-used.  Ideally, it should be gen erated\n             randomly,\
    \ but if the correct time is known, it may suffice\n             (Note, however,\
    \ that if the time is used as the nonce, one\n             must make sure that\
    \ the workstation time is monotonically\n             increasing.  If the time\
    \ is ever reset backwards, there is\n             a small, but finite, probability\
    \ that a nonce will be\n             reused.).\n   etype     This field specifies\
    \ the desired encryption algorithm to be\n             used in the response.\n\
    \   addresses This field is included in the initial request for tickets,\n   \
    \          and optionally included in requests for additional tickets\n      \
    \       from the ticket-granting server.  It specifies the\n             addresses\
    \ from which the requested ticket is to be valid.\n             Normally it includes\
    \ the addresses for the client's host.\n             If a proxy is requested,\
    \ this field will contain other\n             addresses.  The contents of this\
    \ field are usually copied\n             by the KDC into the caddr field of the\
    \ resulting ticket.\n   additional-tickets Additional tickets may be optionally\
    \ included in a\n             request to the ticket-granting server.  If the ENC-TKT-IN-\n\
    \             SKEY option has been specified, then the session key from\n    \
    \         the additional ticket will be used in place of the server's\n      \
    \       key to encrypt the new ticket.  If more than one option\n            \
    \ which requires additional tickets has been specified, then\n             the\
    \ additional tickets are used in the order specified by\n             the ordering\
    \ of the options bits (see kdc-options, above).\n   The application code will\
    \ be either ten (10) or twelve (12) depending\n   on whether the request is for\
    \ an initial ticket (AS-REQ) or for an\n   additional ticket (TGS-REQ).\n   The\
    \ optional fields (addresses, authorization-data and additional-\n   tickets)\
    \ are only included if necessary to perform the operation\n   specified in the\
    \ kdc-options field.\n   It should be noted that in KRB_TGS_REQ, the protocol\
    \ version number\n   appears twice and two different message types appear: the\
    \ KRB_TGS_REQ\n   message contains these fields as does the authentication header\n\
    \   (KRB_AP_REQ) that is passed in the padata field.\n"
- title: 5.4.2. KRB_KDC_REP definition
  contents:
  - "5.4.2. KRB_KDC_REP definition\n   The KRB_KDC_REP message format is used for\
    \ the reply from the KDC for\n   either an initial (AS) request or a subsequent\
    \ (TGS) request.  There\n   is no message type for KRB_KDC_REP.  Instead, the\
    \ type will be either\n   KRB_AS_REP or KRB_TGS_REP.  The key used to encrypt\
    \ the ciphertext\n   part of the reply depends on the message type.  For KRB_AS_REP,\
    \ the\n   ciphertext is encrypted in the client's secret key, and the client's\n\
    \   key version number is included in the key version number for the\n   encrypted\
    \ data.  For KRB_TGS_REP, the ciphertext is encrypted in the\n   sub-session key\
    \ from the Authenticator, or if absent, the session key\n   from the ticket-granting\
    \ ticket used in the request.  In that case,\n   no version number will be present\
    \ in the EncryptedData sequence.\n   The KRB_KDC_REP message contains the following\
    \ fields:\n   AS-REP ::=    [APPLICATION 11] KDC-REP\n   TGS-REP ::=   [APPLICATION\
    \ 13] KDC-REP\n   KDC-REP ::=   SEQUENCE {\n                 pvno[0]         \
    \           INTEGER,\n                 msg-type[1]                INTEGER,\n \
    \                padata[2]                  SEQUENCE OF PA-DATA OPTIONAL,\n  \
    \               crealm[3]                  Realm,\n                 cname[4] \
    \                  PrincipalName,\n                 ticket[5]                \
    \  Ticket,\n                 enc-part[6]                EncryptedData\n   }\n\
    \   EncASRepPart ::=    [APPLICATION 25[25]] EncKDCRepPart\n   EncTGSRepPart ::=\
    \   [APPLICATION 26] EncKDCRepPart\n   EncKDCRepPart ::=   SEQUENCE {\n      \
    \         key[0]                       EncryptionKey,\n               last-req[1]\
    \                  LastReq,\n               nonce[2]                     INTEGER,\n\
    \               key-expiration[3]            KerberosTime OPTIONAL,\n        \
    \       flags[4]                     TicketFlags,\n               authtime[5]\
    \                  KerberosTime,\n               starttime[6]                \
    \ KerberosTime OPTIONAL,\n               endtime[7]                   KerberosTime,\n\
    \               renew-till[8]                KerberosTime OPTIONAL,\n        \
    \       srealm[9]                    Realm,\n               sname[10]        \
    \            PrincipalName,\n               caddr[11]                    HostAddresses\
    \ OPTIONAL\n   }\n   NOTE: In EncASRepPart, the application code in the encrypted\n\
    \         part of a message provides an additional check that\n         the message\
    \ was decrypted properly.\n   pvno and msg-type These fields are described above\
    \ in section 5.4.1.\n             msg-type is either KRB_AS_REP or KRB_TGS_REP.\n\
    \   padata    This field is described in detail in section 5.4.1.  One\n     \
    \        possible use for this field is to encode an alternate\n             \"\
    mix-in\" string to be used with a string-to-key algorithm\n             (such\
    \ as is described in section 6.3.2). This ability is\n             useful to ease\
    \ transitions if a realm name needs to change\n             (e.g., when a company\
    \ is acquired); in such a case all\n             existing password-derived entries\
    \ in the KDC database would\n             be flagged as needing a special mix-in\
    \ string until the\n             next password change.\n   crealm, cname, srealm\
    \ and sname These fields are the same as those\n             described for the\
    \ ticket in section 5.3.1.\n   ticket    The newly-issued ticket, from section\
    \ 5.3.1.\n   enc-part  This field is a place holder for the ciphertext and related\n\
    \             information that forms the encrypted part of a message.\n      \
    \       The description of the encrypted part of the message\n             follows\
    \ each appearance of this field.  The encrypted part\n             is encoded\
    \ as described in section 6.1.\n   key       This field is the same as described\
    \ for the ticket in\n             section 5.3.1.\n   last-req  This field is returned\
    \ by the KDC and specifies the time(s)\n             of the last request by a\
    \ principal.  Depending on what\n             information is available, this might\
    \ be the last time that\n             a request for a ticket-granting ticket was\
    \ made, or the\n             last time that a request based on a ticket-granting\
    \ ticket\n             was successful.  It also might cover all servers for a\n\
    \             realm, or just the particular server. Some implementations\n   \
    \          may display this information to the user to aid in\n             discovering\
    \ unauthorized use of one's identity.  It is\n             similar in spirit to\
    \ the last login time displayed when\n             logging into timesharing systems.\n\
    \   nonce     This field is described above in section 5.4.1.\n   key-expiration\
    \ The key-expiration field is part of the response from\n             the KDC\
    \ and specifies the time that the client's secret key\n             is due to\
    \ expire.  The expiration might be the result of\n             password aging\
    \ or an account expiration.  This field will\n             usually be left out\
    \ of the TGS reply since the response to\n             the TGS request is encrypted\
    \ in a session key and no client\n             information need be retrieved from\
    \ the KDC database.  It is\n             up to the application client (usually\
    \ the login program) to\n             take appropriate action (such as notifying\
    \ the user) if the\n             expira    tion time is imminent.\n   flags, authtime,\
    \ starttime, endtime, renew-till and caddr These\n             fields are duplicates\
    \ of those found in the encrypted\n             portion of the attached ticket\
    \ (see section 5.3.1),\n             provided so the client may verify they match\
    \ the intended\n             request and to assist in proper ticket caching. \
    \ If the\n             message is of type KRB_TGS_REP, the caddr field will only\n\
    \             be filled in if the request was for a proxy or forwarded\n     \
    \        ticket, or if the user is substituting a subset of the\n            \
    \ addresses from the ticket granting ticket.  If the client-\n             requested\
    \ addresses are not present or not used, then the\n             addresses contained\
    \ in the ticket will be the same as those\n             included in the ticket-granting\
    \ ticket.\n"
- title: 5.5.  Client/Server (CS) message specifications
  contents:
  - "5.5.  Client/Server (CS) message specifications\n   This section specifies the\
    \ format of the messages used for the\n   authentication of the client to the\
    \ application server.\n"
- title: 5.5.1. KRB_AP_REQ definition
  contents:
  - "5.5.1. KRB_AP_REQ definition\n   The KRB_AP_REQ message contains the Kerberos\
    \ protocol version number,\n   the message type KRB_AP_REQ, an options field to\
    \ indicate any options\n   in use, and the ticket and authenticator themselves.\
    \  The KRB_AP_REQ\n   message is often referred to as the \"authentication header\"\
    .\n   AP-REQ ::=      [APPLICATION 14] SEQUENCE {\n                   pvno[0]\
    \                       INTEGER,\n                   msg-type[1]             \
    \      INTEGER,\n                   ap-options[2]                 APOptions,\n\
    \                   ticket[3]                     Ticket,\n                  \
    \ authenticator[4]              EncryptedData\n   }\n   APOptions ::=   BIT STRING\
    \ {\n                   reserved(0),\n                   use-session-key(1),\n\
    \                   mutual-required(2)\n   }\n   pvno and msg-type These fields\
    \ are described above in section 5.4.1.\n             msg-type is KRB_AP_REQ.\n\
    \   ap-options This field appears in the application request (KRB_AP_REQ)\n  \
    \           and affects the way the request is processed.  It is a\n         \
    \    bit-field, where the selected options are indicated by the\n            \
    \ bit being set (1), and the unselected options and reserved\n             fields\
    \ being reset (0).  The encoding of the bits is\n             specified in section\
    \ 5.2.  The meanings of the options are:\n             Bit(s)  Name          \
    \ Description\n             0       RESERVED       Reserved for future expansion\
    \ of\n                                  this field.\n             1       USE-SESSION-KEYThe\
    \ USE-SESSION-KEY option indicates\n                                  that the\
    \ ticket the client is\n                                  presenting to a server\
    \ is encrypted in\n                                  the session key from the\
    \ server's\n                                  ticket-granting ticket. When this\n\
    \                                  option is not specified, the ticket is\n  \
    \                                encrypted in the server's secret key.\n     \
    \        2       MUTUAL-REQUIREDThe MUTUAL-REQUIRED option tells the\n       \
    \                           server that the client requires mutual\n         \
    \                         authentication, and that it must\n                 \
    \                 respond with a KRB_AP_REP message.\n             3-31    RESERVED\
    \       Reserved for future use.\n   ticket    This field is a ticket authenticating\
    \ the client to the\n             server.\n   authenticator This contains the\
    \ authenticator, which includes the\n             client's choice of a subkey.\
    \  Its encoding is described in\n             section 5.3.2.\n"
- title: 5.5.2.  KRB_AP_REP definition
  contents:
  - "5.5.2.  KRB_AP_REP definition\n   The KRB_AP_REP message contains the Kerberos\
    \ protocol version number,\n   the message type, and an encrypted timestamp. The\
    \ message is sent in\n   in response to an application request (KRB_AP_REQ) where\
    \ the mutual\n   authentication option has been selected in the ap-options field.\n\
    \   AP-REP ::=         [APPLICATION 15] SEQUENCE {\n              pvno[0]    \
    \               INTEGER,\n              msg-type[1]               INTEGER,\n \
    \             enc-part[2]               EncryptedData\n   }\n   EncAPRepPart ::=\
    \   [APPLICATION 27]     SEQUENCE {\n              ctime[0]                  KerberosTime,\n\
    \              cusec[1]                  INTEGER,\n              subkey[2]   \
    \              EncryptionKey OPTIONAL,\n              seq-number[3]          \
    \   INTEGER OPTIONAL\n   }\n   NOTE: in EncAPRepPart, the application code in\
    \ the encrypted part of\n   a message provides an additional check that the message\
    \ was decrypted\n   properly.\n   The encoded EncAPRepPart is encrypted in the\
    \ shared session key of\n   the ticket.  The optional subkey field can be used\
    \ in an\n   application-arranged negotiation to choose a per association session\n\
    \   key.\n   pvno and msg-type These fields are described above in section 5.4.1.\n\
    \             msg-type is KRB_AP_REP.\n   enc-part  This field is described above\
    \ in section 5.4.2.\n   ctime     This field contains the current time on the\
    \ client's host.\n   cusec     This field contains the microsecond part of the\
    \ client's\n             timestamp.\n   subkey    This field contains an encryption\
    \ key which is to be used\n             to protect this specific application session.\
    \  See section\n             3.2.6 for specifics on how this field is used to\
    \ negotiate\n             a key.  Unless an application specifies otherwise, if\
    \ this\n             field is left out, the sub-session key from the\n       \
    \      authenticator, or if also left out, the session key from\n            \
    \ the ticket will be used.\n"
- title: 5.5.3. Error message reply
  contents:
  - "5.5.3. Error message reply\n   If an error occurs while processing the application\
    \ request, the\n   KRB_ERROR message will be sent in response.  See section 5.9.1\
    \ for\n   the format of the error message.  The cname and crealm fields may be\n\
    \   left out if the server cannot determine their appropriate values from\n  \
    \ the corresponding KRB_AP_REQ message.  If the authenticator was\n   decipherable,\
    \ the ctime and cusec fields will contain the values from\n   it.\n"
- title: 5.6.  KRB_SAFE message specification
  contents:
  - "5.6.  KRB_SAFE message specification\n   This section specifies the format of\
    \ a message that can be used by\n   either side (client or server) of an application\
    \ to send a tamper-\n   proof message to its peer. It presumes that a session\
    \ key has\n   previously been exchanged (for example, by using the\n   KRB_AP_REQ/KRB_AP_REP\
    \ messages).\n"
- title: 5.6.1. KRB_SAFE definition
  contents:
  - "5.6.1. KRB_SAFE definition\n   The KRB_SAFE message contains user data along\
    \ with a collision-proof\n   checksum keyed with the session key.  The message\
    \ fields are:\n   KRB-SAFE ::=        [APPLICATION 20] SEQUENCE {\n          \
    \     pvno[0]               INTEGER,\n               msg-type[1]           INTEGER,\n\
    \               safe-body[2]          KRB-SAFE-BODY,\n               cksum[3]\
    \              Checksum\n   }\n   KRB-SAFE-BODY ::=   SEQUENCE {\n           \
    \    user-data[0]          OCTET STRING,\n               timestamp[1]        \
    \  KerberosTime OPTIONAL,\n               usec[2]               INTEGER OPTIONAL,\n\
    \               seq-number[3]         INTEGER OPTIONAL,\n               s-address[4]\
    \          HostAddress,\n               r-address[5]          HostAddress OPTIONAL\n\
    \   }\n   pvno and msg-type These fields are described above in section 5.4.1.\n\
    \             msg-type is KRB_SAFE.\n   safe-body This field is a placeholder\
    \ for the body of the KRB-SAFE\n             message.  It is to be encoded separately\
    \ and then have the\n             checksum computed over it, for use in the cksum\
    \ field.\n   cksum     This field contains the checksum of the application data.\n\
    \             Checksum details are described in section 6.4.  The\n          \
    \   checksum is computed over the encoding of the KRB-SAFE-BODY\n            \
    \ sequence.\n   user-data This field is part of the KRB_SAFE and KRB_PRIV messages\n\
    \             and contain the application specific data that is being\n      \
    \       passed from the sender to the recipient.\n   timestamp This field is part\
    \ of the KRB_SAFE and KRB_PRIV messages.\n             Its contents are the current\
    \ time as known by the sender of\n             the message. By checking the timestamp,\
    \ the recipient of\n             the message is able to make sure that it was\
    \ recently\n             generated, and is not a replay.\n   usec      This field\
    \ is part of the KRB_SAFE and KRB_PRIV headers.\n             It contains the\
    \ microsecond part of the timestamp.\n   seq-number This field is described above\
    \ in section 5.3.2.\n   s-address This field specifies the address in use by the\
    \ sender of\n             the message.\n   r-address This field specifies the\
    \ address in use by the recipient of\n             the message.  It may be omitted\
    \ for some uses (such as\n             broadcast protocols), but the recipient\
    \ may arbitrarily\n             reject such messages.  This field along with s-address\
    \ can\n             be used to help detect messages which have been incorrectly\n\
    \             or maliciously delivered to the wrong recipient.\n"
- title: 5.7.  KRB_PRIV message specification
  contents:
  - "5.7.  KRB_PRIV message specification\n   This section specifies the format of\
    \ a message that can be used by\n   either side (client or server) of an application\
    \ to securely and\n   privately send a message to its peer.  It presumes that\
    \ a session key\n   has previously been exchanged (for example, by using the\n\
    \   KRB_AP_REQ/KRB_AP_REP messages).\n"
- title: 5.7.1. KRB_PRIV definition
  contents:
  - "5.7.1. KRB_PRIV definition\n   The KRB_PRIV message contains user data encrypted\
    \ in the Session Key.\n   The message fields are:\n   KRB-PRIV ::=         [APPLICATION\
    \ 21] SEQUENCE {\n                pvno[0]                   INTEGER,\n       \
    \         msg-type[1]               INTEGER,\n                enc-part[3]    \
    \           EncryptedData\n   }\n   EncKrbPrivPart ::=   [APPLICATION 28] SEQUENCE\
    \ {\n                user-data[0]              OCTET STRING,\n               \
    \ timestamp[1]              KerberosTime OPTIONAL,\n                usec[2]  \
    \                 INTEGER OPTIONAL,\n                seq-number[3]           \
    \  INTEGER OPTIONAL,\n                s-address[4]              HostAddress, --\
    \ sender's addr\n                r-address[5]              HostAddress OPTIONAL\n\
    \                                                      -- recip's addr\n   }\n\
    \   NOTE: In EncKrbPrivPart, the application code in the encrypted part\n   of\
    \ a message provides an additional check that the message was\n   decrypted properly.\n\
    \   pvno and msg-type These fields are described above in section 5.4.1.\n   \
    \          msg-type is KRB_PRIV.\n   enc-part  This field holds an encoding of\
    \ the EncKrbPrivPart sequence\n             encrypted under the session key (If\
    \ supported by the\n             encryption method in use, an initialization vector\
    \ may be\n             passed to the encryption procedure, in order to achieve\n\
    \             proper cipher chaining.  The initialization vector might\n     \
    \        come from the last block of the ciphertext from the\n             previous\
    \ KRB_PRIV message, but it is the application's\n             choice whether or\
    \ not to use such an initialization vector.\n             If left out, the default\
    \ initialization vector for the\n             encryption algorithm will be used.).\
    \  This encrypted\n             encoding is used for the enc-part field of the\
    \ KRB-PRIV\n             message.  See section 6 for the format of the ciphertext.\n\
    \   user-data, timestamp, usec, s-address and r-address These fields are\n   \
    \          described above in section 5.6.1.\n   seq-number This field is described\
    \ above in section 5.3.2.\n"
- title: 5.8.  KRB_CRED message specification
  contents:
  - "5.8.  KRB_CRED message specification\n   This section specifies the format of\
    \ a message that can be used to\n   send Kerberos credentials from one principal\
    \ to another.  It is\n   presented here to encourage a common mechanism to be\
    \ used by\n   applications when forwarding tickets or providing proxies to\n \
    \  subordinate servers.  It presumes that a session key has already been\n   exchanged\
    \ perhaps by using the KRB_AP_REQ/KRB_AP_REP messages.\n"
- title: 5.8.1. KRB_CRED definition
  contents:
  - "5.8.1. KRB_CRED definition\n   The KRB_CRED message contains a sequence of tickets\
    \ to be sent and\n   information needed to use the tickets, including the session\
    \ key from\n   each.  The information needed to use the tickets is encryped under\
    \ an\n   encryption key previously exchanged.  The message fields are:\n   KRB-CRED\
    \         ::= [APPLICATION 22]   SEQUENCE {\n                    pvno[0]     \
    \           INTEGER,\n                    msg-type[1]            INTEGER, -- KRB_CRED\n\
    \                    tickets[2]             SEQUENCE OF Ticket,\n            \
    \        enc-part[3]            EncryptedData\n   }\n   EncKrbCredPart   ::= [APPLICATION\
    \ 29]   SEQUENCE {\n                    ticket-info[0]         SEQUENCE OF KrbCredInfo,\n\
    \                    nonce[1]               INTEGER OPTIONAL,\n              \
    \      timestamp[2]           KerberosTime OPTIONAL,\n                    usec[3]\
    \                INTEGER OPTIONAL,\n                    s-address[4]         \
    \  HostAddress OPTIONAL,\n                    r-address[5]           HostAddress\
    \ OPTIONAL\n   }\n   KrbCredInfo      ::=                    SEQUENCE {\n    \
    \                key[0]                 EncryptionKey,\n                    prealm[1]\
    \              Realm OPTIONAL,\n                    pname[2]               PrincipalName\
    \ OPTIONAL,\n                    flags[3]               TicketFlags OPTIONAL,\n\
    \                    authtime[4]            KerberosTime OPTIONAL,\n         \
    \           starttime[5]           KerberosTime OPTIONAL,\n                  \
    \  endtime[6]             KerberosTime OPTIONAL\n                    renew-till[7]\
    \          KerberosTime OPTIONAL,\n                    srealm[8]             \
    \ Realm OPTIONAL,\n                    sname[9]               PrincipalName OPTIONAL,\n\
    \                    caddr[10]              HostAddresses OPTIONAL\n   }\n   pvno\
    \ and msg-type These fields are described above in section 5.4.1.\n          \
    \   msg-type is KRB_CRED.\n   tickets\n               These are the tickets obtained\
    \ from the KDC specifically\n             for use by the intended recipient. \
    \ Successive tickets are\n             paired with the corresponding KrbCredInfo\
    \ sequence from the\n             enc-part of the KRB-CRED message.\n   enc-part\
    \  This field holds an encoding of the EncKrbCredPart sequence\n             encrypted\
    \ under the session key shared between the sender\n             and the intended\
    \ recipient.  This encrypted encoding is\n             used for the enc-part field\
    \ of the KRB-CRED message.  See\n             section 6 for the format of the\
    \ ciphertext.\n   nonce     If practical, an application may require the inclusion\
    \ of a\n             nonce generated by the recipient of the message. If the\n\
    \             same value is included as the nonce in the message, it\n       \
    \      provides evidence that the message is fresh and has not\n             been\
    \ replayed by an attacker.  A nonce must never be re-\n             used; it should\
    \ be generated randomly by the recipient of\n             the message and provided\
    \ to the sender of the mes  sage in\n             an application specific manner.\n\
    \   timestamp and usec These fields specify the time that the KRB-CRED\n     \
    \        message was generated.  The time is used to provide\n             assurance\
    \ that the message is fresh.\n   s-address and r-address These fields are described\
    \ above in section\n             5.6.1.  They are used optionally to provide additional\n\
    \             assurance of the integrity of the KRB-CRED message.\n   key    \
    \   This field exists in the corresponding ticket passed by the\n            \
    \ KRB-CRED message and is used to pass the session key from\n             the\
    \ sender to the intended recipient.  The field's encoding\n             is described\
    \ in section 6.2.\n   The following fields are optional.   If present, they can\
    \ be\n   associated with the credentials in the remote ticket file.  If left\n\
    \   out, then it is assumed that the recipient of the credentials already\n  \
    \ knows their value.\n   prealm and pname The name and realm of the delegated\
    \ principal\n             identity.\n   flags, authtime,  starttime,  endtime,\
    \ renew-till,  srealm, sname,\n             and caddr These fields contain the\
    \ values of the\n             corresponding fields from the ticket found in the\
    \ ticket\n             field.  Descriptions of the fields are identical to the\n\
    \             descriptions in the KDC-REP message.\n"
- title: 5.9.  Error message specification
  contents:
  - "5.9.  Error message specification\n   This section specifies the format for the\
    \ KRB_ERROR message.  The\n   fields included in the message are intended to return\
    \ as much\n   information as possible about an error.  It is not expected that\
    \ all\n   the information required by the fields will be available for all\n \
    \  types of errors.  If the appropriate information is not available\n   when\
    \ the message is composed, the corresponding field will be left\n   out of the\
    \ message.\n   Note that since the KRB_ERROR message is not protected by any\n\
    \   encryption, it is quite possible for an intruder to synthesize or\n   modify\
    \ such a message.  In particular, this means that the client\n   should not use\
    \ any fields in this message for security-critical\n   purposes, such as setting\
    \ a system clock or generating a fresh\n   authenticator.  The message can be\
    \ useful, however, for advising a\n   user on the reason for some failure.\n"
- title: 5.9.1. KRB_ERROR definition
  contents:
  - "5.9.1. KRB_ERROR definition\n   The KRB_ERROR message consists of the following\
    \ fields:\n   KRB-ERROR ::=   [APPLICATION 30] SEQUENCE {\n                  \
    \ pvno[0]               INTEGER,\n                   msg-type[1]           INTEGER,\n\
    \                   ctime[2]              KerberosTime OPTIONAL,\n           \
    \        cusec[3]              INTEGER OPTIONAL,\n                   stime[4]\
    \              KerberosTime,\n                   susec[5]              INTEGER,\n\
    \                   error-code[6]         INTEGER,\n                   crealm[7]\
    \             Realm OPTIONAL,\n                   cname[8]              PrincipalName\
    \ OPTIONAL,\n                   realm[9]              Realm, -- Correct realm\n\
    \                   sname[10]             PrincipalName, -- Correct name\n   \
    \                e-text[11]            GeneralString OPTIONAL,\n             \
    \      e-data[12]            OCTET STRING OPTIONAL\n   }\n   pvno and msg-type\
    \ These fields are described above in section 5.4.1.\n             msg-type is\
    \ KRB_ERROR.\n   ctime     This field is described above in section 5.4.1.\n \
    \  cusec     This field is described above in section 5.5.2.\n   stime     This\
    \ field contains the current time on the server.  It is\n             of type\
    \ KerberosTime.\n   susec     This field contains the microsecond part of the\
    \ server's\n             timestamp.  Its value ranges from 0 to 999. It appears\n\
    \             along with stime. The two fields are used in conjunction to\n  \
    \           specify a reasonably accurate timestamp.\n   error-code This field\
    \ contains the error code returned by Kerberos or\n             the server when\
    \ a request fails.  To interpret the value of\n             this field see the\
    \ list of error codes in section 8.\n             Implementations are encouraged\
    \ to provide for national\n             language support in the display of error\
    \ messages.\n   crealm, cname, srealm and sname These fields are described above\
    \ in\n             section 5.3.1.\n   e-text    This field contains additional\
    \ text to help explain the\n             error code associated with the failed\
    \ request (for example,\n             it might include a principal name which\
    \ was unknown).\n   e-data    This field contains additional data about the error\
    \ for use\n             by the application to help it recover from or handle the\n\
    \             error.  If the errorcode is KDC_ERR_PREAUTH_REQUIRED, then\n   \
    \          the e-data field will contain an encoding of a sequence of\n      \
    \       padata fields, each corresponding to an acceptable pre-\n            \
    \ authentication method and optionally containing data for\n             the method:\n\
    \      METHOD-DATA ::=    SEQUENCE of PA-DATA\n   If the error-code is KRB_AP_ERR_METHOD,\
    \ then the e-data field will\n   contain an encoding of the following sequence:\n\
    \      METHOD-DATA ::=    SEQUENCE {\n                         method-type[0]\
    \   INTEGER,\n                         method-data[1]   OCTET STRING OPTIONAL\n\
    \       }\n   method-type will indicate the required alternate method; method-data\n\
    \   will contain any required additional information.\n"
- title: 6.  Encryption and Checksum Specifications
  contents:
  - "6.  Encryption and Checksum Specifications\n   The Kerberos protocols described\
    \ in this document are designed to use\n   stream encryption ciphers, which can\
    \ be simulated using commonly\n   available block encryption ciphers, such as\
    \ the Data Encryption\n   Standard [11], in conjunction with block chaining and\
    \ checksum\n   methods [12].  Encryption is used to prove the identities of the\n\
    \   network entities participating in message exchanges.  The Key\n   Distribution\
    \ Center for each realm is trusted by all principals\n   registered in that realm\
    \ to store a secret key in confidence.  Proof\n   of knowledge of this secret\
    \ key is used to verify the authenticity of\n   a principal.\n   The KDC uses\
    \ the principal's secret key (in the AS exchange) or a\n   shared session key\
    \ (in the TGS exchange) to encrypt responses to\n   ticket requests; the ability\
    \ to obtain the secret key or session key\n   implies the knowledge of the appropriate\
    \ keys and the identity of the\n   KDC. The ability of a principal to decrypt\
    \ the KDC response and\n   present a Ticket and a properly formed Authenticator\
    \ (generated with\n   the session key from the KDC response) to a service verifies\
    \ the\n   identity of the principal; likewise the ability of the service to\n\
    \   extract the session key from the Ticket and prove its knowledge\n   thereof\
    \ in a response verifies the identity of the service.\n   The Kerberos protocols\
    \ generally assume that the encryption used is\n   secure from cryptanalysis;\
    \ however, in some cases, the order of\n   fields in the encrypted portions of\
    \ messages are arranged to minimize\n   the effects of poorly chosen keys.  It\
    \ is still important to choose\n   good keys.  If keys are derived from user-typed\
    \ passwords, those\n   passwords need to be well chosen to make brute force attacks\
    \ more\n   difficult.  Poorly chosen keys still make easy targets for intruders.\n\
    \   The following sections specify the encryption and checksum mechanisms\n  \
    \ currently defined for Kerberos.  The encodings, chaining, and padding\n   requirements\
    \ for each are described.  For encryption methods, it is\n   often desirable to\
    \ place random information (often referred to as a\n   confounder) at the start\
    \ of the message.  The requirements for a\n   confounder are specified with each\
    \ encryption mechanism.\n   Some encryption systems use a block-chaining method\
    \ to improve the\n   the security characteristics of the ciphertext.  However,\
    \ these\n   chaining methods often don't provide an integrity check upon\n   decryption.\
    \  Such systems (such as DES in CBC mode) must be augmented\n   with a checksum\
    \ of the plaintext which can be verified at decryption\n   and used to detect\
    \ any tampering or damage.  Such checksums should be\n   good at detecting burst\
    \ errors in the input.  If any damage is\n   detected, the decryption routine\
    \ is expected to return an error\n   indicating the failure of an integrity check.\
    \ Each encryption type is\n   expected to provide and verify an appropriate checksum.\
    \ The\n   specification of each encryption method sets out its checksum\n   requirements.\n\
    \   Finally, where a key is to be derived from a user's password, an\n   algorithm\
    \ for converting the password to a key of the appropriate\n   type is included.\
    \  It is desirable for the string to key function to\n   be one-way, and for the\
    \ mapping to be different in different realms.\n   This is important because users\
    \ who are registered in more than one\n   realm will often use the same password\
    \ in each, and it is desirable\n   that an attacker compromising the Kerberos\
    \ server in one realm not\n   obtain or derive the user's key in another.\n  \
    \ For a discussion of the integrity characteristics of the candidate\n   encryption\
    \ and checksum methods considered for Kerberos, the the\n   reader is referred\
    \ to [13].\n"
- title: 6.1.  Encryption Specifications
  contents:
  - "6.1.  Encryption Specifications\n   The following ASN.1 definition describes\
    \ all encrypted messages.  The\n   enc-part field which appears in the unencrypted\
    \ part of messages in\n   section 5 is a sequence consisting of an encryption\
    \ type, an optional\n   key version number, and the ciphertext.\n   EncryptedData\
    \ ::=   SEQUENCE {\n                       etype[0]     INTEGER, -- EncryptionType\n\
    \                       kvno[1]      INTEGER OPTIONAL,\n                     \
    \  cipher[2]    OCTET STRING -- ciphertext\n   }\n   etype     This field identifies\
    \ which encryption algorithm was used\n             to encipher the cipher.  Detailed\
    \ specifications for\n             selected encryption types appear later in this\
    \ section.\n   kvno      This field contains the version number of the key under\n\
    \             which data is encrypted.  It is only present in messages\n     \
    \        encrypted under long lasting keys, such as principals'\n            \
    \ secret keys.\n   cipher    This field contains the enciphered text, encoded\
    \ as an\n             OCTET STRING.\n   The cipher field is generated by applying\
    \ the specified encryption\n   algorithm to data composed of the message and algorithm-specific\n\
    \   inputs.  Encryption mechanisms defined for use with Kerberos must\n   take\
    \ sufficient measures to guarantee the integrity of the plaintext,\n   and we\
    \ recommend they also take measures to protect against\n   precomputed dictionary\
    \ attacks.  If the encryption algorithm is not\n   itself capable of doing so,\
    \ the protections can often be enhanced by\n   adding a checksum and a confounder.\n\
    \   The suggested format for the data to be encrypted includes a\n   confounder,\
    \ a checksum, the encoded plaintext, and any necessary\n   padding.  The msg-seq\
    \ field contains the part of the protocol message\n   described in section 5 which\
    \ is to be encrypted.  The confounder,\n   checksum, and padding are all untagged\
    \ and untyped, and their length\n   is exactly sufficient to hold the appropriate\
    \ item.  The type and\n   length is implicit and specified by the particular encryption\
    \ type\n   being used (etype).  The format for the data to be encrypted is\n \
    \  described in the following diagram:\n         +-----------+----------+-------------+-----+\n\
    \         |confounder |   check  |   msg-seq   | pad |\n         +-----------+----------+-------------+-----+\n\
    \   The format cannot be described in ASN.1, but for those who prefer an\n   ASN.1-like\
    \ notation:\n"
- title: CipherText ::=   ENCRYPTED       SEQUENCE {
  contents:
  - "CipherText ::=   ENCRYPTED       SEQUENCE {\n         confounder[0]   UNTAGGED\
    \ OCTET STRING(conf_length)     OPTIONAL,\n         check[1]        UNTAGGED OCTET\
    \ STRING(checksum_length) OPTIONAL,\n         msg-seq[2]      MsgSequence,\n \
    \        pad             UNTAGGED OCTET STRING(pad_length) OPTIONAL\n"
- title: '}'
  contents:
  - "}\n   In the above specification, UNTAGGED OCTET STRING(length) is the\n   notation\
    \ for an octet string with its tag and length removed.  It is\n   not a valid\
    \ ASN.1 type.  The tag bits and length must be removed from\n   the confounder\
    \ since the purpose of the confounder is so that the\n   message starts with random\
    \ data, but the tag and its length are\n   fixed.  For other fields, the length\
    \ and tag would be redundant if\n   they were included because they are specified\
    \ by the encryption type.\n   One generates a random confounder of the appropriate\
    \ length, placing\n   it in confounder; zeroes out check; calculates the appropriate\n\
    \   checksum over confounder, check, and msg-seq, placing the result in\n   check;\
    \ adds the necessary padding; then encrypts using the specified\n   encryption\
    \ type and the appropriate key.\n   Unless otherwise specified, a definition of\
    \ an encryption algorithm\n   that specifies a checksum, a length for the confounder\
    \ field, or an\n   octet boundary for padding uses this ciphertext format (The\
    \ ordering\n   of the fields in the CipherText is important.  Additionally, messages\n\
    \   encoded in this format must include a length as part of the msg-seq\n   field.\
    \  This allows the recipient to verify that the message has not\n   been truncated.\
    \  Without a length, an attacker could use a chosen\n   plaintext attack to generate\
    \ a message which could be truncated,\n   while leaving the checksum intact. \
    \ Note that if the msg-seq is an\n   encoding of an ASN.1 SEQUENCE or OCTET STRING,\
    \ then the length is\n   part of that encoding.). Those fields which are not specified\
    \ will be\n   omitted.\n   In the interest of allowing all implementations using\
    \ a particular\n   encryption type to communicate with all others using that type,\
    \ the\n   specification of an encryption type defines any checksum that is\n \
    \  needed as part of the encryption process.  If an alternative checksum\n   is\
    \ to be used, a new encryption type must be defined.\n   Some cryptosystems require\
    \ additional information beyond the key and\n   the data to be encrypted. For\
    \ example, DES, when used in cipher-\n   block-chaining mode, requires an initialization\
    \ vector.  If required,\n   the description for each encryption type must specify\
    \ the source of\n   such additional information.\n"
- title: 6.2.  Encryption Keys
  contents:
  - "6.2.  Encryption Keys\n   The sequence below shows the encoding of an encryption\
    \ key:\n          EncryptionKey ::=   SEQUENCE {\n                           \
    \   keytype[0]    INTEGER,\n                              keyvalue[1]   OCTET\
    \ STRING\n          }\n   keytype   This field specifies the type of encryption\
    \ key that\n             follows in the keyvalue field.  It will almost always\n\
    \             correspond to the encryption algorithm used to generate the\n  \
    \           EncryptedData, though more than one algorithm may use the\n      \
    \       same type of key (the mapping is many to one).  This might\n         \
    \    happen, for example, if the encryption algorithm uses an\n             alternate\
    \ checksum algorithm for an integrity check, or a\n             different chaining\
    \ mechanism.\n   keyvalue  This field contains the key itself, encoded as an octet\n\
    \             string.\n   All negative values for the  encryption key type are\
    \ reserved for\n   local use.  All non-negative values are reserved for officially\n\
    \   assigned type fields and interpretations.\n"
- title: 6.3.  Encryption Systems
  contents:
  - '6.3.  Encryption Systems

    '
- title: 6.3.1. The NULL Encryption System (null)
  contents:
  - "6.3.1. The NULL Encryption System (null)\n   If no encryption is in use, the\
    \ encryption system is said to be the\n   NULL encryption system.  In the NULL\
    \ encryption system there is no\n   checksum, confounder or padding.  The ciphertext\
    \ is simply the\n   plaintext.  The NULL Key is used by the null encryption system\
    \ and is\n   zero octets in length, with keytype zero (0).\n"
- title: 6.3.2. DES in CBC mode with a CRC-32 checksum (des-cbc-crc)
  contents:
  - "6.3.2. DES in CBC mode with a CRC-32 checksum (des-cbc-crc)\n   The des-cbc-crc\
    \ encryption mode encrypts information under the Data\n   Encryption Standard\
    \ [11] using the cipher block chaining mode [12].\n   A CRC-32 checksum (described\
    \ in ISO 3309 [14]) is applied to the\n   confounder and message sequence (msg-seq)\
    \ and placed in the cksum\n   field.  DES blocks are 8 bytes.  As a result, the\
    \ data to be\n   encrypted (the concatenation of confounder, checksum, and message)\n\
    \   must be padded to an 8 byte boundary before encryption.  The details\n   of\
    \ the encryption of this data are identical to those for the des-\n   cbc-md5\
    \ encryption mode.\n   Note that, since the CRC-32 checksum is not collisionproof,\
    \ an\n   attacker could use a probabilistic chosenplaintext attack to generate\n\
    \   a valid message even if a confounder is used [13]. The use of\n   collision-proof\
    \ checksums is recommended for environments where such\n   attacks represent a\
    \ significant threat.  The use of the CRC-32 as the\n   checksum for ticket or\
    \ authenticator is no longer mandated as an\n   interoperability requirement for\
    \ Kerberos Version 5 Specification 1\n   (See section 9.1 for specific details).\n"
- title: 6.3.3. DES in CBC mode with an MD4 checksum (des-cbc-md4)
  contents:
  - "6.3.3. DES in CBC mode with an MD4 checksum (des-cbc-md4)\n   The des-cbc-md4\
    \ encryption mode encrypts information under the Data\n   Encryption Standard\
    \ [11] using the cipher block chaining mode [12].\n   An MD4 checksum (described\
    \ in [15]) is applied to the confounder and\n   message sequence (msg-seq) and\
    \ placed in the cksum field.  DES blocks\n   are 8 bytes.  As a result, the data\
    \ to be encrypted (the\n   concatenation of confounder, checksum, and message)\
    \ must be padded to\n   an 8 byte boundary before encryption.  The details of\
    \ the encryption\n   of this data are identical to those for the descbc-md5 encryption\n\
    \   mode.\n"
- title: 6.3.4. DES in CBC mode with an MD5 checksum (des-cbc-md5)
  contents:
  - "6.3.4. DES in CBC mode with an MD5 checksum (des-cbc-md5)\n   The des-cbc-md5\
    \ encryption mode encrypts information under the Data\n   Encryption Standard\
    \ [11] using the cipher block chaining mode [12].\n   An MD5 checksum (described\
    \ in [16]) is applied to the confounder and\n   message sequence (msg-seq) and\
    \ placed in the cksum field.  DES blocks\n   are 8 bytes.  As a result, the data\
    \ to be encrypted (the\n   concatenation of confounder, checksum, and message)\
    \ must be padded to\n   an 8 byte boundary before encryption.\n   Plaintext and\
    \ DES ciphtertext are encoded as 8-octet blocks which are\n   concatenated to\
    \ make the 64-bit inputs for the DES algorithms.  The\n   first octet supplies\
    \ the 8 most significant bits (with the octet's\n   MSbit used as the DES input\
    \ block's MSbit, etc.), the second octet\n   the next 8 bits, ..., and the eighth\
    \ octet supplies the 8 least\n   significant bits.\n   Encryption under DES using\
    \ cipher block chaining requires an\n   additional input in the form of an initialization\
    \ vector.  Unless\n   otherwise specified, zero should be used as the initialization\n\
    \   vector.  Kerberos' use of DES requires an 8-octet confounder.\n   The DES\
    \ specifications identify some \"weak\" and \"semiweak\" keys;\n   those keys\
    \ shall not be used for encrypting messages for use in\n   Kerberos.  Additionally,\
    \ because of the way that keys are derived for\n   the encryption of checksums,\
    \ keys shall not be used that yield \"weak\"\n   or \"semi-weak\" keys when eXclusive-ORed\
    \ with the constant\n   F0F0F0F0F0F0F0F0.\n   A DES key is 8 octets of data, with\
    \ keytype one (1).  This consists\n   of 56 bits of key, and 8 parity bits (one\
    \ per octet).  The key is\n   encoded as a series of 8 octets written in MSB-first\
    \ order. The bits\n   within the key are also encoded in MSB order.  For example,\
    \ if the\n   encryption key is:\n   (B1,B2,...,B7,P1,B8,...,B14,P2,B15,...,B49,P7,B50,...,B56,P8)\
    \ where\n   B1,B2,...,B56 are the key bits in MSB order, and P1,P2,...,P8 are\
    \ the\n   parity bits, the first octet of the key would be B1,B2,...,B7,P1\n \
    \  (with B1 as the MSbit).  [See the FIPS 81 introduction for\n   reference.]\n\
    \   To generate a DES key from a text string (password), the text string\n   normally\
    \ must have the realm and each component of the principal's\n   name appended(In\
    \ some cases, it may be necessary to use a different\n   \"mix-in\" string for\
    \ compatibility reasons; see the discussion of\n   padata in section 5.4.2.),\
    \ then padded with ASCII nulls to an 8 byte\n   boundary.  This string is then\
    \ fan-folded and eXclusive-ORed with\n   itself to form an 8 byte DES key.  The\
    \ parity is corrected on the\n   key, and it is used to generate a DES CBC checksum\
    \ on the initial\n   string (with the realm and name appended).  Next, parity\
    \ is corrected\n   on the CBC checksum.  If the result matches a \"weak\" or \"\
    semiweak\"\n   key as described in the DES specification, it is eXclusive-ORed\
    \ with\n   the constant 00000000000000F0.  Finally, the result is returned as\n\
    \   the key.  Pseudocode follows:\n        string_to_key(string,realm,name) {\n\
    \             odd = 1;\n             s = string + realm;\n             for(each\
    \ component in name) {\n                  s = s + component;\n             }\n\
    \             tempkey = NULL;\n             pad(s); /* with nulls to 8 byte boundary\
    \ */\n             for(8byteblock in s) {\n                  if(odd == 0)  {\n\
    \                      odd = 1;\n                      reverse(8byteblock)\n \
    \                 }\n                  else odd = 0;\n                  tempkey\
    \ = tempkey XOR 8byteblock;\n             }\n             fixparity(tempkey);\n\
    \             key = DES-CBC-check(s,tempkey);\n             fixparity(key);\n\
    \             if(is_weak_key_key(key))\n                  key = key XOR 0xF0;\n\
    \             return(key);\n        }\n"
- title: 6.4.  Checksums
  contents:
  - "6.4.  Checksums\n   The following is the ASN.1 definition used for a checksum:\n\
    \            Checksum ::=   SEQUENCE {\n                           cksumtype[0]\
    \   INTEGER,\n                           checksum[1]    OCTET STRING\n       \
    \     }\n   cksumtype This field indicates the algorithm used to generate the\n\
    \             accompanying checksum.\n   checksum  This field contains the checksum\
    \ itself, encoded\n             as an octet string.\n   Detailed specification\
    \ of selected checksum types appear later in\n   this section.  Negative values\
    \ for the checksum type are reserved for\n   local use.  All non-negative values\
    \ are reserved for officially\n   assigned type fields and interpretations.\n\
    \   Checksums used by Kerberos can be classified by two properties:\n   whether\
    \ they are collision-proof, and whether they are keyed.  It is\n   infeasible\
    \ to find two plaintexts which generate the same checksum\n   value for a collision-proof\
    \ checksum.  A key is required to perturb\n   or initialize the algorithm in a\
    \ keyed checksum.  To prevent\n   message-stream modification by an active attacker,\
    \ unkeyed checksums\n   should only be used when the checksum and message will\
    \ be\n   subsequently encrypted (e.g., the checksums defined as part of the\n\
    \   encryption algorithms covered earlier in this section).  Collision-\n   proof\
    \ checksums can be made tamper-proof as well if the checksum\n   value is encrypted\
    \ before inclusion in a message.  In such cases, the\n   composition of the checksum\
    \ and the encryption algorithm must be\n   considered a separate checksum algorithm\
    \ (e.g., RSA-MD5 encrypted\n   using DES is a new checksum algorithm of type RSA-MD5-DES).\
    \  For most\n   keyed checksums, as well as for the encrypted forms of collisionproof\n\
    \   checksums, Kerberos prepends a confounder before the checksum is\n   calculated.\n"
- title: 6.4.1. The CRC-32 Checksum (crc32)
  contents:
  - "6.4.1. The CRC-32 Checksum (crc32)\n   The CRC-32 checksum calculates a checksum\
    \ based on a cyclic\n   redundancy check as described in ISO 3309 [14].  The resulting\n\
    \   checksum is four (4) octets in length.  The CRC-32 is neither keyed\n   nor\
    \ collision-proof.  The use of this checksum is not recommended.\n   An attacker\
    \ using a probabilistic chosen-plaintext attack as\n   described in [13] might\
    \ be able to generate an alternative message\n   that satisfies the checksum.\
    \  The use of collision-proof checksums is\n   recommended for environments where\
    \ such attacks represent a\n   significant threat.\n"
- title: 6.4.2. The RSA MD4 Checksum (rsa-md4)
  contents:
  - "6.4.2. The RSA MD4 Checksum (rsa-md4)\n   The RSA-MD4 checksum calculates a checksum\
    \ using the RSA MD4\n   algorithm [15].  The algorithm takes as input an input\
    \ message of\n   arbitrary length and produces as output a 128-bit (16 octet)\n\
    \   checksum.  RSA-MD4 is believed to be collision-proof.\n"
- title: 6.4.3. RSA MD4 Cryptographic Checksum Using DES (rsa-md4des)
  contents:
  - "6.4.3. RSA MD4 Cryptographic Checksum Using DES (rsa-md4des)\n   The RSA-MD4-DES\
    \ checksum calculates a keyed collisionproof checksum\n   by prepending an 8 octet\
    \ confounder before the text, applying the RSA\n   MD4 checksum algorithm, and\
    \ encrypting the confounder and the\n   checksum using DES in cipher-block-chaining\
    \ (CBC) mode using a\n   variant of the key, where the variant is computed by\
    \ eXclusive-ORing\n   the key with the constant F0F0F0F0F0F0F0F0 (A variant of\
    \ the key is\n   used to limit the use of a key to a particular function, separating\n\
    \   the functions of generating a checksum from other encryption\n   performed\
    \ using the session key.  The constant F0F0F0F0F0F0F0F0 was\n   chosen because\
    \ it maintains key parity.  The properties of DES\n   precluded the use of the\
    \ complement.  The same constant is used for\n   similar purpose in the Message\
    \ Integrity Check in the Privacy\n   Enhanced Mail standard.).  The initialization\
    \ vector should be zero.\n   The resulting checksum is 24 octets long (8 octets\
    \ of which are\n   redundant).  This checksum is tamper-proof and believed to\
    \ be\n   collision-proof.\n   The DES specifications identify some \"weak keys\"\
    ; those keys shall\n   not be used for generating RSA-MD4 checksums for use in\
    \ Kerberos.\n   The format for the checksum is described in the following diagram:\n\
    \      +--+--+--+--+--+--+--+--\n      |  des-cbc(confounder\n      +--+--+--+--+--+--+--+--\n\
    \                    +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n     \
    \                   rsa-md4(confounder+msg),key=var(key),iv=0)  |\n          \
    \          +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   The format cannot\
    \ be described in ASN.1, but for those who prefer an\n   ASN.1-like notation:\n\
    \   rsa-md4-des-checksum ::=   ENCRYPTED       UNTAGGED SEQUENCE {\n         \
    \                     confounder[0]   UNTAGGED OCTET STRING(8),\n            \
    \                  check[1]        UNTAGGED OCTET STRING(16)\n   }\n"
- title: 6.4.4. The RSA MD5 Checksum (rsa-md5)
  contents:
  - "6.4.4. The RSA MD5 Checksum (rsa-md5)\n   The RSA-MD5 checksum calculates a checksum\
    \ using the RSA MD5\n   algorithm [16].  The algorithm takes as input an input\
    \ message of\n   arbitrary length and produces as output a 128-bit (16 octet)\n\
    \   checksum.  RSA-MD5 is believed to be collision-proof.\n"
- title: 6.4.5. RSA MD5 Cryptographic Checksum Using DES (rsa-md5des)
  contents:
  - "6.4.5. RSA MD5 Cryptographic Checksum Using DES (rsa-md5des)\n   The RSA-MD5-DES\
    \ checksum calculates a keyed collisionproof checksum\n   by prepending an 8 octet\
    \ confounder before the text, applying the RSA\n   MD5 checksum algorithm, and\
    \ encrypting the confounder and the\n   checksum using DES in cipher-block-chaining\
    \ (CBC) mode using a\n   variant of the key, where the variant is computed by\
    \ eXclusive-ORing\n   the key with the constant F0F0F0F0F0F0F0F0.  The initialization\n\
    \   vector should be zero.  The resulting checksum is 24 octets long (8\n   octets\
    \ of which are redundant).  This checksum is tamper-proof and\n   believed to\
    \ be collision-proof.\n   The DES specifications identify some \"weak keys\";\
    \ those keys shall\n   not be used for encrypting RSA-MD5 checksums for use in\
    \ Kerberos.\n   The format for the checksum is described in the following diagram:\n\
    \      +--+--+--+--+--+--+--+--\n      |  des-cbc(confounder\n      +--+--+--+--+--+--+--+--\n\
    \                     +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n    \
    \                     rsa-md5(confounder+msg),key=var(key),iv=0)  |\n        \
    \             +--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n   The format\
    \ cannot be described in ASN.1, but for those who prefer an\n   ASN.1-like notation:\n\
    \   rsa-md5-des-checksum ::=   ENCRYPTED       UNTAGGED SEQUENCE {\n         \
    \                     confounder[0]   UNTAGGED OCTET STRING(8),\n            \
    \                  check[1]        UNTAGGED OCTET STRING(16)\n   }\n"
- title: 6.4.6. DES cipher-block chained checksum (des-mac)
  contents:
  - "6.4.6. DES cipher-block chained checksum (des-mac)\n   The DES-MAC checksum is\
    \ computed by prepending an 8 octet confounder\n   to the plaintext, performing\
    \ a DES CBC-mode encryption on the result\n   using the key and an initialization\
    \ vector of zero, taking the last\n   block of the ciphertext, prepending the\
    \ same confounder and\n   encrypting the pair using DES in cipher-block-chaining\
    \ (CBC) mode\n   using a a variant of the key, where the variant is computed by\n\
    \   eXclusive-ORing the key with the constant F0F0F0F0F0F0F0F0.  The\n   initialization\
    \ vector should be zero.  The resulting checksum is 128\n   bits (16 octets) long,\
    \ 64 bits of which are redundant. This checksum\n   is tamper-proof and collision-proof.\n\
    \   The format for the checksum is described in the following diagram:\n     \
    \ +--+--+--+--+--+--+--+--\n      |   des-cbc(confounder\n      +--+--+--+--+--+--+--+--\n\
    \                     +-----+-----+-----+-----+-----+-----+-----+-----+\n    \
    \                   des-mac(conf+msg,iv=0,key),key=var(key),iv=0) |\n        \
    \             +-----+-----+-----+-----+-----+-----+-----+-----+\n   The format\
    \ cannot be described in ASN.1, but for those who prefer an\n   ASN.1-like notation:\n\
    \   des-mac-checksum ::=    ENCRYPTED       UNTAGGED SEQUENCE {\n            \
    \               confounder[0]   UNTAGGED OCTET STRING(8),\n                  \
    \         check[1]        UNTAGGED OCTET STRING(8)\n   }\n   The DES specifications\
    \ identify some \"weak\" and \"semiweak\" keys;\n   those keys shall not be used\
    \ for generating DES-MAC checksums for use\n   in Kerberos, nor shall a key be\
    \ used whose veriant is \"weak\" or\n   \"semi-weak\".\n"
- title: 6.4.7. RSA MD4 Cryptographic Checksum Using DES alternative
  contents:
  - "6.4.7. RSA MD4 Cryptographic Checksum Using DES alternative\n       (rsa-md4-des-k)\n\
    \   The RSA-MD4-DES-K checksum calculates a keyed collision-proof\n   checksum\
    \ by applying the RSA MD4 checksum algorithm and encrypting\n   the results using\
    \ DES in cipherblock-chaining (CBC) mode using a DES\n   key as both key and initialization\
    \ vector. The resulting checksum is\n   16 octets long. This checksum is tamper-proof\
    \ and believed to be\n   collision-proof.  Note that this checksum type is the\
    \ old method for\n   encoding the RSA-MD4-DES checksum and it is no longer recommended.\n"
- title: 6.4.8. DES cipher-block chained checksum alternative (desmac-k)
  contents:
  - "6.4.8. DES cipher-block chained checksum alternative (desmac-k)\n   The DES-MAC-K\
    \ checksum is computed by performing a DES CBC-mode\n   encryption of the plaintext,\
    \ and using the last block of the\n   ciphertext as the checksum value. It is\
    \ keyed with an encryption key\n   and an initialization vector; any uses which\
    \ do not specify an\n   additional initialization vector will use the key as both\
    \ key and\n   initialization vector.  The resulting checksum is 64 bits (8 octets)\n\
    \   long. This checksum is tamper-proof and collision-proof.  Note that\n   this\
    \ checksum type is the old method for encoding the DESMAC checksum\n   and it\
    \ is no longer recommended.\n   The DES specifications identify some \"weak keys\"\
    ; those keys shall\n   not be used for generating DES-MAC checksums for use in\
    \ Kerberos.\n"
- title: 7.  Naming Constraints
  contents:
  - '7.  Naming Constraints

    '
- title: 7.1.  Realm Names
  contents:
  - "7.1.  Realm Names\n   Although realm names are encoded as GeneralStrings and\
    \ although a\n   realm can technically select any name it chooses, interoperability\n\
    \   across realm boundaries requires agreement on how realm names are to\n   be\
    \ assigned, and what information they imply.\n   To enforce these conventions,\
    \ each realm must conform to the\n   conventions itself, and it must require that\
    \ any realms with which\n   inter-realm keys are shared also conform to the conventions\
    \ and\n   require the same from its neighbors.\n   There are presently four styles\
    \ of realm names: domain, X500, other,\n   and reserved.  Examples of each style\
    \ follow:\n        domain:   host.subdomain.domain (example)\n          X500:\
    \   C=US/O=OSF (example)\n         other:   NAMETYPE:rest/of.name=without-restrictions\
    \ (example)\n      reserved:   reserved, but will not conflict with above\n  \
    \ Domain names must look like domain names: they consist of components\n   separated\
    \ by periods (.) and they contain neither colons (:) nor\n   slashes (/).\n  \
    \ X.500 names contain an equal (=) and cannot contain a colon (:)\n   before the\
    \ equal.  The realm names for X.500 names will be string\n   representations of\
    \ the names with components separated by slashes.\n   Leading and trailing slashes\
    \ will not be included.\n   Names that fall into the other category must begin\
    \ with a prefix that\n   contains no equal (=) or period (.) and the prefix must\
    \ be followed\n   by a colon (:) and the rest of the name. All prefixes must be\n\
    \   assigned before they may be used.  Presently none are assigned.\n   The reserved\
    \ category includes strings which do not fall into the\n   first three categories.\
    \  All names in this category are reserved. It\n   is unlikely that names will\
    \ be assigned to this category unless there\n   is a very strong argument for\
    \ not using the \"other\" category.\n   These rules guarantee that there will\
    \ be no conflicts between the\n   various name styles.  The following additional\
    \ constraints apply to\n   the assignment of realm names in the domain and X.500\
    \ categories: the\n   name of a realm for the domain or X.500 formats must either\
    \ be used\n   by the organization owning (to whom it was assigned) an Internet\n\
    \   domain name or X.500 name, or in the case that no such names are\n   registered,\
    \ authority to use a realm name may be derived from the\n   authority of the parent\
    \ realm.  For example, if there is no domain\n   name for E40.MIT.EDU, then the\
    \ administrator of the MIT.EDU realm can\n   authorize the creation of a realm\
    \ with that name.\n   This is acceptable because the organization to which the\
    \ parent is\n   assigned is presumably the organization authorized to assign names\
    \ to\n   its children in the X.500 and domain name systems as well.  If the\n\
    \   parent assigns a realm name without also registering it in the domain\n  \
    \ name or X.500 hierarchy, it is the parent's responsibility to make\n   sure\
    \ that there will not in the future exists a name identical to the\n   realm name\
    \ of the child unless it is assigned to the same entity as\n   the realm name.\n"
- title: 7.2.  Principal Names
  contents:
  - "7.2.  Principal Names\n   As was the case for realm names, conventions are needed\
    \ to ensure\n   that all agree on what information is implied by a principal name.\n\
    \   The name-type field that is part of the principal name indicates the\n   kind\
    \ of information implied by the name.  The name-type should be\n   treated as\
    \ a hint.  Ignoring the name type, no two names can be the\n   same (i.e., at\
    \ least one of the components, or the realm, must be\n   different).  This constraint\
    \ may be eliminated in the future.  The\n   following name types are defined:\n\
    \      name-type      value   meaning\n      NT-UNKNOWN       0     Name type\
    \ not known\n      NT-PRINCIPAL     1     Just the name of the principal as in\n\
    \                             DCE, or for users\n      NT-SRV-INST      2    \
    \ Service and other unique instance (krbtgt)\n      NT-SRV-HST       3     Service\
    \ with host name as instance\n                             (telnet, rcommands)\n\
    \      NT-SRV-XHST      4     Service with host as remaining components\n    \
    \  NT-UID           5     Unique ID\n   When a name implies no information other\
    \ than its uniqueness at a\n   particular time the name type PRINCIPAL should\
    \ be used.  The\n   principal name type should be used for users, and it might\
    \ also be\n   used for a unique server.  If the name is a unique machine generated\n\
    \   ID that is guaranteed never to be reassigned then the name type of\n   UID\
    \ should be used (note that it is generally a bad idea to reassign\n   names of\
    \ any type since stale entries might remain in access control\n   lists).\n  \
    \ If the first component of a name identifies a service and the\n   remaining\
    \ components identify an instance of the service in a server\n   specified manner,\
    \ then the name type of SRV-INST should be used.  An\n   example of this name\
    \ type is the Kerberos ticket-granting ticket\n   which has a first component\
    \ of krbtgt and a second component\n   identifying the realm for which the ticket\
    \ is valid.\n   If instance is a single component following the service name and\
    \ the\n   instance identifies the host on which the server is running, then the\n\
    \   name type SRV-HST should be used. This type is typically used for\n   Internet\
    \ services such as telnet and the Berkeley R commands.  If the\n   separate components\
    \ of the host name appear as successive components\n   following the name of the\
    \ service, then the name type SRVXHST should\n   be used.  This type might be\
    \ used to identify servers on hosts with\n   X.500 names where the slash (/) might\
    \ otherwise be ambiguous.\n   A name type of UNKNOWN should be used when the form\
    \ of the name is\n   not known. When comparing names, a name of type UNKNOWN will\
    \ match\n   principals authenticated with names of any type.  A principal\n  \
    \ authenticated with a name of type UNKNOWN, however, will only match\n   other\
    \ names of type UNKNOWN.\n   Names of any type with an initial component of \"\
    krbtgt\" are reserved\n   for the Kerberos ticket granting service.  See section\
    \ 8.2.3 for the\n   form of such names.\n"
- title: 7.2.1. Name of server principals
  contents:
  - "7.2.1. Name of server principals\n   The principal identifier for a server on\
    \ a host will generally be\n   composed of two parts: (1) the realm of the KDC\
    \ with which the server\n   is registered, and (2) a two-component name of type\
    \ NT-SRV-HST if the\n   host name is an Internet domain name or a multi-component\
    \ name of\n   type NT-SRV-XHST if the name of the host is of a form such as X.500\n\
    \   that allows slash (/) separators.  The first component of the two- or\n  \
    \ multi-component name will identify the service and the latter\n   components\
    \ will identify the host.  Where the name of the host is not\n   case sensitive\
    \ (for example, with Internet domain names) the name of\n   the host must be lower\
    \ case.  For services such as telnet and the\n   Berkeley R commands which run\
    \ with system privileges, the first\n   component will be the string \"host\"\
    \ instead of a service specific\n   identifier.\n"
- title: 8.  Constants and other defined values
  contents:
  - '8.  Constants and other defined values

    '
- title: 8.1.  Host address types
  contents:
  - "8.1.  Host address types\n   All negative values for the host address type are\
    \ reserved for local\n   use.  All non-negative values are reserved for officially\
    \ assigned\n   type fields and interpretations.\n   The values of the types for\
    \ the following addresses are chosen to\n   match the defined address family constants\
    \ in the Berkeley Standard\n   Distributions of Unix.  They can be found in <sys/socket.h>\
    \ with\n   symbolic names AF_xxx (where xxx is an abbreviation of the address\n\
    \   family name).\n   Internet addresses\n      Internet addresses are 32-bit\
    \ (4-octet) quantities, encoded in MSB\n      order.  The type of internet addresses\
    \ is two (2).\n   CHAOSnet addresses\n      CHAOSnet addresses are 16-bit (2-octet)\
    \ quantities, encoded in MSB\n      order.  The type of CHAOSnet addresses is\
    \ five (5).\n   ISO addresses\n      ISO addresses are variable-length.  The type\
    \ of ISO addresses is\n      seven (7).\n   Xerox Network Services (XNS) addresses\n\
    \      XNS addresses are 48-bit (6-octet) quantities, encoded in MSB\n      order.\
    \  The type of XNS addresses is six (6).\n   AppleTalk Datagram Delivery Protocol\
    \ (DDP) addresses\n      AppleTalk DDP addresses consist of an 8-bit node number\
    \ and a 16-\n      bit network number.  The first octet of the address is the\
    \ node\n      number; the remaining two octets encode the network number in MSB\n\
    \      order. The type of AppleTalk DDP addresses is sixteen (16).\n   DECnet\
    \ Phase IV addresses\n      DECnet Phase IV addresses are 16-bit addresses, encoded\
    \ in LSB\n      order.  The type of DECnet Phase IV addresses is twelve (12).\n"
- title: 8.2.  KDC messages
  contents:
  - '8.2.  KDC messages

    '
- title: 8.2.1. IP transport
  contents:
  - "8.2.1. IP transport\n   When contacting a Kerberos server (KDC) for a KRB_KDC_REQ\
    \ request\n   using IP transport, the client shall send a UDP datagram containing\n\
    \   only an encoding of the request to port 88 (decimal) at the KDC's IP\n   address;\
    \ the KDC will respond with a reply datagram containing only\n   an encoding of\
    \ the reply message (either a KRB_ERROR or a\n   KRB_KDC_REP) to the sending port\
    \ at the sender's IP address.\n"
- title: 8.2.2. OSI transport
  contents:
  - "8.2.2. OSI transport\n   During authentication of an OSI client to and OSI server,\
    \ the mutual\n   authentication of an OSI server to an OSI client, the transfer\
    \ of\n   credentials from an OSI client to an OSI server, or during exchange\n\
    \   of private or integrity checked messages, Kerberos protocol messages\n   may\
    \ be treated as opaque objects and the type of the authentication\n   mechanism\
    \ will be:\n   OBJECT IDENTIFIER ::= {iso (1), org(3), dod(5),internet(1),\n \
    \                         security(5), kerberosv5(2)}\n   Depending on the situation,\
    \ the opaque object will be an\n   authentication header (KRB_AP_REQ), an authentication\
    \ reply\n   (KRB_AP_REP), a safe message (KRB_SAFE), a private message\n   (KRB_PRIV),\
    \ or a credentials message (KRB_CRED).  The opaque data\n   contains an application\
    \ code as specified in the ASN.1 description\n   for each message.  The application\
    \ code may be used by Kerberos to\n   determine the message type.\n"
- title: 8.2.3. Name of the TGS
  contents:
  - "8.2.3. Name of the TGS\n   The principal identifier of the ticket-granting service\
    \ shall be\n   composed of three parts: (1) the realm of the KDC issuing the TGS\n\
    \   ticket (2) a two-part name of type NT-SRVINST, with the first part\n   \"\
    krbtgt\" and the second part the name of the realm which will accept\n   the ticket-granting\
    \ ticket.  For example, a ticket-granting ticket\n   issued by the ATHENA.MIT.EDU\
    \ realm to be used to get tickets from the\n   ATHENA.MIT.EDU KDC has a principal\
    \ identifier of \"ATHENA.MIT.EDU\"\n   (realm), (\"krbtgt\", \"ATHENA.MIT.EDU\"\
    ) (name).  A ticket-granting\n   ticket issued by the ATHENA.MIT.EDU realm to\
    \ be used to get tickets\n   from the MIT.EDU realm has a principal identifier\
    \ of \"ATHENA.MIT.EDU\"\n   (realm), (\"krbtgt\", \"MIT.EDU\") (name).\n"
- title: 8.3.  Protocol constants and associated values
  contents:
  - "8.3.  Protocol constants and associated values\n   The following tables list\
    \ constants used in the protocol and defines\n   their meanings.\n"
- title: '---------------+-----------+----------+----------------+---------------'
  contents:
  - '---------------+-----------+----------+----------------+---------------

    '
- title: Encryption type|etype value|block size|minimum pad size|confounder size
  contents:
  - 'Encryption type|etype value|block size|minimum pad size|confounder size

    '
- title: '---------------+-----------+----------+----------------+---------------'
  contents:
  - '---------------+-----------+----------+----------------+---------------

    '
- title: NULL                0            1              0              0
  contents:
  - 'NULL                0            1              0              0

    '
- title: des-cbc-crc         1            8              4              8
  contents:
  - 'des-cbc-crc         1            8              4              8

    '
- title: des-cbc-md4         2            8              0              8
  contents:
  - 'des-cbc-md4         2            8              0              8

    '
- title: des-cbc-md5         3            8              0              8
  contents:
  - 'des-cbc-md5         3            8              0              8

    '
- title: '-------------------------------+-------------------+-------------'
  contents:
  - '-------------------------------+-------------------+-------------

    '
- title: Checksum type                  |sumtype value      |checksum size
  contents:
  - 'Checksum type                  |sumtype value      |checksum size

    '
- title: '-------------------------------+-------------------+-------------'
  contents:
  - '-------------------------------+-------------------+-------------

    '
- title: CRC32                           1                   4
  contents:
  - 'CRC32                           1                   4

    '
- title: rsa-md4                         2                   16
  contents:
  - 'rsa-md4                         2                   16

    '
- title: rsa-md4-des                     3                   24
  contents:
  - 'rsa-md4-des                     3                   24

    '
- title: des-mac                         4                   16
  contents:
  - 'des-mac                         4                   16

    '
- title: des-mac-k                       5                   8
  contents:
  - 'des-mac-k                       5                   8

    '
- title: rsa-md4-des-k                   6                   16
  contents:
  - 'rsa-md4-des-k                   6                   16

    '
- title: rsa-md5                         7                   16
  contents:
  - 'rsa-md5                         7                   16

    '
- title: rsa-md5-des                     8                   24
  contents:
  - 'rsa-md5-des                     8                   24

    '
- title: '-------------------------------+-----------------'
  contents:
  - '-------------------------------+-----------------

    '
- title: padata type                    |padata-type value
  contents:
  - 'padata type                    |padata-type value

    '
- title: '-------------------------------+-----------------'
  contents:
  - '-------------------------------+-----------------

    '
- title: PA-TGS-REQ                      1
  contents:
  - 'PA-TGS-REQ                      1

    '
- title: PA-ENC-TIMESTAMP                2
  contents:
  - 'PA-ENC-TIMESTAMP                2

    '
- title: PA-PW-SALT                      3
  contents:
  - 'PA-PW-SALT                      3

    '
- title: '-------------------------------+-------------'
  contents:
  - '-------------------------------+-------------

    '
- title: authorization data type        |ad-type value
  contents:
  - 'authorization data type        |ad-type value

    '
- title: '-------------------------------+-------------'
  contents:
  - '-------------------------------+-------------

    '
- title: reserved values                 0-63
  contents:
  - 'reserved values                 0-63

    '
- title: OSF-DCE                         64
  contents:
  - 'OSF-DCE                         64

    '
- title: SESAME                          65
  contents:
  - 'SESAME                          65

    '
- title: '-------------------------------+-----------------'
  contents:
  - '-------------------------------+-----------------

    '
- title: alternate authentication type  |method-type value
  contents:
  - 'alternate authentication type  |method-type value

    '
- title: '-------------------------------+-----------------'
  contents:
  - '-------------------------------+-----------------

    '
- title: reserved values                 0-63
  contents:
  - 'reserved values                 0-63

    '
- title: ATT-CHALLENGE-RESPONSE          64
  contents:
  - 'ATT-CHALLENGE-RESPONSE          64

    '
- title: '-------------------------------+-------------'
  contents:
  - '-------------------------------+-------------

    '
- title: transited encoding type        |tr-type value
  contents:
  - 'transited encoding type        |tr-type value

    '
- title: '-------------------------------+-------------'
  contents:
  - '-------------------------------+-------------

    '
- title: DOMAIN-X500-COMPRESS            1
  contents:
  - 'DOMAIN-X500-COMPRESS            1

    '
- title: reserved values                 all others
  contents:
  - 'reserved values                 all others

    '
- title: '--------------+-------+-----------------------------------------'
  contents:
  - '--------------+-------+-----------------------------------------

    '
- title: Label         |Value  |Meaning or MIT code
  contents:
  - 'Label         |Value  |Meaning or MIT code

    '
- title: '--------------+-------+-----------------------------------------'
  contents:
  - '--------------+-------+-----------------------------------------

    '
- title: pvno             5     current Kerberos protocol version number
  contents:
  - 'pvno             5     current Kerberos protocol version number

    '
- title: message types
  contents:
  - 'message types

    '
- title: KRB_AS_REQ      10     Request for initial authentication
  contents:
  - 'KRB_AS_REQ      10     Request for initial authentication

    '
- title: KRB_AS_REP      11     Response to KRB_AS_REQ request
  contents:
  - 'KRB_AS_REP      11     Response to KRB_AS_REQ request

    '
- title: KRB_TGS_REQ     12     Request for authentication based on TGT
  contents:
  - 'KRB_TGS_REQ     12     Request for authentication based on TGT

    '
- title: KRB_TGS_REP     13     Response to KRB_TGS_REQ request
  contents:
  - 'KRB_TGS_REP     13     Response to KRB_TGS_REQ request

    '
- title: KRB_AP_REQ      14     application request to server
  contents:
  - 'KRB_AP_REQ      14     application request to server

    '
- title: KRB_AP_REP      15     Response to KRB_AP_REQ_MUTUAL
  contents:
  - 'KRB_AP_REP      15     Response to KRB_AP_REQ_MUTUAL

    '
- title: KRB_SAFE        20     Safe (checksummed) application message
  contents:
  - 'KRB_SAFE        20     Safe (checksummed) application message

    '
- title: KRB_PRIV        21     Private (encrypted) application message
  contents:
  - 'KRB_PRIV        21     Private (encrypted) application message

    '
- title: KRB_CRED        22     Private (encrypted) message to forward
  contents:
  - "KRB_CRED        22     Private (encrypted) message to forward\n             \
    \          credentials\n"
- title: KRB_ERROR       30     Error response
  contents:
  - 'KRB_ERROR       30     Error response

    '
- title: name types
  contents:
  - 'name types

    '
- title: KRB_NT_UNKNOWN   0   Name type not known
  contents:
  - 'KRB_NT_UNKNOWN   0   Name type not known

    '
- title: KRB_NT_PRINCIPAL 1   Just the name of the principal as in DCE, or
  contents:
  - "KRB_NT_PRINCIPAL 1   Just the name of the principal as in DCE, or\n         \
    \            for users\n"
- title: KRB_NT_SRV_INST  2   Service and other unique instance (krbtgt)
  contents:
  - 'KRB_NT_SRV_INST  2   Service and other unique instance (krbtgt)

    '
- title: KRB_NT_SRV_HST   3   Service with host name as instance (telnet,
  contents:
  - "KRB_NT_SRV_HST   3   Service with host name as instance (telnet,\n          \
    \           rcommands)\n"
- title: KRB_NT_SRV_XHST  4   Service with host as remaining components
  contents:
  - 'KRB_NT_SRV_XHST  4   Service with host as remaining components

    '
- title: KRB_NT_UID       5   Unique ID
  contents:
  - 'KRB_NT_UID       5   Unique ID

    '
- title: error codes
  contents:
  - 'error codes

    '
- title: KDC_ERR_NONE                   0   No error
  contents:
  - 'KDC_ERR_NONE                   0   No error

    '
- title: KDC_ERR_NAME_EXP               1   Client's entry in database has
  contents:
  - "KDC_ERR_NAME_EXP               1   Client's entry in database has\n         \
    \                          expired\n"
- title: KDC_ERR_SERVICE_EXP            2   Server's entry in database has
  contents:
  - "KDC_ERR_SERVICE_EXP            2   Server's entry in database has\n         \
    \                          expired\n"
- title: KDC_ERR_BAD_PVNO               3   Requested protocol version number
  contents:
  - "KDC_ERR_BAD_PVNO               3   Requested protocol version number\n      \
    \                             not supported\n"
- title: KDC_ERR_C_OLD_MAST_KVNO        4   Client's key encrypted in old
  contents:
  - "KDC_ERR_C_OLD_MAST_KVNO        4   Client's key encrypted in old\n          \
    \                         master key\n"
- title: KDC_ERR_S_OLD_MAST_KVNO        5   Server's key encrypted in old
  contents:
  - "KDC_ERR_S_OLD_MAST_KVNO        5   Server's key encrypted in old\n          \
    \                         master key\n"
- title: KDC_ERR_C_PRINCIPAL_UNKNOWN    6   Client not found in Kerberos database
  contents:
  - 'KDC_ERR_C_PRINCIPAL_UNKNOWN    6   Client not found in Kerberos database

    '
- title: KDC_ERR_S_PRINCIPAL_UNKNOWN    7   Server not found in Kerberos database
  contents:
  - 'KDC_ERR_S_PRINCIPAL_UNKNOWN    7   Server not found in Kerberos database

    '
- title: KDC_ERR_PRINCIPAL_NOT_UNIQUE   8   Multiple principal entries in
  contents:
  - "KDC_ERR_PRINCIPAL_NOT_UNIQUE   8   Multiple principal entries in\n          \
    \                         database\n"
- title: KDC_ERR_NULL_KEY               9   The client or server has a null key
  contents:
  - 'KDC_ERR_NULL_KEY               9   The client or server has a null key

    '
- title: KDC_ERR_CANNOT_POSTDATE       10   Ticket not eligible for postdating
  contents:
  - 'KDC_ERR_CANNOT_POSTDATE       10   Ticket not eligible for postdating

    '
- title: KDC_ERR_NEVER_VALID           11   Requested start time is later than
  contents:
  - "KDC_ERR_NEVER_VALID           11   Requested start time is later than\n     \
    \                              end time\n"
- title: KDC_ERR_POLICY                12   KDC policy rejects request
  contents:
  - 'KDC_ERR_POLICY                12   KDC policy rejects request

    '
- title: KDC_ERR_BADOPTION             13   KDC cannot accommodate requested
  contents:
  - "KDC_ERR_BADOPTION             13   KDC cannot accommodate requested\n       \
    \                            option\n"
- title: KDC_ERR_ETYPE_NOSUPP          14   KDC has no support for encryption
  contents:
  - "KDC_ERR_ETYPE_NOSUPP          14   KDC has no support for encryption\n      \
    \                             type\n"
- title: KDC_ERR_SUMTYPE_NOSUPP        15   KDC has no support for checksum type
  contents:
  - 'KDC_ERR_SUMTYPE_NOSUPP        15   KDC has no support for checksum type

    '
- title: KDC_ERR_PADATA_TYPE_NOSUPP    16   KDC has no support for padata type
  contents:
  - 'KDC_ERR_PADATA_TYPE_NOSUPP    16   KDC has no support for padata type

    '
- title: KDC_ERR_TRTYPE_NOSUPP         17   KDC has no support for transited type
  contents:
  - 'KDC_ERR_TRTYPE_NOSUPP         17   KDC has no support for transited type

    '
- title: KDC_ERR_CLIENT_REVOKED        18   Clients credentials have been revoked
  contents:
  - 'KDC_ERR_CLIENT_REVOKED        18   Clients credentials have been revoked

    '
- title: KDC_ERR_SERVICE_REVOKED       19   Credentials for server have been
  contents:
  - "KDC_ERR_SERVICE_REVOKED       19   Credentials for server have been\n       \
    \                            revoked\n"
- title: KDC_ERR_TGT_REVOKED           20   TGT has been revoked
  contents:
  - 'KDC_ERR_TGT_REVOKED           20   TGT has been revoked

    '
- title: KDC_ERR_CLIENT_NOTYET         21   Client not yet valid - try again
  contents:
  - "KDC_ERR_CLIENT_NOTYET         21   Client not yet valid - try again\n       \
    \                            later\n"
- title: KDC_ERR_SERVICE_NOTYET        22   Server not yet valid - try again
  contents:
  - "KDC_ERR_SERVICE_NOTYET        22   Server not yet valid - try again\n       \
    \                            later\n"
- title: KDC_ERR_KEY_EXPIRED           23   Password has expired - change
  contents:
  - "KDC_ERR_KEY_EXPIRED           23   Password has expired - change\n          \
    \                         password to reset\n"
- title: KDC_ERR_PREAUTH_FAILED        24   Pre-authentication information
  contents:
  - "KDC_ERR_PREAUTH_FAILED        24   Pre-authentication information\n         \
    \                          was invalid\n"
- title: KDC_ERR_PREAUTH_REQUIRED      25   Additional pre-authentication
  contents:
  - "KDC_ERR_PREAUTH_REQUIRED      25   Additional pre-authentication\n          \
    \                         required*\n"
- title: KRB_AP_ERR_BAD_INTEGRITY      31   Integrity check on decrypted field
  contents:
  - "KRB_AP_ERR_BAD_INTEGRITY      31   Integrity check on decrypted field\n     \
    \                              failed\n"
- title: KRB_AP_ERR_TKT_EXPIRED        32   Ticket expired
  contents:
  - 'KRB_AP_ERR_TKT_EXPIRED        32   Ticket expired

    '
- title: KRB_AP_ERR_TKT_NYV            33   Ticket not yet valid
  contents:
  - 'KRB_AP_ERR_TKT_NYV            33   Ticket not yet valid

    '
- title: KRB_AP_ERR_REPEAT             34   Request is a replay
  contents:
  - 'KRB_AP_ERR_REPEAT             34   Request is a replay

    '
- title: KRB_AP_ERR_NOT_US             35   The ticket isn't for us
  contents:
  - 'KRB_AP_ERR_NOT_US             35   The ticket isn''t for us

    '
- title: KRB_AP_ERR_BADMATCH           36   Ticket and authenticator don't match
  contents:
  - 'KRB_AP_ERR_BADMATCH           36   Ticket and authenticator don''t match

    '
- title: KRB_AP_ERR_SKEW               37   Clock skew too great
  contents:
  - 'KRB_AP_ERR_SKEW               37   Clock skew too great

    '
- title: KRB_AP_ERR_BADADDR            38   Incorrect net address
  contents:
  - 'KRB_AP_ERR_BADADDR            38   Incorrect net address

    '
- title: KRB_AP_ERR_BADVERSION         39   Protocol version mismatch
  contents:
  - 'KRB_AP_ERR_BADVERSION         39   Protocol version mismatch

    '
- title: KRB_AP_ERR_MSG_TYPE           40   Invalid msg type
  contents:
  - 'KRB_AP_ERR_MSG_TYPE           40   Invalid msg type

    '
- title: KRB_AP_ERR_MODIFIED           41   Message stream modified
  contents:
  - 'KRB_AP_ERR_MODIFIED           41   Message stream modified

    '
- title: KRB_AP_ERR_BADORDER           42   Message out of order
  contents:
  - 'KRB_AP_ERR_BADORDER           42   Message out of order

    '
- title: KRB_AP_ERR_BADKEYVER          44   Specified version of key is not
  contents:
  - "KRB_AP_ERR_BADKEYVER          44   Specified version of key is not\n        \
    \                           available\n"
- title: KRB_AP_ERR_NOKEY              45   Service key not available
  contents:
  - 'KRB_AP_ERR_NOKEY              45   Service key not available

    '
- title: KRB_AP_ERR_MUT_FAIL           46   Mutual authentication failed
  contents:
  - 'KRB_AP_ERR_MUT_FAIL           46   Mutual authentication failed

    '
- title: KRB_AP_ERR_BADDIRECTION       47   Incorrect message direction
  contents:
  - 'KRB_AP_ERR_BADDIRECTION       47   Incorrect message direction

    '
- title: KRB_AP_ERR_METHOD             48   Alternative authentication method
  contents:
  - "KRB_AP_ERR_METHOD             48   Alternative authentication method\n      \
    \                             required*\n"
- title: KRB_AP_ERR_BADSEQ             49   Incorrect sequence number in message
  contents:
  - 'KRB_AP_ERR_BADSEQ             49   Incorrect sequence number in message

    '
- title: KRB_AP_ERR_INAPP_CKSUM        50   Inappropriate type of checksum in
  contents:
  - "KRB_AP_ERR_INAPP_CKSUM        50   Inappropriate type of checksum in\n      \
    \                             message\n"
- title: KRB_ERR_GENERIC               60   Generic error (description in e-text)
  contents:
  - 'KRB_ERR_GENERIC               60   Generic error (description in e-text)

    '
- title: KRB_ERR_FIELD_TOOLONG         61   Field is too long for this
  contents:
  - "KRB_ERR_FIELD_TOOLONG         61   Field is too long for this\n             \
    \                      implementation\n   *This error carries additional information\
    \ in the e-data field.  The\n   contents of the e-data field for this message\
    \ is described in section\n   5.9.1.\n"
- title: 9.  Interoperability requirements
  contents:
  - "9.  Interoperability requirements\n   Version 5 of the Kerberos protocol supports\
    \ a myriad of options.\n   Among these are multiple encryption and checksum types,\
    \ alternative\n   encoding schemes for the transited field, optional mechanisms\
    \ for\n   pre-authentication, the handling of tickets with no addresses,\n   options\
    \ for mutual authentication, user to user authentication,\n   support for proxies,\
    \ forwarding, postdating, and renewing tickets,\n   the format of realm names,\
    \ and the handling of authorization data.\n   In order to ensure the interoperability\
    \ of realms, it is necessary to\n   define a minimal configuration which must\
    \ be supported by all\n   implementations.  This minimal configuration is subject\
    \ to change as\n   technology does. For example, if at some later date it is discovered\n\
    \   that one of the required encryption or checksum algorithms is not\n   secure,\
    \ it will be replaced.\n"
- title: 9.1.  Specification 1
  contents:
  - "9.1.  Specification 1\n   This section defines the first specification of these\
    \ options.\n   Implementations which are configured in this way can be said to\n\
    \   support Kerberos Version 5 Specification 1 (5.1).\n   Encryption and checksum\
    \ methods\n   The following encryption and checksum mechanisms must be supported.\n\
    \   Implementations may support other mechanisms as well, but the\n   additional\
    \ mechanisms may only be used when communicating with\n   principals known to\
    \ also support them: Encryption: DES-CBC-MD5\n   Checksums: CRC-32, DES-MAC, DES-MAC-K,\
    \ and DES-MD5\n   Realm Names\n   All implementations must understand hierarchical\
    \ realms in both the\n   Internet Domain and the X.500 style.  When a ticket granting\
    \ ticket\n   for an unknown realm is requested, the KDC must be able to determine\n\
    \   the names of the intermediate realms between the KDCs realm and the\n   requested\
    \ realm.\n   Transited field encoding\n   DOMAIN-X500-COMPRESS (described in section\
    \ 3.3.3.1) must be\n   supported.  Alternative encodings may be supported, but\
    \ they may be\n   used only when that encoding is supported by ALL intermediate\
    \ realms.\n   Pre-authentication methods\n   The TGS-REQ method must be supported.\
    \  The TGS-REQ method is not used\n   on the initial request. The PA-ENC-TIMESTAMP\
    \ method must be supported\n   by clients but whether it is enabled by default\
    \ may be determined on\n   a realm by realm basis. If not used in the initial\
    \ request and the\n   error KDC_ERR_PREAUTH_REQUIRED is returned specifying PA-ENCTIMESTAMP\n\
    \   as an acceptable method, the client should retry the initial request\n   using\
    \ the PA-ENC-TIMESTAMP preauthentication method. Servers need not\n   support\
    \ the PAENC-TIMESTAMP method, but if not supported the server\n   should ignore\
    \ the presence of PA-ENC-TIMESTAMP pre-authentication in\n   a request.\n   Mutual\
    \ authentication\n   Mutual authentication (via the KRB_AP_REP message) must be\
    \ supported.\n   Ticket addresses and flags\n   All KDC's must pass on tickets\
    \ that carry no addresses (i.e.,  if a\n   TGT contains no addresses, the KDC\
    \ will return derivative tickets),\n   but each realm may set its own policy for\
    \ issuing such tickets, and\n   each application server will set its own policy\
    \ with respect to\n   accepting them. By default, servers should not accept them.\n\
    \   Proxies and forwarded tickets must be supported.  Individual realms\n   and\
    \ application servers can set their own policy on when such tickets\n   will be\
    \ accepted.\n   All implementations must recognize renewable and postdated tickets,\n\
    \   but need not actually implement them.  If these options are not\n   supported,\
    \ the starttime and endtime in the ticket shall specify a\n   ticket's entire\
    \ useful life.  When a postdated ticket is decoded by a\n   server, all implementations\
    \ shall make the presence of the postdated\n   flag visible to the calling server.\n\
    \   User-to-user authentication\n   Support for user to user authentication (via\
    \ the ENC-TKTIN-SKEY KDC\n   option) must be provided by implementations, but\
    \ individual realms\n   may decide as a matter of policy to reject such requests\
    \ on a per-\n   principal or realm-wide basis.\n   Authorization data\n   Implementations\
    \ must pass all authorization data subfields from\n   ticket-granting tickets\
    \ to any derivative tickets unless directed to\n   suppress a subfield as part\
    \ of the definition of that registered\n   subfield type (it is never incorrect\
    \ to pass on a subfield, and no\n   registered subfield types presently specify\
    \ suppression at the KDC).\n   Implementations must make the contents of any authorization\
    \ data\n   subfields available to the server when a ticket is used.\n   Implementations\
    \ are not required to allow clients to specify the\n   contents of the authorization\
    \ data fields.\n"
- title: 9.2.  Recommended KDC values
  contents:
  - "9.2.  Recommended KDC values\n   Following is a list of recommended values for\
    \ a KDC implementation,\n   based on the list of suggested configuration constants\
    \ (see section\n   4.4).\n   minimum lifetime                5 minutes\n   maximum\
    \ renewable lifetime      1 week\n   maximum ticket lifetime         1 day\n \
    \  empty addresses                 only when suitable restrictions appear\n  \
    \                                 in authorization data\n   proxiable, etc.  \
    \               Allowed.\n"
- title: 10.  Acknowledgments
  contents:
  - "10.  Acknowledgments\n   Early versions of this document, describing version\
    \ 4 of the\n   protocol, were written by Jennifer Steiner (formerly at Project\n\
    \   Athena); these drafts provided an excellent starting point for this\n   current\
    \ version 5 specification.  Many people in the Internet\n   community have contributed\
    \ ideas and suggested protocol changes for\n   version 5. Notable contributions\
    \ came from Ted Anderson, Steve\n   Bellovin and Michael Merritt [17], Daniel\
    \ Bernstein, Mike Burrows,\n   Donald Davis, Ravi Ganesan, Morrie Gasser, Virgil\
    \ Gligor, Bill\n   Griffeth, Mark Lillibridge, Mark Lomas, Steve Lunt, Piers McMahon,\n\
    \   Joe Pato, William Sommerfeld, Stuart Stubblebine, Ralph Swick, Ted\n   T'so,\
    \ and Stanley Zanarotti.  Many others commented and helped shape\n   this specification\
    \ into its current form.\n"
- title: 11.  References
  contents:
  - "11.  References\n   [1]  Miller, S., Neuman, C., Schiller, J., and  J. Saltzer,\
    \ \"Section\n        E.2.1: Kerberos  Authentication and Authorization System\"\
    ,\n        M.I.T. Project Athena, Cambridge, Massachusetts, December 21,\n   \
    \     1987.\n   [2]  Steiner, J., Neuman, C., and J. Schiller, \"Kerberos: An\n\
    \        Authentication Service for Open Network Systems\", pp. 191-202 in\n \
    \       Usenix Conference Proceedings, Dallas, Texas, February, 1988.\n   [3]\
    \  Needham, R., and M. Schroeder, \"Using Encryption for\n        Authentication\
    \ in Large Networks of Computers\", Communications\n        of the ACM, Vol. 21\
    \ (12), pp. 993-999, December 1978.\n   [4]  Denning, D., and G. Sacco, \"Time\
    \ stamps in Key Distribution\n        Protocols\", Communications of the ACM,\
    \ Vol. 24 (8), pp. 533-536,\n        August 1981.\n   [5]  Kohl, J., Neuman, C.,\
    \ and T. Ts'o, \"The Evolution of the\n        Kerberos Authentication Service\"\
    , in an IEEE Computer Society\n        Text soon to be published, June 1992.\n\
    \   [6]  Davis, D., and R. Swick, \"Workstation Services and Kerberos\n      \
    \  Authentication at Project Athena\", Technical Memorandum TM-424,\n        MIT\
    \ Laboratory for Computer Science, February 1990.\n   [7]  Levine, P., Gretzinger,\
    \ M, Diaz, J., Sommerfeld, W., and K.\n        Raeburn, \"Section E.1: Service\
    \ Management System, M.I.T.\n        Project Athena, Cambridge, Mas sachusetts\
    \ (1987).\n   [8]  CCITT, Recommendation X.509: The Directory Authentication\n\
    \        Framework, December 1988.\n   [9]  Neuman, C., \"Proxy-Based Authorization\
    \ and Accounting for\n        Distributed Systems,\" in Proceedings of the 13th\
    \ International\n        Conference on Distributed Computing Systems\", Pittsburgh,\
    \ PA,\n        May 1993.\n   [10] Pato, J., \"Using Pre-Authentication to Avoid\
    \ Password Guessing\n        Attacks\", Open Software Foundation DCE Request for\
    \ Comments 26,\n        December 1992.\n   [11] National Bureau of Standards,\
    \ U.S. Department of Commerce, \"Data\n        Encryption Standard\", Federal\
    \ Information Processing Standards\n        Publication 46, Washington, DC (1977).\n\
    \   [12] National Bureau of Standards, U.S. Department of Commerce, \"DES\n  \
    \      Modes of Operation\", Federal Information Processing Standards\n      \
    \  Publication 81, Springfield, VA, December 1980.\n   [13] Stubblebine S., and\
    \ V. Gligor, \"On Message Integrity in\n        Cryptographic Protocols\", in\
    \ Proceedings of the IEEE Symposium\n        on Research in Security and Privacy,\
    \ Oakland, California, May\n        1992.\n   [14] International Organization\
    \ for Standardization, \"ISO Information\n        Processing Systems - Data Communication\
    \ High-Level Data Link\n        Control Procedure - Frame Structure\", IS 3309,\
    \ October 1984, 3rd\n        Edition.\n   [15] Rivest, R., \"The MD4 Message Digest\
    \ Algorithm\", RFC 1320, MIT\n        Laboratory for Computer Science, April 1992.\n\
    \   [16] Rivest, R., \"The MD5 Message Digest Algorithm\", RFC 1321, MIT\n   \
    \     Laboratory for Computer Science, April 1992.\n   [17] Bellovin S., and M.\
    \ Merritt, \"Limitations of the Kerberos\n        Authentication System\", Computer\
    \ Communications Review, Vol.\n        20(5), pp. 119-132, October 1990.\n"
- title: 12.  Security Considerations
  contents:
  - "12.  Security Considerations\n   Security issues are discussed throughout this\
    \ memo.\n"
- title: 13.  Authors' Addresses
  contents:
  - "13.  Authors' Addresses\n   John Kohl\n   Digital Equipment Corporation\n   110\
    \ Spit Brook Road, M/S ZKO3-3/U14\n   Nashua, NH  03062\n   Phone: 603-881-2481\n\
    \   EMail: jtkohl@zk3.dec.com\n   B. Clifford Neuman\n   USC/Information Sciences\
    \ Institute\n   4676 Admiralty Way #1001\n   Marina del Rey, CA 90292-6695\n \
    \  Phone: 310-822-1511\n   EMail: bcn@isi.edu\n"
- title: A.  Pseudo-code for protocol processing
  contents:
  - "A.  Pseudo-code for protocol processing\n   This appendix provides pseudo-code\
    \ describing how the messages are to\n   be constructed and interpreted by clients\
    \ and servers.\n"
- title: A.1.  KRB_AS_REQ generation
  contents:
  - "A.1.  KRB_AS_REQ generation\n        request.pvno := protocol version; /* pvno\
    \ = 5 */\n        request.msg-type := message type; /* type = KRB_AS_REQ */\n\
    \        if(pa_enc_timestamp_required) then\n                request.padata.padata-type\
    \ = PA-ENC-TIMESTAMP;\n                get system_time;\n                padata-body.patimestamp,pausec\
    \ = system_time;\n                encrypt padata-body into request.padata.padata-value\n\
    \                        using client.key; /* derived from password */\n     \
    \   endif\n        body.kdc-options := users's preferences;\n        body.cname\
    \ := user's name;\n        body.realm := user's realm;\n        body.sname :=\
    \ service's name; /* usually \"krbtgt\",\n                                   \
    \      \"localrealm\" */\n        if (body.kdc-options.POSTDATED is set) then\n\
    \                body.from := requested starting time;\n        else\n       \
    \         omit body.from;\n        endif\n        body.till := requested end time;\n\
    \        if (body.kdc-options.RENEWABLE is set) then\n                body.rtime\
    \ := requested final renewal time;\n        endif\n        body.nonce := random_nonce();\n\
    \        body.etype := requested etypes;\n        if (user supplied addresses)\
    \ then\n                body.addresses := user's addresses;\n        else\n  \
    \              omit body.addresses;\n        endif\n        omit body.enc-authorization-data;\n\
    \        request.req-body := body;\n        kerberos := lookup(name of local kerberos\
    \ server (or servers));\n        send(packet,kerberos);\n        wait(for response);\n\
    \        if (timed_out) then\n                retry or use alternate server;\n\
    \        endif\n"
- title: A.2.  KRB_AS_REQ verification and KRB_AS_REP generation
  contents:
  - "A.2.  KRB_AS_REQ verification and KRB_AS_REP generation\n        decode message\
    \ into req;\n        client := lookup(req.cname,req.realm);\n        server :=\
    \ lookup(req.sname,req.realm);\n        get system_time;\n        kdc_time :=\
    \ system_time.seconds;\n        if (!client) then\n                /* no client\
    \ in Database */\n                error_out(KDC_ERR_C_PRINCIPAL_UNKNOWN);\n  \
    \      endif\n        if (!server) then\n                /* no server in Database\
    \ */\n                error_out(KDC_ERR_S_PRINCIPAL_UNKNOWN);\n        endif\n\
    \        if(client.pa_enc_timestamp_required and\n           pa_enc_timestamp\
    \ not present) then\n                error_out(KDC_ERR_PREAUTH_REQUIRED(PA_ENC_TIMESTAMP));\n\
    \        endif\n        if(pa_enc_timestamp present) then\n                decrypt\
    \ req.padata-value into decrypted_enc_timestamp\n                        using\
    \ client.key;\n                        using auth_hdr.authenticator.subkey;\n\
    \                if (decrypt_error()) then\n                        error_out(KRB_AP_ERR_BAD_INTEGRITY);\n\
    \                if(decrypted_enc_timestamp is not within allowable\n        \
    \                skew) then error_out(KDC_ERR_PREAUTH_FAILED);\n             \
    \   endif\n                if(decrypted_enc_timestamp and usec is replay)\n  \
    \                      error_out(KDC_ERR_PREAUTH_FAILED);\n                endif\n\
    \                add decrypted_enc_timestamp and usec to replay cache;\n     \
    \   endif\n        use_etype := first supported etype in req.etypes;\n       \
    \ if (no support for req.etypes) then\n                error_out(KDC_ERR_ETYPE_NOSUPP);\n\
    \        endif\n        new_tkt.vno := ticket version; /* = 5 */\n        new_tkt.sname\
    \ := req.sname;\n        new_tkt.srealm := req.srealm;\n        reset all flags\
    \ in new_tkt.flags;\n        /* It should be noted that local policy may affect\
    \ the  */\n        /* processing of any of these flags.  For example, some */\n\
    \        /* realms may refuse to issue renewable tickets         */\n        if\
    \ (req.kdc-options.FORWARDABLE is set) then\n                set new_tkt.flags.FORWARDABLE;\n\
    \        endif\n        if (req.kdc-options.PROXIABLE is set) then\n         \
    \       set new_tkt.flags.PROXIABLE;\n        endif\n        if (req.kdc-options.ALLOW-POSTDATE\
    \ is set) then\n                set new_tkt.flags.ALLOW-POSTDATE;\n        endif\n\
    \        if ((req.kdc-options.RENEW is set) or\n            (req.kdc-options.VALIDATE\
    \ is set) or\n            (req.kdc-options.PROXY is set) or\n            (req.kdc-options.FORWARDED\
    \ is set) or\n            (req.kdc-options.ENC-TKT-IN-SKEY is set)) then\n   \
    \             error_out(KDC_ERR_BADOPTION);\n        endif\n        new_tkt.session\
    \ := random_session_key();\n        new_tkt.cname := req.cname;\n        new_tkt.crealm\
    \ := req.crealm;\n        new_tkt.transited := empty_transited_field();\n    \
    \    new_tkt.authtime := kdc_time;\n        if (req.kdc-options.POSTDATED is set)\
    \ then\n           if (against_postdate_policy(req.from)) then\n             \
    \   error_out(KDC_ERR_POLICY);\n           endif\n           set new_tkt.flags.INVALID;\n\
    \           new_tkt.starttime := req.from;\n        else\n           omit new_tkt.starttime;\
    \ /* treated as authtime when\n                                      omitted */\n\
    \        endif\n        if (req.till = 0) then\n                till := infinity;\n\
    \        else\n                till := req.till;\n        endif\n        new_tkt.endtime\
    \ := min(till,\n                              new_tkt.starttime+client.max_life,\n\
    \                              new_tkt.starttime+server.max_life,\n          \
    \                    new_tkt.starttime+max_life_for_realm);\n        if ((req.kdc-options.RENEWABLE-OK\
    \ is set) and\n            (new_tkt.endtime < req.till)) then\n              \
    \  /* we set the RENEWABLE option for later processing */\n                set\
    \ req.kdc-options.RENEWABLE;\n                req.rtime := req.till;\n       \
    \ endif\n        if (req.rtime = 0) then\n                rtime := infinity;\n\
    \        else\n                rtime := req.rtime;\n        endif\n        if\
    \ (req.kdc-options.RENEWABLE is set) then\n                set new_tkt.flags.RENEWABLE;\n\
    \                new_tkt.renew-till := min(rtime,\n                new_tkt.starttime+client.max_rlife,\n\
    \                new_tkt.starttime+server.max_rlife,\n                new_tkt.starttime+max_rlife_for_realm);\n\
    \        else\n                omit new_tkt.renew-till; /* only present if RENEWABLE\
    \ */\n        endif\n        if (req.addresses) then\n                new_tkt.caddr\
    \ := req.addresses;\n        else\n                omit new_tkt.caddr;\n     \
    \   endif\n        new_tkt.authorization_data := empty_authorization_data();\n\
    \        encode to-be-encrypted part of ticket into OCTET STRING;\n        new_tkt.enc-part\
    \ := encrypt OCTET STRING\n            using etype_for_key(server.key), server.key,\
    \ server.p_kvno;\n        /* Start processing the response */\n        resp.pvno\
    \ := 5;\n        resp.msg-type := KRB_AS_REP;\n        resp.cname := req.cname;\n\
    \        resp.crealm := req.realm;\n        resp.ticket := new_tkt;\n        resp.key\
    \ := new_tkt.session;\n        resp.last-req := fetch_last_request_info(client);\n\
    \        resp.nonce := req.nonce;\n        resp.key-expiration := client.expiration;\n\
    \        resp.flags := new_tkt.flags;\n        resp.authtime := new_tkt.authtime;\n\
    \        resp.starttime := new_tkt.starttime;\n        resp.endtime := new_tkt.endtime;\n\
    \        if (new_tkt.flags.RENEWABLE) then\n                resp.renew-till :=\
    \ new_tkt.renew-till;\n        endif\n        resp.realm := new_tkt.realm;\n \
    \       resp.sname := new_tkt.sname;\n        resp.caddr := new_tkt.caddr;\n \
    \       encode body of reply into OCTET STRING;\n        resp.enc-part := encrypt\
    \ OCTET STRING\n                         using use_etype, client.key, client.p_kvno;\n\
    \        send(resp);\n"
- title: A.3.  KRB_AS_REP verification
  contents:
  - "A.3.  KRB_AS_REP verification\n        decode response into resp;\n        if\
    \ (resp.msg-type = KRB_ERROR) then\n                if(error = KDC_ERR_PREAUTH_REQUIRED(PA_ENC_TIMESTAMP))\n\
    \                        then set pa_enc_timestamp_required;\n               \
    \         goto KRB_AS_REQ;\n                endif\n                process_error(resp);\n\
    \                return;\n        endif\n        /* On error, discard the response,\
    \ and zero the session key */\n        /* from the response immediately */\n \
    \       key = get_decryption_key(resp.enc-part.kvno, resp.enc-part.etype,\n  \
    \                               resp.padata);\n        unencrypted part of resp\
    \ := decode of decrypt of resp.enc-part\n                                using\
    \ resp.enc-part.etype and key;\n        zero(key);\n        if (common_as_rep_tgs_rep_checks\
    \ fail) then\n                destroy resp.key;\n                return error;\n\
    \        endif\n        if near(resp.princ_exp) then\n                print(warning\
    \ message);\n        endif\n        save_for_later(ticket,session,client,server,times,flags);\n"
- title: A.4.  KRB_AS_REP and KRB_TGS_REP common checks
  contents:
  - "A.4.  KRB_AS_REP and KRB_TGS_REP common checks\n        if (decryption_error()\
    \ or\n            (req.cname != resp.cname) or\n            (req.realm != resp.crealm)\
    \ or\n            (req.sname != resp.sname) or\n            (req.realm != resp.realm)\
    \ or\n            (req.nonce != resp.nonce) or\n            (req.addresses !=\
    \ resp.caddr)) then\n                destroy resp.key;\n                return\
    \ KRB_AP_ERR_MODIFIED;\n        endif\n        /* make sure no flags are set that\
    \ shouldn't be, and that  */\n        /* all that should be are set          \
    \                    */\n        if (!check_flags_for_compatability(req.kdc-options,resp.flags))\n\
    \                then destroy resp.key;\n                return KRB_AP_ERR_MODIFIED;\n\
    \        endif\n        if ((req.from = 0) and\n            (resp.starttime is\
    \ not within allowable skew)) then\n                destroy resp.key;\n      \
    \          return KRB_AP_ERR_SKEW;\n        endif\n        if ((req.from != 0)\
    \ and (req.from != resp.starttime)) then\n                destroy resp.key;\n\
    \                return KRB_AP_ERR_MODIFIED;\n        endif\n        if ((req.till\
    \ != 0) and (resp.endtime > req.till)) then\n                destroy resp.key;\n\
    \                return KRB_AP_ERR_MODIFIED;\n        endif\n        if ((req.kdc-options.RENEWABLE\
    \ is set) and\n            (req.rtime != 0) and (resp.renew-till > req.rtime))\
    \ then\n                destroy resp.key;\n                return KRB_AP_ERR_MODIFIED;\n\
    \        endif\n        if ((req.kdc-options.RENEWABLE-OK is set) and\n      \
    \      (resp.flags.RENEWABLE) and\n            (req.till != 0) and\n         \
    \   (resp.renew-till > req.till)) then\n                destroy resp.key;\n  \
    \              return KRB_AP_ERR_MODIFIED;\n        endif\n"
- title: A.5.  KRB_TGS_REQ generation
  contents:
  - "A.5.  KRB_TGS_REQ generation\n        /* Note that make_application_request might\
    \ have to     */\n        /* recursivly call this routine to get the appropriate\
    \  */\n        /* ticket-granting ticket                               */\n  \
    \      request.pvno := protocol version; /* pvno = 5 */\n        request.msg-type\
    \ := message type; /* type = KRB_TGS_REQ */\n        body.kdc-options := users's\
    \ preferences;\n        /* If the TGT is not for the realm of the end-server \
    \ */\n        /* then the sname will be for a TGT for the end-realm */\n     \
    \   /* and the realm of the requested ticket (body.realm) */\n        /* will\
    \ be that of the TGS to which the TGT we are    */\n        /* sending applies\
    \                                    */\n        body.sname := service's name;\n\
    \        body.realm := service's realm;\n        if (body.kdc-options.POSTDATED\
    \ is set) then\n                body.from := requested starting time;\n      \
    \  else\n                omit body.from;\n        endif\n        body.till :=\
    \ requested end time;\n        if (body.kdc-options.RENEWABLE is set) then\n \
    \               body.rtime := requested final renewal time;\n        endif\n \
    \       body.nonce := random_nonce();\n        body.etype := requested etypes;\n\
    \        if (user supplied addresses) then\n                body.addresses :=\
    \ user's addresses;\n        else\n                omit body.addresses;\n    \
    \    endif\n        body.enc-authorization-data := user-supplied data;\n     \
    \   if (body.kdc-options.ENC-TKT-IN-SKEY) then\n                body.additional-tickets_ticket\
    \ := second TGT;\n        endif\n        request.req-body := body;\n        check\
    \ := generate_checksum (req.body,checksumtype);\n        request.padata[0].padata-type\
    \ := PA-TGS-REQ;\n        request.padata[0].padata-value := create a KRB_AP_REQ\
    \ using\n                                      the TGT and checksum\n        /*\
    \ add in any other padata as required/supplied */\n        kerberos := lookup(name\
    \ of local kerberose server (or servers));\n        send(packet,kerberos);\n \
    \       wait(for response);\n        if (timed_out) then\n                retry\
    \ or use alternate server;\n        endif\n"
- title: A.6.  KRB_TGS_REQ verification and KRB_TGS_REP generation
  contents:
  - "A.6.  KRB_TGS_REQ verification and KRB_TGS_REP generation\n        /* note that\
    \ reading the application request requires first\n        determining the server\
    \ for which a ticket was issued, and\n        choosing the correct key for decryption.\
    \  The name of the\n        server appears in the plaintext part of the ticket.\
    \ */\n        if (no KRB_AP_REQ in req.padata) then\n                error_out(KDC_ERR_PADATA_TYPE_NOSUPP);\n\
    \        endif\n        verify KRB_AP_REQ in req.padata;\n        /* Note that\
    \ the realm in which the Kerberos server is\n        operating is determined by\
    \ the instance from the\n        ticket-granting ticket.  The realm in the ticket-granting\n\
    \        ticket is the realm under which the ticket granting ticket was\n    \
    \    issued.  It is possible for a single Kerberos server to\n        support\
    \ more than one realm. */\n        auth_hdr := KRB_AP_REQ;\n        tgt := auth_hdr.ticket;\n\
    \        if (tgt.sname is not a TGT for local realm and is not\n             \
    \   req.sname) then error_out(KRB_AP_ERR_NOT_US);\n        realm := realm_tgt_is_for(tgt);\n\
    \        decode remainder of request;\n        if (auth_hdr.authenticator.cksum\
    \ is missing) then\n                error_out(KRB_AP_ERR_INAPP_CKSUM);\n     \
    \   endif\n        if (auth_hdr.authenticator.cksum type is not supported) then\n\
    \                error_out(KDC_ERR_SUMTYPE_NOSUPP);\n        endif\n        if\
    \ (auth_hdr.authenticator.cksum is not both collision-proof\n            and keyed)\
    \  then\n                error_out(KRB_AP_ERR_INAPP_CKSUM);\n        endif\n \
    \       set computed_checksum := checksum(req);\n        if (computed_checksum\
    \ != auth_hdr.authenticatory.cksum) then\n                error_out(KRB_AP_ERR_MODIFIED);\n\
    \        endif\n        server := lookup(req.sname,realm);\n        if (!server)\
    \ then\n                if (is_foreign_tgt_name(server)) then\n              \
    \          server := best_intermediate_tgs(server);\n                else\n  \
    \                      /* no server in Database */\n                        error_out(KDC_ERR_S_PRINCIPAL_UNKNOWN);\n\
    \                endif\n        endif\n        session := generate_random_session_key();\n\
    \        use_etype := first supported etype in req.etypes;\n        if (no support\
    \ for req.etypes) then\n                error_out(KDC_ERR_ETYPE_NOSUPP);\n   \
    \     endif\n        new_tkt.vno := ticket version; /* = 5 */\n        new_tkt.sname\
    \ := req.sname;\n        new_tkt.srealm := realm;\n        reset all flags in\
    \ new_tkt.flags;\n        /* It should be noted that local policy may affect the\
    \  */\n        /* processing of any of these flags.  For example, some */\n  \
    \      /* realms may refuse to issue renewable tickets         */\n        new_tkt.caddr\
    \ := tgt.caddr;\n        resp.caddr := NULL; /* We only include this if they change\
    \ */\n        if (req.kdc-options.FORWARDABLE is set) then\n                if\
    \ (tgt.flags.FORWARDABLE is reset) then\n                        error_out(KDC_ERR_BADOPTION);\n\
    \                endif\n                set new_tkt.flags.FORWARDABLE;\n     \
    \   endif\n        if (req.kdc-options.FORWARDED is set) then\n              \
    \  if (tgt.flags.FORWARDABLE is reset) then\n                        error_out(KDC_ERR_BADOPTION);\n\
    \                endif\n                set new_tkt.flags.FORWARDED;\n       \
    \         new_tkt.caddr := req.addresses;\n                resp.caddr := req.addresses;\n\
    \        endif\n        if (tgt.flags.FORWARDED is set) then\n               \
    \ set new_tkt.flags.FORWARDED;\n        endif\n        if (req.kdc-options.PROXIABLE\
    \ is set) then\n                if (tgt.flags.PROXIABLE is reset)\n          \
    \              error_out(KDC_ERR_BADOPTION);\n                endif\n        \
    \        set new_tkt.flags.PROXIABLE;\n        endif\n        if (req.kdc-options.PROXY\
    \ is set) then\n                if (tgt.flags.PROXIABLE is reset) then\n     \
    \                   error_out(KDC_ERR_BADOPTION);\n                endif\n   \
    \             set new_tkt.flags.PROXY;\n                new_tkt.caddr := req.addresses;\n\
    \                resp.caddr := req.addresses;\n        endif\n        if (req.kdc-options.POSTDATE\
    \ is set) then\n                if (tgt.flags.POSTDATE is reset)\n           \
    \             error_out(KDC_ERR_BADOPTION);\n                endif\n         \
    \       set new_tkt.flags.POSTDATE;\n        endif\n        if (req.kdc-options.POSTDATED\
    \ is set) then\n                if (tgt.flags.POSTDATE is reset) then\n      \
    \                  error_out(KDC_ERR_BADOPTION);\n                endif\n    \
    \            set new_tkt.flags.POSTDATED;\n                set new_tkt.flags.INVALID;\n\
    \                if (against_postdate_policy(req.from)) then\n               \
    \         error_out(KDC_ERR_POLICY);\n                endif\n                new_tkt.starttime\
    \ := req.from;\n        endif\n        if (req.kdc-options.VALIDATE is set) then\n\
    \                if (tgt.flags.INVALID is reset) then\n                      \
    \  error_out(KDC_ERR_POLICY);\n                endif\n                if (tgt.starttime\
    \ > kdc_time) then\n                        error_out(KRB_AP_ERR_NYV);\n     \
    \           endif\n                if (check_hot_list(tgt)) then\n           \
    \             error_out(KRB_AP_ERR_REPEAT);\n                endif\n         \
    \       tkt := tgt;\n                reset new_tkt.flags.INVALID;\n        endif\n\
    \        if (req.kdc-options.(any flag except ENC-TKT-IN-SKEY, RENEW,\n      \
    \                       and those already processed) is set) then\n          \
    \      error_out(KDC_ERR_BADOPTION);\n        endif\n        new_tkt.authtime\
    \ := tgt.authtime;\n        if (req.kdc-options.RENEW is set) then\n         \
    \ /* Note that if the endtime has already passed, the ticket */\n          /*\
    \ would have been rejected in the initial authentication  */\n          /* stage,\
    \ so there is no need to check again here          */\n                if (tgt.flags.RENEWABLE\
    \ is reset) then\n                        error_out(KDC_ERR_BADOPTION);\n    \
    \            endif\n                if (tgt.renew-till >= kdc_time) then\n   \
    \                     error_out(KRB_AP_ERR_TKT_EXPIRED);\n                endif\n\
    \                tkt := tgt;\n                new_tkt.starttime := kdc_time;\n\
    \                old_life := tgt.endttime - tgt.starttime;\n                new_tkt.endtime\
    \ := min(tgt.renew-till,\n                                       new_tkt.starttime\
    \ + old_life);\n        else\n                new_tkt.starttime := kdc_time;\n\
    \                if (req.till = 0) then\n                        till := infinity;\n\
    \                else\n                        till := req.till;\n           \
    \     endif\n                new_tkt.endtime := min(till,\n                  \
    \                 new_tkt.starttime+client.max_life,\n                       \
    \            new_tkt.starttime+server.max_life,\n                            \
    \       new_tkt.starttime+max_life_for_realm,\n                              \
    \     tgt.endtime);\n                if ((req.kdc-options.RENEWABLE-OK is set)\
    \ and\n                    (new_tkt.endtime < req.till) and\n                \
    \    (tgt.flags.RENEWABLE is set) then\n                        /* we set the\
    \ RENEWABLE option for later  */\n                        /* processing      \
    \                       */\n                        set req.kdc-options.RENEWABLE;\n\
    \                        req.rtime := min(req.till, tgt.renew-till);\n       \
    \         endif\n        endif\n        if (req.rtime = 0) then\n            \
    \    rtime := infinity;\n        else\n                rtime := req.rtime;\n \
    \       endif\n        if ((req.kdc-options.RENEWABLE is set) and\n          \
    \  (tgt.flags.RENEWABLE is set)) then\n                set new_tkt.flags.RENEWABLE;\n\
    \                new_tkt.renew-till := min(rtime,\n                new_tkt.starttime+client.max_rlife,\n\
    \                new_tkt.starttime+server.max_rlife,\n                new_tkt.starttime+max_rlife_for_realm,\n\
    \                tgt.renew-till);\n        else\n                new_tkt.renew-till\
    \ := OMIT;\n                              /* leave the renew-till field out */\n\
    \        endif\n        if (req.enc-authorization-data is present) then\n    \
    \            decrypt req.enc-authorization-data\n                        into\
    \    decrypted_authorization_data\n                        using auth_hdr.authenticator.subkey;\n\
    \                if (decrypt_error()) then\n                        error_out(KRB_AP_ERR_BAD_INTEGRITY);\n\
    \                endif\n        endif\n        new_tkt.authorization_data :=\n\
    \        req.auth_hdr.ticket.authorization_data +\n                          \
    \       decrypted_authorization_data;\n        new_tkt.key := session;\n     \
    \   new_tkt.crealm := tgt.crealm;\n        new_tkt.cname := req.auth_hdr.ticket.cname;\n\
    \        if (realm_tgt_is_for(tgt) := tgt.realm) then\n                /* tgt\
    \ issued by local realm */\n                new_tkt.transited := tgt.transited;\n\
    \        else\n                /* was issued for this realm by some other realm\
    \ */\n                if (tgt.transited.tr-type not supported) then\n        \
    \                error_out(KDC_ERR_TRTYPE_NOSUPP);\n                endif\n  \
    \              new_tkt.transited\n                   := compress_transited(tgt.transited\
    \ + tgt.realm)\n        endif\n        encode encrypted part of new_tkt into OCTET\
    \ STRING;\n        if (req.kdc-options.ENC-TKT-IN-SKEY is set) then\n        \
    \        if (server not specified) then\n                        server = req.second_ticket.client;\n\
    \                endif\n                if ((req.second_ticket is not a TGT) or\n\
    \                    (req.second_ticket.client != server)) then\n            \
    \            error_out(KDC_ERR_POLICY);\n                endif\n             \
    \   new_tkt.enc-part := encrypt OCTET STRING using\n                        using\
    \ etype_for_key(second-ticket.key),\n                                        \
    \              second-ticket.key;\n        else\n                new_tkt.enc-part\
    \ := encrypt OCTET STRING\n                        using etype_for_key(server.key),\
    \ server.key,\n                                                      server.p_kvno;\n\
    \        endif\n        resp.pvno := 5;\n        resp.msg-type := KRB_TGS_REP;\n\
    \        resp.crealm := tgt.crealm;\n        resp.cname := tgt.cname;\n      \
    \  resp.ticket := new_tkt;\n        resp.key := session;\n        resp.nonce :=\
    \ req.nonce;\n        resp.last-req := fetch_last_request_info(client);\n    \
    \    resp.flags := new_tkt.flags;\n        resp.authtime := new_tkt.authtime;\n\
    \        resp.starttime := new_tkt.starttime;\n        resp.endtime := new_tkt.endtime;\n\
    \        omit resp.key-expiration;\n        resp.sname := new_tkt.sname;\n   \
    \     resp.realm := new_tkt.realm;\n        if (new_tkt.flags.RENEWABLE) then\n\
    \                resp.renew-till := new_tkt.renew-till;\n        endif\n     \
    \   encode body of reply into OCTET STRING;\n        if (req.padata.authenticator.subkey)\n\
    \                resp.enc-part := encrypt OCTET STRING using use_etype,\n    \
    \                    req.padata.authenticator.subkey;\n        else resp.enc-part\
    \ := encrypt OCTET STRING\n                              using use_etype, tgt.key;\n\
    \        send(resp);\n"
- title: A.7.  KRB_TGS_REP verification
  contents:
  - "A.7.  KRB_TGS_REP verification\n        decode response into resp;\n        if\
    \ (resp.msg-type = KRB_ERROR) then\n                process_error(resp);\n   \
    \             return;\n        endif\n        /* On error, discard the response,\
    \ and zero the session key from\n        the response immediately */\n       \
    \ if (req.padata.authenticator.subkey)\n                unencrypted part of resp\
    \ :=\n                        decode of decrypt of resp.enc-part\n           \
    \             using resp.enc-part.etype and subkey;\n        else unencrypted\
    \ part of resp :=\n                        decode of decrypt of resp.enc-part\n\
    \                        using resp.enc-part.etype and tgt's session key;\n  \
    \      if (common_as_rep_tgs_rep_checks fail) then\n                destroy resp.key;\n\
    \                return error;\n        endif\n        check authorization_data\
    \ as necessary;\n        save_for_later(ticket,session,client,server,times,flags);\n"
- title: A.8.  Authenticator generation
  contents:
  - "A.8.  Authenticator generation\n        body.authenticator-vno := authenticator\
    \ vno; /* = 5 */\n        body.cname, body.crealm := client name;\n        if\
    \ (supplying checksum) then\n                body.cksum := checksum;\n       \
    \ endif\n        get system_time;\n        body.ctime, body.cusec := system_time;\n\
    \        if (selecting sub-session key) then\n                select sub-session\
    \ key;\n                body.subkey := sub-session key;\n        endif\n     \
    \   if (using sequence numbers) then\n                select initial sequence\
    \ number;\n                body.seq-number := initial sequence;\n        endif\n"
- title: A.9.  KRB_AP_REQ generation
  contents:
  - "A.9.  KRB_AP_REQ generation\n        obtain ticket and session_key from cache;\n\
    \        packet.pvno := protocol version; /* 5 */\n        packet.msg-type :=\
    \ message type; /* KRB_AP_REQ */\n        if (desired(MUTUAL_AUTHENTICATION))\
    \ then\n                set packet.ap-options.MUTUAL-REQUIRED;\n        else\n\
    \                reset packet.ap-options.MUTUAL-REQUIRED;\n        endif\n   \
    \     if (using session key for ticket) then\n                set packet.ap-options.USE-SESSION-KEY;\n\
    \        else\n                reset packet.ap-options.USE-SESSION-KEY;\n    \
    \    endif\n        packet.ticket := ticket; /* ticket */\n        generate authenticator;\n\
    \        encode authenticator into OCTET STRING;\n        encrypt OCTET STRING\
    \ into packet.authenticator\n                             using session_key;\n"
- title: A.10.  KRB_AP_REQ verification
  contents:
  - "A.10.  KRB_AP_REQ verification\n        receive packet;\n        if (packet.pvno\
    \ != 5) then\n                either process using other protocol spec\n     \
    \           or error_out(KRB_AP_ERR_BADVERSION);\n        endif\n        if (packet.msg-type\
    \ != KRB_AP_REQ) then\n                error_out(KRB_AP_ERR_MSG_TYPE);\n     \
    \   endif\n        if (packet.ticket.tkt_vno != 5) then\n                either\
    \ process using other protocol spec\n                or error_out(KRB_AP_ERR_BADVERSION);\n\
    \        endif\n        if (packet.ap_options.USE-SESSION-KEY is set) then\n \
    \               retrieve session key from ticket-granting ticket for\n       \
    \          packet.ticket.{sname,srealm,enc-part.etype};\n        else\n      \
    \     retrieve service key for\n           packet.ticket.{sname,srealm,enc-part.etype,enc-part.skvno};\n\
    \        endif\n        if (no_key_available) then\n                if (cannot_find_specified_skvno)\
    \ then\n                        error_out(KRB_AP_ERR_BADKEYVER);\n           \
    \     else\n                        error_out(KRB_AP_ERR_NOKEY);\n           \
    \     endif\n        endif\n        decrypt packet.ticket.enc-part into decr_ticket\n\
    \                                       using retrieved key;\n        if (decryption_error())\
    \ then\n                error_out(KRB_AP_ERR_BAD_INTEGRITY);\n        endif\n\
    \        decrypt packet.authenticator into decr_authenticator\n              \
    \  using decr_ticket.key;\n        if (decryption_error()) then\n            \
    \    error_out(KRB_AP_ERR_BAD_INTEGRITY);\n        endif\n        if (decr_authenticator.{cname,crealm}\
    \ !=\n            decr_ticket.{cname,crealm}) then\n                error_out(KRB_AP_ERR_BADMATCH);\n\
    \        endif\n        if (decr_ticket.caddr is present) then\n             \
    \   if (sender_address(packet) is not in decr_ticket.caddr)\n                \
    \        then error_out(KRB_AP_ERR_BADADDR);\n                endif\n        elseif\
    \ (application requires addresses) then\n                error_out(KRB_AP_ERR_BADADDR);\n\
    \        endif\n        if (not in_clock_skew(decr_authenticator.ctime,\n    \
    \                          decr_authenticator.cusec)) then\n                error_out(KRB_AP_ERR_SKEW);\n\
    \        endif\n        if (repeated(decr_authenticator.{ctime,cusec,cname,crealm}))\n\
    \                then error_out(KRB_AP_ERR_REPEAT);\n        endif\n        save_identifier(decr_authenticator.{ctime,cusec,cname,crealm});\n\
    \        get system_time;\n        if ((decr_ticket.starttime-system_time > CLOCK_SKEW)\
    \ or\n            (decr_ticket.flags.INVALID is set)) then\n                /*\
    \ it hasn't yet become valid */\n                error_out(KRB_AP_ERR_TKT_NYV);\n\
    \        endif\n        if (system_time-decr_ticket.endtime > CLOCK_SKEW) then\n\
    \                error_out(KRB_AP_ERR_TKT_EXPIRED);\n        endif\n        /*\
    \ caller must check decr_ticket.flags for any pertinent */\n        /* details\
    \ */\n        return(OK, decr_ticket, packet.ap_options.MUTUAL-REQUIRED);\n"
- title: A.11.  KRB_AP_REP generation
  contents:
  - "A.11.  KRB_AP_REP generation\n        packet.pvno := protocol version; /* 5 */\n\
    \        packet.msg-type := message type; /* KRB_AP_REP */\n        body.ctime\
    \ := packet.ctime;\n        body.cusec := packet.cusec;\n        if (selecting\
    \ sub-session key) then\n                select sub-session key;\n           \
    \     body.subkey := sub-session key;\n        endif\n        if (using sequence\
    \ numbers) then\n                select initial sequence number;\n           \
    \     body.seq-number := initial sequence;\n        endif\n        encode body\
    \ into OCTET STRING;\n        select encryption type;\n        encrypt OCTET STRING\
    \ into packet.enc-part;\n"
- title: A.12.  KRB_AP_REP verification
  contents:
  - "A.12.  KRB_AP_REP verification\n        receive packet;\n        if (packet.pvno\
    \ != 5) then\n                either process using other protocol spec\n     \
    \           or error_out(KRB_AP_ERR_BADVERSION);\n        endif\n        if (packet.msg-type\
    \ != KRB_AP_REP) then\n                error_out(KRB_AP_ERR_MSG_TYPE);\n     \
    \   endif\n        cleartext := decrypt(packet.enc-part)\n                   \
    \  using ticket's session key;\n        if (decryption_error()) then\n       \
    \         error_out(KRB_AP_ERR_BAD_INTEGRITY);\n        endif\n        if (cleartext.ctime\
    \ != authenticator.ctime) then\n                error_out(KRB_AP_ERR_MUT_FAIL);\n\
    \        endif\n        if (cleartext.cusec != authenticator.cusec) then\n   \
    \             error_out(KRB_AP_ERR_MUT_FAIL);\n        endif\n        if (cleartext.subkey\
    \ is present) then\n                save cleartext.subkey for future use;\n  \
    \      endif\n        if (cleartext.seq-number is present) then\n            \
    \    save cleartext.seq-number for future verifications;\n        endif\n    \
    \    return(AUTHENTICATION_SUCCEEDED);\n"
- title: A.13.  KRB_SAFE generation
  contents:
  - "A.13.  KRB_SAFE generation\n        collect user data in buffer;\n        /*\
    \ assemble packet: */\n        packet.pvno := protocol version; /* 5 */\n    \
    \    packet.msg-type := message type; /* KRB_SAFE */\n        body.user-data :=\
    \ buffer; /* DATA */\n        if (using timestamp) then\n                get system_time;\n\
    \                body.timestamp, body.usec := system_time;\n        endif\n  \
    \      if (using sequence numbers) then\n                body.seq-number := sequence\
    \ number;\n        endif\n        body.s-address := sender host addresses;\n \
    \       if (only one recipient) then\n                body.r-address := recipient\
    \ host address;\n        endif\n        checksum.cksumtype := checksum type;\n\
    \        compute checksum over body;\n        checksum.checksum := checksum value;\
    \ /* checksum.checksum */\n        packet.cksum := checksum;\n        packet.safe-body\
    \ := body;\n"
- title: A.14.  KRB_SAFE verification
  contents:
  - "A.14.  KRB_SAFE verification\n        receive packet;\n        if (packet.pvno\
    \ != 5) then\n                either process using other protocol spec\n     \
    \           or error_out(KRB_AP_ERR_BADVERSION);\n        endif\n        if (packet.msg-type\
    \ != KRB_SAFE) then\n                error_out(KRB_AP_ERR_MSG_TYPE);\n       \
    \ endif\n        if (packet.checksum.cksumtype is not both collision-proof\n \
    \                                            and keyed) then\n               \
    \ error_out(KRB_AP_ERR_INAPP_CKSUM);\n        endif\n        if (safe_priv_common_checks_ok(packet))\
    \ then\n                set computed_checksum := checksum(packet.body);\n    \
    \            if (computed_checksum != packet.checksum) then\n                \
    \        error_out(KRB_AP_ERR_MODIFIED);\n                endif\n            \
    \    return (packet, PACKET_IS_GENUINE);\n        else\n                return\
    \ common_checks_error;\n        endif\n"
- title: A.15.  KRB_SAFE and KRB_PRIV common checks
  contents:
  - "A.15.  KRB_SAFE and KRB_PRIV common checks\n        if (packet.s-address != O/S_sender(packet))\
    \ then\n            /* O/S report of sender not who claims to have sent it */\n\
    \            error_out(KRB_AP_ERR_BADADDR);\n        endif\n        if ((packet.r-address\
    \ is present) and\n            (packet.r-address != local_host_address)) then\n\
    \                /* was not sent to proper place */\n                error_out(KRB_AP_ERR_BADADDR);\n\
    \        endif\n        if (((packet.timestamp is present) and\n             (not\
    \ in_clock_skew(packet.timestamp,packet.usec))) or\n            (packet.timestamp\
    \ is not present and timestamp expected))\n                then error_out(KRB_AP_ERR_SKEW);\n\
    \        endif\n        if (repeated(packet.timestamp,packet.usec,packet.s-address))\n\
    \                then error_out(KRB_AP_ERR_REPEAT);\n        endif\n        if\
    \ (((packet.seq-number is present) and\n             ((not in_sequence(packet.seq-number))))\
    \ or\n            (packet.seq-number is not present and sequence expected))\n\
    \                then error_out(KRB_AP_ERR_BADORDER);\n        endif\n       \
    \ if (packet.timestamp not present and\n            packet.seq-number not present)\
    \ then\n                error_out(KRB_AP_ERR_MODIFIED);\n        endif\n     \
    \   save_identifier(packet.{timestamp,usec,s-address},\n                     \
    \   sender_principal(packet));\n        return PACKET_IS_OK;\n"
- title: A.16.  KRB_PRIV generation
  contents:
  - "A.16.  KRB_PRIV generation\n        collect user data in buffer;\n        /*\
    \ assemble packet: */\n        packet.pvno := protocol version; /* 5 */\n    \
    \    packet.msg-type := message type; /* KRB_PRIV */\n        packet.enc-part.etype\
    \ := encryption type;\n        body.user-data := buffer;\n        if (using timestamp)\
    \ then\n                get system_time;\n                body.timestamp, body.usec\
    \ := system_time;\n        endif\n        if (using sequence numbers) then\n \
    \               body.seq-number := sequence number;\n        endif\n        body.s-address\
    \ := sender host addresses;\n        if (only one recipient) then\n          \
    \      body.r-address := recipient host address;\n        endif\n        encode\
    \ body into OCTET STRING;\n        select encryption type;\n        encrypt OCTET\
    \ STRING into packet.enc-part.cipher;\n"
- title: A.17.  KRB_PRIV verification
  contents:
  - "A.17.  KRB_PRIV verification\n        receive packet;\n        if (packet.pvno\
    \ != 5) then\n                either process using other protocol spec\n     \
    \           or error_out(KRB_AP_ERR_BADVERSION);\n        endif\n        if (packet.msg-type\
    \ != KRB_PRIV) then\n                error_out(KRB_AP_ERR_MSG_TYPE);\n       \
    \ endif\n        cleartext := decrypt(packet.enc-part) using negotiated key;\n\
    \        if (decryption_error()) then\n                error_out(KRB_AP_ERR_BAD_INTEGRITY);\n\
    \        endif\n        if (safe_priv_common_checks_ok(cleartext)) then\n    \
    \        return(cleartext.DATA, PACKET_IS_GENUINE_AND_UNMODIFIED);\n        else\n\
    \                return common_checks_error;\n        endif\n"
- title: A.18.  KRB_CRED generation
  contents:
  - "A.18.  KRB_CRED generation\n        invoke KRB_TGS; /* obtain tickets to be provided\
    \ to peer */\n        /* assemble packet: */\n        packet.pvno := protocol\
    \ version; /* 5 */\n        packet.msg-type := message type; /* KRB_CRED */\n\
    \        for (tickets[n] in tickets to be forwarded) do\n                packet.tickets[n]\
    \ = tickets[n].ticket;\n        done\n        packet.enc-part.etype := encryption\
    \ type;\n        for (ticket[n] in tickets to be forwarded) do\n             \
    \   body.ticket-info[n].key = tickets[n].session;\n                body.ticket-info[n].prealm\
    \ = tickets[n].crealm;\n                body.ticket-info[n].pname = tickets[n].cname;\n\
    \                body.ticket-info[n].flags = tickets[n].flags;\n             \
    \   body.ticket-info[n].authtime = tickets[n].authtime;\n                body.ticket-info[n].starttime\
    \ = tickets[n].starttime;\n                body.ticket-info[n].endtime = tickets[n].endtime;\n\
    \                body.ticket-info[n].renew-till = tickets[n].renew-till;\n   \
    \             body.ticket-info[n].srealm = tickets[n].srealm;\n              \
    \  body.ticket-info[n].sname = tickets[n].sname;\n                body.ticket-info[n].caddr\
    \ = tickets[n].caddr;\n        done\n        get system_time;\n        body.timestamp,\
    \ body.usec := system_time;\n        if (using nonce) then\n                body.nonce\
    \ := nonce;\n        endif\n        if (using s-address) then\n              \
    \  body.s-address := sender host addresses;\n        endif\n        if (limited\
    \ recipients) then\n                body.r-address := recipient host address;\n\
    \        endif\n        encode body into OCTET STRING;\n        select encryption\
    \ type;\n        encrypt OCTET STRING into packet.enc-part.cipher\n        using\
    \ negotiated encryption key;\n"
- title: A.19.  KRB_CRED verification
  contents:
  - "A.19.  KRB_CRED verification\n        receive packet;\n        if (packet.pvno\
    \ != 5) then\n                either process using other protocol spec\n     \
    \           or error_out(KRB_AP_ERR_BADVERSION);\n        endif\n        if (packet.msg-type\
    \ != KRB_CRED) then\n                error_out(KRB_AP_ERR_MSG_TYPE);\n       \
    \ endif\n        cleartext := decrypt(packet.enc-part) using negotiated key;\n\
    \        if (decryption_error()) then\n                error_out(KRB_AP_ERR_BAD_INTEGRITY);\n\
    \        endif\n        if ((packet.r-address is present or required) and\n  \
    \         (packet.s-address != O/S_sender(packet)) then\n            /* O/S report\
    \ of sender not who claims to have sent it */\n            error_out(KRB_AP_ERR_BADADDR);\n\
    \        endif\n        if ((packet.r-address is present) and\n            (packet.r-address\
    \ != local_host_address)) then\n                /* was not sent to proper place\
    \ */\n                error_out(KRB_AP_ERR_BADADDR);\n        endif\n        if\
    \ (not in_clock_skew(packet.timestamp,packet.usec)) then\n                error_out(KRB_AP_ERR_SKEW);\n\
    \        endif\n        if (repeated(packet.timestamp,packet.usec,packet.s-address))\n\
    \                then error_out(KRB_AP_ERR_REPEAT);\n        endif\n        if\
    \ (packet.nonce is required or present) and\n           (packet.nonce != expected-nonce)\
    \ then\n                error_out(KRB_AP_ERR_MODIFIED);\n        endif\n     \
    \   for (ticket[n] in tickets that were forwarded) do\n                save_for_later(ticket[n],key[n],principal[n],\n\
    \                               server[n],times[n],flags[n]);\n        return\n"
- title: A.20.  KRB_ERROR generation
  contents:
  - "A.20.  KRB_ERROR generation\n        /* assemble packet: */\n        packet.pvno\
    \ := protocol version; /* 5 */\n        packet.msg-type := message type; /* KRB_ERROR\
    \ */\n        get system_time;\n        packet.stime, packet.susec := system_time;\n\
    \        packet.realm, packet.sname := server name;\n        if (client time available)\
    \ then\n                packet.ctime, packet.cusec := client_time;\n        endif\n\
    \        packet.error-code := error code;\n        if (client name available)\
    \ then\n                packet.cname, packet.crealm := client name;\n        endif\n\
    \        if (error text available) then\n                packet.e-text := error\
    \ text;\n        endif\n        if (error data available) then\n             \
    \   packet.e-data := error data;\n        endif\n"
