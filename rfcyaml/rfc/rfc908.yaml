- title: __initial_text__
  contents:
  - "                          Reliable Data Protocol\n                          \
    \     David Velten\n                               Robert Hinden\n           \
    \           BBN Communications Corporation\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This RFC specifies a proposed protocol for the ARPA Internet\n\
    \   community, and requests discussion and suggestions for\n   improvements. \
    \ Distribution of this memo is unlimited.\n                             Table\
    \ of Contents\n     1   Introduction..........................................\
    \ 1\n     2   General Description................................... 3\n     2.1\
    \   Motivation.......................................... 3\n     2.2   Relation\
    \ to Other Protocols......................... 5\n     3   Protocol Operation....................................\
    \ 7\n     3.1   Protocol Service Objectives......................... 7\n     3.2\
    \   RDP Connection Management........................... 7\n     3.2.1   Opening\
    \ a Connection.............................. 8\n     3.2.2   Ports.............................................\
    \ 8\n     3.2.3   Connection States................................. 8\n     3.2.4\
    \   Connection Record................................ 11\n     3.2.5   Closing\
    \ a Connection............................. 13\n     3.2.6   Detecting an Half-Open\
    \ Connection................ 14\n     3.3   Data Communication.................................\
    \ 14\n     3.4   Reliable Communication............................. 15\n    \
    \ 3.4.1   Segment Sequence Numbers......................... 15\n     3.4.2   Checksums........................................\
    \ 16\n     3.4.3   Positive Acknowledgement of Segments............. 16\n    \
    \ 3.4.4   Retransmission Timeout........................... 17\n     3.5   Flow\
    \ Control and Window Management................. 17\n     3.6   User Interface.....................................\
    \ 19\n     3.7   Event Processing................................... 20\n    \
    \ 3.7.1   User Request Events.............................. 21\n     3.7.2   Segment\
    \ Arrival Events........................... 24\n     3.7.3   Timeout Events...................................\
    \ 29\n     4   RDP Segments and Formats............................. 31\n    \
    \ 4.1   IP Header Format................................... 31\n     4.2   RDP\
    \ Header Format.................................. 32\n     4.2.1   RDP Header\
    \ Fields................................ 33\n     4.3   SYN Segment........................................\
    \ 36\n     4.3.1   SYN Segment Format............................... 36\n    \
    \ 4.3.2   SYN Segment Fields............................... 37\n     4.4   ACK\
    \ Segment........................................ 38\n     4.4.1   ACK Segment\
    \ Format............................... 38\n     4.4.2   ACK Segment Fields...............................\
    \ 39\n     4.5   Extended ACK Segment............................... 40\n    \
    \ 4.5.1   EACK Segment Format.............................. 40\n     4.5.2   EACK\
    \ Segment Fields.............................. 40\n     4.6   RST Segment........................................\
    \ 42\n     4.6.1   RST Segment Format............................... 42\n    \
    \ 4.7   NUL Segment........................................ 43\n     4.7.1   NUL\
    \ segment format............................... 43\n     5   Examples of Operation................................\
    \ 45\n     5.1   Connection Establishment........................... 45\n    \
    \ 5.2   Simultaneous Connection Establishment.............. 46\n     5.3   Lost\
    \ Segments...................................... 47\n     5.4   Segments Received\
    \ Out of Order..................... 48\n     5.5   Communication Over Long Delay\
    \ Path................. 49\n     5.6   Communication Over Long Delay Path With\
    \ Lost\n       Segments\n          ....................................................\
    \ 50\n     5.7   Detecting a Half-Open  Connection  on  Crash\n       Recovery\n\
    \          .................................................... 51\n     5.8 \
    \  Detecting a Half-Open  Connection  from  the\n       Active Side\n        \
    \  .................................................... 52\n     A   Implementing\
    \ a Minimal RDP........................... 53\n                              \
    \    FIGURES\n     1  Relation to Other Protocols............................\
    \ 5\n     2  Form of Data Exchange Between Layers................... 6\n     3\
    \  RDP Connection State Diagram.......................... 10\n     4  Segment\
    \ Format........................................ 31\n     5  RDP Header Format.....................................\
    \ 32\n     6  SYN Segment Format.................................... 37\n    \
    \ 7  ACK Segment Format.................................... 38\n     8  EACK Segment\
    \ Format................................... 41\n     9  RST Segment Format....................................\
    \ 42\n     10  NUL Segment Format................................... 43\n    \
    \                             CHAPTER 1\n                               Introduction\n\
    \          The Reliable Data Protocol (RDP) is designed  to  provide  a\n    \
    \ reliable  data  transport  service  for packet-based applications\n     such\
    \ as remote loading and debugging.  The protocol  is  intended\n     to  be simple\
    \ to implement but still be efficient in environments\n     where there may be\
    \ long transmission  delays  and  loss  or  non-\n     sequential delivery of\
    \ message segments.\n          Although this protocol was designed with  applications\
    \  such\n     as  remote  loading and debugging in mind, it may be suitable for\n\
    \     other applications that require reliable message  services,  such\n    \
    \ as computer mail, file transfer, transaction processing, etc.\n          Some\
    \ of the concepts used come from a  variety  of  sources.\n     The  authors \
    \ wish credit to be given to Eric Rosen, Rob Gurwitz,\n     Jack Haverty, and\
    \ to acknowledge material adapted from  \"RFC-793,\n     The Transmission Control\
    \ Protocol\", edited by Jon Postel.  Thanks\n     to John Linn for the checksum\
    \ algorithm.\n                                 CHAPTER 2\n                   \
    \         General Description\n     2.1  Motivation\n          RDP is a transport\
    \ protocol designed to efficiently  support\n     the  bulk  transfer  of data\
    \ for such host monitoring and control\n     applications  as  loading/dumping\
    \  and  remote   debugging.    It\n     attempts to provide only those services\
    \ necessary, in order to be\n     efficient in operation and small in size.  Before\
    \  designing  the\n     protocol,  it  was  necessary  to  consider  what  minimum\
    \ set of\n     transport  functions  would  satisfy  the  requirements  of   the\n\
    \     intended applications.\n          The following is a list of requirements\
    \ for such a transport\n     protocol:\n         o   Reliable delivery of packets\
    \ is required.   When  loading\n             or  dumping  a  memory  image,  it\
    \  is necessary that all\n             memory segments be  delivered.   A  'hole'\
    \  left  in  the\n             memory  image  is  not acceptable.  However, the\
    \ internet\n             environment is a lossy  one  in  which  packets  can\
    \  get\n             damaged  or  lost.   So  a  positive  acknowledgement and\n\
    \             retransmission mechanism is a necessary component of  the\n    \
    \         protocol.\n         o   Since loading and  dumping  of  memory  images\
    \  over  the\n             internet  involves  the bulk transfer of large amounts\
    \ of\n             data over a lossy network with potentially  long  delays,\n\
    \             it  is necessary that the protocol move data efficiently.\n    \
    \         In particular,  unnecessary  retransmission  of  segments\n        \
    \     should be avoided.  If a single segment has been lost but\n            \
    \ succeeding  segments  correctly  received,  the  protocol\n             should\
    \  not  require  the  retransmission  of  all of the\n             segments.\n\
    \         o   Loading  and  dumping  are  applications  that   do   not\n    \
    \         necessarily  require  sequenced  delivery of segments, as\n        \
    \     long as all segments eventually are  delivered.   So  the\n            \
    \ protocol  need  not  force sequenced delivery.  For these\n             types\
    \ of applications, segments may be delivered  in  the\n             order in which\
    \ they arrive.\n         o   However, some  applications  may  need  to  know\
    \  that  a\n             particular  piece  of  data  has  been  delivered  before\n\
    \             sending the next.  For example, a debugger will  want  to\n    \
    \         know  that  a  command inserting a breakpoint into a host\n        \
    \     memory  image  has  been  delivered  before   sending   a\n            \
    \ \"proceed\"  command.   If  those  segments  arrived out of\n             sequence,\
    \ the intended results  would  not  be  achieved.\n             The  protocol\
    \  should  allow a user to optionally specify\n             that a connection\
    \  must  deliver  segments  in  sequence-\n             number order.\n      \
    \   o   The loading/dumping and debugging applications are  well-\n          \
    \   defined  and lend themselves to easy packetization of the\n             transferred\
    \ data.  They do not require  a  complex  byte-\n             stream transfer\
    \ mechanism.\n          In order to combine the requirements for bulk  transfers\
    \  of\n     data   and  reliable  delivery,  it  is  necessary  to  design  a\n\
    \     connection-oriented  protocol  using  a  three-way  handshake  to\n    \
    \ synchronize   sequence   numbers.    The  protocol  seems  to  be\n     approaching\
    \ TCP in complexity, so  why  was  TCP  not,  in  fact,\n     chosen?   The answer\
    \ is that TCP has some disadvantages for these\n     applications.  In particular:\n\
    \         o   TCP  is  oriented  toward  a  more  general  environment,\n    \
    \         supporting  the transfer of a stream of bytes between two\n        \
    \     communicating  parties.   TCP  is  best  suited   to   an\n            \
    \ environment where there is no obvious demarcation of data\n             in a\
    \ communications exchange.  Much of the difficulty  in\n             developing\
    \ a TCP implementation stems from the complexity\n             of supporting this\
    \ general byte-stream transfer, and thus\n             a  significant  amount\
    \  of  complexity  can be avoided by\n             using  another   protocol.\
    \    This   is   not   just   an\n             implementation consideration, but\
    \ also one of efficiency.\n         o   Since TCP does not allow a byte to be\
    \ acknowledged  until\n             all  prior  bytes have been acknowledged,\
    \ it often forces\n             unnecessary retransmission of data.  Therefore,\
    \  it  does\n             not meet another of the requirements stated above.\n\
    \         o   TCP  provides  sequenced  delivery   of   data   to   the\n    \
    \         application.   If  the  application does not require such\n        \
    \     sequenced delivery,  a  large  amount  of  resources  are\n            \
    \ wasted in providing it.  For example, buffers may be tied\n             up \
    \ buffering  data  until  a  segment  with  an  earlier\n             sequence\
    \  number  arrives.  The protocol should not force\n             its segment-sequencing\
    \ desires on the application.\n          RDP supports a much simpler set of functions\
    \ than TCP.   The\n     flow control, buffering, and connection management schemes\
    \ of RDP\n     are considerably  simpler  and  less  complex.   The  goal  is\
    \  a\n     protocol  that can be easily and efficiently implemented and that\n\
    \     will serve a range of applications.\n          RDP functions can also be\
    \ subset to further reduce the  size\n     of  a particular implementation.  For\
    \ example, a target processor\n     requiring down-loading from another host might\
    \ implement  an  RDP\n     module  supporting  only  the  passive Open function\
    \ and a single\n     connection.  The module might also choose not to  implement\
    \  out-\n     of-sequence acknowledgements.\n     2.2  Relation to Other Protocols\n\
    \          RDP is a transport  protocol  that  fits  into  the  layered\n    \
    \ internet protocol environment.  Figure 1 illustrates the place of\n     RDP\
    \ in the protocol hierarchy:\n      +------+   +-----+     +-----+      +------+\n\
    \      |TELNET|   | FTP |     |Debug|  ... |Loader|  Application Layer\n     \
    \ +------+   +-----+     +-----+      +------+\n         |          |        \
    \   |             |\n         +-----+----+           +------+------+\n       \
    \        |                       |\n            +------+               +-------+\n\
    \            |  TCP |               |  RDP  |        Transport Layer\n       \
    \     +------+               +-------+\n               |                     |\n\
    \      +--------------------------------+\n      | Internet Protocol & ICMP  \
    \     |            Internetwork Layer\n      +--------------------------------+\n\
    \                             |\n                   +-------------------------+\n\
    \                   | Network Access Protocol |      Network Layer\n         \
    \          +-------------------------+\n                        Relation to Other\
    \ Protocols\n                                 Figure 1\n          RDP provides\
    \ the application layer with a  reliable  message\n     transport service.  The\
    \ interface between users and RDP transfers\n     data in units of messages. \
    \  When  implemented  in  the  internet\n     environment,  RDP is layered on\
    \ the Internet Protocol (IP), which\n     provides an unreliable datagram service\
    \ to RDP.  Data  is  passed\n     across  the  RDP/IP  interface in the form of\
    \ segments.  RDP uses\n     the standard IP interface primitives  to  send  and\
    \  receive  RDP\n     segments  as  IP  datagrams.  At the internet level, IP\
    \ exchanges\n     datagrams with the network layer.  An internet packet may contain\n\
    \     an entire datagram or a fragment of a datagram.\n                      \
    \                                  #        %\n                              \
    \                            ?  *     !\n                                    \
    \                             @  )\n       +------+         +-----+         +----+\
    \          $  =   ^   +\n       |      |Messages |     |Segments |    | Datagrams\
    \   *\n       | User |<------->| RDP |<------->| IP |<------->    Internet\n \
    \      |      |         |     |         |    |          ,            ?\n     \
    \  +------+         +-----+         +----+               !    )\n            \
    \                                              *   %     $\n                 \
    \                                       @    ^   !\n                   Form of\
    \ Data Exchange Between Layers\n                                 Figure 2\n  \
    \        If internetwork services are  not  required,  it  should  be\n     possible\
    \  to  use  the  RDP without the IP layer.  As long as the\n     encapsulating\
    \ protocol  provides  the  RDP  with  such  necessary\n     information  as addressing\
    \ and protocol demultiplexing, it should\n     be possible  to  run  RDP  layered\
    \  on  a  variety  of  different\n     protocols.\n                          \
    \       CHAPTER 3\n                            Protocol Operation\n     3.1  Protocol\
    \ Service Objectives\n          The RDP protocol has the following goals:\n  \
    \       o   RDP will provide  a  full-duplex  communications  channel\n      \
    \       between the two ports of each transport connection.\n         o   RDP\
    \ will attempt to reliably deliver  all  user  messages\n             and  will\
    \  report  a  failure  to  the  user if it cannot\n             deliver a message.\
    \  RDP extends the datagram  service  of\n             IP to include reliable\
    \ delivery.\n         o   RDP will attempt to detect and discard  all  damaged\
    \  and\n             duplicate  segments.  It will use a checksum and sequence\n\
    \             number in each segment header to achieve this goal.\n         o\
    \   RDP  will  optionally  provide  sequenced   delivery   of\n             segments.\
    \    Sequenced   delivery  of  segments  must  be\n             specified when\
    \ the connection is established.\n         o   RDP will acknowledge segments received\
    \ out  of  sequence,\n             as  they  arrive.   This  will  free  up resources\
    \ on the\n             sending side.\n     3.2  RDP Connection Management\n  \
    \        RDP  is  a  connection-oriented  protocol  in   which   each\n     connection\
    \  acts  as  a full-duplex communication channel between\n     two processes.\
    \  Segments from a sender are directed to a port  on\n     the  destination host.\
    \  The two 8-bit source and destination port\n     identifiers in the RDP header\
    \ are used in  conjunction  with  the\n     network  source  and  destination\
    \  addresses to uniquely identify\n     each connection.\n     3.2.1  Opening\
    \ a Connection\n          Connections are opened by issuing the  Open  request,\
    \  which\n     can be either active or passive.  A passive Open request puts RDP\n\
    \     into the Listen state, during which it passively  listens  for  a\n    \
    \ request to open a connection from a remote site.  The active Open\n     request\
    \ attempts to establish a connection with a specified  port\n     at a remote\
    \ site.\n          The active Open request requires that a specific remote port\n\
    \     and host address be specified with the request.  The passive Open\n    \
    \ may  optionally  specify  a  specific  remote  port  and  network\n     address,\
    \  or it may specify that an open be accepted from anyone.\n     If a specific\
    \ remote port and host  address  were  specified,  an\n     arriving  request\
    \  to  open  a  connection must exactly match the\n     specified remote port\
    \ and address.\n     3.2.2  Ports\n          Valid port numbers range from 1 to\
    \ 255 (decimal). There  are\n     two  types  of  ports:  \"well known\" ports\
    \ and \"allocable\" ports.\n     Well-known ports have numbers in the range 1\
    \ to 63 (decimal)  and\n     allocable ports are given numbers in the range 64\
    \ to 255.\n          The user, when issuing an active Open request, must  specify\n\
    \     both  the  remote  host  and  port and may optionally specify the\n    \
    \ local port.  If the local port was not specified, RDP will select\n     an \
    \ unused port from the range of allocable ports. When issuing a\n     passive\
    \ Open request,  the  user  must  specify  the  local  port\n     number.   Generally,\
    \  in this case the local port will be a well-\n     known port.\n     3.2.3 \
    \ Connection States\n          An RDP connection will progress through a series\
    \  of  states\n     during  its  lifetime.   The states are shown in Figure 3\
    \ and are\n     individually described below.  In Figure 3, the  boxes  represent\n\
    \     the  states  of  the  RDP  FSM  and the arcs represent changes in\n    \
    \ state.  Each arc is annotated with the event  causing  the  state\n     change\
    \ and the resulting output.\n     CLOSED\n          The CLOSED state exists when\
    \ no connection exists and  there\n          is no connection record allocated.\n\
    \     LISTEN\n          The LISTEN state is entered after a passive Open request\
    \  is\n          processed.   A  connection record is allocated and RDP waits\n\
    \          for an active request  to  establish  a  connection  from  a\n    \
    \      remote site.\n     SYN-SENT\n          The SYN-SENT state is entered  after\
    \  processing  an  active\n          Open  request.  A connection record is allocated,\
    \ an initial\n          sequence number is generated, and a SYN segment is  sent\
    \  to\n          the  remote  site.  RDP then waits in the SYN-SENT state for\n\
    \          acknowledgement of its Open request.\n     SYN-RCVD\n          The\
    \ SYN-RCVD state may be reached  from  either  the  LISTEN\n          state  or\
    \ from the SYN-SENT state.  SYN-RCVD is reached from\n          the LISTEN state\
    \ when a SYN segment requesting a  connection\n          is  received  from  a\
    \  remote host.  In reply, the local RDP\n          generates an initial sequence\
    \ number for  its  side  of  the\n          connection,  and  then  sends  the\
    \  sequence  number  and an\n          acknowledgement of the SYN segment to the\
    \ remote  site.   It\n          then waits for an acknowledgement.\n         \
    \ The SYN-RCVD state is reached from the SYN-SENT state when a\n          SYN\
    \  segment  is  received  from  the remote host without an\n          accompanying\
    \ acknowledgement of the SYN segment sent to that\n          remote  host  by\
    \ the local RDP.  This situation is caused by\n          simultaneous attempts\
    \ to open a  connection,  with  the  SYN\n          segments  passing  each  other\
    \ in transit.  The action is to\n          repeat the SYN segment with the same\
    \  sequence  number,  but\n          now  including  an  ACK  of the remote host's\
    \ SYN segment to\n          indicate acceptance of the Open request.\n       \
    \                      +------------+\n              Passive Open   |        \
    \    |<-------------------------+\n            +----------------|   CLOSED   |\
    \                          |\n            |   Request      |            |---------------+\
    \          |\n            V                +------------+               |    \
    \      |\n     +------------+                                       |        \
    \  |\n     |            |                                       |          |\n\
    \     |   LISTEN   |                                       |          |\n    \
    \ |            |                                       |          |\n     +------------+\
    \                                       |          |\n            |          \
    \                         Active    |          |\n            |  rcv SYN     \
    \                  Open Request |          |\n            | -----------      \
    \              ------------ |          |\n            | snd SYN,ACK          \
    \            snd SYN    |          |\n            V                   rcv SYN\
    \                   V          |\n     +------------+          -----------   \
    \        +------------+    |\n     |            |          snd SYN,ACK       \
    \    |            |    |\n     |  SYN-RCVD  |<-------------------------------|\
    \  SYN-SENT  |    |\n     |            |                                |    \
    \        |    |\n     +------------+                                +------------+\
    \    |\n            |  rcv ACK                       rcv SYN,ACK  |          |\n\
    \            | ----------                    ------------- |          |\n    \
    \        |    xxx         +------------+    snd ACK    |          |\n        \
    \    |                |            |               |          |\n            +--------------->|\
    \    OPEN    |<--------------+          |\n                             |    \
    \        |                          |\n                             +------------+\
    \                          |\n                         rcv RST   |   Close request\
    \                 |\n                       ----------- |  ---------------   \
    \             |\n                           xxx     |     snd RST            \
    \         |\n                                   V                            \
    \     |\n                             +------------+                         \
    \ |\n                             |            |                          |\n\
    \                             | CLOSE-WAIT |--------------------------+\n    \
    \                         |            |  After a Delay\n                    \
    \         +------------+\n                       RDP Connection State Diagram\n\
    \                                 Figure 3\n     OPEN\n          The OPEN state\
    \ exists when a connection has been established\n          by  the successful\
    \ exchange of state information between the\n          two sides of the connection.\
    \  Each side  has  exchanged  and\n          received  such  data  as  initial\
    \  sequence  number, maximum\n          segment size, and maximum number of unacknowledged\
    \  segments\n          that may be outstanding.  In the Open state data may be\
    \ sent\n          between the two parties of the connection.\n     CLOSE-WAIT\n\
    \          The CLOSE-WAIT state is entered from either a Close  request\n    \
    \      or  from the receipt of an RST segment from the remote site.\n        \
    \  RDP has sent an RST segment and is waiting  a  delay  period\n          for\
    \ activity on the connection to complete.\n     3.2.4  Connection Record\n   \
    \       The variables that define the  state  of  a  connection  are\n     stored\
    \  in  a  connection  record maintained for each connection.\n     The following\
    \ describes some  of  the  variables  that  would  be\n     stored in a typical\
    \ RDP connection record.  It is not intended to\n     be  an  implementation \
    \ specification  nor  is  it   a   complete\n     description.   The  purpose\
    \  of naming and describing some of the\n     connection record fields is to simplify\
    \ the  description  of  RDP\n     protocol operation, particularly event processing.\n\
    \          The connection record fields and their descriptions follow:\n     STATE\n\
    \          The current state of the connection.  Legal values are OPEN,\n    \
    \      LISTEN, CLOSED, SYN-SENT, SYN-RCVD,  and CLOSE-WAIT.\n     Send Sequence\
    \ Number Variables:\n     SND.NXT\n          The sequence number of the next segment\
    \ that is to be sent.\n     SND.UNA\n          The sequence number of the oldest\
    \ unacknowledged segment.\n     SND.MAX\n          The maximum number of outstanding\
    \ (unacknowledged)  segments\n          that can be sent.  The sender should not\
    \ send more than this\n          number of segments without getting an acknowledgement.\n\
    \     SND.ISS\n          The initial send sequence  number.   This  is  the  sequence\n\
    \          number that was sent in the SYN segment.\n     Receive Sequence Number\
    \ Variables:\n     RCV.CUR\n          The sequence number of the last segment\
    \  received  correctly\n          and in sequence.\n     RCV.MAX\n          The\
    \ maximum number of segments that can be buffered for this\n          connection.\n\
    \     RCV.IRS\n          The initial receive sequence number.  This is  the  sequence\n\
    \          number of the SYN segment that established this connection.\n     RCVDSEQNO[n]\n\
    \          The array of sequence numbers of  segments  that  have  been\n    \
    \      received and acknowledged out of sequence.\n     Other Variables:\n   \
    \  CLOSEWAIT\n          A timer used to time out the CLOSE-WAIT state.\n     SBUF.MAX\n\
    \          The largest possible segment (in octets) that can legally be\n    \
    \      sent.  This variable is specified by the foreign host in the\n        \
    \  SYN segment during connection establishment.\n     RBUF.MAX\n          The\
    \  largest  possible  segment  (in  octets)  that  can  be\n          received.\
    \   This  variable is specified by the user when the\n          connection is\
    \ opened.  The variable is sent to  the  foreign\n          host in the SYN segment.\n\
    \     Variables from Current Segment:\n     SEG.SEQ\n          The  sequence \
    \ number  of  the   segment   currently   being\n          processed.\n     SEG.ACK\n\
    \          The acknowledgement sequence number in the segment currently\n    \
    \      being processed.\n     SEG.MAX\n          The maximum number of outstanding\
    \ segments the  receiver  is\n          willing  to  hold,  as  specified  in\
    \  the  SYN segment that\n          established the connection.\n     SEG.BMAX\n\
    \          The maximum segment size (in octets) accepted by the foreign\n    \
    \      host  on  a connection, as specified in the SYN segment that\n        \
    \  established the connection.\n     3.2.5  Closing a Connection\n          The\
    \ closing of a connection can  be  initiated  by  a  Close\n     request  from\
    \  the  user  process or by receipt of an RST segment\n     from the other end\
    \ of the connection.  In the case of  the  Close\n     request,  RDP  will  send\
    \ an RST segment to the other side of the\n     connection and then enter the\
    \ CLOSE-WAIT state for  a  period  of\n     time.   While  in the CLOSE-WAIT state,\
    \ RDP will discard segments\n     received from the other side of the connection.\
    \  When  the  time-\n     out  period expires, the connection record is deallocated\
    \ and the\n     connection ceases  to  exist.   This  simple  connection  closing\n\
    \     facility  requires  that  users  determine that all data has been\n    \
    \ reliably delivered before requesting a close of the connection.\n     3.2.6\
    \  Detecting an Half-Open Connection\n          If one side of a connection crashes,\
    \ the connection  may  be\n     left  with the other side still active.  This\
    \ situation is termed\n     to be an half-open connection.  For many cases,  the\
    \  active  RDP\n     will  eventually  detect the half-open connection and reset.\
    \  Two\n     examples of recovery from half-open connections are  provided  in\n\
    \     sections  5.7  and  5.8.   Recovery  is  usually achieved by user\n    \
    \ activity or by the crashed host's attempts  to  re-establish  the\n     connection.\n\
    \          However, there are cases  where  recovery  is  not  possible\n    \
    \ without action by the RDP itself.  For example, if all connection\n     blocks\
    \ are in use, attempts to re-establish a  broken  connection\n     will  be  rejected.\
    \   In  this  case, the RDP may attempt to free\n     resources by verifying \
    \ that connections are fully open. It  does\n     this  by  sending  a  NUL  segment\
    \ to each of the other RDPs.  An\n     acknowledgement indicates the connection\
    \ is still open and valid.\n          To minimize network overhead,  verification\
    \  of  connections\n     should  only  be  done  when  necessary  to  prevent\
    \  a  deadlock\n     situation.  Only inactive connections  should  be  verified.\
    \   An\n     inactive  connection  is  defined  to be a connection that has no\n\
    \     outstanding unacknowledged segments, has no segments in the  user\n    \
    \ input or output queues, and that has not had any traffic for some\n     period\
    \ of time.\n     3.3  Data Communication\n          Data  flows  through  an \
    \ RDP  connection  in  the  form  of\n     segments.   Each  user  message  submitted\
    \ with a Send request is\n     packaged for transport as a single RDP segment.\
    \  Each RDP segment\n     is packaged as an RDP header and one or more octets\
    \ of data.  RDP\n     will not attempt to fragment a large user  message  into\
    \  smaller\n     segments  and re-assemble the message on the receiving end. \
    \ This\n     differs from a byte-stream protocol such as  TCP  which  supports\n\
    \     the  transfer  of  an indeterminate length stream of data between\n    \
    \ ports, buffering data until it is requested by the receiver.\n          At the\
    \ RDP level, outgoing segments, as  they  are  created,\n     are queued as input\
    \ to the IP layer.  Each segment is held by the\n     sending RDP  until  it \
    \ is  acknowledged  by  the  foreign  host.\n     Incoming segments are queued\
    \ as input to the user process through\n     the user interface.  Segments are\
    \  acknowledged  when  they  have\n     been accepted by the receiving RDP.\n\
    \          The receiving end of each connection specifies  the  maximum\n    \
    \ segment  size  it  will  accept.   Any  attempt  by the sender to\n     transmit\
    \ a larger segment is an error.  If RDP determines that  a\n     buffer  submitted\
    \  with  a  Send request exceeds the maximum size\n     segment permitted on the\
    \ connection, RDP will return an error  to\n     the  user.   In addition, RDP\
    \ will abort a connection with an RST\n     segment if an  incoming  segment \
    \ contains  more  data  than  the\n     maximum  acceptable  segment  size.  \
    \ No  attempt will be made to\n     recover from or otherwise overcome this error\
    \ condition.\n          If  sequenced  delivery  of  segments  is  necessary \
    \ for  a\n     connection, the requirement must be stated when the connection\
    \ is\n     established.  Sequenced  delivery  is  specified  when  the  Open\n\
    \     request is made.  Sequenced delivery of segments will then be the\n    \
    \ mode of delivery for the life of the connection.\n     3.4  Reliable Communication\n\
    \          RDP implements a reliable message service through  a  number\n    \
    \ of  mechanisms.   These include the insertion of sequence numbers\n     and\
    \ checksums into  segments,  the  positive  acknowledgement  of\n     segment\
    \  receipt,  and  timeout  and  retransmission  of  missing\n     segments.\n\
    \     3.4.1  Segment Sequence Numbers\n          Each segment transporting data\
    \ has a  sequence  number  that\n     uniquely  identifies  it  among  all  other\
    \  segments in the same\n     connection.  The initial  sequence  number  is \
    \ chosen  when  the\n     connection  is  opened  and is selected by reading a\
    \ value from a\n     monotonically increasing clock.  Each time a  segment  containing\n\
    \     data   is   transmitted,  the  sequence  number  is  incremented.\n    \
    \ Segments containing no data do not increment the sequence number.\n     However,\
    \ the SYN and NUL segments, which cannot contain data, are\n     exceptions. \
    \ The  SYN  segment  is  always  sent  with  a  unique\n     sequence number,\
    \ the initial sequence number.  The NUL segment is\n     sent with the next valid\
    \ sequence number.\n     3.4.2  Checksums\n          Each RDP segment contains\
    \ a checksum to allow  the  receiver\n     to  detect  damaged  segments.   RDP\
    \  uses  a non-linear checksum\n     algorithm to compute a checksum that is 32-bits\
    \ wide and operates\n     on  data  in  units  of  four octets (32 bits).  The\
    \ area that is\n     covered by the checksum includes both the RDP header and\
    \ the  RDP\n     data area.\n          If a segment contains a number of  header\
    \  and  data  octets\n     that  is  not an integral multiple of 4 octets, the\
    \ last octet is\n     padded on the right with zeros to  form  a  32-bit  quantity\
    \  for\n     computation  purposes.   The padding zeros are not transmitted as\n\
    \     part of the segment.  While computing the checksum, the  checksum\n    \
    \ field  itself  is  replaced  with zeros.  The actual algorithm is\n     described\
    \ in Section 4.2.1.\n     3.4.3  Positive Acknowledgement of Segments\n      \
    \    RDP assumes it has only an unreliable  datagram  service  to\n     deliver\
    \  segments.   To  guarantee  delivery  of segments in this\n     environment,\
    \ RDP uses positive acknowledgement and retransmission\n     of  segments.   Each\
    \  segment containing data and the SYN and NUL\n     segments are acknowledged\
    \ when they are  correctly  received  and\n     accepted  by  the  destination\
    \ host.  Segments containing only an\n     acknowledgement  are  not  acknowledged.\
    \   Damaged  segments  are\n     discarded  and  are not acknowledged.  Segments\
    \ are retransmitted\n     when there is no timely acknowledgement of  the  segment\
    \  by  the\n     destination host.\n          RDP allows  two  types  of  acknowledgement.\
    \   A  cumulative\n     acknowledgement  is  used  to  acknowledge  all  segments\
    \ up to a\n     specified sequence number.  This type of acknowledgement  can\
    \  be\n     sent   using   fixed   length   fields  within  the  RDP  header.\n\
    \     Specifically,  the  ACK  control  flag  is  set  and   the   last\n    \
    \ acknowledged  sequence  number  is  placed in the Acknowledgement\n     Number\
    \ field.\n          The extended or non-cumulative  acknowledgement  allows  the\n\
    \     receiver  to  acknowledge segments out of sequence.  This type of\n    \
    \ acknowledgement is sent using  the  EACK  control  flag  and  the\n     variable\
    \  length  fields in the RDP segment header.  The variable\n     length header\
    \ fields are used to hold the sequence numbers of the\n     acknowledged out-of-sequence\
    \ segments.\n          The type of acknowledgement used is simply a function of\
    \ the\n     order  in which segments arrive.  Whenever possible, segments are\n\
    \     acknowledged using the cumulative acknowledgement segment.   Only\n    \
    \ out-of-sequence  segments  are  acknowledged  using  the extended\n     acknowledgement\
    \ option.\n          The user process, when  initiating  the  connection,  cannot\n\
    \     restrict the type of acknowledgement used on the connection.  The\n    \
    \ receiver   may   choose   not   to   implement    out-of-sequence\n     acknowledgements.\
    \   On  the  other hand, the sender may choose to\n     ignore out-of-sequence\
    \ acknowledgements.\n     3.4.4  Retransmission Timeout\n          Segments may\
    \ be lost in transmission for two  reasons:  they\n     may  be  lost  or  damaged\
    \  due  to  the  effects  of  the  lossy\n     transmission media; or they may\
    \ be  discarded  by  the  receiving\n     RDP.   The  positive acknowledgement\
    \ policy requires the receiver\n     to acknowledge a segment only when the segment\
    \ has been correctly\n     received and accepted.\n          To detect missing\
    \ segments,  the  sending  RDP  must  use  a\n     retransmission  timer for each\
    \ segment transmitted.  The timer is\n     set to a value approximating the transmission\
    \ time of the segment\n     in  the  network.   When  an  acknowledgement  is\
    \  received for a\n     segment, the timer is cancelled for that segment.  If\
    \  the  timer\n     expires before an acknowledgement is received for a segment,\
    \ that\n     segment is retransmitted and the timer is restarted.\n     3.5  Flow\
    \ Control and Window Management\n          RDP employs a simple flow control mechanism\
    \ that is based on\n     the  number  of  unacknowledged  segments  sent  and\
    \  the maximum\n     allowed number of outstanding  (unacknowledged)  segments.\
    \   Each\n     RDP  connection  has an associated set of flow control parameters\n\
    \     that include the maximum number of outstanding segments for  each\n    \
    \ side  of  a  connection.  These parameters are specified when the\n     connection\
    \ is opened with the Open request, with each side of the\n     connection   specifying\
    \  its  own parameters.  The parameters are\n     passed from  one  host  to \
    \ another  in  the  initial  connection\n     segments.\n          The values\
    \ specified for these parameters should be based on\n     the  amount  and  size\
    \  of  buffers  that  the  RDP is willing to\n     allocate to a connection. \
    \ The particular RDP implementation  can\n     set  the  parameters to values\
    \ that are optimal for its buffering\n     scheme.  Once these parameters  are\
    \  set  they  remain  unchanged\n     throughout the life of the connection.\n\
    \          RDP employs the concept of  a  sequence  number  window  for\n    \
    \ acceptable segment sequence numbers.  The left edge of the window\n     is the\
    \ number  of  the  last  in-sequence  acknowledged  sequence\n     number  plus\
    \  one.   The right edge of the window is equal to the\n     left edge plus twice\
    \ the allowed maximum  number  of  outstanding\n     segments.   The allowed maximum\
    \ number of outstanding segments is\n     the number of segments the transmitting\
    \ RDP software  is  allowed\n     to send without receiving any acknowledgement.\n\
    \          The flow control and window management parameters  are  used\n    \
    \ as  follows.   The  RDP  module  in  the  transmitting host sends\n     segments\
    \  until  it  reaches  the  connection's   segment   limit\n     specified  by\
    \ the receiving process.  Once this limit is reached,\n     the transmitting RDP\
    \ module may only send a new segment for  each\n     acknowledged segment.\n \
    \         When a received segment has a  sequence  number  that  falls\n     within\
    \  the  acceptance  window,  it  is  acknowledged.   If  the\n     sequence number\
    \ is equal to the left-hand edge (i.e., it  is  the\n     next  sequence number\
    \ expected), the segment is acknowledged with\n     a cumulative acknowledgement\
    \ (ACK).   The  acceptance  window  is\n     adjusted  by  adding  one  to  the\
    \  value  of  the edges.  If the\n     sequence number is within the acceptance\
    \ window  but  is  out  of\n     sequence,    it    is    acknowledged   with\
    \   a   non-cumulative\n     acknowledgement (EACK).  The window  is  not  adjusted,\
    \  but  the\n     receipt of the out-of-sequence segment is recorded.\n      \
    \    When  segments  are   acknowledged   out   of   order,   the\n     transmitting\
    \  RDP  module must not transmit beyond the acceptance\n     window.  This could\
    \ occur if one segment is not acknowledged  but\n     all  subsequent  segments\
    \  are  received  and acknowledged.  This\n     condition will fix the left edge\
    \ of the window  at  the  sequence\n     number of the unacknowledged segment.\
    \  As additional segments are\n     transmitted, the next  segment  to  be  sent\
    \  will  approach  and\n     eventually  overtake  the  right  window edge.  At\
    \ this point all\n     transmission of new segments will cease until the  unacknowledged\n\
    \     segment is acknowledged.\n     3.6  User Interface\n          The user interface\
    \ to RDP is  implementation  dependent  and\n     may  use  system  calls,  function\
    \ calls or some other mechanism.\n     The list of requests that follows is not\
    \ intended  to  suggest  a\n     particular implementation.\n     OPEN Request\n\
    \          Opens a connection.   Parameters  include  type  (active  or\n    \
    \      passive),  local  port,  remote  port,  remote host address,\n        \
    \  maximum  segment  size,  maximum  number  of  unacknowledged\n          segments,\
    \  delivery  mode (sequenced or non-sequenced).  The\n          connection id,\
    \  including  any  allocated  port  number,  is\n          returned to the user.\n\
    \     SEND Request\n          Sends  a  user  message.   Parameters   include\
    \   connection\n          identifier, buffer address and data count.\n     RECEIVE\
    \ Request\n          Receives a  user  message.   Parameters  include  connection\n\
    \          identifier, buffer address and data count.\n     CLOSE Request\n  \
    \        Closes a specified connection.  The single parameter is  the\n      \
    \    connection identifier.\n     STATUS Request\n          Returns the status\
    \ of a connection.  The parameters  include\n          the  connection  identifier\
    \  and  the  address of the status\n          buffer.\n     3.7  Event Processing\n\
    \          This section describes one possible sequence for  processing\n    \
    \ events.    It   is   not   intended   to   suggest  a  particular\n     implementation,\
    \ but any actual implementation  should  vary  from\n     this   description \
    \ only  in  detail  and  not  significantly  in\n     substance.  The following\
    \ are the kinds of events that may occur:\n          USER REQUESTS\n         \
    \       Open\n                Send\n                Receive\n                Close\n\
    \                Status\n          ARRIVING SEGMENT\n                Segment Arrives\n\
    \          TIMEOUTS\n                Retransmission Timeout\n                Close-Wait\
    \ Timeout\n          User request processing always terminates with a  return\
    \  to\n     the  caller,  with  a possible error indication.  Error responses\n\
    \     are given as a character string.   A  delayed  response  is  also\n    \
    \ possible  in  some  situations  and  is  returned  to the user by\n     whatever\
    \ event or pseudo interrupt mechanism is  available.   The\n     term \"signal\"\
    \ is used to refer to delayed responses.\n          Processing of arriving segments\
    \ usually follows this general\n     sequence:  the  sequence  number  is checked\
    \ for validity and, if\n     valid, the segment is queued  and  processed  in\
    \  sequence-number\n     order.   For  all events, unless a state change is specified,\
    \ RDP\n     remains in the same state.\n     3.7.1  User Request Events\n    \
    \      The following scenarios demonstrate the processing of events\n     caused\
    \ by the issuance of user requests:\n     Open Request\n       CLOSED STATE\n\
    \         Create a connection record\n         If none available\n           Return\
    \ \"Error - insufficient resources\"\n         Endif\n         If passive Open\n\
    \           If local port not specified\n             Return \"Error - local port\
    \ not specified\"\n           Endif\n           Generate SND.ISS\n           Set\
    \ SND.NXT = SND.ISS + 1\n               SND.UNA = SND.ISS\n           Fill in\
    \ SND.MAX, RMAX.BUF from Open parameters\n           Set State = LISTEN\n    \
    \       Return\n         Endif\n         If active Open\n           If remote\
    \ port not specified\n             Return \"Error - remote port not specified\"\
    \n           Endif\n           Generate SND.ISS\n           Set SND.NXT = SND.ISS\
    \ + 1\n               SND.UNA = SND.ISS\n           Fill in SND.MAX, RMAX.BUF\
    \ from Open parameters\n           If local port not specified\n             Allocate\
    \ a local port\n           Endif\n           Send <SEQ=SND.ISS><MAX=SND.MAX><MAXBUF=RMAX.BUF><SYN>\n\
    \           Set State = SYN-SENT\n           Return (local port, connection identifier)\n\
    \         Endif\n       LISTEN STATE\n       SYN-SENT STATE\n       SYN-RCVD STATE\n\
    \       OPEN STATE\n       CLOSE-WAIT STATE\n         Return \"Error - connection\
    \ already open\"\n     Close Request\n       OPEN STATE\n         Send <SEQ=SND.NXT><RST>\n\
    \         Set State = CLOSE-WAIT\n         Start TIMWAIT Timer\n         Return\n\
    \       LISTEN STATE\n         Set State = CLOSED\n         Deallocate connection\
    \ record\n         Return\n       SYN-RCVD STATE\n       SYN-SENT STATE\n    \
    \     Send <SEQ=SND.NXT><RST>\n         Set State = CLOSED\n         Return\n\
    \       CLOSE-WAIT STATE\n         Return \"Error - connection closing\"\n   \
    \    CLOSE STATE\n         Return \"Error - connection not open\"\n     Receive\
    \ Request\n       OPEN STATE\n         If Data is pending\n           Return with\
    \ data\n          else\n           Return with \"no data\" indication\n      \
    \   Endif\n       LISTEN STATE\n       SYN-RCVD STATE\n       SYN-SENT STATE\n\
    \         Return with \"no data\" indication\n       CLOSE STATE\n       CLOSE-WAIT\
    \ STATE\n         Return \"Error - connection not open\"\n     Send Request\n\
    \       OPEN STATE\n         If SND.NXT < SND.UNA + SND.MAX\n           Send <SEQ=SND.NXT><ACK=RCV.CUR><ACK><Data>\n\
    \           Set SND.NXT = SND.NXT + 1\n           Return\n          else\n   \
    \        Return \"Error - insufficient resources to send data\"\n         Endif\n\
    \       LISTEN STATE\n       SYN-RCVD STATE\n       SYN-SENT STATE\n       CLOSE\
    \ STATE\n       CLOSE-WAIT STATE\n         Return \"Error - connection not open\"\
    \n     Status Request\n       Return with:\n         State of connection (OPEN,\
    \ LISTEN, etc.)\n         Number of segments unacknowledged\n         Number of\
    \ segments received not given to user\n         Maximum segment size for the send\
    \ side of the connection\n         Maximum segment size for the receive side of\
    \ the connection\n     3.7.2  Segment Arrival Events\n          The following\
    \ scenarios describe the processing of the event\n     caused  by  the arrival\
    \ of a RDP segment from a remote host.  The\n     assumption is made that the\
    \ segment was addressed  to  the  local\n     port associated with the connection\
    \ record.\n     If State = CLOSED\n       If RST set\n         Discard segment\n\
    \         Return\n       Endif\n       If ACK or NUL set\n          Send <SEQ=SEG.ACK\
    \ + 1><RST>\n          Discard segment\n          Return\n        else\n     \
    \     Send <SEQ=0><RST><ACK=RCV.CUR><ACK>\n          Discard segment\n       \
    \   Return\n       Endif\n     Endif\n     If State = CLOSE-WAIT\n       If RST\
    \ set\n          Set State = CLOSED\n          Discard segment\n          Cancel\
    \ TIMWAIT timer\n          Deallocate connection record\n        else\n      \
    \    Discard segment\n       Endif\n       Return\n     Endif\n     If State =\
    \ LISTEN\n       If RST set\n         Discard the segment\n         Return\n \
    \      Endif\n       If ACK or NUL set\n         Send <SEQ=SEG.ACK + 1><RST>\n\
    \         Return\n       Endif\n       If SYN set\n         Set RCV.CUR = SEG.SEQ\n\
    \             RCV.IRS = SEG.SEQ\n             SND.MAX = SEG.MAX\n            \
    \ SBUF.MAX = SEG.BMAX\n         Send <SEQ=SND.ISS><ACK=RCV.CUR><MAX=RCV.MAX><BUFMAX=RBUF.MAX>\n\
    \              <ACK><SYN>\n         Set State = SYN-RCVD\n         Return\n  \
    \     Endif\n       If anything else (should never get here)\n         Discard\
    \ segment\n         Return\n       Endif\n     Endif\n     If State = SYN-SENT\n\
    \       If ACK set\n         If RST clear and SEG.ACK != SND.ISS\n           Send\
    \ <SEQ=SEG.ACK + 1><RST>\n         Endif\n         Discard segment; Return\n \
    \      Endif\n       If RST set\n         If ACK set\n           Signal \"Connection\
    \ Refused\"\n           Set State =  CLOSED\n           Deallocate connection\
    \ record\n         Endif\n         Discard segment\n         Return\n       Endif\n\
    \       If SYN set\n         Set RCV.CUR = SEG.SEQ\n             RCV.IRS = SEG.SEQ\n\
    \             SND.MAX = SEG.MAX\n             RBUF.MAX = SEG.BMAX\n         If\
    \ ACK set\n           Set SND.UNA = SEG.ACK\n           State = OPEN\n       \
    \    Send <SEQ=SND.NXT><ACK=RCV.CUR><ACK>\n          else\n           Set State\
    \ = SYN-RCVD\n           Send <SEQ=SND.ISS><ACK=RCV.CUR><MAX=RCV.MAX><BUFMAX=RBUF.MAX>\n\
    \                  <SYN><ACK>\n         Endif\n         Return\n       Endif\n\
    \       If anything else\n         Discard segment\n         Return\n       Endif\n\
    \     Endif\n     If State = SYN-RCVD\n       If RCV.IRS < SEG.SEQ =< RCV.CUR\
    \ + (RCV.MAX * 2)\n         Segment sequence number acceptable\n        else\n\
    \         Send <SEQ=SND.NXT><ACK=RCV.CUR><ACK>\n         Discard segment\n   \
    \      Return\n       Endif\n       If RST set\n         If passive Open\n   \
    \         Set State = LISTEN\n         else\n            Set State = CLOSED\n\
    \            Signal \"Connection Refused\"\n            Discard segment\n    \
    \        Deallocate connection record\n         Endif\n         Return\n     \
    \  Endif\n       If SYN set\n         Send <SEQ=SEG.ACK + 1><RST>\n         Set\
    \ State = CLOSED\n         Signal \"Connection Reset\"\n         Discard segment\n\
    \         Deallocate connection record\n         Return\n       Endif\n      \
    \ If EACK set\n          Send <SEQ=SEG.ACK + 1><RST>\n          Discard segment\n\
    \          Return\n       Endif\n       If ACK set\n         If SEG.ACK = SND.ISS\n\
    \            Set State = OPEN\n          else\n            Send <SEQ=SEG.ACK +\
    \ 1><RST>\n            Discard segment\n            Return\n         Endif\n \
    \       else\n         Discard segment\n         Return\n       Endif\n      \
    \ If Data in segment or NUL set\n         If the received segment is in sequence\n\
    \            Copy the data (if any) to user buffers\n            Set RCV.CUR=SEG.SEQ\n\
    \            Send <SEQ=SND.NXT><ACK=RCV.CUR><ACK>\n          else\n          \
    \  If out-of-sequence delivery permitted\n               Copy the data (if any)\
    \ to user buffers\n            Endif\n            Send <SEQ=SND.NXT><ACK=RCV.CUR><ACK><EACK><RCVDSEQNO1>\n\
    \                      ...<RCVDSEQNOn>\n         Endif\n       Endif\n     Endif\n\
    \     If State = OPEN\n       If RCV.CUR < SEG.SEQ =< RCV.CUR + (RCV.MAX * 2)\n\
    \         Segment sequence number acceptable\n        else\n         Send <SEQ=SND.NXT><ACK=RCV.CUR><ACK>\n\
    \         Discard segment and return\n       Endif\n       If RST set\n      \
    \   Set State = CLOSE-WAIT\n         Signal \"Connection Reset\"\n         Return\n\
    \       Endif\n       If NUL set\n         Set RCV.CUR=SEG.SEQ\n         Send\
    \ <SEQ=SND.NXT><ACK=RCV.CUR><ACK>\n         Discard segment\n         Return\n\
    \       Endif\n       If SYN set\n         Send <SEQ=SEG.ACK + 1><RST>\n     \
    \    Set State = CLOSED\n         Signal \"Connection Reset\"\n         Discard\
    \ segment\n         Deallocate connection record\n         Return\n       Endif\n\
    \       If ACK set\n         If SND.UNA =< SEG.ACK < SND.NXT\n           Set SND.UNA\
    \ = SEG.ACK\n           Flush acknowledged segments\n         Endif\n       Endif\n\
    \       If EACK set\n         Flush acknowledged segments\n       Endif\n    \
    \   If Data in segment\n        If the received segment is in sequence\n     \
    \     Copy the data to user buffers\n          Set RCV.CUR=SEG.SEQ\n         \
    \ Send <SEQ=SND.NXT><ACK=RCV.CUR><ACK>\n         else\n          If out-of-sequence\
    \ delivery permitted\n             Copy the data to user buffers\n          Endif\n\
    \          Send <SEQ=SND.NXT><ACK=RCV.CUR><ACK><EACK><RCVDSEQNO1>\n          \
    \            ...<RCVDSEQNOn>\n        Endif\n       Endif\n     Endif\n     3.7.3\
    \  Timeout Events\n          Timeout events occur when a timer expires  and  signals\
    \  the\n     RDP.  Two types of timeout events can occur, as described below:\n\
    \     RETRANSMISSION TIMEOUTS\n       If timeout on segment at head of retransmission\
    \ queue\n          Resend the segment at head of queue\n          Restart the\
    \ retransmission timer for the segment\n          Requeue the segment on retransmission\
    \ queue\n          Return\n       Endif\n     CLOSE-WAIT TIMEOUTS\n       Set\
    \ State = CLOSED\n       Deallocate connection record\n       Return\n       \
    \                          CHAPTER 4\n                         RDP Segments and\
    \ Formats\n          The segments sent by the application layer are  encapsulated\n\
    \     in  headers  by  the  transport,  internet and network layers, as\n    \
    \ follows:\n                            +----------------+\n                 \
    \           | Network Access |\n                            |     Header     |\n\
    \                            +----------------+\n                            |\
    \   IP Header    |\n                            +----------------+\n         \
    \                   |   RDP Header   |\n                            +----------------+\n\
    \                            |     D          |\n                            |\
    \      A         |\n                            |       T        |\n         \
    \                   |        A       |\n                            +----------------+\n\
    \                              Segment Format\n                              \
    \   Figure 4\n     4.1  IP Header Format\n          When used in the internet\
    \ environment, RDP segments are sent\n     using  the  version 4 IP header as\
    \ described in RFC791, \"Internet\n     Protocol.\"  The RDP protocol number is\
    \ ??? (decimal).  The  time-\n     to-live  field  should  be  set  to  a  reasonable\
    \  value for the\n     network.\n          All other fields should be set as specified\
    \ in RFC-791.\n     4.2  RDP Header Format\n          Every RDP segment is  prefaced\
    \  with  an  RDP  header.   The\n     format  of the header is shown in Figure\
    \ 5 below.  The RDP header\n     is variable in length and its size is indicated\
    \ by a field  in  a\n     fixed location within the header.\n                \
    \       0             0 0   1         1\n                       0 1 2 3 4 5 6\
    \ 7 8 9 0 1 2 3 4 5\n                      +-+-+-+-+-+-+---+---------------+\n\
    \                      |S|A|E|R|N| |Ver|    Header     |\n                   \
    \ 0 |Y|C|A|S|U|0|No.|    Length     |\n                      |N|K|K|T|L| |   |\
    \               |\n                      +-+-+-+-+-+-+---+---------------+\n \
    \                   1 | Source Port   |   Dest. Port  |\n                    \
    \  +---------------+---------------+\n                    2 |          Data  Length\
    \         |\n                      +---------------+---------------+\n       \
    \             3 |                               |\n                      +---\
    \    Sequence Number      ---+\n                    4 |                      \
    \         |\n                      +---------------+---------------+\n       \
    \             5 |                               |\n                      +---\
    \ Acknowledgement Number  ---+\n                    6 |                      \
    \         |\n                      +---------------+---------------+\n       \
    \             7 |                               |\n                      +---\
    \        Checksum         ---+\n                    8 |                      \
    \         |\n                      +---------------+---------------+\n       \
    \             9 |     Variable Header Area      |\n                      .   \
    \                            .\n                      .                      \
    \         .\n                      |                               |\n       \
    \               +---------------+---------------+\n                          \
    \   RDP Header Format\n                                 Figure 5\n     4.2.1 \
    \ RDP Header Fields\n     Control Flags\n          This 8-bit field occupies the\
    \ first octet of word one in the\n          header.  It is bit encoded with the\
    \ following bits currently\n          defined:\n          Bit #  Bit Name   Description\n\
    \          0      SYN        Establish connection and\n                      \
    \        synchronize sequence numbers.\n          1      ACK        Acknowledge\
    \ field significant.\n          2      EACK       Non-cumulative (Extended) acknowledgement.\n\
    \          3      RST        Reset the connection.\n          4      NUL     \
    \   This is a null (zero data length) segment.\n          5                 Unused.\n\
    \          Note that the SYN and RST are sent as separate segments  and\n    \
    \      may  not  contain  any  data.   The  ACK  may  accompany any\n        \
    \  message.  The NUL segment must have a zero data length,  but\n          may\
    \  be  accompanied by ACK and EACK information.  The other\n          control\
    \ bit is currently unused and is defined to be zero.\n     Version Number\n  \
    \        This field  occupies  bits  6-7  of  the  first  octet.   It\n      \
    \    contains  the  version  number  of the protocol described by\n          this\
    \ document.  Current value is one (1).\n     Header Length\n          The length\
    \ of the RDP header in units  of  two  (2)  octets,\n          including  this\
    \  field.   This  field allows RDP to find the\n          start of the Data field,\
    \ given a pointer to the head of  the\n          segment.   This  field  is  8\
    \ bits in length.  For a segment\n          with no variable header section, \
    \ the  header  length  field\n          will have the value 9.\n     Source and\
    \ Destination Ports\n          The Source and Destination Ports are used  to \
    \ identify  the\n          processes  in the two hosts that are communicating\
    \ with each\n          other.  The combination of the  port  identifiers  with\
    \  the\n          source  and  destination  addresses  in  the  network access\n\
    \          protocol header serves to fully qualify the  connection  and\n    \
    \      constitutes  the connection identifier.  This permits RDP to\n        \
    \  distinguish multiple connections between  two  hosts.   Each\n          field\
    \  is  8 bits in length, allowing port numbers from 0 to\n          255 (decimal).\n\
    \     Data Length\n          The length in octets of the data in this segment.\
    \  The  data\n          length  does  not  include the RDP header.  This field\
    \ is 16\n          bits in length.\n     Sequence Number\n          The sequence\
    \ number of this segment.  This field is 32  bits\n          in length.\n    \
    \ Acknowledgement Number\n          If the ACK bit is set in the header, this\
    \  is  the  sequence\n          number  of  the segment that the sender of this\
    \ segment last\n          received correctly and in sequence.  Once  a  connection\
    \  is\n          established  this  should  always be sent.  This field is 32\n\
    \          bits in length.\n     Checksum\n          This field is a 32-bit checksum\
    \ of the  segment  header  and\n          data.    The   algorithm   description\
    \  below  includes  two\n          variables,  the  checksum  accumulator  and\
    \   the   checksum\n          pointer.   The  checksum  accumulator  is  an  actual\
    \ 32-bit\n          register in which the  checksum  is  formed.   The  checksum\n\
    \          pointer   is   included  for  purposes  of  description,  to\n    \
    \      represent the operation of advancing through the  data  four\n        \
    \  octets  (32-bits) at a time.  It need not be maintained in a\n          register\
    \ by an implementation.\n          1) The checksum pointer is set to zero, to\
    \ correspond to the\n          beginning  of  the  area  to  be  checksummed.\
    \  The checksum\n          accumulator is also initialized to zero before beginning\
    \ the\n          computation of the checksum.\n          2) The 32-bit memory\
    \ word located at the address  referenced\n          by  the  checksum  pointer\
    \  is  added  arithmetically to the\n          checksum accumulator.   Any  carry\
    \  propagated  out  of  the\n          checksum  accumulator is ignored.  The\
    \ checksum field itself\n          is replaced with zeros when  being  added \
    \ to  the  checksum\n          accumulator.\n          3)  The  checksum  accumulator\
    \  is  rotated  left  one   bit\n          position.  The checksum pointer is\
    \ advanced to correspond to\n          the address of the next 32-bit word in\
    \ the segment.\n          4) Steps 2 and 3 are repeated until the entire  segment\
    \  has\n          been  summed.   If a segment contains a number of header and\n\
    \          data octets that is not an integral multiple  of  4  octets,\n    \
    \      the  last  octet is padded on the right with zeros to form a\n        \
    \  32-bit quantity for computation purposes.\n     Variable Header Area\n    \
    \      This area is used to transmit parameters  for  the  SYN  and\n        \
    \  EACK segments.\n     4.3  SYN Segment\n          The SYN is used to establish\
    \ a  connection  and  synchronize\n     sequence  numbers  between  two  hosts.\
    \   The  SYN  segment  also\n     contains information to inform the remote  host\
    \  of  the  maximum\n     number  of  segments  the local RDP  is willing to accept\
    \ and the\n     maximum segment size it can accept.  The SYN may be combined with\n\
    \     an ACK in a segment but is never combined with user data.\n     4.3.1  SYN\
    \ Segment Format\n                        0             0 0   1         1\n  \
    \                      0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                     \
    \  +-+-+-+-+-+-+---+---------------+\n                     0 |1|0|0|0|0|0|0 1|\
    \ Header Length |\n                       +-+-+-+-+-+-+---+---------------+\n\
    \                     1 | Source Port   |   Dest. Port  |\n                  \
    \     +---------------+---------------+\n                     2 |       Data \
    \ Length = 0        |\n                       +---------------+---------------+\n\
    \                     3 |                               |\n                  \
    \     +---    Sequence Number      ---+\n                     4 |            \
    \                   |\n                       +---------------+---------------+\n\
    \                     5 |                               |\n                  \
    \     +--- Acknowledgement Number  ---+\n                     6 |            \
    \                   |\n                       +---------------+---------------+\n\
    \                     7 |                               |\n                  \
    \     +---        Checksum         ---+\n                     8 |            \
    \                   |\n                       +---------------+---------------+\n\
    \                     9 | Max. # of Outstanding Segments|\n                  \
    \     +---------------+---------------+\n                    10 |       Max. Segment\
    \ Size       |\n                       +-------------------------------+\n   \
    \                 11 |      Options Flag Field       |\n                     \
    \  +---------------+---------------+\n                            SYN Segment\
    \ Format\n                                 Figure 6\n     4.3.2  SYN Segment Fields\n\
    \     Sequence Number\n          Contains the  initial  sequence  number  selected\
    \  for  this\n          connection.\n     Acknowledgement Number\n          This\
    \ field is valid only if the ACK flag is  set.   In  that\n          case, this\
    \ field will contain the sequence number of the SYN\n          segment received\
    \ from the other RDP.\n     Maximum Number of Outstanding Segments\n         \
    \ The maximum number of segments that should be  sent  without\n          getting\
    \ an acknowledgement.  This is used by the receiver as\n          a means of flow\
    \ control.   The  number  is  selected  during\n          connection  initiation\
    \  and  may not be changed later in the\n          life of the connection.\n \
    \    Maximum Segment Size\n          The maximum size segment in octets that \
    \ the  sender  should\n          send.   It informs the sender how big the receiver's\
    \ buffers\n          are.  The specified size  includes  the  length  of  the\
    \  IP\n          header,  RDP  header,  and  data.   It  does not include the\n\
    \          network access layer's header length.\n     Options Flag Field\n  \
    \        This field of two octets contains a  set  of  options  flags\n      \
    \    that  specify the set of optional functions that are desired\n          for\
    \ this connection.  The flags are defined as follows:\n          Bit #   Bit Name\
    \    Description\n          0       SDM         Sequenced delivery mode.\n   \
    \       The sequenced delivery mode flag specifies whether  delivery\n       \
    \   of   segments   to  the  user  is  sequenced  (delivered  in\n          sequence-number\
    \  order)  or  non-sequenced   (delivered   in\n          arrival order, regardless\
    \ of sequence number).  A value of 0\n          specifies non-sequenced delivery\
    \ of segments, and a value of\n          1 specifies sequenced delivery.\n   \
    \  4.4  ACK Segment\n          The ACK segment is used to acknowledge in-sequence\
    \ segments.\n     It   contains   both  the  next  send  sequence  number  and\
    \  the\n     acknowledgement sequence number  in  the  RDP  header.   The  ACK\n\
    \     segment  may  be  sent  as  a  separate segment, but it should be\n    \
    \ combined with data whenever possible.  Data segments must  always\n     include\
    \ the ACK bit and Acknowledgement Number field.\n     4.4.1  ACK Segment Format\n\
    \                        0             0 0   1         1\n                   \
    \     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                       +-+-+-+-+-+-+---+---------------+\n\
    \                     0 |0|1|0|0|0|0|0 1| Header Length |\n                  \
    \     +-+-+-+-+-+-+---+---------------+\n                     1 | Source Port\
    \   |   Dest. Port  |\n                       +---------------+---------------+\n\
    \                     2 |          Data  Length         |\n                  \
    \     +---------------+---------------+\n                     3 |            \
    \                   |\n                       +---    Sequence Number      ---+\n\
    \                     4 |                               |\n                  \
    \     +---------------+---------------+\n                     5 |            \
    \                   |\n                       +--- Acknowledgement Number  ---+\n\
    \                     6 |                               |\n                  \
    \     +---------------+---------------+\n                     7 |            \
    \                   |\n                       +---        Checksum         ---+\n\
    \                     8 |                               |\n                  \
    \     +---------------+---------------+\n                       |            \
    \                   |\n                       |             Data             \
    \ |\n                       .                               .\n              \
    \         .                               .\n                       +---------------+---------------+\n\
    \                            ACK Segment Format\n                            \
    \     Figure 7\n     4.4.2  ACK Segment Fields\n     Data Length\n          A\
    \ non-zero Data Length field indicates that  there  is  data\n          present\
    \ in the segment.\n     Sequence Number\n          The value of the Sequence Number\
    \ field is  advanced  to  the\n          next  sequence  number  only if there\
    \ is data present in the\n          segment.  An ACK segment without data does\
    \ not use  sequence\n          number space.\n     Acknowledgement Number\n  \
    \        The  Acknowledgement  Number  field  contains  the  sequence\n      \
    \    number of the last segment received in sequential order.\n     4.5  Extended\
    \ ACK Segment\n          The EACK segment is used to  acknowledge  segments  received\n\
    \     out of sequence.  It contains the sequence numbers of one or more\n    \
    \ segments received with a correct checksum, but out  of  sequence.\n     The\
    \  EACK  is  always combined with an ACK in the segment, giving\n     the sequence\
    \ number of the last  segment  received  in  sequence.\n     The EACK segment\
    \ may also include user data.\n     4.5.1  EACK Segment Format\n          The\
    \ EACK segment has the format shown in Figure 8.\n     4.5.2  EACK Segment Fields\n\
    \     Data Length\n          A non-zero Data Length field indicates that  there\
    \  is  data\n          present in the segment.\n     Sequence Number\n       \
    \   The value of the Sequence Number field is  advanced  to  the\n          next\
    \  sequence  number  only if there is data present in the\n          segment.\
    \  An EACK segment without data does not use sequence\n          number space.\n\
    \     Acknowledgement Number\n          The  Acknowledgement  Number  field  contains\
    \  the  sequence\n          number of the last segment received in sequential\
    \ order.\n     Sequence # Received OK\n          Each entry is the sequence number\
    \  of  a  segment  that  was\n          received with a correct checksum, but\
    \ out of sequence.\n                        0             0 0   1         1\n\
    \                        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n                   \
    \    +-+-+-+-+-+-+---+---------------+\n                     0 |0|1|1|0|0|0|0\
    \ 1| Header Length |\n                       +-+-+-+-+-+-+---+---------------+\n\
    \                     1 | Source Port   |   Dest. Port  |\n                  \
    \     +---------------+---------------+\n                     2 |          Data\
    \  Length         |\n                       +---------------+---------------+\n\
    \                     3 |                               |\n                  \
    \     +---    Sequence Number      ---|\n                     4 |            \
    \                   |\n                       +---------------+---------------+\n\
    \                     5 |                               |\n                  \
    \     +--- Acknowledgement Number  ---+\n                     6 |            \
    \                   |\n                       +---------------+---------------+\n\
    \                     7 |                               |\n                  \
    \     +---        Checksum         ---+\n                     8 |            \
    \                   |\n                       +---------------+---------------+\n\
    \                     9 |                               |\n                  \
    \     +--- Sequence # Received OK  ---+\n                    10 |            \
    \                   |\n                       +---------------+---------------+\n\
    \                    11 |                               |\n                  \
    \     +--- Sequence # Received OK  ---+\n                    12 |            \
    \                   |\n                       +---------------+---------------+\n\
    \                       :               .               :\n                  \
    \     :               .               :\n                       :            \
    \   .               :\n                       +---------------+---------------+\n\
    \                       |                               |\n                  \
    \     |             Data              |\n                       |            \
    \                   |\n                       +---------------+---------------+\n\
    \                            EACK Segment Format\n                           \
    \      Figure 8\n     4.6  RST Segment\n          The RST segment is used to \
    \ close  or  reset  a  connection.\n     Upon  receipt of an RST segment, the\
    \ sender must stop sending and\n     must abort any  unserviced  requests.   The\
    \  RST  is  sent  as  a\n     separate segment and does not include any data.\n\
    \     4.6.1  RST Segment Format\n                        0             0 0   1\
    \         1\n                        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5\n       \
    \                +-+-+-+-+-+-+---+---------------+\n                     0 |0|0|0|1|0|0|0\
    \ 1| Header Length |\n                       +-+-+-+-+-+-+---+---------------+\n\
    \                     1 | Source Port   |   Dest. Port  |\n                  \
    \     +---------------+---------------+\n                     2 |       Data \
    \ Length = 0        |\n                       +---------------+---------------+\n\
    \                     3 |                               |\n                  \
    \     +---    Sequence Number      ---+\n                     4 |            \
    \                   |\n                       +---------------+---------------+\n\
    \                     5 |                               |\n                  \
    \     +--- Acknowledgement Number  ---+\n                     6 |            \
    \                   |\n                       +---------------+---------------+\n\
    \                     7 |                               |\n                  \
    \     +---        Checksum         ---+\n                     8 |            \
    \                   |\n                       +-------------------------------+\n\
    \                            RST Segment Format\n                            \
    \     Figure 9\n     4.7  NUL Segment\n          The NUL segment is used to determine\
    \ if the other side of  a\n     connection  is  still active.  When a NUL segment\
    \ is received, an\n     RDP implementation  must  acknowledge  the  segment  if\
    \  a  valid\n     connection  exists  and  the segment sequence number falls within\n\
    \     the acceptance window.  The segment is then discarded.   The  NUL\n    \
    \ may  be  combined  with an ACK in a segment but is never combined\n     with\
    \ user data.\n     4.7.1  NUL segment format\n                        0      \
    \       0 0   1         1\n                        0 1 2 3 4 5 6 7 8 9 0 1 2 3\
    \ 4 5\n                       +-+-+-+-+-+-+---+---------------+\n            \
    \         0 |0|0|0|0|1|0|0 1| Header Length |\n                       +-+-+-+-+-+-+---+---------------+\n\
    \                     1 | Source Port   |   Dest. Port  |\n                  \
    \     +---------------+---------------+\n                     2 |       Data \
    \ Length = 0        |\n                       +---------------+---------------+\n\
    \                     3 |                               |\n                  \
    \     +---    Sequence Number      ---+\n                     4 |            \
    \                   |\n                       +---------------+---------------+\n\
    \                     5 |                               |\n                  \
    \     +--- Acknowledgement Number  ---+\n                     6 |            \
    \                   |\n                       +---------------+---------------+\n\
    \                     7 |                               |\n                  \
    \     +---        Checksum         ---+\n                     8 |            \
    \                   |\n                       +-------------------------------+\n\
    \                            NUL Segment Format\n                            \
    \     Figure 10\n                                 CHAPTER 5\n                \
    \           Examples of Operation\n     5.1  Connection Establishment\n      \
    \    This is an example of a connection being established between\n     Host \
    \ A  and  Host  B.   Host B has done a passive Open and is in\n     LISTEN state.\
    \  Host A  does  an  active  Open  to  establish  the\n     connection.\n    \
    \              Host A                         Host B\n     Time State        \
    \                                      State\n     1.    CLOSED              \
    \                               LISTEN\n     2.    SYN-SENT    <SEQ=100><SYN>\
    \ --->\n     3.                               <--- <SEQ=200><ACK=100><SYN,ACK>\n\
    \                                                             SYN-RCVD\n     4.\
    \    OPEN    <SEQ=101><ACK=200> --->                    OPEN\n     5.      <SEQ=101><ACK=200><Data>\
    \ --->\n     6.                               <--- <SEQ=201><ACK=101>\n     5.2\
    \  Simultaneous Connection Establishment\n          This is an example  of  two\
    \  hosts  trying  to  establishing\n     connections  to  each other at the same\
    \ time.  Host A sends a SYN\n     request to Host B at the same time Host B sends\
    \ a SYN request  to\n     Host A.\n          Host A                         Host\
    \ B\n     Time State                                            State\n     1.\
    \   CLOSED                                           CLOSED\n     2.   SYN-SENT\
    \ <SEQ=100><SYN>  --->\n                                   <--- <SEQ=200><SYN>\
    \     SYN-SENT\n     3.   SYN-RCVD                                         SYN-RCVD\n\
    \        <SEQ=100><ACK=200><SYN,ACK> --->\n                                  \
    \ <--- <SEQ=200><ACK=100><SYN,ACK>\n     4.   OPEN                           \
    \                  OPEN\n     5.3  Lost Segments\n          This is an example\
    \ of what happens when a segment  is  lost.\n     It  shows  how  segments  can\
    \ be acknowledged out of sequence and\n     that only the missing segment need\
    \ be retransmitted.   Note  that\n     in  this  and  the  following  examples\
    \  \"EA\"  stands for \"Out of\n     Sequence Acknowledgement.\"\n     Time  \
    \ Host A                           Host B\n     1.     <SEQ=100><ACK=200><Data>\
    \  --->\n     2.                               <--- <SEQ=201><ACK=100>\n     3.\
    \     <SEQ=101><ACK=200><Data> (segment lost)\n     4.\n     5.     <SEQ=102><ACK=200><Data>\
    \  --->\n     6.                               <--  <SEQ=201><ACK=100><EA=102>\n\
    \     7.     <SEQ=103><ACK=200><Data>  --->\n     8.                         \
    \      <--- <SEQ=201><ACK=100>\n                                             <EA=102,103>\n\
    \     9.     <SEQ=101><ACK=200><Data>  --->\n     10.                        \
    \      <--- <SEQ=201><ACK=103>\n     11.    <SEQ=104><ACK=200><Data>  --->\n \
    \    12.                              <--- <SEQ=201><ACK=104>\n     5.4  Segments\
    \ Received Out of Order\n          This an example of  segments  received  out\
    \  of  order.   It\n     further  illustrates  the  use  of  acknowledging segments\
    \ out of\n     order to prevent needless retransmissions.\n     Time     Host\
    \ A                           Host B\n     1.   <SEQ=100><ACK=200><Data>  --->\n\
    \     2.                             <--- <SEQ=201><ACK=100>\n     3.   <SEQ=101><ACK=200><Data>\
    \ (delayed)\n     4.\n     5.   <SEQ=102><ACK=200><Data>  --->\n     6.      \
    \                       <--- <SEQ=201><ACK=100><EA=102>\n     7.   <SEQ=103><ACK=200><Data>\
    \  --->\n                                   ---> (delayed segment 101 arrives)\n\
    \     8.                             <--- <SEQ=201><ACK=103>\n     9.   <SEQ=104><ACK=200><Data>\
    \  --->\n     10.                            <--- <SEQ=201><ACK=104>\n     5.5\
    \  Communication Over Long Delay Path\n          This is an example of a data\
    \  transfer  over  a  long  delay\n     path.   In  this  example, Host A is permitted\
    \ to have as many as\n     five unacknowledged segments.  The example shows that\
    \ it  is  not\n     necessary  to  wait  for  an  acknowledgement  in  order \
    \ to send\n     additional data.\n     Time        Host A                    \
    \ Host B\n     1.   <SEQ=100><ACK=200><Data> -1->\n     2.   <SEQ=101><ACK=200><Data>\
    \ -2->\n     3.   <SEQ=102><ACK=200><Data> -3->\n                            \
    \       -1-> (received)\n     4.                           <-4-  <SEQ=201><ACK=100>\n\
    \     5.   <SEQ=103><ACK=200><Data> -5->\n                                   -2->\
    \ (received)\n     6.                           <-6-  <SEQ=201><ACK=101>\n   \
    \  7.   <SEQ=104><ACK=200><Data> -7->\n                                   -3->\
    \ (received)\n     8.                           <-8-  <SEQ=201><ACK=102>\n   \
    \                    (received) <-4-\n     9.   <SEQ=105><ACK=200><Data> -9->\n\
    \                                   -5-> (received)\n     10.                \
    \          <-10- <SEQ=201><ACK=103>\n                       (received) <-6-\n\
    \     11.  <SEQ=106><ACK=200><Data> -11->\n                                  \
    \ -7-> (received)\n     12.                          <-12- <SEQ=201><ACK=104>\n\
    \                       (received) <-8-\n     13.                           -9->\
    \ (received)\n     14.                          <-13- <SEQ=201><ACK=105>\n   \
    \                    (received) <-10-\n     15.                           -11->\
    \ (received)\n     16.                          <-14- <SEQ=201><ACK=106>\n   \
    \                    (received) <-12-\n     17.               (received) <-13-\n\
    \     18.               (received) <-14-\n     5.6  Communication Over Long Delay\
    \ Path With Lost Segments\n          This is an example of communication over\
    \ a long  delay  path\n     with a lost segment.  It shows that by acknowledging\
    \ segments out\n     of sequence, only the lost segment need be retransmitted.\n\
    \     Time       Host A                     Host B\n     1. <SEQ=100><ACK=200><Data>\
    \  -1->\n     2. <SEQ=101><ACK=200><Data>  -2->\n     3. <SEQ=102><ACK=200><Data>\
    \  -3->\n                                  -1-> (received)\n     4.          \
    \                <-4-  <SEQ=201><ACK=100>\n     5. <SEQ=103><ACK=200><Data> (segment\
    \ lost)\n                                  -2-> (received)\n     6.          \
    \                <-5-  <SEQ=201><ACK=101>\n     7. <SEQ=104><ACK=200><Data>  -6->\n\
    \                                  -3-> (received)\n     8.                  \
    \        <-7-  <SEQ=201><ACK=102>\n                      (received) <-4-\n   \
    \  9. <SEQ=105><ACK=200><Data>  -8->\n     10.\n                      (received)\
    \ <-5-\n     11. <SEQ=106><ACK=200><Data> -10->\n                            \
    \      -6-> (received)\n     12.                         <-11- <SEQ=201><ACK=102><EA=104>\n\
    \                      (received) <-7-\n                                  -8->\
    \ (received)\n     13.                         <-12- <SEQ=201><ACK=102><EA=104,105>\n\
    \                                  -10-> (received)\n     14.                \
    \         <-13- <SEQ=201><ACK=102><EA=104-106>\n                      (received)\
    \ <-11-\n     15. <SEQ=103><ACK=200><Data> -14->\n                      (received)\
    \ <-12-\n     16.              (received) <-13-\n                            \
    \      -14-> (received)\n     17.                         <-15- <SEQ=201><ACK=106>\n\
    \     18.\n     19.              (received) <-15-\n     5.7  Detecting a Half-Open\
    \ Connection on Crash Recovery\n          This  is  an  example  of  a  host \
    \ detecting  a   half-open\n     connection  due  to the crash and subsequent\
    \ restart of the host.\n     In this example, Host A crashes during a  communication\
    \  session,\n     then  recovers  and  tries  to reopen the connection.  During\
    \ the\n     reopen attempt, it discovers that a  half-open  connection  still\n\
    \     exists and it then resets the other side.  Both sides were in the\n    \
    \ OPEN state prior to the crash.\n        Host A                             \
    \     Host B\n     Time\n     1.  OPEN                                     OPEN\n\
    \        (crash!)               <--- <SEQ=200><ACK=100><ACK>\n     2.  CLOSED\
    \                                   OPEN\n        (recover)\n     3.  SYN-SENT\
    \                                 OPEN\n                 <SEQ=400><SYN> ---> \
    \            (?)\n     4.  SYN-SENT                                 OPEN\n   \
    \       (!)                  <--- <SEQ=200><ACK=100><ACK>\n     5.  SYN-SENT \
    \                                OPEN\n                 <SEQ=101><RST> --->  \
    \           (abort)\n     6.  SYN-SENT                                 CLOSED\n\
    \     7.  SYN-SENT <SEQ=400><SYN> --->\n     5.8  Detecting a Half-Open Connection\
    \ from the Active Side\n          This is another example of detecting a half-open\
    \  connection\n     due  to the crash and restart of a host involved in a connection.\n\
    \     In this example, host A again crashes and restarts.   Host  B  is\n    \
    \ still  active and tries to send data to host A.  Since host A has\n     no knowledge\
    \ of the connection, it rejects the data with  an  RST\n     segment, causing\
    \ host B to reset the connection.\n              Host A                      \
    \   Host B\n     Time\n     1.  (crash!)                                     \
    \       OPEN\n     2.  CLOSED                <--- <SEQ=200><ACK=100><Data> OPEN\n\
    \     3.  CLOSED  <SEQ=101><RST> --->                         (abort)\n     4.\
    \  CLOSED                                              CLOSED\n              \
    \                  APPENDIX A\n                        Implementing a Minimal\
    \ RDP\n          It  is  not  necessary   to   implement   the   entire   RDP\n\
    \     specification  to  be  able  to use RDP.  For simple applications\n    \
    \ such as a loader, where  size  of  the  protocol  module  may  be\n     important,\
    \  a  subset  of  RDP  may  be  used.   For  example, an\n     implementation\
    \ of  RDP  for  loading  may  employ  the  following\n     restrictions:\n   \
    \  o    Only one connection  and  connection  record  is  supported.\n       \
    \   This is the connection used to load the device.\n     o    A single, well-known\
    \  port  is  used  as  the  loader  port.\n          Allocable ports are not implemented.\n\
    \     o    Only the passive Open request is implemented.  Active  Opens\n    \
    \      are not supported.\n     o    The sequenced delivery option is  not  supported.\
    \   Messages\n          arriving  out  of  order  are  delivered  in  the order\
    \ they\n          arrive.\n     o    If efficiency is less  important  than  protocol\
    \  size,  the\n          extended acknowledgement feature need not be supported.\n\
    \                                   INDEX\n     ACK..........................................\
    \ 16, 33, 34, 38\n     ACK segment format.......................................\
    \ 38\n     acknowledgement number field......... 16, 34, 37, 38, 39, 40\n    \
    \ byte-stream protocols................................. 4, 14\n     checksum.................................................\
    \ 16\n     checksum field........................................... 34\n    \
    \ Close request............................................ 13\n     Closed state..........................................\
    \ 9, 10\n     CLOSEWAIT................................................ 12\n \
    \    Close-Wait state................................. 10, 11, 13\n     CLOSE-WAIT\
    \ timeouts...................................... 29\n     connection, closing\
    \ of............................... 13, 42\n     connection, establishment of......................\
    \ 8, 11, 45\n     connection identifier................................. 7, 33\n\
    \     connection management..................................... 7\n     connection\
    \ record..................................... 9, 11\n     connection state diagram.................................\
    \ 10\n     connection states......................................... 8\n    \
    \ control flags field...................................... 33\n     cumulative\
    \ acknowledgement............................... 16\n     data communication.......................................\
    \ 14\n     data length field................................ 34, 39, 40\n    \
    \ datagrams................................................. 6\n     debugging..............................................\
    \ 1, 3\n     dumping................................................... 3\n  \
    \   EACK......................................... 16, 33, 35, 40\n     EACK segment\
    \ format...................................... 40\n     event processing.........................................\
    \ 20\n     extended acknowledgement................................. 16\n    \
    \ flow control............................................. 17\n     half-open\
    \ connection, detection of............... 14, 51, 52\n     initial sequence number.......................\
    \ 9, 11, 12, 15\n     internet protocols........................................\
    \ 5\n     IP................................................ 6, 15, 31\n     IP\
    \ header............................................ 31, 37\n     Listen state...................................\
    \ 8, 9, 10, 45\n     loading................................................ 1,\
    \ 3\n     maximum segment size..................... 11, 12, 13, 15, 37\n     maximum\
    \ unacknowledged segments.............. 11, 12, 17, 37\n     message fragmentation....................................\
    \ 14\n     non-cumulative acknowledgement........................... 16\n    \
    \ NUL.................................................. 33, 43\n     NUL segment\
    \ format....................................... 43\n     Open request..........................................\
    \ 8, 17\n     Open request, active................................... 8, 9\n \
    \    Open request, passive.................................. 8, 9\n     Open state.......................................\
    \ 10, 11, 45\n     options flag field....................................... 37\n\
    \     out-of-sequence acknowledgement.................. 12, 16, 18\n     ports.................................................\
    \ 7, 33\n     ports, well-known......................................... 8\n \
    \    positive acknowledgement............................. 15, 16\n     RBUF.MAX.................................................\
    \ 13\n     RCV.CUR.................................................. 12\n    \
    \ RCVDSEQNO................................................ 12\n     RCV.IRS..................................................\
    \ 12\n     RCV.MAX.................................................. 12\n    \
    \ RDP connection........................................... 14\n     RDP header...................................\
    \ 14, 16, 32, 37\n     RDP header length........................................\
    \ 33\n     RDP segment format....................................... 31\n    \
    \ reliable communication................................... 15\n     retransmission\
    \ of segments....................... 15, 16, 17\n     retransmission timeout...............................\
    \ 17, 29\n     RST.................................................. 33, 42\n\
    \     RST segment.......................................... 13, 52\n     RST segment\
    \ format....................................... 42\n     SBUF.MAX.................................................\
    \ 12\n     SDM...................................................... 37\n    \
    \ SEG.ACK.................................................. 13\n     SEG.BMAX.................................................\
    \ 13\n     SEG.MAX.................................................. 13\n    \
    \ segment arrival events............................... 20, 24\n     segments.................................................\
    \ 14\n     SEG.SEQ.................................................. 13\n    \
    \ Send request......................................... 14, 15\n     sequence\
    \ number...................................... 12, 15\n     sequence number acceptance\
    \ window........................ 18\n     sequence number field........................\
    \ 34, 37, 39, 40\n     sequenced delivery................................. 3,\
    \ 4, 37\n     sequential acknowledgement................................ 4\n \
    \    SND.ISS.................................................. 12\n     SND.MAX..................................................\
    \ 12\n     SND.NXT.................................................. 11\n    \
    \ SND.UNA.................................................. 12\n     STATE....................................................\
    \ 11\n     SYN.................................. 12, 13, 15, 33, 35, 36\n    \
    \ SYN segment........................................... 9, 36\n     Syn-Rcvd\
    \ state........................................ 9, 10\n     Syn-Sent state........................................\
    \ 9, 10\n     TCP................................................... 4, 14\n \
    \    three-way handshake....................................... 4\n     user request\
    \ events.................................. 20, 21\n     version number field.....................................\
    \ 33\n"
