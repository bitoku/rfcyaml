- title: __initial_text__
  contents:
  - "                  Robust XML Encoding Rules (RXER) for\n                  Abstract\
    \ Syntax Notation One (ASN.1)\n"
- title: Status of This Memo
  contents:
  - "Status of This Memo\n   This memo defines an Experimental Protocol for the Internet\n\
    \   community.  It does not specify an Internet standard of any kind.\n   Discussion\
    \ and suggestions for improvement are requested.\n   Distribution of this memo\
    \ is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The IETF Trust (2007).\n"
- title: Abstract
  contents:
  - "Abstract\n   This document defines a set of Abstract Syntax Notation One (ASN.1)\n\
    \   encoding rules, called the Robust XML Encoding Rules or RXER, that\n   produce\
    \ an Extensible Markup Language (XML) representation for values\n   of any given\
    \ ASN.1 data type.  Rules for producing a canonical RXER\n   encoding are also\
    \ defined.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n\
    \   2. Conventions .....................................................4\n  \
    \ 3. Definitions .....................................................5\n   4.\
    \ Additional Basic Types ..........................................6\n      4.1.\
    \ The Markup Type ............................................6\n           4.1.1.\
    \ Self-Containment ....................................9\n           4.1.2. Normalization\
    \ for Canonical Encoding Rules .........12\n      4.2. The AnyURI Type ...........................................13\n\
    \      4.3. The NCName Type ...........................................14\n  \
    \    4.4. The Name Type .............................................14\n    \
    \  4.5. The QName Type ............................................14\n   5. Expanded\
    \ Names for ASN.1 Types .................................15\n   6. Encoding Rules\
    \ .................................................17\n      6.1. Identifiers\
    \ ...............................................19\n      6.2. Component Encodings\
    \ .......................................20\n           6.2.1. Referenced Components\
    \ ..............................20\n           6.2.2. Element Components .................................20\n\
    \                  6.2.2.1. Namespace Properties for Elements .........22\n  \
    \                6.2.2.2. Namespace Prefixes for Element Names ......24\n    \
    \       6.2.3. Attribute Components ...............................25\n      \
    \            6.2.3.1. Namespace Prefixes for Attribute Names ....26\n        \
    \   6.2.4. Unencapsulated Components ..........................26\n          \
    \ 6.2.5. Examples ...........................................27\n      6.3. Standalone\
    \ Encodings ......................................28\n      6.4. Embedded ASN.1\
    \ Values .....................................28\n      6.5. Type Referencing\
    \ Notations ................................32\n      6.6. TypeWithConstraint,\
    \ SEQUENCE OF Type, and SET OF Type .....33\n      6.7. Character Data Translations\
    \ ...............................34\n           6.7.1. Restricted Character String\
    \ Types ..................35\n           6.7.2. BIT STRING .........................................36\n\
    \           6.7.3. BOOLEAN ............................................38\n  \
    \         6.7.4. ENUMERATED .........................................38\n    \
    \       6.7.5. GeneralizedTime ....................................39\n      \
    \     6.7.6. INTEGER ............................................41\n        \
    \   6.7.7. NULL ...............................................42\n          \
    \ 6.7.8. ObjectDescriptor ...................................43\n           6.7.9.\
    \ OBJECT IDENTIFIER and RELATIVE-OID .................43\n           6.7.10. OCTET\
    \ STRING ......................................43\n           6.7.11. QName .............................................44\n\
    \                  6.7.11.1. Namespace Prefixes for Qualified Names ...44\n  \
    \         6.7.12. REAL ..............................................45\n    \
    \       6.7.13. UTCTime ...........................................46\n      \
    \     6.7.14. CHOICE as UNION ...................................47\n        \
    \   6.7.15. SEQUENCE OF as LIST ...............................50\n      6.8.\
    \ Combining Types ...........................................50\n           6.8.1.\
    \ CHARACTER STRING ...................................51\n           6.8.2. CHOICE\
    \ .............................................51\n           6.8.3. EMBEDDED\
    \ PDV .......................................52\n           6.8.4. EXTERNAL ...........................................52\n\
    \           6.8.5. INSTANCE OF ........................................52\n  \
    \         6.8.6. SEQUENCE and SET ...................................52\n    \
    \       6.8.7. SEQUENCE OF and SET OF .............................54\n      \
    \     6.8.8. Extensible Combining Types .........................55\n        \
    \          6.8.8.1. Unknown Elements in Extensions ............55\n          \
    \        6.8.8.2. Unknown Attributes in Extensions ..........59\n      6.9. Open\
    \ Type .................................................60\n      6.10. Markup\
    \ ...................................................61\n      6.11. Namespace\
    \ Prefixes for CRXER .............................63\n      6.12. Serialization\
    \ ............................................65\n           6.12.1. Non-Canonical\
    \ Serialization .......................65\n           6.12.2. Canonical Serialization\
    \ ...........................68\n           6.12.3. Unicode Normalization in XML\
    \ Version 1.1 ..........70\n      6.13. Syntax-Based Canonicalization ............................70\n\
    \   7. Transfer Syntax Identifiers ....................................71\n  \
    \    7.1. RXER Transfer Syntax ......................................71\n    \
    \  7.2. CRXER Transfer Syntax .....................................71\n   8. Relationship\
    \ to XER ............................................71\n   9. Security Considerations\
    \ ........................................73\n   10. Acknowledgements ..............................................74\n\
    \   11. IANA Considerations ...........................................75\n  \
    \ 12. References ....................................................75\n    \
    \  12.1. Normative References .....................................75\n      12.2.\
    \ Informative References ...................................77\n   Appendix A.\
    \ Additional Basic Definitions Module ...................78\n"
- title: 1.  Introduction
  contents:
  - "1.  Introduction\n   This document defines a set of Abstract Syntax Notation\
    \ One (ASN.1)\n   [X.680] encoding rules, called the Robust XML Encoding Rules\
    \ or RXER,\n   that produce an Extensible Markup Language (XML) [XML10][XML11]\n\
    \   representation of ASN.1 values of any given ASN.1 type.\n   An ASN.1 value\
    \ is regarded as analogous to the content and attributes\n   of an XML element,\
    \ or in some cases, just an XML attribute value.\n   The RXER encoding of an ASN.1\
    \ value is the well-formed and valid\n   content and attributes of an element,\
    \ or an attribute value, in an\n   XML document [XML10][XML11] conforming to XML\
    \ namespaces\n   [XMLNS10][XMLNS11].  Simple ASN.1 data types such as PrintableString,\n\
    \   INTEGER, and BOOLEAN define character data content or attribute\n   values,\
    \ while the ASN.1 combining types (i.e., SET, SEQUENCE, SET OF,\n   SEQUENCE OF,\
    \ and CHOICE) define element content and attributes.  The\n   attribute and child\
    \ element names are generally provided by the\n   identifiers of the components\
    \ in combining type definitions, i.e.,\n   elements and attributes correspond\
    \ to the NamedType notation.\n   RXER leaves some formatting details to the discretion\
    \ of the encoder,\n   so there is not a single unique RXER encoding for an ASN.1\
    \ value.\n   However, this document also defines a restriction of RXER, called\
    \ the\n   Canonical Robust XML Encoding Rules (CRXER), which does produce a\n\
    \   single unique encoding for an ASN.1 value.  Obviously, the CRXER\n   encoding\
    \ of a value is also a valid RXER encoding of that value.  The\n   restrictions\
    \ on RXER to produce the CRXER encoding are interspersed\n   with the description\
    \ of the rules for RXER.\n   Note that \"ASN.1 value\" does not mean a Basic Encoding\
    \ Rules (BER)\n   [X.690] encoding.  The ASN.1 value is an abstract concept that\
    \ is\n   independent of any particular encoding.  BER is just one possible way\n\
    \   to encode an ASN.1 value.  This document defines an alternative way\n   to\
    \ encode an ASN.1 value.\n   A separate document [RXEREI] defines encoding instructions\
    \ [X.680-1]\n   that may be used in an ASN.1 specification to modify how values\
    \ are\n   encoded in RXER, for example, to encode a component of a combining\n\
    \   ASN.1 type as an attribute rather than as a child element.  A\n   pre-existing\
    \ ASN.1 specification will not have RXER encoding\n   instructions, so any mention\
    \ of encoding instructions in this\n   document can be ignored when dealing with\
    \ such specifications.\n   Encoding instructions for other encoding rules have\
    \ no effect on RXER\n   encodings.\n"
- title: 2.  Conventions
  contents:
  - "2.  Conventions\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\"\
    , \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", and \"MAY\"\
    \ in this document are\n   to be interpreted as described in BCP 14, RFC 2119\
    \ [BCP14].  The key\n   word \"OPTIONAL\" is exclusively used with its ASN.1 meaning.\n\
    \   A reference to an ASN.1 production [X.680] (e.g., Type, NamedType) is\n  \
    \ a reference to the text in an ASN.1 specification corresponding to\n   that\
    \ production.\n   The specification of RXER makes use of definitions from the\
    \ XML\n   Information Set (Infoset) [INFOSET].  In particular, information item\n\
    \   property names follow the Infoset convention of being shown in square\n  \
    \ brackets, e.g., [local name].  Literal values of Infoset properties\n   are\
    \ enclosed in double quotes; however, the double quotes are not\n   part of the\
    \ property values.  In the sections that follow,\n   \"information item\" will\
    \ be abbreviated to \"item\", e.g., \"element\n   information item\" is abbreviated\
    \ to \"element item\".  The term\n   \"element\" or \"attribute\" (without the\
    \ \"item\") is referring to an\n   element or attribute in an XML document, rather\
    \ than an information\n   item.\n   Literal character strings to be used in an\
    \ RXER encoding appear\n   within double quotes; however, the double quotes are\
    \ not part of the\n   literal value and do not appear in the encoding.\n   This\
    \ document uses the namespace prefix [XMLNS10][XMLNS11] \"asnx:\" to\n   stand\
    \ for the namespace name \"urn:ietf:params:xml:ns:asnx\", uses the\n   namespace\
    \ prefix \"xs:\" to stand for the namespace name\n   \"http://www.w3.org/2001/XMLSchema\"\
    , and uses the namespace prefix\n   \"xsi:\" to stand for the namespace name\n\
    \   \"http://www.w3.org/2001/XMLSchema-instance\".  However, in practice,\n  \
    \ any valid namespace prefixes are permitted in non-canonical RXER\n   encodings\
    \ (namespace prefixes are deterministically generated for\n   CRXER).\n   The\
    \ encoding instructions [X.680-1] referenced by name in this\n   specification\
    \ are encoding instructions for RXER [RXEREI].\n   Throughout this document, references\
    \ to the Markup, AnyURI, NCName,\n   Name, and QName ASN.1 types are references\
    \ to the types described in\n   Section 4 and consolidated in the AdditionalBasicDefinitions\
    \ module\n   in Appendix A.  Any provisions associated with the reference do not\n\
    \   apply to types defined in other ASN.1 modules that happen to have\n   these\
    \ same names.\n   Code points for characters [UCS][UNICODE] are expressed using\
    \ the\n   Unicode convention U+n, where n is four to six hexadecimal digits,\n\
    \   e.g., the space character is U+0020.\n"
- title: 3.  Definitions
  contents:
  - "3.  Definitions\n   Definition (white space character): A white space character\
    \ is a\n   space (U+0020), tab (U+0009), carriage return (U+000D), or line feed\n\
    \   (U+000A) character.\n   Definition (white space):  White space is a sequence\
    \ of one or more\n   white space characters.\n   Definition (line break):  A line\
    \ break is any sequence of characters\n   that is normalized to a line feed by\
    \ XML End-of-Line Handling\n   [XML10][XML11].\n   Definition (serialized white\
    \ space): Serialized white space is a\n   sequence of one or more white space\
    \ characters and/or line breaks.\n   Definition (declaring the default namespace):\
    \  A namespace\n   declaration attribute item is declaring the default namespace\
    \ if the\n   [prefix] of the attribute item has no value, the [local name] of\
    \ the\n   attribute item is \"xmlns\" and the [normalized value] is not empty.\n\
    \   Definition (undeclaring the default namespace):  A namespace\n   declaration\
    \ attribute item is undeclaring the default namespace if\n   the [prefix] of the\
    \ attribute item has no value, the [local name] of\n   the attribute item is \"\
    xmlns\" and the [normalized value] is empty\n   (i.e., xmlns=\"\").\n   Definition\
    \ (canonical namespace prefix): A canonical namespace prefix\n   is an NCName\
    \ [XMLNS10] beginning with the letter 'n' (U+006E)\n   followed by a non-negative\
    \ number string.  A non-negative number\n   string is either the digit character\
    \ '0' (U+0030), or a non-zero\n   decimal digit character (U+0031-U+0039) followed\
    \ by zero, one, or\n   more of the decimal digit characters '0' to '9' (U+0030-U+0039).\n\
    \   For convenience, a CHOICE type where the ChoiceType is subject to a\n   UNION\
    \ encoding instruction will be referred to as a UNION type, and a\n   SEQUENCE\
    \ OF type where the SequenceOfType is subject to a LIST\n   encoding instruction\
    \ will be referred to as a LIST type.\n"
- title: 4.  Additional Basic Types
  contents:
  - "4.  Additional Basic Types\n   This section defines an ASN.1 type for representing\
    \ markup in\n   abstract values, as well as basic types that are useful in encoding\n\
    \   instructions [RXEREI] and other related specifications [ASN.X].\n   The ASN.1\
    \ definitions in this section are consolidated in the\n   AdditionalBasicDefinitions\
    \ ASN.1 module in Appendix A.\n"
- title: 4.1.  The Markup Type
  contents:
  - "4.1.  The Markup Type\n   A value of the Markup ASN.1 type holds the [prefix],\
    \ [attributes],\n   [namespace attributes], and [children] of an element item,\
    \ i.e., the\n   content and attributes of an element.\n   RXER has special provisions\
    \ for encoding values of the Markup type\n   (see Section 6.10).  For other encoding\
    \ rules, a value of the Markup\n   type is encoded according to the following\
    \ ASN.1 type definition\n   (with AUTOMATIC TAGS):\n      Markup ::= CHOICE {\n\
    \          text    SEQUENCE {\n              prolog      UTF8String (SIZE(1..MAX))\
    \ OPTIONAL,\n              prefix      NCName OPTIONAL,\n              attributes\
    \  UTF8String (SIZE(1..MAX)) OPTIONAL,\n              content     UTF8String (SIZE(1..MAX))\
    \ OPTIONAL\n          }\n      }\n   The text alternative of the Markup CHOICE\
    \ type provides for the\n   [prefix], [attributes], [namespace attributes], and\
    \ [children] of an\n   element item to be represented as serialized XML using\
    \ the UTF-8\n   character encoding [UTF-8].\n      Aside: The CHOICE allows for\
    \ one or more alternative compact\n      representations of the content and attributes\
    \ of an element to be\n      supported in a future specification.\n   With respect\
    \ to some element item whose content and attributes are\n   represented by a value\
    \ of the text alternative of the Markup type:\n   (1) the prolog component of\
    \ the value contains text that, after line\n       break normalization, conforms\
    \ to the XML prolog production\n       [XML10][XML11],\n   (2) the prefix component\
    \ is absent if the [prefix] of the element\n       item has no value; otherwise,\
    \ the prefix component contains the\n       [prefix] of the element item,\n  \
    \ (3) the attributes component of the value contains an XML\n       serialization\
    \ of the [attributes] and [namespace attributes] of\n       the element item,\
    \ if any, with each attribute separated from the\n       next by serialized white\
    \ space, and\n   (4) the content component is absent if the [children] property\
    \ of the\n       element item is empty; otherwise, the content component of the\n\
    \       value contains an XML serialization of the [children] of the\n       element\
    \ item.\n   All the components of a value of the Markup type MUST use the same\n\
    \   version of XML, either version 1.0 [XML10] or version 1.1 [XML11].\n   If\
    \ XML version 1.1 is used, then the prolog component MUST be present\n   and MUST\
    \ have an XMLDecl for version 1.1.  If the prolog component is\n   absent, then\
    \ XML version 1.0 is assumed.\n   If the prefix component is present, then there\
    \ MUST be a namespace\n   declaration attribute in the attributes component that\
    \ defines that\n   namespace prefix (since an element whose content and attributes\
    \ are\n   described by a value of Markup is required to be self-contained; see\n\
    \   Section 4.1.1).\n   Note that the prefix component is critically related to\
    \ the NamedType\n   that has Markup as its type.  If a Markup value is extracted\
    \ from one\n   enclosing abstract value and embedded in another enclosing abstract\n\
    \   value (i.e., becomes associated with a different NamedType), then the\n  \
    \ prefix may no longer be appropriate, in which case it will need to be\n   revised.\
    \  It may also be necessary to add another namespace\n   declaration attribute\
    \ to the attributes component so as to declare a\n   new namespace prefix.\n \
    \  Leading and/or trailing serialized white space is permitted in the\n   attributes\
    \ component.  A value of the attributes component consisting\n   only of serialized\
    \ white space (i.e., no actual attributes) is\n   permitted.\n   The attributes\
    \ and content components MAY contain entity references\n   [XML10][XML11].  If\
    \ any entity references are used (other than\n   references to the predefined\
    \ entities), then the prolog component\n   MUST be present and MUST contain entity\
    \ declarations for those\n   entities in the internal or external subset of the\
    \ document type\n   definition.\n   Example\n      Given the following ASN.1 module:\n\
    \         MyModule DEFINITIONS\n         AUTOMATIC TAGS ::= BEGIN\n         Message\
    \ ::= SEQUENCE {\n             messageType   INTEGER,\n             messageValue\
    \  Markup\n         }\n         ENCODING-CONTROL RXER\n             TARGET-NAMESPACE\
    \ \"http://example.com/ns/MyModule\"\n             COMPONENT message Message\n\
    \                 -- a top-level NamedType\n         END\n      consider the following\
    \ XML document:\n         <?xml version='1.0'?>\n         <!DOCTYPE message [\n\
    \             <!ENTITY TRUE 'true'>\n         ]>\n         <message>\n       \
    \   <messageType>1</messageType>\n          <messageValue xmlns:ns=\"http://www.example.com/ABD\"\
    \n                        ns:foo=\"1\" bar=\"0\">\n           <this>&TRUE;</this>\n\
    \           <that/>\n          </messageValue>\n         </message>\n      A Markup\
    \ value corresponding to the content and attributes of the\n      <messageValue>\
    \ element is, in ASN.1 value notation [X.680] (where\n      \"lf\" represents\
    \ the line feed character):\n         text:{\n             prolog     { \"<?xml\
    \ version='1.0'?>\", lf,\n                          \"<!DOCTYPE message [\", lf,\n\
    \                          \"    <!ENTITY TRUE 'true'>\", lf,\n              \
    \            \"]>\", lf },\n             attributes { \" xmlns:ns=\"\"http://www.example.com/ABD\"\
    \"\",\n                          lf,\n                          \"           \
    \    ns:foo=\"\"1\"\" bar=\"\"0\"\"\" },\n             content    { lf,\n    \
    \                      \"  <this>&TRUE;</this>\", lf,\n                      \
    \    \"  <that/>\", lf, \" \" }\n         }\n      The following Markup value\
    \ is an equivalent representation of the\n      content and attributes of the\
    \ <messageValue> element:\n         text:{\n             attributes {\n      \
    \                    \"bar=\"\"0\"\" ns:foo=\"\"1\"\" \",\n                  \
    \        \"xmlns:ns=\"\"http://www.example.com/ABD\"\"\" },\n             content\
    \    { lf,\n                          \"  <this>true</this>\", lf,\n         \
    \                 \"  <that/>\", lf, \" \" }\n         }\n   By itself, the Markup\
    \ ASN.1 type imposes no data type restriction on\n   the markup contained by its\
    \ values and is therefore analogous to the\n   XML Schema anyType [XSD1].\n  \
    \ There is no ASN.1 basic notation that can directly impose the\n   constraint\
    \ that the markup represented by a value of the Markup type\n   must conform to\
    \ the markup allowed by a specific type definition.\n   However, certain encoding\
    \ instructions (i.e., the reference encoding\n   instructions [RXEREI]) have been\
    \ defined to have this effect.\n"
- title: 4.1.1.  Self-Containment
  contents:
  - "4.1.1.  Self-Containment\n   An element, its attributes and its content, including\
    \ descendent\n   elements, may contain qualified names [XMLNS10][XMLNS11] as the\
    \ names\n   of elements and attributes, in the values of attributes, and as\n\
    \   character data content of elements.  The binding between namespace\n   prefix\
    \ and namespace name for these qualified names is potentially\n   determined by\
    \ the namespace declaration attributes of ancestor\n   elements (which in the\
    \ Infoset representation are inherited as\n   namespace items in the [in-scope\
    \ namespaces]).\n   In the absence of complete knowledge of the data type of an\
    \ element\n   item whose content and attributes are described by a value of the\n\
    \   Markup type, it is not possible to determine with absolute certainty\n   which\
    \ of the namespace items inherited from the [in-scope namespaces]\n   of the [parent]\
    \ element item are significant in interpreting the\n   Markup value.  The safe\
    \ and easy option would be to assume that all\n   the namespace items from the\
    \ [in-scope namespaces] of the [parent]\n   element item are significant and need\
    \ to be retained within the\n   Markup value.  When the Markup value is re-encoded,\
    \ any of the\n   retained namespace items that do not appear in the\n   [in-scope\
    \ namespaces] of the enclosing element item in the new\n   encoding could be made\
    \ to appear by outputting corresponding\n   namespace declaration attribute items\
    \ in the [namespace attributes]\n   of the enclosing element item.\n   From the\
    \ perspective of the receiver of the new encoding, this\n   enlarges the set of\
    \ attribute items in the [namespace attributes]\n   represented by the Markup\
    \ value.\n   In addition, there is no guarantee that the sender of the new\n \
    \  encoding has recreated the original namespace declaration attributes\n   on\
    \ the ancestor elements, so the [in-scope namespaces] of the\n   enclosing element\
    \ item is likely to have new namespace declarations\n   that the receiver will\
    \ retain and pass on in the\n   [namespace attributes] when it in turn re-encodes\
    \ the Markup value.\n   This unbounded growth in the set of attribute items in\
    \ the\n   [namespace attributes] defeats any attempt to produce a canonical\n\
    \   encoding.\n   The principle of self-containment is introduced to avoid this\n\
    \   problem.  An element item (the subject element item) is\n   self-contained\
    \ if the constraints of Namespaces in XML 1.0 [XMLNS10]\n   are satisfied (i.e.,\
    \ that prefixes are properly declared) and none of\n   the following bindings\
    \ are determined by a namespace declaration\n   attribute item in the [namespace\
    \ attributes] of an ancestor element\n   item of the subject element item:\n \
    \  (1) the binding between the [prefix] and [namespace name] of the\n       subject\
    \ element item,\n   (2) the binding between the [prefix] and [namespace name]\
    \ of any\n       descendant element item of the subject element item,\n   (3)\
    \ the binding between the [prefix] and [namespace name] of any\n       attribute\
    \ item in the [attributes] of the subject element item or\n       the [attributes]\
    \ of any descendant element item of the subject\n       element item,\n   (4)\
    \ the binding between the namespace prefix and namespace name of\n       any qualified\
    \ name in the [normalized value] of any attribute\n       item in the [attributes]\
    \ of the subject element item or the\n       [attributes] of any descendant element\
    \ item of the subject\n       element item, or\n   (5) the binding between the\
    \ namespace prefix and namespace name of\n       any qualified name represented\
    \ by a series of character items\n       (ignoring processing instruction and\
    \ comment items) in the\n       [children] of the subject element item or the\
    \ [children] of any\n       descendant element item of the subject element item.\n\
    \      Aside: If an element is self-contained, then separating the\n      element\
    \ from its parent does not change the semantic\n      interpretation of its name\
    \ and any names in its content and\n      attributes.\n   A supposedly self-contained\
    \ element in a received RXER encoding that\n   is in fact not self-contained SHALL\
    \ be treated as an ASN.1 constraint\n   violation.\n      Aside: ASN.1 does not\
    \ require an encoding with a constraint\n      violation to be immediately rejected;\
    \ however, the constraint\n      violation must be reported at some point, possibly\
    \ in a separate\n      validation step.\n   Implementors should note that an RXER\
    \ decoder will be able to detect\n   some, but not all, violations of self-containment.\
    \  For example, it\n   can detect element and attribute names that depend on namespace\n\
    \   declarations appearing in the ancestors of a supposedly\n   self-contained\
    \ element.  Similarly, where type information is\n   available, it can detect\
    \ qualified names in character data that\n   depend on the namespace declarations\
    \ of ancestor elements.  However,\n   type information is not always available,\
    \ so some qualified names\n   will escape constraint checking.  Thus, the onus\
    \ is on the creator of\n   the original encoding to ensure that element items\
    \ required to be\n   self-contained really are completely self-contained.\n  \
    \ An element item whose content and attributes are described by a value\n   of\
    \ the Markup type MUST be self-contained.\n      Aside: The procedures in Section\
    \ 6 take account of the\n      requirements for self-containment so that an RXER\
    \ encoder\n      following these procedures will not create violations of\n  \
    \    self-containment.\n"
- title: 4.1.2.  Normalization for Canonical Encoding Rules
  contents:
  - "4.1.2.  Normalization for Canonical Encoding Rules\n   Implementations are given\
    \ some latitude in how the content and\n   attributes of an element are represented\
    \ as an abstract value of the\n   Markup type, in part because an Infoset can\
    \ have different equivalent\n   serializations.  For example, the order of attributes\
    \ and the amount\n   and kind of white space characters between attributes are\
    \ irrelevant\n   to the Infoset representation.  The content can also include\
    \ one or\n   more elements corresponding to an ASN.1 top-level NamedType or having\n\
    \   a data type that is an ASN.1 type.  It is only necessary to preserve\n   the\
    \ abstract value for such elements, and a particular abstract value\n   can have\
    \ different Infoset representations.\n   These two characteristics mean that when\
    \ an RXER encoded value of the\n   Markup type is decoded, the components of the\
    \ recovered Markup value\n   may not be exactly the same, character for character,\
    \ as the original\n   value that was encoded, though the recovered value will\
    \ be\n   semantically equivalent.\n   However, canonical ASN.1 encoding rules\
    \ such as the Distinguished\n   Encoding Rules (DER) and the Canonical Encoding\
    \ Rules (CER) [X.690],\n   which encode Markup values according to the ASN.1 definition\
    \ of the\n   Markup type, depend on character-for-character preservation of string\n\
    \   values.  This requirement can be accommodated if values of the Markup\n  \
    \ type are normalized when they are encoded according to a set of\n   canonical\
    \ encoding rules.\n      Aside: The RXER encoding and decoding of a Markup value\
    \ might\n      change the character string components of the value from the\n\
    \      perspective of BER, but there will be a single, repeatable\n      encoding\
    \ for DER.\n   A value of the Markup type will appear as the content and attributes\n\
    \   of an element in an RXER encoding.  When the value is encoded using a\n  \
    \ set of ASN.1 canonical encoding rules other than CRXER, the\n   components of\
    \ the text alternative of the value MUST be normalized as\n   follows, by reference\
    \ to the element as it would appear in a CRXER\n   encoding:\n   (1) The value\
    \ of the prolog component SHALL be the XMLDecl\n       <?xml version=\"1.1\"?>\
    \ with no other leading or trailing\n       characters.\n   (2) If the element's\
    \ name is unprefixed in the CRXER encoding, then\n       the prefix component\
    \ SHALL be absent; otherwise, the value of the\n       prefix component SHALL\
    \ be the prefix of the element's name in the\n       CRXER encoding.\n   (3) Take\
    \ the character string representing the element's attributes,\n       including\
    \ namespace declarations, in the CRXER encoding.  If the\n       first attribute\
    \ is a namespace declaration that undeclares the\n       default namespace (i.e.,\
    \ xmlns=\"\"), then remove it.  Remove any\n       leading space characters. \
    \ If the resulting character string is\n       empty, then the attributes component\
    \ SHALL be absent; otherwise,\n       the value of the attributes component SHALL\
    \ be the resulting\n       character string.\n          Aside: Note that the attributes\
    \ of an element can change if an\n          RXER encoding is re-encoded in CRXER.\n\
    \   (4) If the element has no characters between the start-tag and\n       end-tag\
    \ [XML11] in the CRXER encoding, then the content component\n       SHALL be absent;\
    \ otherwise, the value of the content component\n       SHALL be identical to\
    \ the character string in the CRXER encoding\n       bounded by the element's\
    \ start-tag and end-tag.\n      Aside: A consequence of invoking the CRXER encoding\
    \ is that any\n      nested element corresponding to an ASN.1 top-level NamedType,\
    \ or\n      indeed the element itself, will be normalized according to its\n \
    \     ASN.1 value rather than its Infoset representation.  Likewise for\n    \
    \  an element whose data type is an ASN.1 type.  Section 6.4\n      describes\
    \ how these situations can arise.\n      Aside: It is only through values of the\
    \ Markup type that\n      processing instructions and comments can appear in CRXER\n\
    \      encodings.\n   If an application uses DER, but has no knowledge of RXER,\
    \ then it\n   will not know to normalize values of the Markup type.  If RXER is\n\
    \   deployed into an environment containing such applications, then\n   Markup\
    \ values SHOULD be normalized, even when encoding using\n   non-canonical encoding\
    \ rules.\n"
- title: 4.2.  The AnyURI Type
  contents:
  - "4.2.  The AnyURI Type\n   A value of the AnyURI ASN.1 type is a character string\
    \ conforming to\n   the format of a Uniform Resource Identifier (URI) [URI].\n\
    \      AnyURI ::= UTF8String (CONSTRAINED BY\n                  { -- conforms\
    \ to the format of a URI -- })\n"
- title: 4.3.  The NCName Type
  contents:
  - "4.3.  The NCName Type\n   A value of the NCName ASN.1 type is a character string\
    \ conforming to\n   the NCName production of Namespaces in XML 1.0 [XMLNS10].\n\
    \      NCName ::= UTF8String (CONSTRAINED BY\n                     { -- conforms\
    \ to the NCName production of\n                       -- Namespaces in XML 1.0\
    \ -- })\n      Aside: The NCName production for Namespaces in XML 1.1 [XMLNS11]\n\
    \      allows a wider range of characters than the NCName production for\n   \
    \   Namespaces in XML 1.0.  The NCName type for ASN.1 is currently\n      restricted\
    \ to the characters allowed by Namespaces in XML 1.0,\n      though this may change\
    \ in a future specification of RXER.\n"
- title: 4.4.  The Name Type
  contents:
  - "4.4.  The Name Type\n   A value of the Name ASN.1 type is a character string\
    \ conforming to\n   the Name production of XML version 1.0 [XML10].\n      Name\
    \ ::= UTF8String (CONSTRAINED BY\n                     { -- conforms to the Name\
    \ production of XML -- })\n"
- title: 4.5.  The QName Type
  contents:
  - "4.5.  The QName Type\n   A value of the QName ASN.1 type describes an expanded\
    \ name [XMLNS10],\n   which appears as a qualified name [XMLNS10] in an RXER encoding.\n\
    \   RXER has special provisions for encoding values of the QName type\n   (see\
    \ Section 6.7.11).  For other encoding rules, a value of the Qname\n   type is\
    \ encoded according to the following ASN.1 type definition\n   (with AUTOMATIC\
    \ TAGS):\n      QName ::= SEQUENCE {\n          namespace-name  AnyURI OPTIONAL,\n\
    \          local-name      NCName\n      }\n   The namespace-name component holds\
    \ the namespace name of the expanded\n   name.  If the namespace name of the expanded\
    \ name has no value, then\n   the namespace-name component is absent.\n      Aside:\
    \ A namespace name can be associated with ASN.1 types and\n      top-level NamedType\
    \ instances by using the TARGET-NAMESPACE\n      encoding instruction.\n   The\
    \ local-name component holds the local name of the expanded name.\n"
- title: 5.  Expanded Names for ASN.1 Types
  contents:
  - "5.  Expanded Names for ASN.1 Types\n   A TypeAssignment in ASN.1 associates a\
    \ typereference with a Type.\n   For RXER and Abstract Syntax Notation X (ASN.X)\
    \ [ASN.X], a\n   TypeAssignment is also regarded as associating an expanded name\n\
    \   [XMLNS10] with the Type.  The local name of the expanded name is the\n   typereference\
    \ on the left-hand side of the TypeAssignment.  If the\n   target namespace [RXEREI]\
    \ of the ASN.1 module in which the\n   TypeAssignment is defined is not absent,\
    \ then the namespace name of\n   the expanded name is that target namespace; otherwise,\
    \ the namespace\n   name of the expanded name has no value.\n   A Type that is\
    \ a BuiltinType or ReferencedType that is one of the\n   productions in Table\
    \ 1 is regarded as a reference to a built-in ASN.1\n   type.  These built-in types\
    \ also have expanded names.  In each case,\n   the local name of the expanded\
    \ name is as indicated in Table 1, and\n   the namespace name of the expanded\
    \ name is\n   \"urn:ietf:params:xml:ns:asnx\".\n   Table 1: Local Names for Built-in\
    \ Types\n      +------------------------------------+-------------------+\n  \
    \    | ASN.1 Production                   | Local Name        |\n      +====================================+===================+\n\
    \      | BitStringType                      |                   |\n      |   \
    \ without a NamedBitList          | BIT-STRING        |\n      +------------------------------------+-------------------+\n\
    \      | BooleanType                        | BOOLEAN           |\n      +------------------------------------+-------------------+\n\
    \      | CharacterStringType                |                   |\n      |   \
    \ RestrictedCharacterStringType   |                   |\n      |       BMPString\
    \                    | BMPString         |\n      |       GeneralString      \
    \          | GeneralString     |\n      |       GraphicString                |\
    \ GraphicString     |\n      |       IA5String                    | IA5String\
    \         |\n      |       ISO646String                 | ISO646String      |\n\
    \      |       NumericString                | NumericString     |\n      |   \
    \    PrintableString              | PrintableString   |\n      |       TeletexString\
    \                | TeletexString     |\n      |       T61String              \
    \      | T61String         |\n      |       UniversalString              | UniversalString\
    \   |\n      |       UTF8String                   | UTF8String        |\n    \
    \  |       VideotexString               | VideotexString    |\n      |       VisibleString\
    \                | VisibleString     |\n      |    UnrestrictedCharacterStringType\
    \ | CHARACTER-STRING  |\n      +------------------------------------+-------------------+\n\
    \      | EmbeddedPDVType                    | EMBEDDED-PDV      |\n      | ExternalType\
    \                       | EXTERNAL          |\n      +------------------------------------+-------------------+\n\
    \      | IntegerType                        |                   |\n      |   \
    \ without a NamedNumberList       | INTEGER           |\n      +------------------------------------+-------------------+\n\
    \      | NullType                           | NULL              |\n      | ObjectIdentifierType\
    \               | OBJECT-IDENTIFIER |\n      | OctetStringType               \
    \     | OCTET-STRING      |\n      | RealType                           | REAL\
    \              |\n      | RelativeOIDType                    | RELATIVE-OID  \
    \    |\n      +------------------------------------+-------------------+\n   \
    \   | UsefulType                         |                   |\n      |    GeneralizedTime\
    \                 | GeneralizedTime   |\n      |    UTCTime                  \
    \       | UTCTime           |\n      |    ObjectDescriptor                | ObjectDescriptor\
    \  |\n      +------------------------------------+-------------------+\n   When\
    \ the expanded name for an ASN.1 type is used in an RXER encoding,\n   it appears\
    \ as a qualified name [XMLNS10][XMLNS11].  The namespace\n   prefix for the qualified\
    \ name is determined according to\n   Section 6.7.11.1.\n   If a compatible XML\
    \ Schema translation of an ASN.1 specification is\n   provided (see Section 6.4),\
    \ then that schema SHOULD associate the\n   same expanded name with the XML Schema\
    \ translation of an ASN.1 type.\n   Definition (namespace-qualified reference):\
    \ An ASN.1 Type is a\n   namespace-qualified reference if one of the following\
    \ applies:\n   (1) the Type is a typereference (not a DummyReference) or an\n\
    \       ExternalTypeReference in a DefinedType in a ReferencedType, the\n    \
    \   ASN.1 module in which the referenced type is defined has a\n       TARGET-NAMESPACE\
    \ encoding instruction, the referenced type is not\n       directly or indirectly\
    \ an open type [X.681], and the referenced\n       type is not directly or indirectly\
    \ the Markup type (Section 4.1),\n       or\n   (2) the Type is a BuiltinType\
    \ or ReferencedType that is one of the\n       productions in Table 1.\n   The\
    \ type definition referenced by a namespace-qualified reference\n   will have\
    \ an expanded name with a value for the namespace name.\n"
- title: 6.  Encoding Rules
  contents:
  - "6.  Encoding Rules\n   With respect to RXER, ASN.1 abstract values are uniformly\
    \ regarded as\n   analogous to the content and attributes of an element, or just\
    \ an\n   attribute value, not complete elements or attributes in their own\n \
    \  right.  Elements and attributes in an RXER encoding are defined by\n   ASN.1\
    \ NamedType notation.  Since elements are the fundamental\n   discrete structures\
    \ of an XML document, the notion of a NamedType\n   having a value that can be\
    \ encoded is useful for descriptive purposes\n   (particularly for describing\
    \ the RXER encoding of values of the ASN.1\n   combining types).  There is no\
    \ conceptual basis in X.680 [X.680] for\n   talking about the value of a NamedType,\
    \ or its encoding, so the\n   terminology is introduced here.\n   Definition (value\
    \ of a NamedType):  An abstract value of the Type in\n   a NamedType is also a\
    \ value of that NamedType.  The RXER encoding of\n   the value of a NamedType\
    \ is the RXER encoding of the abstract value\n   of the Type encapsulated according\
    \ to the definition of that\n   NamedType.\n   This document does not refer to\
    \ a value of a NamedType as being an\n   abstract value so as to remain consistent\
    \ with X.680.  An abstract\n   value is exclusively a value of an ASN.1 type.\n\
    \   A complete ASN.1 encoding is traditionally the encoding of an\n   abstract\
    \ value, but it is more natural to think of an XML document as\n   being the RXER\
    \ encoding of a value of a NamedType (because an XML\n   document has a single\
    \ root element that contains all the other\n   elements and attributes).  The\
    \ ASN.1 basic notation does not allow a\n   NamedType to appear on its own, outside\
    \ of an enclosing combining\n   type.  That is, the basic notation does not have\
    \ a concept analogous\n   to a global element or attribute definition.  However,\
    \ an ASN.1\n   specification may use an RXER encoding control section [RXEREI]\
    \ to\n   define global elements and attributes using the NamedType notation.\n\
    \   A NamedType that is not contained in an ASN.1 type definition is\n   called\
    \ a top-level NamedType [RXEREI].  Thus, an RXER encoding would\n   typically\
    \ be described as the encoding of a value of a top-level\n   NamedType.\n   Section\
    \ 6.2 describes how a value of a NamedType is encoded.\n   Section 6.3 defines\
    \ an alternative method for encoding the document\n   element of an XML document\
    \ when a top-level NamedType is not\n   specified.  Section 6.4 describes how\
    \ the encodings of ASN.1 values\n   can be embedded in an XML document where the\
    \ other parts of the\n   document are validated by an XML Schema.\n   The RXER\
    \ encoding of an abstract value, or the encoding of a value of\n   a NamedType,\
    \ is described as a translation into a synthetic Infoset,\n   which is then serialized\
    \ as XML.  This separation has been chosen for\n   descriptive convenience and\
    \ is not intended to impose any particular\n   architecture on RXER implementations.\
    \  An RXER encoder is free to\n   encode an ASN.1 value directly to XML provided\
    \ the result is\n   equivalent to following the two stage procedure described\
    \ in this\n   document.\n   The process of translating an abstract value into\
    \ an Infoset is\n   described as producing either:\n   (1) a string of characters\
    \ that either becomes part of the\n       [normalized value] of an attribute item\
    \ or becomes character\n       items among the [children] of an enclosing element\
    \ item, or\n   (2) a collection of zero or more attribute items contributing to\
    \ the\n       [attributes] of an enclosing element item, plus a series of zero\n\
    \       or more character, element, processing instruction (PI), or\n       comment\
    \ items contributing to the [children] of the enclosing\n       element item.\n\
    \   NamedType notation in the ASN.1 specification controls whether the\n   translation\
    \ of an abstract value is encapsulated in an element item\n   or in an attribute\
    \ item.\n   Sections 6.5 to 6.10 describe the translation of abstract values into\n\
    \   an Infoset for each of the ASN.1 type notations.\n   Section 6.11 describes\
    \ post-processing of namespace prefixes for\n   CRXER encodings.\n   Section 6.12\
    \ specifies how the Infoset translation is serialized as\n   XML.\n   This specification\
    \ assumes that the COMPONENTS OF transformation\n   specified in X.680, Clause\
    \ 24.4 [X.680] has already been applied to\n   all relevant types.\n   Examples\
    \ of RXER encodings in the following sections use a <value>\n   start-tag and\
    \ </value> end-tag to hold attributes and delimit the\n   content.  These start-tags\
    \ and end-tags are for illustration only and\n   are not part of the encoding\
    \ of an abstract value.  In normal use,\n   the name of the enclosing element\
    \ is provided by the context of the\n   type of the abstract value, e.g., a NamedType\
    \ in an enclosing\n   SEQUENCE type.\n   An RXER decoder is a conforming XML processor\
    \ [XML10][XML11].\n"
- title: 6.1.  Identifiers
  contents:
  - "6.1.  Identifiers\n   An identifier, as defined in ASN.1 notation (Clause 11.3\
    \ of X.680\n   [X.680]), is a character string that begins with a Latin lowercase\n\
    \   letter (U+0061-U+007A) and is followed by zero, one or more Latin\n   letters\
    \ (U+0041-U+005A, U+0061-U+007A), decimal digits (U+0030-\n   U+0039), and hyphens\
    \ (U+002D).  A hyphen is not permitted to be the\n   last character, and a hyphen\
    \ is not permitted to be followed by\n   another hyphen.  The case of letters\
    \ in an identifier is always\n   significant.\n   ASN.1 identifiers are used for\
    \ the [local name] of attribute and\n   element items, and may also appear in\
    \ the character data content of\n   elements or the values of attributes.  RXER\
    \ encoding instructions can\n   be used to substitute an NCName [XMLNS10] for\
    \ an identifier.\n"
- title: 6.2.  Component Encodings
  contents:
  - "6.2.  Component Encodings\n   The translation of the value of a NamedType is\
    \ the translation of the\n   abstract value of the Type of the NamedType encapsulated\
    \ according to\n   the definition of that NamedType.  This section specifies the\
    \ form of\n   this encapsulation.\n"
- title: 6.2.1.  Referenced Components
  contents:
  - "6.2.1.  Referenced Components\n   A value of a NamedType that is subject to a\
    \ COMPONENT-REF encoding\n   instruction is translated as a value of the top-level\
    \ NamedType\n   referenced by the encoding instruction.\n"
- title: 6.2.2.  Element Components
  contents:
  - "6.2.2.  Element Components\n   A value of a NamedType that is not subject to\
    \ an ATTRIBUTE,\n   ATTRIBUTE-REF, GROUP, or SIMPLE-CONTENT encoding instruction\
    \ is\n   translated as an element item, either as a child element item added\n\
    \   to the [children] of the enclosing element item or as the document\n   element\
    \ item added to the [children] and [document element] of the\n   document item.\
    \  If the element item is a child element item, then the\n   [parent] is the enclosing\
    \ element item; otherwise, the [parent] is\n   the document item.\n   The [local\
    \ name] of the element item is the local name of the\n   expanded name of the\
    \ NamedType (see [RXEREI]).\n      Aside: If there are no NAME, ATTRIBUTE-REF,\
    \ COMPONENT-REF,\n      ELEMENT-REF, or REF-AS-ELEMENT encoding instructions,\
    \ then the\n      local name of the expanded name of a NamedType is the same as\
    \ the\n      identifier of the NamedType.\n   If the namespace name of the expanded\
    \ name has no value, then the\n   [namespace name] of the element item has no\
    \ value (i.e., the\n   element's name is not namespace qualified); otherwise,\
    \ the\n   [namespace name] is the namespace name of the expanded name.\n   If\
    \ the type of the NamedType is directly or indirectly the Markup\n   type, then\
    \ the [in-scope namespaces] and [namespace attributes] of\n   the element item\
    \ are constructed as specified in Section 6.10;\n   otherwise, the [in-scope namespaces]\
    \ and [namespace attributes] of\n   the element item are constructed as specified\
    \ in Section 6.2.2.1.\n   If the [namespace name] of the element item has no value,\
    \ then the\n   [prefix] of the element item has no value; else if the type of\
    \ the\n   NamedType is not directly or indirectly the Markup type, then the\n\
    \   [prefix] of the element item is determined as specified in\n   Section 6.2.2.2;\
    \ otherwise, the [prefix] is determined by the Markup\n   value as specified in\
    \ Section 6.10.\n   The element item becomes the enclosing element item for the\n\
    \   translation of the value of the Type of the NamedType.\n   For a non-canonical\
    \ RXER encoding, if the type of the NamedType is\n   not directly or indirectly\
    \ the Markup type, then PI and comment items\n   MAY be added to the [children]\
    \ of the element item (before or after\n   any other items).  The element item\
    \ becomes the [parent] for each PI\n   and comment item.  These particular PI\
    \ and comment items in a\n   received RXER encoding MAY be discarded by an application.\n\
    \      Aside: There is no provision for representing comments and PIs in\n   \
    \   ASN.1 abstract values of types other than the Markup type.  These\n      items\
    \ will be lost if the abstract value is re-encoded using a\n      different set\
    \ of encoding rules.\n   For a non-canonical RXER encoding, an attribute item\
    \ with the\n   [local name] \"type\" and the [namespace name]\n   \"http://www.w3.org/2001/XMLSchema-instance\"\
    \ (i.e., xsi:type [XSD1])\n   SHOULD be added to the [attributes] of the element\
    \ item if the\n   corresponding NamedType is subject to a TYPE-AS-VERSION encoding\n\
    \   instruction and MAY be added to the [attributes] of the element item\n   if\
    \ the Type of the corresponding NamedType is a namespace-qualified\n   reference\
    \ (see Section 5).  The [prefix] of this attribute item is\n   determined as specified\
    \ in Section 6.2.3.1.  The [normalized value]\n   of this attribute item is a\
    \ qualified name for the expanded name of\n   the referenced type, with the namespace\
    \ prefix determined as\n   specified in Section 6.7.11.1.  The element item is\
    \ the\n   [owner element] for the attribute item.\n      Aside: Where a compatible\
    \ XML Schema translation of the ASN.1\n      specification has been provided,\
    \ the xsi:type attribute indicates\n      to an XML Schema validator which type\
    \ definition it should use for\n      validating the RXER encoding.\n      Aside:\
    \ An xsi:type attribute is generally not permitted in a CRXER\n      encoding.\
    \  Section 6.4 describes some circumstances where it is\n      required in a CRXER\
    \ encoding.  An xsi:type attribute might also\n      appear in a CRXER encoding\
    \ if it is contained in a value of the\n      Markup type.\n   For a non-canonical\
    \ RXER encoding, if the type of the NamedType is\n   not directly or indirectly\
    \ the Markup type, then attribute items with\n   the [local name] \"schemaLocation\"\
    \ or \"noNamespaceSchemaLocation\" and\n   the [namespace name] \"http://www.w3.org/2001/XMLSchema-instance\"\
    \n   [XSD1] MAY be added to the [attributes] of the element item.  The\n   [prefix]\
    \ for each of these attribute items is determined as specified\n   in Section\
    \ 6.2.3.1.  The [normalized value] of these attribute items\n   MUST reference\
    \ a compatible XML Schema translation of the ASN.1\n   specification.  The element\
    \ item is the [owner element] for the\n   attribute items.\n"
- title: 6.2.2.1.  Namespace Properties for Elements
  contents:
  - "6.2.2.1.  Namespace Properties for Elements\n   This section describes how the\
    \ [in-scope namespaces] and\n   [namespace attributes] of an element item are\
    \ constructed when the\n   content and attributes of the element item are not\
    \ described by a\n   value of the Markup type (otherwise, see Section 6.10).\n\
    \   The [in-scope namespaces] property of the element item initially\n   contains\
    \ only the mandatory namespace item for the \"xml\" prefix\n   [INFOSET].\n  \
    \ For a CRXER encoding, if the element item is not the\n   [document element]\
    \ of the document item and the [in-scope namespaces]\n   property of the element\
    \ item's [parent] contains a namespace item for\n   the default namespace, then\
    \ a namespace declaration attribute item\n   that undeclares the default namespace\
    \ (see Section 3) SHALL be added\n   to the element item's [namespace attributes].\n\
    \   Definition (default namespace restricted): With respect to an element\n  \
    \ item, the default namespace is restricted if:\n   (1) the [namespace name] of\
    \ the element item has no value (i.e., the\n       element's name is not namespace\
    \ qualified), or\n   (2) the element item is the enclosing element item for a\
    \ value of the\n       UNION type where the member attribute will be required\
    \ (see\n       Section 6.7.14), or\n   (3) the element item is the enclosing element\
    \ item for a value of the\n       QName type where the namespace-name component\
    \ is absent (see\n       Section 6.7.11).  This includes the case where the translation\
    \ of\n       the QName value is contained in the [normalized value] of an\n  \
    \     attribute item in the [attributes] of the element item.\n   For a non-canonical\
    \ RXER encoding, if the element item is not the\n   [document element] of the\
    \ document item and the [in-scope namespaces]\n   property of the element item's\
    \ [parent] contains a namespace item for\n   the default namespace, then either:\n\
    \   (1) that item is copied to the [in-scope namespaces] of the element\n    \
    \   item, or\n   (2) a namespace declaration attribute item that declares the\
    \ default\n       namespace is added to the element item's [namespace attributes]\n\
    \       (the namespace name is the encoder's choice), and an equivalent\n    \
    \   namespace item is added to the [in-scope namespaces] of the\n       element\
    \ item, or\n   (3) a namespace declaration attribute item that undeclares the\n\
    \       default namespace is added to the element item's\n       [namespace attributes].\n\
    \   Options (1) and (2) SHALL NOT be used if the default namespace is\n   restricted\
    \ with respect to the element item.\n   For a CRXER encoding, if the element item\
    \ is not the\n   [document element] of the document item and the element item\
    \ is not\n   required to be self-contained, then all the namespace items in the\n\
    \   [in-scope namespaces] of the [parent], excluding the namespace item\n   for\
    \ the \"xml\" prefix and any namespace item for the default\n   namespace, are\
    \ copied to the [in-scope namespaces] of the element\n   item.\n   For a non-canonical\
    \ RXER encoding, if the element item is not the\n   [document element] of the\
    \ document item and the element item is not\n   required to be self-contained,\
    \ then any subset (including none or\n   all) of the namespace items in the [in-scope\
    \ namespaces] of the\n   [parent], excluding certain items, is copied to the\n\
    \   [in-scope namespaces] of the element item.  The excluded items that\n   MUST\
    \ NOT be copied are:  the namespace item for the \"xml\" prefix, any\n   namespace\
    \ item for the default namespace, and any namespace item that\n   matches the\
    \ [prefix], but not the [namespace name], of a namespace\n   item retained for\
    \ the re-encoding of an unknown attribute item (see\n   Section 6.8.8) or an unknown\
    \ alternative of a UNION (see\n   Section 6.7.14).\n      Aside: The descriptive\
    \ approach used by this document only allows\n      a namespace prefix to be used\
    \ by a new namespace item if it is not\n      currently used by another namespace\
    \ item in the\n      [in-scope namespaces].  By not inheriting a namespace item,\
    \ the\n      prefix of that namespace is again available for reuse without fear\n\
    \      of breaking an existing dependency on the prefix.\n   Element items that\
    \ are required to be self-contained inherit none of\n   the namespace items in\
    \ the [in-scope namespaces] of the [parent].\n   Any namespace item that is retained\
    \ for the re-encoding of an unknown\n   attribute item (Section 6.8.8) or an unknown\
    \ alternative of a UNION\n   (Section 6.7.14) and which is not in the [in-scope\
    \ namespaces] of the\n   element item MUST be added to the [in-scope namespaces].\
    \  An\n   equivalent namespace declaration attribute item MUST be added to the\n\
    \   [namespace attributes] of the element item.\n   Definition (unused namespace\
    \ prefix): A namespace prefix is unused if\n   it does not match the [prefix]\
    \ of any namespace item in the\n   [in-scope namespaces] of the element item.\n\
    \   For a non-canonical RXER encoding, if the type of the NamedType is\n   not\
    \ directly or indirectly the Markup type, then additional namespace\n   declaration\
    \ attribute items for currently unused namespace prefixes\n   MAY be added to\
    \ the [namespace attributes] of the element item.  An\n   equivalent namespace\
    \ item MUST be added to the [in-scope namespaces]\n   of the element item for\
    \ each additional namespace declaration\n   attribute item.\n   For a non-canonical\
    \ RXER encoding, if the type of the NamedType is\n   not directly or indirectly\
    \ the Markup type, and the\n   [in-scope namespaces] property of the element item\
    \ does not contain a\n   namespace item for the default namespace, and the default\
    \ namespace\n   is not restricted with respect to the element item, then a namespace\n\
    \   declaration attribute item for the default namespace MAY be added to\n   the\
    \ [namespace attributes] of the element item, in which case an\n   equivalent\
    \ namespace item MUST be added to the [in-scope namespaces]\n   of the element\
    \ item.\n   Whenever a namespace declaration attribute item is added to an\n \
    \  element item's [namespace attributes], the [owner element] of the\n   attribute\
    \ item is set to the element item.\n"
- title: 6.2.2.2.  Namespace Prefixes for Element Names
  contents:
  - "6.2.2.2.  Namespace Prefixes for Element Names\n   This section describes how\
    \ the [prefix] of an element item is\n   determined when the element item has\
    \ a value for its [namespace name]\n   and the content and attributes of the element\
    \ item are not described\n   by a value of the Markup type (otherwise, see Section\
    \ 6.10).\n   For a CRXER encoding, if the [namespace name] of the element item\
    \ has\n   a value, then the [prefix] of the element item is any unused\n   non-canonical\
    \ namespace prefix unless the [in-scope namespaces]\n   property of the element\
    \ item contains a namespace item with the same\n   [namespace name] as the element\
    \ item.  In that case, the [prefix] of\n   that namespace item SHALL be used as\
    \ the [prefix] of the element\n   item.\n      Aside: These prefixes will be rewritten\
    \ to canonical namespace\n      prefixes during the final step in producing the\
    \ Infoset\n      translation (see Section 6.11).  Canonical namespace prefixes\
    \ are\n      not used here in the first instance because canonicalization\n  \
    \    depends on knowing the final [namespace attributes] produced by\n      encoding\
    \ the abstract value of the type of the NamedType.  If an\n      implementation\
    \ looks ahead to determine this final set prior to\n      translating the abstract\
    \ value, then it can assign the appropriate\n      canonical namespace prefix\
    \ in this step and skip the rewriting\n      step.\n   For a non-canonical RXER\
    \ encoding, if the [namespace name] has a\n   value, then the [prefix] of the\
    \ element item is any unused namespace\n   prefix unless the [in-scope namespaces]\
    \ property of the element item\n   contains a namespace item with the same [namespace\
    \ name] as the\n   element item.  In that case, the [prefix] of that namespace\
    \ item MAY\n   be used as the [prefix] of the element item.  Note that the [prefix]\n\
    \   of a namespace item for the default namespace has no value.\n   If the [prefix]\
    \ of the element item is an unused namespace prefix,\n   then a namespace declaration\
    \ attribute item associating the namespace\n   prefix with the namespace name\
    \ MUST be added to the\n   [namespace attributes] of the element item, and a corresponding\n\
    \   namespace item MUST be added to the [in-scope namespaces] of the\n   element\
    \ item.\n      Aside: The [local name] of the namespace declaration attribute\n\
    \      item is the same as the [prefix] of the element item, the\n      [namespace\
    \ name] of the attribute item is\n      \"http://www.w3.org/2000/xmlns/\", and\
    \ the [normalized value] of the\n      attribute item is the same as the [namespace\
    \ name] of the element\n      item.  The namespace item has the same [prefix]\
    \ and\n      [namespace name] as the element item.\n"
- title: 6.2.3.  Attribute Components
  contents:
  - "6.2.3.  Attribute Components\n   A value of a NamedType subject to an ATTRIBUTE\
    \ or ATTRIBUTE-REF\n   encoding instruction is translated as an attribute item\
    \ added to the\n   [attributes] of the enclosing element item (which becomes the\n\
    \   [owner element] of the attribute item).\n   The [local name] of the attribute\
    \ item is the local name of the\n   expanded name of the NamedType (see [RXEREI]).\n\
    \   If the namespace name of the expanded name has no value, then the\n   [namespace\
    \ name] of the attribute item has no value; otherwise, the\n   [namespace name]\
    \ is the namespace name of the expanded name.\n   If the [namespace name] has\
    \ a value, then the [prefix] of the\n   attribute item is determined as specified\
    \ in Section 6.2.3.1;\n   otherwise, the [prefix] of the attribute item has no\
    \ value.\n   The [normalized value] of the attribute item is the translation of\n\
    \   the value of the Type of the NamedType.\n   For completeness, the [specified]\
    \ property is set to true, the\n   [attribute type] has no value, and the value\
    \ of the [references]\n   property is set to unknown.\n"
- title: 6.2.3.1.  Namespace Prefixes for Attribute Names
  contents:
  - "6.2.3.1.  Namespace Prefixes for Attribute Names\n   This section applies when\
    \ an attribute item with a value for its\n   [namespace name] is added to the\
    \ [attributes] of an element item.\n   For a CRXER encoding, the [prefix] of the\
    \ attribute item is any\n   unused non-canonical namespace prefix unless the\n\
    \   [in-scope namespaces] property of the [owner element] contains a\n   namespace\
    \ item with a value for the [prefix] (i.e., is not a\n   namespace item for the\
    \ default namespace) and the same\n   [namespace name] as the attribute item.\
    \  In that case, the [prefix]\n   of that namespace item SHALL be used as the\
    \ [prefix] of the attribute\n   item.\n   For a non-canonical RXER encoding, the\
    \ [prefix] of the attribute item\n   is any unused namespace prefix unless the\
    \ [in-scope namespaces]\n   property of the [owner element] contains a namespace\
    \ item with a\n   value for the [prefix] and the same [namespace name] as the\
    \ attribute\n   item.  In that case, the [prefix] of that namespace item MAY be\
    \ used\n   as the [prefix] of the attribute item.\n   If the [prefix] of the attribute\
    \ item is an unused namespace prefix,\n   then a namespace declaration attribute\
    \ item associating the namespace\n   prefix with the namespace name MUST be added\
    \ to the\n   [namespace attributes] of the [owner element], and a corresponding\n\
    \   namespace item MUST be added to the [in-scope namespaces] of the\n   [owner\
    \ element].\n"
- title: 6.2.4.  Unencapsulated Components
  contents:
  - "6.2.4.  Unencapsulated Components\n   A value of a NamedType subject to a GROUP\
    \ or SIMPLE-CONTENT encoding\n   instruction is translated as the value of the\
    \ Type of the NamedType,\n   i.e., without encapsulation in an element item or\
    \ attribute item.\n   Consequently, the enclosing element item for the translation\
    \ of the\n   value of the NamedType is also the enclosing element item for the\n\
    \   translation of the value of the Type of the NamedType.\n"
- title: 6.2.5.  Examples
  contents:
  - "6.2.5.  Examples\n   Consider this type definition:\n      CHOICE {\n       \
    \   one    [0] BOOLEAN,\n          two    [1] [RXER:ATTRIBUTE] INTEGER,\n    \
    \      three  [2] [RXER:NAME AS \"THREE\"] OBJECT IDENTIFIER,\n          four\
    \   [3] [RXER:ATTRIBUTE-REF {\n                         namespace-name \"http://www.example.com\"\
    ,\n                         local-name     \"foo\" }] UTF8String,\n          five\
    \   [4] [RXER:ELEMENT-REF {\n                         namespace-name \"http://www.example.com\"\
    ,\n                         local-name     \"bar\" }] Markup,\n          six \
    \   [5] [RXER:GROUP] SEQUENCE {\n              seven  [0] [RXER:ATTRIBUTE] INTEGER,\n\
    \              eight  [1] INTEGER\n          }\n      }\n   The content and attributes\
    \ of each of the following <value> elements\n   are the RXER encoding of a value\
    \ of the above type:\n      <value>\n       <one>true</one>\n      </value>\n\
    \      <value two=\"100\"/>\n      <value>\n       <THREE>2.5.4.3</THREE>\n  \
    \    </value>\n      <value xmlns:ex=\"http://www.example.com\"\n            \
    \ ex:foo=\"a string\"/>\n      <value>\n       <ex:bar xmlns:ex=\"http://www.example.com\"\
    >another string</ex:bar>\n      </value>\n      <value seven=\"200\">\n      \
    \ <eight>300</eight>\n      </value>\n"
- title: 6.3.  Standalone Encodings
  contents:
  - "6.3.  Standalone Encodings\n   A typical RXER encoding is the encoding of a value\
    \ of a nominated\n   top-level NamedType.  An abstract value MAY be encoded as\
    \ an XML\n   document without nominating an explicit top-level NamedType by\n\
    \   invoking a Standalone RXER Encoding or Standalone CRXER Encoding.\n   In a\
    \ Standalone RXER Encoding or Standalone CRXER Encoding, the\n   abstract value\
    \ is encoded as the value of a notional NamedType where\n   the identifier of\
    \ the NamedType is \"value\" and the Type of the\n   NamedType is the type of\
    \ the abstract value.  The NamedType is\n   assumed to be subject to no encoding\
    \ instructions.\n      Aside: Thus, the element item corresponding to the document\n\
    \      element will have the [local name] \"value\" and no value for the\n   \
    \   [namespace name] and [prefix].\n   If RXER is chosen as the transfer syntax\
    \ in an EMBEDDED PDV value,\n   then the data-value OCTET STRING SHALL contain\
    \ a Standalone RXER\n   encoding.\n   If CRXER is chosen as the transfer syntax\
    \ in an EMBEDDED PDV value,\n   then the data-value OCTET STRING SHALL contain\
    \ a Standalone CRXER\n   encoding.\n   If RXER is chosen as the transfer syntax\
    \ in an EXTERNAL value, then\n   the octet-aligned OCTET STRING or arbitrary BIT\
    \ STRING SHALL contain\n   a Standalone RXER encoding.\n   If CRXER is chosen\
    \ as the transfer syntax in an EXTERNAL value, then\n   the octet-aligned OCTET\
    \ STRING or arbitrary BIT STRING SHALL contain\n   a Standalone CRXER encoding.\n"
- title: 6.4.  Embedded ASN.1 Values
  contents:
  - "6.4.  Embedded ASN.1 Values\n   The reference encoding instructions [RXEREI]\
    \ allow XML Schema\n   definitions to be referenced from an ASN.1 specification.\
    \  It is also\n   possible to reference an ASN.1 type or top-level NamedType from\
    \ an\n   XML Schema definition or from an information item validated by an\n \
    \  XML Schema wildcard.  The manner in which an XML Schema definition\n   references\
    \ an ASN.1 type or top-level NamedType has an effect on the\n   CRXER encoding\
    \ of a value of the type or top-level NamedType.\n   This section also applies\
    \ to XML Schema definitions that validate\n   information items that are contained\
    \ in a value of the Markup type.\n      Aside: So the document element of an XML\
    \ document might be\n      described by an XML Schema definition that at some\
    \ point\n      references an ASN.1 definition that uses a reference encoding\n\
    \      instruction to reference another XML Schema definition that then\n    \
    \  references another ASN.1 definition, and so on.\n   In each of the following\
    \ cases, an element or attribute item is only\n   permitted to be, or to encapsulate,\
    \ an RXER Infoset translation of an\n   ASN.1 value if an XML Schema element declaration\
    \ or ASN.1 NamedType\n   is known for the [parent] element item ([owner element]\
    \ in the case\n   of an attribute declaration), for the [parent] of the [parent]\n\
    \   element item, and so on, to the document element of the XML document.\n  \
    \ This condition is not satisfied by a NamedType where the Type is\n   directly\
    \ or indirectly the Markup type and the NamedType is not\n   subject to a reference\
    \ encoding instruction.\n      Aside: An element declaration becomes known for\
    \ an element item\n      through assessment [XSD1].  A NamedType becomes known\
    \ for an\n      element item through decoding.\n      Aside: If an XML Schema\
    \ element declaration or ASN.1 NamedType is\n      not known for an element item,\
    \ then the type of the element item\n      and the type of every nested element\
    \ item are treated as unknown.\n      Although an xsi:type attribute definitively\
    \ identifies the type of\n      an element item even if an element declaration\
    \ for the element\n      item is not known, this attribute is generally optional\
    \ in an RXER\n      encoding and so cannot be relied upon when seen in isolation\
    \ from\n      an element declaration.  Although only top-level NamedType\n   \
    \   instances can have namespace-qualified names in the current RXER\n      specification,\
    \ a future version may allow nested NamedType\n      instances to also have namespace-qualified\
    \ names, in which case it\n      will not necessarily be possible to distinguish\
    \ a nested NamedType\n      from a top-level NamedType without knowledge of the\
    \ type of the\n      [parent] element item.\n   An ASN.1 type with an expanded\
    \ name (Section 5) MAY be referenced by\n   the type attribute of an XML Schema\
    \ element declaration.  The\n   reference takes the form of a qualified name for\
    \ the expanded name.\n   An element item validated by such an element declaration\
    \ encapsulates\n   the Infoset translation of an abstract value of the ASN.1 type.\
    \  The\n   [namespace name] and [local name] of the element item are determined\n\
    \   by the XML Schema element declaration.  The remaining properties are\n   determined\
    \ according to RXER.  The element item MUST be\n   self-contained for a CRXER\
    \ encoding.\n      Aside: The element item is not required to be self-contained\
    \ for a\n      non-canonical RXER encoding.\n   A top-level NamedType MAY be referenced\
    \ by the ref attribute of an\n   XML Schema element declaration if the NamedType\
    \ is not subject to an\n   ATTRIBUTE encoding instruction.  The reference takes\
    \ the form of a\n   qualified name for the expanded name of the top-level NamedType\n\
    \   [RXEREI].  An element item validated by such an element declaration\n   is\
    \ the Infoset translation of a value of the referenced top-level\n   NamedType.\
    \  All the properties of the element item are determined\n   according to RXER.\
    \  The element item MUST be self-contained for a\n   CRXER encoding.\n   A top-level\
    \ NamedType MAY be referenced by the ref attribute of an\n   XML Schema attribute\
    \ declaration if the NamedType is subject to an\n   ATTRIBUTE encoding instruction\
    \ and the definition of the type of the\n   NamedType does not depend on the QName\
    \ type in any way.  An attribute\n   item validated by such an attribute declaration\
    \ is the Infoset\n   translation of a value of the referenced top-level NamedType,\
    \ except\n   that whatever valid [prefix] is initially chosen for the attribute\n\
    \   item MUST be preserved in any re-encoding.  The remaining properties\n   of\
    \ the attribute item are determined according to RXER.\n      Aside: The exclusion\
    \ of the QName type means that the attribute\n      value is not dependent upon\
    \ any namespace declarations of its\n      parent element item.\n   An element\
    \ item that is validated by an XML Schema element\n   declaration that has the\
    \ ur-type (i.e., anyType) as its type\n   definition MAY encapsulate the Infoset\
    \ translation of a value of an\n   ASN.1 type with an expanded name.  The [namespace\
    \ name] and\n   [local name] of the element item are determined by the XML Schema\n\
    \   element declaration.  The remaining properties of the element item\n   are\
    \ determined according to RXER.  The [attributes] of the element\n   item SHALL\
    \ contain an attribute item with the [local name] \"type\" and\n   the [namespace\
    \ name] \"http://www.w3.org/2001/XMLSchema-instance\"\n   (i.e., an xsi:type attribute).\
    \  The [prefix] of this attribute item\n   is determined as specified in Section\
    \ 6.2.3.1.  The\n   [normalized value] of this attribute item is a qualified name\
    \ for the\n   expanded name of the ASN.1 type, with the namespace prefix determined\n\
    \   as specified in Section 6.7.11.1.  The element item MUST be\n   self-contained\
    \ for a CRXER encoding.\n   An element item that is validated by an XML Schema\
    \ wildcard (i.e.,\n   <xs:any/>) MAY be the Infoset translation of a value of\
    \ a top-level\n   NamedType that is not subject to an ATTRIBUTE encoding instruction\n\
    \   and comes from an ASN.1 module with a target namespace [RXEREI] that\n   satisfies\
    \ the namespace constraint of the wildcard.  All the\n   properties of the element\
    \ item are determined according to RXER.  The\n   element item MUST be self-contained\
    \ for a CRXER encoding.\n   An attribute item that is validated by an XML Schema\
    \ wildcard (i.e.,\n   <xs:anyAttribute/>) MAY be the Infoset translation of a\
    \ value of a\n   top-level NamedType if the NamedType is subject to an ATTRIBUTE\n\
    \   encoding instruction, comes from an ASN.1 module with a target\n   namespace\
    \ that satisfies the namespace constraint of the wildcard,\n   and has a type\
    \ that does not depend on the QName type in any way.\n   Whatever valid [prefix]\
    \ is initially chosen for the attribute item\n   MUST be preserved in any re-encoding.\
    \  The remaining properties of\n   the attribute item are determined according\
    \ to RXER.\n   No other mechanisms for referencing an ASN.1 type or top-level\n\
    \   NamedType from a different XML schema language are supported in this\n   version\
    \ of RXER.  In particular, this excludes an ASN.1 type being\n   used as the base\
    \ type in an XML Schema derivation by extension or\n   restriction, as a member\
    \ type for an XML Schema union type, as an\n   item type for an XML Schema list\
    \ type, or as the type in an\n   XML Schema attribute declaration.\n   A fully\
    \ conformant RXER implementation will understand both ASN.1 and\n   XML Schema\
    \ and will recognize the transitions between information\n   items controlled\
    \ by ASN.1 definitions and those controlled by\n   XML Schema definitions.  However,\
    \ a purely XML Schema validator used\n   to assess the validity of an RXER encoding\
    \ will perceive any\n   reference to an ASN.1 type or top-level NamedType as an\
    \ unresolved\n   reference.  In order to enable such assessment, it is desirable\
    \ to\n   provide an XML Schema translation of the ASN.1 definitions being\n  \
    \ referenced from an XML Schema.  Although XML Schema and ASN.1 are\n   broadly\
    \ similar, they each have unique features that cannot be\n   adequately expressed\
    \ in the other language, so a semantically\n   equivalent translation is not possible\
    \ in the general case.\n   Fortunately, to simply achieve successful assessment\
    \ it is sufficient\n   for the XML Schema translation of an ASN.1 specification\
    \ to be\n   compatible with that ASN.1 specification.  That is, the XML Schema\n\
    \   translation MUST be constructed such that every correct RXER encoding\n  \
    \ is assessed as valid.  Although not ideal, it is acceptable for the\n   XML\
    \ Schema to assess some incorrect RXER encodings as also being\n   valid (a conformant\
    \ RXER decoder will, of course, reject such an\n   encoding).\n   The simplest\
    \ compatible XML Schema translation of an ASN.1 module is\n   one in which every\
    \ type is equivalent to the XML Schema ur-type.  For\n   example, given an ASN.1\
    \ type with the reference name MyType, a\n   sufficient compatible XML Schema\
    \ type definition is:\n      <xs:complexType name=\"MyType\" mixed=\"true\">\n\
    \       <xs:sequence>\n        <xs:any processContents=\"lax\"\n             \
    \    minOccurs=\"0\" maxOccurs=\"unbounded\"/>\n       </xs:sequence>\n      \
    \ <xs:anyAttribute processContents=\"lax\"/>\n      </xs:complexType>\n      \
    \    OR\n      <xs:complexType name=\"MyType\">\n       <xs:complexContent>\n\
    \        <xs:extension base=\"xs:anyType\"/>\n       </xs:complexContent>\n  \
    \    </xs:complexType>\n      Aside: Because of the possible presence of an asnx:context\n\
    \      attribute (Section 6.8.8.1), it is easiest to assume that all\n      ASN.1\
    \ types translate into XML Schema complex types.\n   Given an ASN.1 top-level\
    \ NamedType that is not subject to an\n   ATTRIBUTE encoding instruction and has\
    \ the reference name myElement,\n   a sufficient compatible XML Schema element\
    \ declaration is:\n      <xs:element name=\"myElement\"/>\n   Given an ASN.1 top-level\
    \ NamedType that is subject to an ATTRIBUTE\n   encoding instruction and has the\
    \ reference name myAttribute, a\n   sufficient compatible XML Schema attribute\
    \ declaration is:\n      <xs:attribute name=\"myAttribute\"/>\n   An application\
    \ specification that mixes ASN.1 and XML Schema is free\n   to provide a stricter\
    \ translation of its ASN.1 definitions; however,\n   a more thorough treatment\
    \ for translating an ASN.1 module into an\n   XML Schema is out of scope for this\
    \ document.\n"
- title: 6.5.  Type Referencing Notations
  contents:
  - "6.5.  Type Referencing Notations\n   A value of a type with a defined type name\
    \ is translated according to\n   the type definition on the right-hand side of\
    \ the type assignment for\n   the type name.\n   A value of a type denoted by\
    \ the use of a parameterized type with\n   actual parameters is translated according\
    \ to the parameterized type\n   with the DummyReferences [X.683] substituted with\
    \ the actual\n   parameters.\n   A value of a constrained type is translated as\
    \ a value of the type\n   without the constraint.  See X.680 [X.680] and X.682\
    \ [X.682] for the\n   details of ASN.1 constraint notation.\n   A prefixed type\
    \ [X.680-1] associates an encoding instruction with a\n   type.  A value of a\
    \ prefixed type is translated as a value of the\n   type without the prefix.\n\
    \      Aside: This does not mean that RXER encoding instructions are\n      ignored.\
    \  It is simply easier to describe their effects in\n      relation to specific\
    \ built-in types, rather than as the\n      translation of a value of a prefixed\
    \ type.\n   A tagged type is a special case of a prefixed type.  A value of a\n\
    \   tagged type is translated as a value of the type without the tag.\n   ASN.1\
    \ tags do not appear in the XML encodings defined by this\n   document.\n   A\
    \ value of a fixed type denoted by an ObjectClassFieldType is\n   translated according\
    \ to that fixed type (see Section 6.9 for the case\n   of an ObjectClassFieldType\
    \ denoting an open type).\n   A value of a selection type is translated according\
    \ to the type\n   referenced by the selection type.  Note that component encoding\n\
    \   instructions are not inherited by the type referenced by a selection\n   type\
    \ [RXEREI].\n   A value of a type described by TypeFromObject notation [X.681]\
    \ is\n   translated according to the denoted type.\n   A value of a type described\
    \ by ValueSetFromObjects notation [X.681]\n   is translated according to the governing\
    \ type.\n"
- title: 6.6.  TypeWithConstraint, SEQUENCE OF Type, and SET OF Type
  contents:
  - "6.6.  TypeWithConstraint, SEQUENCE OF Type, and SET OF Type\n   For the purposes\
    \ of this document, a TypeWithConstraint is treated as\n   if it were the parent\
    \ type [X.680] (either a SEQUENCE OF or SET OF\n   type).\n   For example,\n \
    \     SEQUENCE SIZE(1..MAX) OF SomeType\n         is treated like\n      SEQUENCE\
    \ OF SomeType\n   Additionally, a \"SEQUENCE OF Type\" (including the case where\
    \ it is\n   the parent type for a TypeWithConstraint) is treated as if it were\
    \ a\n   \"SEQUENCE OF NamedType\", where the identifier of the NamedType is\n\
    \   assumed to be \"item\".  Similarly, a \"SET OF Type\" (including the case\n\
    \   where it is the parent type for a TypeWithConstraint) is treated as\n   if\
    \ it were a \"SET OF NamedType\", where the identifier of the\n   NamedType is\
    \ assumed to be \"item\".\n   For example,\n      SEQUENCE SIZE(1..MAX) OF SomeType\n\
    \         is ultimately treated like\n      SEQUENCE OF item SomeType\n"
- title: 6.7.  Character Data Translations
  contents:
  - "6.7.  Character Data Translations\n   For the majority of ASN.1 built-in types,\
    \ encodings of values of\n   those types never have element content.  The encoding\
    \ of a value of\n   an ASN.1 combining type (except a UNION or LIST type) typically\
    \ has\n   element content.\n   For those types that do not produce element content,\
    \ the translation\n   of an abstract value is described as a character string\
    \ of ISO 10646\n   characters [UCS].  This character data translation will be\
    \ destined\n   to become either part of the [normalized value] of an attribute\
    \ item,\n   or a series of character items in the [children] of an element item\n\
    \   (which becomes the [parent] for the character items).  The case that\n   applies\
    \ is determined in accordance with Section 6.2.\n   For a non-canonical RXER encoding,\
    \ if the type of the abstract value\n   is not directly or indirectly a restricted\
    \ character string type, the\n   NULL type, or a UNION type, then leading and/or\
    \ trailing white space\n   characters MAY be added to the character data translation.\n\
    \      Aside: White space characters are significant in the encoding of a\n  \
    \    value of a restricted character string type, and a restricted\n      character\
    \ string type can be a member type of a UNION type.  The\n      encoding of a\
    \ NULL value produces no character data.\n      Aside: Optional white space characters\
    \ are not permitted in a\n      CRXER encoding.\n   For a non-canonical RXER encoding,\
    \ if the type of the abstract value\n   is directly or indirectly the AnyURI,\
    \ NCName, or Name type, then\n   leading and trailing white space characters MAY\
    \ be added to the\n   character data translation.\n      Aside: These types are\
    \ indirectly a restricted character string\n      type (UTF8String); however,\
    \ their definitions exclude white space\n      characters, so any white space\
    \ characters appearing in an encoding\n      are not part of the abstract value\
    \ and can be safely ignored.\n      This exception does not apply to other subtypes\
    \ of a restricted\n      character string type that happen to exclude white space\n\
    \      characters.\n"
- title: 6.7.1.  Restricted Character String Types
  contents:
  - "6.7.1.  Restricted Character String Types\n   The character data translation\
    \ of a value of a restricted character\n   string type is the sequence of characters\
    \ in the string.\n   Depending on the ASN.1 string type, and an application's\
    \ internal\n   representation of that string type, a character may need to be\n\
    \   translated to or from the equivalent ISO 10646 character code [UCS].\n   The\
    \ NumericString, PrintableString, IA5String, VisibleString\n   (ISO646String),\
    \ BMPString, UniversalString, and UTF8String character\n   encodings use the same\
    \ character codes as ISO 10646.  For the\n   remaining string types (GeneralString,\
    \ GraphicString, TeletexString,\n   T61String, and VideotexString), see X.680\
    \ [X.680].\n   The null character (U+0000) is not a legal character for XML. \
    \ It is\n   omitted from the character data translation of a string value.\n \
    \  Certain other control characters are legal for XML version 1.1, but\n   not\
    \ for version 1.0.  If any string value contains these characters,\n   then the\
    \ RXER encoding must use XML version 1.1 (see Section 6.12).\n   All white space\
    \ characters in the RXER encoding of a value of a\n   restricted character string\
    \ type (excluding the AnyURI, NCName, and\n   Name subtypes) are significant,\
    \ i.e., part of the abstract value.\n   Examples\n      The content of each of\
    \ the following <value> elements is the RXER\n      encoding of an IA5String value:\n\
    \         <value> Don't run with scissors! </value>\n         <value>Markup (e.g.,\
    \ &lt;value&gt;) has to be escaped.</value>\n         <value>Markup (e.g., <![CDATA[<value>]]>)\n\
    \         has to be escaped. </value>\n"
- title: 6.7.2.  BIT STRING
  contents:
  - "6.7.2.  BIT STRING\n   The character data translation of a value of the BIT STRING\
    \ type is\n   either a binary digit string, a hexadecimal digit string, or a list\n\
    \   of bit names.\n   A binary digit string is a sequence of zero, one, or more\
    \ of the\n   binary digit characters '0' and '1' (i.e., U+0030 and U+0031).  Each\n\
    \   bit in the BIT STRING value is encoded as a binary digit in order\n   from\
    \ the first bit to the last bit.\n   For a non-canonical RXER encoding, if the\
    \ BIT STRING type has a\n   NamedBitList, then trailing zero bits MAY be omitted\
    \ from a binary\n   digit string.\n   A hexadecimal digit string is permitted\
    \ if and only if the number of\n   bits in the BIT STRING value is zero or a multiple\
    \ of eight and the\n   character data translation is destined for the [children]\
    \ of an\n   element item.\n   A hexadecimal digit string is a sequence of zero,\
    \ one, or more pairs\n   of the hexadecimal digit characters '0'-'9', 'A'-'F',\
    \ and 'a'-'f'\n   (i.e., U+0030-U+0039, U+0041-U+0046 and U+0061-U+0066).  Each\
    \ group\n   of eight bits in the BIT STRING value is encoded as a pair of\n  \
    \ hexadecimal digits where the first bit is the most significant.  An\n   odd\
    \ number of hexadecimal digits is not permitted.  The characters\n   'a'-'f' (i.e.,\
    \ U+0061-U+0066) SHALL NOT be used in the CRXER encoding\n   of a BIT STRING value.\
    \  If a hexadecimal digit string is used, then\n   the enclosing element's [attributes]\
    \ MUST contain an attribute item\n   with the [local name] \"format\", the [namespace\
    \ name]\n   \"urn:ietf:params:xml:ns:asnx\", and the [normalized value] \"hex\"\
    \n   (i.e., asnx:format=\"hex\").  The [prefix] of the attribute item is\n   determined\
    \ as specified in Section 6.2.3.1.\n      Aside: The hexadecimal digit string\
    \ is intended to conform to the\n      lexical representation of the XML Schema\
    \ [XSD2] hexBinary data\n      type.\n   For a non-canonical RXER encoding, if\
    \ the preconditions for using a\n   hexadecimal digit string are satisfied, then\
    \ a hexadecimal digit\n   string MAY be used.\n   A list of bit names is permitted\
    \ if and only if the BIT STRING type\n   has a NamedBitList and each '1' bit in\
    \ the BIT STRING value has a\n   corresponding identifier in the NamedBitList.\n\
    \      Aside: ASN.1 does not require that an identifier be assigned for\n    \
    \  every bit.\n   A list of bit names is a sequence of names for the '1' bits\
    \ in the\n   BIT STRING value, in any order, each separated from the next by at\n\
    \   least one white space character.  If the BitStringType is not subject\n  \
    \ to a VALUES encoding instruction, then each '1' bit in the BIT STRING\n   value\
    \ is represented by its corresponding identifier from the\n   NamedBitList.  If\
    \ the BitStringType is subject to a VALUES encoding\n   instruction, then each\
    \ '1' bit in the BIT STRING value is represented\n   by the replacement name [RXEREI]\
    \ for its corresponding identifier.\n   For a CRXER encoding, if the BIT STRING\
    \ type has a NamedBitList, then\n   a binary digit string MUST be used, and trailing\
    \ zero bits MUST be\n   omitted from the binary digit string; else if the number\
    \ of bits in\n   the BIT STRING value is greater than or equal to 64, and the\n\
    \   preconditions for using a hexadecimal digit string are satisfied,\n   then\
    \ a hexadecimal digit string MUST be used; otherwise, a binary\n   digit string\
    \ MUST be used.\n      Aside: Because the asnx:format attribute adds an overhead\
    \ to a\n      hexadecimal encoding (including a namespace declaration for the\n\
    \      \"asnx\" prefix), a bit string of less than 64 bits is more\n      compactly\
    \ encoded as a binary digit string.\n   Examples\n      Consider this type definition:\n\
    \         BIT STRING { black(0), red(1), orange(2), yellow(3),\n             green(4),\
    \ blue(5), indigo(6), violet(7) }\n      The content and attributes of each of\
    \ the following <value>\n      elements are an RXER encoding of the same abstract\
    \ value:\n         <value>  green violet  orange</value>\n         <value> 001<!--Orange-->01001\
    \ </value>\n         <value xmlns:asnx=\"urn:ietf:params:xml:ns:asnx\"\n     \
    \           asnx:format=\"hex\">\n          29\n         </value>\n         <value>00101001</value>\n\
    \      The final case contains the CRXER encoding of the abstract value.\n"
- title: 6.7.3.  BOOLEAN
  contents:
  - "6.7.3.  BOOLEAN\n   For a non-canonical RXER encoding, the character data translation\
    \ of\n   the BOOLEAN value TRUE is the string \"true\" or \"1\", at the encoder's\n\
    \   discretion.  For a CRXER encoding, the character data translation of\n   the\
    \ BOOLEAN value TRUE is the string \"true\".\n   For a non-canonical RXER encoding,\
    \ the character data translation of\n   the BOOLEAN value FALSE is the string\
    \ \"false\" or \"0\", at the\n   encoder's discretion.  For a CRXER encoding,\
    \ the character data\n   translation of the BOOLEAN value FALSE is the string\
    \ \"false\".\n      Aside: The RXER encoding of BOOLEAN values is intended to\
    \ conform\n      to the lexical representation of the XML Schema [XSD2] boolean\n\
    \      data type.\n   Examples\n      The content of each of the following <value>\
    \ elements is the RXER\n      encoding of a BOOLEAN value:\n         <value>1</value>\n\
    \         <value>\n             false\n         </value>\n         <value> fal<!--\
    \ a pesky comment -->se </value>\n"
- title: 6.7.4.  ENUMERATED
  contents:
  - "6.7.4.  ENUMERATED\n   The character data translation of a value of an ENUMERATED\
    \ type where\n   the EnumeratedType is not subject to a VALUES encoding instruction\
    \ is\n   the identifier corresponding to the actual value.\n   Examples\n    \
    \  Consider this type definition:\n         ENUMERATED { sunday, monday, tuesday,\n\
    \             wednesday, thursday, friday, saturday }\n      The content of both\
    \ of the following <value> elements is the RXER\n      encoding of a value of\
    \ the above type:\n         <value>monday</value>\n         <value>\n        \
    \     thursday\n         </value>\n   The character data translation of a value\
    \ of an ENUMERATED type where\n   the EnumeratedType is subject to a VALUES encoding\
    \ instruction is the\n   replacement name [RXEREI] for the identifier corresponding\
    \ to the\n   actual value.\n   Examples\n      Consider this type definition:\n\
    \         [RXER:VALUES ALL CAPITALIZED,\n                 sunday AS \"SUNDAY\"\
    , saturday AS \"SATURDAY\"]\n             ENUMERATED { sunday, monday, tuesday,\n\
    \                 wednesday, thursday, friday, saturday }\n      The content of\
    \ each of the following <value> elements is the RXER\n      encoding of a value\
    \ of the above type:\n         <value>SUNDAY</value>\n         <value>\n     \
    \        Monday\n         </value>\n         <value> Tuesday </value>\n"
- title: 6.7.5.  GeneralizedTime
  contents:
  - "6.7.5.  GeneralizedTime\n   The character data translation of a value of the\
    \ GeneralizedTime type\n   is a date, the letter 'T' (U+0054), a time of day,\
    \ optional\n   fractional seconds, and an optional time zone.\n   The date is\
    \ two decimal digits representing the century, followed by\n   two decimal digits\
    \ representing the year, a hyphen ('-', U+002D), two\n   decimal digits representing\
    \ the month, a hyphen ('-', U+002D), and\n   two decimal digits representing the\
    \ day.\n   The time of day is two decimal digits representing the hour, followed\n\
    \   by a colon (':', U+003A), two decimal digits representing the\n   minutes,\
    \ a colon (':', U+003A), and two decimal digits representing\n   the seconds.\n\
    \   Note that the hours value \"24\" is disallowed [X.680].\n   A GeneralizedTime\
    \ value with fractional hours or minutes is first\n   converted to the equivalent\
    \ time with whole minutes and seconds and,\n   if necessary, fractional seconds.\n\
    \   The minutes are encoded as \"00\" if the GeneralizedTime value omits\n   minutes.\
    \  The seconds are encoded as \"00\" if the GeneralizedTime\n   value omits seconds.\n\
    \   The fractional seconds part is a full stop ('.', U+002E) followed by\n   zero,\
    \ one, or more decimal digits (U+0030-U+0039).  For a CRXER\n   encoding, trailing\
    \ zero digits (U+0030) in the fractional seconds\n   SHALL be omitted, and the\
    \ full stop SHALL be omitted if there are no\n   following digits.\n   The time\
    \ zone, if present, is either the letter 'Z' (U+005A) to\n   indicate Coordinated\
    \ Universal Time, a plus sign ('+', U+002B)\n   followed by a time zone differential,\
    \ or a minus sign ('-', U+002D)\n   followed by a time zone differential.\n  \
    \ A time zone differential indicates the difference between local time\n   (the\
    \ time specified by the preceding date and time of day) and\n   Coordinated Universal\
    \ Time.  Coordinated Universal Time can be\n   calculated from the local time\
    \ by subtracting the differential.\n   For a CRXER encoding, a GeneralizedTime\
    \ value with a time zone\n   differential SHALL be encoded as the equivalent Coordinated\
    \ Universal\n   Time, i.e., the time zone will be \"Z\".\n   A local time GeneralizedTime\
    \ value is not converted to Coordinated\n   Universal Time for a CRXER encoding.\
    \  Other canonical ASN.1 encoding\n   rules specify that local times must be encoded\
    \ as Coordinated\n   Universal Time but do not specify a method to convert a local\
    \ time to\n   a Coordinated Universal Time.  Consequently, canonicalization of\n\
    \   local time values is unreliable and applications SHOULD NOT use local\n  \
    \ time.\n   A time zone differential is encoded as two decimal digits\n   representing\
    \ hours, a colon (':', U+003A), and two decimal digits\n   representing minutes.\
    \  The minutes are encoded as \"00\" if the\n   GeneralizedTime value omits minutes\
    \ from the time zone differential.\n      Aside: The RXER encoding of GeneralizedTime\
    \ values is intended to\n      conform to the lexical representation of the XML\
    \ Schema [XSD2]\n      dateTime data type.\n   Examples\n      The content of\
    \ each of the following <value> elements is the RXER\n      encoding of a GeneralizedTime\
    \ value:\n         <value>2004-06-15T12:00:00Z</value>\n         <value> 2004-06-15T02:00:00+10:00\
    \ </value>\n         <value>\n             2004-06-15T12:00:00.5\n         </value>\n"
- title: 6.7.6.  INTEGER
  contents:
  - "6.7.6.  INTEGER\n   For a CRXER encoding, the character data translation of a\
    \ value of an\n   IntegerType is a canonical number string representing the integer\n\
    \   value.\n   A canonical number string is either the digit character '0' (U+0030),\n\
    \   or an optional minus sign ('-', U+002D) followed by a non-zero\n   decimal\
    \ digit character (U+0031-U+0039) followed by zero, one, or\n   more of the decimal\
    \ digit characters '0' to '9' (U+0030-U+0039).\n   For a non-canonical RXER encoding,\
    \ the character data translation of\n   a value of the IntegerType without a NamedNumberList\
    \ is a number\n   string representing the integer value.\n   A number string is\
    \ a sequence of one or more of the decimal digit\n   characters '0' to '9' (U+0030-U+0039),\
    \ with an optional leading sign,\n   either '+' (U+002B) or '-' (U+002D).  Leading\
    \ zero digits are\n   permitted in a number string for a non-canonical RXER encoding.\n\
    \      Aside: The RXER encoding of values of the IntegerType without a\n     \
    \ NamedNumberList is intended to conform to the lexical\n      representation\
    \ of the XML Schema [XSD2] integer data type.\n   For a non-canonical RXER encoding,\
    \ if the IntegerType has a\n   NamedNumberList, and the NamedNumberList defines\
    \ an identifier for\n   the actual value, and the IntegerType is not subject to\
    \ a VALUES\n   encoding instruction, then the character data translation of the\n\
    \   value is either a number string or the identifier.\n   Examples\n      Consider\
    \ this type definition:\n         INTEGER { zero(0), one(1) }\n      The content\
    \ of each of the following <value> elements is the RXER\n      encoding of a value\
    \ of the above type:\n         <value>0</value>\n         <value> zero </value>\n\
    \         <value> 2 <!-- This number doesn't have a name. --> </value>\n     \
    \    <value>00167</value>\n   For a non-canonical RXER encoding, if the IntegerType\
    \ is subject to a\n   VALUES encoding instruction (it necessarily must have a\n\
    \   NamedNumberList) and the NamedNumberList defines an identifier for\n   the\
    \ actual value, then the character data translation of the value is\n   either\
    \ a number string or the replacement name [RXEREI] for the\n   identifier.\n \
    \  Examples\n      Consider this type definition:\n         [RXER:VALUES ALL UPPERCASED]\
    \ INTEGER { zero(0), one(1) }\n      The content of both of the following <value>\
    \ elements is the RXER\n      encoding of a value of the above type:\n       \
    \  <value>0</value>\n         <value> ZERO </value>\n"
- title: 6.7.7.  NULL
  contents:
  - "6.7.7.  NULL\n   The character data translation of a value of the NULL type is\
    \ an\n   empty character string.\n   Examples\n      <value/>\n      <value><!--\
    \ Comments don't matter. --></value>\n      <value></value>\n      The final case\
    \ is the CRXER encoding.\n"
- title: 6.7.8.  ObjectDescriptor
  contents:
  - "6.7.8.  ObjectDescriptor\n   A value of the ObjectDescriptor type is translated\
    \ according to the\n   GraphicString type.\n"
- title: 6.7.9.  OBJECT IDENTIFIER and RELATIVE-OID
  contents:
  - "6.7.9.  OBJECT IDENTIFIER and RELATIVE-OID\n   The character data translation\
    \ of a value of the OBJECT IDENTIFIER or\n   RELATIVE-OID type is a full stop\
    \ ('.', U+002E) separated list of the\n   object identifier components of the\
    \ value.\n   Each object identifier component is translated as a non-negative\n\
    \   number string.  A non-negative number string is either the digit\n   character\
    \ '0' (U+0030), or a non-zero decimal digit character\n   (U+0031-U+0039) followed\
    \ by zero, one, or more of the decimal digit\n   characters '0' to '9' (U+0030-U+0039).\n\
    \   Examples\n      The content of each of the following <value> elements is the\
    \ RXER\n      encoding of an OBJECT IDENTIFIER value:\n         <value>2.5.6.0</value>\n\
    \         <value>\n             2.5.4.10\n         </value>\n         <value>\
    \ 2.5.4.3 <!-- commonName --> </value>\n"
- title: 6.7.10.  OCTET STRING
  contents:
  - "6.7.10.  OCTET STRING\n   The character data translation of a value of the OCTET\
    \ STRING type is\n   the hexadecimal digit string representation of the octets.\n\
    \   The octets are encoded in order from the first octet to the last\n   octet.\
    \  Each octet is encoded as a pair of the hexadecimal digit\n   characters '0'-'9',\
    \ 'A'-'F', and 'a'-'f' (i.e., U+0030-U+0039,\n   U+0041-U+0046, and U+0061-U+0066)\
    \ where the first digit in the pair\n   corresponds to the four most significant\
    \ bits of the octet.  An odd\n   number of hexadecimal digits is not permitted.\
    \  The characters 'a'-\n   'f' (i.e., U+0061-U+0066) SHALL NOT be used in the\
    \ CRXER encoding of\n   an OCTET STRING value.\n      Aside: The RXER encoding\
    \ of OCTET STRING values is intended to\n      conform to the lexical representation\
    \ of the XML Schema [XSD2]\n      hexBinary data type.\n   Examples\n      The\
    \ content of each of the following <value> elements is the RXER\n      encoding\
    \ of an OCTET STRING value:\n         <value>27F69A0300</value>\n         <value>\n\
    \             efA03bFF\n         </value>\n"
- title: 6.7.11.  QName
  contents:
  - "6.7.11.  QName\n   The character data translation of a value of the QName type\n\
    \   (Section 4.5) is a qualified name conforming to the QName production\n   of\
    \ Namespaces in XML 1.0 [XMLNS10].\n   The local part (i.e., LocalPart) of the\
    \ qualified name SHALL be the\n   value of the local-name component of the QName\
    \ value.\n   If the namespace-name component of the QName value is absent, then\n\
    \   the namespace prefix (i.e., Prefix) of the qualified name SHALL be\n   absent;\
    \ otherwise, the namespace prefix is determined as specified in\n   Section 6.7.11.1\
    \ using the value of the namespace-name component of\n   the QName value as the\
    \ namespace name.\n"
- title: 6.7.11.1.  Namespace Prefixes for Qualified Names
  contents:
  - "6.7.11.1.  Namespace Prefixes for Qualified Names\n   This section describes\
    \ how the namespace prefix of a qualified name\n   is determined given the namespace\
    \ name to which the namespace prefix\n   must map.\n   For a CRXER encoding, the\
    \ namespace prefix of the qualified name is\n   any unused non-canonical namespace\
    \ prefix unless the\n   [in-scope namespaces] property of the enclosing element\
    \ item contains\n   a namespace item with a [namespace name] that matches the\
    \ namespace\n   name.  In that case, the [prefix] of that namespace item SHALL\
    \ be\n   used as the namespace prefix of the qualified name.\n      Aside: If\
    \ the qualified name appears in the [normalized value] of\n      an attribute\
    \ item, then the enclosing element item is the\n      [owner element] for that\
    \ attribute item.\n   For a non-canonical RXER encoding, the namespace prefix\
    \ of the\n   qualified name is any unused namespace prefix unless the\n   [in-scope\
    \ namespaces] property of the enclosing element item contains\n   a namespace\
    \ item with the same [namespace name] as the element item.\n   In that case, the\
    \ [prefix] of that namespace item MAY be used as the\n   namespace prefix of the\
    \ qualified name.  Note that the [prefix] of a\n   namespace item for the default\
    \ namespace has no value.\n   If the namespace prefix of the qualified name is\
    \ an unused namespace\n   prefix, then a namespace declaration attribute item\
    \ associating the\n   namespace prefix with the namespace name MUST be added to\
    \ the\n   [namespace attributes] of the enclosing element item, and a\n   corresponding\
    \ namespace item MUST be added to the\n   [in-scope namespaces] of the enclosing\
    \ element item.\n"
- title: 6.7.12.  REAL
  contents:
  - "6.7.12.  REAL\n   The character data translation of a value of the REAL type\
    \ is the\n   character string \"0\" if the value is positive zero, the character\n\
    \   string \"-0\" if the value is negative zero, the character string \"INF\"\n\
    \   if the value is positive infinity, the character string \"-INF\" if the\n\
    \   value is negative infinity, the character string \"NaN\" if the value\n  \
    \ is not a number, or a real number otherwise.\n   A real number is the mantissa\
    \ followed by either the character 'E'\n   (U+0045) or 'e' (U+0065) and the exponent.\
    \  The character 'e' SHALL\n   NOT be used for a CRXER encoding.  If the exponent\
    \ is zero, then the\n   'E' or 'e' and exponent MAY be omitted for a non-canonical\
    \ RXER\n   encoding.\n   The mantissa is a decimal number with an optional leading\
    \ sign,\n   either '+' (U+002B) or '-' (U+002D).  A decimal number is a sequence\n\
    \   of one or more of the decimal digit characters '0' to '9'\n   (U+0030-U+0039)\
    \ optionally partitioned by a single full stop\n   character ('.', U+002E) representing\
    \ the decimal point.  Multiple\n   leading zero digits are permitted for a non-canonical\
    \ RXER encoding.\n   The exponent is encoded as a number string (see Section 6.7.6).\n\
    \      Aside: The RXER encoding of REAL values is intended to be\n      compatible\
    \ with the lexical representation of the XML Schema\n      [XSD2] double data\
    \ type, but allows real values outside the set\n      permitted by double.\n \
    \  For a CRXER encoding:\n   (1) The real number MUST be normalized so that the\
    \ mantissa has a\n       single non-zero digit immediately to the left of the\
    \ decimal\n       point.\n   (2) Leading zero digits SHALL NOT be used.\n   (3)\
    \ A leading plus sign SHALL NOT be used in the mantissa or the\n       exponent.\n\
    \   (4) The fractional part of the mantissa (i.e., that part following\n     \
    \  the decimal point) MUST have at least one digit (which may be\n       '0')\
    \ and MUST NOT have any trailing zeroes after the first digit.\n   (5) The exponent\
    \ SHALL be present and SHALL be a canonical number\n       string (see Section\
    \ 6.7.6).\n   Examples\n      The content of each of the following <value> elements\
    \ is the RXER\n      encoding of a REAL value:\n         <value>3.14159<!-- pi\
    \ --></value>\n         <value> 1.0e6 </value>\n         <value> INF </value>\n\
    \         <value>\n             -01e-06\n         </value>\n"
- title: 6.7.13.  UTCTime
  contents:
  - "6.7.13.  UTCTime\n   The character data translation of a value of the UTCTime\
    \ type is a\n   date, the letter 'T' (U+0054), a time of day, and a time zone.\n\
    \   The date is two decimal digits representing the year (no century), a\n   hyphen\
    \ ('-', U+002D), two decimal digits representing the month, a\n   hyphen ('-',\
    \ U+002D), and two decimal digits representing the day.\n   The time of day is\
    \ two decimal digits representing the hour, followed\n   by a colon (':', U+003A),\
    \ two decimal digits representing the\n   minutes, a colon (':', U+003A), and\
    \ two decimal digits representing\n   the seconds.\n   Note that the hours value\
    \ \"24\" is disallowed [X.680].\n   The seconds are encoded as \"00\" if the UTCTime\
    \ value omits seconds.\n   The time zone is either the letter 'Z' (U+005A) to\
    \ indicate\n   Coordinated Universal Time, a plus sign ('+', U+002B) followed\
    \ by a\n   time zone differential, or a minus sign ('-', U+002D) followed by a\n\
    \   time zone differential.\n   A time zone differential indicates the difference\
    \ between local time\n   (the time specified by the preceding date and time of\
    \ day) and\n   Coordinated Universal Time.  Coordinated Universal Time can be\n\
    \   calculated from the local time by subtracting the differential.\n   For a\
    \ CRXER encoding, a UTCTime value with a time zone differential\n   SHALL be encoded\
    \ as the equivalent Coordinated Universal Time, i.e.,\n   the time zone will be\
    \ \"Z\".\n   A time zone differential is encoded as two decimal digits\n   representing\
    \ hours, a colon (':', U+003A), and two decimal digits\n   representing minutes.\n"
- title: 6.7.14.  CHOICE as UNION
  contents:
  - "6.7.14.  CHOICE as UNION\n   The chosen alternative of a value of a UNION type\
    \ corresponds to some\n   NamedType in the UNION type definition (a ChoiceType).\n\
    \   The character data translation of a value of a UNION type is the\n   character\
    \ data translation of the value of the type of the chosen\n   alternative, i.e.,\
    \ without any kind of encapsulation.\n   Leading and trailing white space characters\
    \ are not permitted to be\n   added to the character data translation of a value\
    \ of a UNION type\n   (see Section 6.7); however, this does not preclude such\
    \ white space\n   being added to the character data translation of the value of\
    \ the\n   chosen alternative.\n   The character data translation of a value of\
    \ a UNION type is\n   necessarily destined for the [children] of an enclosing\
    \ element item.\n      Aside: This is because the ATTRIBUTE encoding instruction\
    \ cannot\n      be applied to a NamedType with a type that is a UNION type.\n\
    \   The chosen alternative can be identified by a member attribute item,\n   i.e.,\
    \ an attribute item with the [local name] \"member\" and\n   [namespace name]\
    \ \"urn:ietf:params:xml:ns:asnx\", added to the\n   [attributes] of the enclosing\
    \ element item.  The [prefix] of this\n   attribute item is determined as specified\
    \ in Section 6.2.3.1.  The\n   [normalized value] of the attribute item is a qualified\
    \ name for the\n   expanded name of the NamedType (see [RXEREI]) corresponding\
    \ to the\n   chosen alternative.\n      Aside: It is not possible to associate\
    \ a namespace name with a\n      NamedType in a UNION type using the current specification\
    \ for RXER\n      encoding instructions.  Consequently, the [normalized value]\
    \ of\n      the member attribute item will always contain a qualified name\n \
    \     without a namespace prefix.\n   For a CRXER encoding, the member attribute\
    \ item MUST be used, and the\n   [normalized value] of the attribute item MUST\
    \ be the CRXER\n   translation of the QName value equal to the expanded name.\n\
    \   In the absence of a member attribute item, an RXER decoder MUST\n   determine\
    \ the chosen alternative by considering the alternatives of\n   the choice in\
    \ the order prescribed below and accepting the first\n   alternative for which\
    \ the encoding is valid.\n   If the UNION encoding instruction has a PrecedenceList,\
    \ then the\n   alternatives of the ChoiceType referenced by the PrecedenceList\
    \ are\n   considered in the order identified by that PrecedenceList, then the\n\
    \   remaining alternatives are considered in the order of their\n   definition\
    \ in the ChoiceType.  If the UNION encoding instruction does\n   not have a PrecedenceList,\
    \ then all the alternatives of the\n   ChoiceType are considered in the order\
    \ of their definition in the\n   ChoiceType.\n   A non-canonical RXER encoder\
    \ MUST use the member attribute item if an\n   RXER decoder would determine the\
    \ chosen alternative to be something\n   other than the actual chosen alternative\
    \ of the CHOICE value being\n   translated; otherwise, the member attribute item\
    \ MAY be used.\n   Examples\n      Consider this type definition:\n         [RXER:UNION\
    \ PRECEDENCE serialNumber] CHOICE {\n             name          [0] IA5String,\n\
    \             serialNumber  [1] INTEGER\n         }\n      In the absence of a\
    \ member attribute, an RXER decoder would first\n      consider whether the received\
    \ encoding was a valid serialNumber\n      (an INTEGER) before considering whether\
    \ it was a valid name (an\n      IA5String).\n      The content and attributes\
    \ of each of the following <value>\n      elements are the RXER encoding of a\
    \ value of the above type:\n         <value>Bob</value>\n         <value xmlns:asnx=\"\
    urn:ietf:params:xml:ns:asnx\"\n                asnx:member=\"name\">Alice</value>\n\
    \         <value>\n          <!-- Don't have a name for this one! --> 344\n  \
    \       </value>\n         <value xmlns:asnx=\"urn:ietf:params:xml:ns:asnx\"\n\
    \                asnx:member=\"name\"><!-- A strange name. -->100</value>\n  \
    \    The member attribute is required in the final case to prevent the\n     \
    \ value being interpreted as a serialNumber.\n   If the UNION (i.e., CHOICE) type\
    \ is extensible [X.680], then an\n   application MUST accept and be prepared to\
    \ re-encode (using the same\n   encoding rules) any unknown extension in received\
    \ encoded values of\n   the type.  An unknown extension in a value of a UNION\
    \ type (an\n   unknown alternative) takes the form of an unknown name in the\n\
    \   [normalized value] of the member attribute and/or character data in\n   the\
    \ [children] of the enclosing element item that do not conform to\n   any of the\
    \ known alternatives.\n   To enable re-encoding of an unknown alternative, it\
    \ is necessary to\n   retain the [normalized value] of the member attribute, if\
    \ present,\n   and the [children] property of the enclosing element item.\n  \
    \ The character data for an unknown alternative may contain qualified\n   names\
    \ that depend on the [in-scope namespaces] of the enclosing\n   element item for\
    \ their interpretation.  Therefore, semantically\n   faithful re-encoding of an\
    \ unknown alternative may require\n   reproduction of at least some part of the\
    \ [in-scope namespaces] of\n   the enclosing element item.  The problem is deciding\
    \ which of the\n   namespace items are actually needed.  In the absence of type\n\
    \   information, it is not possible to discern whether anything that\n   syntactically\
    \ resembles a qualified name in the character data of the\n   enclosing element\
    \ item actually is a qualified name.  The simplest\n   approach is to retain all\
    \ the namespace items from the\n   [in-scope namespaces] of the enclosing element\
    \ item and output them\n   as namespace declaration attribute items in the\n \
    \  [namespace attributes] of the enclosing element item when re-encoding\n   the\
    \ unknown alternative.  At best, an application can omit the\n   namespace items\
    \ that do not define the namespace prefix of any\n   potential qualified name.\n\
    \   An application MUST retain the namespace items in the\n   [in-scope namespaces]\
    \ of the enclosing element item that define the\n   namespace prefixes of all\
    \ the potential qualified names in the\n   [children] of the enclosing element\
    \ item.  Other namespace items in\n   the [in-scope namespaces] of the enclosing\
    \ element item MAY be\n   retained.  The effect of these retained namespace items\
    \ on the\n   [namespace attributes] and [in-scope namespaces] of the enclosing\n\
    \   element item when re-encoding is considered in Section 6.2.2.1.\n      Aside:\
    \ The context attribute (Section 6.8.8) is not added to the\n      [attributes]\
    \ of the enclosing element item when re-encoding an\n      unknown alternative\
    \ since the type of a NamedType in a UNION type\n      cannot be the Markup type.\n"
- title: 6.7.15.  SEQUENCE OF as LIST
  contents:
  - "6.7.15.  SEQUENCE OF as LIST\n   The character data translation of a value of\
    \ a LIST type (a\n   SEQUENCE OF NamedType) is the concatenation of the character\
    \ data\n   translations of the component values, i.e., the abstract values of\n\
    \   the type of the NamedType, each separated from the next by at least\n   one\
    \ white space character.  For a CRXER encoding, separating white\n   space MUST\
    \ be exactly one space character (U+0020).\n   Example\n      Consider this type\
    \ definition:\n         [LIST] SEQUENCE OF timeStamp GeneralizedTime\n      The\
    \ content of the following <value> element is the RXER encoding\n      of a value\
    \ of the above type:\n         <value>\n             2004-06-15T12:14:56Z\n  \
    \           2004-06-15T12:18:13Z\n             2004-06-15T01:00:25Z\n        \
    \ </value>\n"
- title: 6.8.  Combining Types
  contents:
  - "6.8.  Combining Types\n   The encoding of a value of an ASN.1 combining type\
    \ (except a UNION or\n   LIST type) typically has element content.\n   The Infoset\
    \ translation of a value of a specific ASN.1 combining type\n   (excluding a UNION\
    \ or LIST type) contains zero or more attribute\n   items to be added to the [attributes]\
    \ of the enclosing element item\n   and zero or more element items to be added\
    \ to the [children] of the\n   enclosing element item.  These translations are\
    \ described in Sections\n   6.8.1 to 6.8.7.\n   For a non-canonical RXER encoding,\
    \ white space character items MAY be\n   added to the [children] of the enclosing\
    \ element item (before or\n   after any other items).\n   For a CRXER encoding,\
    \ a character item with the [character code]\n   U+000A (a line feed) MUST be\
    \ inserted immediately before each element\n   item in the [children] of the enclosing\
    \ element item.  No other white\n   space character items are permitted to be\
    \ added to the [children] of\n   the enclosing element item.\n      Aside: Without\
    \ the single line feed character before each child\n      element, a typical CRXER\
    \ encoding would be a single, very long\n      line.\n"
- title: 6.8.1.  CHARACTER STRING
  contents:
  - "6.8.1.  CHARACTER STRING\n   A value of the unrestricted CHARACTER STRING type\
    \ is translated\n   according to the corresponding SEQUENCE type defined in Clause\
    \ 40.5\n   of X.680 [X.680].\n"
- title: 6.8.2.  CHOICE
  contents:
  - "6.8.2.  CHOICE\n   The chosen alternative of a value of a CHOICE type corresponds\
    \ to,\n   and is a value of (see Section 6), some NamedType in the CHOICE type\n\
    \   definition.\n   The translation of a value of a CHOICE type other than the\
    \ Markup\n   type or a UNION type (see Section 6.7.14) is the translation of the\n\
    \   value of the NamedType corresponding to the actual chosen\n   alternative.\n\
    \   Examples\n      Consider this type definition:\n         CHOICE {\n      \
    \       name          [0] IA5String,\n             serialNumber  [1] INTEGER\n\
    \         }\n      The content of each of the following <value> elements is the\
    \ RXER\n      encoding of a value of the above type:\n         <value><name>Bob</name></value>\n\
    \         <value>\n          <name>Alice</name>\n         </value>\n         <value>\n\
    \          <!-- Don't have a name for this one! -->\n          <serialNumber>\n\
    \           344\n          </serialNumber>\n         </value>\n         <value>\n\
    \          <!-- A strange name. -->\n          <name>100</name>\n         </value>\n\
    \   If the CHOICE type is extensible [X.680], then an application MUST\n   accept,\
    \ and be prepared to re-encode (in RXER), any attribute item or\n   child element\
    \ item with a name that is not recognized (see\n   Section 6.8.8).\n"
- title: 6.8.3.  EMBEDDED PDV
  contents:
  - "6.8.3.  EMBEDDED PDV\n   A value of the EMBEDDED PDV type is translated according\
    \ to the\n   corresponding SEQUENCE type defined in Clause 33.5 of X.680 [X.680].\n"
- title: 6.8.4.  EXTERNAL
  contents:
  - "6.8.4.  EXTERNAL\n   A value of the EXTERNAL type is translated according to\
    \ the\n   corresponding SEQUENCE type defined in Clause 8.18.1 of X.690\n   [X.690].\n"
- title: 6.8.5.  INSTANCE OF
  contents:
  - "6.8.5.  INSTANCE OF\n   A value of the INSTANCE OF type is translated according\
    \ to the\n   corresponding SEQUENCE type defined in Annex C of X.681 [X.681].\n"
- title: 6.8.6.  SEQUENCE and SET
  contents:
  - "6.8.6.  SEQUENCE and SET\n   Each component value of a value of a SEQUENCE or\
    \ SET type corresponds\n   to, and is a value of (see Section 6), some NamedType\
    \ in the SEQUENCE\n   or SET type definition.\n   A value of a SEQUENCE or SET\
    \ type, other than the QName type\n   (Section 4.5), is translated by translating\
    \ in turn each component\n   value actually present in the SEQUENCE or SET value\
    \ and adding the\n   resulting attribute items and/or element items to the [attributes]\n\
    \   and/or [children] of the enclosing element item.  Attribute items may\n  \
    \ be added to the [attributes] of the enclosing element item in any\n   order.\
    \  Element items resulting from the translation of component\n   values MUST be\
    \ appended to the [children] of the enclosing element\n   item in the order of\
    \ the component values' corresponding NamedType\n   definitions in the SEQUENCE\
    \ or SET type definition.\n      Aside: In the case of the SET type, this is a\
    \ deliberate departure\n      from BER [X.690], where the components of a SET\
    \ can be encoded in\n      any order.\n   If a DEFAULT value is defined for a\
    \ NamedType and the value of the\n   NamedType is the same as the DEFAULT value,\
    \ then the translation of\n   the value of the NamedType SHALL be omitted for\
    \ a CRXER encoding and\n   MAY be omitted for a non-canonical RXER encoding.\n\
    \   Examples\n      Consider this type definition:\n         SEQUENCE {\n    \
    \         name        [0] IA5String OPTIONAL,\n             partNumber  [1] INTEGER,\n\
    \             quantity    [2] INTEGER DEFAULT 0\n         }\n      The content\
    \ of each of the following <value> elements is the RXER\n      encoding of a value\
    \ of the above type:\n         <value>\n          <partNumber>23</partNumber>\n\
    \          <!-- The quantity defaults to zero. -->\n         </value>\n      \
    \   <value>\n          <name>chisel</name>\n          <partNumber> 37 </partNumber>\n\
    \          <quantity> 0 </quantity>\n         </value>\n         <value>\n   \
    \       <!-- The name component is optional. -->\n          <partNumber>1543</partNumber>\n\
    \          <quantity>29</quantity>\n         </value>\n   If the SEQUENCE or SET\
    \ type is extensible [X.680], then an\n   application MUST accept, and be prepared\
    \ to re-encode (in RXER), any\n   attribute item or child element item with a\
    \ name that is not\n   recognized (see Section 6.8.8).\n"
- title: 6.8.7.  SEQUENCE OF and SET OF
  contents:
  - "6.8.7.  SEQUENCE OF and SET OF\n   Each component value of a value of a type\
    \ that is a SET OF NamedType\n   or a SEQUENCE OF NamedType corresponds to, and\
    \ is a value of (see\n   Section 6), the NamedType in the type definition.\n \
    \  A value of a type that is a SET OF NamedType, or a\n   SEQUENCE OF NamedType\
    \ other than a LIST type (see Section 6.7.15), is\n   translated by adding the\
    \ translation of each value of the NamedType\n   to the [children] of the enclosing\
    \ element item.\n      Aside: An ATTRIBUTE encoding instruction cannot appear\
    \ in the\n      component type for a SEQUENCE OF or SET OF type, so there are\
    \ no\n      attribute items to add to the [attributes] of the enclosing\n    \
    \  element item.\n   If the type is a SEQUENCE OF NamedType, then the values of\
    \ the\n   NamedType are translated in the order in which they appear in the\n\
    \   value of the type.\n   For a non-canonical RXER encoding, if the type is a\
    \ SET OF NamedType,\n   then the values of the NamedType may be translated in\
    \ any order.\n   For a CRXER encoding, if the type is a SET OF NamedType, then\
    \ the\n   values of the NamedType MUST be translated in ascending order where\n\
    \   the order is determined by comparing the octets of their CRXER\n   encodings\
    \ (which will be UTF-8 encoded character strings; see\n   Section 6.12.2).  A\
    \ shorter encoding is ordered before a longer\n   encoding that is identical up\
    \ to the length of the shorter encoding.\n   Examples\n      Consider this type\
    \ definition:\n         SEQUENCE OF timeStamp GeneralizedTime\n      The content\
    \ of the following <value> element is the RXER encoding\n      of a value of the\
    \ above type:\n         <value>\n             <timeStamp>2004-06-15T12:14:56Z</timeStamp>\n\
    \             <timeStamp>2004-06-15T12:18:13Z</timeStamp>\n             <timeStamp>\n\
    \                 2004-06-15T01:00:25Z\n             </timeStamp>\n         </value>\n\
    \      Consider this type definition (also see Section 6.6):\n         SEQUENCE\
    \ OF INTEGER\n      The content of the following <value> element is the RXER encoding\n\
    \      of a value of the above type:\n         <value>\n          <item>12</item>\n\
    \          <item>\n           9\n          </item>\n          <item> 7 <!-- A\
    \ prime number. --></item>\n         </value>\n"
- title: 6.8.8.  Extensible Combining Types
  contents:
  - "6.8.8.  Extensible Combining Types\n   An application must accept and be prepared\
    \ to re-encode (using the\n   same encoding rules) any unknown extension appearing\
    \ in the encoding\n   of a value of an extensible CHOICE, SEQUENCE, or SET type.\
    \  An\n   unknown extension in a value of an extensible combining type (except\n\
    \   UNION types) takes the form of unknown element and/or attribute\n   items.\
    \  Section 6.8.8.1 describes the processing of unknown element\n   items and Section\
    \ 6.8.8.2 describes the processing of unknown\n   attribute items.\n   An application\
    \ cannot produce a canonical encoding if an abstract\n   value contains unknown\
    \ extensions.  However, the method for\n   re-encoding unknown extensions does\
    \ not prevent a receiving\n   application with knowledge of the extension from\
    \ producing the\n   correct canonical encoding.\n"
- title: 6.8.8.1.  Unknown Elements in Extensions
  contents:
  - "6.8.8.1.  Unknown Elements in Extensions\n   To enable re-encoding of an unknown\
    \ element item it is necessary to\n   retain the [prefix], [local name], [attributes],\n\
    \   [namespace attributes], and [children] properties of the element\n   item.\n\
    \   Definition (inherited namespace item):  An inherited namespace item\n   is\
    \ a namespace item in the [in-scope namespaces] of an element item\n   for which\
    \ there is no corresponding namespace declaration attribute\n   item in the [namespace\
    \ attributes] of the element item.\n   The content and attributes of an unknown\
    \ element item may contain\n   qualified names whose interpretation depends on\
    \ inherited namespace\n   items.  Semantically faithful re-encoding of the unknown\
    \ item may\n   require reproduction of at least some of the inherited namespace\n\
    \   items.  The problem is deciding which of the inherited namespace\n   items\
    \ are actually needed.  Qualified names as the names of elements\n   and attributes\
    \ are easily recognized, but in the absence of type\n   information it is not\
    \ possible to discern whether anything that\n   syntactically resembles a qualified\
    \ name in the value of an attribute\n   or the character data of an element actually\
    \ is a qualified name.\n   The simplest approach is to retain all the inherited\
    \ namespace items\n   and output corresponding namespace declaration attribute\
    \ items in the\n   [namespace attributes] of the unknown element item when re-encoding\n\
    \   the element item.  At best, an application can omit the inherited\n   namespace\
    \ items that do not define the namespace prefix of any\n   definite or potential\
    \ qualified name, though this requires examining\n   the content and attributes\
    \ of the unknown extension.\n   Regardless of how clever an implementation tries\
    \ to be, adding any\n   namespace declaration attribute items to an unknown element\
    \ item is\n   harmful to canonicalization if the ASN.1 type for the element item\n\
    \   turns out to be the Markup type.  To counter this problem, a special\n   attribute\
    \ is used to identify the namespace declaration attribute\n   items added to an\
    \ unknown element item so that they can be removed\n   later, if it proves necessary.\n\
    \   If the outermost element item in an unknown extension does not have\n   an\
    \ attribute item with the [local name] \"context\" and\n   [namespace name] \"\
    urn:ietf:params:xml:ns:asnx\" in its [attributes],\n   then namespace declaration\
    \ attribute items corresponding to the\n   inherited namespace items that define\
    \ the namespace prefixes of all\n   the definite and potential qualified names\
    \ in the content and\n   attributes of the element item MUST be added to the retained\n\
    \   [namespace attributes].  Other inherited namespace items MAY be added\n  \
    \ to the retained [namespace attributes].\n   If there are one or more of these\
    \ added namespace declaration\n   attribute items, then an attribute item with\
    \ the [local name]\n   \"context\" and [namespace name] \"urn:ietf:params:xml:ns:asnx\"\
    \ MUST be\n   added to the retained [attributes].\n   The [prefix] of the context\
    \ attribute item is any namespace prefix\n   that does not match the [local name]\
    \ of any namespace declaration\n   attribute item in the [namespace attributes]\
    \ unless the\n   [namespace attributes] property contains a namespace declaration\n\
    \   attribute item with a non-empty [prefix] and a [normalized value] of\n   \"\
    urn:ietf:params:xml:ns:asnx\".  In that case, the [local name] of\n   that namespace\
    \ declaration attribute item MAY be used as the [prefix]\n   of the context attribute\
    \ item.\n   If the [prefix] of the context attribute item does not match the\n\
    \   [local name] of any namespace declaration attribute item, then an\n   attribute\
    \ item with the [prefix] \"xmlns\", [namespace name]\n   \"urn:ietf:params:xml:ns:asnx\"\
    , and [local name] equal to the [prefix]\n   of the context attribute item MUST\
    \ be added to the retained\n   [namespace attributes] of the element item.\n \
    \  The [normalized value] of the context attribute is the white-space-\n   separated\
    \ unordered list of the [local names] of the added namespace\n   declaration attribute\
    \ items (i.e., a list of the namespace prefixes),\n   including any namespace\
    \ declaration attribute item added to define\n   the [prefix] of the context attribute.\
    \  Note that the [local name]\n   for a namespace declaration attribute item declaring\
    \ the default\n   namespace is \"xmlns\".\n      Aside: A receiver that knows\
    \ about the extension will use the\n      context attribute to strip out the added\
    \ namespace declaration\n      attributes if the type of the associated NamedType\
    \ is the Markup\n      type (Section 6.10), and will discard the context attribute\n\
    \      otherwise.  A receiver that does not know about the extension will\n  \
    \    re-encode the extension as is.\n   Adding the required namespace declaration\
    \ attribute items to an\n   element item effectively makes the element item self-contained.\
    \  A\n   received encoding has an encoding error if it contains an element\n \
    \  item that is not self-contained but has a context attribute item in\n   its\
    \ [attributes].\n   An RXER encoder MUST NOT add the context attribute item to\
    \ an element\n   item corresponding to a NamedType that is known to it.\n   An\
    \ RXER decoder MUST accept the context attribute item on an element\n   item corresponding\
    \ to a NamedType that does not appear to be an\n   extension.\n      Aside: It\
    \ is not uncommon for extension markers to be neglected in\n      specifications\
    \ traditionally using only BER, since extension\n      markers do not alter BER\
    \ encodings.  Consequently, it is not\n      immediately obvious in later versions\
    \ of the specification which\n      instances of NamedType belong to extensions\
    \ of the original base\n      specification.\n   Example\n      Suppose there\
    \ are three applications, A, B, and C.  Suppose that\n      Application A uses\
    \ the first edition of an ASN.1 specification\n      containing the following\
    \ type definition:\n         MyType ::= SEQUENCE {\n                 field1  INTEGER,\
    \  -- present in first edition\n                 ...\n         }\n      Suppose\
    \ that Application B uses the second edition of the ASN.1\n      specification:\n\
    \         MyType ::= SEQUENCE {\n                 field1  INTEGER,  -- present\
    \ in first edition\n                 ...,\n                 field2  QName    \
    \ -- added in second edition\n         }\n      Suppose that Application C uses\
    \ the third edition of the ASN.1\n      specification:\n         MyType ::= SEQUENCE\
    \ {\n                 field1  INTEGER,  -- present in first edition\n        \
    \         ...,\n                 field2  QName,    -- added in second edition\n\
    \                 field3  Markup    -- added in third edition\n         }\n  \
    \    Application C produces the following RXER encoding and sends it to\n    \
    \  Application B:\n         <value xmlns:p2=\"http://example.com/ns2\">\n    \
    \      <field1> 100 </field1>\n          <field2> p2:foobar </field2>\n      \
    \    <field3 xmlns:p1=\"http://example.com/ns1\"> p1:foobar </field3>\n      \
    \   </value>\n      Application B doesn't know about <field3>, so it adds the\n\
    \      asnx:context attribute to <field3> when it re-encodes the abstract\n  \
    \    value to send to Application A:\n         <value xmlns:p1=\"http://example.com/ns2\"\
    >\n          <!-- Application B knows the white space in field1 and\n        \
    \       field2 is optional and discards it. -->\n          <field1>100</field1>\n\
    \          <field2>p1:foobar</field2>\n          <!-- Application B doesn't know\
    \ about field3\n               so it leaves the character data alone. -->\n  \
    \        <field3 asnx:context=\"asnx p2\"\n                  xmlns:asnx=\"urn:ietf:params:xml:ns:asnx\"\
    \n                  xmlns:p1=\"http://example.com/ns1\"\n                  xmlns:p2=\"\
    http://example.com/ns2\"> p1:foobar </field3>\n         </value>\n      Application\
    \ A doesn't know about <field2> and <field3>, so it adds\n      the asnx:context\
    \ attribute to <field2> and leaves <field3> alone\n      when it re-encodes the\
    \ abstract value:\n         <value>\n          <!-- Application A knows about\
    \ field1 and chooses\n               to add some white space. -->\n          <field1>\
    \ 100 </field1>\n          <!-- Application A doesn't know about field2 or field3\n\
    \               so it leaves the character data alone. -->\n          <field2\
    \ asnx:context=\"asnx p1\"\n                  xmlns:asnx=\"urn:ietf:params:xml:ns:asnx\"\
    \n                  xmlns:p1=\"http://example.com/ns2\">p1:foobar</field2>\n \
    \         <field3 asnx:context=\"asnx p2\"\n                  xmlns:asnx=\"urn:ietf:params:xml:ns:asnx\"\
    \n                  xmlns:p1=\"http://example.com/ns1\"\n                  xmlns:p2=\"\
    http://example.com/ns2\"> p1:foobar </field3>\n         </value>\n      If Application\
    \ C receives this final encoding, it has sufficient\n      information to discard\
    \ the asnx:context, xmlns:asnx, and xmlns:p2\n      attributes from the received\
    \ Markup value of <field3> to recover\n      the original value.  Application\
    \ C knows about <field2>, so it\n      uses the namespace declaration for p1 when\
    \ decoding the QName\n      value and ignores the other declarations.\n"
- title: 6.8.8.2.  Unknown Attributes in Extensions
  contents:
  - "6.8.8.2.  Unknown Attributes in Extensions\n   To enable re-encoding of an unknown\
    \ attribute item it is necessary to\n   retain at least the [local name], [namespace\
    \ name], and\n   [normalized value] properties of the attribute item.\n   The\
    \ [normalized value] of an unknown attribute item may contain\n   qualified names\
    \ whose interpretation depends on the\n   [in-scope namespaces] of the [owner\
    \ element].  Semantically faithful\n   re-encoding of the unknown attribute item\
    \ may require reproduction of\n   at least some part of the [in-scope namespaces].\
    \  In the absence of\n   type information, it is not possible to discern whether\
    \ anything that\n   syntactically resembles a qualified name in the [normalized\
    \ value] of\n   an unknown attribute item actually is a qualified name.\n   The\
    \ simplest approach is to retain all the namespace items of the\n   [in-scope\
    \ namespaces] and output corresponding namespace declaration\n   attribute items\
    \ in the [namespace attributes] of the [owner element]\n   when re-encoding the\
    \ extension.  At best, an application can omit the\n   namespace items that do\
    \ not define the namespace prefix of any\n   potential qualified name in the [normalized\
    \ value].\n   An application MUST retain the namespace items in the\n   [in-scope\
    \ namespaces] of the [owner element] that define the\n   namespace prefixes of\
    \ all the potential qualified names in the\n   [normalized value] of the unknown\
    \ attribute item.  Other namespace\n   items in the [in-scope namespaces] of the\
    \ [owner element] MAY be\n   retained.\n      Aside: If the enclosing element\
    \ item has more than one unknown\n      attribute item, then it is sufficient\
    \ to save the union of the\n      retained namespace items with the element item,\
    \ rather than saving\n      the retained namespace items with each unknown attribute\
    \ item.\n   When the unknown attribute item is re-encoded, the retained namespace\n\
    \   items affect the [namespace attributes] and [in-scope namespaces] of\n   the\
    \ enclosing element item as specified in Section 6.2.2.1, and the\n   [prefix]\
    \ of the attribute item is determined as specified in\n   Section 6.2.3.1.\n \
    \     Aside: The context attribute is not added to the [attributes] of\n     \
    \ the [owner element] when re-encoding an unknown attribute item\n      because\
    \ the type of a NamedType subject to an ATTRIBUTE or\n      ATTRIBUTE-REF encoding\
    \ instruction cannot be the Markup type.\n"
- title: 6.9.  Open Type
  contents:
  - "6.9.  Open Type\n   A value of an open type denoted by an ObjectClassFieldType\
    \ [X.681] is\n   translated according to the specific Type of the value.\n   If\
    \ the specific Type of the value is directly or indirectly the\n   Markup type,\
    \ then the enclosing element item MUST be self-contained.\n   For a non-canonical\
    \ RXER encoding, if the translation of the value\n   does not generate an attribute\
    \ item with the [local name] \"type\" and\n   the [namespace name] \"http://www.w3.org/2001/XMLSchema-instance\"\
    \n   (i.e., xsi:type) and the specific Type of the value is a\n   namespace-qualified\
    \ reference (Section 5), then an attribute item\n   with the [local name] \"type\"\
    \ and the [namespace name]\n   \"http://www.w3.org/2001/XMLSchema-instance\" (i.e.,\
    \ xsi:type) MAY be\n   added to the [attributes] of the enclosing element item.\
    \  The\n   [normalized value] of this attribute item is a qualified name for the\n\
    \   expanded name of the referenced type, with the namespace prefix\n   determined\
    \ as specified in Section 6.7.11.1.\n      Aside: The xsi:type attribute is added\
    \ by RXER encoders for the\n      benefit of XML Schema validators.  This attribute\
    \ tells an\n      XML Schema validator which type definition in a compatible\n\
    \      XML Schema translation of the ASN.1 specification it should use\n     \
    \ for validating the content and attributes of the enclosing\n      element. \
    \ For an RXER decoder, the actual type in an open type\n      value is generally\
    \ determined by an associated component relation\n      constraint [X.682], so\
    \ the xsi:type attribute can be ignored.\n   Example\n      The content and attributes\
    \ of the following <value> element are\n      the RXER encoding of an open type\
    \ value containing a BOOLEAN\n      value:\n         <value xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\
    \n                xmlns:asnx=\"urn:ietf:params:xml:ns:asnx\"\n               \
    \ xsi:type=\"asnx:BOOLEAN\"> true </value>\n   If the ObjectClassFieldType denoting\
    \ an open type is not constrained\n   by a TableConstraint, or is constrained\
    \ by a TableConstraint where\n   the constraining object set is extensible, then\
    \ an application MUST\n   accept and be prepared to re-encode (using the same\
    \ encoding rules)\n   any value of the open type where the specific Type of the\
    \ value is\n   unknown.  In such cases, the enclosing element item is treated\
    \ like\n   an unknown element item in the value of an extensible combining ASN.1\n\
    \   type (see Section 6.8.8.1).\n"
- title: 6.10.  Markup
  contents:
  - "6.10.  Markup\n   Conceptually, a value of the Markup type holds the [prefix],\n\
    \   [attributes], [namespace attributes], and [children] of an element\n   item.\
    \  The Infoset translation of a value of the Markup type\n   initially simply\
    \ sets the [prefix], [attributes],\n   [namespace attributes], and [children]\
    \ of the enclosing element item\n   to the corresponding properties represented\
    \ by the Markup value.\n   Recall that the enclosing element item for the translation\
    \ of a\n   Markup value is required to be self-contained (Section 4.1.1).\n  \
    \ If the enclosing element item is not the [document element] of the\n   document\
    \ item, and the [in-scope namespaces] property of the\n   enclosing element item's\
    \ [parent] contains a namespace item for the\n   default namespace, and the [namespace\
    \ attributes] property\n   represented by the Markup value does not contain a\
    \ namespace item\n   declaring or undeclaring the default namespace, then a namespace\n\
    \   declaration attribute item that undeclares the default namespace\n   SHALL\
    \ be added to the enclosing element item's\n   [namespace attributes].\n   It\
    \ is not necessary to populate the [in-scope namespaces] of the\n   enclosing\
    \ element item for encoding purposes (though it may be\n   warranted for other\
    \ purposes).\n   An element item nested in the [children] is potentially the Infoset\n\
    \   translation of a value of a top-level NamedType (as allowed by\n   Section\
    \ 6.4), and the entire Markup value can represent the content\n   and attributes\
    \ of an element item that is the translation of a value\n   of a top-level NamedType.\n\
    \      Aside: The latter case arises when an ELEMENT-REF encoding\n      instruction\
    \ references a top-level NamedType.\n   The content and attributes of an element\
    \ item nested in the\n   [children] of a Markup value are potentially the Infoset\
    \ translation\n   of an abstract value of an ASN.1 type (as allowed by Section\
    \ 6.4),\n   and the entire Markup value can represent the translation of a single\n\
    \   abstract value.\n      Aside: The latter case arises when a TYPE-REF encoding\
    \ instruction\n      references an ASN.1 type.\n   For a non-canonical RXER encoding,\
    \ any element item, at any level of\n   nesting (including the enclosing element\
    \ item itself), that\n   corresponds to the value of a top-level NamedType MAY\
    \ be replaced\n   with any valid translation of that value.\n   For a non-canonical\
    \ RXER encoding, any element item, at any level of\n   nesting (including the\
    \ enclosing element item itself), with content\n   and attributes that correspond\
    \ to an abstract value of an ASN.1 type\n   MAY have that content and those attributes\
    \ replaced with any valid\n   translation of that abstract value.  If the content\
    \ and attributes\n   are replaced, then the [prefix], [in-scope namespaces], and\n\
    \   [namespace attributes] of the element item are constructed as\n   specified\
    \ in Sections 6.2.2.1 and 6.2.2.2.  The enclosing element\n   item for the Markup\
    \ value is still required to be self-contained.\n      Aside: Insofar as a Markup\
    \ value represents ASN.1 abstract values,\n      it is sufficient for the RXER\
    \ encoding of the Markup value to\n      preserve the abstract values rather than\
    \ preserve the exact\n      Infoset representation.\n   For a CRXER encoding,\
    \ any element item, at any level of nesting\n   (including the enclosing element\
    \ item itself), that corresponds to a\n   value of a top-level NamedType MUST\
    \ be replaced with the CRXER\n   translation of that value.\n   For a CRXER encoding,\
    \ any element item, at any level of nesting\n   (including the enclosing element\
    \ item itself), with content and\n   attributes that correspond to an abstract\
    \ value of an ASN.1 type MUST\n   have that content and those attributes replaced\
    \ with the CRXER\n   translation of that abstract value.  The [prefix],\n   [in-scope\
    \ namespaces], and [namespace attributes] of the element item\n   are constructed\
    \ as specified in Sections 6.2.2.1 and 6.2.2.2.\n   If the [attributes] property\
    \ of the enclosing element item from a\n   received RXER encoding contains an\
    \ attribute item with the\n   [local name] \"context\" and [namespace name]\n\
    \   \"urn:ietf:params:xml:ns:asnx\" (i.e., asnx:context), then this\n   attribute\
    \ item MUST be omitted from the [attributes] represented by\n   the Markup value,\
    \ and each namespace declaration attribute item with\n   a [local name] matching\
    \ an NCName in the [normalized value] of the\n   attribute item MUST be omitted\
    \ from the [namespace attributes]\n   represented by the Markup value.\n"
- title: 6.11.  Namespace Prefixes for CRXER
  contents:
  - "6.11.  Namespace Prefixes for CRXER\n   The final step in translating the value\
    \ of a top-level NamedType for\n   a CRXER encoding, or an abstract value for\
    \ a Standalone CRXER\n   Encoding, is the replacement of the arbitrarily chosen\
    \ namespace\n   prefixes with algorithmically determined canonical namespace\n\
    \   prefixes.  This procedure for prefix replacement applies to each\n   element\
    \ item where the [namespace attributes] have been constructed\n   according to\
    \ Section 6.2.2.1.  This includes any element item\n   corresponding to a value\
    \ of a top-level NamedType, or with content\n   and attributes that correspond\
    \ to an abstract value of an ASN.1 type,\n   that is nested in a value of the\
    \ Markup type.\n   For each element item where prefix replacement applies, the\
    \ following\n   sequence of steps is repeated until there are no more eligible\n\
    \   attribute items to select in step (1):\n   (1) Select the attribute item with\
    \ the least [normalized value] from\n       amongst the attribute items of the\
    \ [namespace attributes] that\n       have a [local name] that is not a canonical\
    \ namespace prefix\n       (i.e., select from the namespace declaration attribute\
    \ items that\n       have not already been processed).  A [normalized value] is\
    \ less\n       than another [normalized value] if the former appears before the\n\
    \       latter in an ordering of the values determined by comparing the\n    \
    \   ISO 10646 code points [UCS] of their characters, from first to\n       last.\
    \  A shorter string of characters is ordered before a longer\n       string of\
    \ characters that is identical up to the length of the\n       shorter string.\n\
    \          Aside: Note that when a namespace declaration (other than for\n   \
    \       the default namespace) is represented as an attribute item in\n      \
    \    the [namespace attributes], the attribute's [prefix] is\n          \"xmlns\"\
    , its [local name] is the namespace prefix, and its\n          [normalized value]\
    \ is the namespace name.\n   (2) A canonical namespace prefix is unused if it\
    \ is not currently the\n       [prefix] of any namespace item in the [in-scope\
    \ namespaces] of\n       the element item.  Replace the [local name] of the selected\n\
    \       attribute item with the unused canonical namespace prefix that\n     \
    \  has the non-negative number string with the least integer value\n       (e.g.,\
    \ n2 is less than n10).\n   (3) The selected attribute item has a corresponding\
    \ namespace item in\n       the [in-scope namespaces] of the element.  Replace\
    \ the [prefix]\n       of this corresponding namespace item with the canonical\
    \ namespace\n       prefix determined in step (2).\n   (4) The element item and\
    \ its [attributes] property, and descendent\n       element items and their [attributes]\
    \ properties, may depend on\n       the selected attribute item to determine the\
    \ binding between\n       their [prefix] and [namespace name].  Replace the [prefix]\
    \ of any\n       such dependent element items and attribute items with the\n \
    \      canonical namespace prefix determined in step (2).\n       Note that a\
    \ namespace prefix can be redeclared (reused).\n       Replacement of the prefix\
    \ does not apply to an element item\n       wherein the prefix is redeclared,\
    \ or to the descendants of such\n       an element item.\n   (5) The character\
    \ data translations for values of the QName ASN.1\n       type may depend on the\
    \ selected attribute item to determine the\n       binding between their namespace\
    \ prefix and namespace name.\n       Replace the namespace prefix of any such\
    \ dependent character data\n       translation with the canonical namespace prefix\
    \ determined in\n       step (2).\n       Note that a character data translation\
    \ can appear in the\n       [normalized value] of an attribute item, or as a sequence\
    \ of\n       character items in the [children] of an element item.\n"
- title: 6.12.  Serialization
  contents:
  - "6.12.  Serialization\n   The final RXER encoding is produced by serializing the\
    \ Infoset\n   translation as an XML document.  An implementation MUST serialize\
    \ the\n   Infoset translation as an XML document in such a way that the Infoset\n\
    \   of the resulting XML document matches the Infoset translation, after\n   ignoring\
    \ the following properties:\n   (1) all properties of the document item except\
    \ the\n       [document element],\n   (2) the [base URI] of any item,\n   (3)\
    \ the [element content whitespace] of character items,\n   (4) the [notation]\
    \ of processing instruction items,\n   (5) the [in-scope namespaces] of element\
    \ items.\n      Aside: The [in-scope namespaces] of a parent element item are\
    \ only\n      selectively inherited by its child element items in the Infoset\n\
    \      translations of ASN.1 values.  This means that the Infoset\n      reconstructed\
    \ by parsing the XML document serialization of the\n      original Infoset will\
    \ generally have more namespace items in its\n      [in-scope namespaces], but\
    \ these extra namespace items will not be\n      significant.\n      Aside: A\
    \ consequence of case (1) is that comments and PIs before\n      and after the\
    \ document element are permitted.\n   In general, there is more than one possible\
    \ serialization for any\n   given Infoset translation.  Section 6.12.1 highlights\
    \ some important\n   considerations in producing a correct serialization and discusses\n\
    \   some of the serialization options.\n   Section 6.12.2 applies to CRXER encodings\
    \ and limits the\n   serialization options so that each distinct Infoset has only\
    \ one\n   possible serialization.\n"
- title: 6.12.1.  Non-Canonical Serialization
  contents:
  - "6.12.1.  Non-Canonical Serialization\n   This section discusses aspects of Infoset\
    \ serialization for\n   non-canonical RXER encodings, but is not an exhaustive\
    \ list of the\n   options for non-canonical serialization.\n   If one or more\
    \ character items have a [character code] in the range\n   U+0001 to U+0008, U+000B\
    \ to U+000C, or U+000E to U+001F, or one or\n   more characters in any attribute's\
    \ [normalized value] are in the\n   range U+0001 to U+0008, U+000B to U+000C,\
    \ or U+000E to U+001F, then\n   the Infoset translation MUST be serialized as\
    \ an XML version 1.1\n   document; otherwise, the Infoset translation is serialized\
    \ as either\n   an XML version 1.0 or version 1.1 document.\n   A non-canonical\
    \ RXER encoding may use any of the allowed character\n   encoding schemes for\
    \ XML.  RXER encoders and decoders MUST support\n   the UTF-8 character encoding.\n\
    \   An element item may be serialized as an empty-element tag if it has\n   no\
    \ items in its [children].\n   Attributes of an element can appear in any order\
    \ since the\n   [attributes] and [namespace attributes] of an element item are\n\
    \   unordered.\n   Ampersand ('&', U+0026) and open angle bracket ('<', U+003C)\n\
    \   characters in the [normalized value] of an attribute item must be\n   escaped\
    \ appropriately [XML10][XML11] (with a character reference or a\n   predefined\
    \ entity reference).  Double quote (U+0022) and single quote\n   (U+0027) characters\
    \ in an attribute item's [normalized value] may\n   also need to be escaped. \
    \ Character items with the [character code]\n   U+0026 (ampersand, '&') or U+003C\
    \ (open angle bracket, '<') must be\n   escaped appropriately (with a character\
    \ reference, a predefined\n   entity reference or a CDATA section).\n   Line break\
    \ normalization by XML processors allows some freedom in how\n   a character item\
    \ for a line feed character (U+000A) is serialized:\n   (1) If XML version 1.0\
    \ is selected, then a character item with the\n       [character code] U+000A\
    \ (line feed) is serialized as either a\n       line feed character (U+000A),\
    \ a carriage return character\n       (U+000D) followed by a line feed character\
    \ (U+000A), or just a\n       carriage return character (U+000D) provided the\
    \ next item is not\n       a character item that is serialized as a line feed\
    \ character\n       (U+000A).\n   (2) If XML version 1.1 is selected, then a character\
    \ item with the\n       [character code] U+000A (line feed) is serialized as either\
    \ a\n       line feed character (U+000A), a next line character (U+0085), a\n\
    \       line separator character (U+2028), a carriage return character\n     \
    \  (U+000D) followed by a line feed character (U+000A), a carriage\n       return\
    \ character (U+000D) followed by a next line character\n       (U+0085), or just\
    \ a carriage return character (U+000D) provided\n       the next item is not a\
    \ character item that is serialized as a\n       line feed (U+000A) or next line\
    \ (U+0085) character.\n         Aside: All these sequences will be normalized\
    \ to a line feed\n         character (U+000A) during decoding.\n   A character\
    \ item with the [character code] U+000D (carriage return),\n   U+0085 (next line),\
    \ or U+2028 (line separator) must be serialized as\n   a character reference to\
    \ protect the character from line break\n   normalization during decoding.\n \
    \  The attribute value normalization performed by XML processors allows\n   some\
    \ freedom in how a space character (U+0020) is serialized:\n   (1) If XML version\
    \ 1.0 is selected, then a space character (U+0020)\n       in an attribute item's\
    \ [normalized value] is serialized as either\n       a space character (U+0020),\
    \ a tab character (U+0009), a carriage\n       return character (U+000D), a line\
    \ feed character (U+000A), a\n       carriage return character (U+000D) followed\
    \ by a line feed\n       character (U+000A), or just a carriage return character\
    \ (U+000D)\n       provided the next character in the [normalized value] is not\n\
    \       serialized as a line feed character (U+000A).\n   (2) If XML version 1.1\
    \ is selected, then a space character (U+0020)\n       in an attribute item's\
    \ [normalized value] is serialized as either\n       a space character (U+0020),\
    \ a tab character (U+0009), a carriage\n       return character (U+000D), a line\
    \ feed character (U+000A), a next\n       line character (U+0085), a line separator\
    \ character (U+2028), a\n       carriage return character (U+000D) followed by\
    \ a line feed\n       character (U+000A), a carriage return character (U+000D)\
    \ followed\n       by a next line character (U+0085), or just a carriage return\n\
    \       character (U+000D) provided the next character in the\n       [normalized\
    \ value] is not serialized as a line feed (U+000A) or\n       next line (U+0085)\
    \ character.\n          Aside: All these sequences will be normalized to a space\n\
    \          character (U+0020) during decoding, through a combination of\n    \
    \      line break normalization and attribute value normalization.\n   Each tab\
    \ (U+0009), line feed (U+000A), or carriage return (U+000D)\n   character in an\
    \ attribute item's [normalized value] must be\n   serialized as a character reference\
    \ to protect the character from\n   attribute value normalization during decoding.\
    \  In addition, if XML\n   version 1.1 is selected, then each next line (U+0085)\
    \ or line\n   separator (U+2028) character must be serialized as a character\n\
    \   reference.\n   Parsed entity references may be used (unless the environment\
    \ in which\n   the RXER encoding is used disallows entity references).  If entity\n\
    \   references to other than the predefined entities are used, then the\n   XML\
    \ document containing the RXER encoding must necessarily contain a\n   document\
    \ type declaration, and the internal or external subset of the\n   document type\
    \ definition must contain entity declarations for those\n   entities.\n"
- title: 6.12.2.  Canonical Serialization
  contents:
  - "6.12.2.  Canonical Serialization\n   This section discusses Infoset serialization\
    \ for CRXER encodings.\n   The serialization of an Infoset for a CRXER encoding\
    \ is restricted so\n   that each distinct Infoset has only one possible serialization\
    \ as an\n   XML document.\n      Aside: These restrictions have been chosen so\
    \ as to be consistent\n      with Canonical XML [CXML], where possible.\n   The\
    \ document SHALL be encoded in UTF-8 without a leading Byte Order\n   Mark [UCS].\n\
    \   The XMLDecl of the document SHALL be <?xml version=\"1.1\"?>.\n   A document\
    \ type declaration (doctypedecl) SHALL NOT be used.\n      Aside: This has the\
    \ effect of excluding entity references, except\n      those for the predefined\
    \ entities (e.g., &amp;).\n   A single line feed character (U+000A) MUST be inserted\
    \ immediately\n   before the document element.\n   No other white space characters\
    \ are permitted before or after the\n   document element.\n   There SHALL NOT\
    \ be any PIs or comments before or after the document\n   element.\n   An element\
    \ item MUST NOT be serialized as an empty-element tag.\n      Aside: If an element\
    \ item has no items in its [children], then it\n      is serialized as a start-tag\
    \ followed by an end-tag.\n   There SHALL NOT be any white space characters immediately\
    \ before the\n   closing '>' of an element's start-tag and end-tag.  The white\
    \ space\n   preceding each attribute SHALL be exactly one space character\n  \
    \ (U+0020).  There SHALL NOT be any white space characters immediately\n   before\
    \ or after the equals sign (U+003D) in an attribute.\n   The delimiter for attribute\
    \ values SHALL be the double quote\n   character (U+0022).\n   Namespace declaration\
    \ attributes MUST appear before any other\n   attributes of an element.  A namespace\
    \ declaration for the default\n   namespace, if present, MUST appear as the first\
    \ attribute.  The\n   remaining namespace declaration attributes MUST appear in\n\
    \   lexicographic order based on [local name].\n      Aside: In particular, this\
    \ means that xmlns:n10 comes before\n      xmlns:n2.\n   The attributes that are\
    \ not namespace declarations MUST be\n   lexicographically ordered on [namespace\
    \ name] as the primary key and\n   [local name] as the secondary key.\n   CDATA\
    \ sections SHALL NOT be used.\n   Each ampersand character ('&', U+0026) in an\
    \ attribute item's\n   [normalized value] MUST be serialized as the entity reference\
    \ &amp;.\n   Each open angle bracket character ('<', U+003C) in an attribute\n\
    \   item's [normalized value] MUST be serialized as the entity reference\n   &lt;.\
    \  Each double quote character (U+0022) in an attribute item's\n   [normalized\
    \ value] MUST be serialized as the entity reference &quot;.\n   Each character\
    \ in the range U+0001 to U+001F or U+007F to U+009F in\n   an attribute item's\
    \ [normalized value] MUST be serialized as a\n   character reference.  No other\
    \ character in a [normalized value] is\n   permitted to be serialized as an entity\
    \ reference or character\n   reference.\n   Each character item with the [character\
    \ code] U+0026 (the ampersand\n   character) MUST be serialized as the entity\
    \ reference &amp;.  Each\n   character item with the [character code] U+003C (the\
    \ open angle\n   bracket character) MUST be serialized as the entity reference\
    \ &lt;.\n   Each character item with the [character code] U+003E (the closing\n\
    \   angle bracket character) MUST be serialized as the entity reference\n   &gt;.\
    \  Each character item with a [character code] in the range\n   U+0001 to U+0008,\
    \ U+000B to U+001F, or U+007F to U+009F MUST be\n   serialized as a character\
    \ reference.  No other character item is\n   permitted to be serialized as an\
    \ entity reference or character\n   reference.\n   Character references, where\
    \ they are permitted, SHALL use uppercase\n   hexadecimal with no leading zeroes.\
    \  For example, the carriage return\n   character is represented as &#xD;.\n \
    \  A space character (U+0020) in an attribute item's [normalized value]\n   MUST\
    \ be serialized as a single U+0020 character.\n   A character item with the [character\
    \ code] U+000A MUST be serialized\n   as a single U+000A character.\n   The white\
    \ space separating the [target] and [content] in the\n   serialization of a processing\
    \ instruction item SHALL be exactly one\n   space character (U+0020).\n      Aside:\
    \ A processing instruction or comment can only appear in a\n      CRXER encoding\
    \ if it is embedded in a Markup value.\n"
- title: 6.12.3.  Unicode Normalization in XML Version 1.1
  contents:
  - "6.12.3.  Unicode Normalization in XML Version 1.1\n   XML Version 1.1 recommends,\
    \ but does not absolutely require, that\n   text be normalized according to Unicode\
    \ Normalization Form C\n   [UNICODE].  ASN.1 has no similar requirement on abstract\
    \ values of\n   string types, and ASN.1 canonical encoding rules depend on the\
    \ code\n   points of characters being preserved.\n   To accommodate both requirements,\
    \ applications SHOULD normalize\n   abstract values of ASN.1 character string\
    \ types according to Unicode\n   Normalization Form C at the time the values are\
    \ created, but MUST NOT\n   normalize a previously decoded abstract value of an\
    \ ASN.1 character\n   string type prior to re-encoding it.  An application may,\
    \ of course,\n   normalize a decoded abstract value for other purposes, such as\n\
    \   display to a user.\n"
- title: 6.13.  Syntax-Based Canonicalization
  contents:
  - "6.13.  Syntax-Based Canonicalization\n   ASN.1 encoding rules are designed to\
    \ preserve abstract values, but\n   not to preserve every detail of each transfer\
    \ syntax that is used.\n   In the case of RXER, this means that the Infoset representation\
    \ of an\n   abstract value is not necessarily preserved when the abstract value\n\
    \   is decoded and re-encoded (regardless of the encoding rules used).\n   However,\
    \ syntax-based canonicalization for XML documents (e.g.,\n   Canonical XML [CXML])\
    \ depends on the Infoset of an XML document being\n   preserved.  The Infoset\
    \ representation of an XML document containing\n   the RXER encoding of an ASN.1\
    \ abstract value potentially changes if\n   that value is decoded and re-encoded,\
    \ disrupting the Canonical XML\n   representation.  Extra normalization is required\
    \ if RXER is to be\n   usefully deployed in environments where syntax-based canonicalization\n\
    \   is used.\n   Prior to applying syntax-based canonicalization to an XML document,\n\
    \   any element items in the Infoset representation of the document that\n   correspond\
    \ to the value of an ASN.1 top-level NamedType or have\n   content and attributes\
    \ that correspond to an ASN.1 abstract value\n   MUST be replaced by the translation\
    \ of the value according to CRXER.\n   If an application uses Canonical XML but\
    \ has no knowledge of RXER,\n   then it will not know to normalize RXER encodings.\
    \  If RXER is\n   deployed into an environment containing such applications, then\
    \ the\n   Infoset translation for CRXER SHOULD be used for all RXER encodings.\n"
- title: 7.  Transfer Syntax Identifiers
  contents:
  - '7.  Transfer Syntax Identifiers

    '
- title: 7.1.  RXER Transfer Syntax
  contents:
  - "7.1.  RXER Transfer Syntax\n   The following OBJECT IDENTIFIER has been assigned\
    \ by xmled.org to\n   identify the Robust XML Encoding Rules, under an arc assigned\
    \ to\n   xmled.org by the Internet Assigned Numbers Authority (IANA):\n      {\
    \ iso(1) identified-organization(3) dod(6)\n        internet(1) private(4) enterprise(1)\n\
    \        xmled(21472) asnx(1) encoding(1) rxer(0) }\n   This OBJECT IDENTIFIER\
    \ would be used, for example, to describe the\n   transfer syntax for an RXER\
    \ encoded data-value in an EMBEDDED PDV\n   value.\n"
- title: 7.2.  CRXER Transfer Syntax
  contents:
  - "7.2.  CRXER Transfer Syntax\n   The following OBJECT IDENTIFIER has been assigned\
    \ by xmled.org to\n   identify the Canonical Robust XML Encoding Rules, under\
    \ an arc\n   assigned to xmled.org by the IANA:\n      { iso(1) identified-organization(3)\
    \ dod(6)\n        internet(1) private(4) enterprise(1)\n        xmled(21472) asnx(1)\
    \ encoding(1) crxer(1) }\n   This OBJECT IDENTIFIER would be used, for example,\
    \ to describe the\n   transfer syntax for a CRXER encoded data-value in an EMBEDDED\
    \ PDV\n   value.\n"
- title: 8.  Relationship to XER
  contents:
  - "8.  Relationship to XER\n   The Robust XML Encoding Rules (RXER) and the XML\
    \ Encoding Rules (XER)\n   [X.693] are separate, distinctly different and incompatible\
    \ ASN.1\n   encoding rules for producing XML markup from ASN.1 abstract values.\n\
    \   RXER is therefore unrelated to the XML value notation of X.680\n   [X.680].\n\
    \   This section describes some of the major differences between RXER and\n  \
    \ XER.\n   There are essentially two varieties of XER:  BASIC-XER (with a\n  \
    \ canonical form called CANONICAL-XER) and EXTENDED-XER.  The\n   significant\
    \ difference between the two varieties is that XER encoding\n   instructions are\
    \ used by EXTENDED-XER, but are ignored by BASIC-XER\n   (and therefore by CANONICAL-XER).\
    \  There isn't a canonical variant of\n   EXTENDED-XER.  Characteristics that\
    \ are common to BASIC-XER and\n   EXTENDED-XER will simply be noted as being characteristics\
    \ of XER.\n   Elements and attributes are the fundamental discrete structures\
    \ of an\n   XML document.  Not surprisingly, schema languages for XML typically\n\
    \   have the means to describe, name, and reference global (i.e.,\n   top-level)\
    \ elements and attributes.  Global type definitions are seen\n   more as a convenience\
    \ for defining the contents of elements and\n   attributes.  Traditional ASN.1\
    \ has the means to define global types\n   (and other global constructs that support\
    \ the definition of types)\n   but nothing akin to a global element or attribute\
    \ definition.  The\n   fundamental difference between RXER and XER is in how this\
    \ omission\n   is addressed.\n   With XER, type definitions are also regarded\
    \ as being element\n   definitions by default, or as attribute definitions in\
    \ the presence\n   of an XER ATTRIBUTE encoding instruction.  In some circumstances\
    \ an\n   anonymous Type is required to define an element, which leads to\n   element\
    \ names like <BOOLEAN> and <SEQUENCE>.  NamedType notation also\n   defines local\
    \ elements, and there are some curious cases in\n   EXTENDED-XER where NamedType\
    \ notation can define a global type.  So\n   under XER, types can be defined by\
    \ either Type or NamedType notation,\n   and elements and attributes can also\
    \ be defined by either Type or\n   NamedType notation.\n   With RXER, types are\
    \ only defined by Type notation and elements and\n   attributes are only defined\
    \ by NamedType notation.  Global element\n   and attribute definitions are made\
    \ possible by top-level NamedType\n   notation in an RXER encoding control section.\n\
    \   RXER, with its clean separation of Type notation for types and\n   NamedType\
    \ notation for elements and attributes, is a better basis\n   than XER for translating\
    \ an ASN.1 specification into an XML\n   representation (i.e., ASN.X [ASN.X])\
    \ or a compatible XML Schema,\n   where type, element, and attribute definitions\
    \ are also distinctly\n   separate constructs.\n   There is usually a requirement\
    \ on applications specified in ASN.1 to\n   maintain backward compatibility with\
    \ the encodings generated by\n   previous versions.  The encodings in question\
    \ are typically BER.\n   Even with the backward-compatibility constraint there\
    \ is still\n   considerable leeway for specification writers to rewrite the earlier\n\
    \   specification.  For example, they could rename types, factor out an\n   in-line\
    \ type definition as a defined type (or the reverse), or\n   replace a type definition\
    \ with an equivalent parameterized reference.\n   These changes produce no change\
    \ to BER, DER, CER [X.690], Packed\n   Encoding Rules (PER) [X.691], or Generic\
    \ String Encoding Rules (GSER)\n   [GSER] encodings (so specification writers\
    \ have felt free to make\n   such changes to improve their specification), but\
    \ can change the\n   names of elements in the XER encoding because XER uses types\
    \ as\n   element definitions.  The RXER encoding is immune to this problem,\n\
    \   thus RXER encodings are more stable than XER encodings over\n   successive\
    \ revisions of an ASN.1 specification (which explains the\n   first 'R' in RXER).\
    \  This has an obvious benefit for\n   interoperability.\n   RXER has special\
    \ provisions for encoding values of the QName and\n   Markup types.  QName is\
    \ used to hold qualified names and Markup can\n   be used to hold arbitrary untyped\
    \ markup.  XER doesn't recognize any\n   special types like these, but it is possible\
    \ to get the same effects\n   as RXER's QName and Markup types by using XER encoding\
    \ instructions.\n   Since CANONICAL-XER ignores encoding instructions, this means\
    \ that\n   under XER an application can either support qualified names and\n \
    \  untyped markup, or support canonical XML encodings, but not both.  In\n   contrast,\
    \ CRXER has canonicalization rules for qualified names and\n   for Markup.  Furthermore,\
    \ EXTENDED-XER does not address the issues of\n   normalization of untyped data\
    \ for other ASN.1 canonical encoding\n   rules (e.g., for DER; see Section 4.1.2)\
    \ or normalization of XML\n   encodings for syntax-based canonicalization (e.g.,\
    \ for Canonical XML;\n   see Section 6.13).\n   Both EXTENDED-XER and RXER use\
    \ encoding instructions to define\n   attributes, union types, and list types,\
    \ among other things.  Since\n   CANONICAL-XER ignores encoding instructions,\
    \ this means that under\n   XER an application must choose between making use\
    \ of attributes,\n   union types, list types, etc., or supporting canonical XML\
    \ encodings.\n   In contrast, the canonicalization rules for CRXER encompass all\
    \ the\n   encoding instructions for RXER.\n"
- title: 9.  Security Considerations
  contents:
  - "9.  Security Considerations\n   RXER does not necessarily enable the exact BER\
    \ octet encoding of\n   values of the TeletexString, VideotexString, GraphicString,\
    \ or\n   GeneralString types to be reconstructed, so a transformation from DER\n\
    \   to RXER and back to DER may not reproduce the original DER encoding.\n   This\
    \ is a result of inadequate normalization of values of these\n   string types\
    \ in DER.  A character in a TeletexString value (for\n   example) that corresponds\
    \ to a specific ISO 10646 character can be\n   encoded for BER in a variety of\
    \ ways that are indistinguishable in an\n   RXER re-encoding of the TeletexString\
    \ value.  DER does not mandate\n   one of these possible character encodings in\
    \ preference to all\n   others.\n   Because of the above, RXER MUST NOT be used\
    \ to re-encode, whether for\n   storage or transmission, ASN.1 abstract values\
    \ whose original DER or\n   CER encoding must be recoverable, and whose type definitions\
    \ involve\n   the TeletexString, VideotexString, GraphicString, or GeneralString\n\
    \   type.  Such recovery is needed for the verification of digital\n   signatures.\
    \  In such cases, protocols ought to use DER or a DER-\n   reversible encoding.\
    \  In other cases where ASN.1 canonical encoding\n   rules are used, values of\
    \ the Markup type must be normalized as\n   described in Section 4.1.2.\n   A\
    \ transformation from CRXER to BER and back to CRXER does reproduce\n   the original\
    \ CRXER encoding, therefore it is safe to use BER, DER, or\n   CER to re-encode\
    \ ASN.1 abstract values whose original CRXER encoding\n   must be recoverable.\n\
    \   Digital signatures may also be calculated on the Canonical XML\n   representation\
    \ of an XML document.  If RXER encodings appear in such\n   documents, then applications\
    \ must normalize the encodings as\n   described in Section 6.13.\n   The null\
    \ character (U+0000) cannot be represented in XML and hence\n   cannot be transmitted\
    \ in an RXER encoding.  Null characters in\n   abstract values of ASN.1 string\
    \ types will be dropped if the values\n   are RXER encoded; therefore, RXER MUST\
    \ NOT be used by applications\n   that attach significance to the null character.\n\
    \   When interpreting security-sensitive fields, and in particular fields\n  \
    \ used to grant or deny access, implementations MUST ensure that any\n   comparisons\
    \ are done on the underlying abstract value, regardless of\n   the particular\
    \ encoding used.  Comparisons of Markup values MUST\n   operate as though the\
    \ values have been normalized as specified in\n   Section 4.1.2.\n"
- title: 10.  Acknowledgements
  contents:
  - "10.  Acknowledgements\n   The technology described in this document is the product\
    \ of a\n   research project begun jointly by Adacel Technologies Limited and\n\
    \   Deakin University, and subsequently refined and completed by eB2Bcom.\n"
- title: 11.  IANA Considerations
  contents:
  - "11.  IANA Considerations\n   The IANA has registered a new XML namespace in accordance\
    \ with RFC\n   3688 [XMLREG].\n   URI:  urn:ietf:params:xml:ns:asnx\n   Registrant\
    \ Contact:  Steven Legg <steven.legg@eb2bcom.com>\n   XML:  None\n"
- title: 12.  References
  contents:
  - '12.  References

    '
- title: 12.1.  Normative References
  contents:
  - "12.1.  Normative References\n   [BCP14]    Bradner, S., \"Key words for use in\
    \ RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March\
    \ 1997.\n   [UTF-8]    Yergeau, F., \"UTF-8, a transformation format of ISO\n\
    \              10646\", RFC 3629, November 2003.\n   [XMLREG]   Mealling, M.,\
    \ \"The IETF XML Registry\", RFC 3688, January\n              2004.\n   [URI]\
    \      Berners-Lee, T., Fielding, R. and L. Masinter, \"Uniform\n            \
    \  Resource Identifiers (URI): Generic Syntax\", STD 66, RFC\n              3986,\
    \ January 2005.\n   [RXEREI]   Legg, S., \"Encoding Instructions for the Robust\
    \ XML\n              Encoding Rules (RXER)\", RFC 4911, July 2007.\n   [ASN.X]\
    \    Legg, S., \"Abstract Syntax Notation X (ASN.X)\", RFC 4912,\n           \
    \   July 2007.\n   [X.680]    ITU-T Recommendation X.680 (07/02) | ISO/IEC 8824-1,\n\
    \              Information technology - Abstract Syntax Notation One\n       \
    \       (ASN.1):  Specification of basic notation.\n   [X.680-1]  ITU-T Recommendation\
    \ X.680 (2002) Amendment 1 (10/03) |\n              ISO/IEC 8824-1:2002/Amd 1:2004,\
    \ Support for EXTENDED-XER.\n   [X.681]    ITU-T Recommendation X.681 (07/02)\
    \ | ISO/IEC 8824-2,\n              Information technology - Abstract Syntax Notation\
    \ One\n              (ASN.1):  Information object specification.\n   [X.682] \
    \   ITU-T Recommendation X.682 (07/02) | ISO/IEC 8824-3,\n              Information\
    \ technology - Abstract Syntax Notation One\n              (ASN.1):  Constraint\
    \ specification.\n   [X.683]    ITU-T Recommendation X.683 (07/02) | ISO/IEC 8824-4,\n\
    \              Information technology - Abstract Syntax Notation One\n       \
    \       (ASN.1):  Parameterization of ASN.1 specifications.\n   [X.690]    ITU-T\
    \ Recommendation X.690 (07/02) | ISO/IEC 8825-1,\n              Information technology\
    \ - ASN.1 encoding rules:\n              Specification of Basic Encoding Rules\
    \ (BER), Canonical\n              Encoding Rules (CER) and Distinguished Encoding\
    \ Rules\n              (DER).\n   [UCS]      ISO/IEC 10646-1:2000, Information\
    \ technology - Universal\n              Multiple-Octet Coded Character Set (UCS)\
    \ - Part 1:\n              Architecture and Basic Multilingual Plane.\n   [UNICODE]\
    \  The Unicode Consortium, \"The Unicode Standard, Version\n              4.0\"\
    , Boston, MA, Addison-Wesley Developers Press, 2003.\n              ISBN 0-321-18578-1.\n\
    \   [XML10]    Bray, T., Paoli, J., Sperberg-McQueen, C., Maler, E. and\n    \
    \          F. Yergeau, \"Extensible Markup Language (XML) 1.0 (Fourth\n      \
    \        Edition)\", W3C Recommendation,\n              http://www.w3.org/TR/2006/REC-xml-20060816,\
    \ August 2006.\n   [XML11]    Bray, T., Paoli, J., Sperberg-McQueen, C., Maler,\
    \ E.,\n              Yergeau, F., and J. Cowan, \"Extensible Markup Language\n\
    \              (XML) 1.1 (Second Edition)\", W3C Recommendation,\n           \
    \   http://www.w3.org/TR/2006/REC-xml11-20060816, August 2006.\n   [XMLNS10] \
    \ Bray, T., Hollander, D., Layman, A., and R. Tobin,\n              \"Namespaces\
    \ in XML 1.0 (Second Edition)\", W3C\n              Recommendation,\n        \
    \      http://www.w3.org/TR/2006/REC-xml-names-20060816, August\n            \
    \  2006.\n   [XMLNS11]  Bray, T., Hollander, D., Layman, A. and R. Tobin,\n  \
    \            \"Namespaces in XML 1.1 (Second Edition)\", W3C\n              Recommendation,\n\
    \              http://www.w3.org/TR/2006/REC-xml-names11-20060816, August\n  \
    \            2006.\n   [INFOSET]  Cowan, J. and R. Tobin, \"XML Information Set\
    \ (Second\n              Edition)\", W3C Recommendation,\n              http://www.w3.org/TR/2004/REC-xml-infoset-20040204,\n\
    \              February 2004.\n   [XSD1]     Thompson, H., Beech, D., Maloney,\
    \ M. and N. Mendelsohn,\n              \"XML Schema Part 1: Structures Second\
    \ Edition\", W3C\n              Recommendation,\n              http://www.w3.org/TR/2004/REC-xmlschema-1-20041028/,\n\
    \              October 2004.\n"
- title: 12.2.  Informative References
  contents:
  - "12.2.  Informative References\n   [GSER]     Legg, S., \"Generic String Encoding\
    \ Rules (GSER) for ASN.1\n              Types\", RFC 3641, October 2003.\n   [X.691]\
    \    ITU-T Recommendation X.691 (07/02) | ISO/IEC 8825-4:2002,\n             \
    \ Information technology - ASN.1 encoding rules:\n              Specification\
    \ of Packed Encoding Rules (PER).\n   [X.693]    ITU-T Recommendation X.693 (12/01)\
    \ | ISO/IEC 8825-4:2002,\n              Information technology - ASN.1 encoding\
    \ rules: XML\n              encoding rules (XER).\n   [XSD2]     Biron, P. and\
    \ A. Malhotra, \"XML Schema Part 2: Datatypes\n              Second Edition\"\
    , W3C Recommendation,\n              http://www.w3.org/TR/2004/REC-xmlschema-2-20041028/,\n\
    \              October 2004.\n   [CXML]     Boyer, J., \"Canonical XML Version\
    \ 1.0\", W3C\n              Recommendation,\n              http://www.w3.org/TR/2001/REC-xml-c14n-20010315,\
    \ March\n              2001.\n"
- title: Appendix A.  Additional Basic Definitions Module
  contents:
  - "Appendix A.  Additional Basic Definitions Module\n   This appendix is normative.\n\
    \   AdditionalBasicDefinitions\n       { iso(1) identified-organization(3) dod(6)\n\
    \         internet(1) private(4) enterprise(1)\n         xmled(21472) asnx(1)\
    \ module(0) basic(0) }\n   -- Copyright (C) The IETF Trust (2007).  This version\
    \ of\n   -- this ASN.1 module is part of RFC 4910; see the RFC itself\n   -- for\
    \ full legal notices.\n   --\n   -- Regarding this ASN.1 module or any portion\
    \ of it, the authors\n   -- make no guarantees and are not responsible for any\
    \ damage\n   -- resulting from its use.  The authors grant irrevocable permission\n\
    \   -- to anyone to use, modify, and distribute it in any way that does\n   --\
    \ not diminish the rights of anyone else to use, modify, and\n   -- distribute\
    \ it, provided that redistributed derivative works do\n   -- not contain misleading\
    \ author or version information.\n   -- Derivative works need not be licensed\
    \ under similar terms.\n   DEFINITIONS\n   RXER INSTRUCTIONS\n   AUTOMATIC TAGS\n\
    \   EXTENSIBILITY IMPLIED ::= BEGIN\n   Markup ::= CHOICE {\n       text    SEQUENCE\
    \ {\n           prolog      UTF8String (SIZE(1..MAX)) OPTIONAL,\n           prefix\
    \      NCName OPTIONAL,\n           attributes  UTF8String (SIZE(1..MAX)) OPTIONAL,\n\
    \           content     UTF8String (SIZE(1..MAX)) OPTIONAL\n       }\n   }\n \
    \  AnyURI ::= UTF8String (CONSTRAINED BY\n                  { -- conforms to the\
    \ format of a URI -- })\n   NCName ::= UTF8String (CONSTRAINED BY\n          \
    \        { -- conforms to the NCName production of\n                    -- Namespaces\
    \ in XML 1.0 -- })\n   Name ::= UTF8String (CONSTRAINED BY\n                 \
    \ { -- conforms to the Name production of XML -- })\n   QName ::= SEQUENCE {\n\
    \       namespace-name  AnyURI OPTIONAL,\n       local-name      NCName\n   }\n\
    \   ENCODING-CONTROL RXER\n       TARGET-NAMESPACE \"urn:ietf:params:xml:ns:asnx\"\
    \ PREFIX \"asnx\"\n       COMPONENT context [ATTRIBUTE] [LIST] SEQUENCE OF prefix\
    \ NCName\n   END\n"
- title: Authors' Addresses
  contents:
  - "Authors' Addresses\n   Dr. Steven Legg\n   eB2Bcom\n   Suite 3, Woodhouse Corporate\
    \ Centre\n   935 Station Street\n   Box Hill North, Victoria 3129\n   AUSTRALIA\n\
    \   Phone: +61 3 9896 7830\n   Fax:   +61 3 9896 7801\n   EMail: steven.legg@eb2bcom.com\n\
    \   Dr. Daniel Prager\n   EMail: dap@austhink.com\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The IETF Trust (2007).\n   This document\
    \ is subject to the rights, licenses and restrictions\n   contained in BCP 78,\
    \ and except as set forth therein, the authors\n   retain all their rights.\n\
    \   This document and the information contained herein are provided on an\n  \
    \ \"AS IS\" basis and THE CONTRIBUTOR, THE ORGANIZATION HE/SHE REPRESENTS\n  \
    \ OR IS SPONSORED BY (IF ANY), THE INTERNET SOCIETY, THE IETF TRUST AND\n   THE\
    \ INTERNET ENGINEERING TASK FORCE DISCLAIM ALL WARRANTIES, EXPRESS\n   OR IMPLIED,\
    \ INCLUDING BUT NOT LIMITED TO ANY WARRANTY THAT THE USE OF\n   THE INFORMATION\
    \ HEREIN WILL NOT INFRINGE ANY RIGHTS OR ANY IMPLIED\n   WARRANTIES OF MERCHANTABILITY\
    \ OR FITNESS FOR A PARTICULAR PURPOSE.\n"
- title: Intellectual Property
  contents:
  - "Intellectual Property\n   The IETF takes no position regarding the validity or\
    \ scope of any\n   Intellectual Property Rights or other rights that might be\
    \ claimed to\n   pertain to the implementation or use of the technology described\
    \ in\n   this document or the extent to which any license under such rights\n\
    \   might or might not be available; nor does it represent that it has\n   made\
    \ any independent effort to identify any such rights.  Information\n   on the\
    \ procedures with respect to rights in RFC documents can be\n   found in BCP 78\
    \ and BCP 79.\n   Copies of IPR disclosures made to the IETF Secretariat and any\n\
    \   assurances of licenses to be made available, or the result of an\n   attempt\
    \ made to obtain a general license or permission for the use of\n   such proprietary\
    \ rights by implementers or users of this\n   specification can be obtained from\
    \ the IETF on-line IPR repository at\n   http://www.ietf.org/ipr.\n   The IETF\
    \ invites any interested party to bring to its attention any\n   copyrights, patents\
    \ or patent applications, or other proprietary\n   rights that may cover technology\
    \ that may be required to implement\n   this standard.  Please address the information\
    \ to the IETF at\n   ietf-ipr@ietf.org.\n"
- title: Acknowledgement
  contents:
  - "Acknowledgement\n   Funding for the RFC Editor function is currently provided\
    \ by the\n   Internet Society.\n"
