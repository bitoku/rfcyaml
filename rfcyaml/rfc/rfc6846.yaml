- contents:
  - "                   RObust Header Compression (ROHC):\n                    A Profile
    for TCP/IP (ROHC-TCP)\n"
  title: __initial_text__
- contents:
  - "Abstract\n   This document specifies a RObust Header Compression (ROHC) profile\n
    \  for compression of TCP/IP packets.  The profile, called ROHC-TCP,\n   provides
    efficient and robust compression of TCP headers, including\n   frequently used
    TCP options such as selective acknowledgments (SACKs)\n   and Timestamps.\n   ROHC-TCP
    works well when used over links with significant error rates\n   and long round-trip
    times.  For many bandwidth-limited links where\n   header compression is essential,
    such characteristics are common.\n   This specification obsoletes RFC 4996.  It
    fixes a technical issue\n   with the SACK compression and clarifies other compression
    methods\n   used.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6846.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2013 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................5\n
    \  2. Terminology .....................................................5\n   3.
    Background ......................................................7\n      3.1.
    Existing TCP/IP Header Compression Schemes .................7\n      3.2. Classification
    of TCP/IP Header Fields .....................8\n   4. Overview of the TCP/IP Profile
    (Informative) ...................10\n      4.1. General Concepts ..........................................10\n
    \     4.2. Compressor and Decompressor Interactions ..................10\n           4.2.1.
    Compressor Operation ...............................10\n           4.2.2. Decompressor
    Feedback ..............................11\n      4.3. Packet Formats and Encoding
    Methods .......................11\n           4.3.1. Compressing TCP Options ............................11\n
    \          4.3.2. Compressing Extension Headers ......................11\n      4.4.
    Expected Compression Ratios with ROHC-TCP .................12\n   5. Compressor
    and Decompressor Logic (Normative) ..................13\n      5.1. Context Initialization
    ....................................13\n      5.2. Compressor Operation ......................................13\n
    \          5.2.1. Compression Logic ..................................13\n                  5.2.1.1.
    Optimistic Approach .......................14\n                  5.2.1.2. Periodic
    Context Refreshes ................14\n           5.2.2. Feedback Logic .....................................14\n
    \                 5.2.2.1. Optional Acknowledgments (ACKs) ...........14\n                  5.2.2.2.
    Negative Acknowledgments (NACKs) ..........15\n           5.2.3. Context Replication
    ................................15\n      5.3. Decompressor Operation ....................................16\n
    \          5.3.1. Decompressor States and Logic ......................16\n                  5.3.1.1.
    Reconstruction and Verification ...........16\n                  5.3.1.2. Detecting
    Context Damage ..................17\n                  5.3.1.3. No Context (NC)
    State .....................18\n                  5.3.1.4. Static Context (SC)
    State .................18\n                  5.3.1.5. Full Context (FC) State
    ...................19\n           5.3.2. Feedback Logic .....................................19\n
    \          5.3.3. Context Replication ................................20\n   6.
    Encodings in ROHC-TCP (Normative) ..............................20\n      6.1.
    Control Fields in ROHC-TCP ................................20\n           6.1.1.
    Master Sequence Number (MSN) .......................20\n           6.1.2. IP-ID
    Behavior .....................................21\n           6.1.3. Explicit Congestion
    Notification (ECN) .............22\n      6.2. Compressed Header Chains ..................................22\n
    \     6.3. Compressing TCP Options with List Compression .............24\n           6.3.1.
    List Compression ...................................25\n           6.3.2. Table-Based
    Item Compression .......................26\n           6.3.3. Encoding of Compressed
    Lists .......................26\n           6.3.4. Item Table Mappings ................................28\n
    \          6.3.5. Compressed Lists in Dynamic Chain ..................30\n           6.3.6.
    Irregular Chain Items for TCP Options ..............30\n           6.3.7. Replication
    of TCP Options .........................30\n      6.4. Profile-Specific Encoding
    Methods .........................31\n           6.4.1. inferred_ip_v4_header_checksum
    .....................31\n           6.4.2. inferred_mine_header_checksum ......................31\n
    \          6.4.3. inferred_ip_v4_length ..............................32\n           6.4.4.
    inferred_ip_v6_length ..............................32\n           6.4.5. inferred_offset
    ....................................33\n           6.4.6. baseheader_extension_headers
    .......................33\n           6.4.7. baseheader_outer_headers ...........................34\n
    \          6.4.8. Scaled Encoding of Fields ..........................34\n                  6.4.8.1.
    Scaled TCP Sequence Number Encoding .......35\n                  6.4.8.2. Scaled
    Acknowledgment Number Encoding .....35\n      6.5. Encoding Methods with External
    Parameters .................36\n   7. Packet Types (Normative) .......................................38\n
    \     7.1. Initialization and Refresh (IR) Packets ...................38\n      7.2.
    Context Replication (IR-CR) Packets .......................40\n      7.3. Compressed
    (CO) Packets ...................................42\n   8. Header Formats (Normative)
    .....................................43\n      8.1. Design Rationale for Compressed
    Base Headers ..............44\n      8.2. Formal Definition of Header Formats
    .......................47\n      8.3. Feedback Formats and Options ..............................88\n
    \          8.3.1. Feedback Formats ...................................88\n           8.3.2.
    Feedback Options ...................................89\n                  8.3.2.1.
    The REJECT Option .........................89\n                  8.3.2.2. The
    MSN-NOT-VALID Option ..................90\n                  8.3.2.3. The MSN
    Option ............................90\n                  8.3.2.4. The CONTEXT_MEMORY
    Feedback Option ........91\n                  8.3.2.5. Unknown Option Types ......................91\n
    \  9. Changes from RFC 4996 ..........................................91\n      9.1.
    Functional Changes ........................................91\n      9.2. Non-functional
    Changes ....................................92\n   10. Security Considerations
    .......................................92\n   11. IANA Considerations ...........................................93\n
    \  12. Acknowledgments ...............................................93\n   13.
    References ....................................................93\n      13.1.
    Normative References .....................................93\n      13.2. Informative
    References ...................................94\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   There are several reasons to perform header compression
    on low- or\n   medium-speed links for TCP/IP traffic, and these have already been\n
    \  discussed in [RFC2507].  Additional considerations that make\n   robustness
    an important objective for a TCP [RFC0793] compression\n   scheme are introduced
    in [RFC4163].  Finally, existing TCP/IP header\n   compression schemes ([RFC1144],
    [RFC2507]) are limited in their\n   handling of the TCP options field and cannot
    compress the headers of\n   handshaking packets (SYNs and FINs).\n   It is thus
    desirable for a header compression scheme to be able to\n   handle loss on the
    link between the compression and decompression\n   points as well as loss before
    the compression point.  The header\n   compression scheme also needs to consider
    how to efficiently compress\n   short-lived TCP transfers and TCP options, such
    as selective\n   acknowledgments (SACK) ([RFC2018], [RFC2883]) and Timestamps\n
    \  ([RFC1323]).  TCP options that may be less frequently used do not\n   necessarily
    need to be compressed by the protocol, and instead can be\n   passed transparently
    without reducing the overall compression\n   efficiency of other parts of the
    TCP header.\n   The Robust Header Compression (ROHC) Working Group has developed
    a\n   header compression framework on top of which various profiles can be\n   defined
    for different protocol sets, or for different compression\n   strategies.  This
    document defines a TCP/IP compression profile for\n   the ROHC framework [RFC5795],
    compliant with the requirements listed\n   in [RFC4163].\n   Specifically, it
    describes a header compression scheme for TCP/IP\n   header compression (ROHC-TCP)
    that is robust against packet loss and\n   that offers enhanced capabilities,
    in particular for the compression\n   of header fields including TCP options.
    \ The profile identifier for\n   TCP/IP compression is 0x0006.\n"
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\"
    in this\n   document are to be interpreted as described in [RFC2119].\n   This
    document reuses some of the terminology found in [RFC5795].  In\n   addition,
    this document uses or defines the following terms:\n   Base context\n      The
    base context is a context that has been validated by both the\n      compressor
    and the decompressor.  A base context can be used as\n      the reference when
    building a new context using replication.\n   Base Context Identifier (Base CID)\n
    \     The Base CID is the CID that identifies the base context, from\n      which
    information needed for context replication can be extracted.\n   Base header\n
    \     The Base header is a compressed representation of the innermost IP\n      and
    TCP headers of the uncompressed packet.\n   Chaining of items\n      A chain groups
    fields based on similar characteristics.  ROHC-TCP\n      defines chain items
    for static, dynamic, replicable, or irregular\n      fields.  Chaining is done
    by appending an item for each header,\n      e.g., to the chain in their order
    of appearance in the\n      uncompressed packet.  Chaining is useful to construct
    compressed\n      headers from an arbitrary number of any of the protocol headers\n
    \     for which ROHC-TCP defines a compressed format.\n   Context Replication
    (CR)\n      Context replication is the mechanism that establishes and\n      initializes
    a new context based on another existing valid context\n      (a base context).
    \ This mechanism is introduced to reduce the\n      overhead of the context establishment
    procedure, and is especially\n      useful for compression of multiple short-lived
    TCP connections\n      that may be occurring simultaneously or near-simultaneously.\n
    \  ROHC-TCP packet types\n      ROHC-TCP uses three different packet types: the
    Initialization and\n      Refresh (IR) packet type, the Context Replication (IR-CR)
    packet\n      type, and the Compressed packet (CO) type.\n   Short-lived TCP transfer\n
    \     Short-lived TCP transfers refer to TCP connections transmitting\n      only
    small amounts of packets for each single connection.\n"
  title: 2.  Terminology
- contents:
  - "3.  Background\n   This section provides some background information on TCP/IP
    header\n   compression.  The fundamentals of general header compression can be\n
    \  found in [RFC5795].  In the following subsections, two existing\n   TCP/IP
    header compression schemes are first described along with a\n   discussion of
    their limitations, followed by the classification of\n   TCP/IP header fields.
    \ Finally, some of the characteristics of short-\n   lived TCP transfers are summarized.\n
    \  A behavior analysis of TCP/IP header fields is found in [RFC4413].\n"
  - contents:
    - "3.1.  Existing TCP/IP Header Compression Schemes\n   Compressed TCP (CTCP)
      and IP Header Compression (IPHC) are two\n   different schemes that may be used
      to compress TCP/IP headers.  Both\n   schemes transmit only the differences
      from the previous header in\n   order to reduce the size of the TCP/IP header.\n
      \  The CTCP [RFC1144] compressor detects transport-level retransmissions\n   and
      sends a header that updates the context completely when they\n   occur.  While
      CTCP works well over reliable links, it is vulnerable\n   when used over less
      reliable links as even a single packet loss\n   results in loss of synchronization
      between the compressor and the\n   decompressor.  This in turn leads to the
      TCP receiver discarding all\n   remaining packets in the current window because
      of a checksum error.\n   This effectively prevents the TCP fast retransmit algorithm
      [RFC5681]\n   from being triggered.  In such a case, the compressor must wait
      until\n   TCP times out and retransmits a packet to resynchronize.\n   To reduce
      the errors due to the inconsistent contexts between\n   compressor and decompressor
      when compressing TCP, IPHC [RFC2507]\n   improves somewhat on CTCP by augmenting
      the repair mechanism of CTCP\n   with a local repair mechanism called TWICE
      and with a link-layer\n   mechanism based on negative acknowledgments to request
      a header that\n   updates the context.\n   The TWICE algorithm assumes that
      only the Sequence Number field of\n   TCP segments is changing with the deltas
      between consecutive packets\n   being constant in most cases.  This assumption
      is, however, not\n   always true, especially when TCP Timestamps and SACK options
      are\n   used.\n   The full header request mechanism requires a feedback channel
      that\n   may be unavailable in some circumstances.  This channel is used to\n
      \  explicitly request that the next packet be sent with an uncompressed\n   header
      to allow resynchronization without waiting for a TCP timeout.\n   In addition,
      this mechanism does not perform well on links with long\n   round-trip times.\n
      \  Both CTCP and IPHC are also limited in their handling of the TCP\n   options
      field.  For IPHC, any change in the options field (caused by\n   Timestamps
      or SACK, for example) renders the entire field\n   uncompressible, while for
      CTCP, such a change in the options field\n   effectively disables TCP/IP header
      compression altogether.\n   Finally, existing TCP/IP compression schemes do
      not compress the\n   headers of handshaking packets (SYNs and FINs).  Compressing
      these\n   packets may greatly improve the overall header compression ratio for\n
      \  the cases where many short-lived TCP connections share the same\n   channel.\n"
    title: 3.1.  Existing TCP/IP Header Compression Schemes
  - contents:
    - "3.2.  Classification of TCP/IP Header Fields\n   Header compression is possible
      due to the fact that there is much\n   redundancy between header field values
      within packets, especially\n   between consecutive packets.  To utilize these
      properties for TCP/IP\n   header compression, it is important to understand
      the change patterns\n   of the various header fields.\n   All fields of the
      TCP/IP packet header have been classified in detail\n   in [RFC4413].  The main
      conclusion is that most of the header fields\n   can easily be compressed away
      since they seldom or never change.  The\n   following fields do, however, require
      more sophisticated mechanisms:\n     - IPv4 Identification       (16 bits) -
      IP-ID\n     - TCP Sequence Number       (32 bits) - SN\n     - TCP Acknowledgment
      Number (32 bits)\n     - TCP Reserved              ( 4 bits)\n     - TCP ECN
      flags             ( 2 bits) - ECN\n     - TCP Window                (16 bits)\n
      \    - TCP Options\n       o  Maximum Segment Size   (32 bits) - MSS\n       o
      \ Window Scale           (24 bits) - WSCALE\n       o  SACK Permitted         (16
      bits)\n       o  TCP SACK               (80, 144, 208, or 272 bits) - SACK\n
      \      o  TCP Timestamp          (80 bits) - TS\n   The assignment of IP-ID
      values can be done in various ways, usually\n   one of sequential, sequential
      jump, or random, as described in\n   Section 4.1.3 of [RFC4413].  Some IPv4
      stacks do use a sequential\n   assignment when generating IP-ID values but do
      not transmit the\n   contents of this field in network byte order; instead,
      it is sent\n   with the two octets reversed.  In this case, the compressor can\n
      \  compress the IP-ID field after swapping the bytes.  Consequently, the\n   decompressor
      also swaps the bytes of the IP-ID after decompression to\n   regenerate the
      original IP-ID.  With respect to TCP compression, the\n   analysis in [RFC4413]
      reveals that there is no obvious candidate\n   among the TCP fields suitable
      to infer the IP-ID.\n   The change pattern of several TCP fields (Sequence Number,\n
      \  Acknowledgment Number, Window, etc.) is very hard to predict.  Of\n   particular
      importance to a TCP/IP header compression scheme is the\n   understanding of
      the sequence and acknowledgment numbers [RFC4413].\n   Specifically, the TCP
      Sequence Number can be anywhere within a range\n   defined by the TCP Window
      at any point on the path (i.e., wherever a\n   compressor might be deployed).
      \ Missing packets or retransmissions\n   can cause the TCP Sequence Number to
      fluctuate within the limits of\n   this window.  The TCP Window also bounds
      the jumps in acknowledgment\n   number.\n   Another important behavior of the
      TCP/IP header is the dependency\n   between the sequence number and the acknowledgment
      number.  TCP\n   connections can be either near-symmetrical or show a strong\n
      \  asymmetrical bias with respect to the data traffic.  In the latter\n   case,
      the TCP connections mainly have one-way traffic (Web browsing\n   and file downloading,
      for example).  This means that on the forward\n   path (from server to client),
      only the sequence number is changing\n   while the acknowledgment number remains
      constant for most packets; on\n   the backward path (from client to server),
      only the acknowledgment\n   number is changing and the sequence number remains
      constant for most\n   packets.  A compression scheme for TCP should thus have
      packet\n   formats suitable for either cases, i.e., packet formats that can\n
      \  carry either only sequence number bits, only acknowledgment number\n   bits,
      or both.\n   In addition, TCP flows can be short-lived transfers.  Short-lived
      TCP\n   transfers will degrade the performance of header compression schemes\n
      \  that establish a new context by initially sending full headers.\n   Multiple
      simultaneous or near simultaneous TCP connections may\n   exhibit much similarity
      in header field values and context values\n   among each other, which would
      make it possible to reuse information\n   between flows when initializing a
      new context.  A mechanism to this\n   end, context replication [RFC4164], makes
      the context establishment\n   step faster and more efficient, by replicating
      part of an existing\n   context to a new flow.  The conclusion from [RFC4413]
      is that part of\n   the IP sub-context, some TCP fields, and some context values
      can be\n   replicated since they seldom change or change with only a small jump.\n
      \  ROHC-TCP also compresses the following headers: IPv6 Destination\n   Options
      header [RFC2460], IPv6 Routing header [RFC2460], IPv6 Hop-by-\n   Hop Options
      header [RFC2460], Authentication Header (AH) [RFC4302],\n   Generic Routing
      Encapsulation (GRE) [RFC2784][RFC2890], and the\n   Minimal Encapsulation (MINE)
      header [RFC2004].\n   Headers specific to Mobile IP (for IPv4 or IPv6) do not
      receive any\n   special treatment in this document, for reasons similar to those\n
      \  described in [RFC3095].\n"
    title: 3.2.  Classification of TCP/IP Header Fields
  title: 3.  Background
- contents:
  - '4.  Overview of the TCP/IP Profile (Informative)

    '
  - contents:
    - "4.1.  General Concepts\n   ROHC-TCP uses the ROHC protocol as described in
      [RFC5795].  ROHC-TCP\n   supports context replication as defined in [RFC4164].
      \ Context\n   replication can be particularly useful for short-lived TCP flows\n
      \  [RFC4413].\n"
    title: 4.1.  General Concepts
  - contents:
    - '4.2.  Compressor and Decompressor Interactions

      '
    - contents:
      - "4.2.1.  Compressor Operation\n   Header compression with ROHC can be conceptually
        characterized as the\n   interaction of a compressor with a decompressor state
        machine.  The\n   compressor's task is to minimally send the information needed
        to\n   successfully decompress a packet, based on a certain confidence\n   regarding
        the state of the decompressor context.\n   For ROHC-TCP compression, the compressor
        normally starts compression\n   with the initial assumption that the decompressor
        has no useful\n   information to process the new flow, and sends Initialization
        and\n   Refresh (IR) packets.  Alternatively, the compressor may also support\n
        \  Context Replication (CR) and use IR-CR packets [RFC4164], which\n   attempts
        to reuse context information related to another flow.\n   The compressor can
        then adjust the compression level based on its\n   confidence that the decompressor
        has the necessary information to\n   successfully process the Compressed (CO)
        packets that it selects.  In\n   other words, the task of the compressor is
        to ensure that the\n   decompressor operates in the state that allows decompression
        of the\n   most efficient CO packet(s), and to allow the decompressor to move
        to\n   that state as soon as possible otherwise.\n"
      title: 4.2.1.  Compressor Operation
    - contents:
      - "4.2.2.  Decompressor Feedback\n   The ROHC-TCP profile can be used in environments
        with or without\n   feedback capabilities from decompressor to compressor.
        \ ROHC-TCP,\n   however, assumes that if a ROHC feedback channel is available
        and if\n   this channel is used at least once by the decompressor for a specific\n
        \  ROHC-TCP context, this channel will be used during the entire\n   compression
        operation for that context.  If the feedback channel\n   disappears, compression
        should be restarted.\n   The reception of either positive acknowledgments
        (ACKs) or negative\n   acknowledgments (NACKs) establishes the feedback channel
        from the\n   decompressor for the context for which the feedback was received.\n
        \  Once there is an established feedback channel for a specific context,\n
        \  the compressor should make use of this feedback to estimate the\n   current
        state of the decompressor.  This helps in increasing the\n   compression efficiency
        by providing the information needed for the\n   compressor to achieve the
        necessary confidence level.\n   The ROHC-TCP feedback mechanism is limited
        in its applicability by\n   the number of (least significant bit (LSB) encoded)
        master sequence\n   number (MSN) (see Section 6.1.1) bits used in the FEEDBACK-2
        format\n   (see Section 8.3).  It is not suitable for a decompressor to use\n
        \  feedback altogether where the MSN bits in the feedback could wrap\n   around
        within one round-trip time.  Instead, unidirectional operation\n   -- where
        the compressor periodically sends larger context-updating\n   packets -- is
        more appropriate.\n"
      title: 4.2.2.  Decompressor Feedback
    title: 4.2.  Compressor and Decompressor Interactions
  - contents:
    - "4.3.  Packet Formats and Encoding Methods\n   The packet formats and encoding
      methods used for ROHC-TCP are defined\n   using the formal notation [RFC4997].
      \ The formal notation is used to\n   provide an unambiguous representation of
      the packet formats and a\n   clear definition of the encoding methods.\n"
    - contents:
      - "4.3.1.  Compressing TCP Options\n   The TCP options in ROHC-TCP are compressed
        using a list compression\n   encoding that allows option content to be established
        so that TCP\n   options can be added to the context without having to send
        all TCP\n   options uncompressed.\n"
      title: 4.3.1.  Compressing TCP Options
    - contents:
      - "4.3.2.  Compressing Extension Headers\n   ROHC-TCP compresses the extension
        headers as listed in Section 3.2.\n   These headers are treated exactly as
        other headers and thus have a\n   static chain, a dynamic chain, an irregular
        chain, and a chain for\n   context replication (Section 6.2).\n   This means
        that headers appearing in or disappearing from the flow\n   being compressed
        will lead to changes to the static chain.  However,\n   the change pattern
        of extension headers is not deemed to impair\n   compression efficiency with
        respect to this design strategy.\n"
      title: 4.3.2.  Compressing Extension Headers
    title: 4.3.  Packet Formats and Encoding Methods
  - contents:
    - "4.4.  Expected Compression Ratios with ROHC-TCP\n   The following table illustrates
      typical compression ratios that can\n   be expected when using ROHC-TCP and
      IPHC [RFC2507].\n   The figures in the table assume that the compression context
      has\n   already been properly initialized.  For the TS option, the Timestamp\n
      \  is assumed to change with small values.  All TCP options include a\n   suitable
      number of No Operation (NOP) options [RFC0793] for padding\n   and/or alignment.
      \ Finally, in the examples for IPv4, a sequential\n   IP-ID behavior is assumed.\n
      \                            Total Header Size (octets)\n                              ROHC-TCP
      \         IPHC\n                     Unc.   DATA    ACK      DATA    ACK\n   IPv4+TCP+TS
      \      52       8      8        18     18\n   IPv4+TCP+TS       52       7      6
      \       16     16   (1)\n   IPv6+TCP+TS       72       8      7        18     18\n
      \  IPv6+TCP+no opt   60       6      5         6      6\n   IPv6+TCP+SACK     80
      \      -     15         -     80   (2)\n   IPv6+TCP+SACK     80       -      9
      \        -     26   (3)\n   (1) The payload size of the data stream is constant.\n
      \  (2) The SACK option appears in the header, but was not present\n       in
      the previous packet.  Two SACK blocks are assumed.\n   (3) The SACK option appears
      in the header, and was also present\n       in the previous packet (with different
      SACK blocks).\n       Two SACK blocks are assumed.\n   The table below illustrates
      the typical initial compression ratios\n   for ROHC-TCP and IPHC.  The data
      stream in the example is assumed to\n   be IPv4+TCP, with a sequential behavior
      for the IP-ID.  The following\n   options are assumed present in the SYN packet:
      TS, MSS, and WSCALE,\n   with an appropriate number of NOP options.\n                     Total
      Header Size (octets)\n                      Unc.   ROHC-TCP   IPHC\n   1st packet
      (SYN)   60      49        60\n   2nd packet         52      12        52\n   The
      figures in the table assume that the compressor has received an\n   acknowledgment
      from the decompressor before compressing the second\n   packet, which can be
      expected when feedback is used in ROHC-TCP.\n   This is because in the most
      common case, the TCP ACKs are expected to\n   take the same return path, and
      because TCP does not send more packets\n   until the TCP SYN packet has been
      acknowledged.\n"
    title: 4.4.  Expected Compression Ratios with ROHC-TCP
  title: 4.  Overview of the TCP/IP Profile (Informative)
- contents:
  - '5.  Compressor and Decompressor Logic (Normative)

    '
  - contents:
    - "5.1.  Context Initialization\n   The static context of ROHC-TCP flows can be
      initialized in either of\n   two ways:\n   1.  By using an IR packet as in Section
      7.1, where the profile number\n       is 0x06 and the static chain ends with
      the static part of a TCP\n       header.\n   2.  By replicating an existing
      context using the mechanism defined by\n       [RFC4164].  This is done with
      the IR-CR packet defined in\n       Section 7.2, where the profile number is
      0x06.\n"
    title: 5.1.  Context Initialization
  - contents:
    - '5.2.  Compressor Operation

      '
    - contents:
      - "5.2.1.  Compression Logic\n   The task of the compressor is to determine
        what data must be sent\n   when compressing a TCP/IP packet, so that the decompressor
        can\n   successfully reconstruct the original packet based on its current\n
        \  state.  The selection of the type of compressed header to send thus\n   depends
        on a number of factors, including:\n   o  The change behavior of header fields
        in the flow, e.g., conveying\n      the necessary information within the restrictions
        of the set of\n      available packet formats.\n   o  The compressor's level
        of confidence regarding decompressor state,\n      e.g., by selecting header
        formats updating the same type of\n      information for a number of consecutive
        packets or from the\n      reception of decompressor feedback (ACKs and/or
        NACKs).\n   o  Additional robustness required for the flow, e.g., periodic\n
        \     refreshes of static and dynamic information using IR and IR-DYN\n      packets
        when decompressor feedback is not expected.\n   The impact of these factors
        on the compressor's packet type selection\n   is described in more detail
        in the following subsections.\n   In this section, a \"higher compression
        state\" means that less data\n   will be sent in compressed packets, i.e.,
        smaller compressed headers\n   are used, while a lower compression state means
        that a larger amount\n   of data will be sent using larger compressed headers.\n"
      - contents:
        - "5.2.1.1.  Optimistic Approach\n   The optimistic approach is the principle
          by which a compressor sends\n   the same type of information for a number
          of packets (consecutively\n   or not) until it is fairly confident that
          the decompressor has\n   received the information.  The optimistic approach
          is useful to\n   ensure robustness when ROHC-TCP is used to compress packets
          over\n   lossy links.\n   Therefore, if field X in the uncompressed packet
          changes value, the\n   compressor MUST use a packet type that contains an
          encoding for field\n   X until it has gained confidence that the decompressor
          has received\n   at least one packet containing the new value for X.  The
          compressor\n   SHOULD choose a compressed format with the smallest header
          that can\n   convey the changes needed to fulfill the optimistic approach\n
          \  condition used.\n"
        title: 5.2.1.1.  Optimistic Approach
      - contents:
        - "5.2.1.2.  Periodic Context Refreshes\n   When the optimistic approach is
          used, there will always be a\n   possibility of decompression failures since
          the decompressor may not\n   have received sufficient information for correct
          decompression.\n   Therefore, until the decompressor has established a feedback
          channel,\n   the compressor SHOULD periodically move to a lower compression
          state\n   and send IR and/or IR-DYN packets.  These refreshes can be based
          on\n   timeouts, on the number of compressed packets sent for the flow,
          or\n   any other strategy specific to the implementation.  Once the feedback\n
          \  channel is established, the decompressor MAY stop performing periodic\n
          \  refreshes.\n"
        title: 5.2.1.2.  Periodic Context Refreshes
      title: 5.2.1.  Compression Logic
    - contents:
      - "5.2.2.  Feedback Logic\n   The semantics of feedback messages, acknowledgments
        (ACKs) and\n   negative acknowledgments (NACKs or STATIC-NACKs), are defined
        in\n   Section 5.2.4.1 of [RFC5795].\n"
      - contents:
        - "5.2.2.1.  Optional Acknowledgments (ACKs)\n   The compressor MAY use acknowledgment
          feedback (ACKs) to move to a\n   higher compression state.\n   Upon reception
          of an ACK for a context-updating packet, the\n   compressor obtains confidence
          that the decompressor has received the\n   acknowledged packet and that
          it has observed changes in the packet\n   flow up to the acknowledged packet.\n
          \  This functionality is optional, so a compressor MUST NOT expect to\n
          \  get such ACKs, even if a feedback channel is available and has been\n
          \  established for that flow.\n"
        title: 5.2.2.1.  Optional Acknowledgments (ACKs)
      - contents:
        - "5.2.2.2.  Negative Acknowledgments (NACKs)\n   The compressor uses feedback
          from the decompressor to move to a lower\n   compression state (NACKs).\n
          \  On reception of a NACK feedback, the compressor SHOULD:\n   o  assume
          that only the static part of the decompressor is valid, and\n   o  re-send
          all dynamic information (via an IR or IR-DYN packet) the\n      next time
          it compresses a packet for the indicated flow\n   unless it has confidence
          that information sent after the packet being\n   acknowledged already provides
          a suitable response to the NACK\n   feedback.  In addition, the compressor
          MAY use a CO packet carrying a\n   7-bit Cyclic Redundancy Check (CRC) if
          it can determine with enough\n   confidence what information provides a
          suitable response to the NACK\n   feedback.\n   On reception of a STATIC-NACK
          feedback, the compressor SHOULD:\n   o  assume that the decompressor has
          no valid context, and\n   o  re-send all static and all dynamic information
          (via an IR packet)\n      the next time it compresses a packet for the indicated
          flow\n   unless it has confidence that information sent after the packet
          that\n   is being acknowledged already provides a suitable response to the\n
          \  STATIC-NACK feedback.\n"
        title: 5.2.2.2.  Negative Acknowledgments (NACKs)
      title: 5.2.2.  Feedback Logic
    - contents:
      - "5.2.3.  Context Replication\n   A compressor MAY support context replication
        by implementing the\n   additional compression and feedback logic defined
        in [RFC4164].\n"
      title: 5.2.3.  Context Replication
    title: 5.2.  Compressor Operation
  - contents:
    - '5.3.  Decompressor Operation

      '
    - contents:
      - "5.3.1.  Decompressor States and Logic\n   The three states of the decompressor
        are No Context (NC), Static\n   Context (SC), and Full Context (FC).  The
        decompressor starts in its\n   lowest compression state, the NC state.  Successful
        decompression\n   will always move the decompressor to the FC state.  The
        decompressor\n   state machine normally never leaves the FC state once it
        has entered\n   this state; only repeated decompression failures will force
        the\n   decompressor to transit downwards to a lower state.\n   Below is the
        state machine for the decompressor.  Details of the\n   transitions between
        states and decompression logic are given in the\n   subsections following
        the figure.\n                                 Success\n                +-->------>------>------>------>------>--+\n
        \               |                                        |\n    No Static
        \  |            No Dynamic        Success   |    Success\n     +-->--+    |
        \            +-->--+      +--->----->---+    +-->--+\n     |     |    |             |
        \    |      |             |    |     |\n     |     v    |             |     v
        \     |             v    |     v\n   +-----------------+   +---------------------+
        \  +-------------------+\n   | No Context (NC) |   | Static Context (SC) |
        \  | Full Context (FC) |\n   +-----------------+   +---------------------+
        \  +-------------------+\n      ^                         |        ^                         |\n
        \     |  Static Context         |        | Context Damage Assumed  |\n      |
        \ Damage Assumed         |        |                         |\n      +-----<------<------<-----+
        \       +-----<------<------<-----+\n"
      - contents:
        - "5.3.1.1.  Reconstruction and Verification\n   When decompressing an IR
          or an IR-DYN packet, the decompressor MUST\n   validate the integrity of
          the received header using CRC-8 validation\n   [RFC5795].  If validation
          fails, the packet MUST NOT be delivered to\n   upper layers.\n   Upon receiving
          an IR-CR packet, the decompressor MUST perform the\n   actions as specified
          in [RFC4164].\n   When decompressing other packet types (e.g., CO packets),
          the\n   decompressor MUST validate the outcome of the decompression attempt\n
          \  using CRC verification [RFC5795].  If verification fails, a\n   decompressor
          implementation MAY attempt corrective or repair measures\n   on the packet,
          and the result of any attempt MUST be validated using\n   the CRC verification;
          otherwise, the packet MUST NOT be delivered to\n   upper layers.\n   When
          the CRC-8 validation or the CRC verification of the received\n   header
          is successful, the decompressor SHOULD update its context with\n   the information
          received in the current header; the decompressor then\n   passes the reconstructed
          packet to the system's network layer.\n   Otherwise, the decompressor context
          MUST NOT be updated.\n   If the received packet is older than the current
          reference packet,\n   e.g., based on the master sequence number (MSN) in
          the compressed\n   packet, the decompressor MAY refrain from updating the
          context using\n   the information received in the current packet, even if
          the\n   correctness of its header was successfully verified.\n"
        title: 5.3.1.1.  Reconstruction and Verification
      - contents:
        - "5.3.1.2.  Detecting Context Damage\n   All header formats carry a CRC and
          are context updating.  A packet\n   for which the CRC succeeds updates the
          reference values of all header\n   fields, either explicitly (from the information
          about a field carried\n   within the compressed header) or implicitly (fields
          that are inferred\n   from other fields).\n   The decompressor may assume
          that some or the entire context is\n   invalid, following one or more failures
          to validate or verify a\n   header using the CRC.  Because the decompressor
          cannot know the exact\n   reason(s) for a CRC failure or what field caused
          it, the validity of\n   the context hence does not refer to what exact context
          entry is\n   deemed valid or not.\n   Validity of the context rather relates
          to the detection of a problem\n   with the context.  The decompressor first
          assumes that the type of\n   information that most likely caused the failure(s)
          is the state that\n   normally changes for each packet, i.e., context damage
          of the dynamic\n   part of the context.  Upon repeated failures and unsuccessful\n
          \  repairs, the decompressor then assumes that the entire context,\n   including
          the static part, needs to be repaired, i.e., static context\n   damage.\n
          \  Context Damage Detection\n      The assumption of context damage means
          that the decompressor will\n      not attempt decompression of a CO header
          that carries a 3-bit CRC,\n      and only attempt decompression of IR, IR-DYN,
          or IR-CR headers or\n      CO headers protected by a CRC-7.\n   Static Context
          Damage Detection\n      The assumption of static context damage means that
          the\n      decompressor refrains from attempting decompression of any type
          of\n      header other than the IR header.\n   How these assumptions are
          made, i.e., how context damage is detected,\n   is open to implementations.
          \ It can be based on the residual error\n   rate, where a low error rate
          makes the decompressor assume damage\n   more often than on a high-rate
          link.\n   The decompressor implements these assumptions by selecting the
          type\n   of compressed header for which it may attempt decompression.  In\n
          \  other words, validity of the context refers to the ability of a\n   decompressor
          to attempt or not attempt decompression of specific\n   packet types.\n"
        title: 5.3.1.2.  Detecting Context Damage
      - contents:
        - "5.3.1.3.  No Context (NC) State\n   Initially, while working in the No
          Context (NC) state, the\n   decompressor has not yet successfully decompressed
          a packet.\n   Allowing decompression:\n      In the NC state, only packets
          carrying sufficient information on\n      the static fields (IR and IR-CR
          packets) can be decompressed;\n      otherwise, the packet MUST NOT be decompressed
          and MUST NOT be\n      delivered to upper layers.\n   Feedback logic:\n
          \     In the NC state, the decompressor should send a STATIC-NACK if a\n
          \     packet of a type other than IR is received, or if decompression of\n
          \     an IR packet has failed, subject to the feedback rate limitation\n
          \     as described in Section 5.3.2.\n   Once a packet has been validated
          and decompressed correctly, the\n   decompressor MUST transit to the FC
          state.\n"
        title: 5.3.1.3.  No Context (NC) State
      - contents:
        - "5.3.1.4.  Static Context (SC) State\n   When the decompressor is in the
          Static Context (SC) state, only the\n   static part of the decompressor
          context is valid.\n   From the SC state, the decompressor moves back to
          the NC state if\n   static context damage is detected.\n   Allowing decompression:\n
          \     In the SC state, packets carrying sufficient information on the\n
          \     dynamic fields covered by an 8-bit CRC (e.g., IR and IR-DYN) or CO\n
          \     packets covered by a 7-bit CRC can be decompressed; otherwise, the\n
          \     packet MUST NOT be decompressed and MUST NOT be delivered to upper\n
          \     layers.\n   Feedback logic:\n      In the SC state, the decompressor
          should send a STATIC-NACK if CRC\n      validation of an IR/IR-DYN/IR-CR
          fails and static context damage\n      is assumed.  If any other packet
          type is received, the\n      decompressor should send a NACK.  Both of the
          above cases are\n      subject to the feedback rate limitation as described
          in\n      Section 5.3.2.\n   Once a packet has been validated and decompressed
          correctly, the\n   decompressor MUST transit to the FC state.\n"
        title: 5.3.1.4.  Static Context (SC) State
      - contents:
        - "5.3.1.5.  Full Context (FC) State\n   In the Full Context (FC) state, both
          the static and the dynamic parts\n   of the decompressor context are valid.
          \ From the FC state, the\n   decompressor moves back to the SC state if
          context damage is\n   detected.\n   Allowing decompression:\n      In the
          FC state, decompression can be attempted regardless of the\n      type of
          packet received.\n   Feedback logic:\n      In the FC state, the decompressor
          should send a NACK if the\n      decompression of any packet type fails
          and context damage is\n      assumed, subject to the feedback rate limitation
          as described in\n      Section 5.3.2.\n"
        title: 5.3.1.5.  Full Context (FC) State
      title: 5.3.1.  Decompressor States and Logic
    - contents:
      - "5.3.2.  Feedback Logic\n   The decompressor MAY send positive feedback (ACKs)
        to initially\n   establish the feedback channel for a particular flow.  Either\n
        \  positive feedback (ACKs) or negative feedback (NACKs) establishes\n   this
        channel.\n   Once the feedback channel is established, the decompressor is\n
        \  REQUIRED to continue sending NACKs or STATIC-NACKs for as long as the\n
        \  context is associated with the same profile, in this case with\n   profile
        0x0006, as per the logic defined for each state in\n   Section 5.3.1.\n   The
        decompressor MAY send ACKs upon successful decompression of any\n   packet
        type.  In particular, when a packet carrying a significant\n   context update
        is correctly decompressed, the decompressor MAY send\n   an ACK.\n   The decompressor
        should limit the rate at which it sends feedback,\n   for both ACKs and STATIC-NACK/NACKs,
        and should avoid sending\n   unnecessary duplicates of the same type of feedback
        message that may\n   be associated to the same event.\n"
      title: 5.3.2.  Feedback Logic
    - contents:
      - "5.3.3.  Context Replication\n   ROHC-TCP supports context replication; therefore,
        the decompressor\n   MUST implement the additional decompressor and feedback
        logic defined\n   in [RFC4164].\n"
      title: 5.3.3.  Context Replication
    title: 5.3.  Decompressor Operation
  title: 5.  Compressor and Decompressor Logic (Normative)
- contents:
  - '6.  Encodings in ROHC-TCP (Normative)

    '
  - contents:
    - "6.1.  Control Fields in ROHC-TCP\n   In ROHC-TCP, a number of control fields
      are used by the decompressor\n   in its interpretation of the format of the
      packets received from the\n   compressor.\n   A control field is a field that
      is transmitted from the compressor to\n   the decompressor, but is not part
      of the uncompressed header.  Values\n   for control fields can be set up in
      the context of both the\n   compressor and the decompressor.  Once established
      at the\n   decompressor, the values of these fields should be kept until updated\n
      \  by another packet.\n"
    - contents:
      - "6.1.1.  Master Sequence Number (MSN)\n   There is no field in the TCP header
        that can act as the master\n   sequence number for TCP compression, as explained
        in [RFC4413],\n   Section 5.6.\n   To overcome this problem, ROHC-TCP introduces
        a control field called\n   the Master Sequence Number (MSN) field.  The MSN
        field is created at\n   the compressor, rather than using one of the fields
        already present\n   in the uncompressed header.  The compressor increments
        the value of\n   the MSN by one for each packet that it sends.\n   The MSN
        field has the following two functions:\n   1.  Differentiating between packets
        when sending feedback data.\n   2.  Inferring the value of incrementing fields
        such as the IP-ID.\n   The MSN field is present in every packet sent by the
        compressor.  The\n   MSN is LSB encoded within the CO packets, and the 16-bit
        MSN is sent\n   in full in IR/IR-DYN packets.  The decompressor always sends
        the MSN\n   as part of the feedback information.  The compressor can later
        use\n   the MSN to infer which packet the decompressor is acknowledging.\n
        \  When the MSN is initialized, it SHOULD be initialized to a random\n   value.
        \ The compressor should only initialize a new MSN for the\n   initial IR or
        IR-CR packet sent for a CID that corresponds to a\n   context that is not
        already associated with this profile.  In other\n   words, if the compressor
        reuses the same CID to compress many TCP\n   flows one after the other, the
        MSN is not reinitialized but rather\n   continues to increment monotonically.\n
        \  For context replication, the compressor does not use the MSN of the\n   base
        context when sending the IR-CR packet, unless the replication\n   process
        overwrites the base context (i.e., Base CID == CID).\n   Instead, the compressor
        uses the value of the MSN if it already\n   exists in the ROHC-TCP context
        being associated with the new flow\n   (CID); otherwise, the MSN is initialized
        to a new value.\n"
      title: 6.1.1.  Master Sequence Number (MSN)
    - contents:
      - "6.1.2.  IP-ID Behavior\n   The IP-ID field of the IPv4 header can have different
        change\n   patterns.  Conceptually, a compressor monitors changes in the value\n
        \  of the IP-ID field and selects encoding methods and packet formats\n   that
        are the closest match to the observed change pattern.\n   ROHC-TCP defines
        different types of compression techniques for the\n   IP-ID, to provide the
        flexibility to compress any of the behaviors it\n   may observe for this field:
        sequential in network byte order (NBO),\n   sequential byte-swapped, random
        (RND), or constant to a value of\n   zero.\n   The compressor monitors changes
        in the value of the IP-ID field for a\n   number of packets, to identify which
        one of the above listed\n   compression alternatives is the closest match
        to the observed change\n   pattern.  The compressor can then select packet
        formats and encoding\n   methods based on the identified field behavior.\n
        \  If more than one level of IP headers is present, ROHC-TCP can assign\n
        \  a sequential behavior (NBO or byte-swapped) only to the IP-ID of the\n
        \  innermost IP header.  This is because only this IP-ID can possibly\n   have
        a sufficiently close correlation with the MSN (see also\n   Section 6.1.1)
        to compress it as a sequentially changing field.\n   Therefore, a compressor
        MUST NOT assign either the sequential (NBO)\n   or the sequential byte-swapped
        behavior to tunneling headers.\n   The control field for the IP-ID behavior
        determines which set of\n   packet formats will be used.  These control fields
        are also used to\n   determine the contents of the irregular chain item (see
        Section 6.2)\n   for each IP header.\n"
      title: 6.1.2.  IP-ID Behavior
    - contents:
      - "6.1.3.  Explicit Congestion Notification (ECN)\n   When ECN [RFC3168] is
        used once on a flow, the ECN bits could change\n   quite often.  ROHC-TCP
        maintains a control field in the context to\n   indicate whether or not ECN
        is used.  This control field is\n   transmitted in the dynamic chain of the
        TCP header, and its value can\n   be updated using specific compressed headers
        carrying a 7-bit CRC.\n   When this control field indicates that ECN is being
        used, items of\n   all IP and TCP headers in the irregular chain include bits
        used for\n   ECN.  To preserve octet-alignment, all of the TCP reserved bits
        are\n   transmitted and, for outer IP headers, the entire Type of Service/\n
        \  Traffic Class (TOS/TC) field is included in the irregular chain.\n   When
        there is only one IP header present in the packet (i.e., no IP\n   tunneling
        is used), this compression behavior allows the compressor\n   to handle changes
        in the ECN bits by adding a single octet to the\n   compressed header.\n   The
        reason for including the ECN bits of all IP headers in the\n   compressed
        packet when the control field is set is that the profile\n   needs to efficiently
        compress flows containing IP tunnels using the\n   \"full-functionality option\"
        of Section 9.1 of [RFC3168].  For these\n   flows, a change in the ECN bits
        of an inner IP header is propagated\n   to the outer IP headers.  When the
        \"limited-functionality\" option is\n   used, the compressor will therefore
        sometimes send one octet more\n   than necessary per tunnel header, but this
        has been considered a\n   reasonable trade-off when designing this profile.\n"
      title: 6.1.3.  Explicit Congestion Notification (ECN)
    title: 6.1.  Control Fields in ROHC-TCP
  - contents:
    - "6.2.  Compressed Header Chains\n   Some packet types use one or more chains
      containing sub-header\n   information.  The function of a chain is to group
      fields based on\n   similar characteristics, such as static, dynamic, or irregular\n
      \  fields.  Chaining is done by appending an item for each header to the\n   chain
      in their order of appearance in the uncompressed packet,\n   starting from the
      fields in the outermost header.\n   Chains are defined for all headers compressed
      by ROHC-TCP, as listed\n   below.  Also listed are the names of the encoding
      methods used to\n   encode each of these protocol headers.\n   o  TCP [RFC0793],
      encoding method: \"tcp\"\n   o  IPv4 [RFC0791], encoding method: \"ipv4\"\n
      \  o  IPv6 [RFC2460], encoding method: \"ipv6\"\n   o  AH [RFC4302], encoding
      method: \"ah\"\n   o  GRE [RFC2784][RFC2890], encoding method: \"gre\"\n   o
      \ MINE [RFC2004], encoding method: \"mine\"\n   o  IPv6 Destination Options
      header [RFC2460], encoding method:\n      \"ip_dest_opt\"\n   o  IPv6 Hop-by-Hop
      Options header [RFC2460], encoding method:\n      \"ip_hop_opt\"\n   o  IPv6
      Routing header [RFC2460], encoding method: \"ip_rout_opt\"\n   Static chain:\n
      \     The static chain consists of one item for each header of the chain\n      of
      protocol headers to be compressed, starting from the outermost\n      IP header
      and ending with a TCP header.  In the formal description\n      of the packet
      formats, this static chain item for each header is a\n      format whose name
      is suffixed by \"_static\".  The static chain is\n      only used in IR packets.\n
      \  Dynamic chain:\n      The dynamic chain consists of one item for each header
      of the\n      chain of protocol headers to be compressed, starting from the\n
      \     outermost IP header and ending with a TCP header.  The dynamic\n      chain
      item for the TCP header also contains a compressed list of\n      TCP options
      (see Section 6.3).  In the formal description of the\n      packet formats,
      the dynamic chain item for each header type is a\n      format whose name is
      suffixed by \"_dynamic\".  The dynamic chain is\n      used in both IR and IR-DYN
      packets.\n   Replicate chain:\n      The replicate chain consists of one item
      for each header in the\n      chain of protocol headers to be compressed, starting
      from the\n      outermost IP header and ending with a TCP header.  The replicate\n
      \     chain item for the TCP header also contains a compressed list of\n      TCP
      options (see Section 6.3).  In the formal description of the\n      packet formats,
      the replicate chain item for each header type is a\n      format whose name
      is suffixed by \"_replicate\".  Header fields that\n      are not present in
      the replicate chain are replicated from the\n      base context.  The replicate
      chain is only used in the IR-CR\n      packet.\n   Irregular chain:\n      The
      structure of the irregular chain is analogous to the structure\n      of the
      static chain.  For each compressed packet, the irregular\n      chain is appended
      at the specified location in the general format\n      of the compressed packets
      as defined in Section 7.3.  This chain\n      also includes the irregular chain
      items for TCP options as defined\n      in Section 6.3.6, which are placed directly
      after the irregular\n      chain item of the TCP header, and in the same order
      as the options\n      appear in the uncompressed packet.  In the formal description
      of\n      the packet formats, the irregular chain item for each header type\n
      \     is a format whose name is suffixed by \"_irregular\".  The irregular\n
      \     chain is used only in CO packets.\n      The format of the irregular chain
      for the innermost IP header\n      differs from the format of outer IP headers,
      since this header is\n      part of the compressed base header.\n"
    title: 6.2.  Compressed Header Chains
  - contents:
    - "6.3.  Compressing TCP Options with List Compression\n   This section describes
      in detail how list compression is applied to\n   the TCP options.  In the definition
      of the packet formats for ROHC-\n   TCP, the most frequent TCP options have
      one encoding method each, as\n   listed in the table below.\n           +-----------------+------------------------+\n
      \          |   Option name   |  Encoding method name  |\n           +-----------------+------------------------+\n
      \          |      NOP        | tcp_opt_nop            |\n           |      EOL
      \       | tcp_opt_eol            |\n           |      MSS        | tcp_opt_mss
      \           |\n           |  WINDOW SCALE   | tcp_opt_wscale         |\n           |
      \  TIMESTAMP     | tcp_opt_ts             |\n           | SACK-PERMITTED  |
      tcp_opt_sack_permitted |\n           |      SACK       | tcp_opt_sack           |\n
      \          | Generic options | tcp_opt_generic        |\n           +-----------------+------------------------+\n
      \  Each of these encoding methods has an uncompressed format, a format\n   suffixed
      by \"_list_item\" and a format suffixed by \"_irregular\".  In\n   some cases,
      a single encoding method may have multiple \"_list_item\"\n   or \"_irregular\"
      formats, in which case bindings inside these formats\n   determine what format
      is used.  This is further described in the\n   following sections.\n"
    - contents:
      - "6.3.1.  List Compression\n   The TCP options in the uncompressed packet can
        be represented as an\n   ordered list, whose order and presence are usually
        constant between\n   packets.  The generic structure of such a list is as
        follows:\n            +--------+--------+--...--+--------+\n      list: |
        item 1 | item 2 |       | item n |\n            +--------+--------+--...--+--------+\n
        \  To compress this list, ROHC-TCP uses a list compression scheme, which\n
        \  compresses each of these items individually and combines them into a\n
        \  compressed list.\n   The basic principles of list-based compression are
        the following:\n      1) When a context is being initialized, a complete representation\n
        \     of the compressed list of options is transmitted.  All options\n      that
        have any content are present in the compressed list of items\n      sent by
        the compressor.\n   Then, once the context has been initialized:\n      2)
        When the structure AND the content of the list are unchanged,\n      no information
        about the list is sent in compressed headers.\n      3) When the structure
        of the list is constant, and when only the\n      content defined within the
        irregular format for one or more\n      options is changed, no information
        about the list needs to be sent\n      in compressed base headers; the irregular
        content is sent as part\n      of the irregular chain, as described in Section
        6.3.6.\n      4) When the structure of the list changes, a compressed list
        is\n      sent in the compressed base header, including a representation of\n
        \     its structure and order.  Content defined within the irregular\n      format
        of an option can still be sent as part of the irregular\n      chain (as described
        in Section 6.3.6), provided that the item\n      content is not part of the
        compressed list.\n"
      title: 6.3.1.  List Compression
    - contents:
      - "6.3.2.  Table-Based Item Compression\n   The table-based item compression
        compresses individual items sent in\n   compressed lists.  The compressor
        assigns a unique identifier,\n   \"Index\", to each item, \"Item\", of a list.\n
        \  Compressor Logic\n      The compressor conceptually maintains an item table
        containing all\n      items, indexed using \"Index\".  The (Index, Item) pair
        is sent\n      together in compressed lists until the compressor gains enough\n
        \     confidence that the decompressor has observed the mapping between\n
        \     items and their respective index.  Confidence is obtained from the\n
        \     reception of an acknowledgment from the decompressor, or by\n      sending
        (Index, Item) pairs using the optimistic approach.  Once\n      confidence
        is obtained, the index alone is sent in compressed\n      lists to indicate
        the presence of the item corresponding to this\n      index.\n      The compressor
        may reassign an existing index to a new item, by\n      re-establishing the
        mapping using the procedure described above.\n   Decompressor Logic\n      The
        decompressor conceptually maintains an item table that\n      contains all
        (Index, Item) pairs received.  The item table is\n      updated whenever an
        (Index, Item) pair is received and\n      decompression is successfully verified
        using the CRC.  The\n      decompressor retrieves the item from the table
        whenever an index\n      without an accompanying item is received.\n      If
        an index without an accompanying item is received and the\n      decompressor
        does not have any context for this index, the header\n      MUST be discarded
        and a NACK SHOULD be sent.\n"
      title: 6.3.2.  Table-Based Item Compression
    - contents:
      - "6.3.3.  Encoding of Compressed Lists\n   Each item present in a compressed
        list is represented by:\n   o  an index into the table of items\n   o  a presence
        bit indicating if a compressed representation of the\n      item is present
        in the list\n   o  an item (if the presence bit is set)\n   Decompression
        of an item will fail if the presence bit is not set and\n   the decompressor
        has no entry in the context for that item.\n   A compressed list of TCP options
        uses the following encoding:\n        0   1   2   3   4   5   6   7\n      +---+---+---+---+---+---+---+---+\n
        \     | Reserved  |PS |       m       |\n      +---+---+---+---+---+---+---+---+\n
        \     |        XI_1, ..., XI_m        | m octets, or m * 4 bits\n      /                ---
        --- --- ---/\n      |               :    Padding    : if PS = 0 and m is odd\n
        \     +---+---+---+---+---+---+---+---+\n      |                               |\n
        \     /      item_1, ..., item_n      / variable\n      |                               |\n
        \     +---+---+---+---+---+---+---+---+\n      Reserved: MUST be set to zero;
        otherwise, the decompressor MUST\n      discard the packet.\n      PS: Indicates
        size of XI fields:\n         PS = 0 indicates 4-bit XI fields;\n         PS
        = 1 indicates 8-bit XI fields.\n      m: Number of XI item(s) in the compressed
        list.\n      XI_1, ..., XI_m: m XI items.  Each XI represents one TCP option
        in\n      the uncompressed packet, in the same order as they appear in the\n
        \     uncompressed packet.\n         The format of an XI item is as follows:\n
        \                +---+---+---+---+\n         PS = 0: | X |   Index   |\n                 +---+---+---+---+\n
        \                  0   1   2   3   4   5   6   7\n                 +---+---+---+---+---+---+---+---+\n
        \        PS = 1: | X | Reserved  |     Index     |\n                 +---+---+---+---+---+---+---+---+\n
        \        X: Indicates whether the item is present in the list:\n            X
        = 1 indicates that the item corresponding to the Index is\n            sent
        in the item_1, ..., item_n list;\n            X = 0 indicates that the item
        corresponding to the Index is\n            not sent and is instead included
        in the irregular chain.\n         Reserved: MUST be set to zero; otherwise,
        the decompressor MUST\n         discard the packet.\n         Index: An index
        into the item table.  See Section 6.3.4.\n         When 4-bit XI items are
        used, the XI items are placed in octets\n         in the following manner:\n
        \          0   1   2   3   4   5   6   7\n         +---+---+---+---+---+---+---+---+\n
        \        |     XI_k      |    XI_k + 1   |\n         +---+---+---+---+---+---+---+---+\n
        \     Padding: A 4-bit padding field is present when PS = 0 and the\n      number
        of XIs is odd.  The Padding field MUST be set to zero;\n      otherwise, the
        decompressor MUST discard the packet.\n      Item 1, ..., item n: Each item
        corresponds to an XI with X = 1 in\n      XI 1, ..., XI m.  The format of
        the entries in the item list is\n      described in the table in Section 6.3.
        \ The compressed format(s)\n      suffixed by \"_list_item\" in the encoding
        methods defines the item\n      inside the compressed item list.\n"
      title: 6.3.3.  Encoding of Compressed Lists
    - contents:
      - "6.3.4.  Item Table Mappings\n   The item table for TCP options list compression
        is limited to 16\n   different items, since it is unlikely that any packet
        flow will\n   contain a larger number of unique options.\n   The mapping between
        the TCP option type and table indexes are listed\n   in the table below:\n
        \        +-----------------+---------------+\n         |   Option name   |
        \ Table index  |\n         +-----------------+---------------+\n         |
        \     NOP        |       0       |\n         |      EOL        |       1       |\n
        \        |      MSS        |       2       |\n         |  WINDOW SCALE   |
        \      3       |\n         |   TIMESTAMP     |       4       |\n         |
        SACK-PERMITTED  |       5       |\n         |      SACK       |       6       |\n
        \        | Generic options |      7-15     |\n         +-----------------+---------------+\n
        \  Some TCP options are used more frequently than others.  To simplify\n   their
        compression, a part of the item table is reserved for these\n   option types,
        as shown on the table above.  Both the compressor and\n   the decompressor
        MUST use these mappings between item and indexes to\n   (de)compress TCP options
        when using list compression.\n   It is expected that the option types for
        which an index is reserved\n   in the item table will only appear once in
        a list.  However, if an\n   option type is detected twice in the same options
        list and if both\n   options have a different content, the compressor should
        compress the\n   second occurrence of the option type by mapping it to a generic\n
        \  compressed option.  Otherwise, if the options have the exact same\n   content,
        the compressor can still use the same table index for both.\n   The NOP option\n
        \     The NOP option can appear more than once in the list.  However,\n      since
        its value is always the same, no context information needs\n      to be transmitted.
        \ Multiple NOP options can thus be mapped to the\n      same index.  Since
        the NOP option does not have any content when\n      compressed as a \"_list_item\",
        it will never be present in the item\n      list.  For consistency, the compressor
        should still establish an\n      entry in the list by setting the presence
        bit, as done for the\n      other type of options.\n      List compression
        always preserves the original order of each item\n      in the decompressed
        list, whether or not the item is present in\n      the compressed \"_list_item\"
        or if multiple items of the same type\n      can be mapped to the same index,
        as for the NOP option.\n   The EOL option\n      The size of the compressed
        format for the EOL option can be larger\n      than one octet, and it is defined
        so that it includes the option\n      padding.  This is because the EOL should
        terminate the parsing of\n      the options, but it can also be followed by
        padding octets that\n      all have the value zero.\n   The Generic option\n
        \     The Generic option can be used to compress any type of TCP option\n
        \     that does not have a reserved index in the item table.\n"
      title: 6.3.4.  Item Table Mappings
    - contents:
      - "6.3.5.  Compressed Lists in Dynamic Chain\n   A compressed list for TCP options
        that is part of the dynamic chain\n   (e.g., in IR or IR-DYN packets) must
        have all its list items present,\n   i.e., all X-bits in the XI list MUST
        be set.\n"
      title: 6.3.5.  Compressed Lists in Dynamic Chain
    - contents:
      - "6.3.6.  Irregular Chain Items for TCP Options\n   The \"_list_item\" represents
        the option inside the compressed item\n   list, and the \"_irregular\" format
        is used for the option fields that\n   are expected to change with each packet.
        \ When an item of the\n   specified type is present in the current context,
        these irregular\n   fields are present in each compressed packet, as part
        of the\n   irregular chain.  Since many of the TCP option types are not expected\n
        \  to change for the duration of a flow, many of the \"_irregular\"\n   formats
        are empty.\n   The irregular chain for TCP options is structured analogously
        to the\n   structure of the TCP options in the uncompressed packet.  If a\n
        \  compressed list is present in the compressed packet, then the\n   irregular
        chain for TCP options must not contain irregular items for\n   the list items
        that are transmitted inside the compressed list (i.e.,\n   items in the list
        that have the X-bit set in its XI).  The items that\n   are not present in
        the compressed list, but are present in the\n   uncompressed list, must have
        their respective irregular items present\n   in the irregular chain.\n"
      title: 6.3.6.  Irregular Chain Items for TCP Options
    - contents:
      - "6.3.7.  Replication of TCP Options\n   The entire table of TCP options items
        is always replicated when using\n   the IR-CR packet.  In the IR-CR packet,
        the list of options for the\n   new flow is also transmitted as a compressed
        list in the IR-CR\n   packet.\n"
      title: 6.3.7.  Replication of TCP Options
    title: 6.3.  Compressing TCP Options with List Compression
  - contents:
    - "6.4.  Profile-Specific Encoding Methods\n   This section defines encoding methods
      that are specific to this\n   profile.  These methods are used in the formal
      definition of the\n   packet formats in Section 8.\n"
    - contents:
      - "6.4.1.  inferred_ip_v4_header_checksum\n   This encoding method compresses
        the Header Checksum field of the IPv4\n   header.  This checksum is defined
        in [RFC0791] as follows:\n      Header Checksum: 16 bits\n         A checksum
        on the header only.  Since some header fields change\n         (e.g., time
        to live), this is recomputed and verified at each\n         point that the
        internet header is processed.\n      The checksum algorithm is:\n         The
        checksum field is the 16-bit one's complement of the one's\n         complement
        sum of all 16-bit words in the header.  For purposes\n         of computing
        the checksum, the value of the checksum field is\n         zero.\n   As described
        above, the header checksum protects individual hops from\n   processing a
        corrupted header.  When almost all IP header information\n   is compressed
        away, and when decompression is verified by a CRC\n   computed over the original
        header for every compressed packet, there\n   is no point in having this additional
        checksum; instead, it can be\n   recomputed at the decompressor side.\n   The
        \"inferred_ip_v4_header_checksum\" encoding method thus compresses\n   the
        IPv4 header checksum down to a size of zero bits.  Using this\n   encoding
        method, the decompressor infers the value of this field\n   using the computation
        above.\n   This encoding method implicitly assumes that the compressor will
        not\n   process a corrupted header; otherwise, it cannot guarantee that the\n
        \  checksum as recomputed by the decompressor will be bitwise identical\n
        \  to its original value before compression.\n"
      title: 6.4.1.  inferred_ip_v4_header_checksum
    - contents:
      - "6.4.2.  inferred_mine_header_checksum\n   This encoding method compresses
        the minimal encapsulation header\n   checksum.  This checksum is defined in
        [RFC2004] as follows:\n      Header Checksum\n         The 16-bit one's complement
        of the one's complement sum of all\n         16-bit words in the minimal forwarding
        header.  For purposes of\n         computing the checksum, the value of the
        checksum field is\n         zero.  The IP header and IP payload (after the
        minimal\n         forwarding header) are not included in this checksum\n         computation.\n
        \  The \"inferred_mine_header_checksum\" encoding method compresses the\n
        \  minimal encapsulation header checksum down to a size of zero bits,\n   i.e.,
        no bits are transmitted in compressed headers for this field.\n   Using this
        encoding method, the decompressor infers the value of this\n   field using
        the above computation.\n   The motivations and the assumptions for inferring
        this checksum are\n   similar to the ones explained above in Section 6.4.1.\n"
      title: 6.4.2.  inferred_mine_header_checksum
    - contents:
      - "6.4.3.  inferred_ip_v4_length\n   This encoding method compresses the Total
        Length field of the IPv4\n   header.  The Total Length field of the IPv4 header
        is defined in\n   [RFC0791] as follows:\n      Total Length: 16 bits\n         Total
        Length is the length of the datagram, measured in octets,\n         including
        internet header and data.  This field allows the\n         length of a datagram
        to be up to 65,535 octets.\n   The \"inferred_ip_v4_length\" encoding method
        compresses the IPv4 Total\n   Length field down to a size of zero bits.  Using
        this encoding\n   method, the decompressor infers the value of this field
        by counting\n   in octets the length of the entire packet after decompression.\n"
      title: 6.4.3.  inferred_ip_v4_length
    - contents:
      - "6.4.4.  inferred_ip_v6_length\n   This encoding method compresses the Payload
        Length field of the IPv6\n   header.  This length field is defined in [RFC2460]
        as follows:\n      Payload Length: 16-bit unsigned integer\n         Length
        of the IPv6 payload, i.e., the rest of the packet\n         following this
        IPv6 header, in octets.  (Note that any\n         extension headers present
        are considered part of the payload,\n         i.e., included in the length
        count.)\n   The \"inferred_ip_v6_length\" encoding method compresses the Payload\n
        \  Length field of the IPv6 header down to a size of zero bits.  Using\n   this
        encoding method, the decompressor infers the value of this field\n   by counting
        in octets the length of the entire packet after\n   decompression.\n"
      title: 6.4.4.  inferred_ip_v6_length
    - contents:
      - "6.4.5.  inferred_offset\n   This encoding method compresses the data offset
        field of the TCP\n   header.\n   The \"inferred_offset\" encoding method is
        used on the Data Offset\n   field of the TCP header.  This field is defined
        in [RFC0793] as:\n      Data Offset: 4 bits\n         The number of 32-bit
        words in the TCP header.  This indicates\n         where the data begins.
        \ The TCP header (even one including\n         options) is an integral number
        of 32 bits long.\n   The \"inferred_offset\" encoding method compresses the
        Data Offset\n   field of the TCP header down to a size of zero bits.  Using
        this\n   encoding method, the decompressor infers the value of this field
        by\n   first decompressing the TCP options list, and by then setting:\n              data
        offset = (options length / 4) + 5\n   The equation above uses integer arithmetic.\n"
      title: 6.4.5.  inferred_offset
    - contents:
      - "6.4.6.  baseheader_extension_headers\n   In CO packets (see Section 7.3),
        the innermost IP header and the TCP\n   header are combined to create a compressed
        base header.  In some\n   cases, the IP header will have a number of extension
        headers between\n   itself and the TCP header.\n   To remain formally correct,
        the base header must define some\n   representation of these extension headers,
        which is what this\n   encoding method is used for.  This encoding method
        skips over all the\n   extension headers and does not encode any of the fields.
        \ Changed\n   fields in these headers are encoded in the irregular chain.\n"
      title: 6.4.6.  baseheader_extension_headers
    - contents:
      - "6.4.7.  baseheader_outer_headers\n   This encoding method, as well as the
        baseheader_extension_headers\n   encoding method described above, is needed
        for the specification to\n   remain formally correct.  It is used in CO packets
        (see Section 7.3)\n   to describe tunneling IP headers and their respective
        extension\n   headers (i.e., all headers located before the innermost IP header).\n
        \  This encoding method skips over all the fields in these headers and\n   does
        not perform any encoding.  Changed fields in outer headers are\n   instead
        handled by the irregular chain.\n"
      title: 6.4.7.  baseheader_outer_headers
    - contents:
      - "6.4.8.  Scaled Encoding of Fields\n   Some header fields will exhibit a change
        pattern where the field\n   increases by a constant value or by multiples
        of the same value.\n   Examples of fields that may have this behavior are
        the TCP Sequence\n   Number and the TCP Acknowledgment Number.  For such fields,
        ROHC-TCP\n   provides the means to downscale the field value before applying
        LSB\n   encoding, which allows the compressor to transmit fewer bits.\n   To
        be able to use scaled encoding, the field is required to fulfill\n   the following
        equation:\n        unscaled_value = scaling_factor * scaled_value + residue\n
        \  To use the scaled encoding, the compressor must be confident that the\n
        \  decompressor has established values for the \"residue\" and the\n   \"scaling_factor\",
        so that it can correctly decompress the field when\n   only an LSB-encoded
        \"scaled_value\" is present in the compressed\n   packet.\n   Once the compressor
        is confident that the value of the scaling_factor\n   and the value of the
        residue have been established in the\n   decompressor, the compressor may
        send compressed packets using the\n   scaled representation of the field.
        \ The compressor MUST NOT use\n   scaled encoding with the value of the scaling_factor
        set to zero.\n   If the compressor detects that the value of the residue has
        changed,\n   or if the compressor uses a different value for the scaling factor,\n
        \  it MUST NOT use scaled encoding until it is confident that the\n   decompressor
        has received the new value(s) of these fields.\n   When the unscaled value
        of the field wraps around, the value of the\n   residue is likely to change,
        even if the scaling_factor remains\n   constant.  In such a case, the compressor
        must act in the same way as\n   for any other change in the residue.\n   The
        following subsections describe how the scaled encoding is applied\n   to specific
        fields in ROHC-TCP, in particular, how the scaling_factor\n   and residue
        values are established for the different fields.\n"
      - contents:
        - "6.4.8.1.  Scaled TCP Sequence Number Encoding\n   For some TCP flows, such
          as data transfers, the payload size will be\n   constant over periods of
          time.  For such flows, the TCP Sequence\n   Number is bound to increase
          by multiples of the payload size between\n   packets, which means that this
          field can be a suitable target for\n   scaled encoding.  When using this
          encoding, the payload size will be\n   used as the scaling factor (i.e.,
          as the value for scaling_factor) of\n   this encoding.  This means that
          the scaling factor does not need to\n   be explicitly transmitted, but is
          instead inferred from the length of\n   the payload in the compressed packet.\n
          \  Establishing scaling_factor:\n      The scaling factor is established
          by sending unscaled TCP Sequence\n      Number bits, so that the decompressor
          can infer the scaling_factor\n      from the payload size.\n   Establishing
          residue:\n      The residue is established identically as the scaling_factor,\n
          \     i.e., by sending unscaled TCP Sequence Number bits.\n   A detailed
          specification of how the TCP Sequence Number uses the\n   scaled encoding
          can be found in the definitions of the packet\n   formats, in Section 8.2.\n"
        title: 6.4.8.1.  Scaled TCP Sequence Number Encoding
      - contents:
        - "6.4.8.2.  Scaled Acknowledgment Number Encoding\n   Similar to the pattern
          exhibited by the TCP Sequence Number, the\n   expected increase in the TCP
          Acknowledgment Number is often constant\n   and is therefore suitable for
          scaled encoding.\n   For the TCP Acknowledgment Number, the scaling factor
          depends on the\n   size of packets flowing in the opposite direction; this
          information\n   might not be available to the compressor/decompressor pair.
          \ For this\n   reason, ROHC-TCP uses an explicitly transmitted scaling factor
          to\n   compress the TCP Acknowledgment Number.\n   Establishing scaling_factor:\n
          \     The scaling factor is established by explicitly transmitting the\n
          \     value of the scaling factor (called ack_stride in the formal\n      notation
          in Section 8.2) to the decompressor, using one of the\n      packet types
          that can carry this information.\n   Establishing residue:\n      The scaling
          residue is established by sending unscaled TCP\n      Acknowledgment Number
          bits, so that the decompressor can infer its\n      value from the unscaled
          value and the scaling factor (ack_stride).\n   A detailed specification
          of how the TCP Acknowledgment Number uses\n   the scaled encoding can be
          found in the definitions of the packet\n   formats, in Section 8.2.\n   The
          compressor MAY use the scaled acknowledgment number encoding;\n   what value
          it will use as the scaling factor is up to the compressor\n   implementation.
          \ In the case where there is a co-located decompressor\n   processing packets
          of the same TCP flow in the opposite direction,\n   the scaling factor for
          the sequence number used for that flow can be\n   used by the compressor
          to determine a suitable scaling factor for the\n   TCP Acknowledgment number
          for this flow.\n"
        title: 6.4.8.2.  Scaled Acknowledgment Number Encoding
      title: 6.4.8.  Scaled Encoding of Fields
    title: 6.4.  Profile-Specific Encoding Methods
  - contents:
    - "6.5.  Encoding Methods with External Parameters\n   A number of encoding methods
      in Section 8.2 have one or more\n   arguments for which the derivation of the
      parameter's value is\n   outside the scope of the ROHC-FN specification of the
      header formats.\n   This section lists the encoding methods together with a
      definition of\n   each of their parameters.\n   o  ipv6(is_innermost, ttl_irregular_chain_flag,
      ip_inner_ecn):\n         is_innermost: This Boolean flag is set to true when
      processing\n         the innermost IP header; otherwise, it is set to false.\n
      \        ttl_irregular_chain_flag: This parameter must be set to the\n         value
      that was used for the corresponding\n         \"ttl_irregular_chain_flag\" parameter
      of the \"co_baseheader\"\n         encoding method (as defined below) when extracting
      the\n         irregular chain for a compressed header; otherwise, it is set\n
      \        to zero and ignored for other types of chains.\n         ip_inner_ecn:
      This parameter is bound by the encoding method;\n         therefore, it should
      be undefined when calling this encoding\n         method.  This value is then
      used to bind the corresponding\n         parameter in the \"tcp\" encoding method,
      as its value is needed\n         when processing the irregular chain for TCP.
      \ See the\n         definition of the \"ip_inner_ecn\" parameter for the \"tcp\"\n
      \        encoding method below.\n   o  ipv4(is_innermost, ttl_irregular_chain_flag,
      ip_inner_ecn,\n      ip_id_behavior_value):\n         See definition of arguments
      for \"ipv6\" above.\n         ip_id_behavior_value: Set to a 2-bit integer value,
      using one\n         of the constants whose name begins with the prefix\n         IP_ID_BEHAVIOR_
      and as defined in Section 8.2.\n   o  tcp_opt_eol(nbits):\n         nbits: This
      parameter is set to the length of the padding data\n         located after the
      EOL option type octet to the end of the TCP\n         options in the uncompressed
      header.\n   o  tcp_opt_sack(ack_value):\n         ack_value: Set to the value
      of the Acknowledgment Number field\n         of the TCP header.\n   o  tcp(payload_size,
      ack_stride_value, ip_inner_ecn):\n         payload_size: Set to the length (in
      octets) of the payload\n         following the TCP header.\n         ack_stride_value:
      This parameter is the scaling factor used\n         when scaling the TCP Acknowledgment
      Number.  Its value is set\n         by the compressor implementation.  See Section
      6.4.8.2 for\n         recommendations on how to set this value.\n         ip_inner_ecn:
      This parameter binds with the value given to the\n         corresponding \"ip_inner_ecn\"
      parameter by the \"ipv4\" or the\n         \"ipv6\" encoding method when processing
      the innermost IP header\n         of this packet.  See also the definition of
      the \"ip_inner_ecn\"\n         parameter to the \"ipv6\" and \"ipv4\" encoding
      method above.\n   o  co_baseheader(payload_size, ack_stride_value,\n      ttl_irregular_chain_flag,
      ip_id_behavior_value):\n         payload_size: Set to the length (in octets)
      of the payload\n         following the TCP header.\n         ack_stride_value:
      This parameter is the scaling factor used\n         when scaling the TCP Acknowledgment
      Number.  Its value is set\n         by the compressor implementation.  See Section
      6.4.8.2 for\n         recommendations on how to set this value.\n         ttl_irregular_chain_flag:
      This parameter is set to one if the\n         TTL/Hop Limit of an outer header
      has changed compared to its\n         reference in the context; otherwise, it
      is set to zero.  The\n         value used for this parameter is also used for
      the\n         \"ttl_irregular_chain_flag\" argument for the \"ipv4\" and \"ipv6\"\n
      \        encoding methods when processing the irregular chain, as\n         defined
      above for the \"ipv6\" and \"ipv4\" encoding methods.\n         ip_id_behavior_value:
      Set to a 2-bit integer value, using one\n         of the constants whose name
      begins with the prefix\n         IP_ID_BEHAVIOR_ and as defined in Section 8.2.\n"
    title: 6.5.  Encoding Methods with External Parameters
  title: 6.  Encodings in ROHC-TCP (Normative)
- contents:
  - "7.  Packet Types (Normative)\n   ROHC-TCP uses three different packet types:
    the Initialization and\n   Refresh (IR) packet type, the Context Replication (IR-CR)
    packet\n   type, and the Compressed (CO) packet type.\n   Each packet type defines
    a number of packet formats: two packet\n   formats are defined for the IR type,
    one packet format is defined for\n   the IR-CR type, and two sets of eight base
    header formats are defined\n   for the CO type with one additional format that
    is common to both\n   sets.\n   The profile identifier for ROHC-TCP is 0x0006.\n"
  - contents:
    - "7.1.  Initialization and Refresh (IR) Packets\n   ROHC-TCP uses the basic structure
      of the ROHC IR and IR-DYN packets\n   as defined in [RFC5795] (Sections 5.2.2.1
      and 5.2.2.2, respectively).\n   Packet type: IR\n      This packet type communicates
      the static part and the dynamic part\n      of the context.\n      For the ROHC-TCP
      IR packet, the value of the x bit MUST be set to\n      one.  It has the following
      format, which corresponds to the\n      \"Header\" and \"Payload\" fields described
      in Section 5.2.1 of\n      [RFC5795]:\n        0   1   2   3   4   5   6   7\n
      \      --- --- --- --- --- --- --- ---\n      :        Add-CID octet          :
      if for small CIDs and (CID != 0)\n      +---+---+---+---+---+---+---+---+\n
      \     | 1   1   1   1   1   1   0   1 | IR type octet\n      +---+---+---+---+---+---+---+---+\n
      \     :                               :\n      /       0-2 octets of CID       /
      1-2 octets if for large CIDs\n      :                               :\n      +---+---+---+---+---+---+---+---+\n
      \     |         Profile = 0x06        | 1 octet\n      +---+---+---+---+---+---+---+---+\n
      \     |              CRC              | 1 octet\n      +---+---+---+---+---+---+---+---+\n
      \     |                               |\n      /         Static chain          /
      variable length\n      |                               |\n       - - - - - -
      - - - - - - - - - -\n      |                               |\n      /         Dynamic
      chain         / variable length\n      |                               |\n       -
      - - - - - - - - - - - - - - -\n      |                               |\n      /
      \           Payload            / variable length\n      |                               |\n
      \      - - - - - - - - - - - - - - - -\n      CRC: 8-bit CRC, computed according
      to Section 5.3.1.1 of\n      [RFC5795].  The CRC covers the entire IR header,
      thus excluding\n      payload, padding, and feedback, if any.\n      Static
      chain: See Section 6.2.\n      Dynamic chain: See Section 6.2.\n      Payload:
      The payload of the corresponding original packet, if any.\n      The payload
      consists of all data after the last octet of the TCP\n      header to the end
      of the uncompressed packet.  The presence of a\n      payload is inferred from
      the packet length.\n   Packet type: IR-DYN\n      This packet type communicates
      the dynamic part of the context.\n      The ROHC-TCP IR-DYN packet has the following
      format, which\n      corresponds to the \"Header\" and \"Payload\" fields described
      in\n      Section 5.2.1 of [RFC5795]:\n        0   1   2   3   4   5   6   7\n
      \      --- --- --- --- --- --- --- ---\n      :         Add-CID octet         :
      if for small CIDs and (CID != 0)\n      +---+---+---+---+---+---+---+---+\n
      \     | 1   1   1   1   1   0   0   0 | IR-DYN type octet\n      +---+---+---+---+---+---+---+---+\n
      \     :                               :\n      /       0-2 octets of CID       /
      1-2 octets if for large CIDs\n      :                               :\n      +---+---+---+---+---+---+---+---+\n
      \     |         Profile = 0x06        | 1 octet\n      +---+---+---+---+---+---+---+---+\n
      \     |              CRC              | 1 octet\n      +---+---+---+---+---+---+---+---+\n
      \     |                               |\n      /         Dynamic chain         /
      variable length\n      |                               |\n       - - - - - -
      - - - - - - - - - -\n      |                               |\n      /            Payload
      \           / variable length\n      |                               |\n       -
      - - - - - - - - - - - - - - -\n      CRC: 8-bit CRC, computed according to Section
      5.3.1.1 of\n      [RFC5795].  The CRC covers the entire IR-DYN header, thus\n
      \     excluding payload, padding, and feedback, if any.\n      Dynamic chain:
      See Section 6.2.\n      Payload: The payload of the corresponding original packet,
      if any.\n      The payload consists of all data after the last octet of the
      TCP\n      header to end of the uncompressed packet.  The presence of a\n      payload
      is inferred from the packet length.\n"
    title: 7.1.  Initialization and Refresh (IR) Packets
  - contents:
    - "7.2.  Context Replication (IR-CR) Packets\n   Context replication requires
      a dedicated IR packet format that\n   uniquely identifies the IR-CR packet for
      the ROHC-TCP profile.  This\n   section defines the profile-specific part of
      the IR-CR packet\n   [RFC4164].\n   Packet type: IR-CR\n      This packet type
      communicates a reference to a base context along\n      with the static and
      dynamic parts of the replicated context that\n      differs from the base context.\n
      \  The ROHC-TCP IR-CR packet follows the general format of the ROHC\n   IR-CR
      packet, as defined in [RFC4164], Section 3.5.2.  With\n   consideration to the
      extensibility of the IR packet type defined in\n   [RFC5795], the ROHC-TCP profile
      supports context replication through\n   the profile-specific part of the IR
      packet.  This is achieved using\n   the bit (x) left in the IR header for \"Profile
      specific information\".\n   For ROHC-TCP, this bit is defined as a flag indicating
      whether this\n   packet is an IR packet or an IR-CR packet.  For the ROHC-TCP
      IR-CR\n   packet, the value of the x bit MUST be set to zero.\n   The ROHC-TCP
      IR-CR has the following format, which corresponds to the\n   \"Header\" and
      \"Payload\" fields described in Section 5.2.1 of\n   [RFC5795]:\n        0   1
      \  2   3   4   5   6   7\n       --- --- --- --- --- --- --- ---\n      :         Add-CID
      octet         : if for small CIDs and (CID != 0)\n      +---+---+---+---+---+---+---+---+\n
      \     | 1   1   1   1   1   1   0   0 | IR-CR type octet\n      +---+---+---+---+---+---+---+---+\n
      \     :                               :\n      /       0-2 octets of CID       /
      1-2 octets if for large CIDs\n      :                               :\n      +---+---+---+---+---+---+---+---+\n
      \     |         Profile = 0x06        | 1 octet\n      +---+---+---+---+---+---+---+---+\n
      \     |              CRC              | 1 octet\n      +---+---+---+---+---+---+---+---+\n
      \     | B |             CRC7          | 1 octet\n      +---+---+---+---+---+---+---+---+\n
      \     :   Reserved    |   Base CID    : 1 octet, for small CID, if B=1\n      +---+---+---+---+---+---+---+---+\n
      \     :                               :\n      /           Base CID            /
      1-2 octets, for large CIDs,\n      :                               : if B=1\n
      \     +---+---+---+---+---+---+---+---+\n      |                               |\n
      \     /        Replicate chain        / variable length\n      |                               |\n
      \      - - - - - - - - - - - - - - - -\n      |                               |\n
      \     /            Payload            / variable length\n      |                               |\n
      \      - - - - - - - - - - - - - - - -\n      B: B = 1 indicates that the Base
      CID field is present.\n      CRC: This CRC covers the entire IR-CR header, thus
      excluding\n      payload, padding, and feedback, if any.  This 8-bit CRC is\n
      \     calculated according to Section 5.3.1.1 of [RFC5795].\n      CRC7: The
      CRC over the original, uncompressed, header.  Calculated\n      according to
      Section 3.5.1.1 of [RFC4164].\n      Reserved: MUST be set to zero; otherwise,
      the decompressor MUST\n      discard the packet.\n      Base CID: CID of base
      context.  Encoded according to [RFC4164],\n      Section 3.5.3.\n      Replicate
      chain: See Section 6.2.\n      Payload: The payload of the corresponding original
      packet, if any.\n      The presence of a payload is inferred from the packet
      length.\n"
    title: 7.2.  Context Replication (IR-CR) Packets
  - contents:
    - "7.3.  Compressed (CO) Packets\n   The ROHC-TCP CO packets communicate irregularities
      in the packet\n   header.  All CO packets carry a CRC and can update the context.\n
      \  The general format for a compressed TCP header is as follows, which\n   corresponds
      to the \"Header\" and \"Payload\" fields described in Section\n   5.2.1 of [RFC5795]:\n
      \        0   1   2   3   4   5   6   7\n        --- --- --- --- --- --- ---
      ---\n       :         Add-CID octet         :  if for small CIDs and CID 1-15\n
      \      +---+---+---+---+---+---+---+---+\n       |   First octet of base header
      \ |  (with type indication)\n       +---+---+---+---+---+---+---+---+\n       :
      \                              :\n       /   0, 1, or 2 octets of CID    /  1-2
      octets if large CIDs\n       :                               :\n       +---+---+---+---+---+---+---+---+\n
      \      /   Remainder of base header    /  variable number of octets\n       +---+---+---+---+---+---+---+---+\n
      \      :        Irregular chain        :\n       /   (including irregular chain
      \ /  variable\n       :    items for TCP options)     :\n        --- --- ---
      --- --- --- --- ---\n       |                               |\n       /            Payload
      \           / variable length\n       |                               |\n        -
      - - - - - - - - - - - - - - -\n      Base header: The complete set of base headers
      is defined in\n      Section 8.\n      Irregular chain: See Sections 6.2 and
      6.3.6.\n      Payload: The payload of the corresponding original packet, if
      any.\n      The presence of a payload is inferred from the packet length.\n"
    title: 7.3.  Compressed (CO) Packets
  title: 7.  Packet Types (Normative)
- contents:
  - "8.  Header Formats (Normative)\n   This section describes the set of compressed
    TCP/IP packet formats.\n   The normative description of the packet formats is
    given using the\n   formal notation for ROHC profiles defined in [RFC4997].  The
    formal\n   description of the packet formats specifies all of the information\n
    \  needed to compress and decompress a header relative to the context.\n   In
    particular, the notation provides a list of all the fields present\n   in the
    uncompressed and compressed TCP/IP headers, and defines how to\n   map from each
    uncompressed packet to its compressed equivalent and\n   vice versa.\n"
  - contents:
    - "8.1.  Design Rationale for Compressed Base Headers\n   The compressed header
      formats are defined as two separate sets: one\n   set for the packets where
      the innermost IP header contains a\n   sequential IP-ID (either network byte
      order or byte swapped), and one\n   set for the packets without sequential IP-ID
      (either random, zero, or\n   no IP-ID).\n   These two sets of header formats
      are referred to as the \"sequential\"\n   and the \"random\" set of header formats,
      respectively.\n   In addition, there is one compressed format that is common
      to both\n   sets of header formats and that can thus be used regardless of the\n
      \  type of IP-ID behavior.  This format can transmit rarely changing\n   fields
      and also send the frequently changing fields coded in variable\n   lengths.
      \ It can also change the value of control fields such as\n   IP-ID behavior
      and ECN behavior.\n   All compressed base headers contain a 3-bit CRC, unless
      they update\n   control fields such as \"ip_id_behavior\" or \"ecn_used\" that
      affect the\n   interpretation of subsequent headers.  Headers that can modify
      these\n   control fields carry a 7-bit CRC instead.\n   When discussing LSB-encoded
      fields below, \"p\" equals the\n   \"offset_param\" and \"k\" equals the \"num_lsbs_param\"
      in [RFC4997].\n   The encoding methods used in the compressed base headers are
      based on\n   the following design criteria:\n   o  MSN\n         Since the MSN
      is a number generated by the compressor, it only\n         needs to be large
      enough to ensure robust operation and to\n         accommodate a small amount
      of reordering [RFC4163].  Therefore,\n         each compressed base header has
      an MSN field that is LSB-\n         encoded with k=4 and p=4 to handle a reordering
      depth of up to\n         4 packets.  Additional guidance to improve robustness
      when\n         reordering is possible can be found in [RFC4224].\n   o  TCP
      Sequence Number\n         ROHC-TCP has the capability to handle bulk data transfers\n
      \        efficiently, for which the sequence number is expected to\n         increase
      by about 1460 octets (which can be represented by 11\n         bits).  For the
      compressed base headers to handle\n         retransmissions (i.e., negative
      delta to the sequence number),\n         the LSB interpretation interval has
      to handle negative offsets\n         about as large as positive offsets, which
      means that one more\n         bit is needed.\n         Also, for ROHC-TCP to
      be robust to losses, two additional bits\n         are added to the LSB encoding
      of the sequence number.  This\n         means that the base headers should contain
      at least 14 bits of\n         LSB-encoded sequence number when present.  According
      to the\n         logic above, the LSB offset value is set to be as large as
      the\n         positive offset, i.e., p = 2^(k-1)-1.\n   o  TCP Acknowledgment
      Number\n         The design criterion for the acknowledgment number is similar\n
      \        to that of the TCP Sequence Number.  However, often only every\n         other
      data packet is acknowledged, which means that the\n         expected delta value
      is twice as large as for sequence numbers.\n         Therefore, at least 15
      bits of acknowledgment number should be\n         used in compressed base headers.
      \ Since the acknowledgment\n         number is expected to constantly increase,
      and the only\n         exception to this is packet reordering (either on the
      ROHC\n         channel [RFC3759] or prior to the compression point), the\n         negative
      offset for LSB encoding is set to be 1/4 of the total\n         interval, i.e.,
      p = 2^(k-2)-1.\n   o  TCP Window\n         The TCP Window field is expected
      to increase in increments of\n         similar size as the TCP Sequence Number;
      therefore, the design\n         criterion for the TCP window is to send at least
      14 bits when\n         used.\n   o  IP-ID\n         For the \"sequential\" set
      of packet formats, all the compressed\n         base headers contain LSB-encoded
      IP-ID offset bits, where the\n         offset is the difference between the
      value of the MSN field and\n         the value of the IP-ID field.  The requirement
      is that at least\n         3 bits of IP-ID should always be present, but it
      is preferable\n         to use 4 to 7 bits.  When k=3 then p=1, and if k>3 then
      p=3\n         since the offset is expected to increase most of the time.\n   Each
      set of header formats contains eight different compressed base\n   headers.
      \ The reason for having this large number of header formats\n   is that the
      TCP Sequence Number, TCP Acknowledgment Number, and TCP\n   Window are frequently
      changing in a non-linear pattern.\n   The design of the header formats is derived
      from the field behavior\n   analysis found in [RFC4413].\n   All of the compressed
      base headers transmit LSB-encoded MSN bits, the\n   TCP Push flag, and a CRC,
      and in addition to this, all the base\n   headers in the sequential packet format
      set contain LSB-encoded IP-ID\n   bits.\n   The following header formats exist
      in both the sequential and random\n   packet format sets:\n   o  Format 1: This
      header format carries changes to the TCP Sequence\n      Number and is expected
      to be used on the downstream of a data\n      transfer.\n   o  Format 2: This
      header format carries the TCP Sequence Number in\n      scaled form and is expected
      to be useful for the downstream of a\n      data transfer where the payload
      size is constant for multiple\n      packets.\n   o  Format 3: This header format
      carries changes in the TCP\n      Acknowledgment Number and is expected to be
      useful for the\n      acknowledgment direction of a data transfer.\n   o  Format
      4: This header format is similar to format 3, but carries a\n      scaled TCP
      Acknowledgment Number.\n   o  Format 5: This header format carries both the
      TCP Sequence Number\n      and the TCP Acknowledgment Number and is expected
      to be useful for\n      flows that send data in both directions.\n   o  Format
      6: This header format is similar to format 5, but carries\n      the TCP Sequence
      Number in scaled form, when the payload size is\n      static for certain intervals
      in a data flow.\n   o  Format 7: This header format carries changes to both
      the TCP\n      Acknowledgment Number and the TCP Window and is expected to be\n
      \     useful for the acknowledgment flows of data connections.\n   o  Format
      8: This header format is used to convey changes to some of\n      the more seldom
      changing fields in the TCP flow, such as ECN\n      behavior, RST/SYN/FIN flags,
      the TTL/Hop Limit, and the TCP\n      options list.  This format carries a 7-bit
      CRC, since it can\n      change the structure of the contents of the irregular
      chain for\n      subsequent packets.  Note that this can be seen as a reduced
      form\n      of the common packet format.\n   o  Common header format: The common
      header format can be used for all\n      kinds of IP-ID behavior and should
      be useful when some of the more\n      rarely changing fields in the IP or TCP
      header change.  Since this\n      header format can update control fields that
      decide how the\n      decompressor interprets packets, it carries a 7-bit CRC
      to reduce\n      the probability of context corruption.  This header can basically\n
      \     convey changes to any of the dynamic fields in the IP and TCP\n      headers,
      and it uses a large set of flags to provide information\n      about which fields
      are present in the header format.\n"
    title: 8.1.  Design Rationale for Compressed Base Headers
  - contents:
    - '8.2.  Formal Definition of Header Formats

      '
    - '// NOTE: The irregular, static, and dynamic chains (see Section 6.2)

      '
    - '// are defined across multiple encoding methods and are embodied

      '
    - '// in the correspondingly named formats within those encoding

      '
    - '// methods.  In particular, note that the static and dynamic

      '
    - '// chains ordinarily go together.  The uncompressed fields are

      '
    - '// defined across these two formats combined, rather than in one

      '
    - '// or the other of them.  The irregular chain items are likewise

      '
    - '// combined with a baseheader format.

      '
    - '////////////////////////////////////////////

      '
    - '// Constants

      '
    - '////////////////////////////////////////////

      '
    - 'IP_ID_BEHAVIOR_SEQUENTIAL = 0;

      '
    - 'IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED = 1;

      '
    - 'IP_ID_BEHAVIOR_RANDOM = 2;

      '
    - 'IP_ID_BEHAVIOR_ZERO = 3;

      '
    - '////////////////////////////////////////////

      '
    - '// Global control fields

      '
    - '////////////////////////////////////////////

      '
    - "CONTROL {\n  ecn_used            [ 1 ];\n  msn                 [ 16 ];\n  //
      ip_id fields are for innermost IP header only\n  ip_id_offset                               [
      16 ];\n  ip_id_behavior_innermost                   [  2 ];\n  // ACK-related\n
      \ ack_stride                                 [ 32 ];\n  ack_number_scaled                          [
      32 ];\n  ack_number_residue                         [ 32 ];\n  seq_number_scaled
      \                         [ 32 ];\n  seq_number_residue                         [
      32 ];\n"
    - '}

      '
    - '///////////////////////////////////////////////

      '
    - '// Encoding methods not specified in FN syntax

      '
    - '///////////////////////////////////////////////

      '
    - 'list_tcp_options               "defined in Section 6.3.3";

      '
    - 'inferred_ip_v4_header_checksum "defined in Section 6.4.1";

      '
    - 'inferred_mine_header_checksum  "defined in Section 6.4.2";

      '
    - 'inferred_ip_v4_length          "defined in Section 6.4.3";

      '
    - 'inferred_ip_v6_length          "defined in Section 6.4.4";

      '
    - 'inferred_offset                "defined in Section 6.4.5";

      '
    - 'baseheader_extension_headers   "defined in Section 6.4.6";

      '
    - 'baseheader_outer_headers       "defined in Section 6.4.7";

      '
    - '////////////////////////////////////////////

      '
    - '// General encoding methods

      '
    - '////////////////////////////////////////////

      '
    - 'static_or_irreg(flag, width)

      '
    - "{\n  UNCOMPRESSED {\n    field [ width ];\n  }\n  COMPRESSED irreg_enc {\n
      \   field =:= irregular(width) [ width ];\n    ENFORCE(flag == 1);\n  }\n  COMPRESSED
      static_enc {\n    field =:= static [ 0 ];\n    ENFORCE(flag == 0);\n  }\n"
    - '}

      '
    - 'zero_or_irreg(flag, width)

      '
    - "{\n  UNCOMPRESSED {\n    field [ width ];\n  }\n  COMPRESSED non_zero {\n    field
      =:= irregular(width) [ width ];\n    ENFORCE(flag == 0);\n  }\n  COMPRESSED
      zero {\n    field =:= uncompressed_value(width, 0) [ 0 ];\n    ENFORCE(flag
      == 1);\n  }\n"
    - '}

      '
    - 'variable_length_32_enc(flag)

      '
    - "{\n  UNCOMPRESSED {\n    field [ 32 ];\n  }\n  COMPRESSED not_present {\n    field
      =:= static [ 0 ];\n    ENFORCE(flag == 0);\n  }\n  COMPRESSED lsb_8_bit {\n
      \   field =:= lsb(8, 63) [ 8 ];\n    ENFORCE(flag == 1);\n  }\n  COMPRESSED
      lsb_16_bit {\n    field =:= lsb(16, 16383) [ 16 ];\n    ENFORCE(flag == 2);\n
      \ }\n  COMPRESSED irreg_32_bit {\n    field =:= irregular(32) [ 32 ];\n    ENFORCE(flag
      == 3);\n  }\n"
    - '}

      '
    - 'optional32(flag)

      '
    - "{\n  UNCOMPRESSED {\n    item [ 0, 32 ];\n  }\n  COMPRESSED present {\n    item
      =:= irregular(32) [ 32 ];\n    ENFORCE(flag == 1);\n  }\n  COMPRESSED not_present
      {\n    item =:= compressed_value(0, 0) [ 0 ];\n    ENFORCE(flag == 0);\n  }\n"
    - '}

      '
    - 'lsb_7_or_31

      '
    - "{\n  UNCOMPRESSED {\n    item [ 32 ];\n  }\n  COMPRESSED lsb_7 {\n    discriminator
      =:= '0'       [ 1 ];\n    item          =:= lsb(7, 8) [ 7 ];\n  }\n  COMPRESSED
      lsb_31 {\n    discriminator =:= '1'          [ 1 ];\n    item          =:= lsb(31,
      256) [ 31 ];\n  }\n"
    - '}

      '
    - 'opt_lsb_7_or_31(flag)

      '
    - "{\n  UNCOMPRESSED {\n    item [ 0, 32 ];\n  }\n  COMPRESSED present {\n    item
      =:= lsb_7_or_31 [ 8, 32 ];\n    ENFORCE(flag == 1);\n  }\n  COMPRESSED not_present
      {\n    item =:= compressed_value(0, 0) [ 0 ];\n    ENFORCE(flag == 0);\n  }\n"
    - '}

      '
    - 'crc3(data_value, data_length)

      '
    - "{\n  UNCOMPRESSED {\n  }\n  COMPRESSED {\n    crc_value =:=\n      crc(3, 0x06,
      0x07, data_value, data_length) [ 3 ];\n  }\n"
    - '}

      '
    - 'crc7(data_value, data_length)

      '
    - "{\n  UNCOMPRESSED {\n  }\n  COMPRESSED {\n    crc_value =:=\n      crc(7, 0x79,
      0x7f, data_value, data_length) [ 7 ];\n  }\n"
    - '}

      '
    - 'one_bit_choice

      '
    - "{\n  UNCOMPRESSED {\n    field [ 1 ];\n  }\n  COMPRESSED zero {\n    field
      [ 1 ];\n    ENFORCE(field.UVALUE == 0);\n  }\n  COMPRESSED nonzero {\n    field
      [ 1 ];\n    ENFORCE(field.UVALUE == 1);\n  }\n"
    - '}

      '
    - '// Encoding method for updating a scaled field and its associated

      '
    - '// control fields.  Should be used both when the value is scaled

      '
    - '// or unscaled in a compressed format.

      '
    - '// Does not have an uncompressed side.

      '
    - 'field_scaling(stride_value, scaled_value, unscaled_value, residue_value)

      '
    - "{\n  UNCOMPRESSED {\n    // Nothing\n  }\n  COMPRESSED no_scaling {\n    ENFORCE(stride_value
      == 0);\n    ENFORCE(residue_value == unscaled_value);\n    ENFORCE(scaled_value
      == 0);\n  }\n  COMPRESSED scaling_used {\n    ENFORCE(stride_value != 0);\n
      \   ENFORCE(residue_value == (unscaled_value % stride_value));\n    ENFORCE(unscaled_value
      ==\n            scaled_value * stride_value + residue_value);\n  }\n"
    - '}

      '
    - '////////////////////////////////////////////

      '
    - '// IPv6 Destination options header

      '
    - '////////////////////////////////////////////

      '
    - 'ip_dest_opt

      '
    - "{\n  UNCOMPRESSED {\n    next_header [ 8 ];\n    length      [ 8 ];\n    value
      \      [ length.UVALUE * 64 + 48 ];\n  }\n  DEFAULT {\n    length      =:= static;\n
      \   next_header =:= static;\n    value       =:= static;\n  }\n  COMPRESSED
      dest_opt_static {\n    next_header =:= irregular(8) [ 8 ];\n    length      =:=
      irregular(8) [ 8 ];\n  }\n  COMPRESSED dest_opt_dynamic {\n    value =:=\n      irregular(length.UVALUE
      * 64 + 48) [ length.UVALUE * 64 + 48 ];\n  }\n  COMPRESSED dest_opt_0_replicate
      {\n    discriminator =:= '00000000' [ 8 ];\n  }\n  COMPRESSED dest_opt_1_replicate
      {\n    discriminator =:= '10000000'                     [ 8 ];\n    length        =:=
      irregular(8)                   [ 8 ];\n    value         =:=\n      irregular(length.UVALUE*64+48)
      [ length.UVALUE * 64 + 48 ];\n  }\n  COMPRESSED dest_opt_irregular {\n  }\n"
    - '}

      '
    - '////////////////////////////////////////////

      '
    - '// IPv6 Hop-by-Hop options header

      '
    - '////////////////////////////////////////////

      '
    - 'ip_hop_opt

      '
    - "{\n  UNCOMPRESSED {\n    next_header [ 8 ];\n    length      [ 8 ];\n    value
      \      [ length.UVALUE * 64 + 48 ];\n  }\n  DEFAULT {\n    length      =:= static;\n
      \   next_header =:= static;\n    value       =:= static;\n  }\n  COMPRESSED
      hop_opt_static {\n    next_header =:= irregular(8) [ 8 ];\n    length      =:=
      irregular(8) [ 8 ];\n  }\n  COMPRESSED hop_opt_dynamic {\n    value =:=\n      irregular(length.UVALUE*64+48)
      [ length.UVALUE * 64 + 48 ];\n  }\n  COMPRESSED hop_opt_0_replicate {\n    discriminator
      =:= '00000000' [ 8 ];\n  }\n  COMPRESSED hop_opt_1_replicate {\n    discriminator
      =:= '10000000'                     [ 8 ];\n    length        =:= irregular(8)
      \                  [ 8 ];\n    value         =:=\n      irregular(length.UVALUE*64+48)
      [ length.UVALUE * 64 + 48 ];\n  }\n  COMPRESSED hop_opt_irregular {\n  }\n"
    - '}

      '
    - '////////////////////////////////////////////

      '
    - '// IPv6 Routing header

      '
    - '////////////////////////////////////////////

      '
    - 'ip_rout_opt

      '
    - "{\n  UNCOMPRESSED {\n    next_header [ 8 ];\n    length      [ 8 ];\n    value
      \      [ length.UVALUE * 64 + 48 ];\n  }\n  DEFAULT {\n    length      =:= static;\n
      \   next_header =:= static;\n    value       =:= static;\n  }\n  COMPRESSED
      rout_opt_static {\n    next_header =:= irregular(8)                   [ 8 ];\n
      \   length      =:= irregular(8)                   [ 8 ];\n    value       =:=\n
      \     irregular(length.UVALUE*64+48) [ length.UVALUE * 64 + 48 ];\n  }\n  COMPRESSED
      rout_opt_dynamic {\n  }\n  COMPRESSED rout_opt_0_replicate {\n    discriminator
      =:= '00000000' [ 8 ];\n  }\n  COMPRESSED rout_opt_0_replicate {\n    discriminator
      =:= '10000000'                     [ 8 ];\n    length        =:= irregular(8)
      \                  [ 8 ];\n    value         =:=\n      irregular(length.UVALUE*64+48)
      [ length.UVALUE * 64 + 48 ];\n  }\n  COMPRESSED rout_opt_irregular {\n  }\n"
    - '}

      '
    - '////////////////////////////////////////////

      '
    - '// GRE Header

      '
    - '////////////////////////////////////////////

      '
    - 'optional_checksum(flag_value)

      '
    - "{\n  UNCOMPRESSED {\n    value     [ 0, 16 ];\n    reserved1 [ 0, 16 ];\n  }\n
      \ COMPRESSED cs_present {\n    value     =:= irregular(16)             [ 16
      ];\n    reserved1 =:= uncompressed_value(16, 0) [ 0 ];\n    ENFORCE(flag_value
      == 1);\n  }\n  COMPRESSED not_present {\n    value     =:= compressed_value(0,
      0) [ 0 ];\n    reserved1 =:= compressed_value(0, 0) [ 0 ];\n    ENFORCE(flag_value
      == 0);\n  }\n"
    - '}

      '
    - 'gre_proto

      '
    - "{\n  UNCOMPRESSED {\n    protocol [ 16 ];\n  }\n  COMPRESSED ether_v4 {\n    discriminator
      =:= compressed_value(1, 0)         [ 1 ];\n    protocol      =:= uncompressed_value(16,
      0x0800) [ 0 ];\n  }\n  COMPRESSED ether_v6 {\n    discriminator =:= compressed_value(1,
      1)         [ 1 ];\n    protocol      =:= uncompressed_value(16, 0x86DD) [ 0
      ];\n  }\n"
    - '}

      '
    - 'gre

      '
    - "{\n  UNCOMPRESSED {\n    c_flag                                 [ 1 ];\n    r_flag
      \   =:= uncompressed_value(1, 0) [ 1 ];\n    k_flag                                 [
      1 ];\n    s_flag                                 [ 1 ];\n    reserved0 =:= uncompressed_value(9,
      0) [ 9 ];\n    version   =:= uncompressed_value(3, 0) [ 3 ];\n    protocol                               [
      16 ];\n    checksum_and_res                       [ 0, 32 ];\n    key                                    [
      0, 32 ];\n    sequence_number                        [ 0, 32 ];\n  }\n  DEFAULT
      {\n    c_flag           =:= static;\n    k_flag           =:= static;\n    s_flag
      \          =:= static;\n    protocol         =:= static;\n    key              =:=
      static;\n    sequence_number  =:= static;\n  }\n  COMPRESSED gre_static {\n
      \   ENFORCE((c_flag.UVALUE == 1 && checksum_and_res.ULENGTH == 32)\n            ||
      checksum_and_res.ULENGTH == 0);\n    ENFORCE((s_flag.UVALUE == 1 && sequence_number.ULENGTH
      == 32)\n            || sequence_number.ULENGTH == 0);\n    protocol =:= gre_proto
      \                [ 1 ];\n    c_flag   =:= irregular(1)              [ 1 ];\n
      \   k_flag   =:= irregular(1)              [ 1 ];\n    s_flag   =:= irregular(1)
      \             [ 1 ];\n    padding  =:= compressed_value(4, 0)    [ 4 ];\n    key
      \     =:= optional32(k_flag.UVALUE) [ 0, 32 ];\n  }\n  COMPRESSED gre_dynamic
      {\n    checksum_and_res =:=\n      optional_checksum(c_flag.UVALUE)             [
      0, 16 ];\n    sequence_number  =:= optional32(s_flag.UVALUE) [ 0, 32 ];\n  }\n
      \ COMPRESSED gre_0_replicate {\n    discriminator    =:= '00000000'    [ 8 ];\n
      \   checksum_and_res =:=\n      optional_checksum(c_flag.UVALUE) [ 0, 16 ];\n
      \   sequence_number  =:=\n      optional32(s_flag.UVALUE)        [ 0, 8, 32
      ];\n  }\n  COMPRESSED gre_1_replicate {\n    discriminator    =:= '10000'                   [
      5 ];\n    c_flag           =:= irregular(1)              [ 1 ];\n    k_flag
      \          =:= irregular(1)              [ 1 ];\n    s_flag           =:= irregular(1)
      \             [ 1 ];\n    checksum_and_res =:=\n      optional_checksum(c_flag.UVALUE)
      \            [ 0, 16 ];\n    key              =:= optional32(k_flag.UVALUE)
      [ 0, 32 ];\n    sequence_number  =:= optional32(s_flag.UVALUE) [ 0, 32 ];\n
      \ }\n  COMPRESSED gre_irregular {\n    checksum_and_res =:=\n      optional_checksum(c_flag.UVALUE)
      [ 0, 16 ];\n    sequence_number  =:=\n      opt_lsb_7_or_31(s_flag.UVALUE)   [
      0, 8, 32 ];\n  }\n"
    - '}

      '
    - '/////////////////////////////////////////////

      '
    - '// MINE header

      '
    - '/////////////////////////////////////////////

      '
    - 'mine

      '
    - "{\n  UNCOMPRESSED {\n    next_header [ 8 ];\n    s_bit       [ 1 ];\n    res_bits
      \   [ 7 ];\n    checksum    [ 16 ];\n    orig_dest   [ 32 ];\n    orig_src    [
      0, 32 ];\n  }\n  DEFAULT {\n    next_header =:= static;\n    s_bit       =:=
      static;\n    res_bits    =:= static;\n    checksum    =:= inferred_mine_header_checksum;\n
      \   orig_dest   =:= static;\n    orig_src    =:= static;\n  }\n  COMPRESSED
      mine_static {\n    next_header =:= irregular(8)             [ 8 ];\n    s_bit
      \      =:= irregular(1)             [ 1 ];\n    // Reserved bits are included
      to achieve byte-alignment\n    res_bits    =:= irregular(7)             [ 7
      ];\n    orig_dest   =:= irregular(32)            [ 32 ];\n    orig_src    =:=
      optional32(s_bit.UVALUE) [ 0, 32 ];\n  }\n  COMPRESSED mine_dynamic {\n  }\n
      \ COMPRESSED mine_0_replicate {\n    discriminator =:= '00000000' [ 8 ];\n  }\n
      \ COMPRESSED mine_1_replicate {\n    discriminator =:= '10000000'               [
      8 ];\n    s_bit         =:= irregular(1)             [ 1 ];\n    res_bits      =:=
      irregular(7)             [ 7 ];\n    orig_dest     =:= irregular(32)            [
      32 ];\n    orig_src      =:= optional32(s_bit.UVALUE) [ 0, 32 ];\n  }\n  COMPRESSED
      mine_irregular {\n  }\n"
    - '}

      '
    - '/////////////////////////////////////////////

      '
    - '// Authentication Header (AH)

      '
    - '/////////////////////////////////////////////

      '
    - 'ah

      '
    - "{\n  UNCOMPRESSED {\n    next_header     [ 8 ];\n    length          [ 8 ];\n
      \   res_bits        [ 16 ];\n    spi             [ 32 ];\n    sequence_number
      [ 32 ];\n    icv             [ length.UVALUE*32-32 ];\n  }\n  DEFAULT {\n    next_header
      \    =:= static;\n    length          =:= static;\n    res_bits        =:= static;\n
      \   spi             =:= static;\n    sequence_number =:= static;\n  }\n  COMPRESSED
      ah_static {\n    next_header =:= irregular(8)  [ 8 ];\n    length      =:= irregular(8)
      \ [ 8 ];\n    spi         =:= irregular(32) [ 32 ];\n  }\n  COMPRESSED ah_dynamic
      {\n    res_bits        =:= irregular(16) [ 16 ];\n    sequence_number =:= irregular(32)
      [ 32 ];\n    icv       =:=\n      irregular(length.UVALUE*32-32)  [ length.UVALUE*32-32
      ];\n  }\n  COMPRESSED ah_0_replicate {\n    discriminator   =:= '00000000'    [
      8 ];\n    sequence_number =:= irregular(32) [ 32 ];\n    icv             =:=\n
      \     irregular(length.UVALUE*32-32)  [ length.UVALUE*32-32 ];\n  }\n  COMPRESSED
      ah_1_replicate {\n    discriminator   =:= '10000000'    [ 8 ];\n    length          =:=
      irregular(8)  [ 8 ];\n    res_bits        =:= irregular(16) [ 16 ];\n    spi
      \            =:= irregular(32) [ 32 ];\n    sequence_number =:= irregular(32)
      [ 32 ];\n    icv             =:=\n      irregular(length.UVALUE*32-32)  [ length.UVALUE*32-32
      ];\n  }\n  COMPRESSED ah_irregular {\n    sequence_number =:= lsb_7_or_31  [
      8, 32 ];\n    icv       =:=\n      irregular(length.UVALUE*32-32) [ length.UVALUE*32-32
      ];\n  }\n"
    - '}

      '
    - '/////////////////////////////////////////////

      '
    - '// IPv6 Header

      '
    - '/////////////////////////////////////////////

      '
    - 'fl_enc

      '
    - "{\n  UNCOMPRESSED {\n    flow_label [ 20 ];\n  }\n  COMPRESSED fl_zero {\n
      \   discriminator =:= '0'                       [ 1 ];\n    flow_label    =:=
      uncompressed_value(20, 0) [ 0 ];\n    reserved      =:= '0000'                    [
      4 ];\n  }\n  COMPRESSED fl_non_zero {\n    discriminator =:= '1'           [
      1 ];\n    flow_label    =:= irregular(20) [ 20 ];\n  }\n"
    - '}

      '
    - '// The is_innermost flag is true if this is the innermost IP header

      '
    - '// If extracting the irregular chain for a compressed packet:

      '
    - '//   - ttl_irregular_chain_flag must have the same value as it had when

      '
    - '//     processing co_baseheader.

      '
    - '//   - ip_inner_ecn is bound in this encoding method and the value that

      '
    - '//     it gets bound to should be passed to the tcp encoding method

      '
    - '//   For other formats than the irregular chain, these two are ignored

      '
    - 'ipv6(is_innermost, ttl_irregular_chain_flag, ip_inner_ecn)

      '
    - "{\n  UNCOMPRESSED {\n    version         =:= uncompressed_value(4, 6) [ 4 ];\n
      \   dscp                                         [ 6 ];\n    ip_ecn_flags                                 [
      2 ];\n    flow_label                                   [ 20 ];\n    payload_length
      \                              [ 16 ];\n    next_header                                  [
      8 ];\n    ttl_hopl                                     [ 8 ];\n    src_addr
      \                                    [ 128 ];\n    dst_addr                                     [
      128 ];\n  }\n  DEFAULT {\n    dscp           =:= static;\n    ip_ecn_flags   =:=
      static;\n    flow_label     =:= static;\n    payload_length =:= inferred_ip_v6_length;\n
      \   next_header    =:= static;\n    ttl_hopl       =:= static;\n    src_addr
      \      =:= static;\n    dst_addr       =:= static;\n  }\n  COMPRESSED ipv6_static
      {\n    version_flag =:= '1'            [ 1 ];\n    reserved     =:= '00'           [
      2 ];\n    flow_label   =:= fl_enc         [ 5, 21 ];\n    next_header  =:= irregular(8)
      \  [ 8 ];\n    src_addr     =:= irregular(128) [ 128 ];\n    dst_addr     =:=
      irregular(128) [ 128 ];\n  }\n  COMPRESSED ipv6_dynamic {\n    dscp         =:=
      irregular(6) [ 6 ];\n    ip_ecn_flags =:= irregular(2) [ 2 ];\n    ttl_hopl
      \    =:= irregular(8) [ 8 ];\n  }\n  COMPRESSED ipv6_replicate {\n    dscp         =:=
      irregular(6) [ 6 ];\n    ip_ecn_flags =:= irregular(2) [ 2 ];\n    reserved
      \    =:= '000'        [ 3 ];\n    flow_label   =:= fl_enc       [ 5, 21 ];\n
      \ }\n  COMPRESSED ipv6_outer_without_ttl_irregular {\n    dscp         =:= static_or_irreg(ecn_used.UVALUE,
      6) [ 0, 6 ];\n    ip_ecn_flags =:= static_or_irreg(ecn_used.UVALUE, 2) [ 0,
      2 ];\n    ENFORCE(ttl_irregular_chain_flag == 0);\n    ENFORCE(is_innermost
      == false);\n  }\n  COMPRESSED ipv6_outer_with_ttl_irregular {\n    dscp         =:=
      static_or_irreg(ecn_used.UVALUE, 6) [ 0, 6 ];\n    ip_ecn_flags =:= static_or_irreg(ecn_used.UVALUE,
      2) [ 0, 2 ];\n    ttl_hopl     =:= irregular(8)                        [ 8 ];\n
      \   ENFORCE(ttl_irregular_chain_flag == 1);\n    ENFORCE(is_innermost == false);\n
      \ }\n  COMPRESSED ipv6_innermost_irregular {\n    ENFORCE(ip_inner_ecn == ip_ecn_flags.UVALUE);\n
      \   ENFORCE(is_innermost == true);\n  }\n"
    - '}

      '
    - '/////////////////////////////////////////////

      '
    - '// IPv4 Header

      '
    - '/////////////////////////////////////////////

      '
    - 'ip_id_enc_dyn(behavior)

      '
    - "{\n  UNCOMPRESSED {\n    ip_id [ 16 ];\n  }\n  COMPRESSED ip_id_seq {\n    ENFORCE((behavior
      == IP_ID_BEHAVIOR_SEQUENTIAL) ||\n            (behavior == IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n
      \   ENFORCE(ip_id_offset.UVALUE == ip_id.UVALUE - msn.UVALUE);\n    ip_id =:=
      irregular(16) [ 16 ];\n  }\n  COMPRESSED ip_id_random {\n    ENFORCE(behavior
      == IP_ID_BEHAVIOR_RANDOM);\n    ip_id =:= irregular(16) [ 16 ];\n  }\n  COMPRESSED
      ip_id_zero {\n    ENFORCE(behavior == IP_ID_BEHAVIOR_ZERO);\n    ip_id =:= uncompressed_value(16,
      0) [ 0 ];\n  }\n"
    - '}

      '
    - 'ip_id_enc_irreg(behavior)

      '
    - "{\n  UNCOMPRESSED {\n    ip_id [ 16 ];\n  }\n  COMPRESSED ip_id_seq {\n    ENFORCE(behavior
      == IP_ID_BEHAVIOR_SEQUENTIAL);\n  }\n  COMPRESSED ip_id_seq_swapped {\n    ENFORCE(behavior
      == IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED);\n  }\n  COMPRESSED ip_id_rand {\n    ip_id
      =:= irregular(16) [ 16 ];\n    ENFORCE(behavior == IP_ID_BEHAVIOR_RANDOM);\n
      \ }\n  COMPRESSED ip_id_zero {\n    ip_id =:= uncompressed_value(16, 0) [ 0
      ];\n    ENFORCE(behavior == IP_ID_BEHAVIOR_ZERO);\n  }\n"
    - '}

      '
    - '// The is_innermost flag is true if this is the innermost IP header

      '
    - '// If extracting the irregular chain for a compressed packet:

      '
    - '//   - ttl_irregular_chain_flag must have the same value as it had when

      '
    - '//     processing co_baseheader.

      '
    - '//   - ip_inner_ecn is bound in this encoding method and the value that

      '
    - '//     it gets bound to should be passed to the tcp encoding method

      '
    - '//   For other formats than the irregular chain, these two are ignored

      '
    - "ipv4(is_innermost, ttl_irregular_chain_flag, ip_inner_ecn,\n     ip_id_behavior_value)\n"
    - "{\n  UNCOMPRESSED {\n    version        =:= uncompressed_value(4, 4)  [ 4 ];\n
      \   hdr_length     =:= uncompressed_value(4, 5)  [ 4 ];\n    dscp                                         [
      6 ];\n    ip_ecn_flags                                 [ 2 ];\n    length         =:=
      inferred_ip_v4_length     [ 16 ];\n    ip_id                                        [
      16 ];\n    rf             =:= uncompressed_value(1, 0)  [ 1 ];\n    df                                           [
      1 ];\n    mf             =:= uncompressed_value(1, 0)  [ 1 ];\n    frag_offset
      \   =:= uncompressed_value(13, 0) [ 13 ];\n    ttl_hopl                                     [
      8 ];\n    protocol                                     [ 8 ];\n    checksum
      \   =:= inferred_ip_v4_header_checksum [ 16 ];\n    src_addr                                     [
      32 ];\n    dst_addr                                     [ 32 ];\n  }\n  CONTROL
      {\n    ENFORCE(reorder_ratio.UVALUE == reorder_ratio_value);\n    ENFORCE(innermost_ip.UVALUE
      == is_innermost);\n    ip_id_behavior_outer [ 2 ];\n    innermost_ip [ 1 ];\n
      \ }\n  DEFAULT {\n    dscp           =:= static;\n    ip_ecn_flags   =:= static;\n
      \   df             =:= static;\n    ttl_hopl       =:= static;\n    protocol
      \      =:= static;\n    src_addr       =:= static;\n    dst_addr       =:= static;\n
      \   ip_id_behavior_outer =:= static;\n  }\n  COMPRESSED ipv4_static {\n    version_flag
      =:= '0'           [ 1 ];\n    reserved     =:= '0000000'     [ 7 ];\n    protocol
      \    =:= irregular(8)  [ 8 ];\n    src_addr     =:= irregular(32) [ 32 ];\n
      \   dst_addr     =:= irregular(32) [ 32 ];\n  }\n  COMPRESSED ipv4_innermost_dynamic
      {\n    ENFORCE(is_innermost == 1);\n    ENFORCE(ip_id_behavior_innermost.UVALUE
      == ip_id_behavior_value);\n    reserved       =:= '00000'             [ 5 ];\n
      \   df             =:= irregular(1)        [ 1 ];\n    ip_id_behavior_innermost
      =:= irregular(2) [ 2 ];\n    dscp           =:= irregular(6)        [ 6 ];\n
      \   ip_ecn_flags   =:= irregular(2)        [ 2 ];\n    ttl_hopl       =:= irregular(8)
      \       [ 8 ];\n    ip_id          =:=\n      ip_id_enc_dyn(ip_id_behavior_innermost.UVALUE)
      [ 0, 16 ];\n  }\n  COMPRESSED ipv4_outer_dynamic {\n    ENFORCE(is_innermost
      == 0);\n    ENFORCE(ip_id_behavior_outer.UVALUE == ip_id_behavior_value);\n
      \   reserved       =:= '00000'             [ 5 ];\n    df             =:= irregular(1)
      \       [ 1 ];\n    ip_id_behavior_outer =:=     irregular(2)              [
      2 ];\n    dscp           =:= irregular(6)        [ 6 ];\n    ip_ecn_flags   =:=
      irregular(2)        [ 2 ];\n    ttl_hopl       =:= irregular(8)        [ 8 ];\n
      \   ip_id          =:=\n      ip_id_enc_dyn(ip_id_behavior_outer.UVALUE) [ 0,
      16 ];\n  }\n  COMPRESSED ipv4_innermost_replicate {\n    ENFORCE(is_innermost
      == 1);\n    ENFORCE(ip_id_behavior_innermost.UVALUE == ip_id_behavior_value);\n
      \   reserved       =:= '0000'              [ 4 ];\n    ip_id_behavior_innermost
      =:= irregular(2) [ 2 ];\n    ttl_flag       =:= irregular(1)        [ 1 ];\n
      \   df             =:= irregular(1)        [ 1 ];\n    dscp           =:= irregular(6)
      \       [ 6 ];\n    ip_ecn_flags   =:= irregular(2)        [ 2 ];\n    ip_id
      \         =:=\n      ip_id_enc_dyn(ip_id_behavior_innermost.UVALUE) [ 0, 16
      ];\n    ttl_hopl     =:=\n        static_or_irreg(ttl_flag.UVALUE, 8) [ 0, 8
      ];\n  }\n  COMPRESSED ipv4_outer_replicate {\n    ENFORCE(is_innermost == 0);\n
      \   ENFORCE(ip_id_behavior_outer.UVALUE == ip_id_behavior_value);\n    reserved
      \      =:= '0000'              [ 4 ];\n    ip_id_behavior_outer =:= irregular(2)
      \ [ 2 ]\n    ttl_flag       =:= irregular(1)        [ 1 ];\n    df             =:=
      irregular(1)        [ 1 ];\n    dscp           =:= irregular(6)        [ 6 ];\n
      \   ip_ecn_flags   =:= irregular(2)        [ 2 ];\n    ip_id          =:=\n
      \     ip_id_enc_dyn(ip_id_behavior_outer.UVALUE) [ 0, 16 ];\n    ttl_hopl     =:=\n
      \       static_or_irreg(ttl_flag.UVALUE, 8) [ 0, 8 ];\n  }\n  COMPRESSED ipv4_outer_without_ttl_irregular
      {\n    ENFORCE(is_innermost == 0);\n    ip_id        =:=\n      ip_id_enc_irreg(ip_id_behavior_outer.UVALUE)
      [ 0, 16 ];\n    dscp         =:= static_or_irreg(ecn_used.UVALUE, 6) [ 0, 6
      ];\n    ip_ecn_flags =:= static_or_irreg(ecn_used.UVALUE, 2) [ 0, 2 ];\n    ENFORCE(ttl_irregular_chain_flag
      == 0);\n  }\n  COMPRESSED ipv4_outer_with_ttl_irregular {\n    ENFORCE(is_innermost
      == 0);\n    ip_id        =:=\n      ip_id_enc_irreg(ip_id_behavior_outer.UVALUE)
      \      [ 0, 16 ];\n    dscp         =:= static_or_irreg(ecn_used.UVALUE, 6)
      [ 0, 6 ];\n    ip_ecn_flags =:= static_or_irreg(ecn_used.UVALUE, 2) [ 0, 2 ];\n
      \   ttl_hopl     =:= irregular(8)                        [ 8 ];\n    ENFORCE(ttl_irregular_chain_flag
      == 1);\n  }\n  COMPRESSED ipv4_innermost_irregular {\n    ENFORCE(is_innermost
      == 1);\n    ip_id          =:=\n      ip_id_enc_irreg(ip_id_behavior_innermost.UVALUE)
      [ 0, 16 ];\n    ENFORCE(ip_inner_ecn == ip_ecn_flags.UVALUE);\n  }\n"
    - '}

      '
    - '/////////////////////////////////////////////

      '
    - '// TCP Options

      '
    - '/////////////////////////////////////////////

      '
    - '// nbits is bound to the remaining length (in bits) of TCP

      '
    - '// options, including the EOL type byte.

      '
    - 'tcp_opt_eol(nbits)

      '
    - "{\n  UNCOMPRESSED {\n    type     =:= uncompressed_value(8, 0) [ 8 ];\n    padding
      \ =:=\n      uncompressed_value(nbits-8, 0)      [ nbits-8 ];\n  }\n  CONTROL
      {\n    pad_len [ 8 ];\n  }\n  COMPRESSED eol_list_item {\n    pad_len =:= compressed_value(8,
      nbits-8) [ 8 ];\n  }\n  COMPRESSED eol_irregular {\n    pad_len =:= static;\n
      \   ENFORCE(nbits-8 == pad_len.UVALUE);\n  }\n"
    - '}

      '
    - 'tcp_opt_nop

      '
    - "{\n  UNCOMPRESSED {\n    type =:= uncompressed_value(8, 1) [ 8 ];\n  }\n  COMPRESSED
      nop_list_item {\n  }\n  COMPRESSED nop_irregular {\n  }\n"
    - '}

      '
    - 'tcp_opt_mss

      '
    - "{\n  UNCOMPRESSED {\n    type   =:= uncompressed_value(8, 2) [ 8 ];\n    length
      =:= uncompressed_value(8, 4) [ 8 ];\n    mss                                 [
      16 ];\n  }\n  COMPRESSED mss_list_item {\n    mss =:= irregular(16) [ 16 ];\n
      \ }\n  COMPRESSED mss_irregular {\n    mss    =:= static;\n  }\n"
    - '}

      '
    - 'tcp_opt_wscale

      '
    - "{\n  UNCOMPRESSED {\n    type   =:= uncompressed_value(8, 3) [ 8 ];\n    length
      =:= uncompressed_value(8, 3) [ 8 ];\n    wscale                              [
      8 ];\n  }\n  COMPRESSED wscale_list_item {\n    wscale =:= irregular(8) [ 8
      ];\n  }\n  COMPRESSED wscale_irregular {\n    wscale =:= static;\n  }\n"
    - '}

      '
    - 'ts_lsb

      '
    - "{\n  UNCOMPRESSED {\n    tsval [ 32 ];\n  }\n  COMPRESSED tsval_7 {\n    discriminator
      =:= '0'        [ 1 ];\n    tsval         =:= lsb(7, -1) [ 7 ];\n  }\n  COMPRESSED
      tsval_14 {\n    discriminator =:= '10'        [ 2 ];\n    tsval         =:=
      lsb(14, -1) [ 14 ];\n  }\n  COMPRESSED tsval_21 {\n    discriminator =:= '110'
      \              [ 3 ];\n    tsval         =:= lsb(21, 0x00040000) [ 21 ];\n  }\n
      \ COMPRESSED tsval_29 {\n    discriminator =:= '111'               [ 3 ];\n
      \   tsval         =:= lsb(29, 0x04000000) [ 29 ];\n  }\n"
    - '}

      '
    - 'tcp_opt_ts

      '
    - "{\n  UNCOMPRESSED {\n    type   =:= uncompressed_value(8, 8)  [ 8 ];\n    length
      =:= uncompressed_value(8, 10) [ 8 ];\n    tsval                                [
      32 ];\n    tsecho                               [ 32 ];\n  }\n  COMPRESSED tsopt_list_item
      {\n    tsval  =:= irregular(32) [ 32 ];\n    tsecho =:= irregular(32) [ 32 ];\n
      \ }\n  COMPRESSED tsopt_irregular {\n    tsval  =:= ts_lsb [ 8, 16, 24, 32 ];\n
      \   tsecho =:= ts_lsb [ 8, 16, 24, 32 ];\n  }\n"
    - '}

      '
    - 'sack_pure_lsb(base)

      '
    - "{\n  UNCOMPRESSED {\n    sack_field [ 32 ];\n  }\n  CONTROL {\n    ENFORCE(sack_field.CVALUE
      == (sack_field.UVALUE - base));\n  }\n  COMPRESSED lsb_15 {\n    ENFORCE(sack_field.CVALUE
      == sack_field.CVALUE <= 0x7fff);\n    discriminator =:= '0'           [ 1 ];\n
      \   sack_field                      [ 15 ];\n  }\n  COMPRESSED lsb_22 {\n    ENFORCE(sack_field.CVALUE
      == sack_field.CVALUE <= 0x3fffff);\n    discriminator =:= '10'          [ 2
      ];\n    sack_field                      [ 22 ];\n  }\n  COMPRESSED lsb_29 {\n
      \   ENFORCE(sack_field.CVALUE == sack_field.CVALUE <= 0x1fffffff);\n    discriminator
      =:= '110'         [ 3 ];\n    sack_field                      [ 29 ];\n  }\n
      \ COMPRESSED full_offset {\n    discriminator =:= '11111111'    [ 8 ];\n    sack_field
      \                     [ 32 ];\n  }\n"
    - '}

      '
    - 'sack_block(reference)

      '
    - "{\n  UNCOMPRESSED {\n    block_start [ 32 ];\n    block_end   [ 32 ];\n  }\n
      \ COMPRESSED {\n    block_start =:=\n      sack_pure_lsb(reference)          [
      16, 24, 32, 40 ];\n    block_end   =:=\n      sack_pure_lsb(block_start.UVALUE)
      [ 16, 24, 32, 40 ];\n  }\n"
    - '}

      '
    - '// The value of the parameter is set to the ack_number value

      '
    - '// of the TCP header

      '
    - 'tcp_opt_sack(ack_value)

      '
    - "{\n  UNCOMPRESSED {\n    type    =:= uncompressed_value(8, 5) [ 8 ];\n    length
      \                              [ 8 ];\n    block_1                              [
      64 ];\n    block_2                              [ 0, 64 ];\n    block_3                              [
      0, 64 ];\n    block_4                              [ 0, 64 ];\n  }\n  DEFAULT
      {\n    length  =:= static;\n    block_2 =:= uncompressed_value(0, 0);\n    block_3
      =:= uncompressed_value(0, 0);\n    block_4 =:= uncompressed_value(0, 0);\n  }\n
      \ COMPRESSED sack1_list_item {\n    discriminator =:= '00000001';\n    block_1
      \      =:= sack_block(ack_value);\n    ENFORCE(length.UVALUE == 10);\n  }\n
      \ COMPRESSED sack2_list_item {\n    discriminator =:= '00000010';\n    block_1
      \      =:= sack_block(ack_value);\n    block_2       =:= sack_block(block_1.UVALUE
      && 0xFFFFFFFF);\n    ENFORCE(length.UVALUE == 18);\n  }\n"
    - "COMPRESSED sack3_list_item {\n   discriminator =:= '00000011';\n   block_1
      \      =:= sack_block(ack_value);\n   block_2       =:= sack_block(block_1.UVALUE
      && 0xFFFFFFFF);\n   block_3       =:= sack_block(block_2.UVALUE && 0xFFFFFFFF);\n
      \  ENFORCE(length.UVALUE == 26);\n }\n COMPRESSED sack4_list_item {\n   discriminator
      =:= '00000100';\n   block_1       =:= sack_block(ack_value);\n   block_2       =:=
      sack_block(block_1.UVALUE && 0xFFFFFFFF);\n   block_3       =:= sack_block(block_2.UVALUE
      && 0xFFFFFFFF);\n   block_4       =:= sack_block(block_3.UVALUE && 0xFFFFFFFF);\n
      \  ENFORCE(length.UVALUE == 34);\n }\n  COMPRESSED sack_unchanged_irregular
      {\n    discriminator =:= '00000000';\n    block_1       =:= static;\n    block_2
      \      =:= static;\n    block_3       =:= static;\n    block_4       =:= static;\n
      \ }\n  COMPRESSED sack1_irregular {\n    discriminator =:= '00000001';\n    block_1
      \      =:= sack_block(ack_value);\n    ENFORCE(length.UVALUE == 10);\n  }\n
      COMPRESSED sack2_irregular {\n   discriminator =:= '00000010';\n   block_1       =:=
      sack_block(ack_value);\n   block_2       =:= sack_block(block_1.UVALUE && 0xFFFFFFFF);\n
      \  ENFORCE(length.UVALUE == 18);\n }\n COMPRESSED sack3_irregular {\n   discriminator
      =:= '00000011';\n   block_1       =:= sack_block(ack_value);\n   block_2       =:=
      sack_block(block_1.UVALUE && 0xFFFFFFFF);\n   block_3       =:= sack_block(block_1.UVALUE
      && 0xFFFFFFFF);\n   ENFORCE(length.UVALUE == 26);\n }\n COMPRESSED sack4_irregular
      {\n   discriminator =:= '00000100';\n   block_1       =:= sack_block(ack_value);\n
      \  block_2       =:= sack_block(block_1.UVALUE && 0xFFFFFFFF);\n   block_3       =:=
      sack_block(block_2.UVALUE && 0xFFFFFFFF);\n   block_4       =:= sack_block(block_3.UVALUE
      && 0xFFFFFFFF);\n   ENFORCE(length.UVALUE == 34);\n }\n"
    - '}

      '
    - 'tcp_opt_sack_permitted

      '
    - "{\n  UNCOMPRESSED {\n    type   =:= uncompressed_value(8, 4) [ 8 ];\n    length
      =:= uncompressed_value(8, 2) [ 8 ];\n  }\n  COMPRESSED sack_permitted_list_item
      {\n  }\n  COMPRESSED sack_permitted_irregular {\n  }\n"
    - '}

      '
    - 'tcp_opt_generic

      '
    - "{\n  UNCOMPRESSED {\n    type                                    [ 8 ];\n    length_msb
      =:= uncompressed_value(1, 0) [ 1 ];\n    length_lsb                              [
      7 ];\n    contents                           [ length_lsb.UVALUE*8-16 ];\n  }\n
      \ CONTROL {\n    option_static [ 1 ];\n  }\n  DEFAULT {\n    type       =:=
      static;\n    length_lsb =:= static;\n    contents   =:= static;\n  }\n  COMPRESSED
      generic_list_item {\n    type          =:= irregular(8)      [ 8 ];\n    option_static
      =:= one_bit_choice    [ 1 ];\n    length_lsb    =:= irregular(7)      [ 7 ];\n
      \   contents      =:=\n      irregular(length_lsb.UVALUE*8-16) [ length_lsb.UVALUE*8-16
      ];\n  }\n  // Used when context of option has option_static set to one\n  COMPRESSED
      generic_static_irregular {\n    ENFORCE(option_static.UVALUE == 1);\n  }\n  //
      An item that can change, but currently is unchanged\n  COMPRESSED generic_stable_irregular
      {\n    discriminator =:= '11111111' [ 8 ];\n    ENFORCE(option_static.UVALUE
      == 0);\n  }\n  // An item that is assumed to change constantly.\n  // Length
      is not allowed to change here, since a length change is\n  // most likely to
      cause new NOPs or an EOL length change.\n  COMPRESSED generic_full_irregular
      {\n    discriminator =:= '00000000'        [ 8 ];\n    contents      =:=\n      irregular(length_lsb.UVALUE*8-16)
      [ length_lsb.UVALUE*8-16 ];\n    ENFORCE(option_static.UVALUE == 0);\n  }\n"
    - '}

      '
    - 'tcp_list_presence_enc(presence)

      '
    - "{\n  UNCOMPRESSED {\n    tcp_options;\n  }\n  COMPRESSED list_not_present {\n
      \   tcp_options =:= static [ 0 ];\n    ENFORCE(presence == 0);\n  }\n  COMPRESSED
      list_present {\n    tcp_options =:= list_tcp_options [ VARIABLE ];\n    ENFORCE(presence
      == 1);\n  }\n"
    - '}

      '
    - '/////////////////////////////////////////////

      '
    - '// TCP Header

      '
    - '/////////////////////////////////////////////

      '
    - 'port_replicate(flags)

      '
    - "{\n  UNCOMPRESSED {\n    port [ 16 ];\n  }\n  COMPRESSED port_static_enc {\n
      \   port =:= static [ 0 ];\n    ENFORCE(flags == 0b00);\n  }\n  COMPRESSED port_lsb8
      {\n    port =:= lsb(8, 64) [ 8 ];\n    ENFORCE(flags == 0b01);\n  }\n  COMPRESSED
      port_irr_enc {\n    port =:= irregular(16) [ 16 ];\n    ENFORCE(flags == 0b10);\n
      \ }\n"
    - '}

      '
    - 'tcp_irreg_ip_ecn(ip_inner_ecn)

      '
    - "{\n  UNCOMPRESSED {\n    ip_ecn_flags [ 2 ];\n  }\n  COMPRESSED ecn_present
      {\n    // This field does not exist in the uncompressed header\n    // and therefore
      cannot use uncompressed_value.\n    ip_ecn_flags =:=\n      compressed_value(2,
      ip_inner_ecn) [ 2 ];\n    ENFORCE(ecn_used.UVALUE == 1);\n  }\n  COMPRESSED
      ecn_not_present {\n    ip_ecn_flags =:= static [ 0 ];\n    ENFORCE(ecn_used.UVALUE
      == 0);\n  }\n"
    - '}

      '
    - 'rsf_index_enc

      '
    - "{\n  UNCOMPRESSED {\n    rsf_flag [ 3 ];\n  }\n  COMPRESSED none {\n    rsf_idx
      \ =:= '00' [ 2 ];\n    rsf_flag =:= uncompressed_value(3, 0x00);\n  }\n  COMPRESSED
      rst_only {\n    rsf_idx  =:= '01' [ 2 ];\n    rsf_flag =:= uncompressed_value(3,
      0x04);\n  }\n  COMPRESSED syn_only {\n    rsf_idx  =:= '10' [ 2 ];\n    rsf_flag
      =:= uncompressed_value(3, 0x02);\n  }\n  COMPRESSED fin_only {\n    rsf_idx
      \ =:= '11' [ 2 ];\n    rsf_flag =:= uncompressed_value(3, 0x01);\n  }\n"
    - '}

      '
    - 'optional_2bit_padding(used_flag)

      '
    - "{\n  UNCOMPRESSED {\n  }\n  COMPRESSED used {\n    padding =:= compressed_value(2,
      0x0) [ 2 ];\n    ENFORCE(used_flag == 1);\n  }\n  COMPRESSED unused {\n    padding
      =:= compressed_value(0, 0x0);\n    ENFORCE(used_flag == 0);\n  }\n"
    - '}

      '
    - '// ack_stride_value is the user-selected stride for scaling the

      '
    - '// TCP ack_number

      '
    - '// ip_inner_ecn is the value bound when processing the innermost

      '
    - '// IP header (ipv4 or ipv6 encoding method)

      '
    - 'tcp(payload_size, ack_stride_value, ip_inner_ecn)

      '
    - "{\n  UNCOMPRESSED {\n    src_port      [ 16 ];\n    dst_port      [ 16 ];\n
      \   seq_number    [ 32 ];\n    ack_number    [ 32 ];\n    data_offset   [ 4
      ];\n    tcp_res_flags [ 4 ];\n    tcp_ecn_flags [ 2 ];\n    urg_flag      [
      1 ];\n    ack_flag      [ 1 ];\n    psh_flag      [ 1 ];\n    rsf_flags     [
      3 ];\n    window        [ 16 ];\n    checksum      [ 16 ];\n    urg_ptr       [
      16 ];\n    options       [ (data_offset.UVALUE-5)*32 ];\n  }\n  CONTROL {\n
      \   dummy_field_s =:= field_scaling(payload_size,\n      seq_number_scaled.UVALUE,
      seq_number.UVALUE,\n      seq_number_residue.UVALUE) [ 0 ];\n    dummy_field_a
      =:= field_scaling(ack_stride.UVALUE,\n      ack_number_scaled.UVALUE, ack_number.UVALUE,\n
      \     ack_number_residue.UVALUE) [ 0 ];\n    ENFORCE(ack_stride.UVALUE == ack_stride_value);\n
      \ }\n  INITIAL {\n    ack_stride     =:= uncompressed_value(16, 0);\n  }\n  DEFAULT
      {\n    src_port      =:= static;\n    dst_port      =:= static;\n    seq_number
      \   =:= static;\n    ack_number    =:= static;\n    data_offset   =:= inferred_offset;\n
      \   tcp_res_flags =:= static;\n    tcp_ecn_flags =:= static;\n    urg_flag      =:=
      static;\n    ack_flag      =:= uncompressed_value(1, 1);\n    rsf_flags     =:=
      uncompressed_value(3, 0);\n    window        =:= static;\n    urg_ptr       =:=
      static;\n    ack_stride    =:= static;\n    ack_number_scaled =:= static;\n
      \   seq_number_scaled =:= static;\n    ack_number_residue =:= static;\n    seq_number_residue
      =:= static;\n  }\n  COMPRESSED tcp_static {\n    src_port =:= irregular(16)
      [ 16 ];\n    dst_port =:= irregular(16) [ 16 ];\n  }\n  COMPRESSED tcp_dynamic
      {\n    ecn_used        =:= one_bit_choice          [ 1 ];\n    ack_stride_flag
      =:= irregular(1)            [ 1 ];\n    ack_zero        =:= irregular(1)            [
      1 ];\n    urp_zero        =:= irregular(1)            [ 1 ];\n    tcp_res_flags
      \  =:= irregular(4)            [ 4 ];\n    tcp_ecn_flags   =:= irregular(2)
      \           [ 2 ];\n    urg_flag        =:= irregular(1)            [ 1 ];\n
      \   ack_flag        =:= irregular(1)            [ 1 ];\n    psh_flag        =:=
      irregular(1)            [ 1 ];\n    rsf_flags       =:= irregular(3)            [
      3 ];\n    msn             =:= irregular(16)           [ 16 ];\n    seq_number
      \     =:= irregular(32)           [ 32 ];\n    ack_number      =:=\n      zero_or_irreg(ack_zero.CVALUE,
      32)        [ 0, 32 ];\n    window          =:= irregular(16)           [ 16
      ];\n    checksum        =:= irregular(16)           [ 16 ];\n    urg_ptr         =:=\n
      \     zero_or_irreg(urp_zero.CVALUE, 16)        [ 0, 16 ];\n    ack_stride      =:=\n
      \     static_or_irreg(ack_stride_flag.CVALUE, 16) [ 0, 16 ];\n    options         =:=
      list_tcp_options        [ VARIABLE ];\n  }\n  COMPRESSED tcp_replicate {\n    reserved
      \         =:= '0'                      [ 1 ];\n    window_presence   =:= irregular(1)
      \            [ 1 ];\n    list_present      =:= irregular(1)             [ 1
      ];\n    src_port_presence =:= irregular(2)             [ 2 ];\n    dst_port_presence
      =:= irregular(2)             [ 2 ];\n    ack_stride_flag   =:= irregular(1)
      \            [ 1 ];\n    ack_presence      =:= irregular(1)             [ 1
      ];\n    urp_presence      =:= irregular(1)             [ 1 ];\n    urg_flag
      \         =:= irregular(1)             [ 1 ];\n    ack_flag          =:= irregular(1)
      \            [ 1 ];\n    psh_flag          =:= irregular(1)             [ 1
      ];\n    rsf_flags         =:= rsf_index_enc            [ 2 ];\n    ecn_used
      \         =:= one_bit_choice           [ 1 ];\n    msn               =:= irregular(16)
      \           [ 16 ];\n    seq_number        =:= irregular(32)            [ 32
      ];\n    src_port          =:=\n      port_replicate(src_port_presence)      [
      0, 8, 16 ];\n    dst_port          =:=\n      port_replicate(dst_port_presence)
      \     [ 0, 8, 16 ];\n    window            =:=\n      static_or_irreg(window_presence,
      16)   [ 0, 16 ];\n    urg_point         =:=\n      static_or_irreg(urp_presence,
      16)    [ 0, 16 ];\n    ack_number        =:=\n      static_or_irreg(ack_presence,
      32)    [ 0, 32 ];\n    ecn_padding       =:=\n      optional_2bit_padding(ecn_used.CVALUE)
      \    [ 0, 2 ];\n    tcp_res_flags =:=\n      static_or_irreg(ecn_used.CVALUE,
      4)        [ 0, 4 ];\n    tcp_ecn_flags     =:=\n      static_or_irreg(ecn_used.CVALUE,
      2)        [ 0, 2 ];\n    checksum          =:= irregular(16)            [ 16
      ];\n    ack_stride        =:=\n      static_or_irreg(ack_stride_flag.CVALUE,
      16)  [ 0, 16 ];\n    options           =:=\n      tcp_list_presence_enc(list_present.CVALUE)
      [ VARIABLE ];\n  }\n  COMPRESSED tcp_irregular {\n    ip_ecn_flags  =:= tcp_irreg_ip_ecn(ip_inner_ecn)
      \ [ 0, 2 ];\n    tcp_res_flags =:=\n      static_or_irreg(ecn_used.CVALUE, 4)
      \           [ 0, 4 ];\n    tcp_ecn_flags =:=\n      static_or_irreg(ecn_used.CVALUE,
      2)             [ 0, 2 ];\n    checksum      =:= irregular(16)                   [
      16 ];\n  }\n"
    - '}

      '
    - '///////////////////////////////////////////////////

      '
    - '// Encoding methods used in compressed base headers

      '
    - '///////////////////////////////////////////////////

      '
    - 'dscp_enc(flag)

      '
    - "{\n  UNCOMPRESSED {\n    dscp [ 6 ];\n  }\n  COMPRESSED static_enc {\n    dscp
      =:= static [ 0 ];\n    ENFORCE(flag == 0);\n  }\n  COMPRESSED irreg {\n    dscp
      \   =:= irregular(6)           [ 6 ];\n    padding =:= compressed_value(2, 0)
      [ 2 ];\n    ENFORCE(flag == 1);\n  }\n"
    - '}

      '
    - 'ip_id_lsb(behavior, k, p)

      '
    - "{\n  UNCOMPRESSED {\n    ip_id [ 16 ];\n  }\n  CONTROL {\n    ip_id_nbo    [
      16 ];\n  }\n  COMPRESSED nbo {\n    ip_id_offset =:= lsb(k, p) [ k ];\n    ENFORCE(behavior
      == IP_ID_BEHAVIOR_SEQUENTIAL);\n    ENFORCE(ip_id_offset.UVALUE == ip_id.UVALUE
      - msn.UVALUE);\n  }\n  COMPRESSED non_nbo {\n    ip_id_offset =:= lsb(k, p)
      [ k ];\n    ENFORCE(behavior == IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED);\n    ENFORCE(ip_id_nbo.UVALUE
      ==\n            (ip_id.UVALUE / 256) + (ip_id.UVALUE % 256) * 256);\n    ENFORCE(ip_id_nbo.ULENGTH
      == 16);\n    ENFORCE(ip_id_offset.UVALUE == ip_id_nbo.UVALUE - msn.UVALUE);\n
      \ }\n"
    - '}

      '
    - 'optional_ip_id_lsb(behavior, indicator)

      '
    - "{\n  UNCOMPRESSED {\n    ip_id [ 16 ];\n  }\n  COMPRESSED short {\n    ip_id
      =:= ip_id_lsb(behavior, 8, 3) [ 8 ];\n    ENFORCE((behavior == IP_ID_BEHAVIOR_SEQUENTIAL)
      ||\n            (behavior == IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n    ENFORCE(indicator
      == 0);\n  }\n  COMPRESSED long {\n    ip_id =:= irregular(16)  [ 16 ];\n    ENFORCE((behavior
      == IP_ID_BEHAVIOR_SEQUENTIAL) ||\n            (behavior == IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n
      \   ENFORCE(indicator == 1);\n    ENFORCE(ip_id_offset.UVALUE == ip_id.UVALUE
      - msn.UVALUE);\n  }\n  COMPRESSED not_present {\n    ENFORCE((behavior == IP_ID_BEHAVIOR_RANDOM)
      ||\n            (behavior == IP_ID_BEHAVIOR_ZERO));\n  }\n"
    - '}

      '
    - 'dont_fragment(version)

      '
    - "{\n  UNCOMPRESSED {\n    df [ 1 ];\n  }\n  COMPRESSED v4 {\n    df =:= irregular(1)
      [ 1 ];\n    ENFORCE(version == 4);\n  }\n  COMPRESSED v6 {\n    df =:= compressed_value(1,
      0) [ 1 ];\n    ENFORCE(version == 6);\n  }\n"
    - '}

      '
    - '//////////////////////////////////

      '
    - '// Actual start of compressed packet formats

      '
    - '// Important note:

      '
    - '//   The base header is the compressed representation

      '
    - '//   of the innermost IP header AND the TCP header.

      '
    - '//////////////////////////////////

      '
    - '// ttl_irregular_chain_flag is set by the user if the TTL/Hop Limit

      '
    - '// of an outer header has changed.  The same value must be passed as

      '
    - '// an argument to the ipv4/ipv6 encoding methods when extracting

      '
    - '// the irregular chain items.

      '
    - "co_baseheader(payload_size, ack_stride_value,\n              ttl_irregular_chain_flag,
      ip_id_behavior_value)\n"
    - "{\n  UNCOMPRESSED v4 {\n    outer_headers  =:= baseheader_outer_headers        [
      VARIABLE ];\n    version        =:= uncompressed_value(4, 4)        [ 4 ];\n
      \   header_length  =:= uncompressed_value(4, 5)        [ 4 ];\n    dscp                                               [
      6 ];\n    ip_ecn_flags                                       [ 2 ];\n    length
      \                                            [ 16 ];\n    ip_id                                              [
      16 ];\n    rf             =:= uncompressed_value(1, 0)        [ 1 ];\n    df
      \                                                [ 1 ];\n    mf             =:=
      uncompressed_value(1, 0)        [ 1 ];\n    frag_offset    =:= uncompressed_value(13,
      0)       [ 13 ];\n    ttl_hopl                                           [ 8
      ];\n    next_header                                        [ 8 ];\n    checksum
      \                                          [ 16 ];\n    src_addr                                           [
      32 ];\n    dest_addr                                          [ 32 ];\n    extension_headers
      =:= baseheader_extension_headers [ VARIABLE ];\n    src_port                                           [
      16 ];\n    dest_port                                          [ 16 ];\n    seq_number
      \                                        [ 32 ];\n    ack_number                                         [
      32 ];\n    data_offset                                        [ 4 ];\n    tcp_res_flags
      \                                     [ 4 ];\n    tcp_ecn_flags                                      [
      2 ];\n    urg_flag                                           [ 1 ];\n    ack_flag
      \                                          [ 1 ];\n    psh_flag                                           [
      1 ];\n    rsf_flags                                          [ 3 ];\n    window
      \                                            [ 16 ];\n    tcp_checksum                                       [
      16 ];\n    urg_ptr                                            [ 16 ];\n    options
      \                          [ (data_offset.UVALUE-5)*32 ];\n  }\n  UNCOMPRESSED
      v6 {\n    ENFORCE(ip_id_behavior_innermost.UVALUE == IP_ID_BEHAVIOR_RANDOM);\n
      \   outer_headers  =:= baseheader_outer_headers        [ VARIABLE ];\n    version
      =:= uncompressed_value(4, 6)               [ 4 ];\n    dscp                                               [
      6 ];\n    ip_ecn_flags                                       [ 2 ];\n    flow_label
      \                                        [ 20 ];\n    payload_length                                     [
      16 ];\n    next_header                                        [ 8 ];\n    ttl_hopl
      \                                          [ 8 ];\n    src_addr                                           [
      128 ];\n    dest_addr                                          [ 128 ];\n    extension_headers
      =:= baseheader_extension_headers [ VARIABLE ];\n    src_port                                           [
      16 ];\n    dest_port                                          [ 16 ];\n    seq_number
      \                                        [ 32 ];\n    ack_number                                         [
      32 ];\n    data_offset                                        [ 4 ];\n    tcp_res_flags
      \                                     [ 4 ];\n    tcp_ecn_flags                                      [
      2 ];\n    urg_flag                                           [ 1 ];\n    ack_flag
      \                                          [ 1 ];\n    psh_flag                                           [
      1 ];\n    rsf_flags                                          [ 3 ];\n    window
      \                                            [ 16 ];\n    tcp_checksum                                       [
      16 ];\n    urg_ptr                                            [ 16 ];\n    options
      \                          [ (data_offset.UVALUE-5)*32 ];\n    df    =:= uncompressed_value(0,0)
      \                 [   0 ];\n    ip_id =:= uncompressed_value(0,0)                  [
      \  0 ];\n  }\n  CONTROL {\n    dummy_field_s =:= field_scaling(payload_size,\n
      \     seq_number_scaled.UVALUE, seq_number.UVALUE,\n      seq_number_residue.UVALUE)
      [ 0 ];\n    dummy_field_a =:= field_scaling(ack_stride.UVALUE,\n      ack_number_scaled.UVALUE,
      ack_number.UVALUE,\n      ack_number_residue.UVALUE) [ 0 ];\n    ENFORCE(ack_stride.UVALUE
      == ack_stride_value);\n    ENFORCE(ip_id_behavior_innermost.UVALUE == ip_id_behavior_value);\n
      \ }\n  INITIAL {\n    ack_stride     =:= uncompressed_value(16, 0);\n  }\n  DEFAULT
      {\n    tcp_ecn_flags  =:= static;\n    data_offset    =:= inferred_offset;\n
      \   tcp_res_flags  =:= static;\n    rsf_flags      =:= uncompressed_value(3,
      0);\n    dest_port      =:= static;\n    dscp           =:= static;\n    src_port
      \      =:= static;\n    urg_flag       =:= uncompressed_value(1, 0);\n    window
      \        =:= static;\n    dest_addr      =:= static;\n    version        =:=
      static;\n    ttl_hopl       =:= static;\n    src_addr       =:= static;\n    df
      \            =:= static;\n    ack_number     =:= static;\n    urg_ptr        =:=
      static;\n    seq_number     =:= static;\n    ack_flag       =:= uncompressed_value(1,
      1);\n    // The default for \"options\" is case 2) and 3) from\n    // the list
      in Section 6.3.1 (i.e., nothing present in the\n    // baseheader itself).\n
      \   payload_length =:= inferred_ip_v6_length;\n    checksum       =:= inferred_ip_v4_header_checksum;\n
      \   length         =:= inferred_ip_v4_length;\n    flow_label     =:= static;\n
      \   next_header    =:= static;\n    ip_ecn_flags   =:= static;\n    // The tcp_checksum
      has no default,\n    // it is considered a part of tcp_irregular\n    ip_id_behavior_innermost
      =:= static;\n    ecn_used       =:= static;\n    ack_stride    =:= static;\n
      \   ack_number_scaled =:= static;\n    seq_number_scaled =:= static;\n    ack_number_residue
      =:= static;\n    seq_number_residue =:= static;\n    // Default is to have no
      TTL in irregular chain\n    // Can only be nonzero if co_common is used\n    ENFORCE(ttl_irregular_chain_flag
      == 0);\n  }\n  ////////////////////////////////////////////\n  // Common compressed
      packet format\n  ////////////////////////////////////////////\n  COMPRESSED
      co_common {\n    discriminator        =:= '1111101'                [ 7 ];\n
      \   ttl_hopl_outer_flag  =:=\n        compressed_value(1, ttl_irregular_chain_flag)
      [ 1 ];\n    ack_flag             =:= irregular(1)             [ 1 ];\n    psh_flag
      \            =:= irregular(1)             [ 1 ];\n    rsf_flags            =:=
      rsf_index_enc            [ 2 ];\n    msn                  =:= lsb(4, 4)                [
      4 ];\n    seq_indicator        =:= irregular(2)             [ 2 ];\n    ack_indicator
      \       =:= irregular(2)             [ 2 ];\n    ack_stride_indicator =:= irregular(1)
      \            [ 1 ];\n    window_indicator     =:= irregular(1)             [
      1 ];\n    ip_id_indicator      =:= irregular(1)             [ 1 ];\n    urg_ptr_present
      \     =:= irregular(1)             [ 1 ];\n    reserved             =:= compressed_value(1,
      0)   [ 1 ];\n    ecn_used             =:= one_bit_choice           [ 1 ];\n
      \   dscp_present         =:= irregular(1)             [ 1 ];\n    ttl_hopl_present
      \    =:= irregular(1)             [ 1 ];\n    list_present         =:= irregular(1)
      \            [ 1 ];\n    ip_id_behavior_innermost       =:= irregular(2)             [
      2 ];\n    urg_flag             =:= irregular(1)             [ 1 ];\n    df                   =:=
      dont_fragment(version.UVALUE)   [ 1 ];\n    header_crc           =:= crc7(THIS.UVALUE,
      THIS.ULENGTH) [ 7 ];\n    seq_number           =:=\n      variable_length_32_enc(seq_indicator.CVALUE)
      [ 0, 8, 16, 32 ];\n    ack_number           =:=\n      variable_length_32_enc(ack_indicator.CVALUE)
      [ 0, 8, 16, 32 ];\n    ack_stride           =:=\n      static_or_irreg(ack_stride_indicator.CVALUE,
      16)  [ 0, 16 ];\n    window               =:=\n      static_or_irreg(window_indicator.CVALUE,
      16)      [ 0, 16 ];\n    ip_id                =:=\n      optional_ip_id_lsb(ip_id_behavior_innermost.UVALUE,\n
      \                        ip_id_indicator.CVALUE)      [ 0, 8, 16 ];\n    urg_ptr
      \             =:=\n      static_or_irreg(urg_ptr_present.CVALUE, 16)     [ 0,
      16 ];\n    dscp                 =:=\n      dscp_enc(dscp_present.CVALUE)                   [
      0, 8 ];\n    ttl_hopl             =:=\n      static_or_irreg(ttl_hopl_present.CVALUE,
      8)     [ 0, 8 ];\n    options              =:=\n      tcp_list_presence_enc(list_present.CVALUE)
      \     [ VARIABLE ];\n  }\n  // Send LSBs of sequence number\n  COMPRESSED rnd_1
      {\n    discriminator =:= '101110'                        [ 6 ];\n    seq_number
      \   =:= lsb(18, 65535)                  [ 18 ];\n    msn           =:= lsb(4,
      4)                       [ 4 ];\n    psh_flag      =:= irregular(1)                    [
      1 ];\n    header_crc    =:= crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];\n    ENFORCE((ip_id_behavior_innermost.UVALUE
      ==\n             IP_ID_BEHAVIOR_RANDOM) ||\n            (ip_id_behavior_innermost.UVALUE
      == IP_ID_BEHAVIOR_ZERO));\n  }\n  // Send scaled sequence number LSBs\n  COMPRESSED
      rnd_2 {\n    discriminator      =:= '1100'                          [ 4 ];\n
      \   seq_number_scaled  =:= lsb(4, 7)                       [ 4 ];\n    msn                =:=
      lsb(4, 4)                       [ 4 ];\n    psh_flag           =:= irregular(1)
      \                   [ 1 ];\n    header_crc         =:= crc3(THIS.UVALUE, THIS.ULENGTH)
      [ 3 ];\n    ENFORCE(payload_size != 0);\n    ENFORCE((ip_id_behavior_innermost.UVALUE
      ==\n             IP_ID_BEHAVIOR_RANDOM) ||\n            (ip_id_behavior_innermost.UVALUE
      == IP_ID_BEHAVIOR_ZERO));\n  }\n  // Send acknowledgment number LSBs\n  COMPRESSED
      rnd_3 {\n    discriminator =:= '0'                             [ 1 ];\n    ack_number
      \   =:= lsb(15, 8191)                   [ 15 ];\n    msn           =:= lsb(4,
      4)                       [ 4 ];\n    psh_flag      =:= irregular(1)                    [
      1 ];\n    header_crc    =:= crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];\n    ENFORCE((ip_id_behavior_innermost.UVALUE
      ==\n             IP_ID_BEHAVIOR_RANDOM) ||\n            (ip_id_behavior_innermost.UVALUE
      == IP_ID_BEHAVIOR_ZERO));\n  }\n  // Send acknowledgment number scaled\n  COMPRESSED
      rnd_4 {\n    discriminator      =:= '1101'                          [ 4 ];\n
      \   ack_number_scaled  =:= lsb(4, 3)                       [ 4 ];\n    msn                =:=
      lsb(4, 4)                       [ 4 ];\n    psh_flag           =:= irregular(1)
      \                   [ 1 ];\n    header_crc         =:= crc3(THIS.UVALUE, THIS.ULENGTH)
      [ 3 ];\n    ENFORCE(ack_stride.UVALUE != 0);\n    ENFORCE((ip_id_behavior_innermost.UVALUE
      ==\n             IP_ID_BEHAVIOR_RANDOM) ||\n            (ip_id_behavior_innermost.UVALUE
      == IP_ID_BEHAVIOR_ZERO));\n  }\n  // Send ACK and sequence number\n  COMPRESSED
      rnd_5 {\n    discriminator =:= '100'                           [ 3 ];\n    psh_flag
      \     =:= irregular(1)                    [ 1 ];\n    msn           =:= lsb(4,
      4)                       [ 4 ];\n    header_crc    =:= crc3(THIS.UVALUE, THIS.ULENGTH)
      [ 3 ];\n    seq_number    =:= lsb(14, 8191)                   [ 14 ];\n    ack_number
      \   =:= lsb(15, 8191)                   [ 15 ];\n    ENFORCE((ip_id_behavior_innermost.UVALUE
      ==\n             IP_ID_BEHAVIOR_RANDOM) ||\n            (ip_id_behavior_innermost.UVALUE
      == IP_ID_BEHAVIOR_ZERO));\n  }\n  // Send both ACK and scaled sequence number
      LSBs\n  COMPRESSED rnd_6 {\n    discriminator      =:= '1010'                          [
      4 ];\n    header_crc         =:= crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];\n    psh_flag
      \          =:= irregular(1)                    [ 1 ];\n    ack_number         =:=
      lsb(16, 16383)                  [ 16 ];\n    msn                =:= lsb(4, 4)
      \                      [ 4 ];\n    seq_number_scaled  =:= lsb(4, 7)                       [
      4 ];\n    ENFORCE(payload_size != 0);\n    ENFORCE((ip_id_behavior_innermost.UVALUE
      ==\n             IP_ID_BEHAVIOR_RANDOM) ||\n            (ip_id_behavior_innermost.UVALUE
      == IP_ID_BEHAVIOR_ZERO));\n  }\n  // Send ACK and window\n  COMPRESSED rnd_7
      {\n    discriminator =:= '101111'                        [ 6 ];\n    ack_number
      \   =:= lsb(18, 65535)                  [ 18 ];\n    window        =:= irregular(16)
      \                  [ 16 ];\n    msn           =:= lsb(4, 4)                       [
      4 ];\n    psh_flag      =:= irregular(1)                    [ 1 ];\n    header_crc
      \   =:= crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];\n    ENFORCE((ip_id_behavior_innermost.UVALUE
      ==\n             IP_ID_BEHAVIOR_RANDOM) ||\n            (ip_id_behavior_innermost.UVALUE
      == IP_ID_BEHAVIOR_ZERO));\n  }\n  // An extended packet type for seldom-changing
      fields\n  // Can send LSBs of TTL, RSF flags, change ECN behavior, and\n  //
      options list\n  COMPRESSED rnd_8 {\n    discriminator =:= '10110'                         [
      5 ];\n    rsf_flags     =:= rsf_index_enc                   [ 2 ];\n    list_present
      \ =:= irregular(1)                    [ 1 ];\n    header_crc    =:= crc7(THIS.UVALUE,
      THIS.ULENGTH) [ 7 ];\n    msn           =:= lsb(4, 4)                       [
      4 ];\n    psh_flag      =:= irregular(1)                    [ 1 ];\n    ttl_hopl
      \     =:= lsb(3, 3)                       [ 3 ];\n    ecn_used      =:= one_bit_choice
      \                 [ 1 ];\n    seq_number    =:= lsb(16, 65535)                  [
      16 ];\n    ack_number    =:= lsb(16, 16383)                  [ 16 ];\n    options
      \      =:=\n      tcp_list_presence_enc(list_present.CVALUE)      [ VARIABLE
      ];\n    ENFORCE((ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_RANDOM)
      ||\n            (ip_id_behavior_innermost.UVALUE == IP_ID_BEHAVIOR_ZERO));\n
      \ }\n  // Send LSBs of sequence number\n  COMPRESSED seq_1 {\n    discriminator
      =:= '1010'                                 [ 4 ];\n    ip_id =:= ip_id_lsb(ip_id_behavior_innermost.UVALUE,
      4, 3) [ 4 ];\n    seq_number    =:= lsb(16, 32767)                         [
      16 ];\n    msn           =:= lsb(4, 4)                              [ 4 ];\n
      \   psh_flag      =:= irregular(1)                           [ 1 ];\n    header_crc
      \   =:= crc3(THIS.UVALUE, THIS.ULENGTH)        [ 3 ];\n    ENFORCE((ip_id_behavior_innermost.UVALUE
      ==\n             IP_ID_BEHAVIOR_SEQUENTIAL) ||\n            (ip_id_behavior_innermost.UVALUE
      ==\n             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n  }\n  // Send scaled
      sequence number LSBs\n  COMPRESSED seq_2 {\n    discriminator      =:= '11010'
      \                        [ 5 ];\n    ip_id              =:=\n      ip_id_lsb(ip_id_behavior_innermost.UVALUE,
      7, 3)     [ 7 ];\n    seq_number_scaled  =:= lsb(4, 7)                       [
      4 ];\n    msn                =:= lsb(4, 4)                       [ 4 ];\n    psh_flag
      \          =:= irregular(1)                    [ 1 ];\n    header_crc         =:=
      crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];\n    ENFORCE(payload_size != 0);\n    ENFORCE((ip_id_behavior_innermost.UVALUE
      ==\n             IP_ID_BEHAVIOR_SEQUENTIAL) ||\n            (ip_id_behavior_innermost.UVALUE
      ==\n             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n  }\n  // Send acknowledgment
      number LSBs\n  COMPRESSED seq_3 {\n    discriminator =:= '1001'                                 [
      4 ];\n    ip_id =:= ip_id_lsb(ip_id_behavior_innermost.UVALUE, 4, 3) [ 4 ];\n
      \   ack_number    =:= lsb(16, 16383)                         [ 16 ];\n    msn
      \          =:= lsb(4, 4)                              [ 4 ];\n    psh_flag      =:=
      irregular(1)                           [ 1 ];\n    header_crc    =:= crc3(THIS.UVALUE,
      THIS.ULENGTH)        [ 3 ];\n    ENFORCE((ip_id_behavior_innermost.UVALUE ==\n
      \            IP_ID_BEHAVIOR_SEQUENTIAL) ||\n            (ip_id_behavior_innermost.UVALUE
      ==\n             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n  }\n  // Send scaled
      acknowledgment number scaled\n  COMPRESSED seq_4 {\n    discriminator     =:=
      '0'                             [ 1 ];\n    ack_number_scaled =:= lsb(4, 3)
      \                      [ 4 ];\n    // Due to having very few ip_id bits, no
      negative offset\n    ip_id =:= ip_id_lsb(ip_id_behavior_innermost.UVALUE, 3,
      1) [ 3 ];\n    msn               =:= lsb(4, 4)                       [ 4 ];\n
      \   psh_flag          =:= irregular(1)                    [ 1 ];\n    header_crc
      \       =:= crc3(THIS.UVALUE, THIS.ULENGTH) [ 3 ];\n    ENFORCE(ack_stride.UVALUE
      != 0);\n    ENFORCE((ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL)
      ||\n            (ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n
      \ }\n  // Send ACK and sequence number\n  COMPRESSED seq_5 {\n    discriminator
      =:= '1000'                                 [ 4 ];\n    ip_id =:= ip_id_lsb(ip_id_behavior_innermost.UVALUE,
      4, 3) [ 4 ];\n    ack_number    =:= lsb(16, 16383)                         [
      16 ];\n    seq_number    =:= lsb(16, 32767)                         [ 16 ];\n
      \   msn           =:= lsb(4, 4)                              [ 4 ];\n    psh_flag
      \     =:= irregular(1)                           [ 1 ];\n    header_crc    =:=
      crc3(THIS.UVALUE, THIS.ULENGTH)        [ 3 ];\n    ENFORCE((ip_id_behavior_innermost.UVALUE
      ==\n             IP_ID_BEHAVIOR_SEQUENTIAL) ||\n            (ip_id_behavior_innermost.UVALUE
      ==\n             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n  }\n  // Send both ACK
      and scaled sequence number LSBs\n  COMPRESSED seq_6 {\n    discriminator      =:=
      '11011'                          [ 5 ];\n    seq_number_scaled  =:= lsb(4, 7)
      \                       [ 4 ];\n    ip_id =:= ip_id_lsb(ip_id_behavior_innermost.UVALUE,
      7, 3) [ 7 ];\n    ack_number         =:= lsb(16, 16383)                   [
      16 ];\n    msn                =:= lsb(4, 4)                        [ 4 ];\n
      \   psh_flag           =:= irregular(1)                     [ 1 ];\n    header_crc
      \        =:= crc3(THIS.UVALUE, THIS.ULENGTH)  [ 3 ];\n    ENFORCE(payload_size
      != 0);\n    ENFORCE((ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL)
      ||\n            (ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n
      \ }\n  // Send ACK and window\n  COMPRESSED seq_7 {\n    discriminator =:= '1100'
      \                                [ 4 ];\n    window        =:= lsb(15, 16383)
      \                        [ 15 ];\n    ip_id =:= ip_id_lsb(ip_id_behavior_innermost.UVALUE,
      5, 3) [ 5 ];\n    ack_number    =:= lsb(16, 32767)                         [
      16 ];\n    msn           =:= lsb(4, 4)                              [ 4 ];\n
      \   psh_flag      =:= irregular(1)                           [ 1 ];\n    header_crc
      \   =:= crc3(THIS.UVALUE, THIS.ULENGTH)        [ 3 ];\n    ENFORCE((ip_id_behavior_innermost.UVALUE
      ==\n             IP_ID_BEHAVIOR_SEQUENTIAL) ||\n            (ip_id_behavior_innermost.UVALUE
      ==\n             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n  }\n  // An extended
      packet type for seldom-changing fields\n  // Can send LSBs of TTL, RSF flags,
      change ECN behavior, and\n  // options list\n  COMPRESSED seq_8 {\n    discriminator
      =:= '1011'                                 [ 4 ];\n    ip_id =:= ip_id_lsb(ip_id_behavior_innermost.UVALUE,
      4, 3) [ 4 ];\n    list_present  =:= irregular(1)                           [
      1 ];\n    header_crc    =:= crc7(THIS.UVALUE, THIS.ULENGTH)        [ 7 ];\n
      \   msn           =:= lsb(4, 4)                              [ 4 ];\n    psh_flag
      \     =:= irregular(1)                           [ 1 ];\n    ttl_hopl      =:=
      lsb(3, 3)                              [ 3 ];\n    ecn_used      =:= one_bit_choice
      \                        [ 1 ];\n    ack_number    =:= lsb(15, 8191)                          [
      15 ];\n    rsf_flags     =:= rsf_index_enc                          [ 2 ];\n
      \   seq_number    =:= lsb(14, 8191)                          [ 14 ];\n    options
      \      =:=\n      tcp_list_presence_enc(list_present.CVALUE)       [ VARIABLE
      ];\n    ENFORCE((ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL)
      ||\n            (ip_id_behavior_innermost.UVALUE ==\n             IP_ID_BEHAVIOR_SEQUENTIAL_SWAPPED));\n
      \ }\n"
    - '}

      '
    title: 8.2.  Formal Definition of Header Formats
  - contents:
    - '8.3.  Feedback Formats and Options

      '
    - contents:
      - "8.3.1.  Feedback Formats\n   This section describes the feedback formats
        for the ROHC-TCP profile,\n   following the general ROHC feedback format described
        in Section 5.2.4\n   of [RFC5795].\n   All feedback formats carry a field
        labeled MSN.  The MSN field\n   contains LSBs of the MSN control field described
        in Section 6.1.1.\n   The sequence number to use is the MSN corresponding
        to the last\n   header that was successfully CRC-8 validated or CRC verified.\n
        \  FEEDBACK-1\n        0   1   2   3   4   5   6   7\n      +---+---+---+---+---+---+---+---+\n
        \     |              MSN              |\n      +---+---+---+---+---+---+---+---+\n
        \     MSN: The LSB-encoded master sequence number.\n   A FEEDBACK-1 is an
        ACK.  In order to send a NACK or a STATIC-NACK,\n   FEEDBACK-2 must be used.\n
        \  FEEDBACK-2\n        0   1   2   3   4   5   6   7\n      +---+---+---+---+---+---+---+---+\n
        \     |Acktype|          MSN          |\n      +---+---+---+---+---+---+---+---+\n
        \     |              MSN              |\n      +---+---+---+---+---+---+---+---+\n
        \     |              CRC              |\n      +---+---+---+---+---+---+---+---+\n
        \     /       Feedback options        /\n      +---+---+---+---+---+---+---+---+\n
        \     Acktype:\n         0 = ACK\n         1 = NACK\n         2 = STATIC-NACK\n
        \        3 is reserved (MUST NOT be used for parsability)\n      MSN: The
        LSB-encoded master sequence number.\n      CRC: 8-bit CRC computed over the
        entire feedback element (as\n      defined in Section 5.3.1.1 of [RFC5795]).
        \ For the purpose of\n      computing the CRC, the CRC field is zero.  The
        CRC is calculated\n      using the polynomial defined in [RFC5795].\n      Feedback
        options: A variable number of feedback options, see\n      Section 8.3.2.
        \ Options may appear in any order.\n   A FEEDBACK-2 of type NACK or STATIC-NACK
        is always implicitly an\n   acknowledgment for a successfully decompressed
        packet, which packet\n   corresponds to the MSN of the feedback element, unless
        the MSN-NOT-\n   VALID option (Section 8.3.2.2) appears in the feedback element.\n
        \  The FEEDBACK-2 format always carries a CRC and is thus more robust\n   than
        the FEEDBACK-1 format.  When receiving FEEDBACK-2, the\n   compressor MUST
        verify the information by computing the CRC and by\n   comparing the result
        with the CRC carried in the feedback format.  If\n   the two are not identical,
        the feedback element MUST be discarded.\n"
      title: 8.3.1.  Feedback Formats
    - contents:
      - "8.3.2.  Feedback Options\n   A ROHC-TCP feedback option has variable length
        and the following\n   general format:\n        0   1   2   3   4   5   6   7\n
        \     +---+---+---+---+---+---+---+---+\n      |   Opt Type    |    Opt Len
        \   |\n      +---+---+---+---+---+---+---+---+\n      /          option data
        \         /  Opt Length (octets)\n      +---+---+---+---+---+---+---+---+\n
        \  Each ROHC-TCP feedback option can appear at most once within a\n   FEEDBACK-2.\n"
      - contents:
        - "8.3.2.1.  The REJECT Option\n   The REJECT option informs the compressor
          that the decompressor does\n   not have sufficient resources to handle the
          flow.\n      +---+---+---+---+---+---+---+---+\n      |  Opt Type = 2 |
          \ Opt Len = 0  |\n      +---+---+---+---+---+---+---+---+\n   When receiving
          a REJECT option, the compressor MUST stop compressing\n   the packet flow,
          and SHOULD refrain from attempting to increase the\n   number of compressed
          packet flows for some time.  The REJECT option\n   MUST NOT appear more
          than once in the FEEDBACK-2 format; otherwise,\n   the compressor MUST discard
          the entire feedback element.\n"
        title: 8.3.2.1.  The REJECT Option
      - contents:
        - "8.3.2.2.  The MSN-NOT-VALID Option\n   The MSN-NOT-VALID option indicates
          that the MSN of the feedback is\n   not valid.\n      +---+---+---+---+---+---+---+---+\n
          \     |  Opt Type = 3 |  Opt Len = 0  |\n      +---+---+---+---+---+---+---+---+\n
          \  A compressor MUST ignore the MSN of the feedback element when this\n
          \  option is present.  Consequently, a NACK or a STATIC-NACK feedback\n
          \  type sent with the MSN-NOT-VALID option is equivalent to a STATIC-\n
          \  NACK with respect to the semantics of the feedback message.\n   The MSN-NOT-VALID
          option MUST NOT appear more than once in the\n   FEEDBACK-2 format and MUST
          NOT appear in the same feedback element as\n   the MSN option; otherwise,
          the compressor MUST discard the entire\n   feedback element.\n"
        title: 8.3.2.2.  The MSN-NOT-VALID Option
      - contents:
        - "8.3.2.3.  The MSN Option\n   The MSN option provides 2 additional bits
          of MSN.\n      +---+---+---+---+---+---+---+---+\n      |  Opt Type = 4
          |  Opt Len = 1  |\n      +---+---+---+---+---+---+---+---+\n      |  MSN
          \ |        Reserved       |\n      +---+---+---+---+---+---+---+---+\n   These
          2 bits are the least significant bits of the MSN and are thus\n   concatenated
          with the 14 bits already present in the FEEDBACK-2\n   format.\n   The MSN
          option MUST NOT appear more than once in the FEEDBACK-2\n   format and MUST
          NOT appear in the same feedback element as the MSN-\n   NOT-VALID option;
          otherwise, the compressor MUST discard the entire\n   feedback element.\n"
        title: 8.3.2.3.  The MSN Option
      - contents:
        - "8.3.2.4.  The CONTEXT_MEMORY Feedback Option\n   The CONTEXT_MEMORY option
          means that the decompressor does not have\n   sufficient memory resources
          to handle the context of the packet flow,\n   as the flow is currently compressed.\n
          \       0   1   2   3   4   5   6   7\n      +---+---+---+---+---+---+---+---+\n
          \     |  Opt Type = 9 |  Opt Len = 0  |\n      +---+---+---+---+---+---+---+---+\n
          \  When receiving a CONTEXT_MEMORY option, the compressor SHOULD take\n
          \  actions to compress the packet flow in a way that requires less\n   decompressor
          memory resources, or stop compressing the packet flow.\n   The CONTEXT_MEMORY
          option MUST NOT appear more than once in the\n   FEEDBACK-2 format; otherwise,
          the compressor MUST discard the entire\n   feedback element.\n"
        title: 8.3.2.4.  The CONTEXT_MEMORY Feedback Option
      - contents:
        - "8.3.2.5.  Unknown Option Types\n   If an option type unknown to the compressor
          is encountered, the\n   compressor MUST continue parsing the rest of the
          FEEDBACK element,\n   which is possible since the length of the option is
          explicit, but\n   MUST otherwise ignore the unknown option.\n"
        title: 8.3.2.5.  Unknown Option Types
      title: 8.3.2.  Feedback Options
    title: 8.3.  Feedback Formats and Options
  title: 8.  Header Formats (Normative)
- contents:
  - "9.  Changes from RFC 4996\n   This RFC revises RFC 4996.  It is mostly backwards-compatible
    with\n   RFC 4996, except for two cases that did not interoperate as described\n
    \  below.\n"
  - contents:
    - "9.1.  Functional Changes\n   o  The SACK option compression in [RFC4996] assumed
      that multiple\n      SACK blocks within the same option would be in sorted order
      so\n      that the block starts were LSB-encoded from the end of the\n      previous
      block.  This meant that SACK blocks that are not in\n      sorted order could
      be impossible to compress in some cases.\n      Therefore, the SACK compression
      in the formal notation has changed\n      and therefore also the bits-on-the-wire.\n
      \  o  The ESP NULL header compression has been deprecated due to\n      interoperability
      problems with needing to know information from\n      the trailer.  The ESP
      NULL compression was already removed from\n      ROHCv2 [RFC5225] for the same
      reason and it was considered better\n      to remove it from this profile rather
      than try to fix the\n      interoperability issue.\n"
    title: 9.1.  Functional Changes
  - contents:
    - "9.2.  Non-functional Changes\n   o  The way sequential IP-ID compression was
      described in the FN code\n      was incorrect and the code used for ROHCv2 [RFC5225]
      has been\n      imported into this specification (e.g., offset is made into
      a\n      global control field).  This does not change the bits-on-the-wire.\n
      \     The only change is how this encoding is described in the formal\n      notation,
      not how the compression occurs.\n   o  Default encoding for the 'df' and 'ip_id'
      fields have been added\n      for IPv6 with 0-bit uncompressed format to clarify
      that these\n      never appear in IPv6.\n   o  The scaled encoding of the Acknowledgment
      Number and Sequence\n      Number were incorrectly described in the FN code
      in [RFC4996] and\n      have been updated in the same style as in ROHCv2 [RFC5225].
      \ This\n      does not change the bits-on-the-wire, only the way the compression\n
      \     is described in the FN code.\n   o  The external arguments to ipv4 and
      co_baseheader have been\n      updated.  This is again only a change for FN
      correctness and does\n      not affect interoperability.\n   o  Errata for [RFC4996]
      related to minor errors in the FN and textual\n      errors have also been corrected.\n"
    title: 9.2.  Non-functional Changes
  title: 9.  Changes from RFC 4996
- contents:
  - "10.  Security Considerations\n   A malfunctioning or malicious header compressor
    could cause the\n   header decompressor to reconstitute packets that do not match
    the\n   original packets but still have valid IP and TCP headers, and\n   possibly
    also valid TCP checksums.  Such corruption may be detected\n   with end-to-end
    authentication and integrity mechanisms that will not\n   be affected by the compression.
    \ Moreover, this header compression\n   scheme uses an internal checksum for verification
    of reconstructed\n   headers.  This reduces the probability of producing decompressed\n
    \  headers not matching the original ones without this being noticed.\n   Denial-of-service
    attacks are possible if an intruder can introduce\n   (for example) bogus IR,
    CO, or FEEDBACK packets onto the link and\n   thereby cause compression efficiency
    to be reduced.  However, an\n   intruder having the ability to inject arbitrary
    packets at the link\n   layer in this manner raises additional security issues
    that dwarf\n   those related to the use of header compression.\n"
  title: 10.  Security Considerations
- contents:
  - "11.  IANA Considerations\n   The reference for the ROHC profile identifier 0x0006
    has been updated\n   to reference this document instead of RFC 4996.\n   A ROHC
    profile identifier has been reserved by IANA for the profile\n   defined in this
    document.  Profiles 0x0000-0x0005 have previously\n   been reserved; this profile
    is 0x0006.  As for previous ROHC\n   profiles, profile numbers 0xnn06 have been
    reserved for future\n   updates of this profile.\n        Profile             Usage
    \           Document\n        identifier\n        0x0006              ROHC TCP
    \        [RFC6846]\n        0xnn06              Reserved\n"
  title: 11.  IANA Considerations
- contents:
  - "12.  Acknowledgments\n   The authors would like to thank Qian Zhang, Hong Bin
    Liao, Richard\n   Price, and Fredrik Lindstroem for their work with early versions
    of\n   this specification.  Thanks also to Robert Finking and Carsten\n   Bormann
    for valuable input and to Carl Knutsson and Gilbert Strom for\n   suggestions
    and review of the updates made in this document.\n   Additional thanks: this document
    was reviewed during working group\n   last-call by committed reviewers Joe Touch
    and Ted Faber, as well as\n   by Sally Floyd, who provided a review at the request
    of the Transport\n   Area Directors.\n"
  title: 12.  Acknowledgments
- contents:
  - '13.  References

    '
  - contents:
    - "13.1.  Normative References\n   [RFC0791]  Postel, J., \"Internet Protocol\",
      STD 5, RFC 791,\n              September 1981.\n   [RFC0793]  Postel, J., \"Transmission
      Control Protocol\", STD 7,\n              RFC 793, September 1981.\n   [RFC2004]
      \ Perkins, C., \"Minimal Encapsulation within IP\", RFC 2004,\n              October
      1996.\n   [RFC2119]  Bradner, S., \"Key words for use in RFCs to Indicate\n
      \             Requirement Levels\", BCP 14, RFC 2119, March 1997.\n   [RFC2460]
      \ Deering, S. and R. Hinden, \"Internet Protocol, Version 6\n              (IPv6)
      Specification\", RFC 2460, December 1998.\n   [RFC2784]  Farinacci, D., Li,
      T., Hanks, S., Meyer, D., and P.\n              Traina, \"Generic Routing Encapsulation
      (GRE)\", RFC 2784,\n              March 2000.\n   [RFC2890]  Dommety, G., \"Key
      and Sequence Number Extensions to GRE\",\n              RFC 2890, September
      2000.\n   [RFC4164]  Pelletier, G., \"RObust Header Compression (ROHC): Context\n
      \             Replication for ROHC Profiles\", RFC 4164, August 2005.\n   [RFC4302]
      \ Kent, S., \"IP Authentication Header\", RFC 4302,\n              December
      2005.\n   [RFC4997]  Finking, R. and G. Pelletier, \"Formal Notation for RObust\n
      \             Header Compression (ROHC-FN)\", RFC 4997, July 2007.\n   [RFC5795]
      \ Sandlund, K., Pelletier, G., and L-E. Jonsson, \"The RObust\n              Header
      Compression (ROHC) Framework\", RFC 5795,\n              March 2010.\n"
    title: 13.1.  Normative References
  - contents:
    - "13.2.  Informative References\n   [RFC1144]  Jacobson, V., \"Compressing TCP/IP
      headers for low-speed\n              serial links\", RFC 1144, February 1990.\n
      \  [RFC1323]  Jacobson, V., Braden, B., and D. Borman, \"TCP Extensions\n              for
      High Performance\", RFC 1323, May 1992.\n   [RFC2018]  Mathis, M., Mahdavi,
      J., Floyd, S., and A. Romanow, \"TCP\n              Selective Acknowledgment
      Options\", RFC 2018, October 1996.\n   [RFC2507]  Degermark, M., Nordgren, B.,
      and S. Pink, \"IP Header\n              Compression\", RFC 2507, February 1999.\n
      \  [RFC2883]  Floyd, S., Mahdavi, J., Mathis, M., and M. Podolsky, \"An\n              Extension
      to the Selective Acknowledgement (SACK) Option\n              for TCP\", RFC
      2883, July 2000.\n   [RFC3095]  Bormann, C., Burmeister, C., Degermark, M.,
      Fukushima, H.,\n              Hannu, H., Jonsson, L-E., Hakenberg, R., Koren,
      T., Le,\n              K., Liu, Z., Martensson, A., Miyazaki, A., Svanbro, K.,\n
      \             Wiebke, T., Yoshimura, T., and H. Zheng, \"RObust Header\n              Compression
      (ROHC): Framework and four profiles: RTP, UDP,\n              ESP, and uncompressed\",
      RFC 3095, July 2001.\n   [RFC3168]  Ramakrishnan, K., Floyd, S., and D. Black,
      \"The Addition\n              of Explicit Congestion Notification (ECN) to IP\",\n
      \             RFC 3168, September 2001.\n   [RFC3759]  Jonsson, L-E., \"RObust
      Header Compression (ROHC):\n              Terminology and Channel Mapping Examples\",
      RFC 3759,\n              April 2004.\n   [RFC4163]  Jonsson, L-E., \"RObust
      Header Compression (ROHC):\n              Requirements on TCP/IP Header Compression\",
      RFC 4163,\n              August 2005.\n   [RFC4224]  Pelletier, G., Jonsson,
      L-E., and K. Sandlund, \"RObust\n              Header Compression (ROHC): ROHC
      over Channels That Can\n              Reorder Packets\", RFC 4224, January 2006.\n
      \  [RFC4413]  West, M. and S. McCann, \"TCP/IP Field Behavior\", RFC 4413,\n
      \             March 2006.\n   [RFC4996]  Pelletier, G., Sandlund, K., Jonsson,
      L-E., and M. West,\n              \"RObust Header Compression (ROHC): A Profile
      for TCP/IP\n              (ROHC-TCP)\", RFC 4996, July 2007.\n   [RFC5225]  Pelletier,
      G. and K. Sandlund, \"RObust Header Compression\n              Version 2 (ROHCv2):
      Profiles for RTP, UDP, IP, ESP and\n              UDP-Lite\", RFC 5225, April
      2008.\n   [RFC5681]  Allman, M., Paxson, V., and E. Blanton, \"TCP Congestion\n
      \             Control\", RFC 5681, September 2009.\n"
    title: 13.2.  Informative References
  title: 13.  References
- contents:
  - "Authors' Addresses\n   Ghyslain Pelletier\n   InterDigital Communications\n   1000,
    Sherbrooke Street West, 10th floor\n   Montreal, Quebec  H3A 3G4\n   Canada\n
    \  Phone: +46 (0) 70 609 27 73\n   EMail: ghyslain.pelletier@interdigital.com\n
    \  Kristofer Sandlund\n   Ericsson\n   Box 920\n   Lulea  SE-971 28\n   Sweden\n
    \  Phone: +46 (0) 8 404 41 58\n   EMail: kristofer.sandlund@ericsson.com\n   Lars-Erik
    Jonsson\n   Optand 737\n   Ostersund  SE-831 92\n   Sweden\n   Phone: +46 70 365
    20 58\n   EMail: lars-erik@lejonsson.com\n   Mark A West\n   Siemens/Roke Manor\n
    \  Roke Manor Research Ltd.\n   Romsey, Hampshire  SO51 0ZN\n   UK\n   Phone:
    +44 1794 833311\n   EMail: mark.a.west@roke.co.uk\n   URI:   http://www.roke.co.uk\n"
  title: Authors' Addresses
