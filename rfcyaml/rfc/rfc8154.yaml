- contents:
  - '   Parallel NFS (pNFS) Small Computer System Interface (SCSI) Layout

    '
  title: __initial_text__
- contents:
  - "Abstract\n   The Parallel Network File System (pNFS) allows a separation between\n
    \  the metadata (onto a metadata server) and data (onto a storage\n   device)
    for a file.  The Small Computer System Interface (SCSI)\n   layout type is defined
    in this document as an extension to pNFS to\n   allow the use of SCSI-based block
    storage devices.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    7841.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc8154.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2017 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction  . . . . . . . . . . . . . . . . . . .
    . . . . .   3\n     1.1.  Conventions Used in This Document . . . . . . . . .
    . . .   4\n     1.2.  General Definitions . . . . . . . . . . . . . . . . . .
    .   4\n     1.3.  Code Components Licensing Notice  . . . . . . . . . . . .   5\n
    \    1.4.  XDR Description . . . . . . . . . . . . . . . . . . . . .   5\n   2.
    \ SCSI Layout Description . . . . . . . . . . . . . . . . . . .   7\n     2.1.
    \ Background and Architecture . . . . . . . . . . . . . . .   7\n     2.2.  layouttype4
    . . . . . . . . . . . . . . . . . . . . . . .   8\n     2.3.  GETDEVICEINFO .
    . . . . . . . . . . . . . . . . . . . . .   8\n       2.3.1.  Volume Identification
    . . . . . . . . . . . . . . . .   8\n       2.3.2.  Volume Topology . . . . .
    . . . . . . . . . . . . . .  10\n     2.4.  Data Structures: Extents and Extent
    Lists . . . . . . . .  12\n       2.4.1.  Layout Requests and Extent Lists  .
    . . . . . . . . .  15\n       2.4.2.  Layout Commits  . . . . . . . . . . . .
    . . . . . . .  16\n       2.4.3.  Layout Returns  . . . . . . . . . . . . . .
    . . . . .  17\n       2.4.4.  Layout Revocation . . . . . . . . . . . . . . .
    . . .  17\n       2.4.5.  Client Copy-on-Write Processing . . . . . . . . . .
    .  17\n       2.4.6.  Extents Are Permissions . . . . . . . . . . . . . . .  18\n
    \      2.4.7.  Partial-Block Updates . . . . . . . . . . . . . . . .  19\n       2.4.8.
    \ End-of-File Processing  . . . . . . . . . . . . . . .  20\n       2.4.9.  Layout
    Hints  . . . . . . . . . . . . . . . . . . . .  20\n       2.4.10. Client Fencing
    \ . . . . . . . . . . . . . . . . . . .  21\n     2.5.  Crash Recovery Issues
    . . . . . . . . . . . . . . . . . .  22\n     2.6.  Recalling Resources: CB_RECALL_ANY
    \ . . . . . . . . . . .  23\n     2.7.  Transient and Permanent Errors  . . .
    . . . . . . . . . .  23\n     2.8.  Volatile Write Caches . . . . . . . . . .
    . . . . . . . .  24\n   3.  Enforcing NFSv4 Semantics . . . . . . . . . . . .
    . . . . . .  24\n     3.1.  Use of Open Stateids  . . . . . . . . . . . . . .
    . . . .  25\n     3.2.  Enforcing Security Restrictions . . . . . . . . . . .
    . .  26\n     3.3.  Enforcing Locking Restrictions  . . . . . . . . . . . . .
    \ 26\n   4.  Security Considerations . . . . . . . . . . . . . . . . . . .  27\n
    \  5.  IANA Considerations . . . . . . . . . . . . . . . . . . . . .  28\n   6.
    \ Normative References  . . . . . . . . . . . . . . . . . . . .  28\n   Acknowledgments
    . . . . . . . . . . . . . . . . . . . . . . . . .  29\n   Author's Address  .
    . . . . . . . . . . . . . . . . . . . . . . .  30\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   Figure 1 shows the overall architecture of a Parallel NFS
    (pNFS)\n   system:\n        +-----------+\n        |+-----------+                                 +-----------+\n
    \       ||+-----------+                                |           |\n        |||
    \          |       NFSv4.1 + pNFS           |           |\n        +||  Clients
    \ |<------------------------------>|   Server  |\n         +|           |                                |
    \          |\n          +-----------+                                |           |\n
    \              |||                                     +-----------+\n               |||
    \                                          |\n               |||                                           |\n
    \              ||| Storage        +-----------+              |\n               |||
    Protocol       |+-----------+             |\n               ||+----------------||+-----------+
    \ Control   |\n               |+-----------------|||           |    Protocol|\n
    \              +------------------+||  Storage  |------------+\n                                   +|
    \ Systems  |\n                                    +-----------+\n                                 Figure
    1\n   The overall approach is that pNFS-enhanced clients obtain sufficient\n   information
    from the server to enable them to access the underlying\n   storage (on the storage
    systems) directly.  See Section 12 of\n   [RFC5661] for more details.  This document
    is concerned with access\n   from pNFS clients to storage devices over block storage
    protocols\n   based on the SCSI Architecture Model [SAM-5], e.g., the Fibre Channel\n
    \  Protocol (FCP), Internet SCSI (iSCSI), or Serial Attached SCSI (SAS).\n   pNFS
    SCSI layout requires block-based SCSI command sets, for example,\n   SCSI Block
    Commands [SBC3].  While SCSI command sets for non-block-\n   based access exist,
    these are not supported by the SCSI layout type,\n   and all future references
    to SCSI storage devices will imply a block-\n   based SCSI command set.\n   The
    Server to Storage System protocol, called the \"Control Protocol\",\n   is not
    of concern for interoperability, although it will typically be\n   the same SCSI-based
    storage protocol.\n   This document is based on [RFC5663] and makes changes to
    the block\n   layout type to provide a better pNFS layout protocol for SCSI-based\n
    \  storage devices.  Despite these changes, [RFC5663] remains the\n   defining
    document for the existing block layout type. pNFS Block Disk\n   Protection [RFC6688]
    is unnecessary in the context of the SCSI layout\n   type because the new layout
    type provides mandatory disk access\n   protection as part of the layout type
    definition.  In contrast to\n   [RFC5663], this document uses SCSI protocol features
    to provide\n   reliable fencing by using SCSI persistent reservations, and it
    can\n   provide reliable and efficient device discovery by using SCSI device\n
    \  identifiers instead of having to rely on probing all devices\n   potentially
    attached to a client.  This new layout type also\n   optimizes the Input/Output
    (I/O) path by reducing the size of the\n   LAYOUTCOMMIT payload.\n   The above
    two paragraphs summarize the major functional differences\n   from [RFC5663].
    \ There are other minor differences, e.g., the \"base\"\n   volume type in this
    specification is used instead of the \"simple\"\n   volume type in [RFC5663],
    but there are no significant differences in\n   the data structures that describe
    the volume topology above this\n   level (Section 2.3.2) or in the data structures
    that describe extents\n   (Section 2.4).\n"
  - contents:
    - "1.1.  Conventions Used in This Document\n   The key words \"MUST\", \"MUST
      NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\",
      \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this\n   document are to be interpreted
      as described in [RFC2119].\n"
    title: 1.1.  Conventions Used in This Document
  - contents:
    - "1.2.  General Definitions\n   The following definitions are provided for the
      purpose of providing\n   an appropriate context for the reader.\n   Byte:  an
      octet, i.e., a datum exactly 8 bits in length.\n   Client:  the entity that
      accesses the NFS server's resources.  The\n      client may be an application
      that contains the logic to access the\n      NFS server directly.  The client
      may also be the traditional\n      operating system client that provides remote
      file system services\n      for a set of applications.\n   Server:  the entity
      responsible for coordinating client access to a\n      set of file systems and
      is identified by a server owner.\n   Metadata Server (MDS):  a pNFS server that
      provides metadata\n      information for a file system object.  It also is responsible
      for\n      generating layouts for file system objects.  Note that the MDS is\n
      \     also responsible for directory-based operations.\n"
    title: 1.2.  General Definitions
  - contents:
    - "1.3.  Code Components Licensing Notice\n   The external data representation
      (XDR) description and scripts for\n   extracting the XDR description are Code
      Components as described in\n   Section 4 of \"Legal Provisions Relating to IETF
      Documents\" [LEGAL].\n   These Code Components are licensed according to the
      terms of\n   Section 4 of \"Legal Provisions Relating to IETF Documents\".\n"
    title: 1.3.  Code Components Licensing Notice
  - contents:
    - "1.4.  XDR Description\n   This document contains the XDR [RFC4506] description
      of the NFSv4.1\n   SCSI layout protocol.  The XDR description is embedded in
      this\n   document in a way that makes it simple for the reader to extract into\n
      \  a ready-to-compile form.  The reader can feed this document into the\n   following
      shell script to produce the machine-readable XDR\n   description of the NFSv4.1
      SCSI layout:\n    #!/bin/sh\n    grep '^ *///' $* | sed 's?^ */// ??' | sed
      's?^ *///$??'\n   That is, if the above script is stored in a file called \"extract.sh\",\n
      \  and this document is in a file called \"spec.txt\", then the reader can\n
      \  do:\n    sh extract.sh < spec.txt > scsi_prot.x\n   The effect of the script
      is to remove leading white space from each\n   line, plus a sentinel sequence
      of \"///\".\n   The embedded XDR file header follows.  Subsequent XDR descriptions\n
      \  with the sentinel sequence are embedded throughout the document.\n   Note
      that the XDR code contained in this document depends on types\n   from the NFSv4.1
      nfs4_prot.x file [RFC5662].  This includes both NFS\n   types that end with
      a 4, such as offset4, length4, etc., as well as\n   more generic types such
      as uint32_t and uint64_t.\n       /// /*\n       ///  * This code was derived
      from RFC 8154.\n       ///  * Please reproduce this note if possible.\n       ///
      \ */\n       /// /*\n       ///  * Copyright (c) 2017 IETF Trust and the persons\n
      \      ///  * identified as authors of the code.  All rights reserved.\n       ///
      \ *\n       ///  * Redistribution and use in source and binary forms, with\n
      \      ///  * or without modification, are permitted provided that the\n       ///
      \ * following conditions are met:\n       ///  *\n       ///  * - Redistributions
      of source code must retain the above\n       ///  *   copyright notice, this
      list of conditions and the\n       ///  *   following disclaimer.\n       ///
      \ *\n       ///  * - Redistributions in binary form must reproduce the above\n
      \      ///  *   copyright notice, this list of conditions and the\n       ///
      \ *   following disclaimer in the documentation and/or other\n       ///  *
      \  materials provided with the distribution.\n       ///  *\n       ///  * -
      Neither the name of Internet Society, IETF or IETF\n       ///  *   Trust, nor
      the names of specific contributors, may be\n       ///  *   used to endorse
      or promote products derived from this\n       ///  *   software without specific
      prior written permission.\n       ///  *\n       ///  *   THIS SOFTWARE IS PROVIDED
      BY THE COPYRIGHT HOLDERS\n       ///  *   AND CONTRIBUTORS \"AS IS\" AND ANY
      EXPRESS OR IMPLIED\n       ///  *   WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
      THE\n       ///  *   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n       ///
      \ *   FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO\n       ///  *   EVENT
      SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n       ///  *   LIABLE FOR ANY
      DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n       ///  *   EXEMPLARY, OR CONSEQUENTIAL
      DAMAGES (INCLUDING, BUT\n       ///  *   NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
      GOODS OR\n       ///  *   SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n
      \      ///  *   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n       ///
      \ *   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n       ///  *   OR
      TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING\n       ///  *   IN ANY WAY
      OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n       ///  *   ADVISED OF THE POSSIBILITY
      OF SUCH DAMAGE.\n       ///  */\n       ///\n       /// /*\n       ///  *      nfs4_scsi_layout_prot.x\n
      \      ///  */\n       ///\n       /// %#include \"nfsv41.h\"\n       ///\n"
    title: 1.4.  XDR Description
  title: 1.  Introduction
- contents:
  - '2.  SCSI Layout Description

    '
  - contents:
    - "2.1.  Background and Architecture\n   The fundamental storage model supported
      by SCSI storage devices is a\n   logical unit (LU) consisting of a sequential
      series of fixed-size\n   blocks.  Logical units used as devices for NFS SCSI
      layouts, and the\n   SCSI initiators used for the pNFS metadata server and clients,
      MUST\n   support SCSI persistent reservations as defined in [SPC4].\n   A pNFS
      layout for this SCSI class of storage is responsible for\n   mapping from an
      NFS file (or portion of a file) to the blocks of\n   storage volumes that contain
      the file.  The blocks are expressed as\n   extents with 64-bit offsets and lengths
      using the existing NFSv4\n   offset4 and length4 types.  Clients MUST be able
      to perform I/O to\n   the block extents without affecting additional areas of
      storage\n   (especially important for writes); therefore, extents MUST be aligned\n
      \  to logical block size boundaries of the underlying logical units\n   (typically
      512 or 4096 bytes).  For complex volume topologies, the\n   server MUST ensure
      extents are aligned to the logical block size\n   boundaries of the largest
      logical block size in the volume topology.\n   The pNFS operation for requesting
      a layout (LAYOUTGET) includes the\n   \"layoutiomode4 loga_iomode\" argument,
      which indicates whether the\n   requested layout is for read-only use or read-write
      use.  A read-only\n   layout may contain holes that are read as zero, whereas
      a read-write\n   layout will contain allocated but uninitialized storage in
      those\n   holes (read as zero, can be written by client).  This document also\n
      \  supports client participation in copy-on-write (e.g., for file\n   systems
      with snapshots) by providing both read-only and uninitialized\n   storage for
      the same range in a layout.  Reads are initially\n   performed on the read-only
      storage, with writes going to the\n   uninitialized storage.  After the first
      write that initializes the\n   uninitialized storage, all reads are performed
      to that now-\n   initialized writable storage, and the corresponding read-only
      storage\n   is no longer used.\n   The SCSI layout solution expands the security
      responsibilities of the\n   pNFS clients, and there are a number of environments
      where the\n   mandatory-to-implement security properties for NFS cannot be\n
      \  satisfied.  The additional security responsibilities of the client\n   follow,
      and a full discussion is present in Section 4 (\"Security\n   Considerations\").\n
      \  o  Typically, SCSI storage devices provide access control mechanisms\n      (e.g.,
      Logical Unit Number (LUN) mapping and/or masking), which\n      operate at the
      granularity of individual hosts, not individual\n      blocks.  For this reason,
      block-based protection must be provided\n      by the client software.\n   o
      \ Similarly, SCSI storage devices typically are not able to validate\n      NFS
      locks that apply to file regions.  For instance, if a file is\n      covered
      by a mandatory read-only lock, the server can ensure that\n      only readable
      layouts for the file are granted to pNFS clients.\n      However, it is up to
      each pNFS client to ensure that the readable\n      layout is used only to service
      read requests and not to allow\n      writes to the existing parts of the file.\n
      \  Since SCSI storage devices are generally not capable of enforcing\n   such
      file-based security, in environments where pNFS clients cannot\n   be trusted
      to enforce such policies, pNFS SCSI layouts MUST NOT be\n   used.\n"
    title: 2.1.  Background and Architecture
  - contents:
    - "2.2.  layouttype4\n   The layout4 type defined in [RFC5662] is extended with
      a new value as\n   follows:\n        enum layouttype4 {\n            LAYOUT4_NFSV4_1_FILES
      \  = 1,\n            LAYOUT4_OSD2_OBJECTS    = 2,\n            LAYOUT4_BLOCK_VOLUME
      \   = 3,\n            LAYOUT4_SCSI            = 5\n        };\n   This document
      defines the structure associated with the layouttype4\n   value LAYOUT4_SCSI.
      \ [RFC5661] specifies the loc_body structure as an\n   XDR type \"opaque\".
      \ The opaque layout is uninterpreted by the generic\n   pNFS client layers but
      obviously must be interpreted by the layout\n   type implementation.\n"
    title: 2.2.  layouttype4
  - contents:
    - '2.3.  GETDEVICEINFO

      '
    - contents:
      - "2.3.1.  Volume Identification\n   SCSI targets implementing [SPC4] export
        unique LU names for each LU\n   through the Device Identification Vital Product
        Data (VPD) page (page\n   code 0x83), which can be obtained using the INQUIRY
        command with the\n   Enable VPD (EVPD) bit set to one.  This document uses
        a subset of\n   this information to identify LUs backing pNFS SCSI layouts.
        \ The\n   Device Identification VPD page descriptors used to identify LUs
        for\n   use with pNFS SCSI layouts must adhere to the following restrictions:\n
        \  1.  The \"ASSOCIATION\" MUST be set to 0 (The \"DESIGNATOR\" field is\n
        \      associated with the addressed logical unit).\n   2.  The \"DESIGNATOR
        TYPE\" MUST be set to one of four values that are\n       required for the
        mandatory logical unit name in Section 7.7.3 of\n       [SPC4], as explicitly
        listed in the \"pnfs_scsi_designator_type\"\n       enumeration:\n          PS_DESIGNATOR_T10
        - based on T10 vendor ID\n          PS_DESIGNATOR_EUI64 - based on EUI-64\n
        \         PS_DESIGNATOR_NAA - Network Address Authority (NAA)\n          PS_DESIGNATOR_NAME
        - SCSI name string\n   3.  Any other association or designator type MUST NOT
        be used.  Use\n       of T10 vendor IDs is discouraged when one of the other
        types can\n       be used.\n   The \"CODE SET\" VPD page field is stored in
        the \"sbv_code_set\" field\n   of the \"pnfs_scsi_base_volume_info4\" data
        structure, the \"DESIGNATOR\n   TYPE\" is stored in \"sbv_designator_type\",
        and the DESIGNATOR is\n   stored in \"sbv_designator\".  Due to the use of
        an XDR array, the\n   \"DESIGNATOR LENGTH\" field does not need to be set
        separately.  Only\n   certain combinations of \"sbv_code_set\" and \"sbv_designator_type\"
        are\n   valid; please refer to [SPC4] for details, and note that ASCII MAY
        be\n   used as the code set for UTF-8 text that contains only printable\n
        \  ASCII characters.  Note that a Device Identification VPD page MAY\n   contain
        multiple descriptors with the same association, code set, and\n   designator
        type.  Thus, NFS clients MUST check all the descriptors\n   for a possible
        match to \"sbv_code_set\", \"sbv_designator_type\", and\n   \"sbv_designator\".\n
        \  Storage devices such as storage arrays can have multiple physical\n   network
        interfaces that need not be connected to a common network,\n   resulting in
        a pNFS client having simultaneous multipath access to\n   the same storage
        volumes via different ports on different networks.\n   Selection of one or
        multiple ports to access the storage device is\n   left up to the client.\n
        \  Additionally, the server returns a persistent reservation key in the\n
        \  \"sbv_pr_key\" field.  See Section 2.4.10 for more details on the use\n
        \  of persistent reservations.\n"
      title: 2.3.1.  Volume Identification
    - contents:
      - "2.3.2.  Volume Topology\n   The pNFS SCSI layout volume topology is expressed
        in terms of the\n   volume types described below.  The individual components
        of the\n   topology are contained in an array, and components MAY refer to
        other\n   components by using array indices.\n   /// enum pnfs_scsi_volume_type4
        {\n   ///     PNFS_SCSI_VOLUME_SLICE  = 1,  /* volume is a slice of\n   ///
        \                                     another volume */\n   ///     PNFS_SCSI_VOLUME_CONCAT
        = 2,  /* volume is a\n   ///                                      concatenation
        of\n   ///                                      multiple volumes */\n   ///
        \    PNFS_SCSI_VOLUME_STRIPE = 3   /* volume is striped across\n   ///                                      multiple
        volumes */\n   ///     PNFS_SCSI_VOLUME_BASE   = 4,  /* volume maps to a single\n
        \  ///                                      LU */\n   /// };\n   ///\n   ///
        /*\n   ///  * Code sets from SPC-4.\n   ///  */\n   /// enum pnfs_scsi_code_set
        {\n   ///     PS_CODE_SET_BINARY     = 1,\n   ///     PS_CODE_SET_ASCII      =
        2,\n   ///     PS_CODE_SET_UTF8       = 3\n   /// };\n   ///\n   /// /*\n
        \  ///  * Designator types taken from SPC-4.\n   ///  *\n   ///  * Other values
        are allocated in SPC-4 but are not mandatory to\n   ///  * implement or aren't
        logical unit names.\n   ///  */\n   /// enum pnfs_scsi_designator_type {\n
        \  ///     PS_DESIGNATOR_T10      = 1,\n   ///     PS_DESIGNATOR_EUI64    =
        2,\n   ///     PS_DESIGNATOR_NAA      = 3,\n   ///     PS_DESIGNATOR_NAME
        \    = 8\n   /// };\n   ///\n   /// /*\n   ///  * Logical unit name + reservation
        key.\n   ///  */\n   /// struct pnfs_scsi_base_volume_info4 {\n   ///     pnfs_scsi_code_set
        \            sbv_code_set;\n   ///     pnfs_scsi_designator_type      sbv_designator_type;\n
        \  ///     opaque                         sbv_designator<>;\n   ///     uint64_t
        \                      sbv_pr_key;\n   /// };\n   ///\n   /// struct pnfs_scsi_slice_volume_info4
        {\n   ///     offset4  ssv_start;            /* offset of the start of\n   ///
        \                                      the slice in bytes */\n   ///     length4
        \ ssv_length;           /* length of slice in\n   ///                                       bytes
        */\n   ///     uint32_t ssv_volume;           /* array index of sliced\n   ///
        \                                      volume */\n   /// };\n   ///\n   ///\n
        \  /// struct pnfs_scsi_concat_volume_info4 {\n   ///     uint32_t  scv_volumes<>;
        \      /* array indices of volumes\n   ///                                       that
        are concatenated */\n   /// };\n   ///\n   /// struct pnfs_scsi_stripe_volume_info4
        {\n   ///     length4  ssv_stripe_unit;      /* size of stripe in bytes */\n
        \  ///     uint32_t ssv_volumes<>;        /* array indices of\n   ///                                       volumes
        that are striped\n   ///                                       across -- MUST
        be same\n   ///                                       size */\n   /// };\n
        \  ///\n   /// union pnfs_scsi_volume4 switch (pnfs_scsi_volume_type4 type)
        {\n   ///     case PNFS_SCSI_VOLUME_BASE:\n   ///         pnfs_scsi_base_volume_info4
        sv_simple_info;\n   ///     case PNFS_SCSI_VOLUME_SLICE:\n   ///         pnfs_scsi_slice_volume_info4
        sv_slice_info;\n   ///     case PNFS_SCSI_VOLUME_CONCAT:\n   ///         pnfs_scsi_concat_volume_info4
        sv_concat_info;\n   ///     case PNFS_SCSI_VOLUME_STRIPE:\n   ///         pnfs_scsi_stripe_volume_info4
        sv_stripe_info;\n   /// };\n   ///\n   /// /* SCSI layout-specific type for
        da_addr_body */\n   /// struct pnfs_scsi_deviceaddr4 {\n   ///     pnfs_scsi_volume4
        sda_volumes<>; /* array of volumes */\n   /// };\n   ///\n   The \"pnfs_scsi_deviceaddr4\"
        data structure is a structure that allows\n   arbitrarily complex nested volume
        structures to be encoded.  The\n   types of aggregations that are allowed
        are stripes, concatenations,\n   and slices.  Note that the volume topology
        expressed in the\n   \"pnfs_scsi_deviceaddr4\" data structure will always
        resolve to a set\n   of \"pnfs_scsi_volume_type4\" PNFS_SCSI_VOLUME_BASE.
        \ The array of\n   volumes is ordered such that the root of the volume hierarchy
        is the\n   last element of the array.  Concat, slice, and stripe volumes MUST\n
        \  refer to volumes defined by lower indexed elements of the array.\n   The
        \"pnfs_scsi_deviceaddr4\" data structure is returned by the server\n   as
        the storage-protocol-specific opaque field \"da_addr_body\" in the\n   \"device_addr4\"
        data structure by a successful GETDEVICEINFO operation\n   [RFC5661].\n   As
        noted above, all \"device_addr4\" data structures eventually resolve\n   to
        a set of volumes of type PNFS_SCSI_VOLUME_BASE.  Complicated\n   volume hierarchies
        may be composed of dozens of volumes, each with\n   several components; thus,
        the device address may require several\n   kilobytes.  The client SHOULD be
        prepared to allocate a large buffer\n   to contain the result.  In the case
        of the server returning\n   NFS4ERR_TOOSMALL, the client SHOULD allocate a
        buffer of at least\n   gdir_mincount_bytes to contain the expected result
        and retry the\n   GETDEVICEINFO request.\n"
      title: 2.3.2.  Volume Topology
    title: 2.3.  GETDEVICEINFO
  - contents:
    - "2.4.  Data Structures: Extents and Extent Lists\n   A pNFS SCSI layout is a
      list of extents within a flat array of data\n   blocks in a volume.  The details
      of the volume topology can be\n   determined by using the GETDEVICEINFO operation.
      \ The SCSI layout\n   describes the individual block extents on the volume that
      make up the\n   file.  The offsets and length contained in an extent are specified
      in\n   units of bytes.\n   /// enum pnfs_scsi_extent_state4 {\n   ///     PNFS_SCSI_READ_WRITE_DATA
      = 0, /* the data located by\n   ///                                       this
      extent is valid\n   ///                                       for reading and\n
      \  ///                                       writing. */\n   ///     PNFS_SCSI_READ_DATA
      \     = 1,  /* the data located by this\n   ///                                       extent
      is valid for\n   ///                                       reading only; it
      may not\n   ///                                       be written. */\n   ///
      \    PNFS_SCSI_INVALID_DATA   = 2,  /* the location is valid; the\n   ///                                       data
      is invalid.  It is a\n   ///                                       newly (pre-)allocated\n
      \  ///                                       extent.  The client MUST\n   ///
      \                                      not read from this\n   ///                                       space.
      */\n   ///     PNFS_SCSI_NONE_DATA      = 3   /* the location is invalid.\n
      \  ///                                       It is a hole in the file.\n   ///
      \                                      The client MUST NOT read\n   ///                                       from
      or write to this\n   ///                                       space. */\n   ///
      };\n   ///\n   /// struct pnfs_scsi_extent4 {\n   ///     deviceid4    se_vol_id;
      \        /* id of the volume on\n   ///                                        which
      extent of file is\n   ///                                        stored */\n
      \  ///     offset4      se_file_offset;    /* starting byte offset\n   ///                                        in
      the file */\n   ///     length4      se_length;         /* size in bytes of
      the\n   ///                                        extent */\n   ///     offset4
      \     se_storage_offset; /* starting byte offset\n   ///                                        in
      the volume */\n   ///     pnfs_scsi_extent_state4 se_state;\n   ///                                     /*
      state of this extent */\n   /// };\n   ///\n   /// /* SCSI layout-specific type
      for loc_body */\n   /// struct pnfs_scsi_layout4 {\n   ///     pnfs_scsi_extent4
      sl_extents<>;\n   ///                                    /* extents that make
      up this\n   ///                                       layout */\n   /// };\n
      \  ///\n   The SCSI layout consists of a list of extents that map the regions
      of\n   the file to locations on a volume.  The \"se_storage_offset\" field\n
      \  within each extent identifies a location on the volume specified by\n   the
      \"se_vol_id\" field in the extent.  The \"se_vol_id\" itself is\n   shorthand
      for the whole topology of the volume on which the file is\n   stored.  The client
      is responsible for translating this volume-\n   relative offset into an offset
      on the appropriate underlying SCSI LU.\n   Each extent maps a region of the
      file onto a portion of the specified\n   LU.  The \"se_file_offset\", \"se_length\",
      and \"se_state\" fields for an\n   extent returned from the server are valid
      for all extents.  In\n   contrast, the interpretation of the \"se_storage_offset\"
      field depends\n   on the value of \"se_state\" as follows (in increasing order):\n
      \  PNFS_SCSI_READ_WRITE_DATA\n      \"se_storage_offset\" is valid and points
      to valid/initialized data\n      that can be read and written.\n   PNFS_SCSI_READ_DATA\n
      \     \"se_storage_offset\" is valid and points to valid/initialized data\n
      \     that can only be read.  Write operations are prohibited.\n   PNFS_SCSI_INVALID_DATA\n
      \     \"se_storage_offset\" is valid but points to invalid, uninitialized\n
      \     data.  This data MUST not be read from the disk until it has been\n      initialized.
      \ A read request for a PNFS_SCSI_INVALID_DATA extent\n      MUST fill the user
      buffer with zeros, unless the extent is covered\n      by a PNFS_SCSI_READ_DATA
      extent of a copy-on-write file system.\n      Write requests MUST write whole
      server-sized blocks to the disk;\n      bytes not initialized by the user MUST
      be set to zero.  Any write\n      to storage in a PNFS_SCSI_INVALID_DATA extent
      changes the written\n      portion of the extent to PNFS_SCSI_READ_WRITE_DATA;
      the pNFS\n      client is responsible for reporting this change via LAYOUTCOMMIT.\n
      \  PNFS_SCSI_NONE_DATA\n      \"se_storage_offset\" is not valid, and this extent
      MAY not be used\n      to satisfy write requests.  Read requests MAY be satisfied
      by\n      zero-filling as for PNFS_SCSI_INVALID_DATA.  PNFS_SCSI_NONE_DATA\n
      \     extents MAY be returned by requests for readable extents; they are\n      never
      returned if the request was for a writable extent.\n   An extent list contains
      all relevant extents in increasing order of\n   the se_file_offset of each extent;
      any ties are broken by increasing\n   order of the extent state (se_state).\n"
    - contents:
      - "2.4.1.  Layout Requests and Extent Lists\n   Each request for a layout specifies
        at least three parameters: file\n   offset, desired size, and minimum size.
        \ If the status of a request\n   indicates success, the extent list returned
        MUST meet the following\n   criteria:\n   o  A request for a readable (but
        not writable) layout MUST return\n      either PNFS_SCSI_READ_DATA or PNFS_SCSI_NONE_DATA
        extents.  It\n      SHALL NOT return PNFS_SCSI_INVALID_DATA or\n      PNFS_SCSI_READ_WRITE_DATA
        extents.\n   o  A request for a writable layout MUST return\n      PNFS_SCSI_READ_WRITE_DATA
        or PNFS_SCSI_INVALID_DATA extents, and\n      it MAY return additional PNFS_SCSI_READ_DATA
        extents for ranges\n      covered by PNFS_SCSI_INVALID_DATA extents to allow
        client-side\n      copy-on-write operations.  A request for a writable layout
        SHALL\n      NOT return PNFS_SCSI_NONE_DATA extents.\n   o  The first extent
        in the list MUST contain the requested starting\n      offset.\n   o  The
        total size of extents within the requested range MUST cover at\n      least
        the minimum size.  One exception is allowed: the total size\n      MAY be
        smaller if only readable extents were requested and EOF is\n      encountered.\n
        \  o  Extents in the extent list MUST be logically contiguous for a\n      read-only
        layout.  For a read-write layout, the set of writable\n      extents (i.e.,
        excluding PNFS_SCSI_READ_DATA extents) MUST be\n      logically contiguous.
        \ Every PNFS_SCSI_READ_DATA extent in a read-\n      write layout MUST be
        covered by one or more PNFS_SCSI_INVALID_DATA\n      extents.  This overlap
        of PNFS_SCSI_READ_DATA and\n      PNFS_SCSI_INVALID_DATA extents is the only
        permitted extent\n      overlap.\n   o  Extents MUST be ordered in the list
        by starting offset, with\n      PNFS_SCSI_READ_DATA extents preceding PNFS_SCSI_INVALID_DATA\n
        \     extents in the case of equal se_file_offsets.\n   According to [RFC5661],
        if the minimum requested size,\n   loga_minlength, is zero, this is an indication
        to the metadata server\n   that the client desires any layout at offset loga_offset
        or less that\n   the metadata server has \"readily available\".  Given the
        lack of a\n   clear definition of this phrase, in the context of the SCSI
        layout\n   type, when loga_minlength is zero, the metadata server SHOULD do
        the\n   following:\n   o  when processing requests for readable layouts, return
        all such\n      layouts, even if some extents are in the PNFS_SCSI_NONE_DATA\n
        \     state.\n   o  when processing requests for writable layouts, return
        extents that\n      can be returned in the PNFS_SCSI_READ_WRITE_DATA state.\n"
      title: 2.4.1.  Layout Requests and Extent Lists
    - contents:
      - "2.4.2.  Layout Commits\n     ///\n     /// /* SCSI layout-specific type for
        lou_body */\n     ///\n     /// struct pnfs_scsi_range4 {\n     ///     offset4
        \     sr_file_offset;   /* starting byte offset\n     ///                                       in
        the file */\n     ///     length4      sr_length;        /* size in bytes
        */\n     /// };\n     ///\n     /// struct pnfs_scsi_layoutupdate4 {\n     ///
        \    pnfs_scsi_range4 slu_commit_list<>;\n     ///                                    /*
        list of extents that\n     ///                                     * now contain
        valid data.\n     ///                                     */\n     /// };\n
        \  The \"pnfs_scsi_layoutupdate4\" data structure is used by the client as\n
        \  the SCSI layout-specific argument in a LAYOUTCOMMIT operation.  The\n   \"slu_commit_list\"
        field is a list covering regions of the file layout\n   that were previously
        in the PNFS_SCSI_INVALID_DATA state but have\n   been written by the client
        and SHOULD now be considered in the\n   PNFS_SCSI_READ_WRITE_DATA state.  The
        extents in the commit list MUST\n   be disjoint and MUST be sorted by sr_file_offset.
        \ Implementors\n   should be aware that a server MAY be unable to commit regions
        at a\n   granularity smaller than a file system block (typically 4 KB or 8\n
        \  KB).  As noted above, the block size that the server uses is\n   available
        as an NFSv4 attribute, and any extents included in the\n   \"slu_commit_list\"
        MUST be aligned to this granularity and have a size\n   that is a multiple
        of this granularity.  Since the block in question\n   is in state PNFS_SCSI_INVALID_DATA,
        byte ranges not written SHOULD be\n   filled with zeros.  This applies even
        if it appears that the area\n   being written is beyond what the client believes
        to be the end of\n   file.\n"
      title: 2.4.2.  Layout Commits
    - contents:
      - "2.4.3.  Layout Returns\n   A LAYOUTRETURN operation represents an explicit
        release of resources\n   by the client.  This MAY be done in response to a
        CB_LAYOUTRECALL or\n   before any recall, in order to avoid a future CB_LAYOUTRECALL.
        \ When\n   the LAYOUTRETURN operation specifies a LAYOUTRETURN4_FILE return\n
        \  type, then the \"layoutreturn_file4\" data structure specifies the\n   region
        of the file layout that is no longer needed by the client.\n   The LAYOUTRETURN
        operation is done without any data specific to the\n   SCSI layout.  The opaque
        \"lrf_body\" field of the \"layoutreturn_file4\"\n   data structure MUST have
        length zero.\n"
      title: 2.4.3.  Layout Returns
    - contents:
      - "2.4.4.  Layout Revocation\n   Layouts MAY be unilaterally revoked by the
        server due to the client's\n   lease time expiring or the client failing to
        return a layout that has\n   been recalled in a timely manner.  For the SCSI
        layout type, this is\n   accomplished by fencing off the client from access
        to storage as\n   described in Section 2.4.10.  When this is done, it is necessary
        that\n   all I/Os issued by the fenced-off client be rejected by the storage.\n
        \  This includes any in-flight I/Os that the client issued before the\n   layout
        was revoked.\n   Note that the granularity of this operation can only be at
        the host/\n   LU level.  Thus, if one of a client's layouts is unilaterally
        revoked\n   by the server, it will effectively render useless *all* of the\n
        \  client's layouts for files located on the storage units comprising\n   the
        volume.  This may render useless the client's layouts for files\n   in other
        file systems.  See Section 2.4.10.5 for a discussion of\n   recovery from
        fencing.\n"
      title: 2.4.4.  Layout Revocation
    - contents:
      - "2.4.5.  Client Copy-on-Write Processing\n   Copy-on-write is a mechanism
        used to support file and/or file system\n   snapshots.  When writing to unaligned
        regions, or to regions smaller\n   than a file system block, the writer MUST
        copy the portions of the\n   original file data to a new location on disk.
        \ This behavior can be\n   implemented either on the client or the server.
        \ The paragraphs below\n   describe how a pNFS SCSI layout client implements
        access to a file\n   that requires copy-on-write semantics.\n   Distinguishing
        the PNFS_SCSI_READ_WRITE_DATA and PNFS_SCSI_READ_DATA\n   extent types in
        combination with the allowed overlap of\n   PNFS_SCSI_READ_DATA extents with
        PNFS_SCSI_INVALID_DATA extents\n   allows copy-on-write processing to be done
        by pNFS clients.  In\n   classic NFS, this operation would be done by the
        server.  Since pNFS\n   enables clients to do direct block access, it is useful
        for clients\n   to participate in copy-on-write operations.  All SCSI pNFS
        clients\n   MUST support this copy-on-write processing.\n   When a client
        wishes to write data covered by a PNFS_SCSI_READ_DATA\n   extent, it MUST
        have requested a writable layout from the server;\n   that layout will contain
        PNFS_SCSI_INVALID_DATA extents to cover all\n   the data ranges of that layout's
        PNFS_SCSI_READ_DATA extents.  More\n   precisely, for any se_file_offset range
        covered by one or more\n   PNFS_SCSI_READ_DATA extents in a writable layout,
        the server MUST\n   include one or more PNFS_SCSI_INVALID_DATA extents in
        the layout that\n   cover the same se_file_offset range.  When performing
        a write to such\n   an area of a layout, the client MUST effectively copy
        the data from\n   the PNFS_SCSI_READ_DATA extent for any partial blocks of\n
        \  se_file_offset and range, merge in the changes to be written, and\n   write
        the result to the PNFS_SCSI_INVALID_DATA extent for the blocks\n   for that
        se_file_offset and range.  That is, if entire blocks of data\n   are to be
        overwritten by an operation, the corresponding\n   PNFS_SCSI_READ_DATA blocks
        need not be fetched, but any partial-\n   block writes MUST be merged with
        data fetched via PNFS_SCSI_READ_DATA\n   extents before storing the result
        via PNFS_SCSI_INVALID_DATA extents.\n   For the purposes of this discussion,
        \"entire blocks\" and \"partial\n   blocks\" refer to the block size of the
        server's file system.  Storing\n   of data in a PNFS_SCSI_INVALID_DATA extent
        converts the written\n   portion of the PNFS_SCSI_INVALID_DATA extent to a\n
        \  PNFS_SCSI_READ_WRITE_DATA extent; all subsequent reads MUST be\n   performed
        from this extent; the corresponding portion of the\n   PNFS_SCSI_READ_DATA
        extent MUST NOT be used after storing data in a\n   PNFS_SCSI_INVALID_DATA
        extent.  If a client writes only a portion of\n   an extent, the extent MAY
        be split at block-aligned boundaries.\n   When a client wishes to write data
        to a PNFS_SCSI_INVALID_DATA extent\n   that is not covered by a PNFS_SCSI_READ_DATA
        extent, it MUST treat\n   this write identically to a write to a file not
        involved with copy-\n   on-write semantics.  Thus, data MUST be written in
        at least block-\n   sized increments and aligned to multiples of block-sized
        offsets, and\n   unwritten portions of blocks MUST be zero filled.\n"
      title: 2.4.5.  Client Copy-on-Write Processing
    - contents:
      - "2.4.6.  Extents Are Permissions\n   Layout extents returned to pNFS clients
        grant permission to read or\n   write; PNFS_SCSI_READ_DATA and PNFS_SCSI_NONE_DATA
        are read-only\n   (PNFS_SCSI_NONE_DATA reads as zeros), and PNFS_SCSI_READ_WRITE_DATA\n
        \  and PNFS_SCSI_INVALID_DATA are read-write (PNFS_SCSI_INVALID_DATA\n   reads
        as zeros; any write converts it to PNFS_SCSI_READ_WRITE_DATA).\n   This is
        the only means a client has of obtaining permission to\n   perform direct
        I/O to storage devices; a pNFS client MUST NOT perform\n   direct I/O operations
        that are not permitted by an extent held by the\n   client.  Client adherence
        to this rule places the pNFS server in\n   control of potentially conflicting
        storage device operations,\n   enabling the server to determine what does
        conflict and how to avoid\n   conflicts by granting and recalling extents
        to/from clients.\n   If a client makes a layout request that conflicts with
        an existing\n   layout delegation, the request will be rejected with the error\n
        \  NFS4ERR_LAYOUTTRYLATER.  This client is then expected to retry the\n   request
        after a short interval.  During this interval, the server\n   SHOULD recall
        the conflicting portion of the layout delegation from\n   the client that
        currently holds it.  This reject-and-retry approach\n   does not prevent client
        starvation when there is contention for the\n   layout of a particular file.
        \ For this reason, a pNFS server SHOULD\n   implement a mechanism to prevent
        starvation.  One possibility is that\n   the server can maintain a queue of
        rejected layout requests.  Each\n   new layout request can be checked to see
        if it conflicts with a\n   previous rejected request, and if so, the newer
        request can be\n   rejected.  Once the original requesting client retries
        its request,\n   its entry in the rejected request queue can be cleared, or
        the entry\n   in the rejected request queue can be removed when it reaches
        a\n   certain age.\n   NFSv4 supports mandatory locks and share reservations.
        \ These are\n   mechanisms that clients can use to restrict the set of I/O
        operations\n   that are permissible to other clients.  Since all I/O operations\n
        \  ultimately arrive at the NFSv4 server for processing, the server is\n   in
        a position to enforce these restrictions.  However, with pNFS\n   layouts,
        I/Os will be issued from the clients that hold the layouts\n   directly to
        the storage devices that host the data.  These devices\n   have no knowledge
        of files, mandatory locks, or share reservations,\n   and they are not in
        a position to enforce such restrictions.  For\n   this reason, the NFSv4 server
        MUST NOT grant layouts that conflict\n   with mandatory locks or share reservations.
        \ Further, if a\n   conflicting mandatory lock request or a conflicting OPEN
        request\n   arrives at the server, the server MUST recall the part of the
        layout\n   in conflict with the request before granting the request.\n"
      title: 2.4.6.  Extents Are Permissions
    - contents:
      - "2.4.7.  Partial-Block Updates\n   SCSI storage devices do not provide byte
        granularity access and can\n   only perform read and write operations atomically
        on a block\n   granularity.  Writes to SCSI storage devices thus require read-\n
        \  modify-write cycles to write data that is smaller than the block size\n
        \  or that is otherwise not block aligned.  Write operations from\n   multiple
        clients to the same block can thus lead to data corruption\n   even if the
        byte range written by the applications does not overlap.\n   When there are
        multiple clients who wish to access the same block, a\n   pNFS server MUST
        avoid these conflicts by implementing a concurrency\n   control policy of
        single writer XOR multiple readers for a given data\n   block.\n"
      title: 2.4.7.  Partial-Block Updates
    - contents:
      - "2.4.8.  End-of-File Processing\n   The end-of-file location can be changed
        in two ways: implicitly as\n   the result of a WRITE or LAYOUTCOMMIT beyond
        the current end of file\n   or explicitly as the result of a SETATTR request.
        \ Typically, when a\n   file is truncated by an NFSv4 client via the SETATTR
        call, the server\n   frees any disk blocks belonging to the file that are
        beyond the new\n   end-of-file byte and MUST write zeros to the portion of
        the new end-\n   of-file block beyond the new end-of-file byte.  These actions
        render\n   semantically invalid any pNFS layouts that refer to the blocks
        that\n   are freed or written.  Therefore, the server MUST recall from clients\n
        \  the portions of any pNFS layouts that refer to blocks that will be\n   freed
        or written by the server before effecting the file truncation.\n   These recalls
        may take time to complete; as explained in [RFC5661],\n   if the server cannot
        respond to the client SETATTR request in a\n   reasonable amount of time,
        it SHOULD reply to the client with the\n   error NFS4ERR_DELAY.\n   Blocks
        in the PNFS_SCSI_INVALID_DATA state that lie beyond the new\n   end-of-file
        block present a special case.  The server has reserved\n   these blocks for
        use by a pNFS client with a writable layout for the\n   file, but the client
        has yet to commit the blocks, and they are not\n   yet a part of the file
        mapping on disk.  The server MAY free these\n   blocks while processing the
        SETATTR request.  If so, the server MUST\n   recall any layouts from pNFS
        clients that refer to the blocks before\n   processing the truncate.  If the
        server does not free the\n   PNFS_SCSI_INVALID_DATA blocks while processing
        the SETATTR request,\n   it need not recall layouts that refer only to the\n
        \  PNFS_SCSI_INVALID_DATA blocks.\n   When a file is extended implicitly by
        a WRITE or LAYOUTCOMMIT beyond\n   the current end of file, or extended explicitly
        by a SETATTR request,\n   the server need not recall any portions of any pNFS
        layouts.\n"
      title: 2.4.8.  End-of-File Processing
    - contents:
      - "2.4.9.  Layout Hints\n   The layout hint attribute specified in [RFC5661]
        is not supported by\n   the SCSI layout, and the pNFS server MUST reject setting
        a layout\n   hint attribute with a loh_type value of LAYOUT4_SCSI_VOLUME during\n
        \  OPEN or SETATTR operations.  On a file system only supporting the\n   SCSI
        layout, a server MUST NOT report the layout_hint attribute in\n   the supported_attrs
        attribute.\n"
      title: 2.4.9.  Layout Hints
    - contents:
      - "2.4.10.  Client Fencing\n   The pNFS SCSI protocol must handle situations
        in which a system\n   failure, typically a network connectivity issue, requires
        the server\n   to unilaterally revoke extents from a client after the client
        fails\n   to respond to a CB_LAYOUTRECALL request.  This is implemented by\n
        \  fencing off a non-responding client from access to the storage\n   device.\n
        \  The pNFS SCSI protocol implements fencing using persistent\n   reservations
        (PRs), similar to the fencing method used by existing\n   shared disk file
        systems.  By placing a PR of type \"Exclusive Access\n   - Registrants Only\"
        on each SCSI LU exported to pNFS clients, the MDS\n   prevents access from
        any client that does not have an outstanding\n   device ID that gives the
        client a reservation key to access the LU\n   and allows the MDS to revoke
        access to the logical unit at any time.\n"
      - contents:
        - "2.4.10.1.  PRs -- Key Generation\n   To allow fencing individual systems,
          each system MUST use a unique\n   persistent reservation key.  [SPC4] does
          not specify a way to\n   generate keys.  This document assigns the burden
          to generate unique\n   keys to the MDS, which MUST generate a key for itself
          before\n   exporting a volume and a key for each client that accesses SCSI\n
          \  layout volumes.  Individuals keys for each volume that a client can\n
          \  access are permitted but not required.\n"
        title: 2.4.10.1.  PRs -- Key Generation
      - contents:
        - "2.4.10.2.  PRs -- MDS Registration and Reservation\n   Before returning
          a PNFS_SCSI_VOLUME_BASE volume to the client, the\n   MDS needs to prepare
          the volume for fencing using PRs.  This is done\n   by registering the reservation
          generated for the MDS with the device\n   using the \"PERSISTENT RESERVE
          OUT\" command with a service action of\n   \"REGISTER\", followed by a \"PERSISTENT
          RESERVE OUT\" command with a\n   service action of \"RESERVE\" and the \"TYPE\"
          field set to 8h (Exclusive\n   Access - Registrants Only).  To make sure
          all I_T nexuses (see\n   Section 3.1.45 of [SAM-5]) are registered, the
          MDS SHOULD set the\n   \"All Target Ports\" (ALL_TG_PT) bit when registering
          the key or\n   otherwise ensure the registration is performed for each target
          port,\n   and it MUST perform registration for each initiator port.\n"
        title: 2.4.10.2.  PRs -- MDS Registration and Reservation
      - contents:
        - "2.4.10.3.  PRs -- Client Registration\n   Before performing the first I/O
          to a device returned from a\n   GETDEVICEINFO operation, the client will
          register the registration\n   key returned in sbv_pr_key with the storage
          device by issuing a\n   \"PERSISTENT RESERVE OUT\" command with a service
          action of REGISTER\n   with the \"SERVICE ACTION RESERVATION KEY\" set to
          the reservation key\n   returned in sbv_pr_key.  To make sure all I_T nexuses
          are registered,\n   the client SHOULD set the \"All Target Ports\" (ALL_TG_PT)
          bit when\n   registering the key or otherwise ensure the registration is
          performed\n   for each target port, and it MUST perform registration for
          each\n   initiator port.\n   When a client stops using a device earlier
          returned by GETDEVICEINFO,\n   it MUST unregister the earlier registered
          key by issuing a\n   \"PERSISTENT RESERVE OUT\" command with a service action
          of \"REGISTER\"\n   with the \"RESERVATION KEY\" set to the earlier registered
          reservation\n   key.\n"
        title: 2.4.10.3.  PRs -- Client Registration
      - contents:
        - "2.4.10.4.  PRs -- Fencing Action\n   In case of a non-responding client,
          the MDS fences the client by\n   issuing a \"PERSISTENT RESERVE OUT\" command
          with the service action\n   set to \"PREEMPT\" or \"PREEMPT AND ABORT\",
          the \"RESERVATION KEY\" field\n   set to the server's reservation key, the
          service action \"RESERVATION\n   KEY\" field set to the reservation key
          associated with the non-\n   responding client, and the \"TYPE\" field set
          to 8h (Exclusive Access -\n   Registrants Only).\n   After the MDS preempts
          a client, all client I/O to the LU fails.  The\n   client SHOULD at this
          point return any layout that refers to the\n   device ID that points to
          the LU.  Note that the client can\n   distinguish I/O errors due to fencing
          from other errors based on the\n   \"RESERVATION CONFLICT\" SCSI status.
          \ Refer to [SPC4] for details.\n"
        title: 2.4.10.4.  PRs -- Fencing Action
      - contents:
        - "2.4.10.5.  Client Recovery after a Fence Action\n   A client that detects
          a \"RESERVATION CONFLICT\" SCSI status (I/O\n   error) on the storage devices
          MUST commit all layouts that use the\n   storage device through the MDS,
          return all outstanding layouts for\n   the device, forget the device ID,
          and unregister the reservation key.\n   Future GETDEVICEINFO calls MAY refer
          to the storage device again, in\n   which case the client will perform a
          new registration based on the\n   key provided (via sbv_pr_key) at that
          time.\n"
        title: 2.4.10.5.  Client Recovery after a Fence Action
      title: 2.4.10.  Client Fencing
    title: '2.4.  Data Structures: Extents and Extent Lists'
  - contents:
    - "2.5.  Crash Recovery Issues\n   A critical requirement in crash recovery is
      that both the client and\n   the server know when the other has failed.  Additionally,
      it is\n   required that a client sees a consistent view of data across server\n
      \  restarts.  These requirements and a full discussion of crash recovery\n   issues
      are covered in Section 8.4 (\"Crash Recovery\") of the NFSv4.1\n   specification
      [RFC5661].  This document contains additional crash\n   recovery material specific
      only to the SCSI layout.\n   When the server crashes while the client holds
      a writable layout, the\n   client has written data to blocks covered by the
      layout, and the\n   blocks are still in the PNFS_SCSI_INVALID_DATA state, the
      client has\n   two options for recovery.  If the data that has been written
      to these\n   blocks is still cached by the client, the client can simply re-write\n
      \  the data via NFSv4 once the server has come back online.  However, if\n   the
      data is no longer in the client's cache, the client MUST NOT\n   attempt to
      source the data from the data servers.  Instead, it SHOULD\n   attempt to commit
      the blocks in question to the server during the\n   server's recovery grace
      period by sending a LAYOUTCOMMIT with the\n   \"loca_reclaim\" flag set to true.
      \ This process is described in detail\n   in Section 18.42.4 of [RFC5661].\n"
    title: 2.5.  Crash Recovery Issues
  - contents:
    - "2.6.  Recalling Resources: CB_RECALL_ANY\n   The server MAY decide that it
      cannot hold all of the state for\n   layouts without running out of resources.
      \ In such a case, it is free\n   to recall individual layouts using CB_LAYOUTRECALL
      to reduce the\n   load, or it MAY choose to request that the client return any
      layout.\n   The NFSv4.1 specification [RFC5661] defines the following types:\n
      \      const RCA4_TYPE_MASK_BLK_LAYOUT = 4;\n       struct CB_RECALL_ANY4args
      {\n              uint32_t      craa_objects_to_keep;\n              bitmap4
      \      craa_type_mask;\n       };\n   When the server sends a CB_RECALL_ANY
      request to a client specifying\n   the RCA4_TYPE_MASK_BLK_LAYOUT bit in craa_type_mask,
      the client\n   SHOULD immediately respond with NFS4_OK and then asynchronously\n
      \  return complete file layouts until the number of files with layouts\n   cached
      on the client is less than craa_object_to_keep.\n"
    title: '2.6.  Recalling Resources: CB_RECALL_ANY'
  - contents:
    - "2.7.  Transient and Permanent Errors\n   The server may respond to LAYOUTGET
      with a variety of error statuses.\n   These errors can convey transient conditions
      or more permanent\n   conditions that are unlikely to be resolved soon.\n   The
      error NFS4ERR_RECALLCONFLICT indicates that the server has\n   recently issued
      a CB_LAYOUTRECALL to the requesting client, making it\n   necessary for the
      client to respond to the recall before processing\n   the layout request.  A
      client can wait for that recall to be received\n   and processed, or it can
      retry as NFS4ERR_TRYLATER, as described\n   below.\n   The error NFS4ERR_TRYLATER
      is used to indicate that the server cannot\n   immediately grant the layout
      to the client.  This may be due to\n   constraints on writable sharing of blocks
      by multiple clients or to a\n   conflict with a recallable lock (e.g., a delegation).
      \ In either\n   case, a reasonable approach for the client is to wait several\n
      \  milliseconds and retry the request.  The client SHOULD track the\n   number
      of retries, and if forward progress is not made, the client\n   SHOULD abandon
      the attempt to get a layout and perform READ and WRITE\n   operations by sending
      them to the server.\n   The error NFS4ERR_LAYOUTUNAVAILABLE MAY be returned
      by the server if\n   layouts are not supported for the requested file or its
      containing\n   file system.  The server MAY also return this error code if the\n
      \  server is in the process of migrating the file from secondary\n   storage,
      there is a conflicting lock that would prevent the layout\n   from being granted,
      or any other reason causes the server to be\n   unable to supply the layout.
      \ As a result of receiving\n   NFS4ERR_LAYOUTUNAVAILABLE, the client SHOULD
      abandon the attempt to\n   get a layout and perform READ and WRITE operations
      by sending them to\n   the MDS.  It is expected that a client will not cache
      the file's\n   layoutunavailable state forever.  In particular, when the file
      is\n   closed or opened by the client, issuing a new LAYOUTGET is\n   appropriate.\n"
    title: 2.7.  Transient and Permanent Errors
  - contents:
    - "2.8.  Volatile Write Caches\n   Many storage devices implement volatile write
      caches that require an\n   explicit flush to persist the data from write operations
      to stable\n   storage.  Storage devices implementing [SBC3] should indicate
      a\n   volatile write cache by setting the Write Cache Enable (WCE) bit to 1\n
      \  in the Caching mode page.  When a volatile write cache is used, the\n   pNFS
      server MUST ensure the volatile write cache has been committed\n   to stable
      storage before the LAYOUTCOMMIT operation returns by using\n   one of the SYNCHRONIZE
      CACHE commands.\n"
    title: 2.8.  Volatile Write Caches
  title: 2.  SCSI Layout Description
- contents:
  - "3.  Enforcing NFSv4 Semantics\n   The functionality provided by SCSI persistent
    reservations makes it\n   possible for the MDS to control access by individual
    client machines\n   to specific LUs.  Individual client machines may be allowed
    to or\n   prevented from reading or writing to certain block devices.  Finer-\n
    \  grained access control methods are not generally available.\n   For this reason,
    certain responsibilities for enforcing NFSv4\n   semantics, including security
    and locking, are delegated to pNFS\n   clients when SCSI layouts are being used.
    \ The metadata server's role\n   is to only grant layouts appropriately, and the
    pNFS clients have to\n   be trusted to only perform accesses allowed by the layout
    extents\n   they currently hold (e.g., not access storage for files on which a\n
    \  layout extent is not held).  In general, the server will not be able\n   to
    prevent a client that holds a layout for a file from accessing\n   parts of the
    physical disk not covered by the layout.  Similarly, the\n   server will not be
    able to prevent a client from accessing blocks\n   covered by a layout that it
    has already returned.  The pNFS client\n   must respect the layout model for this
    mapping type to appropriately\n   respect NFSv4 semantics.\n   Furthermore, there
    is no way for the storage to determine the\n   specific NFSv4 entity (principal,
    openowner, lockowner) on whose\n   behalf the I/O operation is being done.  This
    fact may limit the\n   functionality to be supported and require the pNFS client
    to\n   implement server policies other than those describable by layouts.\n   In
    cases in which layouts previously granted become invalid, the\n   server has the
    option of recalling them.  In situations in which\n   communication difficulties
    prevent this from happening, layouts may\n   be revoked by the server.  This revocation
    is accompanied by changes\n   in persistent reservation that have the effect of
    preventing SCSI\n   access to the LUs in question by the client.\n"
  - contents:
    - "3.1.  Use of Open Stateids\n   The effective implementation of these NFSv4
      semantic constraints is\n   complicated by the different granularities of the
      actors for the\n   different types of the functionality to be enforced:\n   o
      \ To enforce security constraints for particular principals.\n   o  To enforce
      locking constraints for particular owners (openowners\n      and lockowners).\n
      \  Fundamental to enforcing both of these sorts of constraints is the\n   principle
      that a pNFS client must not issue a SCSI I/O operation\n   unless it possesses
      both:\n   o  A valid open stateid for the file in question, performing the I/O\n
      \     that allows I/O of the type in question, which is associated with\n      the
      openowner and principal on whose behalf the I/O is to be done.\n   o  A valid
      layout stateid for the file in question that covers the\n      byte range on
      which the I/O is to be done and that allows I/O of\n      that type to be done.\n
      \  As a result, if the equivalent of I/O with an anonymous or write-\n   bypass
      stateid is to be done, it MUST NOT by done using the pNFS SCSI\n   layout type.
      \ The client MAY attempt such I/O using READs and WRITEs\n   that do not use
      pNFS and are directed to the MDS.\n   When open stateids are revoked, due to
      lease expiration or any form\n   of administrative revocation, the server MUST
      recall all layouts that\n   allow I/O to be done on any of the files for which
      open revocation\n   happens.  When there is a failure to successfully return
      those\n   layouts, the client MUST be fenced.\n"
    title: 3.1.  Use of Open Stateids
  - contents:
    - "3.2.  Enforcing Security Restrictions\n   The restriction noted above provides
      adequate enforcement of\n   appropriate security restriction when the principal
      issuing the I/O\n   is the same as that opening the file.  The server is responsible
      for\n   checking that the I/O mode requested by the OPEN is allowed for the\n
      \  principal doing the OPEN.  If the correct sort of I/O is done on\n   behalf
      of the same principal, then the security restriction is\n   thereby enforced.\n
      \  If I/O is done by a principal different from the one that opened the\n   file,
      the client SHOULD send the I/O to be performed by the metadata\n   server rather
      than doing it directly to the storage device.\n"
    title: 3.2.  Enforcing Security Restrictions
  - contents:
    - "3.3.  Enforcing Locking Restrictions\n   Mandatory enforcement of whole-file
      locking by means of share\n   reservations is provided when the pNFS client
      obeys the requirement\n   set forth in Section 3.1.  Since performing I/O requires
      a valid open\n   stateid, an I/O that violates an existing share reservation
      would\n   only be possible when the server allows conflicting open stateids
      to\n   exist.\n   The nature of the SCSI layout type is that such implementation/\n
      \  enforcement of mandatory byte-range locks is very difficult.  Given\n   that
      layouts are granted to clients rather than owners, the pNFS\n   client is in
      no position to successfully arbitrate among multiple\n   lockowners on the same
      client.  Suppose lockowner A is doing a write\n   and, while the I/O is pending,
      lockowner B requests a mandatory byte-\n   range lock for a byte range potentially
      overlapping the pending I/O.\n   In such a situation, the lock request cannot
      be granted while the I/O\n   is pending.  In a non-pNFS environment, the server
      would have to wait\n   for pending I/O before granting the mandatory byte-range
      lock.  In\n   the pNFS environment, the server does not issue the I/O and is
      thus\n   in no position to wait for its completion.  The server may recall\n
      \  such layouts, but in doing so, it has no way of distinguishing those\n   being
      used by lockowners A and B, making it difficult to allow B to\n   perform I/O
      while forbidding A from doing so.  Given this fact, the\n   MDS need to successfully
      recall all layouts that overlap the range\n   being locked before returning
      a successful response to the LOCK\n   request.  While the lock is in effect,
      the server SHOULD respond to\n   requests for layouts that overlap a currently
      locked area with\n   NFS4ERR_LAYOUTUNAVAILABLE.  To simplify the required logic,
      a server\n   MAY do this for all layout requests on the file in question as
      long\n   as there are any byte-range locks in effect.\n   Given these difficulties,
      it may be difficult for servers supporting\n   mandatory byte-range locks to
      also support SCSI layouts.  Servers can\n   support advisory byte-range locks
      instead.  The NFSv4 protocol\n   currently has no way of determining whether
      byte-range lock support\n   on a particular file system will be mandatory or
      advisory, except by\n   trying operation, which would conflict if mandatory
      locking is in\n   effect.  Therefore, to avoid confusion, servers SHOULD NOT
      switch\n   between mandatory and advisory byte-range locking based on whether\n
      \  any SCSI layouts have been obtained or whether a client that has\n   obtained
      a SCSI layout has requested a byte-range lock.\n"
    title: 3.3.  Enforcing Locking Restrictions
  title: 3.  Enforcing NFSv4 Semantics
- contents:
  - "4.  Security Considerations\n   Access to SCSI storage devices is logically at
    a lower layer of the\n   I/O stack than NFSv4; hence, NFSv4 security is not directly\n
    \  applicable to protocols that access such storage directly.  Depending\n   on
    the protocol, some of the security mechanisms provided by NFSv4\n   (e.g., encryption
    and cryptographic integrity) may not be available\n   or may be provided via different
    means.  At one extreme, pNFS with\n   SCSI layouts can be used with storage access
    protocols (e.g., Serial\n   Attached SCSI [SAS3]) that provide essentially no
    security\n   functionality.  At the other extreme, pNFS may be used with storage\n
    \  protocols such as iSCSI [RFC7143] that can provide significant\n   security
    functionality.  It is the responsibility of those\n   administering and deploying
    pNFS with a SCSI storage access protocol\n   to ensure that appropriate protection
    is provided to that protocol\n   (physical security is a common means for protocols
    not based on IP).\n   In environments where the security requirements for the
    storage\n   protocol cannot be met, pNFS SCSI layouts SHOULD NOT be used.\n   When
    using IP-based storage protocols such as iSCSI, IPsec should be\n   used as outlined
    in [RFC3723] and updated in [RFC7146].\n   When security is available for a storage
    protocol, it is generally at\n   a different granularity and with a different
    notion of identity than\n   NFSv4 (e.g., NFSv4 controls user access to files,
    and iSCSI controls\n   initiator access to volumes).  The responsibility for enforcing\n
    \  appropriate correspondences between these security layers is placed\n   upon
    the pNFS client.  As with the issues in the first paragraph of\n   this section,
    in environments where the security requirements are\n   such that client-side
    protection from access to storage outside of\n   the layout is not sufficient,
    pNFS SCSI layouts SHOULD NOT be used.\n"
  title: 4.  Security Considerations
- contents:
  - "5.  IANA Considerations\n   IANA has assigned a new pNFS layout type in the \"pNFS
    Layout Types\n   Registry\" as follows:\n    Layout Type Name: LAYOUT4_SCSI\n
    \   Value:            0x00000005\n    RFC:              RFC 8154\n    How:              L\n
    \   Minor Versions:   1\n"
  title: 5.  IANA Considerations
- contents:
  - "6.  Normative References\n   [LEGAL]    IETF Trust, \"Legal Provisions Relating
    to IETF Documents\",\n              March 2015, <http://trustee.ietf.org/docs/\n
    \             IETF-Trust-License-Policy.pdf>.\n   [RFC2119]  Bradner, S., \"Key
    words for use in RFCs to Indicate\n              Requirement Levels\", BCP 14,
    RFC 2119,\n              DOI 10.17487/RFC2119, March 1997,\n              <http://www.rfc-editor.org/info/rfc2119>.\n
    \  [RFC3723]  Aboba, B., Tseng, J., Walker, J., Rangan, V., and F.\n              Travostino,
    \"Securing Block Storage Protocols over IP\",\n              RFC 3723, DOI 10.17487/RFC3723,
    April 2004,\n              <http://www.rfc-editor.org/info/rfc3723>.\n   [RFC4506]
    \ Eisler, M., Ed., \"XDR: External Data Representation\n              Standard\",
    STD 67, RFC 4506, DOI 10.17487/RFC4506, May\n              2006, <http://www.rfc-editor.org/info/rfc4506>.\n
    \  [RFC5661]  Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed.,\n              \"Network
    File System (NFS) Version 4 Minor Version 1\n              Protocol\", RFC 5661,
    DOI 10.17487/RFC5661, January 2010,\n              <http://www.rfc-editor.org/info/rfc5661>.\n
    \  [RFC5662]  Shepler, S., Ed., Eisler, M., Ed., and D. Noveck, Ed.,\n              \"Network
    File System (NFS) Version 4 Minor Version 1\n              External Data Representation
    Standard (XDR) Description\",\n              RFC 5662, DOI 10.17487/RFC5662, January
    2010,\n              <http://www.rfc-editor.org/info/rfc5662>.\n   [RFC5663]  Black,
    D., Fridella, S., and J. Glasgow, \"Parallel NFS\n              (pNFS) Block/Volume
    Layout\", RFC 5663,\n              DOI 10.17487/RFC5663, January 2010,\n              <http://www.rfc-editor.org/info/rfc5663>.\n
    \  [RFC6688]  Black, D., Ed., Glasgow, J., and S. Faibish, \"Parallel NFS\n              (pNFS)
    Block Disk Protection\", RFC 6688,\n              DOI 10.17487/RFC6688, July 2012,\n
    \             <http://www.rfc-editor.org/info/rfc6688>.\n   [RFC7143]  Chadalapaka,
    M., Satran, J., Meth, K., and D. Black,\n              \"Internet Small Computer
    System Interface (iSCSI) Protocol\n              (Consolidated)\", RFC 7143, DOI
    10.17487/RFC7143, April\n              2014, <http://www.rfc-editor.org/info/rfc7143>.\n
    \  [RFC7146]  Black, D. and P. Koning, \"Securing Block Storage Protocols\n              over
    IP: RFC 3723 Requirements Update for IPsec v3\",\n              RFC 7146, DOI
    10.17487/RFC7146, April 2014,\n              <http://www.rfc-editor.org/info/rfc7146>.\n
    \  [SAM-5]    INCITS Technical Committee T10, \"Information Technology -\n              SCSI
    Architecture Model - 5 (SAM-5)\", ANSI\n              INCITS 515-2016, 2016.\n
    \  [SAS3]     INCITS Technical Committee T10, \"Information technology -\n              Serial
    Attached SCSI-3 (SAS-3)\", ANSI INCITS 519-2014,\n              ISO/IEC 14776-154,
    2014.\n   [SBC3]     INCITS Technical Committee T10, \"Information Technology
    -\n              SCSI Block Commands - 3 (SBC-3)\", ANSI INCITS 514-2014,\n              ISO/IEC
    14776-323, 2014.\n   [SPC4]     INCITS Technical Committee T10, \"Information
    Technology -\n              SCSI Primary Commands - 4 (SPC-4)\", ANSI INCITS 513-2015,\n
    \             2015.\n"
  title: 6.  Normative References
- contents:
  - "Acknowledgments\n   Large parts of this document were copied verbatim from [RFC5663],
    and\n   some parts were inspired by it.  Thank to David Black, Stephen\n   Fridella,
    and Jason Glasgow for their work on the pNFS block/volume\n   layout protocol.\n
    \  David Black, Robert Elliott, and Tom Haynes provided a thorough\n   review
    of drafts of this document, and their input led to the current\n   form of the
    document.\n   David Noveck provided ample feedback to various drafts of this\n
    \  document, wrote the section on enforcing NFSv4 semantics, and rewrote\n   various
    sections to better catch the intent.\n"
  title: Acknowledgments
- contents:
  - "Author's Address\n   Christoph Hellwig\n   Email: hch@lst.de\n"
  title: Author's Address
