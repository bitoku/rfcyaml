- title: __initial_text__
  contents:
  - "                            The TLS Protocol\n                              Version\
    \ 1.0\n"
- title: Status of this Memo
  contents:
  - "Status of this Memo\n   This document specifies an Internet standards track protocol\
    \ for the\n   Internet community, and requests discussion and suggestions for\n\
    \   improvements.  Please refer to the current edition of the \"Internet\n   Official\
    \ Protocol Standards\" (STD 1) for the standardization state\n   and status of\
    \ this protocol.  Distribution of this memo is unlimited.\n"
- title: Copyright Notice
  contents:
  - "Copyright Notice\n   Copyright (C) The Internet Society (1999).  All Rights Reserved.\n"
- title: Abstract
  contents:
  - "Abstract\n   This document specifies Version 1.0 of the Transport Layer Security\n\
    \   (TLS) protocol. The TLS protocol provides communications privacy over\n  \
    \ the Internet. The protocol allows client/server applications to\n   communicate\
    \ in a way that is designed to prevent eavesdropping,\n   tampering, or message\
    \ forgery.\n"
- title: Table of Contents
  contents:
  - "Table of Contents\n   1.       Introduction                                 \
    \             3\n   2.       Goals                                           \
    \          4\n   3.       Goals of this document                             \
    \       5\n   4.       Presentation language                                 \
    \    5\n   4.1.     Basic block size                                         \
    \ 6\n   4.2.     Miscellaneous                                             6\n\
    \   4.3.     Vectors                                                   6\n   4.4.\
    \     Numbers                                                   7\n   4.5.   \
    \  Enumerateds                                               7\n   4.6.     Constructed\
    \ types                                         8\n   4.6.1.   Variants      \
    \                                            9\n   4.7.     Cryptographic attributes\
    \                                 10\n   4.8.     Constants                  \
    \                              11\n   5.       HMAC and the pseudorandom function\
    \                       11\n   6.       The TLS Record Protocol              \
    \                    13\n   6.1.     Connection states                       \
    \                 14\n   6.2.     Record layer                               \
    \              16\n   6.2.1.   Fragmentation                                 \
    \           16\n   6.2.2.   Record compression and decompression             \
    \        17\n   6.2.3.   Record payload protection                           \
    \     18\n   6.2.3.1. Null or standard stream cipher                         \
    \  19\n   6.2.3.2. CBC block cipher                                         19\n\
    \   6.3.     Key calculation                                          21\n   6.3.1.\
    \   Export key generation example                            22\n   7.       The\
    \ TLS Handshake Protocol                               23\n   7.1.     Change\
    \ cipher spec protocol                              24\n   7.2.     Alert protocol\
    \                                           24\n   7.2.1.   Closure alerts   \
    \                                        25\n   7.2.2.   Error alerts        \
    \                                     26\n   7.3.     Handshake Protocol overview\
    \                              29\n   7.4.     Handshake protocol            \
    \                           32\n   7.4.1.   Hello messages                   \
    \                        33\n   7.4.1.1. Hello request                       \
    \                     33\n   7.4.1.2. Client hello                           \
    \                  34\n   7.4.1.3. Server hello                              \
    \               36\n   7.4.2.   Server certificate                           \
    \            37\n   7.4.3.   Server key exchange message                     \
    \         39\n   7.4.4.   Certificate request                                \
    \      41\n   7.4.5.   Server hello done                                     \
    \   42\n   7.4.6.   Client certificate                                       43\n\
    \   7.4.7.   Client key exchange message                              43\n   7.4.7.1.\
    \ RSA encrypted premaster secret message                   44\n   7.4.7.2. Client\
    \ Diffie-Hellman public value                       45\n   7.4.8.   Certificate\
    \ verify                                       45\n   7.4.9.   Finished      \
    \                                           46\n   8.       Cryptographic computations\
    \                               47\n   8.1.     Computing the master secret  \
    \                            47\n   8.1.1.   RSA                             \
    \                         48\n   8.1.2.   Diffie-Hellman                     \
    \                      48\n   9.       Mandatory Cipher Suites               \
    \                   48\n   10.      Application data protocol                \
    \                48\n   A.       Protocol constant values                    \
    \             49\n   A.1.     Record layer                                   \
    \          49\n   A.2.     Change cipher specs message                       \
    \       50\n   A.3.     Alert messages                                       \
    \    50\n   A.4.     Handshake protocol                                      \
    \ 51\n   A.4.1.   Hello messages                                           51\n\
    \   A.4.2.   Server authentication and key exchange messages          52\n   A.4.3.\
    \   Client authentication and key exchange messages          53\n   A.4.4.   Handshake\
    \ finalization message                           54\n   A.5.     The CipherSuite\
    \                                          54\n   A.6.     The Security Parameters\
    \                                  56\n   B.       Glossary                  \
    \                               57\n   C.       CipherSuite definitions      \
    \                            61\n   D.       Implementation Notes            \
    \                         64\n   D.1.     Temporary RSA keys                 \
    \                      64\n   D.2.     Random Number Generation and Seeding  \
    \                   64\n   D.3.     Certificates and authentication          \
    \                65\n   D.4.     CipherSuites                                \
    \             65\n   E.       Backward Compatibility With SSL                \
    \          66\n   E.1.     Version 2 client hello                            \
    \       67\n   E.2.     Avoiding man-in-the-middle version rollback          \
    \    68\n   F.       Security analysis                                       \
    \ 69\n   F.1.     Handshake protocol                                       69\n\
    \   F.1.1.   Authentication and key exchange                          69\n   F.1.1.1.\
    \ Anonymous key exchange                                   69\n   F.1.1.2. RSA\
    \ key exchange and authentication                      70\n   F.1.1.3. Diffie-Hellman\
    \ key exchange with authentication          71\n   F.1.2.   Version rollback attacks\
    \                                 71\n   F.1.3.   Detecting attacks against the\
    \ handshake protocol         72\n   F.1.4.   Resuming sessions               \
    \                         72\n   F.1.5.   MD5 and SHA                        \
    \                      72\n   F.2.     Protecting application data           \
    \                   72\n   F.3.     Final notes                              \
    \                73\n   G.       Patent Statement                            \
    \             74\n            Security Considerations                        \
    \          75\n            References                                        \
    \       75\n            Credits                                              \
    \    77\n            Comments                                                \
    \ 78\n            Full Copyright Statement                                 80\n"
- title: 1. Introduction
  contents:
  - "1. Introduction\n   The primary goal of the TLS Protocol is to provide privacy\
    \ and data\n   integrity between two communicating applications. The protocol\
    \ is\n   composed of two layers: the TLS Record Protocol and the TLS Handshake\n\
    \   Protocol. At the lowest level, layered on top of some reliable\n   transport\
    \ protocol (e.g., TCP[TCP]), is the TLS Record Protocol. The\n   TLS Record Protocol\
    \ provides connection security that has two basic\n   properties:\n     - The\
    \ connection is private. Symmetric cryptography is used for\n       data encryption\
    \ (e.g., DES [DES], RC4 [RC4], etc.) The keys for\n       this symmetric encryption\
    \ are generated uniquely for each\n       connection and are based on a secret\
    \ negotiated by another\n       protocol (such as the TLS Handshake Protocol).\
    \ The Record\n       Protocol can also be used without encryption.\n     - The\
    \ connection is reliable. Message transport includes a message\n       integrity\
    \ check using a keyed MAC. Secure hash functions (e.g.,\n       SHA, MD5, etc.)\
    \ are used for MAC computations. The Record\n       Protocol can operate without\
    \ a MAC, but is generally only used in\n       this mode while another protocol\
    \ is using the Record Protocol as\n       a transport for negotiating security\
    \ parameters.\n   The TLS Record Protocol is used for encapsulation of various\
    \ higher\n   level protocols. One such encapsulated protocol, the TLS Handshake\n\
    \   Protocol, allows the server and client to authenticate each other and\n  \
    \ to negotiate an encryption algorithm and cryptographic keys before\n   the application\
    \ protocol transmits or receives its first byte of\n   data. The TLS Handshake\
    \ Protocol provides connection security that\n   has three basic properties:\n\
    \     - The peer's identity can be authenticated using asymmetric, or\n      \
    \ public key, cryptography (e.g., RSA [RSA], DSS [DSS], etc.). This\n       authentication\
    \ can be made optional, but is generally required\n       for at least one of\
    \ the peers.\n     - The negotiation of a shared secret is secure: the negotiated\n\
    \       secret is unavailable to eavesdroppers, and for any authenticated\n  \
    \     connection the secret cannot be obtained, even by an attacker who\n    \
    \   can place himself in the middle of the connection.\n     - The negotiation\
    \ is reliable: no attacker can modify the\n       negotiation communication without\
    \ being detected by the parties\n       to the communication.\n   One advantage\
    \ of TLS is that it is application protocol independent.\n   Higher level protocols\
    \ can layer on top of the TLS Protocol\n   transparently. The TLS standard, however,\
    \ does not specify how\n   protocols add security with TLS; the decisions on how\
    \ to initiate TLS\n   handshaking and how to interpret the authentication certificates\n\
    \   exchanged are left up to the judgment of the designers and\n   implementors\
    \ of protocols which run on top of TLS.\n"
- title: 2. Goals
  contents:
  - "2. Goals\n   The goals of TLS Protocol, in order of their priority, are:\n  \
    \  1. Cryptographic security: TLS should be used to establish a secure\n     \
    \  connection between two parties.\n    2. Interoperability: Independent programmers\
    \ should be able to\n       develop applications utilizing TLS that will then\
    \ be able to\n       successfully exchange cryptographic parameters without knowledge\n\
    \       of one another's code.\n    3. Extensibility: TLS seeks to provide a framework\
    \ into which new\n       public key and bulk encryption methods can be incorporated\
    \ as\n       necessary. This will also accomplish two sub-goals: to prevent\n\
    \       the need to create a new protocol (and risking the introduction\n    \
    \   of possible new weaknesses) and to avoid the need to implement an\n      \
    \ entire new security library.\n    4. Relative efficiency: Cryptographic operations\
    \ tend to be highly\n       CPU intensive, particularly public key operations.\
    \ For this\n       reason, the TLS protocol has incorporated an optional session\n\
    \       caching scheme to reduce the number of connections that need to\n    \
    \   be established from scratch. Additionally, care has been taken to\n      \
    \ reduce network activity.\n"
- title: 3. Goals of this document
  contents:
  - "3. Goals of this document\n   This document and the TLS protocol itself are based\
    \ on the SSL 3.0\n   Protocol Specification as published by Netscape. The differences\n\
    \   between this protocol and SSL 3.0 are not dramatic, but they are\n   significant\
    \ enough that TLS 1.0 and SSL 3.0 do not interoperate\n   (although TLS 1.0 does\
    \ incorporate a mechanism by which a TLS\n   implementation can back down to SSL\
    \ 3.0). This document is intended\n   primarily for readers who will be implementing\
    \ the protocol and those\n   doing cryptographic analysis of it. The specification\
    \ has been\n   written with this in mind, and it is intended to reflect the needs\
    \ of\n   those two groups. For that reason, many of the algorithm-dependent\n\
    \   data structures and rules are included in the body of the text (as\n   opposed\
    \ to in an appendix), providing easier access to them.\n   This document is not\
    \ intended to supply any details of service\n   definition nor interface definition,\
    \ although it does cover select\n   areas of policy as they are required for the\
    \ maintenance of solid\n   security.\n"
- title: 4. Presentation language
  contents:
  - "4. Presentation language\n   This document deals with the formatting of data\
    \ in an external\n   representation. The following very basic and somewhat casually\n\
    \   defined presentation syntax will be used. The syntax draws from\n   several\
    \ sources in its structure. Although it resembles the\n   programming language\
    \ \"C\" in its syntax and XDR [XDR] in both its\n   syntax and intent, it would\
    \ be risky to draw too many parallels. The\n   purpose of this presentation language\
    \ is to document TLS only, not to\n   have general application beyond that particular\
    \ goal.\n"
- title: 4.1. Basic block size
  contents:
  - "4.1. Basic block size\n   The representation of all data items is explicitly\
    \ specified. The\n   basic data block size is one byte (i.e. 8 bits). Multiple\
    \ byte data\n   items are concatenations of bytes, from left to right, from top\
    \ to\n   bottom. From the bytestream a multi-byte item (a numeric in the\n   example)\
    \ is formed (using C notation) by:\n       value = (byte[0] << 8*(n-1)) | (byte[1]\
    \ << 8*(n-2)) |\n               ... | byte[n-1];\n   This byte ordering for multi-byte\
    \ values is the commonplace network\n   byte order or big endian format.\n"
- title: 4.2. Miscellaneous
  contents:
  - "4.2. Miscellaneous\n   Comments begin with \"/*\" and end with \"*/\".\n   Optional\
    \ components are denoted by enclosing them in \"[[ ]]\" double\n   brackets.\n\
    \   Single byte entities containing uninterpreted data are of type\n   opaque.\n"
- title: 4.3. Vectors
  contents:
  - "4.3. Vectors\n   A vector (single dimensioned array) is a stream of homogeneous\
    \ data\n   elements. The size of the vector may be specified at documentation\n\
    \   time or left unspecified until runtime. In either case the length\n   declares\
    \ the number of bytes, not the number of elements, in the\n   vector. The syntax\
    \ for specifying a new type T' that is a fixed\n   length vector of type T is\n\
    \       T T'[n];\n   Here T' occupies n bytes in the data stream, where n is a\
    \ multiple of\n   the size of T. The length of the vector is not included in the\n\
    \   encoded stream.\n   In the following example, Datum is defined to be three\
    \ consecutive\n   bytes that the protocol does not interpret, while Data is three\n\
    \   consecutive Datum, consuming a total of nine bytes.\n       opaque Datum[3];\
    \      /* three uninterpreted bytes */\n       Datum Data[9];        /* 3 consecutive\
    \ 3 byte vectors */\n   Variable length vectors are defined by specifying a subrange\
    \ of legal\n   lengths, inclusively, using the notation <floor..ceiling>.  When\n\
    \   encoded, the actual length precedes the vector's contents in the byte\n  \
    \ stream. The length will be in the form of a number consuming as many\n   bytes\
    \ as required to hold the vector's specified maximum (ceiling)\n   length. A variable\
    \ length vector with an actual length field of zero\n   is referred to as an empty\
    \ vector.\n       T T'<floor..ceiling>;\n   In the following example, mandatory\
    \ is a vector that must contain\n   between 300 and 400 bytes of type opaque.\
    \ It can never be empty. The\n   actual length field consumes two bytes, a uint16,\
    \ sufficient to\n   represent the value 400 (see Section 4.4). On the other hand,\
    \ longer\n   can represent up to 800 bytes of data, or 400 uint16 elements, and\
    \ it\n   may be empty. Its encoding will include a two byte actual length\n  \
    \ field prepended to the vector. The length of an encoded vector must\n   be an\
    \ even multiple of the length of a single element (for example, a\n   17 byte\
    \ vector of uint16 would be illegal).\n       opaque mandatory<300..400>;\n  \
    \           /* length field is 2 bytes, cannot be empty */\n       uint16 longer<0..800>;\n\
    \             /* zero to 400 16-bit unsigned integers */\n"
- title: 4.4. Numbers
  contents:
  - "4.4. Numbers\n   The basic numeric data type is an unsigned byte (uint8). All\
    \ larger\n   numeric data types are formed from fixed length series of bytes\n\
    \   concatenated as described in Section 4.1 and are also unsigned. The\n   following\
    \ numeric types are predefined.\n       uint8 uint16[2];\n       uint8 uint24[3];\n\
    \       uint8 uint32[4];\n       uint8 uint64[8];\n   All values, here and elsewhere\
    \ in the specification, are stored in\n   \"network\" or \"big-endian\" order;\
    \ the uint32 represented by the hex\n   bytes 01 02 03 04 is equivalent to the\
    \ decimal value 16909060.\n"
- title: 4.5. Enumerateds
  contents:
  - "4.5. Enumerateds\n   An additional sparse data type is available called enum.\
    \ A field of\n   type enum can only assume the values declared in the definition.\n\
    \   Each definition is a different type. Only enumerateds of the same\n   type\
    \ may be assigned or compared. Every element of an enumerated must\n   be assigned\
    \ a value, as demonstrated in the following example.  Since\n   the elements of\
    \ the enumerated are not ordered, they can be assigned\n   any unique value, in\
    \ any order.\n       enum { e1(v1), e2(v2), ... , en(vn) [[, (n)]] } Te;\n   Enumerateds\
    \ occupy as much space in the byte stream as would its\n   maximal defined ordinal\
    \ value. The following definition would cause\n   one byte to be used to carry\
    \ fields of type Color.\n       enum { red(3), blue(5), white(7) } Color;\n  \
    \ One may optionally specify a value without its associated tag to\n   force the\
    \ width definition without defining a superfluous element.\n   In the following\
    \ example, Taste will consume two bytes in the data\n   stream but can only assume\
    \ the values 1, 2 or 4.\n       enum { sweet(1), sour(2), bitter(4), (32000) }\
    \ Taste;\n   The names of the elements of an enumeration are scoped within the\n\
    \   defined type. In the first example, a fully qualified reference to\n   the\
    \ second element of the enumeration would be Color.blue. Such\n   qualification\
    \ is not required if the target of the assignment is well\n   specified.\n   \
    \    Color color = Color.blue;     /* overspecified, legal */\n       Color color\
    \ = blue;           /* correct, type implicit */\n   For enumerateds that are\
    \ never converted to external representation,\n   the numerical information may\
    \ be omitted.\n       enum { low, medium, high } Amount;\n"
- title: 4.6. Constructed types
  contents:
  - "4.6. Constructed types\n   Structure types may be constructed from primitive\
    \ types for\n   convenience. Each specification declares a new, unique type. The\n\
    \   syntax for definition is much like that of C.\n       struct {\n         T1\
    \ f1;\n         T2 f2;\n         ...\n         Tn fn;\n       } [[T]];\n   The\
    \ fields within a structure may be qualified using the type's name\n   using a\
    \ syntax much like that available for enumerateds. For example,\n   T.f2 refers\
    \ to the second field of the previous declaration.\n   Structure definitions may\
    \ be embedded.\n"
- title: 4.6.1. Variants
  contents:
  - "4.6.1. Variants\n   Defined structures may have variants based on some knowledge\
    \ that is\n   available within the environment. The selector must be an enumerated\n\
    \   type that defines the possible variants the structure defines. There\n   must\
    \ be a case arm for every element of the enumeration declared in\n   the select.\
    \ The body of the variant structure may be given a label\n   for reference. The\
    \ mechanism by which the variant is selected at\n   runtime is not prescribed\
    \ by the presentation language.\n       struct {\n           T1 f1;\n        \
    \   T2 f2;\n           ....\n           Tn fn;\n           select (E) {\n    \
    \           case e1: Te1;\n               case e2: Te2;\n               ....\n\
    \               case en: Ten;\n           } [[fv]];\n       } [[Tv]];\n   For\
    \ example:\n       enum { apple, orange } VariantTag;\n       struct {\n     \
    \      uint16 number;\n           opaque string<0..10>; /* variable length */\n\
    \       } V1;\n       struct {\n           uint32 number;\n           opaque string[10];\
    \    /* fixed length */\n       } V2;\n       struct {\n           select (VariantTag)\
    \ { /* value of selector is implicit */\n               case apple: V1;   /* VariantBody,\
    \ tag = apple */\n               case orange: V2;  /* VariantBody, tag = orange\
    \ */\n           } variant_body;       /* optional label on variant */\n     \
    \  } VariantRecord;\n   Variant structures may be qualified (narrowed) by specifying\
    \ a value\n   for the selector prior to the type. For example, a\n       orange\
    \ VariantRecord\n   is a narrowed type of a VariantRecord containing a variant_body\
    \ of\n   type V2.\n"
- title: 4.7. Cryptographic attributes
  contents:
  - "4.7. Cryptographic attributes\n   The four cryptographic operations digital signing,\
    \ stream cipher\n   encryption, block cipher encryption, and public key encryption\
    \ are\n   designated digitally-signed, stream-ciphered, block-ciphered, and\n\
    \   public-key-encrypted, respectively. A field's cryptographic\n   processing\
    \ is specified by prepending an appropriate key word\n   designation before the\
    \ field's type specification. Cryptographic keys\n   are implied by the current\
    \ session state (see Section 6.1).\n   In digital signing, one-way hash functions\
    \ are used as input for a\n   signing algorithm. A digitally-signed element is\
    \ encoded as an opaque\n   vector <0..2^16-1>, where the length is specified by\
    \ the signing\n   algorithm and key.\n   In RSA signing, a 36-byte structure of\
    \ two hashes (one SHA and one\n   MD5) is signed (encrypted with the private key).\
    \ It is encoded with\n   PKCS #1 block type 0 or type 1 as described in [PKCS1].\n\
    \   In DSS, the 20 bytes of the SHA hash are run directly through the\n   Digital\
    \ Signing Algorithm with no additional hashing. This produces\n   two values,\
    \ r and s. The DSS signature is an opaque vector, as above,\n   the contents of\
    \ which are the DER encoding of:\n       Dss-Sig-Value  ::=  SEQUENCE  {\n   \
    \         r       INTEGER,\n            s       INTEGER\n       }\n   In stream\
    \ cipher encryption, the plaintext is exclusive-ORed with an\n   identical amount\
    \ of output generated from a cryptographically-secure\n   keyed pseudorandom number\
    \ generator.\n   In block cipher encryption, every block of plaintext encrypts\
    \ to a\n   block of ciphertext. All block cipher encryption is done in CBC\n \
    \  (Cipher Block Chaining) mode, and all items which are block-ciphered\n   will\
    \ be an exact multiple of the cipher block length.\n   In public key encryption,\
    \ a public key algorithm is used to encrypt\n   data in such a way that it can\
    \ be decrypted only with the matching\n   private key. A public-key-encrypted\
    \ element is encoded as an opaque\n   vector <0..2^16-1>, where the length is\
    \ specified by the signing\n   algorithm and key.\n   An RSA encrypted value is\
    \ encoded with PKCS #1 block type 2 as\n   described in [PKCS1].\n   In the following\
    \ example:\n       stream-ciphered struct {\n           uint8 field1;\n      \
    \     uint8 field2;\n           digitally-signed opaque hash[20];\n       } UserType;\n\
    \   The contents of hash are used as input for the signing algorithm,\n   then\
    \ the entire structure is encrypted with a stream cipher. The\n   length of this\
    \ structure, in bytes would be equal to 2 bytes for\n   field1 and field2, plus\
    \ two bytes for the length of the signature,\n   plus the length of the output\
    \ of the signing algorithm. This is known\n   due to the fact that the algorithm\
    \ and key used for the signing are\n   known prior to encoding or decoding this\
    \ structure.\n"
- title: 4.8. Constants
  contents:
  - "4.8. Constants\n   Typed constants can be defined for purposes of specification\
    \ by\n   declaring a symbol of the desired type and assigning values to it.\n\
    \   Under-specified types (opaque, variable length vectors, and\n   structures\
    \ that contain opaque) cannot be assigned values. No fields\n   of a multi-element\
    \ structure or vector may be elided.\n   For example,\n       struct {\n     \
    \      uint8 f1;\n           uint8 f2;\n       } Example1;\n       Example1 ex1\
    \ = {1, 4};  /* assigns f1 = 1, f2 = 4 */\n"
- title: 5. HMAC and the pseudorandom function
  contents:
  - "5. HMAC and the pseudorandom function\n   A number of operations in the TLS record\
    \ and handshake layer required\n   a keyed MAC; this is a secure digest of some\
    \ data protected by a\n   secret. Forging the MAC is infeasible without knowledge\
    \ of the MAC\n   secret. The construction we use for this operation is known as\
    \ HMAC,\n   described in [HMAC].\n   HMAC can be used with a variety of different\
    \ hash algorithms. TLS\n   uses it in the handshake with two different algorithms:\
    \ MD5 and SHA-\n   1, denoting these as HMAC_MD5(secret, data) and HMAC_SHA(secret,\n\
    \   data). Additional hash algorithms can be defined by cipher suites and\n  \
    \ used to protect record data, but MD5 and SHA-1 are hard coded into\n   the description\
    \ of the handshaking for this version of the protocol.\n   In addition, a construction\
    \ is required to do expansion of secrets\n   into blocks of data for the purposes\
    \ of key generation or validation.\n   This pseudo-random function (PRF) takes\
    \ as input a secret, a seed,\n   and an identifying label and produces an output\
    \ of arbitrary length.\n   In order to make the PRF as secure as possible, it\
    \ uses two hash\n   algorithms in a way which should guarantee its security if\
    \ either\n   algorithm remains secure.\n   First, we define a data expansion function,\
    \ P_hash(secret, data)\n   which uses a single hash function to expand a secret\
    \ and seed into an\n   arbitrary quantity of output:\n       P_hash(secret, seed)\
    \ = HMAC_hash(secret, A(1) + seed) +\n                              HMAC_hash(secret,\
    \ A(2) + seed) +\n                              HMAC_hash(secret, A(3) + seed)\
    \ + ...\n   Where + indicates concatenation.\n   A() is defined as:\n       A(0)\
    \ = seed\n       A(i) = HMAC_hash(secret, A(i-1))\n   P_hash can be iterated as\
    \ many times as is necessary to produce the\n   required quantity of data. For\
    \ example, if P_SHA-1 was being used to\n   create 64 bytes of data, it would\
    \ have to be iterated 4 times\n   (through A(4)), creating 80 bytes of output\
    \ data; the last 16 bytes\n   of the final iteration would then be discarded,\
    \ leaving 64 bytes of\n   output data.\n   TLS's PRF is created by splitting the\
    \ secret into two halves and\n   using one half to generate data with P_MD5 and\
    \ the other half to\n   generate data with P_SHA-1, then exclusive-or'ing the\
    \ outputs of\n   these two expansion functions together.\n   S1 and S2 are the\
    \ two halves of the secret and each is the same\n   length. S1 is taken from the\
    \ first half of the secret, S2 from the\n   second half. Their length is created\
    \ by rounding up the length of the\n   overall secret divided by two; thus, if\
    \ the original secret is an odd\n   number of bytes long, the last byte of S1\
    \ will be the same as the\n   first byte of S2.\n       L_S = length in bytes\
    \ of secret;\n       L_S1 = L_S2 = ceil(L_S / 2);\n   The secret is partitioned\
    \ into two halves (with the possibility of\n   one shared byte) as described above,\
    \ S1 taking the first L_S1 bytes\n   and S2 the last L_S2 bytes.\n   The PRF is\
    \ then defined as the result of mixing the two pseudorandom\n   streams by exclusive-or'ing\
    \ them together.\n       PRF(secret, label, seed) = P_MD5(S1, label + seed) XOR\n\
    \                                  P_SHA-1(S2, label + seed);\n   The label is\
    \ an ASCII string. It should be included in the exact form\n   it is given without\
    \ a length byte or trailing null character.  For\n   example, the label \"slithy\
    \ toves\" would be processed by hashing the\n   following bytes:\n       73 6C\
    \ 69 74 68 79 20 74 6F 76 65 73\n   Note that because MD5 produces 16 byte outputs\
    \ and SHA-1 produces 20\n   byte outputs, the boundaries of their internal iterations\
    \ will not be\n   aligned; to generate a 80 byte output will involve P_MD5 being\n\
    \   iterated through A(5), while P_SHA-1 will only iterate through A(4).\n"
- title: 6. The TLS Record Protocol
  contents:
  - "6. The TLS Record Protocol\n   The TLS Record Protocol is a layered protocol.\
    \ At each layer,\n   messages may include fields for length, description, and\
    \ content.\n   The Record Protocol takes messages to be transmitted, fragments\
    \ the\n   data into manageable blocks, optionally compresses the data, applies\n\
    \   a MAC, encrypts, and transmits the result. Received data is\n   decrypted,\
    \ verified, decompressed, and reassembled, then delivered to\n   higher level\
    \ clients.\n   Four record protocol clients are described in this document: the\n\
    \   handshake protocol, the alert protocol, the change cipher spec\n   protocol,\
    \ and the application data protocol. In order to allow\n   extension of the TLS\
    \ protocol, additional record types can be\n   supported by the record protocol.\
    \ Any new record types should\n   allocate type values immediately beyond the\
    \ ContentType values for\n   the four record types described here (see Appendix\
    \ A.2). If a TLS\n   implementation receives a record type it does not understand,\
    \ it\n   should just ignore it. Any protocol designed for use over TLS must be\n\
    \   carefully designed to deal with all possible attacks against it.\n   Note\
    \ that because the type and length of a record are not protected\n   by encryption,\
    \ care should be take to minimize the value of traffic\n   analysis of these values.\n"
- title: 6.1. Connection states
  contents:
  - "6.1. Connection states\n   A TLS connection state is the operating environment\
    \ of the TLS Record\n   Protocol. It specifies a compression algorithm, encryption\
    \ algorithm,\n   and MAC algorithm. In addition, the parameters for these algorithms\n\
    \   are known: the MAC secret and the bulk encryption keys and IVs for\n   the\
    \ connection in both the read and the write directions. Logically,\n   there are\
    \ always four connection states outstanding: the current read\n   and write states,\
    \ and the pending read and write states. All records\n   are processed under the\
    \ current read and write states. The security\n   parameters for the pending states\
    \ can be set by the TLS Handshake\n   Protocol, and the Handshake Protocol can\
    \ selectively make either of\n   the pending states current, in which case the\
    \ appropriate current\n   state is disposed of and replaced with the pending state;\
    \ the pending\n   state is then reinitialized to an empty state. It is illegal\
    \ to make\n   a state which has not been initialized with security parameters\
    \ a\n   current state. The initial current state always specifies that no\n  \
    \ encryption, compression, or MAC will be used.\n   The security parameters for\
    \ a TLS Connection read and write state are\n   set by providing the following\
    \ values:\n   connection end\n       Whether this entity is considered the \"\
    client\" or the \"server\" in\n       this connection.\n   bulk encryption algorithm\n\
    \       An algorithm to be used for bulk encryption. This specification\n    \
    \   includes the key size of this algorithm, how much of that key is\n       secret,\
    \ whether it is a block or stream cipher, the block size of\n       the cipher\
    \ (if appropriate), and whether it is considered an\n       \"export\" cipher.\n\
    \   MAC algorithm\n       An algorithm to be used for message authentication.\
    \ This\n       specification includes the size of the hash which is returned by\n\
    \       the MAC algorithm.\n   compression algorithm\n       An algorithm to be\
    \ used for data compression. This specification\n       must include all information\
    \ the algorithm requires to do\n       compression.\n   master secret\n      \
    \ A 48 byte secret shared between the two peers in the connection.\n   client\
    \ random\n       A 32 byte value provided by the client.\n   server random\n \
    \      A 32 byte value provided by the server.\n   These parameters are defined\
    \ in the presentation language as:\n       enum { server, client } ConnectionEnd;\n\
    \       enum { null, rc4, rc2, des, 3des, des40 } BulkCipherAlgorithm;\n     \
    \  enum { stream, block } CipherType;\n       enum { true, false } IsExportable;\n\
    \       enum { null, md5, sha } MACAlgorithm;\n       enum { null(0), (255) }\
    \ CompressionMethod;\n       /* The algorithms specified in CompressionMethod,\n\
    \          BulkCipherAlgorithm, and MACAlgorithm may be added to. */\n       struct\
    \ {\n           ConnectionEnd          entity;\n           BulkCipherAlgorithm\
    \    bulk_cipher_algorithm;\n           CipherType             cipher_type;\n\
    \           uint8                  key_size;\n           uint8               \
    \   key_material_length;\n           IsExportable           is_exportable;\n \
    \          MACAlgorithm           mac_algorithm;\n           uint8           \
    \       hash_size;\n           CompressionMethod      compression_algorithm;\n\
    \           opaque                 master_secret[48];\n           opaque     \
    \            client_random[32];\n           opaque                 server_random[32];\n\
    \       } SecurityParameters;\n   The record layer will use the security parameters\
    \ to generate the\n   following six items:\n       client write MAC secret\n \
    \      server write MAC secret\n       client write key\n       server write key\n\
    \       client write IV (for block ciphers only)\n       server write IV (for\
    \ block ciphers only)\n   The client write parameters are used by the server when\
    \ receiving and\n   processing records and vice-versa. The algorithm used for\
    \ generating\n   these items from the security parameters is described in section\
    \ 6.3.\n   Once the security parameters have been set and the keys have been\n\
    \   generated, the connection states can be instantiated by making them\n   the\
    \ current states. These current states must be updated for each\n   record processed.\
    \ Each connection state includes the following\n   elements:\n   compression state\n\
    \       The current state of the compression algorithm.\n   cipher state\n   \
    \    The current state of the encryption algorithm. This will consist\n      \
    \ of the scheduled key for that connection. In addition, for block\n       ciphers\
    \ running in CBC mode (the only mode specified for TLS),\n       this will initially\
    \ contain the IV for that connection state and\n       be updated to contain the\
    \ ciphertext of the last block encrypted\n       or decrypted as records are processed.\
    \ For stream ciphers, this\n       will contain whatever the necessary state information\
    \ is to allow\n       the stream to continue to encrypt or decrypt data.\n   MAC\
    \ secret\n       The MAC secret for this connection as generated above.\n   sequence\
    \ number\n       Each connection state contains a sequence number, which is\n\
    \       maintained separately for read and write states. The sequence\n      \
    \ number must be set to zero whenever a connection state is made\n       the active\
    \ state. Sequence numbers are of type uint64 and may not\n       exceed 2^64-1.\
    \ A sequence number is incremented after each\n       record: specifically, the\
    \ first record which is transmitted under\n       a particular connection state\
    \ should use sequence number 0.\n"
- title: 6.2. Record layer
  contents:
  - "6.2. Record layer\n   The TLS Record Layer receives uninterpreted data from higher\
    \ layers\n   in non-empty blocks of arbitrary size.\n"
- title: 6.2.1. Fragmentation
  contents:
  - "6.2.1. Fragmentation\n   The record layer fragments information blocks into TLSPlaintext\n\
    \   records carrying data in chunks of 2^14 bytes or less. Client message\n  \
    \ boundaries are not preserved in the record layer (i.e., multiple\n   client\
    \ messages of the same ContentType may be coalesced into a\n   single TLSPlaintext\
    \ record, or a single message may be fragmented\n   across several records).\n\
    \       struct {\n           uint8 major, minor;\n       } ProtocolVersion;\n\
    \       enum {\n           change_cipher_spec(20), alert(21), handshake(22),\n\
    \           application_data(23), (255)\n       } ContentType;\n       struct\
    \ {\n           ContentType type;\n           ProtocolVersion version;\n     \
    \      uint16 length;\n           opaque fragment[TLSPlaintext.length];\n    \
    \   } TLSPlaintext;\n   type\n       The higher level protocol used to process\
    \ the enclosed fragment.\n   version\n       The version of the protocol being\
    \ employed. This document\n       describes TLS Version 1.0, which uses the version\
    \ { 3, 1 }. The\n       version value 3.1 is historical: TLS version 1.0 is a\
    \ minor\n       modification to the SSL 3.0 protocol, which bears the version\n\
    \       value 3.0. (See Appendix A.1).\n   length\n       The length (in bytes)\
    \ of the following TLSPlaintext.fragment.\n       The length should not exceed\
    \ 2^14.\n   fragment\n       The application data. This data is transparent and\
    \ treated as an\n       independent block to be dealt with by the higher level\
    \ protocol\n       specified by the type field.\n Note: Data of different TLS\
    \ Record layer content types may be\n       interleaved. Application data is generally\
    \ of lower precedence\n       for transmission than other content types.\n"
- title: 6.2.2. Record compression and decompression
  contents:
  - "6.2.2. Record compression and decompression\n   All records are compressed using\
    \ the compression algorithm defined in\n   the current session state. There is\
    \ always an active compression\n   algorithm; however, initially it is defined\
    \ as\n   CompressionMethod.null. The compression algorithm translates a\n   TLSPlaintext\
    \ structure into a TLSCompressed structure. Compression\n   functions are initialized\
    \ with default state information whenever a\n   connection state is made active.\n\
    \   Compression must be lossless and may not increase the content length\n   by\
    \ more than 1024 bytes. If the decompression function encounters a\n   TLSCompressed.fragment\
    \ that would decompress to a length in excess of\n   2^14 bytes, it should report\
    \ a fatal decompression failure error.\n       struct {\n           ContentType\
    \ type;       /* same as TLSPlaintext.type */\n           ProtocolVersion version;/*\
    \ same as TLSPlaintext.version */\n           uint16 length;\n           opaque\
    \ fragment[TLSCompressed.length];\n       } TLSCompressed;\n   length\n      \
    \ The length (in bytes) of the following TLSCompressed.fragment.\n       The length\
    \ should not exceed 2^14 + 1024.\n   fragment\n       The compressed form of TLSPlaintext.fragment.\n\
    \ Note: A CompressionMethod.null operation is an identity operation; no\n    \
    \   fields are altered.\n   Implementation note:\n       Decompression functions\
    \ are responsible for ensuring that\n       messages cannot cause internal buffer\
    \ overflows.\n"
- title: 6.2.3. Record payload protection
  contents:
  - "6.2.3. Record payload protection\n   The encryption and MAC functions translate\
    \ a TLSCompressed structure\n   into a TLSCiphertext. The decryption functions\
    \ reverse the process.\n   The MAC of the record also includes a sequence number\
    \ so that\n   missing, extra or repeated messages are detectable.\n       struct\
    \ {\n           ContentType type;\n           ProtocolVersion version;\n     \
    \      uint16 length;\n           select (CipherSpec.cipher_type) {\n        \
    \       case stream: GenericStreamCipher;\n               case block: GenericBlockCipher;\n\
    \           } fragment;\n       } TLSCiphertext;\n   type\n       The type field\
    \ is identical to TLSCompressed.type.\n   version\n       The version field is\
    \ identical to TLSCompressed.version.\n   length\n       The length (in bytes)\
    \ of the following TLSCiphertext.fragment.\n       The length may not exceed 2^14\
    \ + 2048.\n   fragment\n       The encrypted form of TLSCompressed.fragment, with\
    \ the MAC.\n"
- title: 6.2.3.1. Null or standard stream cipher
  contents:
  - "6.2.3.1. Null or standard stream cipher\n   Stream ciphers (including BulkCipherAlgorithm.null\
    \ - see Appendix\n   A.6) convert TLSCompressed.fragment structures to and from\
    \ stream\n   TLSCiphertext.fragment structures.\n       stream-ciphered struct\
    \ {\n           opaque content[TLSCompressed.length];\n           opaque MAC[CipherSpec.hash_size];\n\
    \       } GenericStreamCipher;\n   The MAC is generated as:\n       HMAC_hash(MAC_write_secret,\
    \ seq_num + TLSCompressed.type +\n                     TLSCompressed.version +\
    \ TLSCompressed.length +\n                     TLSCompressed.fragment));\n   where\
    \ \"+\" denotes concatenation.\n   seq_num\n       The sequence number for this\
    \ record.\n   hash\n       The hashing algorithm specified by\n       SecurityParameters.mac_algorithm.\n\
    \   Note that the MAC is computed before encryption. The stream cipher\n   encrypts\
    \ the entire block, including the MAC. For stream ciphers that\n   do not use\
    \ a synchronization vector (such as RC4), the stream cipher\n   state from the\
    \ end of one record is simply used on the subsequent\n   packet. If the CipherSuite\
    \ is TLS_NULL_WITH_NULL_NULL, encryption\n   consists of the identity operation\
    \ (i.e., the data is not encrypted\n   and the MAC size is zero implying that\
    \ no MAC is used).\n   TLSCiphertext.length is TLSCompressed.length plus\n   CipherSpec.hash_size.\n"
- title: 6.2.3.2. CBC block cipher
  contents:
  - "6.2.3.2. CBC block cipher\n   For block ciphers (such as RC2 or DES), the encryption\
    \ and MAC\n   functions convert TLSCompressed.fragment structures to and from\
    \ block\n   TLSCiphertext.fragment structures.\n       block-ciphered struct {\n\
    \           opaque content[TLSCompressed.length];\n           opaque MAC[CipherSpec.hash_size];\n\
    \           uint8 padding[GenericBlockCipher.padding_length];\n           uint8\
    \ padding_length;\n       } GenericBlockCipher;\n   The MAC is generated as described\
    \ in Section 6.2.3.1.\n   padding\n       Padding that is added to force the length\
    \ of the plaintext to be\n       an integral multiple of the block cipher's block\
    \ length. The\n       padding may be any length up to 255 bytes long, as long\
    \ as it\n       results in the TLSCiphertext.length being an integral multiple\
    \ of\n       the block length. Lengths longer than necessary might be\n      \
    \ desirable to frustrate attacks on a protocol based on analysis of\n       the\
    \ lengths of exchanged messages. Each uint8 in the padding data\n       vector\
    \ must be filled with the padding length value.\n   padding_length\n       The\
    \ padding length should be such that the total size of the\n       GenericBlockCipher\
    \ structure is a multiple of the cipher's block\n       length. Legal values range\
    \ from zero to 255, inclusive. This\n       length specifies the length of the\
    \ padding field exclusive of the\n       padding_length field itself.\n   The\
    \ encrypted data length (TLSCiphertext.length) is one more than the\n   sum of\
    \ TLSCompressed.length, CipherSpec.hash_size, and\n   padding_length.\n Example:\
    \ If the block length is 8 bytes, the content length\n          (TLSCompressed.length)\
    \ is 61 bytes, and the MAC length is 20\n          bytes, the length before padding\
    \ is 82 bytes. Thus, the\n          padding length modulo 8 must be equal to 6\
    \ in order to make\n          the total length an even multiple of 8 bytes (the\
    \ block\n          length). The padding length can be 6, 14, 22, and so on,\n\
    \          through 254. If the padding length were the minimum necessary,\n  \
    \        6, the padding would be 6 bytes, each containing the value 6.\n     \
    \     Thus, the last 8 octets of the GenericBlockCipher before block\n       \
    \   encryption would be xx 06 06 06 06 06 06 06, where xx is the\n          last\
    \ octet of the MAC.\n Note: With block ciphers in CBC mode (Cipher Block Chaining)\
    \ the\n       initialization vector (IV) for the first record is generated with\n\
    \       the other keys and secrets when the security parameters are set.\n   \
    \    The IV for subsequent records is the last ciphertext block from\n       the\
    \ previous record.\n"
- title: 6.3. Key calculation
  contents:
  - "6.3. Key calculation\n   The Record Protocol requires an algorithm to generate\
    \ keys, IVs, and\n   MAC secrets from the security parameters provided by the\
    \ handshake\n   protocol.\n   The master secret is hashed into a sequence of secure\
    \ bytes, which\n   are assigned to the MAC secrets, keys, and non-export IVs required\
    \ by\n   the current connection state (see Appendix A.6). CipherSpecs require\n\
    \   a client write MAC secret, a server write MAC secret, a client write\n   key,\
    \ a server write key, a client write IV, and a server write IV,\n   which are\
    \ generated from the master secret in that order. Unused\n   values are empty.\n\
    \   When generating keys and MAC secrets, the master secret is used as an\n  \
    \ entropy source, and the random values provide unencrypted salt\n   material\
    \ and IVs for exportable ciphers.\n   To generate the key material, compute\n\
    \       key_block = PRF(SecurityParameters.master_secret,\n                  \
    \        \"key expansion\",\n                          SecurityParameters.server_random\
    \ +\n                          SecurityParameters.client_random);\n   until enough\
    \ output has been generated. Then the key_block is\n   partitioned as follows:\n\
    \       client_write_MAC_secret[SecurityParameters.hash_size]\n       server_write_MAC_secret[SecurityParameters.hash_size]\n\
    \       client_write_key[SecurityParameters.key_material_length]\n       server_write_key[SecurityParameters.key_material_length]\n\
    \       client_write_IV[SecurityParameters.IV_size]\n       server_write_IV[SecurityParameters.IV_size]\n\
    \   The client_write_IV and server_write_IV are only generated for non-\n   export\
    \ block ciphers. For exportable block ciphers, the\n   initialization vectors\
    \ are generated later, as described below. Any\n   extra key_block material is\
    \ discarded.\n   Implementation note:\n       The cipher spec which is defined\
    \ in this document which requires\n       the most material is 3DES_EDE_CBC_SHA:\
    \ it requires 2 x 24 byte\n       keys, 2 x 20 byte MAC secrets, and 2 x 8 byte\
    \ IVs, for a total of\n       104 bytes of key material.\n   Exportable encryption\
    \ algorithms (for which CipherSpec.is_exportable\n   is true) require additional\
    \ processing as follows to derive their\n   final write keys:\n       final_client_write_key\
    \ =\n       PRF(SecurityParameters.client_write_key,\n                       \
    \           \"client write key\",\n                                  SecurityParameters.client_random\
    \ +\n                                  SecurityParameters.server_random);\n  \
    \     final_server_write_key =\n       PRF(SecurityParameters.server_write_key,\n\
    \                                  \"server write key\",\n                   \
    \               SecurityParameters.client_random +\n                         \
    \         SecurityParameters.server_random);\n   Exportable encryption algorithms\
    \ derive their IVs solely from the\n   random values from the hello messages:\n\
    \       iv_block = PRF(\"\", \"IV block\", SecurityParameters.client_random +\n\
    \                      SecurityParameters.server_random);\n   The iv_block is\
    \ partitioned into two initialization vectors as the\n   key_block was above:\n\
    \       client_write_IV[SecurityParameters.IV_size]\n       server_write_IV[SecurityParameters.IV_size]\n\
    \   Note that the PRF is used without a secret in this case: this just\n   means\
    \ that the secret has a length of zero bytes and contributes\n   nothing to the\
    \ hashing in the PRF.\n"
- title: 6.3.1. Export key generation example
  contents:
  - "6.3.1. Export key generation example\n   TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5 requires\
    \ five random bytes for\n   each of the two encryption keys and 16 bytes for each\
    \ of the MAC\n   keys, for a total of 42 bytes of key material. The PRF output\
    \ is\n   stored in the key_block. The key_block is partitioned, and the write\n\
    \   keys are salted because this is an exportable encryption algorithm.\n    \
    \   key_block               = PRF(master_secret,\n                           \
    \          \"key expansion\",\n                                     server_random\
    \ +\n                                     client_random)[0..41]\n       client_write_MAC_secret\
    \ = key_block[0..15]\n       server_write_MAC_secret = key_block[16..31]\n   \
    \    client_write_key        = key_block[32..36]\n       server_write_key    \
    \    = key_block[37..41]\n       final_client_write_key  = PRF(client_write_key,\n\
    \                                     \"client write key\",\n                \
    \                     client_random +\n                                     server_random)[0..15]\n\
    \       final_server_write_key  = PRF(server_write_key,\n                    \
    \                 \"server write key\",\n                                    \
    \ client_random +\n                                     server_random)[0..15]\n\
    \       iv_block                = PRF(\"\", \"IV block\", client_random +\n  \
    \                                   server_random)[0..15]\n       client_write_IV\
    \ = iv_block[0..7]\n       server_write_IV = iv_block[8..15]\n"
- title: 7. The TLS Handshake Protocol
  contents:
  - "7. The TLS Handshake Protocol\n   The TLS Handshake Protocol consists of a suite\
    \ of three sub-protocols\n   which are used to allow peers to agree upon security\
    \ parameters for\n   the record layer, authenticate themselves, instantiate negotiated\n\
    \   security parameters, and report error conditions to each other.\n   The Handshake\
    \ Protocol is responsible for negotiating a session,\n   which consists of the\
    \ following items:\n   session identifier\n       An arbitrary byte sequence chosen\
    \ by the server to identify an\n       active or resumable session state.\n  \
    \ peer certificate\n       X509v3 [X509] certificate of the peer. This element\
    \ of the state\n       may be null.\n   compression method\n       The algorithm\
    \ used to compress data prior to encryption.\n   cipher spec\n       Specifies\
    \ the bulk data encryption algorithm (such as null, DES,\n       etc.) and a MAC\
    \ algorithm (such as MD5 or SHA). It also defines\n       cryptographic attributes\
    \ such as the hash_size. (See Appendix A.6\n       for formal definition)\n  \
    \ master secret\n       48-byte secret shared between the client and server.\n\
    \   is resumable\n       A flag indicating whether the session can be used to\
    \ initiate new\n       connections.\n   These items are then used to create security\
    \ parameters for use by\n   the Record Layer when protecting application data.\
    \ Many connections\n   can be instantiated using the same session through the\
    \ resumption\n   feature of the TLS Handshake Protocol.\n"
- title: 7.1. Change cipher spec protocol
  contents:
  - "7.1. Change cipher spec protocol\n   The change cipher spec protocol exists to\
    \ signal transitions in\n   ciphering strategies. The protocol consists of a single\
    \ message,\n   which is encrypted and compressed under the current (not the pending)\n\
    \   connection state. The message consists of a single byte of value 1.\n    \
    \   struct {\n           enum { change_cipher_spec(1), (255) } type;\n       }\
    \ ChangeCipherSpec;\n   The change cipher spec message is sent by both the client\
    \ and server\n   to notify the receiving party that subsequent records will be\n\
    \   protected under the newly negotiated CipherSpec and keys. Reception\n   of\
    \ this message causes the receiver to instruct the Record Layer to\n   immediately\
    \ copy the read pending state into the read current state.\n   Immediately after\
    \ sending this message, the sender should instruct\n   the record layer to make\
    \ the write pending state the write active\n   state. (See section 6.1.) The change\
    \ cipher spec message is sent\n   during the handshake after the security parameters\
    \ have been agreed\n   upon, but before the verifying finished message is sent\
    \ (see section\n   7.4.9).\n"
- title: 7.2. Alert protocol
  contents:
  - "7.2. Alert protocol\n   One of the content types supported by the TLS Record\
    \ layer is the\n   alert type. Alert messages convey the severity of the message\
    \ and a\n   description of the alert. Alert messages with a level of fatal result\n\
    \   in the immediate termination of the connection. In this case, other\n   connections\
    \ corresponding to the session may continue, but the\n   session identifier must\
    \ be invalidated, preventing the failed session\n   from being used to establish\
    \ new connections. Like other messages,\n   alert messages are encrypted and compressed,\
    \ as specified by the\n   current connection state.\n       enum { warning(1),\
    \ fatal(2), (255) } AlertLevel;\n       enum {\n           close_notify(0),\n\
    \           unexpected_message(10),\n           bad_record_mac(20),\n        \
    \   decryption_failed(21),\n           record_overflow(22),\n           decompression_failure(30),\n\
    \           handshake_failure(40),\n           bad_certificate(42),\n        \
    \   unsupported_certificate(43),\n           certificate_revoked(44),\n      \
    \     certificate_expired(45),\n           certificate_unknown(46),\n        \
    \   illegal_parameter(47),\n           unknown_ca(48),\n           access_denied(49),\n\
    \           decode_error(50),\n           decrypt_error(51),\n           export_restriction(60),\n\
    \           protocol_version(70),\n           insufficient_security(71),\n   \
    \        internal_error(80),\n           user_canceled(90),\n           no_renegotiation(100),\n\
    \           (255)\n       } AlertDescription;\n       struct {\n           AlertLevel\
    \ level;\n           AlertDescription description;\n       } Alert;\n"
- title: 7.2.1. Closure alerts
  contents:
  - "7.2.1. Closure alerts\n   The client and the server must share knowledge that\
    \ the connection is\n   ending in order to avoid a truncation attack. Either party\
    \ may\n   initiate the exchange of closing messages.\n   close_notify\n      \
    \ This message notifies the recipient that the sender will not send\n       any\
    \ more messages on this connection. The session becomes\n       unresumable if\
    \ any connection is terminated without proper\n       close_notify messages with\
    \ level equal to warning.\n   Either party may initiate a close by sending a close_notify\
    \ alert.\n   Any data received after a closure alert is ignored.\n   Each party\
    \ is required to send a close_notify alert before closing\n   the write side of\
    \ the connection. It is required that the other party\n   respond with a close_notify\
    \ alert of its own and close down the\n   connection immediately, discarding any\
    \ pending writes. It is not\n   required for the initiator of the close to wait\
    \ for the responding\n   close_notify alert before closing the read side of the\
    \ connection.\n   If the application protocol using TLS provides that any data\
    \ may be\n   carried over the underlying transport after the TLS connection is\n\
    \   closed, the TLS implementation must receive the responding\n   close_notify\
    \ alert before indicating to the application layer that\n   the TLS connection\
    \ has ended. If the application protocol will not\n   transfer any additional\
    \ data, but will only close the underlying\n   transport connection, then the\
    \ implementation may choose to close the\n   transport without waiting for the\
    \ responding close_notify. No part of\n   this standard should be taken to dictate\
    \ the manner in which a usage\n   profile for TLS manages its data transport,\
    \ including when\n   connections are opened or closed.\n   NB: It is assumed that\
    \ closing a connection reliably delivers\n       pending data before destroying\
    \ the transport.\n"
- title: 7.2.2. Error alerts
  contents:
  - "7.2.2. Error alerts\n   Error handling in the TLS Handshake protocol is very\
    \ simple. When an\n   error is detected, the detecting party sends a message to\
    \ the other\n   party. Upon transmission or receipt of an fatal alert message,\
    \ both\n   parties immediately close the connection. Servers and clients are\n\
    \   required to forget any session-identifiers, keys, and secrets\n   associated\
    \ with a failed connection. The following error alerts are\n   defined:\n   unexpected_message\n\
    \       An inappropriate message was received. This alert is always fatal\n  \
    \     and should never be observed in communication between proper\n       implementations.\n\
    \   bad_record_mac\n       This alert is returned if a record is received with\
    \ an incorrect\n       MAC. This message is always fatal.\n   decryption_failed\n\
    \       A TLSCiphertext decrypted in an invalid way: either it wasn`t an\n   \
    \    even multiple of the block length or its padding values, when\n       checked,\
    \ weren`t correct. This message is always fatal.\n   record_overflow\n       A\
    \ TLSCiphertext record was received which had a length more than\n       2^14+2048\
    \ bytes, or a record decrypted to a TLSCompressed record\n       with more than\
    \ 2^14+1024 bytes. This message is always fatal.\n   decompression_failure\n \
    \      The decompression function received improper input (e.g. data\n       that\
    \ would expand to excessive length). This message is always\n       fatal.\n \
    \  handshake_failure\n       Reception of a handshake_failure alert message indicates\
    \ that the\n       sender was unable to negotiate an acceptable set of security\n\
    \       parameters given the options available. This is a fatal error.\n   bad_certificate\n\
    \       A certificate was corrupt, contained signatures that did not\n       verify\
    \ correctly, etc.\n   unsupported_certificate\n       A certificate was of an\
    \ unsupported type.\n   certificate_revoked\n       A certificate was revoked\
    \ by its signer.\n   certificate_expired\n       A certificate has expired or\
    \ is not currently valid.\n   certificate_unknown\n       Some other (unspecified)\
    \ issue arose in processing the\n       certificate, rendering it unacceptable.\n\
    \   illegal_parameter\n       A field in the handshake was out of range or inconsistent\
    \ with\n       other fields. This is always fatal.\n   unknown_ca\n       A valid\
    \ certificate chain or partial chain was received, but the\n       certificate\
    \ was not accepted because the CA certificate could not\n       be located or\
    \ couldn`t be matched with a known, trusted CA.  This\n       message is always\
    \ fatal.\n   access_denied\n       A valid certificate was received, but when\
    \ access control was\n       applied, the sender decided not to proceed with negotiation.\n\
    \       This message is always fatal.\n   decode_error\n       A message could\
    \ not be decoded because some field was out of the\n       specified range or\
    \ the length of the message was incorrect. This\n       message is always fatal.\n\
    \   decrypt_error\n       A handshake cryptographic operation failed, including\
    \ being\n       unable to correctly verify a signature, decrypt a key exchange,\n\
    \       or validate a finished message.\n   export_restriction\n       A negotiation\
    \ not in compliance with export restrictions was\n       detected; for example,\
    \ attempting to transfer a 1024 bit\n       ephemeral RSA key for the RSA_EXPORT\
    \ handshake method. This\n       message is always fatal.\n   protocol_version\n\
    \       The protocol version the client has attempted to negotiate is\n      \
    \ recognized, but not supported. (For example, old protocol\n       versions might\
    \ be avoided for security reasons). This message is\n       always fatal.\n  \
    \ insufficient_security\n       Returned instead of handshake_failure when a negotiation\
    \ has\n       failed specifically because the server requires ciphers more\n \
    \      secure than those supported by the client. This message is always\n   \
    \    fatal.\n   internal_error\n       An internal error unrelated to the peer\
    \ or the correctness of the\n       protocol makes it impossible to continue (such\
    \ as a memory\n       allocation failure). This message is always fatal.\n   user_canceled\n\
    \       This handshake is being canceled for some reason unrelated to a\n    \
    \   protocol failure. If the user cancels an operation after the\n       handshake\
    \ is complete, just closing the connection by sending a\n       close_notify is\
    \ more appropriate. This alert should be followed\n       by a close_notify. This\
    \ message is generally a warning.\n   no_renegotiation\n       Sent by the client\
    \ in response to a hello request or by the\n       server in response to a client\
    \ hello after initial handshaking.\n       Either of these would normally lead\
    \ to renegotiation; when that\n       is not appropriate, the recipient should\
    \ respond with this alert;\n       at that point, the original requester can decide\
    \ whether to\n       proceed with the connection. One case where this would be\n\
    \       appropriate would be where a server has spawned a process to\n       satisfy\
    \ a request; the process might receive security parameters\n       (key length,\
    \ authentication, etc.) at startup and it might be\n       difficult to communicate\
    \ changes to these parameters after that\n       point. This message is always\
    \ a warning.\n   For all errors where an alert level is not explicitly specified,\
    \ the\n   sending party may determine at its discretion whether this is a fatal\n\
    \   error or not; if an alert with a level of warning is received, the\n   receiving\
    \ party may decide at its discretion whether to treat this as\n   a fatal error\
    \ or not. However, all messages which are transmitted\n   with a level of fatal\
    \ must be treated as fatal messages.\n"
- title: 7.3. Handshake Protocol overview
  contents:
  - "7.3. Handshake Protocol overview\n   The cryptographic parameters of the session\
    \ state are produced by the\n   TLS Handshake Protocol, which operates on top\
    \ of the TLS Record\n   Layer. When a TLS client and server first start communicating,\
    \ they\n   agree on a protocol version, select cryptographic algorithms,\n   optionally\
    \ authenticate each other, and use public-key encryption\n   techniques to generate\
    \ shared secrets.\n   The TLS Handshake Protocol involves the following steps:\n\
    \     - Exchange hello messages to agree on algorithms, exchange random\n    \
    \   values, and check for session resumption.\n     - Exchange the necessary cryptographic\
    \ parameters to allow the\n       client and server to agree on a premaster secret.\n\
    \     - Exchange certificates and cryptographic information to allow the\n   \
    \    client and server to authenticate themselves.\n     - Generate a master secret\
    \ from the premaster secret and exchanged\n       random values.\n     - Provide\
    \ security parameters to the record layer.\n     - Allow the client and server\
    \ to verify that their peer has\n       calculated the same security parameters\
    \ and that the handshake\n       occurred without tampering by an attacker.\n\
    \   Note that higher layers should not be overly reliant on TLS always\n   negotiating\
    \ the strongest possible connection between two peers:\n   there are a number\
    \ of ways a man in the middle attacker can attempt\n   to make two entities drop\
    \ down to the least secure method they\n   support. The protocol has been designed\
    \ to minimize this risk, but\n   there are still attacks available: for example,\
    \ an attacker could\n   block access to the port a secure service runs on, or\
    \ attempt to get\n   the peers to negotiate an unauthenticated connection. The\
    \ fundamental\n   rule is that higher levels must be cognizant of what their security\n\
    \   requirements are and never transmit information over a channel less\n   secure\
    \ than what they require. The TLS protocol is secure, in that\n   any cipher suite\
    \ offers its promised level of security: if you\n   negotiate 3DES with a 1024\
    \ bit RSA key exchange with a host whose\n   certificate you have verified, you\
    \ can expect to be that secure.\n   However, you should never send data over a\
    \ link encrypted with 40 bit\n   security unless you feel that data is worth no\
    \ more than the effort\n   required to break that encryption.\n   These goals\
    \ are achieved by the handshake protocol, which can be\n   summarized as follows:\
    \ The client sends a client hello message to\n   which the server must respond\
    \ with a server hello message, or else a\n   fatal error will occur and the connection\
    \ will fail. The client hello\n   and server hello are used to establish security\
    \ enhancement\n   capabilities between client and server. The client hello and\
    \ server\n   hello establish the following attributes: Protocol Version, Session\n\
    \   ID, Cipher Suite, and Compression Method. Additionally, two random\n   values\
    \ are generated and exchanged: ClientHello.random and\n   ServerHello.random.\n\
    \   The actual key exchange uses up to four messages: the server\n   certificate,\
    \ the server key exchange, the client certificate, and the\n   client key exchange.\
    \ New key exchange methods can be created by\n   specifying a format for these\
    \ messages and defining the use of the\n   messages to allow the client and server\
    \ to agree upon a shared\n   secret. This secret should be quite long; currently\
    \ defined key\n   exchange methods exchange secrets which range from 48 to 128\
    \ bytes in\n   length.\n   Following the hello messages, the server will send\
    \ its certificate,\n   if it is to be authenticated. Additionally, a server key\
    \ exchange\n   message may be sent, if it is required (e.g. if their server has\
    \ no\n   certificate, or if its certificate is for signing only). If the\n   server\
    \ is authenticated, it may request a certificate from the\n   client, if that\
    \ is appropriate to the cipher suite selected. Now the\n   server will send the\
    \ server hello done message, indicating that the\n   hello-message phase of the\
    \ handshake is complete. The server will\n   then wait for a client response.\
    \ If the server has sent a certificate\n   request message, the client must send\
    \ the certificate message. The\n   client key exchange message is now sent, and\
    \ the content of that\n   message will depend on the public key algorithm selected\
    \ between the\n   client hello and the server hello. If the client has sent a\n\
    \   certificate with signing ability, a digitally-signed certificate\n   verify\
    \ message is sent to explicitly verify the certificate.\n   At this point, a change\
    \ cipher spec message is sent by the client,\n   and the client copies the pending\
    \ Cipher Spec into the current Cipher\n   Spec. The client then immediately sends\
    \ the finished message under\n   the new algorithms, keys, and secrets. In response,\
    \ the server will\n   send its own change cipher spec message, transfer the pending\
    \ to the\n   current Cipher Spec, and send its finished message under the new\n\
    \   Cipher Spec. At this point, the handshake is complete and the client\n   and\
    \ server may begin to exchange application layer data. (See flow\n   chart below.)\n\
    \      Client                                               Server\n      ClientHello\
    \                  -------->\n                                               \
    \       ServerHello\n                                                     Certificate*\n\
    \                                               ServerKeyExchange*\n         \
    \                                     CertificateRequest*\n                  \
    \                 <--------      ServerHelloDone\n      Certificate*\n      ClientKeyExchange\n\
    \      CertificateVerify*\n      [ChangeCipherSpec]\n      Finished          \
    \           -------->\n                                               [ChangeCipherSpec]\n\
    \                                   <--------             Finished\n      Application\
    \ Data             <------->     Application Data\n             Fig. 1 - Message\
    \ flow for a full handshake\n   * Indicates optional or situation-dependent messages\
    \ that are not\n   always sent.\n  Note: To help avoid pipeline stalls, ChangeCipherSpec\
    \ is an\n       independent TLS Protocol content type, and is not actually a TLS\n\
    \       handshake message.\n   When the client and server decide to resume a previous\
    \ session or\n   duplicate an existing session (instead of negotiating new security\n\
    \   parameters) the message flow is as follows:\n   The client sends a ClientHello\
    \ using the Session ID of the session to\n   be resumed. The server then checks\
    \ its session cache for a match.  If\n   a match is found, and the server is willing\
    \ to re-establish the\n   connection under the specified session state, it will\
    \ send a\n   ServerHello with the same Session ID value. At this point, both\n\
    \   client and server must send change cipher spec messages and proceed\n   directly\
    \ to finished messages. Once the re-establishment is complete,\n   the client\
    \ and server may begin to exchange application layer data.\n   (See flow chart\
    \ below.) If a Session ID match is not found, the\n   server generates a new session\
    \ ID and the TLS client and server\n   perform a full handshake.\n      Client\
    \                                                Server\n      ClientHello   \
    \                -------->\n                                                 \
    \      ServerHello\n                                                [ChangeCipherSpec]\n\
    \                                    <--------             Finished\n      [ChangeCipherSpec]\n\
    \      Finished                      -------->\n      Application Data       \
    \       <------->     Application Data\n          Fig. 2 - Message flow for an\
    \ abbreviated handshake\n   The contents and significance of each message will\
    \ be presented in\n   detail in the following sections.\n"
- title: 7.4. Handshake protocol
  contents:
  - "7.4. Handshake protocol\n   The TLS Handshake Protocol is one of the defined\
    \ higher level clients\n   of the TLS Record Protocol. This protocol is used to\
    \ negotiate the\n   secure attributes of a session. Handshake messages are supplied\
    \ to\n   the TLS Record Layer, where they are encapsulated within one or more\n\
    \   TLSPlaintext structures, which are processed and transmitted as\n   specified\
    \ by the current active session state.\n       enum {\n           hello_request(0),\
    \ client_hello(1), server_hello(2),\n           certificate(11), server_key_exchange\
    \ (12),\n           certificate_request(13), server_hello_done(14),\n        \
    \   certificate_verify(15), client_key_exchange(16),\n           finished(20),\
    \ (255)\n       } HandshakeType;\n       struct {\n           HandshakeType msg_type;\
    \    /* handshake type */\n           uint24 length;             /* bytes in message\
    \ */\n           select (HandshakeType) {\n               case hello_request:\
    \       HelloRequest;\n               case client_hello:        ClientHello;\n\
    \               case server_hello:        ServerHello;\n               case certificate:\
    \         Certificate;\n               case server_key_exchange: ServerKeyExchange;\n\
    \               case certificate_request: CertificateRequest;\n              \
    \ case server_hello_done:   ServerHelloDone;\n               case certificate_verify:\
    \  CertificateVerify;\n               case client_key_exchange: ClientKeyExchange;\n\
    \               case finished:            Finished;\n           } body;\n    \
    \   } Handshake;\n   The handshake protocol messages are presented below in the\
    \ order they\n   must be sent; sending handshake messages in an unexpected order\n\
    \   results in a fatal error. Unneeded handshake messages can be omitted,\n  \
    \ however. Note one exception to the ordering: the Certificate message\n   is\
    \ used twice in the handshake (from server to client, then from\n   client to\
    \ server), but described only in its first position. The one\n   message which\
    \ is not bound by these ordering rules in the Hello\n   Request message, which\
    \ can be sent at any time, but which should be\n   ignored by the client if it\
    \ arrives in the middle of a handshake.\n"
- title: 7.4.1. Hello messages
  contents:
  - "7.4.1. Hello messages\n   The hello phase messages are used to exchange security\
    \ enhancement\n   capabilities between the client and server. When a new session\n\
    \   begins, the Record Layer's connection state encryption, hash, and\n   compression\
    \ algorithms are initialized to null. The current\n   connection state is used\
    \ for renegotiation messages.\n"
- title: 7.4.1.1. Hello request
  contents:
  - "7.4.1.1. Hello request\n   When this message will be sent:\n       The hello\
    \ request message may be sent by the server at any time.\n   Meaning of this message:\n\
    \       Hello request is a simple notification that the client should\n      \
    \ begin the negotiation process anew by sending a client hello\n       message\
    \ when convenient. This message will be ignored by the\n       client if the client\
    \ is currently negotiating a session. This\n       message may be ignored by the\
    \ client if it does not wish to\n       renegotiate a session, or the client may,\
    \ if it wishes, respond\n       with a no_renegotiation alert. Since handshake\
    \ messages are\n       intended to have transmission precedence over application\
    \ data,\n       it is expected that the negotiation will begin before no more\n\
    \       than a few records are received from the client. If the server\n     \
    \  sends a hello request but does not receive a client hello in\n       response,\
    \ it may close the connection with a fatal alert.\n   After sending a hello request,\
    \ servers should not repeat the request\n   until the subsequent handshake negotiation\
    \ is complete.\n   Structure of this message:\n       struct { } HelloRequest;\n\
    \ Note: This message should never be included in the message hashes which\n  \
    \     are maintained throughout the handshake and used in the finished\n     \
    \  messages and the certificate verify message.\n"
- title: 7.4.1.2. Client hello
  contents:
  - "7.4.1.2. Client hello\n   When this message will be sent:\n       When a client\
    \ first connects to a server it is required to send\n       the client hello as\
    \ its first message. The client can also send a\n       client hello in response\
    \ to a hello request or on its own\n       initiative in order to renegotiate\
    \ the security parameters in an\n       existing connection.\n       Structure\
    \ of this message:\n           The client hello message includes a random structure,\
    \ which is\n           used later in the protocol.\n           struct {\n    \
    \          uint32 gmt_unix_time;\n              opaque random_bytes[28];\n   \
    \        } Random;\n       gmt_unix_time\n       The current time and date in\
    \ standard UNIX 32-bit format (seconds\n       since the midnight starting Jan\
    \ 1, 1970, GMT) according to the\n       sender's internal clock. Clocks are not\
    \ required to be set\n       correctly by the basic TLS Protocol; higher level\
    \ or application\n       protocols may define additional requirements.\n   random_bytes\n\
    \       28 bytes generated by a secure random number generator.\n   The client\
    \ hello message includes a variable length session\n   identifier. If not empty,\
    \ the value identifies a session between the\n   same client and server whose\
    \ security parameters the client wishes to\n   reuse. The session identifier may\
    \ be from an earlier connection, this\n   connection, or another currently active\
    \ connection. The second option\n   is useful if the client only wishes to update\
    \ the random structures\n   and derived values of a connection, while the third\
    \ option makes it\n   possible to establish several independent secure connections\
    \ without\n   repeating the full handshake protocol. These independent connections\n\
    \   may occur sequentially or simultaneously; a SessionID becomes valid\n   when\
    \ the handshake negotiating it completes with the exchange of\n   Finished messages\
    \ and persists until removed due to aging or because\n   a fatal error was encountered\
    \ on a connection associated with the\n   session. The actual contents of the\
    \ SessionID are defined by the\n   server.\n       opaque SessionID<0..32>;\n\
    \   Warning:\n       Because the SessionID is transmitted without encryption or\n\
    \       immediate MAC protection, servers must not place confidential\n      \
    \ information in session identifiers or let the contents of fake\n       session\
    \ identifiers cause any breach of security. (Note that the\n       content of\
    \ the handshake as a whole, including the SessionID, is\n       protected by the\
    \ Finished messages exchanged at the end of the\n       handshake.)\n   The CipherSuite\
    \ list, passed from the client to the server in the\n   client hello message,\
    \ contains the combinations of cryptographic\n   algorithms supported by the client\
    \ in order of the client's\n   preference (favorite choice first). Each CipherSuite\
    \ defines a key\n   exchange algorithm, a bulk encryption algorithm (including\
    \ secret key\n   length) and a MAC algorithm. The server will select a cipher\
    \ suite\n   or, if no acceptable choices are presented, return a handshake\n \
    \  failure alert and close the connection.\n       uint8 CipherSuite[2];    /*\
    \ Cryptographic suite selector */\n   The client hello includes a list of compression\
    \ algorithms supported\n   by the client, ordered according to the client's preference.\n\
    \       enum { null(0), (255) } CompressionMethod;\n       struct {\n        \
    \   ProtocolVersion client_version;\n           Random random;\n           SessionID\
    \ session_id;\n           CipherSuite cipher_suites<2..2^16-1>;\n           CompressionMethod\
    \ compression_methods<1..2^8-1>;\n       } ClientHello;\n   client_version\n \
    \      The version of the TLS protocol by which the client wishes to\n       communicate\
    \ during this session. This should be the latest\n       (highest valued) version\
    \ supported by the client. For this\n       version of the specification, the\
    \ version will be 3.1 (See\n       Appendix E for details about backward compatibility).\n\
    \   random\n       A client-generated random structure.\n   session_id\n     \
    \  The ID of a session the client wishes to use for this connection.\n       This\
    \ field should be empty if no session_id is available or the\n       client wishes\
    \ to generate new security parameters.\n   cipher_suites\n       This is a list\
    \ of the cryptographic options supported by the\n       client, with the client's\
    \ first preference first. If the\n       session_id field is not empty (implying\
    \ a session resumption\n       request) this vector must include at least the\
    \ cipher_suite from\n       that session. Values are defined in Appendix A.5.\n\
    \   compression_methods\n       This is a list of the compression methods supported\
    \ by the\n       client, sorted by client preference. If the session_id field\
    \ is\n       not empty (implying a session resumption request) it must include\n\
    \       the compression_method from that session. This vector must\n       contain,\
    \ and all implementations must support,\n       CompressionMethod.null. Thus,\
    \ a client and server will always be\n       able to agree on a compression method.\n\
    \   After sending the client hello message, the client waits for a server\n  \
    \ hello message. Any other handshake message returned by the server\n   except\
    \ for a hello request is treated as a fatal error.\n   Forward compatibility note:\n\
    \       In the interests of forward compatibility, it is permitted for a\n   \
    \    client hello message to include extra data after the compression\n      \
    \ methods. This data must be included in the handshake hashes, but\n       must\
    \ otherwise be ignored. This is the only handshake message for\n       which this\
    \ is legal; for all other messages, the amount of data\n       in the message\
    \ must match the description of the message\n       precisely.\n"
- title: 7.4.1.3. Server hello
  contents:
  - "7.4.1.3. Server hello\n   When this message will be sent:\n       The server\
    \ will send this message in response to a client hello\n       message when it\
    \ was able to find an acceptable set of algorithms.\n       If it cannot find\
    \ such a match, it will respond with a handshake\n       failure alert.\n   Structure\
    \ of this message:\n       struct {\n           ProtocolVersion server_version;\n\
    \           Random random;\n           SessionID session_id;\n           CipherSuite\
    \ cipher_suite;\n           CompressionMethod compression_method;\n       } ServerHello;\n\
    \   server_version\n       This field will contain the lower of that suggested\
    \ by the client\n       in the client hello and the highest supported by the server.\
    \ For\n       this version of the specification, the version is 3.1 (See\n   \
    \    Appendix E for details about backward compatibility).\n   random\n      \
    \ This structure is generated by the server and must be different\n       from\
    \ (and independent of) ClientHello.random.\n   session_id\n       This is the\
    \ identity of the session corresponding to this\n       connection. If the ClientHello.session_id\
    \ was non-empty, the\n       server will look in its session cache for a match.\
    \ If a match is\n       found and the server is willing to establish the new connection\n\
    \       using the specified session state, the server will respond with\n    \
    \   the same value as was supplied by the client. This indicates a\n       resumed\
    \ session and dictates that the parties must proceed\n       directly to the finished\
    \ messages. Otherwise this field will\n       contain a different value identifying\
    \ the new session. The server\n       may return an empty session_id to indicate\
    \ that the session will\n       not be cached and therefore cannot be resumed.\
    \ If a session is\n       resumed, it must be resumed using the same cipher suite\
    \ it was\n       originally negotiated with.\n   cipher_suite\n       The single\
    \ cipher suite selected by the server from the list in\n       ClientHello.cipher_suites.\
    \ For resumed sessions this field is the\n       value from the state of the session\
    \ being resumed.\n   compression_method\n       The single compression algorithm\
    \ selected by the server from the\n       list in ClientHello.compression_methods.\
    \ For resumed sessions\n       this field is the value from the resumed session\
    \ state.\n"
- title: 7.4.2. Server certificate
  contents:
  - "7.4.2. Server certificate\n   When this message will be sent:\n       The server\
    \ must send a certificate whenever the agreed-upon key\n       exchange method\
    \ is not an anonymous one. This message will always\n       immediately follow\
    \ the server hello message.\n   Meaning of this message:\n       The certificate\
    \ type must be appropriate for the selected cipher\n       suite's key exchange\
    \ algorithm, and is generally an X.509v3\n       certificate. It must contain\
    \ a key which matches the key exchange\n       method, as follows. Unless otherwise\
    \ specified, the signing\n       algorithm for the certificate must be the same\
    \ as the algorithm\n       for the certificate key. Unless otherwise specified,\
    \ the public\n       key may be of any length.\n       Key Exchange Algorithm\
    \  Certificate Key Type\n       RSA                     RSA public key; the certificate\
    \ must\n                               allow the key to be used for encryption.\n\
    \       RSA_EXPORT              RSA public key of length greater than\n      \
    \                         512 bits which can be used for signing,\n          \
    \                     or a key of 512 bits or shorter which\n                \
    \               can be used for either encryption or\n                       \
    \        signing.\n       DHE_DSS                 DSS public key.\n       DHE_DSS_EXPORT\
    \          DSS public key.\n       DHE_RSA                 RSA public key which\
    \ can be used for\n                               signing.\n       DHE_RSA_EXPORT\
    \          RSA public key which can be used for\n                            \
    \   signing.\n       DH_DSS                  Diffie-Hellman key. The algorithm\
    \ used\n                               to sign the certificate should be DSS.\n\
    \       DH_RSA                  Diffie-Hellman key. The algorithm used\n     \
    \                          to sign the certificate should be RSA.\n   All certificate\
    \ profiles, key and cryptographic formats are defined\n   by the IETF PKIX working\
    \ group [PKIX]. When a key usage extension is\n   present, the digitalSignature\
    \ bit must be set for the key to be\n   eligible for signing, as described above,\
    \ and the keyEncipherment bit\n   must be present to allow encryption, as described\
    \ above. The\n   keyAgreement bit must be set on Diffie-Hellman certificates.\n\
    \   As CipherSuites which specify new key exchange methods are specified\n   for\
    \ the TLS Protocol, they will imply certificate format and the\n   required encoded\
    \ keying information.\n   Structure of this message:\n       opaque ASN.1Cert<1..2^24-1>;\n\
    \       struct {\n           ASN.1Cert certificate_list<0..2^24-1>;\n       }\
    \ Certificate;\n   certificate_list\n       This is a sequence (chain) of X.509v3\
    \ certificates. The sender's\n       certificate must come first in the list.\
    \ Each following\n       certificate must directly certify the one preceding it.\
    \ Because\n       certificate validation requires that root keys be distributed\n\
    \       independently, the self-signed certificate which specifies the\n     \
    \  root certificate authority may optionally be omitted from the\n       chain,\
    \ under the assumption that the remote end must already\n       possess it in\
    \ order to validate it in any case.\n   The same message type and structure will\
    \ be used for the client's\n   response to a certificate request message. Note\
    \ that a client may\n   send no certificates if it does not have an appropriate\
    \ certificate\n   to send in response to the server's authentication request.\n\
    \ Note: PKCS #7 [PKCS7] is not used as the format for the certificate\n      \
    \ vector because PKCS #6 [PKCS6] extended certificates are not\n       used. Also\
    \ PKCS #7 defines a SET rather than a SEQUENCE, making\n       the task of parsing\
    \ the list more difficult.\n"
- title: 7.4.3. Server key exchange message
  contents:
  - "7.4.3. Server key exchange message\n   When this message will be sent:\n    \
    \   This message will be sent immediately after the server\n       certificate\
    \ message (or the server hello message, if this is an\n       anonymous negotiation).\n\
    \       The server key exchange message is sent by the server only when\n    \
    \   the server certificate message (if sent) does not contain enough\n       data\
    \ to allow the client to exchange a premaster secret. This is\n       true for\
    \ the following key exchange methods:\n           RSA_EXPORT (if the public key\
    \ in the server certificate is\n           longer than 512 bits)\n           DHE_DSS\n\
    \           DHE_DSS_EXPORT\n           DHE_RSA\n           DHE_RSA_EXPORT\n  \
    \         DH_anon\n       It is not legal to send the server key exchange message\
    \ for the\n       following key exchange methods:\n           RSA\n          \
    \ RSA_EXPORT (when the public key in the server certificate is\n           less\
    \ than or equal to 512 bits in length)\n           DH_DSS\n           DH_RSA\n\
    \   Meaning of this message:\n       This message conveys cryptographic information\
    \ to allow the\n       client to communicate the premaster secret: either an RSA\
    \ public\n       key to encrypt the premaster secret with, or a Diffie-Hellman\n\
    \       public key with which the client can complete a key exchange\n       (with\
    \ the result being the premaster secret.)\n   As additional CipherSuites are defined\
    \ for TLS which include new key\n   exchange algorithms, the server key exchange\
    \ message will be sent if\n   and only if the certificate type associated with\
    \ the key exchange\n   algorithm does not provide enough information for the client\
    \ to\n   exchange a premaster secret.\n Note: According to current US export law,\
    \ RSA moduli larger than 512\n       bits may not be used for key exchange in\
    \ software exported from\n       the US. With this message, the larger RSA keys\
    \ encoded in\n       certificates may be used to sign temporary shorter RSA keys\
    \ for\n       the RSA_EXPORT key exchange method.\n   Structure of this message:\n\
    \       enum { rsa, diffie_hellman } KeyExchangeAlgorithm;\n       struct {\n\
    \           opaque rsa_modulus<1..2^16-1>;\n           opaque rsa_exponent<1..2^16-1>;\n\
    \       } ServerRSAParams;\n       rsa_modulus\n           The modulus of the\
    \ server's temporary RSA key.\n       rsa_exponent\n           The public exponent\
    \ of the server's temporary RSA key.\n       struct {\n           opaque dh_p<1..2^16-1>;\n\
    \           opaque dh_g<1..2^16-1>;\n           opaque dh_Ys<1..2^16-1>;\n   \
    \    } ServerDHParams;     /* Ephemeral DH parameters */\n       dh_p\n      \
    \     The prime modulus used for the Diffie-Hellman operation.\n       dh_g\n\
    \           The generator used for the Diffie-Hellman operation.\n       dh_Ys\n\
    \           The server's Diffie-Hellman public value (g^X mod p).\n       struct\
    \ {\n           select (KeyExchangeAlgorithm) {\n               case diffie_hellman:\n\
    \                   ServerDHParams params;\n                   Signature signed_params;\n\
    \               case rsa:\n                   ServerRSAParams params;\n      \
    \             Signature signed_params;\n           };\n       } ServerKeyExchange;\n\
    \       params\n           The server's key exchange parameters.\n       signed_params\n\
    \           For non-anonymous key exchanges, a hash of the corresponding\n   \
    \        params value, with the signature appropriate to that hash\n         \
    \  applied.\n       md5_hash\n           MD5(ClientHello.random + ServerHello.random\
    \ + ServerParams);\n       sha_hash\n           SHA(ClientHello.random + ServerHello.random\
    \ + ServerParams);\n       enum { anonymous, rsa, dsa } SignatureAlgorithm;\n\
    \       select (SignatureAlgorithm)\n       {   case anonymous: struct { };\n\
    \           case rsa:\n               digitally-signed struct {\n            \
    \       opaque md5_hash[16];\n                   opaque sha_hash[20];\n      \
    \         };\n           case dsa:\n               digitally-signed struct {\n\
    \                   opaque sha_hash[20];\n               };\n       } Signature;\n"
- title: 7.4.4. Certificate request
  contents:
  - "7.4.4. Certificate request\n   When this message will be sent:\n       A non-anonymous\
    \ server can optionally request a certificate from\n       the client, if appropriate\
    \ for the selected cipher suite. This\n       message, if sent, will immediately\
    \ follow the Server Key Exchange\n       message (if it is sent; otherwise, the\
    \ Server Certificate\n       message).\n   Structure of this message:\n      \
    \ enum {\n           rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),\n\
    \           (255)\n       } ClientCertificateType;\n       opaque DistinguishedName<1..2^16-1>;\n\
    \       struct {\n           ClientCertificateType certificate_types<1..2^8-1>;\n\
    \           DistinguishedName certificate_authorities<3..2^16-1>;\n       } CertificateRequest;\n\
    \       certificate_types\n              This field is a list of the types of\
    \ certificates requested,\n              sorted in order of the server's preference.\n\
    \       certificate_authorities\n           A list of the distinguished names\
    \ of acceptable certificate\n           authorities. These distinguished names\
    \ may specify a desired\n           distinguished name for a root CA or for a\
    \ subordinate CA;\n           thus, this message can be used both to describe\
    \ known roots\n           and a desired authorization space.\n Note: DistinguishedName\
    \ is derived from [X509].\n Note: It is a fatal handshake_failure alert for an\
    \ anonymous server to\n       request client identification.\n"
- title: 7.4.5. Server hello done
  contents:
  - "7.4.5. Server hello done\n   When this message will be sent:\n       The server\
    \ hello done message is sent by the server to indicate\n       the end of the\
    \ server hello and associated messages. After\n       sending this message the\
    \ server will wait for a client response.\n   Meaning of this message:\n     \
    \  This message means that the server is done sending messages to\n       support\
    \ the key exchange, and the client can proceed with its\n       phase of the key\
    \ exchange.\n       Upon receipt of the server hello done message the client should\n\
    \       verify that the server provided a valid certificate if required\n    \
    \   and check that the server hello parameters are acceptable.\n   Structure of\
    \ this message:\n       struct { } ServerHelloDone;\n"
- title: 7.4.6. Client certificate
  contents:
  - "7.4.6. Client certificate\n   When this message will be sent:\n       This is\
    \ the first message the client can send after receiving a\n       server hello\
    \ done message. This message is only sent if the\n       server requests a certificate.\
    \ If no suitable certificate is\n       available, the client should send a certificate\
    \ message\n       containing no certificates. If client authentication is required\n\
    \       by the server for the handshake to continue, it may respond with\n   \
    \    a fatal handshake failure alert. Client certificates are sent\n       using\
    \ the Certificate structure defined in Section 7.4.2.\n Note: When using a static\
    \ Diffie-Hellman based key exchange method\n       (DH_DSS or DH_RSA), if client\
    \ authentication is requested, the\n       Diffie-Hellman group and generator\
    \ encoded in the client's\n       certificate must match the server specified\
    \ Diffie-Hellman\n       parameters if the client's parameters are to be used\
    \ for the key\n       exchange.\n"
- title: 7.4.7. Client key exchange message
  contents:
  - "7.4.7. Client key exchange message\n   When this message will be sent:\n    \
    \   This message is always sent by the client. It will immediately\n       follow\
    \ the client certificate message, if it is sent. Otherwise\n       it will be\
    \ the first message sent by the client after it receives\n       the server hello\
    \ done message.\n   Meaning of this message:\n       With this message, the premaster\
    \ secret is set, either though\n       direct transmission of the RSA-encrypted\
    \ secret, or by the\n       transmission of Diffie-Hellman parameters which will\
    \ allow each\n       side to agree upon the same premaster secret. When the key\n\
    \       exchange method is DH_RSA or DH_DSS, client certification has\n      \
    \ been requested, and the client was able to respond with a\n       certificate\
    \ which contained a Diffie-Hellman public key whose\n       parameters (group\
    \ and generator) matched those specified by the\n       server in its certificate,\
    \ this message will not contain any\n       data.\n   Structure of this message:\n\
    \       The choice of messages depends on which key exchange method has\n    \
    \   been selected. See Section 7.4.3 for the KeyExchangeAlgorithm\n       definition.\n\
    \       struct {\n           select (KeyExchangeAlgorithm) {\n               case\
    \ rsa: EncryptedPreMasterSecret;\n               case diffie_hellman: ClientDiffieHellmanPublic;\n\
    \           } exchange_keys;\n       } ClientKeyExchange;\n"
- title: 7.4.7.1. RSA encrypted premaster secret message
  contents:
  - "7.4.7.1. RSA encrypted premaster secret message\n   Meaning of this message:\n\
    \       If RSA is being used for key agreement and authentication, the\n     \
    \  client generates a 48-byte premaster secret, encrypts it using\n       the\
    \ public key from the server's certificate or the temporary RSA\n       key provided\
    \ in a server key exchange message, and sends the\n       result in an encrypted\
    \ premaster secret message. This structure\n       is a variant of the client\
    \ key exchange message, not a message in\n       itself.\n   Structure of this\
    \ message:\n       struct {\n           ProtocolVersion client_version;\n    \
    \       opaque random[46];\n       } PreMasterSecret;\n       client_version\n\
    \           The latest (newest) version supported by the client. This is\n   \
    \        used to detect version roll-back attacks. Upon receiving the\n      \
    \     premaster secret, the server should check that this value\n           matches\
    \ the value transmitted by the client in the client\n           hello message.\n\
    \       random\n           46 securely-generated random bytes.\n       struct\
    \ {\n           public-key-encrypted PreMasterSecret pre_master_secret;\n    \
    \   } EncryptedPreMasterSecret;\n Note: An attack discovered by Daniel Bleichenbacher\
    \ [BLEI] can be used\n       to attack a TLS server which is using PKCS#1 encoded\
    \ RSA. The\n       attack takes advantage of the fact that by failing in different\n\
    \       ways, a TLS server can be coerced into revealing whether a\n       particular\
    \ message, when decrypted, is properly PKCS#1 formatted\n       or not.\n    \
    \   The best way to avoid vulnerability to this attack is to treat\n       incorrectly\
    \ formatted messages in a manner indistinguishable from\n       correctly formatted\
    \ RSA blocks. Thus, when it receives an\n       incorrectly formatted RSA block,\
    \ a server should generate a\n       random 48-byte value and proceed using it\
    \ as the premaster\n       secret. Thus, the server will act identically whether\
    \ the\n       received RSA block is correctly encoded or not.\n       pre_master_secret\n\
    \           This random value is generated by the client and is used to\n    \
    \       generate the master secret, as specified in Section 8.1.\n"
- title: 7.4.7.2. Client Diffie-Hellman public value
  contents:
  - "7.4.7.2. Client Diffie-Hellman public value\n   Meaning of this message:\n  \
    \     This structure conveys the client's Diffie-Hellman public value\n      \
    \ (Yc) if it was not already included in the client's certificate.\n       The\
    \ encoding used for Yc is determined by the enumerated\n       PublicValueEncoding.\
    \ This structure is a variant of the client\n       key exchange message, not\
    \ a message in itself.\n   Structure of this message:\n       enum { implicit,\
    \ explicit } PublicValueEncoding;\n       implicit\n           If the client certificate\
    \ already contains a suitable\n           Diffie-Hellman key, then Yc is implicit\
    \ and does not need to\n           be sent again. In this case, the Client Key\
    \ Exchange message\n           will be sent, but will be empty.\n       explicit\n\
    \           Yc needs to be sent.\n       struct {\n           select (PublicValueEncoding)\
    \ {\n               case implicit: struct { };\n               case explicit:\
    \ opaque dh_Yc<1..2^16-1>;\n           } dh_public;\n       } ClientDiffieHellmanPublic;\n\
    \       dh_Yc\n           The client's Diffie-Hellman public value (Yc).\n"
- title: 7.4.8. Certificate verify
  contents:
  - "7.4.8. Certificate verify\n   When this message will be sent:\n       This message\
    \ is used to provide explicit verification of a client\n       certificate. This\
    \ message is only sent following a client\n       certificate that has signing\
    \ capability (i.e. all certificates\n       except those containing fixed Diffie-Hellman\
    \ parameters). When\n       sent, it will immediately follow the client key exchange\
    \ message.\n   Structure of this message:\n       struct {\n            Signature\
    \ signature;\n       } CertificateVerify;\n       The Signature type is defined\
    \ in 7.4.3.\n       CertificateVerify.signature.md5_hash\n           MD5(handshake_messages);\n\
    \       Certificate.signature.sha_hash\n           SHA(handshake_messages);\n\
    \   Here handshake_messages refers to all handshake messages sent or\n   received\
    \ starting at client hello up to but not including this\n   message, including\
    \ the type and length fields of the handshake\n   messages. This is the concatenation\
    \ of all the Handshake structures\n   as defined in 7.4 exchanged thus far.\n"
- title: 7.4.9. Finished
  contents:
  - "7.4.9. Finished\n   When this message will be sent:\n       A finished message\
    \ is always sent immediately after a change\n       cipher spec message to verify\
    \ that the key exchange and\n       authentication processes were successful.\
    \ It is essential that a\n       change cipher spec message be received between\
    \ the other\n       handshake messages and the Finished message.\n   Meaning of\
    \ this message:\n       The finished message is the first protected with the just-\n\
    \       negotiated algorithms, keys, and secrets. Recipients of finished\n   \
    \    messages must verify that the contents are correct.  Once a side\n      \
    \ has sent its Finished message and received and validated the\n       Finished\
    \ message from its peer, it may begin to send and receive\n       application\
    \ data over the connection.\n       struct {\n           opaque verify_data[12];\n\
    \       } Finished;\n       verify_data\n           PRF(master_secret, finished_label,\
    \ MD5(handshake_messages) +\n           SHA-1(handshake_messages)) [0..11];\n\
    \       finished_label\n           For Finished messages sent by the client, the\
    \ string \"client\n           finished\". For Finished messages sent by the server,\
    \ the\n           string \"server finished\".\n       handshake_messages\n   \
    \        All of the data from all handshake messages up to but not\n         \
    \  including this message. This is only data visible at the\n           handshake\
    \ layer and does not include record layer headers.\n           This is the concatenation\
    \ of all the Handshake structures as\n           defined in 7.4 exchanged thus\
    \ far.\n   It is a fatal error if a finished message is not preceded by a change\n\
    \   cipher spec message at the appropriate point in the handshake.\n   The hash\
    \ contained in finished messages sent by the server\n   incorporate Sender.server;\
    \ those sent by the client incorporate\n   Sender.client. The value handshake_messages\
    \ includes all handshake\n   messages starting at client hello up to, but not\
    \ including, this\n   finished message. This may be different from handshake_messages\
    \ in\n   Section 7.4.8 because it would include the certificate verify message\n\
    \   (if sent). Also, the handshake_messages for the finished message sent\n  \
    \ by the client will be different from that for the finished message\n   sent\
    \ by the server, because the one which is sent second will include\n   the prior\
    \ one.\n Note: Change cipher spec messages, alerts and any other record types\n\
    \       are not handshake messages and are not included in the hash\n       computations.\
    \ Also, Hello Request messages are omitted from\n       handshake hashes.\n"
- title: 8. Cryptographic computations
  contents:
  - "8. Cryptographic computations\n   In order to begin connection protection, the\
    \ TLS Record Protocol\n   requires specification of a suite of algorithms, a master\
    \ secret, and\n   the client and server random values. The authentication, encryption,\n\
    \   and MAC algorithms are determined by the cipher_suite selected by the\n  \
    \ server and revealed in the server hello message. The compression\n   algorithm\
    \ is negotiated in the hello messages, and the random values\n   are exchanged\
    \ in the hello messages. All that remains is to calculate\n   the master secret.\n"
- title: 8.1. Computing the master secret
  contents:
  - "8.1. Computing the master secret\n   For all key exchange methods, the same algorithm\
    \ is used to convert\n   the pre_master_secret into the master_secret. The pre_master_secret\n\
    \   should be deleted from memory once the master_secret has been\n   computed.\n\
    \       master_secret = PRF(pre_master_secret, \"master secret\",\n          \
    \                 ClientHello.random + ServerHello.random)\n       [0..47];\n\
    \   The master secret is always exactly 48 bytes in length. The length of\n  \
    \ the premaster secret will vary depending on key exchange method.\n"
- title: 8.1.1. RSA
  contents:
  - "8.1.1. RSA\n   When RSA is used for server authentication and key exchange, a\
    \ 48-\n   byte pre_master_secret is generated by the client, encrypted under\n\
    \   the server's public key, and sent to the server. The server uses its\n   private\
    \ key to decrypt the pre_master_secret. Both parties then\n   convert the pre_master_secret\
    \ into the master_secret, as specified\n   above.\n   RSA digital signatures are\
    \ performed using PKCS #1 [PKCS1] block type\n   1. RSA public key encryption\
    \ is performed using PKCS #1 block type 2.\n"
- title: 8.1.2. Diffie-Hellman
  contents:
  - "8.1.2. Diffie-Hellman\n   A conventional Diffie-Hellman computation is performed.\
    \ The\n   negotiated key (Z) is used as the pre_master_secret, and is converted\n\
    \   into the master_secret, as specified above.\n Note: Diffie-Hellman parameters\
    \ are specified by the server, and may\n       be either ephemeral or contained\
    \ within the server's certificate.\n"
- title: 9. Mandatory Cipher Suites
  contents:
  - "9. Mandatory Cipher Suites\n   In the absence of an application profile standard\
    \ specifying\n   otherwise, a TLS compliant application MUST implement the cipher\n\
    \   suite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA.\n"
- title: 10. Application data protocol
  contents:
  - "10. Application data protocol\n   Application data messages are carried by the\
    \ Record Layer and are\n   fragmented, compressed and encrypted based on the current\
    \ connection\n   state. The messages are treated as transparent data to the record\n\
    \   layer.\n"
- title: A. Protocol constant values
  contents:
  - "A. Protocol constant values\n   This section describes protocol types and constants.\n"
- title: A.1. Record layer
  contents:
  - "A.1. Record layer\n    struct {\n        uint8 major, minor;\n    } ProtocolVersion;\n\
    \    ProtocolVersion version = { 3, 1 };     /* TLS v1.0 */\n    enum {\n    \
    \    change_cipher_spec(20), alert(21), handshake(22),\n        application_data(23),\
    \ (255)\n    } ContentType;\n    struct {\n        ContentType type;\n       \
    \ ProtocolVersion version;\n        uint16 length;\n        opaque fragment[TLSPlaintext.length];\n\
    \    } TLSPlaintext;\n    struct {\n        ContentType type;\n        ProtocolVersion\
    \ version;\n        uint16 length;\n        opaque fragment[TLSCompressed.length];\n\
    \    } TLSCompressed;\n    struct {\n        ContentType type;\n        ProtocolVersion\
    \ version;\n        uint16 length;\n        select (CipherSpec.cipher_type) {\n\
    \            case stream: GenericStreamCipher;\n            case block:  GenericBlockCipher;\n\
    \        } fragment;\n    } TLSCiphertext;\n    stream-ciphered struct {\n   \
    \     opaque content[TLSCompressed.length];\n        opaque MAC[CipherSpec.hash_size];\n\
    \    } GenericStreamCipher;\n    block-ciphered struct {\n        opaque content[TLSCompressed.length];\n\
    \        opaque MAC[CipherSpec.hash_size];\n        uint8 padding[GenericBlockCipher.padding_length];\n\
    \        uint8 padding_length;\n    } GenericBlockCipher;\n"
- title: A.2. Change cipher specs message
  contents:
  - "A.2. Change cipher specs message\n    struct {\n        enum { change_cipher_spec(1),\
    \ (255) } type;\n    } ChangeCipherSpec;\n"
- title: A.3. Alert messages
  contents:
  - "A.3. Alert messages\n    enum { warning(1), fatal(2), (255) } AlertLevel;\n \
    \       enum {\n            close_notify(0),\n            unexpected_message(10),\n\
    \            bad_record_mac(20),\n            decryption_failed(21),\n       \
    \     record_overflow(22),\n            decompression_failure(30),\n         \
    \   handshake_failure(40),\n            bad_certificate(42),\n            unsupported_certificate(43),\n\
    \            certificate_revoked(44),\n            certificate_expired(45),\n\
    \            certificate_unknown(46),\n            illegal_parameter(47),\n  \
    \          unknown_ca(48),\n            access_denied(49),\n            decode_error(50),\n\
    \            decrypt_error(51),\n            export_restriction(60),\n       \
    \     protocol_version(70),\n            insufficient_security(71),\n        \
    \    internal_error(80),\n            user_canceled(90),\n            no_renegotiation(100),\n\
    \            (255)\n        } AlertDescription;\n    struct {\n        AlertLevel\
    \ level;\n        AlertDescription description;\n    } Alert;\n"
- title: A.4. Handshake protocol
  contents:
  - "A.4. Handshake protocol\n    enum {\n        hello_request(0), client_hello(1),\
    \ server_hello(2),\n        certificate(11), server_key_exchange (12),\n     \
    \   certificate_request(13), server_hello_done(14),\n        certificate_verify(15),\
    \ client_key_exchange(16),\n        finished(20), (255)\n    } HandshakeType;\n\
    \    struct {\n        HandshakeType msg_type;\n        uint24 length;\n     \
    \   select (HandshakeType) {\n            case hello_request:       HelloRequest;\n\
    \            case client_hello:        ClientHello;\n            case server_hello:\
    \        ServerHello;\n            case certificate:         Certificate;\n  \
    \          case server_key_exchange: ServerKeyExchange;\n            case certificate_request:\
    \ CertificateRequest;\n            case server_hello_done:   ServerHelloDone;\n\
    \            case certificate_verify:  CertificateVerify;\n            case client_key_exchange:\
    \ ClientKeyExchange;\n            case finished:            Finished;\n      \
    \  } body;\n    } Handshake;\n"
- title: A.4.1. Hello messages
  contents:
  - "A.4.1. Hello messages\n    struct { } HelloRequest;\n    struct {\n        uint32\
    \ gmt_unix_time;\n        opaque random_bytes[28];\n    } Random;\n    opaque\
    \ SessionID<0..32>;\n    uint8 CipherSuite[2];\n    enum { null(0), (255) } CompressionMethod;\n\
    \    struct {\n        ProtocolVersion client_version;\n        Random random;\n\
    \        SessionID session_id;\n        CipherSuite cipher_suites<2..2^16-1>;\n\
    \        CompressionMethod compression_methods<1..2^8-1>;\n    } ClientHello;\n\
    \    struct {\n        ProtocolVersion server_version;\n        Random random;\n\
    \        SessionID session_id;\n        CipherSuite cipher_suite;\n        CompressionMethod\
    \ compression_method;\n    } ServerHello;\n"
- title: A.4.2. Server authentication and key exchange messages
  contents:
  - "A.4.2. Server authentication and key exchange messages\n    opaque ASN.1Cert<2^24-1>;\n\
    \    struct {\n        ASN.1Cert certificate_list<1..2^24-1>;\n    } Certificate;\n\
    \    enum { rsa, diffie_hellman } KeyExchangeAlgorithm;\n    struct {\n      \
    \  opaque RSA_modulus<1..2^16-1>;\n        opaque RSA_exponent<1..2^16-1>;\n \
    \   } ServerRSAParams;\n    struct {\n        opaque DH_p<1..2^16-1>;\n      \
    \  opaque DH_g<1..2^16-1>;\n        opaque DH_Ys<1..2^16-1>;\n    } ServerDHParams;\n\
    \    struct {\n        select (KeyExchangeAlgorithm) {\n            case diffie_hellman:\n\
    \                ServerDHParams params;\n                Signature signed_params;\n\
    \            case rsa:\n                ServerRSAParams params;\n            \
    \    Signature signed_params;\n        };\n    } ServerKeyExchange;\n    enum\
    \ { anonymous, rsa, dsa } SignatureAlgorithm;\n    select (SignatureAlgorithm)\n\
    \    {   case anonymous: struct { };\n        case rsa:\n            digitally-signed\
    \ struct {\n                opaque md5_hash[16];\n                opaque sha_hash[20];\n\
    \            };\n        case dsa:\n            digitally-signed struct {\n  \
    \              opaque sha_hash[20];\n            };\n    } Signature;\n    enum\
    \ {\n        rsa_sign(1), dss_sign(2), rsa_fixed_dh(3), dss_fixed_dh(4),\n   \
    \     (255)\n    } ClientCertificateType;\n    opaque DistinguishedName<1..2^16-1>;\n\
    \    struct {\n        ClientCertificateType certificate_types<1..2^8-1>;\n  \
    \      DistinguishedName certificate_authorities<3..2^16-1>;\n    } CertificateRequest;\n\
    \    struct { } ServerHelloDone;\n"
- title: A.4.3. Client authentication and key exchange messages
  contents:
  - "A.4.3. Client authentication and key exchange messages\n    struct {\n      \
    \  select (KeyExchangeAlgorithm) {\n            case rsa: EncryptedPreMasterSecret;\n\
    \            case diffie_hellman: DiffieHellmanClientPublicValue;\n        } exchange_keys;\n\
    \    } ClientKeyExchange;\n    struct {\n        ProtocolVersion client_version;\n\
    \        opaque random[46];\n    } PreMasterSecret;\n    struct {\n        public-key-encrypted\
    \ PreMasterSecret pre_master_secret;\n    } EncryptedPreMasterSecret;\n    enum\
    \ { implicit, explicit } PublicValueEncoding;\n    struct {\n        select (PublicValueEncoding)\
    \ {\n            case implicit: struct {};\n            case explicit: opaque\
    \ DH_Yc<1..2^16-1>;\n        } dh_public;\n    } ClientDiffieHellmanPublic;\n\
    \    struct {\n        Signature signature;\n    } CertificateVerify;\n"
- title: A.4.4. Handshake finalization message
  contents:
  - "A.4.4. Handshake finalization message\n    struct {\n        opaque verify_data[12];\n\
    \    } Finished;\n"
- title: A.5. The CipherSuite
  contents:
  - "A.5. The CipherSuite\n   The following values define the CipherSuite codes used\
    \ in the client\n   hello and server hello messages.\n   A CipherSuite defines\
    \ a cipher specification supported in TLS Version\n   1.0.\n   TLS_NULL_WITH_NULL_NULL\
    \ is specified and is the initial state of a\n   TLS connection during the first\
    \ handshake on that channel, but must\n   not be negotiated, as it provides no\
    \ more protection than an\n   unsecured connection.\n    CipherSuite TLS_NULL_WITH_NULL_NULL\
    \                = { 0x00,0x00 };\n   The following CipherSuite definitions require\
    \ that the server provide\n   an RSA certificate that can be used for key exchange.\
    \ The server may\n   request either an RSA or a DSS signature-capable certificate\
    \ in the\n   certificate request message.\n    CipherSuite TLS_RSA_WITH_NULL_MD5\
    \                  = { 0x00,0x01 };\n    CipherSuite TLS_RSA_WITH_NULL_SHA   \
    \               = { 0x00,0x02 };\n    CipherSuite TLS_RSA_EXPORT_WITH_RC4_40_MD5\
    \         = { 0x00,0x03 };\n    CipherSuite TLS_RSA_WITH_RC4_128_MD5         \
    \      = { 0x00,0x04 };\n    CipherSuite TLS_RSA_WITH_RC4_128_SHA            \
    \   = { 0x00,0x05 };\n    CipherSuite TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5     =\
    \ { 0x00,0x06 };\n    CipherSuite TLS_RSA_WITH_IDEA_CBC_SHA              = { 0x00,0x07\
    \ };\n    CipherSuite TLS_RSA_EXPORT_WITH_DES40_CBC_SHA      = { 0x00,0x08 };\n\
    \    CipherSuite TLS_RSA_WITH_DES_CBC_SHA               = { 0x00,0x09 };\n   \
    \ CipherSuite TLS_RSA_WITH_3DES_EDE_CBC_SHA          = { 0x00,0x0A };\n   The\
    \ following CipherSuite definitions are used for server-\n   authenticated (and\
    \ optionally client-authenticated) Diffie-Hellman.\n   DH denotes cipher suites\
    \ in which the server's certificate contains\n   the Diffie-Hellman parameters\
    \ signed by the certificate authority\n   (CA). DHE denotes ephemeral Diffie-Hellman,\
    \ where the Diffie-Hellman\n   parameters are signed by a DSS or RSA certificate,\
    \ which has been\n   signed by the CA. The signing algorithm used is specified\
    \ after the\n   DH or DHE parameter. The server can request an RSA or DSS signature-\n\
    \   capable certificate from the client for client authentication or it\n   may\
    \ request a Diffie-Hellman certificate. Any Diffie-Hellman\n   certificate provided\
    \ by the client must use the parameters (group and\n   generator) described by\
    \ the server.\n    CipherSuite TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA   = { 0x00,0x0B\
    \ };\n    CipherSuite TLS_DH_DSS_WITH_DES_CBC_SHA            = { 0x00,0x0C };\n\
    \    CipherSuite TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA       = { 0x00,0x0D };\n   \
    \ CipherSuite TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA   = { 0x00,0x0E };\n    CipherSuite\
    \ TLS_DH_RSA_WITH_DES_CBC_SHA            = { 0x00,0x0F };\n    CipherSuite TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA\
    \       = { 0x00,0x10 };\n    CipherSuite TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA\
    \  = { 0x00,0x11 };\n    CipherSuite TLS_DHE_DSS_WITH_DES_CBC_SHA           =\
    \ { 0x00,0x12 };\n    CipherSuite TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x13\
    \ };\n    CipherSuite TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x14 };\n\
    \    CipherSuite TLS_DHE_RSA_WITH_DES_CBC_SHA           = { 0x00,0x15 };\n   \
    \ CipherSuite TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA      = { 0x00,0x16 };\n   The\
    \ following cipher suites are used for completely anonymous\n   Diffie-Hellman\
    \ communications in which neither party is\n   authenticated. Note that this mode\
    \ is vulnerable to man-in-the-middle\n   attacks and is therefore deprecated.\n\
    \    CipherSuite TLS_DH_anon_EXPORT_WITH_RC4_40_MD5     = { 0x00,0x17 };\n   \
    \ CipherSuite TLS_DH_anon_WITH_RC4_128_MD5           = { 0x00,0x18 };\n    CipherSuite\
    \ TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA  = { 0x00,0x19 };\n    CipherSuite TLS_DH_anon_WITH_DES_CBC_SHA\
    \           = { 0x00,0x1A };\n    CipherSuite TLS_DH_anon_WITH_3DES_EDE_CBC_SHA\
    \      = { 0x00,0x1B };\n Note: All cipher suites whose first byte is 0xFF are\
    \ considered\n       private and can be used for defining local/experimental\n\
    \       algorithms. Interoperability of such types is a local matter.\n Note:\
    \ Additional cipher suites can be registered by publishing an RFC\n       which\
    \ specifies the cipher suites, including the necessary TLS\n       protocol information,\
    \ including message encoding, premaster\n       secret derivation, symmetric encryption\
    \ and MAC calculation and\n       appropriate reference information for the algorithms\
    \ involved.\n       The RFC editor's office may, at its discretion, choose to\
    \ publish\n       specifications for cipher suites which are not completely\n\
    \       described (e.g., for classified algorithms) if it finds the\n       specification\
    \ to be of technical interest and completely\n       specified.\n Note: The cipher\
    \ suite values { 0x00, 0x1C } and { 0x00, 0x1D } are\n       reserved to avoid\
    \ collision with Fortezza-based cipher suites in\n       SSL 3.\n"
- title: A.6. The Security Parameters
  contents:
  - "A.6. The Security Parameters\n   These security parameters are determined by\
    \ the TLS Handshake\n   Protocol and provided as parameters to the TLS Record\
    \ Layer in order\n   to initialize a connection state. SecurityParameters includes:\n\
    \       enum { null(0), (255) } CompressionMethod;\n       enum { server, client\
    \ } ConnectionEnd;\n       enum { null, rc4, rc2, des, 3des, des40, idea }\n \
    \      BulkCipherAlgorithm;\n       enum { stream, block } CipherType;\n     \
    \  enum { true, false } IsExportable;\n       enum { null, md5, sha } MACAlgorithm;\n\
    \   /* The algorithms specified in CompressionMethod,\n   BulkCipherAlgorithm,\
    \ and MACAlgorithm may be added to. */\n       struct {\n           ConnectionEnd\
    \ entity;\n           BulkCipherAlgorithm bulk_cipher_algorithm;\n           CipherType\
    \ cipher_type;\n           uint8 key_size;\n           uint8 key_material_length;\n\
    \           IsExportable is_exportable;\n           MACAlgorithm mac_algorithm;\n\
    \           uint8 hash_size;\n           CompressionMethod compression_algorithm;\n\
    \           opaque master_secret[48];\n           opaque client_random[32];\n\
    \           opaque server_random[32];\n       } SecurityParameters;\n"
- title: B. Glossary
  contents:
  - "B. Glossary\n   application protocol\n       An application protocol is a protocol\
    \ that normally layers\n       directly on top of the transport layer (e.g., TCP/IP).\
    \ Examples\n       include HTTP, TELNET, FTP, and SMTP.\n   asymmetric cipher\n\
    \       See public key cryptography.\n   authentication\n       Authentication\
    \ is the ability of one entity to determine the\n       identity of another entity.\n\
    \   block cipher\n       A block cipher is an algorithm that operates on plaintext\
    \ in\n       groups of bits, called blocks. 64 bits is a common block size.\n\
    \   bulk cipher\n       A symmetric encryption algorithm used to encrypt large\
    \ quantities\n       of data.\n   cipher block chaining (CBC)\n       CBC is a\
    \ mode in which every plaintext block encrypted with a\n       block cipher is\
    \ first exclusive-ORed with the previous ciphertext\n       block (or, in the\
    \ case of the first block, with the\n       initialization vector). For decryption,\
    \ every block is first\n       decrypted, then exclusive-ORed with the previous\
    \ ciphertext block\n       (or IV).\n   certificate\n       As part of the X.509\
    \ protocol (a.k.a. ISO Authentication\n       framework), certificates are assigned\
    \ by a trusted Certificate\n       Authority and provide a strong binding between\
    \ a party's identity\n       or some other attributes and its public key.\n  \
    \ client\n       The application entity that initiates a TLS connection to a\n\
    \       server. This may or may not imply that the client initiated the\n    \
    \   underlying transport connection. The primary operational\n       difference\
    \ between the server and client is that the server is\n       generally authenticated,\
    \ while the client is only optionally\n       authenticated.\n   client write\
    \ key\n       The key used to encrypt data written by the client.\n   client write\
    \ MAC secret\n       The secret data used to authenticate data written by the\
    \ client.\n   connection\n       A connection is a transport (in the OSI layering\
    \ model\n       definition) that provides a suitable type of service. For TLS,\n\
    \       such connections are peer to peer relationships. The connections\n   \
    \    are transient. Every connection is associated with one session.\n   Data\
    \ Encryption Standard\n       DES is a very widely used symmetric encryption algorithm.\
    \ DES is\n       a block cipher with a 56 bit key and an 8 byte block size. Note\n\
    \       that in TLS, for key generation purposes, DES is treated as\n       having\
    \ an 8 byte key length (64 bits), but it still only provides\n       56 bits of\
    \ protection. (The low bit of each key byte is presumed\n       to be set to produce\
    \ odd parity in that key byte.) DES can also\n       be operated in a mode where\
    \ three independent keys and three\n       encryptions are used for each block\
    \ of data; this uses 168 bits\n       of key (24 bytes in the TLS key generation\
    \ method) and provides\n       the equivalent of 112 bits of security. [DES],\
    \ [3DES]\n   Digital Signature Standard (DSS)\n       A standard for digital signing,\
    \ including the Digital Signing\n       Algorithm, approved by the National Institute\
    \ of Standards and\n       Technology, defined in NIST FIPS PUB 186, \"Digital\
    \ Signature\n       Standard,\" published May, 1994 by the U.S. Dept. of Commerce.\n\
    \       [DSS]\n   digital signatures\n       Digital signatures utilize public\
    \ key cryptography and one-way\n       hash functions to produce a signature of\
    \ the data that can be\n       authenticated, and is difficult to forge or repudiate.\n\
    \   handshake\n       An initial negotiation between client and server that establishes\n\
    \       the parameters of their transactions.\n   Initialization Vector (IV)\n\
    \       When a block cipher is used in CBC mode, the initialization\n       vector\
    \ is exclusive-ORed with the first plaintext block prior to\n       encryption.\n\
    \   IDEA\n       A 64-bit block cipher designed by Xuejia Lai and James Massey.\n\
    \       [IDEA]\n   Message Authentication Code (MAC)\n       A Message Authentication\
    \ Code is a one-way hash computed from a\n       message and some secret data.\
    \ It is difficult to forge without\n       knowing the secret data. Its purpose\
    \ is to detect if the message\n       has been altered.\n   master secret\n  \
    \     Secure secret data used for generating encryption keys, MAC\n       secrets,\
    \ and IVs.\n   MD5\n       MD5 is a secure hashing function that converts an arbitrarily\n\
    \       long data stream into a digest of fixed size (16 bytes). [MD5]\n   public\
    \ key cryptography\n       A class of cryptographic techniques employing two-key\
    \ ciphers.\n       Messages encrypted with the public key can only be decrypted\
    \ with\n       the associated private key. Conversely, messages signed with the\n\
    \       private key can be verified with the public key.\n   one-way hash function\n\
    \       A one-way transformation that converts an arbitrary amount of\n      \
    \ data into a fixed-length hash. It is computationally hard to\n       reverse\
    \ the transformation or to find collisions. MD5 and SHA are\n       examples of\
    \ one-way hash functions.\n   RC2\n       A block cipher developed by Ron Rivest\
    \ at RSA Data Security, Inc.\n       [RSADSI] described in [RC2].\n   RC4\n  \
    \     A stream cipher licensed by RSA Data Security [RSADSI]. A\n       compatible\
    \ cipher is described in [RC4].\n   RSA\n       A very widely used public-key\
    \ algorithm that can be used for\n       either encryption or digital signing.\
    \ [RSA]\n   salt\n       Non-secret random data used to make export encryption\
    \ keys resist\n       precomputation attacks.\n   server\n       The server is\
    \ the application entity that responds to requests\n       for connections from\
    \ clients. See also under client.\n   session\n       A TLS session is an association\
    \ between a client and a server.\n       Sessions are created by the handshake\
    \ protocol. Sessions define a\n       set of cryptographic security parameters,\
    \ which can be shared\n       among multiple connections. Sessions are used to\
    \ avoid the\n       expensive negotiation of new security parameters for each\n\
    \       connection.\n   session identifier\n       A session identifier is a value\
    \ generated by a server that\n       identifies a particular session.\n   server\
    \ write key\n       The key used to encrypt data written by the server.\n   server\
    \ write MAC secret\n       The secret data used to authenticate data written by\
    \ the server.\n   SHA\n       The Secure Hash Algorithm is defined in FIPS PUB\
    \ 180-1. It\n       produces a 20-byte output. Note that all references to SHA\n\
    \       actually use the modified SHA-1 algorithm. [SHA]\n   SSL\n       Netscape's\
    \ Secure Socket Layer protocol [SSL3]. TLS is based on\n       SSL Version 3.0\n\
    \   stream cipher\n       An encryption algorithm that converts a key into a\n\
    \       cryptographically-strong keystream, which is then exclusive-ORed\n   \
    \    with the plaintext.\n   symmetric cipher\n       See bulk cipher.\n   Transport\
    \ Layer Security (TLS)\n       This protocol; also, the Transport Layer Security\
    \ working group\n       of the Internet Engineering Task Force (IETF). See \"\
    Comments\" at\n       the end of this document.\n"
- title: C. CipherSuite definitions
  contents:
  - 'C. CipherSuite definitions

    '
- title: CipherSuite                      Is       Key          Cipher      Hash
  contents:
  - "CipherSuite                      Is       Key          Cipher      Hash\n   \
    \                          Exportable Exchange\n"
- title: TLS_NULL_WITH_NULL_NULL               * NULL           NULL        NULL
  contents:
  - 'TLS_NULL_WITH_NULL_NULL               * NULL           NULL        NULL

    '
- title: TLS_RSA_WITH_NULL_MD5                 * RSA            NULL         MD5
  contents:
  - 'TLS_RSA_WITH_NULL_MD5                 * RSA            NULL         MD5

    '
- title: TLS_RSA_WITH_NULL_SHA                 * RSA            NULL         SHA
  contents:
  - 'TLS_RSA_WITH_NULL_SHA                 * RSA            NULL         SHA

    '
- title: TLS_RSA_EXPORT_WITH_RC4_40_MD5        * RSA_EXPORT     RC4_40       MD5
  contents:
  - 'TLS_RSA_EXPORT_WITH_RC4_40_MD5        * RSA_EXPORT     RC4_40       MD5

    '
- title: TLS_RSA_WITH_RC4_128_MD5                RSA            RC4_128      MD5
  contents:
  - 'TLS_RSA_WITH_RC4_128_MD5                RSA            RC4_128      MD5

    '
- title: TLS_RSA_WITH_RC4_128_SHA                RSA            RC4_128      SHA
  contents:
  - 'TLS_RSA_WITH_RC4_128_SHA                RSA            RC4_128      SHA

    '
- title: TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5    * RSA_EXPORT     RC2_CBC_40   MD5
  contents:
  - 'TLS_RSA_EXPORT_WITH_RC2_CBC_40_MD5    * RSA_EXPORT     RC2_CBC_40   MD5

    '
- title: TLS_RSA_WITH_IDEA_CBC_SHA               RSA            IDEA_CBC     SHA
  contents:
  - 'TLS_RSA_WITH_IDEA_CBC_SHA               RSA            IDEA_CBC     SHA

    '
- title: TLS_RSA_EXPORT_WITH_DES40_CBC_SHA     * RSA_EXPORT     DES40_CBC    SHA
  contents:
  - 'TLS_RSA_EXPORT_WITH_DES40_CBC_SHA     * RSA_EXPORT     DES40_CBC    SHA

    '
- title: TLS_RSA_WITH_DES_CBC_SHA                RSA            DES_CBC      SHA
  contents:
  - 'TLS_RSA_WITH_DES_CBC_SHA                RSA            DES_CBC      SHA

    '
- title: TLS_RSA_WITH_3DES_EDE_CBC_SHA           RSA            3DES_EDE_CBC SHA
  contents:
  - 'TLS_RSA_WITH_3DES_EDE_CBC_SHA           RSA            3DES_EDE_CBC SHA

    '
- title: TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA  * DH_DSS_EXPORT  DES40_CBC    SHA
  contents:
  - 'TLS_DH_DSS_EXPORT_WITH_DES40_CBC_SHA  * DH_DSS_EXPORT  DES40_CBC    SHA

    '
- title: TLS_DH_DSS_WITH_DES_CBC_SHA             DH_DSS         DES_CBC      SHA
  contents:
  - 'TLS_DH_DSS_WITH_DES_CBC_SHA             DH_DSS         DES_CBC      SHA

    '
- title: TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA        DH_DSS         3DES_EDE_CBC SHA
  contents:
  - 'TLS_DH_DSS_WITH_3DES_EDE_CBC_SHA        DH_DSS         3DES_EDE_CBC SHA

    '
- title: TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA  * DH_RSA_EXPORT  DES40_CBC    SHA
  contents:
  - 'TLS_DH_RSA_EXPORT_WITH_DES40_CBC_SHA  * DH_RSA_EXPORT  DES40_CBC    SHA

    '
- title: TLS_DH_RSA_WITH_DES_CBC_SHA             DH_RSA         DES_CBC      SHA
  contents:
  - 'TLS_DH_RSA_WITH_DES_CBC_SHA             DH_RSA         DES_CBC      SHA

    '
- title: TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA        DH_RSA         3DES_EDE_CBC SHA
  contents:
  - 'TLS_DH_RSA_WITH_3DES_EDE_CBC_SHA        DH_RSA         3DES_EDE_CBC SHA

    '
- title: TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA * DHE_DSS_EXPORT DES40_CBC    SHA
  contents:
  - 'TLS_DHE_DSS_EXPORT_WITH_DES40_CBC_SHA * DHE_DSS_EXPORT DES40_CBC    SHA

    '
- title: TLS_DHE_DSS_WITH_DES_CBC_SHA            DHE_DSS        DES_CBC      SHA
  contents:
  - 'TLS_DHE_DSS_WITH_DES_CBC_SHA            DHE_DSS        DES_CBC      SHA

    '
- title: TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA       DHE_DSS        3DES_EDE_CBC SHA
  contents:
  - 'TLS_DHE_DSS_WITH_3DES_EDE_CBC_SHA       DHE_DSS        3DES_EDE_CBC SHA

    '
- title: TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA * DHE_RSA_EXPORT DES40_CBC    SHA
  contents:
  - 'TLS_DHE_RSA_EXPORT_WITH_DES40_CBC_SHA * DHE_RSA_EXPORT DES40_CBC    SHA

    '
- title: TLS_DHE_RSA_WITH_DES_CBC_SHA            DHE_RSA        DES_CBC      SHA
  contents:
  - 'TLS_DHE_RSA_WITH_DES_CBC_SHA            DHE_RSA        DES_CBC      SHA

    '
- title: TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA       DHE_RSA        3DES_EDE_CBC SHA
  contents:
  - 'TLS_DHE_RSA_WITH_3DES_EDE_CBC_SHA       DHE_RSA        3DES_EDE_CBC SHA

    '
- title: TLS_DH_anon_EXPORT_WITH_RC4_40_MD5    * DH_anon_EXPORT RC4_40       MD5
  contents:
  - 'TLS_DH_anon_EXPORT_WITH_RC4_40_MD5    * DH_anon_EXPORT RC4_40       MD5

    '
- title: TLS_DH_anon_WITH_RC4_128_MD5            DH_anon        RC4_128      MD5
  contents:
  - 'TLS_DH_anon_WITH_RC4_128_MD5            DH_anon        RC4_128      MD5

    '
- title: TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA   DH_anon        DES40_CBC    SHA
  contents:
  - 'TLS_DH_anon_EXPORT_WITH_DES40_CBC_SHA   DH_anon        DES40_CBC    SHA

    '
- title: TLS_DH_anon_WITH_DES_CBC_SHA            DH_anon        DES_CBC      SHA
  contents:
  - 'TLS_DH_anon_WITH_DES_CBC_SHA            DH_anon        DES_CBC      SHA

    '
- title: TLS_DH_anon_WITH_3DES_EDE_CBC_SHA       DH_anon        3DES_EDE_CBC SHA
  contents:
  - "TLS_DH_anon_WITH_3DES_EDE_CBC_SHA       DH_anon        3DES_EDE_CBC SHA\n   *\
    \ Indicates IsExportable is True\n      Key\n      Exchange\n      Algorithm \
    \      Description                        Key size limit\n      DHE_DSS      \
    \   Ephemeral DH with DSS signatures   None\n      DHE_DSS_EXPORT  Ephemeral DH\
    \ with DSS signatures   DH = 512 bits\n      DHE_RSA         Ephemeral DH with\
    \ RSA signatures   None\n      DHE_RSA_EXPORT  Ephemeral DH with RSA signatures\
    \   DH = 512 bits,\n                                                         RSA\
    \ = none\n      DH_anon         Anonymous DH, no signatures        None\n    \
    \  DH_anon_EXPORT  Anonymous DH, no signatures        DH = 512 bits\n      DH_DSS\
    \          DH with DSS-based certificates     None\n      DH_DSS_EXPORT   DH with\
    \ DSS-based certificates     DH = 512 bits\n      DH_RSA          DH with RSA-based\
    \ certificates     None\n      DH_RSA_EXPORT   DH with RSA-based certificates\
    \     DH = 512 bits,\n                                                       \
    \  RSA = none\n      NULL            No key exchange                    N/A\n\
    \      RSA             RSA key exchange                   None\n      RSA_EXPORT\
    \      RSA key exchange                   RSA = 512 bits\n   Key size limit\n\
    \       The key size limit gives the size of the largest public key that\n   \
    \    can be legally used for encryption in cipher suites that are\n       exportable.\n\
    \                         Key      Expanded   Effective   IV    Block\n    Cipher\
    \       Type  Material Key Material  Key Bits  Size   Size\n    NULL       * Stream\
    \   0          0           0        0     N/A\n    IDEA_CBC     Block   16   \
    \      16         128        8      8\n    RC2_CBC_40 * Block    5         16\
    \          40        8      8\n    RC4_40     * Stream   5         16        \
    \  40        0     N/A\n    RC4_128      Stream  16         16         128   \
    \     0     N/A\n    DES40_CBC  * Block    5          8          40        8 \
    \     8\n    DES_CBC      Block    8          8          56        8      8\n\
    \    3DES_EDE_CBC Block   24         24         168        8      8\n   * Indicates\
    \ IsExportable is true.\n   Type\n       Indicates whether this is a stream cipher\
    \ or a block cipher\n       running in CBC mode.\n   Key Material\n       The\
    \ number of bytes from the key_block that are used for\n       generating the\
    \ write keys.\n   Expanded Key Material\n       The number of bytes actually fed\
    \ into the encryption algorithm\n   Effective Key Bits\n       How much entropy\
    \ material is in the key material being fed into\n       the encryption routines.\n\
    \   IV Size\n       How much data needs to be generated for the initialization\n\
    \       vector. Zero for stream ciphers; equal to the block size for\n       block\
    \ ciphers.\n   Block Size\n       The amount of data a block cipher enciphers\
    \ in one chunk; a\n       block cipher running in CBC mode can only encrypt an\
    \ even\n       multiple of its block size.\n      Hash      Hash      Padding\n\
    \    function    Size       Size\n      NULL       0          0\n      MD5   \
    \     16         48\n      SHA        20         40\n"
- title: D. Implementation Notes
  contents:
  - "D. Implementation Notes\n   The TLS protocol cannot prevent many common security\
    \ mistakes. This\n   section provides several recommendations to assist implementors.\n"
- title: D.1. Temporary RSA keys
  contents:
  - "D.1. Temporary RSA keys\n   US Export restrictions limit RSA keys used for encryption\
    \ to 512\n   bits, but do not place any limit on lengths of RSA keys used for\n\
    \   signing operations. Certificates often need to be larger than 512\n   bits,\
    \ since 512-bit RSA keys are not secure enough for high-value\n   transactions\
    \ or for applications requiring long-term security. Some\n   certificates are\
    \ also designated signing-only, in which case they\n   cannot be used for key\
    \ exchange.\n   When the public key in the certificate cannot be used for encryption,\n\
    \   the server signs a temporary RSA key, which is then exchanged. In\n   exportable\
    \ applications, the temporary RSA key should be the maximum\n   allowable length\
    \ (i.e., 512 bits). Because 512-bit RSA keys are\n   relatively insecure, they\
    \ should be changed often. For typical\n   electronic commerce applications, it\
    \ is suggested that keys be\n   changed daily or every 500 transactions, and more\
    \ often if possible.\n   Note that while it is acceptable to use the same temporary\
    \ key for\n   multiple transactions, it must be signed each time it is used.\n\
    \   RSA key generation is a time-consuming process. In many cases, a\n   low-priority\
    \ process can be assigned the task of key generation.\n   Whenever a new key is\
    \ completed, the existing temporary key can be\n   replaced with the new one.\n"
- title: D.2. Random Number Generation and Seeding
  contents:
  - "D.2. Random Number Generation and Seeding\n   TLS requires a cryptographically-secure\
    \ pseudorandom number generator\n   (PRNG). Care must be taken in designing and\
    \ seeding PRNGs.  PRNGs\n   based on secure hash operations, most notably MD5\
    \ and/or SHA, are\n   acceptable, but cannot provide more security than the size\
    \ of the\n   random number generator state. (For example, MD5-based PRNGs usually\n\
    \   provide 128 bits of state.)\n   To estimate the amount of seed material being\
    \ produced, add the\n   number of bits of unpredictable information in each seed\
    \ byte. For\n   example, keystroke timing values taken from a PC compatible's\
    \ 18.2 Hz\n   timer provide 1 or 2 secure bits each, even though the total size\
    \ of\n   the counter value is 16 bits or more. To seed a 128-bit PRNG, one\n \
    \  would thus require approximately 100 such timer values.\n Warning: The seeding\
    \ functions in RSAREF and versions of BSAFE prior to\n          3.0 are order-independent.\
    \ For example, if 1000 seed bits are\n          supplied, one at a time, in 1000\
    \ separate calls to the seed\n          function, the PRNG will end up in a state\
    \ which depends only\n          on the number of 0 or 1 seed bits in the seed\
    \ data (i.e.,\n          there are 1001 possible final states). Applications using\n\
    \          BSAFE or RSAREF must take extra care to ensure proper seeding.\n  \
    \        This may be accomplished by accumulating seed bits into a\n         \
    \ buffer and processing them all at once or by processing an\n          incrementing\
    \ counter with every seed bit; either method will\n          reintroduce order\
    \ dependence into the seeding process.\n"
- title: D.3. Certificates and authentication
  contents:
  - "D.3. Certificates and authentication\n   Implementations are responsible for\
    \ verifying the integrity of\n   certificates and should generally support certificate\
    \ revocation\n   messages. Certificates should always be verified to ensure proper\n\
    \   signing by a trusted Certificate Authority (CA). The selection and\n   addition\
    \ of trusted CAs should be done very carefully. Users should\n   be able to view\
    \ information about the certificate and root CA.\n"
- title: D.4. CipherSuites
  contents:
  - "D.4. CipherSuites\n   TLS supports a range of key sizes and security levels,\
    \ including some\n   which provide no or minimal security. A proper implementation\
    \ will\n   probably not support many cipher suites. For example, 40-bit\n   encryption\
    \ is easily broken, so implementations requiring strong\n   security should not\
    \ allow 40-bit keys. Similarly, anonymous Diffie-\n   Hellman is strongly discouraged\
    \ because it cannot prevent man-in-\n   the-middle attacks. Applications should\
    \ also enforce minimum and\n   maximum key sizes. For example, certificate chains\
    \ containing 512-bit\n   RSA keys or signatures are not appropriate for high-security\n\
    \   applications.\n"
- title: E. Backward Compatibility With SSL
  contents:
  - "E. Backward Compatibility With SSL\n   For historical reasons and in order to\
    \ avoid a profligate consumption\n   of reserved port numbers, application protocols\
    \ which are secured by\n   TLS 1.0, SSL 3.0, and SSL 2.0 all frequently share\
    \ the same\n   connection port: for example, the https protocol (HTTP secured\
    \ by SSL\n   or TLS) uses port 443 regardless of which security protocol it is\n\
    \   using. Thus, some mechanism must be determined to distinguish and\n   negotiate\
    \ among the various protocols.\n   TLS version 1.0 and SSL 3.0 are very similar;\
    \ thus, supporting both\n   is easy. TLS clients who wish to negotiate with SSL\
    \ 3.0 servers\n   should send client hello messages using the SSL 3.0 record format\
    \ and\n   client hello structure, sending {3, 1} for the version field to note\n\
    \   that they support TLS 1.0. If the server supports only SSL 3.0, it\n   will\
    \ respond with an SSL 3.0 server hello; if it supports TLS, with a\n   TLS server\
    \ hello. The negotiation then proceeds as appropriate for\n   the negotiated protocol.\n\
    \   Similarly, a TLS server which wishes to interoperate with SSL 3.0\n   clients\
    \ should accept SSL 3.0 client hello messages and respond with\n   an SSL 3.0\
    \ server hello if an SSL 3.0 client hello is received which\n   has a version\
    \ field of {3, 0}, denoting that this client does not\n   support TLS.\n   Whenever\
    \ a client already knows the highest protocol known to a\n   server (for example,\
    \ when resuming a session), it should initiate the\n   connection in that native\
    \ protocol.\n   TLS 1.0 clients that support SSL Version 2.0 servers must send\
    \ SSL\n   Version 2.0 client hello messages [SSL2]. TLS servers should accept\n\
    \   either client hello format if they wish to support SSL 2.0 clients on\n  \
    \ the same connection port. The only deviations from the Version 2.0\n   specification\
    \ are the ability to specify a version with a value of\n   three and the support\
    \ for more ciphering types in the CipherSpec.\n Warning: The ability to send Version\
    \ 2.0 client hello messages will be\n          phased out with all due haste.\
    \ Implementors should make every\n          effort to move forward as quickly\
    \ as possible. Version 3.0\n          provides better mechanisms for moving to\
    \ newer versions.\n   The following cipher specifications are carryovers from\
    \ SSL Version\n   2.0. These are assumed to use RSA for key exchange and\n   authentication.\n\
    \       V2CipherSpec TLS_RC4_128_WITH_MD5          = { 0x01,0x00,0x80 };\n   \
    \    V2CipherSpec TLS_RC4_128_EXPORT40_WITH_MD5 = { 0x02,0x00,0x80 };\n      \
    \ V2CipherSpec TLS_RC2_CBC_128_CBC_WITH_MD5  = { 0x03,0x00,0x80 };\n       V2CipherSpec\
    \ TLS_RC2_CBC_128_CBC_EXPORT40_WITH_MD5\n                                    \
    \              = { 0x04,0x00,0x80 };\n       V2CipherSpec TLS_IDEA_128_CBC_WITH_MD5\
    \     = { 0x05,0x00,0x80 };\n       V2CipherSpec TLS_DES_64_CBC_WITH_MD5     \
    \  = { 0x06,0x00,0x40 };\n       V2CipherSpec TLS_DES_192_EDE3_CBC_WITH_MD5 =\
    \ { 0x07,0x00,0xC0 };\n   Cipher specifications native to TLS can be included\
    \ in Version 2.0\n   client hello messages using the syntax below. Any V2CipherSpec\n\
    \   element with its first byte equal to zero will be ignored by Version\n   2.0\
    \ servers. Clients sending any of the above V2CipherSpecs should\n   also include\
    \ the TLS equivalent (see Appendix A.5):\n       V2CipherSpec (see TLS name) =\
    \ { 0x00, CipherSuite };\n"
- title: E.1. Version 2 client hello
  contents:
  - "E.1. Version 2 client hello\n   The Version 2.0 client hello message is presented\
    \ below using this\n   document's presentation model. The true definition is still\
    \ assumed\n   to be the SSL Version 2.0 specification.\n       uint8 V2CipherSpec[3];\n\
    \       struct {\n           uint8 msg_type;\n           Version version;\n  \
    \         uint16 cipher_spec_length;\n           uint16 session_id_length;\n \
    \          uint16 challenge_length;\n           V2CipherSpec cipher_specs[V2ClientHello.cipher_spec_length];\n\
    \           opaque session_id[V2ClientHello.session_id_length];\n           Random\
    \ challenge;\n       } V2ClientHello;\n   msg_type\n       This field, in conjunction\
    \ with the version field, identifies a\n       version 2 client hello message.\
    \ The value should be one (1).\n   version\n       The highest version of the\
    \ protocol supported by the client\n       (equals ProtocolVersion.version, see\
    \ Appendix A.1).\n   cipher_spec_length\n       This field is the total length\
    \ of the field cipher_specs. It\n       cannot be zero and must be a multiple\
    \ of the V2CipherSpec length\n       (3).\n   session_id_length\n       This field\
    \ must have a value of either zero or 16. If zero, the\n       client is creating\
    \ a new session. If 16, the session_id field\n       will contain the 16 bytes\
    \ of session identification.\n   challenge_length\n       The length in bytes\
    \ of the client's challenge to the server to\n       authenticate itself. This\
    \ value must be 32.\n   cipher_specs\n       This is a list of all CipherSpecs\
    \ the client is willing and able\n       to use. There must be at least one CipherSpec\
    \ acceptable to the\n       server.\n   session_id\n       If this field's length\
    \ is not zero, it will contain the\n       identification for a session that the\
    \ client wishes to resume.\n   challenge\n       The client challenge to the server\
    \ for the server to identify\n       itself is a (nearly) arbitrary length random.\
    \ The TLS server will\n       right justify the challenge data to become the ClientHello.random\n\
    \       data (padded with leading zeroes, if necessary), as specified in\n   \
    \    this protocol specification. If the length of the challenge is\n       greater\
    \ than 32 bytes, only the last 32 bytes are used. It is\n       legitimate (but\
    \ not necessary) for a V3 server to reject a V2\n       ClientHello that has fewer\
    \ than 16 bytes of challenge data.\n Note: Requests to resume a TLS session should\
    \ use a TLS client hello.\n"
- title: E.2. Avoiding man-in-the-middle version rollback
  contents:
  - "E.2. Avoiding man-in-the-middle version rollback\n   When TLS clients fall back\
    \ to Version 2.0 compatibility mode, they\n   should use special PKCS #1 block\
    \ formatting. This is done so that TLS\n   servers will reject Version 2.0 sessions\
    \ with TLS-capable clients.\n   When TLS clients are in Version 2.0 compatibility\
    \ mode, they set the\n   right-hand (least-significant) 8 random bytes of the\
    \ PKCS padding\n   (not including the terminal null of the padding) for the RSA\n\
    \   encryption of the ENCRYPTED-KEY-DATA field of the CLIENT-MASTER-KEY\n   to\
    \ 0x03 (the other padding bytes are random). After decrypting the\n   ENCRYPTED-KEY-DATA\
    \ field, servers that support TLS should issue an\n   error if these eight padding\
    \ bytes are 0x03. Version 2.0 servers\n   receiving blocks padded in this manner\
    \ will proceed normally.\n"
- title: F. Security analysis
  contents:
  - "F. Security analysis\n   The TLS protocol is designed to establish a secure connection\
    \ between\n   a client and a server communicating over an insecure channel. This\n\
    \   document makes several traditional assumptions, including that\n   attackers\
    \ have substantial computational resources and cannot obtain\n   secret information\
    \ from sources outside the protocol. Attackers are\n   assumed to have the ability\
    \ to capture, modify, delete, replay, and\n   otherwise tamper with messages sent\
    \ over the communication channel.\n   This appendix outlines how TLS has been\
    \ designed to resist a variety\n   of attacks.\n"
- title: F.1. Handshake protocol
  contents:
  - "F.1. Handshake protocol\n   The handshake protocol is responsible for selecting\
    \ a CipherSpec and\n   generating a Master Secret, which together comprise the\
    \ primary\n   cryptographic parameters associated with a secure session. The\n\
    \   handshake protocol can also optionally authenticate parties who have\n   certificates\
    \ signed by a trusted certificate authority.\n"
- title: F.1.1. Authentication and key exchange
  contents:
  - "F.1.1. Authentication and key exchange\n   TLS supports three authentication\
    \ modes: authentication of both\n   parties, server authentication with an unauthenticated\
    \ client, and\n   total anonymity. Whenever the server is authenticated, the channel\
    \ is\n   secure against man-in-the-middle attacks, but completely anonymous\n\
    \   sessions are inherently vulnerable to such attacks.  Anonymous\n   servers\
    \ cannot authenticate clients. If the server is authenticated,\n   its certificate\
    \ message must provide a valid certificate chain\n   leading to an acceptable\
    \ certificate authority.  Similarly,\n   authenticated clients must supply an\
    \ acceptable certificate to the\n   server. Each party is responsible for verifying\
    \ that the other's\n   certificate is valid and has not expired or been revoked.\n\
    \   The general goal of the key exchange process is to create a\n   pre_master_secret\
    \ known to the communicating parties and not to\n   attackers. The pre_master_secret\
    \ will be used to generate the\n   master_secret (see Section 8.1). The master_secret\
    \ is required to\n   generate the certificate verify and finished messages, encryption\n\
    \   keys, and MAC secrets (see Sections 7.4.8, 7.4.9 and 6.3). By sending\n  \
    \ a correct finished message, parties thus prove that they know the\n   correct\
    \ pre_master_secret.\n"
- title: F.1.1.1. Anonymous key exchange
  contents:
  - "F.1.1.1. Anonymous key exchange\n   Completely anonymous sessions can be established\
    \ using RSA or\n   Diffie-Hellman for key exchange. With anonymous RSA, the client\n\
    \   encrypts a pre_master_secret with the server's uncertified public key\n  \
    \ extracted from the server key exchange message. The result is sent in\n   a\
    \ client key exchange message. Since eavesdroppers do not know the\n   server's\
    \ private key, it will be infeasible for them to decode the\n   pre_master_secret.\
    \ (Note that no anonymous RSA Cipher Suites are\n   defined in this document).\n\
    \   With Diffie-Hellman, the server's public parameters are contained in\n   the\
    \ server key exchange message and the client's are sent in the\n   client key\
    \ exchange message. Eavesdroppers who do not know the\n   private values should\
    \ not be able to find the Diffie-Hellman result\n   (i.e. the pre_master_secret).\n\
    \ Warning: Completely anonymous connections only provide protection\n        \
    \  against passive eavesdropping. Unless an independent tamper-\n          proof\
    \ channel is used to verify that the finished messages\n          were not replaced\
    \ by an attacker, server authentication is\n          required in environments\
    \ where active man-in-the-middle\n          attacks are a concern.\n"
- title: F.1.1.2. RSA key exchange and authentication
  contents:
  - "F.1.1.2. RSA key exchange and authentication\n   With RSA, key exchange and server\
    \ authentication are combined. The\n   public key may be either contained in the\
    \ server's certificate or may\n   be a temporary RSA key sent in a server key\
    \ exchange message.  When\n   temporary RSA keys are used, they are signed by\
    \ the server's RSA or\n   DSS certificate. The signature includes the current\n\
    \   ClientHello.random, so old signatures and temporary keys cannot be\n   replayed.\
    \ Servers may use a single temporary RSA key for multiple\n   negotiation sessions.\n\
    \ Note: The temporary RSA key option is useful if servers need large\n       certificates\
    \ but must comply with government-imposed size limits\n       on keys used for\
    \ key exchange.\n   After verifying the server's certificate, the client encrypts\
    \ a\n   pre_master_secret with the server's public key. By successfully\n   decoding\
    \ the pre_master_secret and producing a correct finished\n   message, the server\
    \ demonstrates that it knows the private key\n   corresponding to the server certificate.\n\
    \   When RSA is used for key exchange, clients are authenticated using\n   the\
    \ certificate verify message (see Section 7.4.8). The client signs\n   a value\
    \ derived from the master_secret and all preceding handshake\n   messages. These\
    \ handshake messages include the server certificate,\n   which binds the signature\
    \ to the server, and ServerHello.random,\n   which binds the signature to the\
    \ current handshake process.\n"
- title: F.1.1.3. Diffie-Hellman key exchange with authentication
  contents:
  - "F.1.1.3. Diffie-Hellman key exchange with authentication\n   When Diffie-Hellman\
    \ key exchange is used, the server can either\n   supply a certificate containing\
    \ fixed Diffie-Hellman parameters or\n   can use the server key exchange message\
    \ to send a set of temporary\n   Diffie-Hellman parameters signed with a DSS or\
    \ RSA certificate.\n   Temporary parameters are hashed with the hello.random values\
    \ before\n   signing to ensure that attackers do not replay old parameters. In\n\
    \   either case, the client can verify the certificate or signature to\n   ensure\
    \ that the parameters belong to the server.\n   If the client has a certificate\
    \ containing fixed Diffie-Hellman\n   parameters, its certificate contains the\
    \ information required to\n   complete the key exchange. Note that in this case\
    \ the client and\n   server will generate the same Diffie-Hellman result (i.e.,\n\
    \   pre_master_secret) every time they communicate. To prevent the\n   pre_master_secret\
    \ from staying in memory any longer than necessary,\n   it should be converted\
    \ into the master_secret as soon as possible.\n   Client Diffie-Hellman parameters\
    \ must be compatible with those\n   supplied by the server for the key exchange\
    \ to work.\n   If the client has a standard DSS or RSA certificate or is\n   unauthenticated,\
    \ it sends a set of temporary parameters to the server\n   in the client key exchange\
    \ message, then optionally uses a\n   certificate verify message to authenticate\
    \ itself.\n"
- title: F.1.2. Version rollback attacks
  contents:
  - "F.1.2. Version rollback attacks\n   Because TLS includes substantial improvements\
    \ over SSL Version 2.0,\n   attackers may try to make TLS-capable clients and\
    \ servers fall back\n   to Version 2.0. This attack can occur if (and only if)\
    \ two TLS-\n   capable parties use an SSL 2.0 handshake.\n   Although the solution\
    \ using non-random PKCS #1 block type 2 message\n   padding is inelegant, it provides\
    \ a reasonably secure way for Version\n   3.0 servers to detect the attack. This\
    \ solution is not secure against\n   attackers who can brute force the key and\
    \ substitute a new\n   ENCRYPTED-KEY-DATA message containing the same key (but\
    \ with normal\n   padding) before the application specified wait threshold has\
    \ expired.\n   Parties concerned about attacks of this scale should not be using\n\
    \   40-bit encryption keys anyway. Altering the padding of the least-\n   significant\
    \ 8 bytes of the PKCS padding does not impact security for\n   the size of the\
    \ signed hashes and RSA key lengths used in the\n   protocol, since this is essentially\
    \ equivalent to increasing the\n   input block size by 8 bytes.\n"
- title: F.1.3. Detecting attacks against the handshake protocol
  contents:
  - "F.1.3. Detecting attacks against the handshake protocol\n   An attacker might\
    \ try to influence the handshake exchange to make the\n   parties select different\
    \ encryption algorithms than they would\n   normally choose. Because many implementations\
    \ will support 40-bit\n   exportable encryption and some may even support null\
    \ encryption or\n   MAC algorithms, this attack is of particular concern.\n  \
    \ For this attack, an attacker must actively change one or more\n   handshake\
    \ messages. If this occurs, the client and server will\n   compute different values\
    \ for the handshake message hashes. As a\n   result, the parties will not accept\
    \ each others' finished messages.\n   Without the master_secret, the attacker\
    \ cannot repair the finished\n   messages, so the attack will be discovered.\n"
- title: F.1.4. Resuming sessions
  contents:
  - "F.1.4. Resuming sessions\n   When a connection is established by resuming a session,\
    \ new\n   ClientHello.random and ServerHello.random values are hashed with the\n\
    \   session's master_secret. Provided that the master_secret has not been\n  \
    \ compromised and that the secure hash operations used to produce the\n   encryption\
    \ keys and MAC secrets are secure, the connection should be\n   secure and effectively\
    \ independent from previous connections.\n   Attackers cannot use known encryption\
    \ keys or MAC secrets to\n   compromise the master_secret without breaking the\
    \ secure hash\n   operations (which use both SHA and MD5).\n   Sessions cannot\
    \ be resumed unless both the client and server agree.\n   If either party suspects\
    \ that the session may have been compromised,\n   or that certificates may have\
    \ expired or been revoked, it should\n   force a full handshake. An upper limit\
    \ of 24 hours is suggested for\n   session ID lifetimes, since an attacker who\
    \ obtains a master_secret\n   may be able to impersonate the compromised party\
    \ until the\n   corresponding session ID is retired. Applications that may be\
    \ run in\n   relatively insecure environments should not write session IDs to\n\
    \   stable storage.\n"
- title: F.1.5. MD5 and SHA
  contents:
  - "F.1.5. MD5 and SHA\n   TLS uses hash functions very conservatively. Where possible,\
    \ both MD5\n   and SHA are used in tandem to ensure that non-catastrophic flaws\
    \ in\n   one algorithm will not break the overall protocol.\n"
- title: F.2. Protecting application data
  contents:
  - "F.2. Protecting application data\n   The master_secret is hashed with the ClientHello.random\
    \ and\n   ServerHello.random to produce unique data encryption keys and MAC\n\
    \   secrets for each connection.\n   Outgoing data is protected with a MAC before\
    \ transmission. To prevent\n   message replay or modification attacks, the MAC\
    \ is computed from the\n   MAC secret, the sequence number, the message length,\
    \ the message\n   contents, and two fixed character strings. The message type\
    \ field is\n   necessary to ensure that messages intended for one TLS Record Layer\n\
    \   client are not redirected to another. The sequence number ensures\n   that\
    \ attempts to delete or reorder messages will be detected. Since\n   sequence\
    \ numbers are 64-bits long, they should never overflow.\n   Messages from one\
    \ party cannot be inserted into the other's output,\n   since they use independent\
    \ MAC secrets. Similarly, the server-write\n   and client-write keys are independent\
    \ so stream cipher keys are used\n   only once.\n   If an attacker does break\
    \ an encryption key, all messages encrypted\n   with it can be read. Similarly,\
    \ compromise of a MAC key can make\n   message modification attacks possible.\
    \ Because MACs are also\n   encrypted, message-alteration attacks generally require\
    \ breaking the\n   encryption algorithm as well as the MAC.\n Note: MAC secrets\
    \ may be larger than encryption keys, so messages can\n       remain tamper resistant\
    \ even if encryption keys are broken.\n"
- title: F.3. Final notes
  contents:
  - "F.3. Final notes\n   For TLS to be able to provide a secure connection, both\
    \ the client\n   and server systems, keys, and applications must be secure. In\n\
    \   addition, the implementation must be free of security errors.\n   The system\
    \ is only as strong as the weakest key exchange and\n   authentication algorithm\
    \ supported, and only trustworthy\n   cryptographic functions should be used.\
    \ Short public keys, 40-bit\n   bulk encryption keys, and anonymous servers should\
    \ be used with great\n   caution. Implementations and users must be careful when\
    \ deciding\n   which certificates and certificate authorities are acceptable;\
    \ a\n   dishonest certificate authority can do tremendous damage.\n"
- title: G. Patent Statement
  contents:
  - "G. Patent Statement\n   Some of the cryptographic algorithms proposed for use\
    \ in this\n   protocol have patent claims on them. In addition Netscape\n   Communications\
    \ Corporation has a patent claim on the Secure Sockets\n   Layer (SSL) work that\
    \ this standard is based on. The Internet\n   Standards Process as defined in\
    \ RFC 2026 requests that a statement be\n   obtained from a Patent holder indicating\
    \ that a license will be made\n   available to applicants under reasonable terms\
    \ and conditions.\n   The Massachusetts Institute of Technology has granted RSA\
    \ Data\n   Security, Inc., exclusive sub-licensing rights to the following\n \
    \  patent issued in the United States:\n       Cryptographic Communications System\
    \ and Method (\"RSA\"), No.\n       4,405,829\n   Netscape Communications Corporation\
    \ has been issued the following\n   patent in the United States:\n       Secure\
    \ Socket Layer Application Program Apparatus And Method\n       (\"SSL\"), No.\
    \ 5,657,390\n   Netscape Communications has issued the following statement:\n\
    \       Intellectual Property Rights\n       Secure Sockets Layer\n       The\
    \ United States Patent and Trademark Office (\"the PTO\")\n       recently issued\
    \ U.S. Patent No. 5,657,390 (\"the SSL Patent\")  to\n       Netscape for inventions\
    \ described as Secure Sockets Layers\n       (\"SSL\"). The IETF is currently\
    \ considering adopting SSL as a\n       transport protocol with security features.\
    \  Netscape encourages\n       the royalty-free adoption and use of the SSL protocol\
    \ upon the\n       following terms and conditions:\n         * If you already\
    \ have a valid SSL Ref license today which\n           includes source code from\
    \ Netscape, an additional patent\n           license under the SSL patent is not\
    \ required.\n         * If you don't have an SSL Ref license, you may have a royalty\n\
    \           free license to build implementations covered by the SSL\n       \
    \    Patent Claims or the IETF TLS specification provided that you\n         \
    \  do not to assert any patent rights against Netscape or other\n           companies\
    \ for the implementation of SSL or the IETF TLS\n           recommendation.\n\
    \       What are \"Patent Claims\":\n       Patent claims are claims in an issued\
    \ foreign or domestic patent\n       that:\n        1) must be infringed in order\
    \ to implement methods or build\n           products according to the IETF TLS\
    \ specification;  or\n        2) patent claims which require the elements of the\
    \ SSL patent\n           claims and/or their equivalents to be infringed.\n  \
    \ The Internet Society, Internet Architecture Board, Internet\n   Engineering\
    \ Steering Group and the Corporation for National Research\n   Initiatives take\
    \ no position on the validity or scope of the patents\n   and patent applications,\
    \ nor on the appropriateness of the terms of\n   the assurance. The Internet Society\
    \ and other groups mentioned above\n   have not made any determination as to any\
    \ other intellectual property\n   rights which may apply to the practice of this\
    \ standard.  Any further\n   consideration of these matters is the user's own\
    \ responsibility.\n"
- title: Security Considerations
  contents:
  - "Security Considerations\n   Security issues are discussed throughout this memo.\n"
- title: References
  contents:
  - "References\n   [3DES]   W. Tuchman, \"Hellman Presents No Shortcut Solutions\
    \ To DES,\"\n            IEEE Spectrum, v. 16, n. 7, July 1979, pp40-41.\n   [BLEI]\
    \   Bleichenbacher D., \"Chosen Ciphertext Attacks against\n            Protocols\
    \ Based on RSA Encryption Standard PKCS #1\" in\n            Advances in Cryptology\
    \ -- CRYPTO'98, LNCS vol. 1462, pages:\n            1--12, 1998.\n   [DES]   \
    \ ANSI X3.106, \"American National Standard for Information\n            Systems-Data\
    \ Link Encryption,\" American National Standards\n            Institute, 1983.\n\
    \   [DH1]    W. Diffie and M. E. Hellman, \"New Directions in\n            Cryptography,\"\
    \ IEEE Transactions on Information Theory, V.\n            IT-22, n. 6, Jun 1977,\
    \ pp. 74-84.\n   [DSS]    NIST FIPS PUB 186, \"Digital Signature Standard,\" National\n\
    \            Institute of Standards and Technology, U.S. Department of\n     \
    \       Commerce, May 18, 1994.\n   [FTP]    Postel J., and J. Reynolds, \"File\
    \ Transfer Protocol\", STD 9,\n            RFC 959, October 1985.\n   [HTTP] \
    \  Berners-Lee, T., Fielding, R., and H. Frystyk, \"Hypertext\n            Transfer\
    \ Protocol -- HTTP/1.0\", RFC 1945, May 1996.\n   [HMAC]   Krawczyk, H., Bellare,\
    \ M., and R. Canetti, \"HMAC:  Keyed-\n            Hashing for Message Authentication,\"\
    \ RFC 2104, February\n            1997.\n   [IDEA]   X. Lai, \"On the Design and\
    \ Security of Block Ciphers,\" ETH\n            Series in Information Processing,\
    \ v. 1, Konstanz: Hartung-\n            Gorre Verlag, 1992.\n   [MD2]    Kaliski,\
    \ B., \"The MD2 Message Digest Algorithm\", RFC 1319,\n            April 1992.\n\
    \   [MD5]    Rivest, R., \"The MD5 Message Digest Algorithm\", RFC 1321,\n   \
    \         April 1992.\n   [PKCS1]  RSA Laboratories, \"PKCS #1: RSA Encryption\
    \ Standard,\"\n            version 1.5, November 1993.\n   [PKCS6]  RSA Laboratories,\
    \ \"PKCS #6: RSA Extended Certificate Syntax\n            Standard,\" version\
    \ 1.5, November 1993.\n   [PKCS7]  RSA Laboratories, \"PKCS #7: RSA Cryptographic\
    \ Message Syntax\n            Standard,\" version 1.5, November 1993.\n   [PKIX]\
    \   Housley, R., Ford, W., Polk, W. and D. Solo, \"Internet\n            Public\
    \ Key Infrastructure: Part I: X.509 Certificate and CRL\n            Profile\"\
    , RFC 2459, January 1999.\n   [RC2]    Rivest, R., \"A Description of the RC2(r)\
    \ Encryption\n            Algorithm\", RFC 2268, January 1998.\n   [RC4]    Thayer,\
    \ R. and K. Kaukonen, A Stream Cipher Encryption\n            Algorithm, Work\
    \ in Progress.\n   [RSA]    R. Rivest, A. Shamir, and L. M. Adleman, \"A Method\
    \ for\n            Obtaining Digital Signatures and Public-Key Cryptosystems,\"\
    \n            Communications of the ACM, v. 21, n. 2, Feb 1978, pp. 120-\n   \
    \         126.\n   [RSADSI] Contact RSA Data Security, Inc., Tel: 415-595-8782\n\
    \   [SCH]    B. Schneier. Applied Cryptography: Protocols, Algorithms,\n     \
    \       and Source Code in C, Published by John Wiley & Sons, Inc.\n         \
    \   1994.\n   [SHA]    NIST FIPS PUB 180-1, \"Secure Hash Standard,\" National\n\
    \            Institute of Standards and Technology, U.S. Department of\n     \
    \       Commerce, Work in Progress, May 31, 1994.\n   [SSL2]   Hickman, Kipp,\
    \ \"The SSL Protocol\", Netscape Communications\n            Corp., Feb 9, 1995.\n\
    \   [SSL3]   A. Frier, P. Karlton, and P. Kocher, \"The SSL 3.0 Protocol\",\n\
    \            Netscape Communications Corp., Nov 18, 1996.\n   [TCP]    Postel,\
    \ J., \"Transmission Control Protocol,\" STD 7, RFC 793,\n            September\
    \ 1981.\n   [TEL]    Postel J., and J. Reynolds, \"Telnet Protocol\n         \
    \   Specifications\", STD 8, RFC 854, May 1993.\n   [TEL]    Postel J., and J.\
    \ Reynolds, \"Telnet Option Specifications\",\n            STD 8, RFC 855, May\
    \ 1993.\n   [X509]   CCITT. Recommendation X.509: \"The Directory - Authentication\n\
    \            Framework\". 1988.\n   [XDR]    R. Srinivansan, Sun Microsystems,\
    \ RFC-1832: XDR: External\n            Data Representation Standard, August 1995.\n"
- title: Credits
  contents:
  - "Credits\n   Win Treese\n   Open Market\n   EMail: treese@openmarket.com\n   Editors\n\
    \   Christopher Allen                  Tim Dierks\n   Certicom               \
    \            Certicom\n   EMail: callen@certicom.com         EMail: tdierks@certicom.com\n\
    \   Authors' Addresses\n   Tim Dierks                         Philip L. Karlton\n\
    \   Certicom                           Netscape Communications\n   EMail: tdierks@certicom.com\n\
    \   Alan O. Freier                     Paul C. Kocher\n   Netscape Communications\
    \            Independent Consultant\n   EMail: freier@netscape.com         EMail:\
    \ pck@netcom.com\n   Other contributors\n   Martin Abadi                     \
    \  Robert Relyea\n   Digital Equipment Corporation      Netscape Communications\n\
    \   EMail: ma@pa.dec.com               EMail: relyea@netscape.com\n   Ran Canetti\
    \                        Jim Roskind\n   IBM Watson Research Center         Netscape\
    \ Communications\n   EMail: canetti@watson.ibm.com      EMail: jar@netscape.com\n\
    \   Taher Elgamal                      Micheal J. Sabin, Ph. D.\n   Securify \
    \                          Consulting Engineer\n   EMail: elgamal@securify.com\
    \        EMail: msabin@netcom.com\n   Anil R. Gangolli                   Dan Simon\n\
    \   Structured Arts Computing Corp.    Microsoft\n   EMail: gangolli@structuredarts.com\
    \ EMail:  dansimon@microsoft.com\n   Kipp E.B. Hickman                  Tom Weinstein\n\
    \   Netscape Communications            Netscape Communications\n   EMail: kipp@netscape.com\
    \           EMail: tomw@netscape.com\n   Hugo Krawczyk\n   IBM Watson Research\
    \ Center\n   EMail: hugo@watson.ibm.com\n"
- title: Comments
  contents:
  - "Comments\n   The discussion list for the IETF TLS working group is located at\
    \ the\n   e-mail address <ietf-tls@lists.consensus.com>. Information on the\n\
    \   group and information on how to subscribe to the list is at\n   <http://lists.consensus.com/>.\n\
    \   Archives of the list can be found at:\n       <http://www.imc.org/ietf-tls/mail-archive/>\n"
- title: Full Copyright Statement
  contents:
  - "Full Copyright Statement\n   Copyright (C) The Internet Society (1999).  All\
    \ Rights Reserved.\n   This document and translations of it may be copied and\
    \ furnished to\n   others, and derivative works that comment on or otherwise explain\
    \ it\n   or assist in its implementation may be prepared, copied, published\n\
    \   and distributed, in whole or in part, without restriction of any\n   kind,\
    \ provided that the above copyright notice and this paragraph are\n   included\
    \ on all such copies and derivative works.  However, this\n   document itself\
    \ may not be modified in any way, such as by removing\n   the copyright notice\
    \ or references to the Internet Society or other\n   Internet organizations, except\
    \ as needed for the purpose of\n   developing Internet standards in which case\
    \ the procedures for\n   copyrights defined in the Internet Standards process\
    \ must be\n   followed, or as required to translate it into languages other than\n\
    \   English.\n   The limited permissions granted above are perpetual and will\
    \ not be\n   revoked by the Internet Society or its successors or assigns.\n \
    \  This document and the information contained herein is provided on an\n   \"\
    AS IS\" basis and THE INTERNET SOCIETY AND THE INTERNET ENGINEERING\n   TASK FORCE\
    \ DISCLAIMS ALL WARRANTIES, EXPRESS OR IMPLIED, INCLUDING\n   BUT NOT LIMITED\
    \ TO ANY WARRANTY THAT THE USE OF THE INFORMATION\n   HEREIN WILL NOT INFRINGE\
    \ ANY RIGHTS OR ANY IMPLIED WARRANTIES OF\n   MERCHANTABILITY OR FITNESS FOR A\
    \ PARTICULAR PURPOSE.\n"
