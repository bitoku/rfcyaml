- contents:
  - '      RPL: IPv6 Routing Protocol for Low-Power and Lossy Networks

    '
  title: __initial_text__
- contents:
  - "Abstract\n   Low-Power and Lossy Networks (LLNs) are a class of network in which\n
    \  both the routers and their interconnect are constrained.  LLN routers\n   typically
    operate with constraints on processing power, memory, and\n   energy (battery
    power).  Their interconnects are characterized by\n   high loss rates, low data
    rates, and instability.  LLNs are comprised\n   of anything from a few dozen to
    thousands of routers.  Supported\n   traffic flows include point-to-point (between
    devices inside the\n   LLN), point-to-multipoint (from a central control point
    to a subset\n   of devices inside the LLN), and multipoint-to-point (from devices\n
    \  inside the LLN towards a central control point).  This document\n   specifies
    the IPv6 Routing Protocol for Low-Power and Lossy Networks\n   (RPL), which provides
    a mechanism whereby multipoint-to-point traffic\n   from devices inside the LLN
    towards a central control point as well\n   as point-to-multipoint traffic from
    the central control point to the\n   devices inside the LLN are supported.  Support
    for point-to-point\n   traffic is also available.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6550.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2012 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................8\n
    \     1.1. Design Principles ..........................................8\n      1.2.
    Expectations of Link-Layer Type ...........................10\n   2. Terminology
    ....................................................10\n   3. Protocol Overview
    ..............................................13\n      3.1. Topologies ................................................13\n
    \          3.1.1. Constructing Topologies ............................13\n           3.1.2.
    RPL Identifiers ....................................14\n           3.1.3. Instances,
    DODAGs, and DODAG Versions ..............14\n      3.2. Upward Routes and DODAG
    Construction ......................16\n           3.2.1. Objective Function (OF)
    ............................17\n           3.2.2. DODAG Repair .......................................17\n
    \          3.2.3. Security ...........................................17\n           3.2.4.
    Grounded and Floating DODAGs .......................18\n           3.2.5. Local
    DODAGs .......................................18\n           3.2.6. Administrative
    Preference ..........................18\n           3.2.7. Data-Path Validation
    and Loop Detection ............18\n           3.2.8. Distributed Algorithm Operation
    ....................19\n      3.3. Downward Routes and Destination Advertisement
    .............19\n      3.4. Local DODAGs Route Discovery ..............................20\n
    \     3.5. Rank Properties ...........................................20\n           3.5.1.
    Rank Comparison (DAGRank()) ........................21\n           3.5.2. Rank
    Relationships .................................22\n      3.6. Routing Metrics
    and Constraints Used by RPL ...............23\n      3.7. Loop Avoidance ............................................24\n
    \          3.7.1. Greediness and Instability .........................24\n           3.7.2.
    DODAG Loops ........................................26\n           3.7.3. DAO
    Loops ..........................................27\n   4. Traffic Flows Supported
    by RPL .................................27\n      4.1. Multipoint-to-Point Traffic
    ...............................27\n      4.2. Point-to-Multipoint Traffic ...............................27\n
    \     4.3. Point-to-Point Traffic ....................................27\n   5.
    RPL Instance ...................................................28\n      5.1.
    RPL Instance ID ...........................................29\n   6. ICMPv6 RPL
    Control Message .....................................30\n      6.1. RPL Security
    Fields .......................................32\n      6.2. DODAG Information
    Solicitation (DIS) ......................38\n           6.2.1. Format of the DIS
    Base Object ......................38\n           6.2.2. Secure DIS .........................................38\n
    \          6.2.3. DIS Options ........................................38\n      6.3.
    DODAG Information Object (DIO) ............................38\n           6.3.1.
    Format of the DIO Base Object ......................39\n           6.3.2. Secure
    DIO .........................................41\n           6.3.3. DIO Options
    ........................................41\n      6.4. Destination Advertisement
    Object (DAO) ....................41\n           6.4.1. Format of the DAO Base
    Object ......................42\n           6.4.2. Secure DAO .........................................43\n
    \          6.4.3. DAO Options ........................................43\n      6.5.
    Destination Advertisement Object Acknowledgement\n           (DAO-ACK) .................................................43\n
    \          6.5.1. Format of the DAO-ACK Base Object ..................44\n           6.5.2.
    Secure DAO-ACK .....................................45\n           6.5.3. DAO-ACK
    Options ....................................45\n      6.6. Consistency Check (CC)
    ....................................45\n           6.6.1. Format of the CC Base
    Object .......................46\n           6.6.2. CC Options .........................................47\n
    \     6.7. RPL Control Message Options ...............................47\n           6.7.1.
    RPL Control Message Option Generic Format ..........47\n           6.7.2. Pad1
    ...............................................48\n           6.7.3. PadN ...............................................48\n
    \          6.7.4. DAG Metric Container ...............................49\n           6.7.5.
    Route Information ..................................50\n           6.7.6. DODAG
    Configuration ................................52\n           6.7.7. RPL Target
    .........................................54\n           6.7.8. Transit Information
    ................................55\n           6.7.9. Solicited Information ..............................58\n
    \          6.7.10. Prefix Information ................................59\n           6.7.11.
    RPL Target Descriptor .............................63\n   7. Sequence Counters
    ..............................................63\n      7.1. Sequence Counter
    Overview .................................63\n      7.2. Sequence Counter Operation
    ................................64\n   8. Upward Routes ..................................................66\n
    \     8.1. DIO Base Rules ............................................67\n      8.2.
    Upward Route Discovery and Maintenance ....................67\n           8.2.1.
    Neighbors and Parents within a DODAG Version .......67\n           8.2.2. Neighbors
    and Parents across DODAG Versions ........68\n           8.2.3. DIO Message Communication
    ..........................73\n      8.3. DIO Transmission ..........................................74\n
    \          8.3.1. Trickle Parameters .................................75\n      8.4.
    DODAG Selection ...........................................75\n      8.5. Operation
    as a Leaf Node ..................................75\n      8.6. Administrative
    Rank .......................................76\n   9. Downward Routes ................................................77\n
    \     9.1. Destination Advertisement Parents .........................77\n      9.2.
    Downward Route Discovery and Maintenance ..................78\n           9.2.1.
    Maintenance of Path Sequence .......................79\n           9.2.2. Generation
    of DAO Messages .........................79\n      9.3. DAO Base Rules ............................................80\n
    \     9.4. Structure of DAO Messages .................................80\n      9.5.
    DAO Transmission Scheduling ...............................83\n      9.6. Triggering
    DAO Messages ...................................83\n      9.7. Non-Storing Mode
    ..........................................84\n      9.8. Storing Mode ..............................................85\n
    \     9.9. Path Control ..............................................86\n           9.9.1.
    Path Control Example ...............................88\n      9.10. Multicast
    Destination Advertisement Messages .............89\n   10. Security Mechanisms
    ...........................................90\n      10.1. Security Overview ........................................90\n
    \     10.2. Joining a Secure Network .................................91\n      10.3.
    Installing Keys ..........................................92\n      10.4. Consistency
    Checks .......................................93\n      10.5. Counters .................................................93\n
    \     10.6. Transmission of Outgoing Packets .........................94\n      10.7.
    Reception of Incoming Packets ............................95\n           10.7.1.
    Timestamp Key Checks ..............................97\n      10.8. Coverage of
    Integrity and Confidentiality ................97\n      10.9. Cryptographic Mode
    of Operation ..........................98\n           10.9.1. CCM Nonce .........................................98\n
    \          10.9.2. Signatures ........................................99\n   11.
    Packet Forwarding and Loop Avoidance/Detection ................99\n      11.1.
    Suggestions for Packet Forwarding ........................99\n      11.2. Loop
    Avoidance and Detection ............................101\n           11.2.1. Source
    Node Operation ............................102\n           11.2.2. Router Operation
    .................................102\n   12. Multicast Operation ..........................................104\n
    \  13. Maintenance of Routing Adjacency .............................105\n   14.
    Guidelines for Objective Functions ...........................106\n      14.1.
    Objective Function Behavior .............................106\n   15. Suggestions
    for Interoperation with Neighbor Discovery .......108\n   16. Summary of Requirements
    for Interoperable Implementations ....109\n      16.1. Common Requirements .....................................109\n
    \     16.2. Operation as a RPL Leaf Node (Only) .....................110\n      16.3.
    Operation as a RPL Router ...............................110\n           16.3.1.
    Support for Upward Routes (Only) .................110\n           16.3.2. Support
    for Upward Routes and Downward\n                   Routes in Non-Storing ............................110\n
    \          16.3.3. Support for Upward Routes and Downward\n                   Routes
    in Storing Mode ...........................111\n      16.4. Items for Future Specification
    ..........................111\n   17. RPL Constants and Variables ..................................112\n
    \  18. Manageability Considerations .................................113\n      18.1.
    Introduction ............................................114\n      18.2. Configuration
    Management ................................115\n           18.2.1. Initialization
    Mode ..............................115\n           18.2.2. DIO and DAO Base Message
    and Options\n                   Configuration ....................................115\n
    \          18.2.3. Protocol Parameters to Be Configured on\n                   Every
    Router in the LLN ..........................116\n           18.2.4. Protocol Parameters
    to Be Configured on\n                   Every Non-DODAG-Root .............................117\n
    \          18.2.5. Parameters to Be Configured on the DODAG Root ....117\n           18.2.6.
    Configuration of RPL Parameters Related\n                   to DAO-Based Mechanisms
    ..........................118\n           18.2.7. Configuration of RPL Parameters
    Related\n                   to Security Mechanisms ...........................119\n
    \          18.2.8. Default Values ...................................119\n      18.3.
    Monitoring of RPL Operation .............................120\n           18.3.1.
    Monitoring a DODAG Parameters ....................120\n           18.3.2. Monitoring
    a DODAG Inconsistencies and\n                   Loop Detection ...................................121\n
    \     18.4. Monitoring of the RPL Data Structures ...................121\n           18.4.1.
    Candidate Neighbor Data Structure ................121\n           18.4.2. Destination-Oriented
    Directed Acyclic\n                   Graph (DODAG) Table ..............................122\n
    \          18.4.3. Routing Table and DAO Routing Entries ............122\n      18.5.
    Fault Management ........................................123\n      18.6. Policy
    ..................................................124\n      18.7. Fault Isolation
    .........................................125\n      18.8. Impact on Other Protocols
    ...............................125\n      18.9. Performance Management ..................................126\n
    \     18.10. Diagnostics ............................................126\n   19.
    Security Considerations ......................................126\n      19.1.
    Overview ................................................126\n   20. IANA Considerations
    ..........................................128\n      20.1. RPL Control Message
    .....................................128\n      20.2. New Registry for RPL Control
    Codes ......................128\n      20.3. New Registry for the Mode of Operation
    (MOP) ............129\n      20.4. RPL Control Message Option ..............................130\n
    \     20.5. Objective Code Point (OCP) Registry .....................131\n      20.6.
    New Registry for the Security Section Algorithm .........131\n      20.7. New
    Registry for the Security Section Flags .............132\n      20.8. New Registry
    for Per-KIM Security Levels ................132\n      20.9. New Registry for
    DODAG Informational\n            Solicitation (DIS) Flags ................................133\n
    \     20.10. New Registry for the DODAG Information Object\n             (DIO)
    Flags ............................................134\n      20.11. New Registry
    for the Destination Advertisement\n             Object (DAO) Flags .....................................134\n
    \     20.12. New Registry for the Destination Advertisement\n             Object
    (DAO) Flags .....................................135\n      20.13. New Registry
    for the Consistency Check (CC) Flags ......135\n      20.14. New Registry for
    the DODAG Configuration Option Flags ..136\n      20.15. New Registry for the
    RPL Target Option Flags ...........136\n      20.16. New Registry for the Transit
    Information Option Flags ..137\n      20.17. New Registry for the Solicited Information\n
    \            Option Flags ...........................................137\n      20.18.
    ICMPv6: Error in Source Routing Header .................138\n      20.19. Link-Local
    Scope Multicast Address .....................138\n   21. Acknowledgements .............................................138\n
    \  22. Contributors .................................................139\n   23.
    References ...................................................139\n      23.1.
    Normative References ....................................139\n      23.2. Informative
    References ..................................140\n   Appendix A. Example Operation
    ....................................143\n      A.1. Example Operation in Storing
    Mode with Node-Owned\n           Prefixes .................................................143\n
    \          A.1.1. DIO Messages and PIO ..............................144\n           A.1.2.
    DAO Messages ......................................145\n           A.1.3. Routing
    Information Base ..........................145\n      A.2. Example Operation in
    Storing Mode with Subnet-Wide\n           Prefix ...................................................146\n
    \          A.2.1. DIO Messages and PIO ..............................147\n           A.2.2.
    DAO Messages ......................................148\n           A.2.3. Routing
    Information Base ..........................148\n      A.3. Example Operation in
    Non-Storing Mode with Node-Owned\n           Prefixes .................................................149\n
    \          A.3.1. DIO Messages and PIO ..............................150\n           A.3.2.
    DAO Messages ......................................150\n           A.3.3. Routing
    Information Base ..........................151\n      A.4. Example Operation in
    Non-Storing Mode with\n           Subnet-Wide Prefix .......................................151\n
    \          A.4.1. DIO Messages and PIO ..............................152\n           A.4.2.
    DAO Messages ......................................153\n           A.4.3. Routing
    Information Base ..........................153\n      A.5. Example with External
    Prefixes ...........................154\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   Low-power and Lossy Networks (LLNs) consist largely of constrained\n
    \  nodes (with limited processing power, memory, and sometimes energy\n   when
    they are battery operated or energy scavenging).  These routers\n   are interconnected
    by lossy links, typically supporting only low data\n   rates, that are usually
    unstable with relatively low packet delivery\n   rates.  Another characteristic
    of such networks is that the traffic\n   patterns are not simply point-to-point,
    but in many cases point-to-\n   multipoint or multipoint-to-point.  Furthermore,
    such networks may\n   potentially comprise up to thousands of nodes.  These characteristics\n
    \  offer unique challenges to a routing solution: the IETF ROLL working\n   group
    has defined application-specific routing requirements for a\n   Low-power and
    Lossy Network (LLN) routing protocol, specified in\n   [RFC5867], [RFC5826], [RFC5673],
    and [RFC5548].\n   This document specifies the IPv6 Routing Protocol for LLNs
    (RPL).\n   Note that although RPL was specified according to the requirements\n
    \  set forth in the aforementioned requirement documents, its use is in\n   no
    way limited to these applications.\n"
  - contents:
    - "1.1.  Design Principles\n   RPL was designed with the objective to meet the
      requirements spelled\n   out in [RFC5867], [RFC5826], [RFC5673], and [RFC5548].\n
      \  A network may run multiple instances of RPL concurrently.  Each such\n   instance
      may serve different and potentially antagonistic constraints\n   or performance
      criteria.  This document defines how a single instance\n   operates.\n   In
      order to be useful in a wide range of LLN application domains, RPL\n   separates
      packet processing and forwarding from the routing\n   optimization objective.
      \ Examples of such objectives include\n   minimizing energy, minimizing latency,
      or satisfying constraints.\n   This document describes the mode of operation
      of RPL.  Other\n   companion documents specify routing Objective Functions.
      \ A RPL\n   implementation, in support of a particular LLN application, will\n
      \  include the necessary Objective Function(s) as required by the\n   application.\n
      \  RPL operations require bidirectional links.  In some LLN scenarios,\n   those
      links may exhibit asymmetric properties.  It is required that\n   the reachability
      of a router be verified before the router can be\n   used as a parent.  RPL
      expects an external mechanism to be triggered\n   during the parent selection
      phase in order to verify link properties\n   and neighbor reachability.  Neighbor
      Unreachability Detection (NUD)\n   is such a mechanism, but alternates are possible,
      including\n   Bidirectional Forwarding Detection (BFD) [RFC5881] and hints from\n
      \  lower layers via Layer 2 (L2) triggers like [RFC5184].  In a general\n   fashion,
      a detection mechanism that is reactive to traffic is favored\n   in order to
      minimize the cost of monitoring links that are not being\n   used.\n   RPL also
      expects an external mechanism to access and transport some\n   control information,
      referred to as the \"RPL Packet Information\", in\n   data packets.  The RPL
      Packet Information is defined in Section 11.2\n   and enables the association
      of a data packet with a RPL Instance and\n   the validation of RPL routing states.
      \ The RPL option [RFC6553] is an\n   example of such mechanism.  The mechanism
      is required for all packets\n   except when strict source routing is used (that
      is for packets going\n   Downward in Non-Storing mode as detailed further in
      Section 9), which\n   by nature prevents endless loops and alleviates the need
      for the RPL\n   Packet Information.  Future companion specifications may propose\n
      \  alternate ways to carry the RPL Packet Information in the IPv6\n   packets
      and may extend the RPL Packet Information to support\n   additional features.\n
      \  RPL provides a mechanism to disseminate information over the\n   dynamically
      formed network topology.  This dissemination enables\n   minimal configuration
      in the nodes, allowing nodes to operate mostly\n   autonomously.  This mechanism
      uses Trickle [RFC6206] to optimize the\n   dissemination as described in Section
      8.3.\n   In some applications, RPL assembles topologies of routers that own\n
      \  independent prefixes.  Those prefixes may or may not be aggregatable\n   depending
      on the origin of the routers.  A prefix that is owned by a\n   router is advertised
      as on-link.\n   RPL also introduces the capability to bind a subnet together
      with a\n   common prefix and to route within that subnet.  A source can inject\n
      \  information about the subnet to be disseminated by RPL, and that\n   source
      is authoritative for that subnet.  Because many LLN links have\n   non-transitive
      properties, a common prefix that RPL disseminates over\n   the subnet must not
      be advertised as on-link.\n   In particular, RPL may disseminate IPv6 Neighbor
      Discovery (ND)\n   information such as the [RFC4861] Prefix Information Option
      (PIO) and\n   the [RFC4191] Route Information Option (RIO).  ND information
      that is\n   disseminated by RPL conserves all its original semantics for router\n
      \  to host, with limited extensions for router to router, though it is\n   not
      to be confused with routing advertisements and it is never to be\n   directly
      redistributed in another routing protocol.  A RPL node often\n   combines host
      and router behaviors.  As a host, it will process the\n   options as specified
      in [RFC4191], [RFC4861], [RFC4862], and\n   [RFC6275].  As a router, the RPL
      node may advertise the information\n   from the options as required for the
      specific link, for instance, in\n   an ND Router Advertisement (RA) message,
      though the exact operation\n   is out of scope.\n   A set of companion documents
      to this specification will provide\n   further guidance in the form of applicability
      statements specifying a\n   set of operating points appropriate to the Building
      Automation, Home\n   Automation, Industrial, and Urban application scenarios.\n"
    title: 1.1.  Design Principles
  - contents:
    - "1.2.  Expectations of Link-Layer Type\n   In compliance with the layered architecture
      of IP, RPL does not rely\n   on any particular features of a specific link-layer
      technology.  RPL\n   is designed to be able to operate over a variety of different
      link\n   layers, including ones that are constrained, potentially lossy, or\n
      \  typically utilized in conjunction with highly constrained host or\n   router
      devices, such as but not limited to, low-power wireless or PLC\n   (Power Line
      Communication) technologies.\n   Implementers may find [RFC3819] a useful reference
      when designing a\n   link-layer interface between RPL and a particular link-layer\n
      \  technology.\n"
    title: 1.2.  Expectations of Link-Layer Type
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\",
    \"MAY\", and\n   \"OPTIONAL\" in this document are to be interpreted as described
    in RFC\n   2119 [RFC2119].\n   Additionally, this document uses terminology from
    [ROLL-TERMS], and\n   introduces the following terminology:\n   DAG: Directed
    Acyclic Graph.  A directed graph having the property\n         that all edges
    are oriented in such a way that no cycles exist.\n         All edges are contained
    in paths oriented toward and\n         terminating at one or more root nodes.\n
    \  DAG root: A DAG root is a node within the DAG that has no outgoing\n         edge.
    \ Because the graph is acyclic, by definition, all DAGs\n         must have at
    least one DAG root and all paths terminate at a\n         DAG root.\n   Destination-Oriented
    DAG (DODAG): A DAG rooted at a single\n         destination, i.e., at a single
    DAG root (the DODAG root) with\n         no outgoing edges.\n   DODAG root: A
    DODAG root is the DAG root of a DODAG.  The DODAG root\n         may act as a
    border router for the DODAG; in particular, it may\n         aggregate routes
    in the DODAG and may redistribute DODAG routes\n         into other routing protocols.\n
    \  Virtual DODAG root: A Virtual DODAG root is the result of two or more\n         RPL
    routers, for instance, 6LoWPAN Border Routers (6LBRs),\n         coordinating
    to synchronize DODAG state and act in concert as\n         if they are a single
    DODAG root (with multiple interfaces),\n         with respect to the LLN.  The
    coordination most likely occurs\n         between powered devices over a reliable
    transit link, and the\n         details of that scheme are out of scope for this
    specification\n         (to be defined in future companion specifications).\n
    \  Up:  Up refers to the direction from leaf nodes towards DODAG roots,\n         following
    DODAG edges.  This follows the common terminology\n         used in graphs and
    depth-first-search, where vertices further\n         from the root are \"deeper\"
    or \"down\" and vertices closer to the\n         root are \"shallower\" or \"up\".\n
    \  Down: Down refers to the direction from DODAG roots towards leaf\n         nodes,
    in the reverse direction of DODAG edges.  This follows\n         the common terminology
    used in graphs and depth-first-search,\n         where vertices further from the
    root are \"deeper\" or \"down\" and\n         vertices closer to the root are
    \"shallower\" or \"up\".\n   Rank: A node's Rank defines the node's individual
    position relative\n         to other nodes with respect to a DODAG root.  Rank
    strictly\n         increases in the Down direction and strictly decreases in the\n
    \        Up direction.  The exact way Rank is computed depends on the\n         DAG's
    Objective Function (OF).  The Rank may analogously track\n         a simple topological
    distance, may be calculated as a function\n         of link metrics, and may consider
    other properties such as\n         constraints.\n   Objective Function (OF): An
    OF defines how routing metrics,\n         optimization objectives, and related
    functions are used to\n         compute Rank.  Furthermore, the OF dictates how
    parents in the\n         DODAG are selected and, thus, the DODAG formation.\n
    \  Objective Code Point (OCP): An OCP is an identifier that indicates\n         which
    Objective Function the DODAG uses.\n   RPLInstanceID: A RPLInstanceID is a unique
    identifier within a\n         network.  DODAGs with the same RPLInstanceID share
    the same\n         Objective Function.\n   RPL Instance: A RPL Instance is a set
    of one or more DODAGs that\n         share a RPLInstanceID.  At most, a RPL node
    can belong to one\n         DODAG in a RPL Instance.  Each RPL Instance operates\n
    \        independently of other RPL Instances.  This document describes\n         operation
    within a single RPL Instance.\n   DODAGID: A DODAGID is the identifier of a DODAG
    root.  The DODAGID is\n         unique within the scope of a RPL Instance in the
    LLN.  The\n         tuple (RPLInstanceID, DODAGID) uniquely identifies a DODAG.\n
    \  DODAG Version: A DODAG Version is a specific iteration (\"Version\") of\n         a
    DODAG with a given DODAGID.\n   DODAGVersionNumber: A DODAGVersionNumber is a
    sequential counter that\n         is incremented by the root to form a new Version
    of a DODAG.  A\n         DODAG Version is identified uniquely by the (RPLInstanceID,\n
    \        DODAGID, DODAGVersionNumber) tuple.\n   Goal: The Goal is an application-specific
    goal that is defined\n         outside the scope of RPL.  Any node that roots
    a DODAG will\n         need to know about this Goal to decide whether or not the
    Goal\n         can be satisfied.  A typical Goal is to construct the DODAG\n         according
    to a specific Objective Function and to keep\n         connectivity to a set of
    hosts (e.g., to use an Objective\n         Function that minimizes a metric and
    is connected to a specific\n         database host to store the collected data).\n
    \  Grounded: A DODAG is grounded when the DODAG root can satisfy the\n         Goal.\n
    \  Floating: A DODAG is floating if it is not grounded.  A floating\n         DODAG
    is not expected to have the properties required to\n         satisfy the goal.
    \ It may, however, provide connectivity to\n         other nodes within the DODAG.\n
    \  DODAG parent: A parent of a node within a DODAG is one of the\n         immediate
    successors of the node on a path towards the DODAG\n         root.  A DODAG parent's
    Rank is lower than the node's.  (See\n         Section 3.5.1).\n   Sub-DODAG:
    The sub-DODAG of a node is the set of other nodes whose\n         paths to the
    DODAG root pass through that node.  Nodes in the\n         sub-DODAG of a node
    have a greater Rank than that node.  (See\n         Section 3.5.1).\n   Local
    DODAG: Local DODAGs contain one and only one root node, and\n         they allow
    that single root node to allocate and manage a RPL\n         Instance, identified
    by a local RPLInstanceID, without\n         coordination with other nodes.  Typically,
    this is done in\n         order to optimize routes to a destination within the
    LLN.  (See\n         Section 5).\n   Global DODAG: A Global DODAG uses a global
    RPLInstanceID that may be\n         coordinated among several other nodes.  (See
    Section 5).\n   DIO: DODAG Information Object (see Section 6.3)\n   DAO: Destination
    Advertisement Object (see Section 6.4)\n   DIS: DODAG Information Solicitation
    (see Section 6.2)\n   CC: Consistency Check (see Section 6.6)\n   As they form
    networks, LLN devices often mix the roles of host and\n   router when compared
    to traditional IP networks.  In this document,\n   \"host\" refers to an LLN device
    that can generate but does not forward\n   RPL traffic; \"router\" refers to an
    LLN device that can forward as\n   well as generate RPL traffic; and \"node\"
    refers to any RPL device,\n   either a host or a router.\n"
  title: 2.  Terminology
- contents:
  - "3.  Protocol Overview\n   The aim of this section is to describe RPL in the spirit
    of\n   [RFC4101].  Protocol details can be found in further sections.\n"
  - contents:
    - "3.1.  Topologies\n   This section describes the basic RPL topologies that may
      be formed,\n   and the rules by which these are constructed, i.e., the rules\n
      \  governing DODAG formation.\n"
    - contents:
      - "3.1.1.  Constructing Topologies\n   LLNs, such as Radio Networks, do not
        typically have predefined\n   topologies, for example, those imposed by point-to-point
        wires, so\n   RPL has to discover links and then select peers sparingly.\n
        \  In many cases, because Layer 2 ranges overlap only partially, RPL\n   forms
        non-transitive / Non-Broadcast Multi-Access (NBMA) network\n   topologies
        upon which it computes routes.\n   RPL routes are optimized for traffic to
        or from one or more roots\n   that act as sinks for the topology.  As a result,
        RPL organizes a\n   topology as a Directed Acyclic Graph (DAG) that is partitioned
        into\n   one or more Destination Oriented DAGs (DODAGs), one DODAG per sink.\n
        \  If the DAG has multiple roots, then it is expected that the roots are\n
        \  federated by a common backbone, such as a transit link.\n"
      title: 3.1.1.  Constructing Topologies
    - contents:
      - "3.1.2.  RPL Identifiers\n   RPL uses four values to identify and maintain
        a topology:\n   o  The first is a RPLInstanceID.  A RPLInstanceID identifies
        a set of\n      one or more Destination Oriented DAGs (DODAGs).  A network
        may\n      have multiple RPLInstanceIDs, each of which defines an independent\n
        \     set of DODAGs, which may be optimized for different Objective\n      Functions
        (OFs) and/or applications.  The set of DODAGs identified\n      by a RPLInstanceID
        is called a RPL Instance.  All DODAGs in the\n      same RPL Instance use
        the same OF.\n   o  The second is a DODAGID.  The scope of a DODAGID is a
        RPL\n      Instance.  The combination of RPLInstanceID and DODAGID uniquely\n
        \     identifies a single DODAG in the network.  A RPL Instance may have\n
        \     multiple DODAGs, each of which has an unique DODAGID.\n   o  The third
        is a DODAGVersionNumber.  The scope of a\n      DODAGVersionNumber is a DODAG.
        \ A DODAG is sometimes reconstructed\n      from the DODAG root, by incrementing
        the DODAGVersionNumber.  The\n      combination of RPLInstanceID, DODAGID,
        and DODAGVersionNumber\n      uniquely identifies a DODAG Version.\n   o  The
        fourth is Rank.  The scope of Rank is a DODAG Version.  Rank\n      establishes
        a partial order over a DODAG Version, defining\n      individual node positions
        with respect to the DODAG root.\n"
      title: 3.1.2.  RPL Identifiers
    - contents:
      - "3.1.3.  Instances, DODAGs, and DODAG Versions\n   A RPL Instance contains
        one or more DODAG roots.  A RPL Instance may\n   provide routes to certain
        destination prefixes, reachable via the\n   DODAG roots or alternate paths
        within the DODAG.  These roots may\n   operate independently, or they may
        coordinate over a network that is\n   not necessarily as constrained as an
        LLN.\n   A RPL Instance may comprise:\n   o  a single DODAG with a single
        root\n      *  For example, a DODAG optimized to minimize latency rooted at
        a\n         single centralized lighting controller in a Home Automation\n
        \        application.\n   o  multiple uncoordinated DODAGs with independent
        roots (differing\n      DODAGIDs)\n      *  For example, multiple data collection
        points in an urban data\n         collection application that do not have
        suitable connectivity\n         to coordinate with each other or that use
        the formation of\n         multiple DODAGs as a means to dynamically and autonomously\n
        \        partition the network.\n   o  a single DODAG with a virtual root
        that coordinates LLN sinks\n      (with the same DODAGID) over a backbone
        network.\n      *  For example, multiple border routers operating with a reliable\n
        \        transit link, e.g., in support of an IPv6 Low-Power Wireless\n         Personal
        Area Network (6LoWPAN) application, that are capable\n         of acting as
        logically equivalent interfaces to the sink of the\n         same DODAG.\n
        \  o  a combination of the above as suited to some application scenario.\n
        \  Each RPL packet is associated with a particular RPLInstanceID (see\n   Section
        11.2) and, therefore, RPL Instance (Section 5).  The\n   provisioning or automated
        discovery of a mapping between a\n   RPLInstanceID and a type or service of
        application traffic is out of\n   scope for this specification (to be defined
        in future companion\n   specifications).\n   Figure 1 depicts an example of
        a RPL Instance comprising three DODAGs\n   with DODAG roots R1, R2, and R3.
        \ Each of these DODAG roots\n   advertises the same RPLInstanceID.  The lines
        depict connectivity\n   between parents and children.\n   Figure 2 depicts
        how a DODAGVersionNumber increment leads to a new\n   DODAG Version.  This
        depiction illustrates a DODAGVersionNumber\n   increment that results in a
        different DODAG topology.  Note that a\n   new DODAG Version does not always
        imply a different DODAG topology.\n   To accommodate certain topology changes
        requires a new DODAG Version,\n   as described later in this specification.\n
        \  In the following examples, please note that tree-like structures are\n
        \  depicted for simplicity, although the DODAG structure allows for each\n
        \  node to have multiple parents when the connectivity supports it.\n     +----------------------------------------------------------------+\n
        \    |                                                                |\n
        \    | +--------------+                                               |\n
        \    | |              |                                               |\n
        \    | |     (R1)     |            (R2)                   (R3)        |\n
        \    | |     /  \\     |            /| \\                  / |  \\       |\n
        \    | |    /    \\    |           / |  \\                /  |   \\      |\n
        \    | |  (A)    (B)  |         (C) |  (D)     ...    (F) (G)  (H)    |\n
        \    | |  /|\\     |\\  |         /   | / |\\             |\\  |    |     |\n
        \    | | : : :    : : |        :   (E)  : :            :  `:    :     |\n
        \    | |              |            / \\                                |\n
        \    | +--------------+           :   :                               |\n
        \    |      DODAG                                                     |\n
        \    |                                                                |\n
        \    +----------------------------------------------------------------+\n
        \                               RPL Instance\n                          Figure
        1: RPL Instance\n            +----------------+                +----------------+\n
        \           |                |                |                |\n            |
        \     (R1)      |                |      (R1)      |\n            |      /
        \ \\      |                |      /         |\n            |     /    \\     |
        \               |     /          |\n            |   (A)    (B)   |         \\
        \     |   (A)          |\n            |   /|\\   / |\\   |    ------\\     |
        \  /|\\          |\n            |  : : (C)  : :  |           \\    |  : :
        (C)       |\n            |                |           /    |        \\       |\n
        \           |                |    ------/     |         \\      |\n            |
        \               |         /      |         (B)    |\n            |                |
        \               |          |\\    |\n            |                |                |
        \         : :   |\n            |                |                |                |\n
        \           +----------------+                +----------------+\n                Version
        N                        Version N+1\n                          Figure 2:
        DODAG Version\n"
      title: 3.1.3.  Instances, DODAGs, and DODAG Versions
    title: 3.1.  Topologies
  - contents:
    - "3.2.  Upward Routes and DODAG Construction\n   RPL provisions routes Up towards
      DODAG roots, forming a DODAG\n   optimized according to an Objective Function
      (OF).  RPL nodes\n   construct and maintain these DODAGs through DODAG Information
      Object\n   (DIO) messages.\n"
    - contents:
      - "3.2.1.  Objective Function (OF)\n   The Objective Function (OF) defines how
        RPL nodes select and optimize\n   routes within a RPL Instance.  The OF is
        identified by an Objective\n   Code Point (OCP) within the DIO Configuration
        option.  An OF defines\n   how nodes translate one or more metrics and constraints,
        which are\n   themselves defined in [RFC6551], into a value called Rank, which\n
        \  approximates the node's distance from a DODAG root.  An OF also\n   defines
        how nodes select parents.  Further details may be found in\n   Section 14,
        [RFC6551], [RFC6552], and related companion\n   specifications.\n"
      title: 3.2.1.  Objective Function (OF)
    - contents:
      - "3.2.2.  DODAG Repair\n   A DODAG root institutes a global repair operation
        by incrementing the\n   DODAGVersionNumber.  This initiates a new DODAG Version.
        \ Nodes in\n   the new DODAG Version can choose a new position whose Rank
        is not\n   constrained by their Rank within the old DODAG Version.\n   RPL
        also supports mechanisms that may be used for local repair within\n   the
        DODAG Version.  The DIO message specifies the necessary\n   parameters as
        configured from and controlled by policy at the DODAG\n   root.\n"
      title: 3.2.2.  DODAG Repair
    - contents:
      - "3.2.3.  Security\n   RPL supports message confidentiality and integrity.
        \ It is designed\n   such that link-layer mechanisms can be used when available
        and\n   appropriate; yet, in their absence, RPL can use its own mechanisms.\n
        \  RPL has three basic security modes.\n   In the first, called \"unsecured\",
        RPL control messages are sent\n   without any additional security mechanisms.
        \ Unsecured mode does not\n   imply that the RPL network is unsecure: it could
        be using other\n   present security primitives (e.g., link-layer security)
        to meet\n   application security requirements.\n   In the second, called \"preinstalled\",
        nodes joining a RPL Instance\n   have preinstalled keys that enable them to
        process and generate\n   secured RPL messages.\n   The third mode is called
        \"authenticated\".  In authenticated mode,\n   nodes have preinstalled keys
        as in preinstalled mode, but the\n   preinstalled key may only be used to
        join a RPL Instance as a leaf.\n   Joining an authenticated RPL Instance as
        a router requires obtaining\n   a key from an authentication authority.  The
        process by which this\n   key is obtained is out of scope for this specification.
        \ Note that\n   this specification alone does not provide sufficient detail
        for a RPL\n   implementation to securely operate in authenticated mode.  For
        a RPL\n   implementation to operate securely in authenticated mode, it is\n
        \  necessary for a future companion specification to detail the\n   mechanisms
        by which a node obtains/requests the authentication\n   material (e.g., key,
        certificate) and to determine from where that\n   material should be obtained.
        \ See also Section 10.3.\n"
      title: 3.2.3.  Security
    - contents:
      - "3.2.4.  Grounded and Floating DODAGs\n   DODAGs can be grounded or floating:
        the DODAG root advertises which\n   is the case.  A grounded DODAG offers
        connectivity to hosts that are\n   required for satisfying the application-defined
        goal.  A floating\n   DODAG is not expected to satisfy the goal; in most cases,
        it only\n   provides routes to nodes within the DODAG.  Floating DODAGs may
        be\n   used, for example, to preserve interconnectivity during repair.\n"
      title: 3.2.4.  Grounded and Floating DODAGs
    - contents:
      - "3.2.5.  Local DODAGs\n   RPL nodes can optimize routes to a destination within
        an LLN by\n   forming a Local DODAG whose DODAG root is the desired destination.\n
        \  Unlike global DAGs, which can consist of multiple DODAGs, local DAGs\n
        \  have one and only one DODAG and therefore one DODAG root.  Local\n   DODAGs
        can be constructed on demand.\n"
      title: 3.2.5.  Local DODAGs
    - contents:
      - "3.2.6.  Administrative Preference\n   An implementation/deployment may specify
        that some DODAG roots should\n   be used over others through an administrative
        preference.\n   Administrative preference offers a way to control traffic
        and\n   engineer DODAG formation in order to better support application\n
        \  requirements or needs.\n"
      title: 3.2.6.  Administrative Preference
    - contents:
      - "3.2.7.  Data-Path Validation and Loop Detection\n   The low-power and lossy
        nature of LLNs motivates RPL's use of on-\n   demand loop detection using
        data packets.  Because data traffic can\n   be infrequent, maintaining a routing
        topology that is constantly up\n   to date with the physical topology can
        waste energy.  Typical LLNs\n   exhibit variations in physical connectivity
        that are transient and\n   innocuous to traffic, but that would be costly
        to track closely from\n   the control plane.  Transient and infrequent changes
        in connectivity\n   need not be addressed by RPL until there is data to send.
        \ This\n   aspect of RPL's design draws from existing, highly used LLN protocols\n
        \  as well as extensive experimental and deployment evidence on its\n   efficacy.\n
        \  The RPL Packet Information that is transported with data packets\n   includes
        the Rank of the transmitter.  An inconsistency between the\n   routing decision
        for a packet (Upward or Downward) and the Rank\n   relationship between the
        two nodes indicates a possible loop.  On\n   receiving such a packet, a node
        institutes a local repair operation.\n   For example, if a node receives a
        packet flagged as moving in the\n   Upward direction, and if that packet records
        that the transmitter is\n   of a lower (lesser) Rank than the receiving node,
        then the receiving\n   node is able to conclude that the packet has not progressed
        in the\n   Upward direction and that the DODAG is inconsistent.\n"
      title: 3.2.7.  Data-Path Validation and Loop Detection
    - contents:
      - "3.2.8.  Distributed Algorithm Operation\n   A high-level overview of the
        distributed algorithm, which constructs\n   the DODAG, is as follows:\n   o
        \ Some nodes are configured to be DODAG roots, with associated DODAG\n      configurations.\n
        \  o  Nodes advertise their presence, affiliation with a DODAG, routing\n
        \     cost, and related metrics by sending link-local multicast DIO\n      messages
        to all-RPL-nodes.\n   o  Nodes listen for DIOs and use their information to
        join a new\n      DODAG (thus, selecting DODAG parents), or to maintain an
        existing\n      DODAG, according to the specified Objective Function and Rank
        of\n      their neighbors.\n   o  Nodes provision routing table entries, for
        the destinations\n      specified by the DIO message, via their DODAG parents
        in the DODAG\n      Version.  Nodes that decide to join a DODAG can provision
        one or\n      more DODAG parents as the next hop for the default route and
        a\n      number of other external routes for the associated instance.\n"
      title: 3.2.8.  Distributed Algorithm Operation
    title: 3.2.  Upward Routes and DODAG Construction
  - contents:
    - "3.3.  Downward Routes and Destination Advertisement\n   RPL uses Destination
      Advertisement Object (DAO) messages to establish\n   Downward routes.  DAO messages
      are an optional feature for\n   applications that require point-to-multipoint
      (P2MP) or point-to-\n   point (P2P) traffic.  RPL supports two modes of Downward
      traffic:\n   Storing (fully stateful) or Non-Storing (fully source routed);
      see\n   Section 9.  Any given RPL Instance is either storing or non-storing.\n
      \  In both cases, P2P packets travel Up toward a DODAG root then Down to\n   the
      final destination (unless the destination is on the Upward\n   route).  In the
      Non-Storing case, the packet will travel all the way\n   to a DODAG root before
      traveling Down.  In the Storing case, the\n   packet may be directed Down towards
      the destination by a common\n   ancestor of the source and the destination prior
      to reaching a DODAG\n   root.\n   As of the writing of this specification, no
      implementation is\n   expected to support both Storing and Non-Storing modes
      of operation.\n   Most implementations are expected to support either no Downward\n
      \  routes, Non-Storing mode only, or Storing mode only.  Other modes of\n   operation,
      such as a hybrid mix of Storing and Non-Storing mode, are\n   out of scope for
      this specification and may be described in other\n   companion specifications.\n
      \  This specification describes a basic mode of operation in support of\n   P2P
      traffic.  Note that more optimized P2P solutions may be described\n   in companion
      specifications.\n"
    title: 3.3.  Downward Routes and Destination Advertisement
  - contents:
    - "3.4.  Local DODAGs Route Discovery\n   Optionally, a RPL network can support
      on-demand discovery of DODAGs\n   to specific destinations within an LLN.  Such
      Local DODAGs behave\n   slightly differently than Global DODAGs: they are uniquely
      defined by\n   the combination of DODAGID and RPLInstanceID.  The RPLInstanceID\n
      \  denotes whether a DODAG is a Local DODAG.\n"
    title: 3.4.  Local DODAGs Route Discovery
  - contents:
    - "3.5.  Rank Properties\n   The Rank of a node is a scalar representation of
      the location of that\n   node within a DODAG Version.  The Rank is used to avoid
      and detect\n   loops and, as such, must demonstrate certain properties.  The
      exact\n   calculation of the Rank is left to the Objective Function.  Even\n
      \  though the specific computation of the Rank is left to the Objective\n   Function,
      the Rank must implement generic properties regardless of\n   the Objective Function.\n
      \  In particular, the Rank of the nodes must monotonically decrease as\n   the
      DODAG Version is followed towards the DODAG destination.  In that\n   regard,
      the Rank can be considered a scalar representation of the\n   location or radius
      of a node within a DODAG Version.\n   The details of how the Objective Function
      computes Rank are out of\n   scope for this specification, although that computation
      may depend,\n   for example, on parents, link metrics, node metrics, and the
      node\n   configuration and policies.  See Section 14 for more information.\n
      \  The Rank is not a path cost, although its value can be derived from\n   and
      influenced by path metrics.  The Rank has properties of its own\n   that are
      not necessarily those of all metrics:\n   Type: The Rank is an abstract numeric
      value.\n   Function: The Rank is the expression of a relative position within
      a\n         DODAG Version with regard to neighbors, and it is not\n         necessarily
      a good indication or a proper expression of a\n         distance or a path cost
      to the root.\n   Stability: The stability of the Rank determines the stability
      of the\n         routing topology.  Some dampening or filtering is RECOMMENDED\n
      \        to keep the topology stable; thus, the Rank does not\n         necessarily
      change as fast as some link or node metrics would.\n         A new DODAG Version
      would be a good opportunity to reconcile\n         the discrepancies that might
      form over time between metrics and\n         Ranks within a DODAG Version.\n
      \  Properties: The Rank is incremented in a strictly monotonic fashion,\n         and
      it can be used to validate a progression from or towards\n         the root.
      \ A metric, like bandwidth or jitter, does not\n         necessarily exhibit
      this property.\n   Abstract: The Rank does not have a physical unit, but rather
      a range\n         of increment per hop, where the assignment of each increment
      is\n         to be determined by the Objective Function.\n   The Rank value
      feeds into DODAG parent selection, according to the\n   RPL loop-avoidance strategy.
      \ Once a parent has been added, and a\n   Rank value for the node within the
      DODAG has been advertised, the\n   node's further options with regard to DODAG
      parent selection and\n   movement within the DODAG are restricted in favor of
      loop avoidance.\n"
    - contents:
      - "3.5.1.  Rank Comparison (DAGRank())\n   Rank may be thought of as a fixed-point
        number, where the position of\n   the radix point between the integer part
        and the fractional part is\n   determined by MinHopRankIncrease.  MinHopRankIncrease
        is the minimum\n   increase in Rank between a node and any of its DODAG parents.
        \ A\n   DODAG root provisions MinHopRankIncrease.  MinHopRankIncrease creates\n
        \  a trade-off between hop cost precision and the maximum number of hops\n
        \  a network can support.  A very large MinHopRankIncrease, for example,\n
        \  allows precise characterization of a given hop's effect on Rank but\n   cannot
        support many hops.\n   When an Objective Function computes Rank, the Objective
        Function\n   operates on the entire (i.e., 16-bit) Rank quantity.  When Rank
        is\n   compared, e.g., for determination of parent relationships or loop\n
        \  detection, the integer portion of the Rank is to be used.  The\n   integer
        portion of the Rank is computed by the DAGRank() macro as\n   follows, where
        floor(x) is the function that evaluates to the\n   greatest integer less than
        or equal to x:\n              DAGRank(rank) = floor(rank/MinHopRankIncrease)\n
        \  For example, if a 16-bit Rank quantity is decimal 27, and the\n   MinHopRankIncrease
        is decimal 16, then DAGRank(27) = floor(1.6875) =\n   1.  The integer part
        of the Rank is 1 and the fractional part is\n   11/16.\n   Following the conventions
        in this document, using the macro\n   DAGRank(node) may be interpreted as
        DAGRank(node.rank), where\n   node.rank is the Rank value as maintained by
        the node.\n   A Node A has a Rank less than the Rank of a Node B if DAGRank(A)
        is\n   less than DAGRank(B).\n   A Node A has a Rank equal to the Rank of
        a Node B if DAGRank(A) is\n   equal to DAGRank(B).\n   A Node A has a Rank
        greater than the Rank of a Node B if DAGRank(A)\n   is greater than DAGRank(B).\n"
      title: 3.5.1.  Rank Comparison (DAGRank())
    - contents:
      - "3.5.2.  Rank Relationships\n   Rank computations maintain the following properties
        for any nodes M\n   and N that are neighbors in the LLN:\n   DAGRank(M) is
        less than DAGRank(N):\n      In this case, the position of M is closer to
        the DODAG root than\n      the position of N.  Node M may safely be a DODAG
        parent for Node N\n      without risk of creating a loop.  Further, for a
        Node N, all\n      parents in the DODAG parent set must be of a Rank less
        than\n      DAGRank(N).  In other words, the Rank presented by a Node N MUST\n
        \     be greater than that presented by any of its parents.\n   DAGRank(M)
        equals DAGRank(N):\n      In this case, the positions of M and N within the
        DODAG and with\n      respect to the DODAG root are similar or identical.
        \ Routing\n      through a node with equal Rank may cause a routing loop (i.e.,
        if\n      that node chooses to route through a node with equal Rank as\n      well).\n
        \  DAGRank(M) is greater than DAGRank(N):\n      In this case, the position
        of M is farther from the DODAG root\n      than the position of N.  Further,
        Node M may in fact be in the\n      sub-DODAG of Node N.  If Node N selects
        Node M as DODAG parent,\n      there is a risk of creating a loop.\n   As
        an example, the Rank could be computed in such a way so as to\n   closely
        track ETX (expected transmission count, a fairly common\n   routing metric
        used in LLN and defined in [RFC6551]) when the metric\n   that an Objective
        Function minimizes is ETX, or latency, or in a more\n   complicated way as
        appropriate to the Objective Function being used\n   within the DODAG.\n"
      title: 3.5.2.  Rank Relationships
    title: 3.5.  Rank Properties
  - contents:
    - "3.6.  Routing Metrics and Constraints Used by RPL\n   Routing metrics are used
      by routing protocols to compute shortest\n   paths.  Interior Gateway Protocols
      (IGPs) such as IS-IS ([RFC5120])\n   and OSPF ([RFC4915]) use static link metrics.
      \ Such link metrics can\n   simply reflect the bandwidth or can also be computed
      according to a\n   polynomial function of several metrics defining different
      link\n   characteristics.  Some routing protocols support more than one\n   metric:
      in the vast majority of the cases, one metric is used per\n   (sub-)topology.
      \ Less often, a second metric may be used as a\n   tiebreaker in the presence
      of Equal Cost Multiple Paths (ECMPs).  The\n   optimization of multiple metrics
      is known as an NP-complete problem\n   and is sometimes supported by some centralized
      path computation\n   engine.\n   In contrast, LLNs do require the support of
      both static and dynamic\n   metrics.  Furthermore, both link and node metrics
      are required.  In\n   the case of RPL, it is virtually impossible to define
      one metric, or\n   even a composite metric, that will satisfy all use cases.\n
      \  In addition, RPL supports constraint-based routing where constraints\n   may
      be applied to both link and nodes.  If a link or a node does not\n   satisfy
      a required constraint, it is \"pruned\" from the candidate\n   neighbor set,
      thus leading to a constrained shortest path.\n   An Objective Function specifies
      the objectives used to compute the\n   (constrained) path.  Furthermore, nodes
      are configured to support a\n   set of metrics and constraints and select their
      parents in the DODAG\n   according to the metrics and constraints advertised
      in the DIO\n   messages.  Upstream and Downstream metrics may be merged or\n
      \  advertised separately depending on the OF and the metrics.  When they\n   are
      advertised separately, it may happen that the set of DIO parents\n   is different
      from the set of DAO parents (a DAO parent is a node to\n   which unicast DAO
      messages are sent).  Yet, all are DODAG parents\n   with regard to the rules
      for Rank computation.\n   The Objective Function is decoupled from the routing
      metrics and\n   constraints used by RPL.  Whereas the OF dictates rules such
      as DODAG\n   parent selection, load balancing, and so on, the set of metrics\n
      \  and/or constraints used, and thus those that determine the preferred\n   path,
      are based on the information carried within the DAG container\n   option in
      DIO messages.\n   The set of supported link/node constraints and metrics is
      specified\n   in [RFC6551].\n   Example 1: Shortest path: path offering the
      shortest end-to-end\n              delay.\n   Example 2: Shortest Constrained
      path: the path that does not traverse\n              any battery-operated node
      and that optimizes the path\n              reliability.\n"
    title: 3.6.  Routing Metrics and Constraints Used by RPL
  - contents:
    - "3.7.  Loop Avoidance\n   RPL tries to avoid creating loops when undergoing
      topology changes\n   and includes Rank-based data-path validation mechanisms
      for detecting\n   loops when they do occur (see Section 11 for more details).
      \ In\n   practice, this means that RPL guarantees neither loop-free path\n   selection
      nor tight delay convergence times, but it can detect and\n   repair a loop as
      soon as it is used.  RPL uses this loop detection to\n   ensure that packets
      make forward progress within the DODAG Version\n   and trigger repairs when
      necessary.\n"
    - contents:
      - "3.7.1.  Greediness and Instability\n   A node is greedy if it attempts to
        move deeper (increase Rank) in the\n   DODAG Version in order to increase
        the size of the parent set or\n   improve some other metric.  Once a node
        has joined a DODAG Version,\n   RPL disallows certain behaviors, including
        greediness, in order to\n   prevent resulting instabilities in the DODAG Version.\n
        \  Suppose a node is willing to receive and process a DIO message from a\n
        \  node in its own sub-DODAG and, in general, a node deeper than itself.\n
        \  In this case, a possibility exists that a feedback loop is created,\n   wherein
        two or more nodes continue to try and move in the DODAG\n   Version while
        attempting to optimize against each other.  In some\n   cases, this will result
        in instability.  It is for this reason that\n   RPL limits the cases where
        a node may process DIO messages from\n   deeper nodes to some form of local
        repair.  This approach creates an\n   \"event horizon\", whereby a node cannot
        be influenced beyond some\n   limit into an instability by the action of nodes
        that may be in its\n   own sub-DODAG.\n"
      - contents:
        - "3.7.1.1.  Example: Greedy Parent Selection and Instability\n         (A)
          \                   (A)                    (A)\n          |\\                     |\\
          \                    |\\\n          | `-----.              | `-----.              |
          `-----.\n          |        \\             |        \\             |        \\\n
          \        (B)       (C)          (B)        \\            |        (C)\n
          \                                 \\        |            |        /\n                                   `-----.
          |            | .-----'\n                                          \\|            |/\n
          \                                         (C)          (B)\n              -1-
          \                   -2-                    -3-\n                  Figure
          3: Greedy DODAG Parent Selection\n   Figure 3 depicts a DODAG in three different
          configurations.  A usable\n   link between (B) and (C) exists in all three
          configurations.  In\n   Figure 3-1, Node (A) is a DODAG parent for Nodes
          (B) and (C).  In\n   Figure 3-2, Node (A) is a DODAG parent for Nodes (B)
          and (C), and\n   Node (B) is also a DODAG parent for Node (C).  In Figure
          3-3, Node\n   (A) is a DODAG parent for Nodes (B) and (C), and Node (C)
          is also a\n   DODAG parent for Node (B).\n   If a RPL node is too greedy,
          in that it attempts to optimize for an\n   additional number of parents
          beyond its most preferred parents, then\n   an instability can result.  Consider
          the DODAG illustrated in\n   Figure 3-1.  In this example, Nodes (B) and
          (C) may most prefer Node\n   (A) as a DODAG parent, but we will consider
          the case when they are\n   operating under the greedy condition that will
          try to optimize for\n   two parents.\n   o  Let Figure 3-1 be the initial
          condition.\n   o  Suppose Node (C) first is able to leave the DODAG and
          rejoin at a\n      lower Rank, taking both Nodes (A) and (B) as DODAG parents
          as\n      depicted in Figure 3-2.  Now Node (C) is deeper than both Nodes\n
          \     (A) and (B), and Node (C) is satisfied to have two DODAG parents.\n
          \  o  Suppose Node (B), in its greediness, is willing to receive and\n      process
          a DIO message from Node (C) (against the rules of RPL),\n      and then
          Node (B) leaves the DODAG and rejoins at a lower Rank,\n      taking both
          Nodes (A) and (C) as DODAG parents.  Now Node (B) is\n      deeper than
          both Nodes (A) and (C) and is satisfied with two DAG\n      parents.\n   o
          \ Then, Node (C), because it is also greedy, will leave and rejoin\n      deeper,
          to again get two parents and have a lower Rank then both\n      of them.\n
          \  o  Next, Node (B) will again leave and rejoin deeper, to again get\n
          \     two parents.\n   o  Again, Node (C) leaves and rejoins deeper.\n   o
          \ The process will repeat, and the DODAG will oscillate between\n      Figure
          3-2 and Figure 3-3 until the nodes count to infinity and\n      restart
          the cycle again.\n   o  This cycle can be averted through mechanisms in
          RPL:\n      *  Nodes (B) and (C) stay at a Rank sufficient to attach to
          their\n         most preferred parent (A) and don't go for any deeper (worse)\n
          \        alternate parents (Nodes are not greedy).\n      *  Nodes (B) and
          (C) do not process DIO messages from nodes deeper\n         than themselves
          (because such nodes are possibly in their own\n         sub-DODAGs).\n   These
          mechanisms are further described in Section 8.2.2.4.\n"
        title: '3.7.1.1.  Example: Greedy Parent Selection and Instability'
      title: 3.7.1.  Greediness and Instability
    - contents:
      - "3.7.2.  DODAG Loops\n   A DODAG loop may occur when a node detaches from
        the DODAG and\n   reattaches to a device in its prior sub-DODAG.  In particular,
        this\n   may happen when DIO messages are missed.  Strict use of the\n   DODAGVersionNumber
        can eliminate this type of loop, but this type of\n   loop may possibly be
        encountered when using some local repair\n   mechanisms.\n   For example,
        consider the local repair mechanism that allows a node\n   to detach from
        the DODAG, advertise a Rank of INFINITE_RANK (in order\n   to poison its routes
        / inform its sub-DODAG), and then reattach to\n   the DODAG.  In some of these
        cases, the node may reattach to its own\n   prior-sub-DODAG, causing a DODAG
        loop, because the poisoning may fail\n   if the INFINITE_RANK advertisements
        are lost in the LLN environment.\n   (In this case, the Rank-based data-path
        validation mechanisms would\n   eventually detect and trigger correction of
        the loop).\n"
      title: 3.7.2.  DODAG Loops
    - contents:
      - "3.7.3.  DAO Loops\n   A DAO loop may occur when the parent has a route installed
        upon\n   receiving and processing a DAO message from a child, but the child\n
        \  has subsequently cleaned up the related DAO state.  This loop happens\n
        \  when a No-Path (a DAO message that invalidates a previously announced\n
        \  prefix, see Section 6.4.3) was missed and persists until all state\n   has
        been cleaned up.  RPL includes an optional mechanism to\n   acknowledge DAO
        messages, which may mitigate the impact of a single\n   DAO message being
        missed.  RPL includes loop detection mechanisms\n   that mitigate the impact
        of DAO loops and trigger their repair.  (See\n   Section 11.2.2.3.)\n"
      title: 3.7.3.  DAO Loops
    title: 3.7.  Loop Avoidance
  title: 3.  Protocol Overview
- contents:
  - "4.  Traffic Flows Supported by RPL\n   RPL supports three basic traffic flows:
    multipoint-to-point (MP2P),\n   point-to-multipoint (P2MP), and point-to-point
    (P2P).\n"
  - contents:
    - "4.1.  Multipoint-to-Point Traffic\n   Multipoint-to-point (MP2P) is a dominant
      traffic flow in many LLN\n   applications ([RFC5867], [RFC5826], [RFC5673],
      and [RFC5548]).  The\n   destinations of MP2P flows are designated nodes that
      have some\n   application significance, such as providing connectivity to the\n
      \  larger Internet or core private IP network.  RPL supports MP2P\n   traffic
      by allowing MP2P destinations to be reached via DODAG roots.\n"
    title: 4.1.  Multipoint-to-Point Traffic
  - contents:
    - "4.2.  Point-to-Multipoint Traffic\n   Point-to-multipoint (P2MP) is a traffic
      pattern required by several\n   LLN applications ([RFC5867], [RFC5826], [RFC5673],
      and [RFC5548]).\n   RPL supports P2MP traffic by using a destination advertisement\n
      \  mechanism that provisions Down routes toward destinations (prefixes,\n   addresses,
      or multicast groups), and away from roots.  Destination\n   advertisements can
      update routing tables as the underlying DODAG\n   topology changes.\n"
    title: 4.2.  Point-to-Multipoint Traffic
  - contents:
    - "4.3.  Point-to-Point Traffic\n   RPL DODAGs provide a basic structure for point-to-point
      (P2P)\n   traffic.  For a RPL network to support P2P traffic, a root must be\n
      \  able to route packets to a destination.  Nodes within the network may\n   also
      have routing tables to destinations.  A packet flows towards a\n   root until
      it reaches an ancestor that has a known route to the\n   destination.  As pointed
      out later in this document, in the most\n   constrained case (when nodes cannot
      store routes), that common\n   ancestor may be the DODAG root.  In other cases,
      it may be a node\n   closer to both the source and destination.\n   RPL also
      supports the case where a P2P destination is a 'one-hop'\n   neighbor.\n   RPL
      neither specifies nor precludes additional mechanisms for\n   computing and
      installing potentially more optimal routes to support\n   arbitrary P2P traffic.\n"
    title: 4.3.  Point-to-Point Traffic
  title: 4.  Traffic Flows Supported by RPL
- contents:
  - "5.  RPL Instance\n   Within a given LLN, there may be multiple, logically independent
    RPL\n   Instances.  A RPL node may belong to multiple RPL Instances, and it\n
    \  may act as a router in some and as a leaf in others.  This document\n   describes
    how a single instance behaves.\n   There are two types of RPL Instances: Local
    and Global.  RPL divides\n   the RPLInstanceID space between Global and Local
    instances to allow\n   for both coordinated and unilateral allocation of RPLInstanceIDs.\n
    \  Global RPL Instances are coordinated, have one or more DODAGs, and\n   are
    typically long-lived.  Local RPL Instances are always a single\n   DODAG whose
    singular root owns the corresponding DODAGID and\n   allocates the local RPLInstanceID
    in a unilateral manner.  Local RPL\n   Instances can be used, for example, for
    constructing DODAGs in\n   support of a future on-demand routing solution.  The
    mode of\n   operation of Local RPL Instances is out of scope for this\n   specification
    and may be described in other companion specifications.\n   The definition and
    provisioning of RPL Instances are out of scope for\n   this specification.  Guidelines
    may be application and implementation\n   specific, and they are expected to be
    elaborated in future companion\n   specifications.  Those operations are expected
    to be such that data\n   packets coming from the outside of the RPL network can
    unambiguously\n   be associated to at least one RPL Instance and be safely routed
    over\n   any instance that would match the packet.\n   Control and data packets
    within RPL network are tagged to\n   unambiguously identify of which RPL Instance
    they are a part.\n   Every RPL control message has a RPLInstanceID field.  Some
    RPL\n   control messages, when referring to a local RPLInstanceID as defined\n
    \  below, may also include a DODAGID.\n   Data packets that flow within the RPL
    network expose the\n   RPLInstanceID as part of the RPL Packet Information that
    RPL\n   requires, as further described in Section 11.2.  For data packets\n   coming
    from outside the RPL network, the ingress router determines\n   the RPLInstanceID
    and places it into the resulting packet that it\n   injects into the RPL network.\n"
  - contents:
    - "5.1.  RPL Instance ID\n   A global RPLInstanceID MUST be unique to the whole
      LLN.  Mechanisms\n   for allocating and provisioning global RPLInstanceID are
      out of scope\n   for this specification.  There can be up to 128 Global instance
      in\n   the whole network.  Local instances are always used in conjunction\n
      \  with a DODAGID (which is either given explicitly or implicitly in\n   some
      cases), and up 64 Local instances per DODAGID can be supported.\n   Local instances
      are allocated and managed by the node that owns the\n   DODAGID, without any
      explicit coordination with other nodes, as\n   further detailed below.\n   A
      global RPLInstanceID is encoded in a RPLInstanceID field as\n   follows:\n        0
      1 2 3 4 5 6 7\n       +-+-+-+-+-+-+-+-+\n       |0|     ID      |  Global RPLInstanceID
      in 0..127\n       +-+-+-+-+-+-+-+-+\n         Figure 4: RPLInstanceID Field
      Format for Global Instances\n   A local RPLInstanceID is autoconfigured by the
      node that owns the\n   DODAGID and it MUST be unique for that DODAGID.  The
      DODAGID used to\n   configure the local RPLInstanceID MUST be a reachable IPv6
      address of\n   the node, and it MUST be used as an endpoint of all communications\n
      \  within that Local instance.\n   A local RPLInstanceID is encoded in a RPLInstanceID
      field as follows:\n        0 1 2 3 4 5 6 7\n       +-+-+-+-+-+-+-+-+\n       |1|D|
      \  ID      |  Local RPLInstanceID in 0..63\n       +-+-+-+-+-+-+-+-+\n         Figure
      5: RPLInstanceID Field Format for Local Instances\n   The 'D' flag in a local
      RPLInstanceID is always set to 0 in RPL\n   control messages.  It is used in
      data packets to indicate whether the\n   DODAGID is the source or the destination
      of the packet.  If the 'D'\n   flag is set to 1, then the destination address
      of the IPv6 packet\n   MUST be the DODAGID.  If the 'D' flag is cleared, then
      the source\n   address of the IPv6 packet MUST be the DODAGID.\n   For example,
      consider a Node A that is the DODAG root of a Local RPL\n   Instance, and has
      allocated a local RPLInstanceID.  By definition,\n   all traffic traversing
      that Local RPL Instance will either originate\n   or terminate at Node A.  In
      this case, the DODAGID will be the\n   reachable IPv6 address of Node A.  All
      traffic will contain the\n   address of Node A, and thus the DODAGID, in either
      the source or\n   destination address.  Thus, the local RPLInstanceID may indicate
      that\n   the DODAGID is equivalent to either the source address or the\n   destination
      address by setting the 'D' flag appropriately.\n"
    title: 5.1.  RPL Instance ID
  title: 5.  RPL Instance
- contents:
  - "6.  ICMPv6 RPL Control Message\n   This document defines the RPL control message,
    a new ICMPv6 [RFC4443]\n   message.  A RPL control message is identified by a
    code and composed\n   of a base that depends on the code (and a series of options).\n
    \  Most RPL control messages have the scope of a link.  The only\n   exception
    is for the DAO / DAO-ACK messages in Non-Storing mode,\n   which are exchanged
    using a unicast address over multiple hops and\n   thus uses global or unique-local
    addresses for both the source and\n   destination addresses.  For all other RPL
    control messages, the\n   source address is a link-local address, and the destination
    address\n   is either the all-RPL-nodes multicast address or a link-local unicast\n
    \  address of the destination.  The all-RPL-nodes multicast address is a\n   new
    address with a value of ff02::1a.\n   In accordance with [RFC4443], the RPL Control
    Message consists of an\n   ICMPv6 header followed by a message body.  The message
    body is\n   comprised of a message base and possibly a number of options as\n
    \  illustrated in Figure 6.\n        0                   1                   2
    \                  3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3
    4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \      |     Type      |     Code      |          Checksum             |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \      |                                                               |\n       .
    \                            Base                              .\n       .                                                               .\n
    \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |
    \                                                              |\n       .                           Option(s)
    \                          .\n       .                                                               .\n
    \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                       Figure
    6: RPL Control Message\n   The RPL control message is an ICMPv6 information message
    with a Type\n   of 155.\n   The Code field identifies the type of RPL control
    message.  This\n   document defines codes for the following RPL control message
    types\n   (see Section 20.2)):\n   o  0x00: DODAG Information Solicitation (Section
    6.2)\n   o  0x01: DODAG Information Object (Section 6.3)\n   o  0x02: Destination
    Advertisement Object (Section 6.4)\n   o  0x03: Destination Advertisement Object
    Acknowledgment\n      (Section 6.5)\n   o  0x80: Secure DODAG Information Solicitation
    (Section 6.2.2)\n   o  0x81: Secure DODAG Information Object (Section 6.3.2)\n
    \  o  0x82: Secure Destination Advertisement Object (Section 6.4.2)\n   o  0x83:
    Secure Destination Advertisement Object Acknowledgment\n      (Section 6.5.2)\n
    \  o  0x8A: Consistency Check (Section 6.6)\n   If a node receives a RPL control
    message with an unknown Code field,\n   the node MUST discard the message without
    any further processing, MAY\n   raise a management alert, and MUST NOT send any
    messages in response.\n   The checksum is computed as specified in [RFC4443].
    \ It is set to\n   zero for the RPL security operations specified below and computed\n
    \  once the rest of the content of the RPL message including the\n   security
    fields is all set.\n   The high order bit (0x80) of the code denotes whether the
    RPL message\n   has security enabled.  Secure RPL messages have a format to support\n
    \  confidentiality and integrity, illustrated in Figure 7.\n        0                   1
    \                  2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3
    4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \      |     Type      |     Code      |          Checksum             |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
    \      |                                                               |\n       .
    \                          Security                            .\n       .                                                               .\n
    \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |
    \                                                              |\n       .                             Base
    \                             .\n       .                                                               .\n
    \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |
    \                                                              |\n       .                           Option(s)
    \                          .\n       .                                                               .\n
    \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                   Figure
    7: Secure RPL Control Message\n   The remainder of this section describes the
    currently defined RPL\n   control message Base formats followed by the currently
    defined RPL\n   Control Message options.\n"
  - contents:
    - "6.1.  RPL Security Fields\n   Each RPL message has a secure variant.  The secure
      variants provide\n   integrity and replay protection as well as optional confidentiality\n
      \  and delay protection.  Because security covers the base message as\n   well
      as options, in secured messages the security information lies\n   between the
      checksum and base, as shown in Figure 7.\n   The level of security and the algorithms
      in use are indicated in the\n   protocol messages as described below:\n        0
      \                  1                   2                   3\n        0 1 2
      3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \      |T|  Reserved   |   Algorithm   |KIM|Resvd| LVL |     Flags     |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \      |                            Counter                            |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \      |                                                               |\n       .
      \                       Key Identifier                         .\n       .                                                               .\n
      \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                        Figure
      8: Security Section\n   Message Authentication Codes (MACs) and signatures provide\n
      \  authentication over the entire unsecured ICMPv6 RPL control message,\n   including
      the Security section with all fields defined, but with the\n   ICMPv6 checksum
      temporarily set to zero.  Encryption provides\n   confidentiality of the secured
      RPL ICMPv6 message starting at the\n   first byte after the Security section
      and continuing to the last byte\n   of the packet.  The security transformation
      yields a secured ICMPv6\n   RPL message with the inclusion of the cryptographic
      fields (MAC,\n   signature, etc.).  In other words, the security transformation
      itself\n   (e.g., the Signature and/or Algorithm in use) will detail how to\n
      \  incorporate the cryptographic fields into the secured packet.  The\n   Security
      section itself does not explicitly carry those cryptographic\n   fields.  Use
      of the Security section is further detailed in Sections\n   19 and 10.\n   Counter
      is Time (T): If the counter's Time flag is set, then the\n         Counter field
      is a timestamp.  If the flag is cleared, then the\n         counter is an incrementing
      counter.  Section 10.5 describes the\n         details of the 'T' flag and Counter
      field.\n   Reserved: 7-bit unused field.  The field MUST be initialized to zero\n
      \        by the sender and MUST be ignored by the receiver.\n   Security Algorithm
      (Algorithm): The Security Algorithm field\n         specifies the encryption,
      MAC, and signature scheme the network\n         uses.  Supported values of this
      field are as follows:\n         +-----------+-------------------+------------------------+\n
      \        | Algorithm |  Encryption/MAC   |        Signature       |\n         +-----------+-------------------+------------------------+\n
      \        |     0     | CCM with AES-128  |      RSA with SHA-256  |\n         |
      \  1-255   |    Unassigned     |        Unassigned      |\n         +-----------+-------------------+------------------------+\n
      \            Figure 9: Security Algorithm (Algorithm) Encoding\n   Section 10.9
      describes the algorithms in greater detail.\n   Key Identifier Mode (KIM): The
      Key Identifier Mode is a 2-bit field\n         that indicates whether the key
      used for packet protection is\n         determined implicitly or explicitly
      and indicates the\n         particular representation of the Key Identifier
      field.  The Key\n         Identifier Mode is set one of the values from the
      table below:\n          +------+-----+-----------------------------+------------+\n
      \         | Mode | KIM |           Meaning           |    Key     |\n          |
      \     |     |                             | Identifier |\n          |      |
      \    |                             |   Length   |\n          |      |     |
      \                            |  (octets)  |\n          +------+-----+-----------------------------+------------+\n
      \         |  0   | 00  | Group key used.             |     1      |\n          |
      \     |     | Key determined by Key Index |            |\n          |      |
      \    | field.                      |            |\n          |      |     |
      \                            |            |\n          |      |     | Key Source
      is not present.  |            |\n          |      |     | Key Index is present.
      \      |            |\n          +------+-----+-----------------------------+------------+\n
      \         |  1   | 01  | Per-pair key used.          |     0      |\n          |
      \     |     | Key determined by source    |            |\n          |      |
      \    | and destination of packet.  |            |\n          |      |     |
      \                            |            |\n          |      |     | Key Source
      is not present.  |            |\n          |      |     | Key Index is not present.
      \  |            |\n          +------+-----+-----------------------------+------------+\n
      \         |  2   | 10  | Group key used.             |     9      |\n          |
      \     |     | Key determined by Key Index |            |\n          |      |
      \    | and Key Source Identifier.  |            |\n          |      |     |
      \                            |            |\n          |      |     | Key Source
      is present.      |            |\n          |      |     | Key Index is present.
      \      |            |\n          +------+-----+-----------------------------+------------+\n
      \         |  3   | 11  | Node's signature key used.  |    0/9     |\n          |
      \     |     | If packet is encrypted,     |\n          |      |     | it uses
      a group key, Key    |            |\n          |      |     | Index and Key Source
      \       |            |\n          |      |     | specify key.                |
      \           |\n          |      |     |                             |            |\n
      \         |      |     | Key Source may be present.  |            |\n          |
      \     |     | Key Index may be present.   |            |\n          +------+-----+-----------------------------+------------+\n
      \              Figure 10: Key Identifier Mode (KIM) Encoding\n   In Mode 3 (KIM=11),
      the presence or absence of the Key Source and Key\n   Identifier depends on
      the Security Level (LVL) described below.  If\n   the Security Level indicates
      there is encryption, then the fields are\n   present; if it indicates there
      is no encryption, then the fields are\n   not present.\n   Resvd: 3-bit unused
      field.  The field MUST be initialized to zero by\n         the sender and MUST
      be ignored by the receiver.\n   Security Level (LVL):  The Security Level is
      a 3-bit field that\n         indicates the provided packet protection.  This
      value can be\n         adapted on a per-packet basis and allows for varying
      levels of\n         data authenticity and, optionally, for data confidentiality.\n
      \        The KIM field indicates whether signatures are used and the\n         meaning
      of the Level field.  Note that the assigned values of\n         Security Level
      are not necessarily ordered -- a higher value of\n         LVL does not necessarily
      equate to increased security.  The\n         Security Level is set to one of
      the values in the tables below:\n                      +---------------------------+\n
      \                     |         KIM=0,1,2         |\n              +-------+--------------------+------+\n
      \             |  LVL  |     Attributes     | MAC  |\n              |       |
      \                   | Len  |\n              +-------+--------------------+------+\n
      \             |   0   |       MAC-32       |  4   |\n              |   1   |
      \    ENC-MAC-32     |  4   |\n              |   2   |       MAC-64       |  8
      \  |\n              |   3   |     ENC-MAC-64     |  8   |\n              |  4-7
      \ |     Unassigned     | N/A  |\n              +-------+--------------------+------+\n
      \                           +---------------------+\n                            |
      \       KIM=3        |\n                    +-------+---------------+-----+\n
      \                   |  LVL  |  Attributes   | Sig |\n                    |       |
      \              | Len |\n                    +-------+---------------+-----+\n
      \                   |   0   |   Sign-3072   | 384 |\n                    |   1
      \  | ENC-Sign-3072 | 384 |\n                    |   2   |   Sign-2048   | 256
      |\n                    |   3   | ENC-Sign-2048 | 256 |\n                    |
      \ 4-7  |  Unassigned   | N/A |\n                    +-------+---------------+-----+\n
      \                Figure 11: Security Level (LVL) Encoding\n   The MAC attribute
      indicates that the message has a MAC of the\n   specified length.  The ENC attribute
      indicates that the message is\n   encrypted.  The Sign attribute indicates that
      the message has a\n   signature of the specified length.\n   Flags: 8-bit unused
      field reserved for flags.  The field MUST be\n         initialized to zero by
      the sender and MUST be ignored by the\n         receiver.\n   Counter: The Counter
      field indicates the non-repeating 4-octet value\n         used to construct
      the cryptographic mechanism that implements\n         packet protection and
      allows for the provision of semantic\n         security.  See Section 10.9.1.\n
      \  Key Identifier: The Key Identifier field indicates which key was used\n         to
      protect the packet.  This field provides various levels of\n         granularity
      of packet protection, including peer-to-peer keys,\n         group keys, and
      signature keys.  This field is represented as\n         indicated by the Key
      Identifier Mode field and is formatted as\n         follows:\n        0                   1
      \                  2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1 2
      3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \      |                                                               |\n       .
      \                         Key Source                           .\n       .                                                               .\n
      \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n       |
      \                                                              |\n       .                           Key
      Index                           .\n       .                                                               .\n
      \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n                         Figure
      12: Key Identifier\n   Key Source: The Key Source field, when present, indicates
      the logical\n         identifier of the originator of a group key.  When present,\n
      \        this field is 8 bytes in length.\n   Key Index: The Key Index field,
      when present, allows unique\n         identification of different keys with
      the same originator.  It\n         is the responsibility of each key originator
      to make sure that\n         actively used keys that it issues have distinct
      key indices and\n         that all key indices have a value unequal to 0x00.
      \ Value 0x00\n         is reserved for a preinstalled, shared key.  When present
      this\n         field is 1 byte in length.\n   Unassigned bits of the Security
      section are reserved.  They MUST be\n   set to zero on transmission and MUST
      be ignored on reception.\n"
    title: 6.1.  RPL Security Fields
  - contents:
    - "6.2.  DODAG Information Solicitation (DIS)\n   The DODAG Information Solicitation
      (DIS) message may be used to\n   solicit a DODAG Information Object from a RPL
      node.  Its use is\n   analogous to that of a Router Solicitation as specified
      in IPv6\n   Neighbor Discovery; a node may use DIS to probe its neighborhood
      for\n   nearby DODAGs.  Section 8.3 describes how nodes respond to a DIS.\n"
    - contents:
      - "6.2.1.  Format of the DIS Base Object\n        0                   1                   2\n
        \       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |     Flags     |   Reserved    |   Option(s)...\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \                     Figure 13: The DIS Base Object\n   Flags: 8-bit unused
        field reserved for flags.  The field MUST be\n         initialized to zero
        by the sender and MUST be ignored by the\n         receiver.\n   Reserved:
        8-bit unused field.  The field MUST be initialized to zero\n         by the
        sender and MUST be ignored by the receiver.\n   Unassigned bits of the DIS
        Base are reserved.  They MUST be set to\n   zero on transmission and MUST
        be ignored on reception.\n"
      title: 6.2.1.  Format of the DIS Base Object
    - contents:
      - "6.2.2.  Secure DIS\n   A Secure DIS message follows the format in Figure
        7, where the base\n   format is the DIS message shown in Figure 13.\n"
      title: 6.2.2.  Secure DIS
    - contents:
      - "6.2.3.  DIS Options\n   The DIS message MAY carry valid options.\n   This
        specification allows for the DIS message to carry the following\n   options:\n
        \     0x00 Pad1\n      0x01 PadN\n      0x07 Solicited Information\n"
      title: 6.2.3.  DIS Options
    title: 6.2.  DODAG Information Solicitation (DIS)
  - contents:
    - "6.3.  DODAG Information Object (DIO)\n   The DODAG Information Object carries
      information that allows a node\n   to discover a RPL Instance, learn its configuration
      parameters,\n   select a DODAG parent set, and maintain the DODAG.\n"
    - contents:
      - "6.3.1.  Format of the DIO Base Object\n        0                   1                   2
        \                  3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      | RPLInstanceID |Version Number |             Rank              |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |G|0| MOP | Prf |     DTSN      |     Flags     |   Reserved    |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                                                               |\n
        \      +                                                               +\n
        \      |                                                               |\n
        \      +                            DODAGID                            +\n
        \      |                                                               |\n
        \      +                                                               +\n
        \      |                                                               |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |   Option(s)...\n       +-+-+-+-+-+-+-+-+\n                      Figure
        14: The DIO Base Object\n   Grounded (G): The Grounded 'G' flag indicates
        whether the DODAG\n         advertised can satisfy the application-defined
        goal.  If the\n         flag is set, the DODAG is grounded.  If the flag is
        cleared,\n         the DODAG is floating.\n   Mode of Operation (MOP): The
        Mode of Operation (MOP) field identifies\n         the mode of operation of
        the RPL Instance as administratively\n         provisioned at and distributed
        by the DODAG root.  All nodes\n         who join the DODAG must be able to
        honor the MOP in order to\n         fully participate as a router, or else
        they must only join as a\n         leaf.  MOP is encoded as in the figure
        below:\n           +-----+-----------------------------------------------------+\n
        \          | MOP | Description                                         |\n
        \          +-----+-----------------------------------------------------+\n
        \          |  0  | No Downward routes maintained by RPL                |\n
        \          |  1  | Non-Storing Mode of Operation                       |\n
        \          |  2  | Storing Mode of Operation with no multicast support |\n
        \          |  3  | Storing Mode of Operation with multicast support    |\n
        \          |     |                                                     |\n
        \          |     | All other values are unassigned                     |\n
        \          +-----+-----------------------------------------------------+\n
        \  A value of 0 indicates that destination advertisement messages are\n   disabled
        and the DODAG maintains only Upward routes.\n                Figure 15: Mode
        of Operation (MOP) Encoding\n   DODAGPreference (Prf): A 3-bit unsigned integer
        that defines how\n         preferable the root of this DODAG is compared to
        other DODAG\n         roots within the instance.  DAGPreference ranges from
        0x00\n         (least preferred) to 0x07 (most preferred).  The default is
        0\n         (least preferred).  Section 8.2 describes how DAGPreference\n
        \        affects DIO processing.\n   Version Number: 8-bit unsigned integer
        set by the DODAG root to the\n         DODAGVersionNumber.  Section 8.2 describes
        the rules for\n         DODAGVersionNumbers and how they affect DIO processing.\n
        \  Rank: 16-bit unsigned integer indicating the DODAG Rank of the node\n         sending
        the DIO message.  Section 8.2 describes how Rank is set\n         and how
        it affects DIO processing.\n   RPLInstanceID: 8-bit field set by the DODAG
        root that indicates of\n         which RPL Instance the DODAG is a part.\n
        \  Destination Advertisement Trigger Sequence Number (DTSN): 8-bit\n         unsigned
        integer set by the node issuing the DIO message.  The\n         Destination
        Advertisement Trigger Sequence Number (DTSN) flag\n         is used as part
        of the procedure to maintain Downward routes.\n         The details of this
        process are described in Section 9.\n   Flags: 8-bit unused field reserved
        for flags.  The field MUST be\n         initialized to zero by the sender
        and MUST be ignored by the\n         receiver.\n   Reserved: 8-bit unused
        field.  The field MUST be initialized to zero\n         by the sender and
        MUST be ignored by the receiver.\n   DODAGID: 128-bit IPv6 address set by
        a DODAG root that uniquely\n         identifies a DODAG.  The DODAGID MUST
        be a routable IPv6\n         address belonging to the DODAG root.\n   Unassigned
        bits of the DIO Base are reserved.  They MUST be set to\n   zero on transmission
        and MUST be ignored on reception.\n"
      title: 6.3.1.  Format of the DIO Base Object
    - contents:
      - "6.3.2.  Secure DIO\n   A Secure DIO message follows the format in Figure
        7, where the base\n   format is the DIO message shown in Figure 14.\n"
      title: 6.3.2.  Secure DIO
    - contents:
      - "6.3.3.  DIO Options\n   The DIO message MAY carry valid options.\n   This
        specification allows for the DIO message to carry the following\n   options:\n
        \     0x00 Pad1\n      0x01 PadN\n      0x02 DAG Metric Container\n      0x03
        Routing Information\n      0x04 DODAG Configuration\n      0x08 Prefix Information\n"
      title: 6.3.3.  DIO Options
    title: 6.3.  DODAG Information Object (DIO)
  - contents:
    - "6.4.  Destination Advertisement Object (DAO)\n   The Destination Advertisement
      Object (DAO) is used to propagate\n   destination information Upward along the
      DODAG.  In Storing mode, the\n   DAO message is unicast by the child to the
      selected parent(s).  In\n   Non-Storing mode, the DAO message is unicast to
      the DODAG root.  The\n   DAO message may optionally, upon explicit request or
      error, be\n   acknowledged by its destination with a Destination Advertisement\n
      \  Acknowledgement (DAO-ACK) message back to the sender of the DAO.\n"
    - contents:
      - "6.4.1.  Format of the DAO Base Object\n        0                   1                   2
        \                  3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      | RPLInstanceID |K|D|   Flags   |   Reserved    | DAOSequence   |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                                                               |\n
        \      +                                                               +\n
        \      |                                                               |\n
        \      +                            DODAGID*                           +\n
        \      |                                                               |\n
        \      +                                                               +\n
        \      |                                                               |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |   Option(s)...\n       +-+-+-+-+-+-+-+-+\n   The '*' denotes that
        the DODAGID is not always present, as described\n   below.\n                      Figure
        16: The DAO Base Object\n   RPLInstanceID: 8-bit field indicating the topology
        instance\n         associated with the DODAG, as learned from the DIO.\n   K:
        The 'K' flag indicates that the recipient is expected to send a\n         DAO-ACK
        back.  (See Section 9.3.)\n   D: The 'D' flag indicates that the DODAGID field
        is present.  This\n         flag MUST be set when a local RPLInstanceID is
        used.\n   Flags: The 6 bits remaining unused in the Flags field are reserved\n
        \        for flags.  The field MUST be initialized to zero by the sender\n
        \        and MUST be ignored by the receiver.\n   Reserved: 8-bit unused field.
        \ The field MUST be initialized to zero\n         by the sender and MUST be
        ignored by the receiver.\n   DAOSequence: Incremented at each unique DAO message
        from a node and\n         echoed in the DAO-ACK message.\n   DODAGID (optional):
        128-bit unsigned integer set by a DODAG root that\n         uniquely identifies
        a DODAG.  This field is only present when\n         the 'D' flag is set.  This
        field is typically only present when\n         a local RPLInstanceID is in
        use, in order to identify the\n         DODAGID that is associated with the
        RPLInstanceID.  When a\n         global RPLInstanceID is in use, this field
        need not be present.\n   Unassigned bits of the DAO Base are reserved.  They
        MUST be set to\n   zero on transmission and MUST be ignored on reception.\n"
      title: 6.4.1.  Format of the DAO Base Object
    - contents:
      - "6.4.2.  Secure DAO\n   A Secure DAO message follows the format in Figure
        7, where the base\n   format is the DAO message shown in Figure 16.\n"
      title: 6.4.2.  Secure DAO
    - contents:
      - "6.4.3.  DAO Options\n   The DAO message MAY carry valid options.\n   This
        specification allows for the DAO message to carry the following\n   options:\n
        \     0x00 Pad1\n      0x01 PadN\n      0x05 RPL Target\n      0x06 Transit
        Information\n      0x09 RPL Target Descriptor\n   A special case of the DAO
        message, termed a No-Path, is used in\n   Storing mode to clear Downward routing
        state that has been\n   provisioned through DAO operation.  The No-Path carries
        a Target\n   option and an associated Transit Information option with a lifetime\n
        \  of 0x00000000 to indicate a loss of reachability to that Target.\n"
      title: 6.4.3.  DAO Options
    title: 6.4.  Destination Advertisement Object (DAO)
  - contents:
    - "6.5.  Destination Advertisement Object Acknowledgement (DAO-ACK)\n   The DAO-ACK
      message is sent as a unicast packet by a DAO recipient (a\n   DAO parent or
      DODAG root) in response to a unicast DAO message.\n"
    - contents:
      - "6.5.1.  Format of the DAO-ACK Base Object\n        0                   1
        \                  2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      | RPLInstanceID |D|  Reserved   |  DAOSequence  |    Status     |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                                                               |\n
        \      +                                                               +\n
        \      |                                                               |\n
        \      +                            DODAGID*                           +\n
        \      |                                                               |\n
        \      +                                                               +\n
        \      |                                                               |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |   Option(s)...\n       +-+-+-+-+-+-+-+-+\n   The '*' denotes that
        the DODAGID is not always present, as described\n   below.\n                    Figure
        17: The DAO ACK Base Object\n   RPLInstanceID: 8-bit field indicating the
        topology instance\n         associated with the DODAG, as learned from the
        DIO.\n   D: The 'D' flag indicates that the DODAGID field is present.  This\n
        \        would typically only be set when a local RPLInstanceID is used.\n
        \  Reserved: The 7-bit field, reserved for flags.\n   DAOSequence: Incremented
        at each DAO message from a node, and echoed\n         in the DAO-ACK by the
        recipient.  The DAOSequence is used to\n         correlate a DAO message and
        a DAO ACK message and is not to be\n         confused with the Transit Information
        option Path Sequence that\n         is associated to a given Target Down the
        DODAG.\n   Status: Indicates the completion.  Status 0 is defined as unqualified\n
        \        acceptance in this specification.  The remaining status values\n
        \        are reserved as rejection codes.  No rejection status codes are\n
        \        defined in this specification, although status codes SHOULD be\n
        \        allocated according to the following guidelines in future\n         specifications:\n
        \          0:  Unqualified acceptance (i.e., the node receiving the\n               DAO-ACK
        is not rejected).\n       1-127:  Not an outright rejection; the node sending
        the DAO-ACK\n               is willing to act as a parent, but the receiving
        node is\n               suggested to find and use an alternate parent instead.\n
        \    127-255:  Rejection; the node sending the DAO-ACK is unwilling to\n               act
        as a parent.\n   DODAGID (optional): 128-bit unsigned integer set by a DODAG
        root that\n               uniquely identifies a DODAG.  This field is only
        present\n               when the 'D' flag is set.  Typically, this field is
        only\n               present when a local RPLInstanceID is in use in order
        to\n               identify the DODAGID that is associated with the\n               RPLInstanceID.
        \ When a global RPLInstanceID is in use,\n               this field need not
        be present.\n   Unassigned bits of the DAO-ACK Base are reserved.  They MUST
        be set\n   to zero on transmission and MUST be ignored on reception.\n"
      title: 6.5.1.  Format of the DAO-ACK Base Object
    - contents:
      - "6.5.2.  Secure DAO-ACK\n   A Secure DAO-ACK message follows the format in
        Figure 7, where the\n   base format is the DAO-ACK message shown in Figure
        17.\n"
      title: 6.5.2.  Secure DAO-ACK
    - contents:
      - "6.5.3.  DAO-ACK Options\n   This specification does not define any options
        to be carried by the\n   DAO-ACK message.\n"
      title: 6.5.3.  DAO-ACK Options
    title: 6.5.  Destination Advertisement Object Acknowledgement (DAO-ACK)
  - contents:
    - "6.6.  Consistency Check (CC)\n   The CC message is used to check secure message
      counters and issue\n   challenge-responses.  A CC message MUST be sent as a
      secured RPL\n   message.\n"
    - contents:
      - "6.6.1.  Format of the CC Base Object\n        0                   1                   2
        \                  3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      | RPLInstanceID |R|    Flags    |           CC Nonce            |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                                                               |\n
        \      +                                                               +\n
        \      |                                                               |\n
        \      +                            DODAGID                            +\n
        \      |                                                               |\n
        \      +                                                               +\n
        \      |                                                               |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                      Destination Counter                      |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |   Option(s)...\n       +-+-+-+-+-+-+-+-+\n                       Figure
        18: The CC Base Object\n   RPLInstanceID: 8-bit field indicating the topology
        instance\n         associated with the DODAG, as learned from the DIO.\n   R:
        The 'R' flag indicates whether the CC message is a response.  A\n         message
        with the 'R' flag cleared is a request; a message with\n         the 'R' flag
        set is a response.\n   Flags: The 7 bits remaining unused in the Flags field
        are reserved\n         for flags.  The field MUST be initialized to zero by
        the sender\n         and MUST be ignored by the receiver.\n   CC Nonce: 16-bit
        unsigned integer set by a CC request.  The\n         corresponding CC response
        includes the same CC nonce value as\n         the request.\n   DODAGID: 128-bit
        field, contains the identifier of the DODAG root.\n   Destination Counter:
        32-bit unsigned integer value indicating the\n         sender's estimate of
        the destination's current security counter\n         value.  If the sender
        does not have an estimate, it SHOULD set\n         the Destination Counter
        field to zero.\n   Unassigned bits of the CC Base are reserved.  They MUST
        be set to\n   zero on transmission and MUST be ignored on reception.\n   The
        Destination Counter value allows new or recovered nodes to\n   resynchronize
        through CC message exchanges.  This is important to\n   ensure that a Counter
        value is not repeated for a given security key\n   even in the event of devices
        recovering from a failure that created a\n   loss of Counter state.  For example,
        where a CC request or other RPL\n   message is received with an initialized
        counter within the message\n   Security section, the provision of the Incoming
        Counter within the CC\n   response message allows the requesting node to reset
        its Outgoing\n   Counter to a value greater than the last value received by
        the\n   responding node; the Incoming Counter will also be updated from the\n
        \  received CC response.\n"
      title: 6.6.1.  Format of the CC Base Object
    - contents:
      - "6.6.2.  CC Options\n   This specification allows for the CC message to carry
        the following\n   options:\n      0x00 Pad1\n      0x01 PadN\n"
      title: 6.6.2.  CC Options
    title: 6.6.  Consistency Check (CC)
  - contents:
    - '6.7.  RPL Control Message Options

      '
    - contents:
      - "6.7.1.  RPL Control Message Option Generic Format\n   RPL Control Message
        options all follow this format:\n        0                   1                   2\n
        \       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
        - - - - - - -\n       |  Option Type  | Option Length | Option Data\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
        - - - - - - -\n                   Figure 19: RPL Option Generic Format\n   Option
        Type: 8-bit identifier of the type of option.  The Option Type\n         values
        are assigned by IANA (see Section 20.4.)\n   Option Length: 8-bit unsigned
        integer, representing the length in\n         octets of the option, not including
        the Option Type and Length\n         fields.\n   Option Data: A variable length
        field that contains data specific to\n         the option.\n   When processing
        a RPL message containing an option for which the\n   Option Type value is
        not recognized by the receiver, the receiver\n   MUST silently ignore the
        unrecognized option and continue to process\n   the following option, correctly
        handling any remaining options in the\n   message.\n   RPL message options
        may have alignment requirements.  Following the\n   convention in IPv6, options
        with alignment requirements are aligned\n   in a packet such that multi-octet
        values within the Option Data field\n   of each option fall on natural boundaries
        (i.e., fields of width n\n   octets are placed at an integer multiple of n
        octets from the start\n   of the header, for n = 1, 2, 4, or 8).\n"
      title: 6.7.1.  RPL Control Message Option Generic Format
    - contents:
      - "6.7.2.  Pad1\n   The Pad1 option MAY be present in DIS, DIO, DAO, DAO-ACK,
        and CC\n   messages, and its format is as follows:\n        0\n        0 1
        2 3 4 5 6 7\n       +-+-+-+-+-+-+-+-+\n       |   Type = 0x00 |\n       +-+-+-+-+-+-+-+-+\n
        \                  Figure 20: Format of the Pad1 Option\n   The Pad1 option
        is used to insert a single octet of padding into the\n   message to enable
        options alignment.  If more than one octet of\n   padding is required, the
        PadN option should be used rather than\n   multiple Pad1 options.\n   NOTE!
        \ The format of the Pad1 option is a special case -- it has\n   neither Option
        Length nor Option Data fields.\n"
      title: 6.7.2.  Pad1
    - contents:
      - "6.7.3.  PadN\n   The PadN option MAY be present in DIS, DIO, DAO, DAO-ACK,
        and CC\n   messages, and its format is as follows:\n        0                   1
        \                  2\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        2 3\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -\n       |   Type
        = 0x01 | Option Length | 0x00 Padding...\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
        - - - - - - -\n                   Figure 21: Format of the Pad N Option\n
        \  The PadN option is used to insert two or more octets of padding into\n
        \  the message to enable options alignment.  PadN option data MUST be\n   ignored
        by the receiver.\n   Option Type: 0x01\n   Option Length: For N octets of
        padding, where 2 <= N <= 7, the Option\n         Length field contains the
        value N-2.  An Option Length of 0\n         indicates a total padding of 2
        octets.  An Option Length of 5\n         indicates a total padding of 7 octets,
        which is the maximum\n         padding size allowed with the PadN option.\n
        \  Option Data: For N (N > 1) octets of padding, the Option Data\n         consists
        of N-2 zero-valued octets.\n"
      title: 6.7.3.  PadN
    - contents:
      - "6.7.4.  DAG Metric Container\n   The DAG Metric Container option MAY be present
        in DIO or DAO\n   messages, and its format is as follows:\n        0                   1
        \                  2\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        2 3\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+- - - - - - - -\n       |   Type
        = 0x02 | Option Length | Metric Data\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-
        - - - - - - -\n           Figure 22: Format of the DAG Metric Container Option\n
        \  The DAG Metric Container is used to report metrics along the DODAG.\n   The
        DAG Metric Container may contain a number of discrete node, link,\n   and
        aggregate path metrics and constraints specified in [RFC6551] as\n   chosen
        by the implementer.\n   The DAG Metric Container MAY appear more than once
        in the same RPL\n   control message, for example, to accommodate a use case
        where the\n   Metric Data is longer than 256 bytes.  More information is in\n
        \  [RFC6551].\n   The processing and propagation of the DAG Metric Container
        is\n   governed by implementation specific policy functions.\n   Option Type:
        0x02\n   Option Length: The Option Length field contains the length in octets\n
        \        of the Metric Data.\n   Metric Data: The order, content, and coding
        of the DAG Metric\n         Container data is as specified in [RFC6551].\n"
      title: 6.7.4.  DAG Metric Container
    - contents:
      - "6.7.5.  Route Information\n   The Route Information Option (RIO) MAY be present
        in DIO messages,\n   and it carries the same information as the IPv6 Neighbor
        Discovery\n   (ND) RIO as defined in [RFC4191].  The root of a DODAG is\n
        \  authoritative for setting that information and the information is\n   unchanged
        as propagated down the DODAG.  A RPL router may trivially\n   transform it
        back into an ND option to advertise in its own RAs so a\n   node attached
        to the RPL router will end up using the DODAG for which\n   the root has the
        best preference for the destination of a packet.  In\n   addition to the existing
        ND semantics, it is possible for an\n   Objective Function to use this information
        to favor a DODAG whose\n   root is most preferred for a specific destination.
        \ The format of the\n   option is modified slightly (Type, Length, Prefix)
        in order to be\n   carried as a RPL option as follows:\n        0                   1
        \                  2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |   Type = 0x03 | Option Length | Prefix Length |Resvd|Prf|Resvd|\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                        Route Lifetime                         |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                                                               |\n
        \      .                   Prefix (Variable Length)                    .\n
        \      .                                                               .\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \            Figure 23: Format of the Route Information Option\n   The RIO
        is used to indicate that connectivity to the specified\n   destination prefix
        is available from the DODAG root.\n   In the event that a RPL control message
        may need to specify\n   connectivity to more than one destination, the RIO
        may be repeated.\n   [RFC4191] should be consulted as the authoritative reference
        with\n   respect to the RIO.  The field descriptions are transcribed here
        for\n   convenience:\n   Option Type: 0x03\n   Option Length: Variable, length
        of the option in octets excluding the\n         Type and Length fields.  Note
        that this length is expressed in\n         units of single octets, unlike
        in IPv6 ND.\n   Prefix Length: 8-bit unsigned integer.  The number of leading
        bits in\n         the prefix that are valid.  The value ranges from 0 to 128.\n
        \        The Prefix field has the number of bytes inferred from the\n         Option
        Length field, that must be at least the Prefix Length.\n         Note that
        in RPL, this means that the Prefix field may have\n         lengths other
        than 0, 8, or 16.\n   Prf: 2-bit signed integer.  The Route Preference indicates
        whether to\n         prefer the router associated with this prefix over others,
        when\n         multiple identical prefixes (for different routers) have been\n
        \        received.  If the Reserved (10) value is received, the RIO MUST\n
        \        be ignored.  Per [RFC4191], the Reserved (10) value MUST NOT be\n
        \        sent.  ([RFC4191] restricts the Preference to just three values\n
        \        to reinforce that it is not a metric.)\n   Resvd: Two 3-bit unused
        fields.  They MUST be initialized to zero by\n         the sender and MUST
        be ignored by the receiver.\n   Route Lifetime: 32-bit unsigned integer.  The
        length of time in\n         seconds (relative to the time the packet is sent)
        that the\n         prefix is valid for route determination.  A value of all
        one\n         bits (0xFFFFFFFF) represents infinity.\n   Prefix: Variable-length
        field containing an IP address or a prefix of\n         an IPv6 address.  The
        Prefix Length field contains the number\n         of valid leading bits in
        the prefix.  The bits in the prefix\n         after the prefix length (if
        any) are reserved and MUST be\n         initialized to zero by the sender
        and ignored by the receiver.\n         Note that in RPL, this field may have
        lengths other than 0, 8,\n         or 16.\n   Unassigned bits of the RIO are
        reserved.  They MUST be set to zero on\n   transmission and MUST be ignored
        on reception.\n"
      title: 6.7.5.  Route Information
    - contents:
      - "6.7.6.  DODAG Configuration\n   The DODAG Configuration option MAY be present
        in DIO messages, and\n   its format is as follows:\n        0                   1
        \                  2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |   Type = 0x04 |Opt Length = 14| Flags |A| PCS | DIOIntDoubl.  |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |  DIOIntMin.   |   DIORedun.   |        MaxRankIncrease        |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |      MinHopRankIncrease       |              OCP              |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |   Reserved    | Def. Lifetime |      Lifetime Unit            |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \           Figure 24: Format of the DODAG Configuration Option\n   The DODAG
        Configuration option is used to distribute configuration\n   information for
        DODAG Operation through the DODAG.\n   The information communicated in this
        option is generally static and\n   unchanging within the DODAG, therefore
        it is not necessary to include\n   in every DIO.  This information is configured
        at the DODAG root and\n   distributed throughout the DODAG with the DODAG
        Configuration option.\n   Nodes other than the DODAG root MUST NOT modify
        this information when\n   propagating the DODAG Configuration option.  This
        option MAY be\n   included occasionally by the DODAG root (as determined by
        the DODAG\n   root), and MUST be included in response to a unicast request,
        e.g. a\n   unicast DODAG Information Solicitation (DIS) message.\n   Option
        Type: 0x04\n   Option Length: 14\n   Flags: The 4-bits remaining unused in
        the Flags field are reserved\n         for flags.  The field MUST be initialized
        to zero by the sender\n         and MUST be ignored by the receiver.\n   Authentication
        Enabled (A): 1-bit flag describing the security mode\n         of the network.
        \ The bit describes whether a node must\n         authenticate with a key
        authority before joining the network as\n         a router.  If the DIO is
        not a secure DIO, the 'A' bit MUST be\n         zero.\n   Path Control Size
        (PCS): 3-bit unsigned integer used to configure the\n         number of bits
        that may be allocated to the Path Control field\n         (see Section 9.9).
        \ Note that when PCS is consulted to\n         determine the width of the
        Path Control field, a value of 1 is\n         added, i.e., a PCS value of
        0 results in 1 active bit in the\n         Path Control field.  The default
        value of PCS is\n         DEFAULT_PATH_CONTROL_SIZE.\n   DIOIntervalDoublings:
        8-bit unsigned integer used to configure Imax\n         of the DIO Trickle
        timer (see Section 8.3.1).  The default\n         value of DIOIntervalDoublings
        is\n         DEFAULT_DIO_INTERVAL_DOUBLINGS.\n   DIOIntervalMin: 8-bit unsigned
        integer used to configure Imin of the\n         DIO Trickle timer (see Section
        8.3.1).  The default value of\n         DIOIntervalMin is DEFAULT_DIO_INTERVAL_MIN.\n
        \  DIORedundancyConstant: 8-bit unsigned integer used to configure k of\n
        \        the DIO Trickle timer (see Section 8.3.1).  The default value\n         of
        DIORedundancyConstant is DEFAULT_DIO_REDUNDANCY_CONSTANT.\n   MaxRankIncrease:
        16-bit unsigned integer used to configure\n         DAGMaxRankIncrease, the
        allowable increase in Rank in support\n         of local repair.  If DAGMaxRankIncrease
        is 0, then this\n         mechanism is disabled.\n   MinHopRankIncrease: 16-bit
        unsigned integer used to configure\n         MinHopRankIncrease as described
        in Section 3.5.1.  The default\n         value of MinHopRankInc is DEFAULT_MIN_HOP_RANK_INCREASE.\n
        \  Objective Code Point (OCP): 16-bit unsigned integer.  The OCP field\n         identifies
        the OF and is managed by the IANA.\n   Reserved: 7-bit unused field.  The
        field MUST be initialized to zero\n         by the sender and MUST be ignored
        by the receiver.\n   Default Lifetime: 8-bit unsigned integer.  This is the
        lifetime that\n         is used as default for all RPL routes.  It is expressed
        in\n         units of Lifetime Units, e.g., the default lifetime in seconds\n
        \        is (Default Lifetime) * (Lifetime Unit).\n   Lifetime Unit: 16-bit
        unsigned integer.  Provides the unit in seconds\n         that is used to
        express route lifetimes in RPL.  For very\n         stable networks, it can
        be hours to days.\n"
      title: 6.7.6.  DODAG Configuration
    - contents:
      - "6.7.7.  RPL Target\n   The RPL Target option MAY be present in DAO messages,
        and its format\n   is as follows:\n        0                   1                   2
        \                  3\n        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
        2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |   Type = 0x05 | Option Length |     Flags     | Prefix Length |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                                                               |\n
        \      +                                                               +\n
        \      |                Target Prefix (Variable Length)                |\n
        \      .                                                               .\n
        \      .                                                               .\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \               Figure 25: Format of the RPL Target Option\n   The RPL Target
        option is used to indicate a Target IPv6 address,\n   prefix, or multicast
        group that is reachable or queried along the\n   DODAG.  In a DAO, the RPL
        Target option indicates reachability.\n   A RPL Target option MAY optionally
        be paired with a RPL Target\n   Descriptor option (Figure 30) that qualifies
        the target.\n   A set of one or more Transit Information options (Section
        6.7.8) MAY\n   directly follow a set of one or more Target options in a DAO
        message\n   (where each Target option MAY be paired with a RPL Target Descriptor\n
        \  option as above).  The structure of the DAO message, detailing how\n   Target
        options are used in conjunction with Transit Information\n   options is further
        described in Section 9.4.\n   The RPL Target option may be repeated as necessary
        to indicate\n   multiple targets.\n   Option Type: 0x05\n   Option Length:
        Variable, length of the option in octets excluding the\n         Type and
        Length fields.\n   Flags: 8-bit unused field reserved for flags.  The field
        MUST be\n         initialized to zero by the sender and MUST be ignored by
        the\n         receiver.\n   Prefix Length: 8-bit unsigned integer.  Number
        of valid leading bits\n         in the IPv6 Prefix.\n   Target Prefix: Variable-length
        field identifying an IPv6 destination\n         address, prefix, or multicast
        group.  The Prefix Length field\n         contains the number of valid leading
        bits in the prefix.  The\n         bits in the prefix after the prefix length
        (if any) are\n         reserved and MUST be set to zero on transmission and
        MUST be\n         ignored on receipt.\n"
      title: 6.7.7.  RPL Target
    - contents:
      - "6.7.8.  Transit Information\n   The Transit Information option MAY be present
        in DAO messages, and\n   its format is as follows:\n        0                   1
        \                  2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |   Type = 0x06 | Option Length |E|    Flags    | Path Control  |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      | Path Sequence | Path Lifetime |                               |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               +\n
        \      |                                                               |\n
        \      +                                                               +\n
        \      |                                                               |\n
        \      +                        Parent Address*                        +\n
        \      |                                                               |\n
        \      +                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                               |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  The '*' denotes that the DODAG Parent Address subfield is not always\n
        \  present, as described below.\n            Figure 26: Format of the Transit
        Information Option\n   The Transit Information option is used for a node to
        indicate\n   attributes for a path to one or more destinations.  The destinations\n
        \  are indicated by one or more Target options that immediately precede\n
        \  the Transit Information option(s).\n   The Transit Information option can
        be used for a node to indicate its\n   DODAG parents to an ancestor that is
        collecting DODAG routing\n   information, typically, for the purpose of constructing
        source\n   routes.  In the Non-Storing mode of operation, this ancestor will
        be\n   the DODAG root, and this option is carried by the DAO message.  In\n
        \  the Storing mode of operation, the DODAG Parent Address subfield is\n   not
        needed, since the DAO message is sent directly to the parent.\n   The option
        length is used to determine whether or not the DODAG\n   Parent Address subfield
        is present.\n   A non-storing node that has more than one DAO parent MAY include
        a\n   Transit Information option for each DAO parent as part of the non-\n
        \  storing destination advertisement operation.  The node may distribute\n
        \  the bits in the Path Control field among different groups of DAO\n   parents
        in order to signal a preference among parents.  That\n   preference may influence
        the decision of the DODAG root when\n   selecting among the alternate parents/paths
        for constructing Downward\n   routes.\n   One or more Transit Information
        options MUST be preceded by one or\n   more RPL Target options.  In this manner,
        the RPL Target option\n   indicates the child node, and the Transit Information
        option(s)\n   enumerates the DODAG parents.  The structure of the DAO message,\n
        \  further detailing how Target options are used in conjunction with\n   Transit
        Information options, is further described in Section 9.4.\n   A typical non-storing
        node will use multiple Transit Information\n   options, and it will send the
        DAO message thus formed directly to the\n   root.  A typical storing node
        will use one Transit Information option\n   with no parent field and will
        send the DAO message thus formed, with\n   additional adjustments, to Path
        Control as detailed later, to one or\n   multiple parents.\n   For example,
        in a Non-Storing mode of operation let Tgt(T) denote a\n   Target option for
        a Target T.  Let Trnst(P) denote a Transit\n   Information option that contains
        a parent address P.  Consider the\n   case of a non-storing Node N that advertises
        the self-owned targets\n   N1 and N2 and has parents P1, P2, and P3.  In that
        case, the DAO\n   message would be expected to contain the sequence ((Tgt(N1),\n
        \  Tgt(N2)), (Trnst(P1), Trnst(P2), Trnst(P3))), such that the group of\n
        \  Target options {N1, N2} is described by the Transit Information\n   options
        as having the parents {P1, P2, P3}.  The non-storing node\n   would then address
        that DAO message directly to the DODAG root and\n   forward that DAO message
        through one of the DODAG parents: P1, P2, or\n   P3.\n   Option Type: 0x06\n
        \  Option Length: Variable, depending on whether or not the DODAG Parent\n
        \        Address subfield is present.\n   External (E): 1-bit flag.  The 'E'
        flag is set to indicate that the\n         parent router redistributes external
        targets into the RPL\n         network.  An external Target is a Target that
        has been learned\n         through an alternate protocol.  The external targets
        are listed\n         in the Target options that immediately precede the Transit\n
        \        Information option.  An external Target is not expected to\n         support
        RPL messages and options.\n   Flags: The 7 bits remaining unused in the Flags
        field are reserved\n         for flags.  The field MUST be initialized to
        zero by the sender\n         and MUST be ignored by the receiver.\n   Path
        Control: 8-bit bit field.  The Path Control field limits the\n         number
        of DAO parents to which a DAO message advertising\n         connectivity to
        a specific destination may be sent, as well as\n         providing some indication
        of relative preference.  The limit\n         provides some bound on overall
        DAO message fan-out in the LLN.\n         The assignment and ordering of the
        bits in the Path Control\n         also serves to communicate preference.
        \ Not all of these bits\n         may be enabled as according to the PCS in
        the DODAG\n         Configuration.  The Path Control field is divided into
        four\n         subfields that contain two bits each: PC1, PC2, PC3, and PC4,\n
        \        as illustrated in Figure 27.  The subfields are ordered by\n         preference,
        with PC1 being the most preferred and PC4 being the\n         least preferred.
        \ Within a subfield, there is no order of\n         preference.  By grouping
        the parents (as in ECMP) and ordering\n         them, the parents may be associated
        with specific bits in the\n         Path Control field in a way that communicates
        preference.\n                                 0 1 2 3 4 5 6 7\n                                +-+-+-+-+-+-+-+-+\n
        \                               |PC1|PC2|PC3|PC4|\n                                +-+-+-+-+-+-+-+-+\n
        \         Figure 27: Path Control Preference Subfield Encoding\n   Path Sequence:
        8-bit unsigned integer.  When a RPL Target option is\n         issued by the
        node that owns the Target prefix (i.e., in a DAO\n         message), that
        node sets the Path Sequence and increments the\n         Path Sequence each
        time it issues a RPL Target option with\n         updated information.\n   Path
        Lifetime: 8-bit unsigned integer.  The length of time in\n         Lifetime
        Units (obtained from the Configuration option) that\n         the prefix is
        valid for route determination.  The period starts\n         when a new Path
        Sequence is seen.  A value of all one bits\n         (0xFF) represents infinity.
        \ A value of all zero bits (0x00)\n         indicates a loss of reachability.
        \ A DAO message that contains\n         a Transit Information option with
        a Path Lifetime of 0x00 for a\n         Target is referred as a No-Path (for
        that Target) in this\n         document.\n   Parent Address (optional): IPv6
        address of the DODAG parent of the\n         node originally issuing the Transit
        Information option.  This\n         field may not be present, as according
        to the DODAG Mode of\n         Operation (Storing or Non-Storing) and indicated
        by the Transit\n         Information option length.\n   Unassigned bits of
        the Transit Information option are reserved.  They\n   MUST be set to zero
        on transmission and MUST be ignored on reception.\n"
      title: 6.7.8.  Transit Information
    - contents:
      - "6.7.9.  Solicited Information\n   The Solicited Information option MAY be
        present in DIS messages, and\n   its format is as follows:\n        0                   1
        \                  2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |   Type = 0x07 |Opt Length = 19| RPLInstanceID |V|I|D|  Flags  |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                                                               |\n
        \      +                                                               +\n
        \      |                                                               |\n
        \      +                            DODAGID                            +\n
        \      |                                                               |\n
        \      +                                                               +\n
        \      |                                                               |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |Version Number |\n       +-+-+-+-+-+-+-+-+\n           Figure 28:
        Format of the Solicited Information Option\n   The Solicited Information option
        is used for a node to request DIO\n   messages from a subset of neighboring
        nodes.  The Solicited\n   Information option may specify a number of predicate
        criteria to be\n   matched by a receiving node.  This is used by the requester
        to limit\n   the number of replies from \"non-interesting\" nodes.  These
        predicates\n   affect whether a node resets its DIO Trickle timer, as described
        in\n   Section 8.3.\n   The Solicited Information option contains flags that
        indicate which\n   predicates a node should check when deciding whether to
        reset its\n   Trickle timer.  A node resets its Trickle timer when all predicates\n
        \  are true.  If a flag is set, then the RPL node MUST check the\n   associated
        predicate.  If a flag is cleared, then the RPL node MUST\n   NOT check the
        associated predicate.  (If a flag is cleared, the RPL\n   node assumes that
        the associated predicate is true.)\n   Option Type: 0x07\n   Option Length:
        19\n   V: The 'V' flag is the Version predicate.  The Version predicate is\n
        \        true if the receiver's DODAGVersionNumber matches the requested\n
        \        Version Number.  If the 'V' flag is cleared, then the Version\n         field
        is not valid and the Version field MUST be set to zero on\n         transmission
        and ignored upon receipt.\n   I: The 'I' flag is the InstanceID predicate.
        \ The InstanceID\n         predicate is true when the RPL node's current RPLInstanceID\n
        \        matches the requested RPLInstanceID.  If the 'I' flag is\n         cleared,
        then the RPLInstanceID field is not valid and the\n         RPLInstanceID
        field MUST be set to zero on transmission and\n         ignored upon receipt.\n
        \  D: The 'D' flag is the DODAGID predicate.  The DODAGID predicate is\n         true
        if the RPL node's parent set has the same DODAGID as the\n         DODAGID
        field.  If the 'D' flag is cleared, then the DODAGID\n         field is not
        valid and the DODAGID field MUST be set to zero on\n         transmission
        and ignored upon receipt.\n   Flags: The 5 bits remaining unused in the Flags
        field are reserved\n         for flags.  The field MUST be initialized to
        zero by the sender\n         and MUST be ignored by the receiver.\n   Version
        Number: 8-bit unsigned integer containing the value of\n         DODAGVersionNumber
        that is being solicited when valid.\n   RPLInstanceID: 8-bit unsigned integer
        containing the RPLInstanceID\n         that is being solicited when valid.\n
        \  DODAGID: 128-bit unsigned integer containing the DODAGID that is\n         being
        solicited when valid.\n   Unassigned bits of the Solicited Information option
        are reserved.\n   They MUST be set to zero on transmission and MUST be ignored
        on\n   reception.\n"
      title: 6.7.9.  Solicited Information
    - contents:
      - "6.7.10.  Prefix Information\n   The Prefix Information Option (PIO) MAY be
        present in DIO messages,\n   and carries the information that is specified
        for the IPv6 ND Prefix\n   Information option in [RFC4861], [RFC4862], and
        [RFC6275] for use by\n   RPL nodes and IPv6 hosts.  In particular, a RPL node
        may use this\n   option for the purpose of Stateless Address Autoconfiguration
        (SLAAC)\n   from a prefix advertised by a parent as specified in [RFC4862],
        and\n   advertise its own address as specified in [RFC6275].  The root of
        a\n   DODAG is authoritative for setting that information.  The information\n
        \  is propagated down the DODAG unchanged, with the exception that a RPL\n
        \  router may overwrite the Interface ID if the 'R' flag is set to\n   indicate
        its full address in the PIO.  The format of the option is\n   modified (Type,
        Length, Prefix) in order to be carried as a RPL\n   option as follows:\n   If
        the only desired effect of a received PIO in a DIO is to provide\n   the global
        address of the parent node to the receiving node, then the\n   sender resets
        the 'A' and 'L' bits and sets the 'R' bit.  Upon\n   receipt, the RPL will
        not autoconfigure an address or a connected\n   route from the prefix [RFC4862].
        \ As in all cases, when the 'L' bit\n   is not set, the RPL node MAY include
        the prefix in PIOs it sends to\n   its children.\n        0                   1
        \                  2                   3\n        0 1 2 3 4 5 6 7 8 9 0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |   Type = 0x08 |Opt Length = 30| Prefix Length |L|A|R|Reserved1|\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                         Valid Lifetime                        |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                       Preferred Lifetime                      |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                           Reserved2                           |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                                                               |\n
        \      +                                                               +\n
        \      |                                                               |\n
        \      +                            Prefix                             +\n
        \      |                                                               |\n
        \      +                                                               +\n
        \      |                                                               |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \           Figure 29: Format of the Prefix Information Option\n   The PIO
        may be used to distribute the prefix in use inside the DODAG,\n   e.g., for
        address autoconfiguration.\n   [RFC4861] and [RFC6275] should be consulted
        as the authoritative\n   reference with respect to the PIO.  The field descriptions
        are\n   transcribed here for convenience:\n   Option Type: 0x08\n   Option
        Length: 30.  Note that this length is expressed in units of\n         single
        octets, unlike in IPv6 ND.\n   Prefix Length: 8-bit unsigned integer.  The
        number of leading bits in\n         the Prefix field that are valid.  The
        value ranges from 0 to\n         128.  The Prefix Length field provides necessary
        information\n         for on-link determination (when combined with the 'L'
        flag in\n         the PIO).  It also assists with address autoconfiguration
        as\n         specified in [RFC4862], for which there may be more\n         restrictions
        on the prefix length.\n   L:    1-bit on-link flag.  When set, it indicates
        that this prefix\n         can be used for on-link determination.  When not
        set, the\n         advertisement makes no statement about on-link or off-link\n
        \        properties of the prefix.  In other words, if the 'L' flag is\n         not
        set, a RPL node MUST NOT conclude that an address derived\n         from the
        prefix is off-link.  That is, it MUST NOT update a\n         previous indication
        that the address is on-link.  A RPL node\n         acting as a router MUST
        NOT propagate a PIO with the 'L' flag\n         set.  A RPL node acting as
        a router MAY propagate a PIO with\n         the 'L' flag not set.\n   A:    1-bit
        autonomous address-configuration flag.  When set, it\n         indicates that
        this prefix can be used for stateless address\n         configuration as specified
        in [RFC4862].  When both protocols\n         (ND RAs and RPL DIOs) are used
        to carry PIOs on the same link,\n         it is possible to use either one
        for SLAAC by a RPL node.  It\n         is also possible to make either protocol
        ineligible for SLAAC\n         operation by forcing the 'A' flag to 0 for
        PIOs carried in that\n         protocol.\n   R:    1-bit router address flag.
        \ When set, it indicates that the\n         Prefix field contains a complete
        IPv6 address assigned to the\n         sending router that can be used as
        parent in a target option.\n         The indicated prefix is the first prefix
        length bits of the\n         Prefix field.  The router IPv6 address has the
        same scope and\n         conforms to the same lifetime values as the advertised
        prefix.\n         This use of the Prefix field is compatible with its use
        in\n         advertising the prefix itself, since Prefix Advertisement uses\n
        \        only the leading bits.  Interpretation of this flag bit is thus\n
        \        independent of the processing required for the on-link (L) and\n
        \        autonomous address-configuration (A) flag bits.\n   Reserved1: 5-bit
        unused field.  It MUST be initialized to zero by the\n         sender and
        MUST be ignored by the receiver.\n   Valid Lifetime: 32-bit unsigned integer.
        \ The length of time in\n         seconds (relative to the time the packet
        is sent) that the\n         prefix is valid for the purpose of on-link determination.
        \ A\n         value of all one bits (0xFFFFFFFF) represents infinity.  The\n
        \        Valid Lifetime is also used by [RFC4862].\n   Preferred Lifetime:
        32-bit unsigned integer.  The length of time in\n         seconds (relative
        to the time the packet is sent) that\n         addresses generated from the
        prefix via stateless address\n         autoconfiguration remain preferred
        [RFC4862].  A value of all\n         one bits (0xFFFFFFFF) represents infinity.
        \ See [RFC4862].\n         Note that the value of this field MUST NOT exceed
        the Valid\n         Lifetime field to avoid preferring addresses that are
        no longer\n         valid.\n   Reserved2: This field is unused.  It MUST be
        initialized to zero by\n         the sender and MUST be ignored by the receiver.\n
        \  Prefix: An IPv6 address or a prefix of an IPv6 address.  The Prefix\n         Length
        field contains the number of valid leading bits in the\n         prefix.  The
        bits in the prefix after the prefix length are\n         reserved and MUST
        be initialized to zero by the sender and\n         ignored by the receiver.
        \ A router SHOULD NOT send a prefix\n         option for the link-local prefix,
        and a host SHOULD ignore such\n         a prefix option.  A non-storing node
        SHOULD refrain from\n         advertising a prefix till it owns an address
        of that prefix,\n         and then it SHOULD advertise its full address in
        this field,\n         with the 'R' flag set.  The children of a node that
        so\n         advertises a full address with the 'R' flag set may then use\n
        \        that address to determine the content of the DODAG Parent\n         Address
        subfield of the Transit Information option.\n   Unassigned bits of the PIO
        are reserved.  They MUST be set to zero on\n   transmission and MUST be ignored
        on reception.\n"
      title: 6.7.10.  Prefix Information
    - contents:
      - "6.7.11.  RPL Target Descriptor\n   The RPL Target option MAY be immediately
        followed by one opaque\n   descriptor that qualifies that specific target.\n
        \       0                   1                   2                   3\n        0
        1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |   Type = 0x09 |Opt Length = 4 |           Descriptor\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \             Descriptor (cont.)       |\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \          Figure 30: Format of the RPL Target Descriptor Option\n   The RPL
        Target Descriptor option is used to qualify a target,\n   something that is
        sometimes called \"tagging\".\n   At most, there can be one descriptor per
        target.  The descriptor is\n   set by the node that injects the Target in
        the RPL network.  It MUST\n   be copied but not modified by routers that propagate
        the Target Up\n   the DODAG in DAO messages.\n   Option Type: 0x09\n   Option
        Length: 4\n   Descriptor: 32-bit unsigned integer.  Opaque.\n"
      title: 6.7.11.  RPL Target Descriptor
    title: 6.7.  RPL Control Message Options
  title: 6.  ICMPv6 RPL Control Message
- contents:
  - "7.  Sequence Counters\n   This section describes the general scheme for bootstrap
    and operation\n   of sequence counters in RPL, such as the DODAGVersionNumber
    in the\n   DIO message, the DAOSequence in the DAO message, and the Path\n   Sequence
    in the Transit Information option.\n"
  - contents:
    - "7.1.  Sequence Counter Overview\n   This specification utilizes three different
      sequence numbers to\n   validate the freshness and the synchronization of protocol\n
      \  information:\n   DODAGVersionNumber: This sequence counter is present in
      the DIO Base\n         to indicate the Version of the DODAG being formed.  The\n
      \        DODAGVersionNumber is monotonically incremented by the root\n         each
      time the root decides to form a new Version of the DODAG\n         in order
      to revalidate the integrity and allow a global repair\n         to occur.  The
      DODAGVersionNumber is propagated unchanged Down\n         the DODAG as routers
      join the new DODAG Version.  The\n         DODAGVersionNumber is globally significant
      in a DODAG and\n         indicates the Version of the DODAG in which a router
      is\n         operating.  An older (lesser) value indicates that the\n         originating
      router has not migrated to the new DODAG Version\n         and cannot be used
      as a parent once the receiving node has\n         migrated to the newer DODAG
      Version.\n   DAOSequence: This sequence counter is present in the DAO Base to\n
      \        correlate a DAO message and a DAO ACK message.  The DAOSequence\n         number
      is locally significant to the node that issues a DAO\n         message for its
      own consumption to detect the loss of a DAO\n         message and enable retries.\n
      \  Path Sequence: This sequence counter is present in the Transit\n         Information
      option in a DAO message.  The purpose of this\n         counter is to differentiate
      a movement where a newer route\n         supersedes a stale one from a route
      redundancy scenario where\n         multiple routes exist in parallel for the
      same target.  The\n         Path Sequence is globally significant in a DODAG
      and indicates\n         the freshness of the route to the associated target.
      \ An older\n         (lesser) value received from an originating router indicates\n
      \        that the originating router holds stale routing states and the\n         originating
      router should not be considered anymore as a\n         potential next hop for
      the target.  The Path Sequence is\n         computed by the node that advertises
      the target, that is the\n         Target itself or a router that advertises
      a Target on behalf of\n         a host, and is unchanged as the DAO content
      is propagated\n         towards the root by parent routers.  If a host does
      not pass a\n         counter to its router, then the router is in charge of\n
      \        computing the Path Sequence on behalf of the host and the host\n         can
      only register to one router for that purpose.  If a DAO\n         message containing
      the same Target is issued to multiple\n         parents at a given point in
      time for the purpose of route\n         redundancy, then the Path Sequence is
      the same in all the DAO\n         messages for that same target.\n"
    title: 7.1.  Sequence Counter Overview
  - contents:
    - "7.2.  Sequence Counter Operation\n   RPL sequence counters are subdivided in
      a 'lollipop' fashion\n   [Perlman83], where the values from 128 and greater
      are used as a\n   linear sequence to indicate a restart and bootstrap the counter,
      and\n   the values less than or equal to 127 used as a circular sequence\n   number
      space of size 128 as in [RFC1982].  Consideration is given to\n   the mode of
      operation when transitioning from the linear region to\n   the circular region.
      \ Finally, when operating in the circular region,\n   if sequence numbers are
      detected to be too far apart, then they are\n   not comparable, as detailed
      below.\n   A window of comparison, SEQUENCE_WINDOW = 16, is configured based
      on\n   a value of 2^N, where N is defined to be 4 in this specification.\n   For
      a given sequence counter:\n   1.  The sequence counter SHOULD be initialized
      to an implementation\n       defined value, which is 128 or greater prior to
      use.  A\n       recommended value is 240 (256 - SEQUENCE_WINDOW).\n   2.  When
      a sequence counter increment would cause the sequence\n       counter to increment
      beyond its maximum value, the sequence\n       counter MUST wrap back to zero.
      \ When incrementing a sequence\n       counter greater than or equal to 128,
      the maximum value is 255.\n       When incrementing a sequence counter less
      than 128, the maximum\n       value is 127.\n   3.  When comparing two sequence
      counters, the following rules MUST be\n       applied:\n       1.  When a first
      sequence counter A is in the interval [128..255]\n           and a second sequence
      counter B is in [0..127]:\n           1.  If (256 + B - A) is less than or equal
      to\n               SEQUENCE_WINDOW, then B is greater than A, A is less than\n
      \              B, and the two are not equal.\n           2.  If (256 + B - A)
      is greater than SEQUENCE_WINDOW, then A\n               is greater than B, B
      is less than A, and the two are not\n               equal.\n           For example,
      if A is 240, and B is 5, then (256 + 5 - 240) is\n           21. 21 is greater
      than SEQUENCE_WINDOW (16); thus, 240 is\n           greater than 5.  As another
      example, if A is 250 and B is 5,\n           then (256 + 5 - 250) is 11. 11
      is less than SEQUENCE_WINDOW\n           (16); thus, 250 is less than 5.\n       2.
      \ In the case where both sequence counters to be compared are\n           less
      than or equal to 127, and in the case where both\n           sequence counters
      to be compared are greater than or equal to\n           128:\n           1.
      \ If the absolute magnitude of difference between the two\n               sequence
      counters is less than or equal to\n               SEQUENCE_WINDOW, then a comparison
      as described in\n               [RFC1982] is used to determine the relationships
      greater\n               than, less than, and equal.\n           2.  If the absolute
      magnitude of difference of the two\n               sequence counters is greater
      than SEQUENCE_WINDOW, then a\n               desynchronization has occurred
      and the two sequence\n               numbers are not comparable.\n   4.  If
      two sequence numbers are determined not to be comparable,\n       i.e., the
      results of the comparison are not defined, then a node\n       should consider
      the comparison as if it has evaluated in such a\n       way so as to give precedence
      to the sequence number that has most\n       recently been observed to increment.
      \ Failing this, the node\n       should consider the comparison as if it has
      evaluated in such a\n       way so as to minimize the resulting changes to its
      own state.\n"
    title: 7.2.  Sequence Counter Operation
  title: 7.  Sequence Counters
- contents:
  - "8.  Upward Routes\n   This section describes how RPL discovers and maintains
    Upward routes.\n   It describes the use of DODAG Information Objects (DIOs), the\n
    \  messages used to discover and maintain these routes.  It specifies\n   how
    RPL generates and responds to DIOs.  It also describes DODAG\n   Information Solicitation
    (DIS) messages, which are used to trigger\n   DIO transmissions.\n   As mentioned
    in Section 3.2.8, nodes that decide to join a DODAG MUST\n   provision at least
    one DODAG parent as a default route for the\n   associated instance.  This default
    route enables a packet to be\n   forwarded Upward until it eventually hits a common
    ancestor from\n   which it will be routed Downward to the destination.  If the\n
    \  destination is not in the DODAG, then the DODAG root may be able to\n   forward
    the packet using connectivity to the outside of the DODAG; if\n   it cannot forward
    the packet outside, then the DODAG root has to drop\n   it.\n   A DIO message
    can also transport explicit routing information:\n   DODAGID: The DODAGID is a
    Global or Unique Local IPv6 address of the\n         root.  A node that joins
    a DODAG SHOULD provision a host route\n         via a DODAG parent to the address
    used by the root as the\n         DODAGID.\n   RIO Prefix: The root MAY place
    one or more Route Information options\n         in a DIO message.  The RIO is
    used to advertise an external\n         route that is reachable via the root,
    associated with a\n         preference, as presented in Section 6.7.5, which incorporates\n
    \        the RIO from [RFC4191].  It is interpreted as a capability of\n         the
    root as opposed to a routing advertisement, and it MUST NOT\n         be redistributed
    in another routing protocol though it SHOULD\n         be used by an ingress RPL
    router to select a DODAG when a\n         packet is injected in a RPL domain from
    a node attached to that\n         RPL router.  An Objective Function MAY use the
    routes\n         advertised in RIO or the preference for those routes in order\n
    \        to favor a DODAG versus another one for the same instance.\n"
  - contents:
    - "8.1.  DIO Base Rules\n   1.  For the following DIO Base fields, a node that
      is not a DODAG\n       root MUST advertise the same values as its preferred
      DODAG parent\n       (defined in Section 8.2.1).  In this way, these values
      will\n       propagate Down the DODAG unchanged and advertised by every node\n
      \      that has a route to that DODAG root.  These fields are as\n       follows:\n
      \      1.  Grounded (G)\n       2.  Mode of Operation (MOP)\n       3.  DAGPreference
      (Prf)\n       4.  Version\n       5.  RPLInstanceID\n       6.  DODAGID\n   2.
      \ A node MAY update the following fields at each hop:\n       1.  Rank\n       2.
      \ DTSN\n   3.  The DODAGID field each root sets MUST be unique within the RPL\n
      \      Instance and MUST be a routable IPv6 address belonging to the\n       root.\n"
    title: 8.1.  DIO Base Rules
  - contents:
    - "8.2.  Upward Route Discovery and Maintenance\n   Upward route discovery allows
      a node to join a DODAG by discovering\n   neighbors that are members of the
      DODAG of interest and identifying a\n   set of parents.  The exact policies
      for selecting neighbors and\n   parents is implementation dependent and driven
      by the OF.  This\n   section specifies the set of rules those policies must
      follow for\n   interoperability.\n"
    - contents:
      - "8.2.1.  Neighbors and Parents within a DODAG Version\n   RPL's Upward route
        discovery algorithms and processing are in terms\n   of three logical sets
        of link-local nodes.  First, the candidate\n   neighbor set is a subset of
        the nodes that can be reached via link-\n   local multicast.  The selection
        of this set is implementation and OF\n   dependent.  Second, the parent set
        is a restricted subset of the\n   candidate neighbor set.  Finally, the preferred
        parent is a member of\n   the parent set that is the preferred next hop in
        Upward routes.\n   Conceptually, the preferred parent is a single parent;
        although, it\n   may be a set of multiple parents if those parents are equally\n
        \  preferred and have identical Rank.\n   More precisely:\n   1.  The DODAG
        parent set MUST be a subset of the candidate neighbor\n       set.\n   2.
        \ A DODAG root MUST have a DODAG parent set of size zero.\n   3.  A node that
        is not a DODAG root MAY maintain a DODAG parent set\n       of size greater
        than or equal to one.\n   4.  A node's preferred DODAG parent MUST be a member
        of its DODAG\n       parent set.\n   5.  A node's Rank MUST be greater than
        all elements of its DODAG\n       parent set.\n   6.  When Neighbor Unreachability
        Detection (NUD) [RFC4861], or an\n       equivalent mechanism, determines
        that a neighbor is no longer\n       reachable, a RPL node MUST NOT consider
        this node in the\n       candidate neighbor set when calculating and advertising
        routes\n       until it determines that it is again reachable.  Routes through\n
        \      an unreachable neighbor MUST be removed from the routing table.\n   These
        rules ensure that there is a consistent partial order on nodes\n   within
        the DODAG.  As long as node Ranks do not change, following the\n   above rules
        ensures that every node's route to a DODAG root is loop-\n   free, as Rank
        decreases on each hop to the root.\n   The OF can guide candidate neighbor
        set and parent set selection, as\n   discussed in [RFC6552].\n"
      title: 8.2.1.  Neighbors and Parents within a DODAG Version
    - contents:
      - "8.2.2.  Neighbors and Parents across DODAG Versions\n   The above rules govern
        a single DODAG Version.  The rules in this\n   section define how RPL operates
        when there are multiple DODAG\n   Versions.\n"
      - contents:
        - "8.2.2.1.  DODAG Version\n   1.  The tuple (RPLInstanceID, DODAGID, DODAGVersionNumber)
          uniquely\n       defines a DODAG Version.  Every element of a node's DODAG
          parent\n       set, as conveyed by the last heard DIO message from each
          DODAG\n       parent, MUST belong to the same DODAG Version.  Elements of
          a\n       node's candidate neighbor set MAY belong to different DODAG\n
          \      Versions.\n   2.  A node is a member of a DODAG Version if every
          element of its\n       DODAG parent set belongs to that DODAG Version, or
          if that node\n       is the root of the corresponding DODAG.\n   3.  A node
          MUST NOT send DIOs for DODAG Versions of which it is not a\n       member.\n
          \  4.  DODAG roots MAY increment the DODAGVersionNumber that they\n       advertise
          and thus move to a new DODAG Version.  When a DODAG\n       root increments
          its DODAGVersionNumber, it MUST follow the\n       conventions of Serial
          Number Arithmetic as described in\n       Section 7.  Events triggering
          the increment of the\n       DODAGVersionNumber are described later in this
          section and in\n       Section 18.\n   5.  Within a given DODAG, a node
          that is a not a root MUST NOT\n       advertise a DODAGVersionNumber higher
          than the highest\n       DODAGVersionNumber it has heard.  Higher is defined
          as the\n       greater-than operator in Section 7.\n   6.  Once a node has
          advertised a DODAG Version by sending a DIO, it\n       MUST NOT be a member
          of a previous DODAG Version of the same\n       DODAG (i.e., with the same
          RPLInstanceID, the same DODAGID, and a\n       lower DODAGVersionNumber).
          \ Lower is defined as the less-than\n       operator in Section 7.\n   When
          the DODAG parent set becomes empty on a node that is not a root,\n   (i.e.,
          the last parent has been removed, causing the node no longer\n   to be associated
          with that DODAG), then the DODAG information should\n   not be suppressed
          until after the expiration of an implementation-\n   specific local timer.
          \ During the interval prior to suppression of\n   the \"old\" DODAG state,
          the node will be able to observe if the\n   DODAGVersionNumber has been
          incremented should any new parents\n   appear.  This will help protect against
          the possibility of loops that\n   may occur if that node were to inadvertently
          rejoin the old DODAG\n   Version in its own prior sub-DODAG.\n   As the
          DODAGVersionNumber is incremented, a new DODAG Version spreads\n   outward
          from the DODAG root.  A parent that advertises the new\n   DODAGVersionNumber
          cannot belong to the sub-DODAG of a node\n   advertising an older DODAGVersionNumber.
          \ Therefore, a node can\n   safely add a parent of any Rank with a newer
          DODAGVersionNumber\n   without forming a loop.\n   For example, suppose
          that a node has left a DODAG with\n   DODAGVersionNumber N.  Suppose that
          a node had a sub-DODAG and did\n   attempt to poison that sub-DODAG by advertising
          a Rank of\n   INFINITE_RANK, but those advertisements may have become lost
          in the\n   LLN.  Then, if the node did observe a candidate neighbor advertising\n
          \  a position in that original DODAG at DODAGVersionNumber N, that\n   candidate
          neighbor could possibly have been in the node's former sub-\n   DODAG, and
          there is a possible case where adding that candidate\n   neighbor as a parent
          could cause a loop.  In this case, if that\n   candidate neighbor is observed
          to advertise a DODAGVersionNumber N+1,\n   then that candidate neighbor
          is certain to be safe, since it is\n   certain not to be in that original
          node's sub-DODAG, as it has been\n   able to increment the DODAGVersionNumber
          by hearing from the DODAG\n   root while that original node was detached.
          \ For this reason, it is\n   useful for the detached node to remember the
          original DODAG\n   information, including the DODAGVersionNumber N.\n   Exactly
          when a DODAG root increments the DODAGVersionNumber is\n   implementation
          dependent and out of scope for this specification.\n   Examples include
          incrementing the DODAGVersionNumber periodically,\n   upon administrative
          intervention, or on application-level detection\n   of lost connectivity
          or DODAG inefficiency.\n   After a node transitions to and advertises a
          new DODAG Version, the\n   rules above make it unable to advertise the previous
          DODAG Version\n   (prior DODAGVersionNumber) once it has committed to advertising
          the\n   new DODAG Version.\n"
        title: 8.2.2.1.  DODAG Version
      - contents:
        - "8.2.2.2.  DODAG Roots\n   1.  A DODAG root without possibility to satisfy
          the application-\n       defined goal MUST NOT set the Grounded bit.\n   2.
          \ A DODAG root MUST advertise a Rank of ROOT_RANK.\n   3.  A node whose
          DODAG parent set is empty MAY become the DODAG root\n       of a floating
          DODAG.  It MAY also set its DAGPreference such that\n       it is less preferred.\n
          \  In a deployment that uses non-LLN links to federate a number of LLN\n
          \  roots, it is possible to run RPL over those non-RPL links and use one\n
          \  router as a \"backbone root\".  The backbone root is the virtual root\n
          \  of the DODAG and exposes a Rank of BASE_RANK over the backbone.  All\n
          \  the LLN roots that are parented to that backbone root, including the\n
          \  backbone root if it also serves as the LLN root itself, expose a Rank\n
          \  of ROOT_RANK to the LLN.  These virtual roots are part of the same\n
          \  DODAG and advertise the same DODAGID.  They coordinate\n   DODAGVersionNumbers
          and other DODAG parameters with the virtual root\n   over the backbone.
          \ The method of coordination is out of scope for\n   this specification
          (to be defined in future companion\n   specifications).\n"
        title: 8.2.2.2.  DODAG Roots
      - contents:
        - "8.2.2.3.  DODAG Selection\n   The Objective Function and the set of advertised
          routing metrics and\n   constraints of a DAG determine how a node selects
          its neighbor set,\n   parent set, and preferred parents.  This selection
          implicitly also\n   determines the DODAG within a DAG.  Such selection can
          include\n   administrative preference (Prf) as well as metrics or other\n
          \  considerations.\n   If a node has the option to join a more preferred
          DODAG while still\n   meeting other optimization objectives, then the node
          will generally\n   seek to join the more preferred DODAG as determined by
          the OF.  All\n   else being equal, it is left to the implementation to determine
          which\n   DODAG is most preferred (since, as a reminder, a node must only
          join\n   one DODAG per RPL Instance).\n"
        title: 8.2.2.3.  DODAG Selection
      - contents:
        - "8.2.2.4.  Rank and Movement within a DODAG Version\n   1.  A node MUST
          NOT advertise a Rank less than or equal to any member\n       of its parent
          set within the DODAG Version.\n   2.  A node MAY advertise a Rank lower
          than its prior advertisement\n       within the DODAG Version.\n   3.  Let
          L be the lowest Rank within a DODAG Version that a given node\n       has
          advertised.  Within the same DODAG Version, that node MUST\n       NOT advertise
          an effective Rank higher than L +\n       DAGMaxRankIncrease.  INFINITE_RANK
          is an exception to this rule:\n       a node MAY advertise an INFINITE_RANK
          within a DODAG Version\n       without restriction.  If a node's Rank were
          to be higher than\n       allowed by L + DAGMaxRankIncrease, when it advertises
          Rank, it\n       MUST advertise its Rank as INFINITE_RANK.\n   4.  A node
          MAY, at any time, choose to join a different DODAG within\n       a RPL
          Instance.  Such a join has no Rank restrictions, unless\n       that different
          DODAG is a DODAG Version of which this node has\n       previously been
          a member; in which case, the rule of the previous\n       bullet (3) must
          be observed.  Until a node transmits a DIO\n       indicating its new DODAG
          membership, it MUST forward packets\n       along the previous DODAG.\n
          \  5.  A node MAY, at any time after hearing the next DODAGVersionNumber\n
          \      advertised from suitable DODAG parents, choose to migrate to the\n
          \      next DODAG Version within the DODAG.\n   Conceptually, an implementation
          is maintaining a DODAG parent set\n   within the DODAG Version.  Movement
          entails changes to the DODAG\n   parent set.  Moving Up does not present
          the risk to create a loop but\n   moving Down might, so that operation is
          subject to additional\n   constraints.\n   When a node migrates to the next
          DODAG Version, the DODAG parent set\n   needs to be rebuilt for the new
          Version.  An implementation could\n   defer to migrate for some reasonable
          amount of time, to see if some\n   other neighbors with potentially better
          metrics but higher Rank\n   announce themselves.  Similarly, when a node
          jumps into a new DODAG,\n   it needs to construct a new DODAG parent set
          for this new DODAG.\n   If a node needs to move Down a DODAG that it is
          attached to,\n   increasing its Rank, then it MAY poison its routes and
          delay before\n   moving as described in Section 8.2.2.5.\n   A node is allowed
          to join any DODAG Version that it has never been a\n   prior member of without
          any restrictions, but if the node has been a\n   prior member of the DODAG
          Version, then it must continue to observe\n   the rule that it may not advertise
          a Rank higher than\n   L+DAGMaxRankIncrease at any point in the life of
          the DODAG Version.\n   This rule must be observed so as not to create a
          loophole that would\n   allow the node to effectively increment its Rank
          all the way to\n   INFINITE_RANK, which may have impact on other nodes and
          create a\n   resource-wasting count-to-infinity scenario.\n"
        title: 8.2.2.4.  Rank and Movement within a DODAG Version
      - contents:
        - "8.2.2.5.  Poisoning\n   1.  A node poisons routes by advertising a Rank
          of INFINITE_RANK.\n   2.  A node MUST NOT have any nodes with a Rank of
          INFINITE_RANK in\n       its parent set.\n   Although an implementation
          may advertise INFINITE_RANK for the\n   purposes of poisoning, doing so
          is not the same as setting Rank to\n   INFINITE_RANK.  For example, a node
          may continue to send data packets\n   whose RPL Packet Information includes
          a Rank that is not\n   INFINITE_RANK, yet still advertise INFINITE_RANK
          in its DIOs.\n   When a (former) parent is observed to advertise a Rank
          of\n   INFINITE_RANK, that (former) parent has detached from the DODAG and\n
          \  is no longer able to act as a parent, nor is there any way that\n   another
          node may be considered to have a Rank greater-than\n   INFINITE_RANK.  Therefore,
          that (former) parent cannot act as a\n   parent any longer and is removed
          from the parent set.\n"
        title: 8.2.2.5.  Poisoning
      - contents:
        - "8.2.2.6.  Detaching\n   1.  A node unable to stay connected to a DODAG
          within a given DODAG\n       Version, i.e., that cannot retain non-empty
          parent set without\n       violating the rules of this specification, MAY
          detach from this\n       DODAG Version.  A node that detaches becomes the
          root of its own\n       floating DODAG and SHOULD immediately advertise
          this new\n       situation in a DIO as an alternate to poisoning.\n"
        title: 8.2.2.6.  Detaching
      - contents:
        - "8.2.2.7.  Following a Parent\n   1.  If a node receives a DIO from one
          of its DODAG parents,\n       indicating that the parent has left the DODAG,
          that node SHOULD\n       stay in its current DODAG through an alternative
          DODAG parent, if\n       possible.  It MAY follow the leaving parent.\n
          \  A DODAG parent may have moved, migrated to the next DODAG Version, or\n
          \  jumped to a different DODAG.  A node ought to give some preference to\n
          \  remaining in the current DODAG, if possible via an alternate parent,\n
          \  but ought to follow the parent if there are no other options.\n"
        title: 8.2.2.7.  Following a Parent
      title: 8.2.2.  Neighbors and Parents across DODAG Versions
    - contents:
      - "8.2.3.  DIO Message Communication\n   When a DIO message is received, the
        receiving node must first\n   determine whether or not the DIO message should
        be accepted for\n   further processing, and subsequently present the DIO message
        for\n   further processing if eligible.\n   1.  If the DIO message is malformed,
        then the DIO message is not\n       eligible for further processing and a
        node MUST silently discard\n       it.  (See Section 18 for error logging).\n
        \  2.  If the sender of the DIO message is a member of the candidate\n       neighbor
        set and the DIO message is not malformed, the node MUST\n       process the
        DIO.\n"
      - contents:
        - "8.2.3.1.  DIO Message Processing\n   As DIO messages are received from
          candidate neighbors, the neighbors\n   may be promoted to DODAG parents
          by following the rules of DODAG\n   discovery as described in Section 8.2.
          \ When a node places a neighbor\n   into the DODAG parent set, the node
          becomes attached to the DODAG\n   through the new DODAG parent node.\n   The
          most preferred parent should be used to restrict which other\n   nodes may
          become DODAG parents.  Some nodes in the DODAG parent set\n   may be of
          a Rank less than or equal to the most preferred DODAG\n   parent.  (This
          case may occur, for example, if an energy-constrained\n   device is at a
          lesser Rank but should be avoided per an optimization\n   objective, resulting
          in a more preferred parent at a greater Rank.)\n"
        title: 8.2.3.1.  DIO Message Processing
      title: 8.2.3.  DIO Message Communication
    title: 8.2.  Upward Route Discovery and Maintenance
  - contents:
    - "8.3.  DIO Transmission\n   RPL nodes transmit DIOs using a Trickle timer [RFC6206].
      \ A DIO from\n   a sender with a lesser DAGRank that causes no changes to the\n
      \  recipient's parent set, preferred parent, or Rank SHOULD be\n   considered
      consistent with respect to the Trickle timer.\n   The following packets and
      events MUST be considered inconsistencies\n   with respect to the Trickle timer,
      and cause the Trickle timer to\n   reset:\n   o  When a node detects an inconsistency
      when forwarding a packet, as\n      detailed in Section 11.2.\n   o  When a
      node receives a multicast DIS message without a Solicited\n      Information
      option, unless a DIS flag restricts this behavior.\n   o  When a node receives
      a multicast DIS with a Solicited Information\n      option and the node matches
      all of the predicates in the Solicited\n      Information option, unless a DIS
      flag restricts this behavior.\n   o  When a node joins a new DODAG Version (e.g.,
      by updating its\n      DODAGVersionNumber, joining a new RPL Instance, etc.).\n
      \  Note that this list is not exhaustive, and an implementation MAY\n   consider
      other messages or events to be inconsistencies.\n   A node SHOULD NOT reset
      its DIO Trickle timer in response to unicast\n   DIS messages.  When a node
      receives a unicast DIS without a Solicited\n   Information option, it MUST unicast
      a DIO to the sender in response.\n   This DIO MUST include a DODAG Configuration
      option.  When a node\n   receives a unicast DIS message with a Solicited Information
      option\n   and matches the predicates of that Solicited Information option,
      it\n   MUST unicast a DIO to the sender in response.  This unicast DIO MUST\n
      \  include a DODAG Configuration option.  Thus, a node MAY transmit a\n   unicast
      DIS message to a potential DODAG parent in order to probe for\n   DODAG Configuration
      and other parameters.\n"
    - contents:
      - "8.3.1.  Trickle Parameters\n   The configuration parameters of the Trickle
        timer are specified as\n   follows:\n   Imin: learned from the DIO message
        as (2^DIOIntervalMin) ms.  The\n         default value of DIOIntervalMin is
        DEFAULT_DIO_INTERVAL_MIN.\n   Imax: learned from the DIO message as DIOIntervalDoublings.
        \ The\n         default value of DIOIntervalDoublings is\n         DEFAULT_DIO_INTERVAL_DOUBLINGS.\n
        \  k:    learned from the DIO message as DIORedundancyConstant.  The\n         default
        value of DIORedundancyConstant is\n         DEFAULT_DIO_REDUNDANCY_CONSTANT.
        \ In RPL, when k has the value\n         of 0x00, this is to be treated as
        a redundancy constant of\n         infinity in RPL, i.e., Trickle never suppresses
        messages.\n"
      title: 8.3.1.  Trickle Parameters
    title: 8.3.  DIO Transmission
  - contents:
    - "8.4.  DODAG Selection\n   The DODAG selection is implementation and OF dependent.
      \ In order to\n   limit erratic movements, and all metrics being equal, nodes
      SHOULD\n   keep their previous selection.  Also, nodes SHOULD provide a means
      to\n   filter out a parent whose availability is detected as fluctuating, at\n
      \  least when more stable choices are available.\n   When connection to a grounded
      DODAG is not possible or preferable for\n   security or other reasons, scattered
      DODAGs MAY aggregate as much as\n   possible into larger DODAGs in order to
      allow connectivity within the\n   LLN.\n   A node SHOULD verify that bidirectional
      connectivity and adequate\n   link quality is available with a candidate neighbor
      before it\n   considers that candidate as a DODAG parent.\n"
    title: 8.4.  DODAG Selection
  - contents:
    - "8.5.  Operation as a Leaf Node\n   In some cases, a RPL node may attach to
      a DODAG as a leaf node only.\n   One example of such a case is when a node does
      not understand or does\n   not support (policy) the RPL Instance's OF or advertised
      metric/\n   constraint.  As specified in Section 18.6, related to policy\n   function,
      the node may either join the DODAG as a leaf node or may\n   not join the DODAG.
      \ As mentioned in Section 18.5, it is then\n   recommended to log a fault.\n
      \  A leaf node does not extend DODAG connectivity; however, in some\n   cases,
      the leaf node may still need to transmit DIOs on occasion, in\n   particular,
      when the leaf node may not have always been acting as a\n   leaf node and an
      inconsistency is detected.\n   A node operating as a leaf node must obey the
      following rules:\n   1.  It MUST NOT transmit DIOs containing the DAG Metric
      Container.\n   2.  Its DIOs MUST advertise a DAGRank of INFINITE_RANK.\n   3.
      \ It MAY suppress DIO transmission, unless the DIO transmission has\n       been
      triggered due to detection of inconsistency when a packet is\n       being forwarded
      or in response to a unicast DIS message, in which\n       case the DIO transmission
      MUST NOT be suppressed.\n   4.  It MAY transmit unicast DAOs as described in
      Section 9.2.\n   5.  It MAY transmit multicast DAOs to the '1 hop' neighborhood
      as\n       described in Section 9.10.\n   A particular case that requires a
      leaf node to send a DIO is if that\n   leaf node was a prior member of another
      DODAG and another node\n   forwards a message assuming the old topology, triggering
      an\n   inconsistency.  The leaf node needs to transmit a DIO in order to\n   repair
      the inconsistency.  Note that due to the lossy nature of LLNs,\n   even though
      the leaf node may have optimistically poisoned its routes\n   by advertising
      a Rank of INFINITE_RANK in the old DODAG prior to\n   becoming a leaf node,
      that advertisement may have become lost and a\n   leaf node must be capable
      to send a DIO later in order to repair the\n   inconsistency.\n   In the general
      case, the leaf node MUST NOT advertise itself as a\n   router (i.e., send DIOs).\n"
    title: 8.5.  Operation as a Leaf Node
  - contents:
    - "8.6.  Administrative Rank\n   In some cases, it might be beneficial to adjust
      the Rank advertised\n   by a node beyond that computed by the OF based on some\n
      \  implementation-specific policy and properties of the node.  For\n   example,
      a node that has a limited battery should be a leaf unless\n   there is no other
      choice, and may then augment the Rank computation\n   specified by the OF in
      order to expose an exaggerated Rank.\n"
    title: 8.6.  Administrative Rank
  title: 8.  Upward Routes
- contents:
  - "9.  Downward Routes\n   This section describes how RPL discovers and maintains
    Downward\n   routes.  RPL constructs and maintains Downward routes with\n   Destination
    Advertisement Object (DAO) messages.  Downward routes\n   support P2MP flows,
    from the DODAG roots toward the leaves.  Downward\n   routes also support P2P
    flows: P2P messages can flow toward a DODAG\n   root (or a common ancestor) through
    an Upward route, then away from\n   the DODAG root to a destination through a
    Downward route.\n   This specification describes the two modes a RPL Instance
    may choose\n   from for maintaining Downward routes.  In the first mode, called\n
    \  \"Storing\", nodes store Downward routing tables for their sub-DODAG.\n   Each
    hop on a Downward route in a storing network examines its\n   routing table to
    decide on the next hop.  In the second mode, called\n   \"Non-Storing\", nodes
    do not store Downward routing tables.  Downward\n   packets are routed with source
    routes populated by a DODAG root\n   [RFC6554].\n   RPL allows a simple one-hop
    P2P optimization for both storing and\n   non-storing networks.  A node may send
    a P2P packet destined to a\n   one-hop neighbor directly to that node.\n"
  - contents:
    - "9.1.  Destination Advertisement Parents\n   To establish Downward routes, RPL
      nodes send DAO messages Upward.\n   The next-hop destinations of these DAO messages
      are called \"DAO\n   parents\".  The collection of a node's DAO parents is called
      the \"DAO\n   parent set\".\n   1.  A node MAY send DAO messages using the all-RPL-nodes
      multicast\n       address, which is an optimization to provision one-hop routing.\n
      \      The 'K' bit MUST be cleared on transmission of the multicast DAO.\n   2.
      \ A node's DAO parent set MUST be a subset of its DODAG parent set.\n   3.  In
      Storing mode operation, a node MUST NOT address unicast DAO\n       messages
      to nodes that are not DAO parents.\n   4.  In Storing mode operation, the IPv6
      source and destination\n       addresses of a DAO message MUST be link-local
      addresses.\n   5.  In Non-Storing mode operation, a node MUST NOT address unicast\n
      \      DAO messages to nodes that are not DODAG roots.\n   6.  In Non-Storing
      mode operation, the IPv6 source and destination\n       addresses of a DAO message
      MUST be a unique-local or a global\n       address.\n   The selection of DAO
      parents is implementation and Objective Function\n   specific.\n"
    title: 9.1.  Destination Advertisement Parents
  - contents:
    - "9.2.  Downward Route Discovery and Maintenance\n   Destination Advertisement
      may be configured to be entirely disabled,\n   or operate in either a Storing
      or Non-Storing mode, as reported in\n   the MOP in the DIO message.\n   1.  All
      nodes who join a DODAG MUST abide by the MOP setting from the\n       root.
      \ Nodes that do not have the capability to fully participate\n       as a router,
      e.g., that do not match the advertised MOP, MAY join\n       the DODAG as a
      leaf.\n   2.  If the MOP is 0, indicating no Downward routing, nodes MUST NOT\n
      \      transmit DAO messages and MAY ignore DAO messages.\n   3.  In Non-Storing
      mode, the DODAG root SHOULD store source routing\n       table entries for destinations
      learned from DAOs.  The DODAG root\n       MUST be able to generate source routes
      for those destinations\n       learned from DAOs that were stored.\n   4.  In
      Storing mode, all non-root, non-leaf nodes MUST store routing\n       table
      entries for destinations learned from DAOs.\n   A DODAG can have one of several
      possible modes of operation, as\n   defined by the MOP field.  Either it does
      not support Downward\n   routes, it supports Downward routes through source
      routing from DODAG\n   roots, or it supports Downward routes through in-network
      routing\n   tables.\n   When Downward routes are supported through source routing
      from DODAG\n   roots, it is generally expected that the DODAG root has stored
      the\n   source routing information learned from DAOs in order to construct\n
      \  the source routes.  If the DODAG root fails to store some\n   information,
      then some destinations may be unreachable.\n   When Downward routes are supported
      through in-network routing tables,\n   the multicast operation defined in this
      specification may or may not\n   be supported, also as indicated by the MOP
      field.\n   When Downward routes are supported through in-network routing tables,\n
      \  as described in this specification, it is expected that nodes acting\n   as
      routers have been provisioned sufficiently to hold the required\n   routing
      table state.  If a node acting as a router is unable to hold\n   the full routing
      table state then the routing state is not complete,\n   messages may be dropped
      as a consequence, and a fault may be logged\n   (Section 18.5).  Future extensions
      to RPL may elaborate on refined\n   actions/behaviors to manage this case.\n
      \  As of the writing of this specification, RPL does not support mixed-\n   mode
      operation, where some nodes source route and other store routing\n   tables:
      future extensions to RPL may support this mode of operation.\n"
    - contents:
      - "9.2.1.  Maintenance of Path Sequence\n   For each Target that is associated
        with (owned by) a node, that node\n   is responsible to emit DAO messages
        in order to provision the\n   Downward routes.  The Target+Transit information
        contained in those\n   DAO messages subsequently propagates Up the DODAG.
        \ The Path Sequence\n   counter in the Transit information option is used
        to indicate\n   freshness and update stale Downward routing information as
        described\n   in Section 7.\n   For a Target that is associated with (owned
        by) a node, that node\n   MUST increment the Path Sequence counter, and generate
        a new DAO\n   message, when:\n   1.  the Path Lifetime is to be updated (e.g.,
        a refresh or a no-\n       Path).\n   2.  the DODAG Parent Address subfield
        list is to be changed.\n   For a Target that is associated with (owned by)
        a node, that node MAY\n   increment the Path Sequence counter, and generate
        a new DAO message,\n   on occasion in order to refresh the Downward routing
        information.  In\n   Storing mode, the node generates such a DAO to each of
        its DAO\n   parents in order to enable multipath.  All DAOs generated at the
        same\n   time for the same Target MUST be sent with the same Path Sequence
        in\n   the Transit Information.\n"
      title: 9.2.1.  Maintenance of Path Sequence
    - contents:
      - "9.2.2.  Generation of DAO Messages\n   A node might send DAO messages when
        it receives DAO messages, as a\n   result of changes in its DAO parent set,
        or in response to another\n   event such as the expiry of a related prefix
        lifetime.  In the case\n   of receiving DAOs, it matters whether the DAO message
        is \"new\" or\n   contains new information.  In Non-Storing mode, every DAO
        message a\n   node receives is \"new\".  In Storing mode, a DAO message is
        \"new\" if\n   it satisfies any of these criteria for a contained Target:\n
        \  1.  it has a newer Path Sequence number,\n   2.  it has additional Path
        Control bits, or\n   3.  it is a No-Path DAO message that removes the last
        Downward route\n       to a prefix.\n   A node that receives a DAO message
        from its sub-DODAG MAY suppress\n   scheduling a DAO message transmission
        if that DAO message is not new.\n"
      title: 9.2.2.  Generation of DAO Messages
    title: 9.2.  Downward Route Discovery and Maintenance
  - contents:
    - "9.3.  DAO Base Rules\n   1.  If a node sends a DAO message with newer or different
      information\n       than the prior DAO message transmission, it MUST increment
      the\n       DAOSequence field by at least one.  A DAO message transmission\n
      \      that is identical to the prior DAO message transmission MAY\n       increment
      the DAOSequence field.\n   2.  The RPLInstanceID and DODAGID fields of a DAO
      message MUST be the\n       same value as the members of the node's parent set
      and the DIOs\n       it transmits.\n   3.  A node MAY set the 'K' flag in a
      unicast DAO message to solicit a\n       unicast DAO-ACK in response in order
      to confirm the attempt.\n   4.  A node receiving a unicast DAO message with
      the 'K' flag set\n       SHOULD respond with a DAO-ACK.  A node receiving a
      DAO message\n       without the 'K' flag set MAY respond with a DAO-ACK, especially\n
      \      to report an error condition.\n   5.  A node that sets the 'K' flag in
      a unicast DAO message but does\n       not receive a DAO-ACK in response MAY
      reschedule the DAO message\n       transmission for another attempt, up until
      an implementation-\n       specific number of retries.\n   6.  Nodes SHOULD
      ignore DAOs without newer sequence numbers and MUST\n       NOT process them
      further.\n   Unlike the Version field of a DIO, which is incremented only by
      a\n   DODAG root and repeated unchanged by other nodes, DAOSequence values\n
      \  are unique to each node.  The sequence number space for unicast and\n   multicast
      DAO messages can be either the same or distinct.  It is\n   RECOMMENDED to use
      the same sequence number space.\n"
    title: 9.3.  DAO Base Rules
  - contents:
    - "9.4.  Structure of DAO Messages\n   DAOs follow a common structure in both
      storing and non-storing\n   networks.  In the most general form, a DAO message
      may include\n   several groups of options, where each group consists of one
      or more\n   Target options followed by one or more Transit Information options.\n
      \  The entire group of Transit Information options applies to the entire\n   group
      of Target options.  Later sections describe further details for\n   each mode
      of operation.\n   1.  RPL nodes MUST include one or more RPL Target options
      in each DAO\n       message they transmit.  One RPL Target option MUST have
      a prefix\n       that includes the node's IPv6 address if that node needs the\n
      \      DODAG to provision Downward routes to that node.  The RPL Target\n       option
      MAY be immediately followed by an opaque RPL Target\n       Descriptor option
      that qualifies it.\n   2.  When a node updates the information in a Transit
      Information\n       option for a Target option that covers one of its addresses,
      it\n       MUST increment the Path Sequence number in that Transit\n       Information
      option.  The Path Sequence number MAY be incremented\n       occasionally to
      cause a refresh to the Downward routes.\n   3.  One or more RPL Target options
      in a unicast DAO message MUST be\n       followed by one or more Transit Information
      options.  All the\n       transit options apply to all the Target options that
      immediately\n       precede them.\n   4.  Multicast DAOs MUST NOT include the
      DODAG Parent Address subfield\n       in Transit Information options.\n   5.
      \ A node that receives and processes a DAO message containing\n       information
      for a specific Target, and that has prior information\n       for that Target,
      MUST use the Path Sequence number in the Transit\n       Information option
      associated with that Target in order to\n       determine whether or not the
      DAO message contains updated\n       information per Section 7.\n   6.  If a
      node receives a DAO message that does not follow the above\n       rules, it
      MUST discard the DAO message without further\n       processing.\n   In Non-Storing
      mode, the root builds a strict source routing header,\n   hop-by-hop, by recursively
      looking up one-hop information that ties a\n   Target (address or prefix) and
      a transit address together.  In some\n   cases, when a child address is derived
      from a prefix that is owned\n   and advertised by a parent, that parent-child
      relationship may be\n   inferred by the root for the purpose of constructing
      the source\n   routing header.  In all other cases, it is necessary to inform
      the\n   root of the transit-Target relationship from a reachable target, so\n
      \  as to later enable the recursive construction of the routing header.\n   An
      address that is advertised as a Target in a DAO message MUST be\n   collocated
      in the same router, or reachable on-link by the router\n   that owns the address
      that is indicated in the associated Transit\n   Information.  The following
      additional rules apply to ensure the\n   continuity of the end-to-end source
      route path:\n   1.  The address of a parent used in the transit option MUST
      be taken\n       from a PIO from that parent with the 'R' flag set.  The 'R'
      flag\n       in a PIO indicates that the prefix field actually contains the\n
      \      full parent address but the child SHOULD NOT assume that the\n       parent
      address is on-link.\n   2.  A PIO with an 'A' flag set indicates that the RPL
      child node may\n       use the prefix to autoconfigure an address.  A parent
      that\n       advertises a prefix in a PIO with the 'A' flag set MUST ensure\n
      \      that the address or the whole prefix in the PIO is reachable from\n       the
      root by advertising it as a DAO target.  If the parent also\n       sets the
      'L' flag indicating that the prefix is on-link, then it\n       MUST advertise
      the whole prefix as Target in a DAO message.  If\n       the 'L' flag is cleared
      and the 'R' flag is set, indicating that\n       the parent provides its own
      address in the PIO, then the parent\n       MUST advertise that address as a
      DAO target.\n   3.  An address that is advertised as Target in a DAO message
      MUST be\n       collocated in the same router or reachable on-link by the router\n
      \      that owns the address that is indicated in the associated Transit\n       Information.\n
      \  4.  In order to enable an optimum compression of the routing header,\n       the
      parent SHOULD set the 'R' flag in all PIOs with the 'A' flag\n       set and
      the 'L' flag cleared, and the child SHOULD prefer to use\n       as transit
      the address of the parent that is found in the PIO\n       that is used to autoconfigure
      the address that is advertised as\n       Target in the DAO message.\n   5.
      \ A router might have targets that are not known to be on-link for\n       a
      parent, either because they are addresses located on an\n       alternate interface
      or because they belong to nodes that are\n       external to RPL, for instance
      connected hosts.  In order to\n       inject such a Target in the RPL network,
      the router MUST\n       advertise itself as the DODAG Parent Address subfield
      in the\n       Transit Information option for that target, using an address
      that\n       is on-link for that nodes DAO parent.  If the Target belongs to\n
      \      an external node, then the router MUST set the External 'E' flag\n       in
      the Transit Information.\n   A child node that has autoconfigured an address
      from a parent PIO\n   with the 'L' flag set does not need to advertise that
      address as a\n   DAO Target since the parent ensures that the whole prefix is
      already\n   reachable from the root.  However, if the 'L' flag is not set, then\n
      \  it is necessary, in Non-Storing mode, for the child node to inform\n   the
      root of the parent-child relationship, using a reachable address\n   of the
      parent, so as to enable the recursive construction of the\n   routing header.
      \ This is done by associating an address of the parent\n   as transit with the
      address of the child as Target in a DAO message.\n"
    title: 9.4.  Structure of DAO Messages
  - contents:
    - "9.5.  DAO Transmission Scheduling\n   Because DAOs flow Upward, receiving a
      unicast DAO can trigger sending\n   a unicast DAO to a DAO parent.\n   1.  On
      receiving a unicast DAO message with updated information, such\n       as containing
      a Transit Information option with a new Path\n       Sequence, a node SHOULD
      send a DAO.  It SHOULD NOT send this DAO\n       message immediately.  It SHOULD
      delay sending the DAO message in\n       order to aggregate DAO information
      from other nodes for which it\n       is a DAO parent.\n   2.  A node SHOULD
      delay sending a DAO message with a timer\n       (DelayDAO).  Receiving a DAO
      message starts the DelayDAO timer.\n       DAO messages received while the DelayDAO
      timer is active do not\n       reset the timer.  When the DelayDAO timer expires,
      the node sends\n       a DAO.\n   3.  When a node adds a node to its DAO parent
      set, it SHOULD schedule\n       a DAO message transmission.\n   DelayDAO's value
      and calculation is implementation dependent.  A\n   default value of DEFAULT_DAO_DELAY
      is defined in this specification.\n"
    title: 9.5.  DAO Transmission Scheduling
  - contents:
    - "9.6.  Triggering DAO Messages\n   Nodes can trigger their sub-DODAG to send
      DAO messages.  Each node\n   maintains a DAO Trigger Sequence Number (DTSN),
      which it communicates\n   through DIO messages.\n   1.  If a node hears one
      of its DAO parents increment its DTSN, the\n       node MUST schedule a DAO
      message transmission using rules in\n       Sections 9.3 and 9.5.\n   2.  In
      Non-Storing mode, if a node hears one of its DAO parents\n       increment its
      DTSN, the node MUST increment its own DTSN.\n   In a Storing mode of operation,
      as part of routine routing table\n   updates and maintenance, a storing node
      MAY increment DTSN in order\n   to reliably trigger a set of DAO updates from
      its immediate children.\n   In a Storing mode of operation, it is not necessary
      to trigger DAO\n   updates from the entire sub-DODAG, since that state information
      will\n   propagate hop-by-hop Up the DODAG.\n   In a Non-Storing mode of operation,
      a DTSN increment will also cause\n   the immediate children of a node to increment
      their DTSN in turn,\n   triggering a set of DAO updates from the entire sub-DODAG.\n
      \  Typically, in a Non-Storing mode of operation, only the root would\n   independently
      increment the DTSN when a DAO refresh is needed but a\n   global repair (such
      as by incrementing DODAGVersionNumber) is not\n   desired.  Typically, in a
      Non-Storing mode of operation, all non-root\n   nodes would increment their
      DTSN only when their parent(s) are\n   observed to do so.\n   In general, a
      node may trigger DAO updates according to\n   implementation-specific logic,
      such as based on the detection of a\n   Downward route inconsistency or occasionally
      based upon an internal\n   timer.\n   In a storing network, selecting a proper
      DelayDAO for triggered DAOs\n   can greatly reduce the number of DAOs transmitted.
      \ The trigger flows\n   Down the DODAG; in the best case, the DAOs flow Up the
      DODAG such\n   that leaves send DAOs first, with each node sending a DAO message\n
      \  only once.  Such a scheduling could be approximated by setting\n   DelayDAO
      inversely proportional to Rank.  Note that this suggestion\n   is intended as
      an optimization to allow efficient aggregation (it is\n   not required for correct
      operation in the general case).\n"
    title: 9.6.  Triggering DAO Messages
  - contents:
    - "9.7.  Non-Storing Mode\n   In Non-Storing mode, RPL routes messages Downward
      using IP source\n   routing.  The following rule applies to nodes that are in
      Non-Storing\n   mode.  Storing mode has a separate set of rules, described in\n
      \  Section 9.8.\n   1.  The DODAG Parent Address subfield of a Transit Information
      option\n       MUST contain one or more addresses.  All of these addresses MUST\n
      \      be addresses of DAO parents of the sender.\n   2.  DAOs are sent directly
      to the root along a default route\n       installed as part of the parent selection.\n
      \  3.  When a node removes a node from its DAO parent set, it MAY\n       generate
      a new DAO message with an updated Transit Information\n       option.\n   In
      Non-Storing mode, a node uses DAOs to report its DAO parents to\n   the DODAG
      root.  The DODAG root can piece together a Downward route\n   to a node by using
      DAO parent sets from each node in the route.  The\n   Path Sequence information
      may be used to detect stale DAO\n   information.  The purpose of this per-hop
      route calculation is to\n   minimize traffic when DAO parents change.  If nodes
      reported complete\n   source routes, then on a DAO parent change, the entire
      sub-DODAG\n   would have to send new DAOs to the DODAG root.  Therefore, in
      Non-\n   Storing mode, a node can send a single DAO, although it might choose\n
      \  to send more than one DAO message to each of multiple DAO parents.\n   Nodes
      pack DAOs by sending a single DAO message with multiple RPL\n   Target options.
      \ Each RPL Target option has its own, immediately\n   following, Transit Information
      options.\n"
    title: 9.7.  Non-Storing Mode
  - contents:
    - "9.8.  Storing Mode\n   In Storing mode, RPL routes messages Downward by the
      IPv6 destination\n   address.  The following rules apply to nodes that are in
      Storing\n   mode:\n   1.  The DODAG Parent Address subfield of a Transmit Information\n
      \      option MUST be empty.\n   2.  On receiving a unicast DAO, a node MUST
      compute if the DAO would\n       change the set of prefixes that the node itself
      advertises.  This\n       computation SHOULD include consultation of the Path
      Sequence\n       information in the Transit Information options associated with\n
      \      the DAO, to determine if the DAO message contains newer\n       information
      that supersedes the information already stored at the\n       node.  If so,
      the node MUST generate a new DAO message and\n       transmit it, following
      the rules in Section 9.5.  Such a change\n       includes receiving a No-Path
      DAO.\n   3.  When a node generates a new DAO, it SHOULD unicast it to each of\n
      \      its DAO parents.  It MUST NOT unicast the DAO message to nodes\n       that
      are not DAO parents.\n   4.  When a node removes a node from its DAO parent
      set, it SHOULD\n       send a No-Path DAO message (Section 6.4.3) to that removed
      DAO\n       parent to invalidate the existing route.\n   5.  If messages to
      an advertised Downward address suffer from a\n       forwarding error, Neighbor
      Unreachable Detection (NUD), or\n       similar failure, a node MAY mark the
      address as unreachable and\n       generate an appropriate No-Path DAO.\n   DAOs
      advertise to which destination addresses and prefixes a node has\n   routes.
      \ Unlike in Non-Storing mode, these DAOs do not communicate\n   information
      about the routes themselves: that information is stored\n   within the network
      and is implicit from the IPv6 source address.\n   When a storing node generates
      a DAO, it uses the stored state of DAOs\n   it has received to produce a set
      of RPL Target options and their\n   associated Transmit Information options.\n
      \  Because this information is stored within each node's routing tables,\n   in
      Storing mode, DAOs are communicated directly to DAO parents, who\n   store this
      information.\n"
    title: 9.8.  Storing Mode
  - contents:
    - "9.9.  Path Control\n   A DAO message from a node contains one or more Target
      options.  Each\n   Target option specifies either a prefix advertised by the
      node, a\n   prefix of addresses reachable outside the LLN, the address of a\n
      \  destination in the node's sub-DODAG, or a multicast group to which a\n   node
      in the sub-DODAG is listening.  The Path Control field of the\n   Transit Information
      option allows nodes to request or allow for\n   multiple Downward routes.  A
      node constructs the Path Control field\n   of a Transit Information option as
      follows:\n   1.  The bit width of the Path Control field MUST be equal to the\n
      \      value (PCS + 1), where PCS is specified in the control field of\n       the
      DODAG Configuration option.  Bits greater than or equal to\n       the value
      (PCS + 1) MUST be cleared on transmission and MUST be\n       ignored on reception.
      \ Bits below that value are considered\n       \"active\" bits.\n   2.  The
      node MUST logically construct groupings of its DAO parents\n       while populating
      the Path Control field, where each group\n       consists of DAO parents of
      equal preference.  Those groups MUST\n       then be ordered according to preference,
      which allows for a\n       logical mapping of DAO parents onto Path Control
      subfields (see\n       Figure 27).  Groups MAY be repeated in order to extend
      over the\n       entire bit width of the patch control field, but the order,\n
      \      including repeated groups, MUST be retained so that preference is\n       properly
      communicated.\n   3.  For a RPL Target option describing a node's own address
      or a\n       prefix outside the LLN, at least one active bit of the Path\n       Control
      field MUST be set.  More active bits of the Path Control\n       field MAY be
      set.\n   4.  If a node receives multiple DAOs with the same RPL Target option,\n
      \      it MUST bitwise-OR the Path Control fields it receives.  This\n       aggregated
      bitwise-OR represents the number of Downward routes\n       the prefix requests.\n
      \  5.  When a node sends a DAO message to one of its DAO parents, it\n       MUST
      select one or more of the bits that are set active in the\n       subfield that
      is mapped to the group containing that DAO parent\n       from the aggregated
      Path Control field.  A given bit can only be\n       presented as active to
      one parent.  The DAO message it transmits\n       to its parent MUST have these
      active bits set and all other\n       active bits cleared.\n   6.  For the RPL
      Target option and DAOSequence number, the DAOs a node\n       sends to different
      DAO parents MUST have disjoint sets of active\n       Path Control bits.  A
      node MUST NOT set the same active bit on\n       DAOs to two different DAO parents.\n
      \  7.  Path Control bits SHOULD be allocated according to the preference\n       mapping
      of DAO parents onto Path Control subfields, such that the\n       active Path
      Control bits, or groupings of bits, that belong to a\n       particular Path
      Control subfield are allocated to DAO parents\n       within the group that
      was mapped to that subfield.\n   8.  In a Non-Storing mode of operation, a node
      MAY pass DAOs through\n       without performing any further processing on the
      Path Control\n       field.\n   9.  A node MUST NOT unicast a DAO message that
      has no active bits in\n       the Path Control field set.  It is possible that,
      for a given\n       Target option, a node does not have enough aggregate Path
      Control\n       bits to send a DAO message containing that Target to each of
      its\n       DAO parents, in which case those least preferred DAO Parents may\n
      \      not get a DAO message for that Target.\n   The Path Control field allows
      a node to bound how many Downward\n   routes will be generated to it.  It sets
      a number of bits in the Path\n   Control field equal to the maximum number of
      Downward routes it\n   prefers.  At most, each bit is sent to one DAO parent;
      clusters of\n   bits can be sent to a single DAO parent for it to divide among
      its\n   own DAO parents.\n   A node that provisions a DAO route for a Target
      that has an\n   associated Path Control field SHOULD use the content of that
      Path\n   Control field in order to determine an order of preference among\n
      \  multiple alternative DAO routes for that Target.  The Path Control\n   field
      assignment is derived from preference (of the DAO parents), as\n   determined
      on the basis of this node's best knowledge of the \"end-to-\n   end\" aggregated
      metrics in the Downward direction as per the\n   Objective Function.  In Non-Storing
      mode the root can determine the\n   Downward route by aggregating the information
      from each received DAO,\n   which includes the Path Control indications of preferred
      DAO parents.\n"
    - contents:
      - "9.9.1.  Path Control Example\n   Suppose that there is an LLN operating in
        Storing mode that contains\n   a Node N with four parents, P1, P2, P3, and
        P4.  Let N have three\n   children, C1, C2, and C3 in its sub-DODAG.  Let
        PCS be 7, such that\n   there will be 8 active bits in the Path Control field:
        11111111b.\n   Consider the following example:\n   The Path Control field
        is split into four subfields, PC1 (11000000b),\n   PC2 (00110000b), PC3 (00001100b),
        and PC4 (00000011b), such that\n   those four subfields represent four different
        levels of preference\n   per Figure 27.  The implementation at Node N, in
        this example, groups\n   {P1, P2} to be of equal preference to each other
        and the most\n   preferred group overall. {P3} is less preferred to {P1, P2},
        and more\n   preferred to {P4}.  Let Node N then perform its Path Control
        mapping\n   such that:\n              {P1, P2} -> PC1 (11000000b) in the Path
        Control field\n              {P3}     -> PC2 (00110000b) in the Path Control
        field\n              {P4}     -> PC3 (00001100b) in the Path Control field\n
        \             {P4}     -> PC4 (00000011b) in the Path Control field\n   Note
        that the implementation repeated {P4} in order to get complete\n   coverage
        of the Path Control field.\n   1.   Let C1 send a DAO containing a Target
        T with a Path Control\n        10000000b.  Node N stores an entry associating
        10000000b with\n        the Path Control field for C1 and Target T.\n   2.
        \  Let C2 send a DAO containing a Target T with a Path Control\n        00010000b.
        \ Node N stores an entry associating 00010000b with\n        the Path Control
        field for C1 and Target T.\n   3.   Let C3 send a DAO containing a Target
        T with a Path Control\n        00001100b.  Node N stores an entry associating
        00001100b with\n        the Path Control field for C1 and Target T.\n   4.
        \  At some later time, Node N generates a DAO for Target T.  Node N\n        will
        construct an aggregate Path Control field by ORing together\n        the contribution
        from each of its children that have given a DAO\n        for Target T.  Thus,
        the aggregate Path Control field has the\n        active bits set as: 10011100b.\n
        \  5.   Node N then distributes the aggregate Path Control bits among\n        its
        parents P1, P2, P3, and P4 in order to prepare the DAO\n        messages.\n
        \  6.   P1 and P2 are eligible to receive active bits from the most\n        preferred
        subfield (11000000b).  Those bits are 10000000b in the\n        aggregate
        Path Control field.  Node N must set the bit to one of\n        the two parents
        only.  In this case, Node P1 is allocated the\n        bit and gets the Path
        Control field 10000000b for its DAO.\n        There are no bits left to allocate
        to Node P2; thus, Node P2\n        would have a Path Control field of 00000000b
        and a DAO cannot be\n        generated to Node P2 since there are no active
        bits.\n   7.   The second-most preferred subfield (00110000b) has the active\n
        \       bits 00010000b.  Node N has mapped P3 to this subfield.  Node N\n
        \       may allocates the active bit to P3, constructing a DAO for P3\n        containing
        Target T with a Path Control of 00010000b.\n   8.   The third-most preferred
        subfield (00001100b) has the active\n        bits 00001100b.  Node N has mapped
        P4 to this subfield.  Node N\n        may allocate both bits to P4, constructing
        a DAO for P4\n        containing Target T with a Path Control of 00001100b.\n
        \  9.   The least preferred subfield (00000011b) has no active bits.\n        Had
        there been active bits, those bits would have been added to\n        the Path
        Control field of the DAO constructed for P4.\n   10.  The process of populating
        the DAO messages destined for P1, P2,\n        P3, P4 with other targets (other
        than T) proceeds according to\n        the aggregate Path Control fields collected
        for those targets.\n"
      title: 9.9.1.  Path Control Example
    title: 9.9.  Path Control
  - contents:
    - "9.10.  Multicast Destination Advertisement Messages\n   A special case of DAO
      operation, distinct from unicast DAO operation,\n   is multicast DAO operation
      that may be used to populate '1-hop'\n   routing table entries.\n   1.  A node
      MAY multicast a DAO message to the link-local scope all-\n       RPL-nodes multicast
      address.\n   2.  A multicast DAO message MUST be used only to advertise\n       information
      about the node itself, i.e., prefixes directly\n       connected to or owned
      by the node, such as a multicast group that\n       the node is subscribed to
      or a global address owned by the node.\n   3.  A multicast DAO message MUST
      NOT be used to relay connectivity\n       information learned (e.g., through
      unicast DAO) from another\n       node.\n   4.  A node MUST NOT perform any
      other DAO-related processing on a\n       received multicast DAO message; in
      particular, a node MUST NOT\n       perform the actions of a DAO parent upon
      receipt of a multicast\n       DAO.\n   o  The multicast DAO may be used to
      enable direct P2P communication,\n      without needing the DODAG to relay the
      packets.\n"
    title: 9.10.  Multicast Destination Advertisement Messages
  title: 9.  Downward Routes
- contents:
  - "10.  Security Mechanisms\n   This section describes the generation and processing
    of secure RPL\n   messages.  The high-order bit of the RPL message code identifies\n
    \  whether or not a RPL message is secure.  In addition to secure\n   versions
    of basic control messages (DIS, DIO, DAO, DAO-ACK), RPL has\n   several messages
    that are relevant only in networks that are security\n   enabled.\n   Implementation
    complexity and size is a core concern for LLNs such\n   that it may be economically
    or physically impossible to include\n   sophisticated security provisions in a
    RPL implementation.\n   Furthermore, many deployments can utilize link-layer or
    other\n   security mechanisms to meet their security requirements without\n   requiring
    the use of security in RPL.\n   Therefore, the security features described in
    this document are\n   OPTIONAL to implement.  A given implementation MAY support
    a subset\n   (including the empty set) of the described security features, for\n
    \  example, it could support integrity and confidentiality, but not\n   signatures.
    \ An implementation SHOULD clearly specify which security\n   mechanisms are supported,
    and it is RECOMMENDED that implementers\n   carefully consider security requirements
    and the availability of\n   security mechanisms in their network.\n"
  - contents:
    - "10.1.  Security Overview\n   RPL supports three security modes:\n   o  Unsecured.
      \ In this security mode, RPL uses basic DIS, DIO, DAO,\n      and DAO-ACK messages,
      which do not have Security sections.  As a\n      network could be using other
      security mechanisms, such as link-\n      layer security, unsecured mode does
      not imply all messages are\n      sent without any protection.\n   o  Preinstalled.
      \ In this security mode, RPL uses secure messages.\n      To join a RPL Instance,
      a node must have a preinstalled key.\n      Nodes use this to provide message
      confidentiality, integrity, and\n      authenticity.  A node may, using this
      preinstalled key, join the\n      RPL network as either a host or a router.\n
      \  o  Authenticated.  In this security mode, RPL uses secure messages.\n      To
      join a RPL Instance, a node must have a preinstalled key.\n      Nodes use this
      key to provide message confidentiality, integrity,\n      and authenticity.
      \ Using this preinstalled key, a node may join\n      the network as a host
      only.  To join the network as a router, a\n      node must obtain a second key
      from a key authority.  This key\n      authority can authenticate that the requester
      is allowed to be a\n      router before providing it with the second key.  Authenticated\n
      \     mode cannot be supported by symmetric algorithms.  As of the\n      writing
      of this specification, RPL supports only symmetric\n      algorithms: authenticated
      mode is included for the benefit of\n      potential future cryptographic primitives.
      \ See Section 10.3.\n   Whether or not the RPL Instance uses unsecured mode
      is signaled by\n   whether it uses secure RPL messages.  Whether a secured network
      uses\n   the preinstalled or authenticated mode is signaled by the 'A' bit of\n
      \  the DAG Configuration option.\n   This specification specifies CCM -- Counter
      with CBC-MAC (Cipher\n   Block Chaining - Message Authentication Code) -- as
      the cryptographic\n   basis for RPL security [RFC3610].  In this specification,
      CCM uses\n   AES-128 as its underlying cryptographic algorithm.  There are bits\n
      \  reserved in the Security section to specify other algorithms in the\n   future.\n
      \  All secured RPL messages have either a MAC or a signature.\n   Optionally,
      secured RPL messages also have encryption protection for\n   confidentiality.
      \ Secured RPL message formats support both integrated\n   encryption/authentication
      schemes (e.g., CCM) as well as schemes that\n   separately encrypt and authenticate
      packets.\n"
    title: 10.1.  Security Overview
  - contents:
    - "10.2.  Joining a Secure Network\n   RPL security assumes that a node wishing
      to join a secured network\n   has been pre-configured with a shared key for
      communicating with\n   neighbors and the RPL root.  To join a secure RPL network,
      a node\n   either listens for secure DIOs or triggers secure DIOs by sending
      a\n   secure DIS.  In addition to the DIO/DIS rules in Section 8, secure\n   DIO
      and DIS messages have these rules:\n   1.  If sent, this initial secure DIS
      MUST set the Key Identifier Mode\n       field to 0 (00) and MUST set the Security
      Level field to 1 (001).\n       The key used MUST be the pre-configured group
      key (Key Index\n       0x00).\n   2.  When a node resets its Trickle timer in
      response to a secure DIS\n       (Section 8.3), the next DIO it transmits MUST
      be a secure DIO\n       with the same security configuration as the secure DIS.
      \ If a\n       node receives multiple secure DIS messages before it transmits
      a\n       DIO, the secure DIO MUST have the same security configuration as\n
      \      the last DIS to which it is responding.\n   3.  When a node sends a DIO
      in response to a unicast secure DIS\n       (Section 8.3), the DIO MUST be a
      secure DIO.\n   The above rules allow a node to join a secured RPL Instance
      using the\n   pre-configured shared key.  Once a node has joined the DODAG using\n
      \  the pre-configured shared key, the 'A' bit of the Configuration\n   option
      determines its capabilities.  If the 'A' bit of the\n   Configuration option
      is cleared, then nodes can use this\n   preinstalled, shared key to exchange
      messages normally: it can issue\n   DIOs, DAOs, etc.\n   If the 'A' bit of the
      Configuration option is set and the RPL\n   Instance is operating in authenticated
      mode:\n   1.  A node MUST NOT advertise a Rank besides INFINITE_RANK in secure\n
      \      DIOs secured with Key Index 0x00.  When processing DIO messages\n       secured
      with Key Index 0x00, a processing node MUST consider the\n       advertised
      Rank to be INFINITE_RANK.  Any other value results in\n       the message being
      discarded.\n   2.  Secure DAOs using a Key Index 0x00 MUST NOT have a RPL Target\n
      \      option with a prefix besides the node's address.  If a node\n       receives
      a secured DAO message using the preinstalled, shared key\n       where the RPL
      Target option does not match the IPv6 source\n       address, it MUST discard
      the secured DAO message without further\n       processing.\n   The above rules
      mean that in RPL Instances where the 'A' bit is set,\n   using Key Index 0x00,
      a node can join the RPL Instance as a host but\n   not a router.  A node must
      communicate with a key authority to obtain\n   a key that will enable it to
      act as a router.\n"
    title: 10.2.  Joining a Secure Network
  - contents:
    - "10.3.  Installing Keys\n   Authenticated mode requires a would-be router to
      dynamically install\n   new keys once they have joined a network as a host.
      \ Having joined as\n   a host, the node uses standard IP messaging to communicate
      with an\n   authorization server, which can provide new keys.\n   The protocol
      to obtain such keys is out of scope for this\n   specification and to be elaborated
      in future specifications.  That\n   elaboration is required for RPL to securely
      operate in authenticated\n   mode.\n"
    title: 10.3.  Installing Keys
  - contents:
    - "10.4.  Consistency Checks\n   RPL nodes send Consistency Check (CC) messages
      to protect against\n   replay attacks and synchronize counters.\n   1.  If a
      node receives a unicast CC message with the 'R' bit cleared,\n       and it
      is a member of or is in the process of joining the\n       associated DODAG,
      it SHOULD respond with a unicast CC message to\n       the sender.  This response
      MUST have the 'R' bit set, and it MUST\n       have the same CC nonce, RPLInstanceID,
      and DODAGID fields as the\n       message it received.\n   2.  If a node receives
      a multicast CC message, it MUST discard the\n       message with no further
      processing.\n   Consistency Check messages allow nodes to issue a challenge-response\n
      \  to validate a node's current counter value.  Because the CC nonce is\n   generated
      by the challenger, an adversary replaying messages is\n   unlikely to be able
      to generate a correct response.  The counter in\n   the Consistency Check response
      allows the challenger to validate the\n   counter values it hears.\n"
    title: 10.4.  Consistency Checks
  - contents:
    - "10.5.  Counters\n   In the simplest case, the counter value is an unsigned
      integer that a\n   node increments by one or more on each secured RPL transmission.
      \ The\n   counter MAY represent a timestamp that has the following properties:\n
      \  1.  The timestamp MUST be at least six octets long.\n   2.  The timestamp
      MUST be in 1024 Hz (binary millisecond)\n       granularity.\n   3.  The timestamp
      start time MUST be January 1, 1970, 12:00:00AM UTC.\n   4.  If the counter represents
      a timestamp, the counter value MUST be\n       a value computed as follows.
      \ Let T be the timestamp, S be the\n       start time of the key in use, and
      E be the end time of the key in\n       use.  Both S and E are represented using
      the same three rules as\n       the timestamp described above.  If E > T < S,
      then the counter is\n       invalid and a node MUST NOT generate a packet.  Otherwise,
      the\n       counter value is equal to T-S.\n   5.  If the counter represents
      such a timestamp, a node MAY set the\n       'T' flag of the Security section
      of secured RPL packets.\n   6.  If the Counter field does not present such a
      timestamp, then a\n       node MUST NOT set the 'T' flag.\n   7.  If a node
      does not have a local timestamp that satisfies the\n       above requirements,
      it MUST ignore the 'T' flag.\n   If a node supports such timestamps and it receives
      a message with the\n   'T' flag set, it MAY apply the temporal check on the
      received message\n   described in Section 10.7.1.  If a node receives a message
      without\n   the 'T' flag set, it MUST NOT apply this temporal check.  A node's\n
      \  security policy MAY, for application reasons, include rejecting all\n   messages
      without the 'T' flag set.\n   The 'T' flag is present because many LLNs today
      already maintain\n   global time synchronization at sub-millisecond granularity
      for\n   security, application, and other reasons.  Allowing RPL to leverage\n
      \  this existing functionality when present greatly simplifies solutions\n   to
      some security problems, such as delay protection.\n"
    title: 10.5.  Counters
  - contents:
    - "10.6.  Transmission of Outgoing Packets\n   Given an outgoing RPL control packet
      and the required security\n   protection, this section describes how RPL generates
      the secured\n   packet to transmit.  It also describes the order of cryptographic\n
      \  operations to provide the required protection.\n   The requirement for security
      protection and the level of security to\n   be applied to an outgoing RPL packet
      shall be determined by the\n   node's security policy database.  The configuration
      of this security\n   policy database for outgoing packet processing is implementation\n
      \  specific.\n   Where secured RPL messages are to be transmitted, a RPL node
      MUST set\n   the Security section (T, Sec, KIM, and LVL) in the outgoing RPL\n
      \  packet to describe the protection level and security settings that\n   are
      applied (see Section 6.1).  The Security subfield bit of the RPL\n   Message
      Code field MUST be set to indicate the secure RPL message.\n   The counter value
      used in constructing the AES-128 CCM nonce\n   (Figure 31) to secure the outgoing
      packet MUST be an increment of the\n   last counter transmitted to the particular
      destination address.\n   Where security policy specifies the application of
      delay protection,\n   the Timestamp counter used in constructing the CCM nonce
      to secure\n   the outgoing packet MUST be incremented according to the rules
      in\n   Section 10.5.  Where a Timestamp counter is applied (indicated with\n
      \  the 'T' flag set), the locally maintained Timestamp counter MUST be\n   included
      as part of the transmitted secured RPL message.\n   The cryptographic algorithm
      used in securing the outgoing packet\n   shall be specified by the node's security
      policy database and MUST be\n   indicated in the value of the Sec field set
      within the outgoing\n   message.\n   The security policy for the outgoing packet
      shall determine the\n   applicable KIM and Key Identifier specifying the security
      key to be\n   used for the cryptographic packet processing, including the optional\n
      \  use of signature keys (see Section 6.1).  The security policy will\n   also
      specify the algorithm (Algorithm) and level of protection\n   (Level) in the
      form of authentication or authentication and\n   encryption, and potential use
      of signatures that shall apply to the\n   outgoing packet.\n   Where encryption
      is applied, a node MUST replace the original packet\n   payload with that payload
      encrypted using the security protection,\n   key, and CCM nonce specified in
      the Security section of the packet.\n   All secured RPL messages include integrity
      protection.  In\n   conjunction with the security algorithm processing, a node
      derives\n   either a MAC or signature that MUST be included as part of the\n
      \  outgoing secured RPL packet.\n"
    title: 10.6.  Transmission of Outgoing Packets
  - contents:
    - "10.7.  Reception of Incoming Packets\n   This section describes the reception
      and processing of a secured RPL\n   packet.  Given an incoming secured RPL packet,
      where the Security\n   subfield bit of the RPL Message Code field is set, this
      section\n   describes how RPL generates an unencrypted variant of the packet
      and\n   validates its integrity.\n   The receiver uses the RPL security control
      fields to determine the\n   necessary packet security processing.  If the described
      level of\n   security for the message type and originator is unknown or does
      not\n   meet locally maintained security policies, a node MUST discard the\n
      \  packet without further processing, MAY raise a management alert, and\n   MUST
      NOT send any messages in response.  These policies can include\n   security
      levels, keys used, source identifiers, or the lack of\n   timestamp-based counters
      (as indicated by the 'T' flag).  The\n   configuration of the security policy
      database for incoming packet\n   processing is out of scope for this specification
      (it may, for\n   example, be defined through DIO Configuration or through out-of-band\n
      \  administrative router configuration).\n   Where the message Security Level
      (LVL) indicates an encrypted RPL\n   message, the node uses the key information
      identified through the KIM\n   field as well as the CCM nonce as input to the
      message payload\n   decryption processing.  The CCM nonce shall be derived from
      the\n   message Counter field and other received and locally maintained\n   information
      (see Section 10.9.1).  The plaintext message contents\n   shall be obtained
      by invoking the inverse cryptographic mode of\n   operation specified by the
      Sec field of the received packet.\n   The receiver shall use the CCM nonce and
      identified key information\n   to check the integrity of the incoming packet.
      \ If the integrity\n   check fails against the received MAC, a node MUST discard
      the packet.\n   If the received message has an initialized (zero value) counter
      value\n   and the receiver has an incoming counter currently maintained for
      the\n   originator of the message, the receiver MUST initiate a counter\n   resynchronization
      by sending a Consistency Check response message\n   (see Section 6.6) to the
      message source.  The Consistency Check\n   response message shall be protected
      with the current full outgoing\n   counter maintained for the particular node
      address.  That outgoing\n   counter will be included within the security section
      of the message\n   while the incoming counter will be included within the Consistency\n
      \  Check message payload.\n   Based on the specified security policy, a node
      MAY apply replay\n   protection for a received RPL message.  The replay check
      SHOULD be\n   performed before the authentication of the received packet.  The\n
      \  counter, as obtained from the incoming packet, shall be compared\n   against
      the watermark of the incoming counter maintained for the\n   given origination
      node address.  If the received message counter\n   value is non-zero and less
      than the maintained incoming counter\n   watermark, a potential packet replay
      is indicated and the node MUST\n   discard the incoming packet.\n   If delay
      protection is specified as part of the incoming packet\n   security policy checks,
      the Timestamp counter is used to validate the\n   timeliness of the received
      RPL message.  If the incoming message\n   Timestamp counter value indicates
      a message transmission time prior\n   to the locally maintained transmission
      time counter for the\n   originator address, a replay violation is indicated
      and the node MUST\n   discard the incoming packet.  If the received Timestamp
      counter value\n   indicates a message transmission time that is earlier than
      the\n   Current time less the acceptable packet delay, a delay violation is\n
      \  indicated and the node MUST discard the incoming packet.\n   Once a message
      has been decrypted, where applicable, and has\n   successfully passed its integrity
      check, replay check, and optionally\n   delay-protection checks, the node can
      update its local security\n   information, such as the source's expected counter
      value for replay\n   comparison.\n   A node MUST NOT update its security information
      on receipt of a\n   message that fails security policy checks or other applied
      integrity,\n   replay, or delay checks.\n"
    - contents:
      - "10.7.1.  Timestamp Key Checks\n   If the 'T' flag of a message is set and
        a node has a local timestamp\n   that follows the requirements in Section
        10.5, then a node MAY check\n   the temporal consistency of the message.  The
        node computes the\n   transmit time of the message by adding the counter value
        to the start\n   time of the associated key.  If this transmit time is past
        the end\n   time of the key, the node MAY discard the message without further\n
        \  processing.  If the transmit time is too far in the past or future\n   compared
        to the local time on the receiver, it MAY discard the\n   message without
        further processing.\n"
      title: 10.7.1.  Timestamp Key Checks
    title: 10.7.  Reception of Incoming Packets
  - contents:
    - "10.8.  Coverage of Integrity and Confidentiality\n   For a RPL ICMPv6 message,
      the entire packet is within the scope of\n   RPL security.\n   MACs and signatures
      are calculated over the entire unsecured IPv6\n   packet.  When computing MACs
      and signatures, mutable IPv6 fields are\n   considered to be filled with zeroes,
      following the rules in Section\n   3.3.3.1 of [RFC4302] (IPsec Authenticated
      Header).  MAC and signature\n   calculations are performed before any compression
      that lower layers\n   may apply.\n   When a RPL ICMPv6 message is encrypted,
      encryption starts at the\n   first byte after the Security section and continues
      to the last byte\n   of the packet.  The IPv6 header, ICMPv6 header, and RPL
      message up to\n   the end of the Security section are not encrypted, as they
      are needed\n   to correctly decrypt the packet.\n   For example, a node sending
      a message with LVL=1, KIM=0, and\n   Algorithm=0 uses the CCM algorithm [RFC3610]
      to create a packet with\n   attributes ENC-MAC-32: it encrypts the packet and
      appends a 32-bit\n   MAC.  The block cipher key is determined by the Key Index.
      \ The CCM\n   nonce is computed as described in Section 10.9.1; the message
      to\n   authenticate and encrypt is the RPL message starting at the first\n   byte
      after the Security section and ends with the last byte of the\n   packet.  The
      additional authentication data starts with the beginning\n   of the IPv6 header
      and ends with the last byte of the RPL Security\n   section.\n"
    title: 10.8.  Coverage of Integrity and Confidentiality
  - contents:
    - "10.9.  Cryptographic Mode of Operation\n   The cryptographic mode of operation
      described in this specification\n   (Algorithm = 0) is based on CCM and the
      block-cipher AES-128\n   [RFC3610].  This mode of operation is widely supported
      by existing\n   implementations.  CCM mode requires a nonce (CCM nonce).\n"
    - contents:
      - "10.9.1.  CCM Nonce\n   A RPL node constructs a CCM nonce as follows:\n        0
        \                  1                   2                   3\n        0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n       +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                                                               |\n
        \      +                       Source Identifier                       +\n
        \      |                                                               |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |                            Counter                            |\n
        \      +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \      |KIM|Resvd| LVL |\n       +-+-+-+-+-+-+-+-+\n                           Figure
        31: CCM Nonce\n   Source Identifier: 8 bytes.  Source Identifier is set to
        the logical\n         identifier of the originator of the protected packet.\n
        \  Counter: 4 bytes.  Counter is set to the (uncompressed) value of the\n
        \        corresponding field in the Security option of the RPL control\n         message.\n
        \  Key Identifier Mode (KIM): 2 bits.  KIM is set to the value of the\n         corresponding
        field in the Security option of the RPL control\n         message.\n   Security
        Level (LVL): 3 bits.  Security Level is set to the value of\n         the
        corresponding field in the Security option of the RPL\n         control message.\n
        \  Unassigned bits of the CCM nonce are reserved.  They MUST be set to\n   zero
        when constructing the CCM nonce.\n   All fields of the CCM nonce are represented
        in most significant octet\n   and most significant bit first order.\n"
      title: 10.9.1.  CCM Nonce
    - contents:
      - "10.9.2.  Signatures\n   If the KIM indicates the use of signatures (a value
        of 3), then a\n   node appends a signature to the data payload of the packet.
        \ The\n   Security Level (LVL) field describes the length of this signature.\n
        \  The signature scheme in RPL for Security Mode 3 is an instantiation\n   of
        the RSA algorithm (RSASSA-PSS) as defined in Section 8.1 of\n   [RFC3447].
        \ As public key, it uses the pair (n,e), where n is a\n   2048-bit or 3072-bit
        RSA modulus and where e=2^{16}+1.  It uses CCM\n   mode [RFC3610] as the encryption
        scheme with M=0 (as a stream-\n   cipher).  Note that although [RFC3610] disallows
        the CCM mode with\n   M=0, RPL explicitly allows the CCM mode with M=0 when
        used in\n   conjunction with a signature, because the signature provides\n
        \  sufficient data authentication.  Here, the CCM mode with M=0 is\n   specified
        as in [RFC3610], but where the M' field in Section 2.2 MUST\n   be set to
        0.  It uses the SHA-256 hash function specified in Section\n   6.2 of [FIPS180].
        \ It uses the message encoding rules of Section 8.1\n   of [RFC3447].\n   Let
        'a' be a concatenation of a 6-byte representation of counter and\n   the message
        header.  The packet payload is the right-concatenation of\n   packet data
        'm' and the signature 's'.  This signature scheme is\n   invoked with the
        right-concatenation of the message parts a and m,\n   whereas the signature
        verification is invoked with the right-\n   concatenation of the message parts
        a and m and with signature s.\n   RSA signatures of this form provide sufficient
        protection for RPL\n   networks.  If needed, alternative signature schemes
        that produce more\n   concise signatures is out of scope for this specification
        and may be\n   the subject of a future specification.\n   An implementation
        that supports RSA signing with either 2048-bit or\n   3072-bit signatures
        SHOULD support verification of both 2048-bit and\n   3072-bit RSA signatures.
        \ This is in consideration of providing an\n   upgrade path for a RPL deployment.\n"
      title: 10.9.2.  Signatures
    title: 10.9.  Cryptographic Mode of Operation
  title: 10.  Security Mechanisms
- contents:
  - '11.  Packet Forwarding and Loop Avoidance/Detection

    '
  - contents:
    - "11.1.  Suggestions for Packet Forwarding\n   This document specifies a routing
      protocol.  These non-normative\n   suggestions are provided to aid in the design
      of a forwarding\n   implementation by illustrating how such an implementation
      could work\n   with RPL.\n   When forwarding a packet to a destination, precedence
      is given to\n   selection of a next-hop successor as follows:\n   1.  This specification
      only covers how a successor is selected from\n       the DODAG Version that
      matches the RPLInstanceID marked in the\n       IPv6 header of the packet being
      forwarded.  Routing outside the\n       instance can be done as long as additional
      rules are put in place\n       such as strict ordering of instances and routing
      protocols to\n       protect against loops.  Such rules may be defined in a
      separate\n       document.\n   2.  If a local administrative preference favors
      a route that has been\n       learned from a different routing protocol than
      RPL, then use that\n       successor.\n   3.  If the packet header specifies
      a source route by including an RH4\n       header as specified in [RFC6554],
      then use that route.  If the\n       node fails to forward the packet with that
      specified source\n       route, then that packet should be dropped.  The node
      MAY log an\n       error.  The node may send an ICMPv6 error in Source Routing\n
      \      Header message to the source of the packet (see Section 20.18).\n   4.
      \ If there is an entry in the routing table matching the\n       destination
      that has been learned from a multicast destination\n       advertisement (e.g.,
      the destination is a one-hop neighbor), then\n       use that successor.\n   5.
      \ If there is an entry in the routing table matching the\n       destination
      that has been learned from a unicast destination\n       advertisement (e.g.,
      the destination is located Down the sub-\n       DODAG), then use that successor.
      \ If there are DAO Path Control\n       bits associated with multiple successors,
      then consult the Path\n       Control bits to order the successors by preference
      when choosing.\n       If, for a given DAO Path Control bit, multiple successors
      are\n       recorded as having asserted that bit, precedence should be given\n
      \      to the successor who most recently asserted that bit.\n   6.  If there
      is a DODAG Version offering a route to a prefix matching\n       the destination,
      then select one of those DODAG parents as a\n       successor according to the
      OF and routing metrics.\n   7.  Any other as-yet-unattempted DODAG parent may
      be chosen for the\n       next attempt to forward a unicast packet when no better
      match\n       exists.\n   8.  Finally, the packet is dropped.  ICMP Destination
      Unreachable MAY\n       be invoked (an inconsistency is detected).\n   Hop Limit
      MUST be decremented when forwarding per [RFC2460].\n   Note that the chosen
      successor MUST NOT be the neighbor that was the\n   predecessor of the packet
      (split horizon), except in the case where\n   it is intended for the packet
      to change from an Upward to a Downward\n   direction, as determined by the routing
      table of the node making the\n   change, such as switching from DIO routes to
      DAO routes as the\n   destination is neared in order to continue traveling toward
      the\n   destination.\n"
    title: 11.1.  Suggestions for Packet Forwarding
  - contents:
    - "11.2.  Loop Avoidance and Detection\n   RPL loop avoidance mechanisms are kept
      simple and designed to\n   minimize churn and states.  Loops may form for a
      number of reasons,\n   e.g., control packet loss.  RPL includes a reactive loop
      detection\n   technique that protects from meltdown and triggers repair of broken\n
      \  paths.\n   RPL loop detection uses RPL Packet Information that is transported\n
      \  within the data packets, relying on an external mechanism such as\n   [RFC6553]
      that places in the RPL Packet Information in an IPv6 Hop-\n   by-Hop option
      header.\n   The content of RPL Packet Information is defined as follows:\n   Down
      'O': 1-bit flag indicating whether the packet is expected to\n         progress
      Up or Down.  A router sets the 'O' flag when the\n         packet is expected
      to progress Down (using DAO routes), and\n         clears it when forwarding
      toward the DODAG root (to a node with\n         a lower Rank).  A host or RPL
      leaf node MUST set the 'O' flag\n         to 0.\n   Rank-Error 'R': 1-bit flag
      indicating whether a Rank error was\n         detected.  A Rank error is detected
      when there is a mismatch in\n         the relative Ranks and the direction as
      indicated in the 'O'\n         bit.  A host or RPL leaf node MUST set the 'R'
      bit to 0.\n   Forwarding-Error 'F': 1-bit flag indicating that this node cannot\n
      \        forward the packet further towards the destination.  The 'F'\n         bit
      might be set by a child node that does not have a route to\n         destination
      for a packet with the Down 'O' bit set.  A host or\n         RPL leaf node MUST
      set the 'F' bit to 0.\n   RPLInstanceID: 8-bit field indicating the DODAG instance
      along which\n         the packet is sent.\n   SenderRank: 16-bit field set to
      zero by the source and to\n         DAGRank(rank) by a router that forwards
      inside the RPL network.\n"
    - contents:
      - "11.2.1.  Source Node Operation\n   If the source is aware of the RPLInstanceID
        that is preferred for the\n   packet, then it MUST set the RPLInstanceID field
        associated with the\n   packet accordingly; otherwise, it MUST set it to the\n
        \  RPL_DEFAULT_INSTANCE.\n"
      title: 11.2.1.  Source Node Operation
    - contents:
      - '11.2.2.  Router Operation

        '
      - contents:
        - "11.2.2.1.  Instance Forwarding\n   The RPLInstanceID is associated by the
          source with the packet.  This\n   RPLInstanceID MUST match the RPL Instance
          onto which the packet is\n   placed by any node, be it a host or router.
          \ The RPLInstanceID is\n   part of the RPL Packet Information.\n   A RPL
          router that forwards a packet in the RPL network MUST check if\n   the packet
          includes the RPL Packet Information.  If not, then the RPL\n   router MUST
          insert the RPL Packet Information.  If the router is an\n   ingress router
          that injects the packet into the RPL network, the\n   router MUST set the
          RPLInstanceID field in the RPL Packet\n   Information.  The details of how
          that router determines the mapping\n   to a RPLInstanceID are out of scope
          for this specification and left\n   to future specification.\n   A router
          that forwards a packet outside the RPL network MUST remove\n   the RPL Packet
          Information.\n   When a router receives a packet that specifies a given
          RPLInstanceID\n   and the node can forward the packet along the DODAG associated
          to\n   that instance, then the router MUST do so and leave the RPLInstanceID\n
          \  value unchanged.\n   If any node cannot forward a packet along the DODAG
          associated with\n   the RPLInstanceID, then the node SHOULD discard the
          packet and send\n   an ICMP error message.\n"
        title: 11.2.2.1.  Instance Forwarding
      - contents:
        - "11.2.2.2.  DAG Inconsistency Loop Detection\n   The DODAG is inconsistent
          if the direction of a packet does not match\n   the Rank relationship.  A
          receiver detects an inconsistency if it\n   receives a packet with either:\n
          \     the 'O' bit set (to Down) from a node of a higher Rank.\n      the
          'O' bit cleared (for Up) from a node of a lower Rank.\n   When the DODAG
          root increments the DODAGVersionNumber, a temporary\n   Rank discontinuity
          may form between the next DODAG Version and the\n   prior DODAG Version,
          in particular, if nodes are adjusting their Rank\n   in the next DODAG Version
          and deferring their migration into the next\n   DODAG Version.  A router
          that is still a member of the prior DODAG\n   Version may choose to forward
          a packet to a (future) parent that is\n   in the next DODAG Version.  In
          some cases, this could cause the\n   parent to detect an inconsistency because
          the Rank-ordering in the\n   prior DODAG Version is not necessarily the
          same as in the next DODAG\n   Version, and the packet may be judged not
          to be making forward\n   progress.  If the sending router is aware that
          the chosen successor\n   has already joined the next DODAG Version, then
          the sending router\n   MUST update the SenderRank to INFINITE_RANK as it
          forwards the\n   packets across the discontinuity into the next DODAG Version
          in order\n   to avoid a false detection of Rank inconsistency.\n   One inconsistency
          along the path is not considered a critical error\n   and the packet may
          continue.  However, a second detection along the\n   path of the same packet
          should not occur and the packet MUST be\n   dropped.\n   This process is
          controlled by the Rank-Error bit associated with the\n   packet.  When an
          inconsistency is detected on a packet, if the Rank-\n   Error bit was not
          set, then the Rank-Error bit is set.  If it was set\n   the packet MUST
          be discarded and the Trickle timer MUST be reset.\n"
        title: 11.2.2.2.  DAG Inconsistency Loop Detection
      - contents:
        - "11.2.2.3.  DAO Inconsistency Detection and Recovery\n   DAO inconsistency
          loop recovery is a mechanism that applies to\n   Storing mode of operation
          only.\n   In Non-Storing mode, the packets are source routed to the\n   destination,
          and DAO inconsistencies are not corrected locally.\n   Instead, an ICMP
          error with a new code \"Error in Source Routing\n   Header\" is sent back
          to the root.  The \"Error in Source Routing\n   Header\" message has the
          same format as the \"Destination Unreachable\n   Message\", as specified
          in [RFC4443].  The portion of the invoking\n   packet that is sent back
          in the ICMP message should record at least\n   up to the routing header,
          and the routing header should be consumed\n   by this node so that the destination
          in the IPv6 header is the next\n   hop that this node could not reach.\n
          \  A DAO inconsistency happens when a router has a Downward route that\n
          \  was previously learned from a DAO message via a child, but that\n   Downward
          route is not longer valid in the child, e.g., because that\n   related state
          in the child has been cleaned up.  With DAO\n   inconsistency loop recovery,
          a packet can be used to recursively\n   explore and clean up the obsolete
          DAO states along a sub-DODAG.\n   In a general manner, a packet that goes
          Down should never go Up\n   again.  If DAO inconsistency loop recovery is
          applied, then the\n   router SHOULD send the packet back to the parent that
          passed it with\n   the Forwarding-Error 'F' bit set and the 'O' bit left
          untouched.\n   Otherwise, the router MUST silently discard the packet.\n
          \  Upon receiving a packet with a Forwarding-Error bit set, the node\n   MUST
          remove the routing states that caused forwarding to that\n   neighbor, clear
          the Forwarding-Error bit, and attempt to send the\n   packet again.  The
          packet may be sent to an alternate neighbor, after\n   the expiration of
          a user-configurable implementation-specific timer.\n   If that alternate
          neighbor still has an inconsistent DAO state via\n   this node, the process
          will recurse, this node will set the\n   Forwarding-Error 'F' bit, and the
          routing state in the alternate\n   neighbor will be cleaned up as well.\n"
        title: 11.2.2.3.  DAO Inconsistency Detection and Recovery
      title: 11.2.2.  Router Operation
    title: 11.2.  Loop Avoidance and Detection
  title: 11.  Packet Forwarding and Loop Avoidance/Detection
- contents:
  - "12.  Multicast Operation\n   This section describes a multicast routing operation
    over an IPv6 RPL\n   network and, specifically, how unicast DAOs can be used to
    relay\n   group registrations.  The same DODAG construct can be used to forward\n
    \  unicast and multicast traffic.  This section is limited to a\n   description
    of how group registrations may be exchanged and how the\n   forwarding infrastructure
    operates.  It does not provide a full\n   description of multicast within an LLN
    and, in particular, does not\n   describe the generation of DODAGs specifically
    targeted at multicast\n   or the details of operating RPL for multicast -- that
    will be the\n   subject of further specifications.\n   The multicast group registration
    uses DAO messages that are identical\n   to unicast except for the type of address
    that is transported.  The\n   main difference is that the multicast traffic going
    down is copied to\n   all the children that have registered with the multicast
    group,\n   whereas unicast traffic is passed to one child only.\n   Nodes that
    support the RPL Storing mode of operation SHOULD also\n   support multicast DAO
    operations as described below.  Nodes that only\n   support the Non-Storing mode
    of operation are not expected to support\n   this section.\n   The multicast operation
    is controlled by the MOP field in the DIO.\n   o  If the MOP field requires multicast
    support, then a node that\n      joins the RPL network as a router must operate
    as described in\n      this section for multicast signaling and forwarding within
    the RPL\n      network.  A node that does not support the multicast operation\n
    \     required by the MOP field can only join as a leaf.\n   o  If the MOP field
    does not require multicast support, then\n      multicast is handled by some other
    way that is out of scope for\n      this specification.  (Examples may include
    a series of unicast\n      copies or limited-scope flooding).\n   A router might
    select to pass a listener registration DAO message to\n   its preferred parent
    only; in which case, multicast packets coming\n   back might be lost for all of
    its sub-DODAGs if the transmission\n   fails over that link.  Alternatively, the
    router might select copying\n   additional parents as it would do for DAO messages
    advertising\n   unicast destinations; in which case, there might be duplicates
    that\n   the router will need to prune.\n   As a result, multicast routing states
    are installed in each router on\n   the way from the listeners to the DODAG root,
    enabling the root to\n   copy a multicast packet to all its children routers that
    had issued a\n   DAO message including a Target option for that multicast group.\n
    \  For a multicast packet sourced from inside the DODAG, the packet is\n   passed
    to the preferred parents, and if that fails, then to the\n   alternates in the
    DODAG.  The packet is also copied to all the\n   registered children, except for
    the one that passed the packet.\n   Finally, if there is a listener in the external
    infrastructure, then\n   the DODAG root has to further propagate the packet into
    the external\n   infrastructure.\n   As a result, the DODAG root acts as an automatic
    proxy Rendezvous\n   Point for the RPL network and as source towards the non-RPL
    domain\n   for all multicast flows started in the RPL domain.  So, regardless
    of\n   whether the root is actually attached to a non-RPL domain, and\n   regardless
    of whether the DODAG is grounded or floating, the root can\n   serve inner multicast
    streams at all times.\n"
  title: 12.  Multicast Operation
- contents:
  - "13.  Maintenance of Routing Adjacency\n   The selection of successors, along
    the default paths Up along the\n   DODAG, or along the paths learned from destination
    advertisements\n   Down along the DODAG, leads to the formation of routing adjacencies\n
    \  that require maintenance.\n   In IGPs, such as OSPF [RFC4915] or IS-IS [RFC5120],
    the maintenance\n   of a routing adjacency involves the use of keepalive mechanisms\n
    \  (Hellos) or other protocols such as the Bidirectional Forwarding\n   Detection
    (BFD) [RFC5881] and the MANET Neighborhood Discovery\n   Protocol (NHDP) [RFC6130].
    \ Unfortunately, such a proactive approach\n   is often not desirable in constrained
    environments where it would\n   lead to excessive control traffic in light of
    the data traffic with a\n   negative impact on both link loads and nodes resources.\n
    \  By contrast with those routing protocols, RPL does not define any\n   keepalive
    mechanisms to detect routing adjacency failures: this is\n   because in many cases,
    such a mechanism would be too expensive in\n   terms of bandwidth and, even more
    importantly, energy (a battery-\n   operated device could not afford to send periodic
    keepalives).  Still\n   RPL requires an external mechanisms to detect that a neighbor
    is no\n   longer reachable.  Such a mechanism should preferably be reactive to\n
    \  traffic in order to minimize the overhead to maintain the routing\n   adjacency
    and focus on links that are actually being used.\n   Example reactive mechanisms
    that can be used include:\n      The Neighbor Unreachability Detection [RFC4861]
    mechanism.\n      Layer 2 triggers [RFC5184] derived from events such as association\n
    \     states and L2 acknowledgements.\n"
  title: 13.  Maintenance of Routing Adjacency
- contents:
  - "14.  Guidelines for Objective Functions\n   An Objective Function (OF), in conjunction
    with routing metrics and\n   constraints, allows for the selection of a DODAG
    to join, and a\n   number of peers in that DODAG as parents.  The OF is used to
    compute\n   an ordered list of parents.  The OF is also responsible to compute\n
    \  the Rank of the device within the DODAG Version.\n   The Objective Function
    is indicated in the DIO message using an\n   Objective Code Point (OCP), and it
    indicates the method that must be\n   used to construct the DODAG.  The Objective
    Code Points are specified\n   in [RFC6552] and related companion specifications.\n"
  - contents:
    - "14.1.  Objective Function Behavior\n   Most Objective Functions are expected
      to follow the same abstract\n   behavior at a node:\n   o  The parent selection
      is triggered each time an event indicates\n      that a potential next-hop information
      is updated.  This might\n      happen upon the reception of a DIO message, a
      timer elapse, all\n      DODAG parents are unavailable, or a trigger indicating
      that the\n      state of a candidate neighbor has changed.\n   o  An OF scans
      all the interfaces on the node.  Although, there may\n      typically be only
      one interface in most application scenarios,\n      there might be multiple
      of them and an interface might be\n      configured to be usable or not for
      RPL operation.  An interface\n      can also be configured with a preference
      or dynamically learned to\n      be better than another by some heuristics that
      might be link-layer\n      dependent and are out of scope for this specification.
      \ Finally,\n      an interface might or might not match a required criterion
      for an\n      Objective Function, for instance, a degree of security.  As a\n
      \     result, some interfaces might be completely excluded from the\n      computation,
      for example, if those interfaces cannot satisfy some\n      advertised constraints,
      while others might be more or less\n      preferred.\n   o  An OF scans all
      the candidate neighbors on the possible interfaces\n      to check whether they
      can act as a router for a DODAG.  There\n      might be many of them and a candidate
      neighbor might need to pass\n      some validation tests before it can be used.
      \ In particular, some\n      link layers require experience on the activity
      with a router to\n      enable the router as a next hop.\n   o  An OF computes
      Rank of a node for comparison by adding to the Rank\n      of the candidate
      a value representing the relative locations of\n      the node and the candidate
      in the DODAG Version.\n      *  The increase in Rank must be at least MinHopRankIncrease.\n
      \     *  To keep loop avoidance and metric optimization in alignment,\n         the
      increase in Rank should reflect any increase in the metric\n         value.
      \ For example, with a purely additive metric, such as\n         ETX, the increase
      in Rank can be made proportional to the\n         increase in the metric.\n
      \     *  Candidate neighbors that would cause the Rank of the node to\n         increase
      are not considered for parent selection.\n   o  Candidate neighbors that advertise
      an OF incompatible with the set\n      of OFs specified by the policy functions
      are ignored.\n   o  As it scans all the candidate neighbors, the OF keeps the
      current\n      best parent and compares its capabilities with the current\n
      \     candidate neighbor.  The OF defines a number of tests that are\n      critical
      to reach the objective.  A test between the routers\n      determines an order
      relation.\n      *  If the routers are equal for that relation, then the next
      test\n         is attempted between the routers,\n      *  Else the best of
      the two routers becomes the current best\n         parent, and the scan continues
      with the next candidate\n         neighbor.\n      *  Some OFs may include a
      test to compare the Ranks that would\n         result if the node joined either
      router.\n   o  When the scan is complete, the preferred parent is elected and
      the\n      node's Rank is computed as the preferred parent Rank plus the step\n
      \     in Rank with that parent.\n   o  Other rounds of scans might be necessary
      to elect alternate\n      parents.  In the next rounds:\n      *  Candidate
      neighbors that are not in the same DODAG are ignored.\n      *  Candidate neighbors
      that are of greater Rank than the node are\n         ignored.\n      *  Candidate
      neighbors of an equal Rank to the node are ignored\n         for parent selection.\n
      \     *  Candidate neighbors of a lesser Rank than the node are\n         preferred.\n"
    title: 14.1.  Objective Function Behavior
  title: 14.  Guidelines for Objective Functions
- contents:
  - "15.  Suggestions for Interoperation with Neighbor Discovery\n   This specification
    directly borrows the Prefix Information Option\n   (PIO) and the Route Information
    Option (RIO) from IPv6 ND.  It is\n   envisioned that, as future specifications
    build on this base, there\n   may be additional cause to leverage parts of IPv6
    ND.  This section\n   provides some suggestions for future specifications.\n   First
    and foremost, RPL is a routing protocol.  One should take great\n   care to preserve
    architecture when mapping functionalities between\n   RPL and ND.  RPL is for
    routing only.  That said, there may be\n   persuading technical reasons to allow
    for sharing options between RPL\n   and IPv6 ND in a particular implementation/deployment.\n
    \  In general, the following guidelines apply:\n   o  RPL Type codes must be allocated
    from the RPL Control Message\n      Options registry.\n   o  RPL Length fields
    must be expressed in units of single octets, as\n      opposed to ND Length fields,
    which are expressed in units of 8\n      octets.\n   o  RPL options are generally
    not required to be aligned to 8-octet\n      boundaries.\n   o  When mapping/transposing
    an IPv6 ND option for redistribution as a\n      RPL option, any padding octets
    should be removed when possible.\n      For example, the Prefix Length field in
    the PIO is sufficient to\n      describe the length of the Prefix field.  When
    mapping/transposing\n      a RPL option for redistribution as an IPv6 ND option,
    any such\n      padding octets should be restored.  This procedure must be\n      unambiguous.\n"
  title: 15.  Suggestions for Interoperation with Neighbor Discovery
- contents:
  - "16.  Summary of Requirements for Interoperable Implementations\n   This section
    summarizes basic interoperability and references\n   normative text for RPL implementations
    operating in one of three\n   major modes.  Implementations are expected to support
    either no\n   Downward routes, Non-Storing mode only, or Storing mode only.  A\n
    \  fourth mode, operation as a leaf, is also possible.\n   Implementations conforming
    to this specification may contain\n   different subsets of capabilities as appropriate
    to the application\n   scenario.  It is important for the implementer to support
    a level of\n   interoperability consistent with that required by the application\n
    \  scenario.  To this end, further guidance may be provided beyond this\n   specification
    (e.g., as applicability statements), and it is\n   understood that in some cases
    such further guidance may override\n   portions of this specification.\n"
  - contents:
    - "16.1.  Common Requirements\n   In a general case, the greatest level of interoperability
      may be\n   achieved when all of the nodes in a RPL LLN are cooperating to use\n
      \  the same MOP, OF, metrics, and constraints, and are thus able to act\n   as
      RPL routers.  When a node is not capable of being a RPL router, it\n   may be
      possible to interoperate in a more limited manner as a RPL\n   leaf.\n   All
      RPL implementations need to support the use of RPL Packet\n   Information transported
      within data packets (Section 11.2).  One such\n   mechanism is described in
      [RFC6553].\n   RPL implementations will need to support the use of Neighbor\n
      \  Unreachability Detection (NUD), or an equivalent mechanism, to\n   maintain
      the reachability of neighboring RPL nodes (Section 8.2.1).\n   Alternate mechanisms
      may be optimized to the constrained capabilities\n   of the implementation,
      such as hints from the link layer.\n   This specification provides means to
      obtain a PIO and thus form an\n   IPv6 address.  When that mechanism is used,
      it may be necessary to\n   perform address resolution and duplicate address
      detection through an\n   external process, such as IPv6 ND [RFC4861] or 6LoWPAN
      ND\n   [6LOWPAN-ND].\n"
    title: 16.1.  Common Requirements
  - contents:
    - "16.2.  Operation as a RPL Leaf Node (Only)\n   o  An implementation of a leaf
      node (only) does not ever participate\n      as a RPL router.  Interoperable
      implementations of leaf nodes\n      behave as summarized in Section 8.5.\n
      \  o  Support of a particular MOP encoding is not required, although if\n      the
      leaf node sends DAO messages to set up Downward routes, the\n      leaf node
      should do so in a manner consistent with the mode of\n      operation indicated
      by the MOP.\n   o  Support of a particular OF is not required.\n   o  In summary,
      a leaf node does not generally issue DIO messages, it\n      may issue DAO and
      DIS messages.  A leaf node accepts DIO messages\n      though it generally ignores
      DAO and DIS messages.\n"
    title: 16.2.  Operation as a RPL Leaf Node (Only)
  - contents:
    - "16.3.  Operation as a RPL Router\n   If further guidance is not available then
      a RPL router implementation\n   MUST at least support the metric-less OF0 [RFC6552].\n
      \  For consistent operation a RPL router implementation needs to support\n   the
      MOP in use by the DODAG.\n   All RPL routers will need to implement Trickle
      [RFC6206].\n"
    - contents:
      - "16.3.1.  Support for Upward Routes (Only)\n   An implementation of a RPL
        router that supports only Upward routes\n   supports the following:\n   o
        \ Upward routes (Section 8)\n   o  MOP encoding 0 (Section 20.3)\n   o  In
        summary, DIO and DIS messages are issued, and DAO messages are\n      not
        issued.  DIO and DIS messages are accepted, and DAO messages\n      are ignored.\n"
      title: 16.3.1.  Support for Upward Routes (Only)
    - contents:
      - "16.3.2.  Support for Upward Routes and Downward Routes in Non-Storing\n         Mode\n
        \  An implementation of a RPL router that supports Upward routes and\n   Downward
        routes in Non-Storing mode supports the following:\n   o  Upward routes (Section
        8)\n   o  Downward routes (Non-Storing) (Section 9)\n   o  MOP encoding 1
        (Section 20.3)\n   o  Source-routed Downward traffic ([RFC6554])\n   o  In
        summary, DIO and DIS messages are issued, and DAO messages are\n      issued
        to the DODAG root.  DIO and DIS messages are accepted, and\n      DAO messages
        are ignored by nodes other than DODAG roots.\n      Multicast is not supported
        through the means described in this\n      specification, though it may be
        supported through some alternate\n      means.\n"
      title: 16.3.2.  Support for Upward Routes and Downward Routes in Non-Storing
    - contents:
      - "16.3.3.  Support for Upward Routes and Downward Routes in Storing Mode\n
        \  An implementation of a RPL router that supports Upward routes and\n   Downward
        routes in Storing mode supports the following:\n   o  Upward routes (Section
        8)\n   o  Downward routes (Storing) (Section 9)\n   o  MOP encoding 2 (Section
        20.3)\n   o  In summary, DIO, DIS, and DAO messages are issued.  DIO, DIS,
        and\n      DAO messages are accepted.  Multicast is not supported through
        the\n      means described in this specification, though it may be supported\n
        \     through some alternate means.\n"
      - contents:
        - "16.3.3.1.  Optional Support for Basic Multicast Scheme\n   A Storing mode
          implementation may be enhanced with basic multicast\n   support through
          the following additions:\n   o  Basic Multicast Support (Section 12)\n   o
          \ MOP encoding 3 (Section 20.3)\n"
        title: 16.3.3.1.  Optional Support for Basic Multicast Scheme
      title: 16.3.3.  Support for Upward Routes and Downward Routes in Storing Mode
    title: 16.3.  Operation as a RPL Router
  - contents:
    - "16.4.  Items for Future Specification\n   A number of items are left to future
      specification, including but not\n   limited to the following:\n   o  How to
      attach a non-RPL node such as an IPv6 host, e.g., to\n      consistently distribute
      at least PIO material to the attached\n      node.\n   o  How to obtain authentication
      material in support if authenticated\n      mode is used (Section 10.3).\n   o
      \ Details of operation over multiple simultaneous instances.\n   o  Advanced
      configuration mechanisms, such as the provisioning of\n      RPLInstanceIDs,
      parameterization of Objective Functions, and\n      parameters to control security.
      \ (It is expected that such\n      mechanisms might extend the DIO as a means
      to disseminate\n      information across the DODAG).\n"
    title: 16.4.  Items for Future Specification
  title: 16.  Summary of Requirements for Interoperable Implementations
- contents:
  - "17.  RPL Constants and Variables\n   The following is a summary of RPL constants
    and variables:\n   BASE_RANK: This is the Rank for a virtual root that might be
    used to\n         coordinate multiple roots.  BASE_RANK has a value of 0.\n   ROOT_RANK:
    This is the Rank for a DODAG root.  ROOT_RANK has a value\n         of MinHopRankIncrease
    (as advertised by the DODAG root), such\n         that DAGRank(ROOT_RANK) is 1.\n
    \  INFINITE_RANK: This is the constant maximum for the Rank.\n         INFINITE_RANK
    has a value of 0xFFFF.\n   RPL_DEFAULT_INSTANCE: This is the RPLInstanceID that
    is used by this\n         protocol by a node without any overriding policy.\n
    \        RPL_DEFAULT_INSTANCE has a value of 0.\n   DEFAULT_PATH_CONTROL_SIZE:
    This is the default value used to\n         configure PCS in the DODAG Configuration
    option, which dictates\n         the number of significant bits in the Path Control
    field of the\n         Transit Information option.  DEFAULT_PATH_CONTROL_SIZE
    has a\n         value of 0.  This configures the simplest case limiting the\n
    \        fan-out to 1 and limiting a node to send a DAO message to only\n         one
    parent.\n   DEFAULT_DIO_INTERVAL_MIN: This is the default value used to configure\n
    \        Imin for the DIO Trickle timer.  DEFAULT_DIO_INTERVAL_MIN has a\n         value
    of 3.  This configuration results in Imin of 8 ms.\n   DEFAULT_DIO_INTERVAL_DOUBLINGS:
    This is the default value used to\n         configure Imax for the DIO Trickle
    timer.\n         DEFAULT_DIO_INTERVAL_DOUBLINGS has a value of 20.  This\n         configuration
    results in a maximum interval of 2.3 hours.\n   DEFAULT_DIO_REDUNDANCY_CONSTANT:
    This is the default value used to\n         configure k for the DIO Trickle timer.\n
    \        DEFAULT_DIO_REDUNDANCY_CONSTANT has a value of 10.  This\n         configuration
    is a conservative value for Trickle suppression\n         mechanism.\n   DEFAULT_MIN_HOP_RANK_INCREASE:
    This is the default value of\n         MinHopRankIncrease.  DEFAULT_MIN_HOP_RANK_INCREASE
    has a value\n         of 256.  This configuration results in an 8-bit wide integer\n
    \        part of Rank.\n   DEFAULT_DAO_DELAY: This is the default value for the
    DelayDAO Timer.\n         DEFAULT_DAO_DELAY has a value of 1 second.  See Section
    9.5.\n   DIO Timer: One instance per DODAG of which a node is a member.\n         Expiry
    triggers DIO message transmission.  A Trickle timer with\n         variable interval
    in [0,\n         DIOIntervalMin..2^DIOIntervalDoublings].  See Section 8.3.1\n
    \  DAG Version Increment Timer: Up to one instance per DODAG of which\n         the
    node is acting as DODAG root.  May not be supported in all\n         implementations.
    \ Expiry triggers increment of\n         DODAGVersionNumber, causing a new series
    of updated DIO message\n         to be sent.  Interval should be chosen appropriate
    to\n         propagation time of DODAG and as appropriate to application\n         requirements
    (e.g., response time versus overhead).\n   DelayDAO Timer: Up to one timer per
    DAO parent (the subset of DODAG\n         parents chosen to receive destination
    advertisements) per\n         DODAG.  Expiry triggers sending of DAO message to
    the DAO\n         parent.  See Section 9.5\n   RemoveTimer: Up to one timer per
    DAO entry per neighbor (i.e., those\n         neighbors that have given DAO messages
    to this node as a DODAG\n         parent).  Expiry may trigger No-Path advertisements
    or\n         immediately deallocate the DAO entry if there are no DAO\n         parents.\n"
  title: 17.  RPL Constants and Variables
- contents:
  - "18.  Manageability Considerations\n   The aim of this section is to give consideration
    to the manageability\n   of RPL, and how RPL will be operated in an LLN.  The
    scope of this\n   section is to consider the following aspects of manageability:\n
    \  configuration, monitoring, fault management, accounting, and\n   performance
    of the protocol in light of the recommendations set forth\n   in [RFC5706].\n"
  - contents:
    - "18.1.  Introduction\n   Most of the existing IETF management standards are
      MIB modules (data\n   models based on the Structure of Management Information
      (SMI)) to\n   monitor and manage networking devices.\n   For a number of protocols,
      the IETF community has used the IETF\n   Standard Management Framework, including
      the Simple Network\n   Management Protocol [RFC3410], the Structure of Management\n
      \  Information [RFC2578], and MIB data models for managing new\n   protocols.\n
      \  As pointed out in [RFC5706], the common policy in terms of operation\n   and
      management has been expanded to a policy that is more open to a\n   set of tools
      and management protocols rather than strictly relying on\n   a single protocol
      such as SNMP.\n   In 2003, the Internet Architecture Board (IAB) held a workshop
      on\n   Network Management [RFC3535] that discussed the strengths and\n   weaknesses
      of some IETF network management protocols and compared\n   them to operational
      needs, especially configuration.\n   One issue discussed was the user-unfriendliness
      of the binary format\n   of SNMP [RFC3410].  In the case of LLNs, it must be
      noted that at the\n   time of writing, the CoRE working group is actively working
      on\n   resource management of devices in LLNs.  Still, it is felt that this\n
      \  section provides important guidance on how RPL should be deployed,\n   operated,
      and managed.\n   As stated in [RFC5706]:\n      A management information model
      should include a discussion of what\n      is manageable, which aspects of the
      protocol need to be\n      configured, what types of operations are allowed,
      what protocol-\n      specific events might occur, which events can be counted,
      and for\n      which events an operator should be notified.\n   These aspects
      are discussed in detail in the following sections.\n   RPL will be used on a
      variety of devices that may have resources such\n   as memory varying from a
      few kilobytes to several hundreds of\n   kilobytes and even megabytes.  When
      memory is highly constrained, it\n   may not be possible to satisfy all the
      requirements listed in this\n   section.  Still it is worth listing all of these
      in an exhaustive\n   fashion, and implementers will then determine which of
      these\n   requirements could be satisfied according to the available resources\n
      \  on the device.\n"
    title: 18.1.  Introduction
  - contents:
    - "18.2.  Configuration Management\n   This section discusses the configuration
      management, listing the\n   protocol parameters for which configuration management
      is relevant.\n   Some of the RPL parameters are optional.  The requirements
      for\n   configuration are only applicable for the options that are used.\n"
    - contents:
      - "18.2.1.  Initialization Mode\n   \"Architectural Principles of the Internet\"
        [RFC1958], Section 3.8,\n   states: \"Avoid options and parameters whenever
        possible.  Any options\n   and parameters should be configured or negotiated
        dynamically rather\n   than manually\".  This is especially true in LLNs where
        the number of\n   devices may be large and manual configuration is infeasible.
        \ This\n   has been taken into account in the design of RPL whereby the DODAG\n
        \  root provides a number of parameters to the devices joining the\n   DODAG,
        thus avoiding cumbersome configuration on the routers and\n   potential sources
        of misconfiguration (e.g., values of Trickle\n   timers, etc.).  Still, there
        are additional RPL parameters that a RPL\n   implementation should allow to
        be configured, which are discussed in\n   this section.\n"
      - contents:
        - "18.2.1.1.  DIS Mode of Operation upon Boot-Up\n   When a node is first
          powered up:\n   1.  The node may decide to stay silent, waiting to receive
          DIO\n       messages from DODAG of interest (advertising a supported OF
          and\n       metrics/constraints) and not send any multicast DIO messages\n
          \      until it has joined a DODAG.\n   2.  The node may decide to send
          one or more DIS messages (optionally,\n       requesting DIO for a specific
          DODAG) as an initial probe for\n       nearby DODAGs, and in the absence
          of DIO messages in reply after\n       some configurable period of time,
          the node may decide to root a\n       floating DODAG and start sending multicast
          DIO messages.\n   A RPL implementation SHOULD allow configuring the preferred
          mode of\n   operation listed above along with the required parameters (in
          the\n   second mode: the number of DIS messages and related timer).\n"
        title: 18.2.1.1.  DIS Mode of Operation upon Boot-Up
      title: 18.2.1.  Initialization Mode
    - contents:
      - "18.2.2.  DIO and DAO Base Message and Options Configuration\n   RPL specifies
        a number of protocol parameters considering the large\n   spectrum of applications
        where it will be used.  That said,\n   particular attention has been given
        to limiting the number of these\n   parameters that must be configured on
        each RPL router.  Instead, a\n   number of the default values can be used,
        and when required these\n   parameters can be provided by the DODAG root thus
        allowing for\n   dynamic parameter setting.\n   A RPL implementation SHOULD
        allow configuring the following routing\n   protocol parameters.  As pointed
        out above, note that a large set of\n   parameters is configured on the DODAG
        root.\n"
      title: 18.2.2.  DIO and DAO Base Message and Options Configuration
    - contents:
      - "18.2.3.  Protocol Parameters to Be Configured on Every Router in the LLN\n
        \  A RPL implementation MUST allow configuring the following RPL\n   parameters:\n
        \  o  RPLInstanceID [DIO message, in DIO Base message].  Although the\n      RPLInstanceID
        must be configured on the DODAG root, it must also\n      be configured as
        a policy on every node in order to determine\n      whether or not the node
        should join a particular DODAG.  Note that\n      a second RPLInstanceID can
        be configured on the node, should it\n      become root of a floating DODAG.\n
        \  o  List of supported Objective Code Points (OCPs)\n   o  List of supported
        metrics: [RFC6551] specifies a number of metrics\n      and constraints used
        for the DODAG formation.  Thus, a RPL\n      implementation should allow configuring
        the list of metrics that a\n      node can accept and understand.  If a DIO
        is received with a\n      metric and/or constraint that is not understood
        or supported, as\n      specified in Section 8.5, the node would join as a
        leaf node.\n   o  Prefix Information, along with valid and preferred lifetime
        and\n      the 'L' and 'A' flags.  [DIO message, Prefix Information Option].\n
        \     A RPL implementation SHOULD allow configuring if the Prefix\n      Information
        option must be carried with the DIO message to\n      distribute the Prefix
        Information for autoconfiguration.  In that\n      case, the RPL implementation
        MUST allow the list of prefixes to be\n      advertised in the PIO along with
        the corresponding flags.\n   o  Solicited Information [DIS message, in Solicited
        Information\n      option].  Note that a RPL implementation SHOULD allow configuring\n
        \     when such messages should be sent and under which circumstances,\n      along
        with the value of the RPLInstance ID, 'V'/'I'/'D' flags.\n   o  'K' flag:
        when a node should set the 'K' flag in a DAO message\n      [DAO message,
        in DAO Base message].\n   o  MOP (Mode of Operation) [DIO message, in DIO
        Base message].\n   o  Route Information (and preference) [DIO message, in
        Route\n      Information option]\n"
      title: 18.2.3.  Protocol Parameters to Be Configured on Every Router in the
        LLN
    - contents:
      - "18.2.4.  Protocol Parameters to Be Configured on Every Non-DODAG-Root\n         Router
        in the LLN\n   A RPL implementation MUST allow configuring the Target prefix
        [DAO\n   message, in RPL Target option].\n   Furthermore, there are circumstances
        where a node may want to\n   designate a Target to allow for specific processing
        of the Target\n   (prioritization, etc.).  Such processing rules are out of
        scope for\n   this specification.  When used, a RPL implementation SHOULD
        allow\n   configuring the Target Descriptor on a per-Target basis (for example,\n
        \  using access lists).\n   A node whose DODAG parent set is empty may become
        the DODAG root of a\n   floating DODAG.  It may also set its DAGPreference
        such that it is\n   less preferred.  Thus, a RPL implementation MUST allow
        configuring\n   the set of actions that the node should initiate in this case:\n
        \  o  Start its own (floating) DODAG: the new DODAGID must be configured\n
        \     in addition to its DAGPreference.\n   o  Poison the broken path (see
        procedure in Section 8.2.2.5).\n   o  Trigger a local repair.\n"
      title: 18.2.4.  Protocol Parameters to Be Configured on Every Non-DODAG-Root
    - contents:
      - "18.2.5.  Parameters to Be Configured on the DODAG Root\n   In addition, several
        other parameters are configured only on the\n   DODAG root and advertised
        in options carried in DIO messages.\n   As specified in Section 8.3, a RPL
        implementation makes use of\n   Trickle timers to govern the sending of DIO
        messages.  The operation\n   of the Trickle algorithm is determined by a set
        of configurable\n   parameters, which MUST be configurable and that are then
        advertised\n   by the DODAG root along the DODAG in DIO messages.\n   o  DIOIntervalDoublings
        [DIO message, in DODAG Configuration option]\n   o  DIOIntervalMin [DIO message,
        in DODAG Configuration option]\n   o  DIORedundancyConstant [DIO message,
        in DODAG Configuration option]\n   In addition, a RPL implementation SHOULD
        allow for configuring the\n   following set of RPL parameters:\n   o  Path
        Control Size [DIO message, in DODAG Configuration option]\n   o  MinHopRankIncrease
        [DIO message, in DODAG Configuration option]\n   o  The DODAGPreference field
        [DIO message, DIO Base object]\n   o  DODAGID [DIO message, in DIO Base option]
        and [DAO message, when\n      the 'D' flag of the DAO message is set]\n   DAG
        root behavior: in some cases, a node may not want to permanently\n   act as
        a floating DODAG root if it cannot join a grounded DODAG.  For\n   example,
        a battery-operated node may not want to act as a floating\n   DODAG root for
        a long period of time.  Thus, a RPL implementation MAY\n   support the ability
        to configure whether or not a node could act as a\n   floating DODAG root
        for a configured period of time.\n   DAG Version Number Increment: a RPL implementation
        may allow, by\n   configuration at the DODAG root, refreshing the DODAG states
        by\n   updating the DODAGVersionNumber.  A RPL implementation SHOULD allow\n
        \  configuring whether or not periodic or event triggered mechanisms are\n
        \  used by the DODAG root to control DODAGVersionNumber change (which\n   triggers
        a global repair as specified in Section 3.2.2).\n"
      title: 18.2.5.  Parameters to Be Configured on the DODAG Root
    - contents:
      - "18.2.6.  Configuration of RPL Parameters Related to DAO-Based Mechanisms\n
        \  DAO messages are optional and used in DODAGs that require Downward\n   routing
        operation.  This section deals with the set of parameters\n   related to DAO
        messages and provides recommendations on their\n   configuration.\n   As stated
        in Section 9.5, it is recommended to delay the sending of\n   DAO message
        to DAO parents in order to maximize the chances to\n   perform route aggregation.
        \ Upon receiving a DAO message, the node\n   should thus start a DelayDAO
        timer.  The default value is\n   DEFAULT_DAO_DELAY.  A RPL implementation
        MAY allow for configuring\n   the DelayDAO timer.\n   In a Storing mode of
        operation, a storing node may increment DTSN in\n   order to reliably trigger
        a set of DAO updates from its immediate\n   children, as part of routine routing
        table updates and maintenance.\n   A RPL implementation MAY allow for configuring
        a set of rules\n   specifying the triggers for DTSN increment (manual or event-based).\n
        \  When a DAO entry times out or is invalidated, a node SHOULD make a\n   reasonable
        attempt to report a No-Path to each of the DAO parents.\n   That number of
        attempts MAY be configurable.\n   An implementation should support rate-limiting
        the sending of DAO\n   messages.  The related parameters MAY be configurable.\n"
      title: 18.2.6.  Configuration of RPL Parameters Related to DAO-Based Mechanisms
    - contents:
      - "18.2.7.  Configuration of RPL Parameters Related to Security Mechanisms\n
        \  As described in Section 10, the security features described in this\n   document
        are optional to implement and a given implementation may\n   support a subset
        (including the empty set) of the described security\n   features.\n   To this
        end, an implementation supporting described security features\n   may conceptually
        implement a security policy database.  In support of\n   the security mechanisms,
        a RPL implementation SHOULD allow for\n   configuring a subset of the following
        parameters:\n   o  Security Modes accepted [Unsecured mode, Preinstalled mode,\n
        \     Authenticated mode]\n   o  KIM values accepted [Secure RPL control messages,
        in Security\n      section]\n   o  Level values accepted [Secure RPL control
        messages, in Security\n      section]\n   o  Algorithm values accepted [Secure
        RPL control messages, in\n      Security section]\n   o  Key material in support
        of Authenticated or Preinstalled key\n      modes.\n   In addition, a RPL
        implementation SHOULD allow for configuring a\n   DODAG root with a subset
        of the following parameters:\n   o  Level values advertised [Secure DIO message,
        in Security section]\n   o  KIM value advertised [Secure DIO message, in Security
        section]\n   o  Algorithm value advertised [Secure DIO message, in Security\n
        \     section]\n"
      title: 18.2.7.  Configuration of RPL Parameters Related to Security Mechanisms
    - contents:
      - "18.2.8.  Default Values\n   This document specifies default values for the
        following set of RPL\n   variables:\n      DEFAULT_PATH_CONTROL_SIZE\n      DEFAULT_DIO_INTERVAL_MIN\n
        \     DEFAULT_DIO_INTERVAL_DOUBLINGS\n      DEFAULT_DIO_REDUNDANCY_CONSTANT\n
        \     DEFAULT_MIN_HOP_RANK_INCREASE\n      DEFAULT_DAO_DELAY\n   It is recommended
        to specify default values in protocols; that being\n   said, as discussed
        in [RFC5706], default values may make less and\n   less sense.  RPL is a routing
        protocol that is expected to be used in\n   a number of contexts where network
        characteristics such as the number\n   of nodes and link and node types are
        expected to vary significantly.\n   Thus, these default values are likely
        to change with the context and\n   as the technology evolves.  Indeed, LLNs'
        related technology (e.g.,\n   hardware, link layers) have been evolving dramatically
        over the past\n   few years and such technologies are expected to change and
        evolve\n   considerably in the coming years.\n   The proposed values are not
        based on extensive best current practices\n   and are considered to be conservative.\n"
      title: 18.2.8.  Default Values
    title: 18.2.  Configuration Management
  - contents:
    - "18.3.  Monitoring of RPL Operation\n   Several RPL parameters should be monitored
      to verify the correct\n   operation of the routing protocol and the network
      itself.  This\n   section lists the set of monitoring parameters of interest.\n"
    - contents:
      - "18.3.1.  Monitoring a DODAG Parameters\n   A RPL implementation SHOULD provide
        information about the following\n   parameters:\n   o  DODAG Version number
        [DIO message, in DIO Base message]\n   o  Status of the 'G' flag [DIO message,
        in DIO Base message]\n   o  Status of the MOP field [DIO message, in DIO Base
        message]\n   o  Value of the DTSN [DIO message, in DIO Base message]\n   o
        \ Value of the Rank [DIO message, in DIO Base message]\n   o  DAOSequence:
        Incremented at each unique DAO message, echoed in the\n      DAO-ACK message
        [DAO and DAO-ACK messages]\n   o  Route Information [DIO message, Route Information
        Option] (list of\n      IPv6 prefixes per parent along with lifetime and preference]\n
        \  o  Trickle parameters:\n      *  DIOIntervalDoublings [DIO message, in
        DODAG Configuration\n         option]\n      *  DIOIntervalMin [DIO message,
        in DODAG Configuration option]\n      *  DIORedundancyConstant [DIO message,
        in DODAG Configuration\n         option]\n   o  Path Control Size [DIO message,
        in DODAG Configuration option]\n   o  MinHopRankIncrease [DIO message, in
        DODAG Configuration option]\n   Values that may be monitored only on the DODAG
        root:\n   o  Transit Information [DAO, Transit Information option]: A RPL\n
        \     implementation SHOULD allow configuring whether the set of\n      received
        Transit Information options should be displayed on the\n      DODAG root.
        \ In this case, the RPL database of received Transit\n      Information should
        also contain the Path Sequence, Path Control,\n      Path Lifetime, and Parent
        Address.\n"
      title: 18.3.1.  Monitoring a DODAG Parameters
    - contents:
      - "18.3.2.  Monitoring a DODAG Inconsistencies and Loop Detection\n   Detection
        of DODAG inconsistencies is particularly critical in RPL\n   networks.  Thus,
        it is recommended for a RPL implementation to\n   provide appropriate monitoring
        tools.  A RPL implementation SHOULD\n   provide a counter reporting the number
        of a times the node has\n   detected an inconsistency with respect to a DODAG
        parent, e.g., if\n   the DODAGID has changed.\n   When possible more granular
        information about inconsistency detection\n   should be provided.  A RPL implementation
        MAY provide counters\n   reporting the number of following inconsistencies:\n
        \  o  Packets received with 'O' bit set (to Down) from a node with a\n      higher
        Rank\n   o  Packets received with 'O' bit cleared (to Up) from a node with
        a\n      lower Rank\n   o  Number of packets with the 'F' bit set\n   o  Number
        of packets with the 'R' bit set\n"
      title: 18.3.2.  Monitoring a DODAG Inconsistencies and Loop Detection
    title: 18.3.  Monitoring of RPL Operation
  - contents:
    - '18.4.  Monitoring of the RPL Data Structures

      '
    - contents:
      - "18.4.1.  Candidate Neighbor Data Structure\n   A node in the candidate neighbor
        list is a node discovered by the\n   same means and qualified to potentially
        become a parent (with high\n   enough local confidence).  A RPL implementation
        SHOULD provide a way\n   to allow for the candidate neighbor list to be monitored
        with some\n   metric reflecting local confidence (the degree of stability
        of the\n   neighbors) as measured by some metrics.\n   A RPL implementation
        MAY provide a counter reporting the number of\n   times a candidate neighbor
        has been ignored, should the number of\n   candidate neighbors exceed the
        maximum authorized value.\n"
      title: 18.4.1.  Candidate Neighbor Data Structure
    - contents:
      - "18.4.2.  Destination-Oriented Directed Acyclic Graph (DODAG) Table\n   For
        each DODAG, a RPL implementation is expected to keep track of the\n   following
        DODAG table values:\n   o  RPLInstanceID\n   o  DODAGID\n   o  DODAGVersionNumber\n
        \  o  Rank\n   o  Objective Code Point\n   o  A set of DODAG parents\n   o
        \ A set of prefixes offered Upward along the DODAG\n   o  Trickle timers used
        to govern the sending of DIO messages for the\n      DODAG\n   o  List of
        DAO parents\n   o  DTSN\n   o  Node status (router versus leaf)\n   A RPL
        implementation SHOULD allow for monitoring the set of\n   parameters listed
        above.\n"
      title: 18.4.2.  Destination-Oriented Directed Acyclic Graph (DODAG) Table
    - contents:
      - "18.4.3.  Routing Table and DAO Routing Entries\n   A RPL implementation maintains
        several information elements related\n   to the DODAG and the DAO entries
        (for storing nodes).  In the case of\n   a non-storing node, a limited amount
        of information is maintained\n   (the routing table is mostly reduced to a
        set of DODAG parents along\n   with characteristics of the DODAG as mentioned
        above); whereas in the\n   case of storing nodes, this information is augmented
        with routing\n   entries.\n   A RPL implementation SHOULD allow for the following
        parameters to be\n   monitored:\n   o  Next Hop (DODAG parent)\n   o  Next
        Hop Interface\n   o  Path metrics value for each DODAG parent\n   A DAO Routing
        Table entry conceptually contains the following\n   elements (for storing
        nodes only):\n   o  Advertising Neighbor Information\n   o  IPv6 address\n
        \  o  Interface ID to which DAO parents has this entry been reported\n   o
        \ Retry counter\n   o  Logical equivalent of DAO Content:\n      *  DAO-Sequence\n
        \     *  Path Sequence\n      *  DAO Lifetime\n      *  DAO Path Control\n
        \  o  Destination Prefix (or address or Mcast Group)\n   A RPL implementation
        SHOULD provide information about the state of\n   each DAO Routing Table entry
        states.\n"
      title: 18.4.3.  Routing Table and DAO Routing Entries
    title: 18.4.  Monitoring of the RPL Data Structures
  - contents:
    - "18.5.  Fault Management\n   Fault management is a critical component used for
      troubleshooting,\n   verification of the correct mode of operation of the protocol,
      and\n   network design; also, it is a key component of network performance\n
      \  monitoring.  A RPL implementation SHOULD allow the provision of the\n   following
      information related to fault managements:\n   o  Memory overflow along with
      the cause (e.g., routing tables\n      overflow, etc.)\n   o  Number of times
      a packet could not be sent to a DODAG parent\n      flagged as valid\n   o  Number
      of times a packet has been received for which the router\n      did not have
      a corresponding RPLInstanceID\n   o  Number of times a local repair procedure
      was triggered\n   o  Number of times a global repair was triggered by the DODAG
      root\n   o  Number of received malformed messages\n   o  Number of seconds with
      packets to forward and no next hop (DODAG\n      parent)\n   o  Number of seconds
      without next hop (DODAG parent)\n   o  Number of times a node has joined a DODAG
      as a leaf because it\n      received a DIO with a metric/constraint that was
      not understood\n      and it was configured to join as a leaf node in this case
      (see\n      Section 18.6)\n   It is RECOMMENDED to report faults via at least
      error log messages.\n   Other protocols may be used to report such faults.\n"
    title: 18.5.  Fault Management
  - contents:
    - "18.6.  Policy\n   Policy rules can be used by a RPL implementation to determine
      whether\n   or not the node is allowed to join a particular DODAG advertised
      by a\n   neighbor by means of DIO messages.\n   This document specifies operation
      within a single DODAG.  A DODAG is\n   characterized by the following tuple
      (RPLInstanceID, DODAGID).\n   Furthermore, as pointed out above, DIO messages
      are used to advertise\n   other DODAG characteristics such as the routing metrics
      and\n   constraints used to build to the DODAG and the Objective Function in\n
      \  use (specified by OCP).\n   The first policy rules consist of specifying
      the following conditions\n   that a RPL node must satisfy to join a DODAG:\n
      \  o  RPLInstanceID\n   o  List of supported routing metrics and constraints\n
      \  o  Objective Function (OCP values)\n   A RPL implementation MUST allow configuring
      these parameters and\n   SHOULD specify whether the node must simply ignore
      the DIO if the\n   advertised DODAG is not compliant with the local policy or
      whether\n   the node should join as the leaf node if only the list of supported\n
      \  routing metrics and constraints, and the OF is not supported.\n   Additionally,
      a RPL implementation SHOULD allow for the addition of\n   the DODAGID as part
      of the policy.\n   A RPL implementation SHOULD allow configuring the set of
      acceptable\n   or preferred Objective Functions (OFs) referenced by their Objective\n
      \  Code Points (OCPs) for a node to join a DODAG, and what action should\n   be
      taken if none of a node's candidate neighbors advertise one of the\n   configured
      allowable Objective Functions, or if the advertised\n   metrics/constraint is
      not understood/supported.  Two actions can be\n   taken in this case:\n   o
      \ The node joins the DODAG as a leaf node as specified in\n      Section 8.5.\n
      \  o  The node does not join the DODAG.\n   A node in an LLN may learn routing
      information from different routing\n   protocols including RPL.  In this case,
      it is desirable to control,\n   via administrative preference, which route should
      be favored.  An\n   implementation SHOULD allow for the specification of an\n
      \  administrative preference for the routing protocol from which the\n   route
      was learned.\n   Internal Data Structures: some RPL implementations may limit
      the size\n   of the candidate neighbor list in order to bound the memory usage;
      in\n   which case, some otherwise viable candidate neighbors may not be\n   considered
      and simply dropped from the candidate neighbor list.\n   A RPL implementation
      MAY provide an indicator on the size of the\n   candidate neighbor list.\n"
    title: 18.6.  Policy
  - contents:
    - "18.7.  Fault Isolation\n   It is RECOMMENDED to quarantine neighbors that start
      emitting\n   malformed messages at unacceptable rates.\n"
    title: 18.7.  Fault Isolation
  - contents:
    - "18.8.  Impact on Other Protocols\n   RPL has very limited impact on other protocols.
      \ Where more than one\n   routing protocol is required on a router, such as
      an LBR, it is\n   expected for the device to support routing redistribution
      functions\n   between the routing protocols to allow for reachability between
      the\n   two routing domains.  Such redistribution SHOULD be governed by the\n
      \  use of user configurable policy.\n   With regard to the impact in terms of
      traffic on the network, RPL has\n   been designed to limit the control traffic
      thanks to mechanisms such\n   as Trickle timers (Section 8.3).  Thus, the impact
      of RPL on other\n   protocols should be extremely limited.\n"
    title: 18.8.  Impact on Other Protocols
  - contents:
    - "18.9.  Performance Management\n   Performance management is always an important
      aspect of a protocol,\n   and RPL is not an exception.  Several metrics of interest
      have been\n   specified by the IP Performance Monitoring (IPPM) working group:
      that\n   being said, they will be hardly applicable to LLN considering the\n
      \  cost of monitoring these metrics in terms of resources on the devices\n   and
      required bandwidth.  Still, RPL implementations MAY support some\n   of these,
      and other parameters of interest are listed below:\n   o  Number of repairs
      and time to repair in seconds (average,\n      variance)\n   o  Number of times
      and time period during which a devices could not\n      forward a packet because
      of a lack of a reachable neighbor in its\n      routing table\n   o  Monitoring
      of resources consumption by RPL in terms of bandwidth\n      and required memory\n
      \  o  Number of RPL control messages sent and received\n"
    title: 18.9.  Performance Management
  - contents:
    - "18.10.  Diagnostics\n   There may be situations where a node should be placed
      in \"verbose\"\n   mode to improve diagnostics.  Thus, a RPL implementation
      SHOULD\n   provide the ability to place a node in and out of verbose mode in\n
      \  order to get additional diagnostic information.\n"
    title: 18.10.  Diagnostics
  title: 18.  Manageability Considerations
- contents:
  - '19.  Security Considerations

    '
  - contents:
    - "19.1.  Overview\n   From a security perspective, RPL networks are no different
      from any\n   other network.  They are vulnerable to passive eavesdropping attacks\n
      \  and, potentially, even active tampering when physical access to a\n   wire
      is not required to participate in communications.  The very\n   nature of ad
      hoc networks and their cost objectives impose additional\n   security constraints,
      which perhaps make these networks the most\n   difficult environments to secure.
      \ Devices are low-cost and have\n   limited capabilities in terms of computing
      power, available storage,\n   and power drain; it cannot always be assumed they
      have a trusted\n   computing base or a high-quality random number generator
      aboard.\n   Communications cannot rely on the online availability of a fixed\n
      \  infrastructure and might involve short-term relationships between\n   devices
      that may never have communicated before.  These constraints\n   might severely
      limit the choice of cryptographic algorithms and\n   protocols and influence
      the design of the security architecture\n   because the establishment and maintenance
      of trust relationships\n   between devices need to be addressed with care.  In
      addition, battery\n   lifetime and cost constraints put severe limits on the
      security\n   overhead these networks can tolerate, something that is of far
      less\n   concern with higher bandwidth networks.  Most of these security\n   architectural
      elements can be implemented at higher layers and may,\n   therefore, be considered
      to be out of scope for this specification.\n   Special care, however, needs
      to be exercised with respect to\n   interfaces to these higher layers.\n   The
      security mechanisms in this standard are based on symmetric-key\n   and public-key
      cryptography and use keys that are to be provided by\n   higher-layer processes.
      \ The establishment and maintenance of these\n   keys are out of scope for this
      specification.  The mechanisms assume\n   a secure implementation of cryptographic
      operations and secure and\n   authentic storage of keying material.\n   The
      security mechanisms specified provide particular combinations of\n   the following
      security services:\n   Data confidentiality: Assurance that transmitted information
      is only\n         disclosed to parties for which it is intended.\n   Data authenticity:
      Assurance of the source of transmitted information\n         (and, hereby, that
      information was not modified in transit).\n   Replay protection: Assurance that
      a duplicate of transmitted\n         information is detected.\n   Timeliness
      (delay protection):  Assurance that transmitted\n         information was received
      in a timely manner.\n   The actual protection provided can be adapted on a per-packet
      basis\n   and allows for varying levels of data authenticity (to minimize\n
      \  security overhead in transmitted packets where required) and for\n   optional
      data confidentiality.  When nontrivial protection is\n   required, replay protection
      is always provided.\n   Replay protection is provided via the use of a non-repeating
      value\n   (CCM nonce) in the packet protection process and storage of some\n
      \  status information (originating device and the CCM nonce counter last\n   received
      from that device), which allows detection of whether this\n   particular CCM
      nonce value was used previously by the originating\n   device.  In addition,
      so-called delay protection is provided amongst\n   those devices that have a
      loosely synchronized clock on board.  The\n   acceptable time delay can be adapted
      on a per-packet basis and allows\n   for varying latencies (to facilitate longer
      latencies in packets\n   transmitted over a multi-hop communication path).\n
      \  Cryptographic protection may use a key shared between two peer\n   devices
      (link key) or a key shared among a group of devices (group\n   key), thus allowing
      some flexibility and application-specific trade-\n   offs between key storage
      and key maintenance costs versus the\n   cryptographic protection provided.
      \ If a group key is used for peer-\n   to-peer communication, protection is
      provided only against outsider\n   devices and not against potential malicious
      devices in the key-\n   sharing group.\n   Data authenticity may be provided
      using symmetric-key-based or\n   public-key-based techniques.  With public-key-based
      techniques (via\n   signatures), one corroborates evidence as to the unique
      originator of\n   transmitted information, whereas with symmetric-key-based
      techniques,\n   data authenticity is only provided relative to devices in a
      key-\n   sharing group.  Thus, public-key-based authentication may be useful\n
      \  in scenarios that require a more fine-grained authentication than can\n   be
      provided with symmetric-key-based authentication techniques alone,\n   such
      as with group communications (broadcast, multicast) or in\n   scenarios that
      require non-repudiation.\n"
    title: 19.1.  Overview
  title: 19.  Security Considerations
- contents:
  - '20.  IANA Considerations

    '
  - contents:
    - "20.1.  RPL Control Message\n   The RPL control message is an ICMP information
      message type that is\n   to be used carry DODAG Information Objects, DODAG Information\n
      \  Solicitations, and Destination Advertisement Objects in support of\n   RPL
      operation.\n   IANA has defined an ICMPv6 Type Number Registry.  The type value
      for\n   the RPL control message is 155.\n"
    title: 20.1.  RPL Control Message
  - contents:
    - "20.2.  New Registry for RPL Control Codes\n   IANA has created a registry,
      RPL Control Codes, for the Code field of\n   the ICMPv6 RPL control message.\n
      \  New codes may be allocated only by an IETF Review.  Each code is\n   tracked
      with the following qualities:\n   o  Code\n   o  Description\n   o  Defining
      RFC\n   The following codes are currently defined:\n   +------+----------------------------------------------+-------------+\n
      \  | Code | Description                                  | Reference   |\n   +------+----------------------------------------------+-------------+\n
      \  | 0x00 | DODAG Information Solicitation               | This        |\n   |
      \     |                                              | document    |\n   |      |
      \                                             |             |\n   | 0x01 | DODAG
      Information Object                     | This        |\n   |      |                                              |
      document    |\n   |      |                                              |             |\n
      \  | 0x02 | Destination Advertisement Object             | This        |\n   |
      \     |                                              | document    |\n   |      |
      \                                             |             |\n   | 0x03 | Destination
      Advertisement Object             | This        |\n   |      | Acknowledgment
      \                              | document    |\n   |      |                                              |
      \            |\n   | 0x80 | Secure DODAG Information Solicitation        | This
      \       |\n   |      |                                              | document
      \   |\n   |      |                                              |             |\n
      \  | 0x81 | Secure DODAG Information Object              | This        |\n   |
      \     |                                              | document    |\n   |      |
      \                                             |             |\n   | 0x82 | Secure
      Destination Advertisement Object      | This        |\n   |      |                                              |
      document    |\n   |      |                                              |             |\n
      \  | 0x83 | Secure Destination Advertisement Object      | This        |\n   |
      \     | Acknowledgment                               | document    |\n   |      |
      \                                             |             |\n   | 0x8A | Consistency
      Check                            | This        |\n   |      |                                              |
      document    |\n   +------+----------------------------------------------+-------------+\n
      \                            RPL Control Codes\n"
    title: 20.2.  New Registry for RPL Control Codes
  - contents:
    - "20.3.  New Registry for the Mode of Operation (MOP)\n   IANA has created a
      registry for the 3-bit Mode of Operation (MOP),\n   which is contained in the
      DIO Base.\n   New values may be allocated only by an IETF Review.  Each value
      is\n   tracked with the following qualities:\n   o  Mode of Operation Value\n
      \  o  Capability description\n   o  Defining RFC\n   Four values are currently
      defined:\n   +----------+------------------------------------------+-------------+\n
      \  |    MOP   | Description                              | Reference   |\n   |
      \  value  |                                          |             |\n   +----------+------------------------------------------+-------------+\n
      \  |     0    | No Downward routes maintained by RPL     | This        |\n   |
      \         |                                          | document    |\n   |          |
      \                                         |             |\n   |     1    | Non-Storing
      Mode of Operation            | This        |\n   |          |                                          |
      document    |\n   |          |                                          |             |\n
      \  |     2    | Storing Mode of Operation with no        | This        |\n   |
      \         | multicast support                        | document    |\n   |          |
      \                                         |             |\n   |     3    | Storing
      Mode of Operation with multicast | This        |\n   |          | support                                  |
      document    |\n   +----------+------------------------------------------+-------------+\n
      \                          DIO Mode of Operation\n   The rest of the range,
      decimal 4 to 7, is currently unassigned.\n"
    title: 20.3.  New Registry for the Mode of Operation (MOP)
  - contents:
    - "20.4.  RPL Control Message Options\n   IANA has created a registry for the
      RPL Control Message Options.\n   New values may be allocated only by an IETF
      Review.  Each value is\n   tracked with the following qualities:\n   o  Value\n
      \  o  Meaning\n   o  Defining RFC\n             +-------+-----------------------+---------------+\n
      \            | Value | Meaning               | Reference     |\n             +-------+-----------------------+---------------+\n
      \            |  0x00 | Pad1                  | This document |\n             |
      \      |                       |               |\n             |  0x01 | PadN
      \                 | This document |\n             |       |                       |
      \              |\n             |  0x02 | DAG Metric Container  | This Document
      |\n             |       |                       |               |\n             |
      \ 0x03 | Routing Information   | This Document |\n             |       |                       |
      \              |\n             |  0x04 | DODAG Configuration   | This Document
      |\n             |       |                       |               |\n             |
      \ 0x05 | RPL Target            | This Document |\n             |       |                       |
      \              |\n             |  0x06 | Transit Information   | This Document
      |\n             |       |                       |               |\n             |
      \ 0x07 | Solicited Information | This Document |\n             |       |                       |
      \              |\n             |  0x08 | Prefix Information    | This Document
      |\n             |       |                       |               |\n             |
      \ 0x09 | Target Descriptor     | This Document |\n             +-------+-----------------------+---------------+\n
      \                       RPL Control Message Options\n"
    title: 20.4.  RPL Control Message Options
  - contents:
    - "20.5.  Objective Code Point (OCP) Registry\n   IANA has created a registry
      to manage the codespace of the Objective\n   Code Point (OCP) field.\n   No
      OCPs are defined in this specification.\n   New codes may be allocated only
      by an IETF Review.  Each code is\n   tracked with the following qualities:\n
      \  o  Code\n   o  Description\n   o  Defining RFC\n"
    title: 20.5.  Objective Code Point (OCP) Registry
  - contents:
    - "20.6.  New Registry for the Security Section Algorithm\n   IANA has created
      a registry for the values of the 8-bit Algorithm\n   field in the Security section.\n
      \  New values may be allocated only by an IETF Review.  Each value is\n   tracked
      with the following qualities:\n   o  Value\n   o  Encryption/MAC\n   o  Signature\n
      \  o  Defining RFC\n   The following value is currently defined:\n      +-------+------------------+------------------+---------------+\n
      \     | Value | Encryption/MAC   | Signature        | Reference     |\n      +-------+------------------+------------------+---------------+\n
      \     |   0   | CCM with AES-128 | RSA with SHA-256 | This document |\n      +-------+------------------+------------------+---------------+\n
      \                       Security Section Algorithm\n"
    title: 20.6.  New Registry for the Security Section Algorithm
  - contents:
    - "20.7.  New Registry for the Security Section Flags\n   IANA has created a registry
      for the 8-bit Security Section Flags\n   field.\n   New bit numbers may be allocated
      only by an IETF Review.  Each bit is\n   tracked with the following qualities:\n
      \  o  Bit number (counting from bit 0 as the most significant bit)\n   o  Capability
      description\n   o  Defining RFC\n   No bit is currently defined for the Security
      Section Flags field.\n"
    title: 20.7.  New Registry for the Security Section Flags
  - contents:
    - "20.8.  New Registry for Per-KIM Security Levels\n   IANA has created one registry
      for the 3-bit Security Level (LVL)\n   field per allocated KIM value.\n   For
      a given KIM value, new levels may be allocated only by an IETF\n   Review.  Each
      level is tracked with the following qualities:\n   o  Level\n   o  KIM value\n
      \  o  Description\n   o  Defining RFC\n   The following levels per KIM value
      are currently defined:\n           +-------+-----------+---------------+---------------+\n
      \          | Level | KIM value | Description   | Reference     |\n           +-------+-----------+---------------+---------------+\n
      \          |   0   |     0     | See Figure 11 | This document |\n           |
      \      |           |               |               |\n           |   1   |     0
      \    | See Figure 11 | This document |\n           |       |           |               |
      \              |\n           |   2   |     0     | See Figure 11 | This document
      |\n           |       |           |               |               |\n           |
      \  3   |     0     | See Figure 11 | This document |\n           |       |           |
      \              |               |\n           |   0   |     1     | See Figure
      11 | This document |\n           |       |           |               |               |\n
      \          |   1   |     1     | See Figure 11 | This document |\n           |
      \      |           |               |               |\n           |   2   |     1
      \    | See Figure 11 | This document |\n           |       |           |               |
      \              |\n           |   3   |     1     | See Figure 11 | This document
      |\n           |       |           |               |               |\n           |
      \  0   |     2     | See Figure 11 | This document |\n           |       |           |
      \              |               |\n           |   1   |     2     | See Figure
      11 | This document |\n           |       |           |               |               |\n
      \          |   2   |     2     | See Figure 11 | This document |\n           |
      \      |           |               |               |\n           |   3   |     2
      \    | See Figure 11 | This document |\n           |       |           |               |
      \              |\n           |   0   |     3     | See Figure 11 | This document
      |\n           |       |           |               |               |\n           |
      \  1   |     3     | See Figure 11 | This document |\n           |       |           |
      \              |               |\n           |   2   |     3     | See Figure
      11 | This document |\n           |       |           |               |               |\n
      \          |   3   |     3     | See Figure 11 | This document |\n           +-------+-----------+---------------+---------------+\n
      \                         Per-KIM Security Levels\n"
    title: 20.8.  New Registry for Per-KIM Security Levels
  - contents:
    - "20.9.  New Registry for DODAG Informational Solicitation (DIS) Flags\n   IANA
      has created a registry for the DIS (DODAG Informational\n   Solicitation) Flags
      field.\n   New bit numbers may be allocated only by an IETF Review.  Each bit
      is\n   tracked with the following qualities:\n   o  Bit number (counting from
      bit 0 as the most significant bit)\n   o  Capability description\n   o  Defining
      RFC\n   No bit is currently defined for the DIS (DODAG Informational\n   Solicitation)
      Flags field.\n"
    title: 20.9.  New Registry for DODAG Informational Solicitation (DIS) Flags
  - contents:
    - "20.10.  New Registry for the DODAG Information Object (DIO) Flags\n   IANA
      has created a registry for the 8-bit DODAG Information Object\n   (DIO) Flags
      field.\n   New bit numbers may be allocated only by an IETF Review.  Each bit
      is\n   tracked with the following qualities:\n   o  Bit number (counting from
      bit 0 as the most significant bit)\n   o  Capability description\n   o  Defining
      RFC\n   No bit is currently defined for the DIS (DODAG Informational\n   Solicitation)
      Flags.\n"
    title: 20.10.  New Registry for the DODAG Information Object (DIO) Flags
  - contents:
    - "20.11.  New Registry for the Destination Advertisement Object (DAO)\n        Flags\n
      \  IANA has created a registry for the 8-bit Destination Advertisement\n   Object
      (DAO) Flags field.\n   New bit numbers may be allocated only by an IETF Review.
      \ Each bit is\n   tracked with the following qualities:\n   o  Bit number (counting
      from bit 0 as the most significant bit)\n   o  Capability description\n   o
      \ Defining RFC\n   The following bits are currently defined:\n       +------------+------------------------------+---------------+\n
      \      | Bit number | Description                  | Reference     |\n       +------------+------------------------------+---------------+\n
      \      |      0     | DAO-ACK request (K)          | This document |\n       |
      \           |                              |               |\n       |      1
      \    | DODAGID field is present (D) | This document |\n       +------------+------------------------------+---------------+\n
      \                             DAO Base Flags\n"
    title: 20.11.  New Registry for the Destination Advertisement Object (DAO)
  - contents:
    - "20.12.  New Registry for the Destination Advertisement Object (DAO)\n        Acknowledgement
      Flags\n   IANA has created a registry for the 8-bit Destination Advertisement\n
      \  Object (DAO) Acknowledgement Flags field.\n   New bit numbers may be allocated
      only by an IETF Review.  Each bit is\n   tracked with the following qualities:\n
      \  o  Bit number (counting from bit 0 as the most significant bit)\n   o  Capability
      description\n   o  Defining RFC\n   The following bit is currently defined:\n
      \      +------------+------------------------------+---------------+\n       |
      Bit number | Description                  | Reference     |\n       +------------+------------------------------+---------------+\n
      \      |      0     | DODAGID field is present (D) | This document |\n       +------------+------------------------------+---------------+\n
      \                           DAO-ACK Base Flags\n"
    title: 20.12.  New Registry for the Destination Advertisement Object (DAO)
  - contents:
    - "20.13.  New Registry for the Consistency Check (CC) Flags\n   IANA has created
      a registry for the 8-bit Consistency Check (CC)\n   Flags field.\n   New bit
      numbers may be allocated only by an IETF Review.  Each bit is\n   tracked with
      the following qualities:\n   o  Bit number (counting from bit 0 as the most
      significant bit)\n   o  Capability description\n   o  Defining RFC\n   The following
      bit is currently defined:\n             +------------+-----------------+---------------+\n
      \            | Bit number | Description     | Reference     |\n             +------------+-----------------+---------------+\n
      \            |      0     | CC Response (R) | This document |\n             +------------+-----------------+---------------+\n
      \                      Consistency Check Base Flags\n"
    title: 20.13.  New Registry for the Consistency Check (CC) Flags
  - contents:
    - "20.14.  New Registry for the DODAG Configuration Option Flags\n   IANA has
      created a registry for the 8-bit DODAG Configuration Option\n   Flags field.\n
      \  New bit numbers may be allocated only by an IETF Review.  Each bit is\n   tracked
      with the following qualities:\n   o  Bit number (counting from bit 0 as the
      most significant bit)\n   o  Capability description\n   o  Defining RFC\n   The
      following bits are currently defined:\n        +------------+----------------------------+---------------+\n
      \       | Bit number | Description                | Reference     |\n        +------------+----------------------------+---------------+\n
      \       |      4     | Authentication Enabled (A) | This document |\n        |
      \    5-7    | Path Control Size (PCS)    | This document |\n        +------------+----------------------------+---------------+\n
      \                    DODAG Configuration Option Flags\n"
    title: 20.14.  New Registry for the DODAG Configuration Option Flags
  - contents:
    - "20.15.  New Registry for the RPL Target Option Flags\n   IANA has created a
      registry for the 8-bit RPL Target Option Flags\n   field.\n   New bit numbers
      may be allocated only by an IETF Review.  Each bit is\n   tracked with the following
      qualities:\n   o  Bit number (counting from bit 0 as the most significant bit)\n
      \  o  Capability description\n   o  Defining RFC\n   No bit is currently defined
      for the RPL Target Option Flags.\n"
    title: 20.15.  New Registry for the RPL Target Option Flags
  - contents:
    - "20.16.  New Registry for the Transit Information Option Flags\n   IANA has
      created a registry for the 8-bit Transit Information Option\n   (TIO) Flags
      field.\n   New bit numbers may be allocated only by an IETF Review.  Each bit
      is\n   tracked with the following qualities:\n   o  Bit number (counting from
      bit 0 as the most significant bit)\n   o  Capability description\n   o  Defining
      RFC\n   The following bits are currently defined:\n               +------------+--------------+---------------+\n
      \              | Bit number | Description  | Reference     |\n               +------------+--------------+---------------+\n
      \              |      0     | External (E) | This document |\n               +------------+--------------+---------------+\n
      \                    Transit Information Option Flags\n"
    title: 20.16.  New Registry for the Transit Information Option Flags
  - contents:
    - "20.17.  New Registry for the Solicited Information Option Flags\n   IANA has
      created a registry for the 8-bit Solicited Information\n   Option (SIO) Flags
      field.\n   New bit numbers may be allocated only by an IETF Review.  Each bit
      is\n   tracked with the following qualities:\n   o  Bit number (counting from
      bit 0 as the most significant bit)\n   o  Capability description\n   o  Defining
      RFC\n   The following bits are currently defined:\n      +------------+--------------------------------+---------------+\n
      \     | Bit number | Description                    | Reference     |\n      +------------+--------------------------------+---------------+\n
      \     |      0     | Version Predicate match (V)    | This document |\n      |
      \           |                                |               |\n      |      1
      \    | InstanceID Predicate match (I) | This document |\n      |            |
      \                               |               |\n      |      2     | DODAGID
      Predicate match (D)    | This document |\n      +------------+--------------------------------+---------------+\n
      \                   Solicited Information Option Flags\n"
    title: 20.17.  New Registry for the Solicited Information Option Flags
  - contents:
    - "20.18.  ICMPv6: Error in Source Routing Header\n   In some cases RPL will return
      an ICMPv6 error message when a message\n   cannot be delivered as specified
      by its source routing header.  This\n   ICMPv6 error message is \"Error in Source
      Routing Header\".\n   IANA has defined an ICMPv6 \"Code\" Fields Registry for
      ICMPv6 Message\n   Types.  ICMPv6 Message Type 1 describes \"Destination Unreachable\"\n
      \  codes.  The \"Error in Source Routing Header\" code is has been\n   allocated
      from the ICMPv6 Code Fields Registry for ICMPv6 Message\n   Type 1, with a code
      value of 7.\n"
    title: '20.18.  ICMPv6: Error in Source Routing Header'
  - contents:
    - "20.19.  Link-Local Scope Multicast Address\n   The rules for assigning new
      IPv6 multicast addresses are defined in\n   [RFC3307].  This specification requires
      the allocation of a new\n   permanent multicast address with a link-local scope
      for RPL nodes\n   called all-RPL-nodes, with a value of ff02::1a.\n"
    title: 20.19.  Link-Local Scope Multicast Address
  title: 20.  IANA Considerations
- contents:
  - "21.  Acknowledgements\n   The authors would like to acknowledge the review, feedback,
    and\n   comments from Emmanuel Baccelli, Dominique Barthel, Yusuf Bashir,\n   Yoav
    Ben-Yehezkel, Phoebus Chen, Quynh Dang, Mischa Dohler, Mathilde\n   Durvy, Joakim
    Eriksson, Omprakash Gnawali, Manhar Goindi, Mukul\n   Goyal, Ulrich Herberg, Anders
    Jagd, JeongGil (John) Ko, Ajay Kumar,\n   Quentin Lampin, Jerry Martocci, Matteo
    Paris, Alexandru Petrescu,\n   Joseph Reddy, Michael Richardson, Don Sturek, Joydeep
    Tripathi, and\n   Nicolas Tsiftes.\n   The authors would like to acknowledge the
    guidance and input provided\n   by the ROLL Chairs, David Culler and JP. Vasseur,
    and the Area\n   Director, Adrian Farrel.\n   The authors would like to acknowledge
    prior contributions of Robert\n   Assimiti, Mischa Dohler, Julien Abeille, Ryuji
    Wakikawa, Teco Boot,\n   Patrick Wetterwald, Bryan Mclaughlin, Carlos J. Bernardos,
    Thomas\n   Watteyne, Zach Shelby, Caroline Bontoux, Marco Molteni, Billy Moon,\n
    \  Jim Bound, Yanick Pouffary, Henning Rogge, and Arsalan Tavakoli, who\n   have
    provided useful design considerations to RPL.\n   RPL Security Design, found in
    Section 10, Section 19, and elsewhere\n   throughout the document, is primarily
    the contribution of the\n   Security Design Team: Tzeta Tsao, Roger Alexander,
    Dave Ward, Philip\n   Levis, Kris Pister, Rene Struik, and Adrian Farrel.\n   Thanks
    also to Jari Arkko and Ralph Droms for their attentive\n   reviews, especially
    with respect to interoperability considerations\n   and integration with other
    IETF specifications.\n"
  title: 21.  Acknowledgements
- contents:
  - "22.  Contributors\n   Stephen Dawson-Haggerty\n   UC Berkeley\n   Soda Hall\n
    \  Berkeley, CA  94720\n   USA\n   EMail: stevedh@cs.berkeley.edu\n"
  title: 22.  Contributors
- contents:
  - '23.  References

    '
  - contents:
    - "23.1.  Normative References\n   [RFC2119]     Bradner, S., \"Key words for
      use in RFCs to Indicate\n                 Requirement Levels\", BCP 14, RFC
      2119, March 1997.\n   [RFC2460]     Deering, S. and R. Hinden, \"Internet Protocol,
      Version\n                 6 (IPv6) Specification\", RFC 2460, December 1998.\n
      \  [RFC3447]     Jonsson, J. and B. Kaliski, \"Public-Key Cryptography\n                 Standards
      (PKCS) #1: RSA Cryptography Specifications\n                 Version 2.1\",
      RFC 3447, February 2003.\n   [RFC4191]     Draves, R. and D. Thaler, \"Default
      Router Preferences\n                 and More-Specific Routes\", RFC 4191, November
      2005.\n   [RFC4302]     Kent, S., \"IP Authentication Header\", RFC 4302,\n
      \                December 2005.\n   [RFC4443]     Conta, A., Deering, S., and
      M. Gupta, \"Internet Control\n                 Message Protocol (ICMPv6) for
      the Internet Protocol\n                 Version 6 (IPv6) Specification\", RFC
      4443, March 2006.\n   [RFC4861]     Narten, T., Nordmark, E., Simpson, W., and
      H. Soliman,\n                 \"Neighbor Discovery for IP version 6 (IPv6)\",
      RFC 4861,\n                 September 2007.\n   [RFC4862]     Thomson, S., Narten,
      T., and T. Jinmei, \"IPv6 Stateless\n                 Address Autoconfiguration\",
      RFC 4862, September 2007.\n   [RFC6206]     Levis, P., Clausen, T., Hui, J.,
      Gnawali, O., and J.\n                 Ko, \"The Trickle Algorithm\", RFC 6206,
      March 2011.\n   [RFC6275]     Perkins, C., Johnson, D., and J. Arkko, \"Mobility\n
      \                Support in IPv6\", RFC 6275, July 2011.\n   [RFC6551]     Vasseur,
      JP., Ed., Kim, M., Ed., Pister, K., Dejean,\n                 N., and D. Barthel,
      \"Routing Metrics Used for Path\n                 Calculation in Low-Power and
      Lossy Networks\", RFC 6551,\n                 March 2012.\n   [RFC6552]     Thubert,
      P., Ed., \"Objective Function Zero for the\n                 Routing Protocol
      for Low-Power and Lossy Networks\n                 (RPL)\", RFC 6552, March
      2012.\n   [RFC6553]     Hui, J. and JP. Vasseur, \"The Routing Protocol for
      Low-\n                 Power and Lossy Networks (RPL) Option for Carrying RPL\n
      \                Information in Data-Plane Datagrams\", RFC 6553,\n                 March
      2012.\n   [RFC6554]     Hui, J., Vasseur, JP., Culler, D., and V. Manral, \"An\n
      \                IPv6 Routing Header for Source Routes with the Routing\n                 Protocol
      for Low-Power and Lossy Networks (RPL)\",\n                 RFC 6554, March
      2012.\n"
    title: 23.1.  Normative References
  - contents:
    - "23.2.  Informative References\n   [6LOWPAN-ND]  Shelby, Z., Ed., Chakrabarti,
      S., and E. Nordmark,\n                 \"Neighbor Discovery Optimization for
      Low Power and\n                 Lossy Networks (6LoWPAN)\", Work in Progress,\n
      \                October 2011.\n   [FIPS180]     National Institute of Standards
      and Technology, \"FIPS\n                 Pub 180-3, Secure Hash Standard (SHS)\",
      US Department\n                 of Commerce , February 2008,\n                 <http://www.nist.gov/itl/upload/fips180-3_final.pdf>.\n
      \  [Perlman83]   Perlman, R., \"Fault-Tolerant Broadcast of Routing\n                 Information\",
      North-Holland Computer Networks,\n                 Vol.7: p. 395-405, December
      1983.\n   [RFC1958]     Carpenter, B., \"Architectural Principles of the\n                 Internet\",
      RFC 1958, June 1996.\n   [RFC1982]     Elz, R. and R. Bush, \"Serial Number
      Arithmetic\",\n                 RFC 1982, August 1996.\n   [RFC2578]     McCloghrie,
      K., Ed., Perkins, D., Ed., and J.\n                 Schoenwaelder, Ed., \"Structure
      of Management\n                 Information Version 2 (SMIv2)\", STD 58, RFC
      2578,\n                 April 1999.\n   [RFC3307]     Haberman, B., \"Allocation
      Guidelines for IPv6 Multicast\n                 Addresses\", RFC 3307, August
      2002.\n   [RFC3410]     Case, J., Mundy, R., Partain, D., and B. Stewart,\n
      \                \"Introduction and Applicability Statements for\n                 Internet-Standard
      Management Framework\", RFC 3410,\n                 December 2002.\n   [RFC3535]
      \    Schoenwaelder, J., \"Overview of the 2002 IAB Network\n                 Management
      Workshop\", RFC 3535, May 2003.\n   [RFC3610]     Whiting, D., Housley, R.,
      and N. Ferguson, \"Counter\n                 with CBC-MAC (CCM)\", RFC 3610,
      September 2003.\n   [RFC3819]     Karn, P., Bormann, C., Fairhurst, G., Grossman,
      D.,\n                 Ludwig, R., Mahdavi, J., Montenegro, G., Touch, J., and\n
      \                L. Wood, \"Advice for Internet Subnetwork Designers\",\n                 BCP
      89, RFC 3819, July 2004.\n   [RFC4101]     Rescorla, E. and IAB, \"Writing Protocol
      Models\",\n                 RFC 4101, June 2005.\n   [RFC4915]     Psenak, P.,
      Mirtorabi, S., Roy, A., Nguyen, L., and P.\n                 Pillay-Esnault,
      \"Multi-Topology (MT) Routing in OSPF\",\n                 RFC 4915, June 2007.\n
      \  [RFC5120]     Przygienda, T., Shen, N., and N. Sheth, \"M-ISIS: Multi\n                 Topology
      (MT) Routing in Intermediate System to\n                 Intermediate Systems
      (IS-ISs)\", RFC 5120,\n                 February 2008.\n   [RFC5184]     Teraoka,
      F., Gogo, K., Mitsuya, K., Shibui, R., and K.\n                 Mitani, \"Unified
      Layer 2 (L2) Abstractions for Layer 3\n                 (L3)-Driven Fast Handover\",
      RFC 5184, May 2008.\n   [RFC5548]     Dohler, M., Watteyne, T., Winter, T.,
      and D. Barthel,\n                 \"Routing Requirements for Urban Low-Power
      and Lossy\n                 Networks\", RFC 5548, May 2009.\n   [RFC5673]     Pister,
      K., Thubert, P., Dwars, S., and T. Phinney,\n                 \"Industrial Routing
      Requirements in Low-Power and Lossy\n                 Networks\", RFC 5673,
      October 2009.\n   [RFC5706]     Harrington, D., \"Guidelines for Considering
      Operations\n                 and Management of New Protocols and Protocol\n
      \                Extensions\", RFC 5706, November 2009.\n   [RFC5826]     Brandt,
      A., Buron, J., and G. Porcu, \"Home Automation\n                 Routing Requirements
      in Low-Power and Lossy Networks\",\n                 RFC 5826, April 2010.\n
      \  [RFC5867]     Martocci, J., De Mil, P., Riou, N., and W. Vermeylen,\n                 \"Building
      Automation Routing Requirements in Low-Power\n                 and Lossy Networks\",
      RFC 5867, June 2010.\n   [RFC5881]     Katz, D. and D. Ward, \"Bidirectional
      Forwarding\n                 Detection (BFD) for IPv4 and IPv6 (Single Hop)\",\n
      \                RFC 5881, June 2010.\n   [RFC6130]     Clausen, T., Dearlove,
      C., and J. Dean, \"Mobile Ad Hoc\n                 Network (MANET) Neighborhood
      Discovery Protocol\n                 (NHDP)\", RFC 6130, April 2011.\n   [ROLL-TERMS]
      \ Vasseur, J., \"Terminology in Low power And Lossy\n                 Networks\",
      Work in Progress, September 2011.\n"
    title: 23.2.  Informative References
  title: 23.  References
- contents:
  - "Appendix A.  Example Operation\n   This appendix provides some examples to illustrate
    the dissemination\n   of addressing information and prefixes with RPL.  The examples
    depict\n   information being distributed with PIOs and RIOs and the use of DIO\n
    \  and DAO messages.  Note that this appendix is not normative, and that\n   the
    specific details of a RPL addressing plan and autoconfiguration\n   may vary according
    to specific implementations.  RPL merely provides\n   a vehicle for disseminating
    information that may be built upon and\n   used by other mechanisms.\n   Note
    that these examples illustrate use of address autoconfiguration\n   schemes supported
    by information distributed within RPL.  However, if\n   an implementation includes
    another address autoconfiguration scheme,\n   RPL nodes might be configured not
    to set the 'A' flag in PIO options,\n   though the PIO can still be used to distribute
    prefix and addressing\n   information.\n"
  - contents:
    - "A.1.  Example Operation in Storing Mode with Node-Owned Prefixes\n   Figure
      32 illustrates the logical addressing architecture of a simple\n   RPL network
      operating in Storing mode.  In this example, each Node,\n   A, B, C, and D,
      owns its own prefix and makes that prefix available\n   for address autoconfiguration
      by on-link devices.  (This is conveyed\n   by setting the 'A' flag and the 'L'
      flag in the PIO of the DIO\n   messages).  Node A owns the prefix A::/64, Node
      B owns B::/64, and so\n   on.  Node B autoconfigures an on-link address with
      respect to Node A,\n   A::B.  Nodes C and D similarly autoconfigure on-link
      addresses from\n   Node B's prefix, B::C and B::D, respectively.  Nodes have
      the option\n   of setting the 'R' flag and publishing their address within the\n
      \  Prefix field of the PIO.\n                              +-------------+\n
      \                             |    Root     |\n                              |
      \            |\n                              |   Node A    |\n                              |
      \            |\n                              |    A::A     |\n                              +------+------+\n
      \                                    |\n                                     |\n
      \                                    |\n                              +------+------+\n
      \                             |    A::B     |\n                              |
      \            |\n                              |   Node B    |\n                              |
      \            |\n                              |    B::B     |\n                              +------+------+\n
      \                                    |\n                                     |\n
      \                     .--------------+--------------.\n                     /
      \                              \\\n                    /                                 \\\n
      \           +------+------+                     +------+------+\n            |
      \   B::C     |                     |    B::D     |\n            |             |
      \                    |             |\n            |   Node C    |                     |
      \  Node D    |\n            |             |                     |             |\n
      \           |    C::C     |                     |    D::D     |\n            +-------------+
      \                    +-------------+\n             Figure 32: Storing Mode with
      Node-Owned Prefixes\n"
    - contents:
      - "A.1.1.  DIO Messages and PIO\n   Node A, for example, will send DIO messages
        with a PIO as follows:\n   'A' flag:       Set\n   'L' flag:       Set\n   'R'
        flag:       Clear\n   Prefix Length:  64\n   Prefix:         A::\n   Node
        B, for example, will send DIO messages with a PIO as follows:\n   'A' flag:
        \      Set\n   'L' flag:       Set\n   'R' flag:       Set\n   Prefix Length:
        \ 64\n   Prefix:         B::B\n   Node C, for example, will send DIO messages
        with a PIO as follows:\n   'A' flag:       Set\n   'L' flag:       Set\n   'R'
        flag:       Clear\n   Prefix Length:  64\n   Prefix:         C::\n   Node
        D, for example, will send DIO messages with a PIO as follows:\n   'A' flag:
        \      Set\n   'L' flag:       Set\n   'R' flag:       Set\n   Prefix Length:
        \ 64\n   Prefix:         D::D\n"
      title: A.1.1.  DIO Messages and PIO
    - contents:
      - "A.1.2.  DAO Messages\n   Node B will send DAO messages to Node A with the
        following\n   information:\n       o  Target B::/64\n       o  Target C::/64\n
        \      o  Target D::/64\n   Node C will send DAO messages to Node B with the
        following\n   information:\n       o  Target C::/64\n   Node D will send DAO
        messages to Node B with the following\n   information:\n       o  Target D::/64\n"
      title: A.1.2.  DAO Messages
    - contents:
      - "A.1.3.  Routing Information Base\n   Node A will conceptually collect the
        following information into its\n   Routing Information Base (RIB):\n       o
        \ A::/64 connected\n       o  B::/64 via B's link local\n       o  C::/64
        via B's link local\n       o  D::/64 via B's link local\n   Node B will conceptually
        collect the following information into its\n   RIB:\n       o  ::/0 via A's
        link local\n       o  B::/64 connected\n       o  C::/64 via C's link local\n
        \      o  D::/64 via D's link local\n   Node C will conceptually collect the
        following information into its\n   RIB:\n       o  ::/0 via B's link local\n
        \      o  C::/64 connected\n   Node D will conceptually collect the following
        information into its\n   RIB:\n       o  ::/0 via B's link local\n       o
        \ D::/64 connected\n"
      title: A.1.3.  Routing Information Base
    title: A.1.  Example Operation in Storing Mode with Node-Owned Prefixes
  - contents:
    - "A.2.  Example Operation in Storing Mode with Subnet-Wide Prefix\n   Figure
      33 illustrates the logical addressing architecture of a simple\n   RPL network
      operating in Storing mode.  In this example, the root\n   Node A sources a prefix
      that is used for address autoconfiguration\n   over the entire RPL subnet.  (This
      is conveyed by setting the 'A'\n   flag and clearing the 'L' flag in the PIO
      of the DIO messages.)\n   Nodes A, B, C, and D all autoconfigure to the prefix
      A::/64.  Nodes\n   have the option of setting the 'R' flag and publishing their
      address\n   within the Prefix field of the PIO.\n                              +-------------+\n
      \                             |    Root     |\n                              |
      \            |\n                              |   Node A    |\n                              |
      \   A::A     |\n                              |             |\n                              +------+------+\n
      \                                    |\n                                     |\n
      \                                    |\n                              +------+------+\n
      \                             |             |\n                              |
      \  Node B    |\n                              |    A::B     |\n                              |
      \            |\n                              +------+------+\n                                     |\n
      \                                    |\n                      .--------------+--------------.\n
      \                    /                               \\\n                    /
      \                                \\\n            +------+------+                     +------+------+\n
      \           |             |                     |             |\n            |
      \  Node C    |                     |   Node D    |\n            |    A::C     |
      \                    |    A::D     |\n            |             |                     |
      \            |\n            +-------------+                     +-------------+\n
      \             Figure 33: Storing Mode with Subnet-Wide Prefix\n"
    - contents:
      - "A.2.1.  DIO Messages and PIO\n   Node A, for example, will send DIO messages
        with a PIO as follows:\n   'A' flag:       Set\n   'L' flag:       Clear\n
        \  'R' flag:       Clear\n   Prefix Length:  64\n   Prefix:         A::\n
        \  Node B, for example, will send DIO messages with a PIO as follows:\n   'A'
        flag:       Set\n   'L' flag:       Clear\n   'R' flag:       Set\n   Prefix
        Length:  64\n   Prefix:         A::B\n   Node C, for example, will send DIO
        messages with a PIO as follows:\n   'A' flag:       Set\n   'L' flag:       Clear\n
        \  'R' flag:       Clear\n   Prefix Length:  64\n   Prefix:         A::\n
        \  Node D, for example, will send DIO messages with a PIO as follows:\n   'A'
        flag:       Set\n   'L' flag:       Clear\n   'R' flag:       Set\n   Prefix
        Length:  64\n   Prefix:         A::D\n"
      title: A.2.1.  DIO Messages and PIO
    - contents:
      - "A.2.2.  DAO Messages\n   Node B will send DAO messages to Node A with the
        following\n   information:\n       o  Target A::B/128\n       o  Target A::C/128\n
        \      o  Target A::D/128\n   Node C will send DAO messages to Node B with
        the following\n   information:\n       o  Target A::C/128\n   Node D will
        send DAO messages to Node B with the following\n   information:\n       o
        \ Target A::D/128\n"
      title: A.2.2.  DAO Messages
    - contents:
      - "A.2.3.  Routing Information Base\n   Node A will conceptually collect the
        following information into its\n   RIB:\n       o  A::A/128 connected\n       o
        \ A::B/128 via B's link local\n       o  A::C/128 via B's link local\n       o
        \ A::D/128 via B's link local\n   Node B will conceptually collect the following
        information into its\n   RIB:\n       o  ::/0 via A's link local\n       o
        \ A::B/128 connected\n       o  A::C/128 via C's link local\n       o  A::D/128
        via D's link local\n   Node C will conceptually collect the following information
        into its\n   RIB:\n       o  ::/0 via B's link local\n       o  A::C/128 connected\n
        \  Node D will conceptually collect the following information into its\n   RIB:\n
        \      o  ::/0 via B's link local\n       o  A::D/128 connected\n"
      title: A.2.3.  Routing Information Base
    title: A.2.  Example Operation in Storing Mode with Subnet-Wide Prefix
  - contents:
    - "A.3.  Example Operation in Non-Storing Mode with Node-Owned Prefixes\n   Figure
      34 illustrates the logical addressing architecture of a simple\n   RPL network
      operating in Non-Storing mode.  In this example, each\n   Node, A, B, C, and
      D, owns its own prefix, and makes that prefix\n   available for address autoconfiguration
      by on-link devices.  (This is\n   conveyed by setting the 'A' flag and the 'L'
      flag in the PIO of the\n   DIO messages.)  Node A owns the prefix A::/64, Node
      B owns B::/64,\n   and so on.  Node B autoconfigures an on-link address with
      respect to\n   Node A, A::B.  Nodes C and D similarly autoconfigure on-link\n
      \  addresses from Node B's prefix, B::C and B::D, respectively.  Nodes\n   have
      the option of setting the 'R' flag and publishing their address\n   within the
      Prefix field of the PIO.\n                              +-------------+\n                              |
      \   Root     |\n                              |             |\n                              |
      \  Node A    |\n                              |             |\n                              |
      \   A::A     |\n                              +------+------+\n                                     |\n
      \                                    |\n                                     |\n
      \                             +------+------+\n                              |
      \   A::B     |\n                              |             |\n                              |
      \  Node B    |\n                              |             |\n                              |
      \   B::B     |\n                              +------+------+\n                                     |\n
      \                                    |\n                      .--------------+--------------.\n
      \                    /                               \\\n                    /
      \                                \\\n            +------+------+                     +------+------+\n
      \           |    B::C     |                     |    B::D     |\n            |
      \            |                     |             |\n            |   Node C    |
      \                    |   Node D    |\n            |             |                     |
      \            |\n            |    C::C     |                     |    D::D     |\n
      \           +-------------+                     +-------------+\n           Figure
      34: Non-Storing Mode with Node-Owned Prefixes\n"
    - contents:
      - "A.3.1.  DIO Messages and PIO\n   The PIO contained in the DIO messages in
        the Non-Storing mode with\n   node-owned prefixes can be considered to be
        identical to those in the\n   Storing mode with node-owned prefixes case (Appendix
        A.1.1).\n"
      title: A.3.1.  DIO Messages and PIO
    - contents:
      - "A.3.2.  DAO Messages\n   Node B will send DAO messages to Node A with the
        following\n   information:\n       o  Target B::/64, Transit A::B\n   Node
        C will send DAO messages to Node A with the following\n   information:\n       o
        \ Target C::/64, Transit B::C\n   Node D will send DAO messages to Node A
        with the following\n   information:\n       o  Target D::/64, Transit B::D\n"
      title: A.3.2.  DAO Messages
    - contents:
      - "A.3.3.  Routing Information Base\n   Node A will conceptually collect the
        following information into its\n   RIB.  Note that Node A has enough information
        to construct source\n   routes by doing recursive lookups into the RIB:\n
        \      o  A::/64 connected\n       o  B::/64 via A::B\n       o  C::/64 via
        B::C\n       o  D::/64 via B::D\n   Node B will conceptually collect the following
        information into its\n   RIB:\n       o  ::/0 via A's link local\n       o
        \ B::/64 connected\n   Node C will conceptually collect the following information
        into its\n   RIB:\n       o  ::/0 via B's link local\n       o  C::/64 connected\n
        \  Node D will conceptually collect the following information into its\n   RIB:\n
        \      o  ::/0 via B's link local\n       o  D::/64 connected\n"
      title: A.3.3.  Routing Information Base
    title: A.3.  Example Operation in Non-Storing Mode with Node-Owned Prefixes
  - contents:
    - "A.4.  Example Operation in Non-Storing Mode with Subnet-Wide Prefix\n   Figure
      35 illustrates the logical addressing architecture of a simple\n   RPL network
      operating in Non-Storing mode.  In this example, the root\n   Node A sources
      a prefix that is used for address autoconfiguration\n   over the entire RPL
      subnet.  (This is conveyed by setting the 'A'\n   flag and clearing the 'L'
      flag in the PIO of the DIO messages.)\n   Nodes A, B, C, and D all autoconfigure
      to the prefix A::/64.  Nodes\n   must set the 'R' flag and publish their address
      within the Prefix\n   field of the PIO, in order to inform their children which
      address to\n   use in the transit option.\n                              +-------------+\n
      \                             |    Root     |\n                              |
      \            |\n                              |   Node A    |\n                              |
      \   A::A     |\n                              |             |\n                              +------+------+\n
      \                                    |\n                                     |\n
      \                                    |\n                              +------+------+\n
      \                             |             |\n                              |
      \  Node B    |\n                              |    A::B     |\n                              |
      \            |\n                              +------+------+\n                                     |\n
      \                                    |\n                      .--------------+--------------.\n
      \                    /                               \\\n                    /
      \                                \\\n            +------+------+                     +------+------+\n
      \           |             |                     |             |\n            |
      \  Node C    |                     |   Node D    |\n            |    A::C     |
      \                    |    A::D     |\n            |             |                     |
      \            |\n            +-------------+                     +-------------+\n
      \           Figure 35: Non-Storing Mode with Subnet-Wide Prefix\n"
    - contents:
      - "A.4.1.  DIO Messages and PIO\n   Node A, for example, will send DIO messages
        with a PIO as follows:\n   'A' flag:       Set\n   'L' flag:       Clear\n
        \  'R' flag:       Set\n   Prefix Length:  64\n   Prefix:         A::A\n   Node
        B, for example, will send DIO messages with a PIO as follows:\n   'A' flag:
        \      Set\n   'L' flag:       Clear\n   'R' flag:       Set\n   Prefix Length:
        \ 64\n   Prefix:         A::B\n   Node C, for example, will send DIO messages
        with a PIO as follows:\n   'A' flag:       Set\n   'L' flag:       Clear\n
        \  'R' flag:       Set\n   Prefix Length:  64\n   Prefix:         A::C\n   Node
        D, for example, will send DIO messages with a PIO as follows:\n   'A' flag:
        \      Set\n   'L' flag:       Clear\n   'R' flag:       Set\n   Prefix Length:
        \ 64\n   Prefix:         A::D\n"
      title: A.4.1.  DIO Messages and PIO
    - contents:
      - "A.4.2.  DAO Messages\n   Node B will send DAO messages to Node A with the
        following\n   information:\n       o  Target A::B/128, Transit A::A\n   Node
        C will send DAO messages to Node A with the following\n   information:\n       o
        \ Target A::C/128, Transit A::B\n   Node D will send DAO messages to Node
        A with the following\n   information:\n       o  Target A::D/128, Transit
        A::B\n"
      title: A.4.2.  DAO Messages
    - contents:
      - "A.4.3.  Routing Information Base\n   Node A will conceptually collect the
        following information into its\n   RIB.  Note that Node A has enough information
        to construct source\n   routes by doing recursive lookups into the RIB:\n
        \      o  A::A/128 connected\n       o  A::B/128 via A::A\n       o  A::C/128
        via A::B\n       o  A::D/128 via A::B\n   Node B will conceptually collect
        the following information into its\n   RIB:\n       o  ::/0 via A's link local\n
        \      o  A::B/128 connected\n   Node C will conceptually collect the following
        information into its\n   RIB:\n       o  ::/0 via B's link local\n       o
        \ A::C/128 connected\n   Node D will conceptually collect the following information
        into its\n   RIB:\n       o  ::/0 via B's link local\n       o  A::D/128 connected\n"
      title: A.4.3.  Routing Information Base
    title: A.4.  Example Operation in Non-Storing Mode with Subnet-Wide Prefix
  - contents:
    - "A.5.  Example with External Prefixes\n   Consider the simple network illustrated
      in Figure 36.  In this\n   example, there are a group of routers participating
      in a RPL network:\n   a DODAG root, Nodes A, Y, and Z.  The DODAG root and Node
      Z also have\n   connectivity to different external network domains (i.e., external
      to\n   the RPL network).  Note that those external networks could be RPL\n   networks
      or another type of network altogether.\n                          RPL Network
      \       +-------------------+\n                           RPL::/64          |
      \                  |\n                                             |     External
      \     |\n              [RPL::Root]    (Root)----------+      Prefix       |\n
      \                              |             |    EXT_1::/64     |\n                               |
      \            |                   |\n                               |             +-------------------+\n
      \                [RPL::A]     (A)\n                               :\n                               :\n
      \                              :\n                 [RPL::Y]     (Y)\n                               |
      \            +-------------------+\n                               |             |
      \                  |\n                               |             |     External
      \     |\n                 [RPL::Z]     (Z)------------+      Prefix       |\n
      \                              :             |    EXT_2::/64     |\n                               :
      \            |                   |\n                               :             +-------------------+\n
      \                    Figure 36: Simple Network Example\n   In this example,
      the DODAG root makes a prefix available to the RPL\n   subnet for address autoconfiguration.
      \ Here, the entire RPL subnet\n   uses that same prefix, RPL::/64, for address
      autoconfiguration,\n   though in other implementations more complex/hybrid schemes
      could be\n   employed.\n   The DODAG root has connectivity to an external (with
      respect to that\n   RPL network) prefix EXT_1::/64.  The DODAG root may have
      learned of\n   connectivity to this prefix, for example, via explicit configuration\n
      \  or IPv6 ND on a non-RPL interface.  The DODAG root is configured to\n   announce
      information on the connectivity to this prefix.\n   Similarly, Node Z has connectivity
      to an external prefix EXT_2::/64.\n   Node Z also has a sub-DODAG underneath
      of it.\n   1.  The DODAG root adds a RIO to its DIO messages.  The RIO contains\n
      \      the external prefix EXT_1::/64.  This information may be repeated\n       in
      the DIO messages emitted by the other nodes within the DODAG.\n       Thus,
      the reachability to the prefix EXT_1::/64 is disseminated\n       down the DODAG.\n
      \  2.  Node Z may advertise reachability to the Target network\n       EXT_2::/64
      by sending DAO messages using EXT_2::/64 as a Target\n       in the Target option
      and itself (Node Z) as a parent in the\n       Transit Information option.  (In
      Storing mode, that Transit\n       Information option does not need to contain
      the address of Node\n       Z).  A non-storing root then becomes aware of the
      1-hop link\n       (Node Z -- EXT_2::/64) for use in constructing source routes.\n
      \      Node Z may additionally advertise its reachability to EXT_2::/64\n       to
      nodes in its sub-DODAG by sending DIO messages with a PIO,\n       with the
      'A' flag cleared.\n"
    title: A.5.  Example with External Prefixes
  title: Appendix A.  Example Operation
- contents:
  - "Authors' Addresses\n   Tim Winter (editor)\n   EMail: wintert@acm.org\n   Pascal
    Thubert (editor)\n   Cisco Systems\n   Village d'Entreprises Green Side\n   400,
    Avenue de Roumanille\n   Batiment T3\n   Biot - Sophia Antipolis  06410\n   France\n
    \  Phone: +33 497 23 26 34\n   EMail: pthubert@cisco.com\n   Anders Brandt\n   Sigma
    Designs\n   Emdrupvej 26A, 1.\n   Copenhagen  DK-2100\n   Denmark\n   EMail: abr@sdesigns.dk\n
    \  Jonathan W. Hui\n   Arch Rock Corporation\n   501 2nd St., Suite 410\n   San
    Francisco, CA  94107\n   USA\n   EMail: jhui@archrock.com\n   Richard Kelsey\n
    \  Ember Corporation\n   Boston, MA\n   USA\n   Phone: +1 617 951 1225\n   EMail:
    kelsey@ember.com\n   Philip Levis\n   Stanford University\n   358 Gates Hall,
    Stanford University\n   Stanford, CA  94305-9030\n   USA\n   EMail: pal@cs.stanford.edu\n
    \  Kris Pister\n   Dust Networks\n   30695 Huntwood Ave.\n   Hayward, CA  94544\n
    \  USA\n   EMail: kpister@dustnetworks.com\n   Rene Struik\n   Struik Security
    Consultancy\n   EMail: rstruik.ext@gmail.com\n   JP. Vasseur\n   Cisco Systems\n
    \  11, Rue Camille Desmoulins\n   Issy Les Moulineaux  92782\n   France\n   EMail:
    jpv@cisco.com\n   Roger K. Alexander\n   Cooper Power Systems\n   20201 Century
    Blvd., Suite 250\n   Germantown, MD  20874\n   USA\n   Phone: +1 240 454 9817\n
    \  EMail: roger.alexander@cooperindustries.com\n"
  title: Authors' Addresses
