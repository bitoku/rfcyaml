- contents:
  - "          Remote Authentication Dial-In User Service (RADIUS)\n                          Protocol
    Extensions\n"
  title: __initial_text__
- contents:
  - "Abstract\n   The Remote Authentication Dial-In User Service (RADIUS) protocol
    is\n   nearing exhaustion of its current 8-bit Attribute Type space.  In\n   addition,
    experience shows a growing need for complex grouping, along\n   with attributes
    that can carry more than 253 octets of data.  This\n   document defines changes
    to RADIUS that address all of the above\n   problems.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6929.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2013 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1. Introduction ....................................................3\n
    \     1.1. Caveats and Limitations ....................................5\n           1.1.1.
    Failure to Meet Certain Goals .......................5\n           1.1.2. Implementation
    Recommendations ......................5\n      1.2. Terminology ................................................6\n
    \     1.3. Requirements Language ......................................7\n   2.
    Extensions to RADIUS ............................................7\n      2.1.
    Extended Type ..............................................8\n      2.2. Long
    Extended Type .........................................9\n      2.3. TLV Data
    Type .............................................12\n           2.3.1. TLV Nesting
    ........................................14\n      2.4. EVS Data Type .............................................14\n
    \     2.5. Integer64 Data Type .......................................16\n      2.6.
    Vendor-Id Field ...........................................16\n      2.7. Attribute
    Naming and Type Identifiers .....................17\n           2.7.1. Attribute
    and TLV Naming ...........................17\n           2.7.2. Attribute Type
    Identifiers .........................18\n           2.7.3. TLV Identifiers ....................................18\n
    \          2.7.4. VSA Identifiers ....................................18\n      2.8.
    Invalid Attributes ........................................19\n   3. Attribute
    Definitions ..........................................21\n      3.1. Extended-Type-1
    ...........................................21\n      3.2. Extended-Type-2 ...........................................22\n
    \     3.3. Extended-Type-3 ...........................................23\n      3.4.
    Extended-Type-4 ...........................................24\n      3.5. Long-Extended-Type-1
    ......................................25\n      3.6. Long-Extended-Type-2 ......................................26\n
    \  4. Vendor-Specific Attributes .....................................27\n      4.1.
    Extended-Vendor-Specific-1 ................................28\n      4.2. Extended-Vendor-Specific-2
    ................................29\n      4.3. Extended-Vendor-Specific-3 ................................30\n
    \     4.4. Extended-Vendor-Specific-4 ................................31\n      4.5.
    Extended-Vendor-Specific-5 ................................32\n      4.6. Extended-Vendor-Specific-6
    ................................34\n   5. Compatibility with Traditional RADIUS
    ..........................35\n      5.1. Attribute Allocation ......................................35\n
    \     5.2. Proxy Servers .............................................36\n   6.
    Guidelines .....................................................37\n      6.1.
    Updates to RFC 6158 .......................................37\n      6.2. Guidelines
    for Simple Data Types ..........................38\n      6.3. Guidelines for
    Complex Data Types .........................38\n      6.4. Design Guidelines for
    the New Types .......................39\n      6.5. TLV Guidelines ............................................40\n
    \     6.6. Allocation Request Guidelines .............................40\n      6.7.
    Allocation Request Guidelines for TLVs ....................41\n      6.8. Implementation
    Guidelines .................................42\n      6.9. Vendor Guidelines .........................................42\n
    \  7. Rationale for This Design ......................................42\n      7.1.
    Attribute Audit ...........................................43\n   8. Diameter
    Considerations ........................................44\n   9. Examples .......................................................44\n
    \     9.1. Extended Type .............................................46\n      9.2.
    Long Extended Type ........................................47\n   10. IANA Considerations
    ...........................................50\n      10.1. Attribute Allocations
    ....................................50\n      10.2. RADIUS Attribute Type Tree
    ...............................50\n      10.3. Allocation Instructions ..................................52\n
    \          10.3.1. Requested Allocation from the Standard Space ......52\n           10.3.2.
    Requested Allocation from the Short\n                   Extended Space ....................................52\n
    \          10.3.3. Requested Allocation from the Long\n                   Extended
    Space ....................................52\n           10.3.4. Allocation Preferences
    ............................52\n           10.3.5. Extending the Type Space via
    the TLV Data Type ....53\n           10.3.6. Allocation within a TLV ...........................53\n
    \          10.3.7. Allocation of Other Data Types ....................54\n   11.
    Security Considerations .......................................54\n   12. References
    ....................................................54\n      12.1. Normative
    References .....................................54\n      12.2. Informative References
    ...................................55\n   13. Acknowledgments ...............................................55\n
    \  Appendix A. Extended Attribute Generator Program ..................56\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   Under current allocation pressure, we expect that the RADIUS\n
    \  Attribute Type space will be exhausted by 2014 or 2015.  We therefore\n   need
    a way to extend the type space so that new specifications may\n   continue to
    be developed.  Other issues have also been shown with\n   RADIUS.  The attribute
    grouping method defined in [RFC2868] has been\n   shown to be impractical, and
    a more powerful mechanism is needed.\n   Multiple Attributes have been defined
    that transport more than the\n   253 octets of data originally envisioned with
    the protocol.  Each of\n   these attributes is handled as a \"special case\" inside
    of RADIUS\n   implementations, instead of as a general method.  We therefore also\n
    \  need a standardized method of transporting large quantities of data.\n   Finally,
    some vendors are close to allocating all of the Attributes\n   within their Vendor-Specific
    Attribute space.  It would be useful to\n   leverage changes to the base protocol
    for extending the Vendor-\n   Specific Attribute space.\n   We satisfy all of
    these requirements through the following changes\n   given in this document:\n
    \  * Defining an \"Extended Type\" format, which adds 8 bits of \"Extended\n     Type\"
    to the RADIUS Attribute Type space, by using one octet of the\n     \"Value\"
    field.  This method gives us a general way of extending the\n     Attribute Type
    space (Section 2.1).\n   * Allocating 4 attributes as using the format of \"Extended
    Type\".\n     This allocation extends the RADIUS Attribute Type space by\n     approximately
    1000 values (Sections 3.1, 3.2, 3.3, and 3.4).\n   * Defining a \"Long Extended
    Type\" format, which inserts an additional\n     octet between the \"Extended
    Type\" octet and the \"Value\" field.\n     This method gives us a general way
    of adding more functionality to\n     the protocol (Section 2.2).\n   * Defining
    a method that uses the additional octet in the \"Long\n     Extended Type\" to
    indicate data fragmentation across multiple\n     Attributes.  This method provides
    a standard way for an Attribute\n     to carry more than 253 octets of data (Section
    2.2).\n   * Allocating 2 attributes as using the format \"Long Extended Type\".\n
    \    This allocation extends the RADIUS Attribute Type space by an\n     additional
    500 values (Sections 3.5 and 3.6).\n   * Defining a new \"Type-Length-Value\"
    (TLV) data type.  This data type\n     allows an attribute to carry TLVs as \"sub-Attributes\",
    which can in\n     turn encapsulate other TLVs as \"sub-sub-Attributes\".  This
    change\n     creates a standard way to group a set of Attributes (Section 2.3).\n
    \  * Defining a new \"Extended-Vendor-Specific\" (EVS) data type.  This\n     data
    type allows an attribute to carry Vendor-Specific Attributes\n     (VSAs) inside
    of the new Attribute formats (Section 2.4).\n   * Defining a new \"integer64\"
    data type.  This data type allows\n     counters that track more than 2^32 octets
    of data (Section 2.5).\n   * Allocating 6 attributes using the new EVS data type.
    \ This\n     allocation extends the Vendor-Specific Attribute Type space by over\n
    \    1500 values (Sections 4.1 through 4.6).\n   * Defining the \"Vendor-Id\"
    for Vendor-Specific Attributes to\n     encompass the entire 4 octets of the Vendor
    field.  [RFC2865]\n     Section 5.26 defined it to be 3 octets, with the fourth
    octet being\n     zero (Section 2.6).\n   * Describing compatibility with existing
    RADIUS systems (Section 5).\n   * Defining guidelines for the use of these changes
    for IANA,\n     implementations of this specification, and for future RADIUS\n
    \    specifications (Section 6).\n   As with any protocol change, the changes
    defined here are the result\n   of a series of compromises.  We have tried to
    find a balance between\n   flexibility, space in the RADIUS message, compatibility
    with existing\n   deployments, and difficulty of implementation.\n"
  - contents:
    - "1.1.  Caveats and Limitations\n   This section describes some caveats and limitations
      of the proposal.\n"
    - contents:
      - "1.1.1.  Failure to Meet Certain Goals\n   One goal that was not met by the
        above modifications is to have an\n   incentive for standards to use the new
        space.  That incentive is\n   being provided by the exhaustion of the standard
        space.\n"
      title: 1.1.1.  Failure to Meet Certain Goals
    - contents:
      - "1.1.2.  Implementation Recommendations\n   It is RECOMMENDED that implementations
        support this specification.\n   It is RECOMMENDED that new specifications
        use the formats defined in\n   this specification.\n   The alternative to
        the above recommendations is a circular argument\n   of not implementing this
        specification because no other standards\n   reference it, and also not defining
        new standards referencing this\n   specification because no implementations
        exist.\n   As noted earlier, the standard space is almost entirely allocated.\n
        \  Ignoring the looming crisis benefits no one.\n"
      title: 1.1.2.  Implementation Recommendations
    title: 1.1.  Caveats and Limitations
  - contents:
    - "1.2.  Terminology\n   This document uses the following terms:\n   Silently
      discard\n      This means the implementation discards the packet without further\n
      \     processing.  The implementation MAY provide the capability of\n      logging
      the error, including the contents of the silently\n      discarded packet, and
      SHOULD record the event in a statistics\n      counter.\n   Invalid attribute\n
      \     This means that the Length field of an Attribute is valid (as per\n      [RFC2865],
      Section 5, top of page 25) but the contents of the\n      Attribute do not follow
      the correct format, for example, an\n      Attribute of type \"address\" that
      encapsulates more than four, or\n      less than four, octets of data.  See
      Section 2.8 for a more\n      complete definition.\n   Standard space\n      This
      refers to codes in the RADIUS Attribute Type space that are\n      allocated
      by IANA and that follow the format defined in Section 5\n      of [RFC2865].\n
      \  Extended space\n      This refers to codes in the RADIUS Attribute Type space
      that\n      require the extensions defined in this document and are an\n      extension
      of the standard space, but that cannot be represented\n      within the standard
      space.\n   Short extended space\n      This refers to codes in the extended
      space that use the \"Extended\n      Type\" format.\n   Long extended space\n
      \     This refers to codes in the extended space that use the \"Long\n      Extended
      Type\" format.\n   The following terms are used here with the meanings defined
      in BCP 26\n   [RFC5226]: \"namespace\", \"assigned value\", \"registration\",
      \"Private\n   Use\", \"Reserved\", \"Unassigned\", \"IETF Review\", and \"Standards\n
      \  Action\".\n"
    title: 1.2.  Terminology
  - contents:
    - "1.3.  Requirements Language\n   In this document, several words are used to
      signify the requirements\n   of the specification.  The key words \"MUST\",
      \"MUST NOT\", \"REQUIRED\",\n   \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD
      NOT\", \"RECOMMENDED\", \"MAY\",\n   and \"OPTIONAL\" in this document are to
      be interpreted as described in\n   [RFC2119].\n"
    title: 1.3.  Requirements Language
  title: 1.  Introduction
- contents:
  - "2.  Extensions to RADIUS\n   This section defines two new Attribute formats:
    \"Extended Type\" and\n   \"Long Extended Type\".  It defines a new Type-Length-Value
    (TLV) data\n   type, an Extended-Vendor-Specific (EVS) data type, and an Integer64\n
    \  data type.  It defines a new method for naming attributes and\n   identifying
    Attributes using the new Attribute formats.  It finally\n   defines the new term
    \"invalid attribute\" and describes how it affects\n   implementations.\n   The
    new Attribute formats are designed to be compatible with the\n   Attribute format
    given in [RFC2865] Section 5.  The meaning and\n   interpretation of the Type
    and Length fields are unchanged from that\n   specification.  This reuse allows
    the new formats to be compatible\n   with RADIUS implementations that do not implement
    this specification.\n   Those implementations can simply ignore the \"Value\"
    field of an\n   attribute or forward it verbatim.\n   The changes to the Attribute
    format come about by \"stealing\" one or\n   more octets from the \"Value\" field.
    \ This change has the effect that\n   the \"Value\" field of [RFC2865] Section
    5 contains both the new octets\n   given here and any attribute-specific Value.
    \ The result is that\n   \"Value\"s in this specification are limited to less
    than 253 octets in\n   size.  This limitation is overcome through the use of the
    \"Long\n   Extended Type\" format.\n   We reiterate that the formats given in
    this document do not insert\n   new data into an attribute.  Instead, we \"steal\"
    one octet of Value,\n   so that the definition of the Length field remains unchanged.
    \ The\n   new Attribute formats are designed to be compatible with the\n   Attribute
    format given in [RFC2865] Section 5.  The meaning and\n   interpretation of the
    Type and Length fields is unchanged from that\n   specification.  This reuse allows
    the new formats to be compatible\n   with RADIUS implementations that do not implement
    this specification.\n   Those implementations can simply ignore the \"Value\"
    field of an\n   attribute or forward it verbatim.\n"
  - contents:
    - "2.1.  Extended Type\n   This section defines a new Attribute format, called
      \"Extended Type\".\n   A summary of the Attribute format is shown below.  The
      fields are\n   transmitted from left to right.\n     0                   1                   2
      \                  3\n     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \   |     Type      |    Length     | Extended-Type |  Value ...\n    +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Type\n      This field is identical to the Type field of the Attribute format\n
      \     defined in [RFC2865] Section 5.\n   Length\n      The Length field is
      one octet and indicates the length of this\n      Attribute, including the Type,
      Length, \"Extended-Type\", and\n      \"Value\" fields.  Permitted values are
      between 4 and 255.  If a\n      client or server receives an Extended Attribute
      with a Length of 2\n      or 3, then that Attribute MUST be considered to be
      an \"invalid\n      attribute\" and handled as per Section 2.8, below.\n   Extended-Type\n
      \     The Extended-Type field is one octet.  Up-to-date values of this\n      field
      are specified according to the policies and rules described\n      in Section
      10.  Unlike the Type field defined in [RFC2865]\n      Section 5, no values
      are allocated for experimental or\n      implementation-specific use.  Values
      241-255 are reserved and MUST\n      NOT be used.\n      The Extended-Type is
      meaningful only within a context defined by\n      the Type field.  That is,
      this field may be thought of as defining\n      a new type space of the form
      \"Type.Extended-Type\".  See\n      Section 3.5, below, for additional discussion.\n
      \     A RADIUS server MAY ignore Attributes with an unknown\n      \"Type.Extended-Type\".\n
      \     A RADIUS client MAY ignore Attributes with an unknown\n      \"Type.Extended-Type\".\n
      \  Value\n      This field is similar to the \"Value\" field of the Attribute
      format\n      defined in [RFC2865] Section 5.  The format of the data MUST be
      a\n      valid RADIUS data type.\n      The \"Value\" field is one or more octets.\n
      \     Implementations supporting this specification MUST use the\n      identifier
      of \"Type.Extended-Type\" to determine the interpretation\n      of the \"Value\"
      field.\n      The addition of the Extended-Type field decreases the maximum\n
      \     length for attributes of type \"text\" or \"string\" from 253 to\n      252
      octets.  Where an Attribute needs to carry more than\n      252 octets of data,
      the \"Long Extended Type\" format MUST be used.\n   Experience has shown that
      the \"experimental\" and \"implementation-\n   specific\" attributes defined
      in [RFC2865] Section 5 have had little\n   practical value.  We therefore do
      not continue that practice here\n   with the Extended-Type field.\n"
    title: 2.1.  Extended Type
  - contents:
    - "2.2.  Long Extended Type\n   This section defines a new Attribute format, called
      \"Long Extended\n   Type\".  It leverages the \"Extended Type\" format in order
      to permit\n   the transport of attributes encapsulating more than 253 octets
      of\n   data.  A summary of the Attribute format is shown below.  The fields\n
      \  are transmitted from left to right.\n    0                   1                   2
      \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |     Type      |    Length     | Extended-Type |M|  Reserved   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |     Value ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Type\n      This field is identical to the Type field of the Attribute format\n
      \     defined in [RFC2865] Section 5.\n   Length\n      The Length field is
      one octet and indicates the length of this\n      Attribute, including the Type,
      Length, Extended-Type, and \"Value\"\n      fields.  Permitted values are between
      5 and 255.  If a client or\n      server receives a \"Long Extended Type\" with
      a Length of 2, 3, or\n      4, then that Attribute MUST be considered to be
      an \"invalid\n      attribute\" and handled as per Section 2.8, below.\n      Note
      that this Length is limited to the length of this fragment.\n      There is
      no field that gives an explicit value for the total size\n      of the fragmented
      attribute.\n   Extended-Type\n      This field is identical to the Extended-Type
      field defined above\n      in Section 2.1.\n   M (More)\n      The More field
      is one (1) bit in length and indicates whether or\n      not the current attribute
      contains \"more\" than 251 octets of data.\n      The More field MUST be clear
      (0) if the Length field has a value\n      of less than 255.  The More field
      MAY be set (1) if the Length\n      field has a value of 255.\n      If the
      More field is set (1), it indicates that the \"Value\" field\n      has been
      fragmented across multiple RADIUS attributes.  When the\n      More field is
      set (1), the Attribute MUST have a Length field of\n      value 255, there MUST
      be an attribute following this one, and the\n      next attribute MUST have
      both the same Type and \"Extended Type\".\n      That is, multiple fragments
      of the same value MUST be in order and\n      MUST be consecutive attributes
      in the packet, and the last\n      attribute in a packet MUST NOT have the More
      field set (1).\n      That is, a packet containing a fragmented attribute needs
      to\n      contain all fragments of the Attribute, and those fragments need\n
      \     to be contiguous in the packet.  RADIUS does not support\n      inter-packet
      fragmentation, which means that fragmenting an\n      attribute across multiple
      packets is impossible.\n      If a client or server receives an attribute fragment
      with the\n      \"More\" field set (1) but for which no subsequent fragment
      can be\n      found, then the fragmented attribute is considered to be an\n
      \     \"invalid attribute\" and handled as per Section 2.8, below.\n   Reserved\n
      \     This field is 7 bits long and is reserved for future use.\n      Implementations
      MUST set it to zero (0) when encoding an attribute\n      for sending in a packet.
      \ The contents SHOULD be ignored on\n      reception.\n      Future specifications
      may define additional meaning for this\n      field.  Implementations therefore
      MUST NOT treat this field as\n      invalid if it is non-zero.\n   Value\n      This
      field is similar to the \"Value\" field of the Attribute format\n      defined
      in [RFC2865] Section 5.  It may contain a complete set of\n      data (when
      the Length field has a value of less than 255), or it\n      may contain a fragment
      of data.\n      The \"Value\" field is one or more octets.\n      Implementations
      supporting this specification MUST use the\n      identifier of \"Type.Extended-Type\"
      to determine the interpretation\n      of the \"Value\" field.\n      Any interpretation
      of the resulting data MUST occur after the\n      fragments have been reassembled.
      \ The length of the data MUST be\n      taken as the sum of the lengths of the
      fragments (i.e., \"Value\"\n      fields) from which it is constructed.  The
      format of the data\n      SHOULD be a valid RADIUS data type.  If the reassembled
      data does\n      not match the expected format, all fragments MUST be treated
      as\n      \"invalid attributes\", and the reassembled data MUST be discarded.\n
      \     We note that the maximum size of a fragmented attribute is limited\n      only
      by the RADIUS packet length limitation (i.e., 4096 octets,\n      not counting
      various headers and overhead).  Implementations MUST\n      be able to handle
      the case where one fragmented attribute\n      completely fills the packet.\n
      \  This definition increases the RADIUS Attribute Type space as above\n   but
      also provides for transport of Attributes that could contain more\n   than 253
      octets of data.\n   Note that [RFC2865] Section 5 says:\n      If multiple Attributes
      with the same Type are present, the order\n      of Attributes with the same
      Type MUST be preserved by any proxies.\n      The order of Attributes of different
      Types is not required to be\n      preserved.  A RADIUS server or client MUST
      NOT have any\n      dependencies on the order of attributes of different types.
      \ A\n      RADIUS server or client MUST NOT require attributes of the same\n
      \     type to be contiguous.\n   These requirements also apply to the \"Long
      Extended Type\" Attribute,\n   including fragments.  Implementations MUST be
      able to process\n   non-contiguous fragments -- that is, fragments that are
      mixed\n   together with other attributes of a different Type.  This will allow\n
      \  them to accept packets, so long as the Attributes can be correctly\n   decoded.\n"
    title: 2.2.  Long Extended Type
  - contents:
    - "2.3.  TLV Data Type\n   We define a new data type in RADIUS, called \"tlv\".
      \ The \"tlv\" data\n   type is an encapsulation layer that permits the \"Value\"
      field of an\n   Attribute to contain new sub-Attributes.  These sub-Attributes
      can in\n   turn contain \"Value\"s of data type TLV.  This capability both extends\n
      \  the Attribute space and permits \"nested\" attributes to be used.  This\n
      \  nesting can be used to encapsulate or group data into one or more\n   logical
      containers.\n   The \"tlv\" data type reuses the RADIUS Attribute format, as
      given\n   below:\n    0                   1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |   TLV-Type    |  TLV-Length   |     TLV-Value ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  TLV-Type\n      The TLV-Type field is one octet.  Up-to-date values of this
      field\n      are specified according to the policies and rules described in\n
      \     Section 10.  Values 254-255 are \"Reserved\" for use by future\n      extensions
      to RADIUS.  The value 26 has no special meaning and\n      MUST NOT be treated
      as a Vendor-Specific Attribute.\n      As with the Extended-Type field defined
      above, the TLV-Type is\n      meaningful only within the context defined by
      \"Type\" fields of the\n      encapsulating Attributes.  That is, the field
      may be thought of as\n      defining a new type space of the form\n      \"Type.Extended-Type.TLV-Type\".
      \ Where TLVs are nested, the type\n      space is of the form \"Type.Extended-Type.TLV-Type.TLV-Type\",
      etc.\n      A RADIUS server MAY ignore Attributes with an unknown \"TLV-Type\".\n
      \     A RADIUS client MAY ignore Attributes with an unknown \"TLV-Type\".\n
      \     A RADIUS proxy SHOULD forward Attributes with an unknown\n      \"TLV-Type\"
      verbatim.\n   TLV-Length\n      The TLV-Length field is one octet and indicates
      the length of this\n      TLV, including the TLV-Type, TLV-Length, and TLV-Value
      fields.  It\n      MUST have a value between 3 and 255.  If a client or server\n
      \     receives a TLV with an invalid TLV-Length, then the Attribute that\n      encapsulates
      that TLV MUST be considered to be an \"invalid\n      attribute\" and handled
      as per Section 2.8, below.\n   TLV-Value\n      The TLV-Value field is one or
      more octets and contains information\n      specific to the Attribute.  The
      format and length of the TLV-Value\n      field are determined by the TLV-Type
      and TLV-Length fields.\n      The TLV-Value field SHOULD encapsulate a standard
      RADIUS data\n      type.  Non-standard data types SHOULD NOT be used within
      TLV-Value\n      fields.  We note that the TLV-Value field MAY also contain
      one or\n      more attributes of data type TLV; data type TLV allows for simple\n
      \     grouping and multiple layers of nesting.\n      The TLV-Value field is
      limited to containing 253 or fewer octets\n      of data.  Specifications that
      require a TLV to contain more than\n      253 octets of data are incompatible
      with RADIUS and need to be\n      redesigned.  Specifications that require the
      transport of empty\n      \"Value\"s (i.e., Length = 2) are incompatible with
      RADIUS and need\n      to be redesigned.\n      The TLV-Value field MUST NOT
      contain data using the \"Extended\n      Type\" formats defined in this document.
      \ The base Extended\n      Attributes format allows for sufficient flexibility
      that nesting\n      them inside of a TLV offers little additional value.\n   This
      TLV definition is compatible with the suggested format of the\n   \"String\"
      field of the Vendor-Specific Attribute, as defined in\n   [RFC2865] Section
      5.26, though that specification does not discuss\n   nesting.\n   Vendors MAY
      use attributes of type \"TLV\" in any Vendor-Specific\n   Attribute.  It is
      RECOMMENDED to use type \"TLV\" for VSAs, in\n   preference to any other format.\n
      \  If multiple TLVs with the same TLV-Type are present, the order of\n   TLVs
      with the same TLV-Type MUST be preserved by any proxies.  The\n   order of TLVs
      of different TLV-Types is not required to be preserved.\n   A RADIUS server
      or client MUST NOT have any dependencies on the order\n   of TLVs of different
      TLV-Types.  A RADIUS server or client MUST NOT\n   require TLVs of the same
      TLV-Type to be contiguous.\n   The interpretation of multiple TLVs of the same
      TLV-Type MUST be that\n   of a logical \"and\", unless otherwise specified.
      \ That is, multiple\n   TLVs are interpreted as specifying an unordered set
      of values.\n   Specifications SHOULD NOT define TLVs to be interpreted as a
      logical\n   \"or\".  Doing so would mean that a RADIUS client or server would
      make\n   an arbitrary and non-deterministic choice among the values.\n"
    - contents:
      - "2.3.1.  TLV Nesting\n   TLVs may contain other TLVs.  When this occurs, the
        \"container\" TLV\n   MUST be completely filled by the \"contained\" TLVs.
        \ That is, the\n   \"container\" TLV-Length field MUST be exactly two (2)
        more than the\n   sum of the \"contained\" TLV-Length fields.  If the \"contained\"
        TLVs\n   overfill the \"container\" TLV, the \"container\" TLV MUST be considered\n
        \  to be an \"invalid attribute\" and handled as described in Section 2.8,\n
        \  below.\n   The depth of TLV nesting is limited only by the restrictions
        on the\n   TLV-Length field.  The limit of 253 octets of data results in a
        limit\n   of 126 levels of nesting.  However, nesting depths of more than
        4 are\n   NOT RECOMMENDED.  They have not been demonstrated to be necessary
        in\n   practice, and they appear to make implementations more complex.\n   Reception
        of packets with such deeply nested TLVs may indicate\n   implementation errors
        or deliberate attacks.  Where implementations\n   do not support deep nesting
        of TLVs, it is RECOMMENDED that the\n   unsupported layers are treated as
        \"invalid attributes\".\n"
      title: 2.3.1.  TLV Nesting
    title: 2.3.  TLV Data Type
  - contents:
    - "2.4.  EVS Data Type\n   We define a new data type in RADIUS, called \"evs\",
      for \"Extended-\n   Vendor-Specific\".  The \"evs\" data type is an encapsulation
      layer that\n   permits the EVS-Value field of an Attribute to contain a Vendor-Id,\n
      \  followed by an EVS-Type, and then vendor-defined data.  This data can\n   in
      turn contain valid RADIUS data types or any other data as\n   determined by
      the vendor.\n   This data type is intended for use in attributes that carry
      vendor-\n   specific information, as is done with the Vendor-Specific Attribute\n
      \  (Attribute number 26).  It is RECOMMENDED that this data type be used\n   by
      a vendor only when the Vendor-Specific Attribute Type space has\n   been fully
      allocated.\n   Where [RFC2865] Section 5.26 makes a recommendation for the format
      of\n   the data following the Vendor-Id, we give a strict definition.\n   Experience
      has shown that many vendors have not followed the\n   [RFC2865] recommendations,
      leading to interoperability issues.  We\n   hope here to give vendors sufficient
      flexibility as to meet their\n   needs while minimizing the use of non-standard
      VSA formats.\n   The \"evs\" data type MAY be used in Attributes having the
      format of\n   \"Extended Type\" or \"Long Extended Type\".  It MUST NOT be used
      in any\n   other Attribute definition, including standard RADIUS attributes,\n
      \  TLVs, and VSAs.\n   A summary of the \"evs\" data type format is shown below.
      \ The fields\n   are transmitted from left to right.\n    0                   1
      \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                            Vendor-Id                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |  EVS-Type      |  EVS-Value ....\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Vendor-Id\n      The 4 octets of the Vendor-Id field are the Network Management\n
      \     Private Enterprise Code [PEN] of the vendor in network byte order.\n   EVS-Type\n
      \     The EVS-Type field is one octet.  Values are assigned at the sole\n      discretion
      of the vendor.\n   EVS-Value\n      The EVS-Value field is one or more octets.
      \ It SHOULD encapsulate\n      a standard RADIUS data type.  Using non-standard
      data types is NOT\n      RECOMMENDED.  We note that the EVS-Value field may
      be of data type\n      TLV.  However, it MUST NOT be of data type \"evs\", as
      the use cases\n      are unclear for one vendor delegating Attribute Type space
      to\n      another vendor.\n      The actual format of the information is site
      or application\n      specific, and a robust implementation SHOULD support the
      field as\n      undistinguished octets.  While we recognize that vendors have\n
      \     complete control over the contents and format of the EVS-Value\n      field,
      we recommend that good practices be followed.\n      Further codification of
      the range of allowed usage of this field\n      is outside the scope of this
      specification.\n   Note that unlike the format described in [RFC2865] Section
      5.26, this\n   data type has no \"Vendor-Length\" field.  The length of the
      EVS-Value\n   field is implicit and is determined by taking the \"Length\" of
      the\n   encapsulating RADIUS attribute and then subtracting the length of the\n
      \  Attribute header (2 octets), the \"Extended Type\" (1 octet), the\n   Vendor-Id
      (4 octets), and the EVS-Type (1 octet).  That is, for\n   \"Extended Type\"
      Attributes the length of the EVS-Value field is eight\n   (8) less than the
      value of the Length field, and for \"Long Extended\n   Type\" Attributes the
      length of the EVS-Value field is nine (9) less\n   than the value of the Length
      field.\n"
    title: 2.4.  EVS Data Type
  - contents:
    - "2.5.  Integer64 Data Type\n   We define a new data type in RADIUS, called \"integer64\",
      which\n   carries a 64-bit unsigned integer in network byte order.\n   This
      data type is intended to be used in any situation where there is\n   a need
      to have counters that can count past 2^32.  The expected use\n   of this data
      type is within Accounting-Request packets, but this data\n   type SHOULD be
      used in any packet where 32-bit integers are expected\n   to be insufficient.\n
      \  The \"integer64\" data type can be used in Attributes of any format,\n   standard
      space, extended attributes, TLVs, and VSAs.\n   A summary of the \"integer64\"
      data type format is shown below.  The\n   fields are transmitted from left to
      right.\n    0                   1                   2                   3\n
      \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                  Value ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \                                                                  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Attributes having data type \"integer64\" MUST have the relevant Length\n
      \  field set to eight more than the length of the Attribute header.  For\n   standard
      space Attributes and TLVs, this means that the Length field\n   MUST be set
      to ten (10).  For \"Extended Type\" Attributes, the Length\n   field MUST be
      set to eleven (11).  For \"Long Extended Type\"\n   Attributes, the Length field
      MUST be set to twelve (12).\n"
    title: 2.5.  Integer64 Data Type
  - contents:
    - "2.6.  Vendor-Id Field\n   We define the Vendor-Id field of Vendor-Specific
      Attributes\n   to encompass the entire 4 octets of the Vendor field.\n   [RFC2865]
      Section 5.26 defined it to be 3 octets, with the fourth\n   octet being zero.
      \ This change has no immediate impact on RADIUS, as\n   the maximum Private
      Enterprise Code defined is still within 16 bits.\n   However, it is best to
      make advance preparations for changes in the\n   protocol.  As such, it is RECOMMENDED
      that all implementations\n   support four (4) octets for the Vendor-Id field,
      instead of\n   three (3).\n"
    title: 2.6.  Vendor-Id Field
  - contents:
    - "2.7.  Attribute Naming and Type Identifiers\n   Attributes have traditionally
      been identified by a unique name and\n   number.  For example, the Attribute
      \"User-Name\" has been allocated\n   number one (1).  This scheme needs to be
      extended in order to be able\n   to refer to attributes of \"Extended Type\",
      and to TLVs.  It will also\n   be used by IANA for allocating RADIUS Attribute
      Type values.\n   The names and identifiers given here are intended to be used
      only in\n   specifications.  The system presented here may not be useful when\n
      \  referring to the contents of a RADIUS packet.  It imposes no\n   requirements
      on implementations, as implementations are free to\n   reference RADIUS attributes
      via any method they choose.\n"
    - contents:
      - "2.7.1.  Attribute and TLV Naming\n   RADIUS specifications traditionally
        use names consisting of one or\n   more words, separated by hyphens, e.g.,
        \"User-Name\".  However, these\n   names are not allocated from a registry,
        and there is no restriction\n   other than convention on their global uniqueness.\n
        \  Similarly, vendors have often used their company name as the prefix\n   for
        VSA names, though this practice is not universal.  For example,\n   for a
        vendor named \"Example\", the name \"Example-Attribute-Name\"\n   SHOULD be
        used instead of \"Attribute-Name\".  The second form can\n   conflict with
        attributes from other vendors, whereas the first form\n   cannot.\n   It is
        therefore RECOMMENDED that specifications give names to\n   Attributes that
        attempt to be globally unique across all RADIUS\n   Attributes.  It is RECOMMENDED
        that a vendor use its name as a unique\n   prefix for attribute names, e.g.,
        Livingston-IP-Pool instead of\n   IP-Pool.  It is RECOMMENDED that implementations
        enforce uniqueness\n   on names; not doing so would lead to ambiguity and
        problems.\n   We recognize that these suggestions may sometimes be difficult
        to\n   implement in practice.\n   TLVs SHOULD be named with a unique prefix
        that is shared among\n   related attributes.  For example, a specification
        that defines a set\n   of TLVs related to time could create attributes called
        \"Time-Zone\",\n   \"Time-Day\", \"Time-Hour\", \"Time-Minute\", etc.\n"
      title: 2.7.1.  Attribute and TLV Naming
    - contents:
      - "2.7.2.  Attribute Type Identifiers\n   The RADIUS Attribute Type space defines
        a context for a particular\n   \"Extended-Type\" field.  The \"Extended-Type\"
        field allows for 256\n   possible type code values, with values 1 through
        240 available for\n   allocation.  We define here an identification method
        that uses a\n   \"dotted number\" notation similar to that used for Object
        Identifiers\n   (OIDs), formatted as \"Type.Extended-Type\".\n   For example,
        an attribute within the Type space of 241, having\n   Extended-Type of one
        (1), is uniquely identified as \"241.1\".\n   Similarly, an attribute within
        the Type space of 246, having\n   Extended-Type of ten (10), is uniquely identified
        as \"246.10\".\n"
      title: 2.7.2.  Attribute Type Identifiers
    - contents:
      - "2.7.3.  TLV Identifiers\n   We can extend the Attribute reference scheme
        defined above for TLVs.\n   This is done by leveraging the \"dotted number\"
        notation.  As above,\n   we define an additional TLV Type space, within the
        \"Extended Type\"\n   space, by appending another \"dotted number\" in order
        to identify the\n   TLV.  This method can be repeated in sequence for nested
        TLVs.\n   For example, let us say that \"245.1\" identifies RADIUS Attribute
        Type\n   245, containing an \"Extended Type\" of one (1), which is of type\n
        \  \"TLV\".  That attribute will contain 256 possible TLVs, one for each\n
        \  value of the TLV-Type field.  The first TLV-Type value of one (1) can\n
        \  then be identified by appending a \".1\" to the number of the\n   encapsulating
        attribute (\"241.1\"), to yield \"241.1.1\".  Similarly,\n   the sequence
        \"245.2.3.4\" identifies RADIUS attribute 245, containing\n   an \"Extended
        Type\" of two (2), which is of type \"TLV\", which in turn\n   contains a
        TLV with TLV-Type number three (3), which in turn contains\n   another TLV,
        with TLV-Type number four (4).\n"
      title: 2.7.3.  TLV Identifiers
    - contents:
      - "2.7.4.  VSA Identifiers\n   There has historically been no method for numerically
        addressing\n   VSAs.  The \"dotted number\" method defined here can also be
        leveraged\n   to create such an addressing scheme.  However, as the VSAs are\n
        \  completely under the control of each individual vendor, this section\n
        \  provides a suggested practice but does not define a standard of any\n   kind.\n
        \  The Vendor-Specific Attribute has been assigned the Attribute\n   number
        26.  It in turn carries a 32-bit Vendor-Id, and possibly\n   additional VSAs.
        \ Where the VSAs follow the format recommended\n   by [RFC2865] Section 5.26,
        a VSA can be identified as\n   \"26.Vendor-Id.Vendor-Type\".\n   For example,
        Livingston has Vendor-Id 307 and has defined an\n   attribute \"IP-Pool\"
        as number 6.  This VSA can be uniquely identified\n   as 26.307.6, but it
        cannot be uniquely identified by name, as other\n   vendors may have used
        the same name.\n   Note that there are few restrictions on the size of the
        numerical\n   values in this notation.  The Vendor-Id is a 32-bit number,
        and the\n   VSA may have been assigned from a 16-bit Vendor-Specific Attribute\n
        \  Type space.  Implementations SHOULD be capable of handling 32-bit\n   numbers
        at each level of the \"dotted number\" notation.\n   For example, the company
        USR has historically used Vendor-Id 429 and\n   has defined a \"Version-Id\"
        attribute as number 32768.  This VSA can\n   be uniquely identified as 26.429.32768
        but again cannot be uniquely\n   identified by name.\n   Where a VSA is a
        TLV, the \"dotted number\" notation can be used as\n   above: 26.Vendor-Id.Vendor-Type.TLV1.TLV2.TLV3,
        where the \"TLVn\"\n   values are the numerical values assigned by the vendor
        to the\n   different nested TLVs.\n"
      title: 2.7.4.  VSA Identifiers
    title: 2.7.  Attribute Naming and Type Identifiers
  - contents:
    - "2.8.  Invalid Attributes\n   The term \"invalid attribute\" is new to this
      specification.  It is\n   defined to mean that the Length field of an Attribute
      permits the\n   packet to be accepted as not being \"malformed\".  However,
      the \"Value\"\n   field of the Attribute does not follow the format required
      by the\n   data type defined for that Attribute, and therefore the Attribute
      is\n   \"malformed\".  In order to distinguish the two cases, we refer to\n
      \  \"malformed\" packets and \"invalid attributes\".\n   For example, an implementation
      receives a packet that is well formed.\n   That packet contains an Attribute
      allegedly of data type \"address\"\n   but that has Length not equal to four.
      \ In that situation, the packet\n   is well formed, but the Attribute is not.
      \ Therefore, it is an\n   \"invalid attribute\".\n   A similar analysis can
      be performed when an attribute carries TLVs.\n   The encapsulating attribute
      may be well formed, but the TLV may be an\n   \"invalid attribute\".  The existence
      of an \"invalid attribute\" in a\n   packet or attribute MUST NOT result in
      the implementation discarding\n   the entire packet or treating the packet as
      a negative\n   acknowledgment.  Instead, only the \"invalid attribute\" is treated\n
      \  specially.\n   When an implementation receives an \"invalid attribute\",
      it SHOULD be\n   silently discarded, except when the implementation is acting
      as a\n   proxy (see Section 5.2 for discussion of proxy servers).  If it is\n
      \  not discarded, it MUST NOT be handled in the same manner as a well-\n   formed
      attribute.  For example, receiving an Attribute of data type\n   \"address\"
      containing either less than four octets or more than\n   four octets of data
      means that the Attribute MUST NOT be treated as\n   being of data type \"address\".
      \ The reason here is that if the\n   Attribute does not carry an IPv4 address,
      the receiver has no idea\n   what format the data is in, and it is therefore
      not an IPv4 address.\n   For Attributes of type \"Long Extended Type\", an Attribute
      is\n   considered to be an \"invalid attribute\" when it does not match the\n
      \  criteria set out in Section 2.2, above.\n   For Attributes of type \"TLV\",
      an Attribute is considered to be an\n   \"invalid attribute\" when the TLV-Length
      field allows the\n   encapsulating Attribute to be parsed but the TLV-Value
      field does not\n   match the criteria for that TLV.  Implementations SHOULD
      NOT treat\n   the \"invalid attribute\" property as being transitive.  That
      is, the\n   Attribute encapsulating the \"invalid attribute\" SHOULD NOT be
      treated\n   as an \"invalid attribute\".  That encapsulating Attribute might\n
      \  contain multiple TLVs, only one of which is an \"invalid attribute\".\n   However,
      a TLV definition may require particular sub-TLVs to be\n   present and/or to
      have specific values.  If a sub-TLV is missing or\n   contains incorrect value(s),
      or if it is an \"invalid attribute\", then\n   the encapsulating TLV SHOULD
      be treated as an \"invalid attribute\".\n   This requirement ensures that strongly
      connected TLVs are either\n   handled as a coherent whole or ignored entirely.\n
      \  It is RECOMMENDED that Attributes with unknown Type, Extended-Type,\n   TLV-Type,
      or EVS-Type are treated as \"invalid attributes\".  This\n   recommendation
      is compatible with the suggestion in [RFC2865]\n   Section 5 that implementations
      \"MAY ignore Attributes with an\n   unknown Type\".\n"
    title: 2.8.  Invalid Attributes
  title: 2.  Extensions to RADIUS
- contents:
  - "3.  Attribute Definitions\n   We define four (4) attributes of \"Extended Type\",
    which are allocated\n   from the \"Reserved\" Attribute Type codes of 241, 242,
    243, and 244.\n   We also define two (2) attributes of \"Long Extended Type\",
    which are\n   allocated from the \"Reserved\" Attribute Type codes of 245 and
    246.\n      Type  Name\n      ----  ----\n      241   Extended-Type-1\n      242
    \  Extended-Type-2\n      243   Extended-Type-3\n      244   Extended-Type-4\n
    \     245   Long-Extended-Type-1\n      246   Long-Extended-Type-2\n   The rest
    of this section gives detailed definitions for each\n   Attribute based on the
    above summary.\n"
  - contents:
    - "3.1.  Extended-Type-1\n   Description\n      This attribute encapsulates attributes
      of the \"Extended Type\"\n      format, in the RADIUS Attribute Type space of
      241.{1-255}.\n   A summary of the Extended-Type-1 Attribute format is shown
      below.\n   The fields are transmitted from left to right.\n    0                   1
      \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |     Type      |    Length     | Extended-Type |  Value ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Type\n      241 for Extended-Type-1.\n   Length\n      >= 4\n   Extended-Type\n
      \     The Extended-Type field is one octet.  Up-to-date values of this\n      field
      are specified in the 241.{1-255} RADIUS Attribute Type\n      space, according
      to the policies and rules described in\n      Section 10.  Further definition
      of this field is given in\n      Section 2.1, above.\n   Value\n      The \"Value\"
      field is one or more octets.\n      Implementations supporting this specification
      MUST use the\n      identifier of \"Type.Extended-Type\" to determine the interpretation\n
      \     of the \"Value\" field.\n"
    title: 3.1.  Extended-Type-1
  - contents:
    - "3.2.  Extended-Type-2\n   Description\n      This attribute encapsulates attributes
      of the \"Extended Type\"\n      format, in the RADIUS Attribute Type space of
      242.{1-255}.\n   A summary of the Extended-Type-2 Attribute format is shown
      below.\n   The fields are transmitted from left to right.\n    0                   1
      \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |     Type      |    Length     | Extended-Type |  Value ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Type\n      242 for Extended-Type-2.\n   Length\n      >= 4\n   Extended-Type\n
      \     The Extended-Type field is one octet.  Up-to-date values of this\n      field
      are specified in the 242.{1-255} RADIUS Attribute Type\n      space, according
      to the policies and rules described in\n      Section 10.  Further definition
      of this field is given in\n      Section 2.1, above.\n   Value\n      The \"Value\"
      field is one or more octets.\n      Implementations supporting this specification
      MUST use the\n      identifier of \"Type.Extended-Type\" to determine the interpretation\n
      \     of the \"Value\" field.\n"
    title: 3.2.  Extended-Type-2
  - contents:
    - "3.3.  Extended-Type-3\n   Description\n      This attribute encapsulates attributes
      of the \"Extended Type\"\n      format, in the RADIUS Attribute Type space of
      243.{1-255}.\n   A summary of the Extended-Type-3 Attribute format is shown
      below.\n   The fields are transmitted from left to right.\n    0                   1
      \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |     Type      |    Length     | Extended-Type |  Value ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Type\n      243 for Extended-Type-3.\n   Length\n      >= 4\n   Extended-Type\n
      \     The Extended-Type field is one octet.  Up-to-date values of this\n      field
      are specified in the 243.{1-255} RADIUS Attribute Type\n      space, according
      to the policies and rules described in\n      Section 10.  Further definition
      of this field is given in\n      Section 2.1, above.\n   Value\n      The \"Value\"
      field is one or more octets.\n      Implementations supporting this specification
      MUST use the\n      identifier of \"Type.Extended-Type\" to determine the interpretation\n
      \     of the \"Value\" field.\n"
    title: 3.3.  Extended-Type-3
  - contents:
    - "3.4.  Extended-Type-4\n   Description\n      This attribute encapsulates attributes
      of the \"Extended Type\"\n      format, in the RADIUS Attribute Type space of
      244.{1-255}.\n   A summary of the Extended-Type-4 Attribute format is shown
      below.\n   The fields are transmitted from left to right.\n    0                   1
      \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |     Type      |    Length     | Extended-Type |  Value ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Type\n      244 for Extended-Type-4.\n   Length\n      >= 4\n   Extended-Type\n
      \     The Extended-Type field is one octet.  Up-to-date values of this\n      field
      are specified in the 244.{1-255} RADIUS Attribute Type\n      space, according
      to the policies and rules described in\n      Section 10.  Further definition
      of this field is given in\n      Section 2.1, above.\n   Value\n      The \"Value\"
      field is one or more octets.\n      Implementations supporting this specification
      MUST use the\n      identifier of \"Type.Extended-Type\" to determine the interpretation\n
      \     of the Value Field.\n"
    title: 3.4.  Extended-Type-4
  - contents:
    - "3.5.  Long-Extended-Type-1\n   Description\n      This attribute encapsulates
      attributes of the \"Long Extended Type\"\n      format, in the RADIUS Attribute
      Type space of 245.{1-255}.\n   A summary of the Long-Extended-Type-1 Attribute
      format is shown\n   below.  The fields are transmitted from left to right.\n
      \   0                   1                   2                   3\n    0 1 2
      3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |     Type      |    Length     | Extended-Type |M|  Reserved   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |     Value ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Type\n      245 for Long-Extended-Type-1\n   Length\n      >= 5\n   Extended-Type\n
      \     The Extended-Type field is one octet.  Up-to-date values of this\n      field
      are specified in the 245.{1-255} RADIUS Attribute Type\n      space, according
      to the policies and rules described in\n      Section 10.  Further definition
      of this field is given in\n      Section 2.1, above.\n   M (More)\n      The
      More field is one (1) bit in length and indicates whether or\n      not the
      current attribute contains \"more\" than 251 octets of data.\n      Further
      definition of this field is given in Section 2.2, above.\n   Reserved\n      This
      field is 7 bits long and is reserved for future use.\n      Implementations
      MUST set it to zero (0) when encoding an attribute\n      for sending in a packet.
      \ The contents SHOULD be ignored on\n      reception.\n   Value\n      The \"Value\"
      field is one or more octets.\n      Implementations supporting this specification
      MUST use the\n      identifier of \"Type.Extended-Type\" to determine the interpretation\n
      \     of the \"Value\" field.\n"
    title: 3.5.  Long-Extended-Type-1
  - contents:
    - "3.6.  Long-Extended-Type-2\n   Description\n      This attribute encapsulates
      attributes of the \"Long Extended Type\"\n      format, in the RADIUS Attribute
      Type space of 246.{1-255}.\n   A summary of the Long-Extended-Type-2 Attribute
      format is shown\n   below.  The fields are transmitted from left to right.\n
      \   0                   1                   2                   3\n    0 1 2
      3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |     Type      |    Length     | Extended-Type |M|  Reserved   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |     Value ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Type\n      246 for Long-Extended-Type-2\n   Length\n      >= 5\n   Extended-Type\n
      \     The Extended-Type field is one octet.  Up-to-date values of this\n      field
      are specified in the 246.{1-255} RADIUS Attribute Type\n      space, according
      to the policies and rules described in\n      Section 10.  Further definition
      of this field is given in\n      Section 2.1, above.\n   M (More)\n      The
      More field is one (1) bit in length and indicates whether or\n      not the
      current attribute contains \"more\" than 251 octets of data.\n      Further
      definition of this field is given in Section 2.2, above.\n   Reserved\n      This
      field is 7 bits long and is reserved for future use.\n      Implementations
      MUST set it to zero (0) when encoding an attribute\n      for sending in a packet.
      \ The contents SHOULD be ignored on\n      reception.\n   Value\n      The \"Value\"
      field is one or more octets.\n      Implementations supporting this specification
      MUST use the\n      identifier of \"Type.Extended-Type\" to determine the interpretation\n
      \     of the \"Value\" field.\n"
    title: 3.6.  Long-Extended-Type-2
  title: 3.  Attribute Definitions
- contents:
  - "4.  Vendor-Specific Attributes\n   We define six new attributes that can carry
    vendor-specific\n   information.  We define four (4) attributes of the \"Extended
    Type\"\n   format, with Type codes (241.26, 242.26, 243.26, 244.26), using the\n
    \  \"evs\" data type.  We also define two (2) attributes using \"Long\n   Extended
    Type\" format, with Type codes (245.26, 246.26), which are of\n   the \"evs\"
    data type.\n      Type.Extended-Type  Name\n      ------------------  ----\n      241.26
    \             Extended-Vendor-Specific-1\n      242.26              Extended-Vendor-Specific-2\n
    \     243.26              Extended-Vendor-Specific-3\n      244.26              Extended-Vendor-Specific-4\n
    \     245.26              Extended-Vendor-Specific-5\n      246.26              Extended-Vendor-Specific-6\n
    \  The rest of this section gives detailed definitions for each\n   Attribute
    based on the above summary.\n"
  - contents:
    - "4.1.  Extended-Vendor-Specific-1\n   Description\n      This attribute defines
      a RADIUS Type Code of 241.26, using the\n      \"evs\" data type.\n   A summary
      of the Extended-Vendor-Specific-1 Attribute format is shown\n   below.  The
      fields are transmitted from left to right.\n    0                   1                   2
      \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |     Type      |    Length     | Extended-Type |  Vendor-Id ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     ... Vendor-Id  (cont)                        |  Vendor-Type  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |  Value ....\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Type.Extended-Type\n      241.26 for Extended-Vendor-Specific-1\n   Length\n
      \     >= 9\n   Vendor-Id\n      The 4 octets of the Vendor-Id field are the
      Network Management\n      Private Enterprise Code [PEN] of the vendor in network
      byte order.\n   Vendor-Type\n      The Vendor-Type field is one octet.  Values
      are assigned at the\n      sole discretion of the vendor.\n   Value\n      The
      \"Value\" field is one or more octets.  The actual format of the\n      information
      is site or application specific, and a robust\n      implementation SHOULD support
      the field as undistinguished octets.\n      The codification of the range of
      allowed usage of this field is\n      outside the scope of this specification.\n
      \     The length of the \"Value\" field is eight (8) less than the value\n      of
      the Length field.\n      Implementations supporting this specification MUST
      use the\n      identifier of \"Type.Extended-Type.Vendor-Id.Vendor-Type\" to\n
      \     determine the interpretation of the \"Value\" field.\n"
    title: 4.1.  Extended-Vendor-Specific-1
  - contents:
    - "4.2.  Extended-Vendor-Specific-2\n   Description\n      This attribute defines
      a RADIUS Type Code of 242.26, using the\n      \"evs\" data type.\n   A summary
      of the Extended-Vendor-Specific-2 Attribute format is shown\n   below.  The
      fields are transmitted from left to right.\n    0                   1                   2
      \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |     Type      |    Length     | Extended-Type |  Vendor-Id ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     ... Vendor-Id  (cont)                        |  Vendor-Type  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |  Value ....\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Type.Extended-Type\n      242.26 for Extended-Vendor-Specific-2\n   Length\n
      \     >= 9\n   Vendor-Id\n      The 4 octets of the Vendor-Id field are the
      Network Management\n      Private Enterprise Code [PEN] of the vendor in network
      byte order.\n   Vendor-Type\n      The Vendor-Type field is one octet.  Values
      are assigned at the\n      sole discretion of the vendor.\n   Value\n      The
      \"Value\" field is one or more octets.  The actual format of the\n      information
      is site or application specific, and a robust\n      implementation SHOULD support
      the field as undistinguished octets.\n      The codification of the range of
      allowed usage of this field is\n      outside the scope of this specification.\n
      \     The length of the \"Value\" field is eight (8) less than the value\n      of
      the Length field.\n      Implementations supporting this specification MUST
      use the\n      identifier of \"Type.Extended-Type.Vendor-Id.Vendor-Type\" to\n
      \     determine the interpretation of the \"Value\" field.\n"
    title: 4.2.  Extended-Vendor-Specific-2
  - contents:
    - "4.3.  Extended-Vendor-Specific-3\n   Description\n      This attribute defines
      a RADIUS Type Code of 243.26, using the\n      \"evs\" data type.\n   A summary
      of the Extended-Vendor-Specific-3 Attribute format is shown\n   below.  The
      fields are transmitted from left to right.\n    0                   1                   2
      \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |     Type      |    Length     | Extended-Type |  Vendor-Id ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     ... Vendor-Id  (cont)                        |  Vendor-Type  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |  Value ....\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Type.Extended-Type\n      243.26 for Extended-Vendor-Specific-3\n   Length\n
      \     >= 9\n   Vendor-Id\n      The 4 octets of the Vendor-Id field are the
      Network Management\n      Private Enterprise Code [PEN] of the vendor in network
      byte order.\n   Vendor-Type\n      The Vendor-Type field is one octet.  Values
      are assigned at the\n      sole discretion of the vendor.\n   Value\n      The
      \"Value\" field is one or more octets.  The actual format of the\n      information
      is site or application specific, and a robust\n      implementation SHOULD support
      the field as undistinguished octets.\n      The codification of the range of
      allowed usage of this field is\n      outside the scope of this specification.\n
      \     The length of the \"Value\" field is eight (8) less than the value\n      of
      the Length field.\n      Implementations supporting this specification MUST
      use the\n      identifier of \"Type.Extended-Type.Vendor-Id.Vendor-Type\" to\n
      \     determine the interpretation of the \"Value\" field.\n"
    title: 4.3.  Extended-Vendor-Specific-3
  - contents:
    - "4.4.  Extended-Vendor-Specific-4\n   Description\n      This attribute defines
      a RADIUS Type Code of 244.26, using the\n      \"evs\" data type.\n   A summary
      of the Extended-Vendor-Specific-4 Attribute format is shown\n   below.  The
      fields are transmitted from left to right.\n    0                   1                   2
      \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |     Type      |    Length     | Extended-Type |  Vendor-Id ...\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \     ... Vendor-Id  (cont)                        |  Vendor-Type  |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |  Value ....\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Type.Extended-Type\n      244.26 for Extended-Vendor-Specific-4\n   Length\n
      \     >= 9\n   Vendor-Id\n      The 4 octets of the Vendor-Id field are the
      Network Management\n      Private Enterprise Code [PEN] of the vendor in network
      byte order.\n   Vendor-Type\n      The Vendor-Type field is one octet.  Values
      are assigned at the\n      sole discretion of the vendor.\n   Value\n      The
      \"Value\" field is one or more octets.  The actual format of the\n      information
      is site or application specific, and a robust\n      implementation SHOULD support
      the field as undistinguished octets.\n      The codification of the range of
      allowed usage of this field is\n      outside the scope of this specification.\n
      \     The length of the \"Value\" field is eight (8) less than the value\n      of
      the Length field.\n      Implementations supporting this specification MUST
      use the\n      identifier of \"Type.Extended-Type.Vendor-Id.Vendor-Type\" to\n
      \     determine the interpretation of the \"Value\" field.\n"
    title: 4.4.  Extended-Vendor-Specific-4
  - contents:
    - "4.5.  Extended-Vendor-Specific-5\n   Description\n      This attribute defines
      a RADIUS Type Code of 245.26, using the\n      \"evs\" data type.\n   A summary
      of the Extended-Vendor-Specific-5 Attribute format is shown\n   below.  The
      fields are transmitted from left to right.\n    0                   1                   2
      \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |     Type      |    Length     | Extended-Type |M|  Reserved   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                            Vendor-Id                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |  Vendor-Type   |  Value ....\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Type.Extended-Type\n      245.26 for Extended-Vendor-Specific-5\n   Length\n
      \     >= 10   (first fragment)\n      >= 5    (subsequent fragments)\n      When
      a VSA is fragmented across multiple Attributes, only the\n      first Attribute
      contains the Vendor-Id and Vendor-Type fields.\n      Subsequent Attributes
      contain fragments of the \"Value\" field only.\n   M (More)\n      The More
      field is one (1) bit in length and indicates whether or\n      not the current
      attribute contains \"more\" than 251 octets of data.\n      Further definition
      of this field is given in Section 2.2, above.\n   Reserved\n      This field
      is 7 bits long and is reserved for future use.\n      Implementations MUST set
      it to zero (0) when encoding an attribute\n      for sending in a packet.  The
      contents SHOULD be ignored on\n      reception.\n   Vendor-Id\n      The 4 octets
      of the Vendor-Id field are the Network Management\n      Private Enterprise
      Code [PEN] of the vendor in network byte order.\n   Vendor-Type\n      The Vendor-Type
      field is one octet.  Values are assigned at the\n      sole discretion of the
      vendor.\n   Value\n      The \"Value\" field is one or more octets.  The actual
      format of the\n      information is site or application specific, and a robust\n
      \     implementation SHOULD support the field as undistinguished octets.\n      The
      codification of the range of allowed usage of this field is\n      outside the
      scope of this specification.\n      Implementations supporting this specification
      MUST use the\n      identifier of \"Type.Extended-Type.Vendor-Id.Vendor-Type\"
      to\n      determine the interpretation of the \"Value\" field.\n"
    title: 4.5.  Extended-Vendor-Specific-5
  - contents:
    - "4.6.  Extended-Vendor-Specific-6\n   Description\n      This attribute defines
      a RADIUS Type Code of 246.26, using the\n      \"evs\" data type.\n   A summary
      of the Extended-Vendor-Specific-6 Attribute format is shown\n   below.  The
      fields are transmitted from left to right.\n    0                   1                   2
      \                  3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4
      5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |     Type      |    Length     | Extended-Type |M|  Reserved   |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |                            Vendor-Id                          |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  |  Vendor-Type   |  Value ....\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
      \  Type.Extended-Type\n      246.26 for Extended-Vendor-Specific-6\n   Length\n
      \     >= 10   (first fragment)\n      >= 5    (subsequent fragments)\n      When
      a VSA is fragmented across multiple Attributes, only the\n      first Attribute
      contains the Vendor-Id and Vendor-Type fields.\n      Subsequent Attributes
      contain fragments of the \"Value\" field only.\n   M (More)\n      The More
      field is one (1) bit in length and indicates whether or\n      not the current
      attribute contains \"more\" than 251 octets of data.\n      Further definition
      of this field is given in Section 2.2, above.\n   Reserved\n      This field
      is 7 bits long and is reserved for future use.\n      Implementations MUST set
      it to zero (0) when encoding an attribute\n      for sending in a packet.  The
      contents SHOULD be ignored on\n      reception.\n   Vendor-Id\n      The 4 octets
      of the Vendor-Id field are the Network Management\n      Private Enterprise
      Code [PEN] of the vendor in network byte order.\n   Vendor-Type\n      The Vendor-Type
      field is one octet.  Values are assigned at the\n      sole discretion of the
      vendor.\n   Value\n      The \"Value\" field is one or more octets.  The actual
      format of the\n      information is site or application specific, and a robust\n
      \     implementation SHOULD support the field as undistinguished octets.\n      The
      codification of the range of allowed usage of this field is\n      outside the
      scope of this specification.\n      Implementations supporting this specification
      MUST use the\n      identifier of \"Type.Extended-Type.Vendor-Id.Vendor-Type\"
      to\n      determine the interpretation of the \"Value\" field.\n"
    title: 4.6.  Extended-Vendor-Specific-6
  title: 4.  Vendor-Specific Attributes
- contents:
  - "5.  Compatibility with Traditional RADIUS\n   There are a number of potential
    compatibility issues with traditional\n   RADIUS, as defined in [RFC6158] and
    earlier.  This section describes\n   them.\n"
  - contents:
    - "5.1.  Attribute Allocation\n   Some vendors have used Attribute Type codes
      from the \"Reserved\" space\n   as part of vendor-defined dictionaries.  This
      practice is considered\n   antisocial behavior, as noted in [RFC6158].  These
      vendor definitions\n   conflict with the Attributes in the RADIUS Attribute
      Type space.  The\n   conflicting definitions may make it difficult for implementations
      to\n   support both those Vendor Attributes, and the new Extended Attribute\n
      \  formats.\n   We RECOMMEND that RADIUS client and server implementations delete
      all\n   references to these improperly defined attributes.  Failing that, we\n
      \  RECOMMEND that RADIUS server implementations have a per-client\n   configurable
      flag that indicates which type of attributes are being\n   sent from the client.
      \ If the flag is set to \"Non-Standard\n   Attributes\", the conflicting attributes
      can be interpreted as being\n   improperly defined Vendor-Specific Attributes.
      \ If the flag is set to\n   \"IETF Attributes\", the Attributes MUST be interpreted
      as being of the\n   Extended Attributes format.  The default SHOULD be to interpret
      the\n   Attributes as being of the Extended Attributes format.\n   Other methods
      of determining how to decode the Attributes into a\n   \"correct\" form are
      NOT RECOMMENDED.  Those methods are likely to be\n   fragile and prone to error.\n
      \  We RECOMMEND that RADIUS server implementations reuse the above flag\n   to
      determine which types of attributes to send in a reply message.\n   If the request
      is expected to contain the improperly defined\n   attributes, the reply SHOULD
      NOT contain Extended Attributes.  If the\n   request is expected to contain
      Extended Attributes, the reply MUST\n   NOT contain the improper Attributes.\n
      \  RADIUS clients will have fewer issues than servers.  Clients MUST NOT\n   send
      improperly defined Attributes in a request.  For replies,\n   clients MUST interpret
      attributes as being of the Extended Attributes\n   format, instead of the improper
      definitions.  These requirements\n   impose no change in the RADIUS specifications,
      as such usage by\n   vendors has always been in conflict with the standard requirements\n
      \  and the standards process.\n   Existing clients that send these improperly
      defined attributes\n   usually have a configuration setting that can disable
      this behavior.\n   We RECOMMEND that vendors ship products with the default
      set to\n   \"disabled\".  We RECOMMEND that administrators set this flag to\n
      \  \"disabled\" on all equipment that they manage.\n"
    title: 5.1.  Attribute Allocation
  - contents:
    - "5.2.  Proxy Servers\n   RADIUS proxy servers will need to forward Attributes
      having the new\n   format, even if they do not implement support for the encoding
      and\n   decoding of those attributes.  We remind implementers of the\n   following
      text in [RFC2865] Section 2.3:\n      The forwarding server MUST NOT change
      the order of any attributes\n      of the same type, including Proxy-State.\n
      \  This requirement solves some of the issues related to proxying of the\n   new
      format, but not all.  The reason is that proxy servers are\n   permitted to
      examine the contents of the packets that they forward.\n   Many proxy implementations
      not only examine the Attributes, but they\n   refuse to forward attributes that
      they do not understand (i.e.,\n   attributes for which they have no local dictionary
      definitions).\n   This practice is NOT RECOMMENDED.  Proxy servers SHOULD forward\n
      \  attributes, even attributes that they do not understand or that are\n   not
      in a local dictionary.  When forwarded, these attributes SHOULD\n   be sent
      verbatim, with no modifications or changes.  This requirement\n   includes \"invalid
      attributes\", as there may be some other system in\n   the network that understands
      them.\n   The only exception to this recommendation is when local site policy\n
      \  dictates that filtering of attributes has to occur.  For example, a\n   filter
      at a visited network may require removal of certain\n   authorization rules
      that apply to the home network but not to the\n   visited network.  This filtering
      can sometimes be done even when the\n   contents of the Attributes are unknown,
      such as when all Vendor-\n   Specific Attributes are designated for removal.\n
      \  As seen during testing performed in 2010 via the EDUcation ROAMing\n   (EDUROAM)
      service (A. DeKok, unpublished data), many proxies do not\n   follow these practices
      for unknown Attributes.  Some proxies filter\n   out unknown attributes or attributes
      that have unexpected lengths\n   (24%, 17/70), some truncate the Attributes
      to the \"expected\" length\n   (11%, 8/70), some discard the request entirely
      (1%, 1/70), and the\n   rest (63%, 44/70) follow the recommended practice of
      passing the\n   Attributes verbatim.  It will be difficult to widely use the
      Extended\n   Attributes format until all non-conformant proxies are fixed.  We\n
      \  therefore RECOMMEND that all proxies that do not support the Extended\n   Attributes
      (241 through 246) define them as being of data type\n   \"string\" and delete
      all other local definitions for those attributes.\n   This last change should
      enable wider usage of the Extended Attributes\n   format.\n"
    title: 5.2.  Proxy Servers
  title: 5.  Compatibility with Traditional RADIUS
- contents:
  - "6.  Guidelines\n   This specification proposes a number of changes to RADIUS
    and\n   therefore requires a set of guidelines, as has been done in\n   [RFC6158].
    \ These guidelines include suggestions related to design,\n   interaction with
    IANA, usage, and implementation of attributes using\n   the new formats.\n"
  - contents:
    - "6.1.  Updates to RFC 6158\n   This specification updates [RFC6158] by adding
      the data types \"evs\",\n   \"tlv\", and \"integer64\"; defining them to be
      \"basic\" data types; and\n   permitting their use subject to the restrictions
      outlined below.\n   The recommendations for the use of the new data types and
      Attribute\n   formats are given below.\n"
    title: 6.1.  Updates to RFC 6158
  - contents:
    - "6.2.  Guidelines for Simple Data Types\n   [RFC6158] Section A.2.1 says in
      part:\n   * Unsigned integers of size other than 32 bits.  SHOULD be replaced\n
      \    by an unsigned integer of 32 bits.  There is insufficient\n     justification
      to define a new size of integer.\n   We update that specification to permit
      unsigned integers of 64 bits,\n   for the reasons defined above in Section 2.5.
      The updated text is as\n   follows:\n   * Unsigned integers of size other than
      32 or 64 bits.  SHOULD be\n     replaced by an unsigned integer of 32 or 64
      bits.  There is\n     insufficient justification to define a new size of integer.\n
      \  That section later continues with the following list item:\n   * Nested attribute-value
      pairs (AVPs).  Attributes should be defined\n     in a flat typespace.\n   We
      update that specification to permit nested TLVs, as defined in\n   this document:\n
      \  * Nested attribute-value pairs (AVPs) using the extended Attribute\n     format
      MAY be used.  All other nested AVP or TLV formats MUST NOT\n     be used.\n
      \  The [RFC6158] recommendations for \"basic\" data types apply to the\n   three
      types listed above.  All other recommendations given in\n   [RFC6158] for \"basic\"
      data types remain unchanged.\n"
    title: 6.2.  Guidelines for Simple Data Types
  - contents:
    - "6.3.  Guidelines for Complex Data Types\n   [RFC6158] Section 2.1 says:\n      Complex
      data types MAY be used in situations where they reduce\n      complexity in
      non-RADIUS systems or where using the basic data\n      types would be awkward
      (such as where grouping would be required\n      in order to link related attributes).\n
      \  Since the extended Attribute format allows for grouping of complex\n   types
      via TLVs, the guidelines for complex data types need to be\n   updated as follows:\n
      \     [RFC6158], Section 3.2.4, describes situations in which complex\n      data
      types might be appropriate.  They SHOULD NOT be used even in\n      those situations,
      without careful consideration of the described\n      limitations.  In all other
      cases not covered by the complex data\n      type exceptions, complex data types
      MUST NOT be used.  Instead,\n      complex data types MUST be decomposed into
      TLVs.\n   The checklist in [RFC6158] Appendix A.2.2 is similarly updated to
      add\n   a new requirement at the top of that section, as follows:\n      Does
      the Attribute\n      * define a complex type that can be represented via TLVs?\n
      \     If so, this data type MUST be represented via TLVs.\n   Note that this
      requirement does not override [RFC6158] Appendix A.1,\n   which permits the
      transport of complex types in certain situations.\n   All other recommendations
      given in [RFC6158] for \"complex\" data types\n   remain unchanged.\n"
    title: 6.3.  Guidelines for Complex Data Types
  - contents:
    - "6.4.  Design Guidelines for the New Types\n   This section gives design guidelines
      for specifications defining\n   attributes using the new format.  The items
      listed below are not\n   exhaustive.  As experience is gained with the new formats,
      later\n   specifications may define additional guidelines.\n   * The data type
      \"evs\" MUST NOT be used for standard RADIUS\n     Attributes, or for TLVs,
      or for VSAs.\n   * The data type TLV SHOULD NOT be used for standard RADIUS\n
      \    attributes.\n   * [RFC2866] \"tagged\" attributes MUST NOT be defined in
      the\n     Extended-Type space.  The \"tlv\" data type should be used instead
      to\n     group attributes.\n   * The \"integer64\" data type MAY be used in
      any RADIUS attribute.  The\n     use of 64-bit integers was not recommended
      in [RFC6158], but their\n     utility is now evident.\n   * Any attribute that
      is allocated from the long extended space of\n     data type \"text\", \"string\",
      or \"tlv\" can potentially carry more\n     than 251 octets of data.  Specifications
      defining such attributes\n     SHOULD define a maximum length to guide implementations.\n
      \  All other recommendations given in [RFC6158] for attribute design\n   guidelines
      apply to attributes using the short extended space and\n   long extended space.\n"
    title: 6.4.  Design Guidelines for the New Types
  - contents:
    - "6.5.  TLV Guidelines\n   The following items give design guidelines for specifications
      using\n   TLVs.\n   * When multiple Attributes are intended to be grouped or
      managed\n     together, the use of TLVs to group related attributes is\n     RECOMMENDED.\n
      \  * More than 4 layers (depth) of TLV nesting is NOT RECOMMENDED.\n   * Interpretation
      of an attribute depends only on its type definition\n     (e.g., Type.Extended-Type.TLV-Type)
      and not on its encoding or\n     location in the RADIUS packet.\n   * Where
      a group of TLVs is strictly defined, and not expected to\n     change, and totals
      less than 247 octets of data, the specifications\n     SHOULD request allocation
      from the short extended space.\n   * Where a group of TLVs is loosely defined
      or is expected to change,\n     the specifications SHOULD request allocation
      from the long extended\n     space.\n   All other recommendations given in [RFC6158]
      for attribute design\n   guidelines apply to attributes using the TLV format.\n"
    title: 6.5.  TLV Guidelines
  - contents:
    - "6.6.  Allocation Request Guidelines\n   The following items give guidelines
      for allocation requests made in a\n   RADIUS specification.\n   * Discretion
      is recommended when requesting allocation of attributes.\n     The new space
      is much larger than the old one, but it is not\n     infinite.\n   * Specifications
      that allocate many attributes MUST NOT request that\n     allocation be made
      from the standard space.  That space is under\n     allocation pressure, and
      the extended space is more suitable for\n     large allocations.  As a guideline,
      we suggest that one\n     specification allocating twenty percent (20%) or more
      of the\n     standard space would meet the above criteria.\n   * Specifications
      that allocate many related attributes SHOULD define\n     one or more TLVs to
      contain related attributes.\n   * Specifications SHOULD request allocation from
      a specific space.\n     The IANA considerations given in Section 10, below,
      give\n     instructions to IANA, but authors should assist IANA where\n     possible.\n
      \  * Specifications of an attribute that encodes 252 octets or less of\n     data
      MAY request allocation from the short extended space.\n   * Specifications of
      an attribute that always encode less than\n     253 octets of data MUST NOT
      request allocation from the long\n     extended space.  The standard space or
      the short extended space\n     MUST be used instead.\n   * Specifications of
      an attribute that encodes 253 octets or more of\n     data MUST request allocation
      from the long extended space.\n   * When the extended space is nearing exhaustion,
      a new specification\n     will have to be written that requests allocation of
      one or more\n     RADIUS attributes from the \"Reserved\" portion of the standard\n
      \    space, values 247-255, using an appropriate format (\"Short Extended\n
      \    Type\", or \"Long Extended Type\").\n   An allocation request made in a
      specification SHOULD use one of the\n   following formats when allocating an
      attribute type code:\n   * TBDn - request allocation of an attribute from the
      standard space.\n     The value \"n\" should be 1 or more, to track individual
      attributes\n     that are to be allocated.\n   * SHORT-TBDn - request allocation
      of an attribute from the short\n     extended space.  The value \"n\" should
      be 1 or more, to track\n     individual attributes that are to be allocated.\n
      \  * LONG-TBDn - request allocation of an attribute from the long\n     extended
      space.  The value \"n\" should be 1 or more, to track\n     individual attributes
      that are to be allocated.\n   These guidelines should help specification authors
      and IANA\n   communicate effectively and clearly.\n"
    title: 6.6.  Allocation Request Guidelines
  - contents:
    - "6.7.  Allocation Request Guidelines for TLVs\n   Specifications may allocate
      a new attribute of type TLV and at the\n   same time allocate sub-Attributes
      within that TLV.  These\n   specifications SHOULD request allocation of specific
      values for the\n   sub-TLV.  The \"dotted number\" notation MUST be used.\n
      \  For example, a specification may request allocation of a TLV as\n   SHORT-TBD1.
      \ Within that attribute, it could request allocation of\n   three sub-TLVs,
      as SHORT-TBD1.1, SHORT-TBD1.2, and SHORT-TBD1.3.\n   Specifications may request
      allocation of additional sub-TLVs within\n   an existing attribute of type TLV.
      \ Those specifications SHOULD use\n   the \"TBDn\" format for every entry in
      the \"dotted number\" notation.\n   For example, a specification may request
      allocation within an\n   existing TLV, with \"dotted number\" notation MM.NN.
      \ Within that\n   attribute, the specification could request allocation of three\n
      \  sub-TLVs, as MM.NN.TBD1, MM.NN.TBD2, and MM.NN.TBD3.\n"
    title: 6.7.  Allocation Request Guidelines for TLVs
  - contents:
    - "6.8.  Implementation Guidelines\n   * RADIUS client implementations SHOULD
      support this specification in\n     order to permit the easy deployment of specifications
      using the\n     changes defined herein.\n   * RADIUS server implementations
      SHOULD support this specification in\n     order to permit the easy deployment
      of specifications using the\n     changes defined herein.\n   * RADIUS proxy
      servers MUST follow the specifications in Section 5.2.\n"
    title: 6.8.  Implementation Guidelines
  - contents:
    - "6.9.  Vendor Guidelines\n   * Vendors SHOULD use the existing Vendor-Specific
      Attribute Type\n     space in preference to the new Extended-Vendor-Specific
      Attributes,\n     as this specification may take time to become widely deployed.\n
      \  * Vendors SHOULD implement this specification.  The changes to RADIUS\n     are
      relatively small and are likely to quickly be used in new\n     specifications.\n"
    title: 6.9.  Vendor Guidelines
  title: 6.  Guidelines
- contents:
  - "7.  Rationale for This Design\n   The path to extending the RADIUS protocol has
    been long and arduous.\n   A number of proposals have been made and discarded
    by the RADEXT\n   working group.  These proposals have been judged to be either
    too\n   bulky, too complex, too simple, or unworkable in practice.  We do not\n
    \  otherwise explain here why earlier proposals did not obtain working\n   group
    consensus.\n   The changes outlined here have the benefit of being simple, as
    the\n   \"Extended Type\" format requires only a one-octet change to the\n   Attribute
    format.  The downside is that the \"Long Extended Type\"\n   format is awkward,
    and the 7 Reserved bits will likely never be used\n   for anything.\n"
  - contents:
    - "7.1.  Attribute Audit\n   An audit of almost five thousand publicly available
      attributes [ATTR]\n   (2010) shows the statistics summarized below.  The Attributes
      include\n   over 100 Vendor dictionaries, along with the IANA-assigned\n   attributes:\n
      \     Count    Data Type\n      -----    ---------\n      2257     integer\n
      \     1762     text\n      273      IPv4 Address\n      225      string\n      96
      \      other data types\n      35       IPv6 Address\n      18       date\n
      \     10       integer64\n      4        Interface Id\n      3        IPv6 Prefix\n
      \     4683     Total\n   The entries in the \"Data Type\" column are data types
      recommended by\n   [RFC6158], along with \"integer64\".  The \"other data types\"
      row\n   encompasses all other data types, including complex data types and\n
      \  data types transporting opaque data.\n   We see that over half of the Attributes
      encode less than 16 octets of\n   data.  It is therefore important to have an
      extension mechanism that\n   adds as little as possible to the size of these
      attributes.  Another\n   result is that the overwhelming majority of attributes
      use simple\n   data types.\n   Of the Attributes defined above, 177 were declared
      as being inside of\n   a TLV.  This is approximately 4% of the total.  We did
      not\n   investigate whether additional attributes were defined in a flat\n   namespace
      but could have been defined as being inside of a TLV.  We\n   expect that the
      number could be as high as 10% of attributes.\n   Manual inspection of the dictionaries
      shows that approximately 20 (or\n   0.5%) attributes have the ability to transport
      more than 253 octets\n   of data.  These attributes are divided between VSAs
      and a small\n   number of standard Attributes such as EAP-Message.\n   The results
      of this audit and analysis are reflected in the design of\n   the extended attributes.
      \ The extended format has minimal overhead,\n   permits TLVs, and has support
      for \"long\" attributes.\n"
    title: 7.1.  Attribute Audit
  title: 7.  Rationale for This Design
- contents:
  - "8.  Diameter Considerations\n   The Attribute formats defined in this specification
    need to be\n   transported in Diameter.  While Diameter supports attributes longer\n
    \  than 253 octets and grouped attributes, we do not use that\n   functionality
    here.  Instead, we define the simplest possible\n   encapsulation method.\n   The
    new formats MUST be treated the same as traditional RADIUS\n   attributes when
    converting from RADIUS to Diameter, or vice versa.\n   That is, the new attribute
    space is not converted to any \"extended\"\n   Diameter attribute space.  Fragmented
    attributes are not converted to\n   a single long Diameter attribute.  The new
    EVS data types are not\n   converted to Diameter attributes with the \"V\" bit
    set.\n   In short, this document mandates no changes for existing RADIUS-to-\n
    \  Diameter or Diameter-to-RADIUS gateways.\n"
  title: 8.  Diameter Considerations
- contents:
  - "9.  Examples\n   A few examples are presented here in order to illustrate the
    encoding\n   of the new Attribute formats.  These examples are not intended to
    be\n   exhaustive, as many others are possible.  For simplicity, we do not\n   show
    complete packets, but only attributes.\n   The examples are given using a domain-specific
    language implemented\n   by the program given in Appendix A of this document.
    \ The language is\n   line oriented and composed of a sequence of lines matching
    the ABNF\n   grammar ([RFC5234]) given below:\n      Identifier = 1*DIGIT *( \".\"
    1*DIGIT )\n      HEXCHAR = HEXDIG HEXDIG\n      STRING = DQUOTE 1*CHAR DQUOTE\n
    \     TLV = \"{\" SP 1*DIGIT SP DATA SP \"}\"\n      DATA = (HEXCHAR *(SP HEXCHAR))
    / (TLV *(SP TLV)) / STRING\n      LINE = Identifier SP DATA\n   The program has
    additional restrictions on its input that are not\n   reflected in the above grammar.
    \ For example, the portions of the\n   identifier that refer to Type and Extended-Type
    are limited to values\n   between 1 and 255.  We trust that the source code in
    Appendix A is\n   clear and that these restrictions do not negatively affect the\n
    \  comprehensibility of the examples.\n   The program reads the input text and
    interprets it as a set of\n   instructions to create RADIUS attributes.  It then
    prints the hex\n   encoding of those attributes.  It implements the minimum set
    of\n   functionality that achieves that goal.  This minimalism means that it\n
    \  does not use attribute dictionaries; it does not implement support\n   for
    RADIUS data types; it can be used to encode attributes with\n   invalid data fields;
    and there is no requirement for consistency from\n   one example to the next.
    \ For example, it can be used to encode a\n   User-Name attribute that contains
    non-UTF8 data or a\n   Framed-IP-Address that contains 253 octets of ASCII data.
    \ As a\n   result, it MUST NOT be used to create RADIUS attributes for transport\n
    \  in a RADIUS message.\n   However, the program correctly encodes the RADIUS
    attribute fields of\n   \"Type\", \"Length\", \"Extended-Type\", \"More\", \"Reserved\",
    \"Vendor-Id\",\n   \"Vendor-Type\", and \"Vendor-Length\".  It encodes RADIUS
    attribute data\n   types \"evs\" and \"tlv\".  It can therefore be used to encode
    example\n   attributes from inputs that are human readable.\n   We do not give
    examples of \"invalid attributes\".  We also note that\n   the examples show format,
    rather than consistent meaning.  A\n   particular Attribute Type code may be used
    to demonstrate two\n   different formats.  In real specifications, attributes
    have a static\n   definitions based on their type code.\n   The examples given
    below are strictly for demonstration purposes only\n   and do not provide a standard
    of any kind.\n"
  - contents:
    - "9.1.  Extended Type\n   The following is a series of examples of the \"Extended
      Type\" format.\n   Attribute encapsulating textual data:\n     241.1 \"bob\"\n
      \      -> f1 06 01 62 6f 62\n   Attribute encapsulating a TLV with TLV-Type
      of one (1):\n     241.2 { 1 23 45 }\n       -> f1 07 02 01 04 23 45\n   Attribute
      encapsulating two TLVs, one after the other:\n     241.2 { 1 23 45 } { 2 67
      89 }\n       -> f1 0b 02 01 04 23 45 02 04 67 89\n   Attribute encapsulating
      two TLVs, where the second TLV is itself\n   encapsulating a TLV:\n     241.2
      { 1 23 45 } { 3 { 1 ab cd } }\n       -> f1 0d 02 01 04 23 45 03 06 01 04 ab
      cd\n   Attribute encapsulating two TLVs, where the second TLV is itself\n   encapsulating
      two TLVs:\n     241.2 { 1 23 45 } { 3 { 1 ab cd } { 2 \"foo\" } }\n       ->
      f1 12 02 01 04 23 45 03 0b 01 04 ab cd 02 05 66 6f 6f\n   Attribute encapsulating
      a TLV, which in turn encapsulates a TLV, to a\n   depth of 5 nestings:\n     241.1
      { 1 { 2 { 3 { 4 { 5 cd ef } } } } }\n       -> f1 0f 01 01 0c 02 0a 03 08 04
      06 05 04 cd ef\n   Attribute encapsulating an Extended-Vendor-Specific Attribute,
      with\n   Vendor-Id of 1 and Vendor-Type of 4, which in turn encapsulates\n   textual
      data:\n     241.26.1.4 \"test\"\n       -> f1 0c 1a 00 00 00 01 04 74 65 73
      74\n   Attribute encapsulating an Extended-Vendor-Specific Attribute, with\n
      \  Vendor-Id of 1 and Vendor-Type of 5, which in turn encapsulates a TLV\n   with
      TLV-Type of 3, which encapsulates textual data:\n     241.26.1.5 { 3 \"test\"
      }\n       -> f1 0e 1a 00 00 00 01 05 03 06 74 65 73 74\n"
    title: 9.1.  Extended Type
  - contents:
    - "9.2.  Long Extended Type\n   The following is a series of examples of the \"Long
      Extended Type\"\n   format.\n   Attribute encapsulating textual data:\n     245.1
      \"bob\"\n       -> f5 07 01 00 62 6f 62\n   Attribute encapsulating a TLV with
      TLV-Type of one (1):\n     245.2 { 1 23 45 }\n       -> f5 08 02 00 01 04 23
      45\n   Attribute encapsulating two TLVs, one after the other:\n     245.2 {
      1 23 45 } { 2 67 89 }\n       -> f5 0c 02 00 01 04 23 45 02 04 67 89\n   Attribute
      encapsulating two TLVs, where the second TLV is itself\n   encapsulating a TLV:\n
      \    245.2 { 1 23 45 } { 3 { 1 ab cd } }\n       -> f5 0e 02 00 01 04 23 45
      03 06 01 04 ab cd\n   Attribute encapsulating two TLVs, where the second TLV
      is itself\n   encapsulating two TLVs:\n     245.2 { 1 23 45 } { 3 { 1 ab cd
      } { 2 \"foo\" } }\n       -> f5 13 02 00 01 04 23 45 03 0b 01 04 ab cd 02 05
      66 6f 6f\n   Attribute encapsulating a TLV, which in turn encapsulates a TLV,
      to a\n   depth of 5 nestings:\n     245.1 { 1 { 2 { 3 { 4 { 5 cd ef } } } }
      }\n       -> f5 10 01 00 01 0c 02 0a 03 08 04 06 05 04 cd ef\n   Attribute encapsulating
      an Extended-Vendor-Specific Attribute, with\n   Vendor-Id of 1 and Vendor-Type
      of 4, which in turn encapsulates\n   textual data:\n     245.26.1.4 \"test\"\n
      \      -> f5 0d 1a 00 00 00 00 01 04 74 65 73 74\n   Attribute encapsulating
      an Extended-Vendor-Specific Attribute, with\n   Vendor-Id of 1 and Vendor-Type
      of 5, which in turn encapsulates a TLV\n   with TLV-Type of 3, which encapsulates
      textual data:\n     245.26.1.5 { 3 \"test\" }\n       -> f5 0f 1a 00 00 00 00
      01 05 03 06 74 65 73 74\n   Attribute encapsulating more than 251 octets of
      data.  The \"Data\"\n   portions are indented for readability:\n     245.4 \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n
      \          aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n           aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n
      \          aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n           aaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n
      \          bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n           bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n
      \          bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n           bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbcccccccccccccccccccc\n
      \          ccccccccccc\"\n       -> f5 ff 04 80 aa aa aa aa aa aa aa aa aa aa
      aa aa aa aa aa aa\n          aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa
      aa aa aa aa\n          aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa
      aa aa\n          aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa\n
      \         aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa\n          aa
      aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa\n          aa aa aa
      aa aa aa aa aa aa ab bb bb bb bb bb bb bb bb bb bb\n          bb bb bb bb bb
      bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb\n          bb bb bb bb bb bb bb
      bb bb bb bb bb bb bb bb bb bb bb bb bb\n          bb bb bb bb bb bb bb bb bb
      bb bb bb bb bb bb bb bb bb bb bb\n          bb bb bb bb bb bb bb bb bb bb bb
      bb bb bb bb bb bb bb bb bb\n          bb bb bb bb bb bb bb bb bb bb bb bb bb
      bb bb bb bb bb bb bb\n          bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb
      f5 13 04 00 cc\n          cc cc cc cc cc cc cc cc cc cc cc cc cc cc\n   Below
      is an example of an attribute encapsulating an Extended-Vendor-\n   Specific
      Attribute, with Vendor-Id of 1 and Vendor-Type of 6, which\n   in turn encapsulates
      more than 251 octets of data.\n   As the VSA encapsulates more than 251 octets
      of data, it is split\n   into two RADIUS attributes.  The first attribute has
      the More field\n   set, and it carries the Vendor-Id and Vendor-Type.  The second\n
      \  attribute has the More field clear and carries the rest of the data\n   portion
      of the VSA.  Note that the second attribute does not include\n   the Vendor-Id
      ad Vendor-Type fields.\n   The \"Data\" portions are indented for readability:\n
      \    245.26.1.6  \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n           aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n
      \          aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n           aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n
      \          aaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n           bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n
      \          bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n           bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n
      \          bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbccccccccccccc\n           ccccccccccccccccc\"\n
      \      -> f5 ff 1a 80 00 00 00 01 06 aa aa aa aa aa aa aa aa aa aa aa\n          aa
      aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa\n          aa aa aa
      aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa\n          aa aa aa aa aa
      aa aa aa aa aa aa aa aa aa aa aa aa aa aa aa\n          aa aa aa aa aa aa aa
      aa aa aa aa aa aa aa aa aa aa aa aa aa\n          aa aa aa aa aa aa aa aa aa
      aa aa aa aa aa aa aa aa aa aa aa\n          aa aa aa aa aa aa aa aa aa aa aa
      aa aa aa ab bb bb bb bb bb\n          bb bb bb bb bb bb bb bb bb bb bb bb bb
      bb bb bb bb bb bb bb\n          bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb
      bb bb bb bb bb\n          bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb
      bb bb bb\n          bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb
      bb\n          bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb\n
      \         bb bb bb bb bb bb bb bb bb bb bb bb bb bb bb f5 18 1a 00 bb\n          bb
      bb bb bb cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc\n"
    title: 9.2.  Long Extended Type
  title: 9.  Examples
- contents:
  - "10.  IANA Considerations\n   This document updates [RFC3575] in that it adds
    new IANA\n   considerations for RADIUS attributes.  These considerations modify\n
    \  and extend the IANA considerations for RADIUS, rather than replacing\n   them.\n
    \  The IANA considerations of this document are limited to the \"RADIUS\n   Attribute
    Types\" registry.  Some Attribute Type values that were\n   previously marked
    \"Reserved\" are now allocated, and the registry is\n   extended from a simple
    8-bit array to a tree-like structure, up to a\n   maximum depth of 125 nodes.
    \ Detailed instructions are given below.\n"
  - contents:
    - "10.1.  Attribute Allocations\n   IANA has moved the following Attribute Type
      values from \"Reserved\" to\n   \"Allocated\" with the corresponding names:\n
      \     * 241 Extended-Type-1\n      * 242 Extended-Type-2\n      * 243 Extended-Type-3\n
      \     * 244 Extended-Type-4\n      * 245 Long-Extended-Type-1\n      * 246 Long-Extended-Type-2\n
      \  These values serve as an encapsulation layer for the new RADIUS\n   Attribute
      Type tree.\n"
    title: 10.1.  Attribute Allocations
  - contents:
    - "10.2.  RADIUS Attribute Type Tree\n   Each of the Attribute Type values allocated
      above extends the \"RADIUS\n   Attribute Types\" to an N-ary tree, via a \"dotted
      number\" notation.\n   Allocation of an Attribute Type value \"TYPE\" using
      the new \"Extended\n   Type\" format results in allocation of 255 new Attribute
      Type values\n   of format \"TYPE.1\" through \"TYPE.255\".  Value twenty-six
      (26) is\n   assigned as \"Extended-Vendor-Specific-*\".  Values \"TYPE.241\"
      through\n   \"TYPE.255\" are marked \"Reserved\".  All other values are \"Unassigned\".\n
      \  The initial set of Attribute Type values and names assigned by this\n   document
      is given below.\n      * 241           Extended-Attribute-1\n      * 241.{1-25}
      \   Unassigned\n      * 241.26        Extended-Vendor-Specific-1\n      * 241.{27-240}
      \ Unassigned\n      * 241.{241-255} Reserved\n      * 242           Extended-Attribute-2\n
      \     * 242.{1-25}    Unassigned\n      * 242.26        Extended-Vendor-Specific-2\n
      \     * 242.{27-240}  Unassigned\n      * 242.{241-255} Reserved\n      * 243
      \          Extended-Attribute-3\n      * 243.{1-25}    Unassigned\n      * 243.26
      \       Extended-Vendor-Specific-3\n      * 243.{27-240}  Unassigned\n      *
      243.{241-255} Reserved\n      * 244           Extended-Attribute-4\n      *
      244.{1-25}    Unassigned\n      * 244.26        Extended-Vendor-Specific-4\n
      \     * 244.{27-240}  Unassigned\n      * 244.{241-255} Reserved\n      * 245
      \          Extended-Attribute-5\n      * 245.{1-25}    Unassigned\n      * 245.26
      \       Extended-Vendor-Specific-5\n      * 245.{27-240}  Unassigned\n      *
      245.{241-255} Reserved\n      * 246           Extended-Attribute-6\n      *
      246.{1-25}    Unassigned\n      * 246.26        Extended-Vendor-Specific-6\n
      \     * 246.{27-240}  Unassigned\n      * 246.{241-255} Reserved\n   As per
      [RFC5226], the values marked \"Unassigned\" above are available\n   for assignment
      by IANA in future RADIUS specifications.  The values\n   marked \"Reserved\"
      are reserved for future use.\n   The Extended-Vendor-Specific spaces (TYPE.26)
      are for Private Use,\n   and allocations are not managed by IANA.\n   Allocation
      of Reserved entries in the extended space requires\n   Standards Action.\n   All
      other allocations in the extended space require IETF Review.\n"
    title: 10.2.  RADIUS Attribute Type Tree
  - contents:
    - "10.3.  Allocation Instructions\n   This section defines what actions IANA needs
      to take when allocating\n   new attributes.  Different actions are required
      when allocating\n   attributes from the standard space, attributes of the \"Extended
      Type\"\n   format, attributes of the \"Long Extended Type\" format, preferential\n
      \  allocations, attributes of data type TLV, attributes within a TLV,\n   and
      attributes of other data types.\n"
    - contents:
      - "10.3.1.  Requested Allocation from the Standard Space\n   Specifications
        can request allocation of an Attribute from within the\n   standard space
        (e.g., Attribute Type Codes 1 through 255), subject to\n   the considerations
        of [RFC3575] and this document.\n"
      title: 10.3.1.  Requested Allocation from the Standard Space
    - contents:
      - "10.3.2.  Requested Allocation from the Short Extended Space\n   Specifications
        can request allocation of an Attribute that requires\n   the format \"Extended
        Type\", by specifying the short extended space.\n   In that case, IANA should
        assign the lowest Unassigned number from\n   the Attribute Type space with
        the relevant format.\n"
      title: 10.3.2.  Requested Allocation from the Short Extended Space
    - contents:
      - "10.3.3.  Requested Allocation from the Long Extended Space\n   Specifications
        can request allocation of an Attribute that requires\n   the format \"Long
        Extended Type\", by specifying the extended space\n   (long).  In that case,
        IANA should assign the lowest Unassigned\n   number from the Attribute Type
        space with the relevant format.\n"
      title: 10.3.3.  Requested Allocation from the Long Extended Space
    - contents:
      - "10.3.4.  Allocation Preferences\n   Specifications that make no request for
        allocation from a specific\n   type space should have Attributes allocated
        using the following\n   criteria:\n   * When the standard space has no more
        Unassigned attributes, all\n     allocations should be performed from the
        extended space.\n   * Specifications that allocate a small number of attributes
        (i.e.,\n     less than ten) should have all allocations made from the standard\n
        \    space.\n   * Specifications that would allocate more than twenty percent
        of the\n     remaining standard space attributes should have all allocations\n
        \    made from the extended space.\n   * Specifications that request allocation
        of an attribute of data type\n     TLV should have that attribute allocated
        from the extended space.\n   * Specifications that request allocation of an
        attribute that can\n     transport 253 or more octets of data should have
        that attribute\n     allocated from within the long extended space.  We note
        that\n     Section 6.5 above makes recommendations related to this allocation.\n
        \  There is otherwise no requirement that all attributes within a\n   specification
        be allocated from one type space or another.\n   Specifications can simultaneously
        allocate attributes from both the\n   standard space and the extended space.\n"
      title: 10.3.4.  Allocation Preferences
    - contents:
      - "10.3.5.  Extending the Type Space via the TLV Data Type\n   When specifications
        request allocation of an attribute of data type\n   TLV, that allocation extends
        the Attribute Type tree by one more\n   level.  Allocation of an Attribute
        Type value \"TYPE.TLV\", with data\n   type TLV, results in allocation of
        255 new Attribute Type values, of\n   format \"TYPE.TLV.1\" through \"TYPE.TLV.255\".
        \ Values 254-255 are\n   marked \"Reserved\".  All other values are \"Unassigned\".
        \ Value 26 has\n   no special meaning.\n   For example, if a new attribute
        \"Example-TLV\" of data type TLV is\n   assigned the identifier \"245.1\",
        then the extended tree will be\n   allocated as below:\n      * 245.1           Example-TLV\n
        \     * 245.1.{1-253}   Unassigned\n      * 245.1.{254-255} Reserved\n   Note
        that this example does not define an \"Example-TLV\" attribute.\n   The Attribute
        Type tree can be extended multiple levels in one\n   specification when the
        specification requests allocation of nested\n   TLVs, as discussed below.\n"
      title: 10.3.5.  Extending the Type Space via the TLV Data Type
    - contents:
      - "10.3.6.  Allocation within a TLV\n   Specifications can request allocation
        of Attribute Type values within\n   an Attribute of data type TLV.  The encapsulating
        TLV can be\n   allocated in the same specification, or it can have been previously\n
        \  allocated.\n   Specifications need to request allocation within a specific
        Attribute\n   Type value (e.g., \"TYPE.TLV.*\").  Allocations are performed
        from the\n   smallest Unassigned value, proceeding to the largest Unassigned\n
        \  value.\n   Where the Attribute being allocated is of data type TLV, the\n
        \  Attribute Type tree is extended by one level, as given in the\n   previous
        section.  Allocations can then be made within that level.\n"
      title: 10.3.6.  Allocation within a TLV
    - contents:
      - "10.3.7.  Allocation of Other Data Types\n   Attribute Type value allocations
        are otherwise allocated from the\n   smallest Unassigned value, proceeding
        to the largest Unassigned\n   value, e.g., starting from 241.1, proceeding
        through 241.255, then to\n   242.1, through 242.255, etc.\n"
      title: 10.3.7.  Allocation of Other Data Types
    title: 10.3.  Allocation Instructions
  title: 10.  IANA Considerations
- contents:
  - "11.  Security Considerations\n   This document defines new formats for data carried
    inside of RADIUS\n   but otherwise makes no changes to the security of the RADIUS\n
    \  protocol.\n   Attacks on cryptographic hashes are well known and are getting
    better\n   with time, as discussed in [RFC4270].  The security of the RADIUS\n
    \  protocol is dependent on MD5 [RFC1321], which has security issues as\n   discussed
    in [RFC6151].  It is not known if the issues described in\n   [RFC6151] apply
    to RADIUS.  For other issues, we incorporate by\n   reference the security considerations
    of [RFC6158] Section 5.\n   As with any protocol change, code changes are required
    in order to\n   implement the new features.  These code changes have the potential
    to\n   introduce new vulnerabilities in the software.  Since the RADIUS\n   server
    performs network authentication, it is an inviting target for\n   attackers.  We
    RECOMMEND that access to RADIUS servers be kept to a\n   minimum.\n"
  title: 11.  Security Considerations
- contents:
  - '12.  References

    '
  - contents:
    - "12.1.  Normative References\n   [RFC2119]  Bradner, S., \"Key words for use
      in RFCs to Indicate\n              Requirement Levels\", BCP 14, RFC 2119, March
      1997.\n   [RFC2865]  Rigney, C., Willens, S., Rubens, A., and W. Simpson,\n
      \             \"Remote Authentication Dial In User Service (RADIUS)\",\n              RFC
      2865, June 2000.\n   [RFC2866]  Rigney, C., \"RADIUS Accounting\", RFC 2866,
      June 2000.\n   [RFC3575]  Aboba, B., \"IANA Considerations for RADIUS (Remote\n
      \             Authentication Dial In User Service)\", RFC 3575,\n              July
      2003.\n   [RFC5226]  Narten, T. and H. Alvestrand, \"Guidelines for Writing
      an\n              IANA Considerations Section in RFCs\", BCP 26, RFC 5226,\n
      \             May 2008.\n   [RFC6158]  DeKok, A., Ed., and G. Weber, \"RADIUS
      Design Guidelines\",\n              BCP 158, RFC 6158, March 2011.\n   [PEN]
      \     IANA, \"PRIVATE ENTERPRISE NUMBERS\",\n              <http://www.iana.org/assignments/enterprise-numbers>.\n"
    title: 12.1.  Normative References
  - contents:
    - "12.2.  Informative References\n   [RFC1321]  Rivest, R., \"The MD5 Message-Digest
      Algorithm\", RFC 1321,\n              April 1992.\n   [RFC2868]  Zorn, G., Leifer,
      D., Rubens, A., Shriver, J., Holdrege,\n              M., and I. Goyret, \"RADIUS
      Attributes for Tunnel Protocol\n              Support\", RFC 2868, June 2000.\n
      \  [RFC4270]  Hoffman, P. and B. Schneier, \"Attacks on Cryptographic\n              Hashes
      in Internet Protocols\", RFC 4270, November 2005.\n   [RFC5234]  Crocker, D.,
      Ed., and P. Overell, \"Augmented BNF for\n              Syntax Specifications:
      ABNF\", STD 68, RFC 5234,\n              January 2008.\n   [RFC6151]  Turner,
      S. and L. Chen, \"Updated Security Considerations\n              for the MD5
      Message-Digest and the HMAC-MD5 Algorithms\",\n              RFC 6151, March
      2011.\n   [ATTR]     \"alandekok/freeradius-server\", available from GitHub,
      data\n              retrieved September 2010, <http://github.com/alandekok/\n
      \             freeradius-server/tree/master/share/>.\n"
    title: 12.2.  Informative References
  title: 12.  References
- contents:
  - "13.  Acknowledgments\n   This document is the result of long discussions in the
    IETF RADEXT\n   working group.  The authors would like to thank all of the\n   participants
    who contributed various ideas over the years.  Their\n   feedback has been invaluable
    and has helped to make this\n   specification better.\n"
  title: 13.  Acknowledgments
- contents:
  - "Appendix A.  Extended Attribute Generator Program\n   This section contains \"C\"
    program source code that can be used for\n   testing.  It reads a line-oriented
    text file, parses it to create\n   RADIUS formatted attributes, and prints the
    hex version of those\n   attributes to standard output.\n   The input accepts
    grammar similar to that given in Section 9, with\n   some modifications for usability.
    \ For example, blank lines are\n   allowed, lines beginning with a '#' character
    are interpreted as\n   comments, numbers (RADIUS Types, etc.) are checked for
    minimum/\n   maximum values, and RADIUS attribute lengths are enforced.\n   The
    program is included here for demonstration purposes only, and\n   does not define
    a standard of any kind.\n   ------------------------------------------------------------\n
    \  /*\n    * Copyright (c) 2013 IETF Trust and the persons identified as\n    *
    authors of the code.  All rights reserved.\n    *\n    * Redistribution and use
    in source and binary forms, with or without\n    * modification, are permitted
    provided that the following conditions\n    * are met:\n    *\n    * - Redistributions
    of source code must retain the above copyright\n    *   notice, this list of conditions
    and the following disclaimer.\n    *\n    * - Redistributions in binary form must
    reproduce the above\n    *   copyright notice, this list of conditions and the
    following\n    *   disclaimer in the documentation and/or other materials provided\n
    \   *   with the distribution.\n    *\n    * - Neither the name of Internet Society,
    IETF or IETF Trust, nor\n    *   the names of specific contributors, may be used
    to endorse or\n    *   promote products derived from this software without specific\n
    \   *   prior written permission.\n    *\n    * THIS SOFTWARE IS PROVIDED BY THE
    COPYRIGHT HOLDERS AND\n    * CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR IMPLIED
    WARRANTIES,\n    * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\n
    \   * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n    * DISCLAIMED.
    \ IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS\n    * BE LIABLE FOR ANY
    DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n    * EXEMPLARY, OR CONSEQUENTIAL DAMAGES
    (INCLUDING, BUT NOT LIMITED\n    * TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
    LOSS OF USE,\n    * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
    AND ON\n    * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n
    \   * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\n    *
    OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n    * SUCH
    DAMAGE.\n    *\n    *  Author:  Alan DeKok <aland@networkradius.com>\n    */\n
    \  #include <stdlib.h>\n   #include <stdio.h>\n   #include <stdint.h>\n   #include
    <string.h>\n   #include <errno.h>\n   #include <ctype.h>\n   static int encode_tlv(char
    *buffer, uint8_t *output, size_t outlen);\n   static const char *hextab = \"0123456789abcdef\";\n
    \  static int encode_data_string(char *buffer,\n                        uint8_t
    *output, size_t outlen)\n   {\n        int length = 0;\n        char *p;\n        p
    = buffer + 1;\n        while (*p && (outlen > 0)) {\n             if (*p == '\"')
    {\n                  return length;\n             }\n             if (*p != '\\\\')
    {\n                  *(output++) = *(p++);\n                  outlen--;\n                  length++;\n
    \                 continue;\n             }\n             switch (p[1]) {\n             default:\n
    \                 *(output++) = p[1];\n                  break;\n             case
    'n':\n                  *(output++) = '\\n';\n                  break;\n             case
    'r':\n                  *(output++) = '\\r';\n                  break;\n             case
    't':\n                  *(output++) = '\\t';\n                  break;\n             }\n
    \            outlen--;\n             length++;\n        }\n        fprintf(stderr,
    \"String is not terminated\\n\");\n        return 0;\n   }\n   static int encode_data_tlv(char
    *buffer, char **endptr,\n                     uint8_t *output, size_t outlen)\n
    \  {\n        int depth = 0;\n        int length;\n        char *p;\n        for
    (p = buffer; *p != '\\0'; p++) {\n             if (*p == '{') depth++;\n             if
    (*p == '}') {\n                  depth--;\n                  if (depth == 0) break;\n
    \            }\n        }\n        if (*p != '}') {\n             fprintf(stderr,
    \"No trailing '}' in string starting \"\n                  \"with \\\"%s\\\"\\n\",\n
    \                 buffer);\n             return 0;\n        }\n        *endptr
    = p + 1;\n        *p = '\\0';\n        p = buffer + 1;\n        while (isspace((int)
    *p)) p++;\n        length = encode_tlv(p, output, outlen);\n        if (length
    == 0) return 0;\n        return length;\n   }\n   static int encode_data(char
    *p, uint8_t *output, size_t outlen)\n   {\n        int length;\n        if (!isspace((int)
    *p)) {\n             fprintf(stderr, \"Invalid character following attribute \"\n
    \                 \"definition\\n\");\n             return 0;\n        }\n        while
    (isspace((int) *p)) p++;\n        if (*p == '{') {\n             int sublen;\n
    \            char *q;\n             length = 0;\n             do {\n                  while
    (isspace((int) *p)) p++;\n                  if (!*p) {\n                       if
    (length == 0) {\n                            fprintf(stderr, \"No data\\n\");\n
    \                           return 0;\n                       }\n                       break;\n
    \                 }\n                  sublen = encode_data_tlv(p, &q, output,
    outlen);\n                  if (sublen == 0) return 0;\n                  length
    += sublen;\n                  output += sublen;\n                  outlen -= sublen;\n
    \                 p = q;\n             } while (*q);\n             return length;\n
    \       }\n        if (*p == '\"') {\n             length = encode_data_string(p,
    output, outlen);\n             return length;\n        }\n        length = 0;\n
    \       while (*p) {\n             char *c1, *c2;\n             while (isspace((int)
    *p)) p++;\n             if (!*p) break;\n             if(!(c1 = memchr(hextab,
    tolower((int) p[0]), 16)) ||\n                !(c2 = memchr(hextab, tolower((int)
    \ p[1]), 16))) {\n                  fprintf(stderr, \"Invalid data starting at
    \"\n                       \"\\\"%s\\\"\\n\", p);\n                  return 0;\n
    \            }\n             *output = ((c1 - hextab) << 4) + (c2 - hextab);\n
    \            output++;\n             length++;\n             p += 2;\n             outlen--;\n
    \            if (outlen == 0) {\n                  fprintf(stderr, \"Too much
    data\\n\");\n                  return 0;\n             }\n        }\n        if
    (length == 0) {\n             fprintf(stderr, \"Empty string\\n\");\n             return
    0;\n        }\n        return length;\n   }\n   static int decode_attr(char *buffer,
    char **endptr)\n   {\n        long attr;\n        attr = strtol(buffer, endptr,
    10);\n        if (*endptr == buffer) {\n             fprintf(stderr, \"No valid
    number found in string \"\n                  \"starting with \\\"%s\\\"\\n\",
    buffer);\n             return 0;\n        }\n        if (!**endptr) {\n             fprintf(stderr,
    \"Nothing follows attribute number\\n\");\n             return 0;\n        }\n
    \       if ((attr <= 0) || (attr > 256)) {\n             fprintf(stderr, \"Attribute
    number is out of valid \"\n                  \"range\\n\");\n             return
    0;\n        }\n        return (int) attr;\n   }\n   static int decode_vendor(char
    *buffer, char **endptr)\n   {\n        long vendor;\n        if (*buffer != '.')
    {\n             fprintf(stderr, \"Invalid separator before vendor id\\n\");\n
    \            return 0;\n        }\n        vendor = strtol(buffer + 1, endptr,
    10);\n        if (*endptr == (buffer + 1)) {\n             fprintf(stderr, \"No
    valid vendor number found\\n\");\n             return 0;\n        }\n        if
    (!**endptr) {\n             fprintf(stderr, \"Nothing follows vendor number\\n\");\n
    \            return 0;\n        }\n        if ((vendor <= 0) || (vendor > (1 <<
    24))) {\n             fprintf(stderr, \"Vendor number is out of valid range\\n\");\n
    \            return 0;\n        }\n        if (**endptr != '.') {\n             fprintf(stderr,
    \"Invalid data following vendor number\\n\");\n             return 0;\n        }\n
    \       (*endptr)++;\n        return (int) vendor;\n   }\n   static int encode_tlv(char
    *buffer, uint8_t *output, size_t outlen)\n   {\n        int attr;\n        int
    length;\n        char *p;\n        attr = decode_attr(buffer, &p);\n        if
    (attr == 0) return 0;\n        output[0] = attr;\n        output[1] = 2;\n        if
    (*p == '.') {\n             p++;\n             length = encode_tlv(p, output +
    2, outlen - 2);\n        } else {\n             length = encode_data(p, output
    + 2, outlen - 2);\n        }\n        if (length == 0) return 0;\n        if (length
    > (255 - 2)) {\n             fprintf(stderr, \"TLV data is too long\\n\");\n             return
    0;\n        }\n        output[1] += length;\n        return length + 2;\n   }\n
    \  static int encode_vsa(char *buffer, uint8_t *output, size_t outlen)\n   {\n
    \       int vendor;\n        int attr;\n        int length;\n        char *p;\n
    \       vendor = decode_vendor(buffer, &p);\n        if (vendor == 0) return 0;\n
    \       output[0] = 0;\n        output[1] = (vendor >> 16) & 0xff;\n        output[2]
    = (vendor >> 8) & 0xff;\n        output[3] = vendor & 0xff;\n        length =
    encode_tlv(p, output + 4, outlen - 4);\n        if (length == 0) return 0;\n        if
    (length > (255 - 6)) {\n             fprintf(stderr, \"VSA data is too long\\n\");\n
    \            return 0;\n        }\n        return length + 4;\n   }\n   static
    int encode_evs(char *buffer, uint8_t *output, size_t outlen)\n   {\n        int
    vendor;\n        int attr;\n        int length;\n        char *p;\n        vendor
    = decode_vendor(buffer, &p);\n        if (vendor == 0) return 0;\n        attr
    = decode_attr(p, &p);\n        if (attr == 0) return 0;\n        output[0] = 0;\n
    \       output[1] = (vendor >> 16) & 0xff;\n        output[2] = (vendor >> 8)
    & 0xff;\n        output[3] = vendor & 0xff;\n        output[4] = attr;\n        length
    = encode_data(p, output + 5, outlen - 5);\n        if (length == 0) return 0;\n
    \       return length + 5;\n   }\n   static int encode_extended(char *buffer,\n
    \                    uint8_t *output, size_t outlen)\n   {\n        int attr;\n
    \       int length;\n        char *p;\n        attr = decode_attr(buffer, &p);\n
    \       if (attr == 0) return 0;\n        output[0] = attr;\n        if (attr
    == 26) {\n             length = encode_evs(p, output + 1, outlen - 1);\n        }
    else {\n             length = encode_data(p, output + 1, outlen - 1);\n        }\n
    \       if (length == 0) return 0;\n        if (length > (255 - 3)) {\n             fprintf(stderr,
    \"Extended Attr data is too long\\n\");\n             return 0;\n        }\n        return
    length + 1;\n   }\n   static int encode_extended_flags(char *buffer,\n                        uint8_t
    *output, size_t outlen)\n   {\n        int attr;\n        int length, total;\n
    \       char *p;\n        attr = decode_attr(buffer, &p);\n        if (attr ==
    0) return 0;\n        /* output[0] is the extended attribute */\n        output[1]
    = 4;\n        output[2] = attr;\n        output[3] = 0;\n        if (attr == 26)
    {\n             length = encode_evs(p, output + 4, outlen - 4);\n             if
    (length == 0) return 0;\n             output[1] += 5;\n             length -=
    5;\n        } else {\n             length = encode_data(p, output + 4, outlen
    - 4);\n        }\n        if (length == 0) return 0;\n        total = 0;\n        while
    (1) {\n             int sublen = 255 - output[1];\n             if (length <=
    sublen) {\n                  output[1] += length;\n                  total +=
    output[1];\n                  break;\n             }\n             length -= sublen;\n
    \            memmove(output + 255 + 4, output + 255, length);\n             memcpy(output
    + 255, output, 4);\n             output[1] = 255;\n             output[3] |= 0x80;\n
    \            output += 255;\n             output[1] = 4;\n             total +=
    255;\n        }\n        return total;\n   }\n   static int encode_rfc(char *buffer,
    uint8_t *output, size_t outlen)\n   {\n        int attr;\n        int length,
    sublen;\n        char *p;\n        attr = decode_attr(buffer, &p);\n        if
    (attr == 0) return 0;\n        length = 2;\n        output[0] = attr;\n        output[1]
    = 2;\n        if (attr == 26) {\n             sublen = encode_vsa(p, output +
    2, outlen - 2);\n        } else if ((*p == ' ') || ((attr < 241) || (attr > 246)))
    {\n             sublen = encode_data(p, output + 2, outlen - 2);\n        } else
    {\n             if (*p != '.') {\n                  fprintf(stderr, \"Invalid
    data following \"\n                       \"attribute number\\n\");\n                  return
    0;\n             }\n             if (attr < 245) {\n                  sublen =
    encode_extended(p + 1,\n                                  output + 2, outlen -
    2);\n             } else {\n                  /*\n                   *   Not like
    the others!\n                   */\n                  return encode_extended_flags(p
    + 1, output, outlen);\n             }\n        }\n        if (sublen == 0) return
    0;\n        if (sublen > (255 -2)) {\n             fprintf(stderr, \"RFC Data
    is too long\\n\");\n             return 0;\n        }\n        output[1] += sublen;\n
    \       return length + sublen;\n   }\n   int main(int argc, char *argv[])\n   {\n
    \       int lineno;\n        size_t i, outlen;\n        FILE *fp;\n        char
    input[8192], buffer[8192];\n        uint8_t output[4096];\n        if ((argc <
    2) || (strcmp(argv[1], \"-\") == 0)) {\n             fp = stdin;\n        } else
    {\n             fp = fopen(argv[1], \"r\");\n             if (!fp) {\n                  fprintf(stderr,
    \"Error opening %s: %s\\n\",\n                       argv[1], strerror(errno));\n
    \                 exit(1);\n             }\n        }\n        lineno = 0;\n        while
    (fgets(buffer, sizeof(buffer), fp) != NULL) {\n             char *p = strchr(buffer,
    '\\n');\n             lineno++;\n             if (!p) {\n                  if
    (!feof(fp)) {\n                       fprintf(stderr, \"Line %d too long in %s\\n\",\n
    \                           lineno, argv[1]);\n                       exit(1);\n
    \                 }\n             } else {\n                  *p = '\\0';\n             }\n
    \            p = strchr(buffer, '#');\n             if (p) *p = '\\0';\n             p
    = buffer;\n             while (isspace((int) *p)) p++;\n             if (!*p)
    continue;\n             strcpy(input, p);\n             outlen = encode_rfc(input,
    output, sizeof(output));\n             if (outlen == 0) {\n                  fprintf(stderr,
    \"Parse error in line %d of %s\\n\",\n                       lineno, input);\n
    \                 exit(1);\n             }\n             printf(\"%s -> \", buffer);\n
    \            for (i = 0; i < outlen; i++) {\n                  printf(\"%02x \",
    output[i]);\n             }\n             printf(\"\\n\");\n        }\n        if
    (fp != stdin) fclose(fp);\n        return 0;\n   }\n   ------------------------------------------------------------\n"
  title: Appendix A.  Extended Attribute Generator Program
- contents:
  - "Authors' Addresses\n   Alan DeKok\n   Network RADIUS SARL\n   57bis blvd des
    Alpes\n   38240 Meylan\n   France\n   EMail: aland@networkradius.com\n   URI:
    http://networkradius.com\n   Avi Lior\n   EMail: avi.ietf@lior.org\n"
  title: Authors' Addresses
