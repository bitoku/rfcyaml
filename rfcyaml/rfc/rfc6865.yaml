- contents:
  - ' Simple Reed-Solomon Forward Error Correction (FEC) Scheme for FECFRAME

    '
  title: __initial_text__
- contents:
  - "Abstract\n   This document describes a fully-specified simple Forward Error\n
    \  Correction (FEC) scheme for Reed-Solomon codes over the finite field\n   (also
    known as the Galois Field) GF(2^^m), with 2 <= m <= 16, that\n   can be used to
    protect arbitrary media streams along the lines\n   defined by FECFRAME.  The
    Reed-Solomon codes considered have\n   attractive properties, since they offer
    optimal protection against\n   packet erasures and the source symbols are part
    of the encoding\n   symbols, which can greatly simplify decoding.  However, the
    price to\n   pay is a limit on the maximum source block size, on the maximum\n
    \  number of encoding symbols, and a computational complexity higher\n   than
    that of the Low-Density Parity Check (LDPC) codes, for instance.\n"
  title: Abstract
- contents:
  - "Status of This Memo\n   This is an Internet Standards Track document.\n   This
    document is a product of the Internet Engineering Task Force\n   (IETF).  It represents
    the consensus of the IETF community.  It has\n   received public review and has
    been approved for publication by the\n   Internet Engineering Steering Group (IESG).
    \ Further information on\n   Internet Standards is available in Section 2 of RFC
    5741.\n   Information about the current status of this document, any errata,\n
    \  and how to provide feedback on it may be obtained at\n   http://www.rfc-editor.org/info/rfc6865.\n"
  title: Status of This Memo
- contents:
  - "Copyright Notice\n   Copyright (c) 2013 IETF Trust and the persons identified
    as the\n   document authors.  All rights reserved.\n   This document is subject
    to BCP 78 and the IETF Trust's Legal\n   Provisions Relating to IETF Documents\n
    \  (http://trustee.ietf.org/license-info) in effect on the date of\n   publication
    of this document.  Please review these documents\n   carefully, as they describe
    your rights and restrictions with respect\n   to this document.  Code Components
    extracted from this document must\n   include Simplified BSD License text as described
    in Section 4.e of\n   the Trust Legal Provisions and are provided without warranty
    as\n   described in the Simplified BSD License.\n"
  title: Copyright Notice
- contents:
  - "Table of Contents\n   1.  Introduction . . . . . . . . . . . . . . . . . . .
    . . . . . .  4\n   2.  Terminology  . . . . . . . . . . . . . . . . . . . . .
    . . . .  5\n   3.  Definitions Notations and Abbreviations  . . . . . . . . .
    . .  5\n     3.1.  Definitions  . . . . . . . . . . . . . . . . . . . . . . .
    \ 5\n     3.2.  Notations  . . . . . . . . . . . . . . . . . . . . . . . .  7\n
    \    3.3.  Abbreviations  . . . . . . . . . . . . . . . . . . . . . .  8\n   4.
    \ Common Procedures Related to the ADU Block and Source\n       Block Creation
    . . . . . . . . . . . . . . . . . . . . . . . .  9\n     4.1.  Restrictions .
    . . . . . . . . . . . . . . . . . . . . . .  9\n     4.2.  ADU Block Creation
    . . . . . . . . . . . . . . . . . . . .  9\n     4.3.  Source Block Creation  .
    . . . . . . . . . . . . . . . . . 10\n   5.  Simple Reed-Solomon FEC Scheme over
    GF(2^^m) for Arbitrary\n       ADU Flows  . . . . . . . . . . . . . . . . . .
    . . . . . . . . 12\n     5.1.  Formats and Codes  . . . . . . . . . . . . . .
    . . . . . . 12\n       5.1.1.  FEC Framework Configuration Information  . . .
    . . . . 12\n       5.1.2.  Explicit Source FEC Payload ID . . . . . . . . . .
    . . 14\n       5.1.3.  Repair FEC Payload ID  . . . . . . . . . . . . . . . .
    15\n     5.2.  Procedures . . . . . . . . . . . . . . . . . . . . . . . . 17\n
    \    5.3.  FEC Code Specification . . . . . . . . . . . . . . . . . . 17\n   6.
    \ Security Considerations  . . . . . . . . . . . . . . . . . . . 17\n     6.1.
    \ Attacks Against the Data Flow  . . . . . . . . . . . . . . 17\n       6.1.1.
    \ Access to Confidential Content . . . . . . . . . . . . 17\n       6.1.2.  Content
    Corruption . . . . . . . . . . . . . . . . . . 18\n     6.2.  Attacks Against
    the FEC Parameters . . . . . . . . . . . . 18\n     6.3.  When Several Source
    Flows Are to Be Protected Together . . 19\n     6.4.  Baseline Secure FECFRAME
    Operation . . . . . . . . . . . . 19\n   7.  Operations and Management Considerations
    . . . . . . . . . . . 19\n     7.1.  Operational Recommendations: Finite Field
    Size (m) . . . . 19\n   8.  IANA Considerations  . . . . . . . . . . . . . . .
    . . . . . . 20\n   9.  Acknowledgments  . . . . . . . . . . . . . . . . . . .
    . . . . 20\n   10. References . . . . . . . . . . . . . . . . . . . . . . . .
    . . 21\n     10.1. Normative References . . . . . . . . . . . . . . . . . . .
    21\n     10.2. Informative References . . . . . . . . . . . . . . . . . . 21\n"
  title: Table of Contents
- contents:
  - "1.  Introduction\n   The use of the Forward Error Correction (FEC) codes is a
    classic\n   solution to improve the reliability of unicast, multicast, and\n   broadcast
    Content Delivery Protocols (CDP) and applications.\n   [RFC6363] describes a generic
    framework to use FEC schemes with media\n   delivery applications, and for instance
    with real-time streaming\n   media applications based on the Real-time Transport
    Protocol (RTP).\n   Similarly, [RFC5052] describes a generic framework to use
    FEC schemes\n   with object delivery applications (where the objects are files,
    for\n   example) based on the Asynchronous Layered Coding (ALC) [RFC5775] and\n
    \  NACK-Oriented Reliable Multicast (NORM) [RFC5740] transport\n   protocols.\n
    \  More specifically, the [RFC5053] and [RFC5170] FEC schemes introduce\n   erasure
    codes based on sparse parity-check matrices for object\n   delivery protocols
    like ALC and NORM.  These codes are efficient in\n   terms of processing but not
    optimal in terms of erasure recovery\n   capabilities when dealing with \"small\"
    objects.\n   The Reed-Solomon FEC codes described in this document belong to the\n
    \  class of Maximum Distance Separable (MDS) codes that are optimal in\n   terms
    of erasure recovery capability.  It means that a receiver can\n   recover the
    k source symbols from any set of exactly k encoding\n   symbols.  These codes
    are also systematic codes, which means that the\n   k source symbols are part
    of the encoding symbols.  However, they are\n   limited in terms of maximum source
    block size and number of encoding\n   symbols.  Since the real-time constraints
    of media delivery\n   applications usually limit the maximum source block size,
    this is not\n   considered to be a major issue in the context of FECFRAME for
    many\n   (but not necessarily all) use cases.  Additionally, if the encoding/\n
    \  decoding complexity is higher with Reed-Solomon codes than it is with\n   [RFC5053]
    or [RFC5170] codes, it remains reasonable for most use\n   cases, even in case
    of a software codec.\n   Many applications dealing with reliable content transmission
    or\n   content storage already rely on packet-based Reed-Solomon erasure\n   recovery
    codes.  In particular, many of them use the Reed-Solomon\n   codec of Luigi Rizzo
    [RS-codec] [Rizzo97].  The goal of the present\n   document is to specify a simple
    Reed-Solomon scheme that is\n   compatible with this codec.\n   More specifically,
    [RFC5510] introduced such Reed-Solomon codes and\n   several associated FEC schemes
    that are compatible with the [RFC5052]\n   framework.  The present document inherits
    from Section 8 of\n   [RFC5510], \"Reed-Solomon Codes Specification for the Erasure\n
    \  Channel\", the specifications of the core Reed-Solomon codes based on\n   Vandermonde
    matrices and specifies a simple FEC scheme that is\n   compatible with FECFRAME
    [RFC6363]:\n      The Fully-Specified FEC Scheme with FEC Encoding ID 8 specifies
    a\n      simple way of using of Reed-Solomon codes over GF(2^^m), with\n      2
    <= m <= 16, in order to protect arbitrary Application Data Unit\n      (ADU) flows.\n
    \  Therefore, Sections 4, 5, 6, and 7 of [RFC5510] that define\n   [RFC5052]-specific
    Formats and Procedures are not considered and are\n   replaced by FECFRAME-specific
    Formats and Procedures.\n   For instance, with this scheme, a set of Application
    Data Units\n   (ADUs) coming from one or several media delivery applications (e.g.,\n
    \  a set of RTP packets), are grouped in an ADU block and FEC encoded as\n   a
    whole.  With Reed-Solomon codes over GF(2^^8), there is a strict\n   limit over
    the number of ADUs that can be protected together, since\n   the number of encoded
    symbols, n, must be inferior or equal to 255.\n   This constraint is relaxed when
    using a higher finite field size (m >\n   8), at the price of an increased computational
    complexity.\n"
  title: 1.  Introduction
- contents:
  - "2.  Terminology\n   The key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\",
    \"SHALL NOT\",\n   \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"MAY\", and \"OPTIONAL\"
    in this\n   document are to be interpreted as described in RFC 2119 [RFC2119].\n"
  title: 2.  Terminology
- contents:
  - '3.  Definitions Notations and Abbreviations

    '
  - contents:
    - "3.1.  Definitions\n   This document uses the following terms and definitions.
      \ Some of\n   these terms and definitions are FEC scheme specific and are in
      line\n   with [RFC5052]:\n   Source symbol:  unit of data used during the encoding
      process.  In\n      this specification, there is always one source symbol per
      ADU.\n   Encoding symbol:  unit of data generated by the encoding process.\n
      \     With systematic codes, source symbols are part of the encoding\n      symbols.\n
      \  Repair symbol:  encoding symbol that is not a source symbol.\n   Code rate:
      \ the k/n ratio, i.e., the ratio between the number of\n      source symbols
      and the number of encoding symbols.  By definition,\n      the code rate is
      such that: 0 < code rate <= 1.  A code rate close\n      to 1 indicates that
      a small number of repair symbols have been\n      produced during the encoding
      process.\n   Systematic code:  FEC code in which the source symbols are part
      of\n      the encoding symbols.  The Reed-Solomon codes introduced in this\n
      \     document are systematic.\n   Source Block:  a block of k source symbols
      that are considered\n      together for the encoding.\n   Packet erasure channel:
      \ a communication path where packets are\n      either dropped (e.g., by a congested
      router, or because the number\n      of transmission errors exceeds the correction
      capabilities of the\n      physical layer codes) or received.  When a packet
      is received, it\n      is assumed that this packet is not corrupted.\n   Some
      of these terms and definitions are FECFRAME specific and are in\n   line with
      [RFC6363]:\n   Application Data Unit (ADU):  The unit of source data provided
      as\n      payload to the transport layer.  Depending on the use case, an ADU\n
      \     may use an RTP encapsulation.\n   (Source) ADU Flow:  A sequence of ADUs
      associated with a transport-\n      layer flow identifier (such as the standard
      5-tuple {Source IP\n      address, source port, destination IP address, destination
      port,\n      transport protocol}).  Depending on the use case, several ADU\n
      \     flows may be protected together by FECFRAME.\n   ADU Block:  a set of
      ADUs that are considered together by the\n      FECFRAME instance for the purpose
      of the FEC scheme.  Along with\n      the flow ID (F[]), length (L[]), and padding
      (Pad[]) fields, they\n      form the set of source symbols over which FEC encoding
      will be\n      performed.\n   ADU Information (ADUI):  a unit of data constituted
      by the ADU and\n      the associated Flow ID, Length and Padding fields (Section
      4.3).\n      This is the unit of data that is used as source symbol.\n   FEC
      Framework Configuration Information (FFCI):  Information that\n      controls
      the operation of FECFRAME.  The FFCI enables the\n      synchronization of the
      FECFRAME sender and receiver instances.\n   FEC Source Packet:  At a sender
      (respectively, at a receiver) a\n      payload submitted to (respectively, received
      from) the transport\n      protocol containing an ADU along with an Explicit
      Source FEC\n      Payload ID (that must be present in the FEC scheme defined
      by the\n      present document, see Section 5.1.2).\n   FEC Repair Packet:  At
      a sender (respectively, at a receiver) a\n      payload submitted to (respectively,
      received from) the transport\n      protocol containing one repair symbol along
      with a Repair FEC\n      Payload ID and possibly an RTP header.\n   The above
      terminology is illustrated in Figure 1 (sender's point of\n   view):\n   +----------------------+\n
      \  |     Application      |\n   +----------------------+\n              |\n
      \             | (1) Application Data Units (ADUs)\n              |\n              v\n
      \  +----------------------+                           +----------------+\n   |
      \      FECFRAME       |                           |                |\n   |                      |-------------------------->|
      \  FEC Scheme   |\n   |(2) Construct source  |(3) Source Block           |                |\n
      \  |    blocks            |                           |(4) FEC Encoding|\n   |(6)
      Construct FEC     |<--------------------------|                |\n   |    source
      and repair |                           |                |\n   |    packets           |(5)
      Explicit Source FEC    |                |\n   +----------------------+    Payload
      IDs            +----------------+\n              |                Repair FEC
      Payload IDs\n              |                Repair symbols\n              |\n
      \             |(7) FEC source and repair packets\n              v\n   +----------------------+\n
      \  |   Transport Layer    |\n   |     (e.g., UDP)      |\n   +----------------------+\n
      \          Figure 1: Terminology used in this document (sender).\n"
    title: 3.1.  Definitions
  - contents:
    - "3.2.  Notations\n   This document uses the following notations.  Some of them
      are FEC\n   scheme specific.\n   k      denotes the number of source symbols
      in a source block.\n   max_k  denotes the maximum number of source symbols for
      any source\n          block.\n   n      denotes the number of encoding symbols
      generated for a source\n          block.\n   E      denotes the encoding symbol
      length in bytes.\n   GF(q)  denotes a finite field (also known as the Galois
      Field) with q\n          elements.  We assume that q = 2^^m in this document.\n
      \  m      defines the length of the elements in the finite field, in\n          bits.
      \ In this document, m is such that 2 <= m <= 16.\n   q      defines the number
      of elements in the finite field.  We have:\n          q = 2^^m in this specification.\n
      \  CR     denotes the \"code rate\", i.e., the k/n ratio.\n   a^^b   denotes
      a raised to the power b.\n   Some of them are FECFRAME specific:\n   B      denotes
      the number of ADUs per ADU block.\n   max_B  denotes the maximum number of ADUs
      for any ADU block.\n"
    title: 3.2.  Notations
  - contents:
    - "3.3.  Abbreviations\n   This document uses the following abbreviations:\n   ADU
      \   stands for Application Data Unit.\n   ADUI   stands for Application Data
      Unit Information.\n   ESI    stands for Encoding Symbol ID.\n   FEC    stands
      for Forward Error (or Erasure) Correction code.\n   FFCI   stands for FEC Framework
      Configuration Information.\n   FSSI   stands for FEC Scheme-Specific Information.\n
      \  MDS    stands for Maximum Distance Separable code.\n   SBN    stands for
      Source Block Number.\n   SDP    stands for Session Description Protocol.\n"
    title: 3.3.  Abbreviations
  title: 3.  Definitions Notations and Abbreviations
- contents:
  - "4.  Common Procedures Related to the ADU Block and Source Block Creation\n   This
    section introduces the procedures that are used during the ADU\n   block and the
    related source block creation for the FEC scheme\n   considered.\n"
  - contents:
    - "4.1.  Restrictions\n   This specification has the following restrictions:\n
      \  o  there MUST be exactly one source symbol per ADUI, and therefore\n      per
      ADU;\n   o  there MUST be exactly one repair symbol per FEC Repair Packet;\n
      \  o  there MUST be exactly one source block per ADU block.\n"
    title: 4.1.  Restrictions
  - contents:
    - "4.2.  ADU Block Creation\n   Two kinds of limitations exist that impact the
      ADU block creation:\n   o  at the FEC Scheme level: the finite field size (m
      parameter)\n      directly impacts the maximum source block size and the maximum\n
      \     number of encoding symbols;\n   o  at the FECFRAME instance level: the
      target use case can have real-\n      time constraints that can/will define
      a maximum ADU block size.\n   Note that terms \"maximum source block size\"
      and \"maximum ADU block\n   size\" depend on the point of view that is adopted
      (FEC Scheme versus\n   FECFRAME instance).  However, in this document, both
      refer to the\n   same value since Section 4.1 requires there is exactly one
      source\n   symbol per ADU.  We now detail each of these aspects.\n   The finite
      field size parameter m defines the number of non-zero\n   elements in this field,
      which is equal to: q - 1 = 2^^m - 1.  This q\n   - 1 value is also the theoretical
      maximum number of encoding symbols\n   that can be produced for a source block.
      \ For instance, when m = 8\n   (default) there is a maximum of 2^^8 - 1 = 255
      encoding symbols.  So:\n   k < n <= 255.  Given the target FEC code rate (e.g.,
      provided by the\n   end-user or upper application when starting the FECFRAME
      instance,\n   and taking into account the known or estimated packet loss rate),
      the\n   sender calculates:\n      max_k = floor((2^^m - 1) * CR)\n   This max_k
      value leaves enough room for the sender to produce the\n   desired number of
      repair symbols.  Since there is one source symbol\n   per ADU, max_k is also
      an upper bound to the maximum number of ADUs\n   per ADU block.\n   The source
      ADU flows can have real-time constraints.  When there are\n   multiple flows,
      with different real-time constraints, let us consider\n   the most stringent
      constraints (see [RFC6363], Section 10.2, item 6\n   for recommendations when
      several flows are globally protected).  In\n   that case, the maximum number
      of ADUs of an ADU block must not exceed\n   a certain threshold since it directly
      impacts the decoding delay.\n   The larger the ADU block size, the longer a
      decoder may have to wait\n   until it has received a sufficient number of encoding
      symbols for\n   decoding to succeed, and therefore the larger the decoding delay.\n
      \  When the target use case is known, these real-time constraints result\n   in
      an upper bound to the ADU block size, max_rt.\n   For instance, if the use case
      specifies a maximum decoding latency l,\n   and if each source ADU covers a
      duration d of a continuous media (we\n   assume here the simple case of a constant
      bit-rate ADU flow), then\n   the ADU block size must not exceed:\n      max_rt
      = floor(l / d)\n   After encoding, this block will produce a set of at most
      n = max_rt /\n   CR encoding symbols.  These n encoding symbols will have to
      be sent\n   at a rate of n / l packets per second.  For instance, with d = 10
      ms,\n   l = 1 s, max_rt = 100 ADUs.\n   If we take into account all these constraints,
      we find:\n      max_B = min(max_k, max_rt)\n   This max_B parameter is an upper
      bound to the number of ADUs that can\n   constitute an ADU block.\n"
    title: 4.2.  ADU Block Creation
  - contents:
    - "4.3.  Source Block Creation\n   In their most general form, FECFRAME and the
      Reed-Solomon FEC scheme\n   are meant to protect a set of independent flows.
      \ Since the flows\n   have no relationship to one another, the ADU size of each
      flow can\n   potentially vary significantly.  Even in the special case of a
      single\n   flow, the ADU sizes can largely vary (e.g., the various frames of
      a\n   \"Group of Pictures\" (GOP) of an H.264 flow will have different\n   sizes).
      \ This diversity must be addressed since the Reed-Solomon FEC\n   scheme requires
      a constant encoding symbol size (E parameter) per\n   source block.  Since this
      specification requires that there is only\n   one source symbol per ADU, E must
      be large enough to contain all the\n   ADUs of an ADU block along with their
      prepended 3 bytes (see below).\n   In situations where E is determined per source
      block (default,\n   specified by the FFCI/FSSI with S = 0, Section 5.1.1.2),
      E is equal\n   to the size of the largest ADU of this source block plus 3 (for
      the\n   prepended 3 bytes; see below).  In this case, upon receiving the\n   first
      FEC Repair Packet for this source block, since this packet MUST\n   contain
      a single repair symbol (Section 5.1.3), a receiver determines\n   the E parameter
      used for this source block.\n   In situations where E is fixed (specified by
      the FFCI/FSSI with\n   S = 1, Section 5.1.1.2), then E must be greater or equal
      to the size\n   of the largest ADU of this source block plus 3 (for the prepended
      3\n   bytes; see below).  If this is not the case, an error is returned.\n   How
      to handle this error is use-case specific (e.g., a larger E\n   parameter may
      be communicated to the receivers in an updated FFCI\n   message using an appropriate
      mechanism) and is not considered by this\n   specification.\n   The ADU block
      is always encoded as a single source block.  There are\n   a total of B <= max_B
      ADUs in this ADU block.  For the ADU i, with\n   0 <= i <= B-1, 3 bytes are
      prepended (Figure 2):\n   o  The first byte, F[i] (Flow ID), contains the integer
      identifier\n      associated to the source ADU flow to which this ADU belongs
      to.\n      It is assumed that a single byte is sufficient, or said\n      differently,
      that no more than 256 flows will be protected by a\n      single instance of
      FECFRAME.\n   o  The following 2 bytes, L[i] (Length), contain the length of
      this\n      ADU, in network byte order (i.e., big endian).  This length is for\n
      \     the ADU itself and does not include the F[i], L[i], or Pad[i]\n      fields.\n
      \  Then zero padding is added to ADU i (if needed), in field Pad[i], for\n   alignment
      purposes up to a size of exactly E bytes.  The data unit\n   resulting from
      the ADU i and the F[i], L[i], and Pad[i] fields, is\n   called ADU Information
      (or ADUI).  Each ADUI contributes to exactly\n   one source symbol of the source
      block.\n                        Encoding Symbol Length (E)\n   < -----------------------------------------------------------------
      >\n   +----+--------+-----------------------+-----------------------------+\n
      \  |F[0]|  L[0]  |        ADU[0]         |            Pad[0]           |\n   +----+--------+----------+------------+-----------------------------+\n
      \  |F[1]|  L[1]  | ADU[1]   |                         Pad[1]           |\n   +----+--------+----------+------------------------------------------+\n
      \  |F[2]|  L[2]  |                    ADU[2]                           |\n   +----+--------+------+----------------------------------------------+\n
      \  |F[3]|  L[3]  |ADU[3]|                             Pad[3]           |\n   +----+--------+------+----------------------------------------------+\n
      \  \\_________________________________  ________________________________/\n
      \                                    \\/\n                            simple
      FEC encoding\n   +-------------------------------------------------------------------+\n
      \  |                              Repair 4                             |\n   +-------------------------------------------------------------------+\n
      \  .                                                                   .\n   .
      \                                                                  .\n   +-------------------------------------------------------------------+\n
      \  |                              Repair 7                             |\n   +-------------------------------------------------------------------+\n
      \   Figure 2: Source block creation, for code rate 1/2 (equal number of\n         source
      and repair symbols; 4 in this example), and S = 0.\n   Note that neither the
      initial 3 bytes nor the optional padding are\n   sent over the network.  However,
      they are considered during FEC\n   encoding.  It means that a receiver who lost
      a certain FEC source\n   packet (e.g., the UDP datagram containing this FEC
      source packet)\n   will be able to recover the ADUI if FEC decoding succeeds.
      \ Thanks to\n   the initial 3 bytes, this receiver will get rid of the padding
      (if\n   any) and identify the corresponding ADU flow.\n"
    title: 4.3.  Source Block Creation
  title: 4.  Common Procedures Related to the ADU Block and Source Block Creation
- contents:
  - "5.  Simple Reed-Solomon FEC Scheme over GF(2^^m) for Arbitrary ADU Flows\n   This
    Fully-Specified FEC Scheme specifies the use of Reed-Solomon\n   codes over GF(2^^m),
    with 2 <= m <= 16, with a simple FEC encoding\n   for arbitrary packet flows.\n"
  - contents:
    - '5.1.  Formats and Codes

      '
    - contents:
      - "5.1.1.  FEC Framework Configuration Information\n   The FEC Framework Configuration
        Information (or FFCI) includes\n   information that must be communicated between
        the sender and\n   receiver(s) [RFC6363].  More specifically, it enables the\n
        \  synchronization of the FECFRAME sender and receiver instances.  It\n   includes
        both mandatory elements and scheme-specific elements, as\n   detailed below.\n"
      - contents:
        - "5.1.1.1.  Mandatory Information\n   o  FEC Encoding ID: the value assigned
          to this Fully-Specified FEC\n      scheme MUST be 8, as assigned by IANA
          (Section 8).\n   When SDP is used to communicate the FFCI, this FEC Encoding
          ID MUST\n   be carried in the 'encoding-id' parameter of the 'fec-repair-flow'\n
          \  attribute specified in RFC 6364 [RFC6364].\n"
        title: 5.1.1.1.  Mandatory Information
      - contents:
        - "5.1.1.2.  FEC Scheme-Specific Information\n   The FEC Scheme-Specific Information
          (FSSI) includes elements that are\n   specific to the present FEC scheme.
          \ More precisely:\n   o  Encoding Symbol Length (E): a non-negative integer,
          inferior to\n      2^^16, that indicates either the length of each encoding
          symbol in\n      bytes (\"strict\" mode, i.e., if S = 1), or the maximum
          length of\n      any encoding symbol (i.e., if S = 0).\n   o  Strict (S)
          flag: when set to 1, this flag indicates that the E\n      parameter is
          the actual encoding symbol length value for each\n      block of the session
          (unless otherwise notified by an updated FFCI\n      if this possibility
          is considered by the use case or CDP).  When\n      set to 0, this flag
          indicates that the E parameter is the maximum\n      encoding symbol length
          value for each block of the session (unless\n      otherwise notified by
          an updated FFCI if this possibility is\n      considered by the use case
          or CDP).\n   o  m parameter (m): an integer that defines the length of the\n
          \     elements in the finite field, in bits.  We have: 2 <= m <= 16.\n   These
          elements are required both by the sender (Reed-Solomon encoder)\n   and
          the receiver(s) (Reed-Solomon decoder).\n   When SDP is used to communicate
          the FFCI, this FEC scheme-specific\n   information MUST be carried in the
          'fssi' parameter of the\n   'fec-repair-flow' attribute, in textual representation
          as specified\n   in RFC 6364 [RFC6364].  For instance:\n   a=fec-repair-flow:
          encoding-id=8; fssi=E:1400,S:0,m:8\n   If another mechanism requires the
          FSSI to be carried as an opaque\n   octet string (for instance after a Base64
          encoding), the encoding\n   format consists of the following 3 octets of
          Figure 3:\n   o  Encoding symbol length (E): 16-bit field.\n   o  Strict
          (S) flag: 1-bit field.\n   o  m parameter (m): 7-bit field.\n    0                   1
          \                  2\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2
          3\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n   |   Encoding
          Symbol Length (E)  |S|     m       |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
          \                     Figure 3: FSSI encoding format.\n"
        title: 5.1.1.2.  FEC Scheme-Specific Information
      title: 5.1.1.  FEC Framework Configuration Information
    - contents:
      - "5.1.2.  Explicit Source FEC Payload ID\n   A FEC source packet MUST contain
        an Explicit Source FEC Payload ID\n   that is appended to the end of the packet
        as illustrated in Figure 4.\n   +--------------------------------+\n   |           IP
        Header            |\n   +--------------------------------+\n   |        Transport
        Header        |\n   +--------------------------------+\n   |              ADU
        \              |\n   +--------------------------------+\n   | Explicit Source
        FEC Payload ID |\n   +--------------------------------+\n    Figure 4: Structure
        of a FEC Source Packet with the Explicit Source\n                              FEC
        Payload ID.\n   More precisely, the Explicit Source FEC Payload ID is composed
        of the\n   Source Block Number, the Encoding Symbol ID, and the Source Block\n
        \  Length.  The length of the first 2 fields depends on the m parameter\n
        \  (transmitted separately in the FFCI, Section 5.1.1.2):\n   o  Source Block
        Number (SBN) ((32-m)-bit field): this field\n      identifies the source block
        to which this FEC source packet\n      belongs.\n   o  Encoding Symbol ID
        (ESI) (m-bit field): this field identifies the\n      source symbol contained
        in this FEC source packet.  This value is\n      such that 0 <= ESI <= k -
        1 for source symbols.\n   o  Source Block Length (k) (16-bit field): this
        field provides the\n      number of source symbols for this source block,
        i.e., the k\n      parameter.  If 16 bits are too much when m <= 8, it is
        needed when\n      8 < m <= 16.  Therefore, we provide a single common format\n
        \     regardless of m.\n    0                   1                   2                   3\n
        \   0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |           Source Block Number (24 bits)       | Enc. Symb. ID |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |    Source Block Length (k)    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Figure 5: Source FEC Payload ID encoding format for m = 8 (default).\n
        \   0                   1                   2                   3\n    0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |   Source Block Nb (16 bits)   |   Enc. Symbol ID (16 bits)    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |    Source Block Length (k)    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \       Figure 6: Source FEC Payload ID encoding format for m = 16.\n   The
        format of the Source FEC Payload ID for m = 8 and m = 16 are\n   illustrated
        in Figures 5 and 6, respectively.\n"
      title: 5.1.2.  Explicit Source FEC Payload ID
    - contents:
      - "5.1.3.  Repair FEC Payload ID\n   A FEC repair packet MUST contain a Repair
        FEC Payload ID that is\n   prepended to the repair symbol(s) as illustrated
        in Figure 7.  There\n   MUST be a single repair symbol per FEC repair packet.\n
        \  +--------------------------------+\n   |           IP Header            |\n
        \  +--------------------------------+\n   |        Transport Header        |\n
        \  +--------------------------------+\n   |      Repair FEC Payload ID     |\n
        \  +--------------------------------+\n   |         Repair Symbol          |\n
        \  +--------------------------------+\n      Figure 7: Structure of a FEC
        Repair Packet with the Repair FEC\n                                Payload
        ID.\n   More precisely, the Repair FEC Payload ID is composed of the Source\n
        \  Block Number, the Encoding Symbol ID, and the Source Block Length.\n   The
        length of the first 2 fields depends on the m parameter\n   (transmitted separately
        in the FFCI, Section 5.1.1.2):\n   o  Source Block Number (SBN) ((32-m)-bit
        field): this field\n      identifies the source block to which the FEC repair
        packet\n      belongs.\n   o  Encoding Symbol ID (ESI) (m-bit field): this
        field identifies the\n      repair symbol contained in this FEC repair packet.
        \ This value is\n      such that k <= ESI <= n - 1 for repair symbols.\n   o
        \ Source Block Length (k) (16-bit field): this field provides the\n      number
        of source symbols for this source block, i.e., the k\n      parameter.  If
        16 bits are too much when m <= 8, it is needed when\n      8 < m <= 16.  Therefore,
        we provide a single common format\n      regardless of m.\n    0                   1
        \                  2                   3\n    0 1 2 3 4 5 6 7 8 9 0 1 2 3
        4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |           Source Block Number (24 bits)       | Enc. Symb. ID |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |    Source Block Length (k)    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  Figure 8: Repair FEC Payload ID encoding format for m = 8 (default).\n
        \   0                   1                   2                   3\n    0 1
        2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |   Source Block Nb (16 bits)   |   Enc. Symbol ID (16 bits)    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \  |    Source Block Length (k)    |\n   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n
        \       Figure 9: Repair FEC Payload ID encoding format for m = 16.\n   The
        format of the Repair FEC Payload ID for m = 8 and m = 16 are\n   illustrated
        in Figures 8 and 9, respectively.\n"
      title: 5.1.3.  Repair FEC Payload ID
    title: 5.1.  Formats and Codes
  - contents:
    - "5.2.  Procedures\n   The following procedures apply:\n   o  The source block
      creation MUST follow the procedures specified in\n      Section 4.3.\n   o  The
      SBN value MUST start with value 0 for the first block of the\n      ADU flow
      and MUST be incremented by 1 for each new source block.\n      Wrapping to zero
      will happen for long sessions, after value\n      2^^(32-m) - 1.\n   o  The
      ESI of encoding symbols MUST start with value 0 for the first\n      symbol
      and MUST be managed sequentially.  The first k values\n      (0 <= ESI <= k
      - 1) identify source symbols, whereas the last n-k\n      values (k <= ESI <=
      n - 1) identify repair symbols.\n   o  The FEC repair packet creation MUST follow
      the procedures\n      specified in Section 5.1.3.\n"
    title: 5.2.  Procedures
  - contents:
    - "5.3.  FEC Code Specification\n   The present document inherits from Section
      8 of [RFC5510], \"Reed-\n   Solomon Codes Specification for the Erasure Channel\",
      the\n   specifications of the core Reed-Solomon codes based on Vandermonde\n
      \  matrices.\n"
    title: 5.3.  FEC Code Specification
  title: 5.  Simple Reed-Solomon FEC Scheme over GF(2^^m) for Arbitrary ADU Flows
- contents:
  - "6.  Security Considerations\n   The FECFRAME document [RFC6363] provides a comprehensive
    analysis of\n   security considerations applicable to FEC schemes.  Therefore,
    the\n   present section follows the security considerations section of\n   [RFC6363]
    and only discusses topics that are specific to the use of\n   Reed-Solomon codes.\n"
  - contents:
    - '6.1.  Attacks Against the Data Flow

      '
    - contents:
      - "6.1.1.  Access to Confidential Content\n   The Reed-Solomon FEC Scheme specified
        in this document does not\n   change the recommendations of [RFC6363].  To
        summarize, if\n   confidentiality is a concern, it is RECOMMENDED that one
        of the\n   solutions mentioned in [RFC6363] is used with special considerations\n
        \  to the way this solution is applied (e.g., is encryption applied\n   before
        or after FEC protection, within the end-system or in a\n   middlebox) to the
        operational constraints (e.g., performing FEC\n   decoding in a protected
        environment may be complicated or even\n   impossible) and to the threat model.\n"
      title: 6.1.1.  Access to Confidential Content
    - contents:
      - "6.1.2.  Content Corruption\n   The Reed-Solomon FEC Scheme specified in this
        document does not\n   change the recommendations of [RFC6363].  To summarize,
        it is\n   RECOMMENDED that one of the solutions mentioned in [RFC6363] is
        used\n   on both the FEC Source and Repair Packets.\n"
      title: 6.1.2.  Content Corruption
    title: 6.1.  Attacks Against the Data Flow
  - contents:
    - "6.2.  Attacks Against the FEC Parameters\n   The FEC Scheme specified in this
      document defines parameters that can\n   be the basis of several attacks.  More
      specifically, the following\n   parameters of the FFCI may be modified by an
      attacker\n   (Section 5.1.1.2):\n   o  FEC Encoding ID: changing this parameter
      leads the receiver to\n      consider a different FEC Scheme, which enables
      an attacker to\n      create a Denial of Service (DoS).\n   o  Encoding symbol
      length (E): setting this E parameter to a value\n      smaller than the valid
      one enables an attacker to create a DoS\n      since the repair symbols and
      certain source symbols will be larger\n      than E, which is an incoherency
      for the receiver.  Setting this E\n      parameter to a value larger than the
      valid one has similar impacts\n      when S = 1 since the received repair symbol
      size will be smaller\n      than expected.  On the opposite, it will not lead
      to any\n      incoherency when S = 0 since the actual symbol length value for\n
      \     the block is determined by the size of any received repair symbol,\n      as
      long as this value is smaller than E. However, setting this E\n      parameter
      to a larger value may have impacts on receivers that\n      pre-allocate memory
      space in advance to store incoming symbols.\n   o  Strict (S) flag: flipping
      this S flag from 0 to 1 (i.e., E is now\n      considered as a strict value)
      enables an attacker to mislead the\n      receiver if the actual symbol size
      varies over different source\n      blocks.  Flipping this S flag from 1 to
      0 has no major\n      consequences unless the receiver requires to have a fixed
      E value\n      (e.g., because the receiver pre-allocates memory space).\n   o
      \ m parameter: changing this parameter triggers a DoS since the\n      receiver
      and sender will consider different codes, and the\n      receiver will interpret
      the Explicit Source FEC Payload ID and\n      Repair FEC Payload ID differently.
      \ Additionally, by increasing\n      this m parameter to a larger value (typically
      m = 16 rather than\n      8, when both values are possible in the target use
      case) will\n      create additional processing load at a receiver if decoding
      is\n      attempted.\n   It is therefore RECOMMENDED that security measures
      are taken to\n   guarantee the FFCI integrity, as specified in [RFC6363].  How
      to\n   achieve this depends on the way the FFCI is communicated from the\n   sender
      to the receiver, which is not specified in this document.\n   Similarly, attacks
      are possible against the Explicit Source FEC\n   Payload ID and Repair FEC Payload
      ID: by modifying the Source Block\n   Number (SBN), or the Encoding Symbol ID
      (ESI), or the Source Block\n   Length (k), an attacker can easily corrupt the
      block identified by\n   the SBN.  Other consequences, that are use case and/or
      CDP dependent,\n   may also happen.  It is therefore RECOMMENDED that security
      measures\n   are taken to guarantee the FEC Source and Repair Packets as stated
      in\n   [RFC6363].\n"
    title: 6.2.  Attacks Against the FEC Parameters
  - contents:
    - "6.3.  When Several Source Flows Are to Be Protected Together\n   The Reed-Solomon
      FEC Scheme specified in this document does not\n   change the recommendations
      of [RFC6363].\n"
    title: 6.3.  When Several Source Flows Are to Be Protected Together
  - contents:
    - "6.4.  Baseline Secure FECFRAME Operation\n   The Reed-Solomon FEC Scheme specified
      in this document does not\n   change the recommendations of [RFC6363] concerning
      the use of the\n   IPsec/ESP security protocol as a mandatory to implement (but
      not\n   mandatory to use) security scheme.  This is well suited to situations\n
      \  where the only insecure domain is the one over which FECFRAME\n   operates.\n"
    title: 6.4.  Baseline Secure FECFRAME Operation
  title: 6.  Security Considerations
- contents:
  - "7.  Operations and Management Considerations\n   The FECFRAME document [RFC6363]
    provides a comprehensive analysis of\n   operations and management considerations
    applicable to FEC schemes.\n   Therefore, the present section only discusses topics
    that are\n   specific to the use of Reed-Solomon codes as specified in this\n
    \  document.\n"
  - contents:
    - "7.1.  Operational Recommendations: Finite Field Size (m)\n   The present document
      requires that m, the length of the elements in\n   the finite field in bits,
      is such that 2 <= m <= 16.  However, all\n   possibilities are not equally interesting
      from a practical point of\n   view.  It is expected that m = 8, the default
      value, will be mostly\n   used since it offers the possibility to have small
      to medium sized\n   source blocks and/or a significant number of repair symbols
      (i.e., k\n   < n <= 255).  Additionally, elements in the finite field are 8
      bits\n   long, which makes read/write memory operations aligned on bytes\n   during
      encoding and decoding.\n   An alternative when it is known that only very small
      source blocks\n   will be used is m = 4 (i.e., k < n <= 15).  Elements in the
      finite\n   field are 4 bits long, so if 2 elements are accessed at a time, read/\n
      \  write memory operations are aligned on bytes during encoding and\n   decoding.\n
      \  An alternative when very large source blocks are needed is m = 16\n   (i.e.,
      k < n<= 65535).  However, this choice has significant impact\n   on the processing
      load.  For instance, using pre-calculated tables to\n   speed up operations
      over the finite field (as done with smaller\n   finite fields) may require a
      prohibitive amount of memory to be used\n   on embedded platforms.  Alternative
      lightweight solutions (e.g., LDPC\n   FEC [RFC5170]) may be preferred in situations
      where the processing\n   load is an issue and the source block length is large
      enough\n   [Matsuzono10].\n   Since several values for the m parameter are possible,
      the use case\n   SHOULD define which value or values need to be supported.  In\n
      \  situations where this is not specified, the default m = 8 value MUST\n   be
      used.\n   In any case, any compliant implementation MUST support at least the\n
      \  default m = 8 value.\n"
    title: '7.1.  Operational Recommendations: Finite Field Size (m)'
  title: 7.  Operations and Management Considerations
- contents:
  - "8.  IANA Considerations\n   Values of FEC Encoding IDs are subject to IANA registration.\n
    \  [RFC6363] defines general guidelines on IANA considerations.  In\n   particular,
    it defines the \"FEC Framework (FECFRAME) FEC Encoding\n   IDs\" subregistry of
    the \"Reliable Multicast Transport (RMT) FEC\n   Encoding IDs and FEC Instance
    IDs\" registry, whose registration\n   procedure is IETF Review.\n   This document
    registers one value in the \"FEC Framework (FECFRAME)\n   FEC Encoding IDs\" subregistry
    as follows:\n      8 refers to the Simple Reed-Solomon [RFC5510] FEC Scheme over\n
    \     GF(2^^m) for Arbitrary Packet Flows.\n"
  title: 8.  IANA Considerations
- contents:
  - "9.  Acknowledgments\n   The authors want to thank Hitoshi Asaeda and Ali Begen
    for their\n   valuable comments.\n"
  title: 9.  Acknowledgments
- contents:
  - '10.  References

    '
  - contents:
    - "10.1.  Normative References\n   [RFC2119]      Bradner, S., \"Key words for
      use in RFCs to Indicate\n                  Requirement Levels\", BCP 14, RFC
      2119, March 1997.\n   [RFC5052]      Watson, M., Luby, M., and L. Vicisano,
      \"Forward Error\n                  Correction (FEC) Building Block\", RFC 5052,\n
      \                 August 2007.\n   [RFC5510]      Lacan, J., Roca, V., Peltotalo,
      J., and S. Peltotalo,\n                  \"Reed-Solomon Forward Error Correction
      (FEC) Schemes\",\n                  RFC 5510, April 2009.\n   [RFC6363]      Watson,
      M., Begen, A., and V. Roca, \"Forward Error\n                  Correction (FEC)
      Framework\", RFC 6363, October 2011.\n   [RFC6364]      Begen, A., \"Session
      Description Protocol Elements for\n                  the Forward Error Correction
      (FEC) Framework\",\n                  RFC 6364, October 2011.\n"
    title: 10.1.  Normative References
  - contents:
    - "10.2.  Informative References\n   [Matsuzono10]  Matsuzono, K., Detchart, J.,
      Cunche, M., Roca, V., and\n                  H. Asaeda, \"Performance Analysis
      of a High-Performance\n                  Real-Time Application with Several
      AL-FEC Schemes\",\n                  35th Annual IEEE Conference on Local Computer\n
      \                 Networks (LCN 2010), October 2010.\n   [RFC5053]      Luby,
      M., Shokrollahi, A., Watson, M., and T.\n                  Stockhammer, \"Raptor
      Forward Error Correction Scheme\n                  for Object Delivery\", RFC
      5053, October 2007.\n   [RFC5170]      Roca, V., Neumann, C., and D. Furodet,
      \"Low Density\n                  Parity Check (LDPC) Staircase and Triangle
      Forward\n                  Error Correction (FEC) Schemes\", RFC 5170, June
      2008.\n   [RFC5740]      Adamson, B., Bormann, C., Handley, M., and J. Macker,\n
      \                 \"NACK-Oriented Reliable Multicast (NORM) Transport\n                  Protocol\",
      RFC 5740, November 2009.\n   [RFC5775]      Luby, M., Watson, M., and L. Vicisano,
      \"Asynchronous\n                  Layered Coding (ALC) Protocol Instantiation\",\n
      \                 RFC 5775, April 2010.\n   [Rizzo97]      Rizzo, L., \"Effective
      Erasure Codes for Reliable\n                  Computer Communication Protocols\",
      ACM SIGCOMM\n                  Computer Communication Review, Vol.27, No.2,
      pp.24-36,\n                  April 1997.\n   [RS-codec]     Rizzo, L., \"Reed-Solomon
      FEC codec (C language)\",\n                  original codec: http://info.iet.unipi.it/~luigi/vdm98/\n
      \                 vdm980702.tgz, improved codec: http://openfec.org/,\n                  July
      1998.\n"
    title: 10.2.  Informative References
  title: 10.  References
- contents:
  - "Authors' Addresses\n   Vincent Roca\n   INRIA\n   655, av. de l'Europe\n   Inovallee;
    Montbonnot\n   ST ISMIER cedex  38334\n   France\n   EMail: vincent.roca@inria.fr\n
    \  URI:   http://planete.inrialpes.fr/people/roca/\n   Mathieu Cunche\n   INSA-Lyon/INRIA\n
    \  Laboratoire CITI\n   6 av. des Arts\n   Villeurbanne cedex  69621\n   France\n
    \  EMail: mathieu.cunche@inria.fr\n   URI:   http://mathieu.cunche.free.fr/\n
    \  Jerome Lacan\n   ISAE, Univ. of Toulouse\n   10 av. Edouard Belin; BP 54032\n
    \  Toulouse cedex 4  31055\n   France\n   EMail: jerome.lacan@isae.fr\n   URI:
    \  http://personnel.isae.fr/jerome-lacan/\n   Amine Bouabdallah\n   CDTA\n   Center
    for Development of Advanced Technologies\n   Cite 20 aout 1956, Baba Hassen\n
    \  Algiers\n   Algeria\n   EMail: abouabdallah@cdta.dz\n   Kazuhisa Matsuzono\n
    \  Keio University\n   Graduate School of Media and Governance\n   5322 Endo\n
    \  Fujisawa, Kanagawa  252-8520\n   Japan\n   EMail: kazuhisa@sfc.wide.ad.jp\n"
  title: Authors' Addresses
